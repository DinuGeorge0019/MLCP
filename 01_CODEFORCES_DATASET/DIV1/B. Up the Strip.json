{
    "link": "https://codeforces.com//contest/1558/problem/B",
    "problemId": "1088950",
    "problem_idx": "B",
    "shortId": "1558B",
    "contest_number": "1558",
    "problem_submissions": {
        "F": [
            126899482,
            126888055,
            126902100,
            126890640,
            126888389,
            126894123,
            126904590,
            126900041,
            126902212,
            126902942,
            127549735,
            127006693
        ],
        "E": [
            126883583,
            126896785,
            126884151,
            126898148,
            126905418,
            126902611,
            126899238,
            126907028,
            126907352,
            126891363,
            126891974,
            126891356,
            126892061,
            126902546,
            126900088,
            126903655,
            126904227,
            126900317,
            126902700
        ],
        "D": [
            126869704,
            126870708,
            126871179,
            126874038,
            126874151,
            126876731,
            126871810,
            126867588,
            126872511,
            126871952,
            126882884,
            126882215,
            126882465,
            126878861,
            126876122,
            126890668,
            126874784,
            126883630,
            126892178,
            126890480
        ],
        "B": [
            126858181,
            126855670,
            126854102,
            126855872,
            126858058,
            126860085,
            126854841,
            126852806,
            126853901,
            126856718,
            126855353,
            126856232,
            126858032,
            126857658,
            126854131,
            126863721,
            126854756,
            126864821,
            126867061,
            126863501
        ],
        "A": [
            126854362,
            126850555,
            126848635,
            126848815,
            126849088,
            126855964,
            126848126,
            126847884,
            126848457,
            126849581,
            126847772,
            126849333,
            126852232,
            126849014,
            126848809,
            126853376,
            126847687,
            126859049,
            126849750,
            126850402
        ],
        "C": [
            126850882,
            126858888,
            126859482,
            126861350,
            126866099,
            126867225,
            126859442,
            126858664,
            126862495,
            126861859,
            126865577,
            126860578,
            126863128,
            126865366,
            126858535,
            126873768,
            126863562,
            126873408,
            126874458,
            126871983
        ]
    },
    "name": "B. Up the Strip",
    "statement": "You have a vertical strip with n cells, numbered consecutively from 1 to\r\nn from top to bottom.You also have a token that is initially placed in\r\ncell n. You will move the token up until it arrives at cell 1.Let the\r\ntoken be in cell x > 1 at some moment. One shift of the token can have\r\neither of the following kinds: Subtraction: you choose an integer y\r\nbetween 1 and x-1, inclusive, and move the token from cell x to cell x -\r\ny. Floored division: you choose an integer z between 2 and x, inclusive,\r\nand move the token from cell x to cell\r\nlfloor\r\nfrac{x}{z}\r\nrfloor (x divided by z rounded down). Find the number of ways to move\r\nthe token from cell n to cell 1 using one or more shifts, and print it\r\nmodulo m. Note that if there are several ways to move the token from one\r\ncell to another in one shift, all these ways are considered (check\r\nexample explanation for a better understanding).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint MOD;\n\nstruct modnum {\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint n;\n\tcin >> n >> MOD;\n\tvector<num> dp(n+1, 0);\n\tvector<num> diff(n+1, 0);\n\tdiff[1] += 1;\n\tdiff[2] -= 1;\n\tnum cur = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tcur += diff[i];\n\t\tdp[i] = cur;\n\t\tif(i+1 <= n) diff[i+1] += cur;\n\t\tfor(int j = i; j <= n; j += i){\n\t\t\tint r = max(j, i+1);\n\t\t\tint s = max(r, j+j/i);\n\t\t\tif(r <= n) diff[r] += cur;\n\t\t\tif(s <= n) diff[s] -= cur;\n\t\t}\n\t}\n\tcout << dp[n] << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "math",
        "number theory",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Up the Strip.json",
    "editorial_link": "https://codeforces.com//blog/entry/94216",
    "editorial": "This problem was inspired by Blogewoosh 4 a long time ago ().Pretty\r\nclearly, we are facing a dynamic programming problem. Let be the number\r\nof ways to move from cell to cell . Then, , , and is the answer to the\r\nproblem. However, a straightforward implementation has time complexity\r\nand is too slow.Letâs look at the main formula for again: .The first\r\nsum, , is easy to optimize: just maintain the sum of and recalculate it\r\nby adding . This takes just time per cell.For the second sum, , note\r\nthat can take at most different values over . We can handle this sum as\r\nfollows: Find the sum over all directly. We only need to consider now.\r\nFor any such value, . Letâs loop over a cell , for how many different\r\nvalues of itâs true that ? By definition of the floor function, .\r\nSolving this inequality, we get . The length of this segment gives us\r\nthe coefficient of in the sum. This gives us an solution which is enough\r\nfor the subtask in Division 2.To get a faster solution, let denote the\r\nmultiset of cells where we can go to from cell (this multiset contains\r\nvalues). How is different from ? contains an extra occurrence of because\r\nwe can subtract from . contains an extra occurrence of because we can\r\ndivide by . For each that is a divisor of , contains an occurrence of\r\nthat replaces an occurrence of . We donât need to maintain itself, but\r\nwe can maintain the sum of over all and recalculate this sum as we go\r\nfrom to . The total number of changes to is limited by the total number\r\nof divisors of all numbers from to , that is, .However, if implemented\r\ndirectly, we need to quickly find the divisors of each , and we can only\r\nafford memory due to the memory limit. We can achieve that by preparing\r\na sieve of Eratosthenes, factorizing and generating all its divisors.A\r\nbetter way is do it the reverse way: once we find for some , letâs\r\ntraverse and add to . This way the time complexity stays and the memory\r\ncomplexity is .\r\n",
    "hint": []
}