{"link": "https://codeforces.com//contest/1320/problem/D", "problemId": "551758", "problem_idx": "D", "shortId": "1320D", "contest_number": "1320", "problem_submissions": {"F": [72202332, 72223011, 72205107, 72198337, 72222998, 72196293, 72223902], "E": [72193224, 72190175, 72191679, 72192473, 72195171, 89517976, 72207354, 72207256, 72196434, 72194256, 72192283, 72199164, 72195289, 72197732, 72223673, 72193338, 72195901, 72200544, 72200353, 72200814, 72198992, 72200456], "C": [72184867, 72177670, 72177948, 72173628, 72175737, 72172966, 72176352, 72179230, 72175568, 72177066, 72173843, 72175840, 72176052, 72179445, 72190361, 72188981, 72179839, 72183510, 72186001, 72181401], "B": [72179476, 72169823, 72171581, 72177394, 72169041, 72168596, 72168669, 72172513, 72171074, 72169530, 72169385, 72171115, 72178856, 72172293, 72186108, 72169156, 72173456, 72185954, 72172093, 72178248], "D": [72176425, 72181800, 72183448, 72260282, 72184393, 72182092, 72185033, 72188594, 72279361, 72184633, 72186338, 72185288, 72188013, 72184398, 72189053, 72517140, 72199444, 72180732, 72186150, 72193094, 72172140, 72191769, 72190479], "A": [72166896, 72166972, 72167131, 72166858, 72166891, 72166853, 72166967, 72167271, 72166947, 72166915, 72167040, 72167216, 72167056, 72167066, 72166886, 72170109, 72167510, 72181754, 72167043, 72167049]}, "name": "D. Reachable Strings", "statement": "In this problem, we will deal with binary strings. Each character of a\r\nbinary string is either a or a . We will also deal with substrings;\r\nrecall that a substring is a contiguous subsequence of a string. We\r\ndenote the substring of string s starting from the l-th character and\r\nending with the r-th character as s[l\r\ndots r]. The characters of each string are numbered from 1.We can\r\nperform several operations on the strings we consider. Each operation is\r\nto choose a substring of our string and replace it with another string.\r\nThere are two possible types of operations: replace with , or replace\r\nwith . For example, if we apply exactly one operation to the string , it\r\ncan be transformed into , , or .Binary string a is considered from\r\nbinary string b if there exists a sequence s_1, s_2, ..., s_k such that\r\ns_1 = a, s_k = b, and for every i\r\nin [1, k - 1], s_i can be transformed into s_{i + 1} using exactly one\r\noperation. Note that k can be equal to 1, i. e., .You are given a string\r\nt and q queries to it. Each query consists of three integers l_1, l_2\r\nand len. To answer each query, you have to determine whether t[l_1\r\ndots l_1 + len - 1] is reachable from t[l_2\r\ndots l_2 + len - 1].\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\n\nnum A;\nnum B;\nnum C;\n\nint n;\nstring s;\n\nstruct info {\n\tint lc, rc;\n\tnum x, y;\n};\n\ninfo combine(info a, info b){\n\tif(a.lc == -1 && b.lc == -1){\n\t\treturn {-1, a.rc ^ b.rc, 0, 0};\n\t} else if(a.lc == -1){\n\t\treturn {a.rc ^ b.lc, b.rc, b.x, b.y};\n\t} else if(b.lc == -1){\n\t\treturn {a.lc, a.rc ^ b.rc, a.x, a.y};\n\t} else {\n\t\treturn {a.lc, b.rc, a.x + a.y * (((a.rc ^ b.lc) ? B : C) + A * b.x), a.y * b.y * A};\n\t}\n}\n\nstruct node {\n\tnode *l, *r;\n\tinfo a;\n};\n\nnode* build(int lx, int rx){\n\tnode* x = new node();\n\tif(lx == rx){\n\t\tx->l = x->r = nullptr;\n\t\tif(s[lx] == '0'){\n\t\t\tx->a = {0, 0, 0, 1};\n\t\t} else {\n\t\t\tx->a = {-1, 1, 0, 0};\n\t\t}\n\t} else {\n\t\tx->l = build(lx, (lx + rx) / 2);\n\t\tx->r = build((lx + rx) / 2 + 1, rx);\n\t\tx->a = combine(x->l->a, x->r->a);\n\t}\n\treturn x;\n}\n\ninfo query(node* v, int lx, int rx, int qlx, int qrx){\n\tif(rx < qlx || qrx < lx) return {-1, 0, 0, 0};\n\tif(qlx <= lx && rx <= qrx) return v->a;\n\treturn combine(query(v->l, lx, (lx + rx)/2, qlx, qrx), query(v->r, (lx+rx)/2 + 1, rx, qlx, qrx));\n}\n\nbool equal(info a, info b){\n\tif(a.lc == -1 && b.lc == -1) return true;\n\treturn (a.lc == b.lc) && (a.rc == b.rc) && (a.x == b.x) && (a.y == b.y);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tA = rng();\n\tB = rng();\n\tC = rng();\n\tcin >> n >> s;\n\tnode* segtree = build(0, n-1);\n\tint q;\n\tcin >> q;\n\tfor(int i = 0; i < q; i++){\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\t\tbool ans = equal(query(segtree, 0, n-1, a, a+l-1), query(segtree, 0, n-1, b, b+l-1));\n\t\tcout << (ans ? \"YES\" : \"NO\") << '\\n';\n\t}\n}"], "input": "", "output": "", "tags": ["data structures", "hashing", "strings"], "dificulty": "2500", "interactive": false}