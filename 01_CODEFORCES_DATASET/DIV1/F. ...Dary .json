{"link": "https://codeforces.com//contest/696/problem/F", "problemId": "65173", "problem_idx": "F", "shortId": "696F", "contest_number": "696", "problem_submissions": {"E": [20498917, 19122817, 19128171, 19128416, 19128548, 19128551, 19129321, 142908498, 19129056, 19129065, 19148528, 19121431], "A": [19119258, 19112517, 19113245, 19130646, 19113356, 19114035, 19112027, 19112329, 19113544, 19115943, 19114049, 19111947, 19112445, 19112591, 19113340, 19112458, 19127604, 19113354, 19112419, 19122807], "B": [19118714, 19115949, 19116617, 19115367, 19115254, 19116922, 19113777, 19114248, 19115893, 19113611, 19114745, 19113499, 19115275, 19114851, 19115798, 19115867, 19113047, 19115983, 19115146, 19124178], "D": [19117852, 19121638, 19123814, 19122693, 19131199, 19131585, 19120524, 19123388, 19122212, 19124637, 19122311, 19124184, 19125355, 19124738, 19124393, 19125186, 19123099, 19124323, 19124512, 19154347], "C": [19113058, 19119301, 19121245, 19119819, 19118377, 19124627, 19116332, 19120250, 19118573, 19118620, 19122282, 19118411, 19120542, 19120806, 19119142, 19121243, 19119728, 19127751], "F": [19223787, 19134194]}, "name": "F. ...Dary ", "statement": "Barney has finally found the one, a beautiful young lady named Lyanna.\r\nThe problem is, Lyanna and Barney are trapped in Lord Loss\u2019 castle. This\r\ncastle has shape of a convex polygon of points. Like most of castles in\r\nDemonata worlds, this castle has no ceiling. Barney and Lyanna have an\r\nescape plan, but it requires some geometry knowledge, so they asked for\r\nyour help.Barney knows that demons are organized and move in lines. He\r\nand Lyanna want to wait for the appropriate time so they need to watch\r\nfor the demons. Each of them wants to stay in a point (possibly on edges\r\nor corners), also they may stay in the same position. They both want to\r\npick a real number and watch all points in the circles with radius\r\naround each of them (these two circles may overlap). We say that Barney\r\nand Lyanna are if and only if for every edge of the polygon, at least\r\none of them can see at least one point on the line this edge lies on,\r\nthus such point may not be on the edge but it should be on edge\u2019s line.\r\nFormally, each edge line should have at least one common point with at\r\nleast one of two circles.The greater is, the more energy and focus they\r\nneed. So they asked you to tell them the minimum value of such that they\r\ncan watch carefully.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst double eps = 1e-8;\n\ninline int dcmp(double x) { return x < -eps ? -1 : x > eps; }\n\nstruct point\n{\n\tdouble x, y;\n\n\tpoint() { }\n\tpoint(const double &_x, const double &_y): x(_x), y(_y) { }\n\n\tfriend point operator+(const point &x, const point &y) { return point(x.x + y.x, x.y + y.y); }\n\tfriend point &operator+=(point &x, const point &y) { x.x += y.x, x.y += y.y; return x; }\n\tfriend point operator-(const point &x, const point &y) { return point(x.x - y.x, x.y - y.y); }\n\tfriend point &operator-=(point &x, const point &y) { x.x -= y.x, x.y -= y.y; return x; }\n\tfriend point operator*(const point &x, const double &y) { return point(x.x * y, x.y * y); }\n\tfriend point &operator*=(point &x, const double &y) { x.x *= y, x.y *= y; return x; }\n\tfriend point operator/(const point &x, const double &y) { return point(x.x / y, x.y / y); }\n\tfriend point &operator/=(point &x, const double &y) { x.x /= y, x.y /= y; return x; }\n\tfriend bool operator<(const point &x, const point &y) { if (!dcmp(x.x - y.x)) return dcmp(x.y - y.y) < 0; return x.x < y.x; }\n\tfriend double operator*(const point &x, const point &y) { return x.x * y.x + x.y * y.y; }\n\tfriend double operator^(const point &x, const point &y) { return x.x * y.y - x.y * y.x; }\n\tdouble length() { return sqrt(x * x + y * y); }\n\tdouble length2() { return x * x + y * y; }\n\n};\n\nconst int maxn = 300;\n\nint n;\npoint a[maxn + 5];\n\ninline double dis(const point &k, const point &i, const point &j) { return ((i - k) ^ (j - k)) / (j - i).length(); }\n\ninline double calc(int x, int y, bool out)\n{\n\tif ((y - x + n) % n <= 2)\n\t{\n\t\tif (out) printf(\"%.15f %.15f\\n\", a[(x + 1) % n].x, a[(x + 1) % n].y);\n\t\treturn 0;\n\t}\n\tif (((a[(x + 1) % n] - a[x]) ^ (a[(y + n - 1) % n] - a[y])) > 0) return 1e100;\n\tdouble u = -dis(a[x], a[(y + n - 1) % n], a[y]);\n\tfor (int i = x, nxt; i != y; i = nxt)\n\t{\n\t\tnxt = (i + 1) % n;\n\t\tdouble v = dis(a[nxt], a[x], a[(x + 1) % n]) - dis(a[nxt], a[(y + n - 1) % n], a[y]);\n\t\tif ((u > 0) != (v > 0))\n\t\t{\n\t\t\tpoint p = (a[i] * v - a[nxt] * u) / (v - u);\n\t\t\tif (out) printf(\"%.15f %.15f\\n\", p.x, p.y);\n\t\t\treturn dis(p, a[x], a[(x + 1) % n]);\n\t\t}\n\t\tu = v;\n\t}\n\tassert(0);\n\treturn 1e100;\n}\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif \n\tscanf(\"%d\", &n);\n\tREP(i, 0, n) scanf(\"%lf%lf\", &a[i].x, &a[i].y);\n\tdouble ans = 1e100;\n\tint ansx = -1, ansy = -1;\n\tREP(i, 0, n) REP(j, i + 2, n)\n\t\tif (chkmin(ans, max(calc(i, j, 0), calc(j, i, 0)))) ansx = i, ansy = j;\n\tprintf(\"%.15f\\n\", ans);\n\tcalc(ansx, ansy, 1);\n\tcalc(ansy, ansx, 1);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "geometry", "two pointers"], "dificulty": "3300", "interactive": false}