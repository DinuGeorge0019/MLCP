{"link": "https://codeforces.com//contest/1852/problem/E", "problemId": "2099136", "problem_idx": "E", "shortId": "1852E", "contest_number": "1852", "problem_submissions": {"F": [215258181, 215285692, 217509901, 217509714], "E": [215240027, 215239122, 215243644, 215243658, 215248799, 215245960, 215237098, 215240727, 215296441, 215327365, 215336328, 217901271, 215247415], "D": [215222100, 215222081, 215222261, 215225730, 215218775, 215382147, 215226776, 215250750, 215250174, 215230611, 215232642, 215226731, 215232589, 215240152, 215237043, 215236182, 215239579, 215241752, 215242725], "C": [215209363, 215208759, 215214250, 215220833, 215208505, 215217394, 215219756, 215218376, 215205472, 215208510, 215213920, 215221691, 215216406, 215223920, 215226652, 215216927, 215221642, 215210662, 215212429], "B": [215201282, 215200579, 215202726, 215199335, 215200474, 215207713, 215208166, 215202505, 215214027, 215200003, 215206319, 215205331, 215204344, 215212727, 215206313, 215209315, 215209426, 215199777, 215204560], "A": [215201184, 215192031, 215194261, 215194419, 215219859, 215194029, 215260286, 215197669, 215196351, 215192202, 215192228, 215192416, 215194163, 215196399, 215195136, 215198712, 215191998, 215201193, 215192233, 215195682]}, "name": "E. Rivalries", "statement": "Ntarsis has an array a of length n.The of a subarray a_l\r\ndots a_r (1\r\nleq l\r\nleq r\r\nleq n) is defined as: The largest value x such that a_l\r\ndots a_r contains x and neither a_1\r\ndots a_{l-1} nor a_{r+1}\r\ndots a_n contains x. If no such x exists, the power is 0. Call an array\r\nb a to a if the following holds: The length of both a and b are equal to\r\nsome n. Over all l, r where 1\r\nleq l\r\nleq r\r\nleq n, the power of a_l\r\ndots a_r equals the power of b_l\r\ndots b_r. The elements of b are positive. Ntarsis wants you to find a\r\nrival b to a such that the sum of b_i over 1\r\nleq i\r\nleq n is maximized. Help him with this task!\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n    \n    int find(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return siz[find(x)];\n    }\n};\ntemplate<class Info>\nstruct SegmentTree {\n    int n;\n    std::vector<Info> info;\n    SegmentTree() : n(0) {}\n    SegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    SegmentTree(std::vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(std::vector(n_, v_));\n    }\n    template<class T>\n    void init(std::vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << std::__lg(n), Info());\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    template<class F>\n    int findFirst(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = findFirst(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = findFirst(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findFirst(int l, int r, F pred) {\n        return findFirst(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int findLast(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = findLast(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = findLast(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findLast(int l, int r, F pred) {\n        return findLast(1, 0, n, l, r, pred);\n    }\n};\n\nconstexpr i64 inf = 1E18;\n\nstruct Info {\n    i64 cnt = 0;\n    i64 sum = 0;\n    i64 min = inf;\n};\n\nInfo operator+(Info a, Info b) {\n    Info c;\n    c.cnt = a.cnt + b.cnt;\n    c.sum = a.sum + b.sum;\n    c.min = std::min(a.min, b.min);\n    return c;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::map<int, int> l, r;\n    for (int i = 0; i < n; i++) {\n        if (!l.count(a[i])) {\n            l[a[i]] = i;\n        }\n        r[a[i]] = i;\n    }\n    \n    std::vector<std::array<int, 3>> e;\n    std::vector<int> b(n);\n    for (auto [x, lx] : l) {\n        e.push_back({x, lx, r[x]});\n    }\n    std::reverse(e.begin(), e.end());\n    \n    std::map<int, int> f;\n    std::vector<std::array<int, 3>> v;\n    DSU dsu(n + 1);\n    std::vector<bool> fix(n);\n    for (auto [x, l, r] : e) {\n        auto it = f.lower_bound(l);\n        if (it != f.end() && it->second < r) {\n            continue;\n        }\n        v.push_back({x, l, r});\n        dsu.merge(l + 1, l);\n        dsu.merge(r + 1, r);\n        fix[l] = fix[r] = true;\n        b[l] = b[r] = x;\n        f[l] = r;\n        it--;\n        while (it != f.begin() && std::prev(it)->second > r) {\n            f.erase(std::prev(it));\n        }\n    }\n    \n    for (auto [x, l, r] : v) {\n        for (int i = dsu.find(l); i <= r; i = dsu.find(i)) {\n            dsu.merge(i + 1, i);\n            b[i] = x;\n        }\n    }\n    i64 ans = -1;\n    i64 sum = std::accumulate(b.begin(), b.end(), 0LL);\n    if (std::count(b.begin(), b.end(), 0) == 0) {\n        ans = sum;\n    }\n    int lz = n, rz = -1;\n    for (int i = 0; i < n; i++) {\n        if (b[i] == 0) {\n            lz = std::min(lz, i);\n            rz = i;\n        }\n    }\n    std::vector<int> p(n);\n    std::iota(p.begin(), p.end(), 0);\n    std::sort(p.begin(), p.end(), [&](int i, int j) {\n        return b[i] > b[j];\n    });\n    SegmentTree<Info> seg(n);\n    for (int i = 0; i < n; i++) {\n        if (!fix[i]) {\n            seg.modify(i, {1, b[i], b[i]});\n        }\n    }\n    int Val = -1;\n    int Lv = -1, Rv = -1;\n    for (int i = 0, j = 0, k = 0; i < v.size(); i++) {\n        auto [x, l, r] = v[i];\n        if (j < i) {\n            j = i;\n        }\n        while (j + 1 < v.size() && v[j][0] - 1 == v[j + 1][0]) {\n            j++;\n        }\n        int val = v[j][0] - 1;\n        if (val == 0) {\n            continue;\n        }\n        while (k < n && b[p[k]] > val) {\n            if (!fix[p[k]]) {\n                seg.modify(p[k], {0, 0, b[p[k]]});\n            }\n            k++;\n        }\n        int lv = std::min(l, lz);\n        int rv = std::max(r, rz);\n        i64 res = sum;\n        auto info = seg.rangeQuery(0, lv + 1);\n        if (info.cnt) {\n            res += 1LL * info.cnt * val - info.sum;\n        } else {\n            res += val - info.min;\n        }\n        info = seg.rangeQuery(rv, n);\n        if (info.cnt) {\n            res += 1LL * info.cnt * val - info.sum;\n        } else {\n            res += val - info.min;\n        }\n        if (lv < rv) {\n            info = seg.rangeQuery(lv + 1, rv);\n            res += 1LL * info.cnt * val - info.sum;\n        }\n        if (res > ans) {\n            ans = res;\n            Val = val;\n            Lv = lv;\n            Rv = rv;\n        }\n    }\n    if (Val != -1) {\n        int x = -1;\n        bool lt = false;\n        for (int i = Lv; i >= 0; i--) {\n            if (!fix[i]) {\n                if (b[i] < Val) {\n                    b[i] = Val;\n                    lt = true;\n                } else {\n                    if (x == -1 || b[i] < b[x]) {\n                        x = i;\n                    }\n                }\n            }\n        }\n        if (!lt) {\n            b[x] = Val;\n        }\n        x = -1;\n        lt = false;\n        for (int i = Rv; i < n; i++) {\n            if (!fix[i]) {\n                if (b[i] < Val) {\n                    b[i] = Val;\n                    lt = true;\n                } else {\n                    if (x == -1 || b[i] < b[x]) {\n                        x = i;\n                    }\n                }\n            }\n        }\n        if (!lt) {\n            b[x] = Val;\n        }\n        for (int i = Lv + 1; i < Rv; i++) {\n            if (!fix[i] && b[i] < Val) {\n                b[i] = Val;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        std::cout << b[i] << \" \\n\"[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "greedy"], "dificulty": "3400", "interactive": false}