{"link": "https://codeforces.com//contest/1710/problem/E", "problemId": "1478271", "problem_idx": "E", "shortId": "1710E", "contest_number": "1710", "problem_submissions": {"D": [165580964, 165583659, 165582423, 165579985, 165578292, 165621030, 165665623, 165863180, 165686266, 165622179, 253472539, 253472055, 253196732], "C": [165561993, 165571937, 165567266, 165564305, 165560493, 165557009, 165565561, 165573369, 167610382, 165564040, 165565611, 165559918, 165863165, 165574164, 165561713, 165562795, 166635016, 165567222, 165574139, 165575303, 165568215, 165580670, 165575504], "B": [165557184, 165556433, 165562218, 165559397, 165550455, 165567723, 165557989, 165562869, 167610352, 165552192, 165580788, 165551441, 165863147, 165568559, 165640205, 165639837, 165621062, 165556086, 165556541, 167747535, 165575476, 165569308, 165567541, 165555460, 165570664, 165584416], "E": [165552045, 165543060, 165549416, 165565765, 165563275, 165541229, 165548123, 165548892, 165559843, 165548838, 165565641, 165863198, 165549459, 165565050, 165564177, 166635025, 165555617, 165553406, 165554497, 165569888, 165555183, 165548602], "A": [165540652, 165547446, 165541424, 165545863, 165540100, 165538811, 165546951, 165544526, 167610720, 167610305, 165540896, 165542843, 165539482, 165863070, 165547951, 165543234, 165543554, 165541413, 165551173, 165542506, 165539602, 165547656, 165544347]}, "name": "E. Two Arrays", "statement": "You are given two arrays of integers a_1,a_2,\r\ndots,a_n and b_1,b_2,\r\ndots,b_m. Alice and Bob are going to play a game. Alice moves first and\r\nthey take turns making a move.They play on a grid of size n\r\ntimes m (a grid with n rows and m columns). Initially, there is a rook\r\npositioned on the first row and first column of the grid.During her/his\r\nmove, a player can do one of the following two operations: Move the rook\r\nto a cell on the same row or the same column of the current cell. A\r\nplayer cannot move the rook to a cell that has been visited 1000 times\r\nbefore (i.e., the rook can stay in a certain cell at most 1000 times\r\nduring the entire game). Note that the starting cell is considered to be\r\nvisited once at the beginning of the game. End the game immediately with\r\na score of a_r+b_c, where (r, c) is the current cell (i.e., the rook is\r\non the r-th row and c-th column). Bob wants to maximize the score while\r\nAlice wants to minimize it. If they both play this game optimally, what\r\nis the final score of the game?\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int maxn=555555,mod=998244353;\n#define fi first\n#define se second\n#define PB push_back\n#define MP make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline int read(){\n\tchar ch=getchar();int x=0;bool f=0;\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\ninline int qmo(int x){return x+((x>>31)&mod);}\nint n,m,a[maxn],b[maxn],x,y,c[maxn],r[maxn];\nll c1[maxn],c2[maxn];\nbool check(int w){\n\tif(a[x]+b[y]<w) return false;\n\tll s1=0,s2=0;\n\tint j=m;\n//\tprintf(\"w=%d\\n\",w);\n\tFOR(i,1,n){\n\t\twhile(j && a[i]+b[j]>=w) j--;\n\t\tr[i]=m-j;\n\t}\n\tj=n;\n\tFOR(i,1,m){\n\t\twhile(j && a[j]+b[i]>=w) j--;\n\t\tc[i]=n-j;\n\t}\n\tFOR(i,0,n) c1[i]=c2[i]=0;\n\tFOR(i,1,m) c1[c[i]]++,c2[c[i]]+=c[i];\n\tFOR(i,1,n) c1[i]+=c1[i-1],c2[i]+=c2[i-1];\n\tll s=0;\n\tFOR(i,1,n){\n\t\ts-=r[i];\n\t\ts1=max(s1,s+i*c1[i]-c2[i]);\n\t}\n\tr[x]--;c[y]--;\n\tFOR(i,0,n) c1[i]=c2[i]=0;\n\tFOR(i,1,m) c1[c[i]]++,c2[c[i]]+=c[i];\n\tFOR(i,1,n) c1[i]+=c1[i-1],c2[i]+=c2[i-1];\n\ts=0;\n\tFOR(i,1,n){\n\t\ts-=r[i];\n\t\ts2=max(s2,s+i*c1[i]-c2[i]-(i>=x && i-1>=c[y]));\n\t}\n\tFOR(i,1,n){\n\t\tif(i==x) continue;\n\t\ts-=r[i];\n\t\tint ii=i-(i>=x);\n\t\ts2=max(s2,s+ii*c1[ii]-c2[ii]);\n\t}\n//\tprintf(\"%lld and %lld\\n\",s1,s2);\n\treturn s1==s2;\n}\nint main(){\n\tn=read();m=read();\n\tFOR(i,1,n) a[i]=read();\n\tFOR(i,1,m) b[i]=read();\n\tint aa=a[1],bb=b[1];\n\tsort(a+1,a+n+1);sort(b+1,b+m+1);\n\tx=lower_bound(a+1,a+n+1,aa)-a;\n\ty=lower_bound(b+1,b+m+1,bb)-b;\n//\tprintf(\"x=%d,y=%d\\n\",x,y);\n\tint l=2,r=1e9;\n\twhile(l<r){\n\t\tint mid=(l+r+1)>>1;\n\t\tif(check(mid)) l=mid;\n\t\telse r=mid-1;\n\t}\n\tprintf(\"%d\\n\",l);\n}"], "input": "", "output": "", "tags": ["binary search", "games", "graph matchings"], "dificulty": "2400", "interactive": false}