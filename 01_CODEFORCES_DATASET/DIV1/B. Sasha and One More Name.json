{"link": "https://codeforces.com//contest/1109/problem/B", "problemId": "298870", "problem_idx": "B", "shortId": "1109B", "contest_number": "1109", "problem_submissions": {"E": [50026873, 50038594, 50033088, 50025271, 50029128, 50029427, 50028676, 50028977, 50035588, 50034800, 50030219, 50030201, 50018221, 50030444, 50031682, 50021323, 50035024, 50031663, 50032167, 50027503], "C": [50018224, 50032258, 50027083, 50523597, 50061049, 50019096, 50015185], "D": [50006360, 50006283, 50016138, 50011686, 50015522, 50017005, 50014754, 50017015, 50015842, 50036394, 50036291, 50035638, 50015625, 50018432, 50025929, 50017587, 50016208, 50029181, 50013944, 50013609, 50026717, 50030603, 50031093], "B": [50001043, 50019350, 50007187, 50004994, 50003589, 50005230, 50000704, 50008934, 50007447, 50003085, 50002442, 50022126, 50007014, 50005280, 50003394, 50003776, 50016263, 50000661, 50002322, 50006926], "A": [49999265, 49999276, 50001550, 50004725, 49999432, 50001055, 49999266, 50001592, 49999413, 50035642, 49999326, 49999231, 50019325, 50000549, 50000251, 49999282, 49999284, 49999278, 49999235, 49999298, 49999812], "F": [50024623, 158339458, 50027544, 50158209, 95343531]}, "name": "B. Sasha and One More Name", "statement": "Reading books is one of Sasha\u2019s passions. Once while he was reading one\r\nbook, he became acquainted with an unusual character. The character told\r\nabout himself like that: \"Many are my names in many countries.\r\nMithrandir among the Elves, Thark n to the Dwarves, Ol rin I was in my\r\nyouth in the West that is forgotten, in the South Inc nus, in the North\r\nGandalf; to the East I go not.\"And at that moment Sasha thought, how\r\nwould that character be called in the East? In the East all names are\r\npalindromes. A string is a palindrome if it reads the same backward as\r\nforward. For example, such strings as \"\", \"\" and \"\" are palindromes, but\r\nstrings \"\" and \"\" are not. Sasha believed that the hero would be named\r\nafter one of the gods of the East. As long as there couldn\u2019t be two\r\nequal names, so in the East people did the following: they wrote the\r\noriginal name as a string on a piece of paper, then cut the paper\r\nminimum number of times k, so they got k+1 pieces of paper with\r\nsubstrings of the initial string, and then unite those pieces together\r\nto get a new string. Pieces , they could be shuffled.In this way, it\u2019s\r\npossible to achive a string from the string using 3 cuts (by swapping\r\npapers with substrings and ). The string can\u2019t be received using the\r\nsame cuts.More formally, Sasha wants for the given s find such minimum\r\nk, that you can cut this string into k + 1 parts, and then unite them in\r\nsuch a way that the final string will be a palindrome and it won\u2019t be\r\nequal to the initial string s. It there is no answer, then print \"\"\r\n(without quotes).\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nbool isPal(string s) {\n\tint n = s.length();\n\tfor (int i = 0; i < n; i++)\n\t\tif (s[i] != s[n - 1 - i])\n\t\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tstring s;\n\tcin >> s;\n\tbool allEq = true;\n\tint n = s.length();\n\tfor (int i = 0; i < n; i++)\n\t\tif (n % 2 == 0 || i != n / 2)\n\t\t\tallEq &= s[0] == s[i];\n\tif (allEq) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n - 1; i++) {\n\t\tstring p = s.substr(i, n - i) + s.substr(0, i);\n\t\tif (p == s || !isPal(p)) continue;\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tcout << 2 << endl;\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "hashing", "strings"], "dificulty": "1800", "interactive": false}