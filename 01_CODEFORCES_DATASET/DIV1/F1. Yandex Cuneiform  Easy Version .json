{
    "link": "https://codeforces.com//contest/2046/problem/F1",
    "problemId": "3064645",
    "problem_idx": "F1",
    "shortId": "2046F1",
    "contest_number": "2046",
    "problem_submissions": {
        "E2": [
            294584009,
            294914447,
            299392707
        ],
        "E1": [
            294583764,
            294575583,
            294575752,
            294582430,
            294565503,
            294626979,
            294869963,
            294674514,
            294674138,
            294611999,
            294672171,
            295181016,
            299301861,
            294579122,
            294609733
        ],
        "D": [
            294560152,
            294564191,
            294566638,
            294575690,
            294573167,
            294577461,
            294570961,
            294577018,
            294582440,
            294580055,
            294581279,
            294580878,
            294578858,
            294578559,
            294582493,
            294576385,
            294578827
        ],
        "C": [
            294540710,
            294545229,
            294545966,
            294548359,
            294558363,
            294545738,
            294550008,
            294552252,
            294555169,
            294551693,
            294558653,
            294550648,
            294551477,
            294560374,
            294559914,
            294555355,
            294557938,
            294552127,
            294543297,
            294557586
        ],
        "B": [
            294535038,
            294535101,
            294537375,
            294540562,
            294536849,
            294536519,
            294541688,
            294539018,
            294541654,
            294536164,
            294543153,
            294539414,
            294540802,
            294537409,
            294549010,
            294540274,
            294543427,
            294535624,
            294535094,
            294536775
        ],
        "A": [
            294532826,
            294532846,
            294539095,
            294533971,
            294533241,
            294533253,
            294534636,
            294533446,
            294534152,
            294532988,
            294537957,
            294533256,
            294533123,
            294534271,
            294537609,
            294533346,
            294537414,
            294532885,
            294532806,
            294533598
        ],
        "F2": [
            301103610,
            294606357
        ],
        "F1": [
            301085708,
            295825018,
            294574079
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136908",
    "editorial": "It can be noted that if the string contains the correct number of symbols 'Y', 'D', 'X' and does not have two consecutive identical symbols, then it can be obtained using the given operations.\n\nTo demonstrate this, we will provide an algorithm that constructs a sequence of operations leading to the desired string. We will start from the end (from the string we want to obtain to the empty string) gradually removing symbols.\n\nLet's look at the current string. Without loss of generality, let its first symbol be 'Y'. Then the string must contain the substring 'DX' and/or the substring 'XD'. This is true because for the absence of 'DX' and 'XD', it is necessary that between any pair of symbols not equal to 'Y', there is at least one symbol 'Y'. This can be achieved at best by placing 'Y' between every symbol. Thus, the number of symbols not equal to 'Y' with n?1\n 'Y' can be at most n\n. But 3n?1>n\n when n>0\n.\n\nThus, the string has the form 'Y...ADXB...'.\n\nIf A ?\n B, we can remove the symbols 'Y', 'D', 'X' and nothing will break.\n\nIf A = B, then A = B = 'Y', since A != 'D' and A != 'X'.\n\nThen the string has the form 'Y...YDXY...', and we can remove the substring 'YDX' and still have an unbroken string 'Y...Y...'.",
    "name": "F1. Yandex Cuneiform  Easy Version ",
    "statement": "For a long time, no one could decipher Sumerian cuneiform. However, it\r\nhas finally succumbed to pressure! Today, you have the chance to\r\ndecipher Yandex cuneiform.Yandex cuneiform is defined by the following\r\nrules: An empty string is a Yandex cuneiform. If you insert exactly one\r\ncopy of each of the three letters \u201d, \u201d, and \u201d into a Yandex cuneiform in\r\nsuch a way that no two adjacent letters become equal after the\r\noperation, you obtain a Yandex cuneiform. If a string can\u2019t be obtained\r\nusing the above rules, it is not a Yandex cuneiform. You are given a\r\ntemplate. A template is a string consisting of the characters \u201d, \u201d, \u201d,\r\nand \u201d.You need to check whether there exists a way to replace each\r\nquestion mark with \u201d, \u201d, or \u201d to obtain a Yandex cuneiform, and if it\r\nexists, output any of the matching options, as well as a sequence of\r\ninsertion operations to obtain the resulting cuneiform.In this version\r\nof the problem, there are in the template.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;#define fwd(i, a, n) for (int i = (a); i < (n); i++)#define rep(i, n) fwd(i, 0, n)#define all(X) X.begin(), X.end()#define sz(X) int(size(X))#define pb push_back#define eb emplace_back#define st first#define nd secondusing pii = pair<int, int>; using vi = vector<int>;using ll = long long; using ld = long double;#ifdef LOCauto SS = signal(6, [](int) { *(int *)0 = 0; });#define DTP(x, y) auto operator << (auto &o, auto a) -> decltype(y, o) { o << \"(\"; x; return o << \")\"; }DTP(o << a.st << \", \" << a.nd, a.nd);DTP(for (auto i : a) o << i << \", \", all(a));#define deb(x...) cerr << setw(4) << __LINE__ << \":[\" #x \"]: \", [](auto... y) { (( cerr << y << \", \" ), ...) << '\\n'; }(x)#else#define deb(...) 0#endif\u00a0#include <bits/extc++.h>using namespace __gnu_pbds;template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\u00a0vi char_to_int;string int_to_char;\u00a0void solve() {    int n;    vi s;    string ss;    {        cin >> ss;        n = sz(ss);        s.resize(n);        rep(i, n) s[i] = char_to_int[ss[i]];    }    array<int, 3> cnts{};    rep(i, n) ++cnts[s[i]];\u00a0    if (cnts[0] != cnts[1] || cnts[0] != cnts[2]) {        cout << \"NO\\n\";        return;    }\u00a0    rep(i, n-1) if (s[i] == s[i+1]) {        cout << \"NO\\n\";        return;    };    cout << \"YES\\n\" << ss << '\\n';\u00a0    set<int> active;    Tree<int> tree;    rep(i, n) active.insert(i), tree.insert(i);    array<array<set<int>, 3>, 3> where;\u00a0    auto nx = [&](int i) {        auto it = active.upper_bound(i);        return it == active.end() ? -1 : *it;    };    auto pr = [&](int i) {        auto it = active.lower_bound(i);        return it == active.begin() ? -1 : *--it;    };\u00a0    auto clear = [&](int i) {        if (i == -1) return;        rep(b, 3) where[s[i]][b].erase(i);    };\u00a0    auto re = [&](int i, int j) {        if (i == -1 || j == -1) return;        clear(i);        where[s[i]][s[j]].insert(i);    };\u00a0    rep(i, n - 1) re(i, i+1);\u00a0    auto remove = [&](int i) {        active.erase(active.find(i));        tree.erase(i);        clear(i);        int pi = pr(i), ni = nx(i);\u00a0        re(pi, ni);    };\u00a0    vector<pair<char, int>> anss;\u00a0    auto ans = [&](int i, int j, int k) {        set<int> st = {s[i], s[j], s[k]};        assert(sz(st) == 3);\u00a0        remove(i);        anss.eb(int_to_char[s[i]], tree.order_of_key(i));        remove(j);        anss.eb(int_to_char[s[j]], tree.order_of_key(j));        remove(k);        anss.eb(int_to_char[s[k]], tree.order_of_key(k));    };\u00a0    rep(_, n / 3) {        int S = nx(-1);        int ok = s[S];\u00a0        bool fi = false;        int a = (ok + 1) % 3, b = (ok + 2) % 3;\u00a0        rep(__, 2) {            if (fi) break;\u00a0            if (where[a][b].empty()) {                swap(a, b);                continue;            }            fi = true;\u00a0            int i = *where[a][b].begin();            int ni = nx(i);\u00a0            int pi = pr(i);            assert(pi != -1);            int nni = nx(ni);\u00a0            if (nni == -1) {                ans(i, ni, S);                continue;            }\u00a0            if (s[pi] == s[nni]) {                ans(i, ni, pi);                continue;            }            else {                ans(i, ni, S);                continue;            }        }\u00a0        assert(fi);    }\u00a0    reverse(all(anss));    for (auto [c, i] : anss)        cout << c << ' ' << i << '\\n';}\u00a0int32_t main() {    cin.tie(0)->sync_with_stdio(0);    cout << fixed << setprecision(10);\u00a0    int_to_char = \"YDX\";    char_to_int.resize(256);    rep(i, 3)        char_to_int[int_to_char[i]] = i;\u00a0    int z = 1;    cin >> z;    rep(_, z) solve();\u00a0    #ifdef LOCF    cout.flush(); cerr << \"- - - - - - - - -\\n\";    (void)!system(\"grep VmPeak /proc/$PPID/status | sed s/....kB/\\' MB\\'/1 >&2\"); // 4x.kB ....kB    #endif\u00a0    cout << flush;    _Exit(0);}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F1. Yandex Cuneiform  Easy Version .json"
}