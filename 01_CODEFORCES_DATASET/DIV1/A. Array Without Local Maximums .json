{
    "link": "https://codeforces.com//contest/1067/problem/A",
    "problemId": "242827",
    "problem_idx": "A",
    "shortId": "1067A",
    "contest_number": "1067",
    "problem_submissions": {
        "E": [
            44797063,
            44801350,
            44801345,
            44800256,
            44807009,
            44795862,
            44802107,
            44801174,
            44802534,
            44808036,
            44807819,
            44808903,
            44813776,
            44808812,
            44823059,
            44822826
        ],
        "C": [
            44791919,
            44798705,
            44789846,
            45703244,
            44817690,
            44796737,
            44821755,
            44819508,
            44819482,
            44798809,
            44800641
        ],
        "B": [
            44785395,
            44790831,
            44786324,
            44787984,
            44813565,
            44800421,
            44789408,
            44792434,
            44795239,
            44792208,
            44793600,
            44795334,
            44790580,
            44792571,
            44793492,
            44790971,
            44785468,
            44794434
        ],
        "A": [
            44781795,
            44784467,
            44782825,
            44782486,
            44802955,
            44788563,
            44785068,
            44786748,
            44791948,
            44785790,
            44788019,
            44787518,
            44785264,
            44787093,
            44892470,
            44785358,
            44786648,
            44792812,
            44788577
        ],
        "D": [
            44810645,
            44811277,
            59968450,
            44830180,
            44927930,
            44819755,
            44819681,
            44819351,
            44807988,
            44804123
        ]
    },
    "name": "A. Array Without Local Maximums ",
    "statement": "Ivan unexpectedly saw a present from one of his previous birthdays. It\r\nis array of n numbers from 1 to 200. Array is old and some numbers are\r\nhard to read. Ivan remembers that for all elements at least one of its\r\nneighbours ls not less than it, more formally:a_{1}\r\nle a_{2},a_{n}\r\nle a_{n-1} anda_{i}\r\nle max(a_{i-1},\r\n,\r\n, a_{i+1}) for all i from 2 to n-1.Ivan does not remember the array and\r\nasks to find the number of ways to restore it. Restored elements also\r\nshould be integers from 1 to 200. Since the number of ways can be big,\r\nprint it modulo 998244353.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst int d=200;\n\nint n;\n\nll dps[nax][2];\nll dpn[nax][2];\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\ninline int mog(int v, int i)\n{\n\tif (v==i)\n\t\treturn 1;\n\tif (v==-1)\n\t\treturn i>0;\n\treturn 0;\n}\n\nvoid upd(int v)\n{\n\tfor (int i=0; i<=d; i++)\n\t{\n\t\tfor (int j=0; j<2; j++)\n\t\t{\n\t\t\tdps[i][j]=dpn[i][j];\n\t\t\tdpn[i][j]=0;\n\t\t}\n\t}\n\tll s=0;\n\tfor (int i=0; i<=d; i++)\n\t{\n\t\tif (mog(v, i))\n\t\t\tdod(dpn[i][0], s);\n\t\tdod(s, dps[i][0]+dps[i][1]);\n\t}\n\ts=0;\n\tfor (int i=d; i>=0; i--)\n\t{\n\t\tif (mog(v, i))\n\t\t\tdod(dpn[i][1], s);\n\t\tdod(s, dps[i][1]);\n\t}\n\tfor (int i=0; i<=d; i++)\n\t{\n\t\tif (mog(v, i))\n\t\t\tdod(dpn[i][1], dps[i][0]+dps[i][1]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tdpn[0][1]=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tupd(x);\n\t}\n\tupd(0);\n\tprintf(\"%lld\\n\", dpn[0][1]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Array Without Local Maximums .json",
    "editorial_link": "https://codeforces.com/blog/entry/62688",
    "editorial": "Letâs find solution with complexity . We can count quantity of ways to\r\nrestore element from to with last element equalls to , means that\r\nprevious element is less then the last or last element is first, the\r\nopposite. So , .Now letâs count on each prefix before counting all , so\r\nwe can recalculate dp in O(1) time.Complexity is .\r\n",
    "hint": []
}