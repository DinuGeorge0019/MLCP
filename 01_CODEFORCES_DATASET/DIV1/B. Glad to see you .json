{
    "link": "https://codeforces.com//contest/809/problem/B",
    "problemId": "106951",
    "problem_idx": "B",
    "shortId": "809B",
    "contest_number": "809",
    "problem_submissions": {
        "E": [
            27253997,
            27253429
        ],
        "D": [
            27249075,
            27251826,
            27251250,
            27252529,
            27250844,
            27248855,
            27249814,
            27250805,
            27251747,
            27249258,
            27246563,
            27254846,
            27254749
        ],
        "C": [
            27246781,
            27244976,
            27248082,
            27245390,
            27251108,
            27243956,
            27253183,
            27253135,
            27244552,
            27253129,
            27245688,
            27244697,
            27248015,
            27245843,
            27247902,
            27248924,
            27249554,
            27245267,
            27250102,
            27250477
        ],
        "B": [
            27242404,
            27247452,
            27245322,
            27249228,
            27241882,
            27241895,
            27246216,
            27242600,
            27252141,
            27243365,
            27243040,
            27244839,
            27249122,
            27244039,
            27244488
        ],
        "A": [
            27238822,
            27238882,
            27238974,
            27238780,
            27251619,
            27238718,
            27238690,
            27238879,
            27238895,
            27238975,
            27238855,
            27238770,
            27239286,
            27239029,
            27238990,
            27239207,
            27238846,
            27239176,
            27238782
        ]
    },
    "name": "B. Glad to see you ",
    "statement": "On Sunday Leha the hacker took Nura from the house where she lives and\r\nwent with her to one of the most luxurious restaurants in Vi kopolis.\r\nUpon arrival, they left the car in a huge parking lot near the\r\nrestaurant and hurried inside the building.In the restaurant a polite\r\nwaiter immediately brought the menu to Leha and Noora, consisting of\r\ndishes. It is interesting that all dishes in the menu are numbered with\r\nintegers from to . After a little thought, the girl ordered exactly\r\ndifferent dishes from available in the menu. To pass the waiting time\r\nwhile the chefs prepare ordered dishes, the girl invited the hacker to\r\nplay a game that will help them get to know each other better.The game\r\nitself is very simple: Noora wants Leha to guess any two dishes among\r\nall ordered. At the same time, she is ready to answer only one type of\r\nquestions. Leha can say two numbers and . After that Noora chooses some\r\ndish for the number such that, at first, is among the dishes Noora\r\nordered ( can be equal to ), and, secondly, the value is the minimum\r\npossible. By the same rules the girl chooses dish for . After that Noora\r\nsays to Leha, if , and otherwise. However, the restaurant is preparing\r\nquickly, so Leha has enough time to ask no more than questions. After\r\nthat he should name numbers of any two dishes Noora ordered.Help Leha to\r\nsolve this problem!\r\n",
    "solutions": [
        "//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nint n, k;\n\nset <int> setel;\n\nchar wcz[100];\n\nint znajdz(int a, int b, int lew=1)\n{\n\tif (a==b)\n\t\treturn a;\n\tint s=(a+b)>>1;\n\tif (lew)\n\t{\n\t\tprintf(\"1 %d %d\\n\", s, s+1);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", wcz);\n\t\tif (wcz[0]=='T')\n\t\t\treturn znajdz(a, s, lew);\n\t\telse\n\t\t\tznajdz(s+1, b, lew);\n\t}\n\telse\n\t{\n\t\tprintf(\"1 %d %d\\n\", s+1, s);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", wcz);\n\t\tif (wcz[0]=='T')\n\t\t\treturn znajdz(s+1, b, lew);\n\t\telse\n\t\t\tznajdz(a, s, lew);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tsetel.insert(znajdz(1, n));\n\tint x=*setel.begin();\n\tif (x!=1)\n\t\tsetel.insert(znajdz(1, x-1));\n\tif (x!=n)\n\t\tsetel.insert(znajdz(x+1, n, 0));\n\tdebug() << imie(x);\n\tint juz=0;\n\tvector <int> wek;\n\tfor (auto i : setel)\n\t{\n\t\tprintf(\"1 %d %d\\n\", i, x);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", wcz);\n\t\tif (wcz[0]=='T')\n\t\t{\n\t\t\twek.push_back(i);\n\t\t\tjuz++;\n\t\t\tif (juz==2)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"2\");\n\tfor (int i : wek)\n\t\tprintf(\" %d\", i);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "interactive"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Glad to see you .json",
    "editorial_link": "https://codeforces.com/blog/entry/52099",
    "editorial": "Letâs start with searching the first point. We can do it using this\r\nbinary search: letâs ask points and each time, when we calculated the\r\ncenter of search interval. So we always know in which of the halves\r\nexists at least one point. Since in the initial interval there is at\r\nleast one point and , we will never lose this point out of the\r\nsearch.Now letâs run two binsearches more, similarly for everything to\r\nthe left and to the right of the first found point. Again, any point in\r\nthe interval of search is closer, than any point out of the interval.\r\nNow it is not guaranteed that initially exist at least one point, so we\r\nhave to check the found one using one query.\r\n",
    "hint": []
}