{"link": "https://codeforces.com//contest/543/problem/B", "problemId": "27498", "problem_idx": "B", "shortId": "543B", "contest_number": "543", "problem_submissions": {"C": [11031273, 11032297, 11028921, 11027662, 11035224, 11032105, 11026578, 11030569, 11027731, 11030889, 11031150, 11032259, 11039311, 11029744, 11031844, 11033030, 11027751, 11027833, 11030513], "D": [11026961, 11027152, 11029036, 11027586, 11028656, 11027275, 11031263, 11026257, 11029360, 11029505, 11032424, 11028940, 11031163, 11035849, 11028432], "B": [11024775, 11024536, 11030599, 11035262, 11024794, 11024869, 11025321, 11028836, 11028474, 11031647, 11025986, 11024625, 11027272, 11029817, 11024295, 11024309], "A": [11022855, 11023048, 11023174, 11022792, 11022796, 11023075, 11030178, 11022790, 11023930, 11023772, 11022768, 11023607, 11023159, 11022742, 11022813, 11022885]}, "name": "B. Destroying Roads", "statement": "In some country there are exactly cities and bidirectional roads\r\nconnecting the cities. Cities are numbered with integers from to . If\r\ncities and are connected by a road, then in an hour you can go along\r\nthis road either from city to city , or from city to city . The road\r\nnetwork is such that from any city you can get to any other one by\r\nmoving along the roads.You want to destroy the largest possible number\r\nof roads in the country so that the remaining roads would allow you to\r\nget from city to city in at most hours and get from city to city in at\r\nmost hours.Determine what maximum number of roads you need to destroy in\r\norder to meet the condition of your plan. If it is impossible to reach\r\nthe desired result, print -1.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n\n#ifdef _WIN32\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n\ntypedef long double ld;\n\nlong long rdtsc() {\n  long long tmp;\n  asm(\"rdtsc\" : \"=A\"(tmp));\n  return tmp;\n}\n\ninline int myrand() {\n  return abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n  return myrand() % x;\n}\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME \"text\"\n\nconst int INF = (int)1e9 + 1;\nconst ld EPS = 1e-9;\n\nvoid precalc() {\n}\n\nint n, m;\n\nvector<vector<int> > es;\n\nint vs[2][2], lens[2];\n\nbool read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return 0;\n  }\n  es = vector<vector<int> >(n);\n  for (int i = 0; i < m; ++i) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    --s, --t;\n    es[s].pb(t), es[t].pb(s);\n  }\n  for (int it = 0; it < 2; ++it) {\n    int s, t, len;\n    scanf(\"%d%d%d\", &s, &t, &len);\n    --s, --t;\n    vs[it][0] = s, vs[it][1] = t, lens[it] = len;\n  }\n  return 1;\n}\n\nconst int maxn = (int) 3e3 + 10;\n\nint dist[maxn][maxn];\n\nint st[maxn];\n\nvoid bfs(int S) {\n  int *dist = ::dist[S];\n  for (int i = 0; i < n; ++i) {\n    dist[i] = INF;\n  }\n\n  dist[S] = 0;\n  st[0] = S;\n\n  for (int l = 0, r = 1; l < r; ++l) {\n    int v = st[l];\n    for (int it = 0; it < sz(es[v]); ++it) {\n      int u = es[v][it];\n      if (dist[u] > dist[v] + 1) {\n        dist[u] = dist[v] + 1;\n        st[r++] = u;\n      }\n    }\n  }\n}\n\nvoid solve() {\n  for (int i = 0; i < n; ++i) {\n    bfs(i);\n  }\n\n  if (dist[vs[0][0]][vs[0][1]] > lens[0] || dist[vs[1][0]][vs[1][1]] > lens[1]) {\n    printf(\"-1\\n\");\n    return;\n  }\n  int res = dist[vs[0][0]][vs[0][1]] + dist[vs[1][0]][vs[1][1]];\n  for (int rot = 0; rot < 2; ++rot) {\n    for (int v1 = 0; v1 < n; ++v1) {\n      for (int v2 = 0; v2 < n; ++v2) {\n        bool fail = 0;\n        for (int it = 0; it < 2; ++it) {\n          if (dist[vs[it][0]][v1] + dist[v1][v2] + dist[v2][vs[it][1]] > lens[it]) {\n            fail = 1;\n            break;\n          }\n        }\n        if (!fail) {\n          int value = dist[v1][v2] + dist[v1][vs[0][0]] + dist[v1][vs[1][0]] + dist[v2][vs[0][1]] + dist[v2][vs[1][1]];\n          res = min(res, value);\n        }\n      }\n    }\n    swap(vs[1][0], vs[1][1]);\n  }\n  res = m - res;\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  srand(rdtsc());\n#ifdef DEBUG\n  freopen(TASKNAME\".out\", \"w\", stdout);\n  assert(freopen(TASKNAME\".in\", \"r\", stdin));\n#endif\n\n  precalc();\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"%.18lf\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "shortest paths"], "dificulty": "2100", "interactive": false}