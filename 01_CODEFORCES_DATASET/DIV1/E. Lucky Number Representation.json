{
    "link": "https://codeforces.com//contest/354/problem/E",
    "problemId": "3670",
    "problem_idx": "E",
    "shortId": "354E",
    "contest_number": "354",
    "problem_submissions": {
        "D": [
            4777100,
            138831224,
            4787255
        ],
        "B": [
            4773542,
            4773611,
            4776468,
            4775805,
            4775193,
            4773708,
            4777067,
            4775769,
            4772925,
            4775400,
            4771413,
            4771906,
            4774887,
            4777860,
            4778618
        ],
        "E": [
            4771246,
            4771315,
            4769492,
            4772059,
            4772808,
            4771657,
            4773587,
            4773533,
            4773905,
            4774625,
            4774509,
            4772823,
            4772897,
            4776755,
            4773505,
            4773556,
            4773459
        ],
        "A": [
            4769568,
            4768918,
            4772027,
            4767693,
            4768128,
            4767864,
            4767903,
            4768032,
            4777935,
            4771459,
            4769551,
            4767761,
            4767775,
            4769653,
            4768177,
            4767934,
            4771768
        ],
        "C": [
            4768755,
            4770072,
            4771488,
            4770801,
            4770647,
            4775263,
            4770953,
            4771621,
            4770211,
            4772507,
            4775843,
            4771271,
            4771934,
            4770241,
            4775127,
            4769346
        ]
    },
    "name": "E. Lucky Number Representation",
    "statement": "We know that lucky digits are digits and , however Vasya’s got another\r\nfavorite digit and he assumes it also is lucky! Lucky numbers are such\r\nintegers whose decimal record only contains lucky digits. For example,\r\nnumbers are lucky, but - are not.Vasya has important positive integers\r\nhe needs to remember. Vasya is quite superstitious and he wants to\r\nremember lucky numbers only, so he is asking you for each important\r\nnumber to represent it as a sum of exactly six lucky numbers (Vasya just\r\ncan’t remember more numbers). Then Vasya can just remember these six\r\nnumbers and calculate the important number at any moment.For each of\r\nimportant integers represent it as the sum of six lucky numbers or state\r\nthat this is impossible.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint a[30];\nbool dp[30][10]; // pos, carry\nint c4[30][10],c7[30][10];\n\nll ten[20];\nll ans[10];\n\nvoid func(void){\n    int i,j,k,p,q;\n    \n    REP(i,30) REP(j,10) dp[i][j] = false;\n    dp[20][0] = true;\n    \n    for(i=19;i>=0;i--) REP(j,5){\n        REP(p,7) REP(q,7-p){\n            if((4*p+7*q+j) % 10 == a[i]){\n                int carry = (4*p+7*q+j) / 10;\n                if(dp[i+1][carry]){\n                    c4[i][j] = p;\n                    c7[i][j] = q;\n                    dp[i][j] = true;\n                }\n            }\n        }\n    }\n    \n    if(!dp[0][0]){\n        printf(\"-1\\n\");\n        return;\n    }\n    \n    REP(i,6) ans[i] = 0;\n    i = 0; j = 0;\n    \n    while(i <= 18){\n        p = c4[i][j];\n        q = c7[i][j];\n        REP(k,p) ans[k] += ten[i] * 4;\n        REP(k,q) ans[p+k] += ten[i] * 7;\n        j = (4*p+7*q+j) / 10;\n        i++;\n    }\n    \n    REP(i,6){\n        printf(\"%I64d\", ans[i]);\n        if(i == 5) printf(\"\\n\"); else printf(\" \");\n    }\n}\n\nint main(void){\n    int Q,i,j;\n    ll N;\n    \n    ten[0] = 1;\n    for(i=1;i<=18;i++) ten[i] = ten[i-1] * 10;\n    \n    cin >> Q;\n    \n    REP(i,Q){\n        cin >> N;\n    //  cout << N << endl;\n        REP(j,20){\n            a[j] = (int)(N % 10);\n            N /= 10;\n        }\n        func();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Lucky Number Representation.json",
    "editorial_link": "https://codeforces.com//blog/entry/8672",
    "editorial": "First of all, let write a DP with complexity , where is the count\nof lucky numbers , . As we can see, for all sufficiently large solution\nexists. Really for every . Now, we can say that for we have a solution,\nwhich is found using DP. Letâs solve the task for larger values of .\nNext and key idea is to separate the task into two parts: . Letâs choose\nand in such way that for them it was easy to find a solution and then\nmerge these two solutions into one. Let . Here we can have a problem\nthat there is no solution for number , in this case we can do . Now it\nis guaranteed that solutions exists for both and , moreover, the\nsolution for number will contain only numbers of not more than 3 digits\n. The proof is quite easy: if it is obvious; else if the solution uses\nsome number of the form , we can replace it with just and receive a\ncorrect solution for number (), but is doesnât exist! So, the solution\nfor number we have found using DP, now letâs find the solution for . If\nit will contains only of numbers of the form , then we will be able to\neasily merge this solution with solution for , so, letâs find such a\nsolution. Here we will use the fact that is divisible by 4. For\nsimplicity, letâs divide by 1000 and in the end multiply all by the same\n1000. Let . Now, letâs construct the solution. Consider, for example, P\n= 95: we will walk through digits of this number, last digit 5, means\nthat we want to put digit 4 at the last decimal position of five answer\nnumbers ok, put it and in the last, sixth, number leave there digit 0.\nGo forward, digit 9 we donât have nine numbers, but we can replace seven\nfours with four sevens, then to the second position we have to put ()\nfours and 4 sevens, in total 6 numbers, exactly as much as we have.\nThus, if next digit , we just put to the first answer numbers digit 4 to\nthe next position; if , then we put 4 sevens and fours. In all other\nnumbers we just leave digit 0 at this position. If answer for , for ,\nthe the answer for will be just . Time complexity for one number: .\nDuring the competition many participants have wrote the following\nsolution: can we put the digit to the last decimal positions of the\nanswer number in such way that we will get correct last digits in the\nsum and with carry to the next position equals to . Then the solution\nexist iff . To restore the answer we just have to remember for each\nstate the previous state. Base . Transition brute force how many fours\nand sevens we will put to the -th position.\n",
    "hint": []
}