{
    "link": "https://codeforces.com//contest/1290/problem/B",
    "problemId": "529278",
    "problem_idx": "B",
    "shortId": "1290B",
    "contest_number": "1290",
    "problem_submissions": {
        "C": [
            70096929,
            70064543,
            70052395,
            70054161,
            70047406,
            70047992,
            70053917,
            70053152,
            70054979,
            70214121,
            70054528,
            70058183,
            70057014,
            70052660,
            70052531,
            70060568,
            70059018,
            70063715,
            70055920,
            70058007,
            70059153,
            70056438
        ],
        "D": [
            70071102,
            70083418,
            70081951,
            70059761,
            70062540,
            70064117,
            70088222,
            70088118,
            70087893,
            70066142,
            71762685,
            70214194,
            70214147,
            70068516,
            70069978,
            70069936,
            70074018,
            70075546,
            70074118,
            70071674,
            70072917,
            70077679,
            70075595,
            70065164,
            70078630
        ],
        "F": [
            70059398,
            70084031,
            70111116,
            70110928,
            75833689,
            70089144,
            70131709
        ],
        "A": [
            70040962,
            70037530,
            70037805,
            70036026,
            70036076,
            70037499,
            70037219,
            70040023,
            70214047,
            70038241,
            70036901,
            70036876,
            70037974,
            70038261,
            70038975,
            70040060,
            70041968,
            70036027,
            70043312,
            70045091,
            70039900
        ],
        "B": [
            70038396,
            70041221,
            70041673,
            70039846,
            70040515,
            70043644,
            70043914,
            70045743,
            70214060,
            70047838,
            70043116,
            70043411,
            70045228,
            70046548,
            70048357,
            70051227,
            70051419,
            70047415,
            70062917,
            70075181,
            70045909
        ],
        "E": [
            70074704,
            70107871,
            70086286,
            70079191,
            70214607,
            70086883,
            70085799,
            70123893,
            70086530,
            70158475,
            70100288,
            70111014
        ]
    },
    "name": "B. Irreducible Anagrams",
    "statement": "Let\u2019s call two strings s and t of each other if it is possible to\r\nrearrange symbols in the string s to get a string, equal to t.Let\u2019s\r\nconsider two strings s and t . We say that t is a of s if there exists\r\nan integer k\r\nge 2 and 2k non-empty strings s_1, t_1, s_2, t_2,\r\ndots, s_k, t_k that satisfy the following conditions: If we write the\r\nstrings s_1, s_2,\r\ndots, s_k in order, the resulting string will be equal to s; If we write\r\nthe strings t_1, t_2,\r\ndots, t_k in order, the resulting string will be equal to t; For all\r\nintegers i between 1 and k inclusive, s_i and t_i are anagrams of each\r\nother. If such strings don\u2019t exist, then t is said to be an of s. .For\r\nexample, consider the string s = \"\". Then the string t = \"\" is a\r\nreducible anagram of s, we may choose for example s_1 = \"\", s_2 = \"\",\r\ns_3 = \"\" and t_1 = \"\", t_2 = \"\", t_3 = \"\": On the other hand, we can\r\nprove that t = \"\" is an irreducible anagram of s.You will be given a\r\nstring s and q queries, represented by two integers 1\r\nle l\r\nle r\r\nle |s| (where |s| is equal to the length of the string s). For each\r\nquery, you should find if the substring of s formed by characters from\r\nthe l-th to the r-th has irreducible anagram.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 02.02.2020 17:12:43       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int len = (int) s.size();\n  vector<int> nxt(len + 1);\n  for (int i = len - 2; i >= 0; i--) {\n    if (s[i] != s[i + 1]) {\n      nxt[i] = i + 1;\n    } else {\n      nxt[i] = nxt[i + 1];\n    }\n  }\n  vector<vector<int>> txn(len + 1, vector<int>(26, len));\n  for (int i = len - 1; i >= 0; i--) {\n    txn[i] = txn[i + 1];\n    txn[i][(char) (s[i] - 'a')] = i;\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int from, to;\n    cin >> from >> to;\n    --from; --to;\n    if (to - from + 1 == 1) {\n      cout << \"Yes\" << '\\n';\n      continue;\n    }\n    if (nxt[from] > to) {\n      cout << \"No\" << '\\n';\n      continue;\n    }\n    if (s[from] != s[to]) {\n      cout << \"Yes\" << '\\n';\n      continue;\n    }\n    int cnt = 0;\n    for (int c = 0; c < 26; c++) {\n      cnt += (txn[from][c] <= to);\n    }\n    if (cnt >= 3) {\n      cout << \"Yes\" << '\\n';\n      continue;\n    }\n    cout << \"No\" << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "strings",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Irreducible Anagrams.json",
    "editorial_link": "https://codeforces.com//blog/entry/73563",
    "editorial": "We claim that a string has at least one irreducible anagram if and only\r\nif one of the following conditions holds: Its length is equal to . Its\r\nfirst and last characters are different. It contains at least three\r\ndifferent characters. Once we have proven this characterization it is\r\neasy to solve the problem: For any given query, the first and second\r\nconditions are trivial to check, while the third condition can be\r\nchecked efficiently if we maintain the number of appearances of each\r\ncharacter in each prefix of our string. This allows us to answer queries\r\nin where is the size of our alphabet.Now let\u00e2\u0080\u0099s prove the\r\ncharacterization. Consider any string with . First note that for any two\r\nstrings and that are anagrams, it is enough to check that no two proper\r\nprefixes of them are anagrams for them to be irreducible anagrams,\r\nbecause if and are reducible then and are two proper prefixes that are\r\nanagrams. We will consider three cases. In what follows all indices are\r\n-based. If .Write all occurrences of in , and then write all the\r\nremaining characters of in any order. Every proper prefix of the\r\nresulting string will have more occurrences of than the corresponding\r\nprefix of , so no two of them will be anagrams. If and has at least\r\nthree different characters.Consider the last distinct character that\r\nappears in . Write all occurrences of it, followed by all occurrences of\r\n, and then write the remaining characters of in any order. We can check\r\nthat every proper prefix of the resulting strings contains more\r\noccurrences of either this last distinct character, or more occurrences\r\nof , than the corresponding prefix of , so no two proper prefixes are\r\nanagrams. If and has at most two different characters.Assume that only\r\nhas characters and , and that . Assume that has an irreducible anagram .\r\nThen , as otherwise and are anagrams.Consider the leftmost position such\r\nthat the prefix has appearances of as . We have because contains every\r\npossible appearance of . Moreover, we have . Now, notice that must have\r\nstrictly more appearances of than . This is only possible if this prefix\r\nhad one more appearance of , and then and have the same number of\r\nappearances of . But this means that the proper prefixes and are\r\nanagrams a contradiction.\r\n"
}