{
    "link": "https://codeforces.com//contest/1558/problem/E",
    "problemId": "1088953",
    "problem_idx": "E",
    "shortId": "1558E",
    "contest_number": "1558",
    "problem_submissions": {
        "F": [
            126899482,
            126888055,
            126902100,
            126890640,
            126888389,
            126894123,
            126904590,
            126900041,
            126902212,
            126902942,
            127549735,
            127006693
        ],
        "E": [
            126883583,
            126896785,
            126884151,
            126898148,
            126905418,
            126902611,
            126899238,
            126907028,
            126907352,
            126891363,
            126891974,
            126891356,
            126892061,
            126902546,
            126900088,
            126903655,
            126904227,
            126900317,
            126902700
        ],
        "D": [
            126869704,
            126870708,
            126871179,
            126874038,
            126874151,
            126876731,
            126871810,
            126867588,
            126872511,
            126871952,
            126882884,
            126882215,
            126882465,
            126878861,
            126876122,
            126890668,
            126874784,
            126883630,
            126892178,
            126890480
        ],
        "B": [
            126858181,
            126855670,
            126854102,
            126855872,
            126858058,
            126860085,
            126854841,
            126852806,
            126853901,
            126856718,
            126855353,
            126856232,
            126858032,
            126857658,
            126854131,
            126863721,
            126854756,
            126864821,
            126867061,
            126863501
        ],
        "A": [
            126854362,
            126850555,
            126848635,
            126848815,
            126849088,
            126855964,
            126848126,
            126847884,
            126848457,
            126849581,
            126847772,
            126849333,
            126852232,
            126849014,
            126848809,
            126853376,
            126847687,
            126859049,
            126849750,
            126850402
        ],
        "C": [
            126850882,
            126858888,
            126859482,
            126861350,
            126866099,
            126867225,
            126859442,
            126858664,
            126862495,
            126861859,
            126865577,
            126860578,
            126863128,
            126865366,
            126858535,
            126873768,
            126863562,
            126873408,
            126874458,
            126871983
        ]
    },
    "name": "E. Down Below",
    "statement": "In a certain video game, the player controls a hero characterized by a\r\nsingle integer value: .On the current level, the hero got into a system\r\nof n caves numbered from 1 to n, and m tunnels between them. Each tunnel\r\nconnects two distinct caves. Any two caves are connected with at most\r\none tunnel. Any cave can be reached from any other cave by moving via\r\ntunnels.The hero starts the level in cave 1, and every other cave\r\ncontains a monster.The hero can move between caves via tunnels. If the\r\nhero leaves a cave and enters a tunnel, he must finish his movement and\r\narrive at the opposite end of the tunnel.The hero can use each tunnel to\r\nmove in both directions. However, the hero use the same tunnel .\r\nFormally, if the hero has just moved from cave i to cave j via a tunnel,\r\nhe can not head back to cave i immediately after, but he can head to any\r\nother cave connected to cave j with a tunnel.It is known that at least\r\ntwo tunnels come out of every cave, thus, the hero will never find\r\nhimself in a dead end even considering the above requirement.To pass the\r\nlevel, the hero must beat the monsters in all the caves. When the hero\r\nenters a cave for the first time, he will have to fight the monster in\r\nit. The hero can beat the monster in cave i if and only if the hero’s\r\npower is strictly greater than a_i. In case of beating the monster, the\r\nhero’s power increases by b_i. If the hero can’t beat the monster he’s\r\nfighting, the game ends and the player loses.After the hero beats the\r\nmonster in cave i, all subsequent visits to cave i won’t have any\r\nconsequences: the cave won’t have any monsters, and the hero’s power\r\nwon’t change either.Find the smallest possible power the hero must start\r\nthe level with to be able to beat all the monsters and pass the level.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nusing ll = int64_t;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> a(n), b(n);\n\tfor(int i = 1; i < n; i++){\n\t\tcin >> a[i];\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tcin >> b[i];\n\t}\n\tvector<vector<int> > edges(n);\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tint s = -1;\n\tint e = int(1e9) + 1;\n\twhile(s + 1 < e){\n\t\tint mid = (s + e) / 2;\n\t\tvector<int> vis(n, 0);\n\t\tvis[0] = 1;\n\t\tvector<int> par(n, -1);\n\t\tll cpower = mid;\n\t\twhile(true){\n\t\t\tpar = vector<int>(n, -1);\n\t\t\tint found = -1;\n\t\t\tfor(int st = 0; st < n; st++){\n\t\t\t\tif(!vis[st]) continue;\n\t\t\t\tfor(int st2 : edges[st]){\n\t\t\t\t\tif(vis[st2]) continue;\n\t\t\t\t\ty_combinator(\n\t\t\t\t\t\t[&](auto self, int v, int p, ll power) -> void {\n\t\t\t\t\t\t\t// cerr << \"dfs \" << st << ' ' << st2 << ' ' << v << ' ' << p << ' ' << power << '\\n';\n\t\t\t\t\t\t\tif(found >= 0) return;\n\t\t\t\t\t\t\tif(power <= a[v]) return;\n\t\t\t\t\t\t\tif(vis[v]){\n\t\t\t\t\t\t\t\tfound = p;\n\t\t\t\t\t\t\t} else if(par[v] != -1){\n\t\t\t\t\t\t\t\tfound = v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpower += b[v];\n\t\t\t\t\t\t\t\tpar[v] = p;\n\t\t\t\t\t\t\t\tfor(int w : edges[v]){\n\t\t\t\t\t\t\t\t\tif(w == p) continue;\n\t\t\t\t\t\t\t\t\tself(w, v, power);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t)(st2, st, cpower);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found == -1) break;\n\t\t\tcpower += b[found];\n\t\t\tvis[found] = 1;\n\t\t\t// cerr << mid << ' ' << \"found \" << found << '\\n';\n\t\t}\n\t\tif(vis == vector<int>(n, 1)){\n\t\t\te = mid;\n\t\t} else {\n\t\t\ts = mid;\n\t\t}\n\t}\n\tcout << e << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "graphs",
        "greedy",
        "meet-in-the-middle",
        "shortest paths"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Down Below.json",
    "editorial_link": "https://codeforces.com//blog/entry/94216",
    "editorial": "Letâs find the smallest possible initial power with binary search.\r\nSuppose the initial power is .The main idea behind the solution is to\r\nmaintain a set of caves where we have beaten all the monsters, and try\r\nto extend the set by finding \"augmenting\" paths.However, we can not just\r\ngo in an arbitrary unvisited cave and pretend we add it to the set:\r\nsince we are not allowed to turn back, it might happen that we can not\r\nmove forward anymore because we donât have enough power. Itâs important\r\nthat we must be able to reach any cave inside the set only going through\r\ncaves belonging to the set itself.Initially, the set contains just cave\r\n.What can an augmenting path look like? The path can start somewhere\r\ninside the set, go out of the set, follow a simple route visiting some\r\nnew caves (and beating monsters inside them), and go back to a cave\r\nbelonging to the set. For example, if caves and belong to the set, the\r\nroute can look like , and we can add caves , , and to the set.\r\nAlternatively, instead of going back to a cave from the set, the path\r\nmight go into a cave . For example, if caves and belong to the set, the\r\nroute can look like , and we can add caves , , , and to the set. How do\r\nwe find any augmenting path satisfying us?It turns out that we can use\r\nthe following property. Suppose we have a path (where is the only cave\r\nbelonging to the set) that we can follow and beat all the monsters in\r\nthe caves we visit. Suppose that we have another such path . Suppose\r\nthat following the former path, we arrive at with the same or higher\r\npower than following the latter path. In this case, notice that is\r\nactually a valid augmenting path!Thus, we can simply use BFS or DFS to\r\nfind all reachable caves. Once we find a path leading back into the set,\r\nor we find two different paths leading into the same unvisited cave, we\r\ncan build an augmenting path, extend the set, and start over, until the\r\nset contains all caves (in which case we can try to decrease the initial\r\npower level ) or until we can not find any augmenting path (in which\r\ncase we must increase ).At each binary search iteration, we can have at\r\nmost augmenting paths and we find each of them in . Thus, the time\r\ncomplexity of the solution is .\r\n",
    "hint": []
}