{
    "link": "https://codeforces.com//contest/1434/problem/C",
    "problemId": "773400",
    "problem_idx": "C",
    "shortId": "1434C",
    "contest_number": "1434",
    "problem_submissions": {
        "E": [
            96677024,
            96703305,
            96695061,
            105543081,
            96703526,
            96698372
        ],
        "C": [
            96660091,
            96659353,
            96663643,
            96664995,
            96666231,
            96665833,
            96660295,
            96665975,
            96667697,
            96663270,
            96667899,
            96671631,
            96669472,
            96667880,
            96663509,
            96656865,
            96675583,
            96671215,
            96671994,
            96665979
        ],
        "B": [
            96653756,
            96655206,
            96656896,
            96653660,
            96657305,
            96660070,
            96656102,
            96658196,
            96659133,
            96653643,
            96661876,
            96658486,
            96660839,
            96661406,
            96658185,
            96654001,
            96679983,
            96658727,
            96658564,
            96660622
        ],
        "A": [
            96649454,
            96650673,
            96653179,
            96660619,
            96651935,
            96654803,
            96651530,
            96652454,
            96653264,
            96657461,
            96658652,
            96653143,
            96656680,
            96654396,
            96655185,
            96650897,
            96672264,
            96652811,
            96654828,
            96652745
        ],
        "D": [
            96673411,
            96677110,
            96683665,
            96678842,
            96678338,
            96679519,
            96679771,
            96683979,
            96680244,
            96683615,
            96681902,
            96685151,
            96688093,
            96669235,
            96686214,
            96686134,
            96682142
        ]
    },
    "name": "C. Solo mid Oracle",
    "statement": "Meka-Naruto plays a computer game. His character has the following\r\nability: given an enemy hero, deal a instant damage to him, and then\r\nheal that enemy b health points at the end of every second, for exactly\r\nc seconds, starting one second after the ability is used. That means\r\nthat if the ability is used at time t, the enemy\u2019s health decreases by a\r\nat time t, and then increases by b at time points t + 1, t + 2, ..., t +\r\nc due to this ability.The ability has a cooldown of d seconds, i. e. if\r\nMeka-Naruto uses it at time moment t, next time he can use it is the\r\ntime t + d. Please note that he can only use the ability at integer\r\npoints in time, so all changes to the enemy\u2019s health also occur at\r\ninteger times only.The effects from different uses of the ability may\r\nstack with each other; that is, the enemy which is currently under k\r\nspells gets k\r\ncdot b amount of heal this time. Also, if several health changes occur\r\nat the same moment, they are all counted at once.Now Meka-Naruto wonders\r\nif he can kill the enemy by just using the ability each time he can\r\n(that is, every d seconds). The enemy is killed if their health points\r\nbecome 0 or less. Assume that the enemy\u2019s health is not affected in any\r\nway other than by Meka-Naruto\u2019s character ability. What is the maximal\r\nnumber of health points the enemy can have so that Meka-Naruto is able\r\nto kill them?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 25.10.2020 14:23:37       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (a - b * c > 0) {\n      cout << -1 << '\\n';\n      continue;\n    }\n    long long step = b * d;\n    long long last = a % step;\n    long long first = a;\n    long long cnt = (first - last) / step + 1;\n    long long ans = (last + first) * cnt / 2;\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "math",
        "ternary search"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Solo mid Oracle.json",
    "editorial_link": "https://codeforces.com//blog/entry/84056",
    "editorial": "It will be easier to explain using illustrations. We will use timelines, where each cast spell instance will occupy a separate row; and each second will be represented as a column.\n\nFirst of all, if a>b?c\n then the answer is ?1\n. Indeed, after time t\n the total amount of damage dealt is (a?bc)\n for each spell which has expired completely plus some damage from spells which have not expired. The first summand can be as great as we want it to, and the second one is bounded by, say, ?bc2\n as there are at most c\n spells which have not yet expired, and each of them healed the enemy by at most b\n units each second, for at most c\n seconds. Therefore, the damage may be arbitrarily huge.\n\nOn the other hand, if a?bc\n, then the answer always exists, and here is why. First of all, let's only look at the moments divisible by d\n \u0097 that is, the moments when damage was dealt. It is obvious that for every other moment t\n the enemy had less (or the same amount of) health at time t?1\n. Second, if t?c\n, then the enemy had no more health than now at the moment t?d\n. Indeed, the difference between damages then and now is exactly one full-lasted spell, which is non-negative, as we know. For clarity take a look at the pictures below:\n\n\nSo now we know that we may consider only t<c\n, and it follows in particular that the answer exists. Also, when in general should we subtract d\n from t\n to obtain a more damaged enemy? One can see that if t<c\n then the damage we subtract is a?tb\n, and since t=dk\n for some integer nonnegative k\n, then we subtract a?bdk\n damage. It makes sense to do this while a?bdk<0\n:\n\n\nIn other words, we have reduced the task to the following: find the greatest k\n so that a?bdk\n, and cast the spell (k+1)\n time. The enemy will have the least amount of health just after we cast the spell for the (k+1)\n-st time. The answer is thus a(k+1)?k(k+1)2bd\n. The time complexity of this solution is O(1)\n per test.\n\nOne could also find out that the enemy's health is convex over time and use ternary search to find the minimum. It requires O(logmaxanswer)\n per test, which is still ok."
}