{
    "link": "https://codeforces.com//contest/704/problem/C",
    "problemId": "67579",
    "problem_idx": "C",
    "shortId": "704C",
    "contest_number": "704",
    "problem_submissions": {
        "D": [
            40927696,
            40927622,
            40927587,
            40927467,
            40927396,
            19704142,
            19710237,
            19708323,
            19774513,
            19774457,
            19774399,
            19764110,
            19708427,
            19756062,
            26821434,
            22052930
        ],
        "C": [
            19708702,
            23913352,
            19710963,
            19714551,
            19717256,
            19728619,
            19710982,
            19720592,
            22049772,
            19704534
        ],
        "B": [
            19698622,
            19822826,
            19698078,
            19696251,
            19698272,
            19697250,
            19698738,
            19697542,
            19699793,
            19700128,
            19700526,
            19700174,
            19702386,
            19697314,
            19708684,
            19700116
        ],
        "A": [
            19690324,
            19692784,
            19688619,
            19690302,
            19690344,
            19691492,
            19691120,
            19689897,
            19691217,
            19692269,
            19690729,
            19691407,
            19691187,
            19689858,
            19690147,
            19691829,
            19694517,
            19693111,
            19701512,
            19690489
        ],
        "E": [
            27277354,
            20669015,
            22073776,
            22073733
        ]
    },
    "name": "C. Black Widow",
    "statement": "Natalia Romanova is trying to test something on the new gun S.H.I.E.L.D\r\ngave her. In order to determine the result of the test, she needs to\r\nfind the number of answers to a certain equation. The equation is of\r\nform:Where represents logical OR and represents logical exclusive OR\r\n(XOR), and are some boolean variables or their negations. Natalia calls\r\nthe left side of the equation a XNF formula. Each statement in brackets\r\nis called a clause, and are called literals.In the equation Natalia has,\r\nthe left side is actually a 2-XNF-2 containing variables and their\r\nnegations. An XNF formula is 2-XNF-2 if: For each , , i.e. the size of\r\neach clause doesn’t exceed two. Each variable occurs (with negation and\r\nwithout negation in total). Please note that it’s possible that a\r\nvariable occurs twice but its negation doesn’t occur in any clause (or\r\nvice versa). Natalia is given a formula of variables, consisting of\r\nclauses. Please, make sure to check the samples in order to properly\r\nunderstand how the formula looks like.Natalia is more into fight than\r\ntheory, so she asked you to tell her the number of answers to this\r\nequation. More precisely, you need to find the number of ways to set\r\nwith and (out of total of ways) so that the equation is satisfied. Since\r\nthis number can be extremely large, you need to print the answer modulo\r\n.Please, note that some variable may appear twice in one clause, or not\r\nappear in the equation at all (but still, setting it to or gives\r\ndifferent ways to set variables).\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <cstdint>\n#include <climits>\n#include <numeric>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nstruct edge_t {\n  int next;\n  int mysign; // 1 if negation, 0 otherwise\n  int opsign; // 1 if negation, 0 otherwise\n  int edge_index;\n};\n\nint n, m;\nvector<vector<edge_t>> graph;\nvector<int> visit;\nvector<int> singleterm; // changes sign if + or -\n\nvector<bool> visit_edge;\n\npair<long long, long long> countChain(int s)\n{\n  int dp[2][2] = {0, 0, 0, 0}; // last value and total sign\n  visit[s] = 1;\n  if (singleterm[s] == 0) {\n    dp[0][0] = 1;\n    dp[1][0] = 1;\n  }\n  else if (singleterm[s] == 1) {\n    dp[0][0] = 1;\n    dp[1][1] = 1;\n  }\n  else if (singleterm[s] == -1) {\n    dp[0][1] = 1;\n    dp[1][0] = 1;\n  }\n  int prev = -1, cur = s;\n  for (;;) {\n    bool found = false;\n    for (const auto &edge : graph[cur]) {\n      if (visit_edge[edge.edge_index])\n        continue;\n      if (edge.next == prev)\n        continue;\n      visit_edge[edge.edge_index] = true;\n      found = true;\n      prev = cur;\n      cur = edge.next;\n      long long ndp[2][2] = { 0, 0, 0, 0 };\n      for (int pval = 0; pval < 2; pval++) {\n        for (int ptotal = 0; ptotal < 2; ptotal++) {\n          for (int cval = 0; cval < 2; cval ++) {\n            int edge_value = (pval^edge.mysign) | (cval^edge.opsign);\n            int vert_value = 0;\n            if (singleterm[cur] == 1 && cval)\n              vert_value = 1;\n            if (singleterm[cur] == -1 && cval == 0)\n              vert_value = 1;\n            ndp[cval][ptotal ^ edge_value ^ vert_value] += dp[pval][ptotal];\n          }\n        }\n      }\n      for (int i = 0; i < 2; i++)\n        for (int j = 0; j < 2; j++)\n          dp[i][j] = ndp[i][j] % mod;\n      visit[cur] = true;\n      break;\n    }\n    // end of chain\n    if (!found)\n      break;\n  }\n  long long ans0 = (dp[0][0] + dp[1][0]) % mod;\n  long long ans1 = (dp[0][1] + dp[1][1]) % mod;\n  return make_pair(ans0, ans1);\n}\n\npair<long long, long long> countCycle(int s)\n{\n  long long ans0 = 0;\n  long long ans1 = 0;\n  vector<int> vertexlist;\n  vector<edge_t> vedges;\n  {\n    int prev = -1, cur = s;\n    for (;;) {\n      vertexlist.push_back(cur);\n      visit[cur] = 1;\n      for (const auto &edge : graph[cur]) {\n        if (visit_edge[edge.edge_index])\n          continue;\n        visit_edge[edge.edge_index] = true;\n        vedges.push_back(edge);\n        prev = cur;\n        cur = edge.next;\n        break;\n      }\n      if (cur == s)\n        break;\n    }\n  }\n  for (int initvalue = 0; initvalue < 2; initvalue++) {\n    int dp[2][2] = { 0, 0, 0, 0 }; // last value and total sign\n    if (singleterm[s] == 0) {\n      if (initvalue == 0) dp[0][0] = 1;\n      if (initvalue == 1) dp[1][0] = 1;\n    }\n    else if (singleterm[s] == 1) {\n      if (initvalue == 0) dp[0][0] = 1;\n      if (initvalue == 1) dp[1][1] = 1;\n    }\n    else if (singleterm[s] == -1) {\n      if (initvalue == 0) dp[0][1] = 1;\n      if (initvalue == 1) dp[1][0] = 1;\n    }\n    for (int vv = 0; vv < vertexlist.size(); vv++) {\n      int prev = vertexlist[vv];\n      int next = vertexlist[(vv+1) % vertexlist.size()];\n      const auto &edge = vedges[vv];\n      long long ndp[2][2] = { 0, 0, 0, 0 };\n      for (int pval = 0; pval < 2; pval++) {\n        for (int ptotal = 0; ptotal < 2; ptotal++) {\n          for (int cval = 0; cval < 2; cval++) {\n            int edge_value = (pval^edge.mysign) | (cval^edge.opsign);\n            int vert_value = 0;\n            if (singleterm[next] == 1 && cval)\n              vert_value = 1;\n            if (singleterm[next] == -1 && cval == 0)\n              vert_value = 1;\n            ndp[cval][ptotal ^ edge_value ^ vert_value] += dp[pval][ptotal];\n          }\n        }\n      }\n      for (int i = 0; i < 2; i++)\n        for (int j = 0; j < 2; j++)\n          dp[i][j] = ndp[i][j] % mod;\n    }\n    ans0 += dp[initvalue][0];\n    ans1 += dp[initvalue][1];\n  }\n  ans0 %= mod;\n  ans1 %= mod;\n  return make_pair(ans0, ans1);\n}\n\nint main()\n{\n  scanf(\"%d%d\", &n, &m);\n  visit.resize(m);\n  singleterm.resize(m);\n  graph.resize(m);\n  int destsign = 1;\n  for (int i = 0; i < n; i++) {\n    int cnt;\n    scanf(\"%d\", &cnt);\n    if (cnt == 1) {\n      int a;\n      scanf(\"%d\", &a);\n      int ra = abs(a) - 1;\n      if (a < 0) {\n        if (singleterm[ra] == 0)\n        {\n          singleterm[ra] = -1;\n        }\n        else if (singleterm[ra] == 1) {\n          singleterm[ra] = 0;\n          destsign ^= 1;\n        }\n        else if (singleterm[ra] == -1) {\n          singleterm[ra] = 0;\n        }\n      }\n      else {\n        if (singleterm[ra] == 0)\n        {\n          singleterm[ra] = 1;\n        }\n        else if (singleterm[ra] == 1) {\n          singleterm[ra] = 0;\n        }\n        else if (singleterm[ra] == -1) {\n          singleterm[ra] = 0;\n          destsign ^= 1;\n        }\n      }\n    }\n    else {\n      int a, b;\n      scanf(\"%d%d\", &a, &b);\n      int ra = abs(a) - 1, rb = abs(b) - 1;\n      if (ra == rb) {\n        if (a != b) {\n          destsign ^= 1;\n        }\n        else {\n          if (a < 0) singleterm[ra] = -1;\n          else singleterm[ra] = 1;\n        }\n      }\n      else {\n        {\n          edge_t forward;\n          forward.next = rb;\n          forward.mysign = (a < 0);\n          forward.opsign = (b < 0);\n          forward.edge_index = i;\n          graph[ra].push_back(forward);\n        }\n        {\n          edge_t backward;\n          backward.next = ra;\n          backward.mysign = (b < 0);\n          backward.opsign = (a < 0);\n          backward.edge_index = i;\n          graph[rb].push_back(backward);\n        }\n      }\n    }\n  }\n  visit_edge.resize(n);\n  long long dp[2] = { 1, 0 };\n  for (int i = 0; i < m; i++) {\n    if (graph[i].size() <= 1 && visit[i] == 0) {\n      auto sub = countChain(i);\n      long long mul[2] = { sub.first, sub.second };\n      long long ndp[2] = { 0, 0 };\n      for (int j = 0; j < 2; j ++) {\n        for (int k = 0; k < 2; k++) {\n          ndp[j^k] += mul[j] * dp[k];\n          ndp[j^k] %= mod;\n        }\n      }\n      dp[0] = ndp[0];\n      dp[1] = ndp[1];\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    if (visit[i] == 0) {\n      auto sub = countCycle(i);\n      long long mul[2] = { sub.first, sub.second };\n      long long ndp[2] = { 0, 0 };\n      for (int j = 0; j < 2; j++) {\n        for (int k = 0; k < 2; k++) {\n          ndp[j^k] += mul[j] * dp[k];\n          ndp[j^k] %= mod;\n        }\n      }\n      dp[0] = ndp[0];\n      dp[1] = ndp[1];\n    }\n  }\n  long long ans = dp[destsign];\n  ans %= mod;\n  ans += mod;\n  ans %= mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "implementation",
        "math"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Black Widow.json",
    "editorial_link": "https://codeforces.com//blog/entry/46450",
    "editorial": "Build a graph. Assume a vertex for each clause. For every variable that appears twice in the clauses, add an edge between clauses it appears in (variables that appear once are corner cases). Every vertex in this graph has degree at most two. So, every component is either a cycle or a path. We want to solve the problem for a path component. Every edge either appear the same in its endpoints or appears differently. Denote a dp to count the answer. dp[i][j] is the number of ways to value the edges till i?-?th vertex in the path so that the last clause(i's) value is j so far (j is either 0 or 1). Using the last edge to update dp[i][j] from dp[i?-?1] is really easy in theory.\n\n \n\nCounting the answer for a cycle is practically the same, just that we also need another dimension in our dp for the value of the first clause (then we convert it into a path). Handling variables that appear once (edges with one endpoint, this endpoint is always an endpoint of a path component) is also hard coding. And finally we need to merge the answers.\n\nTime Complexity: ",
    "hint": []
}