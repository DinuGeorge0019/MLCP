{"link": "https://codeforces.com//contest/553/problem/D", "problemId": "30216", "problem_idx": "D", "shortId": "553D", "contest_number": "553", "problem_submissions": {"D": [11744562, 11744498, 11745257, 11745223, 11745470, 11745572, 11744919, 11745032, 11745427, 11746100, 11746456, 11746392, 11746335, 11745162, 11746455, 11746854, 11746886, 11745082], "C": [11742306, 11742552, 11743239, 11743506, 11742528, 11742781, 11742831, 11741480, 11743177, 11743672, 11744065, 11743860, 11743962, 11742856, 11745114, 11744324, 11744734, 11743321], "B": [11740294, 11741146, 11741320, 11741933, 11744161, 11741212, 11741622, 11743234, 11743626, 11740923, 11740570, 11741924, 11742141, 11741812, 11743960, 11742897, 11743061, 11741732], "A": [11739123, 11739635, 11739748, 11739276, 11740077, 11739044, 11739303, 11739327, 11739192, 11744185, 11739212, 11740023, 11739776, 11740185, 11741127, 11739503, 11739666], "E": [11751187, 11762331]}, "name": "D. Nudist Beach", "statement": "Nudist Beach is planning a military operation to attack the Life Fibers.\r\nIn this operation, they will attack and capture several cities which are\r\ncurrently under the control of the Life Fibers.There are cities, labeled\r\nfrom 1 to , and bidirectional roads between them. Currently, there are\r\nLife Fibers in every city. In addition, there are cities that are\r\nfortresses of the Life Fibers that cannot be captured under any\r\ncircumstances. So, the Nudist Beach can capture an arbitrary non-empty\r\nsubset of cities with no fortresses.After the operation, Nudist Beach\r\nwill have to defend the captured cities from counterattack. If they\r\ncapture a city and it is connected to many Life Fiber controlled cities,\r\nit will be easily defeated. So, Nudist Beach would like to capture a set\r\nof cities such that for each captured city the ratio of Nudist Beach\r\ncontrolled neighbors among all neighbors of that city is as high as\r\npossible. More formally, they would like to capture a non-empty set of\r\ncities with no fortresses of Life Fibers. The strength of a city is\r\ndefined as (number of neighbors of in ) / (total number of neighbors of\r\n). Here, two cities are called neighbors if they are connnected with a\r\nroad. The goal is to maximize the strength of the weakest city in .Given\r\na description of the graph, and the cities with fortresses, find a\r\nnon-empty subset that maximizes the strength of the weakest city.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5;\nconst int MAXM = 2e5;\n\nll N, M;\nll K;\n\nint F[MAXN];\n\nint V = 0;\nint vis[MAXN];\n\nvector<int> adj[MAXN];\n\nll good[MAXN];\nll tot[MAXN];\n\nstruct frac {\n\tll num, den;\n\tfrac(ll a, ll b) : num(a), den(b) {}\n};\ninline bool operator < (frac a, frac b) { return a.num * b.den < b.num * a.den; }\n\ninline bool operator > (frac a, frac b) { return b < a; }\n\ntypedef pair<frac, int> pfi;\n#define A first\n#define B second\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> N >> M >> K;\n\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> F[i];\n\t\tF[i] --;\n\t}\n\n\tfor(int i = 0; i < M; i++) {\n\t\tint a, b; cin >> a >> b; a--, b--;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\n\tfor(int i = 0; i < N; i++) {\n\t\ttot[i] = good[i] = ll(adj[i].size());\n\t}\n\n\tfor(int i = 0; i < K; i++) {\n\t\tint f = F[i];\n\t\tfor(int a : adj[f]) {\n\t\t\tgood[a] --;\n\t\t}\n\t\tvis[f] = -1;\n\t}\n\n\tpriority_queue<pfi, vector<pfi>, greater<pfi>> pq;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tif(vis[i]) continue;\n\t\tpq.push(pfi(frac(good[i], tot[i]), i));\n\t}\n\n\tfrac best(0, 1);\n\tint res = 0;\n\twhile(!pq.empty()) {\n\t\tint a = pq.top().B;\n\t\tfrac f = pq.top().A;\n\t\tpq.pop();\n\t\tif(vis[a]) continue;\n\n\t\tvis[a] = ++V;\n\n\t\tif(!(f < best) /* f >= best */) {\n\t\t\tbest = f;\n\t\t\tres = vis[a];\n\t\t}\n\n\t\tfor(int b : adj[a]) {\n\t\t\tgood[b] --;\n\t\t\tif(!vis[b]) pq.push(pfi(frac(good[b], tot[b]), b));\n\t\t}\n\t}\n\n\tassert(V == N - K);\n\tcout << V - res + 1 << '\\n';\n\tfor(int i = 0; i < N; i++) {\n\t\tif(vis[i] >= res) cout << i + 1 << ' ';\n\t}\n\tcout << '\\n';\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "graphs", "greedy"], "dificulty": "2300", "interactive": false}