{
    "link": "https://codeforces.com//contest/553/problem/D",
    "problemId": "30216",
    "problem_idx": "D",
    "shortId": "553D",
    "contest_number": "553",
    "problem_submissions": {
        "D": [
            11744562,
            11744498,
            11745257,
            11745223,
            11745470,
            11745572,
            11744919,
            11745032,
            11745427,
            11746100,
            11746456,
            11746392,
            11746335,
            11745162,
            11746455,
            11746854,
            11746886,
            11745082
        ],
        "C": [
            11742306,
            11742552,
            11743239,
            11743506,
            11742528,
            11742781,
            11742831,
            11741480,
            11743177,
            11743672,
            11744065,
            11743860,
            11743962,
            11742856,
            11745114,
            11744324,
            11744734,
            11743321
        ],
        "B": [
            11740294,
            11741146,
            11741320,
            11741933,
            11744161,
            11741212,
            11741622,
            11743234,
            11743626,
            11740923,
            11740570,
            11741924,
            11742141,
            11741812,
            11743960,
            11742897,
            11743061,
            11741732
        ],
        "A": [
            11739123,
            11739635,
            11739748,
            11739276,
            11740077,
            11739044,
            11739303,
            11739327,
            11739192,
            11744185,
            11739212,
            11740023,
            11739776,
            11740185,
            11741127,
            11739503,
            11739666
        ],
        "E": [
            11751187,
            11762331
        ]
    },
    "name": "D. Nudist Beach",
    "statement": "Nudist Beach is planning a military operation to attack the Life Fibers.\r\nIn this operation, they will attack and capture several cities which are\r\ncurrently under the control of the Life Fibers.There are cities, labeled\r\nfrom 1 to , and bidirectional roads between them. Currently, there are\r\nLife Fibers in every city. In addition, there are cities that are\r\nfortresses of the Life Fibers that cannot be captured under any\r\ncircumstances. So, the Nudist Beach can capture an arbitrary non-empty\r\nsubset of cities with no fortresses.After the operation, Nudist Beach\r\nwill have to defend the captured cities from counterattack. If they\r\ncapture a city and it is connected to many Life Fiber controlled cities,\r\nit will be easily defeated. So, Nudist Beach would like to capture a set\r\nof cities such that for each captured city the ratio of Nudist Beach\r\ncontrolled neighbors among all neighbors of that city is as high as\r\npossible. More formally, they would like to capture a non-empty set of\r\ncities with no fortresses of Life Fibers. The strength of a city is\r\ndefined as (number of neighbors of in ) / (total number of neighbors of\r\n). Here, two cities are called neighbors if they are connnected with a\r\nroad. The goal is to maximize the strength of the weakest city in .Given\r\na description of the graph, and the cities with fortresses, find a\r\nnon-empty subset that maximizes the strength of the weakest city.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5;\nconst int MAXM = 2e5;\n\nll N, M;\nll K;\n\nint F[MAXN];\n\nint V = 0;\nint vis[MAXN];\n\nvector<int> adj[MAXN];\n\nll good[MAXN];\nll tot[MAXN];\n\nstruct frac {\n\tll num, den;\n\tfrac(ll a, ll b) : num(a), den(b) {}\n};\ninline bool operator < (frac a, frac b) { return a.num * b.den < b.num * a.den; }\n\ninline bool operator > (frac a, frac b) { return b < a; }\n\ntypedef pair<frac, int> pfi;\n#define A first\n#define B second\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> N >> M >> K;\n\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> F[i];\n\t\tF[i] --;\n\t}\n\n\tfor(int i = 0; i < M; i++) {\n\t\tint a, b; cin >> a >> b; a--, b--;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\n\tfor(int i = 0; i < N; i++) {\n\t\ttot[i] = good[i] = ll(adj[i].size());\n\t}\n\n\tfor(int i = 0; i < K; i++) {\n\t\tint f = F[i];\n\t\tfor(int a : adj[f]) {\n\t\t\tgood[a] --;\n\t\t}\n\t\tvis[f] = -1;\n\t}\n\n\tpriority_queue<pfi, vector<pfi>, greater<pfi>> pq;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tif(vis[i]) continue;\n\t\tpq.push(pfi(frac(good[i], tot[i]), i));\n\t}\n\n\tfrac best(0, 1);\n\tint res = 0;\n\twhile(!pq.empty()) {\n\t\tint a = pq.top().B;\n\t\tfrac f = pq.top().A;\n\t\tpq.pop();\n\t\tif(vis[a]) continue;\n\n\t\tvis[a] = ++V;\n\n\t\tif(!(f < best) /* f >= best */) {\n\t\t\tbest = f;\n\t\t\tres = vis[a];\n\t\t}\n\n\t\tfor(int b : adj[a]) {\n\t\t\tgood[b] --;\n\t\t\tif(!vis[b]) pq.push(pfi(frac(good[b], tot[b]), b));\n\t\t}\n\t}\n\n\tassert(V == N - K);\n\tcout << V - res + 1 << '\\n';\n\tfor(int i = 0; i < N; i++) {\n\t\tif(vis[i] >= res) cout << i + 1 << ' ';\n\t}\n\tcout << '\\n';\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "graphs",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Nudist Beach.json",
    "editorial_link": "https://codeforces.com//blog/entry/18842",
    "editorial": "The algorithm idea works as follows: Start with all allowed nodes.\r\nRemove the node with the smallest ratio. Repeat. Take the best ratio\r\nover all iterations. Itâs only necessary to consider these subsets.\r\nProof for why. We say this process finds a ratio of at least p if and\r\nonly if there exists a subset with ratio at least p. Exists a subset\r\nwith ratio at least p => algorithm will find answer of at least p.\r\nFirst, observe that the ratio of any particular node only decreases\r\nthroughout the algorithm. Thus, all nodes in this subset initally have\r\nratio at least p. Then, the very first node that gets removed from this\r\nsubset must not have ratio smaller than p, thus the above algorithm will\r\nrecord an answer of at least p. Exists no subset with ratio at least p\r\n=> algorithm finds answer at most p. No subset with ratio at least p\r\nimplies every subset has ratio at most p. Thus, at every iteration of\r\nour algorithm, weâll get an answer of at most p, so weâre done. Thus, we\r\ncan see these are necessary and sufficient conditions, so weâre done.\r\nNow for efficient implementation, we can use a variant of Dijkstraâs.\r\nRecording the best subset must be done a bit more carefully as well.\r\nExample code: http://codeforces.com/contest/553/submission/11767581\r\n",
    "hint": []
}