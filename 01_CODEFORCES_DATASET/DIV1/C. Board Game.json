{
    "link": "https://codeforces.com//contest/533/problem/C",
    "problemId": "26204",
    "problem_idx": "C",
    "shortId": "533C",
    "contest_number": "533",
    "problem_submissions": {
        "A": [
            10758806,
            41260125,
            10758808,
            10802245,
            10802137,
            10804672
        ],
        "F": [
            10756507,
            10757309,
            10756418,
            10756618,
            10756621,
            10756168,
            10757079,
            10756058,
            10757142,
            10756771,
            10757619,
            10759646,
            10756355,
            10754977,
            10755266,
            10757451,
            10757215
        ],
        "B": [
            10754115,
            10753181,
            10753247,
            10758386,
            10754046,
            10755412,
            10754879,
            10754156,
            10755561,
            10754427,
            10755399,
            10754294,
            10754859,
            10753587,
            10753864,
            10753648,
            10756961,
            10754716,
            10755774
        ],
        "E": [
            10753290,
            10754938,
            10754117,
            10754867,
            10757574,
            10755405,
            10753428,
            10753036,
            10753133,
            10753451,
            10753117,
            10753877,
            10753615,
            10753601,
            10754357,
            10753173,
            10756615,
            10756357,
            10753749,
            10753638
        ],
        "C": [
            10753054,
            10753925,
            10753515,
            10754395,
            10759452,
            10754436,
            10754096,
            10753898,
            10753485,
            10759228,
            10753726,
            10753443,
            10753028,
            10753108,
            10754551,
            10754248,
            10757723,
            10757684,
            10753241,
            10754870
        ],
        "D": [
            10759362,
            10758040,
            10759441,
            10756824,
            10799120,
            10799069
        ]
    },
    "name": "C. Board Game",
    "statement": "Polycarp and Vasiliy love simple logical games. Today they play a game\r\nwith infinite chessboard and one pawn for each player. Polycarp and\r\nVasiliy move in turns, Polycarp starts. In each turn Polycarp can move\r\nhis pawn from cell to or . Vasiliy can move his pawn from to one of\r\ncells: and . are also allowed to skip move. There are some additional\r\nrestrictions a player is forbidden to move his pawn to a cell with\r\nnegative -coordinate or -coordinate or to the cell containing opponent\u2019s\r\npawn The winner is the first person to reach cell . You are given the\r\nstarting coordinates of both pawns. Determine who will win if both of\r\nthem play optimally well.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\nint X1,Y1,X2,Y2;\nvoid spr(){\n  int ruchy = X2 - X1;\n  if(ruchy <= 0)return;\n  int yy = max(0,Y2-ruchy);\n  int ruchy2 = Y1 - yy;\n  if(ruchy2 <= ruchy){\n    puts(\"Polycarp\");\n    exit(0);\n  }\n}\nmain(){\n  make2(X1,Y1);\n  make2(X2,Y2);\n  spr();\n  swap(X1,Y1);\n  swap(X2,Y2);\n  spr();\n  puts(\"Vasiliy\");\n  \n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Board Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/17458",
    "editorial": "We will consider three cases:\n\n1) xp?+?yp???max(xv,?yv). In this case Polycarp can be in (0,?0) after xp?+?yp moves and Vasiliy will always be ,,behind''. It's enough for Polycarp to make any move and he is always able to do it. It makes Polycarp closer to (0,?0) and after Vasiliy's move we again have xp?+?yp???max(xv,?yv) condition fulfilled and in some moment Polycarp will reach (0,?0). It's impossible that Vasiliy wins because our condition would be unfulfilled.\n\n2) xp???xv,?yp???yv. In this scenario Polycarp must block Vasiliy somehow. He must make such a move that after any Vasiliy's response condition will be fulfilled again.\n\nIf xp?=?xv?>?0 he goes to (xp?-?1,?yp).\nIf yp?=?yv?>?0 he goes to (xp,?yp?-?1).\nOtherwise he makes any move.\nWith this strategy Vasiliy is unable to get out of our new condition.\n\n3) Otherwise we can consider any shortest path to (0,?0) for Vasiliy. Lenght of it is max(xv,?yv). For any cell on this path Polycarp has greater distance than Vasiliy to it so he can't be there before Vasiliy and he can't block him. Vasiliy wins. Alternative explanation: after any possible Polycarp move Vasiliy can make a move that none of conditions (1) and (2) aren't fulfilled."
}