{
    "link": "https://codeforces.com//contest/607/problem/D",
    "problemId": "43766",
    "problem_idx": "D",
    "shortId": "607D",
    "contest_number": "607",
    "problem_submissions": {
        "E": [
            14958443,
            14961849,
            14961838,
            14961831,
            16737326
        ],
        "D": [
            14951724,
            14952244,
            14950470,
            14950039,
            14952208,
            14949972,
            14952659,
            14968005,
            14967954,
            14967922,
            14967912,
            14967907,
            14967903,
            14967896,
            14967707,
            14967669,
            14956925,
            14956428,
            14958812,
            14957599,
            14953577,
            14952372,
            14951711,
            14957330,
            14954653,
            14952137,
            14951821,
            14954577,
            14952711
        ],
        "C": [
            14947368,
            14953869,
            14954714,
            14954225,
            14954959,
            14954407,
            14957641,
            14951200,
            14952263,
            14949536,
            14956671,
            14955594,
            14955895,
            14951583,
            14957050
        ],
        "B": [
            14944943,
            14943843,
            14943439,
            14944195,
            14944079,
            14951944,
            14944759,
            14945484,
            14944543,
            14945215,
            14944778,
            14945950,
            14944649,
            14947158,
            14943778,
            14944962,
            14948034,
            14943374,
            14945989
        ],
        "A": [
            14941938,
            14942696,
            14942042,
            14943122,
            14941989,
            14950953,
            14942232,
            14942613,
            14942728,
            14942057,
            14942385,
            14946665,
            14948612,
            14942429,
            14941952,
            14943906,
            14943291,
            15059376,
            14942040,
            14942093
        ]
    },
    "name": "D. Power Tree",
    "statement": "Genos and Saitama went shopping for Christmas trees. However, a\r\ndifferent type of tree caught their attention, the exalted Power Tree. A\r\nPower Tree starts out as a single root vertex indexed . A Power Tree\r\ngrows through a magical phenomenon known as an update. In an , a single\r\nvertex is added to the tree as a child of some other vertex.Every vertex\r\nin the tree (the root and all the added vertices) has some value\r\nassociated with it. The of a vertex is defined as the strength of the\r\nmultiset composed of the value associated with this vertex () and the of\r\nits direct children. The of a multiset is defined as the sum of all\r\nelements in the multiplied by the number of elements in it. Or in other\r\nwords for some : Saitama knows the that will be performed on the tree,\r\nso he decided to test Genos by asking him queries about the tree during\r\nits growth cycle.An update is of the form , and adds a new vertex with\r\nvalue as a child of vertex .A query is of the form , and asks for the\r\npower of vertex .Please help Genos respond to these queries modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\ninline int fpm(LL b, int e, int m)\n{\n\tb %= m;\n\tLL t = 1;\n\tfor ( ; e; e >>= 1, (b *= b) %= m)\n\t\tif (e & 1) (t *= b) %= m;\n\treturn t;\n}\n\nconst int Mod = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 200000;\n\nint n;\n\nstruct node;\n \nnode *newnode();\n \nstruct node\n{\n\tnode *c[2];\n\n\tint sum;\n\tint label;\n \n\tnode(): sum(0), label(1) { memset(c, 0, sizeof c); }\n \n\tvoid update()\n\t{\n\t\tsum = 0;\n\t\tREP(i, 0, 2) if (c[i]) (sum += c[i]->sum) %= Mod;\n\t}\n\n\tvoid flag_label(int _label)\n\t{\n\t\tlabel = (LL)label * _label % Mod;\n\t\tsum = (LL)sum * _label % Mod;\n\t}\n\n\tvoid push_down()\n\t{\n\t\tif (label)\n\t\t{\n\t\t\tREP(i, 0, 2) c[i]->flag_label(label);\n\t\t\tlabel = 1;\n\t\t}\n\t}\n \n};\n\nconst int max0 = 100000;\n \nnode *nd_pool;\nint nd_res = 0;\n \nnode *newnode()\n{\n\tif (!nd_res) nd_pool = new node[max0], nd_res = max0;\n\treturn nd_pool + (--nd_res);\n}\n \nnode *rt;\n \nint seg_x, seg_y, seg_z;\n \nvoid add(node *&rt, int l, int r)\n{\n\tif (seg_x <= l && r <= seg_y)\n\t{\n\t\trt->flag_label(seg_z);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\trt->push_down();\n\tif (seg_x < mid) add(rt->c[0], l, mid);\n\tif (seg_y > mid) add(rt->c[1], mid, r);\n\trt->update();\n}\n\ninline bool seg_add(int x, int y, int z)\n{\n\tif (x >= y) return 0;\n\tseg_x = x, seg_y = y, seg_z = z;\n\tadd(rt, 0, n);\n\treturn 1;\n}\n\ninline void query(node *rt, int l, int r)\n{\n\tif (seg_x <= l && r <= seg_y)\n\t{\n\t\t(seg_z += rt->sum) %= Mod;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\trt->push_down();\n\tif (seg_x < mid) query(rt->c[0], l, mid);\n\tif (seg_y > mid) query(rt->c[1], mid, r);\n}\n\ninline int seg_query(int x, int y)\n{\n\tif (x >= y) return 0;\n\tseg_x = x, seg_y = y, seg_z = 0;\n\tquery(rt, 0, n);\n\treturn seg_z;\n}\n\nint pos[maxn + 5];\nint v[maxn + 5];\n\ninline void build(node *&rt, int l, int r)\n{\n\trt = newnode();\n\tif (r - l <= 1) \n\t{\n\t\trt->sum = v[pos[l]];\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(rt->c[0], l, mid);\n\tbuild(rt->c[1], mid, r);\n\trt->update();\n}\n\nstruct edge\n{\n\tint id, nxt;\n\n\tedge() { }\n\tedge(int _id, int _nxt): id(_id), nxt(_nxt) { }\n\n};\n\nedge e[maxn + 5];\nint st[maxn + 5], en = 0;\n\ninline void add_edge(int x, int y)\n{\n\te[en] = edge(y, st[x]), st[x] = en++;\n}\n\nint dfn[maxn + 5], End[maxn + 5];\nint tot = 0;\nint w[maxn + 5];\n\nint seq[maxn + 5], deg[maxn + 5];\nint fa[maxn + 5];\n\nvoid dfs(int x, int now)\n{\n\tpos[dfn[x] = tot++] = x;\n\tv[x] = (LL)w[x] * now % Mod;\n\tfor (int i = st[x]; i != -1; i = e[i].nxt)\n\t{\n\t\tint y = e[i].id;\n\t\tdfs(y, (LL)now * deg[y] % Mod);\n\t}\n\tEnd[x] = tot;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tmemset(st, -1, sizeof st), en = 0;\n\tint m;\n\tscanf(\"%d%d\", w, &m);\n\tn = 1;\n\tREP(i, 0, m)\n\t{\n\t\tint ty, p, v;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1) scanf(\"%d%d\", &p, &v), --p, fa[n] = p, ++deg[p], add_edge(p, n), seq[i] = n << 1, w[n++] = v;\n\t\telse scanf(\"%d\", &p), --p, seq[i] = p << 1 | 1;\n\t}\n\tREP(i, 0, n) ++deg[i];\n\tdfs(0, deg[0]);\n\tbuild(rt, 0, n);\n\tvector<int> ans;\n\tfor (int i = m - 1; i >= 0; --i)\n\t{\n\t\tint x = seq[i] >> 1;\n\t\tif (seq[i] & 1)\n\t\t{\n\t\t\tint tmp = seg_query(dfn[x], dfn[x] + 1);\n\t\t\tint tmp0 = seg_query(dfn[x], End[x]);\n\t\t\ttmp = (LL)tmp * fpm(w[x], Mod - 2, Mod) % Mod * fpm(deg[x], Mod - 2, Mod) % Mod;\n\t\t\tans.pb((LL)tmp0 * fpm(tmp, Mod - 2, Mod) % Mod);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tseg_add(dfn[x], dfn[x] + 1, 0);\n\t\t\tx = fa[x];\n\t\t\tint lyc = (LL)(deg[x] - 1) * fpm(deg[x], Mod - 2, Mod) % Mod;\n\t\t\t--deg[x];\n\t\t\tseg_add(dfn[x], End[x], lyc);\n\t\t}\n\t}\n\treverse(ALL(ans));\n\tfor (auto it : ans) printf(\"%d\\n\", it);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Power Tree71275.json",
    "editorial_link": "https://codeforces.com//blog/entry/22256",
    "editorial": "Let's solve a restricted version of the problem where all queries are about the root. First however, let us define some notation. In this editorial, we will use d(x) to denote the number of children of vertex x. If there is an update involved, d(x) refers to the value prior to the update.\n\nTo deal these queries, notice that each vertex within the tree has some contribution ci to the root power. This contribution is an integer multiple mi of each vertex's value vi, such that ci?=?miÂ·vi If we sum the contributions of every vertex, we get the power of the root.\n\nTo deal with updates, notice that adding a vertex u to a leaf p scales the multiplier of every vertex in p's subtree by a factor of . As for the contribution of u, notice that mu?=?mp.\n\nNow, in order to handle both queries and updates efficiently, we need a fast way to sum all contributions, a way to scale contributions in a subtree, and a way to add new vertices. This sounds like a job for ... a segment tree!\n\nWe all know segment trees hate insertions, so instead of inserting new vertices, we pre-build the tree with initial values 0, updating values instead of inserting new vertices. In order to efficiently support subtree modification, we construct a segment tree on the preorder walk of the tree, so that every subtree corresponds to a contiguous segment within the segment tree. This segment tree will store the contributions of each vertex and needs to support range-sum-query, range-multiply-update, and point-update (updating a single element). The details of implementing such a segment tree and are left as an exercise to the reader.\n\nArmed with this segment tree, queries become a single range-sum. Scaling the contribution in a subtree becomes a range-multiply (we don't need to worry about multiplying un-added vertices because they are set to 0). And adding a new vertex becomes a range-sum-query to retrieve the contribution of the parent, and then a point-set to set the contribution of the added vertex.\n\nFinally, to solve the full version of the problem, notice that the power of a non-root vertex w is a scaled down range sum in the segment tree. The value of the scale is , the proof of which is left as an exercise to the reader.",
    "hint": []
}