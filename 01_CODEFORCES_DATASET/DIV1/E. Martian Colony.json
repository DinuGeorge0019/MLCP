{"link": "https://codeforces.com//contest/154/problem/E", "problemId": "958", "problem_idx": "E", "shortId": "154E", "contest_number": "154", "problem_submissions": {"E": [1231038, 1230512, 1358194], "D": [1225676, 1226429, 1228394, 1228749, 1229408, 1228702, 1229077, 1223939, 1227964, 1479286, 1228630, 1225612, 1229806, 1227500, 1227060], "C": [1223619, 1223667, 1223145, 1226138, 1224320, 1226736, 1226231, 1230453, 1229461, 1479267, 1226553, 1226465, 1225747, 1230469, 1224292, 1224323], "B": [1222804, 1227642, 1224517, 1223990, 1223294, 1225469, 1223473, 1226506, 1224622, 1479175, 1224138, 1223064, 1223792, 1223935, 1223500, 1223955, 1223146, 1223079], "A": [1221382, 1221463, 1226241, 1221946, 1222395, 1223447, 1221860, 1224559, 1222303, 1479137, 1222840, 1221809, 1230571, 1221518, 1221796, 1222615, 1221718]}, "name": "E. Martian Colony", "statement": "The first ship with the Earth settlers landed on Mars. The colonists\r\nmanaged to build necessary structures on the surface of the planet\r\n(which can be regarded as a plane, and the construction can be regarded\r\nas points on it). But one day the scanners recorded suspicious activity\r\non the outskirts of the colony. It was decided to use the protective\r\nforce field generating system to protect the colony against possible\r\ntrouble.The system works as follows: the surface contains a number of\r\ngenerators of the field (they can also be considered as points). The\r\nactive range of each generator is a circle of radius centered at the\r\nlocation of the generator (the boundary of the circle is also included\r\nin the range). After the system is activated, it stretches the\r\nprotective force field . That is, the protected part is the of the\r\ngenerators\u2019 active ranges.The number of generators available to the\r\ncolonists is not limited, but the system of field generation consumes a\r\nlot of energy. More precisely, the energy consumption does not depend on\r\nthe number of generators, but it is directly proportional to the , which\r\nis protected by the field. Also, it is necessary that all the existing\r\nbuildings are located within the protected area.Determine the smallest\r\npossible area of the protected part of the surface containing all the\r\nbuildings.\r\n", "solutions": ["#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-9;\ninline double ABS(double a){\n    if(a<eps&&a>-eps)return 0;\n    return a<0?-a:a;\n}\ninline double SA(double a,double b){return ABS(a-b)<eps;}\nstruct XD{\n    double x,y;\n    XD(double xx=0,double yy=0):x(xx),y(yy){}\n    void get(){\n        scanf(\"%lf%lf\",&x,&y);\n    }\n    XD operator-(const XD& b)const{\n        return XD(x-b.x,y-b.y);\n    }\n    double operator*(const XD& b)const{\n        return x*b.x+y*b.y;\n    }\n    double operator^(const XD& b)const{\n        return x*b.y-y*b.x;\n    }\n    bool operator<(const XD& b)const{\n        return SA(y,b.y)?x<b.x:y<b.y;\n    }\n    double len(){\n        return sqrt(x*x+y*y);\n    }\n}in[100100];\nint stk[101000],sc;\ninline bool f(int a,int b,int c){\n    return ((in[b]-in[a])^(in[c]-in[a]))>0;\n}\nint too[101000],tc;\ndouble r;\ninline bool cyci(int a,int b,int c){\n    double d=(in[c]-in[a]).len();\n    double cd=-sqrt(r*r-d*d/4)/r;\n    double l1=(in[c]-in[b]).len();\n    double l2=(in[a]-in[b]).len();\n    double cd2=((in[c]-in[b])*(in[a]-in[b]))/l1/l2;\n  //  printf(\"cd=%lf cd2=%lf\\n\",cd,cd2);\n    return cd2<cd-eps;\n}\nint nex[101000],pre[101000];\nconst double pi=acos(-1);\ninline double qq(double d){\n    double a1=d/2*sqrt(r*r-d*d/4);\n    double th=asin(d/2/r);\n//    printf(\"%lf %lf %lf %lf\\n\",d,th,r*r*th/2,a1);\n    return r*r*th-a1;\n}\ninline double q(int a,int b){\n    double d=(in[a]-in[b]).len();\n    return qq(d);\n}\nint main(){\n    int n,i,j;\n    scanf(\"%d%lf\",&n,&r);\n    for(i=0;i<n;i++)in[i].get();\n    sort(in,in+n);\n    sc=0;\n    stk[sc++]=0;\n    for(i=1;i<n;i++){\n        while(sc>1&&!f(stk[sc-2],stk[sc-1],i))sc--;\n        stk[sc++]=i;\n    }\n    tc=0;\n    for(i=0;i<sc;i++)too[tc++]=stk[i];\n    sc=0;\n    stk[sc++]=n-1;\n    for(i=n-2;i>=0;i--){\n        while(sc>1&&!f(stk[sc-2],stk[sc-1],i))sc--;\n        stk[sc++]=i;\n    }\n    for(i=1;i<sc-1;i++)too[tc++]=stk[i];\n    for(i=0;i<tc;i++){\n   //     printf(\"#%d %d %lf %lf\\n\",i,too[i],in[too[i]].x,in[too[i]].y);\n        nex[i]=i+1;\n        pre[i]=i-1;\n    }\n    nex[tc-1]=0;\n    pre[0]=tc-1;\n    int lf1=0,p=0,ex=0;\n    while(1){\n        if(p!=lf1)ex=1;\n        int p2=nex[p];\n        int p3=nex[p2];\n        if(p3==p)break;\n        if(cyci(too[p],too[p2],too[p3])){\n      //      printf(\"%d %d %d\\n\",p,p2,p3);\n            nex[p]=p3;\n            pre[p2]=nex[p2]=-1;\n            pre[p3]=p;\n            lf1=p;\n            ex=0;\n        }else{\n            if(p==lf1&&ex)break;\n            p=nex[p];\n        }\n    }\n    int pp=p;\n    double ans=0;\n    for(i=nex[p];i!=p;i=nex[i]){\n        //printf(\"%d\\n\",i);\n        double aa=0;\n        aa+=(in[too[i]].x*in[too[nex[i]]].y-in[too[i]].y*in[too[nex[i]]].x)/2;\n        aa+=q(too[i],too[nex[i]]);\n//        printf(\"   %lf\\n\",q(i,nex[i]));\n        ans+=aa;\n    }\n   // printf(\"%d\\n\",p);\n    double aa=0;\n    aa+=(in[too[p]].x*in[too[nex[p]]].y-in[too[p]].y*in[too[nex[p]]].x)/2;\n    aa+=q(too[p],too[nex[p]]);\n//    printf(\"   %lf\\n\",q(p,nex[p]));\n    ans+=aa;\n    printf(\"%.10lf\\n\",ans);\n    //for(i=0;i<tc;i++)printf(\"%d %lf %lf\\n\",too[i],in[too[i]].x,in[too[i]].y);\n}\n"], "input": "", "output": "", "tags": ["geometry"], "dificulty": "3000", "interactive": false}