{
    "link": "https://codeforces.com//contest/154/problem/E",
    "problemId": "958",
    "problem_idx": "E",
    "shortId": "154E",
    "contest_number": "154",
    "problem_submissions": {
        "E": [
            1231038,
            1230512,
            1358194
        ],
        "D": [
            1225676,
            1226429,
            1228394,
            1228749,
            1229408,
            1228702,
            1229077,
            1223939,
            1227964,
            1479286,
            1228630,
            1225612,
            1229806,
            1227500,
            1227060
        ],
        "C": [
            1223619,
            1223667,
            1223145,
            1226138,
            1224320,
            1226736,
            1226231,
            1230453,
            1229461,
            1479267,
            1226553,
            1226465,
            1225747,
            1230469,
            1224292,
            1224323
        ],
        "B": [
            1222804,
            1227642,
            1224517,
            1223990,
            1223294,
            1225469,
            1223473,
            1226506,
            1224622,
            1479175,
            1224138,
            1223064,
            1223792,
            1223935,
            1223500,
            1223955,
            1223146,
            1223079
        ],
        "A": [
            1221382,
            1221463,
            1226241,
            1221946,
            1222395,
            1223447,
            1221860,
            1224559,
            1222303,
            1479137,
            1222840,
            1221809,
            1230571,
            1221518,
            1221796,
            1222615,
            1221718
        ]
    },
    "name": "E. Martian Colony",
    "statement": "The first ship with the Earth settlers landed on Mars. The colonists\r\nmanaged to build necessary structures on the surface of the planet\r\n(which can be regarded as a plane, and the construction can be regarded\r\nas points on it). But one day the scanners recorded suspicious activity\r\non the outskirts of the colony. It was decided to use the protective\r\nforce field generating system to protect the colony against possible\r\ntrouble.The system works as follows: the surface contains a number of\r\ngenerators of the field (they can also be considered as points). The\r\nactive range of each generator is a circle of radius centered at the\r\nlocation of the generator (the boundary of the circle is also included\r\nin the range). After the system is activated, it stretches the\r\nprotective force field . That is, the protected part is the of the\r\ngenerators\u2019 active ranges.The number of generators available to the\r\ncolonists is not limited, but the system of field generation consumes a\r\nlot of energy. More precisely, the energy consumption does not depend on\r\nthe number of generators, but it is directly proportional to the , which\r\nis protected by the field. Also, it is necessary that all the existing\r\nbuildings are located within the protected area.Determine the smallest\r\npossible area of the protected part of the surface containing all the\r\nbuildings.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-9;\ninline double ABS(double a){\n    if(a<eps&&a>-eps)return 0;\n    return a<0?-a:a;\n}\ninline double SA(double a,double b){return ABS(a-b)<eps;}\nstruct XD{\n    double x,y;\n    XD(double xx=0,double yy=0):x(xx),y(yy){}\n    void get(){\n        scanf(\"%lf%lf\",&x,&y);\n    }\n    XD operator-(const XD& b)const{\n        return XD(x-b.x,y-b.y);\n    }\n    double operator*(const XD& b)const{\n        return x*b.x+y*b.y;\n    }\n    double operator^(const XD& b)const{\n        return x*b.y-y*b.x;\n    }\n    bool operator<(const XD& b)const{\n        return SA(y,b.y)?x<b.x:y<b.y;\n    }\n    double len(){\n        return sqrt(x*x+y*y);\n    }\n}in[100100];\nint stk[101000],sc;\ninline bool f(int a,int b,int c){\n    return ((in[b]-in[a])^(in[c]-in[a]))>0;\n}\nint too[101000],tc;\ndouble r;\ninline bool cyci(int a,int b,int c){\n    double d=(in[c]-in[a]).len();\n    double cd=-sqrt(r*r-d*d/4)/r;\n    double l1=(in[c]-in[b]).len();\n    double l2=(in[a]-in[b]).len();\n    double cd2=((in[c]-in[b])*(in[a]-in[b]))/l1/l2;\n  //  printf(\"cd=%lf cd2=%lf\\n\",cd,cd2);\n    return cd2<cd-eps;\n}\nint nex[101000],pre[101000];\nconst double pi=acos(-1);\ninline double qq(double d){\n    double a1=d/2*sqrt(r*r-d*d/4);\n    double th=asin(d/2/r);\n//    printf(\"%lf %lf %lf %lf\\n\",d,th,r*r*th/2,a1);\n    return r*r*th-a1;\n}\ninline double q(int a,int b){\n    double d=(in[a]-in[b]).len();\n    return qq(d);\n}\nint main(){\n    int n,i,j;\n    scanf(\"%d%lf\",&n,&r);\n    for(i=0;i<n;i++)in[i].get();\n    sort(in,in+n);\n    sc=0;\n    stk[sc++]=0;\n    for(i=1;i<n;i++){\n        while(sc>1&&!f(stk[sc-2],stk[sc-1],i))sc--;\n        stk[sc++]=i;\n    }\n    tc=0;\n    for(i=0;i<sc;i++)too[tc++]=stk[i];\n    sc=0;\n    stk[sc++]=n-1;\n    for(i=n-2;i>=0;i--){\n        while(sc>1&&!f(stk[sc-2],stk[sc-1],i))sc--;\n        stk[sc++]=i;\n    }\n    for(i=1;i<sc-1;i++)too[tc++]=stk[i];\n    for(i=0;i<tc;i++){\n   //     printf(\"#%d %d %lf %lf\\n\",i,too[i],in[too[i]].x,in[too[i]].y);\n        nex[i]=i+1;\n        pre[i]=i-1;\n    }\n    nex[tc-1]=0;\n    pre[0]=tc-1;\n    int lf1=0,p=0,ex=0;\n    while(1){\n        if(p!=lf1)ex=1;\n        int p2=nex[p];\n        int p3=nex[p2];\n        if(p3==p)break;\n        if(cyci(too[p],too[p2],too[p3])){\n      //      printf(\"%d %d %d\\n\",p,p2,p3);\n            nex[p]=p3;\n            pre[p2]=nex[p2]=-1;\n            pre[p3]=p;\n            lf1=p;\n            ex=0;\n        }else{\n            if(p==lf1&&ex)break;\n            p=nex[p];\n        }\n    }\n    int pp=p;\n    double ans=0;\n    for(i=nex[p];i!=p;i=nex[i]){\n        //printf(\"%d\\n\",i);\n        double aa=0;\n        aa+=(in[too[i]].x*in[too[nex[i]]].y-in[too[i]].y*in[too[nex[i]]].x)/2;\n        aa+=q(too[i],too[nex[i]]);\n//        printf(\"   %lf\\n\",q(i,nex[i]));\n        ans+=aa;\n    }\n   // printf(\"%d\\n\",p);\n    double aa=0;\n    aa+=(in[too[p]].x*in[too[nex[p]]].y-in[too[p]].y*in[too[nex[p]]].x)/2;\n    aa+=q(too[p],too[nex[p]]);\n//    printf(\"   %lf\\n\",q(p,nex[p]));\n    ans+=aa;\n    printf(\"%.10lf\\n\",ans);\n    //for(i=0;i<tc;i++)printf(\"%d %lf %lf\\n\",too[i],in[too[i]].x,in[too[i]].y);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Martian Colony.json",
    "editorial_link": "https://codeforces.com//blog/entry/3969",
    "editorial": "We have to find the area of intersection of all circles containing the\r\ngiven set of points (it\u00e2\u0080\u0099s clear that the intersection has the least\r\narea, and we have an unlimited number of circles). First, what shape\r\ndoes such an intersection have? Its border contains some circle arcs of\r\nradius R meeting at some points of convex hull. If we determine which\r\npoints are present in the border, we can count the total area as the sum\r\nof polygon area and several circle segments. So, how to determine those\r\npoints? It\u00e2\u0080\u0099s clear that if there is a circle of radius R containing all\r\nthe points and having some of them on its border, then this particular\r\npoint is present in the border of the intersection. If we fix the circle\r\nand move it in some direction, it eventually will run into some point so\r\nwe can find at least one point. Then we can perform something similar to\r\n\u00e2\u0080\u009dpresent wrapping\u00e2\u0080\u009d go around the convex hull and support the set of the\r\nborder points while controlling the relative position of the arcs. While\r\nthis solution is fast, it is very hard to write and it was not assumed\r\nthat it should be written during the contest. There is much simpler\r\nsolution based on quite different idea. We build the convex hull of the\r\nset so that no three points lie on the same line. Let us take the very\r\nlarge R so that every point of convex hull is present in the\r\nintersection border. As we gradually decrease R, some points will start\r\nto disappear from the border. How to determine which point falls out\r\nfirst? For point u in the convex hull denote its left and right\r\nneighbours l(u) and r(u). It\u00e2\u0080\u0099s clear, that the first point to disappear\r\nwill be such point u which has the largest radius of circle going\r\nthrough u, l(u) and r(u) (when R becomes equal to this radius, two arcs\r\nwill merge into one in point u, while all the other will have joints in\r\nthem; we will call this radius critical for u). Then we remove u from\r\nconvex hull and do not take it into account. We repeat while the largest\r\ncritical radius is larger than R. The rest points will be exactly the\r\npoints forming the border. How to do this fast? Note that when we remove\r\nsome point from the set the critical radii will change only for its two\r\nneighbours. Let us store a priority queue containing critical radii\r\nalong with point numbers. On every iteration we extract the largest\r\ncritical radius, remove the corresponding point from the set, and\r\nrefresh the information about the neighbours in the queue. We repeat\r\nwhile the largest radius is greater than R. As we just simulate the\r\nprocess of R decreasing, everything works correctly. The complexity of\r\nthis procedure is O(n log n), as we have no more than n iterations and\r\non every iteration we perform the constant number of operations with the\r\nqueue of size at most n. There is an unclear case, when the border\r\ncontains only two points. Then on the last phase we have three points in\r\nthe set and the algorithm doesn\u00e2\u0080\u0099t have a clue which one to remove as\r\nthey have equal critical radii. But we know that the triangle with\r\nvertices in these points is obtuse-angled, as we cannot shrink the\r\ncircumcircle of an acute-angle triangle, as that would contradict with\r\nthe circle existence condition. So we have to remove the point with the\r\nobtuse angle.\r\n"
}