{"link": "https://codeforces.com//contest/1039/problem/C", "problemId": "215702", "problem_idx": "C", "shortId": "1039C", "contest_number": "1039", "problem_submissions": {"D": [42513714, 42511510, 42520062, 42506634, 42517597, 42520159, 42521567, 42523747, 42518726, 42517947, 42522840, 42517334, 42557382, 42552709, 42522292, 42521116, 42593278, 42593192, 42592919, 42592856, 42529738, 42525570, 42594801, 42594517, 42530840], "C": [42506498, 42504177, 42507968, 42513002, 42512024, 42513641, 42514946, 42508788, 42515591, 42512122, 42511727, 42516665, 42510178, 42514370, 42513831, 42505887, 42506202], "A": [42503958, 42503367, 42516900, 42503286, 42504774, 42503703, 42517670, 42510165, 42507659, 42503441, 42509759, 42530985, 42509802, 42525002, 42513799, 42511865], "B": [42501109, 42507268, 42505627, 42509001, 42507388, 42508900, 42510540, 42503816, 42504282, 42519348, 42522856, 42514032, 42504233, 42511724, 42514814, 42501808], "E": [44360079, 42649854, 42649543, 42648847, 42648674, 42648023, 42621125, 42617681, 42617609, 42617300]}, "name": "C. Network Safety", "statement": "The Metropolis computer network consists of n servers, each has an\r\nencryption key in the range from 0 to 2^k - 1 assigned to it. Let c_i be\r\nthe encryption key assigned to the i-th server. Additionally, m pairs of\r\nservers are directly connected via a data communication channel. Because\r\nof the encryption algorithms specifics, a data communication channel can\r\nonly be considered safe if the two servers it connects have encryption\r\nkeys. The initial assignment of encryption keys is guaranteed to keep\r\nall data communication channels safe.You have been informed that a new\r\nvirus is actively spreading across the internet, and it is capable to\r\nchange the encryption key of any server it infects. More specifically,\r\nthe virus body contains some unknown number x in the same aforementioned\r\nrange, and when server i is infected, its encryption key changes from\r\nc_i to c_i\r\noplus x, where\r\noplus denotes the bitwise XOR operation.Sadly, you know neither the\r\nnumber x nor which servers of Metropolis are going to be infected by the\r\ndangerous virus, so you have decided to count the number of such\r\nsituations in which all data communication channels remain safe.\r\nFormally speaking, you need to find the number of pairs (A, x), where A\r\nis some (possibly empty) subset of the set of servers and x is some\r\nnumber in the range from 0 to 2^k - 1, such that when all servers from\r\nthe chosen subset A and none of the others are infected by a virus\r\ncontaining the number x, all data communication channels remain safe.\r\nSince this number can be quite big, you are asked to find its remainder\r\nmodulo 10^9 + 7.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 500500;\nint n, m, k;\nll a[N];\nll p2[N];\nmap<ll, vector<pii>> G;\nint par[N];\nint sz[N];\n\nmap<int, int> toId;\nint getId(int v) {\n\tif (toId.count(v) > 0) return toId[v];\n\ttoId[v] = m;\n\tpar[m] = -1;\n\tsz[m] = 1;\n\treturn m++;\n}\n\nint getPar(int v) {\n\treturn par[v] == -1 ? v : par[v] = getPar(par[v]);\n}\nbool unite(int v, int u) {\n\tv = getPar(v);\n\tu = getPar(u);\n\tif (v == u) return false;\n\tif (sz[v] < sz[u]) swap(v, u);\n\tsz[v] += sz[u];\n\tpar[u] = v;\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tp2[i] = add(p2[i - 1], p2[i - 1]);\n\t}\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tll ans = p2[n + k];\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tG[a[v] ^ a[u]].push_back(mp(v, u));\n\t}\n\tfor (auto t : G) {\n\t\tvector<pii> g = t.second;\n\t\tm = 0;\n\t\ttoId.clear();\n\t\tint C = n;\n\t\tfor (pii s : g) {\n\t\t\tint v = getId(s.first), u = getId(s.second);\n\t\t\tif (unite(v, u)) C--;\n\t\t}\n\t\tans = sub(ans, p2[n]);\n\t\tans = add(ans, p2[C]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dsu", "graphs", "math", "sortings"], "dificulty": "2200", "interactive": false}