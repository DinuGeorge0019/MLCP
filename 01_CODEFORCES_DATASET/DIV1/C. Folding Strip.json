{
    "link": "https://codeforces.com//contest/1965/problem/C",
    "problemId": "2614997",
    "problem_idx": "C",
    "shortId": "1965C",
    "contest_number": "1965",
    "problem_submissions": {
        "F": [
            258465624,
            258627065,
            263837667,
            258481689
        ],
        "D": [
            258447727,
            258460812,
            258466117,
            258450218,
            258464835,
            258457510,
            258458513,
            258465971,
            259573719,
            258506961,
            258454027,
            258456282,
            258483429,
            258453210,
            258453791
        ],
        "C": [
            258425895,
            258434352,
            258433902,
            258442030,
            258433331,
            258429762,
            258434494,
            258427059,
            258424566,
            258435014,
            258430069,
            258434394,
            258430905,
            258434841,
            258457386,
            258428580,
            258429520,
            258434274
        ],
        "B": [
            258420424,
            258428605,
            258430303,
            258433453,
            258426877,
            258424079,
            258428403,
            258433720,
            259639909,
            258437552,
            258428917,
            258424298,
            258428062,
            258424086,
            258427169,
            258427222,
            258425398,
            258424422,
            258426595
        ],
        "A": [
            258418141,
            258418841,
            258425010,
            258419725,
            258419999,
            258418044,
            258419071,
            258418897,
            258418989,
            258419441,
            258418664,
            258419165,
            258419761,
            258418751,
            258419361,
            258418280,
            258427816,
            258420207
        ],
        "E": [
            258446500,
            258464809,
            258455602,
            258503208,
            258466942,
            258468402,
            258463371,
            258447373,
            258452406,
            258457290,
            258460561,
            258509487,
            258461569,
            302317911,
            258464177,
            258450702,
            258478527
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128914",
    "editorial": "Define the pattern of a (validly) folded strip to be the set of\r\ncharacters, in order, seen from above after all folds are made.It is\r\nalways possible to fold the strip in such a way that no two adjacent\r\ncharacters in the pattern are equal. If we fold in between every pair of\r\nequal characters, and don\u00e2\u0080\u0099t fold in between every pair of distinct\r\ncharacters, we will achieve this. This diagram shows one example of this\r\n(the red lines indicate where to fold, and the final pattern is ): This\r\nset of folds will always be valid because it ensures that all s in the\r\noriginal string are on odd indices and all s are on even indices (or\r\nvice versa).Also, there is only one obtainable pattern (up to reversal)\r\nthat is alternating in this way. It is never possible to fold in between\r\ntwo adjacent different characters, because that can never be part of a\r\nvalid folding, and if there exists a pair of adjacent equal characters\r\nthat you don\u00e2\u0080\u0099t fold in between, the pattern will not be alternating.We\r\ncan also show that the pattern formed by this process is always optimal.\r\nLet be any pattern obtained from a valid folding of . Notice that if we\r\nperform a valid fold on , that corresponds to a valid fold on , because\r\nwe can essentially \"compose\" the valid folding of into and the valid\r\nfolding of into one valid folding.So we can fold using the process\r\nabove, which will yield a pattern with alternating characters of length\r\nat most . Because the alternating pattern is unique for a given , it\r\nmust be the same (up to reversal) as the one described above. So the\r\nabove pattern is of size at most for any valid pattern , and is\r\ntherefore optimal.We can simulate the folding process to determine the\r\nfinal length.Complexity:\r\n",
    "name": "C. Folding Strip",
    "statement": "You have a strip of paper with a binary string s of length n. You can\r\nfold the paper in between any pair of adjacent digits.A set of folds is\r\nconsidered if after the folds, all characters that are on top of or\r\nbelow each other match. Note that all folds are made at the same time,\r\nso the characters don\u2019t have to match in between folds.For example,\r\nthese are valid foldings of s =\r\nmathtt{110110110011} and s =\r\nmathtt{01110}: The length of the folded strip is the length seen from\r\nabove after all folds are made. So for the two above examples, after the\r\nfolds shown above, the lengths would be 7 and 3, respectively.Notice\r\nthat for the above folding of s =\r\nmathtt{01110}, if we made either of the two folds on their own, that\r\nwould not be a valid folding. However, because we don\u2019t check for\r\nvalidity until all folds are made, this folding is valid.After\r\nperforming a set of valid folds, what is the minimum length strip you\r\ncan form?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;\u00a0void solve() {    int n;    std::cin >> n;        std::string s;    std::cin >> s;        int l = 0, r = 0;    int x = s[0] - '0';    int i = 0;    for (auto c : s) {        if (c - '0' == (x + i % 2 + 2) % 2) {            i++;            r = std::max(r, i);        } else {            i--;            l = std::min(l, i);        }    }    std::cout << r - l << \"\\n\";}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Folding Strip.json"
}