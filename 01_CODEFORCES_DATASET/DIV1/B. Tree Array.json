{
    "link": "https://codeforces.com//contest/1540/problem/B",
    "problemId": "1027087",
    "problem_idx": "B",
    "shortId": "1540B",
    "contest_number": "1540",
    "problem_submissions": {
        "E": [
            158665487,
            120671889,
            120671130,
            120611380
        ],
        "C2": [
            120605147,
            120568544,
            120579011,
            120588964,
            120605073,
            120569097,
            120574747,
            120608479,
            120579015,
            120598713,
            120577744,
            120597136,
            120595479,
            120616218,
            120596815,
            120598287
        ],
        "D": [
            120591057,
            120602670,
            120602293,
            120600949,
            120589579,
            120610881,
            120604354,
            120600348,
            120595403,
            120583946,
            120609085,
            120608380,
            120703598,
            120703586,
            120698836,
            120593678,
            120637556,
            120637415
        ],
        "C1": [
            120567535,
            120561594,
            120567326,
            120573306,
            120596169,
            120563211,
            120564500,
            120604433,
            120607536,
            120590343,
            120588571,
            120578785,
            120575407,
            120560194,
            120579656,
            120577149,
            120580975,
            120582010
        ],
        "B": [
            120551949,
            120542169,
            120552393,
            120556326,
            120559167,
            120545883,
            120578567,
            120557279,
            120559926,
            120559208,
            120581683,
            120555741,
            120556140,
            120587344,
            120581865,
            120550352,
            120557511,
            120561248,
            120559894
        ],
        "A": [
            120538111,
            120534681,
            120538291,
            120538440,
            120536907,
            120535163,
            120537026,
            120546671,
            120535419,
            120535827,
            120537631,
            120535887,
            120540241,
            120536295,
            120551816,
            120535724,
            120539352,
            120540330,
            120541623
        ]
    },
    "name": "B. Tree Array",
    "statement": "You are given a tree consisting of n nodes. You generate an array from\r\nthe tree by marking nodes one by one.Initially, when no nodes are\r\nmarked, a node is equiprobably chosen and marked from the entire tree.\r\nAfter that, until all nodes are marked, a node is equiprobably chosen\r\nand marked from the set of unmarked nodes with at least one edge to a\r\nmarked node. It can be shown that the process marks all nodes in the\r\ntree. The final array a is the list of the nodes\u2019 labels in order of the\r\ntime each node was marked.Find the expected number of inversions in the\r\narray that is generated by the tree and the aforementioned process.The\r\nnumber of inversions in an array a is the number of pairs of indices (i,\r\nj) such that i < j and a_i > a_j. For example, the array [4, 1, 3, 2]\r\ncontains 4 inversions: (1, 2), (1, 3), (1, 4), (3, 4).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//mint107 \u306f verify \u3057\u3066\u306d\u3048\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\ntemplate<class E>\nvc<E> get_tree_path(const vvc<E>&t,int a,int b){\n\tvc<E> res;\n\tauto rec=[&](auto self,int v,int p)->bool{\n\t\tif(v==b)return true;\n\t\tfor(auto e:t[v])if(e!=p){\n\t\t\tres.pb(e);\n\t\t\tif(self(self,e,v))return true;\n\t\t\tres.pop_back();\n\t\t}\n\t\treturn false;\n\t};\n\trec(rec,a,-1);\n\treturn res;\n}\n\nconst int nmax=205;\n\nmint dp[nmax][nmax];\n\nvoid slv(){\n\tconst mint inv2=mint(2).inv();\n\trep(i,nmax)dp[i][0]=0;\n\trep(i,nmax)dp[0][i]=1;\n\trng(i,1,nmax)rng(j,1,nmax){\n\t\tdp[i][j]=(dp[i-1][j]+dp[i][j-1])*inv2;\n\t}\n\t\n\tint n;cin>>n;\n\tauto t=readTree(n);\n\t\n\tauto getsub=[&](auto self,int v,int p)->int{\n\t\tint res=1;\n\t\tfor(auto to:t[v])if(to!=p)\n\t\t\tres+=self(self,to,v);\n\t\treturn res;\n\t};\n\t\n\tmint ans;\n\t\n\trep(a,n)rep(b,a){\n\t\tauto p=get_tree_path(t,a,b);\n\t\tp.insert(p.bg,a);\n\t\tvc<bool> z(n);\n\t\tfor(auto v:p)z[v]=true;\n\t\trep(i,si(p)){\n\t\t\tint v=p[i];\n\t\t\tint sum=1;\n\t\t\tfor(auto to:t[v])if(!z[to]){\n\t\t\t\tsum+=getsub(getsub,to,v);\n\t\t\t}\n\t\t\tans+=dp[i][si(p)-1-i]*sum;\n\t\t}\n\t}\n\t\n\tprint(ans/n);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "dp",
        "graphs",
        "math",
        "probabilities",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Tree Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/92199",
    "editorial": "Parsing through the problem statement, the process can be seen as\r\nchoosing a starting node and \"expanding\" the subtree of marked nodes to\r\nnodes adjacent to the marked component.Fixing a given root , the\r\nexpected value of the entire process is obviously the sum of the\r\nexpected values for a fixed root divided by . Find the contribution of\r\nthe inversion of two nodes where . The expected contribution for any\r\npair is equal to the probability that appears before with a given\r\nroot.Set . Note that, until reaching , every possible process still has\r\nthe same probability of reaching before as it did when the first node\r\nwas chosen. Therefore, we can assume that the process has reached and\r\ncalculate the probability from there. Once is reached, we now note that\r\nthe probability that the process \"gets closer\" to is always equal to the\r\nprobability of getting closer to .The problem can be rephrased as having\r\ntwo stacks of size and with an arbitrary to remove a node from one of\r\nthe two stack (and to nothing) and finding the probability that reaches\r\nzero before . However, it turns out that the actual probability does not\r\nmatter. We propose a function that defines the probability that a stack\r\nof size becomes before a stack of size . In fact a function exists and\r\nit is defined as . Intuitively, this is because the probability of\r\ndecreasing or decreasing is the same, so the probability of\r\ntransitioning the state we end up transitioning to is always the same,\r\nregardless of .So, the solution is clear. Iterate over and root at all\r\nnodes. Then at the given root, iterate over all pairs of node and add to\r\nthe answer. Finally, divide by . In total, the solution works in or .\r\n"
}