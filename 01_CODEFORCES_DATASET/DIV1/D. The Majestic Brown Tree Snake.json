{
    "link": "https://codeforces.com//contest/1381/problem/D",
    "problemId": "672687",
    "problem_idx": "D",
    "shortId": "1381D",
    "contest_number": "1381",
    "problem_submissions": {
        "D": [
            87591748,
            87572223,
            87570648,
            87582982,
            87586752,
            87583704,
            87583370,
            87582500,
            87584659,
            87587190,
            87585425,
            87584920,
            87586314,
            87587486,
            87594226,
            87586828,
            87594293,
            87591657
        ],
        "C": [
            87577674,
            87546464,
            87551239,
            87551679,
            87564770,
            87559807,
            87550092,
            87554512,
            87552473,
            87551783,
            87555903,
            87552429,
            87566646,
            87560357,
            87558905,
            87562842,
            87558315,
            87548663,
            87563323,
            87564320
        ],
        "E": [
            87567737,
            87589785,
            87589949,
            87596216,
            87640160,
            88159077
        ],
        "B": [
            87530540,
            87536246,
            87534741,
            87537123,
            87529700,
            87542854,
            87536901,
            87535443,
            87600036,
            87597446,
            87597372,
            87597147,
            87539002,
            87526278,
            87542730,
            87541737,
            87542797,
            87547230,
            87546945,
            87544725,
            87542982,
            87556756,
            87537375,
            87546524
        ],
        "A2": [
            87526192,
            87528075,
            87538920,
            87528594,
            87524934,
            87532953,
            87532583,
            87529096,
            87530902,
            87560515,
            87534125,
            87531636,
            87526735,
            87535144,
            87541660,
            87537924,
            87531704,
            87562447,
            87527622,
            87539527
        ],
        "A1": [
            87525285,
            87529682,
            87539163,
            87530199,
            87524566,
            87531985,
            87534339,
            87528864,
            87530298,
            87560684,
            87535197,
            87534155,
            87525747,
            87526142,
            87534462,
            87527522,
            87533953,
            87562626,
            87529570,
            87539110
        ]
    },
    "name": "D. The Majestic Brown Tree Snake",
    "statement": "There is an undirected tree of n vertices, connected by n-1\r\nbidirectional edges. There is also a snake stuck inside of this tree.\r\nIts head is at vertex a and its tail is at vertex b. The snake\u2019s body\r\noccupies all vertices on the unique simple path between a and b.The\r\nsnake wants to know if it can reverse itself that is, to move its head\r\nto where its tail started, and its tail to where its head started.\r\nUnfortunately, the snake\u2019s movements are restricted to the tree\u2019s\r\nstructure.In an operation, the snake can move its head to an adjacent\r\nvertex not currently occupied by the snake. When it does this, the tail\r\nmoves one vertex closer to the head, so that the length of the snake\r\nremains unchanged. Similarly, the snake can also move its tail to an\r\nadjacent vertex not currently occupied by the snake. When it does this,\r\nthe head moves one unit closer to the tail. Let\u2019s denote a snake\r\nposition by (h,t), where h is the index of the vertex with the snake\u2019s\r\nhead, t is the index of the vertex with the snake\u2019s tail. This snake can\r\nreverse itself with the movements (4,7)\r\nto (5,1)\r\nto (4,2)\r\nto (1, 3)\r\nto (7,2)\r\nto (8,1)\r\nto (7,4). Determine if it is possible to reverse the snake with some\r\nsequence of operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n\t#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n\t#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint n,a,b;\nvi adj[MX];\nint up[MX], down[MX],depth[MX],par[MX];\n\nvoid dfs(int x, int y) {\n\tdepth[x] = depth[y]+1; par[x] = y;\n\ttrav(t,adj[x]) if (t != y) {\n\t\tdfs(t,x);\n\t\tckmax(down[x],down[t]);\n\t}\n\tdown[x] ++;\n}\n\nint del(pi a, int b) {\n\tif (a.f == b) return a.s;\n\treturn a.f;\n}\n\nvoid ad(pi& a, int b) {\n\tif (a.f < b) swap(a.f,b);\n\tif (a.s < b) swap(a.s,b);\n}\n\nvoid dfs2(int x, int y) {\n\tpi p = {1+up[x],0};\n\ttrav(t,adj[x]) if (t != y) ad(p,1+down[t]);\n\ttrav(t,adj[x]) if (t != y) {\n\t\tup[t] = del(p,1+down[t]);\n\t\tdfs2(t,x);\n\t}\n}\n\nint getPath(int x, int y) {\n\tif (par[y] == x) return down[y]+1;\n\tassert(par[x] == y); return up[x]+1;\n}\n\nint len;\n\nbool visLef[MX], visRig[MX];\nint lefVal[MX], rigVal[MX];\n\nvoid genLefVal(int a, int b) {\n\tlefVal[a] = lefVal[b]-1;\n\ttrav(t,adj[a]) if (t != b) genLefVal(t,a);\n}\n\nvoid genRigVal(int a, int b) {\n\trigVal[a] = rigVal[b]+1;\n\ttrav(t,adj[a]) if (t != b) genRigVal(t,a);\n}\n\nbool stuck() {\n\tFOR(i,1,n+1) {\n\t\tvisLef[i] = visRig[i] = 0;\n\t}\n\tvi path = {b};\n\twhile (path.bk != a) path.pb(par[path.bk]);\n\treverse(all(path));\n\t//dbg(\"STUCK\");\n\tF0R(i,sz(path)) {\n\t\tint x = path[i]; lefVal[x] = rigVal[x] = i;\n\t\ttrav(t,adj[x]) {\n\t\t\tif (i && t == path[i-1]) continue;\n\t\t\tif (i+1 < sz(path) && t == path[i+1]) continue;\n\t\t\tdbg(path,x,t);\n\t\t\tgenLefVal(t,x); genRigVal(t,x);\n\t\t}\n\t}\n\t// dbg(\"MIDDLE\");\n\t// return 0;\n\tint bet = sz(path)-1;\n\tqueue<int> lef, rig;\n\tauto adRig = [&](int x) {\n\t\tif (visRig[x]) return;\n\t\tvisRig[x] = 1; rig.push(x);\n\t};\n\tauto adLef = [&](int x) {\n\t\tif (visLef[x]) return;\n\t\tvisLef[x] = 1; lef.push(x);\n\t};\n\tauto processLef = [&](int x) {\n\t\t// dbg(\"PROCESSLEF\",x);\n\t\t// trav(t,adj[x]) dbg(t,lefVal[t]);\n\t\ttrav(t,adj[x]) if (lefVal[t] < lefVal[x]) adLef(t);\n\t\tint ind = lefVal[x]+bet;\n\t\tif (0 <= ind && ind < sz(path)) adRig(path[ind]);\n\t};\n\tauto processRig = [&](int x) {\n\t\t// dbg(\"PROCESSRIG\",x);\n\t\ttrav(t,adj[x]) if (rigVal[t] > rigVal[x]) adRig(t);\n\t\tint ind = rigVal[x]-bet;\n\t\tif (0 <= ind && ind < sz(path)) adLef(path[ind]);\n\t};\n\tadLef(a), adRig(b);\n\twhile (sz(lef) || sz(rig)) {\n\t\tif (sz(lef)) {\n\t\t\tint x = lef.ft; lef.pop();\n\t\t\tprocessLef(x);\n\t\t}\n\t\tif (sz(rig)) {\n\t\t\tint x = rig.ft; rig.pop();\n\t\t\tprocessRig(x);\n\t\t}\n\t}\n\tint mn = 0, mx = bet;\n\tFOR(i,1,n+1) {\n\t\tif (visLef[i]) ckmin(mn,lefVal[i]);\n\t\tif (visRig[i]) ckmax(mx,rigVal[i]);\n\t}\n\tdbg(mn,mx);\n\tif (mx-bet < mn+bet) return 1;\n\treturn 0;\n}\n\nvoid solve() {\n\tre(n,a,b); FOR(i,1,n+1) adj[i].clear(), up[i] = 0, down[i] = 0, par[i] = 0, depth[i] = 0;\n\tF0R(i,n-1) {\n\t\tint x,y; re(x,y);\n\t\tadj[x].pb(y), adj[y].pb(x);\n\t}\n\t//exit(0);\n\tdfs(a,0); dfs2(a,0);\n\tlen = depth[b];\n\t// dbg(a,len);\n\t//FOR(i,1,n+1) dbg(i,up[i],down[i],depth[i]);\n\t//exit(0);\n\tbool three = 0;\n\tFOR(i,1,n+1) {\n\t\tvi v;\n\t\ttrav(t,adj[i]) v.pb(getPath(i,t));\n\t\tsort(rall(v));\n\t\t//dbg(i,v);\n\t\tif (sz(v) >= 3 && v[2] >= len) three = 1;\n\t}\n\tif (!three || stuck()) { //  \n\t\tps(\"NO\");\n\t\treturn;\n\t}\n\tps(\"YES\");\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) solve();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "greedy",
        "trees",
        "two pointers"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. The Majestic Brown Tree Snake.json",
    "editorial_link": "https://codeforces.com//blog/entry/80427",
    "editorial": "Let the length of the snake be .Let\u00e2\u0080\u0099s call a node a \"pivot\" if there\r\nexist three edge-disjoint paths of length extending from . Clearly, if\r\none of the snake\u00e2\u0080\u0099s endpoints (head or tail) can reach a pivot, then the\r\nsnake can rotate through these paths, reversing itself. I claim two\r\nthings: If a snake\u00e2\u0080\u0099s endpoint can reach some pivot, then it can reach\r\nall pivots. If a snake\u00e2\u0080\u0099s endpoint cannot reach a pivot, the snake cannot\r\nreverse itself. Let\u00e2\u0080\u0099s prove claim 1. Say there are two pivots and , and\r\na snake\u00e2\u0080\u0099s endpoint can reach . At most one edge from is on the path\r\nbetween and . So let\u00e2\u0080\u0099s put the snake in one of the other branches of .\r\nThen we can move the snake back through and on the path to .Let\u00e2\u0080\u0099s prove\r\nclaim 2. Consider the longest path in the tree. If it is impossible for\r\nthe snake to enter this path, we may delete the path without changing\r\nthe possible snake positions, so we apply induction on the smaller tree.\r\nOtherwise, if the snake can enter the path, we can show that it can\r\nnever leave. (And therefore, it is also initially in the path, because\r\nsnake moves are reversible.)Assume for contradiction that the snake can\r\nleave the path. Then in its last move leaving the path, it occupies a\r\nlength path from a node in the longest path. And because we said it was\r\nthe longest path, both of those branches must have length at least as\r\nwell. But then the snake\u00e2\u0080\u0099s endpoint is at a pivot, giving us a\r\ncontradiction. This completes the proof of claim 2.Now that we\r\nunderstand claims 1 and 2, how can we use them? First, we can detect if\r\nany node is a pivot using DP to find the longest 3 paths from each node.\r\nIf a pivot does not exist, we output . Otherwise, root the tree at the\r\npivot .Let\u00e2\u0080\u0099s move the snake back and forth in a greedy fashion like\r\nthis: Move the head to the deepest leaf it can reach. Then move the tail\r\nto the deepest leaf it can reach. And repeat. If at any point, one\r\nendpoint becomes an ancestor of the other, we can move the snake up to .\r\nOtherwise, if no more progress can be made (progress is determined by\r\nthe smallest reachable depth of an endpoint), then the snake cannot\r\nreverse itself. Clearly, the snake can only go back and forth times\r\nbefore progress stops.We can simulate the back-and-forth motion by\r\nanswering -th ancestor queries with binary lifting. Complexity is .It\u00e2\u0080\u0099s\r\nalso possible to achieve with two pointers. Consider the path of nodes\r\ninitially occupied by the snake, numbered from to . Each node has a\r\nsubtree of non-snake nodes. Let be the height of the non-snake subtree\r\nof node . We can maintain two pointers and , where is the maximum\r\nachievable index of the head, and is the minimum achievable index of the\r\ntail.We do a similar back-and-forth motion as in solution . Send the\r\nhead to the node that minimizes , then send the tail to the node that\r\nmaximizes , and repeat. The snake can reverse itself if and only if a\r\npivot exists and can swap places. Can you prove that the number of times\r\nthe snake must switch between moving the head and tail is ?\r\n"
}