{
    "link": "https://codeforces.com//contest/1685/problem/E",
    "problemId": "1410457",
    "problem_idx": "E",
    "shortId": "1685E",
    "contest_number": "1685",
    "problem_submissions": {
        "E": [
            158459552,
            158470179,
            158498551,
            158474226,
            158469548,
            163064811,
            163064579,
            162972274,
            161995310
        ],
        "D1": [
            158446537,
            158446179,
            158436497,
            158441308,
            158450152,
            158437819,
            158438771,
            158444550,
            158444057,
            158444961,
            158450485,
            158456436,
            158455279,
            158451423,
            158456717,
            158456702,
            158458839,
            158450419,
            158454329
        ],
        "C": [
            158440149,
            158436682,
            158456408,
            158436985,
            158433630,
            158430630,
            158430086,
            158437803,
            158438284,
            158438857,
            158446162,
            158444048,
            158440132,
            158447129,
            158447895,
            158449525,
            158447760,
            158457006,
            158449988
        ],
        "B": [
            158430617,
            158426337,
            158489620,
            158427132,
            158430769,
            158427058,
            158419568,
            158419647,
            158422845,
            158428180,
            158427930,
            158426993,
            158428289,
            158433041,
            158438360,
            158432708,
            158432524,
            158429703,
            158431029,
            158439177
        ],
        "A": [
            158416845,
            158416623,
            158416445,
            158417978,
            158414637,
            158414483,
            158414377,
            158414577,
            158419066,
            158418105,
            158416435,
            158417522,
            158415887,
            158415929,
            158418032,
            158416211,
            158417132,
            158417328,
            158424448
        ],
        "D2": [
            158457366,
            158450783,
            158467580,
            158467275,
            158561732,
            166382774,
            166382436
        ]
    },
    "name": "E. The Ultimate LIS Problem",
    "statement": "You are given a permutation p_1, p_2,\r\nldots, p_{2n+1} of integers from 1 to 2n+1. You will have to process q\r\nupdates, where the i-th update consists in swapping p_{u_i},\r\np_{v_i}.After each update, find any cyclic shift of p with LIS\r\nle n, or determine that there is no such shift. (Refer to the output\r\nsection for details).Here LIS(a) denotes the length of longest strictly\r\nincreasing subsequence of a..\r\n",
    "solutions": [
        "//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 500005;\n\nstruct ST\n{\n    int l, r;\n    ST *ch[2];\n    int lz;\n    int mn, mpl;\n} stp[maxn << 2], *root;\nvoid upd(ST *a)\n{\n    a->mn = min(a->ch[0]->mn, a->ch[1]->mn);\n    if (a->mn == a->ch[0]->mn) a->mpl = a->ch[0]->mpl;\n    else a->mpl = a->ch[1]->mpl;\n}\ninline void actlz(ST *a, int lz) {\n    a->lz += lz;\n    a->mn += lz;\n}\nvoid pushdown(ST *a) {\n    for (int i = 0; i < 2; i++)\n        actlz(a->ch[i], a->lz);\n    a->lz = 0;\n}\nint stcnt = 0;\nvoid bdtree(ST *a, int l, int r)\n{\n    a->l = l, a->r = r, a->lz = a->mn = 0, a->mpl = l;\n    if (l == r)\n        return;\n    int mid = (a->l + a->r) >> 1;\n    a->ch[0] = &stp[stcnt++];\n    a->ch[1] = &stp[stcnt++];\n    bdtree(a->ch[0], l, mid);\n    bdtree(a->ch[1], mid + 1, r);\n    upd(a);\n}\nvoid push(ST *a, int l, int r, int lz)\n{\n    if (a->l == l && a->r == r) {\n        actlz(a, lz);\n        return;\n    }\n    pushdown(a);\n    int mid = (a->l + a->r) >> 1;\n    if (r <= mid)\n        push(a->ch[0], l, r, lz);\n    else if (l > mid)\n        push(a->ch[1], l, r, lz);\n    else {\n        push(a->ch[0], l, mid, lz);\n        push(a->ch[1], mid + 1, r, lz);\n    }\n    upd(a);\n}\npi qr(ST *a, int l, int r) {\n    if (a->l == l && a->r == r)\n        return mp(a->mn, a->mpl);\n    pushdown(a);\n    int mid = (a->l + a->r) >> 1;\n    if (r <= mid)\n        return qr(a->ch[0], l, r);\n    else if (l > mid)\n        return qr(a->ch[1], l, r);\n    else\n        return min(qr(a->ch[0], l, mid), qr(a->ch[1], mid + 1, r));\n}\nint p[maxn], q[maxn]; // q : place of each\n\nint n, m;\nint md;\nint fl[maxn]; // 是否出错\nint totfl[2] = {0, 0};\nint chk(int a, int b, int c) {\n    int r = (q[b] - q[a] + n) % n;\n    int g = (q[c] - q[a] + n) % n;\n    return r < g;\n}\nvi ch[maxn];\nint ttp[maxn];\nvi ids[maxn]; // 每个点对应的需要check的\nint ccnt = 0;\nvoid push(int a, int b, int c, int tp) {\n    ccnt += 1;\n    ttp[ccnt] = tp;\n    ch[ccnt] = {a, b, c};\n    for (auto v : ch[ccnt])\n        ids[v].pb(ccnt);\n}\nvoid rec(int id) {\n    int tp = ttp[id];\n    totfl[tp] -= fl[id];\n    fl[id] = 1 ^ chk(ch[id][0], ch[id][1], ch[id][2]);\n    totfl[tp] += fl[id];\n}\nvoid upd(int id, int tp) {\n    if (p[id] == md) return ;\n    if (p[id] > md) push(root, id, n, tp);\n    else push(root, id, n, -tp);\n}\nvoid up1(int id) {\n    for (auto v : ids[id])\n        rec(v);\n}\nint cal() {\n    int pl = q[md];\n    pi cans = qr(root, 1, n); pi cc = qr(root, pl, pl);\n    if (cans.fi < cc.fi) return cans.se;\n    if (totfl[0]) return pl;\n    if (totfl[1]) return pl - 1;\n    return -1;\n}\nint main() {\n    cin >> n >> m;\n    n = 2 * n + 1;\n    root = &stp[stcnt++]; bdtree(root, 1, n);\n    md = (n + 1) / 2;\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &p[i]), q[p[i]] = i;\n    for (int i = 1; i <= md - 3; i++)\n        push(i, i + 1, i + 2, 0);\n    push(md, 1, 2, 0);\n    for (int i = md; i <= n - 2; i++)\n        push(i, i + 1, i + 2, 1);\n    \n    for (int i = 1; i <= n; i++)\n        upd(i, 1), up1(i);\n    for (int i = 1; i <= m; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        upd(u, -1);\n        upd(v, -1);\n        swap(p[u], p[v]);\n        int x = p[u], y = p[v]; swap(q[x], q[y]);\n        up1(x); up1(y);\n        upd(u, 1), upd(v, 1);\n        int ans = cal();\n        if (ans == n) ans = 0;\n        printf(\"%d\\n\", ans);\n    }\n    return (0-0); //<3\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. The Ultimate LIS Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/103198",
    "editorial": "Consider element . Replace for a while by , each element by , and each\r\nelement by . Itâs well-known that for an array of of and of there exists\r\na cyclic shift such that all its prefix sums are nonnegative (which is\r\nequivalent to the sequence of these s and s being balanced). Consider\r\nsuch cyclic shift for our array. Itâs easy to see now that in this cycle\r\nthere is no increasing subsequence of length at of element distinct from\r\n. Indeed, in such a subsequence we would have of s, and then of s, which\r\nwould mean that -th goes after the -th , meaning that the subsequence\r\nisnât balanced. So, if there is an increasing subsequence of length in\r\nthis shift, is in it.Letâs say there are elements before in this\r\nsubsequence and elements after in this subsequence. As -th goes before\r\n-th in this shift, we get that there are exactly elements in this shift\r\nbefore , and (similarly) exactly elements in this shift after . In\r\naddition, these two parts form (as ones and minus ones) two separate\r\nbalanced sequences.Now, consider a shift in which is the first element.\r\nItâs easy to see that if the condition above holds, then in this shift\r\nones and minus ones also form a balanced subsequence. If of this shift\r\nis , it must be the case that and ones form it, which implies that\r\nelements go clockwise in this permutation.Similarly, after considering a\r\nshift in which is the last element, we get that elements go clockwise in\r\nthis permutation.It turns out that if all the conditions above hold,\r\nthen all shifts have . Indeed, consider any shift, elements to the left\r\nof smaller than , , and elements to the right of larger than form an\r\nincreasing subsequence. From the fact that s and s are balanced we get\r\nthat numbers smaller than take at least half of the space before , and\r\nlarger than take at least half of the space after , so its length is at\r\nleast .With all this knowledge, how do we solve the problem?We will keep\r\ntrack of all the s and s with a segment tree, with queries \"smallest\r\nprefix sum on the subsegment\". When we need to provide the answer after\r\nthe update, we will do the following:Check if the circular segment from\r\nto is balanced. If not, find the shift that makes s and s balanced, its\r\nis at most .Then, check if go clockwise in the permutation. If not, then\r\nthe shift in which is the first element has .Then, check if go clockwise\r\nin the permutation. If not, then the shift in which is the last element\r\nhas .Otherwise, output .We check if go clockwise by saving the following\r\nsum: If itâs , they go clockwise, else not. We can update this sum in\r\nper query.Total complexity is per query.\r\n",
    "hint": []
}