{"link": "https://codeforces.com//contest/1685/problem/E", "problemId": "1410457", "problem_idx": "E", "shortId": "1685E", "contest_number": "1685", "problem_submissions": {"E": [158459552, 158470179, 158498551, 158474226, 158469548, 163064811, 163064579, 162972274, 161995310], "D1": [158446537, 158446179, 158436497, 158441308, 158450152, 158437819, 158438771, 158444550, 158444057, 158444961, 158450485, 158456436, 158455279, 158451423, 158456717, 158456702, 158458839, 158450419, 158454329], "C": [158440149, 158436682, 158456408, 158436985, 158433630, 158430630, 158430086, 158437803, 158438284, 158438857, 158446162, 158444048, 158440132, 158447129, 158447895, 158449525, 158447760, 158457006, 158449988], "B": [158430617, 158426337, 158489620, 158427132, 158430769, 158427058, 158419568, 158419647, 158422845, 158428180, 158427930, 158426993, 158428289, 158433041, 158438360, 158432708, 158432524, 158429703, 158431029, 158439177], "A": [158416845, 158416623, 158416445, 158417978, 158414637, 158414483, 158414377, 158414577, 158419066, 158418105, 158416435, 158417522, 158415887, 158415929, 158418032, 158416211, 158417132, 158417328, 158424448], "D2": [158457366, 158450783, 158467580, 158467275, 158561732, 166382774, 166382436]}, "name": "E. The Ultimate LIS Problem", "statement": "You are given a permutation p_1, p_2,\r\nldots, p_{2n+1} of integers from 1 to 2n+1. You will have to process q\r\nupdates, where the i-th update consists in swapping p_{u_i},\r\np_{v_i}.After each update, find any cyclic shift of p with LIS\r\nle n, or determine that there is no such shift. (Refer to the output\r\nsection for details).Here LIS(a) denotes the length of longest strictly\r\nincreasing subsequence of a..\r\n", "solutions": ["//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 500005;\n\nstruct ST\n{\n    int l, r;\n    ST *ch[2];\n    int lz;\n    int mn, mpl;\n} stp[maxn << 2], *root;\nvoid upd(ST *a)\n{\n    a->mn = min(a->ch[0]->mn, a->ch[1]->mn);\n    if (a->mn == a->ch[0]->mn) a->mpl = a->ch[0]->mpl;\n    else a->mpl = a->ch[1]->mpl;\n}\ninline void actlz(ST *a, int lz) {\n    a->lz += lz;\n    a->mn += lz;\n}\nvoid pushdown(ST *a) {\n    for (int i = 0; i < 2; i++)\n        actlz(a->ch[i], a->lz);\n    a->lz = 0;\n}\nint stcnt = 0;\nvoid bdtree(ST *a, int l, int r)\n{\n    a->l = l, a->r = r, a->lz = a->mn = 0, a->mpl = l;\n    if (l == r)\n        return;\n    int mid = (a->l + a->r) >> 1;\n    a->ch[0] = &stp[stcnt++];\n    a->ch[1] = &stp[stcnt++];\n    bdtree(a->ch[0], l, mid);\n    bdtree(a->ch[1], mid + 1, r);\n    upd(a);\n}\nvoid push(ST *a, int l, int r, int lz)\n{\n    if (a->l == l && a->r == r) {\n        actlz(a, lz);\n        return;\n    }\n    pushdown(a);\n    int mid = (a->l + a->r) >> 1;\n    if (r <= mid)\n        push(a->ch[0], l, r, lz);\n    else if (l > mid)\n        push(a->ch[1], l, r, lz);\n    else {\n        push(a->ch[0], l, mid, lz);\n        push(a->ch[1], mid + 1, r, lz);\n    }\n    upd(a);\n}\npi qr(ST *a, int l, int r) {\n    if (a->l == l && a->r == r)\n        return mp(a->mn, a->mpl);\n    pushdown(a);\n    int mid = (a->l + a->r) >> 1;\n    if (r <= mid)\n        return qr(a->ch[0], l, r);\n    else if (l > mid)\n        return qr(a->ch[1], l, r);\n    else\n        return min(qr(a->ch[0], l, mid), qr(a->ch[1], mid + 1, r));\n}\nint p[maxn], q[maxn]; // q : place of each\n\nint n, m;\nint md;\nint fl[maxn]; // \u662f\u5426\u51fa\u9519\nint totfl[2] = {0, 0};\nint chk(int a, int b, int c) {\n    int r = (q[b] - q[a] + n) % n;\n    int g = (q[c] - q[a] + n) % n;\n    return r < g;\n}\nvi ch[maxn];\nint ttp[maxn];\nvi ids[maxn]; // \u6bcf\u4e2a\u70b9\u5bf9\u5e94\u7684\u9700\u8981check\u7684\nint ccnt = 0;\nvoid push(int a, int b, int c, int tp) {\n    ccnt += 1;\n    ttp[ccnt] = tp;\n    ch[ccnt] = {a, b, c};\n    for (auto v : ch[ccnt])\n        ids[v].pb(ccnt);\n}\nvoid rec(int id) {\n    int tp = ttp[id];\n    totfl[tp] -= fl[id];\n    fl[id] = 1 ^ chk(ch[id][0], ch[id][1], ch[id][2]);\n    totfl[tp] += fl[id];\n}\nvoid upd(int id, int tp) {\n    if (p[id] == md) return ;\n    if (p[id] > md) push(root, id, n, tp);\n    else push(root, id, n, -tp);\n}\nvoid up1(int id) {\n    for (auto v : ids[id])\n        rec(v);\n}\nint cal() {\n    int pl = q[md];\n    pi cans = qr(root, 1, n); pi cc = qr(root, pl, pl);\n    if (cans.fi < cc.fi) return cans.se;\n    if (totfl[0]) return pl;\n    if (totfl[1]) return pl - 1;\n    return -1;\n}\nint main() {\n    cin >> n >> m;\n    n = 2 * n + 1;\n    root = &stp[stcnt++]; bdtree(root, 1, n);\n    md = (n + 1) / 2;\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &p[i]), q[p[i]] = i;\n    for (int i = 1; i <= md - 3; i++)\n        push(i, i + 1, i + 2, 0);\n    push(md, 1, 2, 0);\n    for (int i = md; i <= n - 2; i++)\n        push(i, i + 1, i + 2, 1);\n    \n    for (int i = 1; i <= n; i++)\n        upd(i, 1), up1(i);\n    for (int i = 1; i <= m; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        upd(u, -1);\n        upd(v, -1);\n        swap(p[u], p[v]);\n        int x = p[u], y = p[v]; swap(q[x], q[y]);\n        up1(x); up1(y);\n        upd(u, 1), upd(v, 1);\n        int ans = cal();\n        if (ans == n) ans = 0;\n        printf(\"%d\\n\", ans);\n    }\n    return (0-0); //<3\n}"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "3500", "interactive": false}