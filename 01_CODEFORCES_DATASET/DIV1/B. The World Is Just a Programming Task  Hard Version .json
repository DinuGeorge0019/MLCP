{
    "link": "https://codeforces.com//contest/1239/problem/B",
    "problemId": "445270",
    "problem_idx": "B",
    "shortId": "1239B",
    "contest_number": "1239",
    "problem_submissions": {
        "E": [
            63001388,
            63007812,
            63001212,
            62998603,
            62990662,
            63117343,
            63007827,
            63012207,
            63007702,
            63021047,
            63020870,
            63040886
        ],
        "D": [
            62993444,
            63002135,
            62996508,
            63001623,
            62995711,
            62993045,
            63000352,
            62994034,
            62999922,
            62999498,
            63002761,
            62998053,
            63001594,
            63004252,
            63000233,
            63002463,
            63005010,
            63003977,
            62998357
        ],
        "B": [
            62989194,
            62990960,
            62989442,
            62985984,
            62996888,
            63004499,
            62991996,
            62990441,
            62993848,
            62995834,
            62994077,
            62994574,
            62993602,
            63006960,
            62992838,
            62991953,
            62991668,
            63005078
        ],
        "A": [
            62977858,
            62978636,
            62977879,
            62980136,
            62977536,
            62989410,
            62977583,
            62981078,
            62979832,
            62980911,
            62979401,
            62984325,
            62979180,
            62979930,
            62979559,
            62978773,
            62979723,
            62981340,
            62977762,
            62982272
        ],
        "F": [
            63121011,
            63120329,
            63015127,
            63015060,
            63092303,
            63016718,
            63113841,
            63051142
        ],
        "C": [
            62999891,
            62991092,
            62996408,
            62989929,
            62996641,
            62997220,
            62997894,
            63001762,
            62998162,
            62999500,
            63034189,
            62998511,
            62992701,
            62998753,
            62995987,
            62998509,
            62994268
        ]
    },
    "name": "B. The World Is Just a Programming Task  Hard Version ",
    "statement": "This is a harder version of the problem. In this version, n\r\nle 300\r\n,000.Vasya is an experienced developer of programming competitionsâ€™\r\nproblems. As all great minds at some time, Vasya faced a creative\r\ncrisis. To improve the situation, Petya gifted him a string consisting\r\nof opening and closing brackets only. Petya believes, that the beauty of\r\nthe bracket string is a number of its cyclical shifts, which form a\r\ncorrect bracket sequence.To digress from his problems, Vasya decided to\r\nselect two positions of the string () and swap characters located at\r\nthis positions with each other. Vasya will apply this operation exactly\r\nonce. He is curious what is the maximum possible beauty he can achieve\r\nthis way. Please help him.We remind that bracket sequence s is called\r\ncorrect if: s is empty; s is equal to \"t\", where t is correct bracket\r\nsequence; s is equal to t_1 t_2, i.e. concatenation of t_1 and t_2,\r\nwhere t_1 and t_2 are correct bracket sequences. For example, \"\", \"\" are\r\ncorrect, while \"\" and \"\" are not.The cyclical shift of the string s of\r\nlength n by k (0\r\nleq k < n) is a string formed by a concatenation of the last k symbols\r\nof the string s with the first n - k symbols of string s. For example,\r\nthe cyclical shift of string \"\" by 2 equals \"\".Cyclical shifts i and j\r\nare considered different, if i\r\nne j.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MOD = 1e9+7;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nint n, mini;\nint mcnt, ans, ta=1, tb=1;\nchar str[300100];\nint sum[600100];\n\nvoid solve(int s, int e) {\n    int cnt1 = 0;\n    for (int i=s;i<e;i++) {\n        if (sum[i]==mini+1) cnt1++;\n    }\n    if (ans<cnt1) {\n        ta=s;tb=e;\n        ans=cnt1;\n    }\n    int cnt2 = 0, p=s, tcnt = 0;\n    for (int i=s+1;i<e;i++) {\n        if (sum[i]==mini+1) {\n            if (ans<tcnt+mcnt) {\n                ans=tcnt+mcnt;\n                ta=p+1;\n                tb=i;\n            }\n            p=i;\n            tcnt=0;\n        }\n        if (sum[i]==mini+2) tcnt++;\n    }\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    scanf(\"%s\",str+1);\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(str[i]=='('?1:-1);\n    if (sum[n]) {\n        puts(\"0\");\n        puts(\"1 1\");\n        return 0;\n    }\n    for (int i=1;i<=n;i++) mini = min(mini,sum[i]);\n    for (int i=n+1;i<=2*n;i++) sum[i]=sum[i-n];\n    for (int i=1;i<=n;i++) {\n        if (sum[i]==mini)mcnt++;\n    }\n    if (ans<mcnt) {\n        ans=mcnt;\n    }\n    int ploc = -1;\n    for (int i=1;i<=n*2;i++) {\n        if (sum[i]==mini) {\n            if (~ploc) {\n                solve(ploc+1,i);\n            }\n            ploc = i;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    printf(\"%d %d\\n\",(ta>n?ta-n:ta),(tb>n?tb-n:tb));\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. The World Is Just a Programming Task  Hard Version .json",
    "editorial_link": "https://codeforces.com/blog/entry/70720",
    "editorial": "Note first that the number of opening brackets must be equal to the\r\nnumber of closing brackets, otherwise the answer is always . The answer\r\nfor a bracket sequence is the same as the answer for any of its cyclic\r\nshifts. Then find index of the minimum balance and perform a cyclic\r\nshift of the string by i to the left. The resulting line never has a\r\nbalance below zero, which means it is a correct bracket sequence.\r\nFurther we will work only with itLet us draw on the plane the prefix\r\nbalances (the difference between the number of opening and closing\r\nbrackets) of our correct bracket sequence in the form of a polyline. It\r\nwill have a beginning at , an end at and its points will be in the upper\r\nhalf-plane. It can easily be shown that the answer to the question of\r\nthe number of cyclic shifts being correct bracket sequence is the number\r\nof times how much minimum balance is achieved in the array of prefix\r\nbalances. For example, for string , the array of prefix balances is ,\r\nand the number of cyclic shifts, the number of minimums in it (). After\r\nswapping two different brackets ( and ), either on some sub-segment in\r\nan array of balances is added, or on some sub-segment is added. In the\r\nfirst case (as you can see from the figure above), the minimum remains\r\nthe same as it was , and its number does not increase due to the\r\naddition of to some sub-section of the array. So, there is no profit in\r\nswapping brackets in this case.In the second case, there are three\r\noptions: the minimum becomes equal to , or . In the first case, the\r\nminimum reaches a value equal to only at those points at which there was\r\npreviously value equal to , so this answer will less or equal than the\r\none that would have turned out, if no operations were applied to the\r\narray at all.If the minimum becomes equal to , then on the segment in\r\nthe balance array on which was deducted as a result of this operation\r\nthere could not be balances equal to , otherwise the new minimum would\r\nbecome equal to . So, if positions of minimums in the array of prefix\r\nbalances, then the operation was performed on the segment ( for some ).\r\nAfter this operation, the number of local minimums will be equal to the\r\nnumber of elements of the array of balance on the segment , equal to .\r\nSince this number shall be maximized, the right border swall be\r\nmaximised and the left border shall be minimised. So, for some fixed it\r\nis optimal to swap -th and -th brackets (see following figure) If the\r\nminimum remains equal to , then using the reasoning similar to the\r\nreasoning above, it can be proven that for some if we consider points\r\npositions of in the array of balances on the segment , it is optimal for\r\nsome to swap and brackets (see following figure) Thus, we have the\r\nsolution of complexity we shall find all , and count on each of the\r\nsegments of the form or the number of elements equal to , , , then\r\naccording to reasonings above, maximal answer can be found.\r\n",
    "hint": []
}