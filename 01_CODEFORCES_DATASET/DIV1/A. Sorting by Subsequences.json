{
    "link": "https://codeforces.com//contest/843/problem/A",
    "problemId": "119861",
    "problem_idx": "A",
    "shortId": "843A",
    "contest_number": "843",
    "problem_submissions": {
        "D": [
            86210957,
            86210473,
            29756854,
            34937670,
            29781848,
            29781833,
            29781501,
            29855864,
            30128230,
            42158478,
            42158439,
            30022222,
            29772717
        ],
        "C": [
            29753044,
            29759187,
            29746479,
            29758195,
            29749173,
            29747919,
            29747700,
            29750057,
            29750292,
            29751827,
            29751575,
            29754184,
            29754916,
            29751833,
            29755015,
            29755103,
            29756089,
            29752710
        ],
        "E": [
            29748360,
            29749250,
            29756319,
            29752227,
            29761679,
            29956114,
            29762394,
            35205556,
            29781472,
            29754090,
            29761229,
            29762324,
            42187009
        ],
        "A": [
            29740862,
            29750546,
            29737212,
            29736679,
            29736752,
            29736447,
            29736902,
            29737823,
            29737375,
            29738506,
            29737473,
            29738082,
            29739251,
            29737566,
            29736802,
            29738724,
            29737891,
            29739246,
            29738315
        ],
        "B": [
            29755133,
            29757158,
            29758427,
            29740669,
            29739815,
            29741358,
            29743424,
            29741532,
            29745306,
            29741855,
            29742825,
            29744139,
            29742831,
            29742430,
            29744161,
            29746567,
            29746080,
            29746122
        ]
    },
    "name": "A. Sorting by Subsequences",
    "statement": "You are given a sequence consisting of integers. It is required to split\r\nthis sequence into the number of subsequences such that after sorting\r\nintegers in each of them in increasing order, the total sequence also\r\nwill be sorted in increasing order.Sorting integers in a subsequence is\r\na process such that the numbers included in a subsequence are ordered in\r\nincreasing order, and the numbers which are not included in a\r\nsubsequence don\u2019t change their places.Every element of the sequence must\r\nappear in exactly one subsequence.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\n// ========================================================================= //\n\nconst int N = 100179;\n\nint n;\nipair a[N];\nvector < int > e[N];\nvector < vector < int > > ans;\nbool vis[N];\nvoid dfs(int v) {\n    if (vis[v])\n        return;\n    ans.back().push_back(v);\n    vis[v] = 1;\n    for (int x : e[v])\n        dfs(x);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &a[i].X);\n        a[i].Y = i;\n    }\n\n    sort(a, a + n);\n    for (int i = 0; i < n; ++i) {\n        e[i].push_back(a[i].Y);\n        e[a[i].Y].push_back(i);\n    }\n\n    for (int i = 0; i < n; ++i)\n        if (!vis[i]) {\n            ans.push_back(vector<int>());\n            dfs(i);\n        }\n    cout << sz(ans) << \"\\n\";\n    for (auto&xx:ans) {\n        sort(xx.begin(), xx.end());\n        cout << sz(xx);\n        for (int x : xx)\n            cout << \" \" << x+1;\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "implementation",
        "math",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Sorting by Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/54029",
    "editorial": "Sorting any sequence means applying some permutation to its elements.\r\nAll elements of sequence are different, so this permutation is unique\r\nand fixed. Let\u00e2\u0080\u0099s call it .One could split this permutation into simple\r\ncycles. The subsequences in the answer are subsequences formed by these\r\nsimple cycles. One could prove that it\u00e2\u0080\u0099s impossible to split the\r\nsequence into more subsequences because if we could split the sequence\r\ninto more subsequences, we also could split permutation into more\r\ncycles.\r\n"
}