{"link": "https://codeforces.com//contest/778/problem/E", "problemId": "95645", "problem_idx": "E", "shortId": "778E", "contest_number": "778", "problem_submissions": {"D": [25045880, 25060354, 25044951, 25042270, 25047480, 25048926, 25045795, 25045544, 25045486, 25047721, 25047363, 25048949, 25046309, 25047075, 25047917, 25047905, 25036950, 25042732], "E": [25042969, 25046345, 25048943, 25037368, 25230220, 25046363, 25054654, 25048918, 25047591, 25047081], "A": [25035252, 25031242, 25245410, 25036410, 25031451, 25031235, 25031489, 25038781, 25031419, 25031309, 25031692, 25032018, 25031359, 25031871, 25031264, 25031548, 25034117, 25032346, 25031343, 25041816, 25031435], "B": [25034518, 25033704, 25035119, 25035355, 25034840, 25040894, 25042142, 25035930, 25034089, 25038221, 25035530, 25036277, 25035911, 25033345, 25036435, 25039201, 25037280, 25038965, 25040791, 25035608], "C": [25038188, 25041985, 25049416, 25045342, 25039545, 25046412, 25037203, 25040856, 25043392, 25042924, 25041581, 25064524, 25064516, 25064118, 25050637, 25050497, 25042489, 25043145, 25043153, 25044553, 25044592, 25043572, 25044608, 25050488, 25049895]}, "name": "E. Selling Numbers", "statement": "Boris really likes numbers and even owns a small shop selling\r\ninteresting numbers. He has decimal numbers . Cost of the number in his\r\nshop is equal to the sum of costs of its digits. You are given the\r\nvalues , where is the cost of the digit . Of course, Boris is interested\r\nin that numbers he owns have the maximum cost possible.Recently Boris\r\ngot hold of the magical artifact , which can allow him to increase the\r\ncost of his collection. Artifact is a string, consisting of digits and \u201d\r\nsymbols. To use the artifact, Boris must replace all \u201d with digits to\r\nget a decimal number without leading zeros (it is also not allowed to\r\nget number 0). After that, the resulting number is added to all numbers\r\nin Boris\u2019 collection. He uses the artifact exactly once.What is the\r\nmaximum cost of the collection Boris can achieve after using the\r\nartifact?\r\n", "solutions": ["#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<ll> vi;\ntypedef pair<ll, ll> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n\n    ios::sync_with_stdio(false);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic int add(int b, int a)\n{\n    if (b == -1)\n    {\n        if (a == 0)\n            return -1;\n        else\n            return a;\n    }\n    else\n        return b + a;\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    string A;\n    int N;\n    cin >> A >> N;\n    reverse(RA(A));\n    int L = SZ(A);\n    vector<string> B(N);\n    vector<int> c(10);\n    int ML = L;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> B[i];\n        reverse(RA(B[i]));\n        while (SZ(B[i]) < L)\n            B[i] += '0';\n        ML = max(ML, SZ(B[i]));\n    }\n    for (int i = 0; i < 10; i++)\n        cin >> c[i];\n\n    vector<int> dp(N + 1, -1);\n    vector<int> order(N), rank(N);\n    for (int i = 0; i < N; i++)\n        order[i] = i;\n    dp[0] = 0;\n    for (int pos = 0; pos <= ML + 1; pos++)\n    {\n        vector<int> dp2(N + 1, -1);\n        int lo, hi;\n        if (pos >= L)\n            lo = hi = 0;\n        else if (A[pos] == '?')\n        {\n            lo = (pos == L - 1) ? 1 : 0;\n            hi = 9;\n        }\n        else\n            lo = hi = A[pos] - '0';\n        vector<int> col(N);\n        for (int i = 0; i < N; i++)\n        {\n            if (pos >= SZ(B[i]))\n                col[i] = -1;\n            else\n                col[i] = B[i][pos] - '0';\n        }\n        for (int d = lo; d <= hi; d++)\n        {\n            int colsum = 0;\n            int outc = 0;\n            for (int i = 0; i < N; i++)\n            {\n                int s = add(col[i], d);\n                if (s != -1)\n                {\n                    colsum += c[s % 10];\n                    outc += s / 10;\n                }\n            }\n            for (int carry = 0; carry <= N; carry++)\n            {\n                if (dp[carry] >= 0)\n                    dp2[outc] = max(dp2[outc], dp[carry] + colsum);\n                if (carry < N)\n                {\n                    int idx = order[carry];\n                    int s = add(col[idx], d);\n                    if (s != -1)\n                    {\n                        colsum -= c[s % 10];\n                        outc -= s / 10;\n                    }\n                    s = add(col[idx], d + 1);\n                    colsum += c[s % 10];\n                    outc += s / 10;\n                }\n            }\n        }\n        stable_sort(RA(order), [&col](int x, int y)\n        {\n            return max(0, col[x]) > max(0, col[y]);\n        });\n        dp = move(dp2);\n    }\n    cout << dp[0] << '\\n';\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "sortings"], "dificulty": "3000", "interactive": false}