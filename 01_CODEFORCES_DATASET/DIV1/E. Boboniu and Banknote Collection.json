{
    "link": "https://codeforces.com//contest/1394/problem/E",
    "problemId": "697388",
    "problem_idx": "E",
    "shortId": "1394E",
    "contest_number": "1394",
    "problem_submissions": {
        "E": [
            89738268,
            89751614,
            89751306,
            89748113,
            92138216,
            90294852
        ],
        "C": [
            89732445,
            89683758,
            89696028,
            89683626,
            89694594,
            89712053,
            89693715,
            89701612,
            89697873,
            89702287,
            89692727,
            89701355,
            89703625,
            90289383,
            89700363,
            89706177,
            89705251,
            89703716,
            89721405,
            89690071,
            89703493,
            89708013
        ],
        "D": [
            89693191,
            89704513,
            89710792,
            89709417,
            89804436,
            89704286,
            89710073,
            89710943,
            89707637,
            89713733,
            89713912,
            89711885,
            89714265,
            90289402,
            89722481,
            89717905,
            89719820,
            89719453,
            89709166,
            89707845,
            89725892,
            89720000
        ],
        "B": [
            89670028,
            89681474,
            89694856,
            89677267,
            89803448,
            89803280,
            89758188,
            89757972,
            89693039,
            89682124,
            89685684,
            89674007,
            89686030,
            89674213,
            89680671,
            89691474,
            90289363,
            89685315,
            89684531,
            89683358,
            89689040,
            89677823,
            89676540,
            89686855,
            89686732
        ],
        "A": [
            89662871,
            89663327,
            89661651,
            89662462,
            89662370,
            89664124,
            89666251,
            89712037,
            89661542,
            89665502,
            89668072,
            89669720,
            90289341,
            89661258,
            89665118,
            89665097,
            89669384,
            89661494,
            89728914,
            89662580,
            89663285
        ]
    },
    "name": "E. Boboniu and Banknote Collection",
    "statement": "Boboniu has issued his currencies, named Bobo Yuan. Bobo Yuan (BBY) is a\r\nseries of currencies. Boboniu gives each of them a positive integer\r\nidentifier, such as BBY-1, BBY-2, etc.Boboniu has a BBY collection. His\r\ncollection looks like a sequence. For example: We can use sequence\r\na=[1,2,3,3,2,1,4,4,1] of length n=9 to denote it.Now Boboniu wants to\r\nhis collection. You can imagine that Boboniu stick his collection to a\r\nlong piece of paper and fold it between currencies: Boboniu will only\r\nfold the same identifier of currencies together. In other words, if a_i\r\nis folded over a_j (1\r\nle i,j\r\nle n), then a_i=a_j must hold. Boboniu doesn\u2019t care if you follow this\r\nrule in the process of folding. But once it is finished, the rule should\r\nbe obeyed.A formal definition of is described in notes.According to the\r\npicture above, you can a two times. In fact, you can\r\na=[1,2,3,3,2,1,4,4,1] at most two times. So the maximum number of folds\r\nof it is 2.As an international fan of Boboniu, you\u2019re asked to calculate\r\nthe maximum number of folds. You\u2019re given a sequence a of length n, for\r\neach i (1\r\nle i\r\nle n), you need to calculate the maximum number of folds of [a_1,a_2,\r\nldots,a_i].\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<bool> vb; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint n;\nint a[MX];\nvi pal[MX];\nint p[MX], q[MX], num[MX];\n\nvoid getPals(int pos) {\n\tpal[pos].clear(); if (pos == 1) return;\n\tif (a[pos] == a[pos-1]) pal[pos].pb(2);\n\ttrav(x,pal[pos-1]) if (a[pos] == a[pos-x-1]) pal[pos].pb(x+2);\n}\n\nbool checkPal(int L, int R) {\n\ttrav(t,pal[R]) if (t == R-L+1) return 1;\n\treturn 0;\n}\n\nint xyx;\nint pos = 0;\n\nint query() {\n\tint res = xyx+num[pos];\n\tint cur = pos;\n\twhile (p[cur] && q[pos] <= cur-p[cur]/2) {\n\t\tcur -= p[cur]/2;\n\t\t++ res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tsetIO(); re(n);\n\tq[0] = 1;\n\tF0R(i,n) {\n\t\tpos ++; re(a[pos]);\n\t\tgetPals(pos);\n\t\t// dbg(pos,pal[pos]);\n\t\tbool done = 0;\n\t\tif (sz(pal[pos])) {\n\t\t\tint len = pal[pos].ft;\n\t\t\tif (checkPal(pos-len/2-len+1,pos-len/2)) {\n\t\t\t\tpos -= len; xyx += 2;\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t}\n\t\tif (!done) {\n\t\t\tp[pos] = sz(pal[pos]) ? pal[pos][0] : 0; // smallest pal\n\t\t\tq[pos] = q[pos-1];\n\t\t\tnum[pos] = num[pos-1];\n\t\t\t// dbg(\"HUH\",pos,num[pos],q[pos],pos);\n\t\t\tif (checkPal(q[pos],pos)) {\n\t\t\t\tq[pos] = (q[pos]+pos+1)/2;\n\t\t\t\tnum[pos] ++;\n\t\t\t}\n\t\t}\n\t\tpr(query(),' ');\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "strings"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Boboniu and Banknote Collection.json",
    "editorial_link": "https://codeforces.com//blog/entry/81355",
    "editorial": "At first, I\u00e2\u0080\u0099d like to explanation the operation in a intuitive way.To be\r\nexact, the origin problem isn\u00e2\u0080\u0099t ask us to calculate the number of folds,\r\nbut the number of .For example, you can fold three times, but you have\r\ndifferent method to fold it:Method 1: Method 2: The first method can be\r\nrepresent by (defined in the statement) . The second method seems to be\r\ninvalid under the definition of (in statement). But really?In fact,\r\nthose methods are equivalent. The position of their folding marks are\r\nexactly the same, but different in whether it\u00e2\u0080\u0099s valley folds or mountain\r\nfolds. For the first method, the folding type of each fold mark is:\r\nmountain, valley, mountain. For the second method, it\u00e2\u0080\u0099s: mountain,\r\nmountain, valley. (Try it yourself!)Although the second method does only\r\ntwo folds, it folds of paper together so it gets two folding marks in\r\none fold.For , there are different folding methods. I\u00e2\u0080\u0099ll display two of\r\nthem: Firstly to be notice, they have same number of folding marks. The\r\nfirst method can be represent by folding sequence .We can change the\r\nresult of the second method to the first method: Just change the blue\r\npart to red part.In fact, the definition of in statement always lead to\r\nmountain and valley folds. But you can also use different folding\r\nmethod, because any results can be transform into alternate mountain and\r\nvalley folds. : While folding, we don\u00e2\u0080\u0099t care whether it\u00e2\u0080\u0099s mountain or\r\nvalley folds, we just care about the position of folding marks (and the\r\nrule in statement).: Fix the sequence , for all folding methods of , as\r\nlong as the results of them don\u00e2\u0080\u0099t have any available folds, then the\r\nnumber of folding marks of them , and their results must be the same (or\r\nsimply reverse sequence).Although I\u00e2\u0080\u0099ll provide proof for these key\r\npoints, I want you to first think of it intuitively.If understanding the\r\nfolding operation intuitively, it\u00e2\u0080\u0099ll be quite easy to come up with a\r\nnaive algorithm runs in polynomial time. Now I\u00e2\u0080\u0099ll describe a general\r\nfolding method.: I will consider sequence as a string (with a large\r\ncharacter set). The definition of , is similar for sequence.Let\u00e2\u0080\u0099s\r\nconsider , we can fold three into one with a mountain fold and a valley\r\nfold.Similarly, consider three continuous substring , where is the\r\nreverse string of : We can fold them into one with a mountain fold and a\r\nvalley fold, according to the first two key points.Let\u00e2\u0080\u0099s call it and the\r\nfolding method .The questions are: How many layers of paper are folded\r\nduring a X-Y-X fold? Can we find a proper folding method where each fold\r\ncontains only one layer of paper? How to fold a string which doesn\u00e2\u0080\u0099t\r\ncontain X-Y-X substring? (For high level competitor) I display all the\r\nkey points firstly which may lead you to final solution\r\nquickly.Intuitively, we will fold from left to right. Let\u00e2\u0080\u0099s maintain\r\nanother string . Each time: Push to the end of and check if contains new\r\nX-Y-X substring. If it does, then fold it. Calculate the number of folds\r\nof . Note that this step won\u00e2\u0080\u0099t actually change . After that you get the\r\nanswer of . : Using this folding method, each fold contains exactly one\r\nlayer of paper.: After pushing to the end of , contains at most one\r\nX-Y-X substring and it must be a suffix if exists.: For string and two\r\neven palindromic substring , of it, if contains center position of and\r\ncontains center position of , then must contain X-Y-X substring.Use\r\ninformation above, we can figure out a or solution.: For a string which\r\ndoesn\u00e2\u0080\u0099t contain X-Y-X substring, we can only fold its prefix or suffix.\r\nAnd it can be folded at most times.: For a string which doesn\u00e2\u0080\u0099t contain\r\nX-Y-X substring, after pushing an element to the end of , it has at most\r\neven palindromic suffixes.Use information above, we can figure out a or\r\nsolution, which is enough to pass.Let\u00e2\u0080\u0099s say . So the folding method\r\nperforms like: . It doesn\u00e2\u0080\u0099t have any available folds. The answer is . .\r\nIt doesn\u00e2\u0080\u0099t have any available folds. The answer is . . It can be folded\r\nonce. The answer is . , has X-Y-X substring , so is changed to . Plus\r\nX-Y-X counter by . After that, doesn\u00e2\u0080\u0099t have any available folds. The\r\nanswer is . . It can be folded once. The answer is . . It can be folded\r\nonce. The answer is . . It can be folded twice. The answer is . , has\r\nX-Y-X substring , so is changed to . Plus X-Y-X counter by . After that,\r\ndoesn\u00e2\u0080\u0099t have any available folds. The answer is . . It can be folded\r\nonce. The answer is . Each time the answer is the sum of X-Y-X counter\r\nand number of folds of .So the total output will be .Now I\u00e2\u0080\u0099ll describe\r\nthe proof of some key points. If you have already understand them, skip\r\nthis section and read the algorithm part.Description: For string and two\r\neven palindromic substring , of it, if contains center position of and\r\ncontains center position of , then must contain X-Y-X substring.Lets say\r\nand . By construction we can get: Blue lines denotes the center position\r\nof two substrings and the red part forms a X-Y-X substring.Q. E. D.Let\r\ndefine (S-X-Y-X) as a X-Y-X string which doesn\u00e2\u0080\u0099t contain any X-Y-X\r\nsubstring except itself.: S-X-Y-X string contains exactly one even\r\npalindromic suffix. i. e. the Y-X part of it.Proof: Use reduction to\r\nabsurdity and the .Description: After pushing to the end of , contains\r\nat most one X-Y-X substring and it must be a suffix if exists.Let . Just\r\nlike the picture above, if contains two or more X-Y-X substring, there\r\nare three cases: black and red black and blue black and green All of the\r\nthree cases can be negate by the or plain discovery.Q. E. D.By the way:\r\nshows us that if has a X-Y-X substring, it must be a S-X-Y-X substring.\r\nshows us that that if has a X-Y-X substring, it must be produced by its\r\neven palindromic suffix. Description: For a string which doesn\u00e2\u0080\u0099t contain\r\nX-Y-X substring, we can only fold its prefix or suffix. And it can be\r\nfolded at most times.Let\u00e2\u0080\u0099s take suffix for example. Each time you can\r\nfold an if exists. And the length of it increasing: So that it won\u00e2\u0080\u0099t\r\ncontain X-Y-X substring. Similar for prefix. So the folds will end up\r\nbeing Thus you can fold less than times.Q. E. D.Description: For a\r\nstring which doesn\u00e2\u0080\u0099t contain X-Y-X substring, after pushing an element\r\nto the end of , it has at most even palindromic suffixes.Because of the\r\n, even palindromic suffixes of cannot contain center position of each\r\nother, so that if we sort them by length, then every even palindromic\r\nsuffix must be as the previous one: Thus has at most even palindromic\r\nsuffixes.Q. E. D.The algorithm itself is quite simple. Remember\r\nthat:Intuitively, we will fold from left to right. Let\u00e2\u0080\u0099s maintain\r\nanother string . Each time: Push to the end of and check if contains new\r\nX-Y-X substring. If so, then fold it. Calculate the number of folds of .\r\nNote that this step won\u00e2\u0080\u0099t change . After that you get the answer of .\r\nLet\u00e2\u0080\u0099s maintain , the set of even palindromic suffixes of after the -th\r\ntime. Since the size of it is , use any data structure you\r\nwant.Calculate from in is trivial.Then we simply find the shortest even\r\npalindromic suffix of and check if it produce a X-Y-X substring in .If\r\nit does produce, then we simply fold it, which means remove the shortest\r\neven palindromic suffix of .Don\u00e2\u0080\u0099t forget to update X-Y-X counter.To\r\ncalculate the number of folds of , which doesn\u00e2\u0080\u0099t contain X-Y-X\r\nsubstring: Let denote the length of shortest even palindromic suffix of\r\n(index starts from ). Let denote that, if we fold the shortest even\r\npalindromic prefix start from and repeat folding until you can\u00e2\u0080\u0099t fold,\r\nthe position of the first character of the result. i. e. is folded to\r\nfinally. Let denote the number of folds during the process. Calculate\r\nfrom in . Don\u00e2\u0080\u0099t forget .Get from . denotes the number of prefix folds of\r\n.You can fold suffix of using and calculate the number of suffix folds\r\nin .The sum of two above is the number of folds of . Plus it by X-Y-X\r\ncounter you\u00e2\u0080\u0099ll get the answer.Remove suffix of is trivial.The total time\r\ncomplexity is .Can you optimize the time complexity of part 2 to and\r\nimplement the algorithm in ?\r\n"
}