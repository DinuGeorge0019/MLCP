{"link": "https://codeforces.com//contest/1394/problem/E", "problemId": "697388", "problem_idx": "E", "shortId": "1394E", "contest_number": "1394", "problem_submissions": {"E": [89738268, 89751614, 89751306, 89748113, 92138216, 90294852], "C": [89732445, 89683758, 89696028, 89683626, 89694594, 89712053, 89693715, 89701612, 89697873, 89702287, 89692727, 89701355, 89703625, 90289383, 89700363, 89706177, 89705251, 89703716, 89721405, 89690071, 89703493, 89708013], "D": [89693191, 89704513, 89710792, 89709417, 89804436, 89704286, 89710073, 89710943, 89707637, 89713733, 89713912, 89711885, 89714265, 90289402, 89722481, 89717905, 89719820, 89719453, 89709166, 89707845, 89725892, 89720000], "B": [89670028, 89681474, 89694856, 89677267, 89803448, 89803280, 89758188, 89757972, 89693039, 89682124, 89685684, 89674007, 89686030, 89674213, 89680671, 89691474, 90289363, 89685315, 89684531, 89683358, 89689040, 89677823, 89676540, 89686855, 89686732], "A": [89662871, 89663327, 89661651, 89662462, 89662370, 89664124, 89666251, 89712037, 89661542, 89665502, 89668072, 89669720, 90289341, 89661258, 89665118, 89665097, 89669384, 89661494, 89728914, 89662580, 89663285]}, "name": "E. Boboniu and Banknote Collection", "statement": "Boboniu has issued his currencies, named Bobo Yuan. Bobo Yuan (BBY) is a\r\nseries of currencies. Boboniu gives each of them a positive integer\r\nidentifier, such as BBY-1, BBY-2, etc.Boboniu has a BBY collection. His\r\ncollection looks like a sequence. For example: We can use sequence\r\na=[1,2,3,3,2,1,4,4,1] of length n=9 to denote it.Now Boboniu wants to\r\nhis collection. You can imagine that Boboniu stick his collection to a\r\nlong piece of paper and fold it between currencies: Boboniu will only\r\nfold the same identifier of currencies together. In other words, if a_i\r\nis folded over a_j (1\r\nle i,j\r\nle n), then a_i=a_j must hold. Boboniu doesn\u2019t care if you follow this\r\nrule in the process of folding. But once it is finished, the rule should\r\nbe obeyed.A formal definition of is described in notes.According to the\r\npicture above, you can a two times. In fact, you can\r\na=[1,2,3,3,2,1,4,4,1] at most two times. So the maximum number of folds\r\nof it is 2.As an international fan of Boboniu, you\u2019re asked to calculate\r\nthe maximum number of folds. You\u2019re given a sequence a of length n, for\r\neach i (1\r\nle i\r\nle n), you need to calculate the maximum number of folds of [a_1,a_2,\r\nldots,a_i].\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<bool> vb; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint n;\nint a[MX];\nvi pal[MX];\nint p[MX], q[MX], num[MX];\n\nvoid getPals(int pos) {\n\tpal[pos].clear(); if (pos == 1) return;\n\tif (a[pos] == a[pos-1]) pal[pos].pb(2);\n\ttrav(x,pal[pos-1]) if (a[pos] == a[pos-x-1]) pal[pos].pb(x+2);\n}\n\nbool checkPal(int L, int R) {\n\ttrav(t,pal[R]) if (t == R-L+1) return 1;\n\treturn 0;\n}\n\nint xyx;\nint pos = 0;\n\nint query() {\n\tint res = xyx+num[pos];\n\tint cur = pos;\n\twhile (p[cur] && q[pos] <= cur-p[cur]/2) {\n\t\tcur -= p[cur]/2;\n\t\t++ res;\n\t}\n\treturn res;\n}\n\nint main() {\n\tsetIO(); re(n);\n\tq[0] = 1;\n\tF0R(i,n) {\n\t\tpos ++; re(a[pos]);\n\t\tgetPals(pos);\n\t\t// dbg(pos,pal[pos]);\n\t\tbool done = 0;\n\t\tif (sz(pal[pos])) {\n\t\t\tint len = pal[pos].ft;\n\t\t\tif (checkPal(pos-len/2-len+1,pos-len/2)) {\n\t\t\t\tpos -= len; xyx += 2;\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t}\n\t\tif (!done) {\n\t\t\tp[pos] = sz(pal[pos]) ? pal[pos][0] : 0; // smallest pal\n\t\t\tq[pos] = q[pos-1];\n\t\t\tnum[pos] = num[pos-1];\n\t\t\t// dbg(\"HUH\",pos,num[pos],q[pos],pos);\n\t\t\tif (checkPal(q[pos],pos)) {\n\t\t\t\tq[pos] = (q[pos]+pos+1)/2;\n\t\t\t\tnum[pos] ++;\n\t\t\t}\n\t\t}\n\t\tpr(query(),' ');\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"], "input": "", "output": "", "tags": ["strings"], "dificulty": "3500", "interactive": false}