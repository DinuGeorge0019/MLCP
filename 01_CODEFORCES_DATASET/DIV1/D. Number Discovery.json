{
    "link": "https://codeforces.com//contest/1242/problem/D",
    "problemId": "461422",
    "problem_idx": "D",
    "shortId": "1242D",
    "contest_number": "1242",
    "problem_submissions": {
        "D": [
            64429860,
            64401395,
            64404795,
            64415190,
            64415054,
            64417615,
            65038601,
            64421033
        ],
        "E": [
            64409298,
            64420461,
            64419778,
            64424736,
            64419348,
            64414319,
            64418306,
            64411659,
            85134215,
            64416609
        ],
        "C": [
            64384054,
            64387078,
            64388913,
            64394464,
            64389930,
            64394199,
            64391758,
            64389823,
            64419752,
            64392841,
            64389286,
            64389598,
            64391081,
            64391511,
            64389424,
            64390727,
            64393812,
            64387821,
            64392710
        ],
        "B": [
            64375742,
            64376014,
            64376258,
            64379755,
            64379732,
            64382090,
            64380230,
            64379007,
            64378437,
            64381299,
            64377955,
            64379394,
            64386968,
            64379314,
            64379387,
            64378002,
            64378249,
            64378976,
            64378094,
            64382011
        ],
        "A": [
            64373553,
            64378605,
            64373529,
            64375482,
            64375227,
            64375209,
            64374548,
            64373968,
            64380733,
            64373781,
            64373964,
            64373921,
            64376154,
            64374077,
            64374590,
            64374513,
            64373655,
            64375273,
            64373875,
            64376239
        ]
    },
    "name": "D. Number Discovery",
    "statement": "Ujan needs some rest from cleaning, so he started playing with infinite\r\nsequences. He has two integers n and k. He creates an infinite sequence\r\ns by repeating the following steps. Find k smallest distinct positive\r\nintegers that are not in s. Let’s call them u_{1}, u_{2},\r\nldots, u_{k} from the smallest to the largest. Append u_{1}, u_{2},\r\nldots, u_{k} and\r\nsum_{i=1}^{k} u_{i} to s in this order. Go back to the first step. Ujan\r\nwill stop procrastinating when he writes the number n in the sequence s.\r\nHelp him find the index of n in s. In other words, find the integer x\r\nsuch that s_{x} = n. It’s possible to prove that all positive integers\r\nare included in s only once.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void pr(const T& x) { \n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    \n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n    }\n    \n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n    }\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nll K;\n\nll sum(ll a, ll b) { // a to a-b+1\n\treturn b*(2*a-b+1)/2;\n}\n\nll cdiv(ll a, ll b) { return (a+b-1)/b; }\nll ind(ll a, ll b) {\n\tll num = a-b;\n\t// 1..K -> 1..K\n\t// K+1..2K -> K+2..2K+1\n\tll rem = num%K; if (rem == 0) rem = K;\n\treturn (num-1)/K*(K+1)+rem;\n\t// there are n-x.s, groups of K\n}\n\nll range(ll L, ll R) {\n\treturn (L+R)*(R-L+1)/2;\n}\n\nll range(ll L, ll R, ll X) {\n\tif (X < L) return range(L,R);\n\tif (X > R) return range(L-1,R-1);\n\treturn range(L-1,R)-X;\n}\n\npl lastSum(ll n) {\n\tif (n < K*(K+1)/2) return {0,0};\n\t// x, x-2, ..., x-K <= n -> K*x <= n+K*(K+1)/2-1\n\tll x = (n+K*(K+1)/2-1)/K; auto a = lastSum(x);\n\tif (a.f == x) {\n\t\tll xind = ind(x-1,a.s-1); int pos = xind%(K+1);\n\t\tif (pos == K) return {range(x-K,x-1),xind/(K+1)+1};\n\t\treturn {range(x-pos-K,x-pos-1),xind/(K+1)};\n\t} else {\n\t\tll xind = ind(x,a.s); int pos = xind%(K+1);\n\t\tif (range(x-pos+1,x-pos+K,a.f) <= n) return {range(x-pos+1,x-pos+K,a.f),xind/(K+1)+1};\n\t\treturn {range(x-pos+1-K,x-pos,a.f),xind/(K+1)};\n\t}\n}\n\nll solve(ll n) {\n\tauto x = lastSum(n);\n\tif (x.f == n) return x.s*(K+1);\n\treturn ind(n,x.s);\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) {\n\t\tll N; re(N,K);\n\t\t/*FOR(i,1,K+1) assert(ind(i,0) == i);\n\t\tFOR(i,K+1,2*K+1) assert(ind(i,0) == i+1);\n\t\texit(0);*/\n\t\tps(solve(N));\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Number Discovery.json",
    "editorial_link": "https://codeforces.com//blog/entry/71216",
    "editorial": "Letâs make some definitions: is if is appended\ninto by summation form. For example, if , then are non-self numbers. is\nif is not non-self number. Let . In other words, is -th interval of\npositive integers with size. Now let me introduce some strong lemma\nEvery interval has non-self number. Furthermore, we can of using\nnon-self number of .How is this possible? First, you can prove there is\nonly non-self number in . Now letâs try induction. Suppose has only\nnon-self number and each numbers of self numbers form summation, then\nyou can describe generated summations as follows:Where means index of\nsubintervals in () and means added offset into -th subinterval () since\nâs non-self number can be located at left or inside of -th\nsubinterval.Using this fact, you can solve this problem in per test\ncase. Some testers solved this problem by detecting pattern of\ndistribution of non-self numbers.\n",
    "hint": []
}