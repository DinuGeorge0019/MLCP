{
    "link": "https://codeforces.com//contest/95/problem/E",
    "problemId": "501",
    "problem_idx": "E",
    "shortId": "95E",
    "contest_number": "95",
    "problem_submissions": {
        "E": [
            535779,
            536171,
            535576,
            534631,
            535449,
            537379,
            535935,
            538215,
            538206,
            535203,
            543889,
            535690,
            536003,
            536745,
            536509,
            549025
        ],
        "B": [
            535031,
            532607,
            533801,
            533350,
            537169,
            534776,
            532824,
            533550,
            533473,
            533499,
            533085,
            534188,
            533285,
            537343,
            537019,
            533757
        ],
        "D": [
            534913,
            535339,
            534808,
            950906,
            535637,
            535740,
            536719,
            535872,
            536920,
            536227,
            537633
        ],
        "C": [
            534317,
            533819,
            536411,
            534119,
            533891,
            533661,
            534495,
            534743,
            534102,
            533774,
            534164,
            535462,
            533913,
            536894,
            535197,
            535469,
            534630,
            534725
        ],
        "A": [
            533274,
            536622,
            537207,
            536153,
            533227,
            532424,
            532796,
            532812,
            532729,
            532727,
            533283,
            534618,
            532955,
            532983,
            533855,
            532880
        ]
    },
    "name": "E. Lucky Country",
    "statement": "Petya loves lucky numbers. Everybody knows that positive integers are if\r\ntheir decimal representation doesn’t contain digits other than and . For\r\nexample, numbers , , are lucky and , , are not.One night Petya was\r\nsleeping. He was dreaming of being the president of some island country.\r\nThe country is represented by islands connected by two-way roads.\r\nBetween some islands there is no road way, even through other islands,\r\nthat’s why the country is divided into several regions. More formally,\r\neach island belongs to exactly one region, there is a path between any\r\ntwo islands located in the same region; there is no path between any two\r\nislands from different regions. A region is lucky if the amount of\r\nislands in it is a lucky number.As a real president, Petya first decided\r\nto build a presidential palace. Being a lucky numbers’ fan, Petya wants\r\nto position his palace in one of the lucky regions. However, it is\r\npossible that initially the country has no such regions. In this case\r\nPetya can build additional roads between different regions, thus joining\r\nthem. Find the minimum number of roads needed to build to create a lucky\r\nregion.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=100000+10;\nconst int oo=100000000;\n\nvector<int> e[maxn];\nint que[maxn],qid[maxn];\nbool flag[maxn];\nint cnt[maxn];\nint A[maxn],B[maxn];\nint opt[maxn],tmp[maxn];\nint n,m,t;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=0,a,b;i<m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\tif (!flag[i])\n\t{\n\t\tint l=1,r=1;\n\t\tque[1]=i;flag[i]=1;\n\t\tfor (;l<=r;l++)\n\t\tfor (int j=0;j<e[que[l]].size();j++)\n\t\tif (!flag[e[que[l]][j]])\n\t\t{\n\t\t\tque[++r]=e[que[l]][j];\n\t\t\tflag[que[r]]=1;\n\t\t}\n\t\tcnt[r]++;\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\tif (cnt[i])\n\t{\n\t\tA[++t]=i;B[t]=cnt[i];\n\t}\n\n\tfor (int i=1;i<=77777;i++) opt[i]=oo;\n\tfor (int i=1;i<=t;i++)\n\t{\n\t\tfor (int j=0;j<=77777;j++) tmp[j]=oo;\n\t\tfor (int j=0;j<A[i];j++)\n\t\t{\n\t\t\tint l=1,r=0;\n\t\t\tfor (int k=j,id=0;k<=77777;k+=A[i],id++)\n\t\t\t{\n\t\t\t\twhile (l<=r && id-qid[l]>B[i]) l++;\n\t\t\t\tif (l<=r) tmp[k]=que[l]+id;\n\t\t\t\twhile (l<=r && opt[k]-id<=que[r]) r--;\n\t\t\t\tque[++r]=opt[k]-id;qid[r]=id;\n\t\t\t}\n\t\t}\n\t\tfor (int j=0;j<=77777;j++) opt[j]=min(opt[j],tmp[j]);\n\t}\n\n\tint res=n+1;\n\tfor (int i=1;i<=77777;i++)\n\tif (opt[i]<res)\n\t{\n\t\tbool ok=1;\n\t\tfor (int k=i;k;k/=10)\n\t\t\tok&=(k%10==4 || k%10==7);\n\t\tif (ok) res=opt[i];\n\t}\n\tif (res==n+1) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",res-1);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "dsu",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Lucky Country.json",
    "editorial_link": "https://codeforces.com//blog/entry/2257",
    "editorial": "Let A[i] - sorted array of sizes of different connection components, C[i]  number of connection components of size A[i]. Sum for all C[i]*A[i] is equal to N. Size of A will be O(sqrt(N)).",
    "hint": []
}