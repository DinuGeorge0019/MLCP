{"link": "https://codeforces.com//contest/1158/problem/F", "problemId": "343491", "problem_idx": "F", "shortId": "1158F", "contest_number": "1158", "problem_submissions": {"E": [54043697, 54045364, 54049022], "D": [54034270, 54037737, 54037081, 54029996, 54039126, 54036378, 54039507, 54040185, 54038993, 54040201, 54038641, 54040565, 54035763, 54041644, 54031772, 54033510, 54035224], "C": [54032525, 54035029, 54036135, 54034332, 54036498, 54034178, 54037957, 54038859, 54034328, 54037431, 54037039, 54036368, 54038382, 54039919, 54034772, 54037883, 54036347, 54039155], "B": [54031111, 54032629, 54034184, 54032709, 54033881, 54040878, 54036260, 54033097, 54031744, 54033322, 54032381, 54039897, 54035074, 54040745, 54038527, 54041411, 68070838, 54045735, 54041323], "A": [54029723, 54029634, 54031071, 54030974, 54029203, 54030224, 54030247, 54030013, 54029682, 54030151, 54031232, 54030952, 54031158, 54031859, 54031283, 54032676, 54031617, 54030225], "F": [54045740, 54049931, 74200730, 74200612, 73657677, 73657539, 73657494, 73657445, 73007148, 68077713, 68077566, 68077199, 68077121, 68076937]}, "name": "F. Density of subarrays", "statement": "Let c be some positive integer. Let\u2019s call an array a_1, a_2,\r\nldots, a_n of positive integers c-array, if for all i condition 1\r\nleq a_i\r\nleq c is satisfied. Let\u2019s call c-array b_1, b_2,\r\nldots, b_k a of c-array a_1, a_2,\r\nldots, a_n, if there exists such set of k indices 1\r\nleq i_1 < i_2 <\r\nldots < i_k\r\nleq n that b_j = a_{i_j} for all 1\r\nleq j\r\nleq k. Let\u2019s define of c-array a_1, a_2,\r\nldots, a_n as maximal non-negative integer p, such that any c-array,\r\nthat contains p numbers is a subarray of a_1, a_2,\r\nldots, a_n.You are given a number c and some c-array a_1, a_2,\r\nldots, a_n. For all 0\r\nleq p\r\nleq n find the number of sequences of indices 1\r\nleq i_1 < i_2 <\r\nldots < i_k\r\nleq n for all 1\r\nleq k\r\nleq n, such that density of array a_{i_1}, a_{i_2},\r\nldots, a_{i_k} is equal to p. Find these numbers by modulo 998\r\n,244\r\n,353, because they can be too large.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<998244353>;\n\nconst int MAXV = 4000;\nnum p2[MAXV+1];\nnum invp2[MAXV+1];\nnum p2min1[MAXV+1];\nnum invp2min1[MAXV+1];\n\nvoid precomp() {\n\tp2[0] = 1;\n\tfor (int i = 1; i <= MAXV; i++) {\n\t\tp2[i] = p2[i-1] + p2[i-1];\n\t}\n\tinvp2[MAXV] = p2[MAXV].inv();\n\tfor (int i = MAXV-1; i >= 0; i--) {\n\t\tinvp2[i] = invp2[i+1] + invp2[i+1];\n\t}\n\n\tfor (int i = 0; i <= MAXV; i++) {\n\t\tp2min1[i] = p2[i] - 1;\n\t}\n\tfor (int i = 1; i <= MAXV; i++) {\n\t\tinvp2min1[i] = p2min1[i].inv();\n\t}\n}\n\nconst int MAXN = 4000;\nint N;\nint A[MAXN];\n\nint C;\n\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tprecomp();\n\n\tcin >> N >> C;\n\tfor (int i = 0; i < N; i++) { cin >> A[i], A[i] --; }\n\n\tvector<vector<num>> dp(N+1);\n\tdp[0] = vector<num>({num(1)});\n\tif (C > 10) {\n\t\t// c large\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<int> cnt(C);\n\t\t\tnum ways = 1;\n\t\t\tint numBad = C-1;\n\t\t\tfor (int j = i; j >= 0; j--) {\n\t\t\t\tif (A[j] != A[i]) {\n\t\t\t\t\tif (cnt[A[j]] == 0) {\n\t\t\t\t\t\tnumBad --;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tways *= invp2min1[cnt[A[j]]];\n\t\t\t\t\t}\n\t\t\t\t\t++cnt[A[j]];\n\t\t\t\t\tways *= p2min1[cnt[A[j]]];\n\t\t\t\t}\n\n\t\t\t\tif (numBad == 0) {\n\t\t\t\t\tif (dp[i+1].size() < dp[j].size() + 1) {\n\t\t\t\t\t\tdp[i+1].resize(dp[j].size() + 1, num(0));\n\t\t\t\t\t}\n\t\t\t\t\tfor (int l = 0; l < int(dp[j].size()); l++) {\n\t\t\t\t\t\tdp[i+1][l+1] += ways * dp[j][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvector<vector<num>> dp2(1 << C);\n\t\tdp2[0] = vector<num>({num(1)});\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int m = (1 << C) - 1; m >= 0; m--) {\n\t\t\t\tif (dp2[m | (1 << A[i])].size() < dp2[m].size()) {\n\t\t\t\t\tdp2[m | (1 << A[i])].resize(dp2[m].size(), num(0));\n\t\t\t\t}\n\t\t\t\tfor (int l = 0; l < int(dp2[m].size()); l++) {\n\t\t\t\t\tdp2[m | (1 << A[i])][l] += dp2[m][l];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswap(dp[i+1], dp2[(1 << C) - 1]);\n\t\t\tdp[i+1].insert(dp[i+1].begin(), num(0));\n\n\t\t\tif (dp2[0].size() < dp[i+1].size()) {\n\t\t\t\tdp2[0].resize(dp[i+1].size(), num(0));\n\t\t\t}\n\t\t\tfor (int l = 0; l < int(dp[i+1].size()); l++) {\n\t\t\t\tdp2[0][l] += dp[i+1][l];\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<num> ans(N+1);\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int l = 0; l < int(dp[i].size()); l++) {\n\t\t\tans[l] += dp[i][l] * p2[N-i];\n\t\t}\n\t}\n\tans[0] --;\n\tfor (int i = 0; i < N; i++) {\n\t\tans[i] -= ans[i+1];\n\t}\n\tfor (int i = 0; i <= N; i++) {\n\t\tcout << ans[i] << \" \\n\"[i==N];\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "math"], "dificulty": "3500", "interactive": false}