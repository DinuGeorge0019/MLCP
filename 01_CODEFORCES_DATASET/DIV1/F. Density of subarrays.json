{
    "link": "https://codeforces.com//contest/1158/problem/F",
    "problemId": "343491",
    "problem_idx": "F",
    "shortId": "1158F",
    "contest_number": "1158",
    "problem_submissions": {
        "E": [
            54043697,
            54045364,
            54049022
        ],
        "D": [
            54034270,
            54037737,
            54037081,
            54029996,
            54039126,
            54036378,
            54039507,
            54040185,
            54038993,
            54040201,
            54038641,
            54040565,
            54035763,
            54041644,
            54031772,
            54033510,
            54035224
        ],
        "C": [
            54032525,
            54035029,
            54036135,
            54034332,
            54036498,
            54034178,
            54037957,
            54038859,
            54034328,
            54037431,
            54037039,
            54036368,
            54038382,
            54039919,
            54034772,
            54037883,
            54036347,
            54039155
        ],
        "B": [
            54031111,
            54032629,
            54034184,
            54032709,
            54033881,
            54040878,
            54036260,
            54033097,
            54031744,
            54033322,
            54032381,
            54039897,
            54035074,
            54040745,
            54038527,
            54041411,
            68070838,
            54045735,
            54041323
        ],
        "A": [
            54029723,
            54029634,
            54031071,
            54030974,
            54029203,
            54030224,
            54030247,
            54030013,
            54029682,
            54030151,
            54031232,
            54030952,
            54031158,
            54031859,
            54031283,
            54032676,
            54031617,
            54030225
        ],
        "F": [
            54045740,
            54049931,
            74200730,
            74200612,
            73657677,
            73657539,
            73657494,
            73657445,
            73007148,
            68077713,
            68077566,
            68077199,
            68077121,
            68076937
        ]
    },
    "name": "F. Density of subarrays",
    "statement": "Let c be some positive integer. Let\u2019s call an array a_1, a_2,\r\nldots, a_n of positive integers c-array, if for all i condition 1\r\nleq a_i\r\nleq c is satisfied. Let\u2019s call c-array b_1, b_2,\r\nldots, b_k a of c-array a_1, a_2,\r\nldots, a_n, if there exists such set of k indices 1\r\nleq i_1 < i_2 <\r\nldots < i_k\r\nleq n that b_j = a_{i_j} for all 1\r\nleq j\r\nleq k. Let\u2019s define of c-array a_1, a_2,\r\nldots, a_n as maximal non-negative integer p, such that any c-array,\r\nthat contains p numbers is a subarray of a_1, a_2,\r\nldots, a_n.You are given a number c and some c-array a_1, a_2,\r\nldots, a_n. For all 0\r\nleq p\r\nleq n find the number of sequences of indices 1\r\nleq i_1 < i_2 <\r\nldots < i_k\r\nleq n for all 1\r\nleq k\r\nleq n, such that density of array a_{i_1}, a_{i_2},\r\nldots, a_{i_k} is equal to p. Find these numbers by modulo 998\r\n,244\r\n,353, because they can be too large.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<998244353>;\n\nconst int MAXV = 4000;\nnum p2[MAXV+1];\nnum invp2[MAXV+1];\nnum p2min1[MAXV+1];\nnum invp2min1[MAXV+1];\n\nvoid precomp() {\n\tp2[0] = 1;\n\tfor (int i = 1; i <= MAXV; i++) {\n\t\tp2[i] = p2[i-1] + p2[i-1];\n\t}\n\tinvp2[MAXV] = p2[MAXV].inv();\n\tfor (int i = MAXV-1; i >= 0; i--) {\n\t\tinvp2[i] = invp2[i+1] + invp2[i+1];\n\t}\n\n\tfor (int i = 0; i <= MAXV; i++) {\n\t\tp2min1[i] = p2[i] - 1;\n\t}\n\tfor (int i = 1; i <= MAXV; i++) {\n\t\tinvp2min1[i] = p2min1[i].inv();\n\t}\n}\n\nconst int MAXN = 4000;\nint N;\nint A[MAXN];\n\nint C;\n\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tprecomp();\n\n\tcin >> N >> C;\n\tfor (int i = 0; i < N; i++) { cin >> A[i], A[i] --; }\n\n\tvector<vector<num>> dp(N+1);\n\tdp[0] = vector<num>({num(1)});\n\tif (C > 10) {\n\t\t// c large\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<int> cnt(C);\n\t\t\tnum ways = 1;\n\t\t\tint numBad = C-1;\n\t\t\tfor (int j = i; j >= 0; j--) {\n\t\t\t\tif (A[j] != A[i]) {\n\t\t\t\t\tif (cnt[A[j]] == 0) {\n\t\t\t\t\t\tnumBad --;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tways *= invp2min1[cnt[A[j]]];\n\t\t\t\t\t}\n\t\t\t\t\t++cnt[A[j]];\n\t\t\t\t\tways *= p2min1[cnt[A[j]]];\n\t\t\t\t}\n\n\t\t\t\tif (numBad == 0) {\n\t\t\t\t\tif (dp[i+1].size() < dp[j].size() + 1) {\n\t\t\t\t\t\tdp[i+1].resize(dp[j].size() + 1, num(0));\n\t\t\t\t\t}\n\t\t\t\t\tfor (int l = 0; l < int(dp[j].size()); l++) {\n\t\t\t\t\t\tdp[i+1][l+1] += ways * dp[j][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvector<vector<num>> dp2(1 << C);\n\t\tdp2[0] = vector<num>({num(1)});\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int m = (1 << C) - 1; m >= 0; m--) {\n\t\t\t\tif (dp2[m | (1 << A[i])].size() < dp2[m].size()) {\n\t\t\t\t\tdp2[m | (1 << A[i])].resize(dp2[m].size(), num(0));\n\t\t\t\t}\n\t\t\t\tfor (int l = 0; l < int(dp2[m].size()); l++) {\n\t\t\t\t\tdp2[m | (1 << A[i])][l] += dp2[m][l];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswap(dp[i+1], dp2[(1 << C) - 1]);\n\t\t\tdp[i+1].insert(dp[i+1].begin(), num(0));\n\n\t\t\tif (dp2[0].size() < dp[i+1].size()) {\n\t\t\t\tdp2[0].resize(dp[i+1].size(), num(0));\n\t\t\t}\n\t\t\tfor (int l = 0; l < int(dp[i+1].size()); l++) {\n\t\t\t\tdp2[0][l] += dp[i+1][l];\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<num> ans(N+1);\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int l = 0; l < int(dp[i].size()); l++) {\n\t\t\tans[l] += dp[i][l] * p2[N-i];\n\t\t}\n\t}\n\tans[0] --;\n\tfor (int i = 0; i < N; i++) {\n\t\tans[i] -= ans[i+1];\n\t}\n\tfor (int i = 0; i <= N; i++) {\n\t\tcout << ans[i] << \" \\n\"[i==N];\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Density of subarrays.json",
    "editorial_link": "https://codeforces.com/blog/entry/66993?locale=en",
    "editorial": "We have some -array . Let\u00e2\u0080\u0099s find the criterion, that any -array of\r\nlength is its subsequence. To check that -array is a subsequence of , we\r\nshould iterate all elements of and take the most left occurrence of this\r\nsymbol in , starting from the current moment. Because any -array should\r\nbe a subsequence of on each step we can take the symbol the most left\r\noccurrence of such is the most right. Let\u00e2\u0080\u0099s denote the positions, which\r\nwe have taken on each step . So if we will look to the array , in this\r\narrays each of the symbols exists and the symbol occurs exactly time.\r\nLet\u00e2\u0080\u0099s name such array \"critical block\". So the density of , if is the\r\nconcatenation of consecutive critical blocks and some other symbols at\r\nthe end.Let\u00e2\u0080\u0099s note, that the density of any array of length won\u00e2\u0080\u0099t be\r\nmore than . It is obvious, because in any critical block at least\r\nsymbols.Let\u00e2\u0080\u0099s find as the number of subsequences of the array prefix\r\nthat contain the position , which are divided into exactly critical\r\narrays (and no other characters). We will consider it for all and .\r\nLet\u00e2\u0080\u0099s first understand how to get an answer from these values, and then\r\nshow how to calculate them. If we denote by the number of subsequences\r\nwhose density is , then . Next, note that the number of density\r\nsubsequences exactly is .Here are different ways to calculate :1) denote\r\nby the number of subsequences of array that contain and are critical.\r\nThen , where is the number of characters among . Then we can calculate\r\nfor . To speed up this calculation to we will fix and increase by ,\r\nsupporting . Then in such a product multiplier will be changed and it\r\ncan be recalculated by . To get , you simply divide the supported\r\nproduct by .Then note that (iterate over the end of the previous\r\ncritical block). This allows us to calculate the values of in time .2)\r\nWe will need an auxiliary dinamical programming values (where is a mask\r\nof characters, that is ), which means the number of ways to choose a\r\nsubsequence from the prefix , in which there will be first critical\r\nblocks and then several characters that are in , but each character from\r\nwill be at the several symbols at least once. Then , which follows from\r\nthe definition. Conversion formulas are as follows: , if is not\r\ncontained in and , if is contained in (if you take in the subsequence\r\nand if not). For it is true, that .These formulas can be used to\r\ncalculate the values of and by iterating in increasing order over time .\r\nThe parameter can be omitted from memory because the recalculation is\r\nonly from the previous layer.In total, we get ways to calculate working\r\nfor and . Recall that . That is, our solutions work at the time and . If\r\n, then let\u00e2\u0080\u0099s run the first solution and it will work for , otherwise if\r\nand , so let\u00e2\u0080\u0099s run the second solution, which will then work, too, in\r\ntime.If we carefully implement these solutions and run them depending on\r\n, we get a solution with complexity and it is working fast\r\nenough.Complexity: or .\r\n"
}