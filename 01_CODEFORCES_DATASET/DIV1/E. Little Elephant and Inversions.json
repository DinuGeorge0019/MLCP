{"link": "https://codeforces.com//contest/220/problem/E", "problemId": "1621", "problem_idx": "E", "shortId": "220E", "contest_number": "220", "problem_submissions": {"D": [2080540, 2080418, 2074895, 2078075, 2079217, 2081403, 2081824, 2081006, 2076381, 2093601, 2093590, 3084971, 2086233], "E": [2078891, 2078702, 2081885, 2081411, 2081777, 2080333, 2079988, 2077021, 2081284, 2080936, 2080773, 2080185, 2080971, 2082030, 2080110, 2081659, 2081994, 2086312, 2082178], "C": [2077244, 2077402, 2078300, 2079325, 2076073, 2077207, 2078341, 2080109, 2076476, 2078366, 2079100, 2080050, 2078605, 2081663, 2079424, 2078933, 2080721], "B": [2074621, 2083029, 2082854, 2073372, 2075693, 2075380, 2073348, 2074150, 2075655, 2074877, 2074146, 2076125, 2083532, 2074043, 2074785, 2086353, 2077672, 2098154, 2098144, 2076395, 2075929, 2074543], "A": [2072304, 2072260, 2072332, 2072289, 2079727, 2072355, 2072380, 2072450, 2072425, 2072416, 2072763, 2072261, 2072442, 2073395, 2073046, 2072395, 2072278]}, "name": "E. Little Elephant and Inversions", "statement": "The Little Elephant has array , consisting of positive integers, indexed\r\nfrom 1 to . Let\u2019s denote the number with index as .The Little Elephant\r\nwants to count, how many pairs of integers and are there, such that and\r\nsequence has no more than inversions. An in sequence is a pair of\r\nelements of the sequence , that change their relative order after a\r\nstable sorting of the sequence. In other words, an inversion is a pair\r\nof integers and , such that and , where is the length of sequence , and\r\nis its -th element.Help the Little Elephant and count the number of the\r\ndescribed pairs.\r\n", "solutions": ["// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint in[101000];\nint in2[101000];\nint n;\nlong long k;\nmap<int,int> xx;\nint tre[101000];\nint tb[101000];\nint xn;\ninline void add(int* tr,int x,int c=1){\n    for(;x<=xn;x+=x&-x)tr[x]+=c;\n}\ninline int que(int* tr,int x){\n    int r=0;\n    for(;x;x-=x&-x)r+=tr[x];\n    return r;\n}\ninline long long solve(){\n    long long ss=0;\n    int i,j;\n    for(j=n-1;j>=0;j--){\n        int x=que(tb,in[j]-1);\n        if(ss+x>k){\n            j++;\n            break;\n        }\n        ss+=x;\n        add(tb,in[j]);\n    }\n    if(j==-1)return n*(n-1ll)/2;\n    long long ret=0;\n    for(i=0;i<n;i++){\n        ss+=que(tre,xn+1-in[i]-1);\n        ss+=que(tb,in[i]-1);\n        add(tre,xn+1-in[i]);\n        for(;j<n;j++){\n            if(ss<=k)break;\n            ss-=que(tre,xn+1-in[j]-1);\n            ss-=que(tb,in[j]-1);\n            add(tb,in[j],-1);\n        }\n        if(j==n)break;\n        ret+=n-j;\n    }\n    return ret;\n}\nint main(){\n    int i,j;\n    scanf(\"%d%I64d\",&n,&k);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&in[i]);\n        in2[i]=in[i];\n    }\n    //lshua\n    sort(in2,in2+n);\n    xn=unique(in2,in2+n)-in2;\n    for(i=0;i<xn;i++)xx[in2[i]]=i;\n    for(i=0;i<n;i++)in[i]=xx[in[i]]+1;\n    printf(\"%I64d\\n\",solve());\n}\n// vim: fdm=marker:commentstring=\\ \\\"\\ %s:nowrap:autoread\n\n"], "input": "", "output": "", "tags": ["data structures", "two pointers"], "dificulty": "2400", "interactive": false}