{
    "link": "https://codeforces.com//contest/2018/problem/F2",
    "problemId": "2905190",
    "problem_idx": "F2",
    "shortId": "2018F2",
    "contest_number": "2018",
    "problem_submissions": {
        "F1": [
            283240998,
            283223838,
            283219415,
            283236306,
            283222916,
            283217600,
            283233290,
            283231886,
            283231256,
            283232151,
            283229995,
            283237003,
            283235478,
            283237574,
            283236444,
            283230142,
            283243735,
            283243123,
            283242008,
            283243508
        ],
        "F2": [
            283240981,
            283223708,
            283219380,
            283241370,
            283223162,
            283225122,
            283233500,
            283231817,
            283231569,
            283232589,
            283230224,
            283236870,
            283235839,
            283237529,
            283238353,
            283243847,
            283243386,
            283242191,
            283243811
        ],
        "F3": [
            283240882,
            283223675,
            283219246,
            283271588,
            283270237,
            283224933,
            283229369,
            283236884,
            283231408,
            283234186,
            283238623,
            283246555,
            283236714,
            283242719,
            283237265,
            283240426,
            283246144,
            283243432,
            283242213,
            283244419
        ],
        "E2": [
            283228724,
            283271415,
            283952156,
            285367980,
            285366320,
            284023567,
            283309295
        ],
        "E1": [
            283228436,
            283232974,
            283271394,
            283269080,
            283266646,
            283248084,
            283226474,
            285366140,
            284023512,
            283309260,
            283237845
        ],
        "D": [
            283195973,
            283206733,
            283203886,
            283202562,
            283199647,
            283202135,
            283203009,
            283209326,
            283212471,
            283208248,
            283213153,
            283210604,
            283213401,
            283215308,
            283215785,
            283193803,
            283212467,
            283216433,
            283217858,
            283213030
        ],
        "C": [
            283191019,
            283190311,
            283188296,
            283196136,
            283191568,
            283193617,
            283197810,
            283200878,
            283205239,
            283197789,
            283193479,
            283202635,
            283205964,
            283204336,
            283202253,
            283186865,
            283201070,
            283203016,
            283201349,
            283204359
        ],
        "B": [
            283187765,
            283200401,
            283192789,
            283188636,
            283190321,
            283192212,
            283195063,
            283200019,
            283195292,
            283189706,
            283199364,
            283199549,
            283199094,
            283197971,
            283197559,
            283195753,
            283198921,
            283194967,
            283197864
        ],
        "A": [
            283182907,
            283184407,
            283187228,
            283181621,
            283185198,
            283186414,
            283185582,
            283191793,
            283185688,
            283183522,
            283193549,
            283187676,
            283189523,
            283193094,
            283182769,
            283189185,
            283185401,
            283198807,
            283189030
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "SolutionLemma 1For a fixed starting city, if you can win, this strategy\r\nworks: [Strategy 1] If there is a city on the right whose distance is\r\nand whose deadline is in turns, go to the right. Otherwise, go to the\r\nleft. Proof: All constraints on the right hold. This strategy minimizes\r\nthe time to reach any city on the left. So, if any strategy works, this\r\nstrategy works too. CorollaryFor a fixed starting city, if you can win,\r\nthis strategy works: [Strategy 2] If there is a city whose distance is\r\nand whose deadline is in turns, go to that direction. Otherwise, go to\r\nany direction. Lemma 2The valid starting cities are either zero, or all\r\nthe cities in .Proof: The cities outside are losing, because there\r\nexists at least one unreachable city. Letâs start from any city in , and\r\nuse Strategy 2. You want to show that, for any in , Strategy 2 can visit\r\nall cities in first, then all the other cities. Then, you can conclude\r\nthat either all the cities in are winning, or they are all losing. The\r\ninterval gives bounds on the : specifically, . Then, you can verify that\r\nvisiting the interval first does not violate Strategy 2. CorollaryIf you\r\nuse Strategy 1, the first move on the right determines . DPLetâs iterate\r\non the (non-empty) interval . Letâs calculate the bounds . Note that\r\nStrategy 1 is deterministic (i.e., it gives exactly one visiting order\r\nfor each fixed pair (starting city, )). From now, you will use Strategy\r\n1.Now you will calculate the number of pairs (, visiting order) such\r\nthat the cities in are valid starting cities (and there might be other\r\nvalid starting cities).Letâs define dp[i][j][k] = number of pairs (,\r\nvisiting order), restricted to the interval , where \"are you forced to\r\ngo to the right in the next move?\". Here are the main ideas to find the\r\ntransitions: If you go from to , you must ensure that (because you visit\r\nit at time ). Also, must be . If you go from to , and you want to make ,\r\nyou must make . It means that was the city that was enforcing you to go\r\nto the right. In my code, the result is stored in int_ans[i][j].Now you\r\nwant to calculate the number of pairs (, visiting order) such that the\r\ncities in are the only valid starting cities. This is similar to 2D\r\nprefix sums, and itâs enough to make int_ans[i][j] -= int_ans[i -\r\n1][j] + int_ans[i][j + 1] - int_ans[i - 1][j + 1].Since, for a fixed ,\r\nthe visiting order only depends on the starting city, the number of for\r\nthe interval is now int_ans[i][j] / (j - i + 1).You have solved . The\r\nanswer for is just minus all the other answers. DPIn the previous\r\nsection, you are running the same DP for different \"bound arrays\" on the\r\n(in particular, arrays for each ). Now you want to solve a single with a\r\nsingle DP.For a fixed , you can notice that, if you run the DP on an\r\narray of length instead of , the bound array obtained from contains all\r\nthe bound arrays you wanted as subarrays of length . So you can run the\r\nDP and get all the results as dp[i][i + n - 1][0]. DPYou still have\r\ndistinct states in total. How to make \"bound arrays\" simpler?It turns\r\nout that you can handle and differently! You can create bound arrays\r\nonly based on (and get distinct states), and find using the Corollary of\r\nLemma 2. The transitions before finding are very simple (you always go\r\nto the left). So a possible way to get complexity is processing Strategy\r\n1 and the DP in reverse order (from time to time ).Complexity:\r\n",
    "name": "F2. Speedbreaker Counting  Medium Version ",
    "statement": "This is the statement of : There are n cities in a row, numbered 1, 2,\r\nldots, n left to right. At time 1, you conquer exactly one city, called\r\nthe . At time 2, 3,\r\nldots, n, you can choose a city adjacent to the ones conquered so far\r\nand conquer it. You win if, for each i, you conquer city i at a time no\r\nlater than a_i. A winning strategy may or may not exist, also depending\r\non the starting city. How many starting cities allow you to win? For\r\neach 0\r\nleq k\r\nleq n, count the number of arrays of positive integers a_1, a_2,\r\nldots, a_n such that 1\r\nleq a_i\r\nleq n for each 1\r\nleq i\r\nleq n; the answer to is k. The answer can be very large, so you have to\r\ncalculate it modulo a given prime p.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned; u32 p;void inc(u32 &a, u32 b) {    a += b;    if (a >= p) {        a -= p;    }} u32 add(u32 a, u32 b) {    inc(a, b);    return a;} void solve() {    int n;    std::cin >> n >> p;        std::vector dp(n, std::vector<std::array<u32, 2>>(n));    for (int l = 0; l < n; l++) {        for (int r = n - 1; r >= l; r--) {            if (l == 0 && r == n - 1) {                dp[l][r][1] = 1;            } else {                if (r != n - 1) {                    dp[l][r][1] = (1ULL * dp[l][r + 1][1] * (n - (r - l + 1)) + dp[l][r + 1][0]) % p;                }                if (l != 0) {                    dp[l][r][0] = 1ULL * (dp[l - 1][r][1] + dp[l - 1][r][0]) * (n - (r - l + 1)) % p;                }            }        }    }        std::vector<u32> g(n);    for (int k = 0; k < n; k++) {        g[k] = 1;        for (int i = 0; i <= k; i++) {            g[k] = 1ULL * g[k] * (n - k + std::min(i, k - i)) % p;        }    }    std::vector<u32> ans(n + 1);    for (int l = 0; l < n; l++) {        for (int r = l; r < n; r++) {            inc(ans[r - l + 1], 1ULL * g[r - l] * (dp[l][r][0] + dp[l][r][1]) % p);        }    }    for (int i = n; i >= 1; i--) {        for (int j = i - 1; j >= 1; j--) {            inc(ans[j], 1ULL * ans[i] * (p - (i - j + 1)) % p);        }    }        u32 tot = 1;    for (int i = 1; i <= n; i++) {        tot = 1ULL * tot * n % p;    }    for (int i = 1; i <= n; i++) {        inc(tot, p - ans[i]);    }    ans[0] = tot;    for (int i = 0; i <= n; i++) {        std::cout << ans[i] << \" \\n\"[i == n];    }} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F2. Speedbreaker Counting  Medium Version .json",
    "hint": [
        "Hint 1 Suppose you are given a starting city and you want to win. Find several strategies to win (if possible) and try to work with the simplest ones.",
        "Hint 2 The valid starting cities are either zero, or all the cities in .",
        "Hint 3 Now you have some bounds on the .",
        "Hint 4 Fix the interval and try to find a (slow) DP.",
        "Hint 5 Counting paths seems easier than counting arrays. Make sure that, for each array, you make exactly one path (or a number of paths which is easy to handle).",
        "Hint 6 How many distinct states do you calculate in your DP?",
        "Hint 1 Think, how can we use the fact that we have to perform all the operations before seeing the array.",
        "Hint 2 Instead of just looping over to , we instead want to pass this information and get the real value later."
    ]
}