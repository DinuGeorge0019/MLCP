{"link": "https://codeforces.com//contest/295/problem/D", "problemId": "2837", "problem_idx": "D", "shortId": "295D", "contest_number": "295", "problem_submissions": {"E": [3511398, 3511419, 3511437, 3511617, 3512460, 3509679, 3512315, 3510900, 3508827, 3511729, 3510067, 3513473, 3512096, 3510503, 3513504, 3513446, 3513998, 3513357, 3512431], "D": [3509428, 3508084, 3508466, 3509763, 3509435, 3512601, 3509591, 3512430, 3510879, 3510319, 3512308, 3511034, 3506982, 3509190, 3509840, 3509472, 3580137], "C": [3508174, 3509402, 3509512, 3507449, 3507654, 3508191, 3508111, 3508096, 3513124, 3512841, 3513121, 3508464, 3508663, 3507348, 3507241, 3508781, 3507476, 3507076, 3507577, 3507688], "B": [3506807, 3505379, 3506165, 3505888, 3506089, 3506387, 3506261, 3505484, 3505919, 3507043, 3506794, 3509222, 3505786, 3505827, 3505874, 3505560, 3506566, 3506119], "A": [3505050, 3504656, 3505453, 3504455, 3504863, 3505059, 3505155, 3504693, 3504542, 3504788, 3504749, 3508036, 3504910, 3507685, 3504620, 3504661, 3556448, 3505140, 3504565]}, "name": "D. Greg and Caves", "statement": "Greg has a pad. The pad\u2019s screen is an rectangle, each cell can be\r\neither black or white. We\u2019ll consider the pad rows to be numbered with\r\nintegers from 1 to from top to bottom. Similarly, the pad\u2019s columns are\r\nnumbered with integers from 1 to from left to right.Greg thinks that the\r\npad\u2019s screen displays a cave if the following conditions hold: There is\r\na segment , such that each of the rows has exactly two black cells and\r\nall other rows have only white cells. There is a row number , such that\r\nfor all pairs of rows with numbers and the set of columns between the\r\nblack cells in row is the subset of the set of columns between the black\r\ncells in row . Similarly, for all pairs of rows with numbers and the set\r\nof columns between the black cells in row is the subset of the set of\r\ncolumns between the black cells in row . Greg wondered, how many ways\r\nthere are to paint a cave on his pad. Two ways can be considered\r\ndistinct if there is a cell that has distinct colors on the two\r\npictures.Help Greg.\r\n", "solutions": ["#include<algorithm>\n#include<cassert>\n#include<complex>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstring>\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define fup FOR\n#define fdo FORD\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define siz SZ\n#define CLR(x) memset((x), 0, sizeof(x))\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second \n#define FI X\n#define SE Y\n#define SQR(a) ((a)*(a))\n#define DEBUG 1\n#define debug(x) {if (DEBUG)cerr <<#x <<\" = \" <<x <<endl; }\n#define debugv(x) {if (DEBUG) {cerr <<#x <<\" = \"; FORE(it, (x)) cerr <<*it <<\", \"; cout <<endl; }}\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int>P;\ntypedef vector<int>VI;\nconst LL MOD=1E9+7;\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\n#define MAXN 2007\n\nLL n,m,dp[MAXN][MAXN],res;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n    cout << setprecision(15) << fixed;\n\t//in\n    cin >> n >> m;\n    m--;\n    if(m<=0) {cout << 0 << endl; return 0;}\n\t//sol\n    FOR(p,1,MAXN-1) {\n        LL sum = 0, pref = 0;\n        FOR(l,1,MAXN-1) {\n            pref += dp[p-1][l]; pref %= MOD;\n            sum += pref; sum %= MOD;\n            dp[p][l] = sum + 1; dp[p][l] %= MOD;\n        }\n    }\n//    cout << dp[1][1] << \" \" << dp[2][1] << endl;\n    FOR(r,1,n) FOR(s,1,m) {\n        res += ((dp[r][s] * dp[n-r+1][s]) % MOD) * (m-s+1);\n        res %= MOD;\n        if(r<n) {\n            res -= ((dp[r][s] * dp[n-r][s]) % MOD) * (m-s+1);\n            res %= MOD;\n        }\n    }\n\t//out\n    res %= MOD;\n    if(res<0) res += MOD;\n    cout << res << endl;\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2400", "interactive": false}