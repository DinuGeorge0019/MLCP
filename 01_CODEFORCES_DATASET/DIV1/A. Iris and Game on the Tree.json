{
    "link": "https://codeforces.com//contest/2006/problem/A",
    "problemId": "2845530",
    "problem_idx": "A",
    "shortId": "2006A",
    "contest_number": "2006",
    "problem_submissions": {
        "F": [
            278838627,
            278834885,
            278839605,
            278842896,
            283040284,
            278849665,
            279479840,
            279030892,
            278872889
        ],
        "E": [
            278816205,
            278815039,
            278825195,
            278819088,
            278823646,
            278824405,
            278834146,
            278833851,
            278836845,
            278834660,
            278831348,
            278835070,
            278824284,
            278835798,
            278834079,
            278836349,
            278834150,
            278840676,
            278837721,
            278840281
        ],
        "D": [
            278802409,
            278805803,
            278813224,
            278825476,
            278809587,
            278813203,
            278814738,
            278815896,
            278817434,
            278818422,
            278823248,
            278822269,
            278830412,
            278825693,
            278818908,
            278819966,
            278823289,
            278817077,
            278823950,
            278818832
        ],
        "C": [
            278788793,
            278798461,
            278801097,
            278797423,
            278800136,
            278800438,
            278797097,
            278802996,
            278798370,
            278802119,
            278807042,
            278803250,
            278809464,
            278800483,
            278808112,
            278808529,
            278813687,
            278799260,
            278808716,
            278807375
        ],
        "B": [
            278783201,
            278791628,
            278792112,
            278787764,
            278787151,
            278789090,
            278788997,
            278795304,
            278790397,
            278793228,
            278796651,
            278795483,
            278796854,
            278787538,
            278797112,
            278796560,
            278796305,
            278792796,
            278798821,
            278792242
        ],
        "A": [
            278774854,
            278780780,
            278783421,
            278777635,
            278777703,
            278778768,
            278777654,
            278780623,
            278781426,
            278784680,
            278779860,
            278783271,
            278779619,
            278776511,
            278786116,
            278783656,
            278783630,
            278778742,
            278777793,
            278783717
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133382",
    "editorial": "Consider a formed string. Let\u00e2\u0080\u0099s delete the useless part that doesn\u00e2\u0080\u0099t\r\ncontribute to the number of and substrings. We will get a string where\r\neach pair of adjacent bits is different. For example, . Then the weight\r\nof a leaf depends on the parity of the length of the string. You can\r\nalso see that the weight is non-zero if the value of the root is\r\ndifferent from the value of the leaf.If the value of the root is already\r\ndecided, the strategy is quite simple: just fill the values of the leaf\r\nnodes with a value different from or equal to the root. It\u00e2\u0080\u0099s easy to\r\ncalculate the answer.If the value of the root has not yet been decided,\r\nit seems optimal to fill it first. That\u00e2\u0080\u0099s because some values of the\r\nleaves have already been decided. When Iris chooses to colour the root\r\nat the very beginning, she will make the initial value larger (which is\r\nthe larger one of the counts of and in the leaves).However, this can go\r\nwrong when there are equal numbers of and in the leaf nodes. The first\r\nto colour the root may lose the advantage of being the first (and when\r\nthere are odd numbers of in the initial leaf nodes, Iris will colour one\r\nnode less). In this situation, the optimal choice is to colour the\r\nunimportant nodes the nodes that are neither the root nor a leaf. If\r\nthere is an odd number of in the unimportant nodes, then Dora will have\r\nto colour the root (after filling the in the unimportant nodes one by\r\none), which will cause Iris to colour the leaves first. When Dora\r\ncolours a leaf, Iris can colour another leaf with the opposite colour if\r\nthere is at least one leaf left; and colour the root with the opposite\r\ncolour if there is none left. So Dora will never choose to colour a leaf\r\nfirst in this case.To judge whether a node is a leaf, you can record the\r\ndegrees of the nodes.The time complexity is .\r\n",
    "name": "A. Iris and Game on the Tree",
    "statement": "Iris has a tree rooted at vertex 1. Each vertex has a value of\r\nmathtt 0 or\r\nmathtt 1.Let\u2019s consider a leaf of the tree (the vertex 1 is never\r\nconsidered a leaf) and define its . Construct a string formed by the\r\nvalues of the vertices on the path starting at the root and ending in\r\nthis leaf. Then the weight of the leaf is the difference between the\r\nnumber of occurrences of\r\nmathtt{10} and\r\nmathtt{01} substrings in it.Take the following tree as an example. Green\r\nvertices have a value of\r\nmathtt 1 while white vertices have a value of\r\nmathtt 0. Let\u2019s calculate the weight of the leaf 5: the formed string is\r\nmathtt{10110}. The number of occurrences of substring\r\nmathtt{10} is 2, the number of occurrences of substring\r\nmathtt{01} is 1, so the difference is 2 - 1 = 1. Let\u2019s calculate the\r\nweight of the leaf 6: the formed string is\r\nmathtt{101}. The number of occurrences of substring\r\nmathtt{10} is 1, the number of occurrences of substring\r\nmathtt{01} is 1, so the difference is 1 - 1 = 0.The of a tree is defined\r\nas the number of leaves with non-zero weight in the tree.But the values\r\nof some vertices haven\u2019t been decided and will be given to you as\r\ntexttt{?}. Filling the blanks would be so boring, so Iris is going to\r\ninvite Dora to play a game. On each turn, one of the girls chooses any\r\nof the remaining vertices with value\r\ntexttt{?} and changes its value to\r\nmathtt{0} or\r\nmathtt{1}, . The game continues until there are no vertices with value\r\nmathtt{?} left in the tree. Iris aims to maximize the score of the tree,\r\nwhile Dora aims to minimize that.Assuming that both girls play\r\noptimally, please determine the final score of the tree.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 30.08.2024 07:31:34**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int n;    cin >> n;    vector<vector<int>> g(n);    for (int i = 0; i < n - 1; i++) {      int x, y;      cin >> x >> y;      --x; --y;      g[x].push_back(y);      g[y].push_back(x);    }    string s;    cin >> s;    vector<int> cnt(3);    int skip = 0;    for (int i = 1; i < n; i++) {      if (g[i].size() == 1) {        int d = (s[i] == '?' ? 2 : int(s[i] - '0'));        cnt[d] += 1;      } else {        if (s[i] == '?') {          skip += 1;        }      }    }    int root = (s[0] == '?' ? 2 : int(s[0] - '0'));    int it = 0;    while (root == 2 || cnt[2] > 0) {      if (it == 0) {        if (root == 2) {          if (cnt[0] == cnt[1] && skip % 2 == 1) {            skip = 0;          } else {            root = (cnt[0] > cnt[1] ? 1 : 0);          }        } else {          cnt[2] -= 1;          cnt[root ^ 1] += 1;        }      } else {        if (root == 2) {          root = (cnt[0] > cnt[1] ? 0 : 1);        } else {          cnt[2] -= 1;          cnt[root] += 1;        }      }      it ^= 1;    }    cout << cnt[root ^ 1] << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "games",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Iris and Game on the Tree.json"
}