{"link": "https://codeforces.com//contest/1320/problem/B", "problemId": "551755", "problem_idx": "B", "shortId": "1320B", "contest_number": "1320", "problem_submissions": {"F": [72202332, 72223011, 72205107, 72198337, 72222998, 72196293, 72223902], "E": [72193224, 72190175, 72191679, 72192473, 72195171, 89517976, 72207354, 72207256, 72196434, 72194256, 72192283, 72199164, 72195289, 72197732, 72223673, 72193338, 72195901, 72200544, 72200353, 72200814, 72198992, 72200456], "C": [72184867, 72177670, 72177948, 72173628, 72175737, 72172966, 72176352, 72179230, 72175568, 72177066, 72173843, 72175840, 72176052, 72179445, 72190361, 72188981, 72179839, 72183510, 72186001, 72181401], "B": [72179476, 72169823, 72171581, 72177394, 72169041, 72168596, 72168669, 72172513, 72171074, 72169530, 72169385, 72171115, 72178856, 72172293, 72186108, 72169156, 72173456, 72185954, 72172093, 72178248], "D": [72176425, 72181800, 72183448, 72260282, 72184393, 72182092, 72185033, 72188594, 72279361, 72184633, 72186338, 72185288, 72188013, 72184398, 72189053, 72517140, 72199444, 72180732, 72186150, 72193094, 72172140, 72191769, 72190479], "A": [72166896, 72166972, 72167131, 72166858, 72166891, 72166853, 72166967, 72167271, 72166947, 72166915, 72167040, 72167216, 72167056, 72167066, 72166886, 72170109, 72167510, 72181754, 72167043, 72167049]}, "name": "B. Navigation System", "statement": "The map of Bertown can be represented as a set of n intersections,\r\nnumbered from 1 to n and connected by m one-way roads. It is possible to\r\nmove along the roads from any intersection to any other intersection.\r\nThe length of some path from one intersection to another is the number\r\nof roads that one has to traverse along the path. The shortest path from\r\none intersection v to another intersection u is the path that starts in\r\nv, ends in u and has the minimum length among all such paths.Polycarp\r\nlives near the intersection s and works in a building near the\r\nintersection t. Every day he gets from s to t by car. Today he has\r\nchosen the following path to his workplace: p_1, p_2, ..., p_k, where\r\np_1 = s, p_k = t, and all other elements of this sequence are the\r\nintermediate intersections, listed in the order Polycarp arrived at\r\nthem. Polycarp never arrived at the same intersection twice, so all\r\nelements of this sequence are pairwise distinct. .Polycarp\u2019s car has a\r\ncomplex navigation system installed in it. Let\u2019s describe how it works.\r\nWhen Polycarp starts his journey at the intersection s, the system\r\nchooses some shortest path from s to t and shows it to Polycarp. Let\u2019s\r\ndenote the next intersection in the chosen path as v. If Polycarp\r\nchooses to drive along the road from s to v, then the navigator shows\r\nhim the same shortest path (obviously, starting from v as soon as he\r\narrives at this intersection). However, if Polycarp chooses to drive to\r\nanother intersection w instead, the navigator the path: as soon as\r\nPolycarp arrives at w, the navigation system chooses some shortest path\r\nfrom w to t and shows it to Polycarp. The same process continues until\r\nPolycarp arrives at t: if Polycarp moves along the road recommended by\r\nthe system, it maintains the shortest path it has already built; but if\r\nPolycarp chooses some other path, the system the path by the same\r\nrules.Here is an example. Suppose the map of Bertown looks as follows,\r\nand Polycarp drives along the path [1, 2, 3, 4] (s = 1, t = 4): Check\r\nthe picture by the link http://tk.codeforces.com/a.png When Polycarp\r\nstarts at 1, the system chooses some shortest path from 1 to 4. There is\r\nonly one such path, it is [1, 5, 4]; Polycarp chooses to drive to 2,\r\nwhich is not along the path chosen by the system. When Polycarp arrives\r\nat 2, the navigator the path by choosing some shortest path from 2 to 4,\r\nfor example, [2, 6, 4] (note that it could choose [2, 3, 4]); Polycarp\r\nchooses to drive to 3, which is not along the path chosen by the system.\r\nWhen Polycarp arrives at 3, the navigator the path by choosing the only\r\nshortest path from 3 to 4, which is [3, 4]; Polycarp arrives at 4 along\r\nthe road chosen by the navigator, so the system does not have to rebuild\r\nanything. Overall, we get 2 rebuilds in this scenario. Note that if the\r\nsystem chose [2, 3, 4] instead of [2, 6, 4] during the second step,\r\nthere would be only 1 rebuild (since Polycarp goes along the path, so\r\nthe system maintains the path [3, 4] during the third step).The example\r\nshows us that the number of rebuilds can differ even if the map of\r\nBertown and the path chosen by Polycarp stays the same. Given this\r\ninformation (the map and Polycarp\u2019s path), can you determine the minimum\r\nand the maximum number of rebuilds that could have happened during the\r\njourney?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int> > edges(n);\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--;\n\t\tv--;\n\t\tedges[v].push_back(u);\n\t}\n\tint len;\n\tcin >> len;\n\tvector<int> path(len);\n\tfor(int i = 0; i < len; i++){\n\t\tcin >> path[i];\n\t\tpath[i]--;\n\t}\n\n\tint en = path.back();\n\tvector<int> dist(n, -1);\n\tvector<int> bfs;\n\tbfs.push_back(en);\n\tdist[en] = 0;\n\tint s = 0;\n\twhile(s < (int)bfs.size()){\n\t\tint v = bfs[s];\n\t\ts++;\n\t\tfor(int w : edges[v]){\n\t\t\tif(dist[w] == -1){\n\t\t\t\tdist[w] = dist[v] + 1;\n\t\t\t\tbfs.push_back(w);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> nout(n, 0);\n\tfor(int v = 0; v < n; v++){\n\t\tfor(int w : edges[v]){\n\t\t\tif(dist[w] == dist[v] + 1){\n\t\t\t\tnout[w]++;\n\t\t\t}\n\t\t}\n\t}\n\tint minv = 0;\n\tint maxv = 0;\n\tfor(int i = 0; i + 1 < len; i++){\n\t\tif(dist[path[i+1]] != dist[path[i]] - 1) minv++;\n\t\tif(dist[path[i+1]] != dist[path[i]] - 1 || nout[path[i]] != 1) maxv++;\n\t}\n\tcout << minv << ' ' << maxv << '\\n';\n}"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "shortest paths"], "dificulty": "1700", "interactive": false}