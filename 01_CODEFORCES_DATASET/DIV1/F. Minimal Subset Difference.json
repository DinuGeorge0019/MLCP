{"link": "https://codeforces.com//contest/956/problem/F", "problemId": "168084", "problem_idx": "F", "shortId": "956F", "contest_number": "956", "problem_submissions": {"D": [36593366, 36588204, 36587496, 36592289, 36586754, 36588274, 36591263, 36589846, 36592464, 36590122, 36593976, 36596887, 36592121, 36596341, 36592513, 36595632, 36591303, 36590631, 36596259, 36591080], "E": [36587738, 36592013, 36593444, 36590601, 36594002, 36595759, 36595160, 36598384, 36593817, 36599462, 36596926, 36592533, 36598235, 36594351, 36597963, 36598842, 36597808, 36592935, 36598993, 36594463], "C": [36581505, 36582901, 36583070, 36583190, 36582332, 36585605, 36587197, 36582980, 36586547, 36582470, 36583990, 36584599, 36584812, 36584631, 36582176, 36583908, 36599080, 36588304, 36587864], "B": [36579923, 36581052, 36580935, 36580991, 36579886, 36580741, 36581673, 36580683, 36585379, 36580850, 36580955, 36581441, 36582530, 36579783, 36580793, 36581999, 36586325, 36601723, 36601691, 36582893], "A": [36579305, 36579264, 36579274, 36579533, 36579182, 36584111, 36579353, 36579190, 36580060, 36579611, 36579457, 36579222, 36580218, 36579198, 36579466, 36579242, 36580204, 36579496, 36579376], "F": [36617999]}, "name": "F. Minimal Subset Difference", "statement": "We call a positive integer a -beautiful integer if and only if it is\r\npossible to split the multiset of its digits in the decimal\r\nrepresentation into two subsets such that the difference between the sum\r\nof digits in one subset and the sum of digits in the other subset is .\r\nEach digit should belong to exactly one subset after the split.There are\r\nqueries for you. Each query is described with three integers , and ,\r\nwhich mean that you are asked how many integers between and (inclusive)\r\nare -beautiful.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int DEBUG = 0;\nmt19937 mt(123);\n\nunordered_map<bitset<87>, int > ma[19];\nLL table[400000][10];\nint tcnt = 0;\n\ninline bitset<87> tra(bitset<87> b, int dig) {\n    bitset<87> res = (b << dig) | (b >> dig);\n    forn(i, dig) if (b.test(i)) {\n        res.set(dig - i);\n    }\n    return res;\n}\n\nint n;\nLL from, to;\nint k;\nvector<LL> ans;\n\nint solve(bitset<87> b, int rem) {\n    auto it = ma[rem].find(b);\n    if (it != ma[rem].end()) {\n        return it->second;\n    }\n    int ind = tcnt++;\n    if (rem == 0) {\n        int cur = 0;\n        forn(i, 10) {\n            cur |= b.test(i);\n            table[ind][i] = cur;\n        }\n    } else {\n        forn(i, 10) {\n            int cur = solve(tra(b, i), rem - 1);\n            forn(j, 10) {\n                table[ind][j] += table[cur][j];\n            }\n        }\n    }\n    return ma[rem][b] = ind;\n}\n\nLL solve(LL bound, int k) {\n    if (bound == 0) {\n        return 1;\n    }\n    vector<int> dig;\n    while (bound > 0) {\n        dig.pb(bound % 10);\n        bound /= 10;\n    }\n    reverse(dig.begin(), dig.end());\n    int sz = dig.size();\n    bitset<87> b;\n    b.reset();\n    b.set(0);\n    LL ans = 0;\n    forn(i, sz) {\n        forn(j, dig[i] + (i == sz - 1)) {\n            ans += table[solve(tra(b, j), sz - 1 - i)][k];\n        }\n        b = tra(b, dig[i]);\n    }\n    return ans;\n}\n\nLL gen(LL bound) {\n    int times = mt() % 60 + 1;\n    LL res = bound;\n    forn(i, times) {\n        res = mt() % bound + 1;\n    }\n    return res;\n}\n\nint main() {\n    if (DEBUG) {\n        n = 50000;\n    } else {\n        scanf(\"%d\", &n);\n    }\n    forn(i, n) {\n        if (DEBUG) {\n            from = gen(LL(1e18));\n            to = gen(LL(1e18));\n            if (from > to) {\n                swap(from, to);\n            }\n            k = mt() % 10;\n        } else {\n            scanf(\"%I64d%I64d%d\", &from, &to, &k);\n        }\n        ans.pb(solve(to, k) - solve(from - 1, k));\n    }\n    for (LL x : ans) printf(\"%I64d\\n\", x);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp"], "dificulty": "3200", "interactive": false}