{
    "link": "https://codeforces.com//contest/956/problem/F",
    "problemId": "168084",
    "problem_idx": "F",
    "shortId": "956F",
    "contest_number": "956",
    "problem_submissions": {
        "D": [
            36593366,
            36588204,
            36587496,
            36592289,
            36586754,
            36588274,
            36591263,
            36589846,
            36592464,
            36590122,
            36593976,
            36596887,
            36592121,
            36596341,
            36592513,
            36595632,
            36591303,
            36590631,
            36596259,
            36591080
        ],
        "E": [
            36587738,
            36592013,
            36593444,
            36590601,
            36594002,
            36595759,
            36595160,
            36598384,
            36593817,
            36599462,
            36596926,
            36592533,
            36598235,
            36594351,
            36597963,
            36598842,
            36597808,
            36592935,
            36598993,
            36594463
        ],
        "C": [
            36581505,
            36582901,
            36583070,
            36583190,
            36582332,
            36585605,
            36587197,
            36582980,
            36586547,
            36582470,
            36583990,
            36584599,
            36584812,
            36584631,
            36582176,
            36583908,
            36599080,
            36588304,
            36587864
        ],
        "B": [
            36579923,
            36581052,
            36580935,
            36580991,
            36579886,
            36580741,
            36581673,
            36580683,
            36585379,
            36580850,
            36580955,
            36581441,
            36582530,
            36579783,
            36580793,
            36581999,
            36586325,
            36601723,
            36601691,
            36582893
        ],
        "A": [
            36579305,
            36579264,
            36579274,
            36579533,
            36579182,
            36584111,
            36579353,
            36579190,
            36580060,
            36579611,
            36579457,
            36579222,
            36580218,
            36579198,
            36579466,
            36579242,
            36580204,
            36579496,
            36579376
        ],
        "F": [
            36617999
        ]
    },
    "name": "F. Minimal Subset Difference",
    "statement": "We call a positive integer a -beautiful integer if and only if it is\r\npossible to split the multiset of its digits in the decimal\r\nrepresentation into two subsets such that the difference between the sum\r\nof digits in one subset and the sum of digits in the other subset is .\r\nEach digit should belong to exactly one subset after the split.There are\r\nqueries for you. Each query is described with three integers , and ,\r\nwhich mean that you are asked how many integers between and (inclusive)\r\nare -beautiful.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int DEBUG = 0;\nmt19937 mt(123);\n\nunordered_map<bitset<87>, int > ma[19];\nLL table[400000][10];\nint tcnt = 0;\n\ninline bitset<87> tra(bitset<87> b, int dig) {\n    bitset<87> res = (b << dig) | (b >> dig);\n    forn(i, dig) if (b.test(i)) {\n        res.set(dig - i);\n    }\n    return res;\n}\n\nint n;\nLL from, to;\nint k;\nvector<LL> ans;\n\nint solve(bitset<87> b, int rem) {\n    auto it = ma[rem].find(b);\n    if (it != ma[rem].end()) {\n        return it->second;\n    }\n    int ind = tcnt++;\n    if (rem == 0) {\n        int cur = 0;\n        forn(i, 10) {\n            cur |= b.test(i);\n            table[ind][i] = cur;\n        }\n    } else {\n        forn(i, 10) {\n            int cur = solve(tra(b, i), rem - 1);\n            forn(j, 10) {\n                table[ind][j] += table[cur][j];\n            }\n        }\n    }\n    return ma[rem][b] = ind;\n}\n\nLL solve(LL bound, int k) {\n    if (bound == 0) {\n        return 1;\n    }\n    vector<int> dig;\n    while (bound > 0) {\n        dig.pb(bound % 10);\n        bound /= 10;\n    }\n    reverse(dig.begin(), dig.end());\n    int sz = dig.size();\n    bitset<87> b;\n    b.reset();\n    b.set(0);\n    LL ans = 0;\n    forn(i, sz) {\n        forn(j, dig[i] + (i == sz - 1)) {\n            ans += table[solve(tra(b, j), sz - 1 - i)][k];\n        }\n        b = tra(b, dig[i]);\n    }\n    return ans;\n}\n\nLL gen(LL bound) {\n    int times = mt() % 60 + 1;\n    LL res = bound;\n    forn(i, times) {\n        res = mt() % bound + 1;\n    }\n    return res;\n}\n\nint main() {\n    if (DEBUG) {\n        n = 50000;\n    } else {\n        scanf(\"%d\", &n);\n    }\n    forn(i, n) {\n        if (DEBUG) {\n            from = gen(LL(1e18));\n            to = gen(LL(1e18));\n            if (from > to) {\n                swap(from, to);\n            }\n            k = mt() % 10;\n        } else {\n            scanf(\"%I64d%I64d%d\", &from, &to, &k);\n        }\n        ans.pb(solve(to, k) - solve(from - 1, k));\n    }\n    for (LL x : ans) printf(\"%I64d\\n\", x);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Minimal Subset Difference.json",
    "editorial_link": "https://codeforces.com//blog/entry/58544",
    "editorial": "Let f(x) be the minimal subset difference mentioned in the problem statement. The problem seems like a regular digit DP problem. However, it's a bit hard to reduce the number of DP states. Let's take a careful consideration.\n\nFor a given integer x, we can use knapsack DP to determine f(x). Denote the sum of digits of x as s(x). You can just calculate whether there is a subset such that the sum of the subset is a fixed number y, and then find the maximal y  which concludes f(x)?=?s(x)?-?2y. By the way, this type of knapsack DP could be implemented by bitwise operation.\n\nIf we defined dp(len,?sum,?state) as the number of integers x such that the length of x is len, the digit sum is sum, and the knapsack DP array is state (an array only consisting 0 and 1, which could be represented as bit vector), the problem would be difficult to solve. For example, to represent x?=?88888888899999999, a case of f(x)?=?0, the length of state might be 73, which is a bit long vector. Although most of states satisfy dp(len,?sum,?state)?=?0, there are still many states which might be used.\n\nYou may notice the order of digits is unnecessary for the knapsack DP. If we defined state as the number of appearance of digits 1,?2,?...,?9 (digit 0 is unnecessary), the number of states would be . Hence, we can apply knapsack DP for each state first and then calculate for digit DP.\n\nHere are more details. Let's redefine dp(len,?k,?state) as the number of ways to arrange the lowest len digits of x such that f(x)?=?k and the other digits (higher than the lowest len digits) form the state (i. e. the number of appearance of digits 1,?2,?...,?9). We firstly search all the states such that the total number of appearance ???18 and f(x)?=?k, and then set dp(0,?k,?state)?=?1. After searching, we calculate dp(len,?k,?new state) from dp(len?-?1,?k,?state)?>?0 by enumerating the len-th digit.\n\nHowever, the number of dp(len,?k,?state)?>?0 is still too large to calculate for digit DP. You should notice that in decimal representation it always has 0???f(x)???9 for any integer x. Furthermore, because of the distribution of digits, most of states are in cases of f(x)?=?0,?1 (you can make a knapsack DP to prove). In addition, it is easy to show f(x) and s(x) always have the same parity, so we can apply inclusion-exclusion principle to solve the problem only in the cases of f(x)???2 and another counting problem with fixed parity of s(x).\n\nThe total time complexity in above is , where L (?=?18) is the maximal length of x, D (?=?9) is the maximal digit, and S (???3·104) is the number of distinct states such that there exists dp(len,?k,?state)?>?0 (0???len???L,?2???k???9). However, it can hardly pass the tests with n?=?5·104, because we have some fairly worse tests to maximize the times of dp access (e. g. l and r have a lot of 9 as digits and k?=?1).\n\nWe could make a tradeoff between pretreatment and queries by several ways. For example, define dp(len,?k,?state,?upp) as the similar but it memorizes that the len-th digit is less than upp. If we did that, the total time complexity would be , which is acceptable.\n\nThe aforementioned solution is not easy to code; you can use some advanced approach to get accepted, though. Here are bonuses for advanced solutions.",
    "hint": []
}