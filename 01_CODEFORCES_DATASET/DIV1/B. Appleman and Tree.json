{"link": "https://codeforces.com//contest/461/problem/B", "problemId": "13281", "problem_idx": "B", "shortId": "461B", "contest_number": "461", "problem_submissions": {"E": [7595647, 7593699, 7595828, 7594579, 7595368, 7600512, 7595421, 7661605, 9294347, 9294343, 10452636], "D": [7592651, 7591771, 7603387, 7594572, 7594433, 7594196, 7595170, 7595635, 7724393, 7593683, 7594245, 7661058, 8893908, 10452336], "C": [7587261, 7587069, 7586600, 7586584, 7590688, 7588429, 7587923, 7590253, 7588926, 7591752, 7589784, 7592394, 7587055, 7589392, 7587666, 7587706, 7588473], "B": [7582196, 7583106, 209010830, 7582794, 7583033, 7586901, 7583221, 7584128, 7587075, 7584566, 7585023, 7585807, 7586879, 7595401, 7583774, 7584143, 7583861], "A": [7580528, 7580809, 7580521, 7581246, 7587762, 7581843, 7580912, 7581190, 7581018, 7581719, 7581029, 7581078, 7581003, 7584251, 7580442, 7580814, 7580452]}, "name": "B. Appleman and Tree", "statement": "Appleman has a tree with vertices. Some of the vertices (at least one)\r\nare colored black and other vertices are colored white.Consider a set\r\nconsisting of edges of Appleman\u2019s tree. If Appleman deletes these edges\r\nfrom the tree, then it will split into parts. Note, that each part will\r\nbe a tree with colored vertices.Now Appleman wonders, what is the number\r\nof sets splitting the tree in such a way that each resulting part will\r\nhave exactly one black vertex? Find this number modulo ().\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\nconst int MAX_N = int(1e5) + 10;\nconst int MOD = int(1e9) + 7;\n\nvoid addIt(int&x, int c) {\n\tx += c;\n\tif (x >= MOD)\n\t\tx -= MOD;\n}\n\nvector<int> E[MAX_N];\nint col[MAX_N];\nint n;\n\nint dp[MAX_N][2]; //white, black\n\nvoid dfs(int u, int par) {\n//\tfor (auto v : E[u])\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tint v = *e;\n\t\tif (v != par) {\n\t\t\tdfs(v, u);\n\t\t}\n\t}\n\tvector<int> am(2, 0);\n\tam[col[u]] = 1;\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tint v = *e;\n\t\tif (v != par) {\n\t\t\tint*ch = dp[v];\n\t\t\tvector<int> nam(2, 0);\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t//link\n\t\t\t\t\tif (i + j < 2)\n\t\t\t\t\t\taddIt(nam[i + j], 1LL * am[i] * ch[j] % MOD);\n\t\t\t\t\t//cut\n\t\t\t\t\tif (j == 1)\n\t\t\t\t\t\taddIt(nam[i], 1LL * am[i] * ch[j] % MOD);\n\t\t\t\t}\n\t\t\t}\n\t\t\tam = nam;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 2; ++i) {\n\t\tdp[u][i] = am[i];\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\tE[i].push_back(p), E[p].push_back(i);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", col + i);\n\t}\n\tdfs(0, -1);\n\tcout << dp[0][1] << endl;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "trees"], "dificulty": "2000", "interactive": false}