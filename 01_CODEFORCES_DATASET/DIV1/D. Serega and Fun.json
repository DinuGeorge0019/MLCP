{
    "link": "https://codeforces.com//contest/455/problem/D",
    "problemId": "12120",
    "problem_idx": "D",
    "shortId": "455D",
    "contest_number": "455",
    "problem_submissions": {
        "E": [
            7394351,
            7390143,
            7393335,
            7395556,
            15950366,
            7394387,
            7394798
        ],
        "D": [
            7390969,
            7390195,
            7391117,
            7392248,
            7394913,
            7394348,
            7389780,
            7389657,
            7393511,
            7427462,
            7392513,
            7396567
        ],
        "C": [
            7383856,
            7385374,
            7383929,
            7385253,
            7385742,
            7386825,
            7385353,
            7386072,
            7389234,
            7384477,
            7386261,
            7393242,
            7386556,
            148174431,
            7387128,
            7390044,
            7381535,
            7386375,
            7388516,
            7385462
        ],
        "B": [
            7380394,
            7383005,
            7381184,
            7382059,
            7379729,
            7383546,
            7382905,
            7382344,
            7384255,
            7398378,
            7387760,
            7396316,
            7385727,
            7384109,
            7413972,
            7384883,
            7405728,
            7405656,
            7398462,
            7398419,
            7381057
        ],
        "A": [
            7377249,
            7377722,
            7377369,
            7377768,
            7390843,
            7377960,
            7377218,
            7378095,
            7377940,
            7377402,
            7377315,
            7378476,
            7377536,
            7377288,
            7378601,
            7384879,
            7385848,
            7377439,
            7377794
        ]
    },
    "name": "D. Serega and Fun",
    "statement": "Serega loves fun. However, everyone has fun in the unique manner. Serega\r\nhas fun by solving query problems. One day Fedor came up with such a\r\nproblem.You are given an array consisting of positive integers and\r\nqueries to it. The queries can be of two types: Make a unit cyclic shift\r\nto the right on the segment from to (both borders inclusive). That is\r\nrearrange elements of the array in the following manner: Count how many\r\nnumbers equal to are on the segment from to (both borders inclusive).\r\nFedor hurried to see Serega enjoy the problem and Serega solved it\r\nreally quickly. Let\u2019s see, can you solve it?\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 200010;\nconst int MAGIC = 474;\n\nint len;\nint a[N];\n\nint cnt, from[N], to[N];\nvector <int> where[N];\n\nvoid init() {\n  cnt = 1;\n  from[0] = 1;\n  to[0] = len;\n  for (int i = 1; i <= len; i++) {\n    where[i].clear();\n  }\n  for (int i = 1; i <= len; i++) {\n    where[a[i]].push_back(i);\n  }\n}\n\nint get_count(int k, int from, int to) {\n  int sz = where[k].size();\n  if (sz == 0) {\n    return 0;\n  }\n  int low = 0, high = sz;\n  while (low < high) {\n    int mid = (low + high) >> 1;\n    if (where[k][mid] < from) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  int X = low;\n  low = -1, high = sz - 1;\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    if (where[k][mid] > to) {\n      high = mid - 1;\n    } else {\n      low = mid;\n    }\n  }\n  int Y = low;\n  return (Y - X + 1);\n}\n\nint new_from[N], new_to[N];\n\nint bounds[4], bound_id;\n\nvoid cut(int b0, int b1, int b2) {\n  bounds[0] = b0;\n  bounds[1] = b1;\n  bounds[2] = b2;\n  bounds[3] = 123456789;\n  bound_id = 0;\n  int new_cnt = 0;\n  int sum = 0;\n  for (int i = 0; i < cnt; i++) {\n    int new_sum = sum + (to[i] - from[i] + 1);\n    if (new_sum <= bounds[bound_id]) {\n      if (new_sum == bounds[bound_id]) {\n        bound_id++;\n      }\n      new_from[new_cnt] = from[i];\n      new_to[new_cnt] = to[i];\n      new_cnt++;\n      sum = new_sum;\n      continue;\n    }\n    int get = bounds[bound_id] - sum;\n    new_from[new_cnt] = from[i];\n    new_to[new_cnt] = from[i] + get - 1;\n    new_cnt++;\n    from[i] += get;\n    sum += get;\n    bound_id++;\n    i--;\n  }\n  cnt = new_cnt;\n  for (int i = 0; i < cnt; i++) {\n    from[i] = new_from[i];\n    to[i] = new_to[i];\n  }\n}\n\nint new_a[N];\n\nint main() {\n  scanf(\"%d\", &len);\n  for (int i = 1; i <= len; i++) {\n    scanf(\"%d\", a + i);\n  }\n  init();\n  int tt;\n  scanf(\"%d\", &tt);\n  int lastans = 0;\n  for (int qq = 1; qq <= tt; qq++) {\n    int com;\n    scanf(\"%d\", &com);\n    if (com == 2) {\n      int ll, rr, kk;\n      scanf(\"%d %d %d\", &ll, &rr, &kk);\n      ll = ((ll + lastans - 1) % len) + 1;\n      rr = ((rr + lastans - 1) % len) + 1;\n      kk = ((kk + lastans - 1) % len) + 1;\n      if (ll > rr) {\n        swap(ll, rr);\n      }\n      int ans = 0;\n      int sum = 0;\n      for (int i = 0; i < cnt; i++) {\n        int x = from[i], y = to[i];\n        int begin = sum + 1, end = sum + (y - x + 1);\n        if (ll > begin) {\n          x += ll - begin;\n        }\n        if (rr < end) {\n          y -= end - rr;\n        }\n        if (x <= y) {\n          ans += get_count(kk, x, y);\n        }\n        sum = end;\n      }\n      lastans = ans;\n      printf(\"%d\\n\", ans);\n    } else {\n      int ll, rr;\n      scanf(\"%d %d\", &ll, &rr);\n      ll = ((ll + lastans - 1) % len) + 1;\n      rr = ((rr + lastans - 1) % len) + 1;\n      if (ll > rr) {\n        swap(ll, rr);\n      }\n      if (ll == rr) {\n        continue;\n      }\n      cut(ll - 1, rr - 1, rr);\n      int first = -1;\n      int sum = 0;\n      for (int i = 0; i < cnt; i++) {\n        if (sum == ll - 1) {\n          first = i;\n        }\n        sum += to[i] - from[i] + 1;\n        if (sum == rr) {\n          int p = from[i];\n          for (int j = i; j > first; j--) {\n            from[j] = from[j - 1];\n            to[j] = to[j - 1];\n          }\n          from[first] = to[first] = p;\n          break;\n        }\n      }\n    }\n    if (cnt > MAGIC) {\n      int pos = 0;\n      for (int i = 0; i < cnt; i++) {\n        for (int j = from[i]; j <= to[i]; j++) {\n          new_a[++pos] = a[j];\n        }\n      }\n      for (int i = 1; i <= len; i++) {\n        a[i] = new_a[i];\n      }\n      init();\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Serega and Fun.json",
    "editorial_link": "https://codeforces.com//blog/entry/13336",
    "editorial": "Let\u00e2\u0080\u0099s change the query type to two\nmore simple requests: Erase a number from -th position. Insert this\nnumber after -th position. Now let\u00e2\u0080\u0099s keep our array as blocks. In each\nblock will store the numbers themselves in such a manner as in the array\nand will store an array . number of integers in block. This requires\nspace. Now we can fast process the queries of the st type. We can erase\nnumber from -th position in operations. And we can insert this number\nafter -th position in operations. Also we can fast recalc after\ntransformations. Also we can fast process the queries of the Unable to\nparse markup [type=CF_TEX] To keep the size of the blocks close to , we\nneed rebuild our structure after each -th query of the st type. We can\nrebuild structure in operations. Asymptotics .\n"
}