{
    "link": "https://codeforces.com//contest/947/problem/F",
    "problemId": "164142",
    "problem_idx": "F",
    "shortId": "947F",
    "contest_number": "947",
    "problem_submissions": {
        "C": [
            36173454,
            36158955,
            36159580,
            36159099,
            36160344,
            36163522,
            36159314,
            36160080,
            36160850,
            36161300,
            36159923,
            36161359,
            36160490,
            36159503,
            36160981,
            36162645,
            36160904,
            36159951,
            36161496
        ],
        "E": [
            36168563,
            36236455,
            36170443,
            39088009
        ],
        "B": [
            36164839,
            36156882,
            36157486,
            36156947,
            36158529,
            36159543,
            36158110,
            36157900,
            36155578,
            36159650,
            36157136,
            36158516,
            36157266,
            36157820,
            36159109,
            36159552,
            36158553,
            36157744,
            36159160
        ],
        "D": [
            36162982,
            36163865,
            36166846,
            36164126,
            36164997,
            36171948,
            36177192,
            36164630,
            36165682,
            36165588,
            36166182,
            36171226,
            36166510,
            36166759,
            36167046,
            36167052,
            36169076,
            36165891,
            36168487
        ],
        "A": [
            36160906,
            36154995,
            36155654,
            36155514,
            36156087,
            36157563,
            36155459,
            36156152,
            36158089,
            36157373,
            36155161,
            36155827,
            36155589,
            36156282,
            36157634,
            36156202,
            36156868,
            36156079,
            36157276
        ],
        "F": [
            36230948
        ]
    },
    "name": "F. Public Service",
    "statement": "There are cities in Bob’s country connected by roads. Some pairs of\r\ncities are connected by public transport. There are two competing\r\ntransport companies operating buses and running trains. When traveling\r\nfrom to , a passenger always first selects the mode of transport (either\r\nbus or train), and then embarks on a journey. For every pair of cities,\r\nthere are exactly two ways of how to travel between them without\r\nvisiting any city more than once one using only bus routes, and the\r\nsecond using only train routes. Furthermore, there is no pair of cities\r\nthat is directly connected by both a bus route and a train route.You\r\nobtained the plans of each of the networks. Unfortunately, each of the\r\ncompanies uses different names for the same cities. More precisely, the\r\nbus company numbers the cities using integers from to , while the train\r\ncompany uses integers between and . Find one possible mapping between\r\nthose two numbering schemes, such that no pair of cities is connected\r\ndirectly by both a bus route and a train route. Note that this mapping\r\nhas to map different cities to different cities.\r\n",
    "solutions": [
        "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXN = 10000;\n\nstruct T {\n\tint n;\n\tvector<int> adj[MAXN];\n\n\tbool alive[MAXN]; int nalive;\n\tint deg[MAXN];\n\tint afst[MAXN], alst[MAXN], anxt[MAXN], aprv[MAXN]; // doubly-linked lists for leaves adjacent to a node\n\tint bfst, blst, bnxt[MAXN], bprv[MAXN]; // doubly-linked lists for nodes adjacent to at least one leaf\n\tpriority_queue<pair<int, int> > pq;\n\n\tvoid init() {\n\t\tnalive = n; REP(i, n) alive[i] = true, deg[i] = SZ(adj[i]), afst[i] = alst[i] = -1; bfst = blst = -1;\n\t\tREP(at, n) if (deg[at] == 1) aappend(at, adj[at][0]);\n\t\tREP(at, n) if (afst[at] != -1) bappend(at);\n\t\tpq = priority_queue<pair<int, int> >(); REP(i, n) pq.push(MP(deg[i], i));\n\t}\n\tvoid killleaf(int at) {\n\t\tassert(deg[at] == 1); alive[at] = false; --nalive;\n\t\tint to = -1; REPSZ(i, adj[at]) if (alive[adj[at][i]]) { assert(to == -1); to = adj[at][i]; } assert(to != -1);\n\t\t--deg[at]; if (deg[at] == 0) { aremove(at, to); if (afst[to] == -1) bremove(to); }\n\t\t--deg[to]; pq.push(MP(deg[to], to)); if (deg[to] == 0) { aremove(to, at); if (afst[at] == -1) bremove(at); }\n\t\tif (deg[to] == 1) {\n\t\t\tint oth = -1; REPSZ(i, adj[to]) if (alive[adj[to][i]]) { assert(oth == -1); oth = adj[to][i]; } assert(oth != -1);\n\t\t\taappend(to, oth);\n\t\t\tif (afst[oth] == to&&anxt[to] == -1) bappend(oth);\n\t\t}\n\t}\n\tvoid aappend(int at, int to) {\n\t\taprv[at] = alst[to], anxt[at] = -1; if (aprv[at] == -1) afst[to] = at; else anxt[aprv[at]] = at; alst[to] = at;\n\t}\n\tvoid aremove(int at, int to) {\n\t\tif (aprv[at] == -1) afst[to] = anxt[at]; else anxt[aprv[at]] = anxt[at];\n\t\tif (anxt[at] == -1) alst[to] = aprv[at]; else aprv[anxt[at]] = aprv[at];\n\t}\n\tvoid bappend(int at) {\n\t\tbprv[at] = blst, bnxt[at] = -1; if (bprv[at] == -1) bfst = at; else bnxt[bprv[at]] = at; blst = at;\n\t}\n\tvoid bremove(int at) {\n\t\tif (bprv[at] == -1) bfst = bnxt[at]; else bnxt[bprv[at]] = bnxt[at];\n\t\tif (bnxt[at] == -1) blst = bprv[at]; else bprv[bnxt[at]] = bprv[at];\n\t}\n\tbool getleavesatleastthreeapart(pair<int,int> &u, pair<int,int> &v) {\n\t\tif (bfst == -1 || bnxt[bfst] == -1) return false;\n\t\tint x = bfst, y = bnxt[bfst], r = maxdeg().second; if (afst[r] != -1 && x != r) y = r;\n\t\tu = MP(afst[x], x), v = MP(afst[y], y); assert(u.first != -1 && v.first != -1); return true;\n\t}\n\tpair<int, int> maxdeg() { while (!pq.empty() && (!alive[pq.top().second] || deg[pq.top().second] != pq.top().first)) pq.pop(); return !pq.empty() ? pq.top() : MP(0, -1); }\n\tbool isstar() { return maxdeg().first == nalive - 1; }\n\tbool issemistar() { return maxdeg().first == nalive - 2; }\n\tbool ispath() { return maxdeg().first <= 2; }\n\tbool getsemistar1(vector<int> &rem) {\n\t\tif (!issemistar()) return false; assert(bfst != -1 && bnxt[bfst] != -1 && bnxt[bnxt[bfst]] == -1);\n\t\tint w = maxdeg().second; assert(bfst == w || bnxt[bfst] == w); int v = bfst + bnxt[bfst] - w; assert(afst[v] != -1 && anxt[afst[v]] == -1); int u = afst[v];\n\t\trem.clear(); rem.PB(u); rem.PB(v); rem.PB(w); REP(i, n) if (alive[i] && i != u&&i != v&&i != w) rem.PB(i); return true;\n\t}\n\tbool getsemistar2(vector<int> &rem) {\n\t\tif (isstar()) return false; assert(bfst != -1 && bnxt[bfst] != -1); int u = bfst, w = afst[u], v = afst[bnxt[bfst]]; assert(w != -1 && u != -1);\n\t\trem.clear(); rem.PB(u); rem.PB(v); rem.PB(w); REP(i, n) if (alive[i] && i != u&&i != v&&i != w) rem.PB(i); return true;\n\t}\n\tbool getpath1(vector<int> &rem) {\n\t\tif (!ispath()) return false;\n\t\tint at = -1; REP(i, n) if (alive[i] && deg[i] <= 1) { at = i; break; } assert(at != -1);\n\t\trem.PB(at); while (true) { int to = -1; REPSZ(i, adj[at]) if (alive[adj[at][i]] && (SZ(rem) == 1 || adj[at][i] != rem[SZ(rem) - 2])) { assert(to == -1); to = adj[at][i]; } if (to == -1) break; at = to; rem.PB(at); } return SZ(rem) == 5;\n\t}\n\tbool getpath2(vector<int> &rem) {\n\t\tif (!getpath1(rem)) return false;\n\t\tswap(rem[0], rem[2]); swap(rem[0], rem[4]); swap(rem[0], rem[3]); swap(rem[0], rem[1]); return true;\n\t}\n};\n\nint n;\nT a, b;\nint mp[MAXN];\nstruct Op { pair<int, int> au, av, bu, bv; };\nvector<Op> ops;\n\n\nvoid run() {\n\tscanf(\"%d\", &n);\n\ta.n = n; REP(i, n - 1) { int u, v; scanf(\"%d%d\", &u, &v); --u, --v; a.adj[u].PB(v); a.adj[v].PB(u); } a.init();\n\tb.n = n; REP(i, n - 1) { int u, v; scanf(\"%d%d\", &u, &v); --u, --v; u -= n; v -= n; b.adj[u].PB(v); b.adj[v].PB(u); } b.init();\n\n\tif (a.isstar() || b.isstar()) { printf(\"No\\n\"); return; }\n\tREP(i, n) mp[i] = -1; ops.clear();\n\twhile (true) {\n\t\t//printf(\"maxdeg: (%d,%d) (%d,%d)\\n\", a.maxdeg().first, a.maxdeg().second + 1, b.maxdeg().first, b.maxdeg().second + 1 + n);\n\t\tif (a.issemistar()) {\n\t\t\t//printf(\"a semistar\\n\");\n\t\t\tvector<int> arem; assert(a.getsemistar1(arem));\n\t\t\tvector<int> brem; assert(b.getsemistar2(brem));\n\t\t\tassert(a.nalive == b.nalive&&SZ(arem) == a.nalive&&SZ(brem) == b.nalive);\n\t\t\tREPSZ(i, arem) mp[arem[i]] = brem[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (b.issemistar()) {\n\t\t\t//printf(\"b semistar\\n\");\n\t\t\tvector<int> arem; assert(a.getsemistar2(arem));\n\t\t\tvector<int> brem; assert(b.getsemistar1(brem));\n\t\t\tassert(a.nalive == b.nalive&&SZ(arem) == a.nalive&&SZ(brem) == b.nalive);\n\t\t\tREPSZ(i, arem) mp[arem[i]] = brem[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (a.nalive == 5 || b.nalive == 5) {\n\t\t\tassert(a.nalive == 5 && b.nalive == 5 && a.ispath() && b.ispath());\n\t\t\t//printf(\"5 path\\n\");\n\t\t\tvector<int> arem; assert(a.getpath1(arem));\n\t\t\tvector<int> brem; assert(b.getpath2(brem));\n\t\t\tassert(a.nalive == b.nalive&&SZ(arem) == a.nalive&&SZ(brem) == b.nalive);\n\t\t\tREPSZ(i, arem) mp[arem[i]] = brem[i];\n\t\t\tbreak;\n\t\t}\n\t\tassert(a.nalive >= 6 && b.nalive >= 6);\n\t\t//printf(\"general case: \");\n\t\tpair<int,int> au, av; assert(a.getleavesatleastthreeapart(au, av));\n\t\tpair<int,int> bu, bv; assert(b.getleavesatleastthreeapart(bu, bv));\n\t\t//printf(\"(%d,%d) and (%d,%d)\\n\", au.first + 1, av.first + 1, bu.first + n + 1, bv.first + n + 1);\n\t\ta.killleaf(au.first); a.killleaf(av.first);\n\t\tb.killleaf(bu.first); b.killleaf(bv.first);\n\t\tOp op; op.au = au, op.av = av, op.bu = bu, op.bv = bv; ops.PB(op);\n\t}\n\tfor (int i = SZ(ops) - 1; i >= 0; --i) {\n\t\tpair<int, int> au = ops[i].au, av = ops[i].av, bu = ops[i].bu, bv = ops[i].bv;\n\t\tif (mp[au.second] != bu.second&&mp[av.second] != bv.second) { mp[au.first] = bu.first; mp[av.first] = bv.first; continue; }\n\t\tif (mp[au.second] != bv.second&&mp[av.second] != bu.second) { mp[au.first] = bv.first; mp[av.first] = bu.first; continue; }\n\t\tassert(false);\n\t}\n\tprintf(\"Yes\\n\");\n\tREP(i, n) { if (i != 0) printf(\" \"); printf(\"%d\", mp[i] == -1 ? -1 : mp[i] + n + 1); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "trees"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Public Service.json",
    "editorial_link": "https://codeforces.com//blog/entry/58286",
    "editorial": "For k???0, we call graph G a k-star, if we can remove k vertices to form a star, and we cannot remove k?-?1 vertices to form a star. In this terminology, a 0-star is a star.\n\nIt should be rather obvious that if one of the graphs is a 0-star, then the answer is clearly No. This is because the minimum degree of a vertex in a tree is 1, and star has a vertex of degree N?-?1, and the corresponding vertex in the merged graph would have degree at least N, which is clearly impossible.\n\nSurprisingly, the answer is Yes in all other cases. We prove this by giving an explicit construction. There are three cases:\n\nAssume that one of the graphs is 1-star. Without loss of generality let it be G. Denote v the vertex that can be removed to turn G into star, u its only neighbor, and w be the vertex of degree N?-?2. In graph H, find any leaf and denote it w'. Let its only neighbour be u'. Furthermore, pick v' a vertex that is not adjacent to u' (such vertex always exists as H is not a star). Observe that mapping ,  and  does not introduce multiedges in the merged graph. Furthermore, all other edges in G are incident to w, but none of the unprocessed edges in H are incident to w'. We can thus map the remaining N?-?3 vertices arbitrarily.\n\n\nMapping a 1-star G (in red), to arbitrary tree H (in blue). See that there are no multiedges between u,?v,?w, no multiedges from u,?v,?w to the rest of the graph (since u, v and w' have no neighbours there), and no multiedges in the rest of the graph (since  is a graph with zero edges).\n\nN?=?4 or N?=?5: There are only five non-isomorphic trees on this many vertices. Two of them are 0-stars (for which the answer is No), two of them are 1-stars (that we handled in previous case). The only remaining graph is a path on five vertices. Two such graphs can always be merged together. For simplicity of implementation, we can simply try all 5! possible mappings.\n\n\nAll trees on 4 or 5 vertices.\n\nOtherwise, we use induction. In G, find two leaves u and v such that d(u,?v)???3 and  is not a star. This is always possible: either G is a 2-star, and then we can pick one of the neighbouring leaves of the vertex with highest degree and one other leaf, or we can pick any two leaves that are not adjacent to the same vertex. Do the same thing for H, finding u' and v'. Remove these pairs of vertices from the respective graphs and use induction to merge those smaller graphs. Now we can either map ,  or ,   as only one of these mappings may introduce a multiedge.\nThe above is relatively simple to implement in . To turn it into an  algorithm, we need to maintain a few additional information about the graph. Furthemore, note that a graph G is a k-star if and only if the maximum degree is |G|?-?k?-?1.\n\nThe list vertices sorted by their degree, for instance using set of pairs. This is so that we can find the vertex with maximum degree easily, which is useful for testing k-starness.\nthe set of vertices with a leaf neighbour, and\nthe set of leaves neighbouring a given vertex, so that we can find the leaves quickly\nUsing the above, we can always find appropriate leaf and remove it in , which is sufficient.",
    "hint": []
}