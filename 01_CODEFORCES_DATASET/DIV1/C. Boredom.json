{"link": "https://codeforces.com//contest/853/problem/C", "problemId": "121090", "problem_idx": "C", "shortId": "853C", "contest_number": "853", "problem_submissions": {"D": [30147648, 30145874, 30152169, 30145670, 30147401, 30148548, 30157869, 30157814, 30157512, 30150989, 30149728, 30151353, 30151549, 30150847, 30147708, 30168803, 30167984, 30151241, 30151140, 30151931, 30151709, 30155800, 30154094, 30151955], "C": [30142518, 30148496, 30147073, 30143792, 30144399, 30146037, 30145612, 30146271, 30147784, 30146395, 30148182, 30151583, 30168390, 30147533, 30148448, 30148036, 30147775, 30144847, 30147101, 30148563], "B": [30137358, 30139471, 30141499, 30138298, 30137334, 30139875, 30139930, 30139800, 30141449, 30137864, 30144203, 30143376, 30142744, 30143145, 30140773, 30144005, 30140202, 30140453, 30142525], "A": [30133427, 30134359, 30136395, 30133742, 30132639, 30132563, 30134311, 30135028, 30134993, 30133338, 30136720, 30135878, 30134302, 30137681, 30134274, 30133388, 30133609, 30133814, 30134640], "E": [30179221, 30179071, 31229560, 30173059]}, "name": "C. Boredom", "statement": "Ilya is sitting in a waiting area of Metropolis airport and is bored of\r\nlooking at time table that shows again and again that his plane is\r\ndelayed. So he took out a sheet of paper and decided to solve some\r\nproblems.First Ilya has drawn a grid of size and marked squares on it,\r\nsuch that no two marked squares share the same row or the same column.\r\nHe calls a rectangle on a grid with sides parallel to grid sides if\r\nexactly two of its corner squares are marked. There are exactly\r\nbeautiful rectangles.Ilya has chosen query rectangles on a grid with\r\nsides parallel to grid sides (not necessarily beautiful ones), and for\r\neach of those rectangles he wants to find its . Beauty degree of a\r\nrectangle is the number of beautiful rectangles that share at least one\r\nsquare with the given one.Now Ilya thinks that he might not have enough\r\ntime to solve the problem till the departure of his flight. You are\r\ngiven the description of marked cells and the query rectangles, help\r\nIlya find the beauty degree of each of the query rectangles.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 200200;\nstruct Node {\n\tint L, R;\n\tint l, r;\n\tint val;\n\n\tNode() : L(-1), R(-1), l(-1), r(-1), val(0) {}\n\tNode(int _l, int _r) : L(-1), R(-1), l(_l), r(_r), val(0) {}\n};\nconst int S = (int)7e6;\nNode tree[S];\nint treeSz;\n\nint build(int l, int r) {\n\tint v = treeSz++;\n\ttree[v] = Node(l, r);\n\tif (l + 1 == r) return v;\n\tint mid = (l + r) / 2;\n\ttree[v].L = build(l, mid);\n\ttree[v].R = build(mid, r);\n\treturn v;\n}\n\nint setVal(int v, int p, int x) {\n\tif (p < tree[v].l || tree[v].r <= p) return v;\n\tint u = treeSz++;\n\ttree[u] = tree[v];\n\tif (tree[v].L == -1) {\n\t\ttree[u].val = x;\n\t\treturn u;\n\t}\n\ttree[u].L = setVal(tree[v].L, p, x);\n\ttree[u].R = setVal(tree[v].R, p, x);\n\ttree[u].val = tree[tree[u].L].val + tree[tree[u].R].val;\n\treturn u;\n}\n\nint getSum(int v, int l, int r) {\n\tif (l <= tree[v].l && tree[v].r <= r)\n\t\treturn tree[v].val;\n\tif (l >= tree[v].r || tree[v].l >= r)\n\t\treturn 0;\n\treturn getSum(tree[v].L, l, r) + getSum(tree[v].R, l, r);\n}\n\nint roots[N];\nint n, q;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &q);\n\troots[0] = build(0, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\tp--;\n\t\troots[i + 1] = setVal(roots[i], p, 1);\n\t}\n\twhile(q--) {\n\t\tint x1, x2, y1, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tx1--;\n\t\ty1--;\n\t\tll ans = (ll)n * (n - 1);\n\t\tans -= (ll)x1 * (x1 - 1);\n\t\tans -= (ll)(n - x2) * (n - x2 - 1);\n\t\tans -= (ll)y1 * (y1 - 1);\n\t\tans -= (ll)(n - y2) * (n - y2 - 1);\n\t\tll cnt = getSum(roots[x1], 0, y1);\n\t\tans += cnt * (cnt - 1);\n\t\tcnt = getSum(roots[x1], y2, n);\n\t\tans += cnt * (cnt - 1);\n\t\tcnt = y1 - getSum(roots[x2], 0, y1);\n\t\tans += cnt * (cnt - 1);\n\t\tcnt = n - y2 - getSum(roots[x2], y2, n);\n\t\tans += cnt * (cnt - 1);\n\t\tprintf(\"%lld\\n\", ans / 2);\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2100", "interactive": false}