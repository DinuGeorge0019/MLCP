{
    "link": "https://codeforces.com//contest/1120/problem/A",
    "problemId": "306941",
    "problem_idx": "A",
    "shortId": "1120A",
    "contest_number": "1120",
    "problem_submissions": {
        "E": [
            50758414,
            50756395,
            51349737
        ],
        "F": [
            50755440,
            50756775,
            50756923,
            50745238,
            50757783,
            50769406,
            57326050
        ],
        "D": [
            50750764,
            50751956,
            50743562,
            50751566,
            50752777,
            50751884,
            50753994,
            50750618,
            50751945,
            50752229,
            50752378,
            50752892,
            50753276,
            50756304,
            50749029,
            50755638,
            50755384,
            50755602,
            50754622
        ],
        "C": [
            50742812,
            50748170,
            50742079,
            50747757,
            50746596,
            50747930,
            50749515,
            50746554,
            50746940,
            50749954,
            50748511,
            50747866,
            50749223,
            50751278,
            50750205,
            50750042,
            50750814,
            50749510,
            50744496
        ],
        "B": [
            50741885,
            50746393,
            50748182,
            50754599,
            50753894,
            50755398,
            50768361,
            50757846,
            50749483,
            57329791
        ],
        "A": [
            50743197,
            50749514,
            50746437,
            50743945,
            50745821,
            50745101,
            50745374,
            50743501,
            50746721,
            50745328,
            50746455,
            73355086,
            50745671,
            50745395,
            50746139
        ]
    },
    "name": "A. Diana and Liana",
    "statement": "At the first holiday in spring, the town Shortriver traditionally\r\nconducts a flower festival. Townsfolk wear traditional wreaths during\r\nthese festivals. Each wreath contains exactly k flowers.The work\r\nmaterial for the wreaths for all n citizens of Shortriver is cut from\r\nthe longest flowered liana that grew in the town that year. Liana is a\r\nsequence a_1, a_2, ..., a_m, where a_i is an integer that denotes the\r\ntype of flower at the position i. This year the liana is very long (m\r\nge n\r\ncdot k), and that means every citizen will get a wreath.Very soon the\r\nliana will be inserted into a special cutting machine in order to make\r\nwork material for wreaths. The machine works in a simple manner: it cuts\r\nk flowers from the beginning of the liana, then another k flowers and so\r\non. Each such piece of k flowers is called a workpiece. The machine\r\nworks until there are less than k flowers on the liana.Diana has found a\r\nweaving schematic for the most beautiful wreath imaginable. In order to\r\nweave it, k flowers must contain flowers of types b_1, b_2, ..., b_s,\r\nwhile other can be of any type. If a type appears in this sequence\r\nseveral times, there should be at least that many flowers of that type\r\nas the number of occurrences of this flower in the sequence. The order\r\nof the flowers in a workpiece does not matter.Diana has a chance to\r\nremove some flowers from the liana before it is inserted into the\r\ncutting machine. She can remove flowers from any part of the liana\r\nwithout breaking liana into pieces. If Diana removes too many flowers,\r\nit may happen so that some of the citizens do not get a wreath. Could\r\nsome flowers be removed from the liana so that at least one workpiece\r\nwould conform to the schematic and machine would still be able to create\r\nat least n workpieces?\r\n",
    "solutions": [
        "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 510000;\n\nint m, k, n, s;\nint a[MAXN];\nint nd[MAXN];\nint hv[MAXN];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> m >> k >> n >> s;\n\tfor (int i = 0; i < m; ++i)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < s; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++nd[x];\n\t}\n\tint ls = s;\n\tint now = 0;\n\tint lf = m - k * n;\n\tfor (int i = 0; i < m; ++i) {\n\t\twhile (now < m && ls > 0) {\n\t\t\t++hv[a[now]];\n\t\t\tif (hv[a[now]] <= nd[a[now]])\n\t\t\t\t--ls;\n\t\t\t++now;\n\t\t}\n\t\tif (ls == 0) {\n\t\t\tint go = i % k;\n\t\t\tint df = i % k;\n\t\t\tif (i > k * (n - 1))\n\t\t\t\tgo = i - k * (n - 1), df = i - k * (n - 1);\n\t\t\tif (now - i > k)\n\t\t\t\tgo += (now - i) - k;\n\t\t\tif (go <= lf) {\n\t\t\t\tvector<int> del;\n\t\t\t\tfor (int j = 0; j < df; ++j)\n\t\t\t\t\tdel.push_back(j);\n\t\t\t\tint d = max(0, now - i - k);\n\t\t\t\tfor (int j = i; j < now; ++j) {\n\t\t\t\t\tif (nd[a[j]])\n\t\t\t\t\t\t--nd[a[j]];\n\t\t\t\t\telse if (d)\n\t\t\t\t\t\tdel.push_back(j), --d;\n\t\t\t\t}\n\t\t\t\tcout << del.size() << \"\\n\";\n\t\t\t\tfor (int i: del)\n\t\t\t\t\tcout << i + 1 << \" \";\n\t\t\t\tcout << \"\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t--hv[a[i]];\n\t\tif (hv[a[i]] < nd[a[i]])\n\t\t\t++ls;\n\t}\n\tcout << -1 << \"\\n\";\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Diana and Liana.json",
    "editorial_link": "https://codeforces.com//blog/entry/65679",
    "editorial": "First of all, let\u00e2\u0080\u0099s learn how to check if a perfect wreath can be\r\nobtained from the subsegment of our liana (that is, if we can remove\r\nsome flowers so that the remaining ones on represent a perfect wreath,\r\nand this whole wreath will be cut). First, the number of other wreaths\r\nmust be , so the inequality must hold. Second, the segment has to\r\ncontain flowers of all required types. Finally, must be at least . One\r\ncan see that these conditions also guarantee that can become a cut\r\nperfect wreath.Now let\u00e2\u0080\u0099s find for every the minimal possible for which\r\nthe second condition holds. It can be done with the two pointers\r\ntechnique: if we iterate for all from to then this cannot become less\r\nthan it was, and it\u00e2\u0080\u0099s easy to update all counts and the number of\r\ninsufficient flowers types both when increase and .So what remains is to\r\nfind out if there is any such that the segment satisfies the first\r\nrequirement, and if it does, then print some flowers before which we\r\ndelete (we must ensure that what remains before is divisible by and does\r\nnot exceed ) and some flowers from we delete (without breaking the\r\nconditions). It\u00e2\u0080\u0099s not necessary to delete anything after , though.\r\n"
}