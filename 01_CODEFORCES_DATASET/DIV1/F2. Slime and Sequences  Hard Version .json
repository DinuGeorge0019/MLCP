{
    "link": "https://codeforces.com//contest/1349/problem/F2",
    "problemId": "619065",
    "problem_idx": "F2",
    "shortId": "1349F2",
    "contest_number": "1349",
    "problem_submissions": {
        "D": [
            79861873,
            79861806,
            79948658,
            79858494,
            79903166,
            131108532,
            79877857,
            79879188,
            79879019,
            79872081,
            80757765,
            79874857,
            79891331
        ],
        "C": [
            79835117,
            79843720,
            79834387,
            79845607,
            79830281,
            79843236,
            79849443,
            79848794,
            79845617,
            79852466,
            79831253,
            79854349,
            79853472,
            79844058,
            79856498,
            79879255,
            79856862,
            79848324,
            79861537
        ],
        "B": [
            79827155,
            79837122,
            79822255,
            79821907,
            79838530,
            79834646,
            79835497,
            79841171,
            79842066,
            79829421,
            79839013,
            79841661,
            79841348,
            79839739,
            79833357,
            79841018,
            79840476,
            79842544,
            79837256,
            79834808
        ],
        "A": [
            79817454,
            79821533,
            79816750,
            79834360,
            79820968,
            90907998,
            90906860,
            90496887,
            79817368,
            94393615,
            79825623,
            79828847,
            79817688,
            79819374,
            79828023,
            79820779,
            79831851,
            79831246,
            79823300,
            79821494,
            79829816,
            79823411,
            79929306,
            79822107
        ],
        "E": [
            85193181,
            79886501,
            80023736
        ],
        "F2": [
            81605329,
            85716790,
            84837609,
            84835671,
            80416603,
            80415302,
            80161085
        ],
        "F1": [
            79982046,
            79890867,
            79859528,
            80154258,
            79886462,
            79874667,
            79884418,
            79878453,
            79892295,
            79881330,
            79892657,
            79875367,
            79882448,
            79932700
        ]
    },
    "name": "F2. Slime and Sequences  Hard Version ",
    "statement": "Slime is interested in sequences. He defined positive integer sequences\r\np of length n as follows: For each k>1 that presents in p, there should\r\nbe at least one pair of indices i,j, such that 1\r\nleq i < j\r\nleq n, p_i = k - 1 and p_j = k.For the given integer n, the set of all\r\ngood sequences of length n is s_n. For the fixed integer k and the\r\nsequence p, let f_p(k) be the number of times that k appears in p. For\r\neach k from 1 to n, Slime wants to know the following value:\r\nleft(\r\nsum_{p\r\nin s_n} f_p(k)\r\nright)\r\ntextrm{mod}\r\n998\r\n,244\r\n,353\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nstruct modinfo{uint mod,root;};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(int n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#define USE_GOOD_MOD\n\n//size of input must be a power of 2\n//output of forward fmt is bit-reversed\n//output elements are in the range [0,mod*4)\n//input of inverse fmt should be bit-reversed\ntemplate<class mint>\nvoid inplace_fmt(const int n,mint*const f,bool inv){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],ig[L],p2[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tmint w=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\tg[i]=w;\n\t\t\tig[i]=w.inv();\n\t\t\tp2[i]=mint(1<<i).inv();\n\t\t}\n\t}\n\tif(!inv){\n\t\tint b=n;\n\t\tif(b>>=1){//input:[0,mod)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*2)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\twhile(b){\n\t\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tint b=1;\n\t\tif(b<n/2){//input:[0,mod)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t\tb<<=1;\n\t\t}\n\t\tfor(;b<n/2;b<<=1){\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b/2){//input:[0,mod*2)\n\t\t\t\t\tull x=f[j].v+mod2-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j].v=(f[j].v)<mod2?f[j].v:f[j].v-mod2;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\trng(j,i+b/2,i+b){//input:[0,mod)\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b<n){//input:[0,mod*2)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod2-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tmint z=p2[__lg(n)];\n\t\trep(i,n)f[i]*=z;\n\t}\n}\n\ntemplate<class mint>\nvoid inplace_fmt(vector<mint>&f,bool inv){\n\tinplace_fmt(si(f),f.data(),inv);\n}\n\ntemplate<class mint>\nvoid half_fmt(const int n,mint*const f){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],h[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tg[i]=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\th[i]=mint::root().pow((mod-1)>>(i+2));\n\t\t}\n\t}\n\tint b=n;\n\tint lv=0;\n\tif(b>>=1){//input:[0,mod)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\tif(b>>=1){//input:[0,mod*2)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\twhile(b){\n\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<class mint>\nvoid half_fmt(vector<mint>&f){\n\thalf_fmt(si(f),f.data());\n}\n\ntemplate<class mint>\nvc<mint> multiply(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint n=si(x)+si(y)-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tvc<mint> z(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\n//59501818244292734739283969-1=5.95*10^25 \u307e\u3067\u306e\u5024\u3092\u6b63\u3057\u304f\u8a08\u7b97\n//\u6700\u7d42\u7684\u306a\u5217\u306e\u5927\u304d\u3055\u304c 2^24 \u307e\u3067\u306a\u3089\u52d5\u304f\n//\u6700\u7d42\u7684\u306a\u5217\u306e\u5927\u304d\u3055\u304c 2^20 \u4ee5\u4e0b\u306e\u3068\u304d\u306f\uff0c\u4e0b\u306e 3 \u3064\u306e\u7d20\u6570\u3092\u4f7f\u3063\u305f\u307b\u3046\u304c\u901f\u3044\uff08\u306f\uff1f\uff09\n//VERIFY: yosupo\n//Yukicoder No980 (same=true)\nnamespace arbitrary_convolution{\n\t//constexpr modinfo base0{167772161,3};//2^25 * 5 + 1\n\t//constexpr modinfo base1{469762049,3};//2^26 * 7 + 1\n\t//constexpr modinfo base2{754974721,11};//2^24 * 45 + 1\n\tconstexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\tconstexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\tconstexpr modinfo base2{1053818881,7};//2^20 * 1005 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\tusing mint2=modular<base2>;\n\ttemplate<class t,class mint>\n\tvc<t> sub(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tauto d2=sub<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tvc<mint> res(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tres[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n//using arbitrary_convolution::multiply;\n\ntemplate<class mint>\nstruct Poly:public vc<mint>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<mint>(args...){}\n\tPoly(initializer_list<mint>init):vc<mint>(all(init)){}\n\tint size()const{\n\t\treturn vc<mint>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly operator>>(int x)const{\n\t\tassert(x<size());\n\t\tPoly res(size()-x);\n\t\trep(i,size()-x)res[i]=(*this)[i+x];\n\t\treturn res;\n\t}\n\tPoly operator<<(int x)const{\n\t\tPoly res(size()+x);\n\t\trep(i,size())res[i+x]=(*this)[i];\n\t\treturn res;\n\t}\n\tmint freq(int i)const{\n\t\treturn i<size()?(*this)[i]:0;\n\t}\n\tPoly operator-()const{\n\t\tPoly res=*this;\n\t\tfor(auto&v:res)v=-v;\n\t\treturn res;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator+=(T t){\n\t\t(*this)[0]+=t;\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator-=(T t){\n\t\t(*this)[0]-=t;\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_GOOD_MOD\n\tPoly inv(int s)const{\n\t\tPoly r{mint(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\t//source: Section 4 of \"Removing redundancy from high-precision Newton iteration\"\n\t// 5/3\n\tPoly inv(int s)const{\n\t\tPoly r(s);\n\t\tr[0]=mint(1)/(*this)[0];\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tvc<mint> f=low(2*n);\n\t\t\tf.resize(2*n);\n\t\t\tinplace_fmt(f,false);\n\t\t\tvc<mint> g=r.low(2*n);\n\t\t\tg.resize(2*n);\n\t\t\tinplace_fmt(g,false);\n\t\t\trep(i,2*n)f[i]*=g[i];\n\t\t\tinplace_fmt(f,true);\n\t\t\trep(i,n)f[i]=0;\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,2*n)f[i]*=g[i];\n\t\t\tinplace_fmt(f,true);\n\t\t\trng(i,n,min(2*n,s))r[i]=-f[i];\n\t\t}\n\t\treturn r;\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=mint(1)/mint(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1].v);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\ttemplate<class T>\n\tPoly operator+(T t)const{return Poly(*this)+=t;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator-(T t)const{return Poly(*this)-=t;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte(const mint invs[])const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//VERIFY: yosupo\n\t//opencupXIII GP of Peterhof H\n\tPoly log(int s,const mint invs[])const{\n\t\tassert((*this)[0]==1);\n\t\tif(s==1)return {0};\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte(invs);\n\t}\n\t//Petrozavodsk 2019w mintay1 G\n\t//yosupo judge\n\tPoly exp(int s,const mint invs[])const{\n\t\treturn exp2(s,invs).a;\n\t}\n\t//2\u3064\u307b\u3057\u3044\u3068\u304d\u306f\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\u306e\u4f4d\u7f6e\u305a\u3089\u3059\n\tpair<Poly,Poly> exp2(int s,const mint invs[])const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g.square()*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte(invs))).low(2*n);\n\t\t}\n\t\treturn make_pair(f.low(s),g.low(s));\n\t}\n\t#ifndef USE_GOOD_MOD\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tstatic const mint half=mint(1)/mint(2);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*half;\n\t\treturn r.low(s);\n\t}\n\t#else\n\t//11/6\n\t//VERIFY: yosupo\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tstatic const mint half=mint(1)/mint(2);\n\t\tvc<mint> f{1},g{1},z{1};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\trep(i,n)z[i]*=z[i];\n\t\t\tinplace_fmt(z,true);\n\t\t\t\n\t\t\tvc<mint> delta(2*n);\n\t\t\trep(i,n)delta[n+i]=z[i]-freq(i)-freq(n+i);\n\t\t\tinplace_fmt(delta,false);\n\t\t\t\n\t\t\tvc<mint> gbuf(2*n);\n\t\t\trep(i,n)gbuf[i]=g[i];\n\t\t\tinplace_fmt(gbuf,false);\n\t\t\t\n\t\t\trep(i,2*n)delta[i]*=gbuf[i];\n\t\t\tinplace_fmt(delta,true);\n\t\t\tf.resize(2*n);\n\t\t\trng(i,n,2*n)f[i]=-half*delta[i];\n\t\t\t\n\t\t\tif(2*n>=s)break;\n\t\t\t\n\t\t\tz=f;\n\t\t\tinplace_fmt(z,false);\n\t\t\t\n\t\t\tvc<mint> eps=gbuf;\n\t\t\trep(i,2*n)eps[i]*=z[i];\n\t\t\tinplace_fmt(eps,true);\n\t\t\t\n\t\t\trep(i,n)eps[i]=0;\n\t\t\tinplace_fmt(eps,false);\n\t\t\t\n\t\t\trep(i,2*n)eps[i]*=gbuf[i];\n\t\t\tinplace_fmt(eps,true);\n\t\t\tg.resize(2*n);\n\t\t\trng(i,n,2*n)g[i]=-eps[i];\n\t\t}\n\t\tf.resize(s);\n\t\treturn f;\n\t}\n\t#endif\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn make_pair(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tint lowzero()const{\n\t\trep(i,size())if((*this)[i]!=0)return i;\n\t\treturn size();\n\t}\n\t//VERIFY: yosupo\n\tPoly pow(int s,int p,const mint invs[])const{\n\t\tassert(s>0);\n\t\tassert(p>0);\n\t\tint n=size(),z=0;\n\t\tfor(;z<n&&(*this)[z]==0;z++);\n\t\tif(z*p>=s)return Poly(s,0);\n\t\tmint c=(*this)[z],cinv=c.inv();\n\t\tmint d=c.pow(p);\n\t\tint t=s-z*p;\n\t\tPoly x(t);\n\t\trng(i,z,min(z+t,n))x[i-z]=(*this)[i]*cinv;\n\t\tx=x.log(t,invs);\n\t\trep(i,t)x[i]*=p;\n\t\tx=x.exp(t,invs);\n\t\trep(i,t)x[i]*=d;\n\t\tPoly y(s);\n\t\trep(i,t)y[z*p+i]=x[i];\n\t\treturn y;\n\t}\n\tmint eval(mint x)const{\n\t\tmint r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n//f*x^(-a)\ntemplate<class mint>\nstruct Laurent{\n\tPoly<mint> f;\n\tint a;\n\tLaurent(const Poly<mint>&num,const Poly<mint>&den,int s){\n\t\tdmp(num);\n\t\tdmp(den);\n\t\ta=den.lowzero();\n\t\tassert(a<si(den));\n\t\tf=(num*(den>>a).inv(s)).low(s);\n\t}\n\tLaurent(const Poly<mint>&ff,int aa):f(ff),a(aa){}\n\tLaurent dif()const{\n\t\treturn Laurent(f*(-a)+(f.dif()<<1),a+1);\n\t}\n\tmint&operator[](int i){\n\t\tassert(inc(0,i+a,si(f)-1));\n\t\treturn f[i+a];\n\t}\n};\n\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\nusing mint=modular<base>;\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nvoid answer(vc<mint> x){\n\tint n=si(x);\n\t/*vc<mint> y(n);\n\trep(i,n)rep(j,i+1)y[j]+=x[i]*choose(i,j)*((i-j)%2==0?1:-1);\n\trep(i,n)y[i]*=fact[n];\n\tcout<<y<<endl;*/\n\tvc<mint> y(n);\n\trep(i,n)y[n-1-i]=finv[i]*(i%2==0?1:-1);\n\trep(i,n)x[i]*=fact[i];\n\tauto z=multiply(x,y);\n\tvc<mint> w(n);\n\trep(i,n)w[i]=z[n-1+i]*finv[i]*fact[n];\n\tprint(w);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n;cin>>n;\n\tint s=n+10;\n\t\n\tvc<mint> ans(n);\n\t\n\t{\n\t\tPoly<mint> f(s);\n\t\trep(i,s)f[i]=finv[i+1];\n\t\tLaurent<mint> z(f,Poly<mint>{1}-f,s);\n\t\trep(i,n)ans[i]+=z[i];\n\t}\n\tdmp(ans);\n\t/*rep(k,n){\n\t\tPoly<mint> f(s);\n\t\trep(i,s)f[i]=finv[i+1];\n\t\tLaurent<mint> z(f.pow(s,n-k+1,invs),Poly<mint>{1}-f,s);\n\t\tans[k]-=z[k];\n\t}*/\n\t{\n\t\tPoly<mint> f(s);\n\t\trng(i,1,s)f[i]=invs[i]*(i%2?1:-1);\n\t\t\n\t\tn++;\n\t\tvc<mint> u(n+1);\n\t\t\n\t\tLaurent<mint> x(f,f-Poly<mint>{0,1},s);\n\t\tauto y=x.dif();\n\t\tauto z=Poly<mint>(f.bg+1,f.ed).pow(s-1,n,invs).inv(s-1);\n\t\tx.f*=z;\n\t\ty.f*=z;\n\t\t\n\t\trep(i,n+1){\n\t\t\tu[i]+=y[n-1-i];\n\t\t}\n\t\trng(i,1,n+1){\n\t\t\tu[i]+=x[n-1-(i-1)]*i;\n\t\t}\n\t\t\n\t\tn--;\n\t\trep(i,n)ans[i]-=u[n+1-i]*invs[n+1];\n\t}\n\tanswer(ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F2. Slime and Sequences  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/77284",
    "editorial": "Now we consider how to get these values in less than time. Let , so now\r\nwe just want to find for each . We can get the value of in one\r\npolynomial inversion, now we only need to deal with the second one. Let\r\n, satisfies , so , . And from the Lagrange Inversion We can get and in\r\nor time, and then get the answer.The overall complexity is or .\r\n"
}