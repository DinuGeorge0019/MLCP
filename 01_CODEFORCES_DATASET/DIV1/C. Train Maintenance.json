{
    "link": "https://codeforces.com//contest/1580/problem/C",
    "problemId": "1124756",
    "problem_idx": "C",
    "shortId": "1580C",
    "contest_number": "1580",
    "problem_submissions": {
        "B": [
            130368546,
            130343157,
            130344628,
            130363173,
            130349401,
            130355243,
            130367468,
            130348461,
            130361528,
            130349821,
            130353521,
            130358877,
            130349956,
            130352430,
            130351206,
            130360978,
            130375295,
            130370586,
            130394237,
            130361703
        ],
        "F": [
            130365168,
            131645253,
            131635746,
            130511674,
            130411823,
            130434722,
            130858441,
            130432452
        ],
        "D": [
            130353694,
            130351879,
            130354504,
            130348465,
            130361242,
            130356218,
            130400584,
            130360744,
            130356043,
            130858484,
            130362840,
            130366863,
            130368106,
            130352099,
            130366694,
            130365720,
            130365962,
            130368047,
            130360831,
            130353993,
            130370294
        ],
        "C": [
            130347074,
            130348749,
            130348466,
            130344529,
            130355623,
            130348660,
            130349751,
            130374035,
            130353918,
            130350011,
            130356865,
            130358625,
            130355024,
            130348708,
            130393503,
            130361958,
            130360836,
            130360159,
            130358052,
            130357895,
            130349443,
            130349567
        ],
        "A": [
            130339939,
            130502005,
            130339930,
            130348093,
            130341897,
            130340621,
            130340244,
            130356449,
            130343417,
            130342143,
            130341207,
            130340481,
            130341559,
            130340530,
            130339691,
            130340905,
            130340089,
            130340579,
            130352882
        ],
        "E": [
            130370647,
            130421659
        ]
    },
    "name": "C. Train Maintenance",
    "statement": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed\r\nto help maintain trains.There are n models of trains, and Nitori\u2019s\r\ndepartment will only have at most one train of each model at any moment.\r\nIn the beginning, there are no trains, at each of the following m days,\r\none train will be added, or one train will be removed. When a train of\r\nmodel i is added at day t, it works for x_i days (day t inclusive), then\r\nit is in maintenance for y_i days, then in work for x_i days again, and\r\nso on until it is removed.In order to make management easier, Nitori\r\nwants you to help her calculate how many trains are in maintenance in\r\neach day.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int MAGIC = 450;\n\nint n, m, x[200005], y[200005], cur, sum;\nint d0[200005], d1[455][455];\nint beg[200005];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\trep1(i, n) scanf(\"%d%d\", &x[i], &y[i]);\n\t\n\trep(i, m) {\n\t\tint op, k, coef = 1;\n\t\tscanf(\"%d%d\", &op, &k);\n\t\tif(op == 1) beg[k] = i;\n\t\telse {\n\t\t\tcoef = -1;\n\t\t\tif((i - 1 - beg[k]) % (x[k] + y[k]) < x[k]) cur --;\n\t\t}\n\t\tsum += coef;\n\t\tif(x[k] + y[k] < MAGIC) {\n\t\t\td1[x[k] + y[k]][beg[k] % (x[k] + y[k])] += coef; d1[x[k] + y[k]][(beg[k] + x[k]) % (x[k] + y[k])] -= coef;\n\t\t} else {\n\t\t\tfor(LL tmp = beg[k]; tmp < m; tmp += x[k] + y[k]) d0[tmp] += coef;\n\t\t\tfor(LL tmp = beg[k] + x[k]; tmp < m; tmp += x[k] + y[k]) d0[tmp] -= coef;\n\t\t}\n\t\tcur += d0[i];\n\t\tfor(int tmp = 2; tmp < MAGIC; tmp ++) cur += d1[tmp][i % tmp];\n\t\tprintf(\"%d\\n\", sum - cur);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Train Maintenance.json",
    "editorial_link": "https://codeforces.com//blog/entry/95477",
    "editorial": "Let\u00e2\u0080\u0099s distinguish the trains according to . If , the total times of\nmaintenance and running don\u00e2\u0080\u0099t exceed . So we can find every date that\nthe train of model begin or end maintenance in , and we can maintain a\ndifferential sequence. We can add 1 to the beginning date and minus 1 to\nthe end date, and the prefix sum of this sequence is the number of\ntrains in maintenance. If , suppose the train of model is repaired at\nday. For a date that the train of model is in maintenance if and only if\n. Thus for each , we can use an array of length to record the date of\nall trains that satisfy are in maintenance modulo . And for one period\nof maintenance, the total days aren\u00e2\u0080\u0099t exceed . So we can maintain in .\nThus the intended time complexity is and the intended memory complexity\nis .\n"
}