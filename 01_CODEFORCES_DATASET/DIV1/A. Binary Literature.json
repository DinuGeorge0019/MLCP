{
    "link": "https://codeforces.com//contest/1508/problem/A",
    "problemId": "958781",
    "problem_idx": "A",
    "shortId": "1508A",
    "contest_number": "1508",
    "problem_submissions": {
        "D": [
            113258208,
            113225842,
            113232066,
            113242382,
            113242310,
            113248310,
            113252824,
            113256393,
            113240058,
            113236672,
            113233206,
            113240165,
            113242005,
            113242817,
            113243142
        ],
        "F": [
            113247954,
            113415583,
            113275748,
            113263512,
            113569093,
            113516939
        ],
        "C": [
            113237315,
            113213039,
            113214478,
            113213780,
            113212574,
            113213010,
            113224842,
            113226169,
            113232722,
            113215825,
            113215542,
            113224987,
            113223453,
            113228420,
            113228228,
            113217788,
            113226078,
            113229271,
            113230097
        ],
        "E": [
            113228353,
            113239041,
            113241831,
            113228851,
            113231701,
            113244425,
            113243109,
            113247201,
            113253919,
            113253035,
            113238610,
            113246155,
            113333091,
            113246539,
            113240797,
            113246922
        ],
        "A": [
            113201428,
            113189518,
            113189456,
            113190605,
            113198010,
            113192641,
            113194080,
            113204739,
            113207875,
            113194317,
            113200012,
            113222414,
            113194745,
            113195037,
            113199971,
            113199286,
            113193286,
            113195565,
            113191574,
            113194231
        ],
        "B": [
            113197951,
            113196658,
            113192904,
            113196665,
            113201215,
            113199153,
            113202442,
            113210198,
            113217372,
            113203624,
            113208530,
            113197629,
            113206458,
            113203987,
            113206383,
            113212945,
            113200476,
            113197819,
            113199529,
            113200558
        ]
    },
    "name": "A. Binary Literature",
    "statement": "A bitstring is a string that contains only the characters and .Koyomi\r\nKanou is working hard towards her dream of becoming a writer. To\r\npractice, she decided to participate in the . The writing prompt for the\r\ncontest consists of three bitstrings of length 2n. A valid novel for the\r\ncontest is a bitstring of length at most 3n that contains of the three\r\ngiven strings as subsequences.Koyomi has just received the three prompt\r\nstrings from the contest organizers. Help her write a valid novel for\r\nthe contest.A string a is a subsequence of a string b if a can be\r\nobtained from b by deletion of several (possibly, zero) characters.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; cin >> N;\n\t\tarray<string, 3> S;\n\t\tarray<int, 3> cnt{0,0,0};\n\t\tarray<bool, 3> dir{0,0,0};\n\t\tfor (int z = 0; z < 3; z++) {\n\t\t\tcin >> S[z];\n\t\t\tfor (char c : S[z]) cnt[z] += c - '0';\n\t\t\tdir[z] = (cnt[z] >= N);\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = i + 1; j < 3; j++) {\n\t\t\t\tif (dir[i] == dir[j]) {\n\t\t\t\t\tchar d = dir[i] + '0';\n\t\t\t\t\tauto a = S[i].begin(), b = S[j].begin();\n\t\t\t\t\tstring res; res.reserve(3*N);\n\t\t\t\t\tfor (int z = 0; z < N; z++) {\n\t\t\t\t\t\twhile (*a != d) {\n\t\t\t\t\t\t\tres += *a;\n\t\t\t\t\t\t\t++a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (*b != d) {\n\t\t\t\t\t\t\tres += *b;\n\t\t\t\t\t\t\t++b;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres += d;\n\t\t\t\t\t\t++a, ++b;\n\t\t\t\t\t}\n\t\t\t\t\tres.insert(res.end(), a, S[i].end());\n\t\t\t\t\tres.insert(res.end(), b, S[j].end());\n\t\t\t\t\tassert(int(res.size()) == 3*N);\n\t\t\t\t\tcout << res << '\\n';\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(false);\ndone:;\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "strings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Binary Literature.json",
    "editorial_link": "https://codeforces.com//blog/entry/89644",
    "editorial": "Letâs focus on two bitstrings and . How can we get a short string that\r\nhas them both as subsequences? Well, suppose both strings have a common\r\nsubsequence of length . Then we can include this subsequence as part of\r\nour string. Then we just place the remaining characters of both\r\nsequences in the correct positions between the characters of this common\r\nsequence, to make both strings a subsequence of the result. This saves\r\nus characters compared to just concatenating and since the characters of\r\nthe common subsequence only have to included once, i.e. this uses\r\ncharacters.Now, in our problem, all strings have a length of , so this\r\nalgorithm will use a total of characters. This means if we can find two\r\nstrings that have a common subsequence of length , we can finish the\r\nproblem. However, the usual algorithm for computing the longest common\r\nsubsequence works in , which is unlikely to pass the time limit, so we\r\nhave to construct this common subsequence more concretely.The\r\nobservation is that because each character is either or , one of these\r\ncharacters must appear at least times. Call such a character frequent.\r\nNow since each string has at least one frequent character, two of these\r\nfrequent characters are equal. Considering these two strings and their\r\nfrequent character we find a common subsequence of length , equal to\r\neither or .This solution uses a similar idea, in a way that is a bit\r\neasier to implement. Consider three pointers , pointing to a character\r\nin each string, and a string representing our answer. These pointers\r\nwill represent the prefixes of each string that we have represented in\r\nour answer. Initially, is empty and (here our strings are -indexed).Now\r\nwe will add characters to one by one. At each step, consider the three\r\ncharacters pointed at by our three pointers. Since they are either or ,\r\ntwo of them are equal. Add this equal character to , and advance the\r\npointers that match this character by .Continue this algorithm until one\r\nof the strings is completely contained in , letâs say . At this point,\r\nsuppose has characters, and thus the pointers have advanced by at least\r\n, since at least two of them advance on each step. We have exhausted the\r\ncharacters of , so we have advanced by , and the other two pointers have\r\nadvanced , and thus one of them has advanced by at least . Now just add\r\nthe remaining characters of this string to . There are at most of them,\r\nso in the end has at most characters.\r\n",
    "hint": [
        "Hint 1 Consider two of the strings. We can obviously achieve our goal using at most characters. How can we save some of them? Answer Take advantage of any common subsequence in our two strings by including the characters in it only once.",
        "Hint 2 Find a long common subsequence that has a simple structure. You'll need to involve the third string as well.",
        "Hint 3 Either or is a subsequence of each string."
    ]
}