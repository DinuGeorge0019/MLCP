{"link": "https://codeforces.com//contest/590/problem/E", "problemId": "39115", "problem_idx": "E", "shortId": "590E", "contest_number": "590", "problem_submissions": {"D": [13843353, 13843241, 13846192, 13845400, 13845513, 13845184, 13845284, 13846104, 13845914, 13848116, 13848012, 13846585, 13846955, 13840525, 13846113, 13846571, 13847155, 13846536, 13845841], "C": [13840565, 13839464, 13840329, 13843147, 13843128, 13843106, 13843875, 13843172, 13844215, 13844757, 13843685, 13843265, 13844084, 13843699, 13844122, 13843229, 13845260, 13842294, 13843462], "B": [13838659, 13841125, 13841907, 13840783, 13840726, 13840188, 13840959, 13840763, 13840870, 13840852, 13844831, 13840705, 13841546, 13846846, 13841487, 13840918, 13842200, 13844393, 13849735], "A": [13837458, 13845623, 13837970, 13838181, 13838474, 13837720, 13839193, 13837760, 13839312, 13838940, 13839590, 13838409, 13837478, 13845897, 13839666, 13839453, 13839053, 13838125, 13838135], "E": [13864277, 13874288, 13867064, 14107310, 13924688, 13922852, 13869938]}, "name": "E. Birthday", "statement": "Today is birthday of a Little Dasha she is now 8 years old! On this\r\noccasion, each of her friends and relatives gave her a ribbon with a\r\ngreeting written on it, and, as it turned out, all the greetings are\r\ndifferent. Dasha gathered all the ribbons and decided to throw away some\r\nof them in order to make the remaining set . The birthday girl considers\r\na set of ribbons stylish if no greeting written on some ribbon is a\r\nsubstring of another greeting written on some other ribbon. Let us\r\nrecall that the substring of the string is a continuous segment of .Help\r\nDasha to keep as many ribbons as possible, so that she could brag about\r\nthem to all of her friends. Dasha cannot rotate or flip ribbons, that\r\nis, each greeting can be read in a single way given in the input.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\nconst int MAXN = 1e7+10, sigma = 2;\n\nint term[MAXN], to[MAXN][sigma], link[MAXN], sz = 1;\nint que[MAXN], ww[MAXN];\n\nnamespace MF {\n\tconst int N = 755*2, M = 755*755;\n\tint f[N], e[2*M], c[2*M], fl[2*M], nxt[2*M], ce;\n\tint n, s, t;\n\tint Q[N], lvl[N];\n\tint le[N];\n\n\tvoid init(int _n) {\n\t\tn = _n+2; s = _n; t = _n+1; ce = 0;\n\t\tFO(i,0,n) f[i]=-1;\n\t}\n\n\tvoid add(int a, int b, int cap) {\n\t\tnxt[ce]=f[a]; f[a]=ce; e[ce]=b; fl[ce]=0; c[ce]=cap; ce++;\n\t\tnxt[ce]=f[b]; f[b]=ce; e[ce]=a; fl[ce]=0; c[ce]=0; ce++;\n\t}\n\n\tbool bfs() {\n\t\tFO(i,0,n) lvl[i]=-1;\n\t\tint qi = 1;\n\t\tQ[0] = s; lvl[s] = 0;\n\t\tFO(i,0,qi) {\n\t\t\tint x=Q[i];\n\t\t\tle[x]=f[x];\n\t\t\tfor (int j=f[x];j>=0;j=nxt[j]) if (c[j]-fl[j]>0) {\n\t\t\t\tint y=e[j];\n\t\t\t\tif (lvl[y]==-1) {\n\t\t\t\t\tlvl[y]=lvl[x]+1;\n\t\t\t\t\tQ[qi++]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lvl[t]!=-1;\n\t}\n\n\tint aug(int cu, int cf) {\n\t\tif (cu == t) return cf;\n\t\tfor (int &i=le[cu];i>=0;i=nxt[i]) if (c[i]-fl[i]>0) {\n\t\t\tint x=e[i];\n\t\t\tif (lvl[x]!=lvl[cu]+1) continue;\n\t\t\tint rf = aug(x,min(cf,c[i]-fl[i]));\n\t\t\tif (rf>0) {\n\t\t\t\tfl[i]+=rf;\n\t\t\t\tfl[i^1]-=rf;\n\t\t\t\treturn rf;\n\t\t\t}\n\t\t}\n\t\tlvl[cu]=-1;\n\t\treturn 0;\n\t}\n\n\tint mf() {\n\t\tint tot = 0;\n\t\twhile (bfs())\n\t\t\tfor (int x=aug(s,1e9);x;x=aug(s,1e9)) tot+=x;\n\t\treturn tot;\n\t}\n}\n\n\nvoid add_str(string &s, int i) {\n\tint cur = 0;\n\tfor(auto c: s)\n\t{\n\t\tif(!to[cur][c - 'a']) {\n\t\t\tto[cur][c - 'a'] = sz++;\n\t\t}\n\t\tcur = to[cur][c - 'a'];\n\t}\n\tterm[cur] = cur; \n\tww[cur] = i;\n}\n\nint u[755][755];\nint mt[755][755];\nint ei[755][755];\nbool inz[2][755];\n\nvoid calc_str(string &s, int i) {\n\tint cur = 0;\n\tfor(auto c: s) {\n\t\tcur = to[cur][c - 'a'];\n\t\tfor (int sl = term[cur]; sl; sl = term[link[sl]]) {\n\t\t\tif (u[i][ww[sl]]) break;\n\t\t\tu[i][ww[sl]] = true;\n\t\t}\n\t}\n}\n\nvoid push_links()\n{\n\tint st = 0, fi = 1;\n\tque[0] = 0;\n\twhile(st < fi)\n\t{\n\t\tint V = que[st++];\n\t\tint U = link[V];\n\t\t//printf(\"link[%d]=%d\\n\", V, U);\n\t\tif(!term[V]) term[V] = term[U];\n\t\tfor(int c = 0; c < sigma; c++)\n\t\t\tif(to[V][c])\n\t\t\t{\n\t\t\t\tlink[to[V][c]] = V ? to[U][c] : 0;\n\t\t\t\tque[fi++] = to[V][c];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tto[V][c] = to[U][c];\n\t\t\t}\n\t}\n}\n\nint n;\nvector<string> v;\n\nvoid go(int s, int i) {\n\tif (inz[s][i]) return;\n\tinz[s][i] = true;\n\t//printf(\"(%d,%d)\\n\", s, i);\n\tFO(j,0,n) {\n\t\tif (s == 0) {\n\t\t\tif (u[i][j] && !mt[i][j]) go(1,j);\n\t\t} else {\n\t\t\tif (u[j][i] && mt[j][i]) go(0,j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tcin.sync_with_stdio(false);\n\tcin >> n;\n\tv.resize(n);\n\tFO(i,0,n) {\n\t\tcin >> v[i];\n\t\tadd_str(v[i],i);\n\t}\n\tpush_links();\n\tFO(i,0,n) {\n\t\tcalc_str(v[i],i);\n\t}\n\tFO(i,0,n) {\n\t\tu[i][i] = false;\n\t\tFO(j,0,n) if (u[i][j]) {\n\t\t\t//printf(\"%s -> %s\\n\", v[j].c_str(), v[i].c_str());\n\t\t\t//printf(\"%d -- %d\\n\", i, j);\n\t\t}\n\t}\n\tMF::init(2*n);\n\tFO(i,0,n) {\n\t\tMF::add(MF::s, i, 1);\n\t\tMF::add(n+i, MF::t, 1);\n\t}\n\tFO(i,0,n) FO(j,0,n) if (u[i][j]) {\n\t\tei[i][j] = MF::ce;\n\t\tMF::add(i, j+n, 1);\n\t}\n\tint flo = MF::mf();\n\tprintf(\"%d\\n\", n-flo);\n\tFO(i,0,n) FO(j,0,n) if (u[i][j] && MF::fl[ei[i][j]]) {\n\t\tmt[i][j] = 1;\n\t\t//printf(\"%d-%d\\n\", i, j);\n\t}\n\tFO(i,0,n) {\n\t\tbool unm = true;\n\t\tFO(j,0,n) if (mt[i][j]) {\n\t\t\tunm = false;\n\t\t}\n\t\tif (unm) go(0,i);\n\t}\n\tvector<int> res;\n\tFO(i,0,n) if (inz[0][i] && !inz[1][i]) res.push_back(i);\n\tassert(n-flo == sz(res));\n\tfor (int x : res) printf(\"%d \", x+1);\n\tprintf(\"\\n\");\n}\n\n"], "input": "", "output": "", "tags": ["graph matchings", "strings"], "dificulty": "3200", "interactive": false}