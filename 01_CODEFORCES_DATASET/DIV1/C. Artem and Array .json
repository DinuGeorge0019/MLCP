{
    "link": "https://codeforces.com//contest/442/problem/C",
    "problemId": "10513",
    "problem_idx": "C",
    "shortId": "442C",
    "contest_number": "442",
    "problem_submissions": {
        "E": [
            6921847,
            6938403
        ],
        "C": [
            6919336,
            6917056,
            6920953,
            6916705,
            6918582,
            6918908,
            6921923,
            6921586,
            6918715,
            6919667,
            6919614,
            6925095,
            6918272,
            6918805,
            6919118
        ],
        "D": [
            6917753,
            6918850,
            6915556,
            6918817,
            6920381,
            6944679,
            6921502,
            6920210,
            6921312,
            6921510,
            6918431,
            6923717,
            6920981,
            6920504,
            6918960
        ],
        "B": [
            6916976,
            6915574,
            6916305,
            6915680,
            6916666,
            6917064,
            6917904,
            6915565,
            6916220,
            6916648,
            6916245,
            6918094,
            6915819,
            6916307,
            6917195,
            6916646,
            6916658,
            6921189
        ],
        "A": [
            6914458,
            6914295,
            6918545,
            6915241,
            6915516,
            6914863,
            6915569,
            6914808,
            6914997,
            6914852,
            6914659,
            6915403,
            6914675,
            6915467,
            6916072,
            6920156,
            6915628,
            6915075
        ]
    },
    "name": "C. Artem and Array ",
    "statement": "Artem has an array of positive integers. Artem decided to play with it.\r\nThe game consists of moves. Each move goes like this. Artem chooses some\r\nelement of the array and removes it. For that, he gets points, where and\r\nare numbers that were adjacent with the removed number. If the number\r\ndoesn\u2019t have an adjacent number to the left or right, Artem doesn\u2019t get\r\nany points. After the element is removed, the two parts of the array\r\nglue together resulting in the new array that Artem continues playing\r\nwith. Borya wondered what maximum total number of points Artem can get\r\nas he plays this game.\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 1000010;\n\nint a[N];\npair <int, int> p[N];\nint pr[N], ne[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n    p[i] = make_pair(a[i], i);\n  }\n  sort(p, p + n);\n  for (int i = 0; i < n; i++) {\n    pr[i] = i - 1;\n    ne[i] = i + 1;\n  }\n  int low = 0, high = n - 1;\n  long long ans = 0;\n  for (int i = 0; i < n - 2; i++) {\n    int j = p[i].second;\n    if (j == low) {\n      ans += p[i].first;\n      low = ne[low];\n      continue;\n    }\n    if (j == high) {\n      ans += p[i].first;\n      high = pr[high];\n      continue;\n    }\n    int x = a[pr[j]];\n    int y = a[ne[j]];\n    if (x < y) {\n      ans += x;\n    } else {\n      ans += y;\n    }\n    pr[ne[j]] = pr[j];\n    ne[pr[j]] = ne[j];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Artem and Array .json",
    "editorial_link": "https://codeforces.com//blog/entry/12739",
    "editorial": "It\u00e2\u0080\u0099s obvious that we should never delete the first and last elements of\r\narray. Let\u00e2\u0080\u0099s look at the minimum number. Let it be and there are\r\nelements in the array. We can subtract from all elements and the answer\r\nfor the problem will decrease on , becouse we will do delitions of\r\nmiddle elements and each of this delitions will not give Artem exectly\r\nmore points. If minimal element was the first or the last one, we can\r\nnot to count it now (it equals to 0 now, so it will not affect the\r\nanswer now). If it locates in the middle of array, we can prove that\r\nthere is exist an optimal solution when Artem deletes this element on\r\nfirst move. We can prove it by contradaction. Let\u00e2\u0080\u0099s look at the optimal\r\nanswer where the minimal element is deleted on the minimal possible move\r\n(but not on first one). We can prove that we can delete it earlier. If\r\nmove which is exactly before deleting minimum uses element of array\r\nwhich isn\u00e2\u0080\u0099t a neighbour of minimual one we can swap this two delitions\r\nand it will not affect the answer. If those elements are neighbours we\r\ncan write down the number of points which we obtain in both cases and\r\nunderstand that to delete minimum first is the best choice. So, in this\r\ntask we need to maintain a set of all not deleted elements and to find a\r\nsmallest alive element. All of it we can do with built-in data\r\nstructures in time .\r\n"
}