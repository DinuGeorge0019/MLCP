{"link": "https://codeforces.com//contest/1229/problem/D", "problemId": "419078", "problem_idx": "D", "shortId": "1229D", "contest_number": "1229", "problem_submissions": {"E2": [66535857, 61153989, 61162985, 61167725, 61164541, 61175914, 73169874, 73169292, 67251679, 61176348, 61171644, 61168314, 61282274], "C": [61156990, 61139280, 61133462, 61168973, 61144252, 61152507, 61152114, 61139574, 61138824, 61139511, 61146010, 61154268, 61140423, 61146503, 61146999, 61163280, 61145517, 61140699], "E1": [61153988, 61160360, 61157052, 61164602, 61165567, 61168930, 61169365, 61171555, 61161774, 61282244, 91100857], "D": [61143107, 61152425, 61148639, 61156853, 61153552, 61162885, 61162936, 61151975, 61157442, 61157392, 61156341, 61210834, 61160744, 61159221, 61160510, 61155666, 61165039, 61163062], "B": [61128405, 61132933, 61165615, 61142364, 61131741, 61140527, 61129638, 61133794, 61131083, 61134616, 61139186, 61132543, 61141781, 61139438, 61135873, 61137164, 61151652], "A": [61122880, 61126193, 61123596, 61131920, 61125660, 61128699, 61125244, 61171108, 61124176, 61136192, 61128585, 61129134, 61124511, 61133577, 61132336, 61124059, 61130617, 61131139], "F": [61198842, 61176125, 61453900, 61180269, 61179508, 61398042]}, "name": "D. Wojtek and Card Tricks", "statement": "Wojtek has just won a maths competition in Byteland! The prize is\r\nadmirable a great book called \u2019Card Tricks for Everyone.\u2019 \u2019Great!\u2019 he\r\nthought, \u2019I can finally use this old, dusted deck of cards that\u2019s always\r\nbeen lying unused on my desk!\u2019The first chapter of the book is \u2019How to\r\nShuffle k Cards in Any Order You Want.\u2019 It\u2019s basically a list of n\r\nintricate methods of shuffling the deck of k cards in a deterministic\r\nway. Specifically, the i-th recipe can be described as a permutation\r\n(P_{i,1}, P_{i,2},\r\ndots, P_{i,k}) of integers from 1 to k. If we enumerate the cards in the\r\ndeck from 1 to k from top to bottom, then P_{i,j} indicates the number\r\nof the j-th card from the top of the deck after the shuffle.The day is\r\nshort and Wojtek wants to learn only some of the tricks today. He will\r\npick two integers l, r (1\r\nle l\r\nle r\r\nle n), and he will memorize each trick from the l-th to the r-th,\r\ninclusive. He will then take a sorted deck of k cards and repeatedly\r\napply random memorized tricks until he gets bored. He still likes maths,\r\nso he started wondering: how many different decks can he have after he\r\nstops shuffling it?Wojtek still didn\u2019t choose the integers l and r, but\r\nhe is still curious. Therefore, he defined f(l, r) as the number of\r\ndifferent decks he can get if he memorizes all the tricks between the\r\nl-th and the r-th, inclusive. What is the value of\r\nsum_{l=1}^n\r\nsum_{r=l}^n f(l, r)?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nconst int K = 5;\nconst int M = 122;\nconst int S = 10100;\nint n, k, m;\nint pp[M][K];\nint t[M][M];\nint toId[S];\nint a[N];\nbool g[M];\nint q[M];\nint topQ;\nvector<int> b[N];\nvector<int> cur;\n\nvoid precalc() {\n\tfor (int i = 0; i < k; i++)\n\t\tpp[0][i] = i;\n\tm = 1;\n\twhile(true) {\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tpp[m][i] = pp[m - 1][i];\n\t\tif (!next_permutation(pp[m], pp[m] + k)) break;\n\t\tm++;\n\t}\n\tfor (int i = 0; i < S; i++)\n\t\ttoId[i] = -1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint id = 0;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tid = id * k + pp[i][j];\n\t\t}\n\t\ttoId[id] = i;\n\t}\n\tint qq[K];\n\tfor (int v = 0; v < m; v++)\n\t\tfor (int u = 0; u < m; u++) {\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tqq[i] = pp[v][pp[u][i]];\n\t\t\tint id = 0;\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tid = id * k + qq[i];\n\t\t\tid = toId[id];\n\t\t\tif (id == -1) throw;\n\t\t\tt[v][u] = id;\n\t\t}\n}\n\nbool tryAdd(int id) {\n\tif (g[id]) return false;\n\tcur.push_back(id);\n\tfor (int i = 0; i < m; i++)\n\t\tg[i] = 0;\n\tg[0] = 1;\n\ttopQ = 0;\n\tq[topQ++] = 0;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = q[i];\n\t\tfor (int x : cur) {\n\t\t\tint u = t[v][x];\n\t\t\tif (!g[u]) {\n\t\t\t\tg[u] = 1;\n\t\t\t\tq[topQ++] = u;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &k);\n\tprecalc();\n\tfor (int i = 0; i < n; i++) {\n\t\tint id = 0;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tx--;\n\t\t\tid = id * k + x;\n\t\t}\n\t\tid = toId[id];\n\t\tif (id == -1) throw;\n\t\ta[i] = id;\n\t}\n\n\tll ans = 0;\n\tfor (int v = n - 1; v >= 0; v--) {\n\t\tcur.clear();\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tg[i] = 0;\n\t\tg[0] = 1;\n\t\tint curSz = 1;\n\t\tint lst = v;\n\t\tif (tryAdd(a[v])) {\n\t\t\tb[v].push_back(v);\n\t\t\tans += curSz * (v - lst);\n\t\t\tcurSz = topQ;\n\t\t\tlst = v;\n//\t\t\teprintf(\"%d\\n\", curSz);\n\t\t}\n\t\tfor (int u : b[v + 1]) {\n\t\t\tif (tryAdd(a[u])) {\n\t\t\t\tb[v].push_back(u);\n\t\t\t\tans += curSz * (u - lst);\n\t\t\t\tcurSz = topQ;\n\t\t\t\tlst = u;\n//\t\t\t\teprintf(\"%d\\n\", curSz);\n\t\t\t}\n\t\t}\n\t\tans += curSz * (n - lst);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["math"], "dificulty": "2700", "interactive": false}