{"link": "https://codeforces.com//contest/804/problem/D", "problemId": "105175", "problem_idx": "D", "shortId": "804D", "contest_number": "804", "problem_submissions": {"D": [26864569, 26864084, 26864065, 26863844, 26859532, 26855737, 26853547, 26853205, 26854566, 26856630, 26853214, 26855855, 26861591, 26863648, 26855151, 26854613, 26864015, 26856289, 26858468, 26856391], "C": [26847789, 26844906, 26857930, 26847099, 26856657, 26848089, 26857400, 26856222, 26845185, 26848695, 26846499, 26847477, 26843068, 26846575, 26859352, 26846716, 26860420, 26846219, 26852629], "B": [26841209, 26838692, 26840551, 26839159, 26839206, 26840437, 26840273, 26854727, 26841332, 26842906, 26840147, 26841623, 26839518, 26840190, 26840304, 26839516, 26840017, 26847973, 26839966], "A": [26838410, 26837453, 26837406, 26837277, 26841198, 26837228, 26837723, 26837298, 26837762, 26837644, 26837931, 26837280, 26837588, 26838739, 26837615, 26837337, 26846921, 26837692], "E": [26859757, 26861113, 26864419, 26864227, 26864109, 26864035, 26863863, 26860566, 26862404, 26859605, 26854745, 26861397, 26884422, 26865231, 26853306, 26856744, 26859172]}, "name": "D. Expected diameter of a tree", "statement": "Pasha is a good student and one of MoJaK\u2019s best friends. He always have\r\na problem to think about. Today they had a talk about the following\r\nproblem.We have a forest (acyclic undirected graph) with vertices and\r\nedges. There are queries we should answer. In each query two vertices\r\nand are given. Let be the set of vertices in the connected component of\r\nthe graph that contains , and be the set of vertices in the connected\r\ncomponent of the graph that contains . Let\u2019s add an edge between some\r\nvertex and some vertex in and compute the value of the resulting\r\ncomponent. If the resulting component is a tree, the value is the of the\r\ncomponent, and it is equal to otherwise. What is the expected value of ,\r\nif we choose vertices and from the sets uniformly at random?Can you help\r\nPasha to solve this problem?The of the component is the maximum among\r\nsome pair of vertices in the component. The between two vertices is the\r\nminimum number of edges on some path between the two vertices.Note that\r\nqueries don\u2019t add edges to the initial forest.\r\n", "solutions": ["/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <vector>\n#include <cstddef>\n\n\nclass DSU {\npublic:\n\texplicit DSU(std::size_t n): dsu(n) {\n\t\tfor (std::size_t i = 0; i < n; ++i) {\n\t\t\tdsu[i] = i;\n\t\t}\n\t}\n\n\tstd::size_t getSet(std::size_t v) {\n\t\tSPCPPL_ASSERT(v < dsu.size());\n\t\tif (v == dsu[v]) {\n\t\t\treturn v;\n\t\t}\n\t\treturn dsu[v] = getSet(dsu[v]);\n\t}\n\n\tvoid unite(std::size_t u, std::size_t v) {\n\t\tSPCPPL_ASSERT(u < dsu.size());\n\t\tSPCPPL_ASSERT(v < dsu.size());\n\t\tu = getSet(u);\n\t\tv = getSet(v);\n\t\tdsu[v] = u;\n\t}\n\nprivate:\n\tstd::vector<std::size_t> dsu;\n};\n\n#include <algorithm>\n\ntemplate <typename T>\nvoid updateMin(T& oldValue, const T& newValue) {\n\tif (newValue < oldValue) {\n\t\toldValue = newValue;\n\t}\n}\n\ntemplate <typename T>\nvoid updateMax(T& oldValue, const T& newValue) {\n\tif (oldValue < newValue) {\n\t\toldValue = newValue;\n\t}\n}\n\n\n\n\n#include <numeric>\n\n#include <type_traits>\n\ntemplate <typename T>\nusing range_iterator_traits = std::iterator_traits<typename std::decay<decltype(std::declval<T>().begin())>::type>;\n\n\ntemplate <typename R>\nauto prefixSums(const R& range) -> std::vector<typename range_iterator_traits<R>::value_type> {\n\tstd::vector<typename range_iterator_traits<R>::value_type> result(\n\t\t\tstatic_cast<std::size_t>(\n\t\t\t\t\tstd::distance(std::begin(range), std::end(range)) + 1\n\t\t\t)\n\t);\n\tstd::partial_sum(std::begin(range), std::end(range), result.begin() + 1);\n\treturn result;\n}\n\n#include <map>\n\nusing namespace std;\n\nclass TaskD {\npublic:\n\tvector<int> length;\n\tvector<int> lenDown;\n\n\tvector<int> diam;\n\n\tvector<vector<int>> lenCnt;\n\tvector<vector<int>> prefSums;\n\tvector<vector<int64_t>> prefSumsDp;\n\n\tvector<vector<int>> g;\n\n\tvoid dfs1(int v, int p) {\n\t\tfor (int to: g[v]) {\n\t\t\tif (to != p) {\n\t\t\t\tdfs1(to, v);\n\t\t\t\tupdateMax(lenDown[v], 1 + lenDown[to]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs2(int v, int p, int mn, vector<int>& lenCnt, int& my_diam) {\n\t\tlength[v] = max(lenDown[v], mn);\n\t\tif (length[v] >= lenCnt.size()) {\n\t\t\tlenCnt.resize(length[v] + 1);\n\t\t}\n\t\t++lenCnt[length[v]];\n\n\t\tupdateMax(my_diam, length[v]);\n\t\tint mx1 = -1, mx2 = -1;\n\t\tfor (int to: g[v]) {\n\t\t\tif (to != p) {\n\t\t\t\tif (lenDown[to] > mx1) {\n\t\t\t\t\tmx2 = mx1;\n\t\t\t\t\tmx1 = lenDown[to];\n\t\t\t\t} else if (lenDown[to] > mx2) {\n\t\t\t\t\tmx2 = lenDown[to];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int to: g[v]) {\n\t\t\tif (to != p) {\n\t\t\t\tint mx = mx1;\n\t\t\t\tif (lenDown[to] == mx1) {\n\t\t\t\t\tmx = mx2;\n\t\t\t\t}\n\n\t\t\t\tdfs2(to, v, max(mn + 1, mx + 2), lenCnt, my_diam);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, m, q;\n\t\t//in >> n >> m >> q;\nscanf(\"%d%d%d\", &n,&m,&q);\n\t\tDSU dsu(n);\n\n\t\tg.resize(n);\n\t\tlength.resize(n);\n\t\tprefSums.resize(n);\n\t\tprefSumsDp.resize(n);\n\t\tlenDown.resize(n);\n\t\tlenCnt.resize(n);\n\t\tdiam.resize(n);\n\t\tfor (int i: range(m)) {\n\t\t\tint a, b;\n//\t\t\tin >> a >> b;\nscanf(\"%d%d\", &a, &b);\n\t\t\t--a, --b;\n\t\t\tdsu.unite(a, b);\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\n\t\tvector<int> sizes(n);\n\t\tfor (int i: range(n)) {\n\t\t\t++sizes[dsu.getSet(i)];\n\t\t}\n\n\t\t//vector<int> long_groups;\n\n\t\tint MAGIC = 2000;\n\t\tfor (int i: range(n)) {\n\t\t\tif(dsu.getSet(i) == i) {\n\t\t\t\tdfs1(i, i);\n\t\t\t\tdfs2(i, i, 0, lenCnt[i], diam[i]);\n\t\t\t\tprefSums[i] = prefixSums(lenCnt[i]);\n\t\t\t\tprefSumsDp[i].resize(lenCnt[i].size() + 1);\n\t\t\t\tfor (int j: range(lenCnt[i].size())) {\n\t\t\t\t\tprefSumsDp[i][j + 1] = prefSumsDp[i][j] + j * 1LL * lenCnt[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if (sizes[i] > MAGIC) {\n\t\t\t//\tlong_groups.push_back(i);\n\t\t\t//}\n\t\t}\n\n\n\t\tmap<pair<int, int>, double> res;\n\t\tfor (int _: range(q)) {\n\t\t\tint a, b;\n//\t\t\tin >> a >> b;\nscanf(\"%d%d\", &a, &b);\n\t\t\t--a, --b;\n\t\t\ta = (int) dsu.getSet(a);\n\t\t\tb = (int) dsu.getSet(b);\n\t\t\tif (a == b) {\nprintf(\"-1\\n\");\n\t\t\t//\tout << -1 << '\\n';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sizes[a] > sizes[b]) {\n\t\t\t\tswap(a, b);\n\t\t\t}\n\n\t\t\tauto it = res.find({a, b});\n\t\t\tif (it != res.end()) {\nprintf(\"%.10lf\\n\", it->second);\n//\t\t\t\tout << it->second << \"\\n\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint64_t ch = 0;\n\t\t\tint64_t zn = sizes[a] * 1LL * sizes[b];\n\t\t\tint startDiam = max(diam[a], diam[b]);\n\t\t\tfor (int i: range(lenCnt[a].size())) {\n\t\t\t\tint leftSize = i;\n\n\t\t\t\tint gr = max(0, startDiam - i);\n\t\t\t\tgr = min(gr, (int)(prefSums[b].size() - 1));\n\n\t\t\t\tch += lenCnt[a][i] * 1LL * prefSums[b][gr] * startDiam;\n\t\t\t\tch += lenCnt[a][i] * 1LL * ((prefSumsDp[b].back() - prefSumsDp[b][gr]) + (i + 1) * (prefSums[b].back() - prefSums[b][gr]));\n\t\t\t}\n\n\t\t\t//cerr << ch << ' ' << zn << endl;\n\n\t\t\tdouble ans = (ch / 1.0 / zn);\n\t\t\tres[{a, b}] = ans;\n\nprintf(\"%.10lf\\n\", ans);\n\t\t\t//out << ans << \"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskD solver;\n\tstd::istream& in(std::cin);   \n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["binary search", "brute force", "dfs and similar", "dp", "sortings", "trees"], "dificulty": "2500", "interactive": false}