{"link": "https://codeforces.com//contest/871/problem/D", "problemId": "128429", "problem_idx": "D", "shortId": "871D", "contest_number": "871", "problem_submissions": {"D": [31355895, 31362333, 31356242, 31355369, 31353137, 31356572, 31350479, 31349876, 31357261, 31360056, 31358528, 31351384, 31359864, 31356104, 31350689, 31354294, 31357470], "C": [31344782, 31345046, 31354747, 31341122, 31347757, 31339514, 31345476, 31343571, 31352939, 31343640, 31347078, 31353076, 31354366, 31357931, 31352546, 31348044, 31356324, 31348388, 31344111, 31340976], "B": [31340037, 31339973, 31340246, 31344130, 31345296, 31350867, 31351902, 31348642, 31355117, 31356940, 31344400, 31347404, 31350125, 31355555, 31345128, 31496128, 31350503], "A": [31334951, 31334542, 31334472, 31334988, 31334223, 31337899, 42189225, 37478044, 37460318, 31335310, 31335726, 31334028, 31336751, 31333319, 31341866, 31334833, 31352270, 31340759, 31335206, 31350845, 31354568, 31333534, 31334865], "E": [31356130, 31349981, 31355349, 31497224]}, "name": "D. Paths", "statement": "You are given a positive integer . Let\u2019s build a graph on vertices in\r\nsuch a way that there is an edge between vertices and if and only if .\r\nLet be the shortest distance between and , or if there is no path\r\nbetween them. Compute the sum of values over all .The (greatest common\r\ndivisor) of two positive integers is the maximum positive integer that\r\ndivides both of the integers.\r\n", "solutions": ["#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n - 1); i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << ' ';\\\n    cerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nconst int N = 1e7 + 10;\nint p[N];\nint copr[N];\nll pref[N];\nll pref_min_pr[N];\n\nvoid precalc() {\n    vector<int> primes;\n    forn(i, 0, N) p[i] = i;\n    forn(i, 2, N) {\n        if (p[i] == i)\n            primes.eb(i);\n        for (int x : primes) {\n            if (x > p[i]) break;\n            ll mul = 1ll * x * i;\n            if (mul >= N) break;\n            p[mul] = x; \n       }\n    }\n    copr[1] = 1;\n    forn(i, 2, N) {\n        int prev = i / p[i];\n        copr[i] = copr[prev];\n        copr[i] *= p[i];\n        if (p[i] != p[prev])\n            copr[i] -= copr[i] / p[i];\n    }\n    pref[1] = copr[1] - 1;\n    forn(i, 2, N)\n        pref[i] = pref[i - 1] + copr[i];\n}\n\nvoid check(int n) {\n    fore(i, 1, n) {\n        vector<int> dist(n + 1, INF);\n        queue<int> q;\n        dist[i] = 0;\n        q.push(i);\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            fore(v, 1, n)\n                if (__gcd(v, u) > 1 && dist[v] == INF) {\n                    dist[v] = 1 + dist[u];\n                    q.push(v);\n                }\n        }\n        fore(j, 1, n)\n            cout << (dist[j] == INF ? 0 : dist[j]) << ' ';\n        cout << '\\n';\n    }\n} \n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); \n    srand((unsigned)chrono::high_resolution_clock::now().time_since_epoch().count());\n    precalc();\n    //fore(i, 1, 10) cout << p[i] << ' '; \n    int n;\n    cin >> n;\n    if (n < 4) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n    //check(n);\n    ll good = n - 1;\n    fore(i, 2, n) {\n        if (2 * i > n && p[i] == i)\n            --good;\n    }\n    //cerr << good << '\\n';\n    ll ans = good * (good - 1) / 2 * 3;\n    fore(i, 2, n) {\n        //cerr << i << ' ' << pref[n / i] << '\\n';\n        ans -= pref[n / i];\n    }\n    ll cnt2 = 0;\n    fore(i, 2, n)\n        ++pref_min_pr[p[i]];\n\n    fore(i, 3, n)\n        pref_min_pr[i] += pref_min_pr[i - 1];\n    fore(i, 2, n) {\n        //cerr << i << ' ' << pref_min_pr[n / p[i]] << '\\n';\n        cnt2 += pref_min_pr[n / p[i]];\n    }\n    fore(i, 2, n)\n        if (1ll * p[i] * p[i] <= n)\n            --cnt2;\n    assert(cnt2 % 2 == 0);\n    ans -= cnt2 / 2;\n    //cerr << cnt2 << '\\n';\n    cout << ans << '\\n';\n    \n}\n"], "input": "", "output": "", "tags": ["number theory", "sortings"], "dificulty": "2700", "interactive": false}