{
    "link": "https://codeforces.com//contest/1179/problem/A",
    "problemId": "361544",
    "problem_idx": "A",
    "shortId": "1179A",
    "contest_number": "1179",
    "problem_submissions": {
        "E": [
            55903813,
            55902523,
            55901885,
            55909022,
            55905388,
            56432061,
            75942632,
            56023295
        ],
        "D": [
            55893003,
            55895931,
            55888725,
            55893104,
            71080559,
            71080196,
            71080163,
            71080130,
            71080072,
            71080060,
            55893173,
            55892658,
            55908319,
            55894131,
            55894542,
            55893763,
            55896830,
            56019124,
            55897859,
            55895869,
            55954689,
            55895158,
            55899492,
            55899301,
            55888559,
            55898280,
            55898257,
            55896770
        ],
        "C": [
            55884160,
            55884795,
            55882131,
            55884686,
            55905440,
            55885364,
            55885156,
            55885262,
            55885328,
            55886216,
            55885322,
            55883584,
            55886444,
            55954679,
            55890192,
            55886511,
            55887224,
            55900785,
            55886889,
            55887130,
            55889061
        ],
        "B": [
            55880474,
            55886283,
            55907977,
            55879717,
            55880717,
            55880688,
            55881071,
            55881636,
            55881390,
            55878893,
            55881077,
            55881153,
            55954669,
            55881453,
            55881368,
            55881391,
            55880057,
            55884243,
            55877081,
            55883081
        ],
        "A": [
            55876049,
            55878221,
            55877438,
            55877168,
            55878263,
            55877701,
            55876941,
            55878391,
            55879288,
            55877277,
            55877221,
            55878361,
            55954661,
            55878330,
            55878077,
            55877852,
            55877332,
            55880624,
            55880725,
            55879783
        ]
    },
    "name": "A. Valeriy and Deque",
    "statement": "Recently, on the course of algorithms and data structures, Valeriy\r\nlearned how to use a deque. He built a deque filled with n elements. The\r\ni-th element is a_i (i = 1, 2,\r\nldots, n). He gradually takes the first two leftmost elements from the\r\ndeque (let\u2019s call them A and B, respectively), and then does the\r\nfollowing: if A > B, he writes A to the beginning and writes B to the\r\nend of the deque, otherwise, he writes to the beginning B, and A writes\r\nto the end of the deque. We call this sequence of actions an\r\noperation.For example, if deque was [2, 3, 4, 5, 1], on the operation he\r\nwill write B=3 to the beginning and A=2 to the end, so he will get [3,\r\n4, 5, 1, 2].The teacher of the course, seeing Valeriy, who was\r\npassionate about his work, approached him and gave him q queries. Each\r\nquery consists of the singular number m_j (j = 1, 2,\r\nldots, q). It is required for each query to answer which two elements he\r\nwill pull out on the m_j-th operation.Note that and for each query the\r\nnumbers A and B should be . is a data structure representing a list of\r\nelements where insertion of new elements or deletion of existing\r\nelements can be made from both sides.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\n\ndeque <int> kol;\n\nvector <pii> ans;\n\nvoid wyp(pii v)\n{\n\tprintf(\"%d %d\\n\", v.first, v.second);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tkol.push_back(x);\n\t}\n\tfor (int i=1; i<=3*n+7; i++)\n\t{\n\t\tint a=kol.front();\n\t\tkol.pop_front();\n\t\tint b=kol.front();\n\t\tkol.pop_front();\n\t\tans.push_back({a, b});\n\t\tif (b>a)\n\t\t\tswap(a, b);\n\t\tkol.push_front(a);\n\t\tkol.push_back(b);\n\t}\n\twhile(q--)\n\t{\n\t\tll x;\n\t\tscanf(\"%lld\", &x);\n\t\tx--;\n\t\tif (x<=2*n)\n\t\t{\n\t\t\twyp(ans[x]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx-=n;\n\t\t\tx%=(n-1);\n\t\t\tx+=n;\n\t\t\twyp(ans[x]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Valeriy and Deque.json",
    "editorial_link": "https://codeforces.com//blog/entry/67891",
    "editorial": "It can be noted that if the deque has the largest element of the deque\r\nin the first position, then during the next operations it will remain in\r\nthe first position, and the second one will be written to the end each\r\ntime, that is, all the elements of the deque starting from the second\r\nwill move cyclically left.Let\u00e2\u0080\u0099s go over the deque and find the largest\r\nelement by value. We will perform the operation described in the\r\nstatements until the maximum position is in the first position and save\r\nthe elements in the first and second positions by the operation number.\r\nIn order to pre-calculate all pairs until the moment when the maximum\r\nposition is found, it is enough to make no more than one pass through\r\nthe deque, since in the worst case, the maximum element can be located\r\nat the end of the deque.Denote as the position of the maximum element.\r\nThen if , simply return a pair of numbers from the pre-calculated array,\r\notherwise is equal to the maximum element, and is equal to the deque\r\nelement with the index in -indexing (since we performed the operations\r\nuntil the moment when the maximum position is in the first position,\r\nthis maximum element is now recorded in the first position).\r\n"
}