{
    "link": "https://codeforces.com//contest/261/problem/C",
    "problemId": "2513",
    "problem_idx": "C",
    "shortId": "261C",
    "contest_number": "261",
    "problem_submissions": {
        "E": [
            2920000,
            2919867,
            2920093,
            2921784
        ],
        "D": [
            2918755,
            2917824,
            2919624,
            2920041,
            2920164,
            2923335,
            2921126,
            2921013,
            2920536,
            2920705,
            2919641,
            2925478,
            2920426,
            2921207,
            2921666
        ],
        "C": [
            2917546,
            2917887,
            2919188,
            2919828,
            2917463,
            2918109,
            2917854,
            2919507,
            2918011,
            2925470,
            2918182,
            2917265,
            2917678,
            2914481,
            2917995
        ],
        "B": [
            2913743,
            2914942,
            2915180,
            2915778,
            2915691,
            2915592,
            2915955,
            2917070,
            2921240,
            2925461,
            2921213,
            2914639,
            2914202,
            2916720,
            2914335
        ],
        "A": [
            2912104,
            2912172,
            2912286,
            2913678,
            2911982,
            2912228,
            2912646,
            2912866,
            2912845,
            2925453,
            2912722,
            2912028,
            2912201,
            2917202,
            2912517
        ]
    },
    "name": "C. Maxim and Matrix",
    "statement": "Maxim loves to fill in a matrix in a special manner. Here is a\r\npseudocode of filling in a matrix of size :Maxim asks you to count, how\r\nmany numbers are there, such that the sum of values in the cells in the\r\nrow number of the resulting matrix equals .Expression ( ) means applying\r\nthe operation of bitwise excluding \"OR\" to numbers and . The given\r\noperation exists in all modern programming languages. For example, in\r\nlanguages and it is represented by character \"\", in by \"\".\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <queue>\n#include <memory.h>\n#include <stack>\n#define mp make_pair\n#define pb push_back                     \n#define setval(a,v) memset(a,v,sizeof(a))\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n\n\nll ans[2][50];\nll ans2[2][50];\n\n\n\n\nint main(){\n  #ifdef LOCAL\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n  #endif\n\n\n  ll n,t;\n  cin >> n >> t;\n\n  if (t & (t-1)){\n  \tprintf(\"%d\\n\",0);\n  \treturn 0;\n  }\n\n  n++;\n  int cnt = __builtin_ctzll(t)+1;\n\n  ans[0][0] = 1;\n\n  for (int i = 60; i >= 0; i--){\n  \tfor (int j = 0; j < 45; j++){\n  \t\tans2[1][j] += ans[1][j];\n  \t\tans2[1][j+1] += ans[1][j];\n  \t\tif (n & (1LL<<i)) {\n  \t\t\tans2[0][j+1] += ans[0][j];\n  \t\t\tans2[1][j] += ans[0][j];\n  \t\t} else {\n  \t\t\tans2[0][j] += ans[0][j];\n  \t\t}\n  \t}                                                                            \n  \tmemcpy(ans,ans2,sizeof(ans));\n  \tmemset(ans2,0,sizeof(ans));  \t\n  \t//cerr << ans[0][0] <<\" \"<<ans[0][1] <<\" \"<<ans[1][0] <<\" \"<<ans[1][1] << endl;\n  }\n\n\n  cout << (ans[0][cnt] + ans[1][cnt]) - (t == 1) << endl;\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Maxim and Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/6398",
    "editorial": "For fixed m, the sum in the last row will be 2^(bit_count(m+1)-1). So now if T is not power of 2, answer is 0. Else we can find number of bits that we need. And know we have stndart problem. How many numbers form 2 to n+1 have exactly P bits in binary presentation of the number. It is well known problem can be done using binomial cooficients. We will count number of numebers smaller then out number with fixed prefix.",
    "hint": []
}