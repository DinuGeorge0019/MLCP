{"link": "https://codeforces.com//contest/191/problem/D", "problemId": "1353", "problem_idx": "D", "shortId": "191D", "contest_number": "191", "problem_submissions": {"D": [1730940, 1730058, 1732061, 1732109, 1732464], "E": [1728781, 1730615, 1727981, 1728842, 1729175, 1728797, 1729393, 1729602, 1729222, 1729975, 1730220, 1730326, 1729991, 1730136, 1729526, 1730229, 1730018, 1730441, 1730472], "C": [1727557, 1727971, 1727279, 1727922, 1728193, 1726763, 1727330, 1728312, 1727749, 1728454, 1728335, 1728217, 1728234, 1728828, 1727958, 1728318, 1727470, 1728758, 1727987], "B": [1726383, 1726744, 1729343, 1727040, 1726927, 1730397, 1728304, 1726935, 1728912, 1727207, 1727504, 1727317, 1729119, 1727295, 1728990, 1727070, 1729275, 1727129, 1729072], "A": [1725547, 1725524, 1725641, 1725909, 1725741, 1725703, 1725714, 1725752, 1725615, 1725779, 1725777, 1725532, 1726185, 1725907, 1725443, 1725690, 1725534, 1725596, 1727248]}, "name": "D. Metro Scheme", "statement": "Berland is very concerned with privacy, so almost all plans and\r\nblueprints are secret. However, a spy of the neighboring state managed\r\nto steal the Bertown subway scheme.The Bertown Subway has stations,\r\nnumbered from to , and bidirectional tunnels connecting them. All\r\nBertown Subway consists of lines. To be more precise, there are two\r\ntypes of lines: circular and radial.A is a sequence of stations , where\r\nstations and are connected by a tunnel and no station occurs in the line\r\nmore than once ( for ).A is a series of stations, , where stations are\r\nconnected by a tunnel. In addition, stations and are also connected by a\r\ntunnel. No station is occurs in the loop line more than once.Note that a\r\nsingle station can be passed by any number of lines.According to Berland\r\nstandards, there can\u2019t be more than one tunnel between two stations and\r\neach tunnel belongs to exactly one line. Naturally, each line has at\r\nleast one tunnel. Between any two stations there is the way along the\r\nsubway tunnels. In addition, in terms of graph theory, a subway is a\r\nvertex cactus: if we consider the subway as a graph in which the\r\nstations are the vertexes and the edges are tunnels, then each vertex\r\nlies on no more than one simple cycle.Unfortunately, scheme, stolen by\r\nthe spy, had only the stations and the tunnels. It was impossible to\r\ndetermine to which line every tunnel corresponds. But to sabotage\r\nsuccessfully, the spy needs to know what minimum and maximum number of\r\nlines may be in the Bertown subway.Help him!\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME \"std\"\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nvb was;\nvvi es;\nvi cst;\n\nvi cols;\nvvi cycs;\n\nvoid dfs(int v, int par = -1) {\n  was[v] = true;\n  cst.pb(v);\n  \n  for (int i = 0; i < sz(es[v]); i++) {\n    int b = es[v][i];\n    if (b == par) continue;\n    if (was[b]) {\n      if (cols[v] >= 0) {\n        assert(cols[v] == cols[b]);\n      } else {\n        int cid = sz(cycs);\n        cycs.pb(vi());\n        \n        for (int i2 = sz(cst) - 1; i2 >= 0; i2--) {\n          cycs[cid].pb(cst[i2]);\n          assert(cols[cst[i2]] < 0);\n          cols[cst[i2]] = cid;\n          if (cst[i2] == b) break;\n        }\n      }\n    } else\n      dfs(b, v);\n  }\n  cst.pop_back();\n}\n\nint dfs2(int v, int par = -1) {\n  int cid = cols[v];\n  int res = sz(cycs[cid]) > 1;\n  int sumcnt = 0;\n  int nzcnt = 0;\n\n  for (int i = 0; i < sz(cycs[cid]); i++) {\n    int a = cycs[cid][i];\n    int subcnt = 0;\n    \n    for (int i2 = 0; i2 < sz(es[a]); i2++) {\n      int b = es[a][i2];\n      if (cols[b] == cid) continue;\n\n      int cres = -1;\n      if (b != par) {\n        cres = dfs2(b, a);\n      } else {\n         cres = 1;\n      }\n      \n      res += cres; \n      subcnt++;\n    }\n//    if (v + 1 == 2)\n//      eprintf(\"  res=%d, subcnt=%d\\n\", res, subcnt);\n    res -= subcnt / 2;\n    sumcnt += subcnt;\n    if (subcnt) nzcnt++;\n  }\n//  eprintf(\"v=%d, par=%d, res=%d, sumcnt=%d\\n\", v + 1, par + 1, res, sumcnt);\n  if (sz(cycs[cid]) > 1) {\n    if (nzcnt >= 2) {\n      res -= 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME \".in\", \"r\", stdin);\n  freopen(TASKNAME \".out\", \"w\", stdout);\n  #endif\n  \n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) >= 1) {\n    es = vvi(n);\n    for (int i = 0; i < m; i++) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b), a--, b--;\n      es[a].pb(b);\n      es[b].pb(a);\n    }\n    \n    was = vb(n, false);\n    cst.clear();\n    cols = vi(n, -1);\n    cycs = vvi();\n    dfs(0);\n    \n    for (int i = 0; i < n; i++) if (cols[i] < 0) {\n      int cid = sz(cycs);\n      cycs.pb(vi(1, i));\n      cols[i] = cid;\n    }\n    \n/*    for (int i = 0; i < sz(cycs); i++) {\n      for (int i2 = 0; i2 < sz(cycs[i]); i2++)\n        eprintf(\" %d\", cycs[i][i2] + 1);\n      eprintf(\"\\n\");\n    }*/\n    \n    int ans = dfs2(0);\n    printf(\"%d %d\\n\", ans, m);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "greedy"], "dificulty": "2700", "interactive": false}