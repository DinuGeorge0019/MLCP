{
    "link": "https://codeforces.com//contest/986/problem/D",
    "problemId": "186084",
    "problem_idx": "D",
    "shortId": "986D",
    "contest_number": "986",
    "problem_submissions": {
        "D": [
            42104811,
            42104792,
            42104740,
            42104337,
            42103931,
            42103877,
            42103819,
            42103728,
            42103430,
            42103363,
            42090622,
            42090614,
            42090469,
            42090439,
            42090421,
            42090403,
            42090387,
            38733857,
            38748243,
            38741625,
            38744949,
            38732535,
            38776124,
            38775923,
            73829906,
            48935186,
            46682125,
            38947315,
            38947302,
            38947285,
            38946968,
            38946777,
            38946767,
            38946516,
            38946375,
            38946181,
            38944862,
            38944853,
            38944843,
            38944833,
            38944826,
            38944784,
            38944707,
            38944667,
            38944627,
            38903696,
            38903692,
            38903690,
            38903603,
            38903544,
            38903533,
            38903435,
            38903221,
            38903111,
            38903010,
            38902730,
            38902722,
            38902698,
            38868689,
            38868687,
            38868625,
            38868606,
            38868604,
            38868564,
            38868475,
            38868474,
            38868436,
            38868410,
            38868378,
            38868342,
            38868314,
            38868268,
            38868265,
            38868261,
            38868236,
            38868233,
            38868218,
            38868215,
            38868193,
            38868187,
            38868182,
            38868177,
            38868174,
            38868170,
            38868106,
            38868104,
            38868091,
            38868070,
            38868066,
            38868064,
            38868060,
            38868052,
            38868048,
            38868019,
            38868012,
            38868008,
            38868002,
            38783809,
            38783797,
            38783781,
            38783746,
            38783741,
            38783462,
            38783445,
            38780380,
            38776796,
            38776020,
            38776009,
            38775996,
            38775983,
            38775959,
            38774927,
            38774159,
            38774142,
            38774133,
            38774083,
            38772484,
            38772455,
            38772446,
            38772398,
            38772056,
            38771982,
            38771852,
            38771749,
            38771473,
            38770302,
            38770261,
            38758325,
            38743969,
            38775097,
            38775073,
            38775025,
            38774686,
            38769151
        ],
        "E": [
            38747055,
            38738177,
            38746661,
            38745236,
            38748676,
            38751753,
            38745180,
            38747262,
            38746823,
            38745830,
            38751939,
            38740507,
            38750013,
            38749870,
            38752411,
            38979399,
            38747190,
            38753936,
            38746328,
            42589039,
            38781799,
            38781783,
            38752251,
            38750400,
            38738811,
            38743630
        ],
        "F": [
            38743952,
            38741619,
            38749997,
            38752035,
            38759153,
            38766951,
            38747287,
            38803173,
            38802767
        ],
        "C": [
            38736843,
            38745069,
            38732331,
            38733537,
            38731636,
            38741009,
            38735527,
            38733610,
            38737347,
            38735879,
            38747912,
            38735093,
            38731137,
            38747956,
            38732967,
            38749305,
            38742224,
            38742550,
            38745758,
            38746063
        ],
        "B": [
            38727078,
            38726856,
            38726789,
            38729993,
            38726090,
            38734230,
            38728365,
            38728016,
            38727081,
            38728548,
            38726100,
            38728328,
            38735514,
            38726544,
            38737280,
            38727906,
            38727500,
            38748980,
            38769342
        ],
        "A": [
            38722963,
            38723690,
            38723235,
            38724127,
            38723622,
            38736390,
            38723609,
            38724267,
            38724018,
            38725327,
            38724685,
            38725264,
            38723597,
            38724159,
            38722907,
            38723625,
            38725178,
            38724347,
            38741266,
            38724867
        ]
    },
    "name": "D. Perfect Encoding",
    "statement": "You are working as an analyst in a company working on a new system for\r\nbig data storage. This system will store n different objects. Each\r\nobject should have a unique ID.To create the system, you choose the\r\nparameters of the system integers m\r\nge 1 and b_{1}, b_{2},\r\nldots, b_{m}. With these parameters an ID of some object in the system\r\nis an array of integers [a_{1}, a_{2},\r\nldots, a_{m}] where 1\r\nle a_{i}\r\nle b_{i} holds for every 1\r\nle i\r\nle m.Developers say that production costs are proportional to\r\nsum_{i=1}^{m} b_{i}. You are asked to choose parameters m and b_{i} so\r\nthat the system will be able to assign unique IDs to n different objects\r\nand production costs are minimized. Note that you don\u2019t have to use all\r\navailable IDs.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 29.05.2018 18:52:44       \n**/\n//#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nnamespace fft {\n  typedef double dbl;\n\n  struct num {\n    dbl x, y;\n    num() { x = y = 0; }\n    num(dbl x, dbl y) : x(x), y(y) { }\n  };\n\n  inline num operator+(num a, num b) { return num(a.x + b.x, a.y + b.y); }\n  inline num operator-(num a, num b) { return num(a.x - b.x, a.y - b.y); }\n  inline num operator*(num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n  inline num conj(num a) { return num(a.x, -a.y); }\n\n  int base = 1;\n  vector<num> roots = {{0, 0}, {1, 0}};\n  vector<int> rev = {0, 1};\n\n  const dbl PI = acosl(-1.0);\n\n  void ensure_base(int nbase) {\n    if (nbase <= base) {\n      return;\n    }\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      dbl angle = 2 * PI / (1 << (base + 1));\n//      num z(cos(angle), sin(angle));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n//        roots[(i << 1) + 1] = roots[i] * z;\n        dbl angle_i = angle * (2 * i + 1 - (1 << base));\n        roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));\n      }\n      base++;\n    }\n  }\n\n  void fft(vector<num> &a, int n = -1) {\n    if (n == -1) {\n      n = a.size();\n    }\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          num z = a[i + j + k] * roots[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n/*    for (int len = 1; len < n; len <<= 1) {\n      for (int i = 0; i < n; i += 2 * len) {\n        for (int j = i, k = i + len; j < i + len; j++, k++) {\n          num z = a[k] * roots[k - i];\n          a[k] = a[j] - z;\n          a[j] = a[j] + z;\n        }\n      }\n    }*/\n  }\n\n  vector<num> fa, fb;\n\n  vector<int> multiply(vector<int> &a, vector<int> &b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    if (sz > (int) fa.size()) {\n      fa.resize(sz);\n    }\n    for (int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = num(x, y);\n    }\n    fft(fa, sz);\n    num r(0, -0.25 / (sz >> 1));\n    for (int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;\n      if (i != j) {\n        fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;\n      }\n      fa[i] = z;\n    }\n    for (int i = 0; i < (sz >> 1); i++) {\n      num A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);\n      num A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];\n      fa[i] = A0 + A1 * num(0, 1);\n    }\n    fft(fa, sz >> 1);\n    vector<int> res(need);\n    for (int i = 0; i < need; i++) {\n      if (i % 2 == 0) {\n        res[i] = fa[i >> 1].x + 0.5;\n      } else {\n        res[i] = fa[i >> 1].y + 0.5;\n      }\n    }\n    return res;\n  }\n\n  vector<long long> square(const vector<int> &a) {\n    int need = a.size() + a.size() - 1;\n    int nbase = 1;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    if ((sz >> 1) > (int) fa.size()) {\n      fa.resize(sz >> 1);\n    }\n    for (int i = 0; i < (sz >> 1); i++) {\n      int x = (2 * i < (int) a.size() ? a[2 * i] : 0);\n      int y = (2 * i + 1 < (int) a.size() ? a[2 * i + 1] : 0);\n      fa[i] = num(x, y);\n    }\n    fft(fa, sz >> 1);\n    num r(1.0 / (sz >> 1), 0.0);\n    for (int i = 0; i <= (sz >> 2); i++) {\n      int j = ((sz >> 1) - i) & ((sz >> 1) - 1);\n      num fe = (fa[i] + conj(fa[j])) * num(0.5, 0);\n      num fo = (fa[i] - conj(fa[j])) * num(0, -0.5);\n      num aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];\n      num tmp = fe * fo;\n      fa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));\n      fa[j] = r * (aux + num(0, 2) * tmp);\n    }\n    fft(fa, sz >> 1);\n    vector<long long> res(need);\n    for (int i = 0; i < need; i++) {\n      if (i % 2 == 0) {\n        res[i] = fa[i >> 1].x + 0.5;\n      } else {\n        res[i] = fa[i >> 1].y + 0.5;\n      }\n    }\n    return res;\n  }\n\n  vector<int> multiply_mod(vector<int> &a, vector<int> &b, int m, int eq = 0) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    if (sz > (int) fa.size()) {\n      fa.resize(sz);\n    }\n    for (int i = 0; i < (int) a.size(); i++) {\n      int x = (a[i] % m + m) % m;\n      fa[i] = num(x & ((1 << 15) - 1), x >> 15);\n    }\n    fill(fa.begin() + a.size(), fa.begin() + sz, num {0, 0});\n    fft(fa, sz);\n    if (sz > (int) fb.size()) {\n      fb.resize(sz);\n    }\n    if (eq) {\n      copy(fa.begin(), fa.begin() + sz, fb.begin());\n    } else {\n      for (int i = 0; i < (int) b.size(); i++) {\n        int x = (b[i] % m + m) % m;\n        fb[i] = num(x & ((1 << 15) - 1), x >> 15);\n      }\n      fill(fb.begin() + b.size(), fb.begin() + sz, num {0, 0});\n      fft(fb, sz);\n    }\n    dbl ratio = 0.25 / sz;\n    num r2(0, -1);\n    num r3(ratio, 0);\n    num r4(0, -ratio);\n    num r5(0, 1);\n    for (int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      num a1 = (fa[i] + conj(fa[j]));\n      num a2 = (fa[i] - conj(fa[j])) * r2;\n      num b1 = (fb[i] + conj(fb[j])) * r3;\n      num b2 = (fb[i] - conj(fb[j])) * r4;\n      if (i != j) {\n        num c1 = (fa[j] + conj(fa[i]));\n        num c2 = (fa[j] - conj(fa[i])) * r2;\n        num d1 = (fb[j] + conj(fb[i])) * r3;\n        num d2 = (fb[j] - conj(fb[i])) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector<int> res(need);\n    for (int i = 0; i < need; i++) {\n      long long aa = fa[i].x + 0.5;\n      long long bb = fb[i].x + 0.5;\n      long long cc = fa[i].y + 0.5;\n      res[i] = (aa + ((bb % m) << 15) + ((cc % m) << 30)) % m;\n    }\n    return res;\n  }\n\n  vector<int> square_mod(vector<int> &a, int m) {\n    return multiply_mod(a, a, m, 1);\n  }\n};\n\nvoid multiply(vector<int> &a, int b) {\n  int carry = 0;\n  for (int i = 0; i < (int) a.size(); i++) {\n    carry += a[i] * b;\n    a[i] = carry % 100000;\n    carry /= 100000;\n  }\n  while (carry > 0) {\n    a.push_back(carry % 100000);\n    carry /= 100000;\n  }\n}\n\nvoid divide(vector<int> &a, int b) {\n  int md = 0;\n  for (int i = (int) a.size() - 1; i >= 0; i--) {\n    md = 100000 * md + a[i];\n    a[i] = md / b;\n    md %= b;\n  }\n  assert(md == 0);\n  while (!a.empty() && a.back() == 0) {\n    a.pop_back();\n  }\n}\n\nbool is_less(const vector<int> &a, const vector<int> &b) {\n  if (a.size() != b.size()) {\n    return (a.size() < b.size());\n  }\n  for (int i = (int) a.size() - 1; i >= 0; i--) {\n    if (a[i] != b[i]) {\n      return (a[i] < b[i]);\n    }\n  }\n  return false;\n}\n\nvector<int> sp3;\nvector<long long> sp3_aux;\n\nvoid get_p3(int p3) {\n  if (p3 <= 0) {\n    return;\n  }\n  if (p3 & 1) {\n    get_p3(p3 - 1);\n    multiply(sp3, 3);\n  } else {\n    get_p3(p3 >> 1);\n    sp3_aux = fft::square(sp3);\n    sp3.resize(sp3_aux.size());\n    long long carry = 0;\n    for (int i = 0; i < (int) sp3_aux.size(); i++) {\n      carry += sp3_aux[i];\n      sp3[i] = carry % 100000;\n      carry /= 100000;\n    }\n    while (carry > 0) {\n      sp3.push_back(carry % 100000);\n      carry /= 100000;\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n//  debug(fft::square({100, 200, 300, 400, 500}));\n//  return 0;\n  string foo;\n  cin >> foo;\n  if (foo == \"1\") {\n    cout << 1 << '\\n';\n    return 0;\n  }\n  int len = (int) foo.size();\n  vector<int> s_10(len);\n  for (int i = 0; i < len; i++) {\n    s_10[i] = (int) (foo[len - 1 - i] - '0');\n  }\n  vector<int> s((len + 4) / 5);\n  for (int i = 0; i < (int) s.size(); i++) {\n    s[i] = s_10[5 * i];\n    if (5 * i + 1 < (int) s_10.size()) s[i] += 10 * s_10[5 * i + 1];\n    if (5 * i + 2 < (int) s_10.size()) s[i] += 100 * s_10[5 * i + 2];\n    if (5 * i + 3 < (int) s_10.size()) s[i] += 1000 * s_10[5 * i + 3];\n    if (5 * i + 4 < (int) s_10.size()) s[i] += 10000 * s_10[5 * i + 4];\n  }\n  int p3 = (int) (logl(10) * (len - 1) / logl(3));\n  sp3.assign(1, 1);\n  get_p3(p3);\n  int ans = 3 * p3;\n  while (is_less(sp3, s)) {\n    if (ans <= 3) {\n      sp3[0] = ans + 1;\n    } else {\n      if (ans % 3 == 0) {\n        divide(sp3, 3);\n        multiply(sp3, 4);\n      } else {\n        divide(sp3, 2);\n        multiply(sp3, 3);\n      }\n    }\n    ans++;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "fft",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Perfect Encoding.json",
    "editorial_link": "https://codeforces.com//blog/entry/59758",
    "editorial": "The problem asks to find integers such that and is minimized.Let\u00e2\u0080\u0099s\r\nsuppose that in optimal solution there is among . It is better to split\r\nit to and : the sum remains the same and the product is increased (or\r\nstays the same). So we will use only and as our . If there are at least\r\nthree among , we can replace them with two : the sum remains the same,\r\nthe product is increased.So, optimal solution looks like this: zero, one\r\nor two s and some s.For now let\u00e2\u0080\u0099s say that we try all three\r\npossibilities for the number of s. The problem now looks like \"find\r\n\".The trick here is that we can estimate the answer very accurately.\r\nLet\u00e2\u0080\u0099s say that the length of decimal form of is . Then is very close to\r\n, the difference is not greater than . So it is easy to calculate the\r\nnumber such that .If we will calculate , then we should adjust this a\r\nlittle bit by multiplying by a few number of times. Multiplying by can\r\nbe done in linear time, comparing two numbers also in linear time. Let\u00e2\u0080\u0099s\r\nnow remember that we have tried all the possibilities for the number of\r\ns. We will do it not beforehand, but only now, because now each option\r\ncan be checked in linear time.To calculate we will use binary\r\nexponentiation with FFT. If the length of the result is , then the\r\nrunning time will be .To reduce the running time you should store the\r\nnumbers in base , not in base . This will reduce the length of the\r\nnumber times, and the numbers we are getting in FFT will be at most\r\nwhich is good enough to avoid precision issues.In the end, running time\r\nis roughly equivalent to 4 FFT calls of size which is not that big.Total\r\ncomplexity .\r\n"
}