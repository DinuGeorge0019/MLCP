{
    "link": "https://codeforces.com//contest/1508/problem/B",
    "problemId": "958782",
    "problem_idx": "B",
    "shortId": "1508B",
    "contest_number": "1508",
    "problem_submissions": {
        "D": [
            113258208,
            113225842,
            113232066,
            113242382,
            113242310,
            113248310,
            113252824,
            113256393,
            113240058,
            113236672,
            113233206,
            113240165,
            113242005,
            113242817,
            113243142
        ],
        "F": [
            113247954,
            113415583,
            113275748,
            113263512,
            113569093,
            113516939
        ],
        "C": [
            113237315,
            113213039,
            113214478,
            113213780,
            113212574,
            113213010,
            113224842,
            113226169,
            113232722,
            113215825,
            113215542,
            113224987,
            113223453,
            113228420,
            113228228,
            113217788,
            113226078,
            113229271,
            113230097
        ],
        "E": [
            113228353,
            113239041,
            113241831,
            113228851,
            113231701,
            113244425,
            113243109,
            113247201,
            113253919,
            113253035,
            113238610,
            113246155,
            113333091,
            113246539,
            113240797,
            113246922
        ],
        "A": [
            113201428,
            113189518,
            113189456,
            113190605,
            113198010,
            113192641,
            113194080,
            113204739,
            113207875,
            113194317,
            113200012,
            113222414,
            113194745,
            113195037,
            113199971,
            113199286,
            113193286,
            113195565,
            113191574,
            113194231
        ],
        "B": [
            113197951,
            113196658,
            113192904,
            113196665,
            113201215,
            113199153,
            113202442,
            113210198,
            113217372,
            113203624,
            113208530,
            113197629,
            113206458,
            113203987,
            113206383,
            113212945,
            113200476,
            113197819,
            113199529,
            113200558
        ]
    },
    "name": "B. Almost Sorted",
    "statement": "Seiji Maki doesn’t only like to observe relationships being unfolded, he\r\nalso likes to observe sequences of numbers, especially permutations.\r\nToday, he has his eyes on permutations.A permutation a_1, a_2,\r\ndots, a_n of 1, 2,\r\ndots, n is said to be if the condition a_{i + 1}\r\nge a_i - 1 holds for all i between 1 and n - 1 inclusive.Maki is\r\nconsidering the list of all almost sorted permutations of 1, 2,\r\ndots, n, given in lexicographical order, and he wants to find the k-th\r\npermutation in this list. Can you help him to find such\r\npermutation?Permutation p is lexicographically smaller than a\r\npermutation q if and only if the following holds: in the first position\r\nwhere p and q differ, the permutation p has a smaller element than the\r\ncorresponding element in q.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; int64_t K; cin >> N >> K; K--;\n\t\tif (N <= 62 && K >= (1ll << (N-1))) {\n\t\t\tcout << -1 << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> A; A.reserve(N);\n\t\tfor (int i = 0; i < N; ) {\n\t\t\tint j = i+1;\n\t\t\twhile (j < N && N-j-1 <= 62 && K >= (1ll << (N-j-1))) {\n\t\t\t\tK -= (1ll << (N-j-1));\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tfor (int z = j-1; z >= i; z--) {\n\t\t\t\tA.push_back(z);\n\t\t\t}\n\t\t\ti = j;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << A[i]+1 << \" \\n\"[i+1==N];\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Almost Sorted.json",
    "editorial_link": "https://codeforces.com//blog/entry/89644",
    "editorial": "Letâs first analyze the general structure of an almost sorted\r\npermutation. We know that when the sequence decreases, it must decrease\r\nby exactly . Thus, every decreasing subarray covers some consecutive\r\nrange of values. Letâs split the permutation into decreasing subarrays,\r\neach of them as large as possible. For example, we can split the almost\r\nsorted permutation as . The main claim goes as follows. Each almost\r\nsorted permutation is determined uniquely by the sequence of sizes of\r\nits maximal decreasing subarrays.So for instance, in the previous\r\nexample, the sequence of sizes uniquely determines the permutation as .\r\nThis is because the last element of a decreasing block must be smaller\r\nthan the first element in the next block. Otherwise we either have , in\r\nwhich case we should expand the previous block, or , which is\r\ncontradictory.Now, this is basically enough to get a complete solution.\r\nThrough some careful counting (which we will go into detail about later)\r\nwe can show that there are almost sorted permutations of size . Now\r\nnotice that smaller sizes for the first block produce lexicographically\r\nsmaller permutations (since a permutation whose first block has size\r\nstarts with ). Moreover, the remaining sequence after deleting the first\r\nblock is almost sorted. This enables to do a recursive argument to find\r\nthe permutation, by first choosing the correct size for the first block\r\nand then solving recursively for the remaining sequence. This works in\r\n.But we can do better. Letâs mark the positions in the array where a\r\ndecreasing block ends with , and the other positions as . Notice that\r\nthe last character is always , so we will ignore it and assign only the\r\nother characters. Thus our example permutation becomes since the first,\r\nsecond, and third blocks end at positions , , and . By the first claim,\r\nwe can recover the permutation from this sequence (which is also the\r\nproof of there being permutations of size that we promised\r\nearlier!).Now, we can read the assigned sequence as a binary number, for\r\ninstance, the corresponding number is for our trusty example. The point\r\nof doing this is the following: The -th almost sorted permutation in\r\nlexicographical order is assigned the number .To prove this itâs\r\nactually enough to check that the number is assigned to a greater\r\npermutation than the number . This can be done by looking at how the\r\npermutation changes when we add to , looking at the binary\r\nrepresentation of from right to left. We leave it to the reader to fill\r\nin the details of the proof, but hereâs a diagram showing the situation\r\ngraphically (with height representing the values of the permutation).\r\nAnyways, once we have proven this claim, we get a simple solution by\r\nfinding the binary representation of and using it to reconstruct the\r\nblocks in .\r\n",
    "hint": [
        "Hint 1 What is the general structure of an almost sorted permutation? Answer Start with the identity permutation, choose some disjoint subarrays, and reverse each of them.",
        "Hint 2 How many almost sorted permutations of length exist? In other words, how many ways are there to reverse subarrays? Answer",
        "Hint 3 Two options — either solve recursively in a greedy fashion or find a smart bijection."
    ]
}