{"link": "https://codeforces.com//contest/128/problem/C", "problemId": "674", "problem_idx": "C", "shortId": "128C", "contest_number": "128", "problem_submissions": {"B": [868631, 867052, 866131, 868093, 864920, 867712, 867635, 868241, 868954, 866973, 868225, 869082, 869329, 868786], "C": [867417, 865854, 866628, 866135, 867141, 866532, 866167, 866639, 866961, 867655, 868770, 866966, 867088, 867033], "D": [865898, 866482, 867528, 866945, 868692, 868382, 868718, 867247, 867493, 868514, 866507, 867640, 867746, 867494], "A": [865243, 865123, 865205, 865177, 867354, 866061, 865379, 868310, 865524, 866301, 865222, 865534, 865830, 866105]}, "name": "C. Games with Rectangle", "statement": "In this task Anna and Maria play the following game. Initially they have\r\na checkered piece of paper with a painted rectangle (only the border, no\r\nfilling). Anna and Maria move in turns and Anna starts. During each move\r\none should paint inside the last-painted rectangle a new lesser\r\nrectangle (along the grid lines). The new rectangle should have no\r\ncommon points with the previous one. Note that when we paint a\r\nrectangle, we always paint only the border, the rectangles aren\u2019t\r\nfilled.Nobody wins the game Anna and Maria simply play until they have\r\ndone moves in total. Count the number of different ways to play this\r\ngame.\r\n", "solutions": ["#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long double real;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf (stderr, __VA_ARGS__)\n#else\n#define eprintf(...) assert (true)\n#endif\n\n#ifdef WIN32\n#define INT64 \"%I64d\"\n#else\n#define INT64 \"%lld\"\n#endif\n\nusing namespace std;\n\nconst int MaxN = 1003, NA = -1, MaxC = 0x3F3F3F3F, MOD = 1000000007;\n\nint f [2] [MaxN];\nint k, m, n;\n\ninline int add (int a, int b)\n{\n int res;\n res = a + b;\n if (res >= MOD)\n  res -= MOD;\n return res;\n}\n\nint main (void)\n{\n int b, i, j, res, s;\n\n while (scanf (\" %d %d %d\", &n, &m, &k) != EOF)\n {\n  n -= 2 * k + 1;\n  m -= 2 * k + 1;\n  if (n < 0 || m < 0)\n  {\n   printf (\"0\\n\");\n   continue;\n  }\n\n  memset (f, 0, sizeof (f));\n  b = 0;\n  for (i = 0; i < MaxN; i++)\n   f[b][i] = 1;\n  for (j = 0; j < k; j++)\n  {\n   b ^= 1;\n   s = f[!b][0];\n   f[b][0] = s;\n   for (i = 1; i < MaxN; i++)\n   {\n    s = add (s, f[!b][i]);\n    f[b][i] = add (s, f[b][i - 1]);\n   }\n  }\n\n  res = ((int64) f[b][m] * (int64) f[b][n]) % MOD;\n  printf (\"%d\\n\", res);\n }\n return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2000", "interactive": false}