{
    "link": "https://codeforces.com//contest/875/problem/F",
    "problemId": "128563",
    "problem_idx": "F",
    "shortId": "875F",
    "contest_number": "875",
    "problem_submissions": {
        "E": [
            31401553,
            31405129,
            31392967,
            31402730,
            31406263,
            31406095,
            31408958,
            31406910,
            31404200,
            32046810,
            31410002,
            31402646,
            31408382,
            31408030,
            31409057,
            31407519,
            31408444,
            31409422,
            31410812
        ],
        "F": [
            31398084,
            31399145,
            31396559,
            31395380,
            31403081,
            31400082,
            31403804,
            31406312,
            31396246,
            31399556,
            31401521,
            31404590,
            31400144,
            31400447,
            31405585,
            31400568,
            31400491
        ],
        "D": [
            31396611,
            31396495,
            31401963,
            31398464,
            31393353,
            31401930,
            31397316,
            31400838,
            31400178,
            31401960,
            31405520,
            31403500,
            31399600,
            31393212,
            31397813,
            31402582,
            31404085,
            31402819
        ],
        "C": [
            31393812,
            31393863,
            31406345,
            31407198,
            31398483,
            31396625,
            31396317,
            31397236,
            31394681,
            31407238,
            31393913,
            31402010,
            31410726,
            31409259,
            31398396,
            31400696,
            31397975
        ],
        "B": [
            31389883,
            31401063,
            31407394,
            31393529,
            31395934,
            31391146,
            31390806,
            31391837,
            31403535,
            31403703,
            31396960,
            31396617,
            31395546,
            31393934,
            31392682,
            31393141,
            31391081
        ],
        "A": [
            31388853,
            31388828,
            31407811,
            31389006,
            31389634,
            31389036,
            31388899,
            31388792,
            31388831,
            31388861,
            31388768,
            31390308,
            31389965,
            31388888,
            31389164,
            31388787,
            31388820
        ]
    },
    "name": "F. Royal Questions",
    "statement": "In a medieval kingdom, the economic crisis is raging. Milk drops fall,\r\nEconomic indicators are deteriorating every day, money from the treasury\r\ndisappear. To remedy the situation, King Charles Sunnyface decided make\r\nhis sons-princes marry the brides with as big dowry as possible.In\r\nsearch of candidates, the king asked neighboring kingdoms, and after a\r\nwhile several delegations arrived with unmarried princesses. Receiving\r\nguests, Karl learned that the dowry of the th princess is of golden\r\ncoins. Although the action takes place in the Middle Ages, progressive\r\nideas are widespread in society, according to which no one can force a\r\nprincess to marry a prince whom she does not like. Therefore, each\r\nprincess has an opportunity to choose two princes, for each of which she\r\nis ready to become a wife. The princes were less fortunate, they will\r\nobey the will of their father in the matter of choosing a bride.Knowing\r\nthe value of the dowry and the preferences of each princess, Charles\r\nwants to play weddings in such a way that the total dowry of the brides\r\nof all his sons would be as great as possible. At the same time to marry\r\nall the princes or princesses is not necessary. Each prince can marry no\r\nmore than one princess, and vice versa, each princess can marry no more\r\nthan one prince.Help the king to organize the marriage of his sons in\r\nthe most profitable way for the treasury.\r\n",
    "solutions": [
        "#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint n,m,f[200010],g[200010],p;\nstruct orz\n{\n\tint u,v,w;\n}x[200010];\ninline bool cmp(orz a,orz b)\n{\n\treturn a.w>b.w;\n}\ninline int fa(int i)\n{\n\treturn f[i]==i?i:f[i]=fa(f[i]);\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++)\n\t  scanf(\"%d%d%d\",&x[i].u,&x[i].v,&x[i].w);\n\tsort(x+1,x+m+1,cmp);\n\tfor(i=1;i<=n;i++)\n\t  f[i]=i;\n\tfor(i=1;i<=m;i++)\n\t  {\n\t   j=fa(x[i].u);\n\t   k=fa(x[i].v);\n\t   if(j==k)\n\t     {\n\t      if(g[j]==0)\n\t        {\n\t\t\t g[j]++;\n\t\t\t p+=x[i].w;\n\t\t\t}\n\t\t }\n\t   else\n\t     if(g[j]+g[k]<=1)\n\t       {\n\t\t\tf[k]=j;\n\t\t\tg[j]+=g[k];\n\t\t\tp+=x[i].w;\n\t\t   }\n\t  }\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Royal Questions.json",
    "editorial_link": "https://codeforces.com//blog/entry/55233",
    "editorial": "Consider bipartite graph in which princesses are in the left part and\r\nprinces in the right part.Because of the propriety of transversal\r\nmatroid you can choose princesses greedily: letâs sort princesses\r\naccording to decrease in size of dowry and in this order try to add to\r\nmatching. It can be done at every time finding alternating chain. But\r\nthis solution can be speed up.Letâs try to attribute to each (not\r\nisolated) vertex of right part the most expensive vertex of left part.\r\nIf resulting set of edges is a matching it will be the solution. The set\r\nof edges can not form matching only if in the left part there are some\r\nvertexes for which both edges are taken. Letâs name these vertexes\r\n\"popular\". Suppose that we didnât take any popular vertex in the optimal\r\nanswer. Then you can take any its neighbor from right part and improve\r\nthe answer. Thatâ why weight of popular vertex can be added to the\r\nanswer and remove it from the graph uniting its neighbors to one vertex.\r\nThis vertex will describe the prince who has not got popular princess.As\r\nin the previous case weâll consider vertexes of left part in descending\r\norder and the vertexes of right part we will keep is disjoint set union.\r\nIf the current vertex of right part has two neighbors in right part, we\r\nadd its weight to the answer and unite its neighbors in DSU. In the\r\nvertex has one neighbor in right part, we add the weight of vertex to\r\nthe answer and remove the vertex of right part. Otherwise we donât add\r\nthe weight of vertex to the answer.Solution works in .\r\n",
    "hint": []
}