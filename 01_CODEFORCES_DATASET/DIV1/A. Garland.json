{
    "link": "https://codeforces.com//contest/1286/problem/A",
    "problemId": "509639",
    "problem_idx": "A",
    "shortId": "1286A",
    "contest_number": "1286",
    "problem_submissions": {
        "E": [
            68277312,
            68282070,
            68274194,
            68303699,
            68303260,
            68305269,
            68280891,
            68275520,
            68485018,
            68484885,
            68281607,
            68589901,
            71865785,
            101133015,
            68300396
        ],
        "C2": [
            68266879,
            68290041,
            68261617,
            68262301,
            68264579,
            68294367,
            68270650,
            68281404,
            68295029,
            68426335,
            68286377,
            68264588,
            68267031
        ],
        "D": [
            68263572,
            68264108,
            68884999,
            68884847,
            68884788,
            68283246,
            68268908,
            68270542,
            68266913,
            68271305,
            68294377,
            68276847,
            68262972,
            68265436,
            68273176,
            68274949,
            68277188,
            68266253,
            68271981,
            68278589,
            68338459,
            68281162,
            68264815
        ],
        "C1": [
            68253495,
            68254635,
            68259019,
            68259783,
            68260037,
            68294288,
            68263649,
            68253659,
            68276644,
            68259313,
            68260800,
            68257683,
            68278462,
            68275645,
            68260838,
            68264488,
            68260121
        ],
        "B": [
            68249656,
            68250720,
            68252206,
            68250842,
            68249851,
            68249360,
            68294267,
            68254854,
            68250823,
            68250630,
            68252322,
            68250475,
            68253134,
            68252948,
            68253877,
            68249986,
            68255559,
            68256077,
            68252468,
            68253101,
            68252113
        ],
        "A": [
            68245108,
            68248019,
            68248101,
            68248225,
            68245837,
            68246154,
            68294224,
            68250492,
            68248558,
            68247246,
            68248005,
            68247110,
            68249600,
            68246667,
            68250822,
            68253310,
            68252365,
            68251609,
            68247685,
            68248520,
            68246550
        ],
        "F": [
            68288717,
            68426651,
            68284858,
            68284592,
            68283300,
            68321599,
            68593980,
            68272947,
            68281697,
            68274721,
            75028012
        ]
    },
    "name": "A. Garland",
    "statement": "Vadim loves decorating the Christmas tree, so he got a beautiful garland\r\nas a present. It consists of n light bulbs in a single row. Each bulb\r\nhas a number from 1 to n (in arbitrary order), such that all the numbers\r\nare distinct. While Vadim was solving problems, his home Carp removed\r\nsome light bulbs from the garland. Now Vadim wants to put them back\r\non.Vadim wants to put all bulb back on the garland. Vadim defines of a\r\ngarland to be the number of pairs of adjacent bulbs with numbers with\r\ndifferent parity (remainder of the division by 2). For example, the\r\ncomplexity of is 2 and the complexity of is 1.No one likes complexity,\r\nso Vadim wants to minimize the number of such pairs. Find the way to put\r\nall bulbs back on the garland, such that the complexity is as small as\r\npossible.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[110], n, C0, C1, D[110][110][2];\nint main() {\n\tint i, j, k, l;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tif (i % 2 == 0)C0++;\n\t\telse C1++;\n\t}\n\tfor (i = 0; i <= n; i++) {\n\t\tfor (j = 0; j <= n; j++) {\n\t\t\tD[i][j][0]=D[i][j][1] = 1e9;\n\t\t}\n\t}\n\tD[0][0][0]=D[0][0][1] = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tfor (k = 0; k < 2; k++) {\n\t\t\t\tint t = D[i - 1][j][k];\n\t\t\t\tif (w[i]) {\n\t\t\t\t\tif (w[i] % 2 == 0) {\n\t\t\t\t\t\tD[i][j + 1][0] = min(D[i][j + 1][0], t+(k!=0));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tD[i][j][1] = min(D[i][j][1], t + (k!=1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (l = 0; l < 2; l++) {\n\t\t\t\t\t\tD[i][j + 1 - l][l] = min(D[i][j + 1 - l][l], t + (k != l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", min(D[n][C0][0], D[n][C0][1]));\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Garland.json",
    "editorial_link": "https://codeforces.com//blog/entry/72867",
    "editorial": "The problem can be solved using a greedy algorithm. Notice that the only\r\ninformation we need is parity of numbers on bulbs. So let\u00e2\u0080\u0099s replace\r\nnumbers by their remainders modulo . Than of garland will be the number\r\nof pairs of adjacent numbers that are different. Let\u00e2\u0080\u0099s call such pairs\r\nas bad.Divide garland into segments of removed bulbs. Let\u00e2\u0080\u0099s call number\r\nbefore segment as and number after segment as . If there\u00e2\u0080\u0099s no number\r\nbefore/after the segment than the segment doesn\u00e2\u0080\u0099t have left/right\r\nborder.Notice that when filling a segment, one should place the same\r\nnumbers in a row (if any). If the segment has different borders then the\r\noptimal way is to place all zeroes near zero-border and all ones near\r\none-border. If the segment has the same borders and we place both\r\nnumbers in the segment that there will be at least two bad pairs and we\r\nwill achieve it by placing all zeroes and then all ones. Similarly one\r\ncould prove cases with the absence of one or two borders.If the segment\r\nhas both borders and they are different then this segment always will\r\nincrease the complexity by . If the segment has both borders and they\r\nare different then this segment will increase the complexity by or .\r\nwill be in case we fill segment by numbers of the same parity as its\r\nborders. Otherwise, it will be .If the segment doesn\u00e2\u0080\u0099t have at least one\r\nof borders, it will increase the complexity by if all numbers have the\r\nsame parity as its border (if any) and otherwise.So in order to minimize\r\nthe complexity of garland, first of all, we should fill segments with\r\nthe same borders by the numbers of the same parity. Obviously we should\r\nconsider such segments in increasing length order.Then we should fill\r\nsegments with only one border such that complexity won\u00e2\u0080\u0099t increase.After\r\nthat, we can place the remaining numbers arbitrary (but inside one\r\nsegment we should place the same numbers in a row). Because for all\r\nremaining segments number of bad pairs is fixed.Time complexity is\r\n.Also, this problem could be solved using dynamic programming.\r\n"
}