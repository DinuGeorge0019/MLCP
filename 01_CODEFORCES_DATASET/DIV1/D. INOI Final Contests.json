{"link": "https://codeforces.com//contest/1439/problem/D", "problemId": "798718", "problem_idx": "D", "shortId": "1439D", "contest_number": "1439", "problem_submissions": {"E": [98736027, 98740513, 98743267, 98751627, 98746552, 98793931, 99104638], "D": [98723891, 98705229, 98723612, 98827591, 98816648, 98814032, 98725036, 98724071, 98728933, 98730831, 98730544, 98736469, 98737101, 98739698, 98716903, 98721633, 98735777, 98741204, 98725990, 98732940, 98719637, 98741795], "C": [98717653, 98714961, 98717583, 98709251, 98712683, 98710256, 98709014, 98716952, 98723694, 98722478, 98723203, 98711303, 98733440, 98725610, 98728037, 98706473, 98717733, 98731377, 98715466, 98722420], "B": [98704771, 98722470, 98701689, 98703648, 98704924, 98788376, 98780895, 98705172, 98721750, 98849262, 98707321, 98708231, 98709710, 98796719, 98765489, 98765480, 98765433, 98765408, 98765370, 98750864, 98750749, 98747376, 98713010, 98736680, 98709620, 98716637, 98748644, 114352814, 99699811, 98846560, 98754739, 98754712, 98711616], "A2": [98692587, 98708717, 98890116, 98695391, 98695058, 98694605, 98697338, 98695371, 98698896, 98697020, 98700533, 98695246, 98692759, 98703206, 98695281, 98699389, 98696575, 98695659, 98722036, 98693365, 98696174], "A1": [98692484, 98708569, 98695320, 98695174, 98694699, 98697254, 98695563, 98698871, 98696932, 98700473, 98695187, 98692661, 98703311, 98695126, 98699325, 98696645, 98695725, 98722109, 98693254, 98696254]}, "name": "D. INOI Final Contests", "statement": "Today is the final contest of INOI (Iranian National Olympiad in\r\nInformatics). The contest room is a row with n computers. All computers\r\nare numbered with integers from 1 to n from left to right. There are m\r\nparticipants, numbered with integers from 1 to m.We have an array a of\r\nlength m where a_{i} (1\r\nleq a_i\r\nleq n) is the computer behind which the i-th participant wants to\r\nsit.Also, we have another array b of length m consisting of characters \u201d\r\nand \u201d. b_i is the side from which the i-th participant enters the room.\r\n\u201d means the participant enters from the left of computer 1 and goes from\r\nleft to right, and \u201d means the participant enters from the right of\r\ncomputer n and goes from right to left.The participants in the order\r\nfrom 1 to m enter the room one by one. The i-th of them enters the\r\ncontest room in the direction b_i and goes to sit behind the a_i-th\r\ncomputer. If it is occupied he keeps walking in his direction until he\r\nreaches the first unoccupied computer. After that, he sits behind it. If\r\nhe doesn\u2019t find any computer he gets upset and gives up on the\r\ncontest.The madness of the i-th participant is the distance between his\r\nassigned computer (a_i) and the computer he ends up sitting behind. The\r\ndistance between computers i and j is equal to |i - j|.The values in the\r\narray a equal. There exist n^m\r\ncdot 2^m possible pairs of arrays (a, b).Consider all pairs of arrays\r\n(a, b) such that no person becomes upset. For each of them let\u2019s\r\ncalculate the sum of participants madnesses. Find the sum of all these\r\nvalues.You will be given some prime modulo p. Find this sum by modulo p.\r\n", "solutions": ["#include <bits/stdc++.h>\n\ntemplate <typename T, int NDIMS> struct tensor_view {\n\tstatic_assert(NDIMS >= 0, \"NDIMS must be nonnegative\");\n\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tT* data;\n\n\ttensor_view(std::array<int, NDIMS> shape_, std::array<int, NDIMS> strides_, T* data_) : shape(shape_), strides(strides_), data(data_) {}\n\npublic:\n\ttensor_view() : shape{0}, strides{0}, data(nullptr) {}\n\nprotected:\n\tint flatten_index(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) { res += idx[i] * strides[i]; }\n\t\treturn res;\n\t}\n\tint flatten_index_checked(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) {\n\t\t\tassert(0 <= idx[i] && idx[i] < shape[i]);\n\t\t\tres += idx[i] * strides[i];\n\t\t}\n\t\treturn res;\n\t}\n\npublic:\n\tT& operator[] (std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index(idx)];\n\t}\n\tT& at(std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index_checked(idx)];\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> operator[] (int idx) const {\n\t\tstd::array<int, NDIMS-1> nshape; std::copy(shape.begin()+1, shape.end(), nshape.begin());\n\t\tstd::array<int, NDIMS-1> nstrides; std::copy(strides.begin()+1, strides.end(), nstrides.begin());\n\t\tT* ndata = data + (strides[0] * idx);\n\t\treturn tensor_view<T, NDIMS-1>(nshape, nstrides, ndata);\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> at(int idx) const {\n\t\tassert(0 <= idx && idx < shape[0]);\n\t\treturn operator[](idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 == D), T&> operator * () const {\n\t\treturn *data;\n\t}\n\n\ttemplate <typename U, int D> friend struct tensor_view;\n\ttemplate <typename U, int D> friend struct tensor;\n};\n\ntemplate <typename T, int NDIMS> struct tensor {\n\tstatic_assert(NDIMS >= 0, \"NDIMS must be nonnegative\");\n\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tint len;\n\tT* data;\n\npublic:\n\ttensor() : shape{0}, strides{0}, len(0), data(nullptr) {}\n\n\texplicit tensor(std::array<int, NDIMS> shape_, const T& t = T()) {\n\t\tshape = shape_;\n\t\tstrides[NDIMS-1] = 1;\n\t\tfor (int i = NDIMS-1; i > 0; i--) {\n\t\t\tstrides[i-1] = strides[i] * shape[i];\n\t\t}\n\t\tlen = strides[0] * shape[0];\n\t\tdata = new T[len];\n\t\tstd::fill(data, data + len, t);\n\t}\n\n\ttensor(const tensor& o) : shape(o.shape), strides(o.strides), len(o.len), data(new T[len]) {\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tdata[i] = o.data[i];\n\t\t}\n\t}\n\n\ttensor& operator=(tensor&& o) noexcept {\n\t\tusing std::swap;\n\t\tswap(shape, o.shape);\n\t\tswap(strides, o.strides);\n\t\tswap(len, o.len);\n\t\tswap(data, o.data);\n\t\treturn *this;\n\t}\n\ttensor(tensor&& o) : tensor() {\n\t\t*this = std::move(o);\n\t}\n\ttensor& operator=(const tensor& o) {\n\t\treturn *this = tensor(o);\n\t}\n\t~tensor() { delete[] data; }\n\n\tusing view_t = tensor_view<T, NDIMS>;\n\tview_t view() {\n\t\treturn tensor_view<T, NDIMS>(shape, strides, data);\n\t}\n\toperator view_t() {\n\t\treturn view();\n\t}\n\n\tusing const_view_t = tensor_view<const T, NDIMS>;\n\tconst_view_t view() const {\n\t\treturn tensor_view<const T, NDIMS>(shape, strides, data);\n\t}\n\toperator const_view_t() const {\n\t\treturn view();\n\t}\n\n\tT& operator[] (std::array<int, NDIMS> idx) { return view()[idx]; }\n\tT& at(std::array<int, NDIMS> idx) { return view().at(idx); }\n\tconst T& operator[] (std::array<int, NDIMS> idx) const { return view()[idx]; }\n\tconst T& at(std::array<int, NDIMS> idx) const { return view().at(idx); }\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> operator[] (int idx) {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> at(int idx) {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<const T, NDIMS-1>> operator[] (int idx) const {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<const T, NDIMS-1>> at(int idx) const {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 == D), T&> operator * () {\n\t\treturn *view();\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 == D), const T&> operator * () const {\n\t\treturn *view();\n\t}\n};\n\ntemplate <int& MOD_> struct modnum {\n\tstatic constexpr int& MOD = MOD_;\n\t//static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv -= MOD-o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nint MOD;\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint N, M; cin >> N >> M >> MOD;\n\tN++;\n\tusing num = modnum<MOD>;\n\tvector<num> fact(N+1);\n\tfact[0] = 1;\n\tfor (int i = 1; i <= N; i++) fact[i] = fact[i-1] * num(i);\n\tvector<num> ifact(N+1);\n\tifact[N] = inv(fact[N]);\n\tfor (int i = N; i >= 1; i--) ifact[i-1] = ifact[i] * num(i);\n\n\tvector<num> ways(N+1);\n\tvector<num> tot_val(N+1);\n\tways[0] = 1, tot_val[0] = 0;\n\n\tfor (int l = 1; l <= N; l++) {\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\tint a = i, b = l-1-i;\n\n\t\t\tnum choose = fact[a+b] * ifact[a] * ifact[b];\n\t\t\tnum sub_ways = ways[a] * ways[b] * choose;\n\t\t\tnum sub_val = (tot_val[a] * ways[b] + tot_val[b] * ways[a]) * choose;\n\n\t\t\tways[l] += sub_ways * num(l+1);\n\t\t\ttot_val[l] += sub_val * num(l+1) + sub_ways * num(a * (a+1) / 2 + b * (b+1) / 2);\n\t\t}\n\t}\n\n\ttensor<num, 2> pref_ways({N+1, M+1});\n\ttensor<num, 2> pref_vals({N+1, M+1});\n\tpref_ways[{0,0}] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= M; j++) {\n\t\t\tfor (int k = 0; j+k <= M && i+1+k <= N; k++) {\n\t\t\t\tnum choose = fact[j+k] * ifact[j] * ifact[k];\n\t\t\t\tpref_ways[{i+1+k,j+k}] += pref_ways[{i,j}] * ways[k] * choose;\n\t\t\t\tpref_vals[{i+1+k,j+k}] += (pref_ways[{i,j}] * tot_val[k] + pref_vals[{i,j}] * ways[k]) * choose;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << pref_vals[{N,M}] << '\\n';\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "fft"], "dificulty": "3100", "interactive": false}