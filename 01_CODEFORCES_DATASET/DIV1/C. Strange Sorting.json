{
    "link": "https://codeforces.com//contest/484/problem/C",
    "problemId": "16630",
    "problem_idx": "C",
    "shortId": "484C",
    "contest_number": "484",
    "problem_submissions": {
        "C": [
            8575684,
            8569482,
            8574840,
            8573079,
            8568696,
            8568968,
            8568953,
            8573362,
            8573344,
            8575027,
            8567400,
            8571965,
            8576498,
            8577415
        ],
        "D": [
            8571455,
            8567671,
            8570841,
            8566590,
            8573430,
            8573737,
            8570084,
            8567140,
            8569185,
            8572829,
            8569478,
            8568570,
            8570839,
            8567603,
            8570405,
            8575447,
            8576600,
            8570465
        ],
        "E": [
            8569351,
            8573776,
            8571793,
            8588317,
            8599514,
            8573714,
            8570287,
            8574072,
            8576131,
            8573638,
            8564834,
            8574687
        ],
        "B": [
            8564067,
            8565086,
            8563436,
            8564295,
            8563987,
            8571069,
            8564862,
            8565541,
            8565694,
            8569521,
            8562876,
            8561100,
            8562368,
            8567973,
            8567211,
            8562295,
            8570348,
            8565013
        ],
        "A": [
            8560332,
            8562129,
            8565876,
            8560720,
            8562390,
            8561095,
            8562048,
            8560946,
            8561471,
            8562609,
            8565347,
            8560391,
            8562975,
            8560379,
            8563409,
            8565195,
            8567495,
            8562118
        ]
    },
    "name": "C. Strange Sorting",
    "statement": "How many specific orders do you know? Ascending order, descending order,\r\norder of ascending length, order of ascending polar angle... Let\u2019s have\r\na look at another specific order: . This sorting is applied to the\r\nstrings of length at least , where is some positive integer. The\r\ncharacters of the string are sorted in following manner: first come all\r\nthe 0-th characters of the initial string, then the 1-st ones, then the\r\n2-nd ones and so on, in the end go all the -th characters of the initial\r\nstring. By the -th characters we mean all the character whose positions\r\nare exactly modulo . If two characters stand on the positions with the\r\nsame remainder of integer division by , their relative order after the\r\nsorting shouldn\u2019t be changed. The string is zero-indexed. For example,\r\nfor string \u201d:Its 1-sorting is the string \u201d (all characters stand on 0\r\npositions),Its 2-sorting is the string \u201d (characters \u201d, \u201d and \u201d stand on\r\n0 positions and characters \u201d, \u201d and \u201d are on 1 positions),Its 3-sorting\r\nis the string \u201d (characters \u201d and \u201d stand on 0 positions, characters \u201d\r\nand \u201d stand on 1 positions and characters \u201d and \u201d stand on 2\r\npositions),Its 4-sorting is the string \u201d,Its 5-sorting is the string\r\n\u201d.You are given string of length and operations of this string. Each\r\noperation accepts two integer arguments and and transforms string as\r\nfollows. For each from to in the increasing order we apply the operation\r\nof -sorting to the substring . Here represents a substring that consists\r\nof characters on positions from to inclusive.After each operation you\r\nneed to print string .\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\nint LOG = 0;\npii up[21][1000000];\n\npii get_up(int i, int n) {\n    int l = 0;\n    ford(k, LOG + 1) {\n        if ((1 << k) > n) continue;\n        if (up[k][i].fi == -1) return mp(-1, up[k][i].second + l);\n        n -= (1 << k);\n        l += 1 << k;\n        i = up[k][i].fi;\n    }\n    return mp(i, l);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    string s;\n    cin >> s;\n    int N = s.size();\n    while ((1 << LOG) < N) ++LOG;\n    int T;\n    cin >> T;\n    forn(t, T) {\n        int K, D;\n        cin >> K >> D;\n        int q = -1;\n        for (int k = 0; k < D; ++k) {\n            for (int i = k; i < K; i += D) {\n                up[0][i] = mp(q++, 1);\n            }\n        }\n        for1(k, LOG) forn(i, K) {\n            if (up[k - 1][i].fi == -1) up[k][i] = up[k - 1][i];\n            else {\n                up[k][i] = up[k - 1][up[k - 1][i].fi];\n                up[k][i].se += up[k - 1][i].se;\n            }\n        }\n        string ss(N, '.');\n        forn(i, K) {\n            pii r = get_up(i, N - K + 1);\n            if (r.fi == -1) ss[r.se - 1] = s[i];\n            else ss[N - K + 1 + r.fi] = s[i];\n        }\n        for (int i = K; i < N; ++i) {\n            pii r = get_up(K - 1, N - i);\n            if (r.fi == -1) ss[i - K + r.se] = s[i];\n            else ss[N - K + 1 + r.fi] = s[i];\n        }\n        s = ss;\n//        cout << s << '\\n';\n        printf(\"%s\\n\", s.c_str());\n    }\n                \n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Strange Sorting.json",
    "editorial_link": "https://codeforces.com//blog/entry/14592",
    "editorial": "Note, that -sorting is just a permutation (call it ), because it does\r\nnot depends on characters in string. Look at shuffling operation in\r\ndifferent way: instead of going to the next substring and sort it, we\r\nwill shift string to one character left. It remains to understand that\r\nshift of string the permutation too (call it ). Now its clear, we need\r\nto calculate . And after that shift string for character to the left for\r\nmaking answer to the shuffling operation. Here we use the multiplication\r\nof permutations. Since they are associative, that we can use binary\r\nalgorithm to calculate . Total time complexity is .\r\n"
}