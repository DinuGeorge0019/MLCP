{
    "link": "https://codeforces.com//contest/414/problem/C",
    "problemId": "7958",
    "problem_idx": "C",
    "shortId": "414C",
    "contest_number": "414",
    "problem_submissions": {
        "D": [
            6280858,
            6280337,
            6280214,
            6277452,
            6281468,
            6278870,
            6280873,
            6276141,
            6280994,
            6282343,
            6281729,
            6278507,
            6283035,
            6279945,
            6282736,
            6282676,
            6281489
        ],
        "C": [
            6277588,
            6279411,
            6276895,
            6277328,
            6280737,
            6277280,
            6281276,
            6277935,
            6281181,
            6277366,
            6279038,
            6277230,
            6283028,
            6279514,
            6282968,
            6280049,
            6278467,
            6279593
        ],
        "B": [
            6274271,
            6272525,
            6274152,
            6274024,
            6273769,
            6273466,
            6273735,
            6274465,
            6277446,
            6272443,
            6274075,
            6274094,
            6274028,
            6273244,
            6273032,
            6273491,
            6273690,
            6273419
        ],
        "A": [
            6272689,
            6271872,
            6273297,
            6273349,
            6273033,
            6272772,
            6272076,
            6273686,
            6278378,
            6271786,
            6272244,
            6273646,
            6273040,
            6272099,
            6272030,
            6272106,
            6272639,
            6272717
        ],
        "E": [
            6287011,
            6619052
        ]
    },
    "name": "C. Mashmokh and Reverse Operation",
    "statement": "You have an array of length and queries on it. The -th query is\r\ndescribed by an integer . In order to perform the -th query you must:\r\nsplit the array into parts, where each part is a subarray consisting of\r\nnumbers; the -th subarray should contain the elements ; reverse each of\r\nthe subarrays; join them into a single array in the same order (this\r\narray becomes new array ); output the number of inversions in the new .\r\nGiven initial array and all the queries. Answer all the queries. Please,\r\nnote that the changes from some query is saved for further queries.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define forint(i, a, b) for(int i=(int)(a); i<=(int)(b); ++i)\n#define forintdown(i, a, b) for(int i=(int)(a); i>=(int)(b); --i)\n#define forn(i, n) forint(i, 0, (n)-1)\n#define forndown(i, n) forintdown(i, (n)-1, 0)\n#define fillchar(a, x) memset(a, x, sizeof(a))\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPI;\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n\nconst int MAXNP=22;\nconst int MAXN=(1<<20)+10;\n\nLL c1[MAXNP], c2[MAXNP];\nint a[MAXN];\nint n, np;\n\nVI cal(int lev, int l, int r) {\n\tif(lev==0) {\n\t\tVI v; v.PB(a[l]);\n\t\treturn v;\n\t}\n\tint m=(l+r)/2;\n\tVI x=cal(lev-1, l, m);\n\tVI y=cal(lev-1, m+1, r);\n\tVI z;\n\tsize_t i=0, j=0;\n\twhile(i<x.size() && j<y.size()) {\n\t\tint tx=0, ty=0;\n\t\tint cur=min(x[i], y[j]);\n\t\twhile(i<x.size() && x[i]==cur) ++i, ++tx;\n\t\twhile(j<y.size() && y[j]==cur) ++j, ++ty;\n\t\tc1[lev]+=LL(ty)*LL(x.size()-i);\n\t\tc2[lev]+=LL(tx)*LL(y.size()-j);\n\t\tforn(k, tx+ty) z.PB(cur);\n\t}\n\twhile(i<x.size()) z.PB(x[i++]);\n\twhile(j<y.size()) z.PB(y[j++]);\n\treturn z;\n}\n\nint main() {\n\tscanf(\"%d\", &np); n=1<<np;\n\tforint(i, 1, n) scanf(\"%d\", a+i);\n\tfillchar(c1, 0);\n\tfillchar(c2, 0);\n\tcal(np, 1, n);\n\tint q; scanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint k; scanf(\"%d\", &k);\n\t\tforint(i, 0, k) swap(c1[i], c2[i]);\n\t\tLL ans=0;\n\t\tforint(i, 0, np) ans+=c1[i];\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Mashmokh and Reverse Operation.json",
    "editorial_link": "https://codeforces.com//blog/entry/11470",
    "editorial": "Build a complete binary tree with height . So its -th leaf corresponds\r\nto -th element of the initial array. For each vertex lets define its\r\nsubarray as the subarray containing the elements that have a leaf\r\ncorresponding to them in subtree rooted at . For each non-leaf vertex ,\r\nsuppose its left child\u00e2\u0080\u0099s subarray contains elements of the array and its\r\nright child contains elements of the array. We\u00e2\u0080\u0099ll calculate two numbers\r\nfor this vertex. number of pairs that and number of pairs that . We\u00e2\u0080\u0099ll\r\ncall the first calculated number, normal number and the other one\r\nreverse number. Calculating these numbers can be done using merge-sort\r\nalgorithm in . We\u00e2\u0080\u0099ll Initially write normal number for each vertex on\r\nit. We\u00e2\u0080\u0099ll define a vertex\u00e2\u0080\u0099s type as type of the number that is written\r\non them. Let\u00e2\u0080\u0099s define height of a vertex equal to its distnace to the\r\nnearest leaf. Also let\u00e2\u0080\u0099s define switching a vertex as switching the\r\nnumber written on it with the other type number(if normal number is\r\nwritten on it change it to reverse number and vise-versa). Initially sum\r\nof writed numbers is equal to number of inversions in the initial array.\r\nNow when query is given, by switching all vertices with height at most ,\r\nthe sum of writed numbers will become equal to the number of inversions\r\nin the new array. The only question is how to perform such query fast?\r\nOne can notice that in a height , always all of the vertices has the\r\nsame type. So we can calculate two numbers for each height . The sum of\r\nnormal numbers of vertices with height and the sum of their reverse\r\nnumbers. Then instead of switching vertices in a height one by one each\r\ntime, one can just switch the number for that height. The sum of numbers\r\nof heights after each query will be the answer for that query. since\r\nthere are height each query can be performed in so the total running\r\ntime will be .\r\n"
}