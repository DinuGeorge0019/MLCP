{"link": "https://codeforces.com//contest/1007/problem/E", "problemId": "197249", "problem_idx": "E", "shortId": "1007E", "contest_number": "1007", "problem_submissions": {"C": [40289014, 40311007, 40303376, 40289853, 40282836, 40298460, 40292416, 40291392, 40315809, 40295182, 43029830], "B": [40273384, 40274250, 40291551, 40287008, 40280350, 40301243, 40277597, 40277856, 40278440, 40276236, 40280080, 40280290, 40278003, 40280632, 40280737, 40278002], "A": [40264928, 40264790, 40264714, 40264612, 40266456, 40265453, 40267936, 40264621, 40264617, 40264727, 40264905, 40264738, 40265555, 40264686, 40264608, 40264865, 40264835, 40265293], "D": [40284510, 40287759, 40291268, 62534541, 40294556, 40301360], "E": [54819990, 54819956, 47314793]}, "name": "E. Mini Metro", "statement": "In a simplified version of a \"Mini Metro\" game, there is only one subway\r\nline, and all the trains go in the same direction. There are n stations\r\non the line, a_i people are waiting for the train at the i-th station at\r\nthe beginning of the game. The game starts at the beginning of the 0-th\r\nhour. At the end of each hour (couple minutes before the end of the\r\nhour), b_i people instantly arrive to the i-th station. If at some\r\nmoment, the number of people at the i-th station is larger than c_i, you\r\nlose.A player has several trains which he can appoint to some hours. The\r\ncapacity of each train is k passengers. In the middle of the appointed\r\nhour, the train goes from the 1-st to the n-th station, taking as many\r\npeople at each station as it can accommodate. A train can not take\r\npeople from the i-th station if there are people at the i-1-th\r\nstation.If multiple trains are appointed to the same hour, their\r\ncapacities are being added up and they are moving together.The player\r\nwants to stay in the game for t hours. Determine the minimum number of\r\ntrains he will need for it.\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 205;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nll d[MX][MX][2], g[MX][MX][2];\nll a[MX], b[MX], c[MX];\nll sa[MX], sb[MX];\nll n,t,k; \n\nll cdiv(ll a, ll b) {\n    return (a+b-1)/b;\n}\n\nint main() {\n\tre(n,t,k);\n\tFOR(i,1,n+1) re(a[i],b[i],c[i]);\n\ta[n+1] = c[n+1] = 1e18;\n\tFOR(i,1,n+2) {\n\t    sa[i] = sa[i-1]+a[i];\n\t    sb[i] = sb[i-1]+b[i];\n\t}\n\tFOR(p,1,n+2) F0R(s,t+1) F0R(z,2) {\n\t    d[p][s][z] = g[p][s][z] = INF;\n\t    if (s*b[p]+z*a[p] <= c[p] && d[p-1][s][z] != INF) {\n\t        d[p][s][z] = d[p-1][s][z];\n\t        ll val = cdiv(z*sa[p-1]+s*sb[p-1],k);\n\t        if (val*k <= z*sa[p]+s*sb[p]) g[p][s][z] = val;\n\t    }\n\t    F0R(r,s) if (g[p][r][z] != INF) {\n\t        ll m = z*sa[p]+r*sb[p]-k*g[p][r][z];\n\t        ll x = cdiv(max(m+(s-r)*b[p]-c[p],0LL),k); \n\t        // ps(\"WAT\",p,s,z,r,m,x); \n\t        if (x*k <= m && d[p-1][s-r][0] != INF) {\n    \t        ckmin(d[p][s][z],g[p][r][z]+x+d[p-1][s-r][0]);\n    \t        ll val = cdiv((s-r)*sb[p-1],k);\n    \t        if (val*k <= (s-r)*sb[p]+m-x*k) \n    \t            ckmin(g[p][s][z],g[p][r][z]+x+val);\n\t        }\n\t    }\n\t    // ps(\"??\",p,s,z,d[p][s][z],g[p][s][z]);\n\t}\n\tps(d[n+1][t][1]);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"], "input": "", "output": "", "tags": ["dp"], "dificulty": "3400", "interactive": false}