{
    "link": "https://codeforces.com//contest/187/problem/E",
    "problemId": "1325",
    "problem_idx": "E",
    "shortId": "187E",
    "contest_number": "187",
    "problem_submissions": {
        "B": [
            1679215,
            1673469,
            1673732,
            1673153,
            1675030,
            1674956,
            1675111,
            1673806,
            1679398,
            1676105,
            1674092,
            1674719,
            1674215,
            1676107,
            1674271,
            1673982,
            1674600,
            1674313,
            1673997,
            1674141
        ],
        "E": [
            1678609,
            1679989
        ],
        "D": [
            1676469,
            1678199,
            1678043,
            2407052,
            1678555,
            1679755,
            1678435,
            1704251,
            1703901,
            1680981,
            1679861,
            1687546,
            1679340
        ],
        "C": [
            1674683,
            1675935,
            1675188,
            1676560,
            1676489,
            1677858,
            1674899,
            1676989,
            1677275,
            1675430,
            1676217,
            1675632,
            1674653,
            1675726,
            1676281,
            1676115,
            1676408,
            1676632,
            1676653
        ],
        "A": [
            1672823,
            1672616,
            1673643,
            1673994,
            1673278,
            1672815,
            1672696,
            1672795,
            1675020,
            1673285,
            1673012,
            1672803,
            1672821,
            1672657,
            1672773,
            1673154,
            1672871,
            1672576,
            1672702
        ]
    },
    "name": "E. Heaven Tour",
    "statement": "The story was not finished as PMP thought. God offered him one more\r\nchance to reincarnate and come back to life. But before he can come\r\nback, God told him that PMP should ask great men including prominent\r\nprogrammers about their life experiences.The men are standing on a\r\nstraight line. They are numbered through from left to right. The\r\ncoordinate of the -th man is . PMP should visit all these people one by\r\none in arbitrary order. Each men should be visited . At the beginning of\r\nhis tour, he starts at location of -th man and asks him about his\r\nexperiences.Each time PMP wants to change his location, he should give a\r\nticket to an angel and the angel carries him to his destination. Angels\r\ntake PMP from one location, fly to his destination and put him down\r\nthere. Nobody else is visited in this movement. Moving from -th man to\r\n-th man, takes time. PMP can get back to life as soon as he visits all\r\nmen.There are two types of angels: Some angels are going to the right\r\nand they only accept right tickets. Others are going the left and they\r\nonly accept left tickets. There are an unlimited number of angels of\r\neach type. PMP has left tickets and right tickets.PMP wants to get back\r\nto life as soon as possible to be able to compete in this yearâ€™s final\r\ninstead of the final he missed last year. He wants to know the quickest\r\nway to visit all the men exactly once. He also needs to know the exact\r\nsequence moves he should make.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<string>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,lt,rt,s;\nint di[101000];\nint dd[101000];\nconst long long INF=10000000000000000ll;\nlong long ans=INF;\nint aid[101000];\nint tid[101000],tt;\nbool flag;\nbool ansf;\nlong long ta;\ninline void cl(){tt=0;}\ninline void pp(int x){tid[tt++]=x;}\ninline void tr(){\n    //for(int i=0;i<tt;i++)printf(\"%d \",tid[i]);\n   // puts(\"\");\n    if(ta<ans){\n        ans=ta;\n        ansf=flag;\n        for(int i=0;i<n-1;i++)aid[i]=tid[i];\n    }\n}\npair<int,int> ev[101000];\nint to[101000];\nbool rev[101000];\ninline void trylr(){\n    if(s==n-1)return;\n    if(rt==0)return;\n    int i,j;\n    if(lt==0){\n        if(s!=0)return;\n        cl();\n        for(i=1;i<n;i++)pp(i);\n        ta=(long long)di[n-1]-di[0];\n        tr();\n        return;\n    }\n    if(lt<=s){\n        //puts(\"Case 1\");\n        cl();\n        for(i=lt-1;i>=0;i--)pp(i);\n        for(i=lt;i<s;i++)pp(i);\n        for(i=s+1;i<n;i++)pp(i);\n        ta=(long long)di[n-1]-di[0]+(long long)di[s]-di[0];\n        tr();\n        return;\n    }else if(rt==1){\n        cl();\n        for(i=s-1;i>=0;i--)pp(i);\n        for(i=n-1;i>s;i--)pp(i);\n        ta=(long long)di[s]-di[0]+(long long)di[n-1]-di[0]+(long long)di[n-1]-di[s+1];\n        tr();\n        return;\n    }else{\n        int mo=lt-s;\n        int evc=0;\n        for(i=s+1;i<n-1;i++){\n            ev[evc++]=make_pair(dd[i],i);\n        }\n        sort(ev,ev+evc);\n        for(i=0;i<evc;i++)to[ev[i].second]=i;\n        long long ss=0;\n        int bi=-1;\n        long long ba=INF;\n        set<int> XD;\n        set<int>::iterator pt;\n        for(i=s+1;i<n-mo-1;i++){\n            XD.insert(to[i]);\n        }\n        for(i=n-mo-1;i<n;i++){\n            //printf(\"i=%d ss=%I64d\\n\",i,ss);\n            if(ba>ss*2+di[n-1]-di[i]){\n                ba=ss*2+di[n-1]-di[i];\n                bi=i;\n            }\n            int toa=i-1;\n            if(i==n-mo-1){\n                XD.insert(to[toa]);\n                pt=XD.begin();\n                ss+=ev[*pt].first;\n            }else{\n                if(to[toa]<*pt){\n                    ss+=ev[to[toa]].first;\n                }else{\n                    XD.insert(to[toa]);\n                    pt++;\n                    ss+=ev[*pt].first;\n                }\n            }\n        }\n        //printf(\"ba=%I64d bi=%d\\n\",ba,bi);\n        ta=(long long)di[s]-di[0]+(long long)di[n-1]-di[0]+ba;\n        cl();\n        for(i=s-1;i>=0;i--)pp(i);\n        memset(rev,0,sizeof(rev));\n        XD.clear();\n        for(i=s+1;i<n-mo-1;i++){\n            XD.insert(to[i]);\n        }\n        for(i=n-mo;i<=bi;i++){\n            int toa=i-1;\n            if(i==n-mo){\n                XD.insert(to[toa]);\n                pt=XD.begin();\n                rev[ev[*pt].second]=1;\n            }else{\n                if(to[toa]<*pt){\n                    rev[toa]=1;\n                }else{\n                    XD.insert(to[toa]);\n                    pt++;\n                    rev[ev[*pt].second]=1;\n                }\n            }\n        }\n        for(i=s+1;i<bi;i=j+1){\n            for(j=i;j<bi-1&&rev[j];j++);\n            for(int q=j;q>=i;q--)pp(q);\n        }\n        for(i=n-1;i>=bi;i--){\n            pp(i);\n        }\n        tr();\n    }\n}\ninline void tryrl(){\n    //puts(\"tryrl\");\n    swap(lt,rt);\n    s=n-1-s;\n    int i,j;\n    int l=di[n-1];\n    for(i=0;i<n;i++){\n        di[i]=l-di[i];\n    }\n    for(i=0,j=n-1;i<j;i++,j--)swap(di[i],di[j]);\n    for(i=0;i<n-1;i++)dd[i]=di[i+1]-di[i];\n    flag=1;\n    trylr();\n}\nint main(){\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&lt,&s);\n    rt=n-1-lt;\n    s--;\n    for(i=0;i<n;i++)scanf(\"%d\",&di[i]);\n    for(i=0;i<n-1;i++)dd[i]=di[i+1]-di[i];\n    flag=0;\n    trylr();\n    tryrl();\n    if(ans==INF)puts(\"-1\");\n    else{\n        printf(\"%I64d\\n\",ans);\n        for(i=0;i<n-1;i++)printf(\"%d%c\",ansf?n-aid[i]:aid[i]+1,(i==n-2?'\\n':' '));\n    }\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Heaven Tour.json",
    "editorial_link": "https://codeforces.com/blog/entry/4540",
    "editorial": "Step 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.\n\nObviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times.\n\nProof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times:\n\nOnce for you should go after i be in a position to come back.\nOnce for you use a left ticked to come back to i\nAnd once again you should go after i, because you want to finish at man number n\nNote that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).\n\nStep 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.\n\nTo solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.\n\nSo the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).\n\nStep 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.\n\nAssume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.\n\nSo the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.\n\nThere are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
    "hint": []
}