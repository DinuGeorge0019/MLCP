{"link": "https://codeforces.com//contest/187/problem/E", "problemId": "1325", "problem_idx": "E", "shortId": "187E", "contest_number": "187", "problem_submissions": {"B": [1679215, 1673469, 1673732, 1673153, 1675030, 1674956, 1675111, 1673806, 1679398, 1676105, 1674092, 1674719, 1674215, 1676107, 1674271, 1673982, 1674600, 1674313, 1673997, 1674141], "E": [1678609, 1679989], "D": [1676469, 1678199, 1678043, 2407052, 1678555, 1679755, 1678435, 1704251, 1703901, 1680981, 1679861, 1687546, 1679340], "C": [1674683, 1675935, 1675188, 1676560, 1676489, 1677858, 1674899, 1676989, 1677275, 1675430, 1676217, 1675632, 1674653, 1675726, 1676281, 1676115, 1676408, 1676632, 1676653], "A": [1672823, 1672616, 1673643, 1673994, 1673278, 1672815, 1672696, 1672795, 1675020, 1673285, 1673012, 1672803, 1672821, 1672657, 1672773, 1673154, 1672871, 1672576, 1672702]}, "name": "E. Heaven Tour", "statement": "The story was not finished as PMP thought. God offered him one more\r\nchance to reincarnate and come back to life. But before he can come\r\nback, God told him that PMP should ask great men including prominent\r\nprogrammers about their life experiences.The men are standing on a\r\nstraight line. They are numbered through from left to right. The\r\ncoordinate of the -th man is . PMP should visit all these people one by\r\none in arbitrary order. Each men should be visited . At the beginning of\r\nhis tour, he starts at location of -th man and asks him about his\r\nexperiences.Each time PMP wants to change his location, he should give a\r\nticket to an angel and the angel carries him to his destination. Angels\r\ntake PMP from one location, fly to his destination and put him down\r\nthere. Nobody else is visited in this movement. Moving from -th man to\r\n-th man, takes time. PMP can get back to life as soon as he visits all\r\nmen.There are two types of angels: Some angels are going to the right\r\nand they only accept right tickets. Others are going the left and they\r\nonly accept left tickets. There are an unlimited number of angels of\r\neach type. PMP has left tickets and right tickets.PMP wants to get back\r\nto life as soon as possible to be able to compete in this year\u2019s final\r\ninstead of the final he missed last year. He wants to know the quickest\r\nway to visit all the men exactly once. He also needs to know the exact\r\nsequence moves he should make.\r\n", "solutions": ["#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<string>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,lt,rt,s;\nint di[101000];\nint dd[101000];\nconst long long INF=10000000000000000ll;\nlong long ans=INF;\nint aid[101000];\nint tid[101000],tt;\nbool flag;\nbool ansf;\nlong long ta;\ninline void cl(){tt=0;}\ninline void pp(int x){tid[tt++]=x;}\ninline void tr(){\n    //for(int i=0;i<tt;i++)printf(\"%d \",tid[i]);\n   // puts(\"\");\n    if(ta<ans){\n        ans=ta;\n        ansf=flag;\n        for(int i=0;i<n-1;i++)aid[i]=tid[i];\n    }\n}\npair<int,int> ev[101000];\nint to[101000];\nbool rev[101000];\ninline void trylr(){\n    if(s==n-1)return;\n    if(rt==0)return;\n    int i,j;\n    if(lt==0){\n        if(s!=0)return;\n        cl();\n        for(i=1;i<n;i++)pp(i);\n        ta=(long long)di[n-1]-di[0];\n        tr();\n        return;\n    }\n    if(lt<=s){\n        //puts(\"Case 1\");\n        cl();\n        for(i=lt-1;i>=0;i--)pp(i);\n        for(i=lt;i<s;i++)pp(i);\n        for(i=s+1;i<n;i++)pp(i);\n        ta=(long long)di[n-1]-di[0]+(long long)di[s]-di[0];\n        tr();\n        return;\n    }else if(rt==1){\n        cl();\n        for(i=s-1;i>=0;i--)pp(i);\n        for(i=n-1;i>s;i--)pp(i);\n        ta=(long long)di[s]-di[0]+(long long)di[n-1]-di[0]+(long long)di[n-1]-di[s+1];\n        tr();\n        return;\n    }else{\n        int mo=lt-s;\n        int evc=0;\n        for(i=s+1;i<n-1;i++){\n            ev[evc++]=make_pair(dd[i],i);\n        }\n        sort(ev,ev+evc);\n        for(i=0;i<evc;i++)to[ev[i].second]=i;\n        long long ss=0;\n        int bi=-1;\n        long long ba=INF;\n        set<int> XD;\n        set<int>::iterator pt;\n        for(i=s+1;i<n-mo-1;i++){\n            XD.insert(to[i]);\n        }\n        for(i=n-mo-1;i<n;i++){\n            //printf(\"i=%d ss=%I64d\\n\",i,ss);\n            if(ba>ss*2+di[n-1]-di[i]){\n                ba=ss*2+di[n-1]-di[i];\n                bi=i;\n            }\n            int toa=i-1;\n            if(i==n-mo-1){\n                XD.insert(to[toa]);\n                pt=XD.begin();\n                ss+=ev[*pt].first;\n            }else{\n                if(to[toa]<*pt){\n                    ss+=ev[to[toa]].first;\n                }else{\n                    XD.insert(to[toa]);\n                    pt++;\n                    ss+=ev[*pt].first;\n                }\n            }\n        }\n        //printf(\"ba=%I64d bi=%d\\n\",ba,bi);\n        ta=(long long)di[s]-di[0]+(long long)di[n-1]-di[0]+ba;\n        cl();\n        for(i=s-1;i>=0;i--)pp(i);\n        memset(rev,0,sizeof(rev));\n        XD.clear();\n        for(i=s+1;i<n-mo-1;i++){\n            XD.insert(to[i]);\n        }\n        for(i=n-mo;i<=bi;i++){\n            int toa=i-1;\n            if(i==n-mo){\n                XD.insert(to[toa]);\n                pt=XD.begin();\n                rev[ev[*pt].second]=1;\n            }else{\n                if(to[toa]<*pt){\n                    rev[toa]=1;\n                }else{\n                    XD.insert(to[toa]);\n                    pt++;\n                    rev[ev[*pt].second]=1;\n                }\n            }\n        }\n        for(i=s+1;i<bi;i=j+1){\n            for(j=i;j<bi-1&&rev[j];j++);\n            for(int q=j;q>=i;q--)pp(q);\n        }\n        for(i=n-1;i>=bi;i--){\n            pp(i);\n        }\n        tr();\n    }\n}\ninline void tryrl(){\n    //puts(\"tryrl\");\n    swap(lt,rt);\n    s=n-1-s;\n    int i,j;\n    int l=di[n-1];\n    for(i=0;i<n;i++){\n        di[i]=l-di[i];\n    }\n    for(i=0,j=n-1;i<j;i++,j--)swap(di[i],di[j]);\n    for(i=0;i<n-1;i++)dd[i]=di[i+1]-di[i];\n    flag=1;\n    trylr();\n}\nint main(){\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&lt,&s);\n    rt=n-1-lt;\n    s--;\n    for(i=0;i<n;i++)scanf(\"%d\",&di[i]);\n    for(i=0;i<n-1;i++)dd[i]=di[i+1]-di[i];\n    flag=0;\n    trylr();\n    tryrl();\n    if(ans==INF)puts(\"-1\");\n    else{\n        printf(\"%I64d\\n\",ans);\n        for(i=0;i<n-1;i++)printf(\"%d%c\",ansf?n-aid[i]:aid[i]+1,(i==n-2?'\\n':' '));\n    }\n}\n\n"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "2900", "interactive": false}