{
    "link": "https://codeforces.com//contest/1268/problem/C",
    "problemId": "499894",
    "problem_idx": "C",
    "shortId": "1268C",
    "contest_number": "1268",
    "problem_submissions": {
        "E": [
            67361424,
            67355016,
            67380799,
            67371033,
            67446934,
            67376813,
            68023098,
            68022997
        ],
        "D": [
            67348266,
            67347319,
            67365084,
            67357673,
            67360949,
            67364747,
            67359296,
            67368756,
            67411806,
            68016271
        ],
        "C": [
            67338375,
            67339405,
            67344042,
            67338561,
            67344169,
            67346111,
            67349295,
            67348401,
            67341037,
            67348166,
            67347179,
            67340159,
            67353050,
            67348258,
            67346505,
            67347427,
            67342845,
            67349401,
            67353151,
            67341052
        ],
        "B": [
            67331667,
            67334127,
            67337536,
            67334592,
            67334504,
            67337007,
            67342216,
            67338670,
            67336021,
            67336364,
            67336274,
            67334552,
            67335765,
            67336571,
            67336933,
            67336456,
            67331340,
            67342411,
            67336844,
            67347736
        ],
        "A": [
            67329853,
            67333177,
            67334199,
            67331820,
            67331197,
            67332489,
            67334260,
            67332404,
            67331188,
            67334825,
            67333497,
            67332015,
            67333739,
            67334436,
            67335762,
            67333434,
            67335595,
            67333162,
            67332954,
            67335847
        ]
    },
    "name": "C. K Integers",
    "statement": "You are given a permutation p_1, p_2,\r\nldots, p_n.In one move you can swap two adjacent values.You want to\r\nperform a minimum number of moves, such that in the end there will exist\r\na subsegment 1,2,\r\nldots, k, in other words in the end there should be an integer i, 1\r\nleq i\r\nleq n-k+1 such that p_i = 1, p_{i+1} = 2,\r\nldots, p_{i+k-1}=k.Let f(k) be the minimum number of moves that you need\r\nto make a subsegment with values 1,2,\r\nldots,k appear in the permutation.You need to find f(1), f(2),\r\nldots, f(n).\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 21.12.2019 14:12:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nclass segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    long long L = 0;\n    long long R = 0;\n    int alive = 1;\n    int addL = 0;\n    int addR = 0;\n\n    void apply(int l, int r) {\n      alive = 0;\n      L = R = 0;\n      addL = addR = 0;\n    }\n\n    void apply(int l, int r, int v, char c) {\n      if (c == 'L') {\n        L += (long long) alive * v;\n        addL += v;\n      }\n      if (c == 'R') {\n        R += (long long) alive * v;\n        addR += v;\n      }\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.L = a.L + b.L;\n    res.R = a.R + b.R;\n    res.alive = a.alive + b.alive;\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].addL != 0) {\n      tree[x + 1].apply(l, y, tree[x].addL, 'L');\n      tree[z].apply(y + 1, r, tree[x].addL, 'L');\n      tree[x].addL = 0;\n    }\n    if (tree[x].addR != 0) {\n      tree[x + 1].apply(l, y, tree[x].addR, 'R');\n      tree[z].apply(y + 1, r, tree[x].addR, 'R');\n      tree[x].addR = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n  }\n  vector<int> pos(n);\n  for (int i = 0; i < n; i++) {\n    pos[p[i]] = i;\n  }\n  fenwick<int> fenw(n);\n  vector<long long> res(n);\n  long long inv = 0;\n  segtree st(n);\n  for (int it = 0; it < n; it++) {\n    int at = pos[it];\n    inv += fenw.get(n - 1) - fenw.get(at);\n    fenw.modify(at, +1);\n    if (at > 0) {\n      st.modify(0, at - 1, 1, 'R');\n    }\n    if (at < n - 1) {\n      st.modify(at + 1, n - 1, 1, 'L');\n    }\n    st.modify(at, at);\n    int med = -1;\n    {\n      int low = 0, high = n - 1;\n      while (low < high) {\n        int mid = (low + high) >> 1;\n        int s = fenw.get(mid);\n        if (s >= it / 2 + 1) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      med = low;\n    }\n    res[it] = inv;\n    if (med > 0) {\n      res[it] += st.get(0, med - 1).L;\n    }\n    if (med < n - 1) {\n      res[it] += st.get(med + 1, n - 1).R;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << res[i];\n  }\n  cout << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. K Integers.json",
    "editorial_link": "https://codeforces.com//blog/entry/72358",
    "editorial": "At first, let's add to the answer number of inversions among numbers 1,2,\u0085,k\n.\n\nAfter that, let's say that x?k\n is one, and x>k\n is zero.\n\nThen you need to calculate the smallest number of swaps to make segment 1,1,\u0085,1\n of length k\n appear in the permutation.\n\nFor this, let's call pi\n the number of ones on the prefix.\n\nFor all si=0\n we need to add min(pi,k?pi)\n to the answer (it is an obvious lower bound, and it is simple to prove that we always can do one operation to reduce this total value by one).\n\nHow to calculate this for each k\n?\n\nLet's move k\n from 1\n to n\n. You can maintain number of inversions with BIT. To calculate the second value, you can note that you just need to find k2\n-th number ?k\n and add values at the left and add the right with different coefficients. To maintain them, you can recalculate everything when you are moving the median (in heap). But also it is possible to maintain the segment tree by pi\n and just take some sum."
}