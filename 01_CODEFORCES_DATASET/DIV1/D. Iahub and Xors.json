{
    "link": "https://codeforces.com//contest/341/problem/D",
    "problemId": "3425",
    "problem_idx": "D",
    "shortId": "341D",
    "contest_number": "341",
    "problem_submissions": {
        "D": [
            4376750,
            4378780,
            4376395,
            4376720,
            4378230,
            4379371,
            4379846,
            4378978,
            4379778,
            4378578,
            4381466,
            4381249,
            4379639,
            4434623,
            4381692,
            4380681,
            4380927,
            4380941,
            4449185,
            4374777
        ],
        "C": [
            4375168,
            4374068,
            4379294,
            4375659,
            4375652,
            4375871,
            4375036,
            4378006,
            4374746,
            4375347,
            4374858,
            4376054,
            4375611,
            4377642,
            4376535,
            4378502,
            4380054,
            4385371
        ],
        "B": [
            4372755,
            4372469,
            4374229,
            4375035,
            4374390,
            4374268,
            4379570,
            4373332,
            4379590,
            4372609,
            4373078,
            4372906,
            4373853,
            4373520,
            4374372,
            4374299,
            4376277,
            4376672
        ],
        "A": [
            4372149,
            4371769,
            4372926,
            4372916,
            4383777,
            4373604,
            4372813,
            4371963,
            4372756,
            4380996,
            4371671,
            4372384,
            4372154,
            4458518,
            4372373,
            4372183,
            4373535,
            4372955,
            4378126,
            4376128
        ],
        "E": [
            4404432,
            4383929,
            4395989,
            4381763
        ]
    },
    "name": "D. Iahub and Xors",
    "statement": "Iahub does not like background stories, so he’ll tell you exactly what\r\nthis problem asks you for.You are given a matrix with rows and columns.\r\nInitially, all values of the matrix are zeros. Both rows and columns are\r\n1-based, that is rows are numbered 1, 2, ..., and columns are numbered\r\n1, 2, ..., . Let’s denote an element on the -th row and -th column as\r\n.We will call a submatrix such elements for which two inequalities hold:\r\n, .Write a program to perform two following operations: Query(, , , ):\r\nprint the xor sum of the elements of the submatrix . Update(, , , , ):\r\neach element from submatrix gets xor-ed by value .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nclass fenv_tree_2d {\n  inline static int f(int x) { return x & -x; }\n  vector<vector<ll> > tr;\n\n  public:\n  fenv_tree_2d(int n = 0) : tr(n + 1, vector<ll>(n + 1, 0)) {}\n  void update(int x0, int y0, ll v) {\n    for (int y = y0 + 1; y < sz(tr); y += f(y))\n    for (int x = x0 + 1; x < sz(tr[y]); x += f(x))\n      tr[y][x] ^= v;\n  }\n  ll get(int x0, int y0) {\n    ll res = 0;\n    for (int y = y0 + 1; y > 0; y -= f(y))\n    for (int x = x0 + 1; x > 0; x -= f(x))\n      res ^= tr[y][x];\n    return res;\n  }\n};\n\nclass Solver {\n  fenv_tree_2d trs[2][2];\n  int n, n2;\n\n  public:\n  Solver(int n) : n(n), n2((n + 1) / 2) {\n    for (int a = 0; a < 2; a++)\n    for (int b = 0; b < 2; b++)\n      trs[a][b] = fenv_tree_2d(n2);\n  }\n  void update(int x, int y, ll v) {\n    trs[x & 1][y & 1].update(x >> 1, y >> 1, v);\n  }\n  ll get(int x, int y) {\n    return trs[x & 1][y & 1].get(x >> 1, y >> 1);\n  }\n};\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) >= 1) {\n    Solver tr(n);\n    while (m --> 0) {\n      int ty;\n      int x1, y1, x2, y2;\n      scanf(\"%d\", &ty);\n      scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n      x1--, y1--, x2--, y2--;\n\n      if (ty == 1) {\n        // query\n        ll ans = tr.get(x2, y2);\n        if (x1) ans ^= tr.get(x1 - 1, y2);\n        if (y1) ans ^= tr.get(x2, y1 - 1);\n        if (x1 && y1) ans ^= tr.get(x1 - 1, y1 - 1);\n        printf(\"%I64d\\n\", ans);\n      } else {\n        // change\n        assert(ty == 2);\n        ll val;\n        scanf(\"%I64d\", &val);\n        tr.update(x1, y1, val);\n        if (x2 < n) tr.update(x2 + 1, y1, val);\n        if (y2 < n) tr.update(x1, y2 + 1, val);\n        if (x2 < n && y2 < n) tr.update(x2 + 1, y2 + 1, val);\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Iahub and Xors.json",
    "editorial_link": "https://codeforces.com/blog/entry/8755",
    "editorial": "The motivation of the problem is that x ^ x = 0. x ^ x ^ x ^ x (even\r\ntimes) = 0 Update per range, query per element When dealing with\r\ncomplicated problems, itâs sometimes a good idea to try solving easier\r\nversions of them. Suppose you can query only one element each time (x0 =\r\nx1, y0 = y1). To update a submatrix (x0, y0, x1, y1), I ll do following\r\noperations. A[x0][y0] ^= val. A[x0][y1 + 1] ^= val. A[x1 + 1][y0] ^=\r\nval. A[x1 + 1][y1 + 1] ^= val. To query about an element (X, Y), that\r\nelement s value will be the xor sum of submatrix A(1, 1, X, Y). Let s\r\ntake an example. I have a 6x6 matrix and I want to xor all elements from\r\nsubmatrix (2, 2, 3, 4) with a value. The below image should be\r\nexplanatory how the method works: Next, by (1, 1, X, Y) I ll denote xor\r\nsum for this submatrix. White cells are not influenced by (2, 2, 3, 4)\r\nmatrix, as matrix (1, 1, X, Y) with (X, Y) a white cell will never\r\nintersect it. Red cells are from the submatrix, the ones that need to be\r\nxor-ed. Note that for a red cell, (1, 1, X, Y) will contain the value we\r\nneed to xor (as it will contain (2, 2)). Next, blue cells. For this ones\r\n(1, 1, X, Y) will contain the value we xor with, despite they shouldn t\r\nhave it. This is why both (2, 5) and (4, 2) will be xor-ed again by that\r\nvalue, to cancel the xor of (2, 2). Now it s okay, every blue cell do\r\nnot contain the xor value in their (1, 1, X, Y). Finally, the green\r\ncells. These ones are intersection between the 2 blue rectangles. This\r\nmeans, in their (1, 1, X, Y) the value we xor with appears 3 times (this\r\nmeans it is contained 1 time). For cancel this, we xor (4, 5) with the\r\nvalue. Now for every green cell (1, 1, X, Y) contains 4 equal values,\r\nwhich cancel each other. You need a data structure do to the following 2\r\noperations: Both operations can be supported by a Fenwick tree 2D. If\r\nyou donât know this data structure, learn it and come back to this\r\nproblem after you do this. Coming back to our problem Now, instead of\r\nfinding an element, I want xor sum of a submatrix. You can note that xor\r\nsum of (x0, y0, x1, y1) is (1, 1, x1, y1) ^ (1, 1, x0 1, y1) ^ (1, 1,\r\nx1, y0 1) ^ (1, 1, x0 1, y0 1). This is a classical problem, the answer\r\nis (1, 1, x1, y1) from which I exclude what is not in the matrix: (1, 1,\r\nx0 1, y1) and (1, 1, x1, y0 1). Right now I excluded (1, 1, x0 1, y0 1)\r\n2 times, so I need to add it one more time. How to get the xor sum of\r\nsubmatrix (1, 1, X, Y)? In brute force approach, I d take all elements\r\n(x, y) with 1 <= x <= X and 1 <= y <= Y and xor their values. Recall the\r\ndefinition of the previous problem, each element (x, y) is the xor sum\r\nof A(1, 1, x, y). So the answer is xor sum of all xor sums of A(1, 1, x,\r\ny), with 1 <= x <= X and 1 <= y <= Y. We can rewrite that long xor sum.\r\nA number A[x][y] appears in exactly (X x + 1) * (Y y + 1) terms of xor\r\nsum. If (X x + 1) * (Y y + 1) is odd, then the value A[x][y] should be\r\nxor-ed to the final result exactly once. If (X x + 1) * (Y y + 1) is\r\neven, it should be ignored. Below, youâll find 4 pictures. They are\r\nmatrixes with X lines and Y columns. Each picture represents a case: (X\r\nodd, Y odd) (X even, Y even) (X even Y odd) (X odd Y even). Can you\r\nobserve a nice pattern? Elements colored represent those for which (X\r\nx + 1) * (Y y + 1) is odd. Yep, thatâs right! There are 4 cases, diving\r\nthe matrix into 4 disjoint areas. When having a query of form (1, 1, X,\r\nY) you only need specific elements sharing same parity with X and Y.\r\nThis method works in O(4 * logN * logN) for each operation and is the\r\nindented solution. We keep 4 Fenwick trees 2D. We made tests such as\r\nsolutions having complexity greater than O(4 * logN * logN) per\r\noperation to fail. Here is our official solution: 4383473\r\n",
    "hint": []
}