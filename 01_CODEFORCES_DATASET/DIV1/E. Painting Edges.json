{"link": "https://codeforces.com//contest/576/problem/E", "problemId": "34887", "problem_idx": "E", "shortId": "576E", "contest_number": "576", "problem_submissions": {"D": [12948640, 12948506, 12948354, 12937171, 12937633, 12940817, 12940388, 12940233, 12940092, 12939430, 12939063, 12935207, 12942962, 12940891, 12941506, 12939643, 12933648, 12943594], "C": [12932865, 12929775, 12930204, 12934079, 12931097, 12934157, 12932646, 12938006, 12960885, 12936499, 12932088, 12931162, 12933248, 12943319, 12926742, 12932751, 12928085, 12932873, 12935950], "B": [12930813, 12932445, 12933792, 12931978, 12932789, 12930228, 12930366, 12941663, 12931673, 12935038, 12935800, 12940912, 12931636, 12948000, 12937985, 12933306, 12935930, 12933037], "A": [12926373, 12925995, 12926783, 12926169, 12926245, 12926309, 12926740, 12939248, 12926537, 12926100, 12927525, 12926051, 12926418, 12928170, 12926649, 12926146, 12926053, 12936482], "E": [12958478, 12974224, 12948989, 13216883, 12944220]}, "name": "E. Painting Edges", "statement": "You are given an undirected graph consisting of vertices and edges. The\r\nvertices are numbered with integers from to , the edges are numbered\r\nwith integers from to . Each edge can be unpainted or be painted in one\r\nof the colors, which are numbered with integers from to . Initially,\r\nnone of the edges is painted in any of the colors.You get queries of the\r\nform \"Repaint edge to color \". At any time the graph formed by the edges\r\nof the same color must be bipartite. If after the repaint this condition\r\nis violated, then the query is considered to be invalid and edge keeps\r\nits color. Otherwise, edge is repainted in color , and the query is\r\nconsidered to valid.Recall that the graph is called if the set of its\r\nvertices can be divided into two parts so that no edge connected\r\nvertices of the same parts.For example, suppose you are given a triangle\r\ngraph, that is a graph with three vertices and edges , and . Suppose\r\nthat the first two edges are painted color , and the third one is\r\npainted color . Then the query of \"repaint the third edge in color \"\r\nwill be incorrect because after its execution the graph formed by the\r\nedges of color will not be bipartite. On the other hand, it is possible\r\nto repaint the second edge in color .You receive queries. For each\r\nquery, you should either apply it, and report that the query is valid,\r\nor report that the query is invalid.\r\n", "solutions": ["#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate<typename TH>\nvoid debug_vars(const char* data, TH head){\n    cerr << data << \"=\" << head << \"\\n\";\n}\n\ntemplate<typename TH, typename... TA>\nvoid debug_vars(const char* data, TH head, TA... tail){\n    while(*data != ',') cerr << *data++;\n    cerr << \"=\" << head << \",\";\n    debug_vars(data+1, tail...);\n}\n\n#ifdef LOCAL\n#define debug(...) debug_vars(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#endif\n\n/////////////////////////////////////////////////////////\n\n\ntemplate<typename T>\nstruct RevertibleVector {\n    vector<T> data;\n    vector<pair<int,T>> changes;\n    int curState;                  // number of operations done\n    \n    RevertibleVector() : curState(0) {}\n    RevertibleVector(int size) : curState(0) {\n        data.resize(size);\n    }\n\n    void resize(int size){\n        data.resize(size);\n    }\n\n    int getState() const {\n        return curState;\n    }\n\n    T get(int pos) const {\n        return data[pos];\n    }\n\n    T operator[](int pos) const {\n        return data[pos];\n    }\n\n    void set(int pos, T value){\n//        debug(\"set\", pos);\n        changes.emplace_back(pos, data[pos]);\n        data[pos] = value;\n        curState++;\n//        debug(curState);\n    }\n\n    void revert(int prevState){\n        for(int nxt = curState-1; nxt >= prevState; nxt--){\n            data[changes[nxt].first] = changes[nxt].second;\n            changes.pop_back();\n        }\n        curState = prevState;\n    }\n};\n\nstruct FUInfo {   // information about find&union vertex\n    int parent;      // parent in tree\n    int treeSize;    // subtree size (up-to-date only for roots)\n    bool invert;     // are vertex and its f&u parent in distinct parts?\n};\n\nstruct RevertibleFindUnionWithParity {\n    RevertibleVector<FUInfo> data;\n\n    RevertibleFindUnionWithParity() {}\n    RevertibleFindUnionWithParity(int N){\n        data.resize(N);\n        for(int i = 0; i < N; i++){\n            data.data[i] = FUInfo{i, 1, false};\n        }\n    }\n\n    // find root set and check if v and the root are in distinct parts\n    pair<int, bool> findSet(int v) const {\n//        dbg();\n        bool curNeg = false;\n        while(v != data[v].parent){\n            curNeg ^= data[v].invert;\n            v = data[v].parent;\n        }\n        return {v, curNeg};\n    }\n\n    // add edge between 'u' and 'v'; returns 'false' if this leads to\n    // contradiction\n    bool unionSets(int u, int v){\n        bool negU, negV;\n        tie(u, negU) = findSet(u);\n        tie(v, negV) = findSet(v);\n\n        if(u == v) return (negU != negV);   // nothing to do\n        if(data[u].treeSize < data[v].treeSize) swap(u,v);  // say 'v' subtree is smaller\n\n        // connect 'v' with 'u'\n        //data[v].parent    = u;\n        //data[u].treeSize += data[v].treeSize;\n        //data[v].invert    = !(negU ^ negV);\n        int vSize = data[v].treeSize, uSize = data[u].treeSize;\n        data.set(v, FUInfo{u, -1, !(negU ^ negV)});\n        data.set(u, FUInfo{u, vSize+uSize, false});\n        return true;\n    }\n\n    int getState() const {\n        return data.getState();\n    }\n\n    void revert(int state){\n//        debug(\"revert\", state);\n        data.revert(state);\n//        dbg();\n    }\n\n    void dbg() const {\n        for(auto P : data.data){\n            printf(\"(%d,%d,%d) \", P.parent, P.treeSize, P.invert);\n        }\n        printf(\"\\n\");\n    }\n};\n\nconst int MaxVerts   = 500005,\n          MaxEdges   = 500005,\n          MaxQueries = 500005,\n          MaxColors  = 52;\n\nint numVerts, numEdges, numQueries, numColors;\nvector<int> edgeFrom, edgeTo;\nvector<int> queryEdge, queryCol;\nvector<int> nextSameEdge;\nvector<RevertibleFindUnionWithParity> FU;\nvector<vector<pair<int,int>>> paintingTree;   // tree containing painting edge actions\nvector<int> curColor;\nint Base;\n\n\nvoid input(){\n    scanf(\"%d%d%d%d\", &numVerts, &numEdges, &numColors, &numQueries);\n    \n    edgeFrom.resize(numEdges);\n    edgeTo.resize(numEdges);\n    for(int edge = 0; edge < numEdges; edge++){\n        scanf(\"%d%d\", &edgeFrom[edge], &edgeTo[edge]);\n        edgeFrom[edge]--;\n        edgeTo[edge]--;\n    }\n\n    queryEdge.resize(numQueries);\n    queryCol.resize(numQueries);\n    for(int query = 0; query < numQueries; query++){\n        scanf(\"%d%d\", &queryEdge[query], &queryCol[query]);\n        queryEdge[query]--;\n        queryCol[query]--;\n    }\n    debug(sizeof(FUInfo));\n\n    FU.resize(numColors, RevertibleFindUnionWithParity(numVerts));\n/*    FU.resize(numColors);\n    for(int i = 0; i < numColors; i++) FU[i].resize(numVerts);*/\n//    debug(1); sleep(10);\n}\n\n// for each edge find its next occurence in queries (or Q if there's no)\nvoid process_queries_by_edges(){\n    vector<int> firstOccur(numEdges, numQueries);\n    nextSameEdge.resize(numQueries);\n\n    for(int query = numQueries-1; query >= 0; query--){\n        int edge = queryEdge[query];\n        nextSameEdge[query] = firstOccur[edge];\n        firstOccur[edge] = query;\n    }\n}\n\n\n// build segment tree with edge-painting queries\nvoid build_tree(){\n    Base = 1;\n    while(Base < numQueries+1) Base *= 2;\n    paintingTree.resize(Base*2);\n}\n\nvoid update_tree(int left, int right, pair<int,int> op){\n    debug(\"update_tree\", left, right, op.first, op.second);\n    if(left > right) return;\n    left += Base; right += Base;\n    paintingTree[left].push_back(op);\n    if(left != right) paintingTree[right].push_back(op);\n\n    while(left/2 != right/2){\n        if(left % 2 == 0) paintingTree[left+1].push_back(op);\n        if(right % 2 == 1) paintingTree[right-1].push_back(op);\n        left /= 2; right /= 2;\n    }\n}\n\nint maxSum;\n\nvoid traverse_tree(int vert, int leftIntv, int rightIntv){\n//    debug(vert, leftIntv, rightIntv);\n    if(leftIntv >= numQueries) return;\n\n    vector<int> lastState(numColors);\n    int sumStates = 0;\n    for(int i = 0; i < numColors; i++){\n        lastState[i] = FU[i].getState();\n        sumStates += lastState[i];\n    }\n    maxSum = max(maxSum, sumStates);\n\n    // process all painting queries\n    for(pair<int,int> query : paintingTree[vert]){\n        int edge  = query.first,\n            color = query.second;\n        assert(FU[color].unionSets(edgeFrom[edge], edgeTo[edge]));\n    }\n\n    // if at leaf, check if adding queried edge ruins everything\n    if(leftIntv == rightIntv){\n        assert(vert >= Base);\n        int edge  = queryEdge[leftIntv],\n            color = queryCol[leftIntv];\n//        bool dbg = (edge == 0 && color == 1);\n\n        auto from = FU[color].findSet(edgeFrom[edge]),\n             to   = FU[color].findSet(edgeTo[edge]);\n\n//        if(dbg){\n//            debug(from.first, from.second, to.first, to.second);\n//        }\n\n        int newColor = curColor[edge];\n\n        // edge connects same sets in same part\n        if(from == to){\n            printf(\"NO\\n\");\n        } else {\n            printf(\"YES\\n\");\n            newColor = color;\n        }\n\n        if(newColor != -1){\n            int intvFrom = leftIntv+1,\n                intvTo   = nextSameEdge[leftIntv]-1;\n            update_tree(intvFrom, intvTo, {queryEdge[leftIntv], newColor});\n        }\n        curColor[edge] = newColor;\n//        debug(edge, curColor[edge]);\n    } else {\n        // else recurse\n        int mid = (leftIntv + rightIntv) / 2;\n        traverse_tree(vert*2, leftIntv, mid);\n        traverse_tree(vert*2+1, mid+1, rightIntv);\n    }\n\n\n    // revert everything\n    for(int i = 0; i < numColors; i++){\n//        debug(i, lastState[i]);\n        FU[i].revert(lastState[i]);\n    }\n\n    // we can clear the node\n    paintingTree[vert].clear();\n}\n\n\nint main(){\n    input();\n    process_queries_by_edges();\n    build_tree();\n    curColor = vector<int>(numEdges, -1);\n\n    traverse_tree(1, 0, Base-1);\n    debug(maxSum);\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures"], "dificulty": "3300", "interactive": false}