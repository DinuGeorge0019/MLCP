{
    "link": "https://codeforces.com//contest/983/problem/C",
    "problemId": "183241",
    "problem_idx": "C",
    "shortId": "983C",
    "contest_number": "983",
    "problem_submissions": {
        "E": [
            38286454,
            38283020,
            38289482,
            38292735,
            38289453,
            38293779,
            38302472,
            38293561,
            38300012,
            38293577,
            38302643,
            38302639,
            38302635,
            38302629,
            38300139,
            38300133,
            38300000,
            38293677,
            38332361,
            38290750,
            38296688,
            38287165,
            38281146,
            38282245,
            38289240,
            38294540,
            38292692
        ],
        "C": [
            38282068,
            38290172,
            38281090,
            38284331,
            38284560,
            38280127,
            38285062,
            38284712,
            38287114,
            38296797,
            38287523,
            38296777,
            38305865,
            38421418,
            38281072,
            38282940
        ],
        "B": [
            38275765,
            38281040,
            38275649,
            38277253,
            38280013,
            38275961,
            38274648,
            38276342,
            38282348,
            38281288,
            38277599,
            38291629,
            38284850,
            38285475,
            38285545,
            38278223,
            38284828,
            38274818,
            38274252
        ],
        "A": [
            38273115,
            38279677,
            38273911,
            38271977,
            38277206,
            38393404,
            38274395,
            38272239,
            38278413,
            38325576,
            38319214,
            38319178,
            38319075,
            38319020,
            38318977,
            38318949,
            38318775,
            38311499,
            38311463,
            38311378,
            38273182,
            38332311,
            38276058,
            38279900,
            38288950,
            38281038,
            38282952,
            38280788,
            38276091,
            38275298,
            38271513,
            38271658
        ],
        "D": [
            38430702,
            38334183,
            38527958
        ]
    },
    "name": "C. Elevator",
    "statement": "You work in a big office. It is a floor building with an elevator that\r\ncan accommodate up to people. It is your responsibility to manage this\r\nelevator.Today you are late, so there are queues on some floors already.\r\nFor each person you know the floor where he currently is and the floor\r\nhe wants to reach. Also, you know the order in which people came to the\r\nelevator.According to the company’s rules, if an employee comes to the\r\nelevator earlier than another one, he has to enter the elevator earlier\r\ntoo (even if these employees stay on different floors). Note that the\r\nemployees are allowed to leave the elevator in arbitrary order.The\r\nelevator has two commands: Go up or down one floor. The movement takes\r\nsecond. Open the doors on the current floor. During this operation all\r\nthe employees who have reached their destination get out of the\r\nelevator. Then all the employees on the floor get in the elevator in the\r\norder they are queued up while it doesn’t contradict the company’s rules\r\nand there is enough space in the elevator. Each employee spends second\r\nto get inside and outside the elevator. Initially the elevator is empty\r\nand is located on the floor .You are interested what is the minimum\r\npossible time you need to spend to deliver all the employees to their\r\ndestination. It is not necessary to return the elevator to the floor .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nint n,a[2010],b[2010],x[10],f[2010][10][800],p,m[800],u[800][10],v[800],w[10000],c[800][10],d[800][10],ans=1e9;\ninline void dfs(int i,int l)\n{\n    int j,k=0;\n    if(i==l)\n    {\n    p++;\n    m[p]=i-1;\n    for(j=1,k=0;j<i;j++)\n      u[p][j]=x[j],k=k*10+x[j];\n    v[p]=k;\n    w[k]=p;\n      return;\n    }\n    for(j=x[i-1];j<=9;j++)\n      {\n       x[i]=j;\n       dfs(i+1,l);\n      }\n}\ninline int del(int i,int j)\n{\n    int k,l;\n    for(k=1,l=0;k<=m[i];k++)\n      if(u[i][k]!=j)\n        l=l*10+u[i][k];\n    return w[l];\n}\ninline int add(int i,int j)\n{\n    if(m[i]==4)\n      return 0;\n    int k,l;\n    for(k=1,l=0;k<=m[i] && u[i][k]<j;k++)\n      l=l*10+u[i][k];\n    l=l*10+j;\n    for(;k<=m[i];k++)\n      l=l*10+u[i][k];\n    return w[l];\n}\ninline void minn(int &a,int b)\n{\n    a=min(a,b);\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k,l;\n\tx[0]=1;\n\tfor(i=1;i<=5;i++)\n\t  dfs(1,i);\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d%d\",&a[i],&b[i]);\n\tfor(i=1;i<=p;i++)\n\t  for(j=1;j<=9;j++)\n\t    {\n         c[i][j]=add(i,j);\n         d[i][j]=del(i,j);\n        }\n    for(i=1;i<=n+1;i++)\n      for(j=1;j<=9;j++)\n        for(k=1;k<=p;k++)\n          f[i][j][k]=1e9;\n    f[1][1][1]=0;\n    for(i=1;i<=n+1;i++)\n      for(k=p;k>0;k--)\n        for(j=1;j<=9;j++)\n          {\n           for(l=1;l<=m[k];l++)\n             minn(f[i][u[k][l]][d[k][u[k][l]]],f[i][j][k]+abs(j-u[k][l]));\n           if(m[k]<4 && i<=n)\n             minn(f[i+1][a[i]][c[k][b[i]]],f[i][j][k]+abs(j-a[i]));\n           if(i==n+1 && k==1)\n             minn(ans,f[i][j][k]);\n          }\n    printf(\"%d\\n\",ans+2*n);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Elevator.json",
    "editorial_link": "https://codeforces.com//blog/entry/59484",
    "editorial": "We have a strict order. So letâs make , where means that first employees\r\nalready came in the elevator (and possibly came out). So, what is a ?\r\nLetâs store something what will allow us to determine the state. For\r\nthis purpose we want to know the floor, where the elevator currently is,\r\nand number of people, who want to reach each floor. So, itâs integers.\r\nLetâs estimate the number of states: floor takes values, can take . Also\r\nletâs notice, that we donât want to visit floor of nobody in the\r\nelevator donât want to go there and the next person isnât on that floor.\r\nSo we have not more than interesting floors for each . Letâs say the\r\ntotal count of states is .Now weâve got two different solutions.The fast\r\none is we say we go from the floor to the floor and iterate over the\r\npersons who we let come in on the way.The slow one is to run Dijkstra\r\nfor each : from we can go to the floor and let somebody come out or go\r\nto the floor . Now, when we calculated answers for , we can calculate ,\r\nif state has floor equals to and there are no more than people\r\ninside.The answer will be in for .Asymptotics is or Solution\r\n",
    "hint": []
}