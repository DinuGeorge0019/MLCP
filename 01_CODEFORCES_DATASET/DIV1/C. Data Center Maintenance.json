{
    "link": "https://codeforces.com//contest/949/problem/C",
    "problemId": "163630",
    "problem_idx": "C",
    "shortId": "949C",
    "contest_number": "949",
    "problem_submissions": {
        "E": [
            36105597,
            36104729,
            36107882,
            36106052,
            36109939,
            36109078,
            36111836,
            36112039,
            36111175,
            36106962,
            36109964,
            36110554,
            36111413,
            36109601,
            36111115,
            36110022,
            36110942,
            94270940,
            36111425,
            36106250,
            36109832
        ],
        "D": [
            36101360,
            36106649,
            36105542,
            36109215,
            36106017,
            36106726,
            36102230,
            36101449,
            36103104,
            36110228,
            36103260,
            36105066,
            36107080,
            36106355,
            36107442,
            36106210,
            36107773,
            36109010,
            36109232,
            36112599
        ],
        "C": [
            36097297,
            36099409,
            36097097,
            36099338,
            36100026,
            36100955,
            36098934,
            36097758,
            36099260,
            36100420,
            36101363,
            36101312,
            36100998,
            36103414,
            36103747,
            36102556,
            36101236,
            36102526,
            50661562,
            36100630,
            36101932
        ],
        "B": [
            36095300,
            36092787,
            36094621,
            36097341,
            36096959,
            36097302,
            36093518,
            36094892,
            36097014,
            36095796,
            36096835,
            36098669,
            36097021,
            36100952,
            36098276,
            36097313,
            36097889,
            36098939,
            36095872,
            36098787
        ],
        "A": [
            36093067,
            36095425,
            36093246,
            36094348,
            36092357,
            36093156,
            36095248,
            36092415,
            36092267,
            36097893,
            36093322,
            36092795,
            36093362,
            36093672,
            36096228,
            36095964,
            36093387,
            36095876,
            36127878,
            36094011
        ]
    },
    "name": "C. Data Center Maintenance",
    "statement": "BigData Inc. is a corporation that has data centers indexed from to that\r\nare located all over the world. These data centers provide storage for\r\nclient data (you can figure out that client data is really big!).Main\r\nfeature of services offered by BigData Inc. is the access availability\r\nguarantee even under the circumstances of any data center having an\r\noutage. Such a guarantee is ensured by using the . Two-way replication\r\nis such an approach for data storage that any piece of data is\r\nrepresented by two identical copies that are stored in two different\r\ndata centers.For each of company clients, let us denote indices of two\r\ndifferent data centers storing this client data as and .In order to keep\r\ndata centers operational and safe, the software running on data center\r\ncomputers is being updated regularly. Release cycle of BigData Inc. is\r\none day meaning that the new version of software is being deployed to\r\nthe data center computers each day.Data center software update is a\r\nnon-trivial long process, that is why there is a special hour-long time\r\nframe that is dedicated for data center maintenance. During the\r\nmaintenance period, data center computers are installing software\r\nupdates, and thus they may be unavailable. Consider the day to be\r\nexactly hours long. For each data center there is an integer () defining\r\nthe index of an hour of day, such that during this hour data center is\r\nunavailable due to maintenance.Summing up everything above, the\r\ncondition should hold for each client, or otherwise his data may be\r\nunaccessible while data centers that store it are under maintenance.Due\r\nto occasional timezone change in different cities all over the world,\r\nthe maintenance time in some of the data centers may change by one hour\r\nsometimes. Company should be prepared for such situation, that is why\r\nthey decided to conduct an experiment, choosing some non-empty subset of\r\ndata centers, and shifting the maintenance time for them by an hour\r\nlater (i.e. if , then the new maintenance hour would become , otherwise\r\nit would become ). Nonetheless, such an experiment should not break the\r\naccessibility guarantees, meaning that data of any client should be\r\nstill available during any hour of a day after the data center\r\nmaintenance times are changed.Such an experiment would provide useful\r\ninsights, but changing update time is quite an expensive procedure, that\r\nis why the company asked you to find out the minimum number of data\r\ncenters that have to be included in an experiment in order to keep the\r\ndata accessibility guarantees.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define Se second\n#define Fi first\n\nvector <int> conn[100050];\nvector <int> rconn[100050];\n\nint in[100050];\n\nbool dchk[100050];\nint G[100050];\nint gsz[100050];\nvector <int> Vstk;\nvector <int> Vl[100050];\nvoid DFS1(int n) {\n\tdchk[n] = true;\n\tfor (auto it : conn[n]) if (!dchk[it]) DFS1(it);\n\tVstk.push_back(n);\n}\nvoid DFS2(int n, int g) {\n\tG[n] = g;\n\tgsz[g]++;\n\tVl[g].push_back(n);\n\tfor (auto it : rconn[n]) if (!G[it]) DFS2(it, g);\n}\n\nbool vchk[100050];\nint main() {\n\tint N, M, H, i, j, k;\n\tscanf(\"%d %d %d\", &N, &M, &H);\n\tfor (i = 1; i <= N; i++) scanf(\"%d\", &in[i]);\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\n\t\tif ((in[t1] + 1) % H == in[t2]) {\n\t\t\tconn[t1].push_back(t2);\n\t\t\trconn[t2].push_back(t1);\n\t\t}\n\t\tif ((in[t2] + 1) % H == in[t1]) {\n\t\t\tconn[t2].push_back(t1);\n\t\t\trconn[t1].push_back(t2);\n\t\t}\n\t}\n\t\n\tfor (i = 1; i <= N; i++) if (!dchk[i]) DFS1(i);\n\n\tint gc = 0;\n\treverse(all(Vstk));\n\tfor (auto it : Vstk) if (!G[it]) DFS2(it, ++gc);\n\n\tfor (i = 1; i <= N; i++) for (auto it : conn[i]) if (G[i] != G[it]) vchk[G[i]] = true;\n\n\tint ans = INF, ap = -1;\n\tfor (i = 1; i <= gc; i++) {\n\t\tif (vchk[i]) continue;\n\t\tif (ans > gsz[i]) {\n\t\t\tans = gsz[i];\n\t\t\tap = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\tsort(all(Vl[ap]));\n\tfor (auto it : Vl[ap]) printf(\"%d \", it);\n\treturn !printf(\"\\n\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Data Center Maintenance.json",
    "editorial_link": "https://codeforces.com//blog/entry/58291",
    "editorial": "Formally you are given a properly colored graph and you are asked to\r\nfind out size of smallest non-empty subset such that after addition\r\nmodulo to colors of vertices in this subset coloring will remain\r\nproper.Letâs build a directed graph with vertices and edge from to iff\r\nand are connected by edge in original graph and . Now letâs fix some\r\nvertex which color will be changed. Itâs clear that we should take into\r\nits set all vertices which are reachable from it. Now our problem is\r\nreduced to following problem: \"Given directed graph find vertex with\r\nsmallest number reachable from it vertices\". Itâs just any vertex from\r\nsmallest strongly connected component which is sink (strongly connected\r\ncomponent such there is no strongly connected component reachable from\r\nit). Given graph is not properly colored, but you donât have to minimize\r\nsize of the set. Can you solve it? Given graph is not properly colored,\r\nbut you have to minimize size of the set.\r\n",
    "hint": []
}