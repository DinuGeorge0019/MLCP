{
    "link": "https://codeforces.com//contest/634/problem/B",
    "problemId": "49945",
    "problem_idx": "B",
    "shortId": "634B",
    "contest_number": "634",
    "problem_submissions": {
        "E": [
            16414340,
            16416138,
            16413706,
            16414973,
            16415599,
            16414780,
            16415591,
            16416199,
            16416181,
            16416348,
            16415632,
            16415457,
            16416072,
            16413745,
            16466856,
            16413386
        ],
        "D": [
            16411007,
            16410815,
            16412075,
            16411999,
            16412771,
            16413214,
            16412917,
            16413088,
            16413557,
            16414243,
            16411968,
            16413070,
            16413608,
            16410814,
            16411583,
            16411708,
            16418042,
            16411828
        ],
        "C": [
            16409750,
            16409051,
            16410811,
            16409734,
            16410839,
            16411665,
            16411917,
            16411834,
            16411108,
            16413312,
            16410161,
            16411194,
            16417790,
            16416407,
            16409322,
            16410089,
            16410459,
            16409945,
            16409746,
            16410147
        ],
        "B": [
            16408395,
            16409662,
            16410216,
            16408841,
            16409386,
            16409860,
            16410585,
            16409660,
            16410064,
            16408757,
            16417413,
            16417828,
            16409703,
            16408566,
            16409147,
            16409169,
            16409287,
            16410817,
            16408754
        ],
        "A": [
            16407814,
            16407800,
            16408726,
            16407801,
            16408251,
            16407972,
            16407935,
            16408112,
            16408492,
            16407803,
            16407794,
            16408196,
            16407918,
            16407735,
            16407903,
            16407915,
            16407851,
            16408302,
            16407766
        ],
        "F": [
            16417401,
            17066904
        ]
    },
    "name": "B. XOR Equation",
    "statement": "Two integers and have a sum of and a bitwise XOR of . How many possible\r\nvalues are there for the ordered pair ?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define INF ((int) 1e9+10)\n#define LINF ((ll) 1e16)\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(\"%lf\", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c=='-') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>='0') && (c<='9'))\n\t\t\tx=x*10+c-'0',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nll solve(ll s, ll x)\n{\n\tll os = s;\n\tll ways = 1;\n\tfor (int qaz = 60; qaz >= 0; qaz--)\n\t{\n\t\tll c = 1LL << qaz;\n\t\tif (c & x)\n\t\t{\n\t\t\tways *= 2;\n\t\t\ts -= c;\n\t\t\tif (s < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll change = c*2;\n\t\t\tif (change <= s)\n\t\t\t\ts -= change;\n\t\t}\n\t}\n\tif (s != 0)\n\t\treturn 0;\n\tif (os == x)\n\t\tways -= 2;\n\treturn ways;\n}\n\nint main()\n{\n\tll s, x;\n\trint(s); rint(x);\n\tprintf(\"%lld\\n\", solve(s, x));\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. XOR Equation.json",
    "editorial_link": "https://codeforces.com//blog/entry/43467",
    "editorial": "For any two integers a and b, we have , where  is the xor and a&b is the bitwise AND. This is because  is non-carrying binary addition. Thus, we can find a&b?=?(s?-?x)?/?2 (if this is not an integer, there are no solutions).\n\nNow, for each bit, we have 4 cases: , and . If , then ai?=?bi, so we have one possibility: ai?=?bi?=?ai&bi. If , then we must have ai&bi?=?0 (otherwise we print 0), and we have two choices: ai?=?1 and bi?=?0 or vice versa. Thus, we can return 2n, where n is the number of one-bits in x. (Remember to subtract 2 for the cases a?=?0 or b?=?0 if necessary.)"
}