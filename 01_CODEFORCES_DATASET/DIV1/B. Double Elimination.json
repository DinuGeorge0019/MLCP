{
    "link": "https://codeforces.com//contest/1314/problem/B",
    "problemId": "547037",
    "problem_idx": "B",
    "shortId": "1314B",
    "contest_number": "1314",
    "problem_submissions": {
        "F": [
            71726158,
            71718843,
            74749593,
            74749152,
            72292726,
            72292697,
            72292343,
            72291510,
            71844196,
            71723876,
            71715422
        ],
        "B": [
            71718479,
            71829904,
            71711385,
            71709524,
            71707913,
            71711558,
            71720310,
            71713846,
            71720222,
            71715032,
            71716531,
            71717545,
            71717755,
            71716805,
            71725696,
            71868147
        ],
        "D": [
            71714124,
            71712892,
            71733906,
            71707801,
            71745171,
            71710988,
            71712453,
            71713369,
            71709321,
            71710231,
            71720852,
            71726797,
            71713255,
            71704334,
            71710718,
            71710921,
            71711996,
            71765821,
            71712181,
            71712148,
            71712872,
            71716965,
            71711644
        ],
        "C": [
            71711319,
            71864827,
            71714264,
            71722928,
            71716523,
            71714295,
            71721162,
            71720891,
            71720482,
            71720726,
            71723585,
            71724431,
            71726919,
            71725565,
            71714331
        ],
        "A": [
            71703192,
            71704610,
            71703253,
            71706188,
            71703791,
            71704145,
            71707166,
            71705278,
            71704520,
            71703175,
            71715214,
            71703215,
            71703413,
            71707725,
            71704018,
            71704745,
            71703715,
            71704666,
            71704097
        ],
        "E": [
            71722513,
            71724911,
            71718902,
            71725474,
            71727007,
            71717687,
            71725550,
            71726599,
            71726820,
            71859582,
            71935297,
            71720287,
            71723370
        ]
    },
    "name": "B. Double Elimination",
    "statement": "The biggest event of the year Cota 2 world championship \"The\r\nInnernational\" is right around the corner. 2^n teams will compete in a\r\ndouble-elimination format (please, carefully read problem statement even\r\nif you know what is it) to identify the champion. Teams are numbered\r\nfrom 1 to 2^n and will play games one-on-one. All teams start in the\r\nupper bracket.All upper bracket matches will be held played between\r\nteams that haven\u2019t lost any games yet. Teams are split into games by\r\nteam numbers. Game winner advances in the next round of upper bracket,\r\nlosers drop into the lower bracket.Lower bracket starts with 2^{n-1}\r\nteams that lost the first upper bracket game. Each lower bracket round\r\nconsists of two games. In the first game of a round 2^k teams play a\r\ngame with each other (teams are split into games by team numbers).\r\n2^{k-1} loosing teams are eliminated from the championship, 2^{k-1}\r\nwinning teams are playing 2^{k-1} teams that got eliminated in this\r\nround of upper bracket (again, teams are split into games by team\r\nnumbers). As a result of each round both upper and lower bracket have\r\n2^{k-1} teams remaining. See example notes for better\r\nunderstanding.Single remaining team of upper bracket plays with single\r\nremaining team of lower bracket in grand-finals to identify championship\r\nwinner.You are a fan of teams with numbers a_1, a_2, ..., a_k. You want\r\nthe championship to have as many games with your favourite teams as\r\npossible. Luckily, you can affect results of every championship game the\r\nway you want. What\u2019s maximal possible number of championship games that\r\ninclude teams you\u2019re fan of?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<bool> a(1 << n);\n  while (m--) {\n    int x;\n    cin >> x;\n    a[--x] = true;\n  }\n  vector<vector<int>> dp(1 << (n + 1), vector<int>(4, -1));\n  auto merge = [&](int x, int l, int r) {\n    for (int i = 0; i < 4; ++i) {\n      if (dp[l][i] == -1) {\n        continue;\n      }\n      for (int j = 0; j < 4; ++j) {\n        if (dp[r][j] == -1) {\n          continue;\n        }\n        int w1 = i / 2, w2 = j / 2;\n        int l1 = i % 2, l2 = j % 2;\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n        swap(w1, w2);\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n      }\n    }\n  };\n  function<void(int, int, int)> solve = [&](int x, int l, int r) {\n    if (r - l == 2) {\n      if (!a[l] && !a[l + 1]) {\n        dp[x][0] = 0;\n      } else if (a[l] && a[l + 1]) {\n        dp[x][3] = 1;\n      } else {\n        dp[x][1] = dp[x][2] = 1;\n      }\n    } else {\n      int y = (l + r) >> 1, z = x + ((y - l) << 1);\n      solve(x + 1, l, y);\n      solve(z, y, r);\n      merge(x, x + 1, z);\n    }\n  };\n  solve(0, 0, 1 << n);\n  cout << max(dp[0][0], max(dp[0][1] + 1, max(dp[0][2] + 1, dp[0][3] + 1))) << \"\\n\";\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Double Elimination.json",
    "editorial_link": "https://codeforces.com//blog/entry/74214",
    "editorial": "The main observation in this problem is that for each set of players that lie in the subtree of any vertex of a binary tree of the upper bracket, exactly one player will win all matches in the upper bracket, and exactly one player will win all matches in the lower bracket. We can define this set of players (in 0-indexation instead of 1-indexation from statement) as [a?2t;(a+1)?2t)\n for some 1?t?n\n, 0?a<2n2t\n. For each fixed t\n the players with different values of id2t\n don't play with each other, and their upper and lower brackets are independent.\n\nFor each of these sets of players, we are interested only in a number of interesting matches between them, and if the winner of their upper and lower brackets are the teams that are we're fans of. This leads us to the dynamic programming solution:\n\ndp[l\u0085r][fup][flower]\n \u0097 the maximal number of matches between teams with indices in [l;r)\n, if fup?{0,1}\n is 1 if the we're fans of winner of upper bracket, and flower?{0,1}\n is 1 if the we're fans of winner of lower bracket. Again, l\u0085r\n is the special segment: l=a?2t,r=(a+1)?2t?1\n for some 1?t?n\n, 0?a<2n2t\n.\n\ndp[l\u0085r][fup][flower]\n can be recalculated from dp[l\u0085l+r2][flup][fllower]\n and dp[l+r2\u0085r][frup][frlower]\n \u0097 we just iterate over all possible flup,fllower,frup,frlower\n, and the results of all three matches (one in the upper bracket and two in the lower bracket).\n\nIn the end, we use dp[0\u00852n][fup][flower]\n to count the result with the last, grand-finals match.\n\nThis solution works in something like O(2n?27)\n because there are 2n\n interesting segments."
}