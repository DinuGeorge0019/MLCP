{
    "link": "https://codeforces.com//contest/1477/problem/D",
    "problemId": "879398",
    "problem_idx": "D",
    "shortId": "1477D",
    "contest_number": "1477",
    "problem_submissions": {
        "F": [
            106163553,
            106080431,
            106150219,
            105761318,
            105790194,
            105781844
        ],
        "E": [
            105766462,
            105760921,
            105747638,
            105773646,
            105773472,
            105764661,
            105770759,
            105771270,
            105749455,
            107250678,
            107250631,
            105808122
        ],
        "D": [
            105731973,
            105737956,
            105755294,
            105737357,
            105717044,
            105720581,
            105719208,
            105736745,
            105737576,
            105738580,
            105738914,
            105740692,
            105740131,
            105745290,
            105736926,
            105743296,
            105740891,
            105744844
        ],
        "C": [
            105691291,
            105711864,
            105715665,
            105695858,
            105694977,
            105690018,
            105684885,
            105689512,
            105691536,
            105703366,
            105691967,
            105704561,
            105705153,
            105695098,
            105696313,
            105696567,
            105685916,
            105688953,
            105706121,
            105699876
        ],
        "B": [
            105686611,
            105689935,
            105698256,
            105689750,
            105687613,
            105687015,
            105689324,
            105687283,
            105688577,
            105688486,
            105689038,
            105688335,
            105694661,
            105689327,
            105691535,
            105686246,
            105746534,
            105716194,
            105694969,
            105691857
        ],
        "A": [
            105676617,
            105680391,
            105688488,
            105677583,
            105677613,
            105677290,
            105676167,
            105677997,
            105678469,
            105681155,
            105678265,
            105679581,
            105683427,
            105682439,
            105681417,
            105677926,
            105677952,
            105676881,
            105698728,
            105687449
        ]
    },
    "name": "D. Nezzar and Hidden Permutations",
    "statement": "Nezzar designs a brand new game \"Hidden Permutations\" and shares it with\r\nhis best friend, Nanako.At the beginning of the game, Nanako and Nezzar\r\nboth know integers n and m. The game goes in the following way: Firstly,\r\nNezzar hides two permutations p_1,p_2,\r\nldots,p_n and q_1,q_2,\r\nldots,q_n of integers from 1 to n, and Nanako secretly selects m\r\nunordered pairs (l_1,r_1),(l_2,r_2),\r\nldots,(l_m,r_m); After that, Nanako sends his chosen pairs to Nezzar; On\r\nreceiving those m unordered pairs, Nezzar checks if there exists 1\r\nle i\r\nle m, such that (p_{l_i}-p_{r_i}) and (q_{l_i}-q_{r_i}) have different\r\nsigns. If so, Nezzar instantly loses the game and gets a score of -1.\r\nOtherwise, the score Nezzar gets is equal to the number of indices 1\r\nle i\r\nle n such that p_i\r\nneq q_i. However, Nezzar accidentally knows Nanako’s unordered pairs and\r\ndecides to take advantage of them. Please help Nezzar find out two\r\npermutations p and q such that the score is maximized.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tvvc<int> ls;\n\t\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\trep(i,n)sort(all(g[i]));\n\tvi rem(n);iota(all(rem),0);\n\t\n\tauto rec=[&](auto self,int v,bool isroot)->bool{\n\t\tvi cur,tmp,chs;\n\t\tint j=0;\n\t\tfor(auto to:rem){\n\t\t\twhile(j<si(g[v])&&g[v][j]<to)j++;\n\t\t\tif(j<si(g[v])&&g[v][j]==to){\n\t\t\t\ttmp.pb(to);\n\t\t\t}else{\n\t\t\t\tchs.pb(to);\n\t\t\t}\n\t\t}\n\t\trem.swap(tmp);\n\t\tfor(auto ch:chs){\n\t\t\tbool leaf=self(self,ch,false);\n\t\t\tif(leaf){\n\t\t\t\tcur.pb(ch);\n\t\t\t}\n\t\t}\n\t\tif(si(cur)){\n\t\t\tcur.insert(cur.bg,v);\n\t\t\tls.pb(cur);\n\t\t\treturn false;\n\t\t}else if(!isroot){\n\t\t\treturn true;\n\t\t}else{\n\t\t\tif(si(chs)){\n\t\t\t\tassert(si(ls));\n\t\t\t\tls.back().pb(v);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t};\n\t\n\twhile(si(rem)){\n\t\tint root=rem.back();rem.pop_back();\n\t\trec(rec,root,true);\n\t}\n\t\n\trep(_,2){\n\t\tvi tmp(n,-1);\n\t\tint head=0;\n\t\tfor(auto&idx:ls){\n\t\t\tfor(auto i:idx){\n\t\t\t\ttmp[i]=++head;\n\t\t\t}\n\t\t\trotate(idx.bg,idx.bg+1,idx.ed);\n\t\t}\n\t\trep(i,n)if(tmp[i]==-1)tmp[i]=++head;\n\t\tprint(tmp);\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Nezzar and Hidden Permutations.json",
    "editorial_link": "https://codeforces.com//blog/entry/87294",
    "editorial": "We can describe the problem in graph theory terms:We are given a graph\r\nof vertices and edge. The -th edge connects vertices and . We need to\r\nwrite down two numbers on each vertices, on -th vertex we write and on\r\nit, so that: and forms a permutation from to , For each edge , the\r\nrelative order between and must be the same as between and . We want to\r\nmaximize the number of vertices , so that . We can observe the\r\nfollowing: For any vertex with degree , . Proof: For such vertex , let .\r\nThen, there are exactly neighbors of that has its -number smaller than .\r\nSimilarly, let . Then, there are exactly neighbors of that has its\r\n-number smaller than . Since the relative order between and its\r\nneighbors must be the same across and , , which leads to .We can assign\r\nthose numbers with any unused number and delete them from the graph. Now\r\nwe will consider only vertices with degree , where is the number of\r\nremaining vertices. We claim that the maximum number of differing\r\nposition to be exactly .As all vertices have degree , it is easier to\r\nconsider the complement graph , where in is connected if and only if is\r\nnot connected in . Notice that consists of connected components and each\r\nvertex has at least one neighbor.We will focus on a single connected\r\ncomponent. Let us find any spanning tree of this particular component.\r\nIf the spanning tree is astar, Let the center of star be and the other\r\nvertices be . Then, the following is a valid assignment: for Otherwise,\r\nwe claim that we can decompose any tree into different connected stars\r\nwith at least two nodes each. If we can do so, we can assign numbers to\r\nfirst star with nodes, to second star with nodes and so on. Notice that\r\nthe relative order between nodes of different stars never change.The\r\nremaining part is to decompose tree into stars. There are a lot of\r\nalgorithms to do so, one of them would be: Iterate all unassigned nodes.\r\nFor any unassigned node , If any neighbors of are unassigned, assign to\r\nbe the center of new star component along with all unassigned neighbors\r\nof . Otherwise, notice that all neighbors of is now a non-center member\r\nof some star component. Pick up any of âs neighbor, . If the star\r\ncomponent of has at least two non-center nodes, remove from its original\r\nstar component and make node and node a star component centered at .\r\nOtherwise, make to be the center of its star component and add to it. We\r\ncan see that the algorithm produces star components of at least two\r\nnodes each, and therefore we can apply the assignment of numbers to each\r\nstars individually and concat the results. In the end, all nodes will\r\nhave their and assigned differently.It is possible to find all the\r\nneeded spanning tree in time. Then, it takes total time to compute\r\nanswers for all trees. Therefore, time complexity is .\r\n",
    "hint": []
}