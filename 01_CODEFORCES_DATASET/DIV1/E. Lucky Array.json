{
    "link": "https://codeforces.com//contest/121/problem/E",
    "problemId": "646",
    "problem_idx": "E",
    "shortId": "121E",
    "contest_number": "121",
    "problem_submissions": {
        "E": [
            813184,
            803481,
            804722,
            807180,
            805935,
            810990,
            806927,
            805358,
            806319,
            806698,
            840501,
            806868,
            805056,
            812302,
            812293,
            806675,
            806432,
            806020,
            808900,
            807365
        ],
        "D": [
            805974,
            806976,
            804593,
            807857,
            805817,
            819735,
            813011,
            812998,
            837217,
            803664,
            808156,
            805706,
            805598
        ],
        "C": [
            802677,
            802018,
            801698,
            801546,
            802560,
            819807,
            803535,
            802530,
            801865,
            801880,
            802443,
            803919,
            803381,
            804324,
            802973,
            804478,
            802405,
            803458
        ],
        "B": [
            801179,
            800708,
            801605,
            800499,
            800562,
            802015,
            800515,
            800124,
            800949,
            800846,
            801743,
            801824,
            801868,
            801182,
            802657,
            801227,
            800781
        ],
        "A": [
            799835,
            799318,
            799152,
            799351,
            799213,
            800618,
            799387,
            799038,
            799161,
            799506,
            799375,
            800196,
            800336,
            799657,
            799505,
            799863,
            799637
        ]
    },
    "name": "E. Lucky Array",
    "statement": "Petya has an array consisting of numbers. He wants to perform operations\r\nof two types: add an integer to all elements whose indexes belong to the\r\ninterval from to , inclusive ; find and print on the screen how many\r\nlucky numbers there are among elements with indexes that belong to the\r\ninterval from to inclusive . Each lucky number should be counted as many\r\ntimes as it appears in the interval. Petya has a list of all operations.\r\nThe operations are such that after all additions the array won\u2019t have\r\nnumbers that would exceed . Help Petya write a program that would\r\nperform these operations.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <assert.h>\n#include <sstream>\n#include <complex>\n#include <numeric>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define all(a)                  (a).begin(), (a).end()\n#define sz(a)                   int((a).size())\n#define FOR(i, a, b)    for (int i(a); i < b; ++i)\n#define REP(i, n)               FOR(i, 0, n)\n#define UN(v)                   sort(all(v)), (v).erase(unique((v).begin(), (v).end()), (v).end())\n#define CL(a, b)                memset(a, b, sizeof a)\n#define pb                              push_back\n#define X                               first\n#define Y                               second\n\ntypedef long long ll;\ntypedef vector <int> vi;\ntypedef pair <int, int> pii;\n\nbool lucky[10000];\n\nint a[100500];\nint n, m;\n\nint f[200500];\n\nvoid put(int i, int d) {\n        d -= f[i += n];\n        if (d) {\n                for (; i; i /= 2) {\n                        f[i] += d;\n                }\n        }\n}\n\nint sum(int i, int j) {\n        int res = 0;\n        for (i += n, j += n; i <= j; i = (i + 1) / 2, j = (j - 1) / 2) {\n                if (i & 1) res += f[i];\n                if (~j & 1) res += f[j];\n        }\n        return res;\n}\n\nint main() {\n        lucky[0] = true;\n        FOR (i, 1, 10000) {\n                lucky[i] = (i % 10 == 4 || i % 10 == 7) && lucky[i / 10];\n        }\n        scanf(\"%d%d\", &n, &m);\n        REP (i, n) {\n                scanf(\"%d\", a + i);\n                put(i, lucky[a[i]]);\n        }\n        for (; m --> 0; ) {\n                char q[8];\n                int x, y;\n                scanf(\"%s%d%d\", q, &x, &y);\n                --x;\n                --y;\n                if (q[0] == 'c') {\n                        printf(\"%d\\n\", sum(x, y));\n                } else {\n                        int d;\n                        scanf(\"%d\", &d);\n                        for (; x <= y; ++x) {\n                                put(x, lucky[a[x] += d]);\n                        }\n                }\n        }\n        return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Lucky Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/2956",
    "editorial": "In this problem you can use many different algorithms, here is one of them. Obviously, number of different lucky number is 30, because Ai always is ???10000. Let Di - difference between minimum lucky number which is greater than or equal to Ai and Ai. Now, we need to have 5 (but you can use less number) of operation on D: Subtract(l, r, d) - subtract number d from all Ai (l???i???r), Minimum(l, r) - minumum number of all Di (l???i???r), Count(l, r) - how many times that minimum occared in that interval, Left(l, r) = leftmost occarence of that minimum, Set(i, d) - assign d to Di (Di?=?d). Now, we can do our operations. If our operation is \"count\", then we need to find minimum number d (d?=? Minimum(l, r)), if it is equal to 0, then answer is Count(l, r, 0), otherwise, answer is 0. If out operation is \"add\", then we need to Subtract(l, r, d), but now some Di might be less than 0. So, while, Minimum(l, r) ???0, let j = Left(l, r), assign Dj new value (use Set(j, Dj')), which can be calculated with complaxity O(1)."
}