{
    "link": "https://codeforces.com//contest/1109/problem/E",
    "problemId": "298873",
    "problem_idx": "E",
    "shortId": "1109E",
    "contest_number": "1109",
    "problem_submissions": {
        "E": [
            50026873,
            50038594,
            50033088,
            50025271,
            50029128,
            50029427,
            50028676,
            50028977,
            50035588,
            50034800,
            50030219,
            50030201,
            50018221,
            50030444,
            50031682,
            50021323,
            50035024,
            50031663,
            50032167,
            50027503
        ],
        "C": [
            50018224,
            50032258,
            50027083,
            50523597,
            50061049,
            50019096,
            50015185
        ],
        "D": [
            50006360,
            50006283,
            50016138,
            50011686,
            50015522,
            50017005,
            50014754,
            50017015,
            50015842,
            50036394,
            50036291,
            50035638,
            50015625,
            50018432,
            50025929,
            50017587,
            50016208,
            50029181,
            50013944,
            50013609,
            50026717,
            50030603,
            50031093
        ],
        "B": [
            50001043,
            50019350,
            50007187,
            50004994,
            50003589,
            50005230,
            50000704,
            50008934,
            50007447,
            50003085,
            50002442,
            50022126,
            50007014,
            50005280,
            50003394,
            50003776,
            50016263,
            50000661,
            50002322,
            50006926
        ],
        "A": [
            49999265,
            49999276,
            50001550,
            50004725,
            49999432,
            50001055,
            49999266,
            50001592,
            49999413,
            50035642,
            49999326,
            49999231,
            50019325,
            50000549,
            50000251,
            49999282,
            49999284,
            49999278,
            49999235,
            49999298,
            49999812
        ],
        "F": [
            50024623,
            158339458,
            50027544,
            50158209,
            95343531
        ]
    },
    "name": "E. Sasha and a Very Easy Test",
    "statement": "Egor likes math, and not so long ago he got the highest degree of\r\nrecognition in the math community Egor became a mathematician. In this\r\nregard, Sasha decided to congratulate Egor and give him a math test as a\r\npresent. This test contains an array a of integers of length n and\r\nexactly q queries. Queries were of three types: \"\" multiply each number\r\non the range from l to r by x. \"\" divide the number at the position p by\r\nx (divisibility guaranteed). \"\" find the sum of all elements on the\r\nrange from l to r. The sum can be big, so Sasha asked Egor to calculate\r\nthe sum modulo some integer mod. But since Egor is a mathematician, he\r\ndoesn\u2019t have enough time to solve such easy tasks, at the same time he\r\ndoesn\u2019t want to anger Sasha, that\u2019s why he asked you to help and to find\r\nanswers for all queries of the 3-rd type.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll MOD = 1;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll euclid(ll x, ll y, ll &k, ll &l) {\n\tif (y == 0) {\n\t\tk = 1;\n\t\tl = 0;\n\t\treturn x;\n\t}\n\tll g = euclid(y, x % y, l, k);\n\tl -= k * (x / y);\n\treturn g;\n}\nll rev(ll x) {\n\tll k, l;\n\tif (euclid(x, MOD, k, l) != 1) throw;\n\tk %= MOD;\n\tif (k < 0) k += MOD;\n\treturn k;\n}\n\nconst int K = 9;\nconst int C = (int)1e5 + 2;\n\nvector<ll> pr;\nvector<ll> pws[K];\nint m = 0;\n\nstruct Num {\n\tll x;\n\tint a[K];\n\n\tNum() {\n\t\t//cerr << \"here\" << endl;\n\t\tx = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\ta[i] = 0;\n\t}\n\tNum(ll z) {\n\t\tif (z == -1) {\n\t\t\tx = -1;\n\t\t} else {\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\ta[i] = 0;\n\t\t\t\twhile(z % pr[i] == 0) {\n\t\t\t\t\tz /= pr[i];\n\t\t\t\t\ta[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = z % MOD;\n\t\t}\n\t}\n\n\tll getVal() {\n\t\tll res = x;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (a[i] < 0) throw;\n\t\t\tres = mult(res, pws[i][a[i]]);\n\t\t}\n\t\treturn res;\n\t}\n\n\tNum operator + (const Num &A) const {\n\t\tif (A.x == -1) return *this;\n\t\tif (x == -1) return A;\n\t\tNum R = Num();\n\t\tll c1 = x, c2 = A.x;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tR.a[i] = min(a[i], A.a[i]);\n\t\t\tc1 = mult(c1, pws[i][a[i] - R.a[i]]);\n\t\t\tc2 = mult(c2, pws[i][A.a[i] - R.a[i]]);\n\t\t}\n\t\tR.x = add(c1, c2);\n\t\treturn R;\n\t}\n\tNum operator * (const Num &A) const {\n\t\tNum R = Num();\n\t\tR.x = mult(x, A.x);\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tR.a[i] = a[i] + A.a[i];\n\t\treturn R;\n\t}\n\tNum inv() const {\n\t\tNum R = Num();\n\t\tR.x = rev(x);\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tR.a[i] = -a[i];\n\t\treturn R;\n\t}\n};\n\nconst int N = 1 << 17;\nstruct Node {\n\tint l, r;\n\tNum val, toMult;\n\n\tNode() : l(), r(), val(Num(-1)), toMult(Num(1)) {}\n\tNode(int _l, int _r) : l(_l), r(_r), val(Num(-1)), toMult(Num(1)) {}\n};\nNode tree[2 * N + 7];\nll a[N + 5];\nint n;\n\nvoid build() {\n\tfor (int i = 0; i < N; i++) {\n\t\ttree[N + i] = Node(i, i + 1);\n\t\tif (i < n) tree[N + i].val = Num(a[i]);\n\t}\n\tfor (int i = N - 1; i > 0; i--) {\n\t\ttree[i] = Node(tree[2 * i].l, tree[2 * i + 1].r);\n\t\ttree[i].val = tree[2 * i].val + tree[2 * i + 1].val;\n\t}\n}\n\nvoid push(int v) {\n\tif (v >= N) throw;\n\tfor (int u = 2 * v; u < 2 * v + 2; u++) {\n\t\tif (tree[u].val.x == -1) continue;\n\t\ttree[u].val = tree[u].val * tree[v].toMult;\n\t\ttree[u].toMult = tree[u].toMult * tree[v].toMult;\n\t\t//cerr << u << endl;\n\t}\n\ttree[v].toMult = Num(1);\n}\nvoid update(int v) {\n\tif (v >= N) throw;\n\ttree[v].val = tree[2 * v].val + tree[2 * v + 1].val;\n}\n\nvoid multOnSegm(int v, int l, int r, Num x) {\n\tif (l <= tree[v].l && tree[v].r <= r) {\n\t\ttree[v].val = tree[v].val * x;\n\t\ttree[v].toMult = tree[v].toMult * x;\n\t\treturn;\n\t}\n\tif (l >= tree[v].r || tree[v].l >= r) return;\n\tpush(v);\n\tmultOnSegm(2 * v, l, r, x);\n\tmultOnSegm(2 * v + 1, l, r, x);\n\tupdate(v);\n}\nNum getSum(int v, int l, int r) {\n\tif (l <= tree[v].l && tree[v].r <= r) return tree[v].val;\n\tif (l >= tree[v].r || tree[v].l >= r) return Num(-1);\n\tpush(v);\n\tNum R = getSum(2 * v, l, r) + getSum(2 * v + 1, l, r);\n//\teprintf(\"getSum %d %d %d\\n\", v, l, r);\n//\tR.eprint();\n\treturn R;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n//\treturn 0;\n\n\tscanf(\"%d%lld\", &n, &MOD);\n\tll x = MOD;\n\tfor (ll y = 2; y * y <= x; y++) {\n\t\t//cerr << y << endl;\n\t\tif (x % y) continue;\n\t\tpr.push_back(y);\n\t\twhile(x % y == 0) x /= y;\n\t}\n\tif (x > 1)\n\t\tpr.push_back(x);\n\tm = (int)pr.size();\n\n\tfor (int k = 0; k < m; k++) {\n\t\tint L = 0;\n\t\tx = C;\n\t\twhile(x > 0) {\n\t\t\tx /= pr[k];\n\t\t\tL++;\n\t\t}\n\t\tL *= C;\n\t\tL += 2;\n\t\tpws[k].resize(L);\n\t\tpws[k][0] = 1;\n\t\tfor (int i = 1; i < L; i++)\n\t\t\tpws[k][i] = mult(pws[k][i - 1], pr[k]);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\n//\teprintf(\"before build\\n\");\n\n\tbuild();\n\n//\teprintf(\"builded\\n\");\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\t//eprintf(\"%d\\n\", t);\n\t\tif (t == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d%d%lld\", &l, &r, &x);\n\t\t\tl--;\n\t\t\tmultOnSegm(1, l, r, Num(x));\n\t\t} else if (t == 2) {\n\t\t\tint p;\n\t\t\tscanf(\"%d%lld\", &p, &x);\n\t\t\tp--;\n\t\t\tmultOnSegm(1, p, p + 1, Num(x).inv());\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d%d\", &l, &r);\n\t\t\tl--;\n\t\t\tNum X = getSum(1, l, r);\n//\t\t\tX.eprint();\n\t\t\tprintf(\"%lld\\n\", X.getVal());\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Sasha and a Very Easy Test.json",
    "editorial_link": "https://codeforces.com//blog/entry/65295",
    "editorial": "The main idea: Let\u00e2\u0080\u0099s factorize in every query of the -st and the -nd\r\ntype. Now can be presented as , where is a prime divisor of .Then let\u00e2\u0080\u0099s\r\nsplit into two sets: those which are divisors of and those which are not\r\nand process them in different ways.It\u00e2\u0080\u0099s easy to see that all primes from\r\nthe second set are coprime with . According to Euler\u00e2\u0080\u0099s theorem for each\r\ncoprime with there is a modular multiplicative inverse. So you can just\r\nbuild a segment tree with lazy propagation to multiply and divide modulo\r\n.What to do with primes from the first set? Notice, that there are at\r\nmost (because ; let\u00e2\u0080\u0099s call such function to use later) different prime\r\ndivisors of . So let\u00e2\u0080\u0099s maintain a vector in each node of segment tree,\r\nwhich contains pairs (), what means that is such power of , that each\r\nnumber from the corresponding range should be multiplied by . So also\r\nuse lazy propogation to multiply and divide by those primes.Now how to\r\nanswer queries of the -rd type? Just maintain in each node some\r\nauxiliary numbers: the sum from childs equal to the product of primes\r\nfrom the second set, means that each number from the range should be\r\nmultiplied by vector, which contains pairs (), also means that each\r\nmumber from the range should me multiplied by And it is obvious that the\r\nsum on the range which is controled by some node is . How to write\r\nfunction for two nodes from segment tree and to push modification to\r\nchildren I leave you as an exercise, there is nothing diffcult here.Now\r\ncombine ideas from the above, and got the complexity (because in queries\r\ndoesn\u00e2\u0080\u0099t exceed ). To remove a we can precompute all powers of each prime\r\ndivisors of , so we will have no need to use binary exponentiation\r\nalgorithm in segment tree. But here you have to be careful, because\r\nsince we have queries and each of them can increase power of prime by in\r\nthe worst case, so maximal power of prime can be .The complexity is .\r\n"
}