{
    "link": "https://codeforces.com//contest/1129/problem/A1",
    "problemId": "303016",
    "problem_idx": "A1",
    "shortId": "1129A1",
    "contest_number": "1129",
    "problem_submissions": {
        "D": [
            50457140,
            50468228,
            50468213,
            50452551,
            50784588,
            50784524,
            50784516,
            50784486,
            50455866,
            50463030,
            50451241,
            50455843,
            50456518,
            50444260,
            50455126,
            50471374,
            50469822,
            50469757,
            50469734,
            50469338,
            50469151,
            50468662,
            50468322,
            50468273,
            50465415,
            50464634,
            50455747,
            50457843,
            50458250,
            50464059,
            50449299,
            50457330
        ],
        "E": [
            50451183,
            50458483,
            50460101,
            50455688,
            50458301,
            75936467,
            50458791
        ],
        "C": [
            50447279,
            50446245,
            50449561,
            50445538,
            50440385,
            50445043,
            50447738,
            50448032,
            50454787,
            50450606,
            50457517,
            58851047,
            58850895,
            50459942,
            50451465,
            50454057,
            50448457,
            50449663
        ],
        "B": [
            50443936,
            50443531,
            50442156,
            50441155,
            50445396,
            50439298,
            50442768,
            50443504,
            50459278,
            50443656,
            50448178,
            50451750,
            50447513,
            50459190,
            50456796,
            50442875,
            50451493
        ],
        "A1": [
            50438306,
            50436838,
            50435800,
            50454577,
            50434391,
            50434469,
            50436959,
            50437853,
            50449686,
            50439524,
            50436300,
            50436664,
            50460719,
            50444960,
            50438530,
            50438635,
            50437445
        ],
        "A2": [
            50438193,
            50437084,
            50435385,
            50454632,
            50434194,
            50434343,
            50437228,
            50438028,
            50449587,
            50439649,
            50436143,
            50436524,
            50460819,
            50444992,
            50438364,
            50437253,
            50437622
        ]
    },
    "name": "A1. Toy Train  Simplified ",
    "statement": "Alice received a set of Toy Train from Bob. It consists of one train and\r\na connected railway network of n stations, enumerated from 1 through n.\r\nThe train occupies one station at a time and travels around the network\r\nof stations in a circular manner. More precisely, the immediate station\r\nthat the train will visit after station i is station i+1 if 1\r\nleq i < n or station 1 if i = n. It takes the train 1 second to travel\r\nto its next station as described.Bob gave Alice a fun task before he\r\nleft: to deliver m candies that are initially at some stations to their\r\nindependent destinations using the train. The candies are enumerated\r\nfrom 1 through m. Candy i (1\r\nleq i\r\nleq m), now at station a_i, should be delivered to station b_i (a_i\r\nneq b_i). The train has infinite capacity, and it is possible to load\r\noff any number of candies at a station. However, only candy can be\r\nloaded from a station onto the train before it leaves the station. You\r\ncan choose any candy at this station. The time it takes to move the\r\ncandies is negligible.Now, Alice wonders how much time is needed for the\r\ntrain to deliver all candies. Your task is to find, for each station,\r\nthe minimum time the train would need to deliver all the candies were it\r\nto start from there.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  cin >> N >> M;\n\n  vector<PII> candies(M);\n  for (auto &p : candies) { cin >> p.st >> p.nd; --p.st; --p.nd; }\n  vector<VI> ends(N);\n  for (auto &p : candies) {\n    ends[p.st].PB(p.nd);\n  }\n\n  for (int start = 0; start < N; ++start) {\n    int total = 0;\n    for (int i = 0; i < N; ++i) {\n      int tdist = i < start ? N + i - start : i - start;\n\n      int nc = SZ(ends[i]);\n      if (nc == 0) { continue; }\n      int mdist = 1e9;\n      for (int v : ends[i]) {\n        if (v < i) { mini(mdist, N - i + v); } else { mini(mdist, v - i); }\n      }\n\n      maxi(total, (nc - 1) * N + mdist + tdist);\n    }\n\n    cout << total << \" \";\n  }\n  cout << \"\\n\";\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A1. Toy Train  Simplified .json",
    "editorial_link": "https://codeforces.com/blog/entry/65520",
    "editorial": "We can consider the pickup requests from each station individually. The overall answer for some fixed starting station is simply the maximum time needed to fulfill deliveries among all pickup stations.\n\nSuppose the starting station for the train is fixed at some station s\n (1?s?n\n).\n\nConsider some station i\n (1?i?n\n). Let out(i)\n denote the number of candies that need to be picked up from station i\n. If out(i)=0\n, we do not consider this station. From now on, we assume out(i)?1\n. Each time that the train visits station i\n to pick up a candy, we can choose which candy it should pick up. Therefore, we should find an order that would minimize the time needed to fulfill all deliveries from pickup station i\n. It turns out, however, that the only thing that matters is the last candy to be delivered. Suppose the last candy is to be delivered to station e\n, the total time needed to fulfill all pickup requests from station i\n would be: dist(s,i)+n?(out(i)?1)+dist(i,e)\n, where dist(a,b)\n represents the time needed to travel from station a\n to station b\n. Take some time to think why this is the case! With this formulated, it is now clear that we have to choose the last candy to deliver that minimizes dist(i,e)\n.\n\nAll of this can be done in O(n)\n (with an O(n+m)\n pre-process only once to find the optimal last candy for each pickup station). To find the answer for every starting station for the train, we can simply run the above algorithm n\n times.\n\nThe time complexity is O(n2+m)\n."
}