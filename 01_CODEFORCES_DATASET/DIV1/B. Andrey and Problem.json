{
    "link": "https://codeforces.com//contest/442/problem/B",
    "problemId": "10512",
    "problem_idx": "B",
    "shortId": "442B",
    "contest_number": "442",
    "problem_submissions": {
        "E": [
            6921847,
            6938403
        ],
        "C": [
            6919336,
            6917056,
            6920953,
            6916705,
            6918582,
            6918908,
            6921923,
            6921586,
            6918715,
            6919667,
            6919614,
            6925095,
            6918272,
            6918805,
            6919118
        ],
        "D": [
            6917753,
            6918850,
            6915556,
            6918817,
            6920381,
            6944679,
            6921502,
            6920210,
            6921312,
            6921510,
            6918431,
            6923717,
            6920981,
            6920504,
            6918960
        ],
        "B": [
            6916976,
            6915574,
            6916305,
            6915680,
            6916666,
            6917064,
            6917904,
            6915565,
            6916220,
            6916648,
            6916245,
            6918094,
            6915819,
            6916307,
            6917195,
            6916646,
            6916658,
            6921189
        ],
        "A": [
            6914458,
            6914295,
            6918545,
            6915241,
            6915516,
            6914863,
            6915569,
            6914808,
            6914997,
            6914852,
            6914659,
            6915403,
            6914675,
            6915467,
            6916072,
            6920156,
            6915628,
            6915075
        ]
    },
    "name": "B. Andrey and Problem",
    "statement": "Andrey needs one more problem to conduct a programming contest. He has\r\nfriends who are always willing to help. He can ask some of them to come\r\nup with a contest problem. Andrey knows one value for each of his fiends\r\nthe probability that this friend will come up with a problem if Andrey\r\nasks him.Help Andrey choose people to ask. As he needs only one problem,\r\nAndrey is going to be really upset if no one comes up with a problem or\r\nif he gets more than one problem from his friends. You need to choose\r\nsuch a set of people that maximizes the chances of Andrey not getting\r\nupset.\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\ndouble p[12345];\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n  }\n  sort(p, p + n);\n  double ans = 0.0;\n  for (int from = 0; from < n; from++) {\n    double f = 0.0, prod = 1.0;\n    for (int i = from; i < n; i++) {\n      f = f * (1 - p[i]) + prod * p[i];\n      prod *= (1 - p[i]);\n    }\n    if (f > ans) {\n      ans = f;\n    }\n  }\n  printf(\"%.17lf\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "probabilities"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Andrey and Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/12739",
    "editorial": "Letâs sort all friends in such a way that iff . If there is Andrey\r\nshould ask only this friend. Now we can assume that all probabilities\r\nare less then 1. What should we maximize? Let , . Assume we already have\r\nsome group of people we would ask a help. Letâs look what will happen\r\nwith the probability of success if we add a friend with probability to\r\nthis group: It means adding a new people to group will increase a\r\nprobability of success only if . Now letâs look at another question. We\r\nhave some group of people with . And we want to add only one friend to\r\nthis group. Which one is better? Let the probability of the first friend\r\nis and the second friend is . Itâs better to add first one if . As we\r\nget . But itâs only a local criteria of optimality. But, we can prove\r\nthat globally you should use only a group of people with the biggest\r\nprobabilities. We can use proof by contradiction. Letâs look at the\r\noptimal answer with biggest used suffix (in the begining of editorial we\r\nsort all friends). Of all such answers we use one with minimum number of\r\npeople in it. Where are two friends and ( < ) and -th friend is in\r\nanswer and -th isnât. Letâs look at the answer if we exclude -th friend.\r\nIt should be smaller because we used optimal answer with minimum numer\r\nof people in it. So adding a new people to this group will increase\r\nsuccess probability. But we know that adding -th is better than -th. So\r\nwe have found a better answer. So we have a very easy solution of this\r\nproblem. After sorting probabilities we should you some suffix of it.\r\nBecause of sorting time complexity is .\r\n",
    "hint": []
}