{
    "link": "https://codeforces.com//contest/123/problem/C",
    "problemId": "654",
    "problem_idx": "C",
    "shortId": "123C",
    "contest_number": "123",
    "problem_submissions": {
        "E": [
            830840,
            831942,
            831247,
            1154341
        ],
        "C": [
            830171,
            829602,
            829696,
            830545,
            830265,
            830647,
            831072,
            830094,
            829962,
            833283,
            832903,
            833096
        ],
        "D": [
            829496,
            830812,
            1447203,
            829637,
            831873,
            1185562,
            836113,
            832570,
            831822,
            839081,
            831840,
            834715,
            834693,
            831236,
            831444,
            830484,
            833338,
            833314,
            833310,
            830603,
            830534,
            831043,
            833652,
            831461,
            831555,
            831382,
            831934
        ],
        "B": [
            828403,
            828703,
            828120,
            829057,
            828829,
            829690,
            829686,
            832376,
            828694,
            829613,
            829313,
            828996,
            829196,
            828023,
            828574,
            829940,
            829279
        ],
        "A": [
            827847,
            827523,
            827572,
            827701,
            827834,
            828726,
            828164,
            828031,
            832616,
            827887,
            828344,
            829843,
            828296,
            829771,
            827580,
            829074,
            828185
        ]
    },
    "name": "C. Brackets",
    "statement": "A two dimensional array is called a array if each grid contains one of\r\nthe two possible brackets \"(\" or \")\". A path through the two dimensional\r\narray cells is called if any two consecutive cells in the path are\r\nside-adjacent and each cell of the path is located below or to the right\r\nfrom the previous one. A two dimensional array whose size equals is\r\ncalled a array, if any string formed by writing out the brackets on some\r\nmonotonous way from cell to cell forms a correct bracket sequence. Let’s\r\ndefine the operation of comparing two correct bracket arrays of equal\r\nsize ( and ) like that. Let’s consider a given two dimensional array of\r\npriorities () a two dimensional array of same size, containing different\r\nintegers from to . Let’s find such position in the two dimensional\r\narray, that . If there are several such positions, let’s choose the one\r\nwhere number is minimum. If \"(\", then , otherwise . If the position is\r\nnot found, then the arrays are considered equal.Your task is to find a\r\n-th two dimensional correct bracket array. It is guaranteed that for the\r\ngiven sizes of and there will be no less than two dimensional correct\r\nbracket arrays.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef vector<string> vstr;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void pvp(T a, T b) { for (T i = a; i != b; ++i) cout << \"(\" << i->first << \", \" << i->second << \") \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in_c() { int c; for (; (c = getchar()) <= ' '; ) { if (!~c) throw ~0; } return c; }\nint in() { int x = 0, c; for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -in(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10); return x; }\nInt In() { Int x = 0, c; for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -In(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10); return x; }\n\nconst Int INF = 1001001001001001001LL;\nvoid pl(Int &t, Int f) { if ((t += f) >= INF) t = INF; }\n\nconst int LIM = 205;\nInt DP[210][210];\nvoid dping() {\n    int i, j;\n    DP[0][0] = 1;\n    for (i = 0; i < LIM; ++i) for (j = 0; j < LIM; ++j) {\n        if (i < j) pl(DP[i + 1][j], DP[i][j]);\n        pl(DP[i][j + 1], DP[i][j]);\n    }\n}\n\nint M, N;\nInt K;\nint C[210][210];\n\nint L;\nint D[210];\npint ps[210];\nchar seq[210];\nchar ans[210][210];\n\nInt dp[210][210];\nInt calc() {\n    int i, j;\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for (i = 0; i < L; ++i) for (j = 0; j <= L / 2; ++j) if (dp[i][j]) {\n        if (seq[i] != ')') pl(dp[i + 1][j + 1], dp[i][j]);\n        if (seq[i] != '(') if (j) pl(dp[i + 1][j - 1], dp[i][j]);\n    }\n    return dp[L][0];\n}\n\nint main() {\n    int x, y, z;\n    int l;\n    \n    //dping();\n    \n    for (; cin >> M >> N >> K; ) {\n        for (x = 0; x < M; ++x) for (y = 0; y < N; ++y) {\n            C[x][y] = in();\n        }\n        L = M + N - 1;\n        assert(L % 2 == 0);\n        memset(D, 0x3f, sizeof(D));\n        for (x = 0; x < M; ++x) for (y = 0; y < N; ++y) {\n            chmin(D[x + y], C[x][y]);\n        }\n        for (z = 0; z < L; ++z) {\n            ps[z] = mp(D[z], z);\n        }\n        sort(ps, ps + L);\n//cout<<\"ps : \";for(z=0;z<L;++z)cout<<ps[z].second<<\" \";cout<<endl;\n        memset(seq, '?', L);\n        seq[L] = 0;\n        Int k = K;\n        for (l = 0; l < L; ++l) {\n            z = ps[l].second;\n            seq[z] = '(';\n            Int tmp = calc();\n            if (k > tmp) {\n                k -= tmp;\n                seq[z] = ')';\n            }\n        }\n//cout<<\"seq : \"<<seq<<endl;\n        for (x = 0; x < M; ++x) for (y = 0; y < N; ++y) {\n            ans[x][y] = seq[x + y];\n        }\n        for (x = 0; x < M; ++x) {\n            ans[x][N] = 0;\n            puts(ans[x]);\n        }\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Brackets.json",
    "editorial_link": "https://codeforces.com//blog/entry/3047",
    "editorial": "Let's reduce the problem to a one-dimensional matrix. Consider a monotonous path (1,?1),?(1,?2),?...,?(1,?m?-?1),?(1,?m),?(2,?m),?...,?(n?-?1,?m),?(n,?m) which has correct bracket sequence. Now, in this way a cell (1,?m) can be replaced on (2,?m?-?1) and still be a monotonous way and will form the correct sequence of the bracket. So in the cells of (1,?m) and (2,?m?-?1) is one type of bracket. Proceeding further (eg to replace (1,?m?-?1) on (2,?m?-?2) or (2,?m) on (3,?m?-?1)) can be seen that in cells (i,?j) and (i?-?1,?j?+?1) is one type of bracket. Then we get not two-dimensional array n?×?m, a one-dimensional size n?+?m?-?1. For each position can be determined what her highest priority, ie for cell i (1???i???n?+?m?-?1), the priority will be equal to the minimum value of px,?y where 1???x???n, 1???y???m and x?+?y?-?1?=?i.\nLet's iterate through the positions, starting with the highest priority. Let's put in this position the bracket \"(\" and consider how many ways can complete the remaining brackets to get the correct bracket sequence. If the number of ways of not less than k, then leave in this position \"(\", or reduce the k on the number of ways and put in this positions bracket \")\". And so let's iterate through all items. In order to calculate the number of ways each time dynamics is calculated on two parameters fi,?j, where i is the number of processed positions, and j is the number of opened brackets. If the position of i?+?1 bracket is not defined yet then you can go to fi?+?1,?j?+?1 or fi?+?1,?j?-?1, if defined then only fi?+?1,?j?+?1 or only fi?+?1,?j?-?1, depending on opening or closing bracket respectively.",
    "hint": []
}