{"link": "https://codeforces.com//contest/1338/problem/B", "problemId": "590532", "problem_idx": "B", "shortId": "1338B", "contest_number": "1338", "problem_submissions": {"E": [76397300, 76619327, 76403815, 76434529, 76434479, 76434133, 76434078, 76433920, 76433813, 76433749, 76433522, 76432895, 76432405, 76433003, 76432715, 76492191, 76458850, 77714923, 76416304, 78374239, 105958584], "D": [76383105, 76378423, 76373799, 76372283, 76380290, 76721483, 76721183, 76718097, 76716953, 76379002, 76377538, 76378427, 76454507, 76377531, 76381613, 76384929, 76380304, 76384800, 76387623, 76383511, 76383924, 76389002, 76385003, 76379777, 76361072], "C": [76355433, 76365439, 76355356, 76357185, 76342857, 77464916, 77464536, 76797866, 76793425, 76363706, 76354913, 76352467, 76454469, 76364453, 76361606, 76365484, 76367936, 76362206, 76361479, 76370442, 76369319, 76368001, 76372720, 76355615, 76385066], "B": [76346805, 76342391, 76342822, 76343816, 76355163, 77465740, 76793469, 76348894, 76346501, 76359563, 76454438, 76345410, 76341218, 76346125, 76349446, 76346871, 76343626, 76346043, 76350035, 76345138, 76349598, 76348838, 76367005], "A": [76334223, 76335060, 76334379, 76334482, 76348815, 76334952, 76364133, 76339027, 76454272, 76334304, 76334154, 76336649, 76334438, 76334441, 76334773, 76334264, 76337258, 76335486, 76337735, 76341537, 76369906]}, "name": "B. Edge Weight Assignment", "statement": "You have unweighted tree of n vertices. You have to assign a weight to\r\neach edge so that the following condition would hold: For every two\r\ndifferent leaves v_{1} and v_{2} of this tree, bitwise XOR of weights of\r\nall edges on the simple path between v_{1} and v_{2} has to be equal to\r\n0. Note that you can put positive integers (like 10^{(10^{10})}).It\u2019s\r\nguaranteed that such assignment always exists under given constraints.\r\nNow let\u2019s define f as in assignment. In this example, assignment is\r\nvalid, because bitwise XOR of all edge weights between every pair of\r\nleaves is 0. f value is 2 here, because there are 2 distinct edge\r\nweights(4 and 5). In this example, assignment is invalid, because\r\nbitwise XOR of all edge weights between vertex 1 and vertex 6 (3, 4, 5,\r\n4) is not 0. What are the minimum and the maximum possible values of f\r\nfor the given tree? Find and print both.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 12.04.2020 17:16:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass forest : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  forest(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    assert(id < n - 1);\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nclass dfs_forest : public forest<T> {\n public:\n  using forest<T>::edges;\n  using forest<T>::g;\n  using forest<T>::n;\n\n  vector<int> pv;\n  vector<int> pe;\n  vector<int> order;\n  vector<int> pos;\n  vector<int> end;\n  vector<int> sz;\n  vector<int> root;\n  vector<int> depth;\n  vector<T> dist;\n\n  dfs_forest(int _n) : forest<T>(_n) {\n  }\n\n  void init() {\n    pv = vector<int>(n, -1);\n    pe = vector<int>(n, -1);\n    order.clear();\n    pos = vector<int>(n, -1);\n    end = vector<int>(n, -1);\n    sz = vector<int>(n, 0);\n    root = vector<int>(n, -1);\n    depth = vector<int>(n, -1);\n    dist = vector<T>(n);\n  }\n\n  void clear() {\n    pv.clear();\n    pe.clear();\n    order.clear();\n    pos.clear();\n    end.clear();\n    sz.clear();\n    root.clear();\n    depth.clear();\n    dist.clear();\n  }\n\n private:\n  void do_dfs(int v) {\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    sz[v] = 1;\n    for (int id : g[v]) {\n      if (id == pe[v]) {\n        continue;\n      }\n      auto &e = edges[id];\n      int to = e.from ^ e.to ^ v;\n      depth[to] = depth[v] + 1;\n      dist[to] = dist[v] + e.cost;\n      pv[to] = v;\n      pe[to] = id;\n      root[to] = (root[v] != -1 ? root[v] : to);\n      do_dfs(to);\n      sz[v] += sz[to];\n    }\n    end[v] = (int) order.size() - 1;\n  }\n\n  void do_dfs_from(int v) {\n    depth[v] = 0;\n    dist[v] = T{};\n    root[v] = v;\n    pv[v] = pe[v] = -1;\n    do_dfs(v);\n  }\n\n public:\n  void dfs(int v, bool clear_order = true) {\n    if (pv.empty()) {\n      init();\n    } else {\n      if (clear_order) {\n        order.clear();\n      }\n    }\n    do_dfs_from(v);\n  }\n\n  void dfs_all() {\n    init();\n    for (int v = 0; v < n; v++) {\n      if (depth[v] == -1) {\n        do_dfs_from(v);\n      }\n    }\n    assert((int) order.size() == n);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  dfs_forest<int> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g.add(x, y);\n  }\n  int root = 0;\n  while (g.g[root].size() < 2) {\n    ++root;\n  }\n  g.dfs(root);\n  vector<int> has(2, 0);\n  for (int i = 0; i < n; i++) {\n    if (g.g[i].size() == 1) {\n      has[g.depth[i] % 2] += 1;\n    }\n  }\n  cout << ((has[0] && has[1]) ? 3 : 1) << \" \";\n  set<pair<int, int>> s;\n  for (auto& e : g.edges) {\n    int x = e.from;\n    int y = e.to;\n    x = (g.g[x].size() == 1 ? -1 : x);\n    y = (g.g[y].size() == 1 ? -1 : y);\n    s.emplace(min(x, y), max(x, y));\n  }\n  cout << s.size() << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "dfs and similar", "greedy", "math", "trees"], "dificulty": "1800", "interactive": false}