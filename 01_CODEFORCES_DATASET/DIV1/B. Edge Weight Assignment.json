{
    "link": "https://codeforces.com//contest/1338/problem/B",
    "problemId": "590532",
    "problem_idx": "B",
    "shortId": "1338B",
    "contest_number": "1338",
    "problem_submissions": {
        "E": [
            76397300,
            76619327,
            76403815,
            76434529,
            76434479,
            76434133,
            76434078,
            76433920,
            76433813,
            76433749,
            76433522,
            76432895,
            76432405,
            76433003,
            76432715,
            76492191,
            76458850,
            77714923,
            76416304,
            78374239,
            105958584
        ],
        "D": [
            76383105,
            76378423,
            76373799,
            76372283,
            76380290,
            76721483,
            76721183,
            76718097,
            76716953,
            76379002,
            76377538,
            76378427,
            76454507,
            76377531,
            76381613,
            76384929,
            76380304,
            76384800,
            76387623,
            76383511,
            76383924,
            76389002,
            76385003,
            76379777,
            76361072
        ],
        "C": [
            76355433,
            76365439,
            76355356,
            76357185,
            76342857,
            77464916,
            77464536,
            76797866,
            76793425,
            76363706,
            76354913,
            76352467,
            76454469,
            76364453,
            76361606,
            76365484,
            76367936,
            76362206,
            76361479,
            76370442,
            76369319,
            76368001,
            76372720,
            76355615,
            76385066
        ],
        "B": [
            76346805,
            76342391,
            76342822,
            76343816,
            76355163,
            77465740,
            76793469,
            76348894,
            76346501,
            76359563,
            76454438,
            76345410,
            76341218,
            76346125,
            76349446,
            76346871,
            76343626,
            76346043,
            76350035,
            76345138,
            76349598,
            76348838,
            76367005
        ],
        "A": [
            76334223,
            76335060,
            76334379,
            76334482,
            76348815,
            76334952,
            76364133,
            76339027,
            76454272,
            76334304,
            76334154,
            76336649,
            76334438,
            76334441,
            76334773,
            76334264,
            76337258,
            76335486,
            76337735,
            76341537,
            76369906
        ]
    },
    "name": "B. Edge Weight Assignment",
    "statement": "You have unweighted tree of n vertices. You have to assign a weight to\r\neach edge so that the following condition would hold: For every two\r\ndifferent leaves v_{1} and v_{2} of this tree, bitwise XOR of weights of\r\nall edges on the simple path between v_{1} and v_{2} has to be equal to\r\n0. Note that you can put positive integers (like 10^{(10^{10})}).It\u2019s\r\nguaranteed that such assignment always exists under given constraints.\r\nNow let\u2019s define f as in assignment. In this example, assignment is\r\nvalid, because bitwise XOR of all edge weights between every pair of\r\nleaves is 0. f value is 2 here, because there are 2 distinct edge\r\nweights(4 and 5). In this example, assignment is invalid, because\r\nbitwise XOR of all edge weights between vertex 1 and vertex 6 (3, 4, 5,\r\n4) is not 0. What are the minimum and the maximum possible values of f\r\nfor the given tree? Find and print both.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 12.04.2020 17:16:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass forest : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  forest(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    assert(id < n - 1);\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nclass dfs_forest : public forest<T> {\n public:\n  using forest<T>::edges;\n  using forest<T>::g;\n  using forest<T>::n;\n\n  vector<int> pv;\n  vector<int> pe;\n  vector<int> order;\n  vector<int> pos;\n  vector<int> end;\n  vector<int> sz;\n  vector<int> root;\n  vector<int> depth;\n  vector<T> dist;\n\n  dfs_forest(int _n) : forest<T>(_n) {\n  }\n\n  void init() {\n    pv = vector<int>(n, -1);\n    pe = vector<int>(n, -1);\n    order.clear();\n    pos = vector<int>(n, -1);\n    end = vector<int>(n, -1);\n    sz = vector<int>(n, 0);\n    root = vector<int>(n, -1);\n    depth = vector<int>(n, -1);\n    dist = vector<T>(n);\n  }\n\n  void clear() {\n    pv.clear();\n    pe.clear();\n    order.clear();\n    pos.clear();\n    end.clear();\n    sz.clear();\n    root.clear();\n    depth.clear();\n    dist.clear();\n  }\n\n private:\n  void do_dfs(int v) {\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    sz[v] = 1;\n    for (int id : g[v]) {\n      if (id == pe[v]) {\n        continue;\n      }\n      auto &e = edges[id];\n      int to = e.from ^ e.to ^ v;\n      depth[to] = depth[v] + 1;\n      dist[to] = dist[v] + e.cost;\n      pv[to] = v;\n      pe[to] = id;\n      root[to] = (root[v] != -1 ? root[v] : to);\n      do_dfs(to);\n      sz[v] += sz[to];\n    }\n    end[v] = (int) order.size() - 1;\n  }\n\n  void do_dfs_from(int v) {\n    depth[v] = 0;\n    dist[v] = T{};\n    root[v] = v;\n    pv[v] = pe[v] = -1;\n    do_dfs(v);\n  }\n\n public:\n  void dfs(int v, bool clear_order = true) {\n    if (pv.empty()) {\n      init();\n    } else {\n      if (clear_order) {\n        order.clear();\n      }\n    }\n    do_dfs_from(v);\n  }\n\n  void dfs_all() {\n    init();\n    for (int v = 0; v < n; v++) {\n      if (depth[v] == -1) {\n        do_dfs_from(v);\n      }\n    }\n    assert((int) order.size() == n);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  dfs_forest<int> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g.add(x, y);\n  }\n  int root = 0;\n  while (g.g[root].size() < 2) {\n    ++root;\n  }\n  g.dfs(root);\n  vector<int> has(2, 0);\n  for (int i = 0; i < n; i++) {\n    if (g.g[i].size() == 1) {\n      has[g.depth[i] % 2] += 1;\n    }\n  }\n  cout << ((has[0] && has[1]) ? 3 : 1) << \" \";\n  set<pair<int, int>> s;\n  for (auto& e : g.edges) {\n    int x = e.from;\n    int y = e.to;\n    x = (g.g[x].size() == 1 ? -1 : x);\n    y = (g.g[y].size() == 1 ? -1 : y);\n    s.emplace(min(x, y), max(x, y));\n  }\n  cout << s.size() << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "math",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Edge Weight Assignment.json",
    "editorial_link": "https://codeforces.com//blog/entry/75913",
    "editorial": "Let\u00e2\u0080\u0099s make an easy and good construction which can solve actual problem.\r\nNow reroot this tree at any leaf like picture below; Our goal in this\r\nconstruction is, we are trying to make for all two leaves and to satisfy\r\n.First, let\u00e2\u0080\u0099s solve about minimum value. . You can prove that minimum\r\nvalue of is at most , by following construction; Since we pick any leaf\r\nas root, root is not at the top in this picture. Weight of edges are\r\nonly determined by degree of two vertices and whether that edge is\r\nconnected to leaf or not. So answer for minimum value is at most .. If\r\nthere is any construction such that , then it is always possible to have\r\nconstruction of . Because if then there should be even number of edges\r\nfor each weight, and you can simply change all weights them to single\r\nvalue without violating validity of edge weight assignment.If you want\r\nto check validity of assignment, then you can simply check if all leaves\r\nhave same parity of distance from root. Because distances between all\r\nnodes should be even.Now let\u00e2\u0080\u0099s solve about maximum value. . You can\r\nsolve maximum value of by following construction; So for each non-root\r\nvertex , assign weight to edge between and by followings ( is parent of\r\nvertex ); If is not leaf, then assign as weight. Otherwise, assign as\r\nweight. This will differentize all edges\u00e2\u0080\u0099 weights except for multiple\r\nleaves\u00e2\u0080\u0099s edges which are connected to single vertex, because every\r\nnon-leaf vertex have different weights of edge to its parent.So the\r\nanswer for maximum value is , where is number of edges in this tree. is\r\nnumber of leaves in this tree. is number of non-leaves which has at\r\nleast one leaf as its neighbor. Time complexity is . (Update) There is\r\nan another way to approach, provided by Darooha. If you label vertices\r\ninstead of edges where all leaves have same label and none of neighbors\r\nhave same label, then you can consider edge weight as xor of two\r\nvertices\u00e2\u0080\u0099 labels, so this is basically equivalent to original\r\nproblem.Now for minimum, you can see that labelling to leaves, and to\r\nnon-leaves are enough, so you can prove minimum value of is at most . In\r\nsame manner, you can try parity checking to check if value can be or\r\nnot.For maximum, assign to all leaves and assign all different values()\r\nto non-leaf vertices, then you can see all edge weights(except leaves\r\nconnected to same vertex) are different.\r\n"
}