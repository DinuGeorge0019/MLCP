{
    "link": "https://codeforces.com//contest/1503/problem/C",
    "problemId": "945471",
    "problem_idx": "C",
    "shortId": "1503C",
    "contest_number": "1503",
    "problem_submissions": {
        "F": [
            111939776,
            111936345,
            111953640,
            111949537,
            111942068,
            111944734,
            111944711,
            111948141,
            111947867,
            113984444
        ],
        "E": [
            111918055,
            111912666,
            111918864,
            111923939,
            111922990,
            111923269,
            111922053,
            111920801,
            111927922,
            111926604,
            111931364,
            111936374,
            111926173,
            111935792,
            111929517,
            111930613,
            111937713,
            111935328,
            111934244
        ],
        "D": [
            111903738,
            111902585,
            111898744,
            111893896,
            111901869,
            111902624,
            111880076,
            111902059,
            111906951,
            111905795,
            111910439,
            111899185,
            111916472,
            111904574,
            111913444,
            111910826,
            111914877,
            111924091,
            111906860
        ],
        "C": [
            111886477,
            111890876,
            111881938,
            111886094,
            111882409,
            111883959,
            111902446,
            111905834,
            111885208,
            111897171,
            111889963,
            111890061,
            111888926,
            111886850,
            111898651,
            111896248,
            111894668,
            111884135,
            111889304
        ],
        "B": [
            111876447,
            111888244,
            111877449,
            111876120,
            111878468,
            111878981,
            111893644,
            111877927,
            111878327,
            111877579,
            111878407,
            111882807,
            111900739,
            111880662,
            111889601,
            111886898,
            111883228,
            111878516,
            111916268
        ],
        "A": [
            111871860,
            111872029,
            111873354,
            111871912,
            111872701,
            111874636,
            111888931,
            111872574,
            111873406,
            111872331,
            111873739,
            111875192,
            111873092,
            111873513,
            111878839,
            111875591,
            111873509,
            111872858,
            111893066
        ]
    },
    "name": "C. Travelling Salesman Problem",
    "statement": "There are n cities numbered from 1 to n, and city i has beauty a_i.A\r\nsalesman wants to start at city 1, visit every city exactly once, and\r\nreturn to city 1.For all i\r\nne j, a flight from city i to city j costs\r\nmax(c_i,a_j-a_i) dollars, where c_i is the price floor enforced by city\r\ni. Note that there is no absolute value. Find the minimum total cost for\r\nthe salesman to complete his trip.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tusing ll = long long;\n\tint n;\n\tcin >> n;\n\tvector<pair<ll, ll>> z;\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tll a, c;\n\t\tcin >> a >> c;\n\t\tz.push_back({a, a+c});\n\t\tans += c;\n\t}\n\tsort(z.begin(), z.end());\n\tll maxc = z.front().second;\n\tfor(int i = 1; i < n; i++){\n\t\tans += max(0ll, z[i].first - maxc);\n\t\tmaxc = max(maxc, z[i].second);\n\t}\n\tcout << ans << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "shortest paths",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Travelling Salesman Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/89319",
    "editorial": "Let's reindex the cities so they are in increasing order of beauty. Note that it doesn't matter which city we call the start: the trip will be a cycle visiting every city exactly once.\n\nLet's rewrite the cost of a flight i?j\n as\nmax(ci,aj?ai)=ci+max(0,aj?ai?ci).\n\nSince we always need to leave each city exactly once, we can ignore the ci\n term from all flights and only try to minimize the sum of max(0,aj?ai?ci).\n\nNote that a flight to a city of smaller beauty is always free in the adjusted cost. So all we need is a path from a1\n to an\n, and the rest of the trip can be done for free. Also, any valid trip will contain a path from a1\n to an\n, so the shortest path is optimal.\n\nSolution 1\n\nAll we have to do is encode the graph without storing all edges explicitly, and we can simply run Dijkstra's algorithm to find the shortest path. Add the following edges:\n\nai?ai?1\n with weight 0\n.\ni?j\n with weight 0\n, where j\n is the largest index with aj?ai?ci?0\n. The index j\n can be found with binary search.\ni?j+1\n with weight max(0,aj+1?ai?ci)\n where j\n is the same as before.\nEvery edge in this new graph corresponds to an edge in the original graph, and every edge in the original graph corresponds to a path in the new graph with at most the same cost. So the distance from a1\n to an\n is preserved.\n\nSolution 2\n\nA simpler solution is to compute for all i>1\n, the minimum possible cost of the first trip reaching ai\n or larger. It's easy to see that any path must have at least this cost, and we can construct a path of this cost since moving to smaller ai\n is free. It corresponds to the following summation.",
    "hint": []
}