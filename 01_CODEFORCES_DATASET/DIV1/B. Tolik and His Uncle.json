{
    "link": "https://codeforces.com//contest/1179/problem/B",
    "problemId": "361545",
    "problem_idx": "B",
    "shortId": "1179B",
    "contest_number": "1179",
    "problem_submissions": {
        "E": [
            55903813,
            55902523,
            55901885,
            55909022,
            55905388,
            56432061,
            75942632,
            56023295
        ],
        "D": [
            55893003,
            55895931,
            55888725,
            55893104,
            71080559,
            71080196,
            71080163,
            71080130,
            71080072,
            71080060,
            55893173,
            55892658,
            55908319,
            55894131,
            55894542,
            55893763,
            55896830,
            56019124,
            55897859,
            55895869,
            55954689,
            55895158,
            55899492,
            55899301,
            55888559,
            55898280,
            55898257,
            55896770
        ],
        "C": [
            55884160,
            55884795,
            55882131,
            55884686,
            55905440,
            55885364,
            55885156,
            55885262,
            55885328,
            55886216,
            55885322,
            55883584,
            55886444,
            55954679,
            55890192,
            55886511,
            55887224,
            55900785,
            55886889,
            55887130,
            55889061
        ],
        "B": [
            55880474,
            55886283,
            55907977,
            55879717,
            55880717,
            55880688,
            55881071,
            55881636,
            55881390,
            55878893,
            55881077,
            55881153,
            55954669,
            55881453,
            55881368,
            55881391,
            55880057,
            55884243,
            55877081,
            55883081
        ],
        "A": [
            55876049,
            55878221,
            55877438,
            55877168,
            55878263,
            55877701,
            55876941,
            55878391,
            55879288,
            55877277,
            55877221,
            55878361,
            55954661,
            55878330,
            55878077,
            55877852,
            55877332,
            55880624,
            55880725,
            55879783
        ]
    },
    "name": "B. Tolik and His Uncle",
    "statement": "This morning Tolik has understood that while he was sleeping he had\r\ninvented an incredible problem which will be a perfect fit for\r\nCodeforces! But, as a \"Discuss tasks\" project hasn\u2019t been born yet (in\r\nEnglish, well), he decides to test a problem and asks his uncle.After a\r\nlong time thinking, Tolik\u2019s uncle hasn\u2019t any ideas on how to solve it.\r\nBut, he doesn\u2019t want to tell Tolik about his inability to solve it, so\r\nhe hasn\u2019t found anything better than asking you how to solve this\r\ntask.In this task you are given a cell field n\r\ncdot m, consisting of n rows and m columns, where point\u2019s coordinates\r\n(x, y) mean it is situated in the x-th row and y-th column, considering\r\nnumeration from one (1\r\nleq x\r\nleq n, 1\r\nleq y\r\nleq m). Initially, you stand in the cell (1, 1). Every move you can jump\r\nfrom cell (x, y), which you stand in, by any non-zero vector (dx, dy),\r\nthus you will stand in the (x+dx, y+dy) cell. Obviously, you can\u2019t leave\r\nthe field, but also there is one more important condition you\u2019re not\r\nallowed to use one vector twice. Your task is to visit each cell of the\r\nfield exactly once (the initial cell is considered as already\r\nvisited).Tolik\u2019s uncle is a very respectful person. Help him to solve\r\nthis task!\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\n\nvector <pii> wek;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tint l=1;\n\tint p=m;\n\tfor (int i=1; l<=p; i++)\n\t{\n\t\tif (l==p)\n\t\t{\n\t\t\tfor (int j=1; j<=n+1-j; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d\\n\", j, l);\n\t\t\t\tif (j!=n+1-j)\n\t\t\t\t\tprintf(\"%d %d\\n\", n+1-j, l);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d\\n\", j, l);\n\t\t\t\tprintf(\"%d %d\\n\", n+1-j, p);\n\t\t\t}\n\t\t}\n\t\tl++;\n\t\tp--;\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Tolik and His Uncle.json",
    "editorial_link": "https://codeforces.com//blog/entry/67891",
    "editorial": "First, we are going to describe how to bypass strip.This algorithm is\r\npretty easy -> -> -> -> . Obviously all jumps have different vectors\r\nbecause their lengths are different.It turns out that the algorithm for\r\ngrid is almost the same. Initially, we are going to bypass two uttermost\r\nhorizontals almost the same way as above -> -> -> -> -> -> . One can\r\nrealize that all vectors are different because they have different .\r\nNote that all of them have . Then we will jump to (using vector). Now we\r\nhave a smaller task for grid. One can see that we used only vectors with\r\n, so they don\u00e2\u0080\u0099t influence now at all. So the task is fully brought down\r\nto a smaller one.\r\n"
}