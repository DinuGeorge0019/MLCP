{
    "link": "https://codeforces.com//contest/406/problem/E",
    "problemId": "7391",
    "problem_idx": "E",
    "shortId": "406E",
    "contest_number": "406",
    "problem_submissions": {
        "E": [
            6113980,
            6115371,
            6117401,
            6114390,
            6114632,
            6115961,
            6113761,
            6119100,
            6122295,
            6132836,
            6117696,
            6115484
        ],
        "D": [
            6111550,
            6112818,
            6117396,
            6111602,
            6114018,
            6112889,
            6110196,
            6112558,
            6113207,
            6114342,
            6109879,
            6117233,
            6113495,
            6112560,
            6111190,
            6113785,
            6113949,
            6114279,
            6113928,
            6111720,
            6116758,
            6114622
        ],
        "C": [
            6110187,
            6111166,
            6117392,
            6115342,
            6111381,
            6110506,
            6110270,
            6108894,
            6114229,
            6110730,
            6111155,
            6113968,
            6111745,
            6111516,
            6128689,
            6128286,
            6111327,
            6111782,
            6108166
        ],
        "B": [
            6108889,
            6109179,
            6117390,
            6108130,
            6113002,
            6108132,
            6108085,
            6107339,
            6110967,
            6110982,
            6107994,
            6108825,
            6109585,
            6108127,
            6108320,
            6109839,
            6109061,
            6109268,
            6109691,
            6111113
        ],
        "A": [
            6107835,
            6107644,
            6117388,
            6107225,
            6112427,
            6117543,
            6106926,
            6106550,
            6108138,
            6107728,
            6107011,
            6108007,
            6108768,
            6106947,
            6107483,
            6108996,
            6107104,
            6108198,
            6108284,
            6109349
        ]
    },
    "name": "E. Hamming Triples",
    "statement": "Little Chris is having a nightmare. Even in dreams all he thinks about\r\nis math.Chris dreams about binary strings of length , indexed with\r\nnumbers from 1 to . The most horrifying part is that the bits of each\r\nstring are ordered in either ascending or descending order. For example,\r\nChris could be dreaming about the following 4 strings of length 5: The\r\nbetween two strings and of length is the number of positions at which\r\nthe corresponding symbols are different. hris thinks that each three\r\nstrings with different indices constitute a single triple. Chris’s\r\ndelusion is that he will wake up only if he counts the number of such\r\nstring triples , , that the sum is maximal among all the string triples\r\nconstructed from the dreamed strings.Help Chris wake up from this\r\nnightmare!\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA \"sequence\"\n\nlng doit(const vector<lng> &A,const vector<lng> &B){\n\tvector<lng> v;\n\tv.pb(0);\n\tforv(i,A){\n\t\tv.pb(v.back()+(upper_bound(all(B),A[i])-B.begin()));\n\t}\n\tlng res=0;\n\tforv(i,B){\n\t\tres+=v[upper_bound(all(A),B[i])-A.begin()];\n\t\tif(!i || B[i-1]!=B[i]){\n\t\t\tlng a=upper_bound(all(A),B[i])-lower_bound(all(A),B[i]);\n\t\t\tlng b=upper_bound(all(B),B[i])-B.begin()-i;\n\t\t\tres-=a*b*b;\n\t\t\tres+=b*(b-1)/2*a;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef __ASD__\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#else\n\t//freopen(TASKA\".in\", \"r\", stdin); freopen(TASKA\".out\", \"w\", stdout);\n#endif\n\t\n\tlng L;\n\tint n;\n\tcin>>L>>n;\n\tvector<lng> A,B;\n\tforn(i,n){\n\t\tint s,x;\n\t\tscanf(\"%d%d\",&s,&x);\n\t\tif(s)\n\t\t\tB.pb(x);\n\t\telse\n\t\t\tA.pb(x);\n\t}\n\tsort(all(A));\n\tsort(all(B));\n\t\n\tif(!sz(A))\n\t\tswap(A,B);\n\tif(!sz(B)){\n\t\tif(A[0]==A.back()){\n\t\t\tcout<<1LL*sz(A)*(sz(A)-1)*(sz(A)-2)/6;\n\t\t\treturn 0;\n\t\t}\n\t\tlng c1=A.end()-lower_bound(all(A),A.back());\n\t\tlng c2=upper_bound(all(A),A.front())-A.begin();\n\t\tlng res=c1*c2*(sz(A)-c1-c2);\n\t\tres+=c1*(c1-1)/2*c2;\n\t\tres+=c2*(c2-1)/2*c1;\n\t\tcout<<res;\n\t\treturn 0;\n\t}\n\t\n\tif(A[0]>B[0])\n\t\tswap(A,B);\n\t\n\tif(A.back()<B.front()){\n\t\tlng c1=A.end()-lower_bound(all(A),A.back());\n\t\tlng c2=upper_bound(all(B),B.front())-B.begin();\n\t\tlng res =c1*(c2*(c2-1)/2+c2*(sz(B)-c2));\n\t\t    res+=c2*(c1*(c1-1)/2+c1*(sz(A)-c1));\n\t\tcout<<res;\n\t\treturn 0;\n\t}\n\t\n\tcout<<doit(A,B)+doit(B,A);\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math",
        "two pointers"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Hamming Triples.json",
    "editorial_link": "https://codeforces.com//blog/entry/11186",
    "editorial": "Letâs look at the Hamming graph of all possible distinct strings, where\r\neach two strings are connected by an edge with length equal to the\r\nHamming distance between these strings. We can observe that this graph\r\nhas a nice property: if we arrange the vertices cyclically as a regular\r\n-gon with a side length of 1, then the Hamming distance between two\r\nstrings is the length of the shortest route between these vertices on\r\nthe perimeter of the polygon. For example, the figure shows the graph\r\nfor . The gray edges have length 1, the orange edges have length 2 and\r\nthe blue edges have length 3. That is the corresponding Hamming\r\ndistance. Now, we can convert each string coded by a pair to an integer\r\n. The new numbers will be 0, 1, ..., and correspond to the same cyclical\r\norder on the perimeter of the polygon. The given strings are mapped to\r\nsome subset of the vertices. Now we have to find the number of triangles\r\n(possibly degenerate) with maximal perimeter in this subgraph. It will\r\nbe useful to keep the new converted numbers sorted. First, we can figure\r\nout what this perimeter could be. If there exists a diameter in the full\r\ngraph, so that all of the points are on one side of the diameter, the\r\nperimeter is , where is the length of the longest edge: Then any\r\ntriangle with two vertices at the longest edge points and the third one\r\nbeing any point has the maximal perimeter. Since the numbers are sorted,\r\nthe longest edge in this case will be produced by two cyclically\r\nadjacent elements, which is not hard to find. If for any diameter this\r\ndoes not hold, then the maximal perimeter is . This can be proved by\r\ntaking two different points , and drawing two diameters with them as\r\nendpoints; since it is not the previous case, there shoud be a third\r\npoint in area where the perimeter of triangle , , is . The tricky part\r\nis to count the triples in this case. We do this by working with the\r\ndiameter . There can be several cases: One only needs to be careful with\r\nthe formulas in each case. Solution complexity: , because of the\r\nsorting.\r\n",
    "hint": []
}