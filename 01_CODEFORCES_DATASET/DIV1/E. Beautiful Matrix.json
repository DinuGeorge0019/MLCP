{
    "link": "https://codeforces.com//contest/1086/problem/E",
    "problemId": "273655",
    "problem_idx": "E",
    "shortId": "1086E",
    "contest_number": "1086",
    "problem_submissions": {
        "F": [
            47429292,
            47449995,
            47444202
        ],
        "E": [
            47422474,
            47423961,
            47424550,
            47426933,
            47428109,
            47426232,
            47427511,
            47426695,
            47427218,
            47427849,
            47427630,
            47511510,
            47428346,
            47425158,
            47429712,
            47428661,
            47421857,
            47429322,
            47440462,
            63950917
        ],
        "D": [
            47415205,
            47413571,
            47418835,
            47417078,
            47414191,
            47418078,
            47418526,
            47419686,
            47418954,
            47419229,
            47421725,
            47466322,
            47418774,
            47416004,
            47420225,
            47422460,
            47411471,
            47420807,
            47421473,
            47423600,
            47420881
        ],
        "C": [
            47410346,
            47408923,
            47412203,
            47411518,
            47409578,
            47407257,
            47412943,
            47414708,
            47412730,
            47413883,
            47416006,
            47414439,
            47428921,
            47417547,
            47419740,
            47412059,
            47415581,
            47415787
        ],
        "B": [
            47402010,
            47400574,
            47400073,
            47401453,
            47402762,
            47411548,
            47405929,
            47406096,
            47405616,
            47407353,
            47404186,
            47400750,
            47404258,
            47404681,
            47402882,
            47426003,
            47408582,
            47404099,
            47404538,
            47406586
        ],
        "A": [
            47400483,
            47400094,
            47413170,
            47400357,
            47400599,
            47410258,
            47403179,
            47403378,
            47401193,
            47402951,
            47401486,
            47403915,
            47400561,
            47403260,
            47400323,
            47425175,
            47409292,
            47400702,
            47401450,
            47402988
        ]
    },
    "name": "E. Beautiful Matrix",
    "statement": "Petya collects matrix.A matrix of size n\r\ntimes n is if: All elements of the matrix are integers between 1 and n;\r\nFor every row of the matrix, all elements of this row are different; For\r\nevery pair of vertically adjacent elements, these elements are\r\ndifferent. Today Petya bought a matrix a of size n\r\ntimes n, and now he wants to determine its rarity.The rarity of the\r\nmatrix is its index in the list of matrices of size n\r\ntimes n, sorted in lexicographical order. Matrix comparison is done row\r\nby row. (The index of lexicographically smallest matrix is ).Since the\r\nnumber of matrices may be huge, Petya wants you to calculate the rarity\r\nof the matrix a modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct Tree {\n  int Base;\n  vector<int> data;\n\n  Tree(int N) : Base(1) {\n    while (Base < N + 2) { Base *= 2; }\n    data.resize(Base * 2);\n  }\n\n  void Add(int v, int p) {\n    v += Base;\n    while (v) {\n      data[v] += p;\n      v /= 2;\n    }\n  }\n\n  int GetSum(int L, int R) {\n    if (L > R) { return 0; }\n    L += Base; R += Base;\n    if (L == R) { return data[L]; }\n    int ans = data[L] + data[R];\n\n    while (L / 2 != R / 2) {\n      if (L % 2 == 0) { ans += data[L + 1]; }\n      if (R % 2 == 1) { ans += data[R - 1]; }\n      L /= 2; R /= 2;\n    }\n    return ans;\n  }\n};\n\nconst int MaxN = 2048;\nconst int Mod = 998'244'353;\n\nint N;\nint matrix[MaxN][MaxN];\nint derang[MaxN][MaxN];\n\nint PowMod(int a, int n) {\n  int r = 1;\n  while (n) {\n    if (n & 1) { r = (LL)r * a % Mod; }\n    n >>= 1;\n    a = (LL)a * a % Mod;\n  }\n  return r;\n}\n\nvoid MakeDerangements() {\n  derang[0][0] = 1;\n  derang[1][0] = 1;\n  derang[1][1] = 0;\n\n  for (int n = 2; n <= N; ++n) {\n    derang[n][0] = ((LL)derang[n - 1][0] * n) % Mod;\n\n    for (int k = 1; k <= n; ++k) {\n      derang[n][k] = (LL)(k - 1) * derang[n - 1][k - 1] % Mod;\n      derang[n][k] = (derang[n][k] + (LL)(n - k) * derang[n - 1][k]) % Mod;\n      derang[n][k] = (derang[n][k] + (LL)(n - k) * derang[n - 2][k - 1]) % Mod;\n      if (k >= 2) {\n        derang[n][k] = (derang[n][k] + (LL)(k - 1) * derang[n - 2][k - 2]) % Mod;\n      }\n      assert(derang[n][k] >= 0);\n    }\n  }\n}\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < N; ++j)\n      cin >> matrix[i][j];\n\n  MakeDerangements();\n\n  debug(derang[2][0]);\n  debug(derang[2][1]);\n  debug(derang[2][2]);\n  debug(derang[3][3]);\n\n  int answer = 0;\n\n  Tree full_tree(N + 1);\n  for (int i = 1; i <= N; ++i)\n    full_tree.Add(i, 1);\n\n  for (int row = 0; row < N; ++row) {\n    const int row_coef = PowMod(derang[N][N], N - row - 1);\n    debug(row, row_coef);\n\n    vector<bool> is_seen(N + 1);\n    vector<bool> is_top(N + 1);\n    if (row) {\n      for (int j = 1; j <= N; ++j)\n        is_top[j] = true;\n    }\n\n    int occur_right = row ? N : 0;\n\n    Tree right_occur = full_tree;\n    Tree right_nooccur(N + 1);\n\n\n    if (!row) {\n      swap(right_occur, right_nooccur);\n    }\n\n    for (int col = 0; col < N; ++col) {\n      const int val = matrix[row][col];\n      debug(right_occur.GetSum(0, 2));\n      \n      int num_decr = right_occur.GetSum(0, val - 1);\n      int num_nodecr = right_nooccur.GetSum(0, val - 1);\n      assert(num_decr >= 0);\n      if (row && val > matrix[row - 1][col] && !is_seen[matrix[row - 1][col]]) {\n        --num_decr;\n      }\n      int decr_base = row ?\n        occur_right - !is_seen[matrix[row - 1][col]] : 0;\n      int decr_mod = max<int>(0, decr_base - 1);\n\n      assert(decr_base >= 0);\n\n      int coef =\n        ((LL)num_decr * derang[N - col - 1][decr_mod] +\n         (LL)num_nodecr * derang[N - col - 1][decr_base]) % Mod;\n\n      debug(row, col, coef, num_decr, num_nodecr, decr_base, decr_mod);\n\n      answer = (answer + (LL)row_coef * coef) % Mod;\n\n      is_seen[val] = true;\n      if (is_top[val]) {\n        debug(\"SubOccur\", val);\n        right_occur.Add(val, -1);\n      } else {\n        right_nooccur.Add(val, -1);\n      }\n\n      if (row) {\n        const int top = matrix[row - 1][col];\n        is_top[top] = false;\n        if (!is_seen[top]) {\n          debug(\"SubOccur\", top);\n          right_occur.Add(top, -1);\n          right_nooccur.Add(top, 1);\n        }\n      }\n\n      occur_right = decr_base;\n      if (is_top[val]) {\n        --occur_right;\n      }\n      assert(occur_right >= 0);\n\n      debug(answer);\n    }\n  }\n\n  cout << answer << \"\\n\";\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dp"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Beautiful Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/64078",
    "editorial": "Calculate the following dp: the number of permutations of length of\r\nelements such that for every ;Calculate the following dp: the number of\r\npermutations of length of elements such that ;We can follow the usual\r\nprocess of recovering the lexicographic index. Iterate over the element\r\nto put in the current position and add the number of ways to complete\r\nthe matrix to the answer.How to calculate the number of ways to complete\r\nthe matrix?The current row can be completed the following way:Look at\r\nthe elements of the previous row (the same suffix as the one we want to\r\ncomplete), renumerate its elements into , where is the length of suffix.\r\nThe current row now incudes some elements which appeared in the suffix\r\nof the previous row and some which donât. Letâs renumerate those that\r\nappeared correspondingly. Let there be of such elements. Then the number\r\nof ways to complete the row is .The other rows can be completed the\r\nfollowing way:For any row the previous one can be renumerated into\r\npermutation of form , thus the number of ways to choose the current row\r\nis .The only thing left is to raise to the power of the number of rows\r\nto be completed.That solution is as we were looking into all the\r\ncandidates for the current position. However, these candidates can be\r\nsplit up into two groups: those that change the value of by 1 and those\r\nthat leave it as is. Thus a single cell can be processed in with a\r\ncouple of data structures.\r\n",
    "hint": []
}