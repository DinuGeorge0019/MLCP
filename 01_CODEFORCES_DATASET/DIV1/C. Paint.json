{
    "link": "https://codeforces.com//contest/1572/problem/C",
    "problemId": "1113065",
    "problem_idx": "C",
    "shortId": "1572C",
    "contest_number": "1572",
    "problem_submissions": {
        "E": [
            129206504,
            129205064,
            129206146,
            129186931,
            129254910,
            129870976,
            129204851
        ],
        "B": [
            129200222,
            129195364,
            129193573,
            129181375,
            129193456,
            129190984,
            129205791,
            129198794,
            129201998,
            129193078,
            129214920,
            129184305,
            129194122,
            129185643,
            129187972,
            129190794,
            129186099,
            129191410,
            129188216
        ],
        "C": [
            129195835,
            129191513,
            129199311,
            129193150,
            129195181,
            129198867,
            129196979,
            129259448,
            129179785,
            129722486,
            129198454,
            129198079,
            129197696,
            129199887,
            129197773,
            129211811,
            129200276
        ],
        "D": [
            129192769,
            129199613,
            129201627,
            129206390,
            129205002,
            129205082,
            129227304,
            129328372,
            129201185,
            129870962,
            129870944,
            129203066,
            129316237,
            129316188,
            136814393,
            129429191
        ],
        "A": [
            129167164,
            129167977,
            129198411,
            129169285,
            129180189,
            129173821,
            129177103,
            129171630,
            129176985,
            129172424,
            129196280,
            129167530,
            129169791,
            129170025,
            129173030,
            129174006,
            129171850,
            129174559,
            129177053
        ],
        "F": [
            129209583,
            129209541,
            129208785,
            129202453,
            129198897,
            129722539,
            129216893,
            129216152,
            129193790,
            129338264
        ]
    },
    "name": "C. Paint",
    "statement": "You are given a 1 by n pixel image. The i-th pixel of the image has\r\ncolor a_i. For each color, the number of pixels of that color is 20.You\r\ncan perform the following operation, which works like the bucket tool in\r\npaint programs, on this image: pick a color an integer from 1 to n;\r\nchoose a pixel in the image; for all pixels connected to the selected\r\npixel, change their colors to the selected color (two pixels of the same\r\ncolor are considered connected if all the pixels between them have the\r\nsame color as those two pixels). Compute the minimum number of\r\noperations needed to make all the pixels in the image have the same\r\ncolor.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 18.09.2021 18:35:24       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      --a[i];\n    }\n    vector<vector<int>> at(n);\n    for (int i = 0; i < n; i++) {\n      at[a[i]].push_back(i);\n    }\n    vector<vector<int>> dp(n, vector<int>(n));\n    for (int i = n - 1; i >= 0; i--) {\n      for (int j = i; j < n; j++) {\n        dp[i][j] = (i == j ? 1 : dp[i + 1][j] + 1);\n        for (int k : at[a[i]]) {\n          if (k > i && k <= j) {\n            int cur = (i + 1 <= k - 1 ? dp[i + 1][k - 1] : 0);\n            cur += dp[k][j];\n            dp[i][j] = min(dp[i][j], cur);\n          }\n        }\n      }\n    }\n    cout << dp[0][n - 1] - 1 << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Paint.json",
    "editorial_link": "https://codeforces.com//blog/entry/95086",
    "editorial": "Firstly, we can notice that when we modify a segment of the form and\r\nchange it to by performing the operation on the second element, as\r\nopposed to performing the operation first on the third element and then\r\non the second element (like so ) we avoid using one unnecessary\r\noperation. In our solution we will try to maximize the number of\r\noperations that we didnât have to perform.Let be the maximum number of\r\noperations that we can avoid on the interval from to , while making all\r\nof its elements have the same color. Then the answer to the problem will\r\nbe . For we have and for will be the maximum of and over such that .\r\nItâs because we can either not save any operations on the -th element\r\nand just take the answer from the interval or we can save one operation\r\nwhile coloring the segment from to and take the answer from segments and\r\n. Because each color occurs in at most times, we can calculate this in\r\nwhich is also our final time complexity.\r\n",
    "hint": []
}