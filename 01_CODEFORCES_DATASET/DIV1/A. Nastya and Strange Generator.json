{"link": "https://codeforces.com//contest/1340/problem/A", "problemId": "599365", "problem_idx": "A", "shortId": "1340A", "contest_number": "1340", "problem_submissions": {"F": [77861280, 77852254, 77849797, 78528429, 78527982, 77845721, 77870771, 77870728, 77870667, 77809735, 77844929, 78038847, 77865877, 77864401, 77864363, 77862346, 77862326], "D": [77814886, 77820644, 77812632, 77817969, 78526970, 77818222, 77825103, 77825677, 77810183, 77803432, 77810910, 77812394, 77816455, 77825551, 77843873, 77828804, 77822663, 77822063], "C": [77795843, 77812380, 77824845, 77823255, 78526952, 77799809, 77811601, 77834672, 77830782, 77811370, 77793451, 77808028, 77797811, 77795450, 77802848, 77796169, 77858001, 77810294, 77809842], "A": [77782251, 77771158, 77774810, 77787508, 78526918, 78526910, 77776379, 77774309, 77776029, 77816613, 77771928, 77777830, 77775868, 77773607, 77771508, 77776009, 77776621, 77773349, 77795835, 77779579, 77772710, 77776861], "B": [77777625, 77796394, 77787259, 77781233, 78526935, 77868779, 77790975, 77793147, 77821618, 77789026, 77773962, 77770331, 77782427, 77780486, 77790796, 77783960, 77786770, 77783985, 77790124, 77791298, 77788341], "E": [77836196, 77868575, 77868568, 77868546, 77868525, 77868496, 77845628, 77864964, 77846936, 77902183, 77902167, 77902121, 77902068, 77902045, 77901978, 77850099, 77859253, 77828316, 77849841, 77848435, 77856908, 77842257]}, "name": "A. Nastya and Strange Generator", "statement": "Denis bought a mysterious item and it was... Random permutation\r\ngenerator! Denis could not believed his luck.When he arrived home, he\r\nbegan to study how his generator works and learned the algorithm. The\r\nprocess of generating a permutation consists of n steps. At the i-th\r\nstep, a place is chosen for the number i (1\r\nleq i\r\nleq n). The position for the number i is defined as follows: For all j\r\nfrom 1 to n, we calculate r_j the minimum index such that j\r\nleq r_j\r\nleq n, and the position r_j is not yet occupied in the permutation. If\r\nthere are no such positions, then we assume that the value of r_j is not\r\ndefined. For all t from 1 to n, we calculate count_t the number of\r\npositions 1\r\nleq j\r\nleq n such that r_j is defined and r_j = t. Consider the positions that\r\nare still not occupied by permutation and among those we consider the\r\npositions for which the value in the count array is maximum. The\r\ngenerator selects one of these positions for the number i. The generator\r\ncan choose position. Let\u2019s have a look at the operation of the algorithm\r\nin the following example: Let n = 5 and the algorithm has already\r\narranged the numbers 1, 2, 3 in the permutation. Consider how the\r\ngenerator will choose a position for the number 4: The values of r will\r\nbe r = [3, 3, 3, 4,\r\ntimes], where\r\ntimes means an indefinite value. Then the count values will be count =\r\n[0, 0, 3, 1, 0]. There are only two unoccupied positions in the\r\npermutation: 3 and 4. The value in the count array for position 3 is 3,\r\nfor position 4 it is 1. The maximum value is reached only for position\r\n3, so the algorithm will uniquely select this position for number 4.\r\nSatisfied with his purchase, Denis went home. For several days without a\r\nbreak, he generated permutations. He believes that he can come up with\r\nrandom permutations no worse than a generator. After that, he wrote out\r\nthe first permutation that came to mind p_1, p_2,\r\nldots, p_n and decided to find out if it could be obtained as a result\r\nof the generator.Unfortunately, this task was too difficult for him, and\r\nhe asked you for help. It is necessary to define whether the written\r\npermutation could be obtained using the described algorithm if the\r\ngenerator always selects the position Denis needs.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; cin >> N;\n\t\tvector<int> P(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> P[i]; P[i]--;\n\t\t}\n\t\tbool good = true;\n\t\tint curMin = N;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (P[i] < curMin) {\n\t\t\t\tcurMin = P[i];\n\t\t\t} else if (P[i] == P[i-1]+1) {\n\t\t\t\t// still good\n\t\t\t} else {\n\t\t\t\tgood = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (good ? \"Yes\" : \"No\") << '\\n';\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "greedy", "implementation"], "dificulty": "1500", "interactive": false}