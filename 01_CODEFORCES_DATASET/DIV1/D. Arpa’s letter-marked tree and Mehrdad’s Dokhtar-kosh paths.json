{
    "link": "https://codeforces.com//contest/741/problem/D",
    "problemId": "83313",
    "problem_idx": "D",
    "shortId": "741D",
    "contest_number": "741",
    "problem_submissions": {
        "D": [
            22777729,
            22777450,
            22755590,
            22758367,
            22756137,
            22808584,
            22805290,
            22759931,
            22759071,
            22750711,
            22754148,
            22814636,
            47300114,
            22755389,
            22758896,
            22756607,
            22790736,
            22757335,
            22793289
        ],
        "C": [
            22742829,
            22742451,
            22758088,
            22742404,
            22760066,
            22743932,
            22747335,
            22749445,
            22763475,
            22742054,
            22742076,
            22737953,
            22744276,
            22742907,
            22746646
        ],
        "B": [
            22738380,
            22738003,
            22739684,
            22748249,
            22740546,
            22740616,
            22739371,
            22740551,
            22740349,
            22741081,
            22738198,
            22739206,
            22740665,
            22739327,
            22739681,
            22737298,
            22743723,
            22740079,
            22738120,
            22735907
        ],
        "A": [
            22734595,
            22733654,
            22736292,
            22744160,
            22745379,
            22739567,
            22735733,
            22736022,
            22736152,
            22736425,
            22735084,
            22735416,
            22736004,
            22734761,
            22740072,
            22741265,
            22735495,
            22735318,
            22738723
        ],
        "E": [
            22798525
        ]
    },
    "name": "D. Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths",
    "statement": "Arpa has a rooted tree (connected acyclic graph) consisting of vertices.\r\nThe vertices are numbered through , the vertex is the root. There is a\r\nletter written on each edge of this tree. Mehrdad is a fan of things. He\r\ncall a string Dokhtar-kosh, if we can shuffle the characters in string\r\nsuch that it becomes palindrome. He asks Arpa, for each vertex , what is\r\nthe length of the longest simple path in subtree of that form a\r\nDokhtar-kosh string.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=500100,inf=0xe0e0e0e0;\nVI s[N];\nint Hs[(1<<22)+10],tt;\nint n,l[N],r[N],tot,id[N],ret[N],st[N],p;\nint Qt[N],Q[N][28],dep[N],sz[N],ms[N],mv[N];\nchar c;\nvoid upd(int &a,int b) { if (a<b) a=b;}\nvoid dfs(int u) {\n\tsz[u]=Qt[u]; ms[u]=-1;\n\tfor (auto v:s[u]) {\n\t\tdep[v]=dep[u]+1;\n\t\tdfs(v); sz[u]+=sz[v];\n\t\tif (ms[u]==-1||sz[ms[u]]<sz[v]) ms[u]=v;\n\t}\n}\nvoid solve(int u) {\n\tid[l[u]=++tot]=u;\n\tfor (auto v:s[u]) if (v!=ms[u]) {\n\t\tsolve(v);\n\t\trep(j,l[v],r[v]+1) mv[Q[id[j]][0]]=inf;\n\t\tret[u]=max(ret[u],ret[v]);\n\t}\n\tif (ms[u]>0) {\n\t\tsolve(ms[u]);\n\t\tret[u]=max(ret[u],ret[ms[u]]);\n\t}\n\tr[u]=tot;\n\tint tmp=0;\n\tfor (auto v:s[u]) if (v!=ms[u]) {\n\t\trep(j,l[v],r[v]+1) rep(k,0,Qt[id[j]]) tmp=max(tmp,mv[Q[id[j]][k]]+dep[id[j]]);\n\t\trep(j,l[v],r[v]+1) upd(mv[Q[id[j]][0]],dep[id[j]]);\n\t}\n\trep(k,0,Qt[u]) tmp=max(tmp,mv[Q[u][k]]+dep[u]);\n\tupd(mv[Q[u][0]],dep[u]);\n\tret[u]=max(ret[u],tmp-2*dep[u]);\n} \nint main() {\n\tscanf(\"%d\",&n);\n\tHs[st[1]]=++tt;\n\trep(i,2,n+1) {\n\t\tscanf(\"%d %c\",&p,&c);\n\t\tst[i]=st[p]^(1<<(c-'a'));\n\t\ts[p].pb(i);\n\t\tif (Hs[st[i]]==0) Hs[st[i]]=++tt;\n\t}\n\trep(i,1,n+1) {\n\t\tQ[i][Qt[i]++]=Hs[st[i]];\n\t\trep(j,0,22) if (Hs[st[i]^(1<<j)]) Q[i][Qt[i]++]=Hs[st[i]^(1<<j)];\n\t}\n\tmemset(mv,0xe0,sizeof(mv));\n\tdfs(1);\n\tsolve(1);\n\trep(i,1,n+1) printf(\"%d \",ret[i]);\n\tputs(\"\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths.json",
    "editorial_link": "https://codeforces.com//blog/entry/48871",
    "editorial": "Please read my dsu on tree (sack) tutorial before you read.Let s\r\ncalculate for each vertex such , length of longest Dokhtar-kosh path\r\nthat starts in some vertex of subtree of , passes from , and ends in\r\nsome other vertex of subtree of using sack (explained below); then we\r\ncan sum up this values and get answer for each vertex.First keep a mask\r\nfor each vertex, -th bit of is if the number of edges on the path from\r\nthe root to such that the letter is written on them is odd. Now if the\r\nnumber of bits in is or , the path between and is Dokhtar-kosh.Let s use\r\nsack, assume is the maximum height for a vertex that is present in our\r\nsack and its is equal to .Let s define two functions used in sack:( ) :\r\nIf is less than , set . ( , ) : For each such that has at most one bit,\r\nupdate the , with (updating means if is less than , set to it).Suppose\r\ndfs function arrives to vertex . Call dfs for each child of except the\r\nbiggest one (which has more vertices in its subtree than others) and\r\nclear the sack each time. Call dfs for big child of and don t clear the\r\nsack. Then for each other child and for each vertex , call . Then for\r\neach vertex , call . After the addition of the children is done, call\r\nand . Now the answer for this vertex is .To clear the sack, for each\r\nvertex set (i.e. ) and set to 0.Note that there exists another solution\r\nusing centroid decomposition, but it s harder.Time complexity: ( is\r\nnumber of characters which is equal to 22).Corner case: You must use an\r\narray, no map or unordered map for , these solutions got TLE.\r\n",
    "hint": []
}