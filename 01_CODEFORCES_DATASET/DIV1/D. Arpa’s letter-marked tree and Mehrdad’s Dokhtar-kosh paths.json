{"link": "https://codeforces.com//contest/741/problem/D", "problemId": "83313", "problem_idx": "D", "shortId": "741D", "contest_number": "741", "problem_submissions": {"D": [22777729, 22777450, 22755590, 22758367, 22756137, 22808584, 22805290, 22759931, 22759071, 22750711, 22754148, 22814636, 47300114, 22755389, 22758896, 22756607, 22790736, 22757335, 22793289], "C": [22742829, 22742451, 22758088, 22742404, 22760066, 22743932, 22747335, 22749445, 22763475, 22742054, 22742076, 22737953, 22744276, 22742907, 22746646], "B": [22738380, 22738003, 22739684, 22748249, 22740546, 22740616, 22739371, 22740551, 22740349, 22741081, 22738198, 22739206, 22740665, 22739327, 22739681, 22737298, 22743723, 22740079, 22738120, 22735907], "A": [22734595, 22733654, 22736292, 22744160, 22745379, 22739567, 22735733, 22736022, 22736152, 22736425, 22735084, 22735416, 22736004, 22734761, 22740072, 22741265, 22735495, 22735318, 22738723], "E": [22798525]}, "name": "D. Arpa\u2019s letter-marked tree and Mehrdad\u2019s Dokhtar-kosh paths", "statement": "Arpa has a rooted tree (connected acyclic graph) consisting of vertices.\r\nThe vertices are numbered through , the vertex is the root. There is a\r\nletter written on each edge of this tree. Mehrdad is a fan of things. He\r\ncall a string Dokhtar-kosh, if we can shuffle the characters in string\r\nsuch that it becomes palindrome. He asks Arpa, for each vertex , what is\r\nthe length of the longest simple path in subtree of that form a\r\nDokhtar-kosh string.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=500100,inf=0xe0e0e0e0;\nVI s[N];\nint Hs[(1<<22)+10],tt;\nint n,l[N],r[N],tot,id[N],ret[N],st[N],p;\nint Qt[N],Q[N][28],dep[N],sz[N],ms[N],mv[N];\nchar c;\nvoid upd(int &a,int b) { if (a<b) a=b;}\nvoid dfs(int u) {\n\tsz[u]=Qt[u]; ms[u]=-1;\n\tfor (auto v:s[u]) {\n\t\tdep[v]=dep[u]+1;\n\t\tdfs(v); sz[u]+=sz[v];\n\t\tif (ms[u]==-1||sz[ms[u]]<sz[v]) ms[u]=v;\n\t}\n}\nvoid solve(int u) {\n\tid[l[u]=++tot]=u;\n\tfor (auto v:s[u]) if (v!=ms[u]) {\n\t\tsolve(v);\n\t\trep(j,l[v],r[v]+1) mv[Q[id[j]][0]]=inf;\n\t\tret[u]=max(ret[u],ret[v]);\n\t}\n\tif (ms[u]>0) {\n\t\tsolve(ms[u]);\n\t\tret[u]=max(ret[u],ret[ms[u]]);\n\t}\n\tr[u]=tot;\n\tint tmp=0;\n\tfor (auto v:s[u]) if (v!=ms[u]) {\n\t\trep(j,l[v],r[v]+1) rep(k,0,Qt[id[j]]) tmp=max(tmp,mv[Q[id[j]][k]]+dep[id[j]]);\n\t\trep(j,l[v],r[v]+1) upd(mv[Q[id[j]][0]],dep[id[j]]);\n\t}\n\trep(k,0,Qt[u]) tmp=max(tmp,mv[Q[u][k]]+dep[u]);\n\tupd(mv[Q[u][0]],dep[u]);\n\tret[u]=max(ret[u],tmp-2*dep[u]);\n} \nint main() {\n\tscanf(\"%d\",&n);\n\tHs[st[1]]=++tt;\n\trep(i,2,n+1) {\n\t\tscanf(\"%d %c\",&p,&c);\n\t\tst[i]=st[p]^(1<<(c-'a'));\n\t\ts[p].pb(i);\n\t\tif (Hs[st[i]]==0) Hs[st[i]]=++tt;\n\t}\n\trep(i,1,n+1) {\n\t\tQ[i][Qt[i]++]=Hs[st[i]];\n\t\trep(j,0,22) if (Hs[st[i]^(1<<j)]) Q[i][Qt[i]++]=Hs[st[i]^(1<<j)];\n\t}\n\tmemset(mv,0xe0,sizeof(mv));\n\tdfs(1);\n\tsolve(1);\n\trep(i,1,n+1) printf(\"%d \",ret[i]);\n\tputs(\"\");\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "trees"], "dificulty": "2900", "interactive": false}