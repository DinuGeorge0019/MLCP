{
    "link": "https://codeforces.com//contest/840/problem/A",
    "problemId": "118956",
    "problem_idx": "A",
    "shortId": "840A",
    "contest_number": "840",
    "problem_submissions": {
        "E": [
            29579983,
            29579804,
            29577664,
            29579379,
            30931404,
            29639075,
            29617435,
            29681440,
            29681407,
            29681392,
            29681366
        ],
        "D": [
            29572451,
            29573549,
            29574893,
            29644417,
            29644402,
            29595162,
            29575013,
            29575646,
            29572436,
            29576887,
            29575628,
            29572554,
            29567189,
            29575551,
            29574764,
            29578191,
            29654756,
            29591307,
            29590747,
            29590681,
            29590673,
            29590627,
            29571509,
            29577552,
            29578628,
            29580062
        ],
        "C": [
            29567872,
            29569558,
            29567683,
            29569063,
            29562508,
            29569694,
            29567877,
            29577113,
            29566790,
            29572424,
            29577847,
            29579952,
            29584687,
            29571506,
            29571448,
            29570686,
            29578919,
            29571629,
            29571512,
            29569311
        ],
        "B": [
            29561393,
            29563952,
            29561789,
            29563624,
            29569083,
            29562635,
            29573313,
            29563716,
            29576058,
            29565857,
            29562483,
            29571100,
            29573859,
            29577034,
            29563154,
            29568606,
            29568725,
            29563595,
            29562462
        ],
        "A": [
            29557063,
            29560856,
            29557654,
            29557167,
            29564205,
            29559452,
            29556856,
            29560188,
            29575932,
            29562655,
            29557325,
            29559317,
            29562250,
            29559768,
            29556972,
            29558958,
            29556622,
            29557880,
            29558266
        ]
    },
    "name": "A. Leha and Function",
    "statement": "Leha like all kinds of strange things. Recently he liked the function .\r\nConsider all possible -element subsets of the set . For subset find\r\nminimal element in it. mathematical expectation of the minimal element\r\namong all -element subsets.But only function does not interest him. He\r\nwants to do interesting things with it. Mom brought him two arrays and ,\r\neach consists of integers. For all such that the condition holds. Help\r\nLeha rearrange the numbers in the array so that the sum is maximally\r\npossible, where is already rearranged array.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tvector<int> A(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d\", &A[i]);\n\t\tvector<int> B(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d\", &B[i]);\n\t\tvpii Ais(n), Bis(n);\n\t\trep(i, n) {\n\t\t\tAis[i] = { A[i], i };\n\t\t\tBis[i] = { B[i], i };\n\t\t}\n\t\tsort(Ais.begin(), Ais.end());\n\t\tsort(Bis.begin(), Bis.end());\n\t\tvector<int> ans(n);\n\t\trep(i, n)\n\t\t\tans[Bis[i].second] = Ais[n - 1 - i].first;\n\t\tfor (int i = 0; i < (int)ans.size(); ++ i) {\n\t\t\tif (i != 0) putchar(' ');\n\t\t\tprintf(\"%d\", ans[i]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "greedy",
        "math",
        "number theory",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Leha and Function.json",
    "editorial_link": "https://codeforces.com//blog/entry/53943?locale=en",
    "editorial": "First of all, let's understand what is the value of F(N,?K).\nFor any subset of size K, say, a1,?a2...aK, we can represent it as a sequence of numbers d1,?d2...dK?+?1, so that d1?=?a1, d1?+?d2?=?a2, ..., .\nWe're interested in E[d1], expected value of d1. Knowing some basic facts about expected values, we can derive the following:\nE[d1?+?...?+?dK?+?1]?=?N?+?1\nE[d1]?+?...?+?E[dK?+?1]?=?(K?+?1)\u00b7E[d1]\nAnd we immediately get that .\nWe could also get the formula by using the Hockey Stick Identity, as Benq stated in his comment.\nNow, according to rearrangement inequality,  is maximized when A is increasing and B is decreasing."
}