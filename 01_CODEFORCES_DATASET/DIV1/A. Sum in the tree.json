{
    "link": "https://codeforces.com//contest/1098/problem/A",
    "problemId": "278460",
    "problem_idx": "A",
    "shortId": "1098A",
    "contest_number": "1098",
    "problem_submissions": {
        "E": [
            51775559,
            48006690,
            48011091,
            47996318,
            48015799,
            48015745,
            48015679,
            48016465
        ],
        "D": [
            47994331,
            47991784,
            48004915,
            47986667,
            47997263,
            47997207,
            47997823,
            48003406,
            48012772,
            48000542,
            48002246,
            47998686,
            48003172,
            48003847,
            48013739,
            48013700,
            48013652,
            48012961,
            48012955,
            48007481,
            48004946,
            47998449,
            48006927,
            47993907
        ],
        "C": [
            47990851,
            47988182,
            48002088,
            47984104,
            47990986,
            47992891,
            47990373,
            47996864,
            47993728,
            47992046,
            48002685,
            47997828,
            47997416,
            47983441,
            47996246,
            48004923,
            47992474,
            48000276
        ],
        "B": [
            47984141,
            47982505,
            48010238,
            47997345,
            47983353,
            47986135,
            47985242,
            47985258,
            47997818,
            47982827,
            47991394,
            47990410,
            47990108,
            47991143,
            47984918,
            47988149,
            47999187,
            48005571
        ],
        "A": [
            47975157,
            47974213,
            48009223,
            47974115,
            47975580,
            47975415,
            47977674,
            47976551,
            47976714,
            47995866,
            47975779,
            47977103,
            47975994,
            47986982,
            47978302,
            47975716,
            47976034,
            47978693
        ],
        "F": [
            54648301
        ]
    },
    "name": "A. Sum in the tree",
    "statement": "Mitya has a rooted tree with n vertices indexed from 1 to n, where the\r\nroot has index 1. Each vertex v initially had an integer number a_v\r\nge 0 written on it. For every vertex v Mitya has computed s_v: the sum\r\nof all values written on the vertices on the path from vertex v to the\r\nroot, as well as h_v the depth of vertex v, which denotes the number of\r\nvertices on the path from vertex v to the root. Clearly, s_1=a_1 and\r\nh_1=1.Then Mitya erased all numbers a_v, and by accident he also erased\r\nall values s_v for vertices with even depth (vertices with even h_v).\r\nYour task is to restore the values a_v for every vertex, or determine\r\nthat Mitya made a mistake. In case there are multiple ways to restore\r\nthe values, you’re required to find one which minimizes the total sum of\r\nvalues a_v for all vertices in the tree.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvi drz[nax];\nint oj[nax];\n\nll tab[nax];\n\nvoid nope()\n{\n\tprintf(\"-1\\n\");\n\texit(0);\n}\n\nll wyn;\n\nvoid dfs(int v, ll w)\n{\n\tif (tab[v]==-1)\n\t{\n\t\ttab[v]=w;\n\t\tif (!drz[v].empty())\n\t\t{\n\t\t\tfor (int i : drz[v])\n\t\t\t\tif (tab[i]<w)\n\t\t\t\t\tnope();\n\t\t\ttab[v]=tab[drz[v][0]];\n\t\t\tfor (int i : drz[v])\n\t\t\t\ttab[v]=min(tab[v], tab[i]);\n\t\t}\n\t}\n\tif (tab[v]<w)\n\t\tnope();\n\tw=tab[v];\n\twyn+=tab[v]-tab[oj[v]];\n\tfor (int i : drz[v])\n\t\tdfs(i, w);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tdrz[a].push_back(i);\n\t\toj[i]=a;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &tab[i]);\n\tdfs(1, 0);\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Sum in the tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/64331",
    "editorial": "To achieve the minimum possible sum of values in the tree, for vertices with even depth we need to put 0 for leaves and the maximum value possible for other vertices, because increasing the value does not make the resulting sum worse  our children would compensate for it. Since av?0\n, it's obvious that spv?spv+av=sv\n. For every child u\n of vertex v\n it's also true that sv?su\n, hence spv?sv?su\n. From this one can derive that the maximum possible av\n for vertices with even hv\n equals minu ? child vsu?spv\n.\n\nGiven the values av\n in the vertices of even depth, we can restore the values in the vertices of odd depth using the formula av=sv?spv\n. This requires a simple DFS (which translated to a for-loop given the tree representation in the problem statement).",
    "hint": []
}