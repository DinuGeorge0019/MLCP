{
    "link": "https://codeforces.com//contest/1322/problem/F",
    "problemId": "555658",
    "problem_idx": "F",
    "shortId": "1322F",
    "contest_number": "1322",
    "problem_submissions": {
        "E": [
            72651847,
            72667619,
            72663863,
            81989702,
            73455963,
            72654927,
            72662345,
            72661386,
            72662000,
            72646344
        ],
        "D": [
            72644625,
            72640728,
            72645597,
            72646886,
            72650508,
            72648101,
            72647799,
            73117806,
            72646593,
            73115826,
            72647714,
            72648983,
            72649173,
            72652083,
            72650733,
            72645310,
            72649530,
            72653676,
            72654635,
            72652516
        ],
        "C": [
            72636777,
            72636963,
            72637518,
            72639394,
            72637388,
            72638096,
            72639734,
            73117801,
            72640343,
            72640613,
            72638032,
            72638943,
            72642117,
            72644813,
            72641527,
            72650551,
            72650396,
            72639973,
            72642914,
            72642962,
            72643894
        ],
        "B": [
            72630406,
            72634706,
            72633179,
            72634815,
            72634956,
            72641590,
            72633350,
            73117683,
            72635692,
            72635442,
            72633727,
            72635100,
            72639222,
            72636092,
            72637879,
            72655301,
            72636262,
            72636039,
            72637209,
            72638209,
            72636501
        ],
        "A": [
            72628149,
            72629253,
            72629705,
            72631540,
            72628375,
            72630668,
            72629135,
            73117511,
            72629708,
            72630674,
            72628794,
            72628291,
            72630330,
            72629133,
            72629728,
            72647587,
            72628383,
            72631203,
            72630004,
            72630007,
            72628407
        ],
        "F": [
            74191172,
            73465587,
            77378072,
            77728968
        ]
    },
    "name": "F. Assigning Fares",
    "statement": "Mayor of city M. decided to launch several new metro lines during 2020.\r\nSince the city has a very limited budget, it was decided not to dig new\r\ntunnels but to use the existing underground network.The tunnel system of\r\nthe city M. consists of n metro stations. The stations are connected\r\nwith n - 1 bidirectional tunnels. Between every two stations v and u\r\nthere is exactly one simple path. Each metro line the mayor wants to\r\ncreate is a simple path between stations a_i and b_i. Metro lines can\r\nintersects freely, that is, they can share common stations or even\r\ncommon tunnels. However, it\u2019s not yet decided which of two directions\r\neach line will go. More precisely, between the stations a_i and b_i the\r\ntrains will go either from a_i to b_i, or from b_i to a_i, but not\r\nsimultaneously.The city M uses complicated faring rules. Each station is\r\nassigned with a positive integer c_i the fare zone of the station. The\r\ncost of travel from v to u is defined as c_u - c_v roubles. Of course,\r\nsuch travel only allowed in case there is a metro line, the trains on\r\nwhich go from v to u. Mayor doesn\u2019t want to have any travels with a\r\nnegative cost, so it was decided to assign directions of metro lines and\r\nstation fare zones in such a way, that fare zones are strictly\r\nincreasing during any travel on any metro line.Mayor wants firstly\r\nassign each station a fare zone and then choose a lines direction, such\r\nthat all fare zones are increasing along any line. In connection with\r\nthe approaching celebration of the day of the city, the mayor wants to\r\nassign fare zones so that the maximum c_i will be as low as possible.\r\nPlease help mayor to design a new assignment or determine if it\u2019s\r\nimpossible to do. Please note that you only need to assign the fare\r\nzones optimally, you don\u2019t need to print lines\u2019 directions. This way,\r\nyou solution will be considered correct if there will be a way to assign\r\ndirections of every metro line, so that the fare zones will be strictly\r\nincreasing along any movement of the trains.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define FR first\n#define SE second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\ninline pr merge(pr x,pr y) {\n  return pr(max(x.FR,y.FR),min(x.SE,y.SE));\n}\n\nvector <int> e[500005];\nint fa[500005][20],dep[500005];\n\nvoid dfs1(int x) {\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa[x][0]) {\n    \tint u=e[x][i];\n    \tfa[u][0]=x;dep[u]=dep[x]+1;\n    \tfor(int j=1;j<20;j++) fa[u][j]=fa[fa[u][j-1]][j-1];\n    \tdfs1(u);\n\t}\n}\n\nint lca(int x,int y) {\n  if (dep[x]<dep[y]) swap(x,y);\n  int d=dep[x]-dep[y];\n  for(int i=0;i<20;i++)\n    if ((d>>i)&1) x=fa[x][i];\n  if (x==y) return x;\n  for(int i=19;i>=0;i--)\n    if (fa[x][i]!=fa[y][i]) {\n    \tx=fa[x][i];\n    \ty=fa[y][i];\n\t}\n  return fa[x][0];\n}\n\nint jump(int x,int d) {\n  for(int i=0;i<20;i++)\n    if ((d>>i)&1) x=fa[x][i];\n  return x;\n}\n\nvector <pr> ee[500005];\nint size[500005];\n\nvoid dfs2(int x,int fa) {\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) {\n    \tint u=e[x][i];\n    \tdfs2(u,x);\n    \tsize[x]+=size[u];\n\t}\n  if (size[x]) {\n  \tee[x].push_back(pr(fa,0));\n  \tee[fa].push_back(pr(x,0));\n  }\n}\n\nint col[500005],id[500005];\n\nvoid dfs3(int x) {\n  for(int i=0;i<ee[x].size();i++) {\n  \tint u=ee[x][i].FR;\n  \tif (!id[u]) {\n  \t\tid[u]=id[x];\n  \t\tcol[u]=col[x]^ee[x][i].SE;\n  \t\tdfs3(u);\n\t  }\n\telse if ((col[x]^col[u])!=ee[x][i].SE) {\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n  }\n}\n\npr f[500005],g[500005];\nint vis[500005];\n\nbool dfs4(int x,int fa,int k) {\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) {\n    \tint u=e[x][i];\n    \tif (!dfs4(u,x,k)) return 0;\n\t}\n  f[x]=pr(1,k);\n  int sz=0;\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa&&id[e[x][i]]) {\n    \tint u=e[x][i];\n    \tif (id[u]==id[x]) {\n    \t\tif (!col[u]) f[x]=merge(f[x],pr(1,f[u].SE-1));\n    \t\telse f[x]=merge(f[x],pr(f[u].FR+1,k));\n\t\t}\n\t\telse {\n\t\t\tif (!vis[id[u]]) {\n\t\t\t\tvis[id[u]]=++sz;\n\t\t\t\tg[sz]=pr(1,k);\n\t\t\t}\n\t\t\tint t=vis[id[u]];\n\t\t\tif (!col[u]) g[t]=merge(g[t],pr(1,f[u].SE-1));\n\t\t\telse g[t]=merge(g[t],pr(f[u].FR+1,k));\n\t\t}\n\t}\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) vis[id[e[x][i]]]=0;\n  if (f[x].FR>f[x].SE) return 0;\n  pr u(1,k);\n  for(int i=1;i<=sz;i++) {\n  \tif (g[i].FR>g[i].SE) return 0;\n  \tif (k-g[i].SE+1<g[i].FR) g[i]=pr(k-g[i].SE+1,k-g[i].FR+1);\n  \tu=merge(u,g[i]);\n  }\n  pr t1=merge(u,f[x]),t2=merge(pr(k-u.SE+1,k-u.FR+1),f[x]);\n  if (t1.FR>t1.SE&&t2.FR>t2.SE) return 0;\n  if (t1.FR>t1.SE) f[x]=t2;\n  else if (t2.FR>t2.SE) f[x]=t1;\n  else f[x]=pr(min(t1.FR,t2.FR),max(t1.SE,t2.SE));\n  return 1;\n}\n\nint ans[500005],val[500005];\nbool d[500005];\n\nvoid dfs5(int x,int fa,int k,bool v) {\n  int sz=0;\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa&&id[e[x][i]]!=id[x]) {\n    \tint u=e[x][i];\n\t\tif (!vis[id[u]]) {\n\t\t\tvis[id[u]]=++sz;\n\t\t\tval[sz]=id[u];\n\t\t\tg[sz]=pr(1,k);\n\t\t}\n\t\tint t=vis[id[u]];\n\t\tif (!col[u]) g[t]=merge(g[t],pr(1,f[u].SE-1));\n\t\telse g[t]=merge(g[t],pr(f[u].FR+1,k));\n\t}\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) vis[id[e[x][i]]]=0;\n  for(int i=1;i<=sz;i++) d[val[i]]=((g[i].FR<=ans[x]&&g[i].SE>=ans[x])?0:1);\n  for(int i=0;i<e[x].size();i++)\n    if (e[x][i]!=fa) {\n    \tint u=e[x][i];\n    \tif (!id[u]) {\n    \t\tans[u]=f[u].FR;\n    \t\tdfs5(u,x,k,0);\n\t\t}\n\t\telse {\n\t\t\tbool c=((id[u]==id[x])?v:d[id[u]]);\n\t\t\tif (!c) ans[u]=((!col[u])?f[u].SE:f[u].FR);\n\t\t\telse ans[u]=((col[u])?k-f[u].FR+1:k-f[u].SE+1);\n\t\t\tdfs5(u,x,k,c);\n\t\t}\n\t}\n} \n\nint main() {\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  for(int i=1;i<n;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[x].push_back(y);\n  \te[y].push_back(x);\n  }\n  dfs1(1);\n  for(int i=1;i<=m;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \tint p=lca(x,y),u,v;\n  \tif (p!=x) {\n  \t\tsize[x]++;\n  \t\tsize[u=jump(x,dep[x]-dep[p]-1)]--;\n\t  }\n\tif (p!=y) {\n\t\tsize[y]++;\n\t\tsize[v=jump(y,dep[y]-dep[p]-1)]--;\n\t}\n\tif (p!=x&&p!=y) {\n\t\tee[u].push_back(pr(v,1));\n\t\tee[v].push_back(pr(u,1));\n\t}\n  }\n  dfs2(1,0);\n  int cnt=0;\n  for(int i=2;i<=n;i++)\n    if (!id[i]) {\n    \tid[i]=++cnt;\n    \tdfs3(i);\n\t}\n  int l=1,r=n;\n  while (l<r) {\n  \tint mid=((l+r)>>1);\n    bool v=dfs4(1,0,mid);\n    if (v) r=mid; else l=mid+1;\n  }\n  dfs4(1,0,l);\n  ans[1]=f[1].FR;\n  dfs5(1,0,l,0);\n  printf(\"%d\\n\",l);\n  for(int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n  printf(\"\\n\");\n  return 0;\n} \n/*\n3 1 \n1 2\n1 3\n2 3 \n*/ "
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Assigning Fares.json",
    "editorial_link": "https://codeforces.com//blog/entry/74148",
    "editorial": "Let\u00e2\u0080\u0099s assume is the color of vertex v. So, we need to find a coloring of\r\ntree, where strictly increases along every path.First of all, if\r\ncoloring exists, we can renumerate colors so that they will be in range\r\n[1, ]. Secondly, we can always revert our coloring, make . Also, let\u00e2\u0080\u0099s\r\ndo binary search to find . So, now we want to check if it is possible to\r\npaint tree using colors.Every path can be on of two directions. If we\r\ndetermine direction for path 0, then we also automatically determine\r\ndirection for every path which has common edge with path 0. So, we can\r\nget a components of paths if we choose one path direction, we choose\r\nevery other paths direction. We can notice, that if a single component\r\nis not bipartite, answer is -1. So, for every path, we know it\u00e2\u0080\u0099s\r\ncomponent and it\u00e2\u0080\u0099s orientation inside the component. It can be\r\ncalculated using subtree sum for vertexes and we make +1 for , +1 for ,\r\nand -2 for . Let\u00e2\u0080\u0099s make our tree rooted and then count dp on subtrees.\r\nminimal color of , if all it\u00e2\u0080\u0099s subtree is colored in a correct way and\r\nedge goes from lower to higher color. How to calculate dp?If we fix edge\r\ndirection, for some edges we know the orientation. It happens when they\r\nwere in same component as . For other components, we can or use or\r\ndepending on which direction of component we use. If we will try both\r\nvariants and combine all the constraints, we will get two different\r\nsegments and , and must be in one of them. It can be solved with\r\nscanline in time.Now we can notice that . Let\u00e2\u0080\u0099s think of segments as\r\nabout two left constraints: and . We have two sets and . We either put\r\nor .So, we want these conditions to be done: If we fix what is more or ,\r\nwe get fixed distribuition between and max of and goes to max of two\r\nsets. Then we just need to check conditions and use best of variants.\r\nSolution will have complexity .\r\n"
}