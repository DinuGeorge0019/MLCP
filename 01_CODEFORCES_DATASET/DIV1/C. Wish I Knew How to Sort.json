{"link": "https://codeforces.com//contest/1753/problem/C", "problemId": "1601078", "problem_idx": "C", "shortId": "1753C", "contest_number": "1753", "problem_submissions": {"F": [177651080, 177647555, 177657470, 188911747, 188911656, 188911570, 188911428, 188910549, 188910073, 188909646, 188909166, 188907827, 188904326, 188904190, 188903731, 177833531, 177833492], "E": [177581778, 177583727, 177589838, 177589285, 177593827, 177594409, 177597830, 177594087, 177592707, 177585112, 177601527, 177590220, 177673253, 177974155, 177974124, 177973591, 177724036], "D": [177563465, 177565205, 177564757, 177573155, 177575242, 177580076, 177576436, 177570973, 177566523, 177596897, 177580588, 177604329, 177563352, 177570046, 177566269, 177573602, 177755461, 177576614, 177574911], "C": [177552151, 177550933, 177551820, 177553154, 177551866, 177564888, 177563099, 177563169, 177574479, 177556455, 177565810, 177544648, 177550098, 177548226, 177548338, 177556464, 177755441, 177552144, 177557310], "B": [177547853, 177542169, 177543741, 177547659, 177545799, 177543102, 177548449, 177558513, 177542410, 177547120, 177556897, 177532887, 177540969, 177543956, 177543358, 177547075, 177755409, 177545453, 177551061], "A2": [177545216, 177538464, 177539211, 177543167, 177542984, 177539535, 177544288, 177553832, 177538606, 177548841, 177551155, 177550293, 177537648, 177536071, 177539594, 177543961, 177755345, 177539530, 177545423], "A1": [177533578, 177538639, 177539788, 177537288, 177537340, 177539306, 177543813, 177553991, 177538938, 177533253, 177550897, 177550032, 177537887, 177533119, 177533588, 177544324, 177755312, 177540035, 177546684]}, "name": "C. Wish I Knew How to Sort", "statement": "You are given a binary array a (all elements of the array are 0 or 1) of\r\nlength n. You wish to sort this array, but unfortunately, your\r\nalgorithms teacher forgot to teach you sorting algorithms. You perform\r\nthe following operations until a is sorted: Choose two random indices i\r\nand j such that i < j. Indices are chosen equally probable among all\r\npairs of indices (i, j) such that 1\r\nle i < j\r\nle n. If a_i > a_j, then swap elements a_i and a_j. What is the expected\r\nnumber of such operations you will perform before the array becomes\r\nsorted?It can be shown that the answer can be expressed as an\r\nirreducible fraction\r\nfrac{p}{q}, where p and q are integers and q\r\nnot\r\nequiv 0\r\npmod{998\r\n,244\r\n,353}. Output the integer equal to p\r\ncdot q^{-1}\r\nbmod 998\r\n,244\r\n,353. In other words, output such an integer x that 0\r\nle x < 998\r\n,244\r\n,353 and x\r\ncdot q\r\nequiv p\r\npmod{998\r\n,244\r\n,353}.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int cnt = std::count(a.begin(), a.end(), 0);\n    int bad = std::count(a.begin(), a.begin() + cnt, 1);\n    \n    Z ans = 0;\n    for (int i = 1; i <= bad; i++) {\n        ans += Z(1) / i / i;\n    }\n    ans *= Z(n) * (n - 1) / 2;\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["dp", "math", "probabilities"], "dificulty": "2000", "interactive": false}