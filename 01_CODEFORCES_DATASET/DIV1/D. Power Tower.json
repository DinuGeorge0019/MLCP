{"link": "https://codeforces.com//contest/906/problem/D", "problemId": "140847", "problem_idx": "D", "shortId": "906D", "contest_number": "906", "problem_submissions": {"D": [149029866, 33557818, 33559276, 33563941, 33561236, 33558964, 33560338, 33552737, 33564592, 33555169, 33563596, 33557368, 33574046, 33570274, 33569097, 33952208, 33561210, 33554741, 33558804, 33566104, 33558203, 33550675], "E": [33563788, 51774603, 33570251, 42678760, 33642683, 33642639, 57252155, 33595209], "A": [33559632, 33542429, 33541419, 33540284, 33543709, 33540394, 33541815, 33539940, 33541391, 33544813, 33540734, 33541098, 33542736, 33541277, 33565456, 33540685, 33540110, 33569386], "C": [33554104, 33555026, 33556927, 33558399, 33566145, 33563804, 33559596, 33558825, 33566746, 33569757, 33570264, 33560203, 33561015, 33582668, 33568743, 33550511, 33571601, 33568875, 33565260], "B": [33543854, 33551699, 33549379, 33555394, 33548541, 33552331, 33565116, 33549927, 33571875, 33555675, 33564877, 33554448, 33562774, 33555252, 33583579, 33583372, 33554912, 33572090]}, "name": "D. Power Tower", "statement": "Priests of the Quetzalcoatl cult want to build a tower to represent a\r\npower of their god. Tower is usually made of power-charged rocks. It is\r\nbuilt with the help of rare magic by levitating the current top of tower\r\nand adding rocks at its bottom. If top, which is built from rocks,\r\npossesses power and we want to add the rock charged with power then\r\nvalue of power of a new tower will be . Rocks are added from the last to\r\nthe first. That is for sequence value of power will beAfter tower is\r\nbuilt, its power may be extremely large. But still priests want to get\r\nsome information about it, namely they want to know a number called\r\ncumulative power which is the true value of power taken modulo . Priests\r\nhave rocks numbered from to . They ask you to calculate which value of\r\ncumulative power will the tower possess if they will build it from rocks\r\nnumbered .\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 101000;\nint n, q, m, p[100], a[N], t;\n\nll powmod(ll a,ll b,ll mod) {\n    ll res=1;a%=mod;\n    assert(b>=0);\n    for(;b;b>>=1) {\n        if(b&1)res=res*a%mod;\n        a=a*a%mod;\n    }\n    return res;\n}\nll phi(int p) {\n    int phip = p, q = p;\n    for (int i = 2; i * i <= q; i++) if (q % i == 0) {\n        phip = phip / i * (i - 1);\n        while (q % i == 0) q /= i;\n    }\n    if (q != 1) phip = phip / q * (q - 1);\n    return phip;\n}\n\nint solve(int l, int r, int x) {\n    int q = p[x];\n    if (l == r) return a[l];\n    if (q == 1) return 1;\n    int d = solve(l + 1, r, x + 1);\n    int ans = powmod(a[l], d, p[x]);\n    bool isles = true;\n    // a[l] ^ d < q\n    if (a[l] != 1) {\n        if (d >= 30) isles = false;\n        else if (pow(a[l], d) >= 1e9) isles = false;\n        else {\n            int val = powmod(a[l], d, 1000000007);\n            if (val >= q) isles = false;\n        }\n    }\n    if (!isles) ans += q;\n    return ans;\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    p[t++] = m;\n    while (p[t - 1] != 1) {\n        p[t] = phi(p[t - 1]);\n        t += 1;\n    }\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        printf(\"%d\\n\", solve(l, r, 0) % m);\n    }\n}"], "input": "", "output": "", "tags": ["chinese remainder theorem", "math", "number theory"], "dificulty": "2700", "interactive": false}