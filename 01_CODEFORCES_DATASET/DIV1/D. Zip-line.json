{
    "link": "https://codeforces.com//contest/650/problem/D",
    "problemId": "50874",
    "problem_idx": "D",
    "shortId": "650D",
    "contest_number": "650",
    "problem_submissions": {
        "E": [
            16578790,
            16577272,
            16578590,
            16579959,
            16637208,
            16582561,
            16619834,
            16591408,
            16757704
        ],
        "D": [
            16571229,
            16573705,
            16576122,
            16578304,
            16576176,
            16577509,
            16577016,
            16576771,
            16578407,
            16577295,
            16573405,
            16578398,
            16577971,
            16579415,
            16579518,
            16578322,
            16579977,
            16579420,
            16579068
        ],
        "B": [
            16567529,
            16566753,
            16570863,
            16566306,
            16567392,
            16570268,
            16568199,
            16568212,
            16566872,
            16566001,
            16578738,
            16567371,
            16573291,
            16569824,
            16567006,
            16572578,
            16570591,
            16567965,
            16566091
        ],
        "C": [
            16565085,
            16569140,
            16568520,
            16573461,
            16571216,
            16572854,
            16571058,
            16570678,
            16571485,
            16571831,
            16567202,
            16572160,
            16568367,
            16566170,
            16572982,
            16567681,
            16567338,
            16571921,
            16572363
        ],
        "A": [
            16562732,
            16562808,
            16562782,
            16562889,
            16563014,
            16563492,
            16563086,
            16563133,
            16562823,
            16562796,
            16575057,
            16563813,
            16563019,
            16567243,
            16562986,
            16569600,
            16562758,
            16562970,
            16562962
        ]
    },
    "name": "D. Zip-line",
    "statement": "Vasya has decided to build a zip-line on trees of a nearby forest. He\r\nwants the line to be as long as possible but he doesn\u2019t remember exactly\r\nthe heights of all trees in the forest. He is sure that he remembers\r\ncorrect heights of all trees except, possibly, one of them.It is known\r\nthat the forest consists of trees staying in a row numbered from left to\r\nright with integers from to . According to Vasya, the height of the -th\r\ntree is equal to . The zip-line of length should hang over () trees ()\r\nsuch that their heights form an increasing sequence, that is .Petya had\r\nbeen in this forest together with Vasya, and he now has assumptions\r\nabout the mistake in Vasya\u2019s sequence . His -th assumption consists of\r\ntwo integers and indicating that, according to Petya, the height of the\r\ntree numbered is actually equal to . Note that Petya\u2019s assumptions are\r\nfrom each other.Your task is to find the maximum length of a zip-line\r\nthat can be built over the trees under each of the assumptions.In this\r\nproblem the length of a zip line is considered equal to the number of\r\ntrees that form this zip-line.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1200010;\n\nint t, mx[N];\n\ninline void modify(int x, int v) {\n  while (x <= t) {\n    if (v > mx[x]) {\n      mx[x] = v;\n    }\n    x = (x | (x - 1)) + 1;\n  }\n}\n\ninline int find_max(int x) {\n  int v = 0;\n  while (x > 0) {\n    if (mx[x] > v) {\n      v = mx[x];\n    }\n    x &= x - 1;\n  }\n  return v;\n}\n\npair <int, int> ev[N];\nint pos[N], value[N], with[N];\nint dpleft[N], dpright[N];\nvector <int> qs[N];\nvector <int> who[N];\nint h[N];\nbool all[N];\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", h + i);\n    ev[i] = make_pair(h[i], i);\n  }\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d\", pos + i, value + i);\n    pos[i]--;\n    ev[n + i] = make_pair(value[i], ~i);\n    with[i] = 1;\n  }\n  sort(ev, ev + n + m);\n  t = 0;\n  for (int i = 0; i < n + m; i++) {\n    if (i == 0 || ev[i].first != ev[i - 1].first) {\n      t++;\n    }\n    int id = ev[i].second;\n    if (id >= 0) {\n      h[id] = t;\n    } else {\n      value[~id] = t;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    qs[i].clear();\n  }\n  for (int i = 0; i < m; i++) {\n    qs[pos[i]].push_back(i);\n  }\n  for (int i = 1; i <= t; i++) {\n    mx[i] = 0;\n  }\n  for (int i = 0; i < n; i++) {\n    dpleft[i] = find_max(h[i] - 1) + 1;\n    int sz = qs[i].size();\n    for (int j = 0; j < sz; j++) {\n      int qid = qs[i][j];\n      with[qid] += find_max(value[qid] - 1);\n    }\n    modify(h[i], dpleft[i]);\n  }\n  for (int i = 1; i <= t; i++) {\n    mx[i] = 0;\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    dpright[i] = find_max(t - h[i]) + 1;\n    int sz = qs[i].size();\n    for (int j = 0; j < sz; j++) {\n      int qid = qs[i][j];\n      with[qid] += find_max(t - value[qid]);\n    }\n    modify(t - h[i] + 1, dpright[i]);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    ans = max(ans, dpleft[i]);\n  }\n  for (int i = 1; i <= ans; i++) {\n    who[i].clear();\n  }\n  for (int i = 0; i < n; i++) {\n    int total = dpleft[i] + dpright[i] - 1;\n    if (total != ans) {\n      continue;\n    }\n    who[dpleft[i]].push_back(i);\n  }\n  for (int i = 0; i < n; i++) {\n    all[i] = false;\n  }\n  for (int i = 1; i <= ans; i++) {\n    int sz = who[i].size();\n    if (sz != 1) {\n      continue;\n    }\n    all[who[i][0]] = true;\n  }\n  for (int i = 0; i < m; i++) {\n    int res = with[i];\n    if (all[pos[i]]) {\n      res = max(res, ans - 1);\n    } else {\n      res = max(res, ans);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "hashing"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Zip-line.json",
    "editorial_link": "https://codeforces.com//blog/entry/43677",
    "editorial": "We need to find the longest\nincreasing subsequence (LIS) after each change if all changes are\nindependent. First lets calculate LIS for the initial array and denote\nits length as . While calculating it we will store some additional\ninformation: maximal length of LIS ending on this element. Also we will\nneed maximal length of LIS starting from this element (we can calc it\nwhen searching longest decreasing sequence on reversed array). Lets\nsolve the case when we take our new element in the resulting LIS. Then\nwe just calculate . It can be done online with persistent segment tree\nor offline with scanline with regular segment tree in time. This is the\nonly case when answer can be larger then , and it can be only to be\nexact. Second case is when we change our element and ruin all LIS of\nsize . Then answer is . Otherwise we will have at least one not ruined\nLIS of size and it is the answer. Lets calculate number of different LIS\nby some modulo. It can be done with the same dynamic programming with\nsegment tree as just finding LIS. Then we can check if . This exactly\nmeans that all sequences go through our element. But if you don\u00e2\u0080\u0099t want\nthe solution with such \"hashing\" there is another approach. For each\nelement we can calc if it can be in LIS. If so then we know on which\nposition it will go (). Then for each position we will know if there are\nseveral elements wanting to go on that position or only one. If only one\nthen it means that all LIS are going through that element. Overall\ncomplexity is . P.S. We can solve this without segment tree, just using\nalternative approach to calculating LIS with dynamic programming and\nbinary search.\n"
}