{"link": "https://codeforces.com//contest/528/problem/C", "problemId": "24749", "problem_idx": "C", "shortId": "528C", "contest_number": "528", "problem_submissions": {"E": [10341247, 10347694, 10319347], "D": [10329962, 10320069, 10323923, 10323825, 15074824, 15074755, 15074588, 13788938, 12800686, 10323881, 10325933, 10320996, 10324989, 10325719, 10324991, 10322203, 10325699, 10330641, 10325792, 15079118, 15024306, 15024301, 15024294, 10326179, 10326263, 10326568, 10771730, 10326292, 10326245, 10595851, 10595702, 10595678, 10595541, 10595511, 10595468, 10595396, 10595378, 10595366, 10595274, 10595233, 10594977, 10594940, 10594912, 10594743, 10594617, 10325531, 10318821], "C": [10318112, 10318394, 10319266, 10320615, 10318827, 10326662, 10320967, 10321573, 10322337, 10325513, 10322954, 10330901, 10330797, 10322938, 10330769, 10321075, 10321402, 10323235, 10322360, 10323460, 10323142, 10370800], "B": [10314537, 10315068, 10315364, 10314727, 10316045, 10315205, 10316694, 10315441, 10317355, 10318177, 10316603, 10315049, 10313726, 10317367, 10314711, 10315826, 10318768, 10317793, 10318969, 10315008], "A": [10312991, 10313324, 10313565, 10313501, 10314349, 10313172, 10313135, 10314168, 10314385, 10315234, 10313926, 10317754, 10314988, 10315685, 10313735, 10314526, 10314740, 10314101, 10314876, 10312997]}, "name": "C. Data Center Drama", "statement": "The project of a data center of a Big Software Company consists of\r\ncomputers connected by cables. Simply speaking, each computer can be\r\nconsidered as a box with multiple cables going out of the box. Very\r\nImportant Information is transmitted along each cable in one of the two\r\ndirections. As the data center plan is not yet approved, it wasn\u2019t\r\ndetermined yet in which direction information will go along each cable.\r\nThe cables are put so that each computer is connected with each one,\r\nperhaps through some other computers.The person in charge of the\r\ncleaning the data center will be Claudia Ivanova, the janitor. She loves\r\nto tie cables into bundles using cable ties. For some reasons, she\r\ngroups the cables sticking out of a computer into groups of two, and if\r\nit isn\u2019t possible, then she gets furious and attacks the computer with\r\nthe water from the bucket.It should also be noted that due to the\r\nspecific physical characteristics of the Very Important Information, it\r\nis strictly forbidden to connect in one bundle two cables where\r\ninformation flows in different directions.The management of the data\r\ncenter wants to determine how to send information along each cable so\r\nthat Claudia Ivanova is able to group all the cables coming out of each\r\ncomputer into groups of two, observing the condition above. Since it may\r\nnot be possible with the existing connections plan, you are allowed to\r\nadd the minimum possible number of cables to the scheme, and then you\r\nneed to determine the direction of the information flow for each cable\r\n(yes, sometimes data centers are designed based on the janitors\u2019\r\nconvenience...)\r\n", "solutions": ["#include <bits/stdc++.h>\n#define REP(a,b) for(int a=0; a<(b); ++a)\n#define FWD(a,b,c) for(int a=(b); a<(c); ++a)\n#define FWDS(a,b,c,d) for(int a=(b); a<(c); a+=d)\n#define BCK(a,b,c) for(int a=(b); a>(c); --a)\n#define ALL(a) (a).begin(), (a).end()\n#define SIZE(a) ((int)(a).size())\n#define VAR(x) #x \": \" << x << \" \"\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n#define gcd __gcd\n#define x first\n#define y second\n#define st first\n#define nd second\n#define pb push_back\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &out, const vector<T> &v){ out << \"{\"; for(const T &a : v) out << a << \", \"; out << \"}\"; return out; }\ntemplate<typename S, typename T> ostream& operator<<(ostream &out, const pair<S,T> &p){ out << \"(\" << p.st << \", \" << p.nd << \")\"; return out; }\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double K;\ntypedef vector<int> VI;\n\nconst int dx[] = {0,0,-1,1}; //1,1,-1,1};\nconst int dy[] = {-1,1,0,0}; //1,-1,1,-1};\n\nint n, m;\nbool vis[500010];\nint ind[200010];\nvector<PII> edges[200010];\nvector<int> cycle;\n\nvoid dfs(int u){\n\twhile(ind[u] < SIZE(edges[u])){\n\t\tif(vis[edges[u][ind[u]].nd]) ++ind[u];\n\t\telse{\n\t\t\tvis[edges[u][ind[u]].nd] = 1;\n\t\t\tdfs(edges[u][ind[u]].st);\n\t\t\tcycle.push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tFWD(i,0,m){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tedges[a].push_back(PII(b,i));\n\t\tedges[b].push_back(PII(a,i));\n\t}\n\tint j = -1;\n\tFWD(i,1,n+1){\n\t\tif(SIZE(edges[i])&1){\n\t\t\tif(j == -1)\n\t\t\t\tj = i;\n\t\t\telse{\n\t\t\t\tedges[i].push_back(PII(j,m));\n\t\t\t\tedges[j].push_back(PII(i,m));\n\t\t\t\t++m;\n\t\t\t\tj = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif(m&1){\n\t\tedges[1].push_back(PII(1,m));\n\t\tedges[1].push_back(PII(1,m));\t\t\n\t\t++m;\n\t}\n\tcycle.push_back(1);\n\tdfs(1);\n\tprintf(\"%d\\n\", m);\n\tFWD(i,0,SIZE(cycle)-1){\n\t\tif(i&1) printf(\"%d %d\\n\", cycle[i], cycle[i+1]);\n\t\telse printf(\"%d %d\\n\", cycle[i+1], cycle[i]);\n\t}\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs"], "dificulty": "2600", "interactive": false}