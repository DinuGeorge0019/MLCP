{
    "link": "https://codeforces.com//contest/528/problem/C",
    "problemId": "24749",
    "problem_idx": "C",
    "shortId": "528C",
    "contest_number": "528",
    "problem_submissions": {
        "E": [
            10341247,
            10347694,
            10319347
        ],
        "D": [
            10329962,
            10320069,
            10323923,
            10323825,
            15074824,
            15074755,
            15074588,
            13788938,
            12800686,
            10323881,
            10325933,
            10320996,
            10324989,
            10325719,
            10324991,
            10322203,
            10325699,
            10330641,
            10325792,
            15079118,
            15024306,
            15024301,
            15024294,
            10326179,
            10326263,
            10326568,
            10771730,
            10326292,
            10326245,
            10595851,
            10595702,
            10595678,
            10595541,
            10595511,
            10595468,
            10595396,
            10595378,
            10595366,
            10595274,
            10595233,
            10594977,
            10594940,
            10594912,
            10594743,
            10594617,
            10325531,
            10318821
        ],
        "C": [
            10318112,
            10318394,
            10319266,
            10320615,
            10318827,
            10326662,
            10320967,
            10321573,
            10322337,
            10325513,
            10322954,
            10330901,
            10330797,
            10322938,
            10330769,
            10321075,
            10321402,
            10323235,
            10322360,
            10323460,
            10323142,
            10370800
        ],
        "B": [
            10314537,
            10315068,
            10315364,
            10314727,
            10316045,
            10315205,
            10316694,
            10315441,
            10317355,
            10318177,
            10316603,
            10315049,
            10313726,
            10317367,
            10314711,
            10315826,
            10318768,
            10317793,
            10318969,
            10315008
        ],
        "A": [
            10312991,
            10313324,
            10313565,
            10313501,
            10314349,
            10313172,
            10313135,
            10314168,
            10314385,
            10315234,
            10313926,
            10317754,
            10314988,
            10315685,
            10313735,
            10314526,
            10314740,
            10314101,
            10314876,
            10312997
        ]
    },
    "name": "C. Data Center Drama",
    "statement": "The project of a data center of a Big Software Company consists of\r\ncomputers connected by cables. Simply speaking, each computer can be\r\nconsidered as a box with multiple cables going out of the box. Very\r\nImportant Information is transmitted along each cable in one of the two\r\ndirections. As the data center plan is not yet approved, it wasn’t\r\ndetermined yet in which direction information will go along each cable.\r\nThe cables are put so that each computer is connected with each one,\r\nperhaps through some other computers.The person in charge of the\r\ncleaning the data center will be Claudia Ivanova, the janitor. She loves\r\nto tie cables into bundles using cable ties. For some reasons, she\r\ngroups the cables sticking out of a computer into groups of two, and if\r\nit isn’t possible, then she gets furious and attacks the computer with\r\nthe water from the bucket.It should also be noted that due to the\r\nspecific physical characteristics of the Very Important Information, it\r\nis strictly forbidden to connect in one bundle two cables where\r\ninformation flows in different directions.The management of the data\r\ncenter wants to determine how to send information along each cable so\r\nthat Claudia Ivanova is able to group all the cables coming out of each\r\ncomputer into groups of two, observing the condition above. Since it may\r\nnot be possible with the existing connections plan, you are allowed to\r\nadd the minimum possible number of cables to the scheme, and then you\r\nneed to determine the direction of the information flow for each cable\r\n(yes, sometimes data centers are designed based on the janitors’\r\nconvenience...)\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define REP(a,b) for(int a=0; a<(b); ++a)\n#define FWD(a,b,c) for(int a=(b); a<(c); ++a)\n#define FWDS(a,b,c,d) for(int a=(b); a<(c); a+=d)\n#define BCK(a,b,c) for(int a=(b); a>(c); --a)\n#define ALL(a) (a).begin(), (a).end()\n#define SIZE(a) ((int)(a).size())\n#define VAR(x) #x \": \" << x << \" \"\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n#define gcd __gcd\n#define x first\n#define y second\n#define st first\n#define nd second\n#define pb push_back\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &out, const vector<T> &v){ out << \"{\"; for(const T &a : v) out << a << \", \"; out << \"}\"; return out; }\ntemplate<typename S, typename T> ostream& operator<<(ostream &out, const pair<S,T> &p){ out << \"(\" << p.st << \", \" << p.nd << \")\"; return out; }\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double K;\ntypedef vector<int> VI;\n\nconst int dx[] = {0,0,-1,1}; //1,1,-1,1};\nconst int dy[] = {-1,1,0,0}; //1,-1,1,-1};\n\nint n, m;\nbool vis[500010];\nint ind[200010];\nvector<PII> edges[200010];\nvector<int> cycle;\n\nvoid dfs(int u){\n\twhile(ind[u] < SIZE(edges[u])){\n\t\tif(vis[edges[u][ind[u]].nd]) ++ind[u];\n\t\telse{\n\t\t\tvis[edges[u][ind[u]].nd] = 1;\n\t\t\tdfs(edges[u][ind[u]].st);\n\t\t\tcycle.push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tFWD(i,0,m){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tedges[a].push_back(PII(b,i));\n\t\tedges[b].push_back(PII(a,i));\n\t}\n\tint j = -1;\n\tFWD(i,1,n+1){\n\t\tif(SIZE(edges[i])&1){\n\t\t\tif(j == -1)\n\t\t\t\tj = i;\n\t\t\telse{\n\t\t\t\tedges[i].push_back(PII(j,m));\n\t\t\t\tedges[j].push_back(PII(i,m));\n\t\t\t\t++m;\n\t\t\t\tj = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif(m&1){\n\t\tedges[1].push_back(PII(1,m));\n\t\tedges[1].push_back(PII(1,m));\t\t\n\t\t++m;\n\t}\n\tcycle.push_back(1);\n\tdfs(1);\n\tprintf(\"%d\\n\", m);\n\tFWD(i,0,SIZE(cycle)-1){\n\t\tif(i&1) printf(\"%d %d\\n\", cycle[i], cycle[i+1]);\n\t\telse printf(\"%d %d\\n\", cycle[i+1], cycle[i]);\n\t}\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Data Center Drama.json",
    "editorial_link": "https://codeforces.com//blog/entry/17020",
    "editorial": "Problem legend asks you to add minimum number of edges to the given\r\nconnected undirected graph (possibly, with loops and duplicating edges)\r\nand choose direction for its edges so that both the incoming and\r\noutgoing degrees of all vertices are even. First idea is that the\r\nresulting graph before we choose the direction (but after we added some\r\nedges) will contain Euler circuit, since all degrees are even. That s\r\nalmost what we need: if we have an Euler circuit that contains even\r\nnumber of edges, we may direct them like following: a <- b -> c <- d ->\r\ne It s easy to see that each vertex appearance in this cycle adds 2 to\r\nits ingoing or outgoing degree, so the resulting degrees will be even.\r\nBut if the Euler circuit is odd (meaning that there is odd number of\r\nedges in the graph), we must add some extra edge to the graph before we\r\ncontinue, the easiest way is to add a loop from vertex 0 to itself,\r\nsince it doesn t affect the Euler tour, but now tour length is even, so\r\neverything is ok. Now we should think how to add edges optimally. It s\r\neasy to see that the optimal way is to first fix all odd degrees of\r\nvertices (i. e. combine all odd vertices by pairs and put an edge in\r\neach pair), and then, possibly, add an extra loop as described above.\r\nThe last part is to actually find an Euler circuit, and to print the\r\nanswer. There were issues with this task. Intended constraints were\r\nactually , and the intended solution was using Fast Fourier\r\nTransformation, that leads to running time. But unfortunately the\r\nstatement contained wrong constraints, so we reduced input size during\r\nthe tour. Nevertheless, we will add the harder version of this task and\r\nyou will be able to submit it shortly. Key idea is to reduce this task\r\nto a polynomial multiplication. Let s solve the task in following\r\nmanner. For each position i of the S for each character c from ATGC we\r\nwill calculate match(c, i) that is equal to the number of c characters\r\nthat have matching symbol in S if we put string T in position i. Then\r\nthe criteria for us to have an occurrence at position i is that match(A,\r\ni) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly\r\nthat each character from T being put at position i has a corresponding\r\ncharacter in S). Now let s find out how to calculate match(c, i). Let s\r\nkeep only c characters and not c characters in both strings and denote\r\nthem by 1 and 0 respectively. Let s also spread each 1 in string S by\r\nthe distance k to the left and to the right. For example, k = 1 for the\r\nsample string AGCAATTCAT and the character A corresponding bit vector\r\nwill be 111110111, and for the character C it will be 0111001110. This\r\nbitvector can be calculated in by putting two events +1 and -1 in string\r\nS in positions and for each in original string S and then sweeping from\r\nleft to right over the string S and processing those events. Now our\r\ntask is reduced to searching all positions where the bitvector T is the\r\nsubmask of the bitvector S. In constraints this can be done by using\r\nbitsets in . Nevertheless, this task can be seen as calculation of\r\npolynomials S and reversed(T) product. We will keep this as an exercise\r\nfor those who decide to submit the harder version of this task. Let s\r\ndraw a bounding box that contains all intersection points. Let s fix a\r\ntriangle and consider three angles shown on the picture. Calculate area\r\nof intersection of those area with the bounding box and call this area\r\nto be the area of an angle . Then it s easy to see, that those three\r\nangles are complement to the triangle itself in the bounding box, i. e.\r\ntriangle area is bounding box area minus three angle areas. This leads\r\nus to the idea how to solve this task by carefully calculating for each\r\npossible formed angle on the plane, how much times does it appear in\r\ntotal answer if we sum all values like over all triples of lines.\r\nActually, the angle is considered as many times, as many lines there are\r\nthat intersect both sides of its right adjacent angle. So, our task is\r\nreduced to calculate for each angle on plane how much lines intersect\r\nits sides (i. e. its rays). This can be done in by fixing the first side\r\nof the angle and then adding lines in ascending order of polar angle,\r\nand then by keeping the number of lines that intersect the base line to\r\nthe left and that intersect the base line to the right. Key idea is that\r\nthe exact of four angles formed by the pair of lines that is crossed by\r\nsome third line c, can be determined by two numbers: its polar angle\r\nalpha and its crossing with a coordinate x. Further details are shown on\r\nthe picture below. There is also a nice short solution from enot110\r\nhere.\r\n",
    "hint": []
}