{
    "link": "https://codeforces.com//contest/1677/problem/E",
    "problemId": "1392748",
    "problem_idx": "E",
    "shortId": "1677E",
    "contest_number": "1677",
    "problem_submissions": {
        "F": [
            156410211,
            156340426,
            162899316,
            156353702,
            156350954
        ],
        "E": [
            156331815,
            156318644,
            156328561,
            156331386,
            156331002,
            156328868,
            156325230,
            156336008,
            156334099,
            156333516,
            156333464,
            156335361,
            156328640,
            156340153,
            158284059,
            156378160,
            156338101,
            156328125,
            156340956,
            156337665,
            156338196,
            156339034
        ],
        "D": [
            156316835,
            156323238,
            156317161,
            156315911,
            156316022,
            156316672,
            156329661,
            156318133,
            156323976,
            156324745,
            156322030,
            156324914,
            156333446,
            156322961,
            158284040,
            156321654,
            156336035,
            156319782,
            156328313,
            156324515,
            156324891
        ],
        "C": [
            156310492,
            156302984,
            156308123,
            156302398,
            156308505,
            156310990,
            156308842,
            156308240,
            156309247,
            156311925,
            156314980,
            156306934,
            156313634,
            156303102,
            158284033,
            156312769,
            156312306,
            156311466,
            156313895,
            156319948,
            156317818
        ],
        "B": [
            156306242,
            156299817,
            156302654,
            156307122,
            156303982,
            156308030,
            156305072,
            156302974,
            156301220,
            156307457,
            156305188,
            156303760,
            156307405,
            156307846,
            158284021,
            156307024,
            156302217,
            156306717,
            156309806,
            156308440,
            156312263
        ],
        "A": [
            156296375,
            156295896,
            156296011,
            156296172,
            156296391,
            156299927,
            156298060,
            156296590,
            157632647,
            156296271,
            156296400,
            156299458,
            156296757,
            156297768,
            156296676,
            158284002,
            156297493,
            156296069,
            156297899,
            156296595,
            156298804,
            156300116
        ]
    },
    "name": "E. Tokitsukaze and Beautiful Subsegments",
    "statement": "Tokitsukaze has a permutation p of length n.Let’s call a segment [l,r]\r\nbeautiful if there exist i and j satisfying p_i\r\ncdot p_j =\r\nmax\r\n{p_l, p_{l+1},\r\nldots, p_r\r\n}, where l\r\nleq i < j\r\nleq r.Now Tokitsukaze has q queries, in the i-th query she wants to know\r\nhow many beautiful subsegments [x,y] there are in the segment [l_i,r_i]\r\n(i. e. l_i\r\nleq x\r\nleq y\r\nleq r_i).\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\n//atcoder-library をまあまあコピーして使っている\n\n//N() が単位元\n\n//merge で片方が inactive のときはもう片方をそのまま返す，\n//といったときに，lazy の情報までコピーして渡さないようにする\n\n//get の最後の引数は単位元と口では言いつつ・・・？\n//たとえば min で最後の引数を 0 にしても 1 とかが返ってくることはある（一敗）\n\n//VERIFY:\n//https://atcoder.jp/contests/practice2/tasks/practice2_k\ntemplate<class N>\nstruct seglazy{\n\tvc<N> x;\n\tint L,s;\n\tseglazy(){}\n\ttemplate<class T>\n\tseglazy(const vc<T>& a){\n\t\tint n=a.size();\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.resize(s*2);\n\t\trep(i,n)x[s+i]=N(a[i]);\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tseglazy(int n){\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.assign(s*2,N());\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tvoid upd(int i){\n\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid push(int i){\n\t\tx[i].push(x[i*2],x[i*2+1]);\n\t}\n\tN composite(int l,int r){\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif(l==r)return N();\n\t\t\n\t\tl+=s;\n\t\tr+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tN sml,smr;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) sml = N::merge(sml, x[l++]);\n\t\t\tif (r & 1) smr = N::merge(x[--r], smr);\n\t\t\tl >>= 1;\n\t\t\tr >>= 1;\n\t\t}\n\n\t\treturn N::merge(sml, smr);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid ch(int l, int r, F f,Args&&... args) {\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif (l == r) return;\n\n\t\tl+=s;\n\t\tr+=s;\n\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tstatic int buf[2][30];\n\t\tint cnt[2]{};\n\t\t{\n\t\t\tint l2 = l, r2 = r;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1){\n\t\t\t\t\t//(x[l++].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[0][cnt[0]++]=l++;\n\t\t\t\t}\n\t\t\t\tif (r & 1){\n\t\t\t\t\t//(x[--r].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[1][cnt[1]++]=--r;\n\t\t\t\t}\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\tl = l2;\n\t\t\tr = r2;\n\t\t}\n\t\trep(i,cnt[0])(x[buf[0][i]].*f)(forward<Args>(args)...);\n\t\tper(i,cnt[1])(x[buf[1][i]].*f)(forward<Args>(args)...);\n\n\t\tfor (int i = 1; i <= L; i++) {\n\t\t\tif (((l >> i) << i) != l) upd(l >> i);\n\t\t\tif (((r >> i) << i) != r) upd((r - 1) >> i);\n\t\t}\n\t}\n\tN getall(){return x[1];}\n\ttemplate <class F,class... Args> \n\tpair<int,N> max_right(int l,F f,Args&&... args){\n\t\tassert(0<=l&&l<=s);\n\t\tif(l==s)return mp(s,N());\n\t\tl+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) push(l >> i);\n\t\tN sm;\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tdo {\n\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\tif (!(N::merge(sm,x[l]).*f)(forward<Args>(args)...)){\n\t\t\t\twhile (l < s) {\n\t\t\t\t\tpush(l);\n\t\t\t\t\tl = (2 * l);\n\t\t\t\t\tN tmp=N::merge(sm,x[l]);\n\t\t\t\t\tif ((tmp.*f)(forward<Args>(args)...)) {\n\t\t\t\t\t\tsm = tmp;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mp(l - s,sm);\n\t\t\t}\n\t\t\tsm = N::merge(sm, x[l]);\n\t\t\tl++;\n\t\t} while ((l & -l) != l);\n\t\treturn mp(s,sm);\n\t}\n\t//XXI Opencup Krakow M\n\ttemplate <class F,class... Args> \n\tpair<int,N> min_left(int r,F f,Args&&... args){\n\t\tassert(0<=r&&r<=s);\n        if(r==0)return mp(0,N());\n        r+=s;\n        for (int i = L; i >= 1; i--) push((r - 1) >> i);\n        N sm;\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!(N::merge(x[r],sm).*f)(forward<Args>(args)...)) {\n                while (r < s) {\n                    push(r);\n                    r = (2 * r + 1);\n                    N tmp=N::merge(x[r],sm);\n                    if ((tmp.*f)(forward<Args>(args)...)) {\n                        sm = tmp;\n                        r--;\n                    }\n                }\n                return mp(r + 1 - s,sm);\n            }\n            sm = N::merge(x[r], sm);\n        } while ((r & -r) != r);\n        return mp(0,sm);\n    }\n\ttemplate<class F,class...Args>\n\tvoid point_change(int p,F f,Args&&...args){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\t(x[p].*f)(forward<Args>(args)...);\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tN point_get(int p){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\treturn x[p];\n\t}\n\tvoid point_set(int p,N val){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\tx[p]=val;\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tvoid enumerater(int l,int r,int i,int b,int e,vc<N>&dst){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.pb(x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerater(l,m,i*2,b,e,dst);\n\t\tenumerater(m,r,i*2+1,b,e,dst);\n\t}\n\tvoid enumerate(int b,int e,vc<N>&dst){\n\t\tassert(b<=e);\n\t\treturn enumerater(0,s,1,b,e,dst);\n\t}\n};\n\nusing A=array<int,2>;\n\n//Range add,sum\nstruct N{\n\tint len;\n\tA sum,lz;\n\tN(int z=0):len(z),sum{},lz{}{}\n\tvoid add(const A&v){\n\t\trep(k,2){\n\t\t\tsum[k]+=v[k]*len;\n\t\t\tlz[k]+=v[k];\n\t\t}\n\t\treturn;\n\t}\n\tvoid push(N&x,N&y){\n\t\tx.add(lz);\n\t\ty.add(lz);\n\t\trep(k,2)lz[k]=0;\n\t}\n\tstatic N merge(const N&x,const N&y){\n\t\tN res(x.len+y.len);\n\t\trep(k,2)res.sum[k]=x.sum[k]+y.sum[k];\n\t\treturn res;\n\t}\n};\n\n//max cartesian tree\nvi cartesiantree(const vi&a){\n\tint n=si(a);\n\tvi par(n,-1);\n\tvi s;\n\trep(i,n){\n\t\tint last=-1;\n\t\twhile(si(s)&&a[s.back()]<=a[i]){\n\t\t\tlast=s.back();\n\t\t\ts.pop_back();\n\t\t}\n\t\tif(last!=-1)par[last]=i;\n\t\tif(si(s))par[i]=s.back();\n\t\ts.pb(i);\n\t}\n\treturn par;\n}\n\nbool inc(pi a,pi b){\n\treturn a.a<=b.a&&b.b<=a.b;\n}\n\nvoid reduce(vc<pi>&lr){\n\tsort(all(lr));\n\tint s=0;\n\trep(i,si(lr)){\n\t\twhile(s>0&&inc(lr[s-1],lr[i]))s--;\n\t\tif(s==0||lr[s-1].a<lr[i].a)lr[s++]=lr[i];\n\t}\n\tlr.resize(s);\n}\n\nvoid slv(){\n\tint n,q;cin>>n>>q;\n\tvi a=readvi(n);\n\tvc<A> t(n,A{-1,-1});\n\tvi par=cartesiantree(a);\n\tint root=-1;\n\trep(i,n)if(par[i]==-1)root=i;\n\telse t[par[i]][par[i]<i]=i;\n\n\tvc<pi> cap(n);\n\t{\n\t\tauto rec=[&](auto self,int v,int l,int r)->void{\n\t\t\tif(v==-1)return;\n\t\t\tcap[v]=pi(l,r);\n\t\t\tself(self,t[v][0],l,v-1);\n\t\t\tself(self,t[v][1],v+1,r);\n\t\t};\n\t\trec(rec,root,0,n-1);\n\t}\n\n\tvvc<pi> ls(n+1);\n\tvi inv(n+1);\n\trep(i,n)inv[a[i]]=i;\n\trng(x,1,n+1)for(int y=x+1;x*y<=n;y++){\n\t\tint v=x*y;\n\t\tpi z=minmax(inv[x],inv[y]);\n\t\tif(inc(cap[inv[v]],z)){\n\t\t\tchmin(z.a,inv[v]);\n\t\t\tchmax(z.b,inv[v]);\n\t\t\tls[v].pb(z);\n\t\t}\n\t}\n\t\n\tvvc<pi> add(n);\n\trng(v,1,n+1){\n\t\treduce(ls[v]);\n\t\tdmp2(v,ls[v]);\n\t\tif(si(ls[v])){\n\t\t\tauto [c,d]=cap[inv[v]];\n\t\t\tint prel=c-1;\n\t\t\tfor(auto [l,r]:ls[v]){\n\t\t\t\tadd[l].eb(r,1);\n\t\t\t\tif(prel>=0)add[prel].eb(r,-1);\n\t\t\t\tprel=l;\n\t\t\t}\n\t\t\tadd[prel].eb(d+1,-1);\n\t\t\tif(c>0){\n\t\t\t\tadd[c-1].eb(d+1,1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvvc<pi> ask(n);\n\trep(i,q){\n\t\tint l,r;cin>>l>>r;\n\t\tl--;\n\t\task[l].eb(r,i);\n\t}\n\t\n\tvi ans(q);\n\tseglazy<N> seg(vi(n,1));\n\tper(i,n){\n\t\tfor(auto [r,w]:add[i]){\n\t\t\tdmp2(i,r,w);\n\t\t\tseg.ch(r,seg.s,&N::add,A{-w,(i+1)*w});\n\t\t}\n\t\tfor(auto [r,dst]:ask[i]){\n\t\t\tauto w=seg.composite(0,r).sum;\n\t\t\tdmp(w);\n\t\t\tans[dst]=w[0]*i+w[1];\n\t\t}\n\t}\n\t\n\trep(i,q)print(ans[i]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Tokitsukaze and Beautiful Subsegments.json",
    "editorial_link": "https://codeforces.com//blog/entry/102631",
    "editorial": "TutorialLetâs sort the queries with in ascending order.Letâs move from\r\nto , and answer queries when .Use segment tree to solve this problem,\r\neach leaf node in the segment tree maintenance the number that how many\r\nintervals are beautiful, then answering queries is to get sum. Use\r\nmonotone stack to maintain the maximum number. When moving one step\r\nright, the monotone stack will pop some and push one.Letâs think about\r\nthe number in monotone stack, which means the maximum number of the\r\nintervals () is . If there exist a in which satisfies , then before is\r\npoped, intervals are beautiful(, ,).So we can assume that will not be\r\npoped when it is pushed in the monotone stack, and do something like\r\ndifference algorithm in the segment tree, by using the current as the\r\ntime stamp. Each node in the segment tree has to maintain ,which like a\r\nlinear function.So when moving right step, letâs enumerate the factor of\r\nto update old intervals in monotone stack, enumerate the multiple of to\r\nupdate the new interval in monotone stack and update the intervals which\r\nare poped.Time complexity: .\r\n",
    "hint": []
}