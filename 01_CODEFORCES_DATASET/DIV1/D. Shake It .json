{
    "link": "https://codeforces.com//contest/848/problem/D",
    "problemId": "120618",
    "problem_idx": "D",
    "shortId": "848D",
    "contest_number": "848",
    "problem_submissions": {
        "D": [
            29984461,
            29984526,
            29990531,
            29990452,
            29983235,
            29986841,
            30011180,
            30054712,
            29986436,
            29991292,
            29988130,
            30025667
        ],
        "C": [
            29981953,
            29979998,
            29991414,
            29985145,
            29986831,
            29981161,
            30023429,
            30739183,
            30739016,
            29983074,
            29985177,
            29986148,
            29992066,
            29984922,
            29985048,
            30004311,
            29986150,
            29985850,
            29985839,
            29985353,
            29988848
        ],
        "B": [
            29977726,
            29987077,
            29983009,
            29978119,
            29977288,
            29977302,
            29978411,
            29979022,
            29978648,
            29977708,
            29980992,
            29981154,
            29978110,
            29977941,
            29980264,
            29977663,
            29981248,
            29982355,
            29978027
        ],
        "A": [
            29975110,
            29976090,
            29975270,
            29974910,
            29974992,
            29974976,
            29975582,
            29975367,
            29976038,
            29974917,
            29976913,
            29976388,
            29974989,
            29978589,
            29977088,
            29975038,
            29977707,
            29977980,
            29974970
        ],
        "E": [
            31234259
        ]
    },
    "name": "D. Shake It ",
    "statement": "A is an unordered graph , in whose vertex set there are two special\r\nvertices and . An has vertex set and an edge between them.A total of\r\nchanges took place in an . In each change, a new vertex is added into ,\r\nis chosen, and two edges and are added into . Note that it’s possible\r\nthat some edges are chosen in more than one change.It’s known that the\r\ncapacity of the minimum - cut of the resulting graph is , that is, at\r\nleast edges need to be removed in order to make and disconnected.Count\r\nthe number of that can be built under the constraints, modulo . We\r\ndefine two similar, if they are isomorphic and there is isomorphism in\r\nwhich the and vertices are not relabelled. Formally, two and are\r\nconsidered similar, if there is a bijection between their vertex sets ,\r\nsuch that: ; ; Two vertices and of are adjacent in if and only if and\r\nare adjacent in .\r\n",
    "solutions": [
        "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>\n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nll mul_inv(ll a, ll b = MOD) {\n\tll t1 = a, t2 = b, t3;\n\tll v1 = 1, v2 = 0, v3;\n\twhile (t2 != 1) {\n\t\tll x = t1 / t2;\n\t\tt3 = t1 - x*t2;\n\t\tv3 = v1 - x*v2;\n\t\tt1 = t2, t2 = t3;\n\t\tv1 = v2, v2 = v3;\n\t}\n\treturn (v2 + b) % b;\n}\nll F[1005];\nll Finv[1005];\nll C(ll a, ll b) {\n\tll rv = Finv[b];\n\tfor (ll i = a; i > a - b; i--) rv = (rv * (i + MOD)) % MOD;\n\treturn rv;\n}\nll H(ll a, ll b) {\n\treturn C(a + b - 1, b);\n}\n\nll dp[55][55];\nll dp2[55][55];\n\nll tdp[55][55];\nll tdp2[55][55];\n\nint main() {\n\tint N, M, i, j, k, l, m, n;\n\tF[0] = 1;\n\tfor (i = 1; i <= 1000; i++) F[i] = F[i - 1] * i % MOD;\n\tfor (i = 0; i <= 1000; i++) Finv[i] = mul_inv(F[i]);\n\n\n\tscanf(\"%d %d\", &N, &M);\n\tdp[0][1] = 1;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tint a1 = j, a2 = i - 1 - j;\n\t\t\tfor (k = 1; k <= a1 + 1; k++) {\n\t\t\t\tfor (l = 1; l <= a2 + 1; l++) {\n\t\t\t\t\tll v = dp[a1][k] * dp[a2][l];\n\t\t\t\t\tdp2[i][min(k, l)] = (dp2[i][min(k, l)] + v) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(tdp, 0, sizeof(tdp));\n\t\ttdp[0][1] = 1;\n\t\tfor (j = 1; j <= i; j++) {\n\t\t\tfor (k = 0; k <= j + 1; k++) {\n\t\t\t\tmemset(tdp2, 0, sizeof(tdp2));\n\t\t\t\tll x = dp2[j][k];\n\t\t\t\tfor (l = 0;; l++) {\n\t\t\t\t\tint a1 = l * j, a2 = l * k;\n\t\t\t\t\tif (a1 > i) break;\n\t\t\t\t\tll v = C(x + l - 1, l);\n\t\t\t\t\tfor (m = 0; m <= i - a1; m++) {\n\t\t\t\t\t\tfor (n = 0; n <= i + 1 - a2; n++) {\n\t\t\t\t\t\t\ttdp2[m + a1][n + a2] = (tdp2[m + a1][n + a2] + tdp[m][n] * v) % MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (l = 0; l <= i; l++) for (m = 0; m <= i + 1; m++) tdp[l][m] = tdp2[l][m];\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= i; j++) for (k = 1; k <= i + 1; k++) dp[j][k] = tdp[j][k];\n\t}\n\treturn !printf(\"%lld\\n\", dp[N][M]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "flows",
        "graphs"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Shake It .json",
    "editorial_link": "https://codeforces.com//blog/entry/54233",
    "editorial": "Letâs try to find \"subproblems\" in this. A graph can be expressed as: an\r\nedge, in parallel with an multiset of zero or more pair of two graphs.\r\nThat is, \"graph = edge [// (graph + graph) [// (graph + graph)\r\n[...]]]\".A graph can be represented by two parameters: number of\r\noperations needed to build it, and its minimum cut. Let keep the number\r\nof graphs with operations and a minimum cut of . The figure below shows\r\none of the ways in which can be built from other âs. How to iterate over\r\nall such possible splitting into pairs, while keeping them ? One way is\r\nto iterate through pairs instead of determining âs one by one, we find\r\nall pairs of graph parameters and add them to graphs already formed with\r\npairs considered before. (This is like how we do it in knapsack\r\nproblems.)Iterate through the parameters of two graphs in a pair, , and\r\nuse a push-style transition to add each into the corresponding state if\r\nthe pair is added a number of times to a graph in . That is, for each ,\r\nadd to this means a pair of graphs with parameters and is added times to\r\na graph with parameters . With such parameters we need to spend time\r\nupdating all values, therefore time complexity is which is not\r\nsufficient to pass.Letâs see the pair as a whole. Let keep the number of\r\nordered graph pairs with operations and a minimum cut of . At each step,\r\nin stead of iterating over four parameters of a pair, we iterate over\r\ntwo parameters and use values of to perform the update.It can be seen\r\nthat and only depend on such and that . Therefore, we can determine and\r\nvalues in order of increasing . This solution works with states, each of\r\nwhich can be calculated in time with another factor for\r\nMultiCombination, but since a harmonic series exists in the iteration of\r\n, this is actually . Authorâs implementation takes a bit lower than 800\r\nmilliseconds to find an answer.If MultiCombination is calculated along\r\nwith the iteration of (see the model solution), this works in which is\r\nmuch faster. Come up with a DP on .\r\n",
    "hint": [
        "Hint Use DP. keeps the number of subgraphs with operations and a minimum cut of . The transition may be in a knapsack-like manner. Add more functions (say another ) if needed to make it faster. There are more than one way to do DP, you can also read about other nice solutions here and here ."
    ]
}