{
    "link": "https://codeforces.com//contest/1685/problem/C",
    "problemId": "1410454",
    "problem_idx": "C",
    "shortId": "1685C",
    "contest_number": "1685",
    "problem_submissions": {
        "E": [
            158459552,
            158470179,
            158498551,
            158474226,
            158469548,
            163064811,
            163064579,
            162972274,
            161995310
        ],
        "D1": [
            158446537,
            158446179,
            158436497,
            158441308,
            158450152,
            158437819,
            158438771,
            158444550,
            158444057,
            158444961,
            158450485,
            158456436,
            158455279,
            158451423,
            158456717,
            158456702,
            158458839,
            158450419,
            158454329
        ],
        "C": [
            158440149,
            158436682,
            158456408,
            158436985,
            158433630,
            158430630,
            158430086,
            158437803,
            158438284,
            158438857,
            158446162,
            158444048,
            158440132,
            158447129,
            158447895,
            158449525,
            158447760,
            158457006,
            158449988
        ],
        "B": [
            158430617,
            158426337,
            158489620,
            158427132,
            158430769,
            158427058,
            158419568,
            158419647,
            158422845,
            158428180,
            158427930,
            158426993,
            158428289,
            158433041,
            158438360,
            158432708,
            158432524,
            158429703,
            158431029,
            158439177
        ],
        "A": [
            158416845,
            158416623,
            158416445,
            158417978,
            158414637,
            158414483,
            158414377,
            158414577,
            158419066,
            158418105,
            158416435,
            158417522,
            158415887,
            158415929,
            158418032,
            158416211,
            158417132,
            158417328,
            158424448
        ],
        "D2": [
            158457366,
            158450783,
            158467580,
            158467275,
            158561732,
            166382774,
            166382436
        ]
    },
    "name": "C. Bring Balance",
    "statement": "Alina has a bracket sequence s of length 2n, consisting of n opening\r\nbrackets and n closing brackets . As she likes balance, she wants to\r\nturn this bracket sequence into a balanced bracket sequence.In one\r\noperation, she can reverse any substring of s.What\u2019s the smallest number\r\nof operations that she needs to turn s into a balanced bracket sequence?\r\nIt can be shown that it\u2019s always possible in at most n operations.As a\r\nreminder, a sequence of brackets is called balanced if one can turn it\r\ninto a valid math expression by adding characters and . For example,\r\nsequences , , and are balanced, while , , and are not.\r\n",
    "solutions": [
        "//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 1000000007\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 500005;\nchar a[maxn];\n\nint s[maxn];\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        scanf(\"%s\", a + 1);\n        int l = 2 * n;\n        int fs = l + 1, ls = 0, mpl = 0;\n        for (int i = 1; i <= l; i++) {\n            s[i] = s[i - 1];\n            if (a[i] == '(') s[i] += 1;\n            else s[i] -= 1;\n            if (s[i] < 0) chkmin(fs, i), chkmax(ls, i);\n            if (s[i] > s[mpl]) mpl = i;\n        }\n        if (fs > l) printf(\"0\\n\");\n        else {\n            int fm = -1, fp = 0;\n            for (int x = 0; x < fs; x++)\n                if (chkmax(fm, s[x]))\n                    fp = x;\n            int em = -1, ep = 0;\n            for (int x = ls + 1; x <= l; x++)\n                if (chkmax(em, s[x]))\n                    ep = x;\n            fm += em;\n            int flag = 1;\n            for (int x = fs; x <= ls; x++)\n                if (s[x] > fm) flag = 0;\n            if (flag) {\n                printf(\"1\\n\");\n                printf(\"%d %d\\n\", fp + 1, ep);\n            }\n            else {\n                printf(\"2\\n\");\n                printf(\"%d %d\\n\", 1, mpl);\n                printf(\"%d %d\\n\", mpl + 1, l);\n            }\n        }\n                \n    }\n    return (0-0); //<3\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Bring Balance.json",
    "editorial_link": "https://codeforces.com//blog/entry/103198",
    "editorial": "Let\u00e2\u0080\u0099s denote by and by . Then we need to achieve a sequence in which all\r\nprefix sums are nonnegative.Let our sequence be , and denote for each .\r\nIt\u00e2\u0080\u0099s always possible to get a balanced sequence in at most operations.\r\nLet be the index for which the value of is the largest (if there are\r\nseveral such , choose any). Let\u00e2\u0080\u0099s reverse segments and , getting\r\nsequence .It\u00e2\u0080\u0099s easy to show that this sequence is balanced. for any ,\r\nand for any , so for any . So, all prefix sums are nonnegative, as\r\ndesired.It remains to check if we can make our sequence balanced in less\r\nthan operations.Checking if operations are enough is trivial: just check\r\nif the initial sequence is balanced. Now, let\u00e2\u0080\u0099s check if we can make the\r\nsequence (which initially isn\u00e2\u0080\u0099t balanced) balanced in exactly one\r\noperation.Let be the smallest index for which , and be the largest such\r\nindex. Suppose that we will reverse the segment . Clearly, , as\r\notherwise, we would have a negative prefix sum. Similarly . After\r\nreversing, we need to worry only about the -th prefix sum for each from\r\nto , all others will be nonnegative.The -th prefix sum for such will be\r\nequal to . So, segment will be good iff for all .It\u00e2\u0080\u0099s easy to show that\r\nif any such segment works, then also the segment works, where is the\r\nindex from for which is the largest, and is the index from for which is\r\nthe largest. Indeed, suppose that there is some such that . If , then ,\r\ncontradiction. If , then , contradiction. If , then is inside any such\r\nsegment , and for any choice of .So, it\u00e2\u0080\u0099s enough to choose segment and\r\nto check if the sequence becomes balanced after reversing it.\r\n"
}