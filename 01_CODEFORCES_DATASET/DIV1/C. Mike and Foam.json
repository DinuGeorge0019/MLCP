{
    "link": "https://codeforces.com//contest/547/problem/C",
    "problemId": "28331",
    "problem_idx": "C",
    "shortId": "547C",
    "contest_number": "547",
    "problem_submissions": {
        "A": [
            11306176,
            11281663,
            11286152,
            11283154,
            11300410,
            11282966,
            11282839,
            11284240,
            11282987,
            11283935,
            11284453,
            11283105,
            11302976,
            11296402,
            11304989
        ],
        "E": [
            11300374,
            11295900,
            11296096,
            11332517,
            11332504,
            11301614,
            11329764,
            11329670,
            11329557,
            11302402,
            11296504,
            11303628,
            11310167,
            11310570,
            11335792,
            11334862,
            11310094,
            11298023,
            11289647
        ],
        "D": [
            11290397,
            11311418,
            11289189,
            11307197,
            11288244,
            11306223,
            11292199,
            11318433,
            11338617,
            11294617,
            11298075,
            11296934,
            11291997,
            11293528,
            11292331,
            11330482
        ],
        "C": [
            11288602,
            11286288,
            11282036,
            11285135,
            11284518,
            11286983,
            11288810,
            11287248,
            11292291,
            11290371,
            11293842,
            11290787,
            11289508,
            11302378,
            11289341,
            11290547,
            11300174
        ],
        "B": [
            11284410,
            11282963,
            11283861,
            11287519,
            11281935,
            11284503,
            11284754,
            11285157,
            11286946,
            11285798,
            11286796,
            11285456,
            11285604,
            11286200,
            11285607,
            11286328,
            11292395
        ]
    },
    "name": "C. Mike and Foam",
    "statement": "Mike is a bartender at Rico’s bar. At Rico’s, they put beer glasses in a\r\nspecial shelf. There are kinds of beer at Rico’s numbered from to . -th\r\nkind of beer has milliliters of foam on it. Maxim is Mike’s boss. Today\r\nhe told Mike to perform queries. Initially the shelf is empty. In each\r\nrequest, Maxim gives him a number . If beer number is already in the\r\nshelf, then Mike should remove it from the shelf, otherwise he should\r\nput it in the shelf.After each query, Mike should tell him the score of\r\nthe shelf. Bears are geeks. So they think that the score of a shelf is\r\nthe number of pairs of glasses in the shelf such that and where is the\r\ngreatest common divisor of numbers and .Mike is tired. So he asked you\r\nto help him in performing these requests.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 500001;\n// template end here\nvector<int> fac[SIZE];\nvector<int> p_fac[SIZE];\nint num[SIZE],a[SIZE];\nbool v[SIZE];\nLL an;\nvoid build(){\n    REPP(i,1,SIZE){\n        bool pp=0;\n        if(SZ(fac[i])==1)pp=1;\n        for(int j=i;j<SIZE;j+=i)fac[j].PB(i);\n        if(pp&&i!=1){\n            for(int j=i;j<SIZE;j+=i)p_fac[j].PB(i);\n        }\n    }\n}\nint me;\nvoid dfs(int x,int v,int ty){\n    if(x==SZ(p_fac[me])){\n        an+=ty*num[v];\n        return;\n    }\n    dfs(x+1,v*p_fac[me][x],-ty);\n    dfs(x+1,v,ty);\n}\nint main(){\n    build();\n    DRII(n,q);\n    REP(i,n)RI(a[i]);\n    REP(i,q){\n        DRI(x);\n        x--;\n        me=a[x];\n        if(v[x]){\n            REP(i,SZ(fac[me])){\n                num[fac[me][i]]--;\n            }\n            dfs(0,1,-1);\n        }\n        else{\n            dfs(0,1,1);\n            REP(i,SZ(fac[me])){\n                num[fac[me][i]]++;\n            }\n        }\n        v[x]=!v[x];\n        printf(\"%I64d\\n\",an);\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Mike and Foam.json",
    "editorial_link": "https://codeforces.com/blog/entry/18126",
    "editorial": "We define that a number is good if and only if there is no that is a\r\ndivisor of . Also, we define function as follow: Consider where all s\r\nare prime. Then, . Use simple inclusion. Consider all the primes from to\r\nare . So, after each query, if is the set of beers like in the shelf\r\nthat is a divisor of , then number of pairs with equal to 1 is: Consider\r\ngood numbers from to are . The above phrase can be written in some other\r\nway: . So, for each query if we can find all good numbers that is\r\ndivisible by them in a fast way, we can solve the rest of the problem\r\neasily (for each good number , we can store in an array and just update\r\nthis array and update the answer). Since all numbers are less than ,\r\nthen there are at most primes divisible buy . With a simple\r\npreprocesses, we can find their maximum and so easily we can find these\r\n(at most 6) primes fast. If their amount is , then there are exactly\r\ngood numbers that is divisible by them (power of each prime should be\r\neither or ). So we can perform each query in Time complexity: . C++ Code\r\nby PrinceOfPersia C++ Code by Haghani Java Code by Zlobober\r\n",
    "hint": []
}