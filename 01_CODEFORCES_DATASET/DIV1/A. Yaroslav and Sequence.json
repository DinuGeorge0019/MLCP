{
    "link": "https://codeforces.com//contest/301/problem/A",
    "problemId": "2969",
    "problem_idx": "A",
    "shortId": "301A",
    "contest_number": "301",
    "problem_submissions": {
        "E": [
            3682464,
            3681114,
            4247515
        ],
        "D": [
            3677749,
            3677901,
            3677912,
            3678115,
            3677526,
            3679062,
            3677723,
            3677856,
            3679979,
            3679661,
            3680028,
            3677527,
            3675796,
            3683550,
            3682695,
            3682463,
            3677874,
            3677050,
            3678347,
            3678222,
            3680032
        ],
        "B": [
            3675021,
            3674605,
            3676912,
            3676771,
            3675890,
            3677633,
            3681284,
            3684667,
            3684661,
            3684653,
            3684635,
            3678354,
            3678161,
            3680771,
            3678425,
            3681027,
            3676146,
            3677734,
            3676031,
            3675130
        ],
        "A": [
            3674025,
            3673473,
            3675526,
            3674656,
            3679541,
            3673757,
            3674334,
            3676412,
            3677059,
            3674545,
            3673945,
            3673341,
            3675089,
            3673194,
            3673129,
            3673585,
            3673171,
            3675681
        ],
        "C": [
            3679265,
            3679801,
            3681253,
            3680718,
            3680819,
            3680781,
            3681151,
            3681956,
            3682034,
            3680652,
            3688897,
            3683565,
            3679128,
            3680822
        ]
    },
    "name": "A. Yaroslav and Sequence",
    "statement": "Yaroslav has an array, consisting of integers. In a single operation\r\nYaroslav can change the sign of exactly elements in the array. In other\r\nwords, in one operation Yaroslav can select exactly array elements, and\r\nmultiply each of them by -1.Yaroslav is now wondering: what maximum sum\r\nof array elements can be obtained if it is allowed to perform any number\r\nof described operations?Help Yaroslav.\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\nint a,b,c,d,n,m,k;\nint mas[202];\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\tscanf(\"%d\", &n);\n\tc = 0; a = 0;\n\tb = INF;\n\trept(i, 2 * n - 1) {\n\t\tscanf(\"%d\", &mas[i]);\n\t\tc += abs(mas[i]);\n\t\tif (mas[i] < 0) ++a;\n\t\tb = min(b, abs(mas[i]));\n\t}\n\tif (a >= n) {\n\t\ta -= n;\n\t}\n\tif (n % 2 == 1 || a % 2 == 0) printf(\"%d\\n\", c); else\n\tprintf(\"%d\\n\", c - 2 * b);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Yaroslav and Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/7560",
    "editorial": "Using dfs we will find number of numbers that we can set as positive. Note that we can either set all of the numbers as positive or leave one number(any) as negative. If we can obtain all numbers as positive, we just return sum of modules of the numbers, but if we cannot we will count the same sum and will subtract minimal modular value multiple 2 from sum."
}