{
    "link": "https://codeforces.com//contest/1396/problem/E",
    "problemId": "712377",
    "problem_idx": "E",
    "shortId": "1396E",
    "contest_number": "1396",
    "problem_submissions": {
        "E": [
            91420325,
            91433351,
            91395963,
            91403549,
            91401123,
            91402411,
            91409596,
            91414724,
            91398509,
            91431034,
            98258243,
            91413242,
            91418927,
            91416810,
            100070579,
            100069379,
            91404326
        ],
        "D": [
            91388366,
            91423836,
            91402660,
            91943822,
            91410504,
            91407249,
            91405665,
            91404955,
            92387331,
            91409139,
            91420254
        ],
        "C": [
            91373061,
            91380961,
            91375173,
            91383628,
            91383246,
            91370624,
            91378488,
            91375423,
            91372747,
            91401459,
            91603982,
            91437619,
            91381246,
            91378361,
            91395543,
            91392372,
            91380457,
            91391062,
            91392240,
            91390152,
            91380894
        ],
        "B": [
            91358979,
            91360664,
            91363530,
            91358594,
            91358724,
            91359119,
            91363085,
            91359172,
            91358745,
            91363826,
            91362155,
            91366158,
            91362751,
            91365359,
            91360322,
            91364106,
            91365992,
            91378262,
            91361724,
            91365744
        ],
        "A": [
            91354401,
            91357111,
            91359227,
            91352552,
            91352349,
            91355053,
            91358883,
            91356416,
            91355726,
            91357237,
            91356536,
            91360026,
            91358794,
            91362354,
            91356173,
            91360020,
            91356069,
            91361174,
            91357755,
            91354128
        ]
    },
    "name": "E. Distance Matching",
    "statement": "You are given an integer k and a T with n nodes (n is even).Let dist(u,\r\nv) be the number of edges on the shortest path from node u to node v in\r\nT.Let us define a G = (V, E) as following: V =\r\n{x\r\nmid 1\r\nle x\r\nle n\r\n} i.e. the set of integers from 1 to n E =\r\n{(u, v, w)\r\nmid 1\r\nle u, v\r\nle n, u\r\nneq v, w = dist(u, v)\r\n} i.e. there is an edge between every pair of distinct nodes, the weight\r\nbeing the distance between their respective nodes in T Your task is\r\nsimple, find a in G with total edge weight k (1\r\nle k\r\nle n^2).\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.08.2020 18:54:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass forest : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  forest(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    assert(id < n - 1);\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nclass dfs_forest : public forest<T> {\n public:\n  using forest<T>::edges;\n  using forest<T>::g;\n  using forest<T>::n;\n\n  vector<int> pv;\n  vector<int> pe;\n  vector<int> order;\n  vector<int> pos;\n  vector<int> end;\n  vector<int> sz;\n  vector<int> root;\n  vector<int> depth;\n  vector<T> dist;\n\n  dfs_forest(int _n) : forest<T>(_n) {\n  }\n\n  void init() {\n    pv = vector<int>(n, -1);\n    pe = vector<int>(n, -1);\n    order.clear();\n    pos = vector<int>(n, -1);\n    end = vector<int>(n, -1);\n    sz = vector<int>(n, 0);\n    root = vector<int>(n, -1);\n    depth = vector<int>(n, -1);\n    dist = vector<T>(n);\n  }\n\n  void clear() {\n    pv.clear();\n    pe.clear();\n    order.clear();\n    pos.clear();\n    end.clear();\n    sz.clear();\n    root.clear();\n    depth.clear();\n    dist.clear();\n  }\n\n private:\n  void do_dfs(int v) {\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    sz[v] = 1;\n    for (int id : g[v]) {\n      if (id == pe[v]) {\n        continue;\n      }\n      auto &e = edges[id];\n      int to = e.from ^ e.to ^ v;\n      depth[to] = depth[v] + 1;\n      dist[to] = dist[v] + e.cost;\n      pv[to] = v;\n      pe[to] = id;\n      root[to] = (root[v] != -1 ? root[v] : to);\n      do_dfs(to);\n      sz[v] += sz[to];\n    }\n    end[v] = (int) order.size() - 1;\n  }\n\n  void do_dfs_from(int v) {\n    depth[v] = 0;\n    dist[v] = T{};\n    root[v] = v;\n    pv[v] = pe[v] = -1;\n    do_dfs(v);\n  }\n\n public:\n  void dfs(int v, bool clear_order = true) {\n    if (pv.empty()) {\n      init();\n    } else {\n      if (clear_order) {\n        order.clear();\n      }\n    }\n    do_dfs_from(v);\n  }\n\n  void dfs_all() {\n    init();\n    for (int v = 0; v < n; v++) {\n      if (depth[v] == -1) {\n        do_dfs_from(v);\n      }\n    }\n    assert((int) order.size() == n);\n  }\n};\n\ntemplate <typename T>\nclass lca_forest : public dfs_forest<T> {\n public:\n  using dfs_forest<T>::edges;\n  using dfs_forest<T>::g;\n  using dfs_forest<T>::n;\n  using dfs_forest<T>::pv;\n  using dfs_forest<T>::pos;\n  using dfs_forest<T>::end;\n  using dfs_forest<T>::depth;\n\n  int h;\n  vector<vector<int>> pr;\n\n  lca_forest(int _n) : dfs_forest<T>(_n) {\n  }\n\n  inline void build_lca() {\n    assert(!pv.empty());\n    int max_depth = 0;\n    for (int i = 0; i < n; i++) {\n      max_depth = max(max_depth, depth[i]);\n    }\n    h = 1;\n    while ((1 << h) <= max_depth) {\n      h++;\n    }\n    pr.resize(n);\n    for (int i = 0; i < n; i++) {\n      pr[i].resize(h);\n      pr[i][0] = pv[i];\n    }\n    for (int j = 1; j < h; j++) {\n      for (int i = 0; i < n; i++) {\n        pr[i][j] = (pr[i][j - 1] == -1 ? -1 : pr[pr[i][j - 1]][j - 1]);\n      }\n    }\n  }\n\n  inline bool anc(int x, int y) {\n    return (pos[x] <= pos[y] && end[y] <= end[x]);\n  }\n\n  inline int go_up(int x, int up) {\n    assert(!pr.empty());\n    up = min(up, (1 << h) - 1);\n    for (int j = h - 1; j >= 0; j--) {\n      if (up & (1 << j)) {\n        x = pr[x][j];\n        if (x == -1) {\n          break;\n        }\n      }\n    }\n    return x;\n  }\n\n  inline int lca(int x, int y) {\n    assert(!pr.empty());\n    if (anc(x, y)) {\n      return x;\n    }\n    if (anc(y, x)) {\n      return y;\n    }\n    for (int j = h - 1; j >= 0; j--) {\n      if (pr[x][j] != -1 && !anc(pr[x][j], y)) {\n        x = pr[x][j];\n      }\n    }\n    return pr[x][0];\n  }\n};\n\ntemplate <typename T>\nclass hld_forest : public lca_forest<T> {\n public:\n  using lca_forest<T>::edges;\n  using lca_forest<T>::g;\n  using lca_forest<T>::n;\n  using lca_forest<T>::pv;\n  using lca_forest<T>::sz;\n  using lca_forest<T>::pos;\n  using lca_forest<T>::order;\n  using lca_forest<T>::depth;\n  using lca_forest<T>::dfs;\n  using lca_forest<T>::dfs_all;\n  using lca_forest<T>::lca;\n  using lca_forest<T>::build_lca;\n\n  vector<int> head;\n  vector<int> visited;\n\n  hld_forest(int _n) : lca_forest<T>(_n) {\n    visited.resize(n);\n  }\n\n  void build_hld(const vector<int> &vs) {\n    for (int tries = 0; tries < 2; tries++) {\n      if (vs.empty()) {\n        dfs_all();\n      } else {\n        order.clear();\n        for (int v : vs) {\n          dfs(v, false);\n        }\n        assert((int) order.size() == n);\n      }\n      if (tries == 1) {\n        break;\n      }\n      for (int i = 0; i < n; i++) {\n        if (g[i].empty()) {\n          continue;\n        }\n        int best = -1, bid = 0;\n        for (int j = 0; j < (int) g[i].size(); j++) {\n          int id = g[i][j];\n          int v = edges[id].from ^ edges[id].to ^ i;\n          if (pv[v] != i) {\n            continue;\n          }\n          if (sz[v] > best) {\n            best = sz[v];\n            bid = j;\n          }\n        }\n        swap(g[i][0], g[i][bid]);\n      }\n    }\n    build_lca();\n    head.resize(n);\n    for (int i = 0; i < n; i++) {\n      head[i] = i;\n    }\n    for (int i = 0; i < n - 1; i++) {\n      int x = order[i];\n      int y = order[i + 1];\n      if (pv[y] == x) {\n        head[y] = head[x];\n      }\n    }\n  }\n\n  void build_hld(int v) {\n    build_hld(vector<int>(1, v));\n  }\n\n  void build_hld_all() {\n    build_hld(vector<int>());\n  }\n\n  bool apply_on_path(int x, int y, bool with_lca, function<void(int,int,bool)> f) {\n    // f(x, y, up): up -- whether this part of the path goes up\n    assert(!head.empty());\n    int z = lca(x, y);\n    if (z == -1) {\n      return false;\n    }\n    {\n      int v = x;\n      while (v != z) {\n        if (depth[head[v]] <= depth[z]) {\n          f(pos[z] + 1, pos[v], true);\n          break;\n        }\n        f(pos[head[v]], pos[v], true);\n        v = pv[head[v]];\n      }\n    }\n    if (with_lca) {\n      f(pos[z], pos[z], false);\n    }\n    {\n      int v = y;\n      int cnt_visited = 0;\n      while (v != z) {\n        if (depth[head[v]] <= depth[z]) {\n          f(pos[z] + 1, pos[v], false);\n          break;\n        }\n        visited[cnt_visited++] = v;\n        v = pv[head[v]];\n      }\n      for (int at = cnt_visited - 1; at >= 0; at--) {\n        v = visited[at];\n        f(pos[head[v]], pos[v], false);\n      }\n    }\n    return true;\n  }\n};\n\nclass segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    int sum = 0;\n    bool flip = false;\n\n    void apply(int l, int r) {\n      sum = (r - l + 1) - sum;\n      flip = !flip;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.sum = a.sum + b.sum;\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    // push from x into (x + 1) and z\n    if (tree[x].flip) {\n      tree[x + 1].apply(l, y);\n      tree[z].apply(y + 1, r);\n      tree[x].flip = false;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  long long k;\n  cin >> n >> k;\n  hld_forest<int> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g.add(x, y);\n  }\n  g.dfs(0);\n  int root = 0;\n  while (true) {\n    int new_root = -1;\n    for (int eid : g.g[root]) {\n      auto& e = g.edges[eid];\n      int to = e.from ^ e.to ^ root;\n      if (to == g.pv[root]) {\n        continue;\n      }\n      if (2 * g.sz[to] >= n) {\n        new_root = to;\n        break;\n      }\n    }\n    if (new_root == -1) {\n      break;\n    }\n    root = new_root;\n  }\n  g.build_hld(root);\n  long long L = 0;\n  long long R = 0;\n  for (int i = 0; i < n; i++) {\n    if (i != root) {\n      R += g.sz[i];\n      L += g.sz[i] % 2;\n    }\n  }\n  debug(k, L, R);\n  if (k < L || k > R || k % 2 != L % 2) {\n    cout << \"NO\" << '\\n';\n    return 0;\n  }\n  cout << \"YES\" << '\\n';\n  vector<int> rt(n);\n  for (int v : g.order) {\n    rt[v] = v;\n    if (v != root && g.pv[v] != root) {\n      rt[v] = rt[g.pv[v]];\n    }\n  }\n  vector<vector<int>> sets(n);\n  for (int i = 0; i < n; i++) {\n    sets[rt[i]].push_back(i);\n  }\n  for (int i = 0; i < n; i++) {\n    assert(2 * (int) sets[i].size() <= n);\n  }\n  set<pair<int, int>> s;\n  for (int i = 0; i < n; i++) {\n    sort(sets[i].begin(), sets[i].end(), [&](int u, int v) {\n      return g.depth[u] < g.depth[v];\n    });\n    if (!sets[i].empty()) {\n      s.emplace((int) sets[i].size(), i == root ? -1 : i);\n    }\n  }\n  segtree st(n);\n  for (int i = 1; i < n; i++) {\n    if (g.sz[g.order[i]] % 2 == 0) {\n      st.modify(i, i);\n    }\n  }\n  vector<pair<int, int>> ret;\n  long long diff = k - L;\n  vector<bool> used(n, false);\n  while (!s.empty() && diff > 0) {\n    auto it1 = prev(s.end());\n    assert(it1 != s.begin());\n    auto it2 = prev(it1);\n    int i1 = it1->second;\n    int i2 = it2->second;\n    if (i1 == -1) {\n      i1 = root;\n    }\n    if (i2 == -1) {\n      i2 = root;\n    }\n    int v1 = sets[i1].back();\n    int v2 = sets[i2].back();\n    s.erase(s.find(make_pair((int) sets[i1].size(), i1 == root ? -1 : i1)));\n    s.erase(s.find(make_pair((int) sets[i2].size(), i2 == root ? -1 : i2)));\n    sets[i1].pop_back();\n    sets[i2].pop_back();\n    if (!sets[i1].empty()) {\n      s.emplace((int) sets[i1].size(), i1 == root ? -1 : i1);\n    }\n    if (!sets[i2].empty()) {\n      s.emplace((int) sets[i2].size(), i2 == root ? -1 : i2);\n    }\n    long long change = 0;\n    g.apply_on_path(v1, v2, false, [&](int from, int to, bool) {\n      change += st.get(from, to).sum;\n    });\n    while (!g.anc(v2, v1) && 2 * change > diff) {\n      change -= st.get(g.pos[v2], g.pos[v2]).sum;\n      v2 = g.pv[v2];\n    }\n    while (!g.anc(v1, v2) && 2 * change > diff) {\n      change -= st.get(g.pos[v1], g.pos[v1]).sum;\n      v1 = g.pv[v1];\n    }\n    diff -= 2 * change;\n    if (used[v1] || used[v2]) {\n      assert(diff == 0);\n      int lca = g.lca(v1, v2);\n      vector<int> path1;\n      vector<int> path2;\n      while (v1 != lca) {\n        path1.push_back(v1);\n        v1 = g.pv[v1];\n      }\n      while (v2 != lca) {\n        path2.push_back(v2);\n        v2 = g.pv[v2];\n      }\n      vector<int> path;\n      for (int x : path1) {\n        path.push_back(x);\n      }\n      path.push_back(lca);\n      for (int x : vector<int>(path2.rbegin(), path2.rend())) {\n        path.push_back(x);\n      }\n      debug(path);\n      int p1 = 0;\n      int p2 = (int) path.size() - 1;\n      while (p1 < p2 && used[path[p1]]) {\n        ++p1;\n      }\n      while (p1 < p2 && used[path[p2]]) {\n        --p2;\n      }\n      for (int ver : path) if (!used[ver]) debug(ver);\n      assert(p1 < p2);\n      v1 = path[p1];\n      v2 = path[p2];\n    }\n    ret.emplace_back(v1, v2);\n    used[v1] = true;\n    used[v2] = true;\n    g.apply_on_path(v1, v2, false, [&](int from, int to, bool) {\n      st.modify(from, to);\n    });\n  }\n  vector<int> any(n, -1);\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) {\n      any[i] = i;\n    }\n  }\n  for (int it = n - 1; it >= 1; it--) {\n    int v = g.order[it];\n    if (any[v] != -1) {\n      int u = g.pv[v];\n      if (any[u] != -1) {\n        ret.emplace_back(any[v], any[u]);\n        any[u] = -1;\n      } else {\n        any[u] = any[v];\n      }\n    }\n  }\n  assert((int) ret.size() == n / 2);\n  for (int i = 0; i < n; i++) {\n    used[i] = false;\n  }\n  for (auto& p : ret) {\n    assert(0 <= p.first && p.first < n && 0 <= p.second && p.second < n);\n    assert(!used[p.first]);\n    used[p.first] = true;\n    assert(!used[p.second]);\n    used[p.second] = true;\n  }\n  long long total = 0;\n  for (auto& p : ret) {\n    int u = p.first;\n    int v = p.second;\n    int z = g.lca(u, v);\n    total += g.depth[u] + g.depth[v] - 2 * g.depth[z];\n  }\n  assert(total == k);\n  for (auto& p : ret) {\n    cout << p.first + 1 << \" \" << p.second + 1 << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Distance Matching.json",
    "editorial_link": "https://codeforces.com//blog/entry/82142",
    "editorial": "Root the tree at centroid .First, determine if there is any matching\r\nthat satisfies the requirement. Consider an edge that splits the tree\r\ninto subtrees with sizes and respectively, let be the number of paths\r\npassing through , then we have has the same parity as and . Thus the\r\nnecessary condition for a matching is and has the same parity as , where\r\nand is the size of the subtree rooted at . We prove that this is also\r\nthe sufficient condition by its construction:Consider the matching with\r\nmaximum , note that lies on all the paths in the matching.We can see\r\nthat if we remove two vertices from the largest subtree, rooted at ,\r\nthen is still the centroid. Also, if we match two vertices and in the\r\nsubtree rooted at , the answer decreases by . Based on this, we can\r\nachieve the target by repeating the following operation ( is the current\r\nmaximum possible , initially ): Let be a non-leaf vertex in the largest\r\nsubtree such that (if there are many , take any with maximum ). Match\r\ntwo vertices and whose LCA is , then remove and from the tree. After\r\nsome time , so we just need to greedily match the remaining vertices to\r\ncreate the final matching.The final complexity is .\r\n",
    "hint": []
}