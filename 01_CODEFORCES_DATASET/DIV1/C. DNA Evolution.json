{
    "link": "https://codeforces.com//contest/827/problem/C",
    "problemId": "113847",
    "problem_idx": "C",
    "shortId": "827C",
    "contest_number": "827",
    "problem_submissions": {
        "F": [
            28447535,
            28704912
        ],
        "B": [
            28442493,
            28434829,
            28432891,
            28434941,
            28434124,
            28440743,
            28434219,
            28434038,
            28435758,
            28436170,
            28442340,
            28436191,
            28436588,
            28434003,
            28436389,
            28434757,
            28437055,
            28448594,
            28438989
        ],
        "C": [
            28440487,
            28438660,
            28438441,
            28438938,
            28437666,
            28446435,
            28437809,
            28439569,
            28439405,
            28439836,
            28438472,
            28441170,
            28440770,
            28437931,
            28442353,
            28442274,
            28441410,
            28437286,
            28455031,
            28442955
        ],
        "E": [
            28436548,
            28441080,
            28466758,
            28444795,
            28441962,
            28439200,
            28445462,
            28450329,
            28446470,
            28443820,
            28444149,
            28441607,
            28444424,
            28451564,
            28465030,
            28453083,
            28453061,
            28452855,
            28445979,
            28445398,
            28447328,
            28450262,
            28443711,
            28447639
        ],
        "A": [
            28432871,
            28432173,
            28431465,
            28433215,
            28452981,
            28437424,
            28432872,
            28451754,
            28432696,
            28432687,
            28432382,
            28432827,
            28432606,
            28431751,
            28435184,
            28437702,
            28433063,
            28446111,
            28434053
        ],
        "D": [
            28445554,
            28441989,
            28447486,
            28446928,
            28441195,
            28445740,
            28448719,
            28454047,
            28460505,
            28543175,
            28454400,
            28446342,
            28447977,
            29638472,
            28445305,
            28443739
        ]
    },
    "name": "C. DNA Evolution",
    "statement": "Everyone knows that DNA strands consist of nucleotides. There are four\r\ntypes of nucleotides: \"\", \"\", \"\", \"\". A DNA strand is a sequence of\r\nnucleotides. Scientists decided to track evolution of a rare species,\r\nwhich DNA strand was string initially. Evolution of the species is\r\ndescribed as a sequence of changes in the DNA. Every change is a change\r\nof some nucleotide, for example, the following change can happen in DNA\r\nstrand \"\": the second nucleotide can change to \"\" so that the resulting\r\nDNA strand is \"\".Scientists know that some segments of the DNA strand\r\ncan be affected by some unknown infections. They can represent an\r\ninfection as a sequence of nucleotides. Scientists are interested if\r\nthere are any changes caused by some infections. Thus they sometimes\r\nwant to know the value of impact of some infection to some segment of\r\nthe DNA. This value is computed as follows: Let the infection be\r\nrepresented as a string , and let scientists be interested in DNA strand\r\nsegment starting from position to position , inclusive. Prefix of the\r\nstring (i.e. the string that consists of infinitely many repeats of\r\nstring ) is written under the string from position to position ,\r\ninclusive. The value of impact is the number of positions where letter\r\nof string coincided with the letter written under it. Being a developer,\r\nInnokenty is interested in bioinformatics also, so the scientists asked\r\nhim for help. Innokenty is busy preparing VK Cup, so he decided to\r\ndelegate the problem to the competitors. Help the scientists!\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct fenw{\n  VI fw;\n  in n;\n  void ini(in pn){\n    n=pn;\n    fw.clear();\n    fw.resize(n,0);\n  }\n  void ad(in l, in x){\n    while(l<n){\n      fw[l]+=x;\n      l|=(l+1);\n    }\n  }\n  in sm(in l){\n    in r=0;\n    while(l>=0){\n      r+=fw[l];\n      l&=(l+1);\n      --l;\n    }\n    return r;\n  }\n};\nmap<char,in> dcd;\nconst in mx=1e5+9;\nvector<vector<vector<fenw> > > fw; // fw[a][b][c] has 1 at i if letter a is at i*b+c\nvoid adt(in l, in typ, in f){\n  for(in lt=1;lt<=10;++lt){\n    fw[typ][lt][l%lt].ad(l/lt,f);\n  }\n}\nstring s;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  dcd['A']=0;\n  dcd['C']=1;\n  dcd['G']=2;\n  dcd['T']=3;\n  fw.resize(4);\n  forn(i,4){\n    fw[i].resize(11);\n    for(in j=1;j<=10;++j){\n      fw[i][j].resize(j);\n      forn(k,j){\n\tfw[i][j][k].ini(mx/j+9);\n      }\n    }\n  }\n  cin>>s;\n  forv(i,s){\n    adt(i,dcd[s[i]],1);\n  }\n  in q;\n  cin>>q;\n  in typ,x,l,r;\n  char c;\n  string e;\n  in sm;\n  in lt;\n  in loc;\n  forn(z,q){\n    cin>>typ;\n    if(typ==1){\n      cin>>x>>c;\n      --x;\n      adt(x,dcd[s[x]],-1);\n      s[x]=c;\n      adt(x,dcd[s[x]],1);\n    }\n    else{\n      cin>>l>>r>>e;\n      --l;\n      --r;\n      sm=0;\n      lt=sz(e);\n      forv(i,e){\n\tloc=(l+i)%lt;\n\tif(r-loc>=0)\n\t  sm+=fw[dcd[e[i]]][lt][loc].sm((r-loc)/lt);\n\tif(l-1-loc>=0)\n\t  sm-=fw[dcd[e[i]]][lt][loc].sm((l-1-loc)/lt);\n      }\n      cout<<sm<<\"\\n\";\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "strings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. DNA Evolution.json",
    "editorial_link": "https://codeforces.com//blog/entry/53268",
    "editorial": "Note that there are only different characters and queries\u00e2\u0080\u0099 lengths are\r\nonly up to . How does this help? Let\u00e2\u0080\u0099s make arrays of length for each of\r\nthe possible letters, putting where the letter in is that letter, and\r\notherwise. We can update these arrays easily with update\r\nqueries.Consider a letter in a query string . It appears equidistantly\r\nin the string we write down under the string . Thus, we should count the\r\nnumber of ones (in one of our four arrays) at positions which indices\r\nform an arithmetic progression, and bounded by some segment (the query\r\nsegment ). This sounds hard, but we can note that the difference between\r\nthe indices (i.e. the common difference of the arithmetic progression)\r\nis not larger than . Thus, we can store copies of each of four arrays we\r\ncreated above. For the -th copy of some letter, we reorder the elements\r\nso that first we put all positions for which , then all positions for\r\nwhich , and so on. This will make possible to change each query on an\r\narithmetic progression to a sum query on a segment. Thus, we can just\r\nsum up answers for each letter in string .\r\n"
}