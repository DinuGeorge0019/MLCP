{"link": "https://codeforces.com//contest/804/problem/A", "problemId": "105172", "problem_idx": "A", "shortId": "804A", "contest_number": "804", "problem_submissions": {"D": [26864569, 26864084, 26864065, 26863844, 26859532, 26855737, 26853547, 26853205, 26854566, 26856630, 26853214, 26855855, 26861591, 26863648, 26855151, 26854613, 26864015, 26856289, 26858468, 26856391], "C": [26847789, 26844906, 26857930, 26847099, 26856657, 26848089, 26857400, 26856222, 26845185, 26848695, 26846499, 26847477, 26843068, 26846575, 26859352, 26846716, 26860420, 26846219, 26852629], "B": [26841209, 26838692, 26840551, 26839159, 26839206, 26840437, 26840273, 26854727, 26841332, 26842906, 26840147, 26841623, 26839518, 26840190, 26840304, 26839516, 26840017, 26847973, 26839966], "A": [26838410, 26837453, 26837406, 26837277, 26841198, 26837228, 26837723, 26837298, 26837762, 26837644, 26837931, 26837280, 26837588, 26838739, 26837615, 26837337, 26846921, 26837692], "E": [26859757, 26861113, 26864419, 26864227, 26864109, 26864035, 26863863, 26860566, 26862404, 26859605, 26854745, 26861397, 26884422, 26865231, 26853306, 26856744, 26859172]}, "name": "A. Find Amir", "statement": "A few years ago Sajjad left his school and register to another one due\r\nto security reasons. Now he wishes to find Amir, one of his schoolmates\r\nand good friends.There are schools numerated from to . One can travel\r\nbetween each pair of them, to do so, he needs to buy a ticket. The\r\nticker between schools and costs and can be used multiple times. Help\r\nSajjad to find the minimum cost he needs to pay for tickets to visit all\r\nschools. He can start and finish in any school.\r\n", "solutions": ["/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\nusing namespace std;\n\nclass TaskA {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n;\n\t\tin >> n;\n\t\tint l = 1;\n\t\tint r = n;\n\t\tvector<int> v;\n\t\twhile (l <= r) {\n\t\t\tv.push_back(l++);\n\t\t\tif (l <= r) {\n\t\t\t\tv.push_back(r--);\n\t\t\t}\n\t\t}\n\t\tint64_t ans = 0;\n\t\tfor (int i: range(1, n)) {\n\t\t\tans += (v[i] + v[i - 1]) % (n + 1);\n\t\t}\n\t\tout << ans << \"\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskA solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "math"], "dificulty": "1000", "interactive": false}