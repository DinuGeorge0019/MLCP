{
    "link": "https://codeforces.com//contest/403/problem/D",
    "problemId": "7186",
    "problem_idx": "D",
    "shortId": "403D",
    "contest_number": "403",
    "problem_submissions": {
        "E": [
            6040937,
            154984304,
            6052630,
            6052356,
            14574817,
            14574735,
            14574710,
            14574669,
            14574665,
            6040453
        ],
        "A": [
            6035160,
            6030951,
            6030860,
            6031178,
            6034007,
            6030859,
            6031215,
            6036883,
            6034828,
            6031673,
            6031177,
            6031105,
            6030857,
            6031293,
            6030993,
            6042179,
            6030867,
            6040743,
            6030907,
            6031032
        ],
        "D": [
            6032031,
            6036149,
            6037514,
            6035188,
            6038552,
            6036821,
            6037360,
            6035214,
            6032979,
            6051793,
            6039305,
            6040517,
            6037815,
            6037208,
            6040122,
            6042199,
            6036355,
            6036730,
            6039500,
            6040454
        ],
        "B": [
            6037462,
            6032575,
            6037115,
            6031670,
            6038606,
            6034965,
            6038593,
            6037275,
            6035133,
            6032908,
            6036968,
            6034116,
            6033389,
            6034279,
            6042123,
            6032620,
            6032444,
            6034225
        ],
        "C": [
            6033086,
            6035964,
            6032440,
            6032942,
            6033609,
            6032046,
            6031154,
            6035769,
            6036195,
            6034842,
            6032124,
            6038424,
            6038292,
            6035730,
            6042190,
            6033591,
            6038234,
            6037774,
            6036096
        ]
    },
    "name": "D. Beautiful Pairs of Numbers",
    "statement": "The sequence of integer pairs is , if the following statements are\r\nfulfilled: , where is a given positive integer; all numbers , , , are\r\ndistinct. For the given number find the number of beautiful sequences of\r\nlength . As the answer can be rather large, print the remainder after\r\ndividing it by .\r\n",
    "solutions": [
        "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<\" = \"<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\n\n#define MD 1000000007\n#define maxn 1010\n\nint C[maxn][maxn], fact[maxn], dp[maxn][maxn];\n\nvoid su(int &a, int b)\n{\n\ta+=b; if (a>=MD) a-=MD;\n}\n\nvoid lemon()\n{\n\tC[0][0]=1;\n\trep(i,1,1000)\n\t{\n\t\tC[i][0]=1; C[i][i]=1;\n\t\trep(j,1,i-1)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%MD;\n\t}\n\t\n\tfact[0]=1;\n\trep(i,1,1000) fact[i]=LL(fact[i-1])*i%MD;\n\t\n\t//dp[s][k]=sum(dp[s-k*i+1][k-1]) i>=1\n\trep(s,0,1000)\n\t{\n\t\tdp[s][1]=1;\n\t\trep(k,2,1000)\n\t\t\trep(i,1,(s+1)/k)\n\t\t\t\tsu(dp[s][k],dp[s-i*k+1][k-1]);\n\t}\n\t\n\trep(s,0,1000)\n\t\trep(k,0,1000)\n\t\t\tdp[s][k]=LL(dp[s][k])*fact[k]%MD;\n\t\t\t\n\tint tcase; scanf(\"%d\",&tcase);\n\twhile (tcase--)\n\t{\n\t\tint n,k; scanf(\"%d%d\",&n,&k);\n\t\tint final=0;\n\t\trep(s,0,n)\n\t\t\tsu(final,LL(C[n-s][k])*dp[s][k]%MD);\n\t\tprintf(\"%d\\n\",final);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(true);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"D.in\",\"r\",stdin);\n\t#endif\n\tlemon();\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Beautiful Pairs of Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/10972",
    "editorial": "First, we can note, that length of sequence is not greater then . Ok,\r\nbut why? Because all numbers are different, so . Letâs imagine, that\r\nsequence from input is a sequence of non-intersecting segments. So, is\r\nlength of segment . Also, . After that letâs calculate the following DP:\r\nnumber of sequences for which following holds: , , and maximal number is\r\nless then (upper bound of sequence). This DP will helps us to calculate\r\nnumber of ways to set length to each segment in sequence. Itâs simple to\r\ncalculate such DP: We can calculate such DP, by using only of memory,\r\nwhere . After that we should multiply on , because we need number of\r\nsequences , where order does not matter. After that we can calculate\r\nanswer for . Letâs , where some upper bound of sequences. After that we\r\nshould calculate next number: how many ways to set to distances between\r\nsegments? Itâs clear, that we can increase distance between some\r\nsegments, but we have only such operations. Itâs well known, that answer\r\nnumber of ways equals to . So, for each we should sum by following\r\nvalues: . Note, that we need array (binomials) where .\r\n",
    "hint": []
}