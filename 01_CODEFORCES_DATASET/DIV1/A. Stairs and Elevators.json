{
    "link": "https://codeforces.com//contest/966/problem/A",
    "problemId": "179475",
    "problem_idx": "A",
    "shortId": "966A",
    "contest_number": "966",
    "problem_submissions": {
        "E": [
            37728467,
            37721887,
            37727395,
            37722353,
            46428064,
            37735854,
            37726097,
            37728168,
            37731395,
            37731373
        ],
        "D": [
            37722933,
            37721182,
            37720577,
            37745366,
            37727547,
            37724656,
            37720856,
            37720615,
            37721601,
            37723190,
            37720741,
            37720916,
            37854456,
            37723453,
            37723867,
            37723823,
            37723640,
            37725199
        ],
        "C": [
            37716531,
            37723619,
            37716233,
            37716062,
            37721394,
            37719905,
            37724974,
            37710146,
            37715347,
            37715961,
            37715642,
            37715427,
            37717480,
            37715886,
            37716616,
            37716460,
            37712823,
            37718703,
            37718856
        ],
        "B": [
            37712342,
            37710216,
            37712076,
            37714505,
            37717238,
            37717093,
            37713464,
            37712937,
            37711956,
            37712143,
            37712153,
            37712830,
            37714037,
            37717527,
            37712504,
            37714456,
            37719214,
            37710052,
            37715647
        ],
        "A": [
            37709493,
            37711125,
            37709073,
            37709222,
            37711428,
            37711424,
            37710230,
            37723341,
            37715473,
            37709490,
            37710976,
            37717218,
            37726403,
            37716138,
            37716852,
            37710495,
            37715732,
            37712927,
            37711795
        ],
        "F": [
            37856043
        ]
    },
    "name": "A. Stairs and Elevators",
    "statement": "In the year of 30XX participants of some world programming championship\r\nlive in a single large hotel. The hotel has n floors. Each floor has m\r\nsections with a single corridor connecting all of them. The sections are\r\nenumerated from 1 to m along the corridor, and all sections with equal\r\nnumbers on different floors are located exactly one above the other.\r\nThus, the hotel can be represented as a rectangle of height n and width\r\nm. We can denote sections with pairs of integers (i, j), where i is the\r\nfloor, and j is the section number on the floor.The guests can walk\r\nalong the corridor on each floor, use stairs and elevators. Each stairs\r\nor elevator occupies all sections (1, x), (2, x),\r\nldots, (n, x) for some x between 1 and m. All sections not occupied with\r\nstairs or elevators contain guest rooms. It takes one time unit to move\r\nbetween neighboring sections on the same floor or to move one floor up\r\nor down using stairs. It takes one time unit to move up to v floors in\r\nany direction using an elevator. You can assume you donâ€™t have to wait\r\nfor an elevator, and the time needed to enter or exit an elevator is\r\nnegligible.You are to process q queries. Each query is a question \"what\r\nis the minimum time needed to go from a room in section (x_1, y_1) to a\r\nroom in section (x_2, y_2)?\"\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nint n,m,q,na,nb,a[100010],b[100010],v,p;\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,sx,sy,tx,ty;\n\tscanf(\"%d%d%d%d%d\",&n,&m,&na,&nb,&v);\n\tfor(i=1;i<=na;i++)\n\t  scanf(\"%d\",&a[i]);\n\tfor(i=1;i<=nb;i++)\n\t  scanf(\"%d\",&b[i]);\n\tsort(a+1,a+na+1);\n\tsort(b+1,b+nb+1);\n\tscanf(\"%d\",&q);\n\twhile(q--)\n\t  {\n       scanf(\"%d%d%d%d\",&sx,&sy,&tx,&ty);\n       p=1e9;\n       if(na)\n         {\n          i=lower_bound(a+1,a+na+1,sy)-a;\n          if(i>0 && i<=na)\n            p=min(p,abs(a[i]-sy)+abs(a[i]-ty)+abs(sx-tx));\n          i--;\n          if(i>0 && i<=na)\n            p=min(p,abs(a[i]-sy)+abs(a[i]-ty)+abs(sx-tx));\n         }\n       if(nb)\n         {\n          i=lower_bound(b+1,b+nb+1,sy)-b;\n          if(i>0 && i<=nb)\n            p=min(p,abs(b[i]-sy)+abs(b[i]-ty)+(abs(sx-tx)-1)/v+1);\n          i--;\n          if(i>0 && i<=nb)\n            p=min(p,abs(b[i]-sy)+abs(b[i]-ty)+(abs(sx-tx)-1)/v+1);\n         }\n       if(sx==tx)\n         p=abs(ty-sy);\n       printf(\"%d\\n\",p);\n      }\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Stairs and Elevators.json",
    "editorial_link": "https://codeforces.com//blog/entry/59173",
    "editorial": "First thing to mention is that we can use no more than one stairs or elevator per query. Indeed, optimal path is always a few sections horizontally, then a stair of elevator, then a few sections horizontally.\n\nThen, we can note that we can always use one of the nearest stairs/elevators to start/finish. Using this fact, we can binary search in the sequence of stairs/elevators to find the optimal one, and choose the optimum between using a stairs and an elevator. Don't forget about the case where you don't have to reach any stairs/elevators.",
    "hint": []
}