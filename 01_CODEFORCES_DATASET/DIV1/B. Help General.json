{
    "link": "https://codeforces.com//contest/142/problem/B",
    "problemId": "756",
    "problem_idx": "B",
    "shortId": "142B",
    "contest_number": "142",
    "problem_submissions": {
        "D": [
            1037429,
            1033957,
            1037084,
            1113531,
            1036315,
            1036207,
            1039046,
            1039771,
            1035511,
            1039807
        ],
        "C": [
            1036084,
            1037803,
            1040168,
            1038580,
            1038178,
            1041260,
            1038906,
            1038902,
            1038753,
            1034775,
            1040737,
            1039056,
            1038416,
            1037153,
            1034481
        ],
        "B": [
            1032453,
            1035023,
            1033212,
            1031763,
            1032487,
            1041275,
            1033427,
            1034500,
            1033279,
            1036000,
            1032039,
            1042729,
            1042583,
            1032611,
            1033180,
            1033834,
            1032713,
            1034068,
            1032534
        ],
        "A": [
            1031075,
            1031753,
            1031668,
            1031166,
            1031287,
            1041290,
            1031330,
            1031886,
            1032150,
            1031269,
            1033203,
            1031404,
            1031249,
            1031261,
            1031962,
            1031577,
            1031132
        ],
        "E": [
            1356376,
            1131959,
            1131952,
            1131947
        ]
    },
    "name": "B. Help General",
    "statement": "Once upon a time in the Kingdom of Far Far Away lived Sir Lancelot, the\r\nchief Royal General. He was very proud of his men and he liked to invite\r\nthe King to come and watch drill exercises which demonstrated the\r\nfighting techniques and tactics of the squad he was in charge of. But\r\ntime went by and one day Sir Lancelot had a major argument with the\r\nFairy Godmother (there were rumors that the argument occurred after the\r\ngeneral spoke badly of the Godmother\u2019s flying techniques. That seemed to\r\nhurt the Fairy Godmother very deeply). As the result of the argument,\r\nthe Godmother put a rather strange curse upon the general. It sounded\r\nall complicated and quite harmless: \"\"The drill exercises are held on a\r\nrectangular field, split into square segments for each soldier. Thus,\r\nthe square of the distance between the soldiers that stand on squares\r\nand equals exactly . Now not all squad soldiers can participate in the\r\ndrill exercises as it was before the Fairy Godmother\u2019s curse. Unless, of\r\ncourse, the general wants the soldiers to fight with each other or even\r\nworse... For example, if he puts a soldier in the square , then he\r\ncannot put soldiers in the squares , , and each of them will conflict\r\nwith the soldier in the square .Your task is to help the general. You\r\nare given the size of the drill exercise field. You are asked to\r\ncalculate the maximum number of soldiers that can be simultaneously\r\npositioned on this field, so that no two soldiers fall under the Fairy\r\nGodmother\u2019s curse.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <queue>\n#include <memory.h>\n#include <stack>\n#define mp make_pair\n#define pb push_back                     \n#define setval(a,v) memset(a,v,sizeof(a))\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nint color[1100][1100];\n\nint cnt[2];\nint n,m;\n\nvoid dfs(int x,int y,int c){\n    if (x < 0 || y < 0 || x >= n || y >= m)\n        return;\n    if (color[x][y] != -1){\n        assert(color[x][y] == c);\n        return;\n    }\n    color[x][y] = c;\n    cnt[c]++;\n    for (int i = -1; i <= 1; i+=2)\n        for (int j = -1; j <= 1; j+=2){\n            dfs(x+i,y+2*j,1-c);\n            dfs(x+2*j,y+i,1-c);\n        }\n    return;\n}\n\nint main()\n{\n  #ifdef LOCAL\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n  #endif\n    scanf(\"%d %d\",&n,&m);\n    memset(color,-1,sizeof(color));\n\n    int ans = 0;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n           if (color[i][j] == -1){\n              cnt[0] = cnt[1] = 0;\n              dfs(i,j,0);\n              ans += max(cnt[0],cnt[1]);\n           } \n\n    cout << ans << endl;\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Help General.json",
    "editorial_link": "https://codeforces.com/blog/entry/3651",
    "editorial": "This problem was not on derivation of the general formula m*n - (m*n)/2 (only this would be too simple for the second/fourth problem, isn't it?) but rather on accurate investigation of several cases. Unfortunately, many participants were very eager to submit the formula above, that's why there were so many hacks. I would say: this is not jury fault - pretests were made very weak intentionally, partially - to give you some space for hacks; but jury didn't presume there would be so many hacks. This is your fault of submitting unproven solutions. This is large risk given Codeforces rules, and this time risk-lovers were not lucky =)\n\nOk, let's come to the solution. Without loss of generality let's assume m <= n. Then we have the following cases:\n1. m = 1 x n fields. It is obvious that here the answer is n.\n2. m = 2 x n >= 2 fields. Here the correct formula is 2*[2*(n/4) + min(n%4, 2)]. Why so? To see this draw the board for arbitrary n and draw all possible knight moves on it. In general, you'll see four not overlapping chains. Since you cannot place soldiers in the neighboring cells of any chain, then for a chain of length L the answer doesn't exceed (L - L/2). On the other hand, it is clear that the answer (L - L/2) is always possible since soldiers on different chains never hurt each other. If you consider fields with different remainders n%4, the formula above becomes clear.\n3. m >= 3 x n >= 3 fields, except the cases 3 x 3, 3 x 5, 3 x 6 and 4 x 4. Here one may use general formula m*n - (m*n)/2. Why so? It is known (or becomes known with google) that for all such fields knight tours exists. Any knight tour is just a chain of lenght m*n, so by the logic above one cannot place more than m*n - (m*n)/2 soldiers on it. On the other hand, if one makes chessboard coloring of the field, it is clear that the answer above is always achievable if one chooses cells of one color as places for soldiers. So, formula above is proved.\n4. Cases 3 x 3, 3 x 5, 3 x 6 and 4 x 4. Here we can't use the logic above to prove that the above formula is also right here. The easiest way is to verify it using brute-force or pen and paper. This concludes the solution."
}