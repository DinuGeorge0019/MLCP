{"link": "https://codeforces.com//contest/668/problem/E", "problemId": "57063", "problem_idx": "E", "shortId": "668E", "contest_number": "668", "problem_submissions": {"F": [17499550, 17496606, 17499490, 17520108, 17532592, 18501140, 17506872], "B": [17492263, 17485934, 18962334, 18962098, 17485171, 17485437, 17486714, 17488923, 17486945, 17485337, 17484629, 17487464, 17484958, 17488407, 17491479, 17485748, 17490028, 17488673, 17494403, 17485637], "D": [17490332, 17487430, 17490281, 17491665, 17491589, 17491023, 17492381, 17491847, 17510482, 17491540, 17491742, 17492256, 17492993, 17492659, 17489839, 17492977, 17494347, 17514667, 17493357, 17493004, 17491261], "C": [17488542, 17483428, 17488211, 17499595, 17489413, 17489671, 17487966, 17489865, 17488377, 17490380, 17490343, 17491934, 17490751, 17488239, 17491003, 17488540, 17492291, 17488705, 17488521], "A": [17482539, 17489363, 17482477, 17482341, 17484937, 17482743, 17482929, 17482753, 17482646, 17483327, 17482913, 17484500, 17493264, 17483554, 17483365, 17482861, 17485075, 17503074], "E": [17501421, 17514396, 17516687, 17501875, 18500143, 17500162, 17503103]}, "name": "E. Little Artem and 2-SAT", "statement": "Little Artem is a very smart programmer. He knows many different\r\ndifficult algorithms. Recently he has mastered in one.In computer\r\nscience, 2-satisfiability (abbreviated as ) is the special case of the\r\nproblem of determining whether a conjunction (logical ) of disjunctions\r\n(logical ) have a solution, in which all disjunctions consist of no more\r\nthan two arguments (variables). For the purpose of this problem we\r\nconsider only formulas where each disjunction consists of exactly two\r\narguments.Consider the following problem as an example: . Note that\r\nthere might be negations in formula (like for and for ).Artem now tries\r\nto solve as many problems with as possible. He found a very interesting\r\none, which he can not solve yet. Of course, he asks you to help him. The\r\nproblem is: given two formulas and , determine whether their sets of\r\npossible solutions are the same. Otherwise, find any variables\r\nassignment such that .\r\n", "solutions": ["#include <algorithm>\n#include <assert.h>\n#include <complex>\n#include <ctype.h>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <locale.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n\n#pragma warning(disable:4996)\nusing namespace std;\n\n#define mp make_pair\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <ldb, ldb> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000007;\nconst int INF = 1034567890;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst ldb ERR = 1E-16;\n\nint N;\ninline int ch(int x) {\n\tif (x > 0) return x;\n\telse return N - x;\n}\ninline int rch(int x) {\n\tif (x > N) return -(x - N);\n\telse return x;\n}\nvector <pii> in1;\nvector <pii> in2;\n\nvoid input() {\n\tint M1, M2, i, t1, t2;\n\tscanf(\"%d %d %d\", &N, &M1, &M2);\n\twhile (M1--) {\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tif (t1 == -t2) continue;\n\t\tin1.push_back(pii(t1, t2));\n\t}\n\twhile (M2--) {\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tif (t1 == -t2) continue;\n\t\tin2.push_back(pii(t1, t2));\n\t}\n}\n\nvector <int> conn[2050];\nvector <int> rconn[2050];\nvector <int> gconn[2050];\nvector <int> rgconn[2050];\nvector <int> glist[2050];\nvector <int> V;\nbool dchk[2050];\nint tchk[2050];\nint G[2050];\nint gchk[2050];\nbool go[2050][2050];\nvoid DFS1(int n) {\n\tdchk[n] = true;\n\tfor (auto it : conn[n]) if (!dchk[it]) DFS1(it);\n\tV.push_back(n);\n}\nvoid DFS2(int n, int g) {\n\tG[n] = g;\n\tfor (auto it : rconn[n]) if (G[it] == 0) DFS2(it, g);\n}\n\nvoid update1(int);\nvoid update2(int);\n\nvoid update1(int n) {\n\tif (gchk[n] != 1) {\n\t\tgchk[n] = 1;\n\t\tfor (auto it : glist[n]) {\n\t\t\tif (tchk[it] != 1) tchk[it] = 1;\n\t\t\tif (tchk[ch(-rch(it))] != -1) {\n\t\t\t\ttchk[ch(-rch(it))] = -1;\n\t\t\t\tupdate2(G[ch(-rch(it))]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto it : gconn[n]) if (!gchk[it]) update1(it);\n}\nvoid update2(int n) {\n\tif (gchk[n] != -1) {\n\t\tgchk[n] = -1;\n\t\tfor (auto it : glist[n]) {\n\t\t\tif (tchk[it] != -1) tchk[it] = -1;\n\t\t\tif (tchk[ch(-rch(it))] != 1) {\n\t\t\t\ttchk[ch(-rch(it))] = 1;\n\t\t\t\tupdate1(G[ch(-rch(it))]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto it : rgconn[n]) if (!gchk[it]) update2(it);\n}\n\nvoid solve() {\n\tfor (auto it : in1) {\n\t\tint t1 = it.first, t2 = it.second;\n\t\tconn[ch(-t1)].push_back(ch(t2));\n\t\tconn[ch(-t2)].push_back(ch(t1));\n\t\trconn[ch(t1)].push_back(ch(-t2));\n\t\trconn[ch(t2)].push_back(ch(-t1));\n\t}\n\n\tint i, j, gcnt = 0;\n\tfor (i = 1; i <= 2 * N; i++) if (!dchk[i]) DFS1(i);\n\twhile (!V.empty()) {\n\t\tint t = V.back();\n\t\tV.pop_back();\n\t\tif (G[t] == 0) DFS2(t, ++gcnt);\n\t}\n\tfor (i = 1; i <= N; i++) if (G[i] == G[N + i]) return;\n\n\tfor (i = 1; i <= 2*N; i++) {\n\t\tglist[G[i]].push_back(i);\n\t\tfor (auto it : conn[i]) {\n\t\t\tif (G[i] == G[it]) continue;\n\t\t\tgconn[G[i]].push_back(G[it]);\n\t\t\trgconn[G[it]].push_back(G[i]);\n\t\t}\n\t}\n\n\tfor (i = 1; i <= gcnt; i++) {\n\t\tV.clear();\n\t\tgo[i][i] = true;\n\t\tV.push_back(i);\n\t\tfor (j = 0; j < V.size(); j++) {\n\t\t\tfor (auto it : gconn[V[j]]) {\n\t\t\t\tif (go[i][it]) continue;\n\t\t\t\tV.push_back(it);\n\t\t\t\tgo[i][it] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) {\n\t\tif (go[G[i]][G[i + N]]) {\n\t\t\tupdate1(G[i + N]);\n\t\t\tupdate2(G[i]);\n\t\t}\n\t\tif (go[G[i + N]][G[i]]) {\n\t\t\tupdate1(G[i]);\n\t\t\tupdate2(G[i + N]);\n\t\t}\n\t}\n\n\tfor (auto it : in2) {\n\t\tint t1 = -it.first, t2 = -it.second;\n\t\tif (go[G[ch(t1)]][G[ch(-t2)]]) continue;\n\t\tif (go[G[ch(t2)]][G[ch(-t1)]]) continue;\n\t\tif (gchk[G[ch(t1)]] == -1 || gchk[G[ch(t2)]] == -1) continue;\n\n\t\tupdate1(G[ch(t1)]);\n\t\tupdate1(G[ch(t2)]);\n\n\t\tfor (i = 1; i <= N; i++) if (tchk[i] == 0) update1(G[i]);\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tif (tchk[i] == 1) printf(\"1 \");\n\t\t\telse printf(\"0 \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n}\nvoid init() {\n\tint i, j;\n\tfor (i = 1; i <= 2 * N; i++) {\n\t\tconn[i].clear();\n\t\trconn[i].clear();\n\t\tgconn[i].clear();\n\t\trgconn[i].clear();\n\t\tglist[i].clear();\n\t\tdchk[i] = false;\n\t\tG[i] = 0;\n\t\tfor (j = 1; j <= 2 * N; j++) go[i][j] = false;\n\t\tgchk[i] = 0;\n\t\ttchk[i] = 0;\n\t}\n\tV.clear();\n}\nint main() {\n\tinput();\n\tsolve();\n\tinit();\n\tswap(in1, in2);\n\tsolve();\n\treturn !printf(\"SIMILAR\\n\");\n}"], "input": "", "output": "", "tags": ["graphs"], "dificulty": "3000", "interactive": false}