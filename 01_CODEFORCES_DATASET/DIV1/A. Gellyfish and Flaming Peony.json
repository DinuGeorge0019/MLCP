{
    "link": "https://codeforces.com//contest/2115/problem/A",
    "problemId": "3415143",
    "problem_idx": "A",
    "shortId": "2115A",
    "contest_number": "2115",
    "problem_submissions": {
        "A": [
            322373149,
            322373057,
            322191671,
            322196906,
            322191306,
            322207089,
            322339019,
            322205731,
            322191602,
            322193299,
            322321188,
            322320656,
            322193684,
            322193937,
            322193846,
            322195728,
            322193849,
            322208657,
            322196496,
            322194770,
            322195138,
            322193397,
            322277408,
            322205364,
            322201021
        ],
        "E": [
            322277481,
            322279542,
            322287881,
            322287269,
            322268790,
            322276073,
            322479322,
            322316002,
            322463290,
            322674274,
            322484220
        ],
        "D": [
            322247280,
            322249604,
            322253666,
            322244252,
            322244159,
            322252360,
            322259840,
            322274633,
            322274421,
            322243918,
            322262198,
            322264257,
            322258885,
            322256903,
            322256375,
            322270049,
            322285061,
            322255261,
            322270426,
            322274051
        ],
        "C": [
            322226886,
            322242092,
            322247023,
            322262817,
            322237987,
            322228189,
            322234047,
            322256038,
            322250633,
            322253986,
            322247586,
            322244155,
            322267167,
            322253884,
            322236170,
            322239045,
            322256498,
            322247239
        ],
        "B": [
            322199788,
            322207830,
            322209032,
            322228331,
            322214165,
            322204435,
            322203425,
            322201226,
            322209167,
            322226797,
            322225099,
            322216043,
            322219704,
            322219745,
            322213225,
            322218856,
            322205348,
            322216288,
            322222101,
            322216208
        ],
        "F2": [
            322365448
        ],
        "F1": [
            322365418
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/143418",
    "editorial": "SolutionLet , It can be shown that eventually all elements become\r\n.Consider the assumption that eventually all numbers are . Then for all\r\n, there is ; this is because as , the new value will only be a factor of\r\nthe original. It further follows that .Further analysis reveals that\r\ncannot be less than , no matter how it is manipulated. Thus we have\r\n.Next we consider that after a certain number of operations, if there\r\nexists some equal to . In the next operations, for each element that is\r\nnot equal to , we simply choose and then make . After this, all elements\r\nwill become .If is initially in , then the problem is simple; we just\r\nneed to count the number of elements in that are not equal to .But if\r\nthe initial is not in , we are actually trying to make an element equal\r\nto by minimizing the number of operations.This is not difficult to\r\nachieve through dynamic programming, using to indicate that it takes at\r\nleast a few operations to make an element equal to .The transition is\r\nsimple, just enumerate from largest to smallest, and then for all , use\r\nto update . But computing is , a direct transition takes time. So we\r\nneed to preprocess this. Let , then there is obviously . Before all test\r\ncases, can be preprocessed in time complexity.Time complexity: per test\r\ncase and for preprocessing.Memory complexity: per test case and for\r\npreprocessing.\r\n",
    "name": "A. Gellyfish and Flaming Peony",
    "statement": "Gellyfish hates math problems, but she has to finish her math\r\nhomework:Gellyfish is given an array of n positive integers a_1, a_2,\r\nldots, a_n.She needs to do the following two-step operation until all\r\nelements of a are equal: Select two indexes i, j satisfying 1\r\nleq i, j\r\nleq n and i\r\nneq j. Replace a_i with\r\ngcd(a_i, a_j). Now, Gellyfish asks you for the minimum number of\r\noperations to achieve her goal.It can be proven that Gellyfish can\r\nalways achieve her goal.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Gellyfish and Flaming Peony.json",
    "hint": [
        "Hint 1 Try to think about why Gellyfish can always achieve her goal, and ultimately what all the elements will turn into.",
        "Hint 2 When you've figured out Hint 1 , try using dynamic programming to reach your goal."
    ]
}