{"link": "https://codeforces.com//contest/295/problem/B", "problemId": "2835", "problem_idx": "B", "shortId": "295B", "contest_number": "295", "problem_submissions": {"E": [3511398, 3511419, 3511437, 3511617, 3512460, 3509679, 3512315, 3510900, 3508827, 3511729, 3510067, 3513473, 3512096, 3510503, 3513504, 3513446, 3513998, 3513357, 3512431], "D": [3509428, 3508084, 3508466, 3509763, 3509435, 3512601, 3509591, 3512430, 3510879, 3510319, 3512308, 3511034, 3506982, 3509190, 3509840, 3509472, 3580137], "C": [3508174, 3509402, 3509512, 3507449, 3507654, 3508191, 3508111, 3508096, 3513124, 3512841, 3513121, 3508464, 3508663, 3507348, 3507241, 3508781, 3507476, 3507076, 3507577, 3507688], "B": [3506807, 3505379, 3506165, 3505888, 3506089, 3506387, 3506261, 3505484, 3505919, 3507043, 3506794, 3509222, 3505786, 3505827, 3505874, 3505560, 3506566, 3506119], "A": [3505050, 3504656, 3505453, 3504455, 3504863, 3505059, 3505155, 3504693, 3504542, 3504788, 3504749, 3508036, 3504910, 3507685, 3504620, 3504661, 3556448, 3505140, 3504565]}, "name": "B. Greg and Graph", "statement": "Greg has a weighed directed graph, consisting of vertices. In this graph\r\nany pair of distinct vertices has an edge between them in both\r\ndirections. Greg loves playing with the graph and now he has invented a\r\nnew game: The game consists of steps. On the -th step Greg removes\r\nvertex number from the graph. As Greg removes a vertex, he also removes\r\nall the edges that go in and out of this vertex. Before executing each\r\nstep, Greg wants to know the sum of lengths of the shortest paths\r\nbetween all pairs of the remaining vertices. The shortest path can go\r\nthrough any remaining vertex. In other words, if we assume that is the\r\nshortest path between vertices and in the graph that formed before\r\ndeleting vertex , then Greg wants to know the value of the following\r\nsum: . Help Greg, print the value of the required sum before each step.\r\n", "solutions": ["#include<algorithm>\n#include<cassert>\n#include<complex>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstring>\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define fup FOR\n#define fdo FORD\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define siz SZ\n#define CLR(x) memset((x), 0, sizeof(x))\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second \n#define FI X\n#define SE Y\n#define SQR(a) ((a)*(a))\n#define DEBUG 1\n#define debug(x) {if (DEBUG)cerr <<#x <<\" = \" <<x <<endl; }\n#define debugv(x) {if (DEBUG) {cerr <<#x <<\" = \"; FORE(it, (x)) cerr <<*it <<\", \"; cout <<endl; }}\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int>P;\ntypedef vector<int>VI;\nconst int INF=1E9+7;\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\n#define MAXN 507\n\nint n,G[MAXN][MAXN],best[MAXN][MAXN],x[MAXN];\nbool vis[MAXN];\nvector<LL> ans;\nVI is;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n    cout << setprecision(15) << fixed;\n\t//in\n    cin >> n;\n    REP(i,n) REP(j,n) cin >> G[i][j];\n    REP(i,n) cin >> x[i];\n\t//sol\n    REP(i,n) REP(j,n) best[i][j] = INF;\n    REP(i,n) best[i][i]=0;\n    FORD(f,n-1,0) {\n        int v = x[f]-1;\n        REP(i,n) if(vis[i]) REP(j,n) if(vis[j]) {\n       // FORE(i,is) FORE(j,is) {\n            mini(best[v][i], G[v][j] + best[j][i]);\n            mini(best[i][v], G[j][v] + best[i][j]);\n        }\n        REP(i,n) if(vis[i]) REP(j,n) if(vis[j])\n        //FORE(i,is) FORE(j,is)\n            mini(best[i][j], best[i][v] + best[v][j]);\n        vis[v] = true;\n        LL sum = 0;\n        is.PB(v);\n//        cout << vis[0] << \" \" << vis[1] << \" \" << best[0][1] << \" \" << best[1][0] << endl;\n        REP(i,n) if(vis[i]) REP(j,n) if(vis[j])\n        //FORE(i,is) FORE(j,is)\n            sum += best[i][j];\n        ans.PB(sum);\n    }\n\t//out\n    reverse(ALL(ans));\n    FORE(i,ans)\n        cout << *i << \" \";\n    cout << endl;\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["dp", "graphs", "shortest paths"], "dificulty": "1700", "interactive": false}