{
    "link": "https://codeforces.com//contest/333/problem/C",
    "problemId": "3371",
    "problem_idx": "C",
    "shortId": "333C",
    "contest_number": "333",
    "problem_submissions": {
        "C": [
            4188846,
            4188839,
            4181075,
            4185234,
            4185523,
            4181601,
            4984551
        ],
        "E": [
            4188775,
            4188772,
            4188763,
            4188761,
            4188751,
            4184852,
            4183356,
            4182849,
            4183109,
            4181299,
            4179516,
            4184372,
            4183323,
            4184498,
            4184601,
            4184967,
            4188899,
            4183262,
            4185857,
            4189453,
            4189430,
            4189422,
            4189074,
            4186245,
            4185068,
            4181537
        ],
        "D": [
            4177757,
            4180517,
            4180333,
            4180428,
            4180206,
            4183380,
            4180154,
            4179998,
            4182482,
            4188785,
            4180480,
            4189492,
            4189489,
            4189487,
            4182551,
            4183041,
            4185442,
            4183297,
            4181604,
            4185194,
            4187366,
            4187266
        ],
        "B": [
            4175966,
            4176598,
            4177213,
            4176845,
            4177457,
            4177188,
            4200825,
            4200823,
            4177391,
            4183089,
            4178821,
            4177992,
            4179001,
            4180178,
            4179860,
            4176566,
            4178918,
            4176886,
            4177236
        ],
        "A": [
            4174903,
            4175083,
            4175574,
            4175820,
            4175080,
            4175668,
            4176548,
            4175429,
            4175639,
            4175919,
            4177018,
            4175803,
            4175480,
            4175531,
            4175684,
            4175917
        ]
    },
    "name": "C. Lucky Tickets",
    "statement": "Gerald has a friend, Pollard. Pollard is interested in lucky tickets\r\n(ticket is a sequence of digits). At first he thought that a ticket is\r\nlucky if between some its digits we can add arithmetic signs and\r\nbrackets so that the result obtained by the arithmetic expression was\r\nnumber 100. But he quickly analyzed all such tickets and moved on to a\r\nmore general question. Now he explores -lucky tickets.Pollard sais that\r\na ticket is -lucky if we can add arithmetic operation signs between its\r\ndigits to the left or right of them (i.e., \"+\", \"-\", \"\") and brackets so\r\nas to obtain the correct arithmetic expression whose value would equal .\r\nFor example, ticket \"224201016\" is 1000-lucky as .Pollard was so carried\r\naway by the lucky tickets that he signed up for a seminar on lucky\r\ntickets and, as far as Gerald knows, Pollard will attend it daily at 7\r\npm in some famous institute and will commute to it in the same tram for\r\ndays. In this tram tickets have eight digits. And Gerald wants to make a\r\nsurprise for Pollard: each day Pollard will receive a tram -lucky\r\nticket. The conductor has already agreed to give Pollard certain tickets\r\nduring all these days and he only wants Gerald to tell him what kind of\r\ntickets to give out. In this regard, help Gerald pick exactly distinct\r\n-lucky tickets.\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring> \n#include <functional>\n#include <bitset>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\nint a,b,c,d,n,m,k;\nmap<pii, set<int> > q;\ninline void un(set<int> &s1, set<int> &s2, set<int> &ans, int rt) {\n    for (set<int>::iterator it1 = s1.begin(); it1 != s1.end(); ++it1) {\n        for (set<int>::iterator it2 = s2.begin(); it2 != s2.end(); ++it2) {\n            int a = *it1;\n            rept(j, rt) a *= 10;\n            a += *it2;\n            ans.insert(a);\n            if (L(ans) >= 300000) return;\n        }\n        if (L(ans) >= 300000) return;\n    }\n}\nset<int> rec(int len, int res) {\n    res = abs(res);\n    if (q.count(mp(len, res))) return q[mp(len, res)];\n    set<int> ans;\n    int t = 1;\n    rept(i, len) t *= 10;\n    if (res < t) ans.insert(res);\n    if (len == 1) return q[mp(len, res)] = ans;\n    \n    rep(lf, len - 1) {\n        if (lf > 3) break;\n        rept(j, 10) {\n            set<int> s1 = rec(lf, j);\n            if (s1.empty()) continue;\n            set<int> s2 = rec(len - lf, res - j);\n            \n            un(s1, s2, ans, len - lf);\n            if (L(ans) >= 300000) break;\n\n            s2 = rec(len - lf, res + j);\n            un(s1, s2, ans, len - lf);\n            if (L(ans) >= 300000) break;\n\n            s2 = rec(len - lf, j - res);\n            un(s1, s2, ans, len - lf);\n            if (L(ans) >= 300000) break;\n\n            s2 = rec(len - lf, -res - j);\n            un(s1, s2, ans, len - lf);\n            if (L(ans) >= 300000) break;\n\n            if (j && res % j == 0) {\n                s2 = rec(len - lf, res / j);\n                un(s1, s2, ans, len - lf);\n            }\n            if (L(ans) >= 300000) break;\n        }\n        if (L(ans) >= 300000) break;\n    }\n    return q[mp(len, res)] = ans;\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    scanf(\"%d%d\", &k, &m);\n\n    set<int> ans = rec(8, k);\n\n    rept(h, m) {\n        int t = *ans.begin();\n        ans.erase(ans.begin());\n        string s = \"\";\n        rept(j, 8) {\n            s += (char)(t % 10 + '0');\n            t /= 10;\n        }\n        reverse(all(s));\n        printf(\"%s\\n\", s.c_str());\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Lucky Tickets.json",
    "editorial_link": "https://codeforces.com//blog/entry/8418",
    "editorial": "In this problem we can find the right amount of lucky tickets. Lets\r\nconsider amount of different numbers we can get from one four-digit\r\nticket number. It is easy to iterate all this tickets, since it amount\r\nonly . It happened that we can get almost 60 numbers from ticket on the\r\naverage. Suppose we can get number from ticket . It is clearly that\r\neither or . If we can write eight-digit ticket number who will have in\r\nthe first four digits and in the last four digits. It is clearly that\r\nsuch ticket is -lucky. This method allows us to get almost lucky tickets\r\nand it is enough.\r\n"
}