{
    "link": "https://codeforces.com//contest/1477/problem/E",
    "problemId": "879399",
    "problem_idx": "E",
    "shortId": "1477E",
    "contest_number": "1477",
    "problem_submissions": {
        "F": [
            106163553,
            106080431,
            106150219,
            105761318,
            105790194,
            105781844
        ],
        "E": [
            105766462,
            105760921,
            105747638,
            105773646,
            105773472,
            105764661,
            105770759,
            105771270,
            105749455,
            107250678,
            107250631,
            105808122
        ],
        "D": [
            105731973,
            105737956,
            105755294,
            105737357,
            105717044,
            105720581,
            105719208,
            105736745,
            105737576,
            105738580,
            105738914,
            105740692,
            105740131,
            105745290,
            105736926,
            105743296,
            105740891,
            105744844
        ],
        "C": [
            105691291,
            105711864,
            105715665,
            105695858,
            105694977,
            105690018,
            105684885,
            105689512,
            105691536,
            105703366,
            105691967,
            105704561,
            105705153,
            105695098,
            105696313,
            105696567,
            105685916,
            105688953,
            105706121,
            105699876
        ],
        "B": [
            105686611,
            105689935,
            105698256,
            105689750,
            105687613,
            105687015,
            105689324,
            105687283,
            105688577,
            105688486,
            105689038,
            105688335,
            105694661,
            105689327,
            105691535,
            105686246,
            105746534,
            105716194,
            105694969,
            105691857
        ],
        "A": [
            105676617,
            105680391,
            105688488,
            105677583,
            105677613,
            105677290,
            105676167,
            105677997,
            105678469,
            105681155,
            105678265,
            105679581,
            105683427,
            105682439,
            105681417,
            105677926,
            105677952,
            105676881,
            105698728,
            105687449
        ]
    },
    "name": "E. Nezzar and Tournaments",
    "statement": "In the famous Oh-Suit-United tournament, two teams are playing against\r\neach other for the grand prize of precious pepper points.The first team\r\nconsists of n players, and the second team consists of m players. Each\r\nplayer has a potential: the potential of the i-th player in the first\r\nteam is a_i, and the potential of the i-th player in the second team is\r\nb_i.In the tournament, players will be on the stage in some order. There\r\nwill be a scoring device, initially assigned to an integer k, which will\r\nbe used to value the performance of all players.The scores for all\r\nplayers will be assigned in the order they appear on the stage. Let the\r\npotential of the current player be x, and the potential of the previous\r\nplayer be y (). Then, x-y is added to the value in the scoring device,\r\nAfterwards, if the value in the scoring device becomes negative, .\r\nLastly, the player\u2019s score is assigned to the current value on the\r\nscoring device. The score of a team is the sum of the scores of all its\r\nmembers.As an insane fan of the first team, Nezzar desperately wants the\r\nbiggest win for the first team. He now wonders what is the maximum\r\ndifference between scores of the first team and the second\r\nteam.Formally, let the score of the first team be score_f and the score\r\nof the second team be score_s. Nezzar wants to find the maximum value of\r\nscore_f - score_s over all possible orders of players on the\r\nstage.However, situation often changes and there are q events that will\r\nhappen. There are three types of events: 1 pos x change a_{pos} to x; 2\r\npos x change b_{pos} to x; 3 x tournament is held with k = x and Nezzar\r\nwants you to compute the maximum value of score_f - score_s. Can you\r\nhelp Nezzar to answer the queries of the third type?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.assign(s=n,0);}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\nstruct Waf{\n\tvi vs;\n\tBIT<int> bit,cnt;\n\tvoid prepare(){\n\t\tmkuni(vs);\n\t\tbit=BIT<int>(si(vs));\n\t\tcnt=BIT<int>(si(vs));\n\t}\n\tvoid insert(int v){\n\t\tint i=lwb(vs,v);\n\t\tbit.add(i,v);\n\t\tcnt.add(i,1);\n\t}\n\tvoid erase(int v){\n\t\tint i=lwb(vs,v);\n\t\tbit.add(i,-v);\n\t\tcnt.add(i,-1);\n\t}\n\tint query(int v){\n\t\tint i=lwb(vs,v);\n\t\tint val=bit.sum(i,si(vs));\n\t\tval-=cnt.sum(i,si(vs))*v;\n\t\treturn val;\n\t}\n};\n\nint getmin(const multiset<int>&s){\n\tassert(si(s));\n\treturn *s.bg;\n}\nint getmax(const multiset<int>&s){\n\tassert(si(s));\n\treturn *s.rbegin();\n}\nvoid del(multiset<int>&s,int val){\n\tauto itr=s.find(val);\n\tassert(itr!=s.ed);\n\ts.erase(itr);\n}\n\nvoid slv(){\n\tint n,m,q;cin>>n>>m>>q;\n\tvi a=readvi(n);\n\tvi b=readvi(m);\n\tint asum=accumulate(all(a),int(0));\n\tint bsum=accumulate(all(b),int(0));\n\tmultiset<int> as,bs,abvs;\n\tfor(auto v:a){\n\t\tas.insert(v);\n\t\tabvs.insert(v);\n\t}\n\tfor(auto v:b){\n\t\tbs.insert(v);\n\t\tabvs.insert(v);\n\t}\n\tWaf waf;\n\twaf.vs=b;\n\tstruct Query{\n\t\tint t,pos,x;\n\t\tvoid readinit(){\n\t\t\tcin>>t;\n\t\t\tif(t<=2){\n\t\t\t\tcin>>pos>>x;\n\t\t\t\tpos--;\n\t\t\t}else if(t==3){\n\t\t\t\tcin>>x;\n\t\t\t}else{\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\t};\n\tvc<Query> qs(q);\n\trep(i,q){\n\t\tqs[i].readinit();\n\t\tif(qs[i].t==2)waf.vs.pb(qs[i].x);\n\t}\n\twaf.prepare();\n\tfor(auto v:b)waf.insert(v);\n\tfor(auto qq:qs){\n\t\tif(qq.t<=2){\n\t\t\tint pos=qq.pos,x=qq.x;\n\t\t\tif(qq.t==1){\n\t\t\t\tasum-=a[pos];\n\t\t\t\tdel(as,a[pos]);\n\t\t\t\tdel(abvs,a[pos]);\n\t\t\t\ta[pos]=x;\n\t\t\t\tasum+=a[pos];\n\t\t\t\tas.insert(a[pos]);\n\t\t\t\tabvs.insert(a[pos]);\n\t\t\t}else if(qq.t==2){\n\t\t\t\tbsum-=b[pos];\n\t\t\t\tdel(bs,b[pos]);\n\t\t\t\tdel(abvs,b[pos]);\n\t\t\t\twaf.erase(b[pos]);\n\t\t\t\tb[pos]=x;\n\t\t\t\tbsum+=b[pos];\n\t\t\t\tbs.insert(b[pos]);\n\t\t\t\tabvs.insert(b[pos]);\n\t\t\t\twaf.insert(b[pos]);\n\t\t\t}else assert(false);\n\t\t}else if(qq.t==3){\n\t\t\tint x=qq.x,ans=-inf;\n\t\t\tint tmp=getmin(abvs);\n\t\t\t{\n\t\t\t\tint top=getmax(bs);\n\t\t\t\t//dmp(waf.query(top-x));\n\t\t\t\tchmax(ans,asum-tmp*n-waf.query(top-x));\n\t\t\t\tauto upd=[&](int use){\n\t\t\t\t\tchmax(ans,asum-use-tmp*(n-1)-waf.query(use-x)+x);\n\t\t\t\t};\n\t\t\t\tauto itr=as.lower_bound(top+x);\n\t\t\t\tif(itr!=as.ed)upd(*itr);\n\t\t\t\tif(itr!=as.bg)upd(*prev(itr));\n\t\t\t}\n\t\t\t//dmp(ans);\n\t\t\t{\n\t\t\t\tconst auto upd=[&](int lv){\n\t\t\t\t\tchmax(ans,asum-lv*n-(bsum-lv*m));\n\t\t\t\t};\n\t\t\t\tupd(tmp-x);\n\t\t\t\tauto itr=abvs.upper_bound(tmp+x);\n\t\t\t\t--itr;\n\t\t\t\tupd(*itr-x);\n\t\t\t}\n\t\t\tprint(ans);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Nezzar and Tournaments.json",
    "editorial_link": "https://codeforces.com//blog/entry/87294",
    "editorial": "Let\u00e2\u0080\u0099s firstly consider a simplified problem where the scoring device\r\nwill not reset to . For any player, his score will be fully determined\r\nby his potential as well as the potential of first player when is fixed.\r\nIndeed, similar property still holds in our setting. For any fixed\r\narrangement of players with potentials , , where is the score of the -th\r\nplayer. If the first player is fixed, it is optimal to place players in\r\nsecond team in descending order of potentials, then place all players in\r\nascending order of potentials.Let be the difference where is selected as\r\nthe first, and others ordered optimally (and for sequence similarly).\r\nWith some calculation, we may get where is the minimum value among and ,\r\nand is a universal constant(similarly for ).Suppose that we have an\r\noracle of , we are aiming to find out the maximum value of over sets of\r\nvalues . It can be seen that maximum values can only be reached on\r\ninputs (which can be found in time). For better understanding, you may\r\nrefer to the following figure. Therefore, it only remains to calculate\r\nfor any given input efficiently, which can be decomposed to the\r\nfollowing queries. minimum value over , . for given . All those can be\r\ndone efficiently via segment tree.\r\n"
}