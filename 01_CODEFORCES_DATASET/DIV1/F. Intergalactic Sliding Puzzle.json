{"link": "https://codeforces.com//contest/1280/problem/F", "problemId": "495765", "problem_idx": "F", "shortId": "1280F", "contest_number": "1280", "problem_submissions": {"E": [66917544, 66918710, 66922267, 66921342, 66922263, 66926965, 66926660, 66927067, 66925334, 66928850, 66995264, 66984642, 66984352, 66984306, 66929552, 66927288, 66928819, 66918756, 67988551, 66935139, 67027185, 66930594], "D": [66910755, 66913056, 66911496, 66913696, 66913107, 66913708, 66913839, 66916865, 66916639, 66915491, 66986758, 66986656, 66986610, 66986506, 66986162, 66985974, 66985915, 66985866, 66985681, 66985603, 66985529, 66917639, 66918143, 66919046, 66912800, 66915483, 66915027, 67988467, 66920051, 66917432, 66918759, 66917692], "C": [66906002, 66909093, 66907333, 66908961, 66908129, 66909339, 66908240, 66909052, 66911854, 66908829, 66908393, 66909027, 66913164, 66908797, 66903678, 66908260, 67988454, 66908965, 66910137, 66910802, 66910959], "B": [66904540, 66906897, 66902891, 66906439, 66906232, 66906362, 66905756, 66906434, 66909740, 66905894, 66905319, 66906149, 66910474, 66930936, 66909557, 66906748, 67988445, 66907466, 66906183, 66908402, 66907579], "A": [66901496, 66903238, 66905004, 66902693, 66904062, 66902839, 66902110, 66903240, 66903755, 66903072, 66902272, 66903347, 66905647, 66902258, 66906539, 66904016, 67988407, 66934409, 66903855, 66903188, 66903009, 66902847], "F": [66936996, 66936445, 69949014, 71271095, 66930593, 67311416]}, "name": "F. Intergalactic Sliding Puzzle", "statement": "You are an intergalactic surgeon and you have an alien patient. For the\r\npurposes of this problem, we can and we will model this patient\u2019s body\r\nusing a 2\r\ntimes (2k + 1) rectangular grid. The alien has 4k + 1 distinct organs,\r\nnumbered 1 to 4k + 1.In healthy such aliens, the organs are arranged in\r\na particular way. For example, here is how the organs of a healthy such\r\nalien would be positioned, when viewed from the top, for k = 4: Here,\r\nthe represents empty space. In general, the first row contains organs 1\r\nto 2k + 1 (in that order from left to right), and the second row\r\ncontains organs 2k + 2 to 4k + 1 (in that order from left to right) and\r\nthen empty space right after. Your patient\u2019s organs are complete, and\r\ninside their body, but they somehow got shuffled around! Your job, as an\r\nintergalactic surgeon, is to put everything back in its correct\r\nposition. All organs of the alien must be in its body during the entire\r\nprocedure. This means that at any point during the procedure, there is\r\nexactly one cell (in the grid) that is empty. In addition, you can only\r\nmove organs around by doing one of the following things: You can switch\r\nthe positions of the empty space with any organ to its immediate left or\r\nto its immediate right (if they exist). In reality, you do this by\r\nsliding the organ in question to the empty space; You can switch the\r\npositions of the empty space with any organ to its immediate top or its\r\nimmediate bottom (if they exist) the empty space is on the column,\r\ncolumn or in the column. Again, you do this by sliding the organ in\r\nquestion to the empty space. Your job is to figure out a sequence of\r\nmoves you must do during the surgical procedure in order to place back\r\nall 4k + 1 internal organs of your patient in the correct cells. If it\r\nis impossible to do so, you must say so.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint V[100];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint K; cin >> K;\n\t\tconst int R = 2 * K + 1;\n\t\tN = 2 * R;\n\t\tint p0 = -1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"E\") {\n\t\t\t\tV[i] = 0;\n\t\t\t\tp0 = i;\n\t\t\t} else {\n\t\t\t\tV[i] = stoi(s);\n\t\t\t}\n\t\t}\n\t\tassert(p0 != -1);\n\t\tstring ans;\n\t\twhile (p0 % R) {\n\t\t\tans += 'l';\n\t\t\tswap(V[p0], V[p0-1]);\n\t\t\tp0--;\n\t\t}\n\t\tif (p0 == R) {\n\t\t\tans += 'u';\n\t\t\tswap(V[p0], V[p0 - R]);\n\t\t\tp0 -= R;\n\t\t}\n\t\tassert(p0 == 0);\n\n\t\tbool parity = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i+1; j < N; j++) {\n\t\t\t\tif (V[j] < V[i]) parity ^= 1;\n\t\t\t}\n\t\t}\n\t\tif (parity) {\n\t\t\tcout << \"SURGERY FAILED\" << '\\n';\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tans += 'r';\n\t\t\tswap(V[p0], V[p0+1]);\n\t\t\tp0++;\n\t\t}\n\t\tassert(p0 == K);\n\t\tans += 'd';\n\t\tswap(V[p0], V[p0 + R]);\n\t\tp0 += R;\n\n\t\tauto VtoF = [&](int v) {\n\t\t\tassert(v != 0);\n\t\t\tif (v <= K) {\n\t\t\t\treturn v + K;\n\t\t\t} else if (v == K+1) {\n\t\t\t\treturn R;\n\t\t\t} else if (v <= R) {\n\t\t\t\treturn 2 * R - (v - (K+1));\n\t\t\t} else if (v <= R + K) {\n\t\t\t\treturn (K+1) - (v - R);\n\t\t\t} else {\n\t\t\t\treturn R + (v - R - K);\n\t\t\t}\n\t\t};\n\n\t\tdeque<int> lhs;\n\t\tdeque<int> rhs;\n\t\tfor (int i = K-1; i >= 0; i--) {\n\t\t\tlhs.push_front(VtoF(V[i]));\n\t\t}\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tlhs.push_front(VtoF(V[R+i]));\n\t\t}\n\n\t\tfor (int i = K+1; i < R; i++) {\n\t\t\trhs.push_front(VtoF(V[i]));\n\t\t}\n\t\tfor (int i = R-1; i > K; i--) {\n\t\t\trhs.push_front(VtoF(V[R+i]));\n\t\t}\n\t\tint mid = VtoF(V[K]);\n\t\tassert(int(lhs.size()) == 2 * K);\n\t\tassert(int(rhs.size()) == 2 * K);\n\n\t\tauto rotL = [&]() {\n\t\t\tans += 'L';\n\t\t\tlhs.push_back(mid); mid = lhs.front(); lhs.pop_front();\n\t\t};\n\t\tauto unrotL = [&]() {\n\t\t\tans += 'X';\n\t\t\tlhs.push_front(mid); mid = lhs.back(); lhs.pop_back();\n\t\t};\n\t\tauto rotR = [&]() {\n\t\t\tans += 'R';\n\t\t\trhs.push_back(mid); mid = rhs.front(); rhs.pop_front();\n\t\t};\n\t\tauto unrotR = [&]() {\n\t\t\tans += 'Y';\n\t\t\trhs.push_front(mid); mid = rhs.back(); rhs.pop_back();\n\t\t};\n\t\tfor (int z = 0; z < 2 * N; z++) {\n\t\t\tif (mid <= R) {\n\t\t\t\trotL();\n\t\t\t} else {\n\t\t\t\trotR();\n\t\t\t}\n\t\t}\n\n\t\tfor (int z = 0; z < R; z++) {\n\t\t\trotL();\n\t\t\tfor (int i = 0; i < R-1; i++) {\n\t\t\t\tif (lhs.front() < mid) {\n\t\t\t\t\t// do the swap\n\t\t\t\t\trotR();\n\t\t\t\t\trotL();\n\t\t\t\t\tunrotR();\n\t\t\t\t\tunrotL();\n\t\t\t\t\trotR();\n\t\t\t\t}\n\t\t\t\trotL();\n\t\t\t}\n\t\t}\n\n\t\tassert(mid == R);\n\t\tmid = 2 * R;\n\n\t\tbool f = false;\n\t\tfor (int z = 0; z < R; z++) {\n\t\t\trotR();\n\t\t\tfor (int i = 0; i < R-1; i++) {\n\t\t\t\tif (rhs.front() < mid) {\n\t\t\t\t\t// do the swap\n\t\t\t\t\tf ? unrotL() : rotL();\n\t\t\t\t\trotR();\n\t\t\t\t\tf ? rotL() : unrotL();\n\t\t\t\t\tunrotR();\n\t\t\t\t\tf ? unrotL() : rotL();\n\t\t\t\t\tf = !f;\n\t\t\t\t}\n\t\t\t\trotR();\n\t\t\t}\n\t\t}\n\t\tassert(f == false);\n\n\t\t// finalize answer by moving it to the rightmost\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tans += 'r';\n\t\t}\n\t\tcout << \"SURGERY COMPLETE\" << '\\n';\n\t\tcout << ans << '\\n';\n\t\tcout << \"L\" << ' ' << string(K, 'l')+\"u\"+string(K, 'r')+\"d\" << '\\n';\n\t\tcout << \"X\" << ' ' << \"u\"+string(K, 'l')+\"d\"+string(K, 'r') << '\\n';\n\t\tcout << \"R\" << ' ' << string(K, 'r')+\"u\"+string(K, 'l')+\"d\" << '\\n';\n\t\tcout << \"Y\" << ' ' << \"u\"+string(K, 'r')+\"d\"+string(K, 'l') << '\\n';\n\t\tcout << \"DONE\" << '\\n';\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "constructive algorithms", "math"], "dificulty": "3400", "interactive": false}