{
    "link": "https://codeforces.com//contest/737/problem/D",
    "problemId": "81052",
    "problem_idx": "D",
    "shortId": "737D",
    "contest_number": "737",
    "problem_submissions": {
        "D": [
            22352998,
            22361676,
            22361660,
            22352983,
            22352295,
            22352107,
            22352670,
            22355408,
            22353859,
            22355150,
            22355124,
            22355580,
            22352603,
            22354241,
            22355135,
            22367415,
            22354851,
            22353195,
            22355191,
            22354766,
            22354567,
            22355616,
            22355720
        ],
        "C": [
            22346894,
            22348992,
            22348428,
            22346364,
            22349019,
            22347742,
            22344273,
            22349093,
            22344153,
            22348276,
            22349914,
            22349222,
            22351285,
            22350460,
            22350277,
            22351065,
            22348263,
            22347006,
            22351260,
            22349703
        ],
        "B": [
            22345266,
            22344047,
            22346326,
            22344623,
            22347286,
            22345951,
            22346273,
            22346654,
            22345815,
            22347161,
            22347731,
            22346343,
            22348170,
            22348193,
            22348953,
            22349108,
            22345433,
            22343951,
            22343981,
            22347679
        ],
        "A": [
            22344335,
            22346876,
            22344812,
            22348251,
            22345241,
            22344610,
            22348244,
            22344836,
            22349514,
            22345867,
            22345524,
            22349952,
            22345718,
            22346457,
            22347708,
            22346937,
            22344148,
            22348610,
            22348383,
            22345809
        ],
        "F": [
            22363265,
            22374526
        ],
        "E": [
            22411333
        ]
    },
    "name": "D. Financiers Game",
    "statement": "At evening, Igor and Zhenya the financiers became boring, so they\r\ndecided to play a game. They prepared papers with the income of some\r\ncompany for some time periods. Note that the income can be positive,\r\nzero or negative.Igor and Zhenya placed the papers in a row and decided\r\nto take turns making moves. Igor will take the papers from the left\r\nside, Zhenya will take the papers from the right side. Igor goes first\r\nand takes or (on his choice) papers from the left. Then, on each turn a\r\nplayer can take or papers from his side if the opponent took exactly\r\npapers in the previous turn. Players can’t skip moves. The game ends\r\nwhen there are no papers left, or when some of the players can’t make a\r\nmove.Your task is to determine the difference between the sum of incomes\r\non the papers Igor took and the sum of incomes on the papers Zhenya\r\ntook, assuming both players play optimally. Igor wants to maximize the\r\ndifference, Zhenya wants to minimize it.\r\n",
    "solutions": [
        "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n#include <vector>\n#include <cstring>\n#include <array>\n\n\n\n#include <numeric>\n\n#include <type_traits>\n\ntemplate <typename T>\nusing range_iterator_traits = std::iterator_traits<typename std::decay<decltype(std::declval<T>().begin())>::type>;\n\n\ntemplate <typename R>\nauto prefixSums(const R& range) -> std::vector<typename range_iterator_traits<R>::value_type> {\n\tstd::vector<typename range_iterator_traits<R>::value_type> result(\n\t\t\tstatic_cast<std::size_t>(\n\t\t\t\t\tstd::distance(std::begin(range), std::end(range)) + 1\n\t\t\t)\n\t);\n\tstd::partial_sum(std::begin(range), std::end(range), result.begin() + 1);\n\treturn result;\n}\n\n\nusing namespace std;\n\nint dp[2][4001][201][2];\n\nclass TaskD {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n;\n\t\tin >> n;\n\t\t//n = 4000;\n\t\tvector<int> v(n);\n\t\tfor (int i: range(n)) {\n\t\t\tin >> v[i];\n\t\t}\n\n\t\tauto ps = prefixSums(v);\n\n\t\tmemset(dp, 0, sizeof dp);\n\n\t\tfor (int k: inclusiveDownrange(99, 1)) {\n\t\t\tfor (int i: inclusiveDownrange(n)) {\n\t\t\t\tfor (int d: inclusiveDownrange(100, -100)) {\n\t\t\t\t\tint s = i + d;\n\t\t\t\t\tif (s < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint j = n - s;\n\t\t\t\t\tif (j < i) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdp[k & 1][i][d + 100][0] = 0;\n\t\t\t\t\tdp[k & 1][i][d + 100][1] = 0;\n\n\t\t\t\t\tif (j - i < k) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (j - i == k) {\n\t\t\t\t\t\tdp[k & 1][i][d + 100][0] = ps[j] - ps[i];\n\t\t\t\t\t\tdp[k & 1][i][d + 100][1] = -(ps[j] - ps[i]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (k + 1 < 100 && d - (k + 1) >= -100) {\n\t\t\t\t\t\tdp[k & 1][i][d + 100][0] = max(\n\t\t\t\t\t\t\t\tps[i + k] - ps[i] + dp[k & 1][i + k][d - k + 100][1],\n\t\t\t\t\t\t\t\tps[i + k + 1] - ps[i] + dp[(k + 1) & 1][i + k + 1][d - (k + 1) + 100][1]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (d + k + 1 <= 100 && k + 1 < 100) {\n\t\t\t\t\t\tdp[k & 1][i][d + 100][1] = min(\n\t\t\t\t\t\t\t\t-(ps[j] - ps[j - k]) + dp[k & 1][i][d + k + 100][0],\n\t\t\t\t\t\t\t\t-(ps[j] - ps[j - (k + 1)]) + dp[(k + 1) & 1][i][d + (k + 1) + 100][0]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout << dp[1][0][100][0] << \"\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Financiers Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/48501",
    "editorial": "Let's solve this problem using dynamic programming. We can see that any position in the game can be described with three integers: the left and right bounds of the segment of papers that are still on the table, and the number of papers the previous player took; and who's turn it is. So, let Ilrk be the game result if there were only papers from l to r initially, Igor moved first by taking k or k?+?1 papers. Similarly, let Zlrk be the same but Zhenya moved first. It can be easily seen that in general case\n\n\n\nWe need to carefully proceed the states where a player can't take the needed number of papers. The answer for the problem is I1n1.\n\nAt first sight it seems that this solution runs in O(n3). However, it doesn't. What values can l, r and k be equal to?\n\nFirst,  because if the previous player took k papers then there are at least as  already taken papers. So, k is not greater than .\n\nSecond, let's take a look at the difference between number of papers taken by Zhenya and Igor, i. e. at the value d?=?(n?-?r)?-?(l?-?1). We consider only cases in which both players made the same number of moves, so now it's Igor's move. Then 0???d???k?-?1. Indeed, on each turn Zhenya took as many papers as Igor did, or one paper more, but in the latter case the \"length\" of move increased. The length of move increased by k?-?1 overall, so the difference is at most k?-?1. Thus, we can describe the dynamic programming state with l, d and k, and there are O(n2) states in total. We don't consider states in which it's Zhenya's turn, instead, we try all his possible moves to compute the states. The overall complexity is O(n2). I find it easier to code by the use of recursion and memoization.",
    "hint": []
}