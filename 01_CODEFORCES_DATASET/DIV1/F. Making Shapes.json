{"link": "https://codeforces.com//contest/1290/problem/F", "problemId": "529282", "problem_idx": "F", "shortId": "1290F", "contest_number": "1290", "problem_submissions": {"C": [70096929, 70064543, 70052395, 70054161, 70047406, 70047992, 70053917, 70053152, 70054979, 70214121, 70054528, 70058183, 70057014, 70052660, 70052531, 70060568, 70059018, 70063715, 70055920, 70058007, 70059153, 70056438], "D": [70071102, 70083418, 70081951, 70059761, 70062540, 70064117, 70088222, 70088118, 70087893, 70066142, 71762685, 70214194, 70214147, 70068516, 70069978, 70069936, 70074018, 70075546, 70074118, 70071674, 70072917, 70077679, 70075595, 70065164, 70078630], "F": [70059398, 70084031, 70111116, 70110928, 75833689, 70089144, 70131709], "A": [70040962, 70037530, 70037805, 70036026, 70036076, 70037499, 70037219, 70040023, 70214047, 70038241, 70036901, 70036876, 70037974, 70038261, 70038975, 70040060, 70041968, 70036027, 70043312, 70045091, 70039900], "B": [70038396, 70041221, 70041673, 70039846, 70040515, 70043644, 70043914, 70045743, 70214060, 70047838, 70043116, 70043411, 70045228, 70046548, 70048357, 70051227, 70051419, 70047415, 70062917, 70075181, 70045909], "E": [70074704, 70107871, 70086286, 70079191, 70214607, 70086883, 70085799, 70123893, 70086530, 70158475, 70100288, 70111014]}, "name": "F. Making Shapes", "statement": "You are given n pairwise non-collinear two-dimensional vectors. You can\r\nmake shapes in the two-dimensional plane with these vectors in the\r\nfollowing fashion: Start at the origin (0, 0). Choose a vector and add\r\nthe segment of the vector to the current point. For example, if your\r\ncurrent point is at (x, y) and you choose the vector (u, v), draw a\r\nsegment from your current point to the point at (x + u, y + v) and set\r\nyour current point to (x + u, y + v). Repeat step 2 until you reach the\r\norigin again.You can reuse a vector as many times as you want.Count the\r\nnumber of different, non-degenerate (with an area greater than 0) and\r\nconvex shapes made from applying the steps, such that the shape can be\r\ncontained within a m\r\ntimes m square, and the vectors building the shape are in\r\ncounter-clockwise fashion. Since this number can be too large, you\r\nshould calculate it by modulo 998244353.Two shapes are considered the\r\nsame if there exists some parallel translation of the first shape to\r\nanother.A shape can be contained within a m\r\ntimes m square if there exists some parallel translation of this shape\r\nso that every point (u, v) inside or on the border of the shape\r\nsatisfies 0\r\nleq u, v\r\nleq m.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 02.02.2020 17:52:33       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nconst int MAX = 20;\n\nMint dp[MAX][MAX][MAX][MAX][2][2];\nMint new_dp[MAX][MAX][MAX][MAX][2][2];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  memset(dp, 0, sizeof(dp));\n  dp[0][0][0][0][0][0] = 1;\n  while (m > 0) {\n    int bit = m & 1;\n    memset(new_dp, 0, sizeof(new_dp));\n    for (int cpx = 0; cpx < MAX; cpx++) {\n      for (int cmx = 0; cmx < MAX; cmx++) { \n        for (int cpy = 0; cpy < MAX; cpy++) {\n          for (int cmy = 0; cmy < MAX; cmy++) {\n            for (int fx = 0; fx < 2; fx++) {\n              for (int fy = 0; fy < 2; fy++) {\n                Mint ft = dp[cpx][cmx][cpy][cmy][fx][fy];\n                if (ft == 0) {\n                  continue;\n                }\n                for (int mask = 0; mask < (1 << n); mask++) {\n                  int dpx = cpx;\n                  int dpy = cpy;\n                  int dmx = cmx;\n                  int dmy = cmy;\n                  for (int i = 0; i < n; i++) {\n                    if (mask & (1 << i)) {\n                      dpx += max(x[i], 0);\n                      dmx -= min(x[i], 0);\n                      dpy += max(y[i], 0);\n                      dmy -= min(y[i], 0);\n                    }\n                  }\n                  if ((dpx & 1) != (dmx & 1)) {\n                    continue;\n                  }\n                  if ((dpy & 1) != (dmy & 1)) {\n                    continue;\n                  }\n                  int new_fx = ((dpx & 1) > bit ? 1 : ((dpx & 1) < bit ? 0 : fx));\n                  int new_fy = ((dpy & 1) > bit ? 1 : ((dpy & 1) < bit ? 0 : fy));\n                  dpx >>= 1;\n                  dmx >>= 1;\n                  dpy >>= 1;\n                  dmy >>= 1;\n                  assert(dpx < MAX && dpy < MAX && dmx < MAX && dmy < MAX);\n                  new_dp[dpx][dmx][dpy][dmy][new_fx][new_fy] += ft;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    swap(dp, new_dp);\n    m >>= 1;\n  }\n  cout << dp[0][0][0][0][0][0] - 1 << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "3500", "interactive": false}