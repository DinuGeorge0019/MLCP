{
    "link": "https://codeforces.com//contest/1179/problem/E",
    "problemId": "361548",
    "problem_idx": "E",
    "shortId": "1179E",
    "contest_number": "1179",
    "problem_submissions": {
        "E": [
            55903813,
            55902523,
            55901885,
            55909022,
            55905388,
            56432061,
            75942632,
            56023295
        ],
        "D": [
            55893003,
            55895931,
            55888725,
            55893104,
            71080559,
            71080196,
            71080163,
            71080130,
            71080072,
            71080060,
            55893173,
            55892658,
            55908319,
            55894131,
            55894542,
            55893763,
            55896830,
            56019124,
            55897859,
            55895869,
            55954689,
            55895158,
            55899492,
            55899301,
            55888559,
            55898280,
            55898257,
            55896770
        ],
        "C": [
            55884160,
            55884795,
            55882131,
            55884686,
            55905440,
            55885364,
            55885156,
            55885262,
            55885328,
            55886216,
            55885322,
            55883584,
            55886444,
            55954679,
            55890192,
            55886511,
            55887224,
            55900785,
            55886889,
            55887130,
            55889061
        ],
        "B": [
            55880474,
            55886283,
            55907977,
            55879717,
            55880717,
            55880688,
            55881071,
            55881636,
            55881390,
            55878893,
            55881077,
            55881153,
            55954669,
            55881453,
            55881368,
            55881391,
            55880057,
            55884243,
            55877081,
            55883081
        ],
        "A": [
            55876049,
            55878221,
            55877438,
            55877168,
            55878263,
            55877701,
            55876941,
            55878391,
            55879288,
            55877277,
            55877221,
            55878361,
            55954661,
            55878330,
            55878077,
            55877852,
            55877332,
            55880624,
            55880725,
            55879783
        ]
    },
    "name": "E. Alesya and Discrete Math",
    "statement": "We call a function if its domain of definition is some set of integers\r\nand if in case it\u2019s defined in x and x-1, f(x) = f(x-1) + 1 or f(x) =\r\nf(x-1).Tanya has found n functions f_{1},\r\nldots, f_{n}, which are defined on all integers from 0 to 10^{18} and\r\nf_i(0) = 0 and f_i(10^{18}) = L for all i from 1 to n. It\u2019s an notorious\r\ncoincidence that n is a divisor of L. She suggests Alesya a game. Using\r\none question Alesya can ask Tanya a value of any single function in any\r\nsingle point. To win Alesya must choose integers l_{i} and r_{i} (0\r\nleq l_{i}\r\nleq r_{i}\r\nleq 10^{18}), such that f_{i}(r_{i}) - f_{i}(l_{i})\r\ngeq\r\nfrac{L}{n} (here f_i(x) means the value of i-th function at point x) for\r\nall i such that 1\r\nleq i\r\nleq n so that for any pair of two functions their segments [l_i, r_i]\r\ndon\u2019t intersect (but may have one common point).Unfortunately, Tanya\r\ndoesn\u2019t allow to make more than 2\r\ncdot 10^{5} questions. Help Alesya to win!It can be proved that it\u2019s\r\nalways possible to choose [l_i, r_i] which satisfy the conditions\r\ndescribed above.It\u2019s guaranteed, that Tanya doesn\u2019t change functions\r\nduring the game, i.e. interactor is not adaptive\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nconst ll p=1e18;\n//~ const ll p=5;\n\nint n;\nll l;\n\nll k;\n\nunordered_map <ll,ll> wiem[nax];\n\npll wyn[nax];\n\nll pyt(int v, ll x)\n{\n\tif (wiem[v].count(x))\n\t\treturn wiem[v][x];\n\tprintf(\"? %d %lld\\n\", v, x);\n\tff();\n\tll w;\n\tscanf(\"%lld\", &w);\n\twiem[v][x]=w;\n\treturn w;\n}\n\nll szuk(int v, ll graa, ll grab, ll wa, ll wb, ll cel)\n{\n\tll bsa=graa;\n\tll bsb=grab;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb)>>1;\n\t\tll wez=pyt(v, bss);\n\t\twez=min(wez, wb);\n\t\twez=max(wez, wa);\n\t\tif (wez==cel)\n\t\t\treturn bss;\n\t\tif (wez>cel)\n\t\t\tbsb=bss-1;\n\t\telse\n\t\t\tbsa=bss+1;\n\t}\n\treturn bsa;\n}\n\nvoid rek(vi wek, ll graa, ll grab, ll wa, ll wb)\n{\n\tif (wek.empty())\n\t\treturn;\n\tif (wek.size()==1)\n\t{\n\t\twyn[wek[0]]={graa, grab};\n\t\treturn;\n\t}\n\tint r=wek.size();\n\tshandom_ruffle(wek.begin(), wek.end());\n\tint x=wek.back();\n\tint pa=1;\n\tint pb=r-1;\n\twhile(1)\n\t{\n\t\t//~ assert(pa<=pb);\n\t\tint ps=(pa+pb)>>1;\n\t\tif (pa>pb)\n\t\t{\n\t\t\tpa=1;\n\t\t\tpb=r-1;\n\t\t\tshandom_ruffle(wek.begin(), wek.end());\n\t\t\tx=wek.back();\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tll m=szuk(x, graa, grab, wa, wb, wa+ps*k);\n\t\tvi mni;\n\t\tvi wie;\n\t\tvi row;\n\t\tfor (int i : wek)\n\t\t{\n\t\t\tll wez=pyt(i, m);\n\t\t\tif (wez<wa+ps*k)\n\t\t\t\tmni.push_back(i);\n\t\t\tif (wez==wa+ps*k)\n\t\t\t\trow.push_back(i);\n\t\t\tif (wez>wa+ps*k)\n\t\t\t\twie.push_back(i);\n\t\t}\n\t\tif ((int)wie.size()>ps || (int)mni.size()>r-ps)\n\t\t{\n\t\t\tint oa=0;\n\t\t\tint ob=0;\n\t\t\tif ((int)wie.size()>ps)\n\t\t\t\toa=1;\n\t\t\tif ((int)mni.size()>r-ps)\n\t\t\t\tob=1;\n\t\t\tassert(oa+ob==1);\n\t\t\tif (oa)\n\t\t\t\tpa=ps+1;\n\t\t\telse\n\t\t\t\tpb=ps-1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i : row)\n\t\t{\n\t\t\tif ((int)wie.size()<ps)\n\t\t\t\twie.push_back(i);\n\t\t\telse\n\t\t\t\tmni.push_back(i);\n\t\t}\n\t\trek(wie, graa, m, wa, wa+ps*k);\n\t\trek(mni, m, grab, wa+ps*k, wb);\n\t\t//div\n\t\treturn;\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d%lld\", &n, &l);\n\tk=l/n;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twiem[i][0]=0;\n\t\twiem[i][p]=l;\n\t}\n\tvi start(n);\n\tiota(start.begin(), start.end(), 1);\n\trek(start, 0, p, 0, l);\n\t\n\tprintf(\"!\\n\");\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(\"%lld %lld\\n\", wyn[i].first, wyn[i].second);\n\tff();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "interactive"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Alesya and Discrete Math.json",
    "editorial_link": "https://codeforces.com//blog/entry/67891",
    "editorial": "We denote as for convenience.Let, without loss of generality, is even.\r\nLet us find such for function that using binary search. Now we\u00e2\u0080\u0099re going\r\nto renumber functions so that in new numeration attracts . Let . Now one\r\ncan see that we have reduced the task to two smaller ones the original\r\ntask for functions with numbers , having only a restriction that all\r\ntheir segments of answer are enclosed inside segment , and, similarly,\r\nfor others functions and segment . Considering the original problem with\r\nall functions as a problem with the restriction that segments of the\r\nanswer are enclosed inside , the task is reduced to smaller ones.Proof\r\nof correctness if left as an exercise, it\u00e2\u0080\u0099s pretty easy.This works in\r\n.To speed it up, we\u00e2\u0080\u0099re going to find -th function by a little bit\r\nsmarter. Long story short, we\u00e2\u0080\u0099re going to act as in the search of -th\r\nelement in an array in linear time. We will take a random function , run\r\nbinary search for it, and not run binary searches for others but check\r\nhow many so that . It\u00e2\u0080\u0099s easy to check using one query for all . It will\r\nwork in queries on the average, as we know this process will averagely\r\nconverge in steps. Let\u00e2\u0080\u0099s estimate the total complexity.Let, without loss\r\nof generality, the number of functions is for some . So: + is number of\r\nqueries ( (we will have segments on the -th level pf recursion, and for\r\neach of them log is ).Thus it\u00e2\u0080\u0099s: + . So: + .It\u00e2\u0080\u0099s , cause that series\r\nconverges to 2.\r\n"
}