{
    "link": "https://codeforces.com//contest/1817/problem/B",
    "problemId": "1897390",
    "problem_idx": "B",
    "shortId": "1817B",
    "contest_number": "1817",
    "problem_submissions": {
        "F": [
            204497444,
            204371393,
            203993098,
            203987643,
            204188728,
            204003142,
            203943098,
            204213507
        ],
        "D": [
            203955544,
            203961086,
            203937236,
            203945800,
            203945643,
            203942818,
            203943723,
            203947591,
            203989196,
            203948036,
            204052212,
            203947419,
            203952089,
            203947882,
            203954628
        ],
        "A": [
            203949751,
            203917796,
            203915319,
            203915702,
            203915256,
            203915135,
            203915119,
            203915216,
            203933837,
            203916532,
            203915895,
            203917033,
            203915580,
            203915390,
            203917321,
            203916497,
            203915656,
            203929967,
            203917829
        ],
        "E": [
            203947509,
            203943737,
            203948086,
            203949930,
            204001172,
            203962099,
            204158074,
            203951990,
            204009291,
            203987561,
            203984105,
            203980085,
            203953471,
            203990042,
            203976606,
            203976302,
            203953675,
            204066570,
            204065539,
            204106022
        ],
        "B": [
            203928063,
            203919631,
            203920186,
            203920581,
            203923300,
            203919216,
            203918930,
            203922691,
            203924157,
            203921090,
            203921763,
            203924664,
            203924354,
            203989898,
            203930016,
            203924048,
            203922828,
            203936658,
            203924723
        ],
        "C": [
            203916741,
            203929205,
            203922679,
            203923849,
            203928212,
            203926222,
            203931210,
            203933759,
            203932269,
            203931148,
            203930247,
            203931616,
            203931791,
            203922648,
            203924454,
            204016237,
            203932091,
            203930473,
            203925061,
            203933416
        ]
    },
    "name": "B. Fish Graph",
    "statement": "You are given a simple undirected graph with n nodes and m edges. Note\r\nthat the graph is not necessarily connected. The nodes are labeled from\r\n1 to n.We define a graph to be a if it contains a simple cycle with a\r\nspecial node u belonging to the cycle. Apart from the edges in the\r\ncycle, the graph should have exactly 2 extra edges. Both edges should\r\nconnect to node u, but they should not be connected to any other node of\r\nthe cycle. Determine if the graph contains a subgraph that is a Fish\r\nGraph, and if so, find any such subgraph.In this problem, we define a\r\nsubgraph as a graph obtained by taking any subset of the edges of the\r\noriginal graph.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\nvector<int> G[N];\n\nint fa[N], vis[N];\nint n, m;\nbool is_nbr[N], used[N];\n\nint root = 0;\nint z = -1;\n\nbool dfs(int v, int p) {\n  vis[v] = 1;\n  fa[v] = p;\n  if (is_nbr[v] && p != root) {\n    z = v;\n    return 1;\n  }\n  for (int u: G[v]) {\n    if (!vis[u]) {\n      if (dfs(u, v)) return 1;\n    }\n  }\n  return 0;\n}\n\nvoid solve() {\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  for (int v = 1; v <= n; v++) {\n    if ((int)G[v].size() < 4) continue;\n    fill(vis+1, vis+n+1, 0);\n    fill(is_nbr+1, is_nbr+n+1, 0);\n    fill(used+1, used+n+1, 0);\n    z = -1;\n    root = v;\n    for (int u: G[v]) is_nbr[u] = 1;\n    if (dfs(v, v)) {\n      cout << \"YES\\n\";\n      vector<pair<int, int>> edges;\n      edges.emplace_back(z, v);\n      used[z] = 1;\n      int t = z;\n      for (t = z; t != v; t = fa[t]) {\n        edges.emplace_back(t, fa[t]);\n        used[t] = 1;\n        if (fa[t] == v) break;\n      }\n      int cnt = 0;\n      for (int c: G[v]) {\n        if (used[c]) continue;\n        edges.emplace_back(c, v);\n        cnt++;\n        if (cnt == 2) break;\n      }\n      cout << edges.size() << '\\n';\n      for (auto& [x, y]: edges) cout << x << ' ' << y << '\\n';\n      return;\n    }\n  }\n  cout << \"NO\\n\";\n}\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    solve();\n    for (int i = 1; i <= n; i++) G[i].clear();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Fish Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/115586",
    "editorial": "Try to prove this, and see if your proof can be turned into an\r\nalgorithm.Firstly, letâs try to find some necessary conditions for a\r\nFish Subgraph to exist. Because the Fish Graph has a cycle with two\r\nextra edges attached, the original must contain a cycle with a node in\r\nthe cycle having degree at least 4. It turns out this condition is\r\nactually sufficient, letâs prove this:So, assume a graph contains a\r\ncycle, and one of the nodes in the cycle has . We will only look at this\r\ncycle, and two extra edges connected to the special node that are not\r\ncycle edges, and remove all the other edges from consideration. These\r\ntwo extra edges could have both endpoints inside the cycle, creating\r\ndiagonal(s) and not the fins of the Fish Graph we want. If both edges\r\ndonât form diagonals of the cycle, weâve found a Fish Graph. Otherwise,\r\nletâs label the nodes in the cycle , and label the two extra edges and .\r\nLook at the diagonal that connects nodes and , with as small as\r\npossible. Using it, we find a smaller cycle . To finish the proof, we\r\nnotice that one of the edges from and the edge now have become free to\r\nuse as fins of the Fish Graph, as they are no longer diagonals of the\r\nsmaller cycle. This proof can be turned into an algorithm solving the\r\nproblem.First off, we need to find any cycle with a node with degree .\r\nLetâs brute force the node , which must have degree . Then brute force\r\nthe first edge of the cycle (by looping over the adjacency list of node\r\n). Now to find any cycle, it suffices to find a path from to ,\r\ntemporarily deleting the edge . This can be done with DFS or BFS. When a\r\ncycle is found, all edges except extra edges can be removed from\r\nconsideration, and the proof for sufficiency can be implemented to fix\r\npossible diagonals. For BFS it is even easier, because it already finds\r\nthe shortest path from to , making diagonals impossible. The time\r\ncomplexity will be , because the algorithm loops over all edges, and\r\ndoes a graph traversal for each of them. Bonus: How do you make this\r\nalgorithm ?\r\n",
    "hint": [
        "Hint 1 Can you find a necessary condition for whether a Fish Subgraph exists?",
        "Hint 2 For the Fish Subgraph to exist, the graph must have a cycle with one node in the cycle having degree at least 4.",
        "Hint 3 When the necessary condition is satisfied, actually, you can always find a Fish Subgraph. Try to prove this, and see if your proof can be turned into an algorithm."
    ]
}