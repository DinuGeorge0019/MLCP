{"link": "https://codeforces.com//contest/1817/problem/B", "problemId": "1897390", "problem_idx": "B", "shortId": "1817B", "contest_number": "1817", "problem_submissions": {"F": [204497444, 204371393, 203993098, 203987643, 204188728, 204003142, 203943098, 204213507], "D": [203955544, 203961086, 203937236, 203945800, 203945643, 203942818, 203943723, 203947591, 203989196, 203948036, 204052212, 203947419, 203952089, 203947882, 203954628], "A": [203949751, 203917796, 203915319, 203915702, 203915256, 203915135, 203915119, 203915216, 203933837, 203916532, 203915895, 203917033, 203915580, 203915390, 203917321, 203916497, 203915656, 203929967, 203917829], "E": [203947509, 203943737, 203948086, 203949930, 204001172, 203962099, 204158074, 203951990, 204009291, 203987561, 203984105, 203980085, 203953471, 203990042, 203976606, 203976302, 203953675, 204066570, 204065539, 204106022], "B": [203928063, 203919631, 203920186, 203920581, 203923300, 203919216, 203918930, 203922691, 203924157, 203921090, 203921763, 203924664, 203924354, 203989898, 203930016, 203924048, 203922828, 203936658, 203924723], "C": [203916741, 203929205, 203922679, 203923849, 203928212, 203926222, 203931210, 203933759, 203932269, 203931148, 203930247, 203931616, 203931791, 203922648, 203924454, 204016237, 203932091, 203930473, 203925061, 203933416]}, "name": "B. Fish Graph", "statement": "You are given a simple undirected graph with n nodes and m edges. Note\r\nthat the graph is not necessarily connected. The nodes are labeled from\r\n1 to n.We define a graph to be a if it contains a simple cycle with a\r\nspecial node u belonging to the cycle. Apart from the edges in the\r\ncycle, the graph should have exactly 2 extra edges. Both edges should\r\nconnect to node u, but they should not be connected to any other node of\r\nthe cycle. Determine if the graph contains a subgraph that is a Fish\r\nGraph, and if so, find any such subgraph.In this problem, we define a\r\nsubgraph as a graph obtained by taking any subset of the edges of the\r\noriginal graph.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\nvector<int> G[N];\n\nint fa[N], vis[N];\nint n, m;\nbool is_nbr[N], used[N];\n\nint root = 0;\nint z = -1;\n\nbool dfs(int v, int p) {\n  vis[v] = 1;\n  fa[v] = p;\n  if (is_nbr[v] && p != root) {\n    z = v;\n    return 1;\n  }\n  for (int u: G[v]) {\n    if (!vis[u]) {\n      if (dfs(u, v)) return 1;\n    }\n  }\n  return 0;\n}\n\nvoid solve() {\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  for (int v = 1; v <= n; v++) {\n    if ((int)G[v].size() < 4) continue;\n    fill(vis+1, vis+n+1, 0);\n    fill(is_nbr+1, is_nbr+n+1, 0);\n    fill(used+1, used+n+1, 0);\n    z = -1;\n    root = v;\n    for (int u: G[v]) is_nbr[u] = 1;\n    if (dfs(v, v)) {\n      cout << \"YES\\n\";\n      vector<pair<int, int>> edges;\n      edges.emplace_back(z, v);\n      used[z] = 1;\n      int t = z;\n      for (t = z; t != v; t = fa[t]) {\n        edges.emplace_back(t, fa[t]);\n        used[t] = 1;\n        if (fa[t] == v) break;\n      }\n      int cnt = 0;\n      for (int c: G[v]) {\n        if (used[c]) continue;\n        edges.emplace_back(c, v);\n        cnt++;\n        if (cnt == 2) break;\n      }\n      cout << edges.size() << '\\n';\n      for (auto& [x, y]: edges) cout << x << ' ' << y << '\\n';\n      return;\n    }\n  }\n  cout << \"NO\\n\";\n}\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    solve();\n    for (int i = 1; i <= n; i++) G[i].clear();\n  }\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "dfs and similar", "graphs"], "dificulty": "1900", "interactive": false}