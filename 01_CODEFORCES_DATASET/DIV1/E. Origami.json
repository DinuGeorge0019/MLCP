{"link": "https://codeforces.com//contest/1381/problem/E", "problemId": "672688", "problem_idx": "E", "shortId": "1381E", "contest_number": "1381", "problem_submissions": {"D": [87591748, 87572223, 87570648, 87582982, 87586752, 87583704, 87583370, 87582500, 87584659, 87587190, 87585425, 87584920, 87586314, 87587486, 87594226, 87586828, 87594293, 87591657], "C": [87577674, 87546464, 87551239, 87551679, 87564770, 87559807, 87550092, 87554512, 87552473, 87551783, 87555903, 87552429, 87566646, 87560357, 87558905, 87562842, 87558315, 87548663, 87563323, 87564320], "E": [87567737, 87589785, 87589949, 87596216, 87640160, 88159077], "B": [87530540, 87536246, 87534741, 87537123, 87529700, 87542854, 87536901, 87535443, 87600036, 87597446, 87597372, 87597147, 87539002, 87526278, 87542730, 87541737, 87542797, 87547230, 87546945, 87544725, 87542982, 87556756, 87537375, 87546524], "A2": [87526192, 87528075, 87538920, 87528594, 87524934, 87532953, 87532583, 87529096, 87530902, 87560515, 87534125, 87531636, 87526735, 87535144, 87541660, 87537924, 87531704, 87562447, 87527622, 87539527], "A1": [87525285, 87529682, 87539163, 87530199, 87524566, 87531985, 87534339, 87528864, 87530298, 87560684, 87535197, 87534155, 87525747, 87526142, 87534462, 87527522, 87533953, 87562626, 87529570, 87539110]}, "name": "E. Origami", "statement": "There is a piece of paper in the shape of a simple polygon with n\r\nvertices. The polygon may be non-convex, but we all know that proper\r\norigami paper has the property that If you fold the paper along the\r\nvertical line x=f, what will be the area of the resulting shape? When\r\nyou fold, the part of the paper to the left of the line is symmetrically\r\nreflected on the right side. Your task is to answer q independent\r\nqueries for values f_1,\r\nldots,f_q.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n\t#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n\t#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: Use in place of \\texttt{complex<T>}.\n * Source: http://codeforces.com/blog/entry/22175, KACTL\n * Verification: various\n */\n\ntypedef ld T;\nint sgn(T a) { return (a>0)-(a<0); }\nT sq(T a) { return a*a; }\n\nnamespace Point {\n\ttypedef pair<T,T> P; typedef vector<P> vP;\n\tT norm(const P& p) { return sq(p.f)+sq(p.s); }\n\tT abs(const P& p) { return sqrt(norm(p)); }\n\tT arg(const P& p) { return atan2(p.s,p.f); }\n\tP conj(const P& p) { return P(p.f,-p.s); }\n\tP perp(const P& p) { return P(-p.s,p.f); }\n\tP dir(T ang) { return P(cos(ang),sin(ang)); }\n\t\n\tP operator-(const P& l) { return P(-l.f,-l.s); }\n\tP operator+(const P& l, const P& r) { \n\t\treturn P(l.f+r.f,l.s+r.s); }\n\tP operator-(const P& l, const P& r) { \n\t\treturn P(l.f-r.f,l.s-r.s); }\n\tP operator*(const P& l, const T& r) { \n\t\treturn P(l.f*r,l.s*r); }\n\tP operator*(const T& l, const P& r) { return r*l; }\n\tP operator/(const P& l, const T& r) { \n\t\treturn P(l.f/r,l.s/r); }\n\tP operator*(const P& l, const P& r) { \n\t\treturn P(l.f*r.f-l.s*r.s,l.s*r.f+l.f*r.s); }\n\tP operator/(const P& l, const P& r) { \n\t\treturn l*conj(r)/norm(r); }\n\tP& operator+=(P& l, const P& r) { return l = l+r; }\n\tP& operator-=(P& l, const P& r) { return l = l-r; }\n\tP& operator*=(P& l, const T& r) { return l = l*r; }\n\tP& operator/=(P& l, const T& r) { return l = l/r; }\n\tP& operator*=(P& l, const P& r) { return l = l*r; }\n\tP& operator/=(P& l, const P& r) { return l = l/r; }\n\t\n\tP unit(const P& p) { return p/abs(p); }\n\tT dot(const P& a, const P& b) { return a.f*b.f+a.s*b.s; }\n\tT cross(const P& a, const P& b) { return a.f*b.s-a.s*b.f; }\n\tT cross(const P& p, const P& a, const P& b) {\n\t\treturn cross(a-p,b-p); }\n\tP reflect(const P& p, const P& a, const P& b) { \n\t\treturn a+conj((p-a)/(b-a))*(b-a); }\n\tP foot(const P& p, const P& a, const P& b) { \n\t\treturn (p+reflect(p,a,b))/(T)2; }\n\tbool onSeg(const P& p, const P& a, const P& b) { \n\t\treturn cross(a,b,p) == 0 && dot(p-a,p-b) <= 0; }\n\tostream& operator<<(ostream& os, const P& p) {\n\t\treturn os << \"(\" << p.f << \",\" << p.s << \")\"; }\n};\nusing namespace Point;\n\n/**\n * Description: centroid (center of mass) of a polygon with \n \t* constant mass per unit area and SIGNED area\n * Time: O(N)\n * Source: http://codeforces.com/blog/entry/22175, KACTL\n * Verification: kattis polygonarea, VT HSPC 2018 Holiday Stars\n */\n\n//#include \"../Primitives/Point.h\"\n\npair<P,T> cenArea(const vP& v) { \n\tP cen(0,0); T area = 0; \n\tF0R(i,sz(v)) {\n\t\tint j = (i+1)%sz(v); T a = cross(v[i],v[j]);\n\t\tcen += a*(v[i]+v[j]); area += a;\n\t}\n\treturn {cen/area/(T)3,area/2};\n}\n\nvP v;\nvP L, R;\n\ntypedef array<T,3> Q;\n\nint pos = 0;\nvector<pair<T,Q>> ev;\nQ sum;\n\nint n,q;\n\nT get(T x) {\n\twhile (pos < sz(ev) && ev[pos].f < x) {\n\t\tF0R(i,3) sum[i] += ev[pos].s[i];\n\t\tpos ++;\n\t}\n\treturn (sum[2]*x+sum[1])*x+sum[0];\n}\n\nQ mul(T a, Q b) {\n\ttrav(t,b) t *= a;\n\treturn b;\n}\n\nQ operator-(Q a, Q b) {\n\tF0R(i,3) a[i] -= b[i];\n\treturn a;\n}\nQ operator+(Q a, Q b) {\n\tF0R(i,3) a[i] += b[i];\n\treturn a;\n}\n\nconst int BIG = 2e5;\n\nQ getEq(T l, T r, T a, T b, T c) {\n\tassert(l < r);\n\tQ ori = {0,(c-a)/(r-l),0};\n\tori[0] = a-ori[1]*l;\n\tb -= (a+c)/2;\n\tT m = (l+r)/2;\n\t// (x-l)*(x-r)*k = b\n\tb /= (m-l)*(m-r);\n\tori = ori+mul(b,Q{l*r,-l-r,1});\n\t//dbg(\"GETEQ\",l,r,a,b,c,ori); exit(0);\n\treturn ori;\n}\n\nT getX(P a, P b, T y) {\n\treturn ((b.s-y)*a.f+(y-a.s)*b.f)/(b.s-a.s);\n}\n\nT getArea(P a, P b) {\n\t//dbg(\"DOING\",a,b);\n\tvd impY = {0,1};\n\tauto ad = [&](T l, T r) { // 5, -1 -> 5/6\n\t\tif (min(l,r) < 0 && max(l,r) > 0) impY.pb(l/(l-r)); // get point where it becomes 0\n\t};\n\tad(a.f,b.f); ad(a.s,b.s);\n\tad((a.f+a.s)/2,(b.f+b.s)/2);\n\tremDup(impY);\n\tT ans = 0;\n\tF0R(i,sz(impY)-1) {\n\t\tT difY = impY[i+1]-impY[i];\n\t\tT y = (impY[i]+impY[i+1])/2;\n\t\tT xl = getX({a.f,0},{b.f,1},y), xr = getX({a.s,0},{b.s,1},y);\n\t\tauto cur = [&]() {\n\t\t\tif (min(xl,xr) >= 0 || max(xl,xr) <= 0) return (xr-xl);\n\t\t\treturn max(abs(xl),abs(xr));\n\t\t};\n\t\tans += cur()*difY;\n\t}\n\t// dbg(\"GETAREA\",a,b,ans);\n\treturn ans;\n}\n\nT getArea(P a, P b, T c) {\n\ta.f -= c, a.s -= c;\n\tb.f -= c, b.s -= c;\n\treturn getArea(a,b);\n}\n\nvector<pair<T,Q>> make(P a, P b) {\n\t// evaluate pos and interpolate?\n\tvd reg;\n\treg.pb(-BIG);\n\treg.pb(BIG);\n\treg.pb(a.f); reg.pb((a.f+a.s)/2); reg.pb(a.s);\n\treg.pb(b.f); reg.pb((b.f+b.s)/2); reg.pb(b.s);\n\tremDup(reg);\n\tvd ans;\n\tF0R(i,sz(reg)) ans.pb(getArea(a,b,reg[i]));\n\tvd mid;\n\tF0R(i,sz(reg)-1) mid.pb(getArea(a,b,(reg[i]+reg[i+1])/2));\n\t// dbg(reg);\n\t// dbg(ans);\n\t// dbg(mid);\n\tvector<Q> eqs;\n\tF0R(i,sz(mid)) eqs.pb(getEq(reg[i],reg[i+1],ans[i],mid[i],ans[i+1]));\n\tROF(i,1,sz(eqs)) eqs[i] = eqs[i]-eqs[i-1];\n\tvector<pair<T,Q>> res;\n\tF0R(i,sz(mid)) res.pb({reg[i],eqs[i]});\n\treturn res;\n}\n\nvector<pair<T,pair<P,P>>> tmp;\n\nT brute(T x) {\n\tT ans = 0;\n\ttrav(t,tmp) ans += t.f*getArea(t.s.f,t.s.s,x);\n\treturn ans;\n}\n\nint main() {\n\tsetIO(); re(n,q);\n\tv.rsz(n); re(v);\n\tif (cenArea(v).s > 0) reverse(all(v));\n\tint ind = 0;\n\tF0R(i,n) if (v[i].s < v[ind].s) ind = i;\n\trotate(begin(v),ind+all(v));\n\tF0R(i,n) if (v[i].s > v[ind].s) ind = i;\n\tF0R(i,ind+1) L.pb(v[i]);\n\tFOR(i,ind,n+1) R.pb(v[i%n]);\n\treverse(all(R));\n\t// dbg(L);\n\t// dbg(R);\n\n\tint il = 0, ir = 0;\n\tT cy = v[0].s;\n\twhile (il < sz(L)-1 && ir < sz(R)-1) {\n\t\tT ny = min(L[il+1].s,R[ir+1].s); assert(ny > cy);\n\t\tT dif = ny-cy;\n\t\t//dbg(\"HA\",cy,ny);\n\t\tP x0 = {getX(L[il],L[il+1],cy),getX(R[ir],R[ir+1],cy)};\n\t\tP x1 = {getX(L[il],L[il+1],ny),getX(R[ir],R[ir+1],ny)};\n\t\ttmp.pb({dif,{x0,x1}});\n\t\t// dbg(cy,ny,x0,x1);\n\t\t//dbg(ny-cy,x0,x1);\n\t\tauto evs = make(x0,x1);\n\t\ttrav(t,evs) ev.pb({t.f,mul(dif,t.s)});\n\t\tcy = ny;\n\t\tif (L[il+1].s == cy) il ++;\n\t\tif (R[ir+1].s == cy) ir ++;\n\t}\n\tsort(all(ev));\n\t// trav(t,tmp) dbg(t);\n\t//exit(0);\n\tvector<pair<T,int>> query;\n\tvd ans(q);\n\tF0R(i,q) {\n\t\tT f; re(f);\n\t\tquery.pb({f,i});\n\t}\n\tsort(all(query));\n\ttrav(t,query) {\n\t\tans[t.s] = get(t.f);\n\t}\n\ttrav(t,ans) cout << fixed << setprecision(10) << t << \"\\n\";\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"], "input": "", "output": "", "tags": ["geometry", "math", "sortings"], "dificulty": "3300", "interactive": false}