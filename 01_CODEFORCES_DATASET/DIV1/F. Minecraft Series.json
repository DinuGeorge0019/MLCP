{
    "link": "https://codeforces.com//contest/1753/problem/F",
    "problemId": "1601081",
    "problem_idx": "F",
    "shortId": "1753F",
    "contest_number": "1753",
    "problem_submissions": {
        "F": [
            177651080,
            177647555,
            177657470,
            188911747,
            188911656,
            188911570,
            188911428,
            188910549,
            188910073,
            188909646,
            188909166,
            188907827,
            188904326,
            188904190,
            188903731,
            177833531,
            177833492
        ],
        "E": [
            177581778,
            177583727,
            177589838,
            177589285,
            177593827,
            177594409,
            177597830,
            177594087,
            177592707,
            177585112,
            177601527,
            177590220,
            177673253,
            177974155,
            177974124,
            177973591,
            177724036
        ],
        "D": [
            177563465,
            177565205,
            177564757,
            177573155,
            177575242,
            177580076,
            177576436,
            177570973,
            177566523,
            177596897,
            177580588,
            177604329,
            177563352,
            177570046,
            177566269,
            177573602,
            177755461,
            177576614,
            177574911
        ],
        "C": [
            177552151,
            177550933,
            177551820,
            177553154,
            177551866,
            177564888,
            177563099,
            177563169,
            177574479,
            177556455,
            177565810,
            177544648,
            177550098,
            177548226,
            177548338,
            177556464,
            177755441,
            177552144,
            177557310
        ],
        "B": [
            177547853,
            177542169,
            177543741,
            177547659,
            177545799,
            177543102,
            177548449,
            177558513,
            177542410,
            177547120,
            177556897,
            177532887,
            177540969,
            177543956,
            177543358,
            177547075,
            177755409,
            177545453,
            177551061
        ],
        "A2": [
            177545216,
            177538464,
            177539211,
            177543167,
            177542984,
            177539535,
            177544288,
            177553832,
            177538606,
            177548841,
            177551155,
            177550293,
            177537648,
            177536071,
            177539594,
            177543961,
            177755345,
            177539530,
            177545423
        ],
        "A1": [
            177533578,
            177538639,
            177539788,
            177537288,
            177537340,
            177539306,
            177543813,
            177553991,
            177538938,
            177533253,
            177550897,
            177550032,
            177537887,
            177533119,
            177533588,
            177544324,
            177755312,
            177540035,
            177546684
        ]
    },
    "name": "F. Minecraft Series",
    "statement": "Little Misha goes to the programming club and solves nothing there. It\r\nmay seem strange, but when you find out that Misha is filming a\r\nMinecraft series, everything will fall into place...Misha is inspired by\r\nManhattan, so he built a city in Minecraft that can be imagined as a\r\ntable of size n\r\ntimes m. k students live in a city, the i-th student lives in the house,\r\nlocated at the intersection of the x_i-th row and the y_i-th column.\r\nAlso, each student has a degree of his aggressiveness w_i. Since the\r\ncity turned out to be very large, Misha decided to territorially limit\r\nthe actions of his series to some square s, which sides are parallel to\r\nthe coordinate axes. The length of the side of the square should be an\r\ninteger from 1 to\r\nmin(n, m) cells.According to the plot, the main hero will come to the\r\ncity and accidentally fall into the square s. Possessing a unique degree\r\nof aggressiveness 0, he will be able to show his leadership qualities\r\nand assemble a team of calm, moderate and aggressive students.In order\r\nfor the assembled team to be versatile and close-knit, degrees of\r\naggressiveness of all students of the team must be pairwise distinct and\r\nmust form a single segment of consecutive integers. Formally, if\r\nstudents with degrees of aggressiveness l, l+1,\r\nldots, -1, 1,\r\nldots, r-1, r inside the square s, where l\r\nle 0\r\nle r, the main hero will be able to form a team of r-l+1 people (of\r\ncourse, he is included in this team)., that it is not required to take\r\nall students from square s to the team.Misha thinks that the team should\r\nconsist of at least t people. That is why he is interested, how many\r\nsquares are there in the table in which the main hero will be able to\r\nform a team of at least t people. Help him to calculate this.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int K = 1E6 + 2;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m, k, t;\n    std::cin >> n >> m >> k >> t;\n    \n    const int N = n * m;\n    std::vector<std::vector<int>> ap(N), an(N);\n    \n    std::bitset<K> fp, fn;\n    for (int i = 1; i <= t; i++) {\n        fp[i] = fn[i] = 1;\n    }\n    \n    std::vector<int> cp(t + 1), cn(t + 1);\n    cp[0] = cn[0] = 1;\n    \n    for (int i = 0; i < k; i++) {\n        int x, y, z;\n        std::cin >> x >> y >> z;\n        x--, y--;\n        if (z && z > -t && z < t) {\n            if (z > 0) {\n                ap[x * m + y].push_back(z);\n            } else {\n                an[x * m + y].push_back(-z);\n            }\n        }\n    }\n    \n    auto add = [&](int x, int y) {\n        for (auto i : ap[x * m + y]) {\n            if (!cp[i]++) {\n                fp[i] = 0;\n            }\n        }\n        for (auto i : an[x * m + y]) {\n            if (!cn[i]++) {\n                fn[i] = 0;\n            }\n        }\n    };\n    \n    auto del = [&](int x, int y) {\n        for (auto i : ap[x * m + y]) {\n            if (!--cp[i]) {\n                fp[i] = 1;\n            }\n        }\n        for (auto i : an[x * m + y]) {\n            if (!--cn[i]) {\n                fn[i] = 1;\n            }\n        }\n    };\n    \n    auto check = [&]() {\n        return fp._Find_first() + fn._Find_first() >= t + 1;\n    };\n    \n    std::vector len(n, std::vector<int>(m));\n    i64 ans = 0;\n    for (int i = 0; i < n; i++) {\n        int x0 = i, x1 = i, y0 = 0, y1 = 0;\n        int l = 0;\n        fp = 1;\n        fp = fn = ~fp;\n        std::fill(cp.begin() + 1, cp.end(), 0);\n        std::fill(cn.begin() + 1, cn.end(), 0);\n        for (int j = 0; j < m; j++) {\n            if (l && (i == 0 || l >= len[i - 1][j])) {\n                l--;\n            }\n            l = std::min({l, n - i, m - j});\n            while (y1 < j + l) {\n                for (int i = x0; i < x1; i++) {\n                    add(i, y1);\n                }\n                y1++;\n            }\n            while (y0 < j) {\n                for (int i = x0; i < x1; i++) {\n                    del(i, y0);\n                }\n                y0++;\n            }\n            while (x1 > i + l) {\n                x1--;\n                for (int i = y0; i < y1; i++) {\n                    del(x1, i);\n                }\n            }\n            while (!l || !check()) {\n                l++;\n                if (i + l > n || j + l > m) {\n                    break;\n                }\n                while (y1 < j + l) {\n                    for (int i = x0; i < x1; i++) {\n                        add(i, y1);\n                    }\n                    y1++;\n                }\n                while (x1 < i + l) {\n                    for (int i = y0; i < y1; i++) {\n                        add(x1, i);\n                    }\n                    x1++;\n                }\n            }\n            ans += std::min(n - i, m - j) - l + 1;\n            len[i][j] = l;\n        }\n    }\n    \n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "two pointers"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Minecraft Series.json",
    "editorial_link": "https://codeforces.com//blog/entry/108336",
    "editorial": "Letâs formalize the problem condition. It is required to calculate the\r\nnumber of squares in the table for which we have inequality , where is a\r\nof positive integers in the sqare and is a of absolute values of all\r\nnegative integers in the square. Then we denote cost of a square as .\r\nNote that when the square is expanded, its value cannot decrease.Letâs\r\nfix the diagonal that contains the upper left and lower right sides of\r\nthe square. Now, with a fixed lower right cell, we want to maintain the\r\nupper left cell of the square that is maximally removed from it so that\r\nits cost does not exceed . Note that this upper-left boundary can only\r\nshift in the direction of moving the right lower one, which means we can\r\nuse the two pointers technique.We will also need to maintain a set of\r\nnumbers that are contained in a square. To do this, we will process each\r\ncell separately, which are added and removed from our square. Note that\r\nfor each cell there are no more than diagonals on which it is possible\r\nto construct a square containing this cell, and also note that due to\r\nthe structure of our solution for each such diagonal, our cell will be\r\nadded to the set no more than time. Thus, the total number of additions\r\nof cells to our set does not exceed , and accordingly the total number\r\nof additions of numbers to the set does not exceed .We will also need to\r\nfind out the of all positive integers in the square, as well as the of\r\nabsolute values of negative integers in the square. Here we need to make\r\nanother observation about our algorithm. The number of queries will not\r\nexceed . That is, you can use the square roots technique to adding and\r\nremoving integers in time, and find out the values in time.To summarize,\r\nour algorithm will work in asymptotic time:As the author of the problem,\r\nI want to apologize for the very low TL in this problem. Due to the\r\nspecificity of the task, it was difficult to cut off the wrong\r\nsolutions. The solution described above, if implemented correctly, fits\r\ninto TL with a time reserve at least second. But if suddenly you didnât\r\nwrite it efficiently enough and you have TL, then you can try using the\r\nfollowing tips: Sort the numbers in each cell. This will help to better\r\nin the cache. It does benefit buffering provided by a cache. It is more\r\naccurate to implement your algorithm without making unnecessary MEX\r\nqueries. Use bit magic and implement the search in time where is machine\r\nword size. Such a solution may have a better time-constant and it is\r\nbetter to be vectorized\r\n",
    "hint": []
}