{
    "link": "https://codeforces.com//contest/1710/problem/D",
    "problemId": "1478270",
    "problem_idx": "D",
    "shortId": "1710D",
    "contest_number": "1710",
    "problem_submissions": {
        "D": [
            165580964,
            165583659,
            165582423,
            165579985,
            165578292,
            165621030,
            165665623,
            165863180,
            165686266,
            165622179,
            253472539,
            253472055,
            253196732
        ],
        "C": [
            165561993,
            165571937,
            165567266,
            165564305,
            165560493,
            165557009,
            165565561,
            165573369,
            167610382,
            165564040,
            165565611,
            165559918,
            165863165,
            165574164,
            165561713,
            165562795,
            166635016,
            165567222,
            165574139,
            165575303,
            165568215,
            165580670,
            165575504
        ],
        "B": [
            165557184,
            165556433,
            165562218,
            165559397,
            165550455,
            165567723,
            165557989,
            165562869,
            167610352,
            165552192,
            165580788,
            165551441,
            165863147,
            165568559,
            165640205,
            165639837,
            165621062,
            165556086,
            165556541,
            167747535,
            165575476,
            165569308,
            165567541,
            165555460,
            165570664,
            165584416
        ],
        "E": [
            165552045,
            165543060,
            165549416,
            165565765,
            165563275,
            165541229,
            165548123,
            165548892,
            165559843,
            165548838,
            165565641,
            165863198,
            165549459,
            165565050,
            165564177,
            166635025,
            165555617,
            165553406,
            165554497,
            165569888,
            165555183,
            165548602
        ],
        "A": [
            165540652,
            165547446,
            165541424,
            165545863,
            165540100,
            165538811,
            165546951,
            165544526,
            167610720,
            167610305,
            165540896,
            165542843,
            165539482,
            165863070,
            165547951,
            165543234,
            165543554,
            165541413,
            165551173,
            165542506,
            165539602,
            165547656,
            165544347
        ]
    },
    "name": "D. Recover the Tree",
    "statement": "Rhodoks has a tree with n vertices, but he doesn’t remember its\r\nstructure. The vertices are indexed from 1 to n.A segment [l,r] (1\r\nleq l\r\nleq r\r\nleq n) is good if the vertices with indices l, l + 1, ..., r form a\r\nconnected component in Rhodoks’ tree. Otherwise, it is bad.For example,\r\nif the tree is the one in the picture, then only the segment [3,4] is\r\nbad while all the other segments are good. For each of the\r\nfrac{n(n+1)}{2} segments, Rhodoks remembers whether it is good or bad.\r\nCan you help him recover the tree? If there are multiple solutions,\r\nprint any.It is guaranteed that the there is at least one tree\r\nsatisfying Rhodoks’ description.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int maxn=2222,mod=998244353;\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline ll read(){\n\tchar ch=getchar();ll x=0,f=0;\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint n,al,tmp[maxn],tl,sum[maxn][maxn];\nPII ans[maxn];\nset<PII> s;\nchar str[maxn][maxn];\ninline void add(int u,int v){\n\tif(u>v) swap(u,v);\n\tans[++al]=MP(u,v);\n}\nvoid clear(){\n\tal=tl=0;\n\tFOR(i,1,n) tmp[i]=0,ans[i]=MP(0,0);\n\tFOR(i,1,n) FOR(j,1,n) sum[i][j]=0;\n\ts.clear();\n}\nvoid solve(){\n\tn=read();\n\tFOR(i,1,n) scanf(\"%s\",str[i]+1);\n\tFOR(i,1,n) s.insert(MP(i,i));\n\tFOR(len,2,n) FOR(l,1,n-len+1){\n\t\tint r=l+len-1;\n\t\tif(str[l][len]=='0') continue;\n\t\t// last se>=l is the one before first fi>l\n\t\t// last fi<=r\n\t\tauto lft=s.lower_bound(MP(l+1,0)),rig=s.lower_bound(MP(r+1,0));\n\t\tlft--;rig--;\n//\t\tprintf(\"l=%d,r=%d\\n\",l,r);\n\t\tif(lft==rig) continue;\n//\t\tputs(\"in\");\n\t\ttmp[tl=1]=l;\n\t\tfor(auto it=lft;it!=rig;it++){\n\t\t\tif(it==lft) continue;\n\t\t\ttmp[++tl]=it->fi;\n\t\t}\n\t\ttmp[++tl]=r;\n//\t\tFOR(i,1,tl) printf(\"%d \",tmp[i]);\n//\t\tputs(\"\");\n\t\tassert(tl!=3);\n\t\tif(tl>=4){\n\t\t\tif(tl%2==1){\n\t\t\t\tint lst=tmp[4];\n\t\t\t\tFOR(i,1,tl) if(i%2==1) add(lst,tmp[i]),lst=tmp[i];\n\t\t\t\tFOR(i,2,tl) if(i!=4 && i%2==0) add(lst,tmp[i]),lst=tmp[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint lst=tmp[2];\n\t\t\t\tFOR(i,4,tl) if(i%2==0) add(lst,tmp[i]),lst=tmp[i];\n\t\t\t\tFOR(i,1,tl) if(i%2==1) add(lst,tmp[i]),lst=tmp[i];\n\t\t\t}\n\t\t}\n\t\telse add(l,r);\n\t\tint x=lft->fi,y=rig->se;\n\t\trig++;\n\t\ts.erase(lft,rig);\n\t\ts.insert(MP(x,y));\n\t}\n\tassert(al==n-1);\n\tFOR(i,1,n-1) printf(\"%d %d\\n\",ans[i].fi,ans[i].se),sum[ans[i].fi][ans[i].se]++;\n\tFOR(i,1,n) FOR(j,1,n) sum[i][j]+=sum[i][j-1];\n\tROF(i,n,1) FOR(j,1,n) sum[i][j]+=sum[i+1][j];\n\tFOR(i,1,n){\n\t\tFOR(j,i,n){\n\t\t\tassert((sum[i][j]==j-i)==(str[i][j-i+1]=='1'));\n\t\t\tif((sum[i][j]==j-i)!=(str[i][j-i+1]=='1')) printf(\"at %d %d\\n\",i,j);\n\t\t}\n\t}\n\tclear();\n}\nint main(){\n\tint T=read();\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Recover the Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/105232",
    "editorial": "Thank dario2994, the key part of the proof is from him. hint1If interval\r\nare all good and , then is good, too.\r\n",
    "hint": [
        "hint1 If interval are all good and , then is good, too.",
        "hint2 If interval are all good and , then is good, too.",
        "hint3 Consider enumerating good intervals according to their length."
    ]
}