{
    "link": "https://codeforces.com//contest/403/problem/E",
    "problemId": "7187",
    "problem_idx": "E",
    "shortId": "403E",
    "contest_number": "403",
    "problem_submissions": {
        "E": [
            6040937,
            154984304,
            6052630,
            6052356,
            14574817,
            14574735,
            14574710,
            14574669,
            14574665,
            6040453
        ],
        "A": [
            6035160,
            6030951,
            6030860,
            6031178,
            6034007,
            6030859,
            6031215,
            6036883,
            6034828,
            6031673,
            6031177,
            6031105,
            6030857,
            6031293,
            6030993,
            6042179,
            6030867,
            6040743,
            6030907,
            6031032
        ],
        "D": [
            6032031,
            6036149,
            6037514,
            6035188,
            6038552,
            6036821,
            6037360,
            6035214,
            6032979,
            6051793,
            6039305,
            6040517,
            6037815,
            6037208,
            6040122,
            6042199,
            6036355,
            6036730,
            6039500,
            6040454
        ],
        "B": [
            6037462,
            6032575,
            6037115,
            6031670,
            6038606,
            6034965,
            6038593,
            6037275,
            6035133,
            6032908,
            6036968,
            6034116,
            6033389,
            6034279,
            6042123,
            6032620,
            6032444,
            6034225
        ],
        "C": [
            6033086,
            6035964,
            6032440,
            6032942,
            6033609,
            6032046,
            6031154,
            6035769,
            6036195,
            6034842,
            6032124,
            6038424,
            6038292,
            6035730,
            6042190,
            6033591,
            6038234,
            6037774,
            6036096
        ]
    },
    "name": "E. Two Rooted Trees",
    "statement": "You have two rooted undirected trees, each contains vertices. Let\u2019s\r\nnumber the vertices of each tree with integers from to . The root of\r\neach tree is at vertex . The edges of the first tree are painted blue,\r\nthe edges of the second one are painted red. For simplicity, let\u2019s say\r\nthat the first tree is blue and the second tree is red.Edge is called\r\nbad for edge if two conditions are fulfilled: The color of edge is\r\ndifferent from the color of edge . Let\u2019s consider the tree of the same\r\ncolor that edge is. Exactly one of vertices , lies both in the subtree\r\nof vertex and in the subtree of vertex . In this problem, your task is\r\nto simulate the process described below. The process consists of several\r\nstages: On each stage edges of exactly one color are deleted. On the\r\nfirst stage, exactly one blue edge is deleted. Let\u2019s assume that at the\r\nstage we\u2019ve deleted edges , , , . At the stage we will delete all\r\nundeleted bad edges for edge , then we will delete all undeleted bad\r\nedges for edge and so on until we reach edge . For each stage of\r\ndeleting edges determine what edges will be removed on the stage. Note\r\nthat the definition of a bad edge always considers the initial tree\r\nbefore it had any edges removed.\r\n",
    "solutions": [
        "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<\" = \"<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\n\n#define maxn 200010\n#define INF 1000000000\n\nstruct node\n{\n\tint left, right, mid, minv, minvi;\n};\n\nstruct SegT\n{\n\tnode a[524288];\n\t\n\tvoid update(int i)\n\t{\n\t\tif (a[i*2].minv<a[i*2+1].minv)\n\t\t{\n\t\t\ta[i].minv=a[i*2].minv; a[i].minvi=a[i*2].minvi;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta[i].minv=a[i*2+1].minv; a[i].minvi=a[i*2+1].minvi;\n\t\t}\n\t}\n\t\n\tvoid build(int i, int bg, int ed)\n\t{\n\t\ta[i].left=bg; a[i].right=ed; a[i].mid=(bg+ed)/2;\n\t\tif (bg==ed) { a[i].minv=INF; a[i].minvi=bg; return; }\n\t\tbuild(i*2,bg,a[i].mid); build(i*2+1,a[i].mid+1,ed);\n\t\tupdate(i);\n\t}\n\t\n\tvoid serere(int i, int pl, int val)\n\t{\n\t\tif (a[i].left==a[i].right) { a[i].minv=val; a[i].minvi=a[i].left; return; }\n\t\tif (pl<=a[i].mid) serere(i*2,pl,val); else serere(i*2+1,pl,val);\n\t\tupdate(i);\n\t}\n\t\n\tpair<int,int> query(int i, int bg, int ed)\n\t{\n\t\tif (bg<=a[i].left && a[i].right<=ed) return make_pair(a[i].minv,a[i].minvi);\n\t\tif (ed<=a[i].mid) return query(i*2,bg,ed);\n\t\tif (a[i].mid<bg) return query(i*2+1,bg,ed);\n\t\tpair<int,int> t1=query(i*2,bg,ed), t2=query(i*2+1,bg,ed);\n\t\tif (t1.first<t2.first) return t1; else return t2;\n\t}\n};\n\t\nstruct tree\n{\n\tint n, tot;\n\tvector<int> e[maxn];\n\tint parent[maxn], depth[maxn], lg2[maxn], killed[maxn];\n\tint p[maxn][20], lbound[maxn], rbound[maxn], whom[maxn];\n\tSegT t;\n\tmap< pair<int,int>, int> snum, sonum;\n\tvector< pair<int,int> > eo[maxn];\n\tint edge_o1[maxn], edge_o2[maxn];\n\tvector< pair<int,int> >::iterator iter[maxn];\n\t\n\tvoid dfs(int cur, int pre, int dep)\n\t{\n\t\ttot++; lbound[cur]=tot; whom[tot]=cur;\n\t\tdepth[cur]=dep; p[cur][0]=pre; parent[cur]=pre;\n\t\trep(i,1,lg2[dep]) p[cur][i]=p[p[cur][i-1]][i-1];\n\t\trept(it,e[cur])\n\t\t\tif (*it!=pre)\n\t\t\t\tdfs(*it,cur,dep+1);\n\t\t\t\n\t\trbound[cur]=tot;\n\t}\n\t\n\tint moveup(int x, int y)\n\t{\n\t\twhile (y) x=p[x][lg2[y&-y]], y-=y&-y;\n\t\treturn x;\n\t}\n\t\n\tint lca(int x, int y)\n\t{\n\t\tif (depth[x]>depth[y]) x=moveup(x,depth[x]-depth[y]); else y=moveup(y,depth[y]-depth[x]);\n\t\trepd(i,19,0)\n\t\t\tif (p[x][i]!=p[y][i])\n\t\t\t{\n\t\t\t\tx=p[x][i]; y=p[y][i];\n\t\t\t}\n\t\tif (x==y) return x; else return p[x][0];\n\t}\n\t\n\tvoid readin(int _n, int *d, int *od)\n\t{\n\t\tn=_n;\n\t\trep(i,1,n-1)\n\t\t{\n\t\t\tint x=d[i], y=i+1;\n\t\t\te[x].push_back(y); e[y].push_back(x);\n\t\t\tsnum[make_pair(x,y)]=i;\n\t\t\tsnum[make_pair(y,x)]=i;\n\t\t}\n\t\t\n\t\tlg2[1]=0; rep(i,2,maxn-1) lg2[i]=lg2[i/2]+1;\n\t\ttot=0;\n\t\tdfs(1,0,0);\n\t\tt.build(1,1,n);\n\t\t\n\t\trep(i,1,n-1)\n\t\t{\n\t\t\tint x=od[i], y=i+1;\n\t\t\tsonum[make_pair(x,y)]=i;\n\t\t\tsonum[make_pair(y,x)]=i;\n\t\t\tint z=depth[lca(x,y)];\n\t\t\teo[x].push_back(make_pair(z,i));\n\t\t\teo[y].push_back(make_pair(z,i));\n\t\t\tedge_o1[i]=x; edge_o2[i]=y;\n\t\t}\n\t\t\n\t\trep(i,1,n) eo[i].push_back(make_pair(INF,0));\n\t\trep(i,1,n) sort(eo[i].begin(),eo[i].end());\n\t\trep(i,1,n) t.serere(1,lbound[i],(eo[i].begin())->first);\n\t\trep(i,1,n) iter[i]=eo[i].begin();\n\t\tmemset(killed,0,sizeof killed);\n\t}\n\t\n\tvoid kill_edge(int x, int y)\n\t{\n\t\tkilled[sonum[make_pair(x,y)]]=1;\n\t}\n\t\n\tvoid kill(int x, int y, vector< pair<int,int> > &ret)\n\t{\n\t\tif (parent[y]==x) swap(x,y);\n\t\twhile (1)\n\t\t{\n\t\t\tpair<int,int> ts=t.query(1,lbound[x],rbound[x]);\n\t\t\tif (ts.first>=depth[x]) break;\n\t\t\tint where=whom[ts.second];\n\t\t\tint edge_id=iter[where]->second;\n\t\t\tif (!killed[edge_id])\n\t\t\t{\n\t\t\t\tkilled[edge_id]=1;\n\t\t\t\tret.push_back(make_pair(edge_o1[edge_id],edge_o2[edge_id]));\n\t\t\t}\n\t\t\titer[where]++;\n\t\t\tt.serere(1,lbound[where],iter[where]->first);\n\t\t}\n\t}\n\t\n};\n\ntree blue, red;\nint d1[maxn], d2[maxn];\n\nvoid lemon()\n{\n\tint n; scanf(\"%d\",&n);\n\trep(i,1,n-1) scanf(\"%d\",&d1[i]);\n\trep(i,1,n-1) scanf(\"%d\",&d2[i]);\n\tint idx; scanf(\"%d\",&idx);\n\tint x0=idx+1, y0=d1[idx];\n\tblue.readin(n,d1,d2);\n\tred.readin(n,d2,d1);\n\tred.kill_edge(x0,y0);\n\t\n\tint who=0;\n\tvector< pair<int,int> > cur, next;\n\tcur.push_back(make_pair(x0,y0));\n\twhile (!cur.empty())\n\t{\n\t\tnext.clear();\n\t\tif (who==0)\n\t\t{\n\t\t\tprintf(\"Blue\\n\");\n\t\t\tvector<int> ans; ans.clear();\n\t\t\trept(it,cur) ans.push_back(blue.snum[*it]);\n\t\t\tsort(ans.begin(),ans.end());\n\t\t\trept(it,ans) printf(\"%d \",*it); printf(\"\\n\");\n\t\t\trept(it,cur) blue.kill(it->first,it->second,next);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Red\\n\");\n\t\t\tvector<int> ans; ans.clear();\n\t\t\trept(it,cur) ans.push_back(red.snum[*it]);\n\t\t\tsort(ans.begin(),ans.end());\n\t\t\trept(it,ans) printf(\"%d \",*it); printf(\"\\n\");\n\t\t\trept(it,cur) red.kill(it->first,it->second,next);\n\t\t}\n\t\tswap(cur,next);\n\t\twho=1-who;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(true);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"E.in\",\"r\",stdin);\n\t#endif\n\tlemon();\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Two Rooted Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/10972",
    "editorial": "First, for each vertex of the first and second tree we calculate two\r\nvalues , the entry time and exit time in dfs order from vertex with\r\nnumber . Also with each edge from both trees we will assosiate a pair ,\r\nwhere , (values for each vertex we take from tree with another color).\r\nNow for each tree we will build two segment trees (yes, totally 4\r\nsegment trees). In first segment will store all pairs in following way:\r\nwe will store a pair in node of segment tree if and only if (node of\r\nsegment tree is a segment ) left element of pair lies in segment . In\r\nsecond segment tree we will store a pair if and only if right element of\r\nthe pair lies in segment All pairs in segment trees we will store in\r\nsome order (in first segment tree increasing order, in the second tree\r\ndecreasing order). Such trees use of memory, also you can build it in .\r\nGood. How to answer on query erase all edges from tree for which exactly\r\none vertex have value in segment ? We will go down in our segment tree.\r\nLet\u00e2\u0080\u0099s imagine, that now we in some node of segment tree. Because we\r\nstore all pairs in the first segment tree in increasing order of the\r\nright element, so answer to the query is a some suffix of the array of\r\npairs. After we can add they to the answer (if it not erased yet). After\r\nthat we should modify our segment tree: for each node, where we work\r\nwith suffixes, we should erase all pairs from such suffix. So, this\r\nsolution in . My solution to E: 6052738\r\n"
}