{
    "link": "https://codeforces.com//contest/321/problem/B",
    "problemId": "3264",
    "problem_idx": "B",
    "shortId": "321B",
    "contest_number": "321",
    "problem_submissions": {
        "D": [
            3996276,
            3980026,
            3983272,
            3983312,
            12592698,
            3984131
        ],
        "E": [
            3980136,
            4452055,
            3980389,
            3985877,
            3982432,
            3983276,
            3983985,
            3983546,
            3989402,
            3982283,
            3982901,
            3987486,
            3986621,
            3986597,
            3984324
        ],
        "B": [
            3977018,
            3976497,
            3975346,
            3975457,
            3977862,
            3977933,
            3976248,
            3977096,
            3975835,
            3975367,
            3981509,
            3977308,
            3981308,
            3976604,
            3978354,
            23607133
        ],
        "C": [
            3976574,
            3973635,
            80179378,
            80179360,
            80178543,
            80177368,
            3977407,
            3978721,
            3979609,
            3977413,
            3979117,
            3980301,
            3977480,
            3978832,
            3979230,
            3979055,
            3978017,
            3980667,
            3983932,
            3980825
        ],
        "A": [
            3973735,
            3982224,
            3988924,
            3983503,
            3973922,
            3973057,
            3973436,
            3974764,
            3973866,
            3973513,
            3973909,
            3973666,
            3985547,
            3973654,
            3974568
        ]
    },
    "name": "B. Ciel and Duel",
    "statement": "Fox Ciel is playing a card game with her friend Jiro.Jiro has cards,\r\neach one has two attributes: (Attack or Defense) and . Fox Ciel has\r\ncards, each one has these two attributes too. It\u2019s known that position\r\nof all Ciel\u2019s cards is Attack.Now is Ciel\u2019s battle phase, Ciel can do\r\nthe following operation many times: Choose one of her cards . This card\r\nmustn\u2019t be chosen before. If Jiro has no alive cards at that moment, he\r\ngets the damage equal to (\u2019s strength). Otherwise, Ciel needs to choose\r\none Jiro\u2019s alive card , then: If \u2019s position is Attack, then (\u2019s\r\nstrength) (\u2019s strength) must hold. After this attack, card dies, and\r\nJiro gets the damage equal to (\u2019s strength) - (\u2019s strength). If \u2019s\r\nposition is Defense, then (\u2019s strength) (\u2019s strength) must hold. After\r\nthis attack, card dies, but Jiro gets no damage. Ciel can end her battle\r\nphase at any moment (so, she can use not all her cards). Help the Fox to\r\ncalculate the maximal sum of damage Jiro can get.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n//template<class Flow = int, class Cost = int>\ntypedef int Flow;\ntypedef int Cost;\n\nstruct MinCostFlow {\n\tstruct Edge {\n\t\tint t;\n\t\tFlow f;\n\t\tCost c;\n\t\tEdge*next, *rev;\n\t\tEdge(int _t, Flow _f, Cost _c, Edge*_next) :\n\t\t\t\tt(_t), f(_f), c(_c), next(_next) {\n\t\t}\n\t};\n\n\tvector<Edge*> E;\n\n\tint addV() {\n\t\tE.push_back((Edge*) 0);\n\t\treturn E.size() - 1;\n\t}\n\n\tEdge* makeEdge(int s, int t, Flow f, Cost c) {\n\t\treturn E[s] = new Edge(t, f, c, E[s]);\n\t}\n\n\tvoid addEdge(int s, int t, Flow f, Cost c) {\n\t\tEdge*e1 = makeEdge(s, t, f, c), *e2 = makeEdge(t, s, 0, -c);\n\t\te1->rev = e2, e2->rev = e1;\n\t}\n\n\tpair<Flow, Cost> minCostFlow(int vs, int vt, bool maxFlow) { //flow,cost\n\t\tint n = E.size();\n\t\tFlow flow = 0;\n\t\tCost cost = 0;\n//\t\tconst Cost MAX_COST = numeric_limits<Cost>::max();\n//\t\tconst Flow MAX_FLOW = numeric_limits<Flow>::max();\n\t\tconst Cost MAX_COST = ~0U >> 1;\n\t\tconst Flow MAX_FLOW = ~0U >> 1;\n\t\tfor (;;) {\n\t\t\tvector<Cost> dist(n, MAX_COST);\n\t\t\tvector<Flow> am(n, 0);\n\t\t\tvector<Edge*> prev(n);\n\t\t\tvector<bool> inQ(n, false);\n\t\t\tqueue<int> que;\n\n\t\t\tdist[vs] = 0;\n\t\t\tam[vs] = MAX_FLOW;\n\t\t\tque.push(vs);\n\t\t\tinQ[vs] = true;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint u = que.front();\n\t\t\t\tCost c = dist[u];\n\t\t\t\tque.pop();\n\t\t\t\tinQ[u] = false;\n\t\t\t\tfor (Edge*e = E[u]; e; e = e->next)\n\t\t\t\t\tif (e->f > 0) {\n\t\t\t\t\t\tCost nc = c + e->c;\n\t\t\t\t\t\tif (nc < dist[e->t]) {\n\t\t\t\t\t\t\tdist[e->t] = nc;\n\t\t\t\t\t\t\tprev[e->t] = e;\n\t\t\t\t\t\t\tam[e->t] = min(am[u], e->f);\n\t\t\t\t\t\t\tif (!inQ[e->t]) {\n\t\t\t\t\t\t\t\tque.push(e->t);\n\t\t\t\t\t\t\t\tinQ[e->t] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (maxFlow) {\n\t\t\t\tif (dist[vt] == MAX_COST)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (dist[vt] >= 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tFlow by = am[vt];\n\t\t\tint u = vt;\n\t\t\tflow += by;\n\t\t\tcost += by * dist[vt];\n\t\t\twhile (u != vs) {\n\t\t\t\tEdge*e = prev[u];\n\t\t\t\te->f -= by;\n\t\t\t\te->rev->f += by;\n\t\t\t\tu = e->rev->t;\n\t\t\t}\n\t\t}\n\n\t\treturn make_pair(flow, cost);\n\t}\n};\n\nconst int MAX_N = 100 + 10;\nint n, m;\nstring how[MAX_N];\nint A[MAX_N], B[MAX_N];\nint ia[MAX_N], ib[MAX_N];\n\nint notKillAll() {\n\tMinCostFlow net;\n\tint vs = net.addV(), vt = net.addV();\n\tfor (int i = 0; i < n; ++i) {\n\t\tia[i] = net.addV();\n\t\tnet.addEdge(vs, ia[i], 1, 0);\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tib[i] = net.addV();\n\t\tnet.addEdge(ib[i], vt, 1, 0);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t//j attack i\n\t\t\tif (B[j] > A[i] && how[i] == \"ATK\") {\n\t\t\t\tnet.addEdge(ia[i], ib[j], 1, -(B[j] - A[i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -net.minCostFlow(vs, vt, false).second;\n}\n\nint killAll() {\n\tMinCostFlow net;\n\tint vs = net.addV(), vt = net.addV();\n\t//m>n!\n\tfor (int i = 0; i < m; ++i) {\n\t\tia[i] = net.addV();\n\t\tnet.addEdge(vs, ia[i], 1, 0);\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tib[i] = net.addV();\n\t\tnet.addEdge(ib[i], vt, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t//j attack i\n\t\t\tif (i < n) {\n\t\t\t\tif (how[i] == \"ATK\") {\n\t\t\t\t\tif (B[j] >= A[i])\n\t\t\t\t\t\tnet.addEdge(ia[i], ib[j], 1, -(B[j] - A[i]));\n\t\t\t\t} else {\n\t\t\t\t\tif (B[j] > A[i])\n\t\t\t\t\t\tnet.addEdge(ia[i], ib[j], 1, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//directly attack\n\t\t\t\tnet.addEdge(ia[i], ib[j], 1, -B[j]);\n\t\t\t}\n\t\t}\n\t}\n\tpair<int, int> ret = net.minCostFlow(vs, vt, true);\n\tif (ret.first == m)\n\t\treturn -ret.second;\n\treturn 0;\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> how[i] >> A[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> B[i];\n\t}\n\tint ans = notKillAll();\n\tif (m > n)\n\t\tans = max(ans, killAll());\n\tcout << ans << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "flows",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Ciel and Duel.json",
    "editorial_link": "https://codeforces.com//blog/entry/8192",
    "editorial": "We have 3 solutions to this problem: = 1. greedy = There are 2 cases: we\r\nkilled all Jiro\u00e2\u0080\u0099s cards, or not. If we are not killed all of Jiro\u00e2\u0080\u0099s\r\ncards, then: If we kill all Jiro\u00e2\u0080\u0099s card: Then for all DEF cards, we\r\nconsider it from lower strength to higher: if its strength is L, then we\r\nfind a card of Ciel with strength more than L (If there are many, we\r\nchoose one with lowest strength). Then we can know if we can kill all\r\nDEF cards. And then we choose |x| cards with highest strength of Ciel,\r\ntry to kill Jiro\u00e2\u0080\u0099s remain card. Note that if we could kill all ATK\r\ncards, the order doesn\u00e2\u0080\u0099t matter: the total damage will be (sum of\r\nstrength of Ciel\u00e2\u0080\u0099s remain card) (sum of strength of Jiro\u00e2\u0080\u0099s remain card).\r\n= 2. DP = Above solution looks complicated, can we solve it with few\r\nobservation? Yes we can. The only observation is that: There always\r\nexist an optimal solution that: If Ciel\u00e2\u0080\u0099s two card X\u00e2\u0080\u0099s strength > Y\u00e2\u0080\u0099s\r\nstrength, and X, Y attacks on A and B with the same position, then A\u00e2\u0080\u0099s\r\nstrength > B\u00e2\u0080\u0099s strength. We already use this observation in above\r\nsolution. Then what can we do? Yes, we can sort all Ciel\u00e2\u0080\u0099s card, all ATK\r\ncard of Jiro, all DEF card of Jiro. Let\u00e2\u0080\u0099s\r\nDP[pCiel][pATK][pJiro][killAll] be the state that next unconsidered card\r\nof Ciel, Jiro\u00e2\u0080\u0099s ATk, Jiro\u00e2\u0080\u0099s DEF are pCiel, pATK, pJiro, and killAll=1 if\r\nand only if we assume at the end we can kill all Jiro\u00e2\u0080\u0099s card. Then we\r\nhave 4 choice: = 3. MinCostMaxFlow = Well, what if we want to solve this\r\nproblem with no observation? Ok, if you are good at construct flow\r\nalgorithm, it\u00e2\u0080\u0099s an easy thing to solve this by flow. Please see my\r\nsolution for details. It just considered the matching relationship.\r\n"
}