{
    "link": "https://codeforces.com//contest/377/problem/D",
    "problemId": "4964",
    "problem_idx": "D",
    "shortId": "377D",
    "contest_number": "377",
    "problem_submissions": {
        "E": [
            5565104,
            5561250,
            5564607,
            5609766,
            5609753,
            16200081
        ],
        "C": [
            5557198,
            5559102,
            5556756,
            5557878,
            5557073,
            5556778,
            5561172,
            5559969,
            5556623,
            5561484,
            5557118,
            5556739,
            5555480,
            5555881,
            5556358,
            5558864,
            5562930,
            5557451
        ],
        "B": [
            5555860,
            5557367,
            5555019,
            5553998,
            5554910,
            5555169,
            5554737,
            5555727,
            5555389,
            5556153,
            5555427,
            5554761,
            5558108,
            5554728,
            5554498,
            5556897,
            5555212,
            5555735
        ],
        "D": [
            5554743,
            5555639,
            5559458,
            5563602,
            5559736,
            5559573,
            5557812,
            5558888,
            5560657,
            5558023,
            5561888,
            5561586,
            5561721,
            5561010,
            5567302,
            5562027,
            5561348,
            5557665,
            5560854
        ],
        "A": [
            5552294,
            5552852,
            5553023,
            5554895,
            5553159,
            5553613,
            5552588,
            5552740,
            5553136,
            5552790,
            5552857,
            5552997,
            5553105,
            5552479,
            5552633,
            5554023,
            5552441
        ]
    },
    "name": "D. Developing Game",
    "statement": "Pavel is going to make a game of his dream. However, he knows that he\r\ncan’t make it on his own so he founded a development company and hired\r\nworkers of staff. Now he wants to pick workers from the staff who will\r\nbe directly responsible for developing a game.Each worker has a certain\r\nskill level . Besides, each worker doesn’t want to work with the one\r\nwhose skill is very different. In other words, the -th worker won’t work\r\nwith those whose skill is less than , and with those whose skill is more\r\nthan .Pavel understands that the game of his dream isn’t too hard to\r\ndevelop, so the worker with any skill will be equally useful. That’s why\r\nhe wants to pick a team of the maximum possible size. Help him pick such\r\nteam.\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nconst int co = 300000;\nconst int TREE = 10 * co + 10;\n\nint max[TREE], add[TREE], index[TREE];\n\nvoid build(int x, int l, int r) {\n  max[x] = add[x] = 0;\n  index[x] = l;\n  if (l < r) {\n    int y = (l + r) >> 1;\n    build(x + x, l, y);\n    build(x + x + 1, y + 1, r);\n  }\n}\n\nvoid modify(int x, int l, int r, int ll, int rr, int v) {\n  if (r < ll || rr < l) return;\n  if (l >= ll && r <= rr) {\n    add[x] += v;\n    return;\n  }\n  int y = (l + r) >> 1;\n  modify(x + x, l, y, ll, rr, v);\n  modify(x + x + 1, y + 1, r, ll, rr, v);\n  int wl = max[x + x] + add[x + x];\n  int wr = max[x + x + 1] + add[x + x + 1];\n  if (wl > wr) {\n    max[x] = wl;\n    index[x] = index[x + x];\n  } else {\n    max[x] = wr;\n    index[x] = index[x + x + 1];\n  }\n}\n\nconst int N = 100010;\n\nint low[N], v[N], high[N];\nint r[N];\n\nstd::vector <int> left[co + 10], skill[co + 10];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d %d %d\", low + i, v + i, high + i);\n  for (int i = 1; i <= co; i++) {\n    left[i].clear();\n    skill[i].clear();\n  }\n  for (int i = 1; i <= n; i++) {\n    left[low[i]].push_back(i);\n    skill[v[i]].push_back(i);\n  }\n  build(1, 1, co);\n  int ans = 0, a_from = 0, a_to = 0;\n  for (int from = 1; from <= co; from++) {\n    {\n      int sz = left[from].size();\n      for (int j = 0; j < sz; j++) {\n        int id = left[from][j];\n        modify(1, 1, co, v[id], high[id], 1);\n      }\n    }\n    int cur = max[1] + add[1];\n    if (cur > ans) {\n      ans = cur;\n      a_from = from;\n      a_to = index[1];\n    }\n    {\n      int sz = skill[from].size();\n      for (int j = 0; j < sz; j++) {\n        int id = skill[from][j];\n        modify(1, 1, co, v[id], high[id], -1);\n      }\n    }\n  }\n  int kr = 0;\n  for (int i = 1; i <= n; i++)\n    if (low[i] <= a_from && a_from <= v[i] && v[i] <= a_to && a_to <= high[i]) {\n      r[++kr] = i;\n    }\n  printf(\"%d\\n\", kr);\n  for (int i = 1; i < kr; i++) printf(\"%d \", r[i]);\n  printf(\"%d\\n\", r[kr]);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Developing Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/10157",
    "editorial": "Letâs note that every answer is characterized with two numbers and so\r\nthat , , and . If we know and , we can check every person and choose\r\nthose who satisfies the conditions above. Letâs imagine a plane with the\r\ncoordinate axes: one of the axes will be , and the other will be . If\r\nthe point on this plane is the optimal answer, people included in this\r\nanswer for sure satisfy the conditions and . These conditions specify\r\nthe rectangle on the plane. Since we should find the maximum number of\r\npeople, we should find such point that it is inside the maximum number\r\nof the specified rectangles. Now itâs the standard problem that can be\r\nsolved using the scanline through one axis and the segment tree built on\r\nthe other axis. The hardest part is to reduce the original problem to\r\nit.\r\n",
    "hint": []
}