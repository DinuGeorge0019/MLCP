{
    "link": "https://codeforces.com//contest/1361/problem/D",
    "problemId": "640971",
    "problem_idx": "D",
    "shortId": "1361D",
    "contest_number": "1361",
    "problem_submissions": {
        "F": [
            82547256,
            82558388,
            82548841,
            82560787,
            82546613,
            82571701,
            82569539,
            82568479,
            82553474,
            82561525
        ],
        "D": [
            82532533,
            82534707,
            82556057,
            82527759,
            82536652,
            82533679,
            82553972,
            82540929,
            82539127,
            82540566,
            86424872,
            82526480,
            82568104,
            82567738,
            82567880
        ],
        "E": [
            82521789,
            82543705,
            82541718,
            82540946,
            82583418,
            82541333,
            82541041,
            82533619,
            82550465,
            82553317,
            82579674,
            82579569,
            82559988,
            82559485,
            82543445,
            82543446,
            82551504,
            82544569,
            82550130,
            82547325,
            82579220,
            82517696
        ],
        "C": [
            82504494,
            82509183,
            82560689,
            82519634,
            82513804,
            82519054,
            82526119,
            82516120,
            82517904,
            82521411,
            82523427,
            82525691,
            82518977,
            82516229,
            82512604,
            82516960,
            82527524,
            82521519,
            82527700,
            82553581
        ],
        "B": [
            82495175,
            82498230,
            82507103,
            82567148,
            82501464,
            82497400,
            82516527,
            82498261,
            82504352,
            82509962,
            82510314,
            82502680,
            82509498,
            82502669,
            82499583,
            82499214,
            82513823,
            82505015,
            82504805,
            82531052
        ],
        "A": [
            82492363,
            82493600,
            82494974,
            82494327,
            82492565,
            82492329,
            82494389,
            82493605,
            82492642,
            82494930,
            82499298,
            82494769,
            82492795,
            82495342,
            82493416,
            82492640,
            82495622,
            82493415,
            82512573,
            82523180
        ]
    },
    "name": "D. Johnny and James",
    "statement": "James Bond, Johnny\u2019s favorite secret agent, has a new mission. There are\r\nn enemy bases, each of them is described by its coordinates so that we\r\ncan think about them as points in the Cartesian plane. The bases can\r\ncommunicate with each other, sending a signal, which is the ray directed\r\nfrom the chosen point to the origin or in the opposite direction. The\r\nexception is the central base, which lies at the origin and can send a\r\nsignal in any direction. When some two bases want to communicate, there\r\nare two possible scenarios. If they lie on the same line with the\r\norigin, one of them can send a signal directly to the other one.\r\nOtherwise, the signal is sent from the first base to the central, and\r\nthen the central sends it to the second base. We denote the distance\r\nbetween two bases as the total Euclidean distance that a signal sent\r\nbetween them has to travel.Bond can damage all but some k bases, which\r\nhe can choose arbitrarily. A damaged base can\u2019t send or receive the\r\ndirect signal but still can pass it between two working bases. In\r\nparticular, James can damage the central base, and the signal between\r\nany two undamaged bases as before, so the distance between them remains\r\nthe same. What is the maximal sum of the distances between all pairs of\r\nremaining bases that 007 can achieve by damaging exactly n - k of them?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 04.06.2020 18:33:28       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> x(n);\n  vector<int> y(n);\n  vector<double> d(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    d[i] = sqrt((double) ((long long) x[i] * x[i] + (long long) y[i] * y[i]));\n    if (x[i] != 0 || y[i] != 0) {\n      int g = __gcd(abs(x[i]), abs(y[i]));\n      x[i] /= g;\n      y[i] /= g;\n    }\n  }\n  vector<int> order(n);\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&](int i, int j) {\n    if (x[i] != x[j]) {\n      return x[i] < x[j];\n    }\n    if (y[i] != y[j]) {\n      return y[i] < y[j];\n    }\n    return d[i] < d[j];\n  });\n  vector<double> r;\n  int beg = 0;\n  while (beg < n) {\n    int end = beg;\n    int dx = x[order[beg]];\n    int dy = y[order[beg]];\n    while (end + 1 < n && x[order[end + 1]] == dx && y[order[end + 1]] == dy) {\n      end += 1;\n    }\n    int L = beg, R = end;\n    for (int i = 0; i < k / 2 && L <= R; i++) {\n      int coeff = k - 1 - 2 * i;\n      r.push_back(d[order[R]] * coeff);\n      R -= 1;\n    }\n    if (k % 2 == 0) {\n      double sum = 0;\n      while (L <= R) {\n        r.push_back(-(sum + d[order[L]]));\n        sum += 2 * d[order[L]];\n        L += 1;\n      }\n    } else {\n      double sum = 0;\n      while (L <= R) {\n        r.push_back(-sum);\n        sum += 2 * d[order[L]];\n        L += 1;\n      }\n    }\n    beg = end + 1;\n  }\n  sort(r.rbegin(), r.rend());\n  double ans = 0;\n  for (int i = 0; i < k; i++) {\n    ans += r[i];\n  }\n  cout << fixed << setprecision(17) << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Johnny and James.json",
    "editorial_link": "https://codeforces.com//blog/entry/78355",
    "editorial": "We can easily model the way of calculating distances from the problem\r\nstatement as a tree with vertices, each corresponding to a base. This\r\ntree has the following structure: there is only one vertex which can\r\nhave degree bigger than (the one corresponding to the central base), I\r\nwill call it the center of the tree. There are also some paths\r\nconsisting of vertices corresponding to bases lying on the same\r\nhalf-line starting at point . We will call those arms of the tree.\r\nAssume that the center does not belong to any arm.The task is to choose\r\nvertices in a way that maximizes the sum of distances between them. Let\r\nus start with a lemma:If vertices are chosen from an arm, at least of\r\nthem are the ones furthest from the center.Say that less than is chosen\r\nfrom the end of the arm (counting from the center). Then there exists\r\nsuch chosen vertex on the arm, that the next (counting from the center)\r\nvertex is not chosen. Let the length of the edge between them be and let\r\nthere be vertices further from the center than . If we had chosen\r\ninstead of , the sum of distances would change by (the chosen vertex\r\nwould move closer by to vertices, but also it\u00e2\u0080\u0099s distance to vertices\r\nwould increase by ). But since , this value is non-negative (the sum of\r\ndistances would not decrease).There are two cases which will be solved\r\nindependently:First case: there is no arm containing more than vertices\r\nchosen. By the lemma, in every arm, only vertices furthest from the\r\ncenter will be selected in an optimal solution. If a vertex is chosen,\r\nall the ones in the same arm further from the center are chosen as well.\r\nUsing this knowledge, we can assign weights to vertices in such a way\r\nthat the result for a set will be the sum of weights. Weight for vertex\r\nequals: where is the number of vertices further from center in the same\r\narm as . The weight of the center equals . Note that (with exception to\r\nthe center) iff taking would violate the condition that at most are\r\nchosen from every arm.The algorithm for this case is to add the vertices\r\ngreedily to the set until vertices have been chosen. The complexity of\r\nthe above algorithm is .Second case: there is an arm, in which more than\r\nvertices are chosen in the optimal solution.From the lemma, we know that\r\nvertices lying furthest from the center will be chosen. It can be proved\r\n(in a similar manner as the lemma) that in an optimal solution, all\r\nother selected vertices from this arm will be as close to the center as\r\npossible. Furthermore, the center and all the vertices in the other arms\r\nwill be selected. Intuitively, when there are chosen vertices on a\r\nsingle-arm, we will not decrease the sum of distances by moving another\r\nselected vertex further from them along an edge.There is at most one set\r\nof vertices satisfying those conditions so that this part can be\r\nimplemented in .The time complexity of this solution is .\r\n"
}