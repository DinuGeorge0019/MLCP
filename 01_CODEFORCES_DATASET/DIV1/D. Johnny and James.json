{"link": "https://codeforces.com//contest/1361/problem/D", "problemId": "640971", "problem_idx": "D", "shortId": "1361D", "contest_number": "1361", "problem_submissions": {"F": [82547256, 82558388, 82548841, 82560787, 82546613, 82571701, 82569539, 82568479, 82553474, 82561525], "D": [82532533, 82534707, 82556057, 82527759, 82536652, 82533679, 82553972, 82540929, 82539127, 82540566, 86424872, 82526480, 82568104, 82567738, 82567880], "E": [82521789, 82543705, 82541718, 82540946, 82583418, 82541333, 82541041, 82533619, 82550465, 82553317, 82579674, 82579569, 82559988, 82559485, 82543445, 82543446, 82551504, 82544569, 82550130, 82547325, 82579220, 82517696], "C": [82504494, 82509183, 82560689, 82519634, 82513804, 82519054, 82526119, 82516120, 82517904, 82521411, 82523427, 82525691, 82518977, 82516229, 82512604, 82516960, 82527524, 82521519, 82527700, 82553581], "B": [82495175, 82498230, 82507103, 82567148, 82501464, 82497400, 82516527, 82498261, 82504352, 82509962, 82510314, 82502680, 82509498, 82502669, 82499583, 82499214, 82513823, 82505015, 82504805, 82531052], "A": [82492363, 82493600, 82494974, 82494327, 82492565, 82492329, 82494389, 82493605, 82492642, 82494930, 82499298, 82494769, 82492795, 82495342, 82493416, 82492640, 82495622, 82493415, 82512573, 82523180]}, "name": "D. Johnny and James", "statement": "James Bond, Johnny\u2019s favorite secret agent, has a new mission. There are\r\nn enemy bases, each of them is described by its coordinates so that we\r\ncan think about them as points in the Cartesian plane. The bases can\r\ncommunicate with each other, sending a signal, which is the ray directed\r\nfrom the chosen point to the origin or in the opposite direction. The\r\nexception is the central base, which lies at the origin and can send a\r\nsignal in any direction. When some two bases want to communicate, there\r\nare two possible scenarios. If they lie on the same line with the\r\norigin, one of them can send a signal directly to the other one.\r\nOtherwise, the signal is sent from the first base to the central, and\r\nthen the central sends it to the second base. We denote the distance\r\nbetween two bases as the total Euclidean distance that a signal sent\r\nbetween them has to travel.Bond can damage all but some k bases, which\r\nhe can choose arbitrarily. A damaged base can\u2019t send or receive the\r\ndirect signal but still can pass it between two working bases. In\r\nparticular, James can damage the central base, and the signal between\r\nany two undamaged bases as before, so the distance between them remains\r\nthe same. What is the maximal sum of the distances between all pairs of\r\nremaining bases that 007 can achieve by damaging exactly n - k of them?\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 04.06.2020 18:33:28       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> x(n);\n  vector<int> y(n);\n  vector<double> d(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    d[i] = sqrt((double) ((long long) x[i] * x[i] + (long long) y[i] * y[i]));\n    if (x[i] != 0 || y[i] != 0) {\n      int g = __gcd(abs(x[i]), abs(y[i]));\n      x[i] /= g;\n      y[i] /= g;\n    }\n  }\n  vector<int> order(n);\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&](int i, int j) {\n    if (x[i] != x[j]) {\n      return x[i] < x[j];\n    }\n    if (y[i] != y[j]) {\n      return y[i] < y[j];\n    }\n    return d[i] < d[j];\n  });\n  vector<double> r;\n  int beg = 0;\n  while (beg < n) {\n    int end = beg;\n    int dx = x[order[beg]];\n    int dy = y[order[beg]];\n    while (end + 1 < n && x[order[end + 1]] == dx && y[order[end + 1]] == dy) {\n      end += 1;\n    }\n    int L = beg, R = end;\n    for (int i = 0; i < k / 2 && L <= R; i++) {\n      int coeff = k - 1 - 2 * i;\n      r.push_back(d[order[R]] * coeff);\n      R -= 1;\n    }\n    if (k % 2 == 0) {\n      double sum = 0;\n      while (L <= R) {\n        r.push_back(-(sum + d[order[L]]));\n        sum += 2 * d[order[L]];\n        L += 1;\n      }\n    } else {\n      double sum = 0;\n      while (L <= R) {\n        r.push_back(-sum);\n        sum += 2 * d[order[L]];\n        L += 1;\n      }\n    }\n    beg = end + 1;\n  }\n  sort(r.rbegin(), r.rend());\n  double ans = 0;\n  for (int i = 0; i < k; i++) {\n    ans += r[i];\n  }\n  cout << fixed << setprecision(17) << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["greedy", "implementation", "math", "trees"], "dificulty": "2900", "interactive": false}