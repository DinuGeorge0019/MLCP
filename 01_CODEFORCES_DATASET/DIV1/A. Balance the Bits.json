{"link": "https://codeforces.com//contest/1503/problem/A", "problemId": "945469", "problem_idx": "A", "shortId": "1503A", "contest_number": "1503", "problem_submissions": {"F": [111939776, 111936345, 111953640, 111949537, 111942068, 111944734, 111944711, 111948141, 111947867, 113984444], "E": [111918055, 111912666, 111918864, 111923939, 111922990, 111923269, 111922053, 111920801, 111927922, 111926604, 111931364, 111936374, 111926173, 111935792, 111929517, 111930613, 111937713, 111935328, 111934244], "D": [111903738, 111902585, 111898744, 111893896, 111901869, 111902624, 111880076, 111902059, 111906951, 111905795, 111910439, 111899185, 111916472, 111904574, 111913444, 111910826, 111914877, 111924091, 111906860], "C": [111886477, 111890876, 111881938, 111886094, 111882409, 111883959, 111902446, 111905834, 111885208, 111897171, 111889963, 111890061, 111888926, 111886850, 111898651, 111896248, 111894668, 111884135, 111889304], "B": [111876447, 111888244, 111877449, 111876120, 111878468, 111878981, 111893644, 111877927, 111878327, 111877579, 111878407, 111882807, 111900739, 111880662, 111889601, 111886898, 111883228, 111878516, 111916268], "A": [111871860, 111872029, 111873354, 111871912, 111872701, 111874636, 111888931, 111872574, 111873406, 111872331, 111873739, 111875192, 111873092, 111873513, 111878839, 111875591, 111873509, 111872858, 111893066]}, "name": "A. Balance the Bits", "statement": "A sequence of brackets is called balanced if one can turn it into a\r\nvalid math expression by adding characters \u201d and \u201d. For example,\r\nsequences \u201d, \u201d, and \u201d are balanced, while \u201d, \u201d, and \u201d are not.You are\r\ngiven a binary string s of length n. Construct two balanced bracket\r\nsequences a and b of length n such that for all 1\r\nle i\r\nle n: if s_i=1, then a_i=b_i if s_i=0, then a_i\r\nne b_i If it is impossible, you should report about it.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint r = 0;\n\tfor(char c : s) if(c == '1') r++;\n\tif(s.front() != '1' || s.back() != '1' || (r & 1)){\n\t\tcout << \"NO\" << '\\n';\n\t\treturn;\n\t}\n\tstring x, y;\n\t\n\tint d = 0;\n\tint f = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(s[i] == '1'){\n\t\t\tif(d < r/2){\n\t\t\t\tx += '(';\n\t\t\t\ty += '(';\n\t\t\t} else {\n\t\t\t\tx += ')';\n\t\t\t\ty += ')';\n\t\t\t}\n\t\t\td++;\n\t\t} else {\n\t\t\tx += \"()\"[f];\n\t\t\ty += \")(\"[f];\n\t\t\tf ^= 1;\n\t\t}\n\t}\n\tcout << \"YES\" << '\\n';\n\tcout << x << '\\n';\n\tcout << y << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "1600", "interactive": false}