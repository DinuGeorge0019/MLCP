{
    "link": "https://codeforces.com//contest/1261/problem/A",
    "problemId": "479745",
    "problem_idx": "A",
    "shortId": "1261A",
    "contest_number": "1261",
    "problem_submissions": {
        "F": [
            65647116,
            65658053,
            65657980,
            65657931,
            65651526,
            65649568,
            65649392,
            65651843,
            65651789,
            65643329,
            65715623,
            65660068,
            66569502,
            66569457,
            66569446,
            66563643,
            66529592,
            66529450,
            66529001,
            66528877,
            66527265,
            66527166,
            202179447,
            65759590,
            65736891,
            65656177,
            65801900,
            65656900,
            65653812
        ],
        "E": [
            65640839,
            65636308,
            65639924,
            65632814,
            65644428,
            65645126,
            65649634,
            65644543,
            65648074,
            65645492,
            65646710,
            65643401,
            65649412,
            65647298,
            65649626,
            65646791,
            65647214,
            65650131,
            65673025
        ],
        "D2": [
            65637210,
            65632855,
            65635634,
            65636824,
            65639345,
            65639544,
            65635456,
            65639090,
            65637689,
            65685918,
            65636623,
            65641288,
            65630575,
            65640353,
            65641640,
            65638704,
            65642981,
            65642369,
            65636523,
            65640625
        ],
        "D1": [
            65637138,
            65632929,
            65635559,
            65636922,
            65639374,
            65639684,
            65633638,
            65639276,
            65637859,
            65636779,
            65641185,
            65630619,
            65640390,
            65641739,
            65638754,
            65643069,
            65642429,
            65636584,
            65639802
        ],
        "C": [
            65632448,
            65642046,
            65632919,
            65640324,
            65637319,
            65636062,
            65629189,
            65635829,
            65634638,
            65686469,
            65686406,
            65686240,
            65686235,
            65686196,
            65686121,
            65686065,
            65686054,
            65686032,
            65685983,
            65685973,
            65685956,
            65633182,
            65639316,
            65636734,
            65647142,
            65634479,
            65636999,
            65635515,
            65637442,
            65637462,
            65658341,
            65640232,
            65635038
        ],
        "B1": [
            65629099,
            65627296,
            65628841,
            65642477,
            65630053,
            65629451,
            65645427,
            65631701,
            65629375,
            65639182,
            65631034,
            65637262,
            65630223,
            65630435,
            65630786,
            65631879,
            65632451,
            65627736,
            65630111
        ],
        "B2": [
            65629029,
            65627239,
            65628722,
            65642378,
            65629995,
            65629248,
            65645596,
            65631497,
            65629280,
            65720078,
            65685862,
            65639011,
            65631167,
            65637207,
            65630166,
            65630277,
            65630671,
            65631817,
            65632276,
            65627619,
            65630224
        ],
        "A": [
            65626424,
            65626236,
            65626313,
            65643924,
            65627202,
            65627360,
            65650514,
            65628121,
            65627165,
            65626869,
            65627525,
            65634172,
            65626632,
            65626977,
            65627953,
            65628262,
            65627833,
            65631529,
            65627297
        ]
    },
    "name": "A. Messy",
    "statement": "You are fed up with your messy room, so you decided to clean it up.Your\r\nroom is a bracket sequence s=s_{1}s_{2}\r\ndots s_{n} of length n. Each character of this string is either an\r\nopening bracket ” or a closing bracket ”.In one operation you can choose\r\nany consecutive substring of s and reverse it. In other words, you can\r\nchoose any substring s[l\r\ndots r]=s_l, s_{l+1},\r\ndots, s_r and change the order of elements in it into s_r, s_{r-1},\r\ndots, s_{l}.For example, if you will decide to reverse substring s[2\r\ndots 4] of string s=\"\" it will be equal to s=\"\".A (aka balanced) bracket\r\nsequence is a bracket sequence that can be transformed into a correct\r\narithmetic expression by inserting characters ” and ” between the\r\noriginal characters of the sequence. For example, bracket sequences \"\",\r\n\"\" are regular (the resulting expressions are: \"\", \"\"), and \"\" and \"\"\r\nare not.A prefix of a string s is a substring that starts at position 1.\r\nFor example, for s=\"\" there are 6 prefixes: \"\", \"\", \"\", \"\", \"\" and \"\".In\r\nyour opinion, a neat and clean room s is a bracket sequence that: the\r\nwhole string s is a bracket sequence; there are exactly k prefixes of\r\nthis sequence which are regular (including whole s itself). For example,\r\nif k = 2, then \"\" is a neat and clean room.You want to use at most n\r\noperations to make your room neat and clean. Operations are applied one\r\nafter another sequentially.It is guaranteed that the answer exists. Note\r\nthat you to minimize the number of operations: find any way to achieve\r\nthe desired configuration in n or less operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    string s, t;\n    cin >> n >> m >> s;\n    for (int i = 0; i < n / 2 - (m - 1); ++i) {\n      t.push_back('(');\n    }\n    for (int i = 0; i < n / 2 - (m - 1); ++i) {\n      t.push_back(')');\n    }\n    for (int i = 0; i < m - 1; ++i) {\n      t.push_back('(');\n      t.push_back(')');\n    }\n    vector<pair<int, int>> ans;\n    for (int i = 0; i < n; ++i) {\n      if (s[i] != t[i]) {\n        int j = i;\n        while (j < n && s[j] != t[i]) {\n          j++;\n        }\n        reverse(s.begin() + i, s.begin() + j + 1);\n        ans.emplace_back(i + 1, j + 1);\n      }\n    }\n    cout << ans.size() << \"\\n\";\n    for (auto p : ans) {\n      cout << p.first << \" \" << p.second << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Messy.json",
    "editorial_link": "https://codeforces.com/blog/entry/71740",
    "editorial": "Itâs easy to construct a valid bracket sequence, for example \"\".Now let\r\nthe initial bracket sequence be , the target one be . For each position,\r\nif then we neednât do anything, otherwise find a position which and (it\r\nexists), and reverse the segment .The number of operations is at most ,\r\nand the solution works in .\r\n",
    "hint": []
}