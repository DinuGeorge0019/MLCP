{"link": "https://codeforces.com//contest/806/problem/E", "problemId": "105599", "problem_idx": "E", "shortId": "806E", "contest_number": "806", "problem_submissions": {"E": [26946399, 26946353, 26942942, 26940751, 26976136, 26943065, 26942598, 26942187, 26937843, 26947143, 27001343, 26946488, 26943631, 26951183, 26939699, 26944777], "D": [26938120, 26934427, 26936263, 26937600, 26934513, 26936339, 26937621, 26938327, 26939404, 26938853, 26942391, 26940455, 26938860, 26938974, 26941503, 26941670], "B": [26933193, 26932004, 26938489, 26932467, 26931704, 26932365, 26935492, 26932113, 26930780, 26942817, 26930285, 26932725, 26943302, 26937682, 26931932, 26932598], "C": [26931766, 26942392, 26933099, 26934784, 26933629, 26933365, 26933930, 26931141, 26934600, 26930447, 26934117, 26934951, 26929917, 26933809, 26935513, 26934671], "A": [26928049, 26926811, 26929039, 26927072, 26927004, 26926681, 26927002, 26927962, 26928737, 26927722, 26927311, 26932013, 26927300, 26928724, 26926850, 26927034, 26927665, 26929077]}, "name": "E. Blog Post Rating", "statement": "It\u2019s well-known that blog posts are an important part of Codeforces\r\nplatform. Every blog post has a global characteristic changing over time\r\nits . A newly created blog post\u2019s community rating is 0. Codeforces\r\nusers may visit the blog post page and rate it, changing its community\r\nrating by +1 or -1.Consider the following model of Codeforces users\u2019\r\nbehavior. The -th user has his own denoted by an integer . When a user\r\nvisits a blog post page, he compares his estimated blog post rating to\r\nits community rating. If his estimated rating is higher, he rates the\r\nblog post with +1 (thus, the blog post\u2019s community rating increases by\r\n1). If his estimated rating is lower, he rates the blog post with -1\r\n(decreasing its community rating by 1). If the estimated rating and the\r\ncommunity rating are equal, user doesn\u2019t rate the blog post at all (in\r\nthis case we\u2019ll say that user rates the blog post for 0). In any case,\r\nafter this procedure user closes the blog post page and never opens it\r\nagain.Consider a newly created blog post with the initial community\r\nrating of 0. For each of Codeforces users, numbered from 1 to , his\r\nestimated blog post rating is known.For each from 1 to , inclusive, the\r\nfollowing question is asked. Let users with indices from 1 to , , visit\r\nthe blog post page, rate the blog post and close the page. Each user\r\nopens the blog post only after the previous user closes it. What could\r\nbe the maximum possible community rating of the blog post after these\r\nvisits?\r\n", "solutions": ["#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\n#define tm f__k\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\nstruct FastSet {\n    int N, lg;\n    VV<ull> seg;\n    FastSet(int N) : N(N) {\n        while (N > 1) {\n            seg.push_back(V<ull>((N+63)/64));\n            N = (N+63)/64;\n        }\n        lg = seg.size();\n    }\n    bool test(int x) const {\n        int D = x/64, R = x%64;\n        return (seg[0][D] & (1ULL<<R)) != 0;\n    }\n    void set(int x) {\n        for (int i = 0; i < lg; i++) {\n            int D = x/64, R = x%64;\n            seg[i][D] |= (1ULL<<R);\n            x /= 64;\n        }\n    }\n    void clear(int x) {\n        for (int i = 0; i < lg; i++) {\n            int D = x/64, R = x%64;\n            seg[i][D] &= ~(1ULL<<R);\n            if (i && seg[i-1][x] != 0) {\n                seg[i][D] |= (1ULL<<R);\n            }\n            x /= 64;\n        }\n    }\n    // x\u4ee5\u4e0a\u6700\u5c0f\u306e\u8981\u7d20\n    int next(int x) {\n        for (int i = 0; i < lg; i++) {\n            int D = x/64, R = x%64;\n            if (D == seg[i].size()) break;\n            ull B = seg[i][D]>>R;\n            if (!B) {\n                x = x/64+1;\n                continue;\n            }\n            //find\n            x += bsf(B);\n            for (int j = i-1; j >= 0; j--) {\n                x *= 64;\n                int D = x/64;\n                x += bsf(seg[j][D]);\n            }\n            return x;\n        }\n        return N;\n    }\n    // x\u4ee5\u4e0b\u6700\u5927\u306e\u8981\u7d20\n    int back(int x) {\n        for (int i = 0; i < lg; i++) {\n            if (x == -1) break;\n            int D = x/64, R = x%64;\n            ull B = seg[i][D]<<(63-R);\n            if (!B) {\n                x = x/64-1;\n                continue;\n            }\n            //find\n            x += bsr(B)-63;\n            for (int j = i-1; j >= 0; j--) {\n                x *= 64;\n                int D = x/64;\n                x += bsr(seg[j][D]);\n            }\n            return x;\n        }\n        return -1;\n    }    \n};\n\ntemplate<class T>\nstruct Fenwick {\n    int N, lg;\n    V<T> seg;\n    Fenwick(int N) : N(N) {\n        seg.resize(N+1);\n        lg = bsr(uint(N));\n        fill(begin(seg), end(seg), T(0));\n    }\n    /// i\u756a\u76ee\u306e\u8981\u7d20\u306bx\u3092\u8ffd\u52a0\u3059\u308b\n    void add(int i, T x) {\n        i++;\n        while (i <= N) {\n            seg[i] += x;\n            i += i & -i;\n        }\n    }\n    /// [0, i)\u306esum\n    T sum(int i) {\n        T s{0};\n        while (i > 0) {\n            s += seg[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n    /// [a, b)\u306esum\n    T sum(int a, int b) {\n        return sum(b) - sum(a);\n    }\n    /// sum[0, idx) >= x\u306a\u308b\u6700\u5c0f\u306eidx\n    int sum_lower_bound(T x) {\n        if (x <= 0) return 0;\n        int res = 0;\n        for (int len = 1<<lg; len >= 1; len /= 2) {\n            if (res + len <= N && seg[res + len] < x) {\n                x -= seg[res+len];\n                res += len;\n            }\n        }\n        return res + 1;\n    }\n};\ntemplate<class N>\nstruct SegTree {\n    int lg, sz;\n    vector<N> n;\n    SegTree() {}\n    SegTree(int sz) {\n        assert(sz >= 1);\n        lg = bsr(uint(2*sz-1));\n        sz = 1<<lg;\n        this->sz = sz;\n        n = vector<N>(2*sz);\n        for (int i = 2*sz-1; i >= sz; i--) {\n            n[i] = N();\n        }\n        for (int i = sz-1; i >= 1; i--) {\n            n[i] = N(n[2*i], n[2*i+1]);\n        }\n    }\n    void all_update() {\n        for (int i = 1; i <= sz-1; i++) {\n            n[i].push();\n        }\n        for (int i = sz-1; i >= 1; i--) {\n            n[i].update(n[2*i], n[2*i+1]);\n        }\n    }\n    template<class Q>\n    Q single(int idx, Q q) {\n        if (idx < 0 || sz <= idx) return q;\n        idx += sz;\n        for (int i = lg; i >= 1; i--) {\n            int k = idx>>i;\n            n[k].push(n[2*k], n[2*k+1]);\n        }\n        q += n[idx];\n        if (q.update()) {\n            for (int i = 1; i <= lg; i++) {\n                int k = idx>>i;\n                n[k].update(n[2*k], n[2*k+1]);\n            }\n        }\n        return q;\n    }\n    template<class Q>\n    void query(int a, int b, Q &q, int k, int sz) {\n        if (a <= 0 && sz <= b) {\n            q += n[k];\n            return;\n        }\n        n[k].push(n[2*k], n[2*k+1]);\n        if (a < sz/2) query(a, b, q, 2*k, sz/2);\n        if (sz/2 < b) query(a-sz/2, b-sz/2, q, 2*k+1, sz/2);\n        if (q.update()) n[k].update(n[2*k], n[2*k+1]);\n    }\n    template<class Q>\n    Q query(int a, int b, Q q) {\n        if (a < sz && 0 < b) query(a, b, q, 1, sz);\n        return q;\n    }\n    struct NodeQuery {\n        N n;\n        static constexpr bool update() { return false; }\n        void operator+=(N &r) { N nn; nn.update(n, r); n = nn; }\n    };\n};\n\nusing P = pair<int, int>;\nstruct Node {\n    P mi;\n    int lz;\n    void init() {\n        mi = P(TEN(9), -1);\n        lz = 0;\n    }\n    Node() { init(); } // leaf\n    Node(Node &l, Node &r) { init(); update(l, r); }\n    void update(const Node &l, const Node &r) {\n        mi = min(l.mi, r.mi);\n    }\n    void push(Node &l, Node &r) {\n        if (lz) {\n            l.lzdata(lz);\n            r.lzdata(lz);\n            lz = 0;\n        }\n    }\n    void lzdata(ll x) {\n        mi.first += x;\n        lz += x;\n    }\n    // query\n    struct MinQuery {\n        P mi = P(TEN(9), -1);\n        static constexpr bool update() { return false; }\n        void operator+=(Node &r) { mi = min(mi, r.mi); }\n    };\n    struct AddQuery {\n        int x;\n        static constexpr bool update() { return true; }\n        void operator+=(Node &n) { n.lzdata(x); }\n    };\n    struct SetQuery {\n        P x;\n        static constexpr bool update() { return true; }\n        void operator+=(Node &n) { n.mi = x; }\n    };    \n};\n\n\nconst int MN = 500500;\nint n;\nint base[MN];\nint idx[MN];\n\nvoid main2() {\n/*    for (int i = 0; i < n; i++) {\n        cout << base[i] << \" \";\n    }\n    cout << endl;\n\n    for (int i = 0; i < n; i++) {\n        cout << idx[i] << \" \";\n    }\n    cout << endl;*/\n    Fenwick<int> fw(n);\n//    FastSet mid(n);\nset<int> mid;\n    SegTree<Node> plus(n), minus(n);\n    for (int ph = 0; ph < n; ph++) {\n        int i = idx[ph];\n        int h = fw.sum(0, i);\n        if (h == base[i]) {\n//            mid.set(i);\nmid.insert(i);\n        } else {\n            bool isAdd = h < base[i];\n            int dif = abs(base[i] - h);\n//            int lm = mid.next(i);\nauto it = mid.lower_bound(i); int lm = (it == mid.end() ? n : *it);\n            P buf;\n            if (isAdd) {\n                //add\n                buf = plus.query(i, n, Node::MinQuery{}).mi;\n            } else {\n                //dec\n                buf = minus.query(i, n, Node::MinQuery{}).mi;\n            }\n            int lz = (buf.first == 0) ? buf.second : n;\n//            cout << lm << \" \" << lz << endl;\n            int L = i, R = min(lm, lz);\n            if (R < n) {\n                if (lm < lz) {\n                    //mid\n//                    mid.clear(lm);\nmid.erase(lm);\n                    if (isAdd) {\n                        minus.single(R, Node::SetQuery{P(0, R)});\n                        fw.add(R, -1);\n                    } else {\n                        plus.single(R, Node::SetQuery{P(0, R)});\n                        fw.add(R, 1);\n                    }\n                } else {\n                    //zero\n//                    mid.set(R);\nmid.insert(R);\n                    if (isAdd) {\n                        plus.single(R, Node::SetQuery{P(TEN(9), -1)});\n                        fw.add(R, -1);\n                    } else {\n                        minus.single(R, Node::SetQuery{P(TEN(9), -1)});\n                        fw.add(R, 1);\n                    }\n                }\n            }\n\n            if (isAdd) {\n                plus.single(i, Node::SetQuery{P(dif, i)});\n                plus.query(L, R, Node::AddQuery{-1});\n                minus.query(L, R, Node::AddQuery{1});\n                fw.add(i, 1);\n            } else {\n                plus.query(L, R, Node::AddQuery{1});\n                minus.single(i, Node::SetQuery{P(dif, i)});\n                minus.query(L, R, Node::AddQuery{-1});\n                fw.add(i, -1);\n            }\n        }\nprintf(\"%d\\n\", fw.sum(0, n));\n    }\n}\n\nint main() {\nscanf(\"%d\", &n);\n    using P = pair<int, int>;\n    V<P> v(n);\n    for (int i = 0; i < n; i++) {\nscanf(\"%d\", &(v[i].first));\n        v[i].second = i;\n    }\n    sort(begin(v), end(v));\n    for (int i = 0; i < n; i++) {\n        base[i] = v[i].first;\n        idx[v[i].second] = i;\n    }\n    main2();\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3000", "interactive": false}