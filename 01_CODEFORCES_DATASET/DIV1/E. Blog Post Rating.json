{
    "link": "https://codeforces.com//contest/806/problem/E",
    "problemId": "105599",
    "problem_idx": "E",
    "shortId": "806E",
    "contest_number": "806",
    "problem_submissions": {
        "E": [
            26946399,
            26946353,
            26942942,
            26940751,
            26976136,
            26943065,
            26942598,
            26942187,
            26937843,
            26947143,
            27001343,
            26946488,
            26943631,
            26951183,
            26939699,
            26944777
        ],
        "D": [
            26938120,
            26934427,
            26936263,
            26937600,
            26934513,
            26936339,
            26937621,
            26938327,
            26939404,
            26938853,
            26942391,
            26940455,
            26938860,
            26938974,
            26941503,
            26941670
        ],
        "B": [
            26933193,
            26932004,
            26938489,
            26932467,
            26931704,
            26932365,
            26935492,
            26932113,
            26930780,
            26942817,
            26930285,
            26932725,
            26943302,
            26937682,
            26931932,
            26932598
        ],
        "C": [
            26931766,
            26942392,
            26933099,
            26934784,
            26933629,
            26933365,
            26933930,
            26931141,
            26934600,
            26930447,
            26934117,
            26934951,
            26929917,
            26933809,
            26935513,
            26934671
        ],
        "A": [
            26928049,
            26926811,
            26929039,
            26927072,
            26927004,
            26926681,
            26927002,
            26927962,
            26928737,
            26927722,
            26927311,
            26932013,
            26927300,
            26928724,
            26926850,
            26927034,
            26927665,
            26929077
        ]
    },
    "name": "E. Blog Post Rating",
    "statement": "It’s well-known that blog posts are an important part of Codeforces\r\nplatform. Every blog post has a global characteristic changing over time\r\nits . A newly created blog post’s community rating is 0. Codeforces\r\nusers may visit the blog post page and rate it, changing its community\r\nrating by +1 or -1.Consider the following model of Codeforces users’\r\nbehavior. The -th user has his own denoted by an integer . When a user\r\nvisits a blog post page, he compares his estimated blog post rating to\r\nits community rating. If his estimated rating is higher, he rates the\r\nblog post with +1 (thus, the blog post’s community rating increases by\r\n1). If his estimated rating is lower, he rates the blog post with -1\r\n(decreasing its community rating by 1). If the estimated rating and the\r\ncommunity rating are equal, user doesn’t rate the blog post at all (in\r\nthis case we’ll say that user rates the blog post for 0). In any case,\r\nafter this procedure user closes the blog post page and never opens it\r\nagain.Consider a newly created blog post with the initial community\r\nrating of 0. For each of Codeforces users, numbered from 1 to , his\r\nestimated blog post rating is known.For each from 1 to , inclusive, the\r\nfollowing question is asked. Let users with indices from 1 to , , visit\r\nthe blog post page, rate the blog post and close the page. Each user\r\nopens the blog post only after the previous user closes it. What could\r\nbe the maximum possible community rating of the blog post after these\r\nvisits?\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\n#define tm f__k\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\nstruct FastSet {\n    int N, lg;\n    VV<ull> seg;\n    FastSet(int N) : N(N) {\n        while (N > 1) {\n            seg.push_back(V<ull>((N+63)/64));\n            N = (N+63)/64;\n        }\n        lg = seg.size();\n    }\n    bool test(int x) const {\n        int D = x/64, R = x%64;\n        return (seg[0][D] & (1ULL<<R)) != 0;\n    }\n    void set(int x) {\n        for (int i = 0; i < lg; i++) {\n            int D = x/64, R = x%64;\n            seg[i][D] |= (1ULL<<R);\n            x /= 64;\n        }\n    }\n    void clear(int x) {\n        for (int i = 0; i < lg; i++) {\n            int D = x/64, R = x%64;\n            seg[i][D] &= ~(1ULL<<R);\n            if (i && seg[i-1][x] != 0) {\n                seg[i][D] |= (1ULL<<R);\n            }\n            x /= 64;\n        }\n    }\n    // x以上最小の要素\n    int next(int x) {\n        for (int i = 0; i < lg; i++) {\n            int D = x/64, R = x%64;\n            if (D == seg[i].size()) break;\n            ull B = seg[i][D]>>R;\n            if (!B) {\n                x = x/64+1;\n                continue;\n            }\n            //find\n            x += bsf(B);\n            for (int j = i-1; j >= 0; j--) {\n                x *= 64;\n                int D = x/64;\n                x += bsf(seg[j][D]);\n            }\n            return x;\n        }\n        return N;\n    }\n    // x以下最大の要素\n    int back(int x) {\n        for (int i = 0; i < lg; i++) {\n            if (x == -1) break;\n            int D = x/64, R = x%64;\n            ull B = seg[i][D]<<(63-R);\n            if (!B) {\n                x = x/64-1;\n                continue;\n            }\n            //find\n            x += bsr(B)-63;\n            for (int j = i-1; j >= 0; j--) {\n                x *= 64;\n                int D = x/64;\n                x += bsr(seg[j][D]);\n            }\n            return x;\n        }\n        return -1;\n    }    \n};\n\ntemplate<class T>\nstruct Fenwick {\n    int N, lg;\n    V<T> seg;\n    Fenwick(int N) : N(N) {\n        seg.resize(N+1);\n        lg = bsr(uint(N));\n        fill(begin(seg), end(seg), T(0));\n    }\n    /// i番目の要素にxを追加する\n    void add(int i, T x) {\n        i++;\n        while (i <= N) {\n            seg[i] += x;\n            i += i & -i;\n        }\n    }\n    /// [0, i)のsum\n    T sum(int i) {\n        T s{0};\n        while (i > 0) {\n            s += seg[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n    /// [a, b)のsum\n    T sum(int a, int b) {\n        return sum(b) - sum(a);\n    }\n    /// sum[0, idx) >= xなる最小のidx\n    int sum_lower_bound(T x) {\n        if (x <= 0) return 0;\n        int res = 0;\n        for (int len = 1<<lg; len >= 1; len /= 2) {\n            if (res + len <= N && seg[res + len] < x) {\n                x -= seg[res+len];\n                res += len;\n            }\n        }\n        return res + 1;\n    }\n};\ntemplate<class N>\nstruct SegTree {\n    int lg, sz;\n    vector<N> n;\n    SegTree() {}\n    SegTree(int sz) {\n        assert(sz >= 1);\n        lg = bsr(uint(2*sz-1));\n        sz = 1<<lg;\n        this->sz = sz;\n        n = vector<N>(2*sz);\n        for (int i = 2*sz-1; i >= sz; i--) {\n            n[i] = N();\n        }\n        for (int i = sz-1; i >= 1; i--) {\n            n[i] = N(n[2*i], n[2*i+1]);\n        }\n    }\n    void all_update() {\n        for (int i = 1; i <= sz-1; i++) {\n            n[i].push();\n        }\n        for (int i = sz-1; i >= 1; i--) {\n            n[i].update(n[2*i], n[2*i+1]);\n        }\n    }\n    template<class Q>\n    Q single(int idx, Q q) {\n        if (idx < 0 || sz <= idx) return q;\n        idx += sz;\n        for (int i = lg; i >= 1; i--) {\n            int k = idx>>i;\n            n[k].push(n[2*k], n[2*k+1]);\n        }\n        q += n[idx];\n        if (q.update()) {\n            for (int i = 1; i <= lg; i++) {\n                int k = idx>>i;\n                n[k].update(n[2*k], n[2*k+1]);\n            }\n        }\n        return q;\n    }\n    template<class Q>\n    void query(int a, int b, Q &q, int k, int sz) {\n        if (a <= 0 && sz <= b) {\n            q += n[k];\n            return;\n        }\n        n[k].push(n[2*k], n[2*k+1]);\n        if (a < sz/2) query(a, b, q, 2*k, sz/2);\n        if (sz/2 < b) query(a-sz/2, b-sz/2, q, 2*k+1, sz/2);\n        if (q.update()) n[k].update(n[2*k], n[2*k+1]);\n    }\n    template<class Q>\n    Q query(int a, int b, Q q) {\n        if (a < sz && 0 < b) query(a, b, q, 1, sz);\n        return q;\n    }\n    struct NodeQuery {\n        N n;\n        static constexpr bool update() { return false; }\n        void operator+=(N &r) { N nn; nn.update(n, r); n = nn; }\n    };\n};\n\nusing P = pair<int, int>;\nstruct Node {\n    P mi;\n    int lz;\n    void init() {\n        mi = P(TEN(9), -1);\n        lz = 0;\n    }\n    Node() { init(); } // leaf\n    Node(Node &l, Node &r) { init(); update(l, r); }\n    void update(const Node &l, const Node &r) {\n        mi = min(l.mi, r.mi);\n    }\n    void push(Node &l, Node &r) {\n        if (lz) {\n            l.lzdata(lz);\n            r.lzdata(lz);\n            lz = 0;\n        }\n    }\n    void lzdata(ll x) {\n        mi.first += x;\n        lz += x;\n    }\n    // query\n    struct MinQuery {\n        P mi = P(TEN(9), -1);\n        static constexpr bool update() { return false; }\n        void operator+=(Node &r) { mi = min(mi, r.mi); }\n    };\n    struct AddQuery {\n        int x;\n        static constexpr bool update() { return true; }\n        void operator+=(Node &n) { n.lzdata(x); }\n    };\n    struct SetQuery {\n        P x;\n        static constexpr bool update() { return true; }\n        void operator+=(Node &n) { n.mi = x; }\n    };    \n};\n\n\nconst int MN = 500500;\nint n;\nint base[MN];\nint idx[MN];\n\nvoid main2() {\n/*    for (int i = 0; i < n; i++) {\n        cout << base[i] << \" \";\n    }\n    cout << endl;\n\n    for (int i = 0; i < n; i++) {\n        cout << idx[i] << \" \";\n    }\n    cout << endl;*/\n    Fenwick<int> fw(n);\n//    FastSet mid(n);\nset<int> mid;\n    SegTree<Node> plus(n), minus(n);\n    for (int ph = 0; ph < n; ph++) {\n        int i = idx[ph];\n        int h = fw.sum(0, i);\n        if (h == base[i]) {\n//            mid.set(i);\nmid.insert(i);\n        } else {\n            bool isAdd = h < base[i];\n            int dif = abs(base[i] - h);\n//            int lm = mid.next(i);\nauto it = mid.lower_bound(i); int lm = (it == mid.end() ? n : *it);\n            P buf;\n            if (isAdd) {\n                //add\n                buf = plus.query(i, n, Node::MinQuery{}).mi;\n            } else {\n                //dec\n                buf = minus.query(i, n, Node::MinQuery{}).mi;\n            }\n            int lz = (buf.first == 0) ? buf.second : n;\n//            cout << lm << \" \" << lz << endl;\n            int L = i, R = min(lm, lz);\n            if (R < n) {\n                if (lm < lz) {\n                    //mid\n//                    mid.clear(lm);\nmid.erase(lm);\n                    if (isAdd) {\n                        minus.single(R, Node::SetQuery{P(0, R)});\n                        fw.add(R, -1);\n                    } else {\n                        plus.single(R, Node::SetQuery{P(0, R)});\n                        fw.add(R, 1);\n                    }\n                } else {\n                    //zero\n//                    mid.set(R);\nmid.insert(R);\n                    if (isAdd) {\n                        plus.single(R, Node::SetQuery{P(TEN(9), -1)});\n                        fw.add(R, -1);\n                    } else {\n                        minus.single(R, Node::SetQuery{P(TEN(9), -1)});\n                        fw.add(R, 1);\n                    }\n                }\n            }\n\n            if (isAdd) {\n                plus.single(i, Node::SetQuery{P(dif, i)});\n                plus.query(L, R, Node::AddQuery{-1});\n                minus.query(L, R, Node::AddQuery{1});\n                fw.add(i, 1);\n            } else {\n                plus.query(L, R, Node::AddQuery{1});\n                minus.single(i, Node::SetQuery{P(dif, i)});\n                minus.query(L, R, Node::AddQuery{-1});\n                fw.add(i, -1);\n            }\n        }\nprintf(\"%d\\n\", fw.sum(0, n));\n    }\n}\n\nint main() {\nscanf(\"%d\", &n);\n    using P = pair<int, int>;\n    V<P> v(n);\n    for (int i = 0; i < n; i++) {\nscanf(\"%d\", &(v[i].first));\n        v[i].second = i;\n    }\n    sort(begin(v), end(v));\n    for (int i = 0; i < n; i++) {\n        base[i] = v[i].first;\n        idx[v[i].second] = i;\n    }\n    main2();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Blog Post Rating.json",
    "editorial_link": "https://codeforces.com//blog/entry/51883",
    "editorial": "There are several different solutions to this problem, Iâll describe one\r\nof them.First, we have to determine the optimal rating order for a set\r\nof users. Using an exchange argument, it can be shown that to maximize\r\nthe final community rating the users should rate the blog post in\r\nnon-decreasing order of their estimated ratings. Indeed, consider an\r\noptimal rating order, consider two users with estimated ratings and next\r\nto each other in this order, and assume that . Letâs denote the\r\ncommunity rating before these two users rate the blog post by . Then\r\nhere is what happens if these two users rate this blog post in the\r\ncurrent and the reverse order: We can see that the , order is never\r\nbetter than , . That means we can swap these two users in the order and\r\nthe result wonât become worse. We can continue swapping all such pairs\r\nof users until we obtain a non-decreasing order.Now, suppose users with\r\nestimated ratings rate a newly created blog post. For some , the first\r\nusers will rate it with -1. It can be seen that the following property\r\nwill hold for the rest of the users their estimated ratings will not be\r\nlower than the community rating of the blog post at the moment of\r\nviewing the page. Thus, all remaining users will rate the blog post with\r\n+1 or 0.Letâs sort all users according to their estimated rating, and\r\nmaintain a segment tree which contains, for each user in this order, the\r\ndifference between his estimated rating and the community rating after\r\nhis view. Initially, all users are inactive and it looks like they rate\r\nthe blog post with 0. Then, weâll make users active one by one in order\r\nof input. Weâll also maintain three sets of active users those who rate\r\nthe blog post with +1, 0 and -1, respectively.To make a user active,\r\nfirst we find how he rates the blog post. Then, there are three cases:\r\nIf he rates the blog post for 0, there is no need to do anything else.\r\nIf he rates the blog post for -1, the rightmost -1 might change to 0. If\r\nit does, we are done. Otherwise, the community rating before users in\r\nthe \"+1 and 0\" group has decreased by 1. Thus, the leftmost 0 (if it\r\nexists) changes to +1, and weâre done. If he rates the blog post for +1,\r\nthen either thereâs a user to the right of him whose value in the\r\nsegment tree becomes negative, in which case the leftmost of these users\r\nnow rates the blog post for 0 instead of +1, or thereâs no such user, in\r\nwhich case nothing else changes. All operations above can be performed\r\nusing queries to our sets of users and segment tree. For example, when a\r\nuser appears who rated the blog post with +1, we have to insert him into\r\nthe +1 set and make a query to the segment tree to decrease the value by\r\n1 in the range from this user to the last user. The answer that is, the\r\nmaximum possible community rating after the first users is the size of\r\nthe +1 set minus the size of the -1 set.\r\n",
    "hint": []
}