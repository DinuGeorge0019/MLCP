{
    "link": "https://codeforces.com//contest/528/problem/B",
    "problemId": "24748",
    "problem_idx": "B",
    "shortId": "528B",
    "contest_number": "528",
    "problem_submissions": {
        "E": [
            10341247,
            10347694,
            10319347
        ],
        "D": [
            10329962,
            10320069,
            10323923,
            10323825,
            15074824,
            15074755,
            15074588,
            13788938,
            12800686,
            10323881,
            10325933,
            10320996,
            10324989,
            10325719,
            10324991,
            10322203,
            10325699,
            10330641,
            10325792,
            15079118,
            15024306,
            15024301,
            15024294,
            10326179,
            10326263,
            10326568,
            10771730,
            10326292,
            10326245,
            10595851,
            10595702,
            10595678,
            10595541,
            10595511,
            10595468,
            10595396,
            10595378,
            10595366,
            10595274,
            10595233,
            10594977,
            10594940,
            10594912,
            10594743,
            10594617,
            10325531,
            10318821
        ],
        "C": [
            10318112,
            10318394,
            10319266,
            10320615,
            10318827,
            10326662,
            10320967,
            10321573,
            10322337,
            10325513,
            10322954,
            10330901,
            10330797,
            10322938,
            10330769,
            10321075,
            10321402,
            10323235,
            10322360,
            10323460,
            10323142,
            10370800
        ],
        "B": [
            10314537,
            10315068,
            10315364,
            10314727,
            10316045,
            10315205,
            10316694,
            10315441,
            10317355,
            10318177,
            10316603,
            10315049,
            10313726,
            10317367,
            10314711,
            10315826,
            10318768,
            10317793,
            10318969,
            10315008
        ],
        "A": [
            10312991,
            10313324,
            10313565,
            10313501,
            10314349,
            10313172,
            10313135,
            10314168,
            10314385,
            10315234,
            10313926,
            10317754,
            10314988,
            10315685,
            10313735,
            10314526,
            10314740,
            10314101,
            10314876,
            10312997
        ]
    },
    "name": "B. Clique Problem",
    "statement": "The clique problem is one of the most well-known NP-complete problems.\r\nUnder some simplification it can be formulated as follows. Consider an\r\nundirected graph . It is required to find a subset of vertices of the\r\nmaximum size such that any two of them are connected by an edge in graph\r\n. Sounds simple, doesn’t it? Nobody yet knows an algorithm that finds a\r\nsolution to this problem in polynomial time of the size of the graph.\r\nHowever, as with many other NP-complete problems, the clique problem is\r\neasier if you consider a specific type of a graph.Consider distinct\r\npoints on a line. Let the -th point have the coordinate and weight .\r\nLet’s form graph , whose vertices are these points and edges connect\r\nexactly the pairs of points , such that the distance between them is not\r\nless than the sum of their weights, or more formally: .Find the size of\r\nthe maximum clique in such graph.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define REP(a,b) for(int a=0; a<(b); ++a)\n#define FWD(a,b,c) for(int a=(b); a<(c); ++a)\n#define FWDS(a,b,c,d) for(int a=(b); a<(c); a+=d)\n#define BCK(a,b,c) for(int a=(b); a>(c); --a)\n#define ALL(a) (a).begin(), (a).end()\n#define SIZE(a) ((int)(a).size())\n#define VAR(x) #x \": \" << x << \" \"\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n#define gcd __gcd\n#define x first\n#define y second\n#define st first\n#define nd second\n#define pb push_back\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &out, const vector<T> &v){ out << \"{\"; for(const T &a : v) out << a << \", \"; out << \"}\"; return out; }\ntemplate<typename S, typename T> ostream& operator<<(ostream &out, const pair<S,T> &p){ out << \"(\" << p.st << \", \" << p.nd << \")\"; return out; }\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double K;\ntypedef vector<int> VI;\n\nconst int INF = 1000000000;\n\nconst int dx[] = {0,0,-1,1}; //1,1,-1,1};\nconst int dy[] = {-1,1,0,0}; //1,-1,1,-1};\n\nint n, res;\nint X[200010];\nint W[200010];\nint R[200010];\n\nstruct event {\n\tint i, type, x;\n};\n\nbool cmp(event a, event b){\n\tif(a.x != b.x) return a.x < b.x;\n\treturn a.type < b.type;\n}\n\nvector<event> E;\n\nint main(){\n\tscanf(\"%d\", &n);\n\tevent e;\n\tFWD(i,0,n){\n\t\tscanf(\"%d %d\", &X[i], &W[i]);\n\t\te.i = i;\n\t\te.type = 1;\n\t\te.x = X[i] - W[i];\n\t\tE.push_back(e);\n\t\te.type = -1;\n\t\te.x = X[i] + W[i];\n\t\tE.push_back(e);\n\t}\n\tsort(ALL(E), cmp);\n\tFWD(i,0,SIZE(E)){\n\t\te = E[i];\n//\t\tprintf(\"event %d %d %d\\n\", e.i, e.type, e.x);\n\t\tif(e.type == -1) res = max(res, R[e.i]);\n\t\telse R[e.i] = res + 1;\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Clique Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/17020",
    "editorial": "One may think that this task is about graph theory, but it after some\r\ninvestigation and several equivalent changes in task statement it can be\r\nreduced to the well-known greedy problem. Initially you have that points\r\nmay lie together in a set if they are not too close, i. e. . This is\r\nobviously equivalent to the following condition. Let s consider interval\r\nof radius with center in point and call this interval to be the interval\r\nof point i. Then the statement actually says that no two such intervals\r\nshould be intersecting. This task is well-known and can be solved\r\ngreedily after sorting segments in ascending order of right endpoint: It\r\ns easy to prove that this solution is correct. Among all ways to choose\r\nfirst segments, the best way is the one that minimizes x-coordinate of\r\nthe right endpoint of the last segment (since it restricts us in the\r\nleast possible way). Problem legend asks you to add minimum number of\r\nedges to the given connected undirected graph (possibly, with loops and\r\nduplicating edges) and choose direction for its edges so that both the\r\nincoming and outgoing degrees of all vertices are even. First idea is\r\nthat the resulting graph before we choose the direction (but after we\r\nadded some edges) will contain Euler circuit, since all degrees are\r\neven. That s almost what we need: if we have an Euler circuit that\r\ncontains even number of edges, we may direct them like following: a <- b\r\n-> c <- d -> e It s easy to see that each vertex appearance in this\r\ncycle adds 2 to its ingoing or outgoing degree, so the resulting degrees\r\nwill be even. But if the Euler circuit is odd (meaning that there is odd\r\nnumber of edges in the graph), we must add some extra edge to the graph\r\nbefore we continue, the easiest way is to add a loop from vertex 0 to\r\nitself, since it doesn t affect the Euler tour, but now tour length is\r\neven, so everything is ok. Now we should think how to add edges\r\noptimally. It s easy to see that the optimal way is to first fix all odd\r\ndegrees of vertices (i. e. combine all odd vertices by pairs and put an\r\nedge in each pair), and then, possibly, add an extra loop as described\r\nabove. The last part is to actually find an Euler circuit, and to print\r\nthe answer. There were issues with this task. Intended constraints were\r\nactually , and the intended solution was using Fast Fourier\r\nTransformation, that leads to running time. But unfortunately the\r\nstatement contained wrong constraints, so we reduced input size during\r\nthe tour. Nevertheless, we will add the harder version of this task and\r\nyou will be able to submit it shortly. Key idea is to reduce this task\r\nto a polynomial multiplication. Let s solve the task in following\r\nmanner. For each position i of the S for each character c from ATGC we\r\nwill calculate match(c, i) that is equal to the number of c characters\r\nthat have matching symbol in S if we put string T in position i. Then\r\nthe criteria for us to have an occurrence at position i is that match(A,\r\ni) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly\r\nthat each character from T being put at position i has a corresponding\r\ncharacter in S). Now let s find out how to calculate match(c, i). Let s\r\nkeep only c characters and not c characters in both strings and denote\r\nthem by 1 and 0 respectively. Let s also spread each 1 in string S by\r\nthe distance k to the left and to the right. For example, k = 1 for the\r\nsample string AGCAATTCAT and the character A corresponding bit vector\r\nwill be 111110111, and for the character C it will be 0111001110. This\r\nbitvector can be calculated in by putting two events +1 and -1 in string\r\nS in positions and for each in original string S and then sweeping from\r\nleft to right over the string S and processing those events. Now our\r\ntask is reduced to searching all positions where the bitvector T is the\r\nsubmask of the bitvector S. In constraints this can be done by using\r\nbitsets in . Nevertheless, this task can be seen as calculation of\r\npolynomials S and reversed(T) product. We will keep this as an exercise\r\nfor those who decide to submit the harder version of this task. Let s\r\ndraw a bounding box that contains all intersection points. Let s fix a\r\ntriangle and consider three angles shown on the picture. Calculate area\r\nof intersection of those area with the bounding box and call this area\r\nto be the area of an angle . Then it s easy to see, that those three\r\nangles are complement to the triangle itself in the bounding box, i. e.\r\ntriangle area is bounding box area minus three angle areas. This leads\r\nus to the idea how to solve this task by carefully calculating for each\r\npossible formed angle on the plane, how much times does it appear in\r\ntotal answer if we sum all values like over all triples of lines.\r\nActually, the angle is considered as many times, as many lines there are\r\nthat intersect both sides of its right adjacent angle. So, our task is\r\nreduced to calculate for each angle on plane how much lines intersect\r\nits sides (i. e. its rays). This can be done in by fixing the first side\r\nof the angle and then adding lines in ascending order of polar angle,\r\nand then by keeping the number of lines that intersect the base line to\r\nthe left and that intersect the base line to the right. Key idea is that\r\nthe exact of four angles formed by the pair of lines that is crossed by\r\nsome third line c, can be determined by two numbers: its polar angle\r\nalpha and its crossing with a coordinate x. Further details are shown on\r\nthe picture below. There is also a nice short solution from enot110\r\nhere.\r\n",
    "hint": []
}