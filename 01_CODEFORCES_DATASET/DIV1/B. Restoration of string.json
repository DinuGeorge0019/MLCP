{
    "link": "https://codeforces.com//contest/889/problem/B",
    "problemId": "133719",
    "problem_idx": "B",
    "shortId": "889B",
    "contest_number": "889",
    "problem_submissions": {
        "D": [
            32268277,
            32261782,
            32262346,
            32267448,
            32264912,
            32270286,
            32262994,
            32270235,
            32268920
        ],
        "E": [
            32261080,
            32269250,
            42287448
        ],
        "C": [
            32258949,
            32258309,
            32261571,
            32258724,
            32261718,
            32260558,
            32259837,
            32261642,
            32262113,
            32268280,
            32263105,
            32260984,
            32260094,
            32262538,
            32263363,
            32275764,
            32267069,
            32261624,
            32263229
        ],
        "B": [
            32252734,
            32253330,
            32255576,
            32255239,
            32254428,
            32258155,
            32254407,
            32256519,
            32255311,
            32263055,
            32253848,
            32255572,
            32252983,
            32255704,
            32255404,
            32253464,
            32255981
        ],
        "A": [
            32248128,
            32248978,
            32250463,
            32251033,
            32250128,
            32254306,
            32249854,
            32249329,
            32248510,
            32248897,
            32270420,
            32248851,
            32248699,
            32248336,
            32249379,
            32249111,
            32248222,
            32250477
        ]
    },
    "name": "B. Restoration of string",
    "statement": "A substring of some string is called the most frequent, if the number of\r\nits occurrences is not less than number of occurrences of any other\r\nsubstring.You are given a set of strings. A string (not necessarily from\r\nthis set) is called good if all elements of the set are the most\r\nfrequent substrings of this string. Restore the non-empty good string\r\nwith minimum length. If several such strings exist, restore\r\nlexicographically minimum string. If there are no good strings, print \"\"\r\n(without quotes).A substring of a string is a contiguous subsequence of\r\nletters in the string. For example, \"\", \"\", \"\" are substrings of string\r\n\"\", while \"\" is not a substring of that string.The number of occurrences\r\nof a substring in a string is the number of starting positions in the\r\nstring where the substring occurs. These occurrences could\r\noverlap.String is lexicographically smaller than string , if is a prefix\r\nof , or has a smaller letter at the first position where and differ.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 200001;\n\nbool w[26];\nint nxt[26];\nint pvc[26];\n\nvoid nein() {\n    cout << \"NO\\n\";\n    exit(0);\n}\n\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n;\n    cin >> n;\n\n    fill(begin(nxt), end(nxt), -1);\n\n    for (int i = 0; i < n; ++i) {\n        string s;\n        cin >> s;\n        for (char c : s) {\n            w[c - 'a'] = true;\n        }\n\n        for (int j = 1; j < s.length(); ++j) {\n            int pv = s[j - 1] - 'a', nx = s[j] - 'a';\n            if (nxt[pv] == nx) {\n                continue;\n            }\n\n            ++pvc[nx];\n\n            if (nxt[pv] == -1) {\n                nxt[pv] = nx;\n                continue;\n            }\n\n            nxt[pv] = nx;\n        }\n    }\n\n    int forcenext = -1;\n\n    string ans;\n    for (;;) {\n        if (forcenext != -1 && (!w[forcenext] || pvc[forcenext])) {\n            nein();\n        }\n\n        bool hw = false;\n        for (int j = 0; j < 26; ++j) {\n            hw |= w[j];\n        }\n\n        if (!hw) {\n            break;\n        }\n\n        int bj;\n        if (forcenext != -1) {\n            bj = forcenext;\n        } else {\n            bj = -1;\n            for (int j = 25; j >= 0; --j) {\n                if (pvc[j] == 0 && w[j]) {\n                    bj = j;\n                }\n            }\n        }\n\n        if (bj == -1) {\n            nein();\n        }\n\n        ans += char('a' + bj);\n        w[bj] = false;\n        forcenext = nxt[bj];\n        if (forcenext != -1) {\n            --pvc[forcenext];\n        }\n    }\n\n    cout << ans << \"\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "graphs",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Restoration of string.json",
    "editorial_link": "https://codeforces.com//blog/entry/55734",
    "editorial": "If some string is the most frequent then all its substrings are the most frequent too.\nIf string ab or similar is the most frequent then letter a is always followed by letter b and b always follow a.\nLet's consider directed graph on letters where edge a???b exists only if ab is the most frequent. If there is cycle in such graph then good string doesn't exist.\nSo such graph can be represented as several non-intersecting paths. All strings which correspond to paths must occur in non-empty good string. So if we print them in lexicographical order then we will get the answer."
}