{
    "link": "https://codeforces.com//contest/853/problem/D",
    "problemId": "121091",
    "problem_idx": "D",
    "shortId": "853D",
    "contest_number": "853",
    "problem_submissions": {
        "D": [
            30147648,
            30145874,
            30152169,
            30145670,
            30147401,
            30148548,
            30157869,
            30157814,
            30157512,
            30150989,
            30149728,
            30151353,
            30151549,
            30150847,
            30147708,
            30168803,
            30167984,
            30151241,
            30151140,
            30151931,
            30151709,
            30155800,
            30154094,
            30151955
        ],
        "C": [
            30142518,
            30148496,
            30147073,
            30143792,
            30144399,
            30146037,
            30145612,
            30146271,
            30147784,
            30146395,
            30148182,
            30151583,
            30168390,
            30147533,
            30148448,
            30148036,
            30147775,
            30144847,
            30147101,
            30148563
        ],
        "B": [
            30137358,
            30139471,
            30141499,
            30138298,
            30137334,
            30139875,
            30139930,
            30139800,
            30141449,
            30137864,
            30144203,
            30143376,
            30142744,
            30143145,
            30140773,
            30144005,
            30140202,
            30140453,
            30142525
        ],
        "A": [
            30133427,
            30134359,
            30136395,
            30133742,
            30132639,
            30132563,
            30134311,
            30135028,
            30134993,
            30133338,
            30136720,
            30135878,
            30134302,
            30137681,
            30134274,
            30133388,
            30133609,
            30133814,
            30134640
        ],
        "E": [
            30179221,
            30179071,
            31229560,
            30173059
        ]
    },
    "name": "D. Michael and Charging Stations",
    "statement": "Michael has just bought a new electric car for moving across city.\r\nMichael does not like to overwork, so each day he drives to only one of\r\ntwo his jobs.Michael’s day starts from charging his electric car for\r\ngetting to the work and back. He spends burles on charge if he goes to\r\nthe first job, and burles if he goes to the second job.On a charging\r\nstation he uses there is a loyalty program that involves bonus cards.\r\nBonus card may have some non-negative amount of bonus burles. Each time\r\ncustomer is going to buy something for the price of burles, he is\r\nallowed to pay an amount of () burles that does not exceed the bonus\r\ncard balance with bonus burles. In this case he pays burles with cash,\r\nand the balance on the bonus card is decreased by bonus burles. If\r\ncustomer pays whole price with cash (i.e., ) then 10\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 300300;\nconst int INF = 2 * N;\nint a[N];\nbool b[N];\nint n;\n\nbool evaluate(int x) {\n\tint bal = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (b[i]) {\n\t\t\tint val = min(bal, a[i]);\n\t\t\tbal -= val;\n\t\t\tx -= val;\n\t\t} else {\n\t\t\tbal += a[i] / 10;\n\t\t}\n\t}\n\treturn x <= 0;\n}\n\nbool suf(int x) {\n\tint oldx = x;\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = 0;\n\tfor (int i = n - 1; x > 0 && i >= 0; i--) {\n\t\tb[i] = 1;\n\t\tx -= a[i];\n\t}\n\treturn evaluate(oldx);\n}\nbool skip1(int x) {\n\tint oldx = x;\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = 0;\n\tfor (int i = n - 1; x > 0 && i >= 0; i--) {\n\t\tb[i] = 1;\n\t\tx -= a[i];\n\t}\n\tint pos = 0;\n\twhile(pos < n && (a[pos] != 10 || !b[pos])) pos++;\n\tif (pos == n)\n\t\treturn false;\n\tx += a[pos];\n\tb[pos] = 0;\n\tpos--;\n\twhile(pos >= 0 && b[pos]) pos--;\n\tif (evaluate(oldx)) return true;\n\tif (pos >= 0) {\n\t\tb[pos] = 1;\n\t}\n\treturn evaluate(oldx);\n}\nbool take1(int x) {\n\tint oldx = x;\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = 0;\n\tfor (int i = n - 1; x > 0 && i >= 0; i--) {\n\t\tif (x <= 20 && a[i] == 20) continue;\n\t\tx -= a[i];\n\t\tb[i] = 1;\n\t}\n\treturn evaluate(oldx);\n}\n\nbool solve(int x) {\n\treturn suf(x) || skip1(x) || take1(x);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i] /= 100;\n\t}\n\tint l = 0, r = INF;\n\twhile(r - l > 1) {\n\t\tint x = (l + r) / 2;\n\t\tif (solve(x))\n\t\t\tl = x;\n\t\telse\n\t\t\tr = x;\n\t}\n\tint ans = -l;\n\tfor (int i = 0; i < n; i++)\n\t\tans += a[i];\n\tprintf(\"%d\\n\", ans * 100);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Michael and Charging Stations.json",
    "editorial_link": "https://codeforces.com//blog/entry/54368",
    "editorial": "Before solving problem one observation is required: suppose at day we\r\nhave bonuses. Then exists optimal solution, which spends or bonuses\r\nevery day. Itâs quite easy to proof: suppose we have some optimal\r\nsolution and is a first day, when neither nor bonuses were spent. If is\r\na last day on which non-zero amount of bonuses was spent, we can notice\r\nthat solution spending bonuses that day is more optimal, so first\r\nsolution was optimal. So letâs consider next day after , when non-zero\r\namount of bonuses was spent, say , and amount of bonuses spent at day is\r\n(Also, amount of bonuses spent on day is ). Letâs look at solution that\r\nspends bonuses at day and . That solution is still correct and still\r\noptimal, but it spends at day or at day . Anyway this operation\r\nincreases first day when neither nor bonuses were spent or first day\r\nafter it, when non-zero amount of burles were spent. But we canât\r\nincrease or infinitely, so, after some iterations of such\r\ntransformation, solution, spending or bonuses in each day.To make an\r\nsolution itâs possible to consider dynamic programming approach: let be\r\nminimum amount of money that is possible to spend at first days to pay\r\nfor all chargings and have bonuses on card. At first, and . Then we can\r\neasy calculate all states going through all states with something like\r\nthis code:for (int i = 0; i < n; i++) { for (int j = 0; j <= 2 * n; j++)\r\n{ dp[i + 1][j + a[i] / 1000] = min(dp[i + 1][j + a[i] / 1000],\r\ndp[i][j] + a[i]); dp[i + 1][j - min(j, a[i] / 100)] = min(dp[i + 1][j -\r\nmin(j, a[i] / 100)], dp[i][j] + a[i] - 100 * min(j, a[i] / 100)); } }Of\r\ncourse, can be up to , because at each day itâs possible to earn at most\r\n2 bonuses.To make this solution faster letâs consider the following\r\nobservation: there exists an optimal solution, which never has more\r\nbonuses on bonus card. To proof it letâs first proof following lemma::\r\nThere exists an optimal solution which spends only or bonuses at day if\r\nthere are at least bonuses at card at the beginning of day . : Letâs\r\nintroduce some designations. Let be amount of bonuses at the beginning\r\nof day and be amount of bonuses spent at day . Also letâs call day\r\n\"fractional\" if and , and call day \"interesting\" if . Letâs proof lemma2\r\nand lemma3 at first:: Assume and next after interesting day and next\r\nafter interesting day. Then there exists an optimal solution in which is\r\nnot a fractional day or is not a fractional day. : Suppose is some\r\noptimal solution and are fractional days. Letâs consider a solution\r\nspending bonuses at day and at day . This solution is still correct,\r\nbecause , so for days and there is enough bonuses and still optimal.\r\nLemma2 is proved.: Assume and next after interesting day. Then there\r\nexists an optimal solution is which is not a fractional day.: Consider\r\nsome optimal solution with fractional day . At first letâs proof that is\r\nnot last interesting day. Suppose, is last interesting day in solution.\r\nBut we can make a solution that spends bonuses at day (because ) and it\r\nwill be more optimal. Contradiction. So there exists next after\r\ninteresting day. Letâs call it . Letâs consider 2 cases: (): Letâs spend\r\nconsider solution spending bonuses at day and at day . Itâs still\r\ncorrect and optimal but is not a fractional day. (): There are two\r\nsubcases: (): Letâs spend consider solution spending bonuses at day and\r\nat day . Itâs still correct and optimal but is not a fractional day. ():\r\nLetâs proof, is not last interesting day. Assume is last interesting\r\nday. Consider a solution spending bonuses at day and 1000 bonuses at day\r\n. Itâs correct but more optimal that initial solution. Conrtadiction.\r\nNow let be next after interesting day ( is not a fractional day by\r\nlemma2). If we can consider solution which spends bonuses at day ,\r\nbonuses at day and bonuses at day . If letâs consider a solution which\r\nspends bonuses at day , bonuses at day and at day . But by lemma2 , so\r\nwe can consider solution that spends bonuses at day bonuses at day and\r\nat day . All of these solutions are correct and optimal.: At first, of\r\ncourse there is at least one interesting day after (Otherwise, itâs more\r\noptimal to charge at day using bounses, but in initial solution because\r\nand ). Letâs call that day and by lemma3 is not fractional day. Letâs\r\nconsider 4 cases now:: (). Letâs consider a solution with and . Itâs\r\ncorrect and still optimal, but .: (). Same as case1.: (). Letâs consider\r\n2 subcases:: is not last interesting day. Let be next interesting day.\r\nIt consider a solution spending bonuses at day , bonuses at days and .\r\nItâs still correct and optimal, but . If consider a solution a spending\r\nbonuses at day , bonuses at day and bonuses at day . Itâs correct and\r\noptimal too, and too.: is last interesting day. Letâs construct solution\r\nthis way. At first letâs set and . Then letâs iterate over all\r\nineteresting days after , say , in order in increasing time and set . If\r\nafter this process we still have some bonus left just add it to . At the\r\nend, will be equal because we spent all bonuses, solution will still be\r\ncorrect and optimal, but .: (). Let be last day before with . If\r\nconsider a solution with . Itâs correct, optimal and for each . If ,\r\nconsider a solution with . Itâs correct, optimal and for each , too.So\r\nfor all cases we can make correct and optimal solution such there is no\r\nfor all , or number of first day with increases, but it canât increase\r\nforever, so after some amount of opereations solution with for all will\r\nbe constructed.Because of this fact we can consider dynamic programming\r\napproach described before but notice, that we should consider only\r\nstates with . It will have complexity. Moreover, looking at states with\r\nis required. Itâs possible to make a test on which solution, that looks\r\nat states with will be incorrect.\r\n",
    "hint": []
}