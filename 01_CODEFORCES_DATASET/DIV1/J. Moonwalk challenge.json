{"link": "https://codeforces.com//contest/1045/problem/J", "problemId": "223472", "problem_idx": "J", "shortId": "1045J", "contest_number": "1045", "problem_submissions": {"E": [43261410, 43577517], "J": [43258702, 43260133, 43575980, 43263093, 43266033], "A": [43255060, 43256216, 43263322, 43263783, 43258806, 43275613], "D": [43251490, 43264794, 43257475, 43253807, 43257410, 43253327, 43248880], "C": [43250229, 43244156, 43255852, 43252661, 43258515, 43251235, 43259397], "G": [43247867, 43248087, 43251069, 43250948, 43255077, 43249900, 43251360], "H": [43246289, 43252595, 43260022, 43258468, 43261064, 43264435, 43263084], "B": [43243648, 43248788, 43247063, 43264324, 43264189, 43246587, 43256450, 43248333, 43254638], "I": [43243009, 43244706, 43243112, 43242671, 43255452, 43243089, 43243594], "F": [43577952]}, "name": "J. Moonwalk challenge", "statement": "Since astronauts from BubbleCup XI mission finished their mission on the\r\nMoon and are big fans of famous singer, they decided to spend some fun\r\ntime before returning to the Earth and hence created a so called\r\n\"Moonwalk challenge\" game.Teams of astronauts are given the map of\r\ncraters on the Moon and direct bidirectional paths from some craters to\r\nothers that are safe for \"Moonwalking\". Each of those direct paths is\r\ncolored in one color and there is unique path between each two craters.\r\nGoal of the game is to find two craters such that given array of colors\r\nappears most times as continuous subarray on the path between those two\r\ncraters (overlapping appearances should be counted).To help your\r\nfavorite team win, you should make a program that, given the map,\r\nanswers the queries of the following type: For two craters and array of\r\ncolors answer how many times given array appears as continuous subarray\r\non the path from the first crater to the second.Colors are represented\r\nas lowercase English alphabet letters.\r\n", "solutions": ["#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nusing hsh = ull;\nconst int MAXN = 120000;\nconst int LOG = 20;\nconst hsh P = 23917;\n\nint n;\nvector<pair<int, char>> eds[MAXN];\nint aa[MAXN];\nint bb[MAXN];\nstring s[MAXN];\nint up[MAXN][LOG];\nchar pc[MAXN];\nint tm1;\nint tin[MAXN];\nint tout[MAXN];\nint h[MAXN];\n\nvoid dfs1(int v, int p) {\n\ttin[v] = tm1++;\n\tup[v][0] = p;\n\tfor (int i = 1; i < LOG; ++i)\n\t\tup[v][i] = up[up[v][i - 1]][i - 1];\n\tfor (auto e: eds[v]) {\n\t\tif (e.first == p)\n\t\t\tcontinue;\n\t\th[e.first] = h[v] + 1;\n\t\tpc[e.first] = e.second;\n\t\tdfs1(e.first, v);\n\t}\n\ttout[v] = tm1;\n}\n\nbool is_p(int a, int b) {\n\treturn tin[a] <= tin[b] && tin[b] < tout[a];\n}\n\nint lca(int a, int b) {\n\tif (is_p(a, b))\n\t\treturn a;\n\tif (is_p(b, a))\n\t\treturn b;\n\tfor (int i = LOG - 1; i >= 0; --i) {\n\t\tif (!is_p(up[a][i], b))\n\t\t\ta = up[a][i];\n\t}\n\treturn up[a][0];\n}\n\nint goup(int a, int h) {\n\tfor (int i = LOG - 1; i >= 0; --i) {\n\t\tif (h >= (1 << i))\n\t\t\th -= (1 << i), a = up[a][i];\n\t}\n\treturn a;\n}\n\nhsh geths(const string &s) {\n\thsh hs = 0;\n\tfor (int i = 0; i < s.size(); ++i)\n\t\ths = hs * P + s[i];\n\treturn hs;\n}\n\nhsh pw[MAXN];\nint ans[MAXN];\nvector<hsh> vv;\nvector<tuple<hsh, int, int>> go[MAXN];\n\nvoid add(int v, hsh hs, int k, int d) {\n\tgo[v].emplace_back(hs, k, d);\n}\n\nint lst[MAXN * 2];\nint cc[MAXN * 2];\nvector<char> st;\n\nvoid dfs2(int v, int p) {\n\tif (v != 0)\n\t\tst.push_back(pc[v]);\n\tvector<pair<int, int>> undo;\n\thsh hs = 0;\n\tfor (int i = (int)st.size() - 1; i >= 0 && i >= (int)st.size() - 100; --i) {\n\t\ths = hs * P + st[i];\n\t\tint pos = lower_bound(ALL(vv), hs) - vv.begin();\n\t\tif (pos == vv.size() || vv[pos] != hs)\n\t\t\tcontinue;\n\t\tundo.emplace_back(pos, lst[pos]);\n\t\t++cc[pos];\n\t}\n\n\tfor (auto q: go[v]) {\n\t\thsh hs; int k, d;\n\t\ttie(hs, k, d) = q;\n\t\tint pos = lower_bound(ALL(vv), hs) - vv.begin();\n\t\tif (pos == vv.size() || vv[pos] != hs)\n\t\t\tcontinue;\n\t\tans[k] += d * cc[pos];\n\t}\n\tfor (auto e: eds[v]) {\n\t\tif (e.first == p)\n\t\t\tcontinue;\n\t\tdfs2(e.first, v);\n\t}\n\n\tfor (auto p: undo) {\n\t\t--cc[p.first];\n\t\tlst[p.first] = p.second;\n\t}\n\tif (v != 0)\n\t\tst.pop_back();\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tpw[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tpw[i] = (pw[i - 1] * P);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tchar c;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\tcin >> c;\n\t\teds[a].emplace_back(b, c);\n\t\teds[b].emplace_back(a, c);\n\t}\n\tdfs1(0, 0);\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tcin >> aa[i] >> bb[i];\n\t\t--aa[i], --bb[i];\n\t\tcin >> s[i];\n\t\tint x = lca(aa[i], bb[i]);\n\t\tint a = aa[i];\n\t\tint b = bb[i];\n\t\tint ga = a;\n\t\tif (h[a] - h[x] > s[i].size() - 1)\n\t\t\tga = goup(a, h[a] - h[x] - (s[i].size() - 1));\n\t\tint gb = b;\n\t\tif (h[b] - h[x] > s[i].size() - 1)\n\t\t\tgb = goup(b, h[b] - h[x] - (s[i].size() - 1));\n\t\tstring s2;\n\t\tstring tmp;\n\t\tint cur = ga;\n\t\twhile (cur != x)\n\t\t\ts2 += pc[cur], cur = up[cur][0];\n\t\tcur = gb;\n\t\twhile (cur != x)\n\t\t\ttmp += pc[cur], cur = up[cur][0];\n\t\treverse(ALL(tmp));\n\t\ts2 += tmp;\n\t\thsh hs = geths(s[i]);\n\t\tif (s2.size() >= s[i].size()) {\n\t\t\thsh now = 0;\n\t\t\tfor (int j = 0; j < s[i].size(); ++j)\n\t\t\t\tnow = now * P + s2[j];\n\t\t\tif (now == hs)\n\t\t\t\t++ans[i];\n\t\t\tfor (int j = s[i].size(); j < s2.size(); ++j) {\n\t\t\t\tnow = now * P + s2[j];\n\t\t\t\tnow -= pw[s[i].size()] * s2[j - s[i].size()];\n\t\t\t\tif (now == hs)\n\t\t\t\t\t++ans[i];\n\t\t\t}\n\t\t}\n\t\tvv.push_back(hs);\n\t\tadd(a, hs, i, 1);\n\t\tadd(ga, hs, i, -1);\n\t\treverse(ALL(s[i]));\n\t\ths = geths(s[i]);\n\t\tvv.push_back(hs);\n\t\tadd(b, hs, i, 1);\n\t\tadd(gb, hs, i, -1);\n\t}\n\tsort(ALL(vv));\n\tvv.resize(unique(ALL(vv)) - vv.begin());\n\tfor (int i = 0; i < vv.size(); ++i)\n\t\tlst[i] = -1, cc[i] = 0;\n\tdfs2(0, -1);\n\tfor (int i = 0; i < q; ++i)\n\t\tcout << ans[i] << \"\\n\";\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["data structures", "strings", "trees"], "dificulty": "2600", "interactive": false}