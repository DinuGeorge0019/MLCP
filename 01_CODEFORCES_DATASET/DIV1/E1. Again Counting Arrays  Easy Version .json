{
    "link": "https://codeforces.com//contest/1967/problem/E1",
    "problemId": "2620324",
    "problem_idx": "E1",
    "shortId": "1967E1",
    "contest_number": "1967",
    "problem_submissions": {
        "E2": [
            258916135,
            258921598,
            280919018,
            283055351,
            258925888,
            258925224,
            258926598,
            259116859,
            258926070,
            258925546,
            259722295,
            258957419
        ],
        "E1": [
            258904834,
            258921659,
            258894575,
            258912226,
            258903044,
            258906344,
            258912831,
            258915891,
            258918877,
            258922310,
            259006535,
            258965622,
            258951459,
            258945783,
            258913874,
            258917530,
            258919711,
            258921338,
            258917617,
            258919765,
            259722116,
            258915462,
            258933640,
            258908305,
            258913393,
            258909598
        ],
        "D": [
            258893511,
            258891796,
            258909116,
            258896081,
            258913757,
            258931804,
            258897887,
            258899842,
            258900877,
            258900605,
            258900883,
            258903500,
            258906692,
            258903262,
            258903546,
            258905322,
            258906645,
            259721880,
            258919184,
            258918997,
            258920966,
            258894127
        ],
        "C": [
            258884312,
            258885547,
            258878790,
            258885577,
            258886778,
            258891500,
            258888513,
            258894435,
            258891427,
            258888089,
            258895759,
            258890296,
            258893524,
            258896216,
            258896443,
            258888021,
            258883737,
            258891226,
            258889628,
            258879732
        ],
        "B2": [
            258880311,
            258879319,
            258874379,
            258880426,
            258874860,
            258887764,
            258882431,
            258886567,
            258994245,
            258885903,
            258878827,
            258889665,
            258882193,
            258884237,
            258880372,
            258891352,
            258877071,
            258876977,
            258886917,
            258884212
        ],
        "B1": [
            258869431,
            258871590,
            258870854,
            258865105,
            258869777,
            258876404,
            258873073,
            258874727,
            258869407,
            258874121,
            258875290,
            258873932,
            258869896,
            258873122,
            258871143,
            258871635,
            258872574,
            258874952,
            258869924,
            258867671
        ],
        "A": [
            258865187,
            258866636,
            258865467,
            258874287,
            258866222,
            258865534,
            258866742,
            258868436,
            258867130,
            258868014,
            258872371,
            258870129,
            258865415,
            258868641,
            258868839,
            258866810,
            258868141,
            258871863,
            258867322,
            258865436
        ],
        "F": [
            283293514,
            273029197
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129027",
    "editorial": "It can be easily proven that for a given , we can always try to get the\r\nlargest from to one by one. A perceptual understanding is that if not\r\nso, we can\u00e2\u0080\u0099t escape from some gap in either.Thus, it\u00e2\u0080\u0099s easy to get a\r\nsolution: Let be, in the optimal determination progress, the ways of .\r\nThe transition is easy, and it reminds us that s always add to answers\r\nwith straightly without continuing to transmit.There is a solution that\r\nsolves the above grid path counting problem with NTT. It can pass this\r\nversion of the problem, but it is not that useful for the hard\r\nversion.However, we strongly suggest you read the following part as it\r\nreveals the solution in the hard version. It currently works in , but in\r\nfact, it runs much faster than the polylog one.Try to modify the\r\nsolution so that it works in .Consider the simplified version: You have\r\ntwo lines and in a Cartesian coordinate system. You are at and you want\r\nto move to . Each move is or . You are not allowed to get onto the\r\npoints on the two lines. Count the number of ways to get to .We will\r\nintroduce a classical solution.Then, for each invalid path, we enumerate\r\nthe end position where , and after that, simply conduct the process (you\r\njust need to change some parameters).Now, we get a solution, which\r\nshould be fast enough to pass.: If there is only one line , we can do\r\nlike what we have done in solving the grid path counting problem, which\r\nultimately yields one of the general term formulas for Catalan\r\nnumbers.Remind that the key part is to flip by the line to . Thus, for\r\neach invalid path (It touches at least once ), if we flip all the way\r\nfrom the last time it touches the line to , then it uniquely corresponds\r\nto a path starting from the origin, and finally arriving at .For the\r\nanswer to the problem with two lines , , we perform the\r\ninclusion-exclusion principle (aka. the reflection method). Let\u00e2\u0080\u0099s denote\r\nas touching , as touching .An invalid path can, for example, be\r\nexplained as . From the experiment in solving the previous problem, we\r\nshrink into (That is, to replace each with , and each with ).Then we can\r\ncalculate the answer as, . refers to flip by the characters in in order.\r\nFor example, is, flip by first , then , then again, and count the paths\r\nfrom the origin to . And actually refers to all the invalid schemes\r\ncontaining the pattern which are the borderlines a path touches in\r\norder.There are non-zero terms, each term is a combinatorial number. So\r\nthe overall time complexity is .\r\n",
    "name": "E1. Again Counting Arrays  Easy Version ",
    "statement": "Little R has counted many sets before, and now she decides to count\r\narrays.Little R thinks an array b_0,\r\nldots, b_n consisting of non-negative integers is if and only if, for\r\neach i such that 1\r\nleq i\r\nleq n,\r\nlvert b_i - b_{i-1}\r\nrvert = 1 is satisfied. She likes continuity, so she only wants to\r\ngenerate continuous arrays.If Little R is given b_0 and a_1,\r\nldots, a_n, she will try to generate a non-negative continuous array b,\r\nwhich has no similarity with a. More formally, for all 1\r\nleq i\r\nleq n, a_i\r\nneq b_i holds.However, Little R does not have any array a. Instead, she\r\ngives you n, m and b_0. She wants to count the different integer arrays\r\na_1,\r\nldots, a_n satisfying: 1\r\nleq a_i\r\nleq m; At least one non-negative continuous array b_0,\r\nldots, b_n can be generated. Since the actual answer may be enormous,\r\nplease just tell her the answer modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 30.04.2024 11:45:08**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0template <typename T>T inverse(T a, T m) {  T u = 0, v = 1;  while (a != 0) {    T t = m / a;    m -= t * a; swap(a, m);    u -= t * v; swap(u, v);  }  assert(m == 1);  return u;}\u00a0template <typename T>class Modular { public:  using Type = typename decay<decltype(T::value)>::type;\u00a0  constexpr Modular() : value() {}  template <typename U>  Modular(const U& x) {    value = normalize(x);  }\u00a0  template <typename U>  static Type normalize(const U& x) {    Type v;    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);    else v = static_cast<Type>(x % mod());    if (v < 0) v += mod();    return v;  }\u00a0  const Type& operator()() const { return value; }  template <typename U>  explicit operator U() const { return static_cast<U>(value); }  constexpr static Type mod() { return T::value; }\u00a0  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }  Modular& operator++() { return *this += 1; }  Modular& operator--() { return *this -= 1; }  Modular operator++(int) { Modular result(*this); *this += 1; return result; }  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }  Modular operator-() const { return Modular(-value); }\u00a0  template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));    return *this;  }  template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());    value = normalize(value * rhs.value - q * mod());    return *this;  }  template <typename U = T>  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(value * rhs.value);    return *this;  }\u00a0  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\u00a0  friend const Type& abs(const Modular& x) { return x.value; }\u00a0  template <typename U>  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\u00a0  template <typename U>  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\u00a0  template <typename V, typename U>  friend V& operator>>(V& stream, Modular<U>& number);\u00a0 private:  Type value;};\u00a0template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\u00a0template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\u00a0template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\u00a0template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\u00a0template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\u00a0template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\u00a0template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\u00a0template<typename T, typename U>Modular<T> power(const Modular<T>& a, const U& b) {  assert(b >= 0);  Modular<T> x = a, res = 1;  U p = b;  while (p > 0) {    if (p & 1) res *= x;    x *= x;    p >>= 1;  }  return res;}\u00a0template <typename T>bool IsZero(const Modular<T>& number) {  return number() == 0;}\u00a0template <typename T>string to_string(const Modular<T>& number) {  return to_string(number());}\u00a0// U == std::ostream? but done this way because of fastoutputtemplate <typename U, typename T>U& operator<<(U& stream, const Modular<T>& number) {  return stream << number();}\u00a0// U == std::istream? but done this way because of fastinputtemplate <typename U, typename T>U& operator>>(U& stream, Modular<T>& number) {  typename common_type<typename Modular<T>::Type, long long>::type x;  stream >> x;  number.value = Modular<T>::normalize(x);  return stream;}\u00a0/*using ModType = int;\u00a0struct VarMod { static ModType value; };ModType VarMod::value;ModType& md = VarMod::value;using Mint = Modular<VarMod>;*/\u00a0constexpr int md = 998244353;using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\u00a0vector<Mint> fact(1, 1);vector<Mint> inv_fact(1, 1);\u00a0Mint C(int n, int k) {  if (k < 0 || k > n) {    return 0;  }  while ((int) fact.size() < n + 1) {    fact.push_back(fact.back() * (int) fact.size());    inv_fact.push_back(1 / fact.back());  }  return fact[n] * inv_fact[k] * inv_fact[n - k];}\u00a0template <typename T>class NTT { public:  using Type = typename decay<decltype(T::value)>::type;\u00a0  static Type md;  static Modular<T> root;  static int base;  static int max_base;  static vector<Modular<T>> roots;  static vector<int> rev;\u00a0  static void clear() {    root = 0;    base = 0;    max_base = 0;    roots.clear();    rev.clear();  }\u00a0  static void init() {    md = T::value;    assert(md >= 3 && md % 2 == 1);    auto tmp = md - 1;    max_base = 0;    while (tmp % 2 == 0) {      tmp /= 2;      max_base++;    }    root = 2;    while (power(root, (md - 1) >> 1) == 1) {      root++;    }    assert(power(root, md - 1) == 1);    root = power(root, (md - 1) >> max_base);    base = 1;    rev = {0, 1};    roots = {0, 1};  }\u00a0  static void ensure_base(int nbase) {    if (md != T::value) {      clear();    }    if (roots.empty()) {      init();    }    if (nbase <= base) {      return;    }    assert(nbase <= max_base);    rev.resize(1 << nbase);    for (int i = 0; i < (1 << nbase); i++) {      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));    }    roots.resize(1 << nbase);    while (base < nbase) {      Modular<T> z = power(root, 1 << (max_base - 1 - base));      for (int i = 1 << (base - 1); i < (1 << base); i++) {        roots[i << 1] = roots[i];        roots[(i << 1) + 1] = roots[i] * z;      }      base++;    }  }\u00a0  static void fft(vector<Modular<T>> &a) {    int n = (int) a.size();    assert((n & (n - 1)) == 0);    int zeros = __builtin_ctz(n);    ensure_base(zeros);    int shift = base - zeros;    for (int i = 0; i < n; i++) {      if (i < (rev[i] >> shift)) {        swap(a[i], a[rev[i] >> shift]);      }    }    for (int k = 1; k < n; k <<= 1) {      for (int i = 0; i < n; i += 2 * k) {        for (int j = 0; j < k; j++) {          Modular<T> x = a[i + j];          Modular<T> y = a[i + j + k] * roots[j + k];          a[i + j] = x + y;          a[i + j + k] = x - y;        }      }    }  }\u00a0  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {    if (a.empty() || b.empty()) {      return {};    }    int eq = (a == b);    int need = (int) a.size() + (int) b.size() - 1;    int nbase = 0;    while ((1 << nbase) < need) nbase++;    ensure_base(nbase);    int sz = 1 << nbase;    a.resize(sz);    b.resize(sz);    fft(a);    if (eq) b = a; else fft(b);    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);    for (int i = 0; i < sz; i++) {      a[i] *= b[i] * inv_sz;    }    reverse(a.begin() + 1, a.end());    fft(a);    a.resize(need);    return a;  }};\u00a0template <typename T> typename NTT<T>::Type NTT<T>::md;template <typename T> Modular<T> NTT<T>::root;template <typename T> int NTT<T>::base;template <typename T> int NTT<T>::max_base;template <typename T> vector<Modular<T>> NTT<T>::roots;template <typename T> vector<int> NTT<T>::rev;\u00a0template <typename T>vector<Modular<T>> inverse(const vector<Modular<T>>& a) {  assert(!a.empty());  int n = (int) a.size();  vector<Modular<T>> b = {1 / a[0]};  while ((int) b.size() < n) {    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));    x.resize(b.size() << 1);    b.resize(b.size() << 1);    vector<Modular<T>> c = b;    NTT<T>::fft(c);    NTT<T>::fft(x);    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());    for (int i = 0; i < (int) x.size(); i++) {      x[i] *= c[i] * inv;    }    reverse(x.begin() + 1, x.end());    NTT<T>::fft(x);    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());    fill(x.begin() + (x.size() >> 1), x.end(), 0);    NTT<T>::fft(x);    for (int i = 0; i < (int) x.size(); i++) {      x[i] *= c[i] * inv;    }    reverse(x.begin() + 1, x.end());    NTT<T>::fft(x);    for (int i = 0; i < ((int) x.size() >> 1); i++) {      b[i + ((int) x.size() >> 1)] = -x[i];    }  }  b.resize(n);  return b;}\u00a0template <typename T>vector<Modular<T>> inverse_old(vector<Modular<T>> a) {  assert(!a.empty());  int n = (int) a.size();  if (n == 1) {    return {1 / a[0]};  }  int m = (n + 1) >> 1;  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));  int need = n << 1;  int nbase = 0;  while ((1 << nbase) < need) {    ++nbase;  }  NTT<T>::ensure_base(nbase);  int size = 1 << nbase;  a.resize(size);  b.resize(size);  NTT<T>::fft(a);  NTT<T>::fft(b);  Modular<T> inv = 1 / static_cast<Modular<T>>(size);  for (int i = 0; i < size; ++i) {    a[i] = (2 - a[i] * b[i]) * b[i] * inv;  }  reverse(a.begin() + 1, a.end());  NTT<T>::fft(a);  a.resize(n);  return a;}\u00a0template <typename T>vector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {  if (a.empty() || b.empty()) {    return {};  }  if (min(a.size(), b.size()) < 150) {    vector<Modular<T>> c(a.size() + b.size() - 1, 0);    for (int i = 0; i < (int) a.size(); i++) {      for (int j = 0; j < (int) b.size(); j++) {        c[i + j] += a[i] * b[j];      }    }    return c;  }  return NTT<T>::multiply(a, b);}\u00a0template <typename T>vector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {  return a = a * b;}\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n, m, b0;    cin >> n >> m >> b0;    if (b0 >= m || b0 >= n) {      cout << power(Mint(m), n) << '\\n';      continue;    }    auto orig_m = m;    auto inv = (orig_m == 1 ? 0 : 1 / Mint(orig_m - 1));    vector<Mint> pw(n + 1);    vector<Mint> pw_m(n + 1);    vector<Mint> inv_pw(n + 1);    pw[0] = 1;    pw_m[0] = 1;    inv_pw[0] = 1;    for (int i = 1; i <= n; i++) {      pw[i] = pw[i - 1] * (orig_m - 1);      pw_m[i] = pw_m[i - 1] * orig_m;      inv_pw[i] = inv_pw[i - 1] * inv;    }    m = min(m, b0 + n + 1);    Mint ans = 0;    vector<Mint> dp(m);    dp[b0] = 1;    while (n > 0) {      int steps = min(n, m);      vector<Mint> p(2 * steps + 1);      for (int i = 0; i <= steps; i++) {        p[2 * i] = C(steps, i) * pw[i];      }      auto prod = dp * p;      vector<Mint> new_dp(m);      for (int i = 0; i < int(prod.size()); i++) {        int at = i - steps;        if (at < 0) {          continue;        }        if (at >= m) {          ans += prod[i] * pw_m[n - steps];          continue;        }        new_dp[at] += prod[i];        {          int fake = 2 * m - at;          if (fake + steps >= 0 && fake + steps < int(prod.size())) {            auto sub = prod[fake + steps];            sub *= inv_pw[(fake - at) / 2];            ans += sub * pw_m[n - steps];            new_dp[at] -= sub;          }        }        {          int fake = -2 - at;          if (fake + steps >= 0 && fake + steps < int(prod.size())) {            auto sub = prod[fake + steps];            sub *= pw[(at - fake) / 2];            new_dp[at] -= sub;          }        }      }      swap(dp, new_dp);      n -= steps;    }    ans += accumulate(dp.begin(), dp.end(), Mint(0));    cout << ans << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E1. Again Counting Arrays  Easy Version .json"
}