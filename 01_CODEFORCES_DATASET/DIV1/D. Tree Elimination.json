{
    "link": "https://codeforces.com//contest/1276/problem/D",
    "problemId": "495591",
    "problem_idx": "D",
    "shortId": "1276D",
    "contest_number": "1276",
    "problem_submissions": {
        "D": [
            66855093,
            66857065,
            66845974,
            66997276,
            66858540,
            66861684,
            66862730,
            66868898,
            66866703,
            66862266,
            66863710,
            66863337,
            66865506,
            66863170,
            66863353,
            66867792,
            66869234,
            66868492,
            66866182,
            66863049
        ],
        "C": [
            66843940,
            66846263,
            66855304,
            66856299,
            66850349,
            66850097,
            66849241,
            66845111,
            66840733,
            66851808,
            66846583,
            66853445,
            66848190,
            66854997,
            66857353,
            66855797,
            66855510,
            66860652,
            66856100,
            66851090
        ],
        "B": [
            66838883,
            66837202,
            66851887,
            66837950,
            66845504,
            66843521,
            66841052,
            66839337,
            66846582,
            66845011,
            66837082,
            66842169,
            66845204,
            66846655,
            66853297,
            66842949,
            66842748,
            66847818,
            66847458,
            66873447,
            66868214
        ],
        "A": [
            66836393,
            66834386,
            66848931,
            66834574,
            66835090,
            66834499,
            66835628,
            66834748,
            66844259,
            66835765,
            66834448,
            66836891,
            66834649,
            66835369,
            66834624,
            66839341,
            66838551,
            66839846,
            66837852,
            66838233
        ],
        "F": [
            66875333,
            66866989,
            68039784,
            67198171,
            67466141
        ],
        "E": [
            93753835,
            67190434,
            67455260,
            81662494
        ]
    },
    "name": "D. Tree Elimination",
    "statement": "Vasya has a tree with n vertices numbered from 1 to n, and n - 1 edges\r\nnumbered from 1 to n - 1. Initially each vertex contains a token with\r\nthe number of the vertex written on it.Vasya plays a game. He considers\r\nall edges of the tree by increasing of their indices. For every edge he\r\nacts as follows: If both endpoints of the edge contain a token, remove a\r\ntoken from one of the endpoints and write down its number. Otherwise, do\r\nnothing.The result of the game is the sequence of numbers Vasya has\r\nwritten down. Note that there may be many possible resulting sequences\r\ndepending on the choice of endpoints when tokens are removed.Vasya has\r\nplayed for such a long time that he thinks he exhausted all possible\r\nresulting sequences he can obtain. He wants you to verify him by\r\ncomputing the number of distinct sequences modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define N_ 201000\n#define pii pair<int,int>\nusing namespace std;\nint n, pL[N_];\nlong long Mod = 998244353;\nvector<pii>E[N_];\nvector<int>D[N_];\nlong long S1[N_], S2[N_], Back[N_], SS[N_];\nvoid DFS(int a, int pp) {\n\tvector<int>Ch;\n\tfor (auto &t : E[a]) {\n\t\tif (t.second == pp)continue;\n\t\tpL[t.second] = t.first;\n\t\tDFS(t.second, a);\n\t\tCh.push_back(t.second);\n\t}\n\tD[a].resize(E[a].size() + 1);\n\tint sz = E[a].size();\n\tif (Ch.empty()) {\n\t\tD[a][0] = 1;\n\t\tD[a][sz] = 1;\n\t}\n\telse {\n\t\tBack[sz] = 1;\n\t\tfor (int j = sz - 1; j >= 0; j--) {\n\t\t\tBack[j] = Back[j + 1];\n\t\t\tif (E[a][j].second != pp) Back[j] = Back[j] * S2[E[a][j].second] % Mod;\n\t\t}\n\t\tlong long ss = 1;\n\t\tfor (int j = 0; j < sz; j++) {\n\t\t\tint x = E[a][j].second;\n\t\t\tif (x == pp) {\n\t\t\t\tD[a][j] = ss * Back[j + 1] % Mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tD[a][j] = ss * (SS[x] - S1[x] + Mod)%Mod * Back[j + 1] % Mod;\n\t\t\t\tss = ss * S1[x] % Mod;\n\t\t\t}\n\t\t}\n\t\tD[a][sz] = ss;\n\t}\n\tfor (int i = 0; i <= sz; i++) {\n\t\tif (i<sz && E[a][i].first <= pL[a]) {\n\t\t\tS1[a] = (S1[a] + D[a][i]) % Mod;\n\t\t}\n\t\tSS[a] = (SS[a] + D[a][i]) % Mod;\n\t\tif (i < sz && E[a][i].second == pp)continue;\n\t\tS2[a] = (S2[a] + D[a][i]) % Mod;\n\t}\n}\nint main() {\n\tint i, a, b;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back({ i,b });\n\t\tE[b].push_back({ i,a });\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tsort(E[i].begin(), E[i].end());\n\t}\n\tDFS(1, 0);\n\tlong long res = 0;\n\tfor (i = 0; i <= E[1].size(); i++) {\n\t\tres = (res + D[1][i]) % Mod;\n\t}\n\tprintf(\"%lld\\n\", res);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Tree Elimination.json",
    "editorial_link": "https://codeforces.com//blog/entry/72239",
    "editorial": "First of all, counting different sequences is the same as counting the number of different playbacks of the elimination process (that is, different combinations of which token was removed on each step). Indeed, if we consider any resulting sequence, we can simulate the process and unambiguously determine which endpoint got its token removed on any step, skipping steps when no tokens can be removed.\n\nTo count different playbacks, we will use subtree dynamic programming. Let us consider a vertex v\n, and forget about all edges not incident to any vertex that is not in a subtree of v\n; that is, we are only considering edges in the subtree of v\n, as well as the edge between v\n and its parent p\n (for convenience, assume that the root vertex has an edge with index n\n to a \"virtual\" parent). Note that we assume that p\n can not be eliminated by means other than considering its edge to v\n.\n\nAs a shorthand, we will say \"v\n was compared with u\n\" to mean \"when the edge (v,u)\n was considered, both its endpoints had their token\", and \"v\n was killed by u\n\" to mean \"v\n was compared with u\n and lost its token on that step\".\n\nWe will distinguish three types of playbacks in v\n's subtree:\n\nv\n was killed before comparing to p\n (situation 0\n);\nv\n was killed by p\n (situation 1\n);\nv\n killed p\n (situation 2\n).\nWe will write dpv,s\n the number of playbacks in the subtree of v\n that correspond to the situation s\n.\n\nLet u1,\u0085,uk\n be the list of children of v\n ordered by increasing of index(ui,v)\n, and let d\n be the largest index such that index(ud,v)<index(v,p)\n. If index(u1,v)>index(v,p)\n, put d=0\n.\n\nLet us work out the recurrence relations for dpv,s\n. For example, for s=0\n we must have that v\n was killed by one of its children ui\n with i?d\n. For a fixed i\n, the playback should have proceeded as follows:\n\nall children u1,\u0085,ui\n were either killed before comparing to v\n, or killed by v\n (but they could not have survived comparing with v\n).\nv\n was killed by ui\n;\nall children ui+1,\u0085,uk\n were either killed before comparing to v\n, or \"survived\" the non-existent comparison to v\n (but they could not have been killed by v\n).\nConsequently, we have the formula\ndpv,0=?i=1d(?j=1i=1(dpuj,0+dpuj,1)\u00d7dpui,1\u00d7?j=i+1k(dpuj,0+dpuj,2)).\n\nArguing in a similar way, we can further obtain\n\ndpv,1=?j=1i=d(dpuj,0+dpuj,1)\u00d7?j=d+1k(dpuj,0+dpuj,2),\n\ndpv,2=?i=d+1k(?j=1i=1(dpuj,0+dpuj,1)\u00d7dpui,1\u00d7?j=i+1k(dpuj,0+dpuj,2))+?j=1k(dpuj,0+dpuj,1).\n\nIn all these formulas we naturally assume that empty products are equal to 1\n.\n\nTo compute these formulas fast enough we can use prefix products of dpj,0+dpj,1\n and suffix products of dpj,0+dpj,2\n. Finally, the answer is equal to dproot,0+dproot,1\n (either the root was killed, or it wasn't and we assume that it was killed by its virtual parent).\n\nThis solution can implemented in O(n)\n since the edges are already given by increasing of their indices, but O(nlogn)\n should also be enough."
}