{
    "link": "https://codeforces.com//contest/1086/problem/C",
    "problemId": "273653",
    "problem_idx": "C",
    "shortId": "1086C",
    "contest_number": "1086",
    "problem_submissions": {
        "F": [
            47429292,
            47449995,
            47444202
        ],
        "E": [
            47422474,
            47423961,
            47424550,
            47426933,
            47428109,
            47426232,
            47427511,
            47426695,
            47427218,
            47427849,
            47427630,
            47511510,
            47428346,
            47425158,
            47429712,
            47428661,
            47421857,
            47429322,
            47440462,
            63950917
        ],
        "D": [
            47415205,
            47413571,
            47418835,
            47417078,
            47414191,
            47418078,
            47418526,
            47419686,
            47418954,
            47419229,
            47421725,
            47466322,
            47418774,
            47416004,
            47420225,
            47422460,
            47411471,
            47420807,
            47421473,
            47423600,
            47420881
        ],
        "C": [
            47410346,
            47408923,
            47412203,
            47411518,
            47409578,
            47407257,
            47412943,
            47414708,
            47412730,
            47413883,
            47416006,
            47414439,
            47428921,
            47417547,
            47419740,
            47412059,
            47415581,
            47415787
        ],
        "B": [
            47402010,
            47400574,
            47400073,
            47401453,
            47402762,
            47411548,
            47405929,
            47406096,
            47405616,
            47407353,
            47404186,
            47400750,
            47404258,
            47404681,
            47402882,
            47426003,
            47408582,
            47404099,
            47404538,
            47406586
        ],
        "A": [
            47400483,
            47400094,
            47413170,
            47400357,
            47400599,
            47410258,
            47403179,
            47403378,
            47401193,
            47402951,
            47401486,
            47403915,
            47400561,
            47403260,
            47400323,
            47425175,
            47409292,
            47400702,
            47401450,
            47402988
        ]
    },
    "name": "C. Vasya and Templates",
    "statement": "Vasya owns three strings s , a and b, each of them consists only of\r\nfirst k Latin letters.Let a template be such a string of length k that\r\neach of the first k Latin letters appears in it exactly once (thus there\r\nare k! distinct templates). Application of template p to the string s is\r\nthe replacement of each character in string s with p_i, i is the index\r\nof this letter in the alphabet. For example, applying template \"\" to a\r\nstring \"\" yields string \"\".Vasya wants to know if there exists such a\r\ntemplate which yields a string lexicographically greater than or equal\r\nto string a and lexicographically less than or equal to string b after\r\napplying it to s.If there exist multiple suitable templates, print any\r\nof them.String a is lexicographically less than string b if there is\r\nsome i (1\r\nle i\r\nle n) that a_i < b_i and for any j (1\r\nle j < i) a_j = b_j.You are required to answer t testcases .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct Testcase {\n  string s, a, b;\n  int K;\n  string mapping;\n  vector<bool> taken;\n\n  bool Bt(int pos, bool is_a, bool is_b) {\n    debug(pos, is_a, is_b);\n    if (pos == SZ(s) || (!is_a && !is_b)) {\n      return true;\n    }\n\n    bool new_ch = true;\n    char min_ch = is_a ? a[pos] : 'a';\n    char max_ch = is_b ? b[pos] : 'a' + K - 1;\n    if (mapping[s[pos] - 'a']) {\n      const char val_new_ch = mapping[s[pos] - 'a'];\n      if (val_new_ch < min_ch || val_new_ch > max_ch) { return false; }\n      min_ch = max_ch = val_new_ch;\n      new_ch = false;\n    }\n    for (char ch = min_ch; ch <= max_ch; ++ch) {\n      if (new_ch) {\n        if (taken[ch - 'a']) { continue; }\n        taken[ch - 'a'] = true;\n        mapping[s[pos] - 'a'] = ch;\n      }\n\n      if (Bt(pos + 1, is_a && ch == a[pos], is_b && ch == b[pos])) {\n        return true;\n      }\n\n      if (new_ch) {\n        taken[ch - 'a'] = false;\n        mapping[s[pos] - 'a'] = 0;\n      }\n    }\n\n    return false;\n  }\n\n  void Run() {\n    cin >> K >> s >> a >> b;\n    mapping.resize(K);\n    taken.resize(K);\n\n    if (Bt(0, true, true)) {\n      cout << \"YES\\n\";\n\n      string unused;\n      for (int i = 0; i < K; ++i)\n        if (!taken[i]) {\n          unused += 'a' + i;\n        }\n\n      for (char &ch : mapping) {\n        if (!ch) {\n          ch = unused.back();\n          unused.pop_back();\n        }\n      }\n      cout << mapping << \"\\n\";\n    } else {\n      cout << \"NO\\n\";\n    }\n  }\n};\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int T;\n  cin >> T;\n  for (int i = 0; i < T; ++i)\n    Testcase().Run();\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Vasya and Templates.json",
    "editorial_link": "https://codeforces.com//blog/entry/64078",
    "editorial": "Letâs implement the following strategy: obtain the minimal string which\r\nis greater than or equal to to correspond to at least one template. If\r\nthere exists such a string and it is less than or equal to then the\r\nanswer exists, otherwise itâs not.Letâs iterate over the length of\r\nprefix of the answer , which equals the prefix of . For some fixed\r\nlength we can restore some part of the template. For example, let prefix\r\nof be \"\" and prefix of be \"\", template will then look like \"\". Also\r\nsometimes prefix can have no answer.Now we want to expand the prefix\r\nwith some character at position . If that character had appeared\r\nalready, then the substitute is known. Also if the substitute is less\r\nthan then the resulting string will be less than , so it will be\r\nincorrect. If it equals then put it and proceed to position . And if\r\nitâs greater then the resulting string will be greater than , so the\r\nrest of the string can be filled greedily, minimizing the resulting\r\nstring .If character hadnât appeared previously, then letâs try all\r\npossible character to substitute it (let it be some character ). That\r\ncharacter should be greater than or equal to and it shouldnât be already\r\ntaken. If is greater then , then the rest of the string can be filled\r\ngreedily, minimizing the resulting string . Otherwise itâs and we\r\nproceed to position .Itâs easy to show that the greedy filling will be\r\nperformed no more than times, thus the solution will work in .\r\n",
    "hint": []
}