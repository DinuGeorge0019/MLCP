{"link": "https://codeforces.com//contest/1161/problem/F", "problemId": "339903", "problem_idx": "F", "shortId": "1161F", "contest_number": "1161", "problem_submissions": {"F": [53909371, 114209812, 53863200], "E": [53757964, 53756987, 53756569, 53759204, 53758710, 53758335, 53759423, 53759655, 53759053, 53758599, 53760097, 53761659, 53757322, 53759810], "D": [53752102, 53753035, 53753793, 53751800, 53753429, 53754722, 87768256, 53755219, 53754639, 53755997, 53749499, 53756338, 53756778, 53758722, 53757091, 53754786, 53751937, 53753965, 53753805, 53754929], "C": [53750364, 53751704, 53751645, 53749841, 53749214, 53750926, 53751458, 53755261, 53754114, 53751399, 53756883, 53754076, 53759235, 53760202, 53749644, 53749593, 53751107, 53750858], "B": [53748059, 53750584, 53750568, 53748260, 53748334, 53748600, 53749151, 53749091, 53748293, 53760218, 53747945, 53749635, 53748265, 53747869, 53748914, 53748572, 53749307, 53749491], "A": [53746899, 53747514, 53747934, 53746630, 53746650, 53747171, 53747667, 53746731, 53746977, 53759102, 53746696, 53748269, 53748575, 53751158, 53747184, 53746584, 53747125, 53747652]}, "name": "F. Zigzag Game", "statement": "You are given a complete bipartite graph with 2n nodes, with n nodes on\r\neach side of the bipartition. Nodes 1 through n are on one side of the\r\nbipartition, and nodes n+1 to 2n are on the other side. You are also\r\ngiven an n\r\ntimes n matrix a describing the edge weights. a_{ij} denotes the weight\r\nof the edge between nodes i and j+n. Each edge has a distinct\r\nweight.Alice and Bob are playing a game on this graph. First Alice\r\nchooses to play as either \"increasing\" or \"decreasing\" for herself, and\r\nBob gets the other choice. Then she places a token on any node of the\r\ngraph. Bob then moves the token along any edge incident to that node.\r\nThey now take turns playing the following game, with Alice going\r\nfirst.The current player must move the token from the current vertex to\r\nsome adjacent unvisited vertex. Let w be the last weight of the last\r\nedge that was traversed. The edge that is traversed must be strictly\r\ngreater than w if the player is playing as \"increasing\", otherwise, it\r\nmust be strictly less. The first player unable to make a move loses.You\r\nare given n and the edge weights of the graph. You can choose to play as\r\neither Alice or Bob, and you will play against the judge. You must win\r\nall the games for your answer to be judged correct.\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint t,n,a[50][50], partner[101];\nvi pref[101];\nint ord[101][101];\n\nvoid makeStable() {\n    vi cool; FOR(i,1,n+1) cool.pb(i);\n    while (sz(cool)) {\n        int x = cool.back(); cool.pop_back();\n        trav(t,pref[x]) {\n            if (!partner[t]) {\n                partner[x] = t, partner[t] = x;\n                break;\n            }\n            if (ord[t][x] < ord[t][partner[t]]) {\n                partner[partner[t]] = 0; cool.pb(partner[t]);\n                partner[x] = t, partner[t] = x;\n                break;\n            }\n        }\n    }\n}\n\nvoid solve() {\n    re(n);\n    F0R(i,n) F0R(j,n) re(a[i][j]);\n    FOR(i,1,2*n+1) {\n        pref[i].clear();\n        partner[i] = 0;\n    }\n    cout << \"B\" << endl;\n    char c; re(c);\n    if (c == 'D') {\n        F0R(i,n) F0R(j,n) a[i][j] *= -1;\n    }\n    int st; re(st);\n    if (st <= n) {\n        // <= n prefers smaller \n        FOR(i,1,n+1) {\n            FOR(j,n+1,2*n+1) pref[i].pb(j);\n            sort(all(pref[i]),[&i](int x, int y) { return a[i-1][x-n-1] < a[i-1][y-n-1]; });\n        }\n        // > n prefers greater\n        FOR(i,n+1,2*n+1) {\n            FOR(j,1,n+1) pref[i].pb(j);\n            sort(all(pref[i]),[&i](int x, int y) { return a[x-1][i-n-1] > a[y-1][i-n-1]; });\n        }\n    } else {\n        // <= n prefers greater\n        FOR(i,1,n+1) {\n            FOR(j,n+1,2*n+1) pref[i].pb(j);\n            sort(all(pref[i]),[&i](int x, int y) { return a[i-1][x-n-1] > a[i-1][y-n-1]; });\n        }\n        // > n prefers smaller\n        FOR(i,n+1,2*n+1) {\n            FOR(j,1,n+1) pref[i].pb(j);\n            sort(all(pref[i]),[&i](int x, int y) { return a[x-1][i-n-1] < a[y-1][i-n-1]; });\n        } \n    }\n    FOR(i,1,2*n+1) F0R(j,sz(pref[i])) ord[i][pref[i][j]] = j;\n    makeStable();\n    /*FOR(i,1,2*n+1) ps(i,partner[i]);\n    exit(0);*/\n    while (1) {\n        st = partner[st];\n        cout << st << endl;\n        re(st); if (st < 0) return;\n    }\n}\n\nint main() {\n    re(t);\n    F0R(i,t) solve();\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"], "input": "", "output": "", "tags": ["games", "interactive"], "dificulty": "3500", "interactive": false}