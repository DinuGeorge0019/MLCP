{"link": "https://codeforces.com//contest/434/problem/D", "problemId": "9715", "problem_idx": "D", "shortId": "434D", "contest_number": "434", "problem_submissions": {"D": [6699538, 6706635, 6706622, 6706591, 6706589, 6795823, 6704699, 6708335, 6707919], "C": [6697907, 6699177, 6698487, 6699311, 6699392, 6797515, 6797483, 6718935, 6697269, 6700102, 6699851, 6696039, 6700493, 6700403, 6700591, 6698358, 6698258, 6700561, 6698389], "B": [6695587, 6696287, 6694622, 6695678, 6696514, 6695797, 6699364, 6695860, 6695864, 6699676, 6699377, 6696715, 6697097, 6695263, 6696899, 6700084, 6700621, 6697368, 6695731], "A": [6692446, 6694191, 6692438, 6693456, 6692853, 6692909, 6693769, 6692709, 6691931, 6694014, 6700765, 6693088, 6694404, 6692737, 6695761, 6695148, 6698289, 6693859, 6708768], "E": [6711897]}, "name": "D. Nanami s Power Plant", "statement": "Nanami likes playing games, and is also really good at it. This day she\r\nwas playing a new game which involved operating a power plant. Nanami\u2019s\r\njob is to control the generators in the plant and produce maximum\r\noutput.There are generators in the plant. Each generator should be set\r\nto a generating level. Generating level is an integer (possibly zero or\r\nnegative), the generating level of the -th generator should be between\r\nand (both inclusive). The output of a generator can be calculated using\r\na certain quadratic function , where is the generating level of the\r\ngenerator. Each generator has its own function, the function of the -th\r\ngenerator is denoted as .However, there are further restrictions to the\r\ngenerators. Let the generating level of the -th generator be . Each\r\nrestriction is of the form , where and are IDs of two different\r\ngenerators and is an integer.Nanami found the game tedious but giving up\r\nis against her creed. So she decided to have a program written to\r\ncalculate the answer for her (the maximum total output of generators).\r\nSomehow, this became your job.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\nconst int INF = ~0U >> 1;\n\ntemplate<class Flow>\nstruct Maxflow {\n\tstatic const Flow INF = ~0U >> 1; //should change with type\n//\tstatic const Flow INF = numeric_limits<Flow>::max();\n\tstruct Edge {\n\t\tint t;\n\t\tFlow c;\n\t\tEdge*n, *r;\n\t\tEdge(int _t, Flow _c, Edge*_n) :\n\t\t\t\tt(_t), c(_c), n(_n) {\n\t\t}\n\t};\n\tvector<Edge*> E;\n\n\tint addV() {\n\t\tE.push_back((Edge*) 0);\n\t\treturn E.size() - 1;\n\t}\n\n\tvoid clear() {\n\t\tE.clear();\n\t}\n\n\tEdge* makeEdge(int s, int t, Flow c) {\n\t\treturn E[s] = new Edge(t, c, E[s]);\n\t}\n\n\tvoid addEdge(int s, int t, Flow c) {\n\t\tEdge*e1 = makeEdge(s, t, c), *e2 = makeEdge(t, s, 0);\n\t\te1->r = e2, e2->r = e1;\n\t}\n\n\tint calcMaxFlow(int vs, int vt) {\n\t\tint nV = E.size();\n\t\tFlow totalFlow = 0;\n\n\t\tvector<Flow> am(nV, 0);\n\t\tvector<int> h(nV, 0), cnt(nV + 1, 0);\n\t\tvector<Edge*> prev(nV, (Edge*) 0), cur(nV, (Edge*) 0);\n\t\tcnt[0] = nV;\n\n\t\tint u = vs;\n\t\tEdge*e;\n\t\tam[u] = INF;\n\t\twhile (h[vs] < nV) {\n\t\t\tfor (e = cur[u]; e; e = e->n)\n\t\t\t\tif (e->c > 0 && h[u] == h[e->t] + 1)\n\t\t\t\t\tbreak;\n\t\t\tif (e) {\n\t\t\t\tint v = e->t;\n\t\t\t\tcur[u] = prev[v] = e;\n\t\t\t\tam[v] = min(am[u], e->c);\n\t\t\t\tu = v;\n\t\t\t\tif (u == vt) {\n\t\t\t\t\tFlow by = am[u];\n\t\t\t\t\twhile (u != vs) {\n\t\t\t\t\t\tprev[u]->c -= by;\n\t\t\t\t\t\tprev[u]->r->c += by;\n\t\t\t\t\t\tu = prev[u]->r->t;\n\t\t\t\t\t}\n\t\t\t\t\ttotalFlow += by;\n\t\t\t\t\tam[u] = INF;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!--cnt[h[u]])\n\t\t\t\t\tbreak;\n\t\t\t\th[u] = nV;\n\t\t\t\tfor (e = E[u]; e; e = e->n)\n\t\t\t\t\tif (e->c > 0 && h[e->t] + 1 < h[u]) {\n\t\t\t\t\t\th[u] = h[e->t] + 1;\n\t\t\t\t\t\tcur[u] = e;\n\t\t\t\t\t}\n\t\t\t\t++cnt[h[u]];\n\t\t\t\tif (u != vs)\n\t\t\t\t\tu = prev[u]->r->t;\n\t\t\t}\n\t\t}\n\n\t\treturn totalFlow;\n\t}\n\n\t~Maxflow() {\n\t\tfor (int i = 0; i < E.size(); ++i) {\n\t\t\tfor (Edge*e = E[i]; e;) {\n\t\t\t\tEdge*ne = e->n;\n\t\t\t\tdelete e;\n\t\t\t\te = ne;\n\t\t\t}\n\t\t}\n\t}\n};\n\nMaxflow<int> net;\nint n, m;\nconst int MAX_N = 50 + 1, MAX_M = 100 + 1;\nint a[MAX_N], b[MAX_N], c[MAX_N];\n\nconst int BIG = int(3e5);\nconst int MX = 110;\n\nvector<int> id[MAX_N];\nint l[MAX_M], r[MAX_M];\nint vs, vt;\n\nint eval(int i, int x) {\n\treturn (a[i] * x + b[i]) * x + c[i];\n}\n\nint get(int u, int i) {\n\tif (i < -MX || i > MX)\n\t\treturn -1;\n\treturn id[u][i + MX];\n}\n\nvoid addEdge(int u, int i, int v, int j) {\n\tint x = get(u, i), y = get(v, j);\n\tif (x == -1 || y == -1)\n\t\treturn;\n\tnet.addEdge(x, y, INF);\n}\n\nvoid constraint(int u, int v, int d) {\n\t//X_u \\ge X_v +d\n\tfor (int i = -MX; i <= MX; ++i) {\n\t\taddEdge(v, i, u, i + d);\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tvs = net.addV(), vt = net.addV();\n\tfor (int me = 0; me < n; ++me) {\n\t\tint tot = MX * 2 + 2; //[-100,100]\n\n\t\tvector<int>&v = id[me];\n\t\tfor (int j = 0; j < tot; ++j) {\n\t\t\tv.push_back(net.addV());\n\t\t}\n\t\tnet.addEdge(vs, v[0], INF);\n\t\tfor (int i = -MX; i <= MX; ++i) {\n\t\t\tif (i >= l[me] && i <= r[me])\n\t\t\t\tnet.addEdge(v[i + MX], v[i + MX + 1], BIG - eval(me, i));\n\t\t\telse\n\t\t\t\tnet.addEdge(v[i + MX], v[i + MX + 1], INF);\n\t\t}\n\t\tnet.addEdge(v.back(), vt, INF);\n\t}\n\twhile (m--) {\n\t\tint u, v, d;\n\t\tcin >> u >> v >> d;\n\t\t--u, --v;\n\t\tconstraint(v, u, -d);\n\t}\n\tint ans = BIG * n - net.calcMaxFlow(vs, vt);\n\tcout << ans << endl;\n}\n"], "input": "", "output": "", "tags": ["flows"], "dificulty": "2900", "interactive": false}