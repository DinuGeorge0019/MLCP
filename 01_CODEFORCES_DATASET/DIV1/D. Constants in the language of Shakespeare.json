{
    "link": "https://codeforces.com//contest/132/problem/D",
    "problemId": "709",
    "problem_idx": "D",
    "shortId": "132D",
    "contest_number": "132",
    "problem_submissions": {
        "E": [
            925463,
            924045,
            926495,
            927129,
            930757,
            927949,
            927053
        ],
        "B": [
            923684,
            925104,
            927721,
            923959,
            924110,
            922324,
            922978,
            923016,
            925081,
            924882,
            922141,
            926108,
            923013,
            925452,
            925520,
            925045,
            926157,
            926077
        ],
        "D": [
            922457,
            922554,
            924871,
            922974,
            924948,
            924454,
            924331,
            923366,
            923651,
            925293,
            923560,
            925565,
            922791,
            924076,
            923184,
            923568,
            923999
        ],
        "C": [
            920611,
            921352,
            922698,
            921318,
            922939,
            921777,
            922465,
            921286,
            921687,
            923127,
            921959,
            921893,
            920032,
            922242,
            921743,
            922634,
            922920
        ],
        "A": [
            919809,
            919078,
            921073,
            919691,
            920209,
            919403,
            919950,
            919419,
            920157,
            919937,
            920116,
            920376,
            920930,
            921451,
            922067,
            920124,
            920860
        ]
    },
    "name": "D. Constants in the language of Shakespeare",
    "statement": "Shakespeare is a widely known esoteric programming language in which\r\nprograms look like plays by Shakespeare, and numbers are given by\r\ncombinations of ornate epithets. In this problem we will have a closer\r\nlook at the way the numbers are described in Shakespeare.Each constant\r\nin Shakespeare is created from non-negative powers of 2 using arithmetic\r\noperations. For simplicity we’ll allow only addition and subtraction and\r\nwill look for a representation of the given number which requires a\r\nminimal number of operations.You are given an integer . You have to\r\nrepresent it as , where each of is a non-negative power of 2, possibly\r\nmultiplied by -1. Find a representation which minimizes the value of .\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:65777216\")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nchar s[1111111];\nint  n;\nint main(){\n#ifdef LocalHost\n\n    freopen(\"input.txt\",\"r\",stdin);\n//  freopen(\"output.txt\",\"w\",stdout);\n#endif\n\t\n\tgets(s);\n\tn = strlen(s);\n\tll rrr=0;\n\tREP(i,n) rrr=rrr*2+(s[i]-'0');\n\n\tvector<pii> r;\n\tvector<pii> v;\n\tint res = 0;\n\tREP(i,n){\n\t\tint dig = s[i]-'0';\n\t\tif(v.size() && v.back().first==dig) v.back().second++;\n\t\telse v.pb(pii(dig,1));\n\t}\n\tvector<pii> w;\n\tswap(v,w);\n\n\tint sm=0;\n\tREP(i,w.size()){\n\t\tpii curr = w[i];\n\t\tsm += curr.second;\n\t\tif(v.size() && v.back().first==0 && v.back().second==1 && (curr.second>1 || v.size()>1 && v[v.size()-2].second>1)){\n\t\t\tv.pop_back();\n\t\t\tv.back().second++;\n\t\t\tv.back().second+=curr.second;\n\t\t\tr.pb(pii(0,n-(sm-curr.second)));\n\t\t}else v.pb(curr);\n\t}\n\n\tint sum=0;\n\tREP(i,v.size()){\n\t\tif(v[i].first==1){\n\t\t\tif(v[i].second==1){\n\t\t\t\tr.pb(pii(1,n-sum-1));\n\t\t\t}else{\n\t\t\t\tr.pb(pii(1,n-sum));\n\t\t\t\tr.pb(pii(0,n-sum-v[i].second));\n\t\t\t}\n\t\t}\n\t\tsum += v[i].second;\n\t}\n\tcout<<r.size()<<endl;\n\tll t = 0;\n\tREP(i,r.size()){\n\t\t//if(r[i].first) t += 1ll<<r[i].second;\n\t\t//else t-=1ll<<r[i].second;\n\t\tprintf(\"%c2^%d\\n\",r[i].first?'+':'-',r[i].second);\n\t}\n\n\t\n#ifdef LocalHost\n    cout<<rrr<<' '<<t<<endl;\n\tcout<<endl<<endl<<\"TIME: \"<<clock()<<endl;\n#endif\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Constants in the language of Shakespeare.json",
    "editorial_link": "https://codeforces.com//blog/entry/3302",
    "editorial": "Two last problems of the round were inspired by Shakespeare programming\r\nlanguage. The original idea was to make them one problem \"How to print\r\nthe given sequence using as few adjectives as possible?\". But later we\r\ncame to our senses and split this monster of a problem in two. The\r\nevident greedy solution (break the binary notation into contiguous\r\ngroups of 1s, if the size of the group is 1, write it as a single power,\r\notherwise write it as a difference of two powers) is wrong. You can see\r\nthis from test 4 \"10110111\": the greedy solution will return 5 (), while\r\nitâs possible to find a notation of size 4 (). The correct solution is\r\nbased on the following idea. Let us have a fragment of binary notation\r\nwhich contains bits for powers of 3 between N and M (N < M), inclusive,\r\nwhich has K 0s and L 1s. It can be written as a sum of powers which\r\ncorrespond to positions of 1s, using L powers. Alternatively, it can be\r\nwritten as , where ... are powers which correspond to positions of 0s,\r\nusing 2 + K powers. Itâs evident that using second method makes sense\r\nonly if the fragment starts and ends with 1s (otherwise it can be used\r\nfor shorter fragment without the leading/trailing 0s, and save at least\r\none power on this) and contains no 00 sequence inside (otherwise you can\r\nbreak the fragment into two in place of these 00 and write these\r\nfragments separately with the same or better result). After youâve noted\r\nthis, you can solve the problem using DP: for each position in binary\r\nnotation store the sign \"write it as sum of powers or as difference of\r\npowers\", and in second case store the length of the fragment which is\r\nwritten using difference (storing the length of the fragment which is\r\nwritten using sums only is unnecessary, since this can be done for\r\nindividual bits with the same result as for longer fragments.\r\n",
    "hint": []
}