{"link": "https://codeforces.com//contest/132/problem/D", "problemId": "709", "problem_idx": "D", "shortId": "132D", "contest_number": "132", "problem_submissions": {"E": [925463, 924045, 926495, 927129, 930757, 927949, 927053], "B": [923684, 925104, 927721, 923959, 924110, 922324, 922978, 923016, 925081, 924882, 922141, 926108, 923013, 925452, 925520, 925045, 926157, 926077], "D": [922457, 922554, 924871, 922974, 924948, 924454, 924331, 923366, 923651, 925293, 923560, 925565, 922791, 924076, 923184, 923568, 923999], "C": [920611, 921352, 922698, 921318, 922939, 921777, 922465, 921286, 921687, 923127, 921959, 921893, 920032, 922242, 921743, 922634, 922920], "A": [919809, 919078, 921073, 919691, 920209, 919403, 919950, 919419, 920157, 919937, 920116, 920376, 920930, 921451, 922067, 920124, 920860]}, "name": "D. Constants in the language of Shakespeare", "statement": "Shakespeare is a widely known esoteric programming language in which\r\nprograms look like plays by Shakespeare, and numbers are given by\r\ncombinations of ornate epithets. In this problem we will have a closer\r\nlook at the way the numbers are described in Shakespeare.Each constant\r\nin Shakespeare is created from non-negative powers of 2 using arithmetic\r\noperations. For simplicity we\u2019ll allow only addition and subtraction and\r\nwill look for a representation of the given number which requires a\r\nminimal number of operations.You are given an integer . You have to\r\nrepresent it as , where each of is a non-negative power of 2, possibly\r\nmultiplied by -1. Find a representation which minimizes the value of .\r\n", "solutions": ["#pragma comment(linker, \"/STACK:65777216\")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nchar s[1111111];\nint  n;\nint main(){\n#ifdef LocalHost\n\n    freopen(\"input.txt\",\"r\",stdin);\n//  freopen(\"output.txt\",\"w\",stdout);\n#endif\n\t\n\tgets(s);\n\tn = strlen(s);\n\tll rrr=0;\n\tREP(i,n) rrr=rrr*2+(s[i]-'0');\n\n\tvector<pii> r;\n\tvector<pii> v;\n\tint res = 0;\n\tREP(i,n){\n\t\tint dig = s[i]-'0';\n\t\tif(v.size() && v.back().first==dig) v.back().second++;\n\t\telse v.pb(pii(dig,1));\n\t}\n\tvector<pii> w;\n\tswap(v,w);\n\n\tint sm=0;\n\tREP(i,w.size()){\n\t\tpii curr = w[i];\n\t\tsm += curr.second;\n\t\tif(v.size() && v.back().first==0 && v.back().second==1 && (curr.second>1 || v.size()>1 && v[v.size()-2].second>1)){\n\t\t\tv.pop_back();\n\t\t\tv.back().second++;\n\t\t\tv.back().second+=curr.second;\n\t\t\tr.pb(pii(0,n-(sm-curr.second)));\n\t\t}else v.pb(curr);\n\t}\n\n\tint sum=0;\n\tREP(i,v.size()){\n\t\tif(v[i].first==1){\n\t\t\tif(v[i].second==1){\n\t\t\t\tr.pb(pii(1,n-sum-1));\n\t\t\t}else{\n\t\t\t\tr.pb(pii(1,n-sum));\n\t\t\t\tr.pb(pii(0,n-sum-v[i].second));\n\t\t\t}\n\t\t}\n\t\tsum += v[i].second;\n\t}\n\tcout<<r.size()<<endl;\n\tll t = 0;\n\tREP(i,r.size()){\n\t\t//if(r[i].first) t += 1ll<<r[i].second;\n\t\t//else t-=1ll<<r[i].second;\n\t\tprintf(\"%c2^%d\\n\",r[i].first?'+':'-',r[i].second);\n\t}\n\n\t\n#ifdef LocalHost\n    cout<<rrr<<' '<<t<<endl;\n\tcout<<endl<<endl<<\"TIME: \"<<clock()<<endl;\n#endif\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "greedy"], "dificulty": "2100", "interactive": false}