{
    "link": "https://codeforces.com//contest/1876/problem/E",
    "problemId": "2251949",
    "problem_idx": "E",
    "shortId": "1876E",
    "contest_number": "1876",
    "problem_submissions": {
        "F": [
            227177806,
            227207094,
            227205539,
            227205151
        ],
        "E": [
            227157151,
            227151734,
            227168660,
            227172380,
            227183052,
            227309041,
            227308704,
            227174767,
            227180790,
            227181408,
            227180728,
            227180621,
            227182335,
            227260713,
            227259829,
            227186766,
            227170474,
            227321208,
            227261014
        ],
        "D": [
            227143743,
            227138577,
            227308847,
            227146942,
            227140586,
            227141511,
            227160448,
            227153072,
            227151615,
            227160275,
            227166901,
            227141697,
            227262091,
            227163246,
            227151371,
            227141424,
            227141434,
            227152662,
            227155489,
            227148839,
            227151040,
            227154461
        ],
        "C": [
            227128643,
            227130062,
            227133604,
            227130971,
            227129714,
            227144982,
            227139072,
            227133756,
            227145578,
            227141605,
            227156976,
            227263099,
            227135346,
            227132471,
            227128506,
            227133146,
            227135885,
            227135604,
            227140440,
            227137265
        ],
        "B": [
            227120010,
            227119885,
            227123059,
            227119488,
            227120157,
            227125041,
            227123945,
            227122604,
            227124586,
            227123169,
            227160403,
            227263121,
            227124143,
            227123043,
            227120364,
            227120185,
            227120687,
            227125676,
            227123006,
            227129980,
            227122132
        ],
        "A": [
            227117267,
            227116977,
            227118151,
            227116487,
            227116831,
            227118490,
            227120408,
            227118388,
            227121296,
            227117209,
            227162962,
            227263136,
            227118862,
            227118193,
            227117199,
            227115769,
            227117422,
            227121537,
            227118512,
            227124495,
            227116510
        ],
        "G": [
            227270487,
            229852864,
            229527555
        ]
    },
    "name": "E. Ball-Stackable",
    "statement": "With a problem title like that, there is no way this is going to be a\r\ngraph problem.Chaneka has a graph with n vertices and n-1 edges. Some of\r\nthe edges are directed and some of the edges are undirected. Edge i\r\nconnects vertex u_i to vertex v_i. If t_i=0, edge i is undirected. If\r\nt_i=1, edge i is directed in the direction from u_i to v_i. It is known\r\nthat if you make all edges undirected, the graph becomes a tree^\r\ndagger.Chaneka wants to direct all undirected edges and colour each edge\r\n(different edges can have the same colour).After doing that, suppose\r\nChaneka starts a walk from an arbitrary vertex x to an arbitrary vertex\r\ny (it is possible that x=y) going through one or more edges. She is\r\nallowed to go through each edge either following the direction or\r\nopposite to the direction of the edge. She is also allowed to visit a\r\nvertex or an edge more than once. During the walk, Chaneka maintains a\r\nstack of balls that is initially empty before the walk. Each time\r\nChaneka goes through an edge, she does the following: If Chaneka goes\r\nthrough it in the right direction, she puts a new ball with a colour\r\nthat is the same as the edge\u2019s colour to the top of the stack. If\r\nChaneka goes through it in the opposite direction, she removes the ball\r\nthat is on the top of the stack. A walk is if and only if the stack is\r\nnot empty before each time Chaneka goes through an edge in the opposite\r\ndirection.A walk is if and only if it is stackable and each time Chaneka\r\ngoes through an edge in the opposite direction, the colour of the ball\r\nremoved from the stack is the same as the colour of the edge\r\ntraversed.Is it possible to direct all undirected edges and colour each\r\nedge such that all stackable walks are also ball-stackable? If it is\r\npossible, find a construction example that uses the among all valid ways\r\nof directing and colouring. If there are multiple such solutions, output\r\nany of them.^\r\ndagger A tree is a connected graph with no cycles.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvector<pii> graf[nax];\n\nint ojf[nax];\n\nint fin(int v)\n{\n\tif (v!=ojf[v])\n\t\tojf[v]=fin(ojf[v]);\n\treturn ojf[v];\n}\n\nvoid uni(int a, int b)\n{\n\tojf[fin(a)]=fin(b);\n}\n\nint blok[nax];\nint dpdol[nax];\nint dpgor[nax];\n\nvoid nope()\n{\n\tprintf(\"-1\\n\");\n\texit(0);\n}\n\nvoid dfs1(int v, int oj)\n{\n\tfor (pii i : graf[v])\n\t{\n\t\tblok[v]=max(blok[v], blok[i.first]-1+2*(i.second==2));\n\t\tblok[i.first]=max(blok[i.first], blok[v]-1+2*(i.second==1));\n\t}\n\tfor (pii i : graf[v])\n\t\tif (i.first!=oj)\n\t\t\tdfs1(i.first, v);\n\tfor (pii i : graf[v])\n\t{\n\t\tblok[v]=max(blok[v], blok[i.first]-1+2*(i.second==2));\n\t\tblok[i.first]=max(blok[i.first], blok[v]-1+2*(i.second==1));\n\t}\n}\n\nvoid dfs2(int v, int oj)\n{\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first!=oj)\n\t\t{\n\t\t\tdfs2(i.first, v);\n\t\t\tdpdol[v]+=dpdol[i.first]+(i.second==2);\n\t\t}\n\t}\n}\n\nvoid dfs3(int v, int oj)\n{\n\tfor (pii i : graf[v])\n\t\tif (i.first==oj && i.second==2)\n\t\t\tdpgor[v]++;\n\tint s=dpgor[v];\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first!=oj)\n\t\t{\n\t\t\ts+=dpdol[i.first]+(i.second==2);\n\t\t}\n\t}\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first!=oj)\n\t\t{\n\t\t\tdpgor[i.first]=s-(dpdol[i.first]+(i.second==2));\n\t\t\tdfs3(i.first, v);\n\t\t}\n\t}\n}\n\nvi stos[nax];\n\nint k=0;\n\nvoid dfs4(int v, int oj, int gle)\n{\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first==oj)\n\t\t\tcontinue;\n\t\tif (i.second==2)\n\t\t{\n\t\t\tprintf(\"%d %d %d\\n\", i.first, v, stos[gle-1].back());\n\t\t\tdfs4(i.first, v, gle-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk++;\n\t\t\tprintf(\"%d %d %d\\n\", v, i.first, k);\n\t\t\tstos[gle].push_back(k);\n\t\t\tdfs4(i.first, v, gle+1);\n\t\t\tstos[gle].pop_back();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tif (!c)\n\t\t{\n\t\t\tgraf[a].push_back({b, 0});\n\t\t\tgraf[b].push_back({a, 0});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgraf[a].push_back({b, 1});\n\t\t\tgraf[b].push_back({a, 2});\n\t\t}\n\t}\n\tdfs1(1, 0);\n\tdfs1(1, 0);\n\tdebug() << range(blok+1, blok+1+n);\n\tdfs2(1, 0);\n\tdfs3(1, 0);\n\tdebug() << range(dpdol+1, dpdol+1+n);\n\tdebug() << range(dpgor+1, dpgor+1+n);\n\tint g=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!blok[i] && (g==0 || dpdol[i]+dpgor[i]<dpdol[g]+dpgor[g]))\n\t\t\tg=i;\n\tprintf(\"%d\\n\", n-1-(dpdol[g]+dpgor[g]));\n\tdfs4(g, 0, 0);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dp",
        "trees"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Ball-Stackable.json",
    "editorial_link": "https://codeforces.com//blog/entry/121200",
    "editorial": "Let\u00e2\u0080\u0099s try to solve the problem if all edges are directed.First, assign\r\nsome arbitrary vertex as the root of the tree. Consider all walks that\r\nstart from . Notice that for a fixed vertex , no matter how Chaneka\r\nwalks from , when she reaches , the number of balls in the stack will\r\nalways be the same. More precisely, if in the shortest path from to\r\nthere are edges in the right direction and edges in the opposite\r\ndirection, then the size of the stack in is .For some root , let\u00e2\u0080\u0099s\r\ncalculate the stack size of every vertex using DFS. What happens if the\r\nstack size that is calculated is negative? This conflicts with our\r\nlogic, but let\u00e2\u0080\u0099s ignore them for now.Next, find a vertex with the\r\nminimum stack size (including negative stack sizes). Then, assign this a\r\nthe new root and do the same process to recalculate every stack size.\r\nBecause of the way we choose the new , the newly recalculated stack\r\nsizes will always be non-negative.Consider a path from this root to some\r\nother vertex and go through that path while maintaining a stack of\r\ncolourful balls. Each time we go through an edge in the right direction,\r\nwe add a new ball to the stack, so we have an opportunity to use a new\r\ncolour for the edge (and simultaneously for the new ball). Each time we\r\ngo through an edge in the opposite direction, we remove the ball at the\r\ntop of the stack, so we must colour the edge to be equal to some ball we\r\nadded before (the colour of some previous edge).We can simulate every\r\npath from this root to every other vertex by doing DFS once while\r\nmaintaining a stack. Using the rules above, we get the rules for\r\ncolouring the edges of the graph. In fact, simulating every path from\r\nthis single root already solves the problem with all directed edges,\r\nbecause there are no other relationships between two edges that must\r\nhave the same colour that we have not considered. Remember that we do\r\nnot have to worry about removing from an empty stack because of how we\r\nsmartly choose the root.Notice that using the rules above, each edge\r\nthat is directed away from the root contributes to add one new different\r\ncolour to the colouring while each edge that is directed towards the\r\nroot does not add any new colour. This means we just want to maximize\r\nthe total number of edges that is directed away from the root.We can\r\nexpand this idea for the original problem with undirected edges. We need\r\nto find a root, then direct all undirected edges away from that root\r\nsuch that the number of edges directed away from that root is as many as\r\npossible. This is equivalent to finding a vertex such that the number of\r\ndirected edges (ignoring all undirected edges) that is directed away\r\nfrom that vertex is maximum. This vertex can be found using a simple\r\nDFS. Furthermore, choosing such a vertex will automatically eliminates\r\nnegative stack sizes if we set it as the root.Once we find the optimal\r\nroot and direct the undirected edges, we just do a simulation DFS like\r\nabove to determine the colouring.Time complexity:\r\n"
}