{"link": "https://codeforces.com//contest/1876/problem/E", "problemId": "2251949", "problem_idx": "E", "shortId": "1876E", "contest_number": "1876", "problem_submissions": {"F": [227177806, 227207094, 227205539, 227205151], "E": [227157151, 227151734, 227168660, 227172380, 227183052, 227309041, 227308704, 227174767, 227180790, 227181408, 227180728, 227180621, 227182335, 227260713, 227259829, 227186766, 227170474, 227321208, 227261014], "D": [227143743, 227138577, 227308847, 227146942, 227140586, 227141511, 227160448, 227153072, 227151615, 227160275, 227166901, 227141697, 227262091, 227163246, 227151371, 227141424, 227141434, 227152662, 227155489, 227148839, 227151040, 227154461], "C": [227128643, 227130062, 227133604, 227130971, 227129714, 227144982, 227139072, 227133756, 227145578, 227141605, 227156976, 227263099, 227135346, 227132471, 227128506, 227133146, 227135885, 227135604, 227140440, 227137265], "B": [227120010, 227119885, 227123059, 227119488, 227120157, 227125041, 227123945, 227122604, 227124586, 227123169, 227160403, 227263121, 227124143, 227123043, 227120364, 227120185, 227120687, 227125676, 227123006, 227129980, 227122132], "A": [227117267, 227116977, 227118151, 227116487, 227116831, 227118490, 227120408, 227118388, 227121296, 227117209, 227162962, 227263136, 227118862, 227118193, 227117199, 227115769, 227117422, 227121537, 227118512, 227124495, 227116510], "G": [227270487, 229852864, 229527555]}, "name": "E. Ball-Stackable", "statement": "With a problem title like that, there is no way this is going to be a\r\ngraph problem.Chaneka has a graph with n vertices and n-1 edges. Some of\r\nthe edges are directed and some of the edges are undirected. Edge i\r\nconnects vertex u_i to vertex v_i. If t_i=0, edge i is undirected. If\r\nt_i=1, edge i is directed in the direction from u_i to v_i. It is known\r\nthat if you make all edges undirected, the graph becomes a tree^\r\ndagger.Chaneka wants to direct all undirected edges and colour each edge\r\n(different edges can have the same colour).After doing that, suppose\r\nChaneka starts a walk from an arbitrary vertex x to an arbitrary vertex\r\ny (it is possible that x=y) going through one or more edges. She is\r\nallowed to go through each edge either following the direction or\r\nopposite to the direction of the edge. She is also allowed to visit a\r\nvertex or an edge more than once. During the walk, Chaneka maintains a\r\nstack of balls that is initially empty before the walk. Each time\r\nChaneka goes through an edge, she does the following: If Chaneka goes\r\nthrough it in the right direction, she puts a new ball with a colour\r\nthat is the same as the edge\u2019s colour to the top of the stack. If\r\nChaneka goes through it in the opposite direction, she removes the ball\r\nthat is on the top of the stack. A walk is if and only if the stack is\r\nnot empty before each time Chaneka goes through an edge in the opposite\r\ndirection.A walk is if and only if it is stackable and each time Chaneka\r\ngoes through an edge in the opposite direction, the colour of the ball\r\nremoved from the stack is the same as the colour of the edge\r\ntraversed.Is it possible to direct all undirected edges and colour each\r\nedge such that all stackable walks are also ball-stackable? If it is\r\npossible, find a construction example that uses the among all valid ways\r\nof directing and colouring. If there are multiple such solutions, output\r\nany of them.^\r\ndagger A tree is a connected graph with no cycles.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvector<pii> graf[nax];\n\nint ojf[nax];\n\nint fin(int v)\n{\n\tif (v!=ojf[v])\n\t\tojf[v]=fin(ojf[v]);\n\treturn ojf[v];\n}\n\nvoid uni(int a, int b)\n{\n\tojf[fin(a)]=fin(b);\n}\n\nint blok[nax];\nint dpdol[nax];\nint dpgor[nax];\n\nvoid nope()\n{\n\tprintf(\"-1\\n\");\n\texit(0);\n}\n\nvoid dfs1(int v, int oj)\n{\n\tfor (pii i : graf[v])\n\t{\n\t\tblok[v]=max(blok[v], blok[i.first]-1+2*(i.second==2));\n\t\tblok[i.first]=max(blok[i.first], blok[v]-1+2*(i.second==1));\n\t}\n\tfor (pii i : graf[v])\n\t\tif (i.first!=oj)\n\t\t\tdfs1(i.first, v);\n\tfor (pii i : graf[v])\n\t{\n\t\tblok[v]=max(blok[v], blok[i.first]-1+2*(i.second==2));\n\t\tblok[i.first]=max(blok[i.first], blok[v]-1+2*(i.second==1));\n\t}\n}\n\nvoid dfs2(int v, int oj)\n{\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first!=oj)\n\t\t{\n\t\t\tdfs2(i.first, v);\n\t\t\tdpdol[v]+=dpdol[i.first]+(i.second==2);\n\t\t}\n\t}\n}\n\nvoid dfs3(int v, int oj)\n{\n\tfor (pii i : graf[v])\n\t\tif (i.first==oj && i.second==2)\n\t\t\tdpgor[v]++;\n\tint s=dpgor[v];\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first!=oj)\n\t\t{\n\t\t\ts+=dpdol[i.first]+(i.second==2);\n\t\t}\n\t}\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first!=oj)\n\t\t{\n\t\t\tdpgor[i.first]=s-(dpdol[i.first]+(i.second==2));\n\t\t\tdfs3(i.first, v);\n\t\t}\n\t}\n}\n\nvi stos[nax];\n\nint k=0;\n\nvoid dfs4(int v, int oj, int gle)\n{\n\tfor (pii i : graf[v])\n\t{\n\t\tif (i.first==oj)\n\t\t\tcontinue;\n\t\tif (i.second==2)\n\t\t{\n\t\t\tprintf(\"%d %d %d\\n\", i.first, v, stos[gle-1].back());\n\t\t\tdfs4(i.first, v, gle-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk++;\n\t\t\tprintf(\"%d %d %d\\n\", v, i.first, k);\n\t\t\tstos[gle].push_back(k);\n\t\t\tdfs4(i.first, v, gle+1);\n\t\t\tstos[gle].pop_back();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tif (!c)\n\t\t{\n\t\t\tgraf[a].push_back({b, 0});\n\t\t\tgraf[b].push_back({a, 0});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgraf[a].push_back({b, 1});\n\t\t\tgraf[b].push_back({a, 2});\n\t\t}\n\t}\n\tdfs1(1, 0);\n\tdfs1(1, 0);\n\tdebug() << range(blok+1, blok+1+n);\n\tdfs2(1, 0);\n\tdfs3(1, 0);\n\tdebug() << range(dpdol+1, dpdol+1+n);\n\tdebug() << range(dpgor+1, dpgor+1+n);\n\tint g=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!blok[i] && (g==0 || dpdol[i]+dpgor[i]<dpdol[g]+dpgor[g]))\n\t\t\tg=i;\n\tprintf(\"%d\\n\", n-1-(dpdol[g]+dpgor[g]));\n\tdfs4(g, 0, 0);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "dp", "trees"], "dificulty": "3300", "interactive": false}