{
    "link": "https://codeforces.com//contest/1239/problem/E",
    "problemId": "445273",
    "problem_idx": "E",
    "shortId": "1239E",
    "contest_number": "1239",
    "problem_submissions": {
        "E": [
            63001388,
            63007812,
            63001212,
            62998603,
            62990662,
            63117343,
            63007827,
            63012207,
            63007702,
            63021047,
            63020870,
            63040886
        ],
        "D": [
            62993444,
            63002135,
            62996508,
            63001623,
            62995711,
            62993045,
            63000352,
            62994034,
            62999922,
            62999498,
            63002761,
            62998053,
            63001594,
            63004252,
            63000233,
            63002463,
            63005010,
            63003977,
            62998357
        ],
        "B": [
            62989194,
            62990960,
            62989442,
            62985984,
            62996888,
            63004499,
            62991996,
            62990441,
            62993848,
            62995834,
            62994077,
            62994574,
            62993602,
            63006960,
            62992838,
            62991953,
            62991668,
            63005078
        ],
        "A": [
            62977858,
            62978636,
            62977879,
            62980136,
            62977536,
            62989410,
            62977583,
            62981078,
            62979832,
            62980911,
            62979401,
            62984325,
            62979180,
            62979930,
            62979559,
            62978773,
            62979723,
            62981340,
            62977762,
            62982272
        ],
        "F": [
            63121011,
            63120329,
            63015127,
            63015060,
            63092303,
            63016718,
            63113841,
            63051142
        ],
        "C": [
            62999891,
            62991092,
            62996408,
            62989929,
            62996641,
            62997220,
            62997894,
            63001762,
            62998162,
            62999500,
            63034189,
            62998511,
            62992701,
            62998753,
            62995987,
            62998509,
            62994268
        ]
    },
    "name": "E. Turtle",
    "statement": "Kolya has a turtle and a field of size 2\r\ntimes n. The field rows are numbered from 1 to 2 from top to bottom,\r\nwhile the columns are numbered from 1 to n from left to right.Suppose in\r\neach cell of the field there is a lettuce leaf. The energy value of\r\nlettuce leaf in row i and column j is equal to a_{i,j}. The turtle is\r\ninitially in the top left cell and wants to reach the bottom right cell.\r\nThe turtle can only move right and down and among all possible ways it\r\nwill choose a way, maximizing the total energy value of lettuce leaves\r\n(in case there are several such paths, it will choose any of them).Kolya\r\nis afraid, that if turtle will eat too much lettuce, it can be bad for\r\nits health. So he wants to reorder lettuce leaves in the field, so that\r\nthe energetic cost of leaves eaten by turtle will be minimized.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MOD = 1e9+7;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nint n, tar, mini = INF, minb;\nint arr[60], brr[30];\nchar pcnt[17000000];\nvector<int> lis[27];\nmap<int,int> lo;\n\nint num[27];\nvoid calc(int arr[]) {\n    vector<int> sum(17000000,0);\n    for (int i=1, c=0;c<n;i*=2,c++) {\n        lo[i]=c;\n    }\n    for (int i=0;i<(1<<(n-1));i++) {\n        num[pcnt[i]]++;\n    }\n    for (int i=0;i<n-1;i++) {\n        lis[i].reserve(num[i]+2);\n    }\n    lis[0].push_back(0);\n    for (int i=1;i<(1<<(n-1));i++) {\n        sum[i]=sum[i&(i-1)]+arr[lo[i&-i]];\n        lis[pcnt[i]].push_back(sum[i]);\n    }\n    vector<int>().swap(sum);\n}\n\nvoid calc2(int arr[]) {\n    vector<int> sum(17000000,0);\n    for (int i=1;i<(1<<(n-1));i++) {\n        sum[i]=sum[i&(i-1)]+arr[lo[i&-i]];\n        int t = n-1-pcnt[i];\n        int p = upper_bound(lis[t].begin(),lis[t].end(),tar/2-sum[i])-lis[t].begin();\n        if (p<lis[t].size()) {\n            if (mini>abs(2*(sum[i]+lis[t][p])-tar)) {\n                mini = abs(2*(sum[i]+lis[t][p])-tar);\n                minb = i;\n            }\n        }\n        p--;\n        if (p>=0) {\n            if (mini>abs(2*(sum[i]+lis[t][p])-tar)) {\n                mini = abs(2*(sum[i]+lis[t][p])-tar);\n                minb = i;\n            }\n        }\n    }\n    vector<int>().swap(sum);\n}\n\npii calc3(int arr[]) {\n    int sum = 0;\n    for (int i=0;i<n-1;i++){\n        if (minb>>i&1) {\n            sum += arr[i];\n        }\n    }\n    int t = n-1-pcnt[minb];\n    int p = upper_bound(lis[t].begin(),lis[t].end(),tar/2-sum)-lis[t].begin();\n    if (p<lis[t].size()) {\n        if (mini==abs(2*(sum+lis[t][p])-tar)) {\n            return {t,lis[t][p]};\n        }\n    }\n    p--;\n    if (p>=0) {\n        if (mini==abs(2*(sum+lis[t][p])-tar)) {\n            return {t,lis[t][p]};\n        }\n    }\n}\n\nint calc4(int arr[], int t, int p){\n    vector<int> sum(17000000,0);\n    if (t==0) return 0;\n    for (int i=1;i<(1<<(n-1));i++) {\n        sum[i]=sum[i&(i-1)]+arr[lo[i&-i]];\n        if (pcnt[i]==t&&sum[i]==p) {\n            return i;\n        }\n    }\n    vector<int>().swap(sum);\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=0;i<n*2;i++) scanf(\"%d\",&arr[i]);\n    pcnt[0] = 0;\n    for (int i=1;i<(1<<(n-1));i++) pcnt[i]=pcnt[i&(i-1)]+1;\n    sort(arr,arr+2*n);\n    int t0 = arr[0], t1 = arr[1];\n    for (int i=0;i<2*n-2;i++) arr[i]=arr[i+2];\n    for (int i=0;i<2*n-2;i++) tar+=arr[i];\n    for (int i=0;i<n-1;i++) brr[i]=arr[i+n-1];\n    calc(arr);\n    calc2(brr);\n    pii tmp = calc3(brr);\n    int minb2= calc4(arr,tmp.first,tmp.second);\n    vector<int> ans, ans2;\n    for (int i=0;i<n-1;i++) {\n        if (minb2>>i&1) ans.push_back(arr[i]);\n        else ans2.push_back(arr[i]);\n        if (minb>>i&1) ans.push_back(brr[i]);\n        else ans2.push_back(brr[i]);\n    }\n    sort(ans.begin(),ans.end());\n    sort(ans2.begin(),ans2.end());\n    printf(\"%d \",t0);\n    for (int i=0;i<n-1;i++) printf(\"%d \",ans[i]);\n    printf(\"\\n\");\n    for (int i=n-2;i>=0;i--) printf(\"%d \",ans2[i]);\n    printf(\"%d\\n\",t1);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Turtle.json",
    "editorial_link": "https://codeforces.com/blog/entry/70720",
    "editorial": "Consider that we already fixed the set in the top line and fixed. If we\r\nperform a swap in this situation, the answer will clearly won\u00e2\u0080\u0099t become\r\nworse (some paths are not changing, and some are decreasing).So we can\r\nassume that the first line is sorted, and similarly the second line is\r\nsorted too (but descending).Now let\u00e2\u0080\u0099s think which path the turtle will\r\nchoose. Observe the difference between to paths: Then cost of path minus\r\ncost of path is equal to . increases when increases, decreases,\r\ndecreases, so the discrete derivative increases.Such function looks\r\nlike: So clearly the turtle will choose either the first or the last\r\npath.So now we need to split our set into two of equal size, so that the\r\nmaximum sum is smallest possible.This is a knapsack problem. The states\r\nare the prefix of elements considered, the number of elements taken, the\r\nweight. It works in : it turned out it was inobvious... The corner cells\r\ntake two minimal elements and are not considered in knapsack since they\r\nare contained in all paths. It\u00e2\u0080\u0099s easy to prove that it\u00e2\u0080\u0099s optimal to put\r\nminimal elements in corners.\r\n"
}