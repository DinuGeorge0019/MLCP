{
    "link": "https://codeforces.com//contest/1588/problem/C",
    "problemId": "1186192",
    "problem_idx": "C",
    "shortId": "1588C",
    "contest_number": "1588",
    "problem_submissions": {
        "D": [
            135372629,
            135381098,
            135359109,
            135369800,
            135370088,
            135380867,
            135357823,
            135362201,
            135366407,
            135370846,
            135374380,
            135373580,
            135374295,
            135373419,
            135378493,
            135376601,
            135375978,
            135382040
        ],
        "C": [
            135363142,
            135352112,
            135379109,
            135361010,
            135362653,
            135375549,
            135350810,
            135353082,
            135359513,
            135351205,
            135365941,
            135366190,
            135366197,
            135366261,
            135798161,
            135798159,
            135798156,
            135798153,
            135793795,
            135353318,
            135359719,
            135363580,
            135376282,
            135360557
        ],
        "B": [
            135354041,
            135372942,
            135367733,
            135353235,
            135382607,
            135353847,
            135347088,
            135367644,
            135348462,
            135359847,
            135354086,
            135351940,
            135356516,
            135347194,
            135365557,
            135349342,
            135357424,
            135354885,
            135351181
        ],
        "A": [
            135347972,
            135342643,
            135342911,
            135343015,
            135342760,
            135342918,
            135342730,
            135343666,
            135342808,
            135352544,
            135343056,
            135344466,
            135342657,
            135342700,
            135342859,
            135345441,
            135343145,
            135343927,
            135342677
        ],
        "E": [
            135346443,
            135364189,
            135371530,
            135382787,
            135381160,
            135387683,
            135507210,
            135399676,
            135412491,
            135411131,
            135507958,
            135387301
        ],
        "F": [
            135608326,
            135531498,
            135406993,
            135398120,
            135395364
        ]
    },
    "name": "C. Game with Stones",
    "statement": "Bob decided to take a break from calculus homework and designed a game\r\nfor himself. The game is played on a sequence of piles of stones, which\r\ncan be described with a sequence of integers s_1,\r\nldots, s_k, where s_i is the number of stones in the i-th pile. On each\r\nturn, Bob picks a pair of non-empty adjacent piles i and i+1 and takes\r\none stone from each. If a pile becomes empty, its adjacent piles . The\r\ngame ends when Bob can\u2019t make turns anymore. Bob considers himself a\r\nwinner if at the end all piles are empty.We consider a sequence of piles\r\nif Bob can start with it and win with some sequence of moves.You are\r\ngiven a sequence a_1,\r\nldots, a_n, count the number of subsegments of a that describe a winning\r\nsequence of piles. In other words find the number of segments [l, r] (1\r\nleq l\r\nleq r\r\nleq n), such that the sequence a_l, a_{l+1},\r\nldots, a_r is winning.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 1600;\n\nlint query(int s, int e){\n\tcout << \"? \" << s << \" \" << e << endl;\n\tlint x; cin >> x; return x;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t; cin >> t;\n\twhile(t--){\n\t\tint n; cin >> n;\n\t\tvector<lint> a(n + 1);\n\t\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\t\t// even negated\n\t\tfor(int i = 2; i <= n; i += 2) a[i] *= -1; \n\t\tfor(int i = 1; i <= n; i++) a[i] += a[i - 1];\n\t\tlint ans = 0;\n\t\tvector<pi> cnts;\n\t\tfor(int i = 1; i <= n; i++) cnts.emplace_back(a[i], i);\n\t\tsort(all(cnts));\n\t\tvector<pi> stk[2];\n\t\tfor(int i = n; i; i--){\n\t\t\tpi val(a[i], i);\n\t\t\tif(i % 2 == 0) val.first *= -1;\n\t\t\twhile(sz(stk[i % 2]) && stk[i % 2].back().first >= val.first) stk[i % 2].pop_back();\n\t\t\tstk[i % 2].push_back(val);\n\t\t\tint lastpos = n;\n\t\t\t{\n\t\t\t\tauto l = lower_bound(all(stk[0]), pi(-a[i - 1], -1));\n\t\t\t\tif(l != stk[0].begin()) lastpos = min(lastpos, (int)prev(l)->second - 1);\n\t\t\t}\t\n\t\t\t{\n\n\t\t\t\tauto l = lower_bound(all(stk[1]), pi(a[i - 1], -1));\n\t\t\t\tif(l != stk[1].begin()) lastpos = min(lastpos, (int)prev(l)->second - 1);\n\t\t\t}\n\t\t\t/*\n\t\t\t   for(int j = i; j <= n; j++){\n\t\t\t   if(j % 2 == 0 && a[j] > a[i - 1]) break;\n\t\t\t   if(j % 2 == 1 && a[j] < a[i - 1]) break;\n\t\t\t   lastpos = j;\n\t\t\t}*/\n\t\t\tauto s = lower_bound(all(cnts), pi(a[i - 1], i));\n\t\t\tauto e = upper_bound(all(cnts), pi(a[i - 1], lastpos));\n\t\t\tans += e - s;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "games",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Game with Stones.json",
    "editorial_link": "https://codeforces.com//blog/entry/96953",
    "editorial": "This game has greedy strategy: look at first pile, all its stones have to be matched with stones from next pile, because it is its only adjacent pile. If pile is non-empty and there are no next pile, or next pile is smaller than current, Bob loses. Otherwise, Bob makes current pile empty, and remove corresponding number of stones from next pile. Now Bob plays the same game as if had one pile less, we can remove first pile without changing game. Bob wins if at the moment he reduced game to one pile it's already empty.\n\nNow let's iteratively define array c\n, where ci\n \u0097 number of stones left in the i\n-th after removing 1,\u0085,i?1\n piles, according to greedy strategy. Let c0=0\n, then ci=ai?ci?1\n.\n\nIf array contains only positive numbers, then it means that Bob is able to remove piles all the way over. Otherwise, let t\n be the first moment with ct<0\n, this means that Bob was able to remove piles until he meet t\n-th pile and ct?1>at\n happened, so Bob loses. To check that last pile is empty, we need to check if cn=0\n.\n\nSo we have criteria of winning subsequence: ci?0\n for all i\n, cn=0\n.\n\nLet's expand recursive notation of ci\n: ci=ai?ai?1+ai?2?\u0085+(?1)i?1?a1\n.\n\nWe will solve problem separately for different l\n \u0097 left bound of subsegment. Let's define sequence al:=al,al+1\u0085an\n, ali=al+i?1\n. It has similar array cl\n. We will find first position of negative number in cl\n \u0097t\n (clt<0\n). And then count how may zeros are on prefix [1\n, t?1\n]. This will give us number of winning subsegemtns with form [l,r]\n, sum over all l\n will give us answer for the problem.\n\nNote, that cli=ali?ali?1+\u0085+(?1)i?1?al1=al+i?1?al+i?2+\u0085+(?1)i?1?al=cl+i?1+(?1)i?1?cl?1\n.\n\nNote, that cli<0\n if and only if cl+i?1<(?1)i?1?cl?1\n. Let's divide problem by parity of indexes. Now to find first position of negative number in cl\n we should find first position of \"number less than x\" on suffix of c\n. This can be done many ways, for example, by descending through segment tree (segment tree for each parity).\n\nNote, that cli=0\n, if and only if cl+i?1=(?1)i?1?cl?1\n. Same division of problem by parity. Now to count number of zeros on subsegment of cl\n we should count number of \"equals to x\" on subsegment of c\n. This can be done by storing all positions of each ci\n in some container (one for each parity) and binnary search."
}