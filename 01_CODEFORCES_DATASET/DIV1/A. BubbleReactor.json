{"link": "https://codeforces.com//contest/1218/problem/A", "problemId": "412333", "problem_idx": "A", "shortId": "1218A", "contest_number": "1218", "problem_submissions": {"D": [60648151, 60643203, 60647260, 60645392, 60642748], "H": [60644806, 60638524], "E": [60642127, 60641056, 60641513, 60643564, 60648498], "I": [60640334, 60639607, 60640474, 60637390, 60638678], "F": [60638215, 60637531, 60635942, 60636552, 60636479], "C": [60637983, 60674902, 60648025], "B": [60648802], "A": [60645770]}, "name": "A. BubbleReactor", "statement": "You are in charge of the BubbleReactor. It consists of N BubbleCores\r\nconnected with N lines of electrical wiring. Each electrical wiring\r\nconnects two distinct BubbleCores. There are no BubbleCores connected\r\nwith more than one line of electrical wiring.Your task is to start the\r\nBubbleReactor by starting each BubbleCore. In order for a BubbleCore to\r\nbe started it needs to be receiving power from a directly connected\r\nBubbleCore which is already started. However, you can kick-start one\r\nBubbleCore manually without needing power. It is guaranteed that all\r\nBubbleCores can be started.Before the BubbleCore boot up procedure its\r\npotential is calculated as the number of BubbleCores it can power on\r\n(the number of inactive BubbleCores which are connected to it directly\r\nor with any number of inactive BubbleCores in between, itself\r\nincluded)Start the BubbleReactor so that the sum of all BubbleCores\u2019\r\npotentials is maximum.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 3e4 + 5;\nVI slo[N];\nint vis[N];\nVI stos;\nint on_cyc[N];\nVI cyc;\nvoid Dfs1(int v, int par) {\n  vis[v] = 1;\n  stos.PB(v);\n  for (auto nei : slo[v]) {\n    if (nei == par) { continue; }\n    if (vis[nei]) {\n      FORD (ind, SZ(stos) - 1, 0) {\n        cyc.PB(stos[ind]);\n        on_cyc[stos[ind]] = 1;\n        if (stos[ind] == nei) {\n          throw 1;\n        }\n      }\n    }\n    Dfs1(nei, v);\n  }\n  stos.pop_back();\n}\nint sz[N];\nint sum_szs[N];\nvoid Dfs2(int v) {\n  sz[v] = 1;\n  for (auto nei : slo[v]) {\n    if (on_cyc[nei]) { continue; }\n    if (sz[nei]) { continue; }\n    Dfs2(nei);\n    sum_szs[v] += sum_szs[nei];\n    sz[v] += sz[nei];\n  }\n  sum_szs[v] += sz[v];\n}\nint res[N];\nint n;\nvoid Dfs3(int v) {\n  for (auto nei : slo[v]) {\n    if (on_cyc[nei]) { continue; }\n    if (res[nei]) { continue; }\n    res[nei] = res[v] + n - 2 * sz[nei];\n    Dfs3(nei);\n  }\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  cin>>n;\n  RE (i, n) {\n    int a, b;\n    cin>>a>>b;\n    a++;\n    b++;\n    slo[a].PB(b);\n    slo[b].PB(a);\n  }\n  try {\n    Dfs1(n, 0);\n  } catch (...) {\n  }\n  RE (i, n) {\n    debug(i, on_cyc[i]);\n  }\n  \n  VI szs;\n  int bonus = 0;\n  for (auto v : cyc) {\n    Dfs2(v);\n    bonus += sum_szs[v] - sz[v];\n    szs.PB(sz[v]);\n  }\n  for (auto v : cyc) {\n    szs.PB(sz[v]);\n  }\n  VI dp(SZ(szs));\n  for (auto v : cyc) {\n    szs.PB(sz[v]);\n  }\n  debug(cyc);\n  debug(szs);\n  dp.insert(dp.begin(), 0);\n  VI pref_sum = szs;\n  RE (i, SZ(pref_sum) - 1) {\n    pref_sum[i] += pref_sum[i - 1];\n  }\n  FOR (len, 1, SZ(cyc) - 1) {\n    debug(dp);\n    VI ndp(SZ(dp) - 1);\n    REP (i, SZ(dp) - 1) {\n      ndp[i] = pref_sum[i + len] - pref_sum[i] + max(dp[i], dp[i + 1]);\n    }\n    dp = ndp;\n  }\n  debug(dp);\n  REP (i, SZ(cyc)) {\n    int v = cyc[i];\n    res[v] = dp[i] + bonus + n;\n    Dfs3(v);\n    debug(v, res[v]);\n  }\n  int best = 0;\n  RE (i, n) {\n    maxi(best, res[i]);\n    debug(i, res[i]);\n  }\n  cout<<best<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "graphs"], "dificulty": "2800", "interactive": false}