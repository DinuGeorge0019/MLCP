{"link": "https://codeforces.com//contest/455/problem/C", "problemId": "12119", "problem_idx": "C", "shortId": "455C", "contest_number": "455", "problem_submissions": {"E": [7394351, 7390143, 7393335, 7395556, 15950366, 7394387, 7394798], "D": [7390969, 7390195, 7391117, 7392248, 7394913, 7394348, 7389780, 7389657, 7393511, 7427462, 7392513, 7396567], "C": [7383856, 7385374, 7383929, 7385253, 7385742, 7386825, 7385353, 7386072, 7389234, 7384477, 7386261, 7393242, 7386556, 148174431, 7387128, 7390044, 7381535, 7386375, 7388516, 7385462], "B": [7380394, 7383005, 7381184, 7382059, 7379729, 7383546, 7382905, 7382344, 7384255, 7398378, 7387760, 7396316, 7385727, 7384109, 7413972, 7384883, 7405728, 7405656, 7398462, 7398419, 7381057], "A": [7377249, 7377722, 7377369, 7377768, 7390843, 7377960, 7377218, 7378095, 7377940, 7377402, 7377315, 7378476, 7377536, 7377288, 7378601, 7384879, 7385848, 7377439, 7377794]}, "name": "C. Civilization", "statement": "Andrew plays a game called \"Civilization\". Dima helps him.The game has\r\ncities and bidirectional roads. The cities are numbered from to .\r\nBetween any pair of cities there either is a single (unique) path, or\r\nthere is no path at all. A path is such a sequence of distinct cities ,\r\nthat there is a road between any contiguous cities and (). The length of\r\nthe described path equals to . We assume that two cities lie in the same\r\nregion if and only if, there is a path connecting these two\r\ncities.During the game events of two types take place: Andrew asks Dima\r\nabout the length of the longest path in the region where city lies.\r\nAndrew asks Dima to merge the region where city lies with the region\r\nwhere city lies. If the cities lie in the same region, then no merging\r\nis needed. Otherwise, you need to merge the regions as follows: choose a\r\ncity from the first region, a city from the second region and connect\r\nthem by a road so as to minimize the length of the longest path in the\r\nresulting region. If there are multiple ways to do so, you are allowed\r\nto choose any of them. Dima finds it hard to execute Andrew\u2019s queries,\r\nso he asks you to help him. Help Dima.\r\n", "solutions": ["#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 600010;\n\nint ROOT, MAX, CITY;\n\nint p[N], was[N];\n\nvector <int> g[N];\n\nvoid dfs(int v, int d, int mark) {\n  p[v] = ROOT;\n  if (d > MAX) {\n    MAX = d;\n    CITY = v;\n  }\n  was[v] = mark + 1;\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j];\n    if (was[u] > mark) {\n      continue;\n    }\n    dfs(u, d + 1, mark);\n  }\n}\n\nint diam[N];\n\nint find_set(int x) {\n  if (x != p[x]) {\n    p[x] = find_set(p[x]);\n  }\n  return p[x];\n}\n\nint main() {\n  int n, m, q;\n  scanf(\"%d %d %d\", &n, &m, &q);\n  for (int i = 1; i <= n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < m; i++) {\n    int foo, bar;\n    scanf(\"%d %d\", &foo, &bar);\n    g[foo].push_back(bar);\n    g[bar].push_back(foo);\n  }\n  for (int i = 1; i <= n; i++) {\n    was[i] = 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (was[i] == 0) {\n      ROOT = i;\n      MAX = -1; CITY = 0;\n      dfs(i, 0, 0);\n      int to = CITY;\n      MAX = -1; CITY = 0;\n      dfs(to, 0, 1);\n      diam[i] = MAX;\n    }\n  }\n  while (q--) {\n    int com;\n    scanf(\"%d\", &com);\n    if (com == 1) {\n      int x;\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", diam[find_set(x)]);\n    } else {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      if (q % 7 <= 4) {\n        swap(x, y);\n      }\n      x = find_set(x);\n      y = find_set(y);\n      if (x == y) {\n        continue;\n      }\n      p[x] = y;\n      int old = (diam[x] > diam[y]) ? diam[x] : diam[y];\n      diam[y] = ((diam[y] + 1) / 2) + 1 + ((diam[x] + 1) / 2);\n      if (old > diam[y]) {\n        diam[y] = old;\n      }\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "dsu", "ternary search", "trees"], "dificulty": "2100", "interactive": false}