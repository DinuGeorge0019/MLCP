{
    "link": "https://codeforces.com//contest/1693/problem/E",
    "problemId": "1430892",
    "problem_idx": "E",
    "shortId": "1693E",
    "contest_number": "1693",
    "problem_submissions": {
        "F": [
            160880007,
            160880972,
            160861674,
            160875588,
            160882783,
            160878948,
            160890167,
            160899913,
            161040863,
            160893311,
            160892940
        ],
        "E": [
            160864775,
            160851833,
            160876978,
            160893451,
            160863343,
            160869365,
            160873611,
            160876701,
            160883190,
            160881001,
            160869009,
            160890042,
            160889537,
            160889370,
            160888603,
            160888570,
            160884303
        ],
        "D": [
            160848374,
            160868923,
            160880702,
            160854200,
            160854032,
            160862911,
            160859336,
            160861278,
            160860933,
            160866823,
            160880935,
            160874455,
            160855846,
            160857826,
            160858928,
            160851586,
            160859103
        ],
        "C": [
            160833863,
            160838237,
            160831750,
            160839496,
            160831595,
            160847471,
            160845192,
            160845432,
            160842623,
            160834916,
            160845029,
            160853816,
            160836315,
            160837724,
            160840237,
            160837127,
            160842065,
            160837528
        ],
        "B": [
            160829995,
            160831749,
            160828393,
            160835792,
            160838408,
            160836721,
            160840343,
            160837858,
            160837790,
            160829673,
            160840637,
            160838527,
            160830551,
            160831811,
            160831387,
            160832406,
            160834629,
            160831231
        ],
        "A": [
            160824784,
            160824733,
            160824181,
            160826982,
            160842765,
            160829489,
            160836610,
            160834230,
            160827824,
            160825693,
            160827125,
            160830489,
            160824662,
            160825298,
            160825387,
            160826936,
            160829963,
            160825879
        ]
    },
    "name": "E. Outermost Maximums",
    "statement": "Yeri has an array of n + 2 non-negative integers : a_0, a_1, ..., a_n,\r\na_{n + 1}.We know that a_0 = a_{n + 1} = 0.She wants to make all the\r\nelements of a equal to zero in the minimum number of operations.In one\r\noperation she can do one of the following: Choose the leftmost maximum\r\nelement and change it to the maximum of the elements on its left. Choose\r\nthe rightmost maximum element and change it to the maximum of the\r\nelements on its right.Help her find the minimum number of operations\r\nneeded to make all elements of a equal to zero.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int n1=(1<<18);\n\nint n;\nint tab[nax];\n\nstruct info\n{\n\tvector<pii> wyj;//first to stan, second to dodanie\n};\n\ninfo operator +(const info &a, const info &b)\n{\n\tinfo ret;\n\tret.wyj.resize(3);\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tint x=a.wyj[i].first;\n\t\tret.wyj[i]={b.wyj[x].first, b.wyj[x].second+a.wyj[i].second};\n\t}\n\treturn ret;\n}\n\ninfo drz[nax];\n\n//0 to JEDYNKI\nint polew[nax];\nint popra[nax];\n\nll wyn;\n\ninfo daj(int l, int p)\n{\n\tinfo ret;\n\tret.wyj.resize(3);\n\tif (l && p)\n\t{\n\t\tfor (int i=0; i<3; i++)\n\t\t\tret.wyj[i]={0, 1};\n\t\treturn ret;\n\t}\n\tif (!l && !p)\n\t{\n\t\tfor (int i=0; i<3; i++)\n\t\t\tret.wyj[i]={i, 0};\n\t\treturn ret;\n\t}\n\tif (l)\n\t{\n\t\tret.wyj[0]={1, 0};\n\t\tret.wyj[1]={1, 0};\n\t\tret.wyj[2]={0, 1};\n\t\treturn ret;\n\t}\n\tif (p)\n\t{\n\t\tret.wyj[0]={2, 0};\n\t\tret.wyj[1]={0, 1};\n\t\tret.wyj[2]={2, 0};\n\t\treturn ret;\n\t}\n\tassert(0);\n}\n\nvoid upd(int v)\n{\n\tif (!v)\n\t\treturn;\n\tdrz[n1-1+v]=daj(polew[v], popra[v]);\n\tv+=n1-1;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tdrz[v]=(drz[2*v+1]+drz[2*v]);\n\t\tv>>=1;\n\t}\n}\n\ninfo glo;\n\nvoid czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\tglo=(glo+drz[v]);\n\t\treturn;\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn;\n\t}\n\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab);\n\tczyt((v<<1), a, (a+b)>>1, graa, grab);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tpopra[tab[i]]++;\n\tfor (int i=1; i<2*n1; i++)\n\t\tdrz[i]=daj(0, 0);\n\tfor (int i=1; i<=n; i++)\n\t\tdrz[n1-1+i]=daj(0, popra[i]);\n\tfor (int i=n1-1; i; i--)\n\t\tdrz[i]=(drz[2*i+1]+drz[2*i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tpopra[tab[i]]--;\n\t\tupd(tab[i]);\n\t\tif (tab[i])\n\t\t{\n\t\t\tglo=daj(0, 0);\n\t\t\tczyt(1, 1, n1, 1, tab[i]-1);\n\t\t\t//~ debug() << imie(drz[(1+n1-1)/2].wyj);\n\t\t\t//~ debug() << imie(drz[(1+n1-1)].wyj);\n\t\t\t//~ debug() << imie(drz[(2+n1-1)].wyj);\n\t\t\t//~ debug() << i << \" \" << glo.wyj;\n\t\t\twyn+=glo.wyj[0].second+1;\n\t\t}\n\t\tpolew[tab[i]]++;\n\t\tupd(tab[i]);\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Outermost Maximums.json",
    "editorial_link": "https://codeforces.com//blog/entry/103952",
    "editorial": "Letâs calculate for each element of the array, the minimum number of\r\ntimes it needs to change throughout the process.Letâs take a look at the\r\nfirst time the -th element is changing. We know that is the maximum\r\nnumber and the elements smaller than havenât changed yet.Denote the\r\nmaximum element on its left as and the maximum element on its right as\r\n.So is equal to the largest number among that is smaller than . Likewise\r\nfor .We can change to either or . Itâs better to change it to the\r\nsmaller one. (Weâll get into the details of why this is correct\r\nlater.)Let be the minimum number of times the -th element needs to\r\nchange. The following greedy algorithm works in operations.Let be the\r\nnumber the leftmost maximum becomes if we do the first operation and be\r\nthe number the rightmost maximum becomes if we do the second\r\noperation.Do the first operation if and do the second operation\r\notherwise. If then for the leftmost maximum, the maximum element on its\r\nleft is smaller than the maximum element on its right. That means we are\r\nmaking the right choice for this element.Letâs assume the array is a\r\npermutation of numbers from through for simplicity.For some element make\r\nstring of length such that = \"O\". for any , = \"L\". for any , = \"R\".\r\nImagine Yeri is initially standing on the -th character of S (which is\r\n\"O\") and she is facing the beginning of the string.In each step she\r\neither jumps to the nearest \"L\" or jumps to the nearest \"R\". And her\r\ngoal is to jump out of the string in minimum number of jumps. We know\r\nitâs always better to jump to the further one, but we wonât need this\r\nfact.We will use a segment tree. For each node maintain 4 values. What\r\nis the minimum possible number of jumps made in this interval in case we\r\nenter it looking for an \"L\" and leave it looking for an \"L\" we enter it\r\nlooking for an \"L\" and leave it looking for an \"R\" we enter it looking\r\nfor an \"R\" and leave it looking for an \"L\" we enter it looking for an\r\n\"R\" and leave it looking for an \"R\" Itâs easy to update this. Just fix\r\nwhich character you are looking for when moving from the nodeâs one\r\nchild to the other. And you can find these values for intervals of\r\nlength .Now if you iterate over from to . At each step at most 2\r\ncharacters of the string are changing, hence you can keep your segment\r\ntree updated.But there are still some details we need to sort out. The\r\narray is not necessarily a permutation. To fix this, first get rid of\r\nthe \"O\". Then for each number see if it appears on the left side and see\r\nif it appears on the right side. Now there are 4 different states for\r\neach number but the same segment tree can handle this too. We just need\r\nto find the 4 values for each of the 4 states of a single number.Time\r\ncomplexity:\r\n",
    "hint": []
}