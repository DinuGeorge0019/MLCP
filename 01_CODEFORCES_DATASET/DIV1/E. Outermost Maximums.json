{"link": "https://codeforces.com//contest/1693/problem/E", "problemId": "1430892", "problem_idx": "E", "shortId": "1693E", "contest_number": "1693", "problem_submissions": {"F": [160880007, 160880972, 160861674, 160875588, 160882783, 160878948, 160890167, 160899913, 161040863, 160893311, 160892940], "E": [160864775, 160851833, 160876978, 160893451, 160863343, 160869365, 160873611, 160876701, 160883190, 160881001, 160869009, 160890042, 160889537, 160889370, 160888603, 160888570, 160884303], "D": [160848374, 160868923, 160880702, 160854200, 160854032, 160862911, 160859336, 160861278, 160860933, 160866823, 160880935, 160874455, 160855846, 160857826, 160858928, 160851586, 160859103], "C": [160833863, 160838237, 160831750, 160839496, 160831595, 160847471, 160845192, 160845432, 160842623, 160834916, 160845029, 160853816, 160836315, 160837724, 160840237, 160837127, 160842065, 160837528], "B": [160829995, 160831749, 160828393, 160835792, 160838408, 160836721, 160840343, 160837858, 160837790, 160829673, 160840637, 160838527, 160830551, 160831811, 160831387, 160832406, 160834629, 160831231], "A": [160824784, 160824733, 160824181, 160826982, 160842765, 160829489, 160836610, 160834230, 160827824, 160825693, 160827125, 160830489, 160824662, 160825298, 160825387, 160826936, 160829963, 160825879]}, "name": "E. Outermost Maximums", "statement": "Yeri has an array of n + 2 non-negative integers : a_0, a_1, ..., a_n,\r\na_{n + 1}.We know that a_0 = a_{n + 1} = 0.She wants to make all the\r\nelements of a equal to zero in the minimum number of operations.In one\r\noperation she can do one of the following: Choose the leftmost maximum\r\nelement and change it to the maximum of the elements on its left. Choose\r\nthe rightmost maximum element and change it to the maximum of the\r\nelements on its right.Help her find the minimum number of operations\r\nneeded to make all elements of a equal to zero.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int n1=(1<<18);\n\nint n;\nint tab[nax];\n\nstruct info\n{\n\tvector<pii> wyj;//first to stan, second to dodanie\n};\n\ninfo operator +(const info &a, const info &b)\n{\n\tinfo ret;\n\tret.wyj.resize(3);\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tint x=a.wyj[i].first;\n\t\tret.wyj[i]={b.wyj[x].first, b.wyj[x].second+a.wyj[i].second};\n\t}\n\treturn ret;\n}\n\ninfo drz[nax];\n\n//0 to JEDYNKI\nint polew[nax];\nint popra[nax];\n\nll wyn;\n\ninfo daj(int l, int p)\n{\n\tinfo ret;\n\tret.wyj.resize(3);\n\tif (l && p)\n\t{\n\t\tfor (int i=0; i<3; i++)\n\t\t\tret.wyj[i]={0, 1};\n\t\treturn ret;\n\t}\n\tif (!l && !p)\n\t{\n\t\tfor (int i=0; i<3; i++)\n\t\t\tret.wyj[i]={i, 0};\n\t\treturn ret;\n\t}\n\tif (l)\n\t{\n\t\tret.wyj[0]={1, 0};\n\t\tret.wyj[1]={1, 0};\n\t\tret.wyj[2]={0, 1};\n\t\treturn ret;\n\t}\n\tif (p)\n\t{\n\t\tret.wyj[0]={2, 0};\n\t\tret.wyj[1]={0, 1};\n\t\tret.wyj[2]={2, 0};\n\t\treturn ret;\n\t}\n\tassert(0);\n}\n\nvoid upd(int v)\n{\n\tif (!v)\n\t\treturn;\n\tdrz[n1-1+v]=daj(polew[v], popra[v]);\n\tv+=n1-1;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tdrz[v]=(drz[2*v+1]+drz[2*v]);\n\t\tv>>=1;\n\t}\n}\n\ninfo glo;\n\nvoid czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\tglo=(glo+drz[v]);\n\t\treturn;\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn;\n\t}\n\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab);\n\tczyt((v<<1), a, (a+b)>>1, graa, grab);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tpopra[tab[i]]++;\n\tfor (int i=1; i<2*n1; i++)\n\t\tdrz[i]=daj(0, 0);\n\tfor (int i=1; i<=n; i++)\n\t\tdrz[n1-1+i]=daj(0, popra[i]);\n\tfor (int i=n1-1; i; i--)\n\t\tdrz[i]=(drz[2*i+1]+drz[2*i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tpopra[tab[i]]--;\n\t\tupd(tab[i]);\n\t\tif (tab[i])\n\t\t{\n\t\t\tglo=daj(0, 0);\n\t\t\tczyt(1, 1, n1, 1, tab[i]-1);\n\t\t\t//~ debug() << imie(drz[(1+n1-1)/2].wyj);\n\t\t\t//~ debug() << imie(drz[(1+n1-1)].wyj);\n\t\t\t//~ debug() << imie(drz[(2+n1-1)].wyj);\n\t\t\t//~ debug() << i << \" \" << glo.wyj;\n\t\t\twyn+=glo.wyj[0].second+1;\n\t\t}\n\t\tpolew[tab[i]]++;\n\t\tupd(tab[i]);\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "3400", "interactive": false}