{
    "link": "https://codeforces.com//contest/1540/problem/E",
    "problemId": "1027091",
    "problem_idx": "E",
    "shortId": "1540E",
    "contest_number": "1540",
    "problem_submissions": {
        "E": [
            158665487,
            120671889,
            120671130,
            120611380
        ],
        "C2": [
            120605147,
            120568544,
            120579011,
            120588964,
            120605073,
            120569097,
            120574747,
            120608479,
            120579015,
            120598713,
            120577744,
            120597136,
            120595479,
            120616218,
            120596815,
            120598287
        ],
        "D": [
            120591057,
            120602670,
            120602293,
            120600949,
            120589579,
            120610881,
            120604354,
            120600348,
            120595403,
            120583946,
            120609085,
            120608380,
            120703598,
            120703586,
            120698836,
            120593678,
            120637556,
            120637415
        ],
        "C1": [
            120567535,
            120561594,
            120567326,
            120573306,
            120596169,
            120563211,
            120564500,
            120604433,
            120607536,
            120590343,
            120588571,
            120578785,
            120575407,
            120560194,
            120579656,
            120577149,
            120580975,
            120582010
        ],
        "B": [
            120551949,
            120542169,
            120552393,
            120556326,
            120559167,
            120545883,
            120578567,
            120557279,
            120559926,
            120559208,
            120581683,
            120555741,
            120556140,
            120587344,
            120581865,
            120550352,
            120557511,
            120561248,
            120559894
        ],
        "A": [
            120538111,
            120534681,
            120538291,
            120538440,
            120536907,
            120535163,
            120537026,
            120546671,
            120535419,
            120535827,
            120537631,
            120535887,
            120540241,
            120536295,
            120551816,
            120535724,
            120539352,
            120540330,
            120541623
        ]
    },
    "name": "E. Tasty Dishes",
    "statement": "There are n chefs numbered 1, 2,\r\nldots, n that must prepare dishes for a king. Chef i has skill i and\r\ninitially has a dish of tastiness a_i where |a_i|\r\nleq i. Each chef has a list of other chefs that he is allowed to copy\r\nfrom. To stop chefs from learning bad habits, the king makes sure that\r\nchef i can only copy from chefs of larger skill.There are a sequence of\r\ndays that pass during which the chefs can work on their dish. During\r\neach day, there are two stages during which a chef can change the\r\ntastiness of their dish. At the beginning of each day, each chef can to\r\nwork (or not work) on their own dish, thereby multiplying the tastiness\r\nof their dish of their skill (a_i := i\r\ncdot a_i) (or doing nothing). After all chefs (who wanted) worked on\r\ntheir own dishes, each start observing the other chefs. In particular,\r\nfor each chef j on chef i\u2019s list, chef i can to copy (or not copy) j\u2019s\r\ndish, thereby adding the tastiness of the j\u2019s dish to i\u2019s dish (a_i :=\r\na_i + a_j) (or doing nothing). It can be assumed that all copying occurs\r\nsimultaneously. Namely, if chef i chooses to copy from chef j he will\r\ncopy the tastiness of chef j\u2019s dish at the end of stage 1.All chefs work\r\nto maximize the tastiness of their dish in order to please the\r\nking.Finally, you are given q queries. Each query is one of two types. 1\r\nk l r find the sum of tastiness a_l, a_{l+1},\r\nldots, a_{r} after the k-th day. Because this value can be large, find\r\nit modulo 10^9 + 7. 2 i x the king adds x tastiness to the i-th chef\u2019s\r\ndish before the 1-st day begins (a_i := a_i + x). Note that, because the\r\nking wants to see tastier dishes, he only adds positive tastiness (x >\r\n0). Note that queries of type 1 are independent of each all other\r\nqueries. Specifically, each query of type 1 is a and does not change the\r\ninitial tastiness a_i of any dish for future queries. Note that queries\r\nof type 2 are cumulative and only change the initial tastiness a_i of a\r\ndish. See notes for an example of queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//mint107 \u306f verify \u3057\u3066\u306d\u3048\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nconst int nmax=305;\nconst int kmax=1005;\nmint ps[nmax][kmax],is[nmax][kmax];\nvoid init(){\n\trng(i,1,nmax)rep(j,kmax){\n\t\tps[i][j]=mint(i).pow(j);\n\t\tis[i][j]=ps[i][j].inv();\n\t}\n}\n\n//XXII Opencup GP of Siberia 6\n//\u5de6c\u5217\u3092sweep\u3057\u3059\u308b\n//a\u306e\u5148\u982drank\u884c\u306b\u8981\u7d20\u304c\u5165\u3063\u3066\u3044\u308b\u611f\u3058\n//\u6383\u304d\u51fa\u3057\u306b\u4f7f\u3063\u305f\u5217\u306e\u756a\u53f7\u304c\u8fd4\u308b\nvi sweep(vvc<mint>&a,int c=-1){\n\tif(a.empty())return {};\n\tif(c==-1)c=a[0].size();\n\tint h=a.size(),w=a[0].size(),r=0;\n\tvi res;\n\trep(i,c){\n\t\tif(r==h)break;\n\t\trng(j,r,h)if(a[j][i].v){\n\t\t\tswap(a[r],a[j]);\n\t\t\tbreak;\n\t\t}\n\t\tif(a[r][i].v==0)continue;\n\t\trep(j,h)if(j!=r){\n\t\t//rng(j,r+1,h){ //for speed up (sweep \u306b\u4f7f\u3063\u305f\u5217\u306b\u8907\u6570\u306e non-zero \u304c\u3042\u3063\u3066\u3082\u826f\u3044\u5834\u5408)\n\t\t\tmint z=-a[j][i]/a[r][i];\n\t\t\trng(k,i,w)\n\t\t\t\ta[j][k]+=a[r][k]*z;\n\t\t}\n\t\tres.pb(i);\n\t\tr++;\n\t}\n\treturn res;\n}\n\nvvc<mint> inverse(vvc<mint> a){\n\tint n=si(a);\n\trep(i,n){\n\t\tassert(si(a[i])==n);\n\t\ta[i].resize(2*n);\n\t\ta[i][n+i]=1;\n\t}\n\tauto tmp=sweep(a,n);\n\tassert(si(tmp)==n);\n\tvvc<mint> b(n,vc<mint>(n));\n\trep(i,n){\n\t\tmint w=a[i][i].inv();\n\t\trep(j,n)b[i][j]=a[i][n+j]*w;\n\t}\n\treturn b;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\t\n\tvi a=readvi(n);\n\t\n\tvvc<int> g(n);\n\trep(i,n){\n\t\tint c;cin>>c;\n\t\trep(_,c){\n\t\t\tint j;cin>>j;j--;\n\t\t\tg[j].pb(i);\n\t\t}\n\t}\n\t\n\tvvc<mint> p(n,vc<mint>(n));\n\trep(r,n){\n\t\tvc<mint> x(n);\n\t\tper(i,r+1){\n\t\t\tif(i==r){\n\t\t\t\tx[i]=1;\n\t\t\t}else{\n\t\t\t\tx[i]/=r-i;\n\t\t\t}\n\t\t\tfor(auto j:g[i])\n\t\t\t\tx[j]+=x[i]*(i+1);\t\n\t\t}\n\t\trep(i,n)p[i][r]=x[i];\n\t}\n\tauto pinv=inverse(p);\n\tvvc<mint> psum(n+1,vc<mint>(n));\n\trep(i,n)rep(j,n)psum[i+1][j]=psum[i][j]+p[i][j];\n\t\n\tvc<mint> buf(n);\n\t\n\tvvc<mint> bit(n,vc<mint>(n));\n\t\n\tauto add=[&](int i){\n\t\tfor(;i<n;i+=(i+1)&(-i-1))\n\t\t\trep(j,n)bit[i][j]+=buf[j];\n\t};\n\tauto getsum=[&](int i){\n\t\tchmin(i,n-1);\n\t\tfill(all(buf),0);\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\trep(j,n)buf[j]+=bit[i][j];\n\t};\n\t\n\tvi d(n,inf);\n\tauto work=[&](int i,mint w){\n\t\tif(d[i]<n){\n\t\t\trep(j,n){\n\t\t\t\tbuf[j]=w*pinv[j][i]*is[j+1][d[i]];\n\t\t\t}\n\t\t\tadd(d[i]);\n\t\t}\n\t};\n\tauto dfs=[&](auto self,int i,int v)->void{\n\t\tif(d[i]>v){\n\t\t\twork(i,-a[i]);\n\t\t\td[i]=v;\n\t\t\twork(i,a[i]);\n\t\t\tfor(auto j:g[i])\n\t\t\t\tself(self,j,v+1);\n\t\t}\n\t};\n\trep(i,n)if(a[i]>0){dfs(dfs,i,0);}\n\t\n\tint q;cin>>q;\n\trep(_,q){\n\t\tint t;cin>>t;\n\t\tif(t==1){\n\t\t\tint k,l,r;cin>>k>>l>>r;\n\t\t\tl--;\n\t\t\tgetsum(k);\n\t\t\tmint ans=0;\n\t\t\trep(i,n){\n\t\t\t\tans+=(psum[r][i]-psum[l][i])*ps[i+1][k]*buf[i];\n\t\t\t}\n\t\t\trng(i,l,r)if(d[i]>k)\n\t\t\t\tans+=a[i];\n\t\t\tprint(ans);\n\t\t}else if(t==2){\n\t\t\tint i,x;cin>>i>>x;\n\t\t\ti--;\n\t\t\twork(i,x);\n\t\t\ta[i]+=x;\n\t\t\tif(a[i]>0)dfs(dfs,i,0);\n\t\t}else assert(false);\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinit();\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "matrices"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Tasty Dishes.json",
    "editorial_link": "https://codeforces.com//blog/entry/92199",
    "editorial": "All operations are conducted under a modulo, it can be proven that each\r\noperation we conduct is valid within the modulo. It\u00e2\u0080\u0099s optimal to perform\r\neach operation if the number being added/multiplied is strictly\r\npositive. Specifically, it\u00e2\u0080\u0099s optimal to do and iif and respectively. A\r\nchef\u00e2\u0080\u0099s dish becomes positive after the \u00e2\u0080\u0099th day where is the closest\r\ndistance of chef from a positive element. We call this value for the \u00e2\u0080\u0099th\r\nchef. Initial observations, there are only pairs of where is not\r\ninfinite (never reaches positive value and thus never changes). We refer\r\nto a vector of length with zeros and a single at the \u00e2\u0080\u0099th index as . If\r\nwe assume that all chefs are currently positive then every chef takes\r\nevery opportunity copy and the transition matrix is well defined and\r\nobvious.We can represent the final array at time as + . This immediately\r\noffers a potential solution with very good constant. Because is\r\ndiagonal, its inverse can with respect to a vector be calculated in .\r\nSo, we can precalculate for all valid numbers in . In fact, this ends up\r\nbeing total operations if optimized. We can then answer each query in by\r\nsimply iterating over each chef and finding it\u00e2\u0080\u0099s contribution to the\r\nanswer. Multiplying a matrix will be explained later.With some special\r\nhacks, it even be possible to get this to pass. An arbitrary matrix has\r\neigenvalues and their paired eigenvectors . Ignoring how we find\r\neigenvectors and eigenvalues, the point of the two is that they are\r\npairs such that . Notably, given a eigenvector and its respective\r\neigenvalue, we can calculate in . In our case, the transition matrix is\r\na diagonal matrix. A basic result in linear algebra is that the\r\neigenvalues of a diagonal matrix is exactly the numbers on it\u00e2\u0080\u0099s\r\ndiagonal. In our case, this means that for . Finding the eigenvectors is\r\nleft as an exercise to the reader. We henceforth denote the eigenvector\r\npaired with the \u00e2\u0080\u0099th eigenvalue as . Decompose into a linear combination\r\nof eigenvectors. This can be precalculated in . Let\u00e2\u0080\u0099s denote another\r\nvector as this linear combination i.e. satisfies . In fact, this is\r\nalmost all we need. Let\u00e2\u0080\u0099s return to to (the second part can be trivially\r\ncalculated). We can calculate almost \"separately\" for each eigenvector .\r\nIn fact, the contribution of the \u00e2\u0080\u0099th eigenvector from the \u00e2\u0080\u0099th chef after\r\nthe \u00e2\u0080\u0099th day is . Let\u00e2\u0080\u0099s store in a segment tree/BIT on . We can extract\r\nin total or for a single eigenvector then find the total contribution by\r\nmultiplying by and using prefix sums on the eigenvector to extract the\r\nrelevant range . We can also process per update if stays constant\r\ntrivially. This is more than enough to pass, but a further optimization\r\nis that the array only changes at most time (whenever a new element\r\nbecomes positive). So, we can simply rebuild our segment tree/BIT in to\r\nreach complexity.Final complexity: .It\u00e2\u0080\u0099s also worth noting that several\r\nnonoptimal solutions can pass. We attempted to cut off any solutions\r\nthat explicitly use matrix multiplication. However, solutions with\r\ncomplexity such as can pass in 64 bit C++ if only additions are used.\r\nThe only way we found to do only additions was by making the same\r\neigenvector reduction, so we were not too worried. It seems impossible\r\nto fail such solutions while maintaining a reasonable TL.\r\n"
}