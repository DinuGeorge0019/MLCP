{
    "link": "https://codeforces.com//contest/963/problem/B",
    "problemId": "175447",
    "problem_idx": "B",
    "shortId": "963B",
    "contest_number": "963",
    "problem_submissions": {
        "E": [
            37408346,
            37407644,
            51152346,
            37411847,
            37415664,
            37414743,
            37424807,
            37560510,
            63561204,
            37525085
        ],
        "D": [
            37404929,
            37404881,
            37407341,
            37406493,
            37404117,
            37403898,
            37407185,
            37408546,
            37404537,
            37409644,
            37405529,
            37411456,
            37412888,
            37408258,
            37411536,
            37411945,
            37405408,
            37405454,
            37410330
        ],
        "C": [
            37403149,
            37410272,
            37405789,
            37402217,
            37408755,
            37410613,
            37405532,
            37406058,
            37410998,
            37406279,
            37408081,
            37407255,
            37409639,
            37405742,
            37409484,
            37407736,
            37415193,
            37408262
        ],
        "A": [
            37400764,
            37398530,
            37400243,
            37398542,
            37398672,
            37398448,
            37403076,
            37400054,
            37401968,
            37403020,
            37402655,
            37401825,
            37399871,
            37409184,
            37400223,
            37401116,
            37399078,
            37407652
        ],
        "B": [
            37399438,
            37401875,
            37403648,
            37403088,
            37402069,
            37401815,
            37401672,
            37402933,
            37403748,
            37400539,
            37403834,
            37404008,
            37402988,
            37412215,
            37402134,
            37404563,
            37403658,
            37399677,
            37411986
        ]
    },
    "name": "B. Destruction of a Tree",
    "statement": "You are given a tree (a graph with vertices and edges in which it’s\r\npossible to reach any vertex from any other vertex using only its\r\nedges).A vertex can be destroyed if this vertex has even degree. If you\r\ndestroy a vertex, all edges connected to it are also deleted.Destroy all\r\nvertices in the given tree or determine that it is impossible.\r\n",
    "solutions": [
        "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\nusing ll = long long;\nusing ld = long double;\nusing ull = uint64_t;\nusing namespace std;\n\nconst int MAXN = 200228;\nint p[MAXN];\nint d[MAXN];\n\nvector<int> e[MAXN];\nvector<int> ord;\n\nvoid dfs(int v) {\n\tfor (int u: e[v]) {\n\t\tdfs(u);\n\t}\n\n\tord.push_back(v);\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(20);\n\tint n;\n\tcin >> n;\n\tint root = 0;\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> p[i];\n\t\t++d[p[i]];\n\t\tif (p[i]) {\n\t\t\t++d[i];\n\t\t} else {\n\t\t\troot = i;\n\t\t}\n\n\t\te[p[i]].push_back(i);\n\t}\n\n\tdfs(root);\n\n\tvector<int> e;\n\tvector<int> ans;\n\n\tfor (int i: ord) {\n\t\tif (d[i] % 2) {\n\t\t\tif (i == root) {\n\t\t\t\tcout << \"NO\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te.push_back(i);\n\t\t} else {\n\t\t\tans.push_back(i);\n\t\t\t--d[p[i]];\n\t\t}\n\t}\n\n\treverse(e.begin(), e.end());\n\tans.insert(ans.end(), e.begin(), e.end());\n\tcout << \"YES\\n\";\n\n\tfor (int x: ans) {\n\t\tcout << x << \"\\n\";\n\t}\n}\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Destruction of a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/58991",
    "editorial": "If is even, then the answer is always , because such trees have odd\r\ndegree, but we can destroy only even number of edges. For any odd the\r\nanswer exists.Letâs call from subtree and destroy such nodes, that new\r\nsubtree will be empty or for all alive nodes in connected component will\r\nbe true, that they have odd degree. Realisation of this :Call it from\r\nsons of and recount degree of , if it is even we destroy all subtree.\r\nAssume, that after the destruction we have nonempty subtree. All nodes\r\nhave odd degree, so amount of left nodes is even. So number of left\r\nedges is odd, but in start we have even count of edges, contradiction.\r\nThat means, that we destroyed all nodes.\r\n",
    "hint": []
}