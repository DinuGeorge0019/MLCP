{
    "link": "https://codeforces.com//contest/283/problem/E",
    "problemId": "2744",
    "problem_idx": "E",
    "shortId": "283E",
    "contest_number": "283",
    "problem_submissions": {
        "E": [
            3343251,
            3348070,
            3348555,
            3348542,
            3348428,
            3342667,
            3340580,
            3359842,
            3361070,
            3400988,
            3346304,
            3342157,
            3353623,
            9563319
        ],
        "D": [
            3341005,
            3335239,
            3338431,
            3338289,
            3339479,
            3336539,
            3339584,
            3338822,
            3341445,
            3341195,
            3339832,
            3341374,
            3340310,
            3343222,
            3352115,
            3341622,
            3342150,
            3335280
        ],
        "C": [
            3338427,
            3332232,
            3337306,
            3335630,
            3335688,
            3336408,
            3338282,
            3337561,
            3334033,
            3335068,
            3338901,
            3342456,
            3339089,
            3338935,
            3340473,
            3349673,
            3339598,
            3338693,
            3342436
        ],
        "A": [
            3335284,
            3336793,
            3332280,
            3331160,
            3331458,
            3331188,
            3331189,
            3331454,
            3337247,
            3331656,
            3332125,
            3331880,
            3333900,
            3331832,
            3331503,
            3331273,
            3331495,
            3332366,
            3339906
        ],
        "B": [
            3334513,
            3338857,
            3338541,
            3333624,
            3334182,
            3337249,
            3334768,
            3336364,
            3339602,
            3335198,
            3336023,
            3336506,
            3337264,
            3334508,
            3334275,
            3339765,
            3343648,
            3343572
        ]
    },
    "name": "E. Cow Tennis Tournament",
    "statement": "Farmer John is hosting a tennis tournament with his cows. Each cow has a\r\nskill level , and no two cows having the same skill level. Every cow\r\nplays every other cow exactly once in the tournament, and each cow beats\r\nevery cow with skill level lower than its own.However, Farmer John\r\nthinks the tournament will be demoralizing for the weakest cows who lose\r\nmost or all of their matches, so he wants to flip some of the results.\r\nIn particular, at different instances, he will take two integers and\r\nflip all the results between cows with skill level between and\r\ninclusive. That is, for any pair he will change the result of the match\r\non the final scoreboard (so if won the match, the scoreboard will now\r\ndisplay that won the match, and vice versa). It is possible that Farmer\r\nJohn will change the result of a match multiple times. It is not\r\nguaranteed that and are equal to some cow’s skill level.Farmer John\r\nwants to determine how balanced he made the tournament results look. In\r\nparticular, he wants to count the number of triples of cows for which\r\nthe final leaderboard shows that cow beats cow , cow beats cow , and cow\r\nbeats cow . Help him determine this number.Note that two triples are\r\nconsidered different if they do not contain the same set of cows (i.e.\r\nif there is a cow in one triple that is not in the other).\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nint tree[1100000];\nint add[1100000];\n\nvoid flip(int l,int r,int a,int b,int k){\n\tif(r<=a || l>=b)\n\t\treturn;\n\tif(l<=a && r>=b){\n\t\ttree[k]=b-a-tree[k];\n\t\tadd[k]^=1;\n\t\treturn;\n\t}\n\tint c=(a+b)/2;\n\tflip(l,r,a,c,k*2+1);\n\tflip(l,r,c,b,k*2+2);\n\ttree[k]=tree[k*2+1]+tree[k*2+2];\n\tif(add[k])\n\t\ttree[k]=b-a-tree[k];\n}\n\nint getsum(int l,int r,int a,int b,int k){\n\tl=max(l,a);\n\tr=min(r,b);\n\tif(r<=l)\n\t\treturn 0;\n\tif(l==a && r==b)\n\t\treturn tree[k];\n\tint c=(a+b)/2;\n\tint t=getsum(l,r,a,c,k*2+1)+getsum(l,r,c,b,k*2+2);\n\tif(add[k])\n\t\tt=r-l-t;\n\treturn t;\n}\n\nvector<int> qu1[110000];\nvector<int> qu2[110000];\n\nint main() {\n#ifdef __ASD__\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tios_base::sync_with_stdio(false);\n\t\n\tint n,k;\n\tcin>>n>>k;\n\tvector<PII> qus(k);\n\tvector<int> vals(n);\n\tforn(i,n){\n\t\tcin>>vals[i];\n\t}\n\tsort(all(vals));\n\tforn(i,k){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta=lower_bound(all(vals),a)-vals.begin();\n\t\tb=upper_bound(all(vals),b)-vals.begin();\n\t\tqu1[a].pb(b);\n\t\tqu2[b].pb(a);\n\t}\n\t\n\tlng res=1LL*n*(n-1)*(n-2)/6;\n\tforn(i,n){\n\t\tforv(j,qu1[i]){\n\t\t\tflip(i,qu1[i][j],0,n,0);\n\t\t}\n\t\tforv(j,qu2[i]){\n\t\t\tflip(qu2[i][j],i,0,n,0);\n\t\t}\n\t\tint t1=getsum(i+1,n,0,n,0);\n\t\tint t2=getsum(0,i,0,n,0);\n\t\tint s=(n-i-1)-t1+t2;\n\t\tlng t=1LL*s*(s-1)/2;\n\t\t//cout<<s<<' '<<t<<endl;\n\t\tres-=t;\n\t}\n\t\n\tcout<<res;\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Cow Tennis Tournament.json",
    "editorial_link": "https://codeforces.com//blog/entry/7037",
    "editorial": "Here is a full solution to Codeforces 174 div 1 E. I find this problem beautiful. :)\n\nThe first thing to note, is that, if you interpret the problem as a graph, you can compute the answer if you have the degrees (i.e. number of wins) of every cow. Call three cows ``unbalanced if the is one cow that beats the other two. Note that every three cows is either unbalanced or balanced (there are no other configurations of three cows). Thus,\n\n\n\nSo to count the number of balanced it suffices to count the number of unbalanced. But it is easy to show that  so \n\nSo now we have reduced the problem to computing the number of wins for each cow. If we do this the dumb way, this is O(MN^2), still way too slow.\n\nSort the skill levels of the cows (the order of the si doesnt actually matter). s1 is lowest skill Now consider an n?×?n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped. The grid is initially all zeros and Farmer Johns query simply flips a rectangle of the form [a,?b]?×?[a,?b],? and the outdegree (#wins) of cow i is just (Number of 1s in range [1,i  1]) + (Number of 0s in range [i + 1, N]) = (Number of 1s in range [1,i  1]) + (N  i  (Number of 1s in range [i + 1, N]))\n\nWe can process these queries and compute outdegrees using a sweep line with a seg tree on the interval [1,N]. The seg tree needs to handle queries of the form\n\nFlip all numbers (0->1, 1->0) in a range [a,?b].\n\nQuery number of 1s in a range [a,?b].",
    "hint": []
}