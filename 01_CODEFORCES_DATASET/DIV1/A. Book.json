{
    "link": "https://codeforces.com//contest/1572/problem/A",
    "problemId": "1113063",
    "problem_idx": "A",
    "shortId": "1572A",
    "contest_number": "1572",
    "problem_submissions": {
        "E": [
            129206504,
            129205064,
            129206146,
            129186931,
            129254910,
            129870976,
            129204851
        ],
        "B": [
            129200222,
            129195364,
            129193573,
            129181375,
            129193456,
            129190984,
            129205791,
            129198794,
            129201998,
            129193078,
            129214920,
            129184305,
            129194122,
            129185643,
            129187972,
            129190794,
            129186099,
            129191410,
            129188216
        ],
        "C": [
            129195835,
            129191513,
            129199311,
            129193150,
            129195181,
            129198867,
            129196979,
            129259448,
            129179785,
            129722486,
            129198454,
            129198079,
            129197696,
            129199887,
            129197773,
            129211811,
            129200276
        ],
        "D": [
            129192769,
            129199613,
            129201627,
            129206390,
            129205002,
            129205082,
            129227304,
            129328372,
            129201185,
            129870962,
            129870944,
            129203066,
            129316237,
            129316188,
            136814393,
            129429191
        ],
        "A": [
            129167164,
            129167977,
            129198411,
            129169285,
            129180189,
            129173821,
            129177103,
            129171630,
            129176985,
            129172424,
            129196280,
            129167530,
            129169791,
            129170025,
            129173030,
            129174006,
            129171850,
            129174559,
            129177053
        ],
        "F": [
            129209583,
            129209541,
            129208785,
            129202453,
            129198897,
            129722539,
            129216893,
            129216152,
            129193790,
            129338264
        ]
    },
    "name": "A. Book",
    "statement": "You are given a book with n chapters.Each chapter has a specified list\r\nof other chapters that need to be understood in order to understand this\r\nchapter. To understand a chapter, you must read it after you understand\r\nevery chapter on its required list.Currently you don’t understand any of\r\nthe chapters. You are going to read the book from the beginning till the\r\nend repeatedly until you understand the whole book. Note that if you\r\nread a chapter at a moment when you don’t understand some of the\r\nrequired chapters, you don’t understand this chapter.Determine how many\r\ntimes you will read the book to understand every chapter, or determine\r\nthat you will never understand every chapter no matter how many times\r\nyou read the book.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 18.09.2021 17:31:31       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    vector<int> deg(n);\n    for (int i = 0; i < n; i++) {\n      int x;\n      cin >> x;\n      while (x--) {\n        int j;\n        cin >> j;\n        --j;\n        g[j].push_back(i);\n        deg[i] += 1;\n      }\n    }\n    set<int> s;\n    for (int i = 0; i < n; i++) {\n      if (deg[i] == 0) {\n        s.insert(i);\n      }\n    }\n    int last = -1;\n    int ans = 1;\n    for (int iter = 0; iter < n; iter++) {\n      if (s.empty()) {\n        ans = -1;\n        break;\n      }\n      auto it = s.lower_bound(last);\n      if (it == s.end()) {\n        ans += 1;\n        it = s.begin();\n      }\n      int i = *it;\n      s.erase(it);\n      for (int j : g[i]) {\n        --deg[j];\n        if (deg[j] == 0) {\n          s.insert(j);\n        }\n      }\n      last = i;\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "graphs",
        "implementation",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Book.json",
    "editorial_link": "https://codeforces.com//blog/entry/95086",
    "editorial": "There are two main solutions in this task.The first solution simulates\r\nthe process of reading the book. Let be the number of chapters that need\r\nto be understood in order to understand -th chapter. We will keep this\r\narray updated during the simulation. Now we will simulate the process by\r\nkeeping a set of chapters that are ready to be understood. Suppose we\r\nhave just understood chapter . We will update array by iterating over\r\nall chapters that require to be understood. If some chapter becomes\r\nready to be understood, we will insert it to the set. Then, we will\r\nlowerbound on our set to the next chapter that can be understood and\r\nwhen we hit the end, the answer increases by one and we come back to the\r\nbeginning.The entire process runs in .The second solution is more graph\r\nbased. We will construct a graph, where there is a directed edge from to\r\nif chapter is needed to understand chapter . This edge has weight if and\r\notherwise. The answer is the length of the longest weighted path in this\r\ngraph incremented by . If there exists a cycle we should output . If the\r\ngraph is a DAG, we can use toposort and a simple DP to calculate the\r\nanswer.This solution works in\r\n",
    "hint": []
}