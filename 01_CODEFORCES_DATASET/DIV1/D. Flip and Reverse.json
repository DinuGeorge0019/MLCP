{
    "link": "https://codeforces.com//contest/1458/problem/D",
    "problemId": "837945",
    "problem_idx": "D",
    "shortId": "1458D",
    "contest_number": "1458",
    "problem_submissions": {
        "C": [
            101749748,
            101754548,
            101742006,
            101765508,
            101760904,
            101735121,
            101758711,
            101733697,
            101742587,
            101742771,
            101744109,
            101764706,
            101753517,
            101758458,
            103876484,
            101781534
        ],
        "D": [
            101742255,
            101733305,
            101750551,
            101754872,
            101747447,
            101747468,
            101737535,
            101761632,
            101756331,
            101755812,
            102023685,
            101761131,
            101768544,
            101764759,
            103932701,
            101747159
        ],
        "E": [
            101737863,
            101746540,
            101766037,
            101749099,
            101757343,
            101752859,
            101763081,
            101766464,
            101774328,
            101752190,
            101746555,
            101751393,
            101757105
        ],
        "B": [
            101728732,
            101721253,
            101733062,
            101725510,
            101763762,
            101727209,
            101722722,
            101732397,
            101727564,
            101724112,
            101730858,
            101735965,
            101740443,
            101732340,
            101727159,
            101744347,
            101723637,
            101730363,
            101730317
        ],
        "A": [
            101720547,
            101718495,
            101723686,
            101718493,
            101718664,
            101719145,
            101718463,
            101718584,
            101718634,
            101718787,
            101720142,
            101718675,
            101719084,
            101722215,
            101718515,
            101719224,
            101718795,
            101718781,
            101721089
        ],
        "F": [
            102925392,
            102542392,
            102542303,
            103841307
        ]
    },
    "name": "D. Flip and Reverse",
    "statement": "You are given a string s of \u2019s and \u2019s. You are allowed to perform the\r\nfollowing operation: choose a non-empty contiguous substring of s that\r\ncontains an equal number of \u2019s and \u2019s; flip all characters in the\r\nsubstring, that is, replace all \u2019s with \u2019s, and vice versa; reverse the\r\nsubstring. For example, consider s = , and the following operation:\r\nChoose the first six characters as the substring to act upon: . Note\r\nthat the number of \u2019s and \u2019s are equal, so this is a legal choice.\r\nChoosing substrings , , or the entire string would not be possible. Flip\r\nall characters in the substring: . Reverse the substring: . Find the\r\nlexicographically smallest string that can be obtained from s after zero\r\nor more operations.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 19.12.2020 13:21:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string s;\n    cin >> s;\n    int n = (int) s.size();\n    int pos = n;\n    vector<int> a(2 * n);\n    for (int i = 0; i < n; i++) {\n      if (s[i] == '1') {\n        a[pos] += 1;\n        pos += 1;\n      } else {\n        pos -= 1;\n        a[pos] += 1;\n      }\n    }\n    int L = -1;\n    int R = -1;\n    for (int i = 0; i < 2 * n; i++) {\n      if (a[i] != 0) {\n        if (L == -1) L = i;\n        R = i;\n      }\n    }\n    int me = n;\n    for (int i = 0; i < n; i++) {\n      if (a[me - 1] > 0 && !(a[me - 1] == 1 && me - 1 < R)) {\n        a[me - 1] -= 1;\n        me -= 1;\n        cout << 0;\n      } else {\n        assert(a[me] > 0);\n        a[me] -= 1;\n        me += 1;\n        cout << 1;\n      }\n      while (L < R && a[L] == 0) {\n        ++L;\n      }\n      while (L < R && a[R] == 0) {\n        --R;\n      }\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "greedy"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Flip and Reverse.json",
    "editorial_link": "https://codeforces.com//blog/entry/85750",
    "editorial": "Let's go over characters of s\n left to right and keep track of the balance = (the number of 0\n's) - (the number of 1\n's) among the visited characters. We can think about starting at the point 0\n, and moving right (from x\n to x+1\n) when we see a 0\n, and moving left (to x?1\n) when we see a 1\n. Each time we go from x\n to x\u00b11\n, let's connect the two points with an edge. We'll keep track of all the edges, even if there are multiple ones connecting the same pair of points. Since our path visits all edges we've created exactly once, it is an Eulerian path in the (multi)graph constructed this way. The start point of the path is 0\n, and the finish point is equal to the total balance of the string s\n.\n\nNow, let's think about what a transformation does. A valid substring subject to the transformation has an equal number of 0\n's and 1\n's, thus it must correspond to a part of our path which is a round tour from a point x\n back to itself. Flipping and reversing the substring makes us traverse all the same edges, but in reverse order and in reverse direction. Thus, in terms of graphs and paths, what we're doing is reversing a cycle that occurs in the Eulerian path. Note that the collection of edges is preserved after every operation, in other words, the graph is an invariant of the process. Furthermore, the start and finish of the path also stay the same.\n\nThe answer (= lex. min. string) thus also corresponds to a certain Eulerian path in the very same graph, but which one? It should be the lex. min. path (where we prefer going right before going left) that is obtainable from the initial one with cycle reverses. However, the important observation is: in this particular graph any Eulerian path is obtainable from any other one with cycle reverses (as long as they start and finish in the same places).\n\nThere are a few ways to prove this. For example, consider two Eulerian paths, and look at the first point where they diverge: say, one goes x?x+1\n, while the other goes x?x?1\n. But both paths will have to eventually return to x\n to go in the other direction, thus there is at least one extra edge in each direction x?x+1\n and x?x?1\n, unvisited before the divergence happened. Let's wait until the first path visits at least two edges between x\n and x?1\n, returning back to x\n, and reverse the resulting cycle. With this, the next edge after diverging have changed from x?x+1\n to x?x?1\n, and now the two paths diverge some time later. We can proceed until both paths are the same.\n\nThe observation implies that we should simply look for the lex. min. Eulerian path in the entire graph. Let's try to do this greedily: build the path from the beginning, marking edges as used when we traverse them. Take the transition x?x+1\n whenever there is a unused edge leading there, otherwise settle for x?x?1\n. There is a caveat, though: we can not go x?x+1\n if this uses the last edge between x\n and x+1\n, and additionally we still have to visit x\n some time later (say, if x\n has unused edges to x?1\n). However, with this extra condition in place, the greedy algorithm will always find an Eulerian path, and it's clearly the lex. min. one. This procedure is fairly easy to implement in linear time: reconstruct the graph and do the greedy thing."
}