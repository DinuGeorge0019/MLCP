{"link": "https://codeforces.com//contest/434/problem/B", "problemId": "9713", "problem_idx": "B", "shortId": "434B", "contest_number": "434", "problem_submissions": {"D": [6699538, 6706635, 6706622, 6706591, 6706589, 6795823, 6704699, 6708335, 6707919], "C": [6697907, 6699177, 6698487, 6699311, 6699392, 6797515, 6797483, 6718935, 6697269, 6700102, 6699851, 6696039, 6700493, 6700403, 6700591, 6698358, 6698258, 6700561, 6698389], "B": [6695587, 6696287, 6694622, 6695678, 6696514, 6695797, 6699364, 6695860, 6695864, 6699676, 6699377, 6696715, 6697097, 6695263, 6696899, 6700084, 6700621, 6697368, 6695731], "A": [6692446, 6694191, 6692438, 6693456, 6692853, 6692909, 6693769, 6692709, 6691931, 6694014, 6700765, 6693088, 6694404, 6692737, 6695761, 6695148, 6698289, 6693859, 6708768], "E": [6711897]}, "name": "B. Nanami s Digital Board", "statement": "Nanami is an expert at playing games. This day, Nanami\u2019s good friend\r\nHajime invited her to watch a game of baseball. Unwilling as she was,\r\nshe followed him to the stadium. But Nanami had no interest in the game,\r\nso she looked around to see if there was something that might interest\r\nher. That\u2019s when she saw the digital board at one end of the stadium.The\r\ndigital board is pixels in height and pixels in width, every pixel is\r\neither light or dark. The pixels are described by its coordinate. The\r\n-th pixel of the -th line is pixel . The board displays messages by\r\nswitching a combination of pixels to light, and the rest to dark. Nanami\r\nnotices that the state of the pixels on the board changes from time to\r\ntime. At certain times, certain pixels on the board may switch from\r\nlight to dark, or from dark to light.Nanami wonders, what is the area of\r\nthe biggest light block such that a specific pixel is on its side. A\r\nlight block is a sub-rectangle of the board, in which all pixels are\r\nlight. Pixel belongs to a side of sub-rectangle with and as its\r\nupper-left and lower-right vertex if and only if it satisfies the\r\nlogical condition: (( or ) and ()) or (( or ) and ()).Nanami has all the\r\nhistory of changing pixels, also she has some questions of the described\r\ntype, can you answer them?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\nint n, m, q;\nconst int MAX_N = 1000 + 10;\nint a[MAX_N][MAX_N];\n\nstruct TR {\n\tbool flip, swap;\n\tint n;\n\n\tTR() {\n\t}\n\n\tTR(bool f, bool s, int n) :\n\t\t\tflip(f), swap(s), n(n) {\n\t}\n\n\tvoid trans(int&r, int&c) {\n\t\tif (swap) {\n\t\t\tstd::swap(r, c);\n\t\t}\n\t\tif (flip) {\n\t\t\tr = n - 1 - r;\n\t\t}\n\t}\n};\n\nstruct Board {\n\tint a[MAX_N][MAX_N], n, m;\n\tint up[MAX_N][MAX_N]; //r,c\n\tTR tr;\n\n\tvoid init(int n, int m, TR tr) {\n\t\tthis->n = n, this->m = m;\n\t\tthis->tr = tr;\n\t}\n\n\tvoid set(int r, int c, int x) {\n\t\ttr.trans(r, c);\n\t\ta[r][c] = x;\n\t}\n\n\tvoid reset(int r, int c, int x) {\n\t\ttr.trans(r, c);\n\t\ta[r][c] = x;\n\t\tprocessCol(c);\n\t}\n\n\tvoid processCol(int c) {\n\t\tup[0][c] = a[0][c];\n\t\tfor (int r = 1; r < n; ++r) {\n\t\t\tif (a[r][c] == 1) {\n\t\t\t\tup[r][c] = up[r - 1][c] + 1;\n\t\t\t} else {\n\t\t\t\tup[r][c] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid doit() {\n\t\tfor (int c = 0; c < m; ++c) {\n\t\t\tprocessCol(c);\n\t\t}\n\t}\n\n\tint ask(int r, int c) {\n\t\ttr.trans(r, c);\n//\t\tcout << r << \" \" << c << endl;\n\t\t//at row r, above it ,contain column c\n\t\t//min at left\n\t\tstatic int what[MAX_N];\n\t\twhat[c] = up[r][c];\n\t\tfor (int i = c - 1; i >= 0; --i) {\n\t\t\twhat[i] = min(what[i + 1], up[r][i]);\n\t\t}\n\t\tfor (int i = c + 1; i < m; ++i) {\n\t\t\twhat[i] = min(what[i - 1], up[r][i]);\n\t\t}\n\n\t\tint ans = 0;\n\t\tint R = c;\n\t\tfor (int i = c; i >= 0; --i) {\n\t\t\twhile (R + 1 < m && what[R + 1] >= what[i])\n\t\t\t\t++R;\n\t\t\tans = max(ans, what[i] * (R - i + 1));\n\t\t}\n\t\tint L = c;\n\t\tfor (int i = c; i < m; ++i) {\n\t\t\twhile (L > 0 && what[L - 1] >= what[i])\n\t\t\t\t--L;\n\t\t\tans = max(ans, what[i] * (i - L + 1));\n\t\t}\n\t\treturn ans;\n\t}\n} D[4];\n\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tscanf(\"%d\", a[i] + j);\n\t\t}\n\t}\n\tD[0].init(n, m, TR(false, false, n));\n\tD[1].init(n, m, TR(true, false, n));\n\tD[2].init(m, n, TR(false, true, m));\n\tD[3].init(m, n, TR(true, true, m));\n\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tfor (int c = 0; c < m; ++c) {\n\t\t\t\tD[i].set(r, c, a[r][c]);\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < D[i].m; ++c) {\n\t\t\tD[i].processCol(c);\n\t\t}\n\t}\n\n\twhile (q--) {\n\t\tint op;\n\t\tscanf(\"%d\", &op);\n\t\tif (op == 1) {\n\t\t\tint r, c;\n\t\t\tscanf(\"%d%d\", &r, &c), --r, --c;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tD[i].reset(r, c, 1 - a[r][c]);\n\t\t\t}\n\t\t\ta[r][c] = 1 - a[r][c];\n\t\t} else {\n\t\t\tint r, c;\n\t\t\tscanf(\"%d%d\", &r, &c), --r, --c;\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tans = max(ans, D[i].ask(r, c));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n}\n"], "input": "", "output": "", "tags": ["divide and conquer", "dp", "dsu", "implementation", "two pointers"], "dificulty": "2000", "interactive": false}