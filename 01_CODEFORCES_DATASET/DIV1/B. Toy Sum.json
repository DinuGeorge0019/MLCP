{
    "link": "https://codeforces.com//contest/406/problem/B",
    "problemId": "7388",
    "problem_idx": "B",
    "shortId": "406B",
    "contest_number": "406",
    "problem_submissions": {
        "E": [
            6113980,
            6115371,
            6117401,
            6114390,
            6114632,
            6115961,
            6113761,
            6119100,
            6122295,
            6132836,
            6117696,
            6115484
        ],
        "D": [
            6111550,
            6112818,
            6117396,
            6111602,
            6114018,
            6112889,
            6110196,
            6112558,
            6113207,
            6114342,
            6109879,
            6117233,
            6113495,
            6112560,
            6111190,
            6113785,
            6113949,
            6114279,
            6113928,
            6111720,
            6116758,
            6114622
        ],
        "C": [
            6110187,
            6111166,
            6117392,
            6115342,
            6111381,
            6110506,
            6110270,
            6108894,
            6114229,
            6110730,
            6111155,
            6113968,
            6111745,
            6111516,
            6128689,
            6128286,
            6111327,
            6111782,
            6108166
        ],
        "B": [
            6108889,
            6109179,
            6117390,
            6108130,
            6113002,
            6108132,
            6108085,
            6107339,
            6110967,
            6110982,
            6107994,
            6108825,
            6109585,
            6108127,
            6108320,
            6109839,
            6109061,
            6109268,
            6109691,
            6111113
        ],
        "A": [
            6107835,
            6107644,
            6117388,
            6107225,
            6112427,
            6117543,
            6106926,
            6106550,
            6108138,
            6107728,
            6107011,
            6108007,
            6108768,
            6106947,
            6107483,
            6108996,
            6107104,
            6108198,
            6108284,
            6109349
        ]
    },
    "name": "B. Toy Sum",
    "statement": "Little Chris is very keen on his toy blocks. His teacher, however, wants\r\nChris to solve more problems, so he decided to play a trick on\r\nChris.There are exactly blocks in Chris’s set, each block has a unique\r\nnumber from 1 to . Chris’s teacher picks a subset of blocks and keeps it\r\nto himself. He will give them back only if Chris can pick such a\r\nnon-empty subset from the remaining blocks, that the equality holds:\r\n\"Are you kidding me?\", asks Chris.For example, consider a case where and\r\nChris’s teacher took the blocks with numbers 1, 4 and 5. One way for\r\nChris to choose a set is to pick the blocks with numbers 3 and 6, see\r\nfigure. Then the required sums would be equal: . However, now Chris has\r\nexactly blocks. Given the set of blocks his teacher chooses, help Chris\r\nto find the required set !\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA \"sequence\"\n\nconst int N=1000000;\nbool A0[N+100];\nbool A[N+100];\n\nint main(){\n#ifdef __ASD__\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#else\n\t//freopen(TASKA\".in\", \"r\", stdin); freopen(TASKA\".out\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin>>n;\n\tforn(i,n){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tA0[a]=true;\n\t\tA[a]=true;\n\t}\n\tvector<int> res;\n\tint c=0;\n\tfor(int i=1;i<=N;++i){\n\t\tif(A0[i]){\n\t\t\tif(A0[N-i+1]){\n\t\t\t\tif(N-i+1>=i)\n\t\t\t\t\t++c;\n\t\t\t}else{\n\t\t\t\tA[N-i+1]=true;\n\t\t\t\tres.pb(N-i+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;++i){\n\t\tif(!c)\n\t\t\tbreak;\n\t\tif(A[i])\n\t\t\tcontinue;\n\t\tif(A[N-i+1])\n\t\t\texit(123);\n\t\t--c;\n\t\tA[i]=A[N-i+1]=true;\n\t\tres.pb(i);\n\t\tres.pb(N-i+1);\n\t}\n\t\n\tcout<<sz(res)<<endl;\n\tforv(i,res){\n\t\tprintf(\"%d \",res[i]);\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Toy Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/11186",
    "editorial": "Letâs define the symmetric number of to be . Since in this case is an\r\neven number, . Note that , i.e., the sum of a number and its symmetric\r\nis always . Letâs process the given members of . There can be two cases:\r\nHow to prove that in the second step we can always find such ? Let the\r\nnumber of symmetric pairs that were processed in the step 1 be , then\r\nthere remain other pairs. Among them, for pairs both members belong to ,\r\nand for other pairs none of the members belong to . To be able to pick\r\nthe same number of pairs for , as there are in , we should have which is\r\nequivalent to , as given in the statement. Solution complexity: .\r\n",
    "hint": []
}