{
    "link": "https://codeforces.com//contest/1261/problem/C",
    "problemId": "479748",
    "problem_idx": "C",
    "shortId": "1261C",
    "contest_number": "1261",
    "problem_submissions": {
        "F": [
            65647116,
            65658053,
            65657980,
            65657931,
            65651526,
            65649568,
            65649392,
            65651843,
            65651789,
            65643329,
            65715623,
            65660068,
            66569502,
            66569457,
            66569446,
            66563643,
            66529592,
            66529450,
            66529001,
            66528877,
            66527265,
            66527166,
            202179447,
            65759590,
            65736891,
            65656177,
            65801900,
            65656900,
            65653812
        ],
        "E": [
            65640839,
            65636308,
            65639924,
            65632814,
            65644428,
            65645126,
            65649634,
            65644543,
            65648074,
            65645492,
            65646710,
            65643401,
            65649412,
            65647298,
            65649626,
            65646791,
            65647214,
            65650131,
            65673025
        ],
        "D2": [
            65637210,
            65632855,
            65635634,
            65636824,
            65639345,
            65639544,
            65635456,
            65639090,
            65637689,
            65685918,
            65636623,
            65641288,
            65630575,
            65640353,
            65641640,
            65638704,
            65642981,
            65642369,
            65636523,
            65640625
        ],
        "D1": [
            65637138,
            65632929,
            65635559,
            65636922,
            65639374,
            65639684,
            65633638,
            65639276,
            65637859,
            65636779,
            65641185,
            65630619,
            65640390,
            65641739,
            65638754,
            65643069,
            65642429,
            65636584,
            65639802
        ],
        "C": [
            65632448,
            65642046,
            65632919,
            65640324,
            65637319,
            65636062,
            65629189,
            65635829,
            65634638,
            65686469,
            65686406,
            65686240,
            65686235,
            65686196,
            65686121,
            65686065,
            65686054,
            65686032,
            65685983,
            65685973,
            65685956,
            65633182,
            65639316,
            65636734,
            65647142,
            65634479,
            65636999,
            65635515,
            65637442,
            65637462,
            65658341,
            65640232,
            65635038
        ],
        "B1": [
            65629099,
            65627296,
            65628841,
            65642477,
            65630053,
            65629451,
            65645427,
            65631701,
            65629375,
            65639182,
            65631034,
            65637262,
            65630223,
            65630435,
            65630786,
            65631879,
            65632451,
            65627736,
            65630111
        ],
        "B2": [
            65629029,
            65627239,
            65628722,
            65642378,
            65629995,
            65629248,
            65645596,
            65631497,
            65629280,
            65720078,
            65685862,
            65639011,
            65631167,
            65637207,
            65630166,
            65630277,
            65630671,
            65631817,
            65632276,
            65627619,
            65630224
        ],
        "A": [
            65626424,
            65626236,
            65626313,
            65643924,
            65627202,
            65627360,
            65650514,
            65628121,
            65627165,
            65626869,
            65627525,
            65634172,
            65626632,
            65626977,
            65627953,
            65628262,
            65627833,
            65631529,
            65627297
        ]
    },
    "name": "C. Arson In Berland Forest",
    "statement": "The Berland Forest can be represented as an infinite cell plane. Every\r\ncell contains a tree. That is, contained before the recent events.A\r\ndestructive fire raged through the Forest, and several trees were\r\ndamaged by it. Precisely speaking, you have a n\r\ntimes m rectangle map which represents the damaged part of the Forest.\r\nThe damaged trees were marked as \"\" while the remaining ones were marked\r\nas \"\". The firemen quickly extinguished the fire, and now they are\r\ninvestigating the cause of it. The main version is that there was an\r\narson: at some moment of time (let\u2019s consider it as 0) some trees were\r\nset on fire. At the beginning of minute 0, only the trees that were set\r\non fire initially were burning. At the end of each minute, the fire\r\nspread from every burning tree to each of 8 neighboring trees. At the\r\nbeginning of minute T, the fire was extinguished.The firemen want to\r\nfind the arsonists as quickly as possible. The problem is, they know\r\nneither the value of T (how long the fire has been raging) nor the\r\ncoordinates of the trees that were initially set on fire. They want you\r\nto find the maximum value of T (to know how far could the arsonists\r\nescape) and a possible set of trees that could be initially set on\r\nfire.Note that you\u2019d like to maximize value T but the set of trees can\r\nbe arbitrary.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<string> board(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> board[i];\n  }\n  vector<vector<int>> s(n + 1, vector<int>(m + 1));\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + (board[i][j] == 'X');\n    }\n  }\n  auto check = [&](int tt) {\n    vector<vector<int>> t(n + 1, vector<int>(m + 1));\n    int r = tt * 2 + 1;\n    for (int i = 0; i <= n - r; ++i) {\n      for (int j = 0; j <= m - r; ++j) {\n        if (s[i + r][j + r] - s[i + r][j] - s[i][j + r] + s[i][j] == r * r) {\n          t[i][j]++;\n          t[i + r][j]--;\n          t[i][j + r]--;\n          t[i + r][j + r]++;\n        }\n      }\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        if (i) {\n          t[i][j] += t[i - 1][j];\n        }\n        if (j) {\n          t[i][j] += t[i][j - 1];\n        }\n        if (i && j) {\n          t[i][j] -= t[i - 1][j - 1];\n        }\n        if (board[i][j] == 'X' && !t[i][j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  int l = 0, r = n;\n  while (l < r) {\n    int mid = (l + r + 1) >> 1;\n    if (check(mid)) {\n      l = mid;\n    } else {\n      r = mid - 1;\n    }\n  }\n  cout << l << \"\\n\";\n  vector<string> ans(n, string(m, '.'));\n  r = l * 2 + 1;\n  for (int i = 0; i <= n - r; ++i) {\n    for (int j = 0; j <= m - r; ++j) {\n      if (s[i + r][j + r] - s[i + r][j] - s[i][j + r] + s[i][j] == r * r) {\n        ans[i + l][j + l] = 'X';\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    cout << ans[i] << \"\\n\";\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Arson In Berland Forest.json",
    "editorial_link": "https://codeforces.com/blog/entry/71740",
    "editorial": "Let\u00e2\u0080\u0099s note that if there is a possible configuration in which the forest\r\nburnt minutes then there is a configuration when the forest burnt\r\nminutes. So we can binary search the answer.Now we need to check the\r\nexistence of the configuration for a fixed time . Let\u00e2\u0080\u0099s find all trees\r\nthat can be set on fire. There are two equivalent conditions for such\r\ntrees: either the square of length with a center in this cell contains\r\nonly -s or a distance between the current cell and any cell with \"\" (or\r\nborder) is more or equal to .We can use any of the conditions. The first\r\ncondition can be checked with prefix sums on 2D - we can precalculate\r\nthem one time and use them to take a sum on a rectangle. The second\r\ncondition can be checked by running bfs from all \"\"-s or borders (or\r\nfrom -s which are neighboring to \"\"-s or to the borders) also one time\r\nbefore the binary search.The second step is to check that it\u00e2\u0080\u0099s possible\r\nto cover all burnt trees starting from all set-on-fire trees. We can\r\ncheck it either with \"add value on a rectangle\" (using prefix sums)\r\nsince each set-on-fire tree will burn a square with center in it. Or,\r\nalternatively, we can run bfs from set-on-fire trees.Anyways, both\r\nalgorithms have complexity. And, since all damaged trees are shown on\r\nthe map, the answer can\u00e2\u0080\u0099t be more than . So, the total complexity is .\r\n"
}