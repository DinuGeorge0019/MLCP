{
    "link": "https://codeforces.com//contest/585/problem/B",
    "problemId": "37965",
    "problem_idx": "B",
    "shortId": "585B",
    "contest_number": "585",
    "problem_submissions": {
        "E": [
            13568408,
            13565539,
            13570428,
            13569433,
            13562876,
            13568414,
            13569561,
            13572183,
            16851653,
            13569075,
            13575618,
            14433103,
            14433079,
            13586801,
            14994906
        ],
        "D": [
            13563803,
            13560460,
            13565708,
            13598452,
            13575351,
            13570446,
            13565845,
            13564574,
            13569714,
            13567701,
            13566576,
            13567580,
            13566498,
            13559261,
            13566963,
            13566457,
            13569728,
            13568576
        ],
        "C": [
            13561640,
            13569007,
            13569377,
            13560848,
            13567147,
            13570951,
            13564734,
            13564195,
            13562727,
            13563205,
            13570079,
            13563945,
            13564180,
            13570698,
            13565134,
            13564377
        ],
        "B": [
            13558808,
            13566721,
            13560966,
            13559388,
            13575429,
            13561963,
            13558427,
            13563703,
            16850949,
            13561366,
            13561440,
            13558802,
            13567542,
            13562248,
            13560363,
            13561318,
            13562539
        ],
        "A": [
            13556266,
            13558452,
            13556785,
            13558546,
            13586871,
            13556142,
            16850921,
            13556990,
            13562212,
            13561943,
            13585791,
            13560017,
            13556037,
            13558619,
            13558552
        ],
        "F": [
            13587655,
            13575255,
            13575217,
            16850828,
            24552744,
            14433355
        ]
    },
    "name": "B. Phillip and Trains",
    "statement": "The mobile application store has a new game called \"Subway Roller\".The\r\nprotagonist of the game Philip is located in one end of the tunnel and\r\nwants to get out of the other one. The tunnel is a rectangular field\r\nconsisting of three rows and columns. At the beginning of the game the\r\nhero is in some cell of the leftmost column. Some number of trains rides\r\ntowards the hero. Each train consists of two or more neighbouring cells\r\nin some row of the field.All trains are moving from right to left at a\r\nspeed of two cells per second, and the hero runs from left to right at\r\nthe speed of one cell per second. For simplicity, the game is\r\nimplemented so that the hero and the trains move in turns. First, the\r\nhero moves one cell to the right, then one square up or down, or stays\r\nidle. Then all the trains move twice simultaneously one cell to the\r\nleft. Thus, in one move, Philip definitely makes a move to the right and\r\ncan move up or down. If at any point, Philip is in the same cell with a\r\ntrain, he loses. If the train reaches the left column, it continues to\r\nmove as before, leaving the tunnel.Your task is to answer the question\r\nwhether there is a sequence of movements of Philip, such that he would\r\nbe able to get to the rightmost column.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int N = 111;\nint n;\nchar t[3][N];\nbool dp[N][3];\nbool g[N][3][N];\n\nvoid read()\n{\n    int z;\n    scanf(\"%d%d\", &n, &z);\n    for (int i = 0; i < 3; i++)\n        scanf(\" %s \", t[i]);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < n; j++)\n            dp[j][i] = false;\n    for (int i = 0; i < 3; i++)\n        if (t[i][0] == 's')\n        {\n            dp[0][i] = true;\n            t[i][0] = '.';\n        }\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < n; j++)\n            g[0][i][j] = (t[i][j] == '.');\n    for (int i = 1; i < n; i++)\n        for (int x = 0; x < 3; x++)\n            for (int y = 0; y < n; y++)\n            {\n                int ny = y + 2 * i;\n                g[i][x][y] = ny >= n || g[0][x][ny];\n            }\n    for (int i = 0; i < n - 1; i++)\n        for (int x = 0; x < 3; x++)\n        {\n            if (!dp[i][x]) continue;\n            if (!g[i][x][i + 1]) continue;\n            for (int nx = x - 1; nx <= x + 1; nx++)\n            {\n                if (nx < 0 || nx >= 3) continue;\n                if (!g[i][nx][i + 1]) continue;\n                if (!g[i + 1][nx][i + 1]) continue;\n                dp[i + 1][nx] = true;\n            }\n        }\n    bool ans = false;\n    for (int i = 0; i < 3; i++)\n        ans |= dp[n - 1][i];\n    if (ans)\n        printf(\"YES\\n\");\n    else\n        printf(\"NO\\n\");\n    return;\n}\n\nvoid solve()\n{\n    read();\n}\n\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    while(t--)\n        solve();\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Phillip and Trains.json",
    "editorial_link": "https://codeforces.com//blog/entry/20898",
    "editorial": "The problem has been prepared by IlyaLos. One could consider a graph\r\nwith vertices corresponding to every position. I should notice that\r\ntrain positions for each Phillip position are fully restorable from his\r\ncoordinate. Edge between vertices and means that we could get from\r\nposition corresponding to to position corresponding by in one turn\r\nwithout moving onto a train cell or moving in a cell which will be\r\noccupied by some train before the next turn. All we need next is to find\r\nwhether any finishing position is reachable from the only starting\r\nposition (using BFS or DFS, or, as soon as graph is a DAG, dynamic\r\nprogramming). As soon as graph has vertices and edges, solution\r\ncomplexity equals to .\r\n",
    "hint": []
}