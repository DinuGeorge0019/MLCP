{
    "link": "https://codeforces.com//contest/1109/problem/C",
    "problemId": "298871",
    "problem_idx": "C",
    "shortId": "1109C",
    "contest_number": "1109",
    "problem_submissions": {
        "E": [
            50026873,
            50038594,
            50033088,
            50025271,
            50029128,
            50029427,
            50028676,
            50028977,
            50035588,
            50034800,
            50030219,
            50030201,
            50018221,
            50030444,
            50031682,
            50021323,
            50035024,
            50031663,
            50032167,
            50027503
        ],
        "C": [
            50018224,
            50032258,
            50027083,
            50523597,
            50061049,
            50019096,
            50015185
        ],
        "D": [
            50006360,
            50006283,
            50016138,
            50011686,
            50015522,
            50017005,
            50014754,
            50017015,
            50015842,
            50036394,
            50036291,
            50035638,
            50015625,
            50018432,
            50025929,
            50017587,
            50016208,
            50029181,
            50013944,
            50013609,
            50026717,
            50030603,
            50031093
        ],
        "B": [
            50001043,
            50019350,
            50007187,
            50004994,
            50003589,
            50005230,
            50000704,
            50008934,
            50007447,
            50003085,
            50002442,
            50022126,
            50007014,
            50005280,
            50003394,
            50003776,
            50016263,
            50000661,
            50002322,
            50006926
        ],
        "A": [
            49999265,
            49999276,
            50001550,
            50004725,
            49999432,
            50001055,
            49999266,
            50001592,
            49999413,
            50035642,
            49999326,
            49999231,
            50019325,
            50000549,
            50000251,
            49999282,
            49999284,
            49999278,
            49999235,
            49999298,
            49999812
        ],
        "F": [
            50024623,
            158339458,
            50027544,
            50158209,
            95343531
        ]
    },
    "name": "C. Sasha and a Patient Friend",
    "statement": "Fedya and Sasha are friends, that’s why Sasha knows everything about\r\nFedya.Fedya keeps his patience in an infinitely large bowl. But, unlike\r\nthe bowl, Fedya’s patience isn’t infinite, that is why let v be the\r\nnumber of liters of Fedya’s patience, and, as soon as v becomes to 0,\r\nthe bowl will burst immediately. There is one tap in the bowl which\r\npumps s liters of patience per second. Notice that s can be negative, in\r\nthat case, the tap pumps out the patience. Sasha can do different\r\nthings, so he is able to change the tap’s speed. All actions that Sasha\r\ndoes can be represented as q queries. There are three types of queries:\r\n\"\" add a new event, means that starting from the t-th second the tap’s\r\nspeed will be equal to s. \"\" delete the event which happens at the t-th\r\nsecond. It is guaranteed that such event exists. \"\" Sasha wonders: if\r\nyou take all the events for which l\r\nle t\r\nle r and simulate changes of Fedya’s patience from the very beginning of\r\nthe l-th second till the very beginning of the r-th second inclusive\r\n(the initial volume of patience, at the beginning of the l-th second,\r\nequals to v liters) then when will be the moment when the bowl will\r\nburst. If that does not happen, then the answer will be -1. Since Sasha\r\ndoes not want to check what will happen when Fedya’s patience ends, and\r\nhe has already come up with the queries, he is asking you to help him\r\nand find the answer for each query of the 3-rd type.It is guaranteed\r\nthat at any moment of time, there won’t be two events which happen at\r\nthe same second.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct Node {\n\tint L, R;\n\tint t, y;\n\tll s;\n\tll sumToLast, minSum, firstT, lastT, lastS;\n\n\tNode() : L(-1), R(-1), t(), y(rng()), s(), sumToLast(), minSum(), firstT(), lastT(), lastS() {}\n};\nconst int N = 100100;\nint treeSz;\nNode tree[N];\n\nint getNode() {\n\treturn treeSz++;\n}\nint update(int v) {\n\tif (v == -1) return -1;\n\tll sumToLast = 0, minSum = 0;\n\tll firstT = tree[v].t, lastT = tree[v].t, lastS = tree[v].s;\n\tif (tree[v].L != -1) {\n\t\tint tL = tree[v].L;\n\t\tminSum = min(minSum, sumToLast + tree[tL].minSum);\n\t\tsumToLast += tree[tL].sumToLast;\n\t\tfirstT = tree[tL].firstT;\n\t\tsumToLast += (tree[v].t - tree[tL].lastT) * tree[tL].lastS;\n\t\tminSum = min(minSum, sumToLast);\n\t}\n\tif (tree[v].R != -1) {\n\t\tint tR = tree[v].R;\n\t\tsumToLast += (tree[tR].firstT - tree[v].t) * tree[v].s;\n\t\tminSum = min(minSum, sumToLast);\n\t\tminSum = min(minSum, sumToLast + tree[tR].minSum);\n\t\tsumToLast += tree[tR].sumToLast;\n\t\tlastT = tree[tR].lastT;\n\t\tlastS = tree[tR].lastS;\n\t}\n\ttree[v].sumToLast = sumToLast;\n\ttree[v].minSum = minSum;\n\ttree[v].firstT = firstT;\n\ttree[v].lastT = lastT;\n\ttree[v].lastS = lastS;\n\treturn v;\n}\n\nint merge(int L, int R) {\n\tif (L == -1) return R;\n\tif (R == -1) return L;\n\tif (tree[L].y > tree[R].y) {\n\t\ttree[L].R = merge(tree[L].R, R);\n\t\treturn update(L);\n\t} else {\n\t\ttree[R].L = merge(L, tree[R].L);\n\t\treturn update(R);\n\t}\n}\nvoid split(int v, int t, int &L, int &R) {\n\tif (v == -1) {\n\t\tL = R = -1;\n\t\treturn;\n\t}\n\tif (tree[v].t >= t) {\n\t\tsplit(tree[v].L, t, L, tree[v].L);\n\t\tR = update(v);\n\t} else {\n\t\tsplit(tree[v].R, t, tree[v].R, R);\n\t\tL = update(v);\n\t}\n}\n\nvoid printAns(int v, ll w, ll t, ll r) {\n\tif (w <= 0) {\n\t\tprintf(\"%lld\\n\", t);\n\t\treturn;\n\t}\n\t//\teprintf(\"in printAns\\n\");\n\tif (v == -1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\twhile(true) {\n\t\tif (w + tree[v].minSum > 0) {\n\t\t\tw += tree[v].sumToLast;\n\t\t\t//eprintf(\"w = %lld, s = %lld\\n\", w, tree[v].lastS);\n\t\t\tt = tree[v].lastT;\n\t\t\tif (w + (r - t) * tree[v].lastS > 0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdouble tm = (double)w / (-tree[v].lastS);\n\t\t\tprintf(\"%.12lf\\n\", t + tm);\n\t\t\treturn;\n\t\t}\n\t\tif (tree[v].L != -1) {\n\t\t\tint tL = tree[v].L;\n\t\t\tif (w + tree[tL].minSum <= 0) {\n\t\t\t\tv = tL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw += tree[tL].sumToLast;\n\t\t\tif (w + (tree[v].t - tree[tL].lastT) * tree[tL].lastS <= 0) {\n\t\t\t\tdouble tm = (double)w / (-tree[tL].lastS);\n\t\t\t\tprintf(\"%.12lf\\n\", tree[tL].lastT + tm);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tw += (tree[v].t - tree[tL].lastT) * tree[tL].lastS;\n\t\t}\n\t\tif (tree[v].R == -1) throw;\n\t\tint tR = tree[v].R;\n\t\tif (w + (tree[tR].firstT - tree[v].t) * tree[v].s <= 0) {\n\t\t\tdouble tm = (double)w / (-tree[v].s);\n\t\t\tprintf(\"%.12lf\\n\", tree[v].t + tm);\n\t\t\treturn;\n\t\t}\n\t\tw += (tree[tR].firstT - tree[v].t) * tree[v].s;\n\t\tt = tree[tR].firstT;\n\t\tv = tR;\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint root = -1;\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint tp;\n\t\tscanf(\"%d\", &tp);\n\t\tif (tp == 1) {\n\t\t\tint t, s;\n\t\t\tscanf(\"%d%d\", &t, &s);\n\t\t\tint L, R;\n\t\t\tsplit(root, t, L, R);\n\t\t\tint v = getNode();\n\t\t\ttree[v].t = t;\n\t\t\ttree[v].s = s;\n\t\t\tv = update(v);\n\t\t\troot = merge(merge(L, v), R);\n\t\t} else if (tp == 2) {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tint L, M, R;\n\t\t\tsplit(root, t, L, M);\n\t\t\tsplit(M, t + 1, M, R);\n\t\t\troot = merge(L, R);\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tll w;\n\t\t\tscanf(\"%d%d%lld\", &l, &r, &w);\n\t\t\tint L, M, R;\n\t\t\tsplit(root, l, L, M);\n\t\t\tsplit(M, r, M, R);\n\n\t\t\tprintAns(M, w, l, r);\n\n\t\t\troot = merge(merge(L, M), R);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "implementation"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Sasha and a Patient Friend.json",
    "editorial_link": "https://codeforces.com//blog/entry/65295",
    "editorial": "Letâs keep not deleted pairs () in a treap where will be the key of some\r\nnode. Also we need some auxiliary variables. So each node in the treap\r\nwill store that: time of the event speed of the tap since second , the\r\nminimum and the maximum in the subtree of that node the of the event\r\nwith maximum in the subtree of that node the value of patience after\r\nprocessing all events from the subtree (we assume that the value before\r\n-th second is ) what is the minumum value of patience if we process all\r\nevents from the subtree (also initial value is ) links to the left child\r\nand to the right child It turns out that this information is enough. Now\r\nto make treap work correctly it should be possible to merge two chilrens\r\nof some node. Letâs look how to do it (suppose that this node has either\r\nleft child () or right child ()): doesnât change doesnât change , , It\r\nis easier to calculate and simulatenously. Look at this block of code:\r\nmn = 0, res = 0 mn = min(mn, LC.mn) res += LC.res + LC.speedR * (time -\r\nLC.tR) mn = min(mn, res) res += speed * (RC.tL - time) mn = min(mn,\r\nres + RC.mn) res += RC.res mn = min(mn, res) It goes through all\r\npossible periods of time where can be, and finds the best one, during\r\nthis it calculates . If there is no left or right child then the\r\ncalculation doenât change too much.So if you have function then you can\r\ndo , , , .You can answer queries of the -rd type in the following way.\r\nCut out the needed range from the treap. And go down the treap starting\r\nfrom the root while you can (you go to the left child, if the value of\r\npatience becomes equal to earlier than , you can check that using the\r\nimformation stored in nodes, then check the right one if it is needed).\r\nSo it is left to consider some extreme cases, which I leave you as and\r\nexercise, and that is all. The complexity is . If you donât like treaps,\r\nyou can actually use segment tree on pointers, or make coordinate\r\ncompression and write a simple segment tree, the complexity will stay\r\nthe same.\r\n",
    "hint": []
}