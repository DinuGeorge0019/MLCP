{
    "link": "https://codeforces.com//contest/238/problem/C",
    "problemId": "2113",
    "problem_idx": "C",
    "shortId": "238C",
    "contest_number": "238",
    "problem_submissions": {
        "E": [
            2504243,
            2503858,
            2509891,
            2694210,
            2552413
        ],
        "B": [
            2501797,
            2504771,
            2501096,
            2501711,
            2501715,
            2500046,
            2500118,
            2500703,
            2501297,
            2500963,
            2500837,
            2501321,
            2500477,
            2500698,
            2502278,
            2501139,
            2500966,
            2501060,
            2501238
        ],
        "C": [
            2500671,
            2502160,
            2502349,
            2502372,
            2500466,
            2501719,
            2501950,
            2502275,
            2502065,
            2502329,
            2502087,
            2502235,
            2501641,
            2502453,
            2501221,
            2502604,
            2502443,
            2502751,
            2503154
        ],
        "A": [
            2498142,
            2498095,
            2498716,
            2498060,
            2498106,
            2498185,
            2498628,
            2498741,
            2498627,
            2498605,
            2499081,
            2498586,
            2498140,
            2501538,
            2498125,
            2498688,
            2499407,
            2498390
        ],
        "D": [
            2556123,
            2505008
        ]
    },
    "name": "C. World Eater Brothers",
    "statement": "You must have heard of the two brothers dreaming of ruling the world.\r\nWith all their previous plans failed, this time they decided to\r\ncooperate with each other in order to rule the world. As you know there\r\nare countries in the world. These countries are connected by directed\r\nroads. If you don’t consider direction of the roads there is a unique\r\npath between every pair of countries in the world, passing through each\r\nroad at most once. Each of the brothers wants to establish his reign in\r\nsome country, then it’s possible for him to control the countries that\r\ncan be reached from his country using directed roads. The brothers can\r\nrule the world if there exists at most two countries for brothers to\r\nchoose (and establish their reign in these countries) so that any other\r\ncountry is under control of at least one of them. In order to make this\r\npossible they want to change the direction of minimum number of roads.\r\nYour task is to calculate this minimum number of roads.\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int N = 42424;\n\nint ss[N], ff[N], pred[N], last[N], was[N], sz[N];\nint n, m, ans, i, st;\n\nvoid dfs0(int v) {\n  was[v] = 1;\n  sz[v] = 0;\n  int j = last[v];\n  while (j > 0) {\n    if (!was[ff[j]]) {\n      dfs0(ff[j]);\n      sz[v] += sz[ff[j]];\n      if (j > m) sz[v]++;\n    }\n    j = pred[j];\n  }\n}\n\nvoid dfs(int v, int w, int s, int mn, int p) {\n  was[v] = 1;\n  int cur = w;\n  int j = last[v];\n  while (j > 0) {\n    if (!was[ff[j]]) {\n      cur += sz[ff[j]];\n      if (j > m) cur++;\n    }\n    j = pred[j];\n  }\n  if (cur+s+mn < ans) ans = cur+s+mn;\n  j = last[v];\n  while (j > 0) {\n    if (!was[ff[j]]) {\n      int cc = cur-sz[ff[j]];\n      if (j > m) cc--;\n      int newp = p+1, news = s;\n      if (j <= m) news++;\n      int newmn = mn;\n      if (newp-2*news < newmn) newmn = newp-2*news;\n      dfs(ff[j], cc, news, newmn, newp);\n    }\n    j = pred[j];\n  }\n}\n\nint main() {\n//  freopen(\"in\", \"r\", stdin);\n//  freopen(\"out\", \"w\", stdout);\n  scanf(\"%d\", &n);\n  m = n-1;\n  for (i=1;i<=m;i++) {\n    scanf(\"%d %d\", ss+i, ff+i);\n    ss[i+m] = ff[i];\n    ff[i+m] = ss[i];\n  }\n  for (i=1;i<=n;i++) last[i] = 0;\n  for (i=1;i<=m+m;i++) {\n    pred[i] = last[ss[i]];\n    last[ss[i]] = i;\n  }\n  ans = 424242;\n  for (st=1;st<=n;st++) {\n    for (i=1;i<=n;i++) was[i] = 0;\n    dfs0(st);\n    for (i=1;i<=n;i++) was[i] = 0;\n    dfs(st, 0, 0, 0, 0);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. World Eater Brothers.json",
    "editorial_link": "https://codeforces.com//blog/entry/5765",
    "editorial": "Consider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.\n\nConsider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.\n\nWe want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).",
    "hint": []
}