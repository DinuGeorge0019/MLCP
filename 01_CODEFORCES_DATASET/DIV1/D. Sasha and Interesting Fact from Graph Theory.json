{
    "link": "https://codeforces.com//contest/1109/problem/D",
    "problemId": "298872",
    "problem_idx": "D",
    "shortId": "1109D",
    "contest_number": "1109",
    "problem_submissions": {
        "E": [
            50026873,
            50038594,
            50033088,
            50025271,
            50029128,
            50029427,
            50028676,
            50028977,
            50035588,
            50034800,
            50030219,
            50030201,
            50018221,
            50030444,
            50031682,
            50021323,
            50035024,
            50031663,
            50032167,
            50027503
        ],
        "C": [
            50018224,
            50032258,
            50027083,
            50523597,
            50061049,
            50019096,
            50015185
        ],
        "D": [
            50006360,
            50006283,
            50016138,
            50011686,
            50015522,
            50017005,
            50014754,
            50017015,
            50015842,
            50036394,
            50036291,
            50035638,
            50015625,
            50018432,
            50025929,
            50017587,
            50016208,
            50029181,
            50013944,
            50013609,
            50026717,
            50030603,
            50031093
        ],
        "B": [
            50001043,
            50019350,
            50007187,
            50004994,
            50003589,
            50005230,
            50000704,
            50008934,
            50007447,
            50003085,
            50002442,
            50022126,
            50007014,
            50005280,
            50003394,
            50003776,
            50016263,
            50000661,
            50002322,
            50006926
        ],
        "A": [
            49999265,
            49999276,
            50001550,
            50004725,
            49999432,
            50001055,
            49999266,
            50001592,
            49999413,
            50035642,
            49999326,
            49999231,
            50019325,
            50000549,
            50000251,
            49999282,
            49999284,
            49999278,
            49999235,
            49999298,
            49999812
        ],
        "F": [
            50024623,
            158339458,
            50027544,
            50158209,
            95343531
        ]
    },
    "name": "D. Sasha and Interesting Fact from Graph Theory",
    "statement": "Once, during a lesson, Sasha got bored and decided to talk with his\r\nfriends. Suddenly, he saw Kefa. Since we can talk endlessly about Kefa,\r\nwe won\u2019t even start doing that. The conversation turned to graphs. Kefa\r\npromised Sasha to tell him about one interesting fact from graph theory\r\nif Sasha helps Kefa to count the number of . In this task, a is a\r\nweighted connected graph, consisting of n vertices and n-1 edges, and\r\nweights of edges are integers from 1 to m. Kefa determines the beauty of\r\na tree as follows: he finds in the tree his two favorite vertices\r\nvertices with numbers a and b, and counts the distance between them. The\r\ndistance between two vertices x and y is the sum of weights of edges on\r\nthe simple path from x to y. If the distance between two vertices a and\r\nb is to m, then the tree is .Sasha likes graph theory, and even more,\r\nSasha likes interesting facts, that\u2019s why he agreed to help Kefa.\r\nLuckily, Sasha is familiar with you . Help Sasha to count the number of\r\ntrees for Kefa. Two trees are considered to be distinct if there is an\r\nedge that occurs in one of them and doesn\u2019t occur in the other one.\r\nEdge\u2019s .Kefa warned Sasha, that there can be too many beautiful trees,\r\nso it will be enough to count the number modulo 10^9 + 7.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = (int)1e6 + 7;\nll f[N], rf[N];\nll pw1[N], pw2[N];\nint n, m;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\trf[0] = rf[1] = 1;\n\tfor (ll x = 2; x < N; x++)\n\t\trf[x] = sub(0, mult(MOD / x, rf[MOD % x]));\n\tfor (int i = 2; i < N; i++)\n\t\trf[i] = mult(rf[i - 1], rf[i]);\n\tf[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tf[i] = mult(f[i - 1], i);\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tpw1[0] = pw2[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tpw1[i] = mult(pw1[i - 1], n);\n\t\tpw2[i] = mult(pw2[i - 1], m);\n\t}\n\n\tll ans = 0;\n\tfor (int k = 1; k < n - 1 && k <= m; k++) {\n\t\tll cur = k + 1;\n\t\tcur = mult(cur, pw1[n - k - 2]);\n\t\tcur = mult(cur, f[n - 2]);\n\t\tcur = mult(cur, rf[n - k - 1]);\n\t\tcur = mult(cur, f[m - 1]);\n\t\tcur = mult(cur, rf[k - 1]);\n\t\tcur = mult(cur, rf[m - k]);\n\t\tcur = mult(cur, pw2[n - 1 - k]);\n\t\tans = add(ans, cur);\n\t}\n\tif (n - 1 <= m) {\n\t\tll cur = f[n - 2];\n\t\tcur = mult(cur, f[m - 1]);\n\t\tcur = mult(cur, rf[n - 2]);\n\t\tcur = mult(cur, rf[m - n + 1]);\n\t\tans = add(ans, cur);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "dp",
        "math",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Sasha and Interesting Fact from Graph Theory.json",
    "editorial_link": "https://codeforces.com//blog/entry/65295",
    "editorial": "Let\u00e2\u0080\u0099s fix the number of edges on the path between and . Then on this\r\npath there are vertices between and , and they can be choosen in ways.\r\nThe amount of ways to place numbers on edges in such a way, that their\r\nsum is equal to , is (stars and bars method). If an edge doesn\u00e2\u0080\u0099t belong\r\nto out path, then doesn\u00e2\u0080\u0099t metter what number is written on it, so we can\r\nmultiply answer by . Now, we want to form a forest from remaining\r\nvertices and to hang it to any of vertexes from our path. According to\r\none of generalizations of Cayley\u00e2\u0080\u0099s formula, number of forsests of\r\nvertices, where vertices belong to different trees is . So for fixed we\r\ngot the formula Complexity is or , in case you precompute all powers,\r\nfactorials and thier inverse in linear time.\r\n"
}