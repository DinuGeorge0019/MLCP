{"link": "https://codeforces.com//contest/1179/problem/C", "problemId": "361546", "problem_idx": "C", "shortId": "1179C", "contest_number": "1179", "problem_submissions": {"E": [55903813, 55902523, 55901885, 55909022, 55905388, 56432061, 75942632, 56023295], "D": [55893003, 55895931, 55888725, 55893104, 71080559, 71080196, 71080163, 71080130, 71080072, 71080060, 55893173, 55892658, 55908319, 55894131, 55894542, 55893763, 55896830, 56019124, 55897859, 55895869, 55954689, 55895158, 55899492, 55899301, 55888559, 55898280, 55898257, 55896770], "C": [55884160, 55884795, 55882131, 55884686, 55905440, 55885364, 55885156, 55885262, 55885328, 55886216, 55885322, 55883584, 55886444, 55954679, 55890192, 55886511, 55887224, 55900785, 55886889, 55887130, 55889061], "B": [55880474, 55886283, 55907977, 55879717, 55880717, 55880688, 55881071, 55881636, 55881390, 55878893, 55881077, 55881153, 55954669, 55881453, 55881368, 55881391, 55880057, 55884243, 55877081, 55883081], "A": [55876049, 55878221, 55877438, 55877168, 55878263, 55877701, 55876941, 55878391, 55879288, 55877277, 55877221, 55878361, 55954661, 55878330, 55878077, 55877852, 55877332, 55880624, 55880725, 55879783]}, "name": "C. Serge and Dining Room", "statement": "Serge came to the school dining room and discovered that there is a big\r\nqueue here. There are m pupils in the queue. He\u2019s not sure now if he\r\nwants to wait until the queue will clear, so he wants to know which dish\r\nhe will receive if he does. As Serge is very tired, he asks you to\r\ncompute it instead of him.Initially there are n dishes with costs a_1,\r\na_2,\r\nldots, a_n. As you already know, there are the queue of m pupils who\r\nhave b_1,\r\nldots, b_m togrogs respectively (pupils are enumerated by queue order,\r\ni.e the first pupil in the queue has b_1 togrogs and the last one has\r\nb_m togrogs)Pupils think that the most expensive dish is the most\r\ndelicious one, so every pupil just buys the most expensive dish for\r\nwhich he has money (every dish has a single copy, so when a pupil has\r\nbought it nobody can buy it later), and if a pupil doesn\u2019t have money\r\nfor any dish, he just leaves the queue (so brutal capitalism...)But\r\nmoney isn\u2019t a problem at all for Serge, so Serge is buying the most\r\nexpensive dish if there is at least one remaining.Moreover, Serge\u2019s\r\nschool has a very unstable economic situation and the costs of some\r\ndishes or number of togrogs of some pupils can change. More formally,\r\nyou must process q queries: change a_i to x. It means that the price of\r\nthe i-th dish becomes x togrogs. change b_i to x. It means that the i-th\r\npupil in the queue has x togrogs now. Nobody leaves the queue during\r\nthose queries because a saleswoman is late.After every query, you must\r\ntell Serge price of the dish which he will buy if he has waited until\r\nthe queue is clear, or -1 if there are no dishes at this point,\r\naccording to rules described above.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=2200*1007;\nconst int n1=(1<<20);\n\nint n, m;\n\nint ta[nax];\nint tb[nax];\n\nint narz[nax];\nint pod[nax];\n\nint daj(int v)\n{\n\treturn narz[v]+pod[v];\n}\n\nvoid upd(int v)\n{\n\tpod[v]=max(daj(v*2), daj(v*2+1));\n}\n\nvoid pisz(int v, int a, int b, int graa, int grab, int w)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\tnarz[v]+=w;\n\t\treturn;\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn;\n\t}\n\tpisz((v<<1), a, (a+b)>>1, graa, grab, w);\n\tpisz((v<<1)^1, (a+b+2)>>1, b, graa, grab, w);\n\tupd(v);\n}\n\nint szuk(int v, int a, int b, int wie)\n{\n\tif (a==b)\n\t\treturn a;\n\twie-=narz[v];\n\tif (daj(v*2+1)>wie)\n\t\treturn szuk((v<<1)^1, (a+b+2)>>1, b, wie);\n\treturn szuk((v<<1), a, (a+b)>>1, wie);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &ta[i]);\n\t\tpisz(1, 1, n1, 1, ta[i], 1);\n\t}\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tscanf(\"%d\", &tb[i]);\n\t\tpisz(1, 1, n1, 1, tb[i], -1);\n\t}\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile(q--)\n\t{\n\t\tint typ, a, b;\n\t\tscanf(\"%d%d%d\", &typ, &a, &b);\n\t\tif (typ==1)\n\t\t{\n\t\t\tpisz(1, 1, n1, 1, ta[a], -1);\n\t\t\tta[a]=b;\n\t\t\tpisz(1, 1, n1, 1, ta[a], 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpisz(1, 1, n1, 1, tb[a], 1);\n\t\t\ttb[a]=b;\n\t\t\tpisz(1, 1, n1, 1, tb[a], -1);\n\t\t}\n\t\tif (daj(1)<=0)\n\t\t\tprintf(\"-1\\n\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", szuk(1, 1, n1, 0));\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "graph matchings", "greedy", "implementation", "math", "trees"], "dificulty": "2200", "interactive": false}