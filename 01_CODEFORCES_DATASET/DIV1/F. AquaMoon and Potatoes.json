{
    "link": "https://codeforces.com//contest/1545/problem/F",
    "problemId": "1042723",
    "problem_idx": "F",
    "shortId": "1545F",
    "contest_number": "1545",
    "problem_submissions": {
        "D": [
            122107122,
            122101318,
            122112155,
            122104020,
            122109653,
            122107428,
            122115750,
            122116493,
            122121641,
            122123526,
            122112699,
            122120695,
            122128586,
            122117389,
            122107326,
            122130554,
            122090817,
            122093272,
            122093535
        ],
        "C": [
            122095530,
            122110873,
            122098409,
            122112986,
            122088985,
            122122234,
            122107021,
            122110115,
            122100227,
            122102454,
            122124600,
            122110793,
            122110757,
            122109117,
            122128432,
            122119096,
            122155152,
            122213467
        ],
        "A": [
            122082186,
            122076078,
            122075671,
            122076509,
            122122714,
            122075627,
            122075591,
            122075678,
            122076215,
            122076949,
            122075854,
            122076317,
            122085649,
            122075796,
            122075639,
            122080513,
            122075936,
            122075621,
            122078770
        ],
        "B": [
            122079612,
            122088170,
            122082472,
            122119780,
            122079771,
            122077496,
            122090297,
            122081981,
            122082032,
            122084749,
            122098370,
            122095139,
            122093255,
            122128209,
            122084402,
            122088184,
            122078878,
            122077599,
            122119388
        ],
        "F": [
            122258728,
            122258683,
            122258676,
            122258661,
            122258513,
            122258288,
            122147603,
            122158393,
            122158209
        ],
        "E2": [
            122155943,
            122135135
        ],
        "E1": [
            122155936,
            122155364,
            122153713,
            122135243
        ]
    },
    "name": "F. AquaMoon and Potatoes",
    "statement": "AquaMoon has three integer arrays a, b, c of length n, where 1\r\nleq a_i, b_i, c_i\r\nleq n for all i.In order to accelerate her potato farming, she organizes\r\nher farm in a manner based on these three arrays. She is now going to\r\ncomplete m operations to count how many potatoes she can get. Each\r\noperation will have one of the two types: AquaMoon reorganizes their\r\nfarm and makes the k-th element of the array a equal to x. In other\r\nwords, perform the assignment a_k := x. Given a positive integer r,\r\nAquaMoon receives a potato for each triplet (i,j,k), such that 1\r\nle i<j<k\r\nle r, and b_{a_i}=a_j=c_{a_k}. Count the number of such triplets. As\r\nAquaMoon is busy finding the library, help her complete all of their\r\noperations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << \"\\n\"; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\nint N,M;\nV<AR<int,3>> val;\nint BLOCK = 1;\n\nvoid sub(vi& v) { each(t,v) --t; }\n\nstruct RangeQuery {\n\tstatic constexpr int SZ = 450;\n\tll block_sum[SZ];\n\tll sing[SZ*SZ];\n\tll get_sum(int r) {\n\t\tll ans = 0; while (r%BLOCK != 0) ans += sing[--r];\n\t\tfor (r /= BLOCK;r;) ans += block_sum[--r];\n\t\treturn ans;\n\t}\n\tvoid increment(int x, ll v) {\n\t\tblock_sum[x/BLOCK] += v;\n\t\tsing[x] += v;\n\t}\n};\n\nRangeQuery RQ;\n\nvpi cur[MX];\n\n#ifdef LOCAL\nconst int THRESH = 0;\n#else\nconst int THRESH = 1500;\n#endif\n\nvi oc;\nvoid contrib(int v, int sgn) {\n\tif (oc[v] > THRESH) return;\n\tint one = 0; ll two = 0;\n\teach(t,cur[v]) {\n\t\tif (t.s == 0) {\n\t\t\t++one;\n\t\t} else if (t.s == -1) {\n\t\t\ttwo += one;\n\t\t} else if (t.s == -2) {\n\t\t\tRQ.increment(t.f,sgn*two);\n\t\t}\n\t}\n}\n\nvoid upd(int pos, int j, int sgn) {\n\tint v = val[pos][j];\n\tif (oc[v] > THRESH) return;\n\tcontrib(v,-1);\n\tpi p{pos,-j};\n\tif (sgn == -1) {\n\t\tauto it = find(all(cur[v]),p); assert(it != end(cur[v]));\n\t\tcur[v].erase(it);\n\t} else {\n\t\tauto it = lb(all(cur[v]),p); cur[v].ins(it,p);\n\t}\n\tcontrib(v,1);\n}\n\nvi A, B, C;\nvoid add_oc(int x) { ++oc[B[x]], ++oc[x], ++oc[C[x]]; }\n\nvl ans;\nV<tuple<int,int,int>> queries;\n\nvoid deal_small() {\n\tF0R(i,N) {\n\t\tval[i] = {B[A[i]],A[i],C[A[i]]};\n\t\tR0F(j,3) cur[val[i][j]].pb({i,-j});\n\t}\n\tF0R(i,N) contrib(i,1);\n\teach(t,queries) {;\n\t\tauto [type,_a,_b] = t;\n\t\tif (type == 1) {\n\t\t\tauto [_,i,x] = t; \n\t\t\tF0R(j,3) upd(i,j,-1);\n\t\t\tval[i] = {B[x],x,C[x]};\n\t\t\tF0R(j,3) upd(i,j,1);\n\t\t} else {\n\t\t\tauto [_a,r,_b] = t;\n\t\t\tans.pb(RQ.get_sum(r));\n\t\t}\n\t}\n}\n\nconstexpr AR<AR<int,4>,4> zz{{\n\t{-1,0,1,2},\n\t{-1,-1,3,4},\n\t{-1,-1,-1,5},\n\t{-1,-1,-1,-1}\n}};\n\nAR<ll,3> calc_nex(const AR<ll,3>& pref, const AR<ll,6>& block) {\n\treturn {pref[0]+block[zz[0][1]],\n\t\t\tpref[0]*block[zz[1][2]]+pref[1]+block[zz[0][2]],\n\t\t\tpref[0]*block[zz[1][3]]+pref[1]*block[zz[2][3]]+pref[2]+block[zz[0][3]]};\n}\n\nvpi relevant[450];\nAR<ll,3> pref[450];\nAR<ll,6> blocks[450];\n\nvoid deal_large() {\n\tF0R(v,N) if (oc[v] > THRESH) {\n\t\tauto recalc_prefixes = [&]() {\n\t\t\tF0R(i,BLOCK-1) pref[i+1] = calc_nex(pref[i],blocks[i]);\n\t\t};\n\t\tauto recalc_block = [&](int x) {\n\t\t\tassert(0 <= x && x < BLOCK);\n\t\t\trelevant[x].clear();\n\t\t\tAR<ll,6>& stor = blocks[x]; stor = {};\n\t\t\tFOR(i,x*BLOCK,min((x+1)*BLOCK,N)) {\n\t\t\t\tif (val[i][2] == v) {\n\t\t\t\t\trelevant[x].pb({i,-2});\n\t\t\t\t\t++stor[zz[2][3]];\n\t\t\t\t\tstor[zz[1][3]] += stor[zz[1][2]];\n\t\t\t\t\tstor[zz[0][3]] += stor[zz[0][2]];\n\t\t\t\t}\n\t\t\t\tif (val[i][1] == v) {\n\t\t\t\t\trelevant[x].pb({i,-1});\n\t\t\t\t\t++stor[zz[1][2]];\n\t\t\t\t\tstor[zz[0][2]] += stor[zz[0][1]];\n\t\t\t\t}\n\t\t\t\tif (val[i][0] == v) {\n\t\t\t\t\trelevant[x].pb({i,0});\n\t\t\t\t\t++stor[zz[0][1]];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tauto recalc_block_2 = [&](int x) {\n\t\t\tAR<ll,6>& stor = blocks[x]; stor = {};\n\t\t\tfor (const pi& p: relevant[x]) {\n\t\t\t\tif (p.s == -2) {\n\t\t\t\t\t++stor[zz[2][3]];\n\t\t\t\t\tstor[zz[1][3]] += stor[zz[1][2]];\n\t\t\t\t\tstor[zz[0][3]] += stor[zz[0][2]];\n\t\t\t\t} else if (p.s == -1) {\n\t\t\t\t\t++stor[zz[1][2]];\n\t\t\t\t\tstor[zz[0][2]] += stor[zz[0][1]];\n\t\t\t\t} else {\n\t\t\t\t\t++stor[zz[0][1]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(i,x,BLOCK-1) pref[i+1] = calc_nex(pref[i],blocks[i]);\n\t\t};\n\t\t\n\t\n\t\tF0R(i,N) val[i] = {B[A[i]],A[i],C[A[i]]};\n\t\tF0R(x,BLOCK) recalc_block(x);\n\t\trecalc_prefixes();\n\t\tint ans_cnt = 0;\n\t\teach(t,queries) {\n\t\t\tauto [type,_a,_b] = t;\n\t\t\tif (type == 1) {\n\t\t\t\tauto [_,i,x] = t; \n\t\t\t\tbool flag = 0;\n\t\t\t\tint label = i/BLOCK;\n\t\t\t\tF0R(j,3) if (val[i][j] == v) relevant[label].erase(lb(all(relevant[label]),mp(i,-j))), flag = 1;\n\t\t\t\tval[i] = {B[x],x,C[x]};\n\t\t\t\tF0R(j,3) if (val[i][j] == v) relevant[label].ins(lb(all(relevant[label]),mp(i,-j)),mp(i,-j)), flag = 1;\n\t\t\t\tif (flag) recalc_block_2(label);\n\t\t\t} else {\n\t\t\t\tauto [_a,r,_b] = t;\n\t\t\t\tAR<ll,3> a = pref[r/BLOCK];\n\t\t\t\tfor (const auto& p: relevant[r/BLOCK]) {\n\t\t\t\t\tif (p.f >= r) break;\n\t\t\t\t\tif (p.s == 0) ++a[0];\n\t\t\t\t\telse if (p.s == -1) a[1] += a[0];\n\t\t\t\t\telse if (p.s == -2) a[2] += a[1];\n\t\t\t\t}\n\t\t\t\tans[ans_cnt++] += a[2];\n\t\t\t}\n\t\t}\n\t\tassert(ans_cnt == sz(ans));\n\t}\n}\n\nint main() {\n\tdbg(THRESH);\n\tsetIO(); re(N,M);\n\twhile (BLOCK*BLOCK <= N) ++BLOCK;\n\tA.rsz(N), B.rsz(N), C.rsz(N); re(A,B,C);\n\tsub(A), sub(B), sub(C);\n\tval.rsz(N);\n\toc = vi(N);\n\n\tF0R(i,N) add_oc(A[i]);\n\n\trep(M) {\n\t\tints(type);\n\t\tif (type == 1) {\n\t\t\tints(i,x); --i, --x;\n\t\t\tqueries.pb({type,i,x});\n\t\t\tadd_oc(x);\n\t\t} else {\n\t\t\tints(r);\n\t\t\tqueries.pb({type,r,-1});\n\t\t}\n\t}\n\t// dbg(oc);\n\n\t// if nothing occurs very frequently\n\tdeal_small();\n\tdeal_large();\n\teach(t,ans) ps(t);\n\t// 3*(250000)/2500\n\n\t// if something occurs very frequently, deal w/ it separately\n\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. AquaMoon and Potatoes.json",
    "editorial_link": "https://codeforces.com//blog/entry/92739",
    "editorial": "We seek a solution of roughly square root time complexity; the small\r\nconstraint of hints at a solution in . This immediately rules out\r\nsolutions based on square root decomposition on sequences, because of\r\nthe overhead incurred with initializing such structures.Instead of\r\ndirectly solving the problem, let us solve the following - equivalent -\r\ntask: How can we solve queries in time?If we only consider queries, then\r\nthere are at most positions that are modified throughout these queries.\r\nCall these positions \"dynamic points\", and the others \"static points\".A\r\nnote concerning notation: The following editorial was written when and\r\nwere permutations, and as such it uses to denote the value such that .\r\nIt was later found that the solution can be easily modified to\r\naccomodate for and that were not permutations. You can regard as the set\r\nof such that . In the following, we often count the number of dynamic or\r\nstatic elements in a prefix that equals a certain value. The number of\r\nelements in a multiset that equal is the same as the number of elements\r\nin said multiset that satisfy . In implementation, we can maintain the\r\nmultiset instead of the original multiset.Call a triplet \"good\" if it\r\nsatisfies , and .Hence, for each query, the good triplets fall under 8\r\ncategories, in roughly increasing order of difficulty: are all static.\r\nWe can calculate for each in , through DP or the like, the number of\r\ngood triplets in where are all static: we simply ignore the dynamic\r\npoints. This is preprocessing and for each query. are all dynamic.\r\nSimilarly to 1, for each query, we do a brute force DP over all dynamic\r\nbefore . This is for each query. are dynamic, is static. We iterate over\r\nall dynamic , moving forward, and keep track of the amount of currently\r\nseen. Then, for each , we know the number of dynamic that can precede it\r\nthrough what we tracked; what remains is to count the number of static\r\nin in . We offline all intervals that we need to count in these queries\r\nand then re-process their contribution at the end of the block. are\r\ndynamic, is static. This is virtually the same as 3; we just iterate in\r\nreverse and we count the number of static in . is dynamic, are static.\r\nUsing the same data structure as 3 and 4, we multiply the number of in\r\nwith the number of static in . are dynamic, is static. We iterate over\r\nall dynamic . The number of good in this situation equals the number of\r\nwhere , , and , minus the number of where , , and . For the former,\r\nnotice that are independent. As we iterate forwards through all dynamic\r\n, we keep track of all dynamic values we have seen so far, and multiply\r\nthe number of dynamic occurrences of with the number of static\r\noccurrences of in . As usual, to solve for static occurrences we offline\r\nthem. For the latter, observe, that when we must have in a good triplet.\r\nHence during the iteration over , for each dynamic we count the number\r\nof static before or on it such that . We obtain this count for each\r\ndynamic and then, for each , sum the count over all . is dynamic, are\r\nstatic. We iterate over all dynamic ; we seek the number of static in\r\nsuch that , , and . We offline all dynamic that we need to count in\r\nthese queries. Then, we iterate forwards through in a manner similar to\r\npart 1, keeping track of the number of that can bind to each , and a sum\r\nover all current where equals some value, answering offlined questions\r\non the way. is dynamic, are static. We iterate over all dynamic ; we\r\nseek the number of static in such that , , and . We offline all\r\nintervals that we need to count in these queries. Notice that the number\r\nof in an interval equals the number of where is in minus the number of\r\nwhere is in and is in . We calculate the former iterating backwards\r\nthrough to count the number of that can bind to each , and then use a\r\nsum similar to part 3. For the latter, we observe, that and are\r\nindependent since we have fixed both the value of and , so we simply\r\nmultiply the possible in with the possible in .As such, we have solved\r\nqueries in , and have solved the problem in .We can prove that this\r\nproblem is more difficult than calculating matrix multiplication of two\r\nmatrices with size , when ignoring poly-logarithmic factors.We construct\r\na special arrangement of array: for , the corresponding , the\r\ncorresponding . For other , . We make sure that no exists in the array\r\n.Array is separated into three parts from left to right. The first part\r\nconsists of , each appears exactly one time. The second part consists of\r\n, each may exist multiple times. The third part consists of , each may\r\nexist multiple times.Let be the number of triplets that . For each ,\r\nthere is exactly one and it appears exactly one time. Hence, is equal to\r\nthe number of corresponding . We only modify elements of in the second\r\npart. If we regard that is in the third part of array as a point in 2D\r\nspace, let , then inserting a corresponding into the second part means a\r\nranged plus operation for any point that . A query operation with value\r\nreports the sum of all point that . Because of our constructed array,\r\nonly triplets where is in the third part can contribute to the answer.\r\nSo we used an algorithm that can solve this problem to solve the\r\ntwo-dimensional add, sum problem, which is equivalent to add, sum when\r\nignoring poly-logarithmic factors. This problem is further equivalent to\r\nthe famous range inverse query problem, which was proven more difficult\r\nthan calculating matrix multiplication of two matrices with size .As\r\ncurrently the best matrix multiplication algorithm is , seeking a\r\nsolution is not realistic, so the solution described above is enough for\r\ncompetitive programming.P.S. There is an easter egg in the problem\r\nstatement, find it :)\r\n",
    "hint": []
}