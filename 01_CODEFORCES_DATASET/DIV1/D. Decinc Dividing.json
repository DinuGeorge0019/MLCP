{
    "link": "https://codeforces.com//contest/1693/problem/D",
    "problemId": "1430891",
    "problem_idx": "D",
    "shortId": "1693D",
    "contest_number": "1693",
    "problem_submissions": {
        "F": [
            160880007,
            160880972,
            160861674,
            160875588,
            160882783,
            160878948,
            160890167,
            160899913,
            161040863,
            160893311,
            160892940
        ],
        "E": [
            160864775,
            160851833,
            160876978,
            160893451,
            160863343,
            160869365,
            160873611,
            160876701,
            160883190,
            160881001,
            160869009,
            160890042,
            160889537,
            160889370,
            160888603,
            160888570,
            160884303
        ],
        "D": [
            160848374,
            160868923,
            160880702,
            160854200,
            160854032,
            160862911,
            160859336,
            160861278,
            160860933,
            160866823,
            160880935,
            160874455,
            160855846,
            160857826,
            160858928,
            160851586,
            160859103
        ],
        "C": [
            160833863,
            160838237,
            160831750,
            160839496,
            160831595,
            160847471,
            160845192,
            160845432,
            160842623,
            160834916,
            160845029,
            160853816,
            160836315,
            160837724,
            160840237,
            160837127,
            160842065,
            160837528
        ],
        "B": [
            160829995,
            160831749,
            160828393,
            160835792,
            160838408,
            160836721,
            160840343,
            160837858,
            160837790,
            160829673,
            160840637,
            160838527,
            160830551,
            160831811,
            160831387,
            160832406,
            160834629,
            160831231
        ],
        "A": [
            160824784,
            160824733,
            160824181,
            160826982,
            160842765,
            160829489,
            160836610,
            160834230,
            160827824,
            160825693,
            160827125,
            160830489,
            160824662,
            160825298,
            160825387,
            160826936,
            160829963,
            160825879
        ]
    },
    "name": "D. Decinc Dividing",
    "statement": "Let\u2019s call an array a of m integers a_1, a_2,\r\nldots, a_m if a can be made increasing by removing a decreasing\r\nsubsequence (possibly empty) from it. For example, if a = [3, 2, 4, 1,\r\n5], we can remove the decreasing subsequence [a_1, a_4] from a and\r\nobtain a = [2, 4, 5], which is increasing.You are given a permutation p\r\nof numbers from 1 to n. Find the number of pairs of integers (l, r) with\r\n1\r\nle l\r\nle r\r\nle n such that p[l\r\nldots r] (the subarray of p from l to r) is a array.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nint nastwie[nax];\nint nastmie[nax];\n\nll wyn;\n\nint dolny[nax];\nint nd[nax];\nint ng[nax];\n\nint pd[nax];\nint pg[nax];\n\nint spokdal[nax];\n\nint lecimy[nax];\n\nmap<pii,int> mapa;\n\nint dive(int d, int g)\n{\n\tif (mapa.count({d, g}))\n\t\treturn mapa[{d, g}];\n\tint x=max(d, g);\n\tif (x==n)\n\t\treturn mapa[{d, g}]=n;\n\tx++;\n\tif (tab[x]>tab[d])\n\t\treturn mapa[{d, g}]=dive(x, g);\n\tif (tab[x]<tab[g])\n\t\treturn mapa[{d, g}]=dive(d, x);\n\treturn mapa[{d, g}]=x-1;\n}\n\nint check(int a, int b)\n{\n\tif (spokdal[a]>=b)\n\t\treturn 1;\n\tint x=spokdal[a];\n\tint g=pg[x];\n\tint d=pd[x];\n\tassert(g && d);\n\treturn dive(d, g)>=b;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\t\t//~ tab[i]=i;\n\t//~ {\n\t\t//~ if (i&1)\n\t\t\t//~ tab[i]=(i+1)/2;\n\t\t//~ else\n\t\t\t//~ tab[i]=n-(i-1)/2;\n\t//~ }\n\t//~ shandom_ruffle(tab+1, tab+1+n);\n\tfor (int i=n; i; i--)\n\t{\n\t\tnastwie[i]=nastmie[i]=i+1;\n\t\twhile(nastwie[i]<=n && tab[nastwie[i]]<tab[i])\n\t\t\tnastwie[i]=nastwie[nastwie[i]];\n\t\twhile(nastmie[i]<=n && tab[nastmie[i]]>tab[i])\n\t\t\tnastmie[i]=nastmie[nastmie[i]];\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tif (tab[i+1]>tab[i])\n\t\t\tdolny[i]=1;\n\t}\n\tnd[n+1]=ng[n+1]=n+1;\n\tfor (int i=n; i; i--)\n\t{\n\t\tnd[i]=nd[i+1];\n\t\tng[i]=ng[i+1];\n\t\tif (dolny[i])\n\t\t\tnd[i]=i;\n\t\telse\n\t\t\tng[i]=i;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tpd[i]=pd[i-1];\n\t\tpg[i]=pg[i-1];\n\t\tif (dolny[i])\n\t\t\tpd[i]=i;\n\t\telse\n\t\t\tpg[i]=i;\n\t}\n\tspokdal[n+1]=n;\n\tfor (int i=n; i; i--)\n\t{\n\t\tspokdal[i]=spokdal[i+1];\n\t\tif (dolny[i])\n\t\t{\n\t\t\tint x=nd[i+1];\n\t\t\tif (x<=n && tab[x]<tab[i])\n\t\t\t\tspokdal[i]=min(spokdal[i], x-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x=ng[i+1];\n\t\t\tif (x<=n && tab[x]>tab[i])\n\t\t\t\tspokdal[i]=min(spokdal[i], x-1);\n\t\t}\n\t}\n\tint w=n;\n\tll wyn=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\twhile(!check(i, w))\n\t\t\tw--;\n\t\twyn+=w-i+1;\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\t//~ lecimy[n]=n;\n\t//~ for (int i=n-1; i; i--)\n\t//~ {\n\t\t//~ if (!pd[i] || !pg[i])\n\t\t//~ {\n\t\t\t//~ lecimy[i]=lecimy[i+1];\n\t\t\t//~ continue;\n\t\t//~ }\n\t\t//~ int d=pd[i];\n\t\t//~ int g=pg[i];\n\t\t//~ assert(d==i || g==i);\n\t\t//~ if (tab[i+1]>=tab[g])\n\t\t//~ {\n\t\t\t\n\t\t//~ }\n\t//~ }\n\t//~ debug() << range(spokdal+1, spokdal+1+n);\n\t//~ debug() << range(dolny+1, dolny+1+n);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "divide and conquer",
        "dp",
        "greedy"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Decinc Dividing.json",
    "editorial_link": "https://codeforces.com//blog/entry/103952",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem for a single subarray.Assume the -th element\r\nbelongs to the increasing subsequence. Define for the interval as the\r\nmaximum value the last element of the decreasing subsequence can have.\r\nIt\u00e2\u0080\u0099s in case the decreasing subsequence is empty. It\u00e2\u0080\u0099s if the array is\r\nnot possible.Assume the -th element belongs to the decreasing\r\nsubsequence. Define for the interval as the minimum value the last\r\nelement of the increasing subsequence can have. It\u00e2\u0080\u0099s in case the\r\nincreasing subsequence is empty. It\u00e2\u0080\u0099s if the array is not possible.The\r\ninterval is not if and only if and .Iterate over from to and keep the\r\nand values updated (shown in the implementation).We claim that each or\r\nvalue will change at most three times throughout the algorithm.For some\r\nindex assume is the largest index smaller than such that . can only be\r\none of these four values: .Because the last element of the decreasing\r\nsubsequence can\u00e2\u0080\u0099t be before the -th element. And if it\u00e2\u0080\u0099s some that lies\r\non the interval you can simply move it to the increasing subsequence\r\nsince both ()-th and ()-th elements belong to the increasing\r\nsubsequence. The same applies for .So the function is called times in\r\ntotal.Time complexity:\r\n"
}