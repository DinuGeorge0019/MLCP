{
    "link": "https://codeforces.com//contest/274/problem/B",
    "problemId": "2642",
    "problem_idx": "B",
    "shortId": "274B",
    "contest_number": "274",
    "problem_submissions": {
        "C": [
            3158978,
            3161367,
            3160459,
            3161088,
            3162848,
            3162836,
            3165392,
            3165808
        ],
        "D": [
            3157146,
            3154578,
            3158626,
            3159674,
            3155066,
            3154610,
            3154494,
            3162878,
            3155274,
            3154799,
            3156202,
            3154900,
            3156390,
            3156684,
            3157059,
            3155641,
            3157406,
            3158027,
            3156972,
            3156358
        ],
        "B": [
            3152846,
            3152029,
            3153572,
            3152338,
            3153369,
            3152405,
            3153123,
            3152132,
            3152478,
            3153001,
            3152618,
            3151871,
            3152600,
            3152514,
            3153029,
            3154367,
            3152641,
            3154376,
            3154181
        ],
        "A": [
            3151000,
            3150976,
            3151370,
            3151011,
            3151226,
            3150986,
            3151237,
            3151023,
            3151171,
            3151002,
            3150999,
            3152680,
            3151235,
            3150991,
            3151625,
            3151251,
            3169649,
            3151050,
            3151668,
            3151075
        ],
        "E": [
            3179779,
            3170504,
            3166357,
            3166349
        ]
    },
    "name": "B. Zero Tree",
    "statement": "A is a graph with vertices and exactly edges; this graph should meet the\r\nfollowing condition: there exists exactly one shortest (by number of\r\nedges) path between any pair of its vertices.A of a tree is a tree with\r\nboth vertices and edges as subsets of vertices and edges of .You\u2019re\r\ngiven a tree with vertices. Consider its vertices numbered with integers\r\nfrom 1 to . Additionally an integer is written on every vertex of this\r\ntree. Initially the integer written on the -th vertex is equal to . In\r\none move you can apply the following operation: Select the subtree of\r\nthe given tree that includes the vertex with number 1. Increase (or\r\ndecrease) by one all the integers which are written on the vertices of\r\nthat subtree. Calculate the minimum number of moves that is required to\r\nmake all the integers written on the vertices of the given tree equal to\r\nzero.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint N;\nvector <int> edge[100010];\nint c[100010];\nll pl[100010],minu[100010];\n\nvoid dfs(int p, int x){\n    int i;\n    \n    ll P = 0, M = 0;\n    REP(i,edge[x].size()){\n        int y = edge[x][i];\n        if(y != p) dfs(x, y);\n        P = max(P, pl[y]);\n        M = max(M, minu[y]);\n    }\n    \n    ll diff = c[x] - (P - M);\n    if(diff > 0) P += diff; else M -= diff;\n    pl[x] = P;\n    minu[x] = M;\n}\n\nint main(void){\n    int a,b,i;\n    \n    cin >> N;\n    REP(i,N-1){\n        scanf(\"%d%d\", &a, &b);\n        edge[a-1].push_back(b-1);\n        edge[b-1].push_back(a-1);\n    }\n    REP(i,N) scanf(\"%d\", &c[i]);\n    \n    dfs(-1, 0);\n    cout << pl[0] + minu[0] << endl;\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Zero Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/6759",
    "editorial": "In the problem statement vertex 1 is not mentioned as root of the tree. But it seems if we make it the root of the tree we can figure out the solution easier. For the leaves of the tree we can see the least number of steps needed to make each of them equal to zero. Consider a vertex which all its children are leaves. The minimum number of times that we should increase this vertex is at least as the maximum times one of the children of this vertex is increased. Also the minimum number of times this vertex is decreased is at least as maximum times one of the children of this vertex is decreased. Now we know some necessary plus or minus steps that this vertex is included in them. So after all of the children of this vertex reached zero, this vertex itself has some new value. If the current value of the vertex is positive we should decrease this vertex certain times otherwise we should decrease it. So we can find the minimum number of times this vertex should be decreased and the minimum number of times this vertex should be increased. As we showed above if we know these pair of numbers for each child of a vertex then we can calculate these numbers for that vertex too.\n\nThis can be implemented using a simple DFS on the rooted tree. And the answer to the problem would be the sum of increments and decrements of vertex 1. The time complexity of the solution is O(n)."
}