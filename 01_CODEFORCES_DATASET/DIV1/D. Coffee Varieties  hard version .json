{"link": "https://codeforces.com//contest/1290/problem/D", "problemId": "529280", "problem_idx": "D", "shortId": "1290D", "contest_number": "1290", "problem_submissions": {"C": [70096929, 70064543, 70052395, 70054161, 70047406, 70047992, 70053917, 70053152, 70054979, 70214121, 70054528, 70058183, 70057014, 70052660, 70052531, 70060568, 70059018, 70063715, 70055920, 70058007, 70059153, 70056438], "D": [70071102, 70083418, 70081951, 70059761, 70062540, 70064117, 70088222, 70088118, 70087893, 70066142, 71762685, 70214194, 70214147, 70068516, 70069978, 70069936, 70074018, 70075546, 70074118, 70071674, 70072917, 70077679, 70075595, 70065164, 70078630], "F": [70059398, 70084031, 70111116, 70110928, 75833689, 70089144, 70131709], "A": [70040962, 70037530, 70037805, 70036026, 70036076, 70037499, 70037219, 70040023, 70214047, 70038241, 70036901, 70036876, 70037974, 70038261, 70038975, 70040060, 70041968, 70036027, 70043312, 70045091, 70039900], "B": [70038396, 70041221, 70041673, 70039846, 70040515, 70043644, 70043914, 70045743, 70214060, 70047838, 70043116, 70043411, 70045228, 70046548, 70048357, 70051227, 70051419, 70047415, 70062917, 70075181, 70045909], "E": [70074704, 70107871, 70086286, 70079191, 70214607, 70086883, 70085799, 70123893, 70086530, 70158475, 70100288, 70111014]}, "name": "D. Coffee Varieties  hard version ", "statement": "You\u2019re considering moving to another city, where one of your friends\r\nalready lives. There are n caf s in this city, where n is a power of\r\ntwo. The i-th caf produces a single variety of coffee a_i. As you\u2019re a\r\ncoffee-lover, before deciding to move or not, produced in this city.You\r\ndon\u2019t know the values a_1,\r\nldots, a_n. Fortunately, your friend has a memory of size k, where k is\r\na power of two.Once per day, you can ask him to taste a cup of coffee\r\nproduced by the caf c, and he will tell you if he tasted a similar\r\ncoffee during the last k days.You can also ask him to take a medication\r\nthat will reset his memory. He will forget all previous cups of coffee\r\ntasted. You can reset his memory at most 30\r\n000 times.More formally, the memory of your friend is a queue S. Doing a\r\nquery on caf c will: Tell you if a_c is in S; Add a_c at the back of S;\r\nIf |S| > k, pop the front element of S. Doing a reset request will pop\r\nall elements out of S.Your friend can taste at most\r\ndfrac{3n^2}{2k} cups of coffee in total. Find the diversity d (number of\r\ndistinct values in the array a).Note that asking your friend to reset\r\nhis memory towards the number of times you ask your friend to taste a\r\ncup of coffee.In some test cases the behavior of the interactor . It\r\nmeans that the array a may be before the start of the interaction and\r\nmay . It is guaranteed that at any moment of the interaction, there is\r\nat least one array a consistent with all the answers given so far.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 02.02.2020 18:33:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  auto Ask = [&](int x) {\n    cout << \"? \" << x + 1 << endl;\n    string foo;\n    cin >> foo;\n    return (foo[0] == 'Y');\n  };\n  auto DoR = [&]() {\n    cout << \"R\" << endl;\n  };\n  int b = max(k / 2, 1);\n  int cnt = n / b;\n  vector<int> dup(n, 0);\n  vector<vector<int>> asked(cnt, vector<int>(cnt, 0));\n  for (int i = 0; i < cnt; i++) {\n    for (int j = i + 1; j < cnt; j++) {\n      if (!asked[i][j]) {       \n        int x = i, y = j;\n        for (int t = 0; t < b; t++) {\n          if (Ask(x * b + t)) {\n            dup[x * b + t] = 1;\n          }\n        }\n        while (true) {\n          for (int t = 0; t < b; t++) {\n            if (Ask(y * b + t)) {\n              dup[y * b + t] = 1;\n            }\n          }\n          asked[x][y] = 1;\n          int z = y + 1;\n          while (z < cnt && asked[y][z]) {\n            ++z;\n          }\n          if (z == cnt) {\n            break;\n          }\n          x = y;\n          y = z;\n        }\n        DoR();\n      }\n    }\n  }\n  cout << \"! \" << n - accumulate(dup.begin(), dup.end(), 0) << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "interactive"], "dificulty": "3000", "interactive": false}