{
    "link": "https://codeforces.com//contest/1290/problem/D",
    "problemId": "529280",
    "problem_idx": "D",
    "shortId": "1290D",
    "contest_number": "1290",
    "problem_submissions": {
        "C": [
            70096929,
            70064543,
            70052395,
            70054161,
            70047406,
            70047992,
            70053917,
            70053152,
            70054979,
            70214121,
            70054528,
            70058183,
            70057014,
            70052660,
            70052531,
            70060568,
            70059018,
            70063715,
            70055920,
            70058007,
            70059153,
            70056438
        ],
        "D": [
            70071102,
            70083418,
            70081951,
            70059761,
            70062540,
            70064117,
            70088222,
            70088118,
            70087893,
            70066142,
            71762685,
            70214194,
            70214147,
            70068516,
            70069978,
            70069936,
            70074018,
            70075546,
            70074118,
            70071674,
            70072917,
            70077679,
            70075595,
            70065164,
            70078630
        ],
        "F": [
            70059398,
            70084031,
            70111116,
            70110928,
            75833689,
            70089144,
            70131709
        ],
        "A": [
            70040962,
            70037530,
            70037805,
            70036026,
            70036076,
            70037499,
            70037219,
            70040023,
            70214047,
            70038241,
            70036901,
            70036876,
            70037974,
            70038261,
            70038975,
            70040060,
            70041968,
            70036027,
            70043312,
            70045091,
            70039900
        ],
        "B": [
            70038396,
            70041221,
            70041673,
            70039846,
            70040515,
            70043644,
            70043914,
            70045743,
            70214060,
            70047838,
            70043116,
            70043411,
            70045228,
            70046548,
            70048357,
            70051227,
            70051419,
            70047415,
            70062917,
            70075181,
            70045909
        ],
        "E": [
            70074704,
            70107871,
            70086286,
            70079191,
            70214607,
            70086883,
            70085799,
            70123893,
            70086530,
            70158475,
            70100288,
            70111014
        ]
    },
    "name": "D. Coffee Varieties  hard version ",
    "statement": "You’re considering moving to another city, where one of your friends\r\nalready lives. There are n caf s in this city, where n is a power of\r\ntwo. The i-th caf produces a single variety of coffee a_i. As you’re a\r\ncoffee-lover, before deciding to move or not, produced in this city.You\r\ndon’t know the values a_1,\r\nldots, a_n. Fortunately, your friend has a memory of size k, where k is\r\na power of two.Once per day, you can ask him to taste a cup of coffee\r\nproduced by the caf c, and he will tell you if he tasted a similar\r\ncoffee during the last k days.You can also ask him to take a medication\r\nthat will reset his memory. He will forget all previous cups of coffee\r\ntasted. You can reset his memory at most 30\r\n000 times.More formally, the memory of your friend is a queue S. Doing a\r\nquery on caf c will: Tell you if a_c is in S; Add a_c at the back of S;\r\nIf |S| > k, pop the front element of S. Doing a reset request will pop\r\nall elements out of S.Your friend can taste at most\r\ndfrac{3n^2}{2k} cups of coffee in total. Find the diversity d (number of\r\ndistinct values in the array a).Note that asking your friend to reset\r\nhis memory towards the number of times you ask your friend to taste a\r\ncup of coffee.In some test cases the behavior of the interactor . It\r\nmeans that the array a may be before the start of the interaction and\r\nmay . It is guaranteed that at any moment of the interaction, there is\r\nat least one array a consistent with all the answers given so far.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 02.02.2020 18:33:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  auto Ask = [&](int x) {\n    cout << \"? \" << x + 1 << endl;\n    string foo;\n    cin >> foo;\n    return (foo[0] == 'Y');\n  };\n  auto DoR = [&]() {\n    cout << \"R\" << endl;\n  };\n  int b = max(k / 2, 1);\n  int cnt = n / b;\n  vector<int> dup(n, 0);\n  vector<vector<int>> asked(cnt, vector<int>(cnt, 0));\n  for (int i = 0; i < cnt; i++) {\n    for (int j = i + 1; j < cnt; j++) {\n      if (!asked[i][j]) {       \n        int x = i, y = j;\n        for (int t = 0; t < b; t++) {\n          if (Ask(x * b + t)) {\n            dup[x * b + t] = 1;\n          }\n        }\n        while (true) {\n          for (int t = 0; t < b; t++) {\n            if (Ask(y * b + t)) {\n              dup[y * b + t] = 1;\n            }\n          }\n          asked[x][y] = 1;\n          int z = y + 1;\n          while (z < cnt && asked[y][z]) {\n            ++z;\n          }\n          if (z == cnt) {\n            break;\n          }\n          x = y;\n          y = z;\n        }\n        DoR();\n      }\n    }\n  }\n  cout << \"! \" << n - accumulate(dup.begin(), dup.end(), 0) << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "interactive"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Coffee Varieties  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/73563",
    "editorial": "Letâs try to maintain representative positions for each value. In the\r\nbeginning, when we know nothing, every position can be a potential\r\nrepresentative.We will call them , and using queries, we will try to\r\nkill some positions and ending up with exactly one alive position per\r\nvalue. The answer will be the number of alive positions.Note that when\r\nwe kill a position, there must be another alive position with the same\r\nvalue. The danger here is to compare a position to a dead position of\r\nthe same value: we may end up killing the single representative of the\r\nvalue.Create blocks of size , (or if ). Query and kill the element if\r\nyou get Yes answer. Each value has at least one alive occurrence, its\r\nleftmost one. Moreover, all equalities inside blocks are removed.In\r\norder to remove equalities between blocks, compare all unordered pairs\r\nof blocks (for each pair, reset the memory, look all elements in the\r\nfirst one, then all elements in the second one, and kill elements in the\r\nsecond one for each Yes answer). Note that we donât need to compare\r\nadjacent blocks. The number of queries is a bit less than .Querying\r\nallowed us to compare pairs in a very efficient manner because we reuse\r\nthe memory of the previous comparison. Letâs try to generalize\r\nthis.Consider a complete graph where nodes are blocks. Comparing pairs\r\nof blocks can be seen as covering edges of the graph. We can take any\r\npath (that doesnât pass through a node twice), reset the memory and\r\nexplore blocks in the corresponding order (killing elements for each Yes\r\nanswer).Each path will require queries. Itâs optimal to have disjoint\r\npaths (if a path goes through an already visited edge, we can split it\r\nthere). Hence, we want to use a few disjoint paths to cover all edges.A\r\nrandomized DFS works experimentally well (constant around ).However, we\r\ncan acheive constant using the following zig-zag pattern: .\r\n",
    "hint": []
}