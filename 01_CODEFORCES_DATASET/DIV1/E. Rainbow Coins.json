{
    "link": "https://codeforces.com//contest/1161/problem/E",
    "problemId": "339902",
    "problem_idx": "E",
    "shortId": "1161E",
    "contest_number": "1161",
    "problem_submissions": {
        "F": [
            53909371,
            114209812,
            53863200
        ],
        "E": [
            53757964,
            53756987,
            53756569,
            53759204,
            53758710,
            53758335,
            53759423,
            53759655,
            53759053,
            53758599,
            53760097,
            53761659,
            53757322,
            53759810
        ],
        "D": [
            53752102,
            53753035,
            53753793,
            53751800,
            53753429,
            53754722,
            87768256,
            53755219,
            53754639,
            53755997,
            53749499,
            53756338,
            53756778,
            53758722,
            53757091,
            53754786,
            53751937,
            53753965,
            53753805,
            53754929
        ],
        "C": [
            53750364,
            53751704,
            53751645,
            53749841,
            53749214,
            53750926,
            53751458,
            53755261,
            53754114,
            53751399,
            53756883,
            53754076,
            53759235,
            53760202,
            53749644,
            53749593,
            53751107,
            53750858
        ],
        "B": [
            53748059,
            53750584,
            53750568,
            53748260,
            53748334,
            53748600,
            53749151,
            53749091,
            53748293,
            53760218,
            53747945,
            53749635,
            53748265,
            53747869,
            53748914,
            53748572,
            53749307,
            53749491
        ],
        "A": [
            53746899,
            53747514,
            53747934,
            53746630,
            53746650,
            53747171,
            53747667,
            53746731,
            53746977,
            53759102,
            53746696,
            53748269,
            53748575,
            53751158,
            53747184,
            53746584,
            53747125,
            53747652
        ]
    },
    "name": "E. Rainbow Coins",
    "statement": "Carl has n coins of various colors, and he would like to sort them into\r\npiles. The coins are labeled 1,2,\r\nldots,n, and each coin is exactly one of red, green, or blue. He would\r\nlike to sort the coins into three different piles so one pile contains\r\nall red coins, one pile contains all green coins, and one pile contains\r\nall blue coins.Unfortunately, Carl is colorblind, so this task is\r\nimpossible for him. Luckily, he has a friend who can take a pair of\r\ncoins and tell Carl if they are the same color or not. Using his friend,\r\nCarl believes he can now sort the coins. The order of the piles doesn’t\r\nmatter, as long as all same colored coins are in the one pile, and no\r\ntwo different colored coins are in the same pile.His friend will answer\r\nquestions about multiple pairs of coins in batches, and will answer\r\nabout all of those pairs in parallel. Each coin should be in at most one\r\npair in each batch. The same coin can appear in different batches.Carl\r\ncan use only 7 batches. Help him find the piles of coins after sorting.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n \nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint t, n, ans[MX];\n// vi col = {1,1,1,1,1,1,1,1,1,1};\n\nvi query(vpi a) {\n    if (!sz(a)) return {};\n    trav(t,a) assert(t.f != t.s);\n    cout << \"Q \" << sz(a) << \" \";\n    trav(t,a) cout << t.f+1 << \" \" << t.s+1 << \" \";\n    cout << endl;\n    string x = \"\"; \n    /*trav(t,a) if (col[t.f] == col[t.s]) x += '1';\n    else x += '0';*/\n    // ps(\"WHAT\",x);\n    re(x); \n    vi ret;\n    trav(t,x) ret.pb(t-'0');\n    // ps(\"WAT\",ret);\n    trav(t,ret) assert(t == 0 || t == 1);\n    return ret;\n}\n\nvi solve(vi cyc) {\n    assert(sz(cyc) > 1);\n    vpi a, b, c; \n    c.pb({cyc.back(),cyc.front()});\n    for (int i = 0; i+1 < sz(cyc); i += 2) a.pb({cyc[i],cyc[i+1]});\n    for (int i = 1; i+1 < sz(cyc); i += 2) b.pb({cyc[i],cyc[i+1]});\n    vi A = query(a), B = query(b), C = query(c);\n    vi ret(sz(cyc));\n    F0R(i,sz(cyc)) {\n        if (i == sz(cyc)-1) ret[i] = C[0];\n        else if (i&1) ret[i] = B[i/2];\n        else ret[i] = A[i/2];\n    }\n    return ret;\n}\n\nvector<vi> compress(vi cyc) {\n    if (sz(cyc) == 1) return {cyc};\n    auto x = solve(cyc);\n    int ind = 0; while (ind < sz(x) && x[ind] == 1) ind ++;\n    ind = (ind+1)%sz(cyc);\n    rotate(cyc.begin(),cyc.begin()+ind,cyc.end());\n    rotate(x.begin(),x.begin()+ind,x.end());\n    vector<vi> V;\n    for (int i = 0; i < sz(cyc); ) {\n        vi cur = {cyc[i]};\n        while (i < sz(cyc)-1 && x[i] == 1) {\n            i ++;\n            cur.pb(cyc[i]);\n        }\n        V.pb(cur); i ++;\n    }\n    return V;\n    // ps(x,ind,x[ind]); exit(0);\n}\n\nvoid zz(vi a) {\n    trav(t,a) pr(t+1,' ');\n    cout << endl;\n}\n\nvoid answer() {\n    vi a,b,c;\n    F0R(i,n) {\n        if (ans[i] == 0) a.pb(i);\n        else if (ans[i] == 1) b.pb(i);\n        else c.pb(i);\n    }\n    cout << \"A \" << sz(a) << \" \" << sz(b) << \" \" << sz(c) << endl;\n    zz(a); zz(b); zz(c);\n}\n\nvoid assign(vi x, int y) {\n    trav(t,x) ans[t] = y;\n}\n\nint getCol(vi& x) {\n    return ans[x[0]];\n}\n\nvoid solve() {\n    re(n); F0R(i,n) ans[i] = 0;\n    vi cyc; F0R(i,n) cyc.pb(i);\n    auto a = compress(cyc);\n    if (sz(a) == 1) { answer(); return; }\n    vpi q0, q1;\n    for (int i = 0; i < sz(a); i += 4) {\n        if (i+2 < sz(a)) q0.pb({a[i].back(),a[i+2].back()});\n        if (i+3 < sz(a)) q0.pb({a[i+1].back(),a[i+3].back()});\n        if (i+4 < sz(a)) q1.pb({a[i+2].back(),a[i+4].back()});\n        if (i+5 < sz(a)) q1.pb({a[i+3].back(),a[i+5].back()});\n    }\n    int i0 = 0, i1 = 0;\n    vi Q0 = query(q0); vi Q1 = query(q1);\n    // ps(a);\n    // ps(q0,q1,Q0,Q1);\n    vi Q;\n    F0R(i,sz(a)-2) {\n        // ps(\"??\",i%4,i%4 <= 1);\n        if (i % 4 <= 1) Q.pb(Q0[i0++]);\n        else Q.pb(Q1[i1++]);\n    }\n    // ps(\"ER\",Q1[0],i0,i1);\n    // ps(Q); exit(0);\n    assign(a[0],0); assign(a[1],1);\n    FOR(i,2,sz(a)) {\n        if (Q[i-2] == 1) assign(a[i],getCol(a[i-2]));\n        else {\n            int x = 3-getCol(a[i-1])-getCol(a[i-2]);\n            assign(a[i],x);\n        }\n    }\n    answer();\n}\n\nint main() {\n    re(t);\n    F0R(i,t) solve();\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "interactive"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Rainbow Coins.json",
    "editorial_link": "https://codeforces.com//blog/entry/66878",
    "editorial": "Let's define a new question that takes a list of coins t1,t2,,tk\n, and returns the answers about all adjacent pairs of coins in this list (e.g. the answers to (t1,t2),(t2,t3),(t3,t4),\n. We can do this in two questions, one question is (t1,t2),(t3,t4),,\n and the other is (t2,t3),(t4,t5),\n, and we can interleave the results to get the answer for all adjacent pairs in order.\n\nWe show how to use only three questions of this type to get the answer (so the total number of questions in the original problem is 6\n).\n\nFirst, let's ask about all adjacent pairs in 1,2,,n\n. This splits the coins into contiguous groups of the same color. Let's take some arbitrary representative from each group and put them in a line, so we now have a problem where all adjacent coins in the line are different colors.\n\nNow, we ask two more questions about adjacent pairs. One for coins 1,3,5,\n and one for coins 2,4,6,\n.\n\nThis is now enough to reconstruct the color of all the coins. WLOG, coin 1\n is red, and coin 2\n is blue. We know coin 3\n cannot be blue (since it must be different from coin 2\n), and we compared it with coin 1\n, so we know if it is either red or green. We can repeat this for all coins in sequence.",
    "hint": []
}