{
    "link": "https://codeforces.com//contest/781/problem/B",
    "problemId": "96950",
    "problem_idx": "B",
    "shortId": "781B",
    "contest_number": "781",
    "problem_submissions": {
        "B": [
            25258392,
            25257297,
            25250177,
            25250748,
            25251116,
            25249653,
            25250716,
            25250834,
            25250705,
            25251947,
            25250575,
            31121662,
            25252893,
            25252683,
            25253146,
            25255775,
            25252991,
            25253498
        ],
        "E": [
            25256397,
            25254067,
            25258825,
            25260075,
            26145785,
            25259028,
            25259758,
            25260563,
            25260848,
            25261488,
            25260086,
            25703349,
            25261912,
            25262169,
            25262264,
            25261946,
            25261665,
            25262876,
            25262009
        ],
        "D": [
            25252423,
            25259248,
            25255529,
            25254368,
            25256042,
            25256267,
            25256774,
            25256075,
            25254834,
            25256057,
            25266603,
            25256151,
            25257817,
            25258124,
            25258109,
            25258052,
            25258679,
            25258333
        ],
        "C": [
            25249500,
            25249747,
            25251802,
            25252056,
            25252378,
            25250971,
            25252726,
            25253382,
            25252087,
            25253151,
            25252105,
            25254478,
            25253975,
            25254827,
            25254070,
            25255284,
            25254950
        ],
        "A": [
            25247143,
            25247027,
            25247783,
            25247695,
            25248775,
            25247133,
            25247620,
            25248678,
            25249108,
            25249147,
            25247139,
            25249553,
            25248502,
            25248323,
            25249740,
            25249518,
            25247402
        ],
        "F": [
            25268984,
            25267317,
            25271843,
            25271410,
            25271394,
            25271157,
            25270611,
            26202615
        ]
    },
    "name": "B. Innokenty and a Football League",
    "statement": "Innokenty is a president of a new football league in Byteland. The first\r\ntask he should do is to assign short names to all clubs to be shown on\r\nTV next to the score. Of course, the short names should be distinct, and\r\nInnokenty wants that all short names consist of .Each club’s full name\r\nconsist of two words: the team’s name and the hometown’s name, for\r\nexample, \"\". Innokenty doesn’t want to assign strange short names, so he\r\nwants to choose such short names for each club that: the short name is\r\nthe same as three first letters of the team’s name, for example, for the\r\nmentioned club it is \"\", or, the first two letters of the short name\r\nshould be the same as the first two letters of the team’s name, while\r\nthe third letter is the same as the first letter in the hometown’s name.\r\nFor the mentioned club it is \"\". Apart from this, there is a rule that\r\nif for some club the second option of short name is chosen, then there\r\nshould be no club, for which the first option is chosen which is the\r\nsame as the first option for the club . For example, if the above\r\nmentioned club has short name \"\", then no club for which the first\r\noption is chosen can have short name equal to \"\". However, it is\r\npossible that some club have short name \"\", where \"\" are the first two\r\nletters of the team’s name, and \"\" is the first letter of hometown’s\r\nname. Of course, no two teams can have the same short name.Help\r\nInnokenty to choose a short name for each of the teams. If this is\r\nimpossible, report that. If there are multiple answer, any of them will\r\nsuit Innokenty. If for some team the two options of short name are\r\nequal, then Innokenty will formally think that only one of these options\r\nis chosen.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:1000000000\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <memory>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <ctime> \n#include <stack>\n\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\n\nusing namespace std;\n\n\nconst int MAXN = 2002;\n\nvector <int> e[MAXN];\n\n\nint tp[MAXN];\n\nvector <int> mdf;\nint n;\n\nbool dfs(int v)\n{\n\tint nv = ((v < n) ? v : (2 * n - 1 - v));\n\tif (tp[nv] == v) return true;\n\tif (tp[nv] != -1) return false;\n\tmdf.push_back(nv);\n\ttp[nv] = v;\n\tfor (int i = 0; i < e[v].size(); i++)\n\t\tif (!dfs(e[v][i])) return false;\n\treturn true;\n}\n\nstring s1[MAXN];\nstring s2[MAXN];\nstring n1[MAXN];\nstring n2[MAXN];\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ttp[i] = -1;\n\t\tcin >> s1[i] >> s2[i];\n\t\tn2[i] = s1[i].substr(0, 2) + s2[i].substr(0, 1);\n\t\tn1[i] = s1[i].substr(0, 3);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (n1[i] == n1[j])\n\t\t\t{\n\t\t\t\te[i].push_back(2 * n - 1 - j);\n\t\t\t\te[j].push_back(2 * n - 1 - i);\n\t\t\t}\n\t\t\tif (n2[i] == n2[j])\n\t\t\t{\n\t\t\t\te[2 * n - 1 - j].push_back(i);\n\t\t\t\te[2 * n - 1 - i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif ((n2[i] == n1[j]) || (n1[j] == n1[i])) e[2 * n - 1 - i].push_back(2 * n - 1 - j), e[j].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (tp[i] != -1) continue;\n\t\tmdf.clear();\n\t\tif (!dfs(i))\n\t\t{\n\t\t\tfor (int j = 0; j < mdf.size(); j++)\n\t\t\t{\n\t\t\t\ttp[mdf[j]] = -1;\n\t\t\t}\n\t\t\tif (!dfs(2 * n - 1 - i))\n\t\t\t{\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (tp[i] == i) cout << n1[i] << endl;\n\t\telse cout << n2[i] << endl;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "brute force",
        "graph matchings",
        "graphs",
        "greedy",
        "implementation",
        "shortest paths",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Innokenty and a Football League.json",
    "editorial_link": "https://codeforces.com//blog/entry/50854",
    "editorial": "Let us write and for first and second options for -th club name.If all\r\nare distinct, we can assign all of them to be club names without\r\nconflict. Otherwise, suppose that for clubs , we have , hence we canât\r\nuse them simultaneously. Note that, say, choosing and is also forbidden\r\nby the statement. It follows that we must use and as -th and -th club\r\nnames respectively.If for some other club we now have , then we are\r\nforced to use as its name as well. We can process this kind of chain\r\nconflicts with a BFS-like procedure. If at any point we are forced to\r\nuse the same name for two different clubs, then the answer is NO.\r\nOtherwise, resolving all conflicts will yield a correct\r\nassignment.Complexity: memory and time if implemented carefully (not\r\nnecessary though).\r\n",
    "hint": []
}