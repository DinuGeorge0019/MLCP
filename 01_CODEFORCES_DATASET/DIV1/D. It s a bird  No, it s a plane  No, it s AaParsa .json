{
    "link": "https://codeforces.com//contest/1528/problem/D",
    "problemId": "994165",
    "problem_idx": "D",
    "shortId": "1528D",
    "contest_number": "1528",
    "problem_submissions": {
        "F": [
            117241784,
            117237625,
            117249711,
            117251014,
            117237719,
            117247531,
            117250487,
            117296792,
            117362083
        ],
        "C": [
            117229826,
            117199788,
            117206577,
            117201851,
            117204674,
            117206245,
            117218212,
            117196904,
            117210131,
            117210736,
            117206890,
            117212730,
            117208145,
            117211669,
            117203428,
            117211467,
            117203007,
            117206081,
            117210746,
            117210824
        ],
        "E": [
            117212844,
            117230561,
            117222959,
            117226469,
            117224989,
            117238353,
            117239558,
            117216115,
            117234224,
            117239827,
            117237600,
            117238423,
            117244129,
            117238121,
            117240390,
            117239904,
            117240349,
            117240625,
            117238487,
            117240173
        ],
        "D": [
            117201259,
            117208270,
            117212623,
            117211738,
            117242708,
            117216479,
            117225362,
            117203170,
            117222650,
            117216984,
            117223735,
            117223429,
            117215498,
            117223732,
            117224661,
            117222534,
            117223454,
            117224387,
            117255573,
            117255349,
            117255220,
            117226605,
            117221662
        ],
        "B": [
            117190972,
            117190286,
            117191599,
            117193984,
            117197139,
            117198582,
            117200082,
            117188842,
            117200429,
            117191737,
            117195913,
            117196829,
            117195712,
            117199801,
            117193006,
            117201359,
            117211353,
            117194542,
            117198721,
            117194778
        ],
        "A": [
            117185385,
            117182301,
            117183363,
            117182330,
            117185042,
            117182254,
            117192623,
            117181878,
            117188021,
            117186007,
            117186714,
            117183913,
            117183194,
            117189883,
            117184967,
            117183486,
            117187212,
            117183227,
            117187339,
            117198905
        ]
    },
    "name": "D. It s a bird  No, it s a plane  No, it s AaParsa ",
    "statement": "There are n cities in Shaazzzland, numbered from 0 to n-1. Ghaazzzland,\r\nthe immortal enemy of Shaazzzland, is ruled by AaParsa.As the head of\r\nthe Ghaazzzland\u2019s intelligence agency, AaParsa is carrying out the most\r\nimportant spying mission in Ghaazzzland\u2019s history on Shaazzzland.AaParsa\r\nhas planted m transport cannons in the cities of Shaazzzland. The i-th\r\ncannon is planted in the city a_i and is initially pointing at city\r\nb_i.It is guaranteed that each of the n cities has transport cannon\r\nplanted inside it, and that no two cannons from the same city are\r\ninitially pointing at the same city (that is, all pairs (a_i, b_i) are\r\ndistinct).AaParsa used very advanced technology to build the cannons,\r\nthe cannons rotate every second. In other words, if the i-th cannon is\r\npointing towards the city x at some second, it will target the city (x +\r\n1)\r\nmod n at the next second.As their name suggests, transport cannons are\r\nfor transportation, specifically for human transport. If you use the\r\ni-th cannon to launch yourself towards the city that it\u2019s currently\r\npointing at, you\u2019ll be airborne for c_i seconds before reaching your\r\ntarget destination.If you still don\u2019t get it, using the i-th cannon at\r\nthe s-th second (using which is only possible if you are currently in\r\nthe city a_i) will shoot you to the city (b_i + s)\r\nmod n and you\u2019ll land in there after c_i seconds (so you\u2019ll be there in\r\nthe (s + c_i)-th second). Also note the cannon that you initially\r\nlaunched from will rotate every second but you obviously won\u2019t change\r\ndirection while you are airborne. AaParsa wants to use the cannons for\r\ntravelling between Shaazzzland\u2019s cities in his grand plan, and he can\r\nstart travelling at second 0. For him to fully utilize them, he needs to\r\nknow the minimum number of seconds required to reach city u from city v\r\nusing the cannons for every pair of cities (u, v)..\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = int64_t;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<pair<int,ll> > > edges(n);\n\tfor(int i = 0; i < m; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tedges[a].push_back({b, c});\n\t}\n\n\tll M = ll(1e15);\n\tvector<vector<ll> > ans(n, vector<ll>(n, M));\n\tfor(int st = 0; st < n; st++){\n\t\tvector<ll> dist(n, M);\n\t\tvector<int> vis(n, 0);\n\t\tfor(auto [b, c] : edges[st]){\n\t\t\tdist[b] = min(dist[b], c);\n\t\t}\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tint best = -1;\n\t\t\tfor(int v = 0; v < n; v++){\n\t\t\t\tif(vis[v]) continue;\n\t\t\t\tif(best == -1 || dist[v] < dist[best]) best = v;\n\t\t\t}\n\t\t\tint v = best;\n\t\t\tvis[v] = 1;\n\t\t\tdist[(v+1) % n] = min(dist[(v+1) % n], dist[v] + 1);\n\t\t\tfor(auto [b, c] : edges[v]){\n\t\t\t\tint go = int((b + dist[v]) % n);\n\t\t\t\tdist[go] = min(dist[go], dist[v] + c);\n\t\t\t}\n\t\t}\n\t\tdist[st] = 0;\n\t\tans[st] = dist;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcout << ans[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. It s a bird  No, it s a plane  No, it s AaParsa .json",
    "editorial_link": "https://codeforces.com//blog/entry/91058",
    "editorial": "Suppose we did normal dijkstra, the only case that might be missed is\r\nwhen we wait in a vertex for some time.To handle the \u00e2\u0080\u0099waiting\u00e2\u0080\u0099 concept,\r\nwe can add fake edges, -th of which is from the -th vertex to the -th\r\nvertex with weight equal to one.Note that unlike the cannons, fake edges\r\ndo not rotate.It can be proved that doing dijkstra in the new graph is\r\nsufficient if we guarantee that the first used edge is not fake.We can\r\nmap waiting for seconds and then using an edge to go to from to using a\r\ncannon and then using fake edges to go to from .Also due to the strict\r\ntime limit you should use the variant of dijkstra.complexity:\r\n"
}