{"link": "https://codeforces.com//contest/1815/problem/F", "problemId": "1871724", "problem_idx": "F", "shortId": "1815F", "contest_number": "1815", "problem_submissions": {"F": [201555670, 201558612, 201561386, 201567730, 201566757, 202046482, 201726445, 201935453, 201585873], "E": [201530172, 201528832, 201551207, 201544435, 201543833, 201554402, 201555894, 201557703, 201554929, 201556101, 201557247, 201555003, 201557950, 201556139, 201563294, 201546853, 201542261, 201546492, 201570815], "D": [201513083, 201506968, 201521370, 201517487, 201522017, 201533871, 201533067, 201531357, 201527346, 201537489, 201539887, 201539975, 201543678, 201546232, 201566677, 201568923, 201534451], "C": [201497483, 201499771, 201506268, 201502220, 201510933, 201510356, 201506402, 201517502, 201515562, 201517401, 201523915, 201524806, 201533994, 201523878, 201503778, 201512320, 201510486, 201513744], "B": [201489690, 201490417, 201495395, 201494655, 201496814, 201493671, 201494756, 201502664, 201501592, 201503253, 201515920, 201510149, 201510749, 201492437, 201503376, 201496616, 201500693], "A": [201483243, 201480897, 201480866, 201480768, 201483195, 201480859, 201480836, 201481081, 201480782, 201481965, 201483607, 201482857, 201481459, 201480707, 201481969, 201481110, 201483462]}, "name": "F. OH NO1  -2-3-4 ", "statement": "You are given an undirected graph with n vertices and 3m edges. The\r\ngraph may contain multi-edges, but does not contain self-loops. The\r\ngraph satisfies the following property: the given edges can be divided\r\ninto m groups of 3, such that each group is a triangle.A triangle is\r\ndefined as three edges (a,b), (b,c) and (c,a) for some three distinct\r\nvertices a,b,c (1\r\nleq a,b,c\r\nleq n).Initially, each vertex v has a non-negative integer weight a_v.\r\nFor every edge (u,v) in the graph, you perform the following operation :\r\nChoose an integer x between 1 and 4. Then increase both a_u and a_v by\r\nx. After performing all operations, the following requirement should be\r\nsatisfied: if u and v are connected by an edge, then a_u\r\nne a_v.It can be proven this is always possible under the constraints of\r\nthe task. Output a way to do so, by outputting the choice of x for each\r\nedge. It is easy to see that the order of operations does not matter. If\r\nthere are multiple valid answers, output any.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 09.04.2023 12:29:46       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    auto orig = a;\n    vector<vector<int>> v(m, vector<int>(3));\n    vector<vector<int>> r(m, vector<int>(3));\n    vector<vector<pair<int, int>>> at(n);\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < 3; j++) {\n        cin >> v[i][j];\n        --v[i][j];\n        a[v[i][j]] += 3;\n        at[v[i][j]].emplace_back(i, j);\n      }\n    }\n    vector<int> ptr(m, 0);\n    set<pair<int, int>> s;\n    for (int i = 0; i < n; i++) {\n      s.emplace(a[i], i);\n    }\n    vector<bool> alive(n, true);\n    for (int it = 0; it < n; it++) {\n      int i = s.begin()->second;\n      s.erase(s.begin());\n      alive[i] = false;\n      for (auto& p : at[i]) {\n        int id = p.first;\n        int pos = p.second;\n        for (int j = 0; j < 3; j++) {\n          int k = v[id][j];\n          if (alive[k]) {\n            r[id][j] += 1;\n            s.erase(make_pair(a[k], k));\n            a[k] += 1;\n            s.emplace(a[k], k);\n          }\n        }\n      }\n    }\n    for (int i = 0; i < m; i++) {\n      cout << r[i][0] + r[i][1] << \" \" << r[i][1] + r[i][2] << \" \" << r[i][2] + r[i][0] << '\\n';\n      orig[v[i][0]] += r[i][0] + r[i][1];\n      orig[v[i][1]] += r[i][0] + r[i][1];\n      orig[v[i][1]] += r[i][1] + r[i][2];\n      orig[v[i][2]] += r[i][1] + r[i][2];\n      orig[v[i][2]] += r[i][2] + r[i][0];\n      orig[v[i][0]] += r[i][2] + r[i][0];\n    }\n/*    for (int i = 0; i < m; i++) {\n      assert(orig[v[i][0]] != orig[v[i][1]]);\n      assert(orig[v[i][1]] != orig[v[i][2]]);\n      assert(orig[v[i][2]] != orig[v[i][0]]);\n    }*/\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "math"], "dificulty": "3500", "interactive": false}