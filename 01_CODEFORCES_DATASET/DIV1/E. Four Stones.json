{
    "link": "https://codeforces.com//contest/1276/problem/E",
    "problemId": "495592",
    "problem_idx": "E",
    "shortId": "1276E",
    "contest_number": "1276",
    "problem_submissions": {
        "D": [
            66855093,
            66857065,
            66845974,
            66997276,
            66858540,
            66861684,
            66862730,
            66868898,
            66866703,
            66862266,
            66863710,
            66863337,
            66865506,
            66863170,
            66863353,
            66867792,
            66869234,
            66868492,
            66866182,
            66863049
        ],
        "C": [
            66843940,
            66846263,
            66855304,
            66856299,
            66850349,
            66850097,
            66849241,
            66845111,
            66840733,
            66851808,
            66846583,
            66853445,
            66848190,
            66854997,
            66857353,
            66855797,
            66855510,
            66860652,
            66856100,
            66851090
        ],
        "B": [
            66838883,
            66837202,
            66851887,
            66837950,
            66845504,
            66843521,
            66841052,
            66839337,
            66846582,
            66845011,
            66837082,
            66842169,
            66845204,
            66846655,
            66853297,
            66842949,
            66842748,
            66847818,
            66847458,
            66873447,
            66868214
        ],
        "A": [
            66836393,
            66834386,
            66848931,
            66834574,
            66835090,
            66834499,
            66835628,
            66834748,
            66844259,
            66835765,
            66834448,
            66836891,
            66834649,
            66835369,
            66834624,
            66839341,
            66838551,
            66839846,
            66837852,
            66838233
        ],
        "F": [
            66875333,
            66866989,
            68039784,
            67198171,
            67466141
        ],
        "E": [
            93753835,
            67190434,
            67455260,
            81662494
        ]
    },
    "name": "E. Four Stones",
    "statement": "There are four stones on an infinite line in integer coordinates a_1,\r\na_2, a_3, a_4. The goal is to have the stones in coordinates b_1, b_2,\r\nb_3, b_4. The order of the stones does not matter, that is, a stone from\r\nany position a_i can end up in at any position b_j, provided there is a\r\nrequired number of stones in each position (that is, if a coordinate x\r\nappears k times among numbers b_1,\r\nldots, b_4, there should be exactly k stones at x in the end).We are\r\nallowed to move stones with the following operation: choose two stones\r\nat positions x and y with at least one stone each, and move one stone\r\nfrom x to 2y - x. In other words, the operation moves a stone to a\r\nsymmetric position relative to some other stone. At any moment it is\r\nallowed to have any number of stones at the same position.Find any\r\nsequence of operations that achieves the goal, or determine that it is\r\nimpossible. The sequence does not have to be shortest, but it may\r\ncontain at most 1000 operations.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define int long long\n\nint a[5],b[5];\nint gcd(int a,int b){return (!b)?a:gcd(b,a%b);}\nint Abs(int x){return (x<0)?-x:x;}\nint getgcd(int *a){\n\tint ans=0;\n\tfor(int i=1;i<=4;i++)\n\t\tfor(int j=1;j<=4;j++)\n\t\t\tans=gcd(ans,Abs(a[i]-a[j]));\n\treturn ans;\n}\nstruct info{\n\tinfo(){ope.clear(),p.clear();}\n\tstd::vector<std::pair<int,int> >ope,p;\n\tvoid flip(int x,int y){\n\t\tope.push_back(std::make_pair(p[x].first,p[y].first));\n\t\tp[x].first=(p[y].first<<1)-p[x].first;\n\t}\n\tstd::pair<int,int>& operator[](int n){return p[n];}\n};\nstd::vector<std::pair<int,int> >ans;\ninfo compress(int *a){\n\tinfo ans;\n\tfor(int i=1;i<=4;i++)ans.p.push_back(std::make_pair(a[i],i));\n\tfor(;;){\n\t\tstd::sort(ans.p.begin(),ans.p.end());\n//\t\tputs(\"\");\n//\tfor(int i=0;i<4;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\tif(ans[0].first==ans[3].first-1)break;\n\t\tint old=(ans[3].first-ans[0].first);\n\t\tint l,r;\n\t\tl=ans[1].first,r=std::max(ans[3].first,(ans[1].first<<1)-ans[0].first);\n\t\tif(((r-l)<<2)<=(ans[3].first-ans[0].first)*3){\n//\t\t\tputchar('*');\n\t\t\tans.flip(0,1);\n\t\t\tcontinue;\n\t\t}\n\t\tr=ans[2].first,l=std::min(ans[0].first,(ans[2].first<<1)-ans[3].first);\n\t\tif(((r-l)<<2)<=(ans[3].first-ans[0].first)*3){\n//\t\t\tputchar('*');\n\t\t\tans.flip(3,2);\n\t\t\tcontinue;\n\t\t}\n\t\t{\n\t\t\tint d1=ans[3].first-ans[2].first,d0=ans[1].first-ans[0].first,tot=ans[3].first-ans[0].first;\n\t\t\tif(d1<(tot>>2)&&d0<(tot>>2)){\n\t\t\t\tans.flip(0,3);\n\t\t\t\tans.flip(1,2);\n\t\t\t\tans.flip(2,3);\n\t\t\t}\n\t\t\telse if(d1>d0){\n\t\t\t\tans.flip(2,3);\n\t\t\t\tans.flip(1,2);\n\t\t\t\tans.flip(1,3);\n\t\t\t\tans.flip(2,3);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans.flip(1,0);\n\t\t\t\tans.flip(2,1);\n\t\t\t\tans.flip(2,0);\n\t\t\t\tans.flip(1,0);\n\t\t\t}\n\t\t}\n\t}\n\tif(ans[0].first&1){\n\t\tans.flip(0,3);\n\t\tans.flip(1,3);\n\t\tans.flip(2,3);\n\t}\n\tstd::sort(ans.p.begin(),ans.p.end());\n\treturn ans;\n}\ninfo move(std::vector<std::pair<int,int> >pos1,std::vector<std::pair<int,int> >pos2){\n\tinfo ans;\n\tans.p=pos1;\n\tint delta=pos2[0].first-pos1[0].first,l=0;\n\tstd::vector<std::pair<int,int> >tem; \n//\tprintf(\"-%d\\n\",delta);\n\tfor(;;){\n\t\tstd::sort(ans.p.begin(),ans.p.end());\n//\t\tprintf(\"%lld %lld %lld\\n\",ans[3].first,ans[0].first,Abs(delta));\n\t\tif(ans[3].first-ans[0].first>Abs(delta))break;\n\t\t++l;\n\t\tans.flip(2,0);\n\t\tans.flip(1,3);\n\t}\n\tfor(;;){\n\t\tstd::sort(ans.p.begin(),ans.p.end());\n\t\tint change=(ans[3].first-ans[0].first)<<1;\n//\t\tprintf(\"*%d\\n\",change);\n\t\tfor(;;){\n//\t\t\tprintf(\"%d %d\\n\",delta,change);\n\t\t\tif(delta>=change){\n\t\t\t\tans.flip(0,3);\n\t\t\t\tans.flip(1,3);\n\t\t\t\tans.flip(2,3);\n\t\t\t\tans.flip(3,0);\n\t\t\t\tans.flip(2,0);\n\t\t\t\tans.flip(1,0);\n\t\t\t\tdelta-=change;\n\t\t\t}\n\t\t\telse if(delta<=-change){\n\t\t\t\tans.flip(1,0);\n\t\t\t\tans.flip(2,0);\n\t\t\t\tans.flip(3,0);\n\t\t\t\tans.flip(2,3);\n\t\t\t\tans.flip(1,3);\n\t\t\t\tans.flip(0,3);\n\t\t\t\tdelta+=change;\n\t\t\t}else break;\n\t\t}\n\t\tif(l){\n\t\t\t--l;\n\t\t\tans.flip(0,1);\n\t\t\tans.flip(3,2);\n\t\t}else break;\n\t}\n\treturn ans;\n}\nvoid add(std::vector<std::pair<int,int> >tem){for(int i=0;i<tem.size();i++)if(tem[i].first!=tem[i].second)ans.push_back(tem[i]);}\nsigned main(){\n\tfor(int i=1;i<=4;i++)scanf(\"%lld\",a+i);\n\tfor(int i=1;i<=4;i++)scanf(\"%lld\",b+i);\n\tint _gcd=getgcd(a);\n\tif(!_gcd){\n\t\tif(getgcd(b)==0&&b[1]==a[1])puts(\"0\");\n\t\telse puts(\"-1\");\n\t\treturn 0;\n\t}\n\tint x=((a[1]%_gcd)+_gcd)%_gcd;\n\tif(_gcd!=getgcd(b)||(b[1]%_gcd+_gcd)%_gcd!=(a[1]%_gcd+_gcd)%_gcd){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=4;i++)(a[i]-=x)/=_gcd,(b[i]-=x)/=_gcd;\n\tint cnt=0;\n\tfor(int i=1;i<=4;i++)cnt+=(a[i]&1)-(b[i]&1);\n\tif(cnt){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=4;i++)\n\t\tif((a[i]+b[i])&1){\n\t\t\tfor(int j=i+1;j<=4;j++)\n\t\t\t\tif((b[j]&1)==(a[i]&1)){\n\t\t\t\t\tstd::swap(b[i],b[j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n//\tfor(int i=1;i<=4;i++)printf(\"%d \",b[i]);putchar('\\n');\n\tauto nowa=compress(a),nowb=compress(b);\n\tadd(nowa.ope);\n\tadd(move(nowa.p,nowb.p).ope);\n\tstd::reverse(nowb.ope.begin(),nowb.ope.end());\n\tfor(int i=0;i<nowb.ope.size();i++){\n\t\tnowb.ope[i].first=(nowb.ope[i].second<<1)-nowb.ope[i].first;\n\t}\n\tadd(nowb.ope);\n\tprintf(\"%d\\n\",ans.size());\n\tfor(int i=0;i<ans.size();i++)printf(\"%lld %lld\\n\",ans[i].first*_gcd+x,ans[i].second*_gcd+x);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Four Stones.json",
    "editorial_link": "https://codeforces.com//blog/entry/72239",
    "editorial": "First, when is the task impossible? If all have the same remainder\r\nmodulo an integer , then it will always be true regardless of our moves.\r\nThe largest we can take is equal to . If the GCD\u00e2\u0080\u0099s or the remainders do\r\nnot match for and , then there is no answer. For convenience, let us\r\napply the transformation to all coordinates, and assume that . We can\r\nobserve further that parity of each coordinate is preserved under any\r\noperation, thus the number of even and odd numbers among and should also\r\nmatch.Otherwise, we will divide the task into two subproblems: Given\r\nfour stones , move them into a segment for an arbitrary even . Given\r\nfour stones in a segment , shift them into a segment .Suppose we can\r\ngather and into segments and . Then we can solve the problem as follows:\r\ngather into ; shift the stones from to ; undo gathering into (all moves\r\nare reversible). Throughout, let denote the maximum distance between any\r\ntwo stones. Our goal is to make . We will achieve this by repeatedly\r\ndecreasing by at least a quarter, then we will be done in steps.Suppose\r\n, and one of the stones is in the range . Consider two halves and , and\r\nmirror all stones in the shorter half with respect to . Then, becomes\r\neither the leftmost or the rightmost stone, and the new maximum distance\r\nis at most , thus reaching our goal.What if no stones are in this range?\r\nDenote the distance from to the closest extreme (leftmost or rightmost)\r\nstone. We suppose that , otherwise we can reduce as shown above. Further\r\nat least one of is non-zero, since otherwise we would have , and the\r\ngoal would be reached.Observe that performing moves , changes to . With\r\nthis we are able to change to . Repeatedly do this with (that is, we are\r\nadding twice the largest distance to the smallest). In steps we will\r\nhave , allowing us to decrease as shown above.Finally, we have all . To\r\nmake things easier, if is odd, move all to . We now have all stones in a\r\nrange , and we want to shift them by (we will assume that ). Observe\r\nthat any arrangement of stones can be shifted by by mirroring all stones\r\nwith respect to the rightmost stone twice.Consider an operation we will\r\ncall : when , make moves and . We can see that if we apply times, the\r\nlargest distance will grow exponentially in . We can then shift the\r\nstones by as follows: Apply until . While , shift all stones by as shown\r\nabove, and decrease by . If , exit. Perform the inverse operation to ,\r\nand return to step .In the end, we will have and . Further, since grows\r\nexponentially in the number of \u00e2\u0080\u0099s, for each value of we will be making\r\nshifts, thus the total number of operations for this method .\r\n"
}