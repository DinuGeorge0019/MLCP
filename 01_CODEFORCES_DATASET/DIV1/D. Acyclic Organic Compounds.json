{
    "link": "https://codeforces.com//contest/601/problem/D",
    "problemId": "41472",
    "problem_idx": "D",
    "shortId": "601D",
    "contest_number": "601",
    "problem_submissions": {
        "A": [
            14454470,
            14443143,
            14447063,
            14443587,
            14445964,
            14443595,
            14444045,
            14444989,
            14446125,
            14443550,
            14443259,
            14443909,
            14445577,
            14444080,
            14443457,
            14446585,
            14444039,
            14443354
        ],
        "B": [
            14453038,
            14449287,
            14452241,
            14450261,
            14447679,
            14448966,
            14446447,
            14447283,
            14448908,
            14445351,
            14446449,
            14446110,
            14446584,
            14449868,
            14447883,
            14445592,
            14448674,
            14450206,
            14448949
        ],
        "C": [
            14451829,
            14446840,
            14444491,
            14448343,
            14449987,
            14446641,
            14447562,
            14449169,
            14451065,
            14449654,
            14454388,
            14453682,
            14454128,
            14447981,
            14450444,
            14450228,
            14453413,
            14447154,
            14447182
        ],
        "D": [
            14449920,
            14451694,
            14450636,
            14452396,
            14452299,
            14456203,
            14456286,
            14457609,
            14452835,
            14451843,
            14450703,
            14452065,
            14453099,
            14453143,
            14453767,
            14451161,
            14453943,
            14454530
        ],
        "E": [
            14447206,
            14455203,
            14456257,
            14455227,
            14455660,
            14455476,
            14454130,
            14452692,
            14454008,
            14577340,
            14553610
        ]
    },
    "name": "D. Acyclic Organic Compounds",
    "statement": "You are given a tree with vertices (numbered through ) and a letter in\r\neach vertex. The tree is rooted at vertex .Let\u2019s look at the subtree of\r\nsome vertex . It is possible to read a string along each simple path\r\nstarting at and ending at some vertex in (possibly itself). Let\u2019s denote\r\nthe number of strings which can be read this way as . Also, there\u2019s a\r\nnumber assigned to each vertex . We are interested in vertices with the\r\nmaximum value of .You should compute two statistics: the maximum value\r\nof and the number of vertices with the maximum .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\n#include <stack>\nconst int N=301000;\nstruct node {\n\tmap<int,node*> g;\n}pool[310000*10],*cur=pool,*rt[N];\nstack<node*> tras;\nint sz[N],c[N],diff[N],n,u,v;\nVI son[N],e[N];\nchar s[N];\nnode *newnode() {\n\tif (tras.empty()) {\n\t\tnode *p=cur++;\n\t\treturn p;\n\t} else {\n\t\tnode *p=tras.top(); p->g.clear();\n\t\ttras.pop();\n\t\treturn p;\n\t}\n}\nbool cmp(int a,int b) { return sz[a]>sz[b];}\nvoid dfs2(node *a,node *b,int &sz) {\n\tfor (auto p:b->g) {\n\t\tif (!a->g.count(p.fi)) {\n\t\t\ta->g[p.fi]=newnode(); sz++;\n\t\t}\n\t\tdfs2(a->g[p.fi],p.se,sz);\n\t}\n}\nvoid dfs(int u,int f) {\n\tsz[u]=1;\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tdfs(v,u);\n\t\tson[u].pb(v);\n\t\tsz[u]+=sz[v];\n\t}\n\tif (sz[u]==1) {\n\t\trt[u]=newnode(); diff[u]=1;\n\t\trt[u]->g[s[u]-'a']=newnode();\n\t\treturn;\n\t}\n\tsort(all(son[u]),cmp);\n\trt[u]=rt[son[u][0]]; diff[u]=diff[son[u][0]];\n\trep(j,1,SZ(son[u])) {\n\t\tint v=son[u][j];\n\t\tdfs2(rt[u],rt[v],diff[u]);\n\t}\n\tnode *p=newnode(); diff[u]++; p->g[s[u]-'a']=rt[u];\n\trt[u]=p;\n//\tprintf(\"%d %d\\n\",u,diff[u]);\n}\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",c+i);\n\tscanf(\"%s\",s+1);\n\trep(i,1,n) scanf(\"%d%d\",&u,&v),e[u].pb(v),e[v].pb(u);\n\tdfs(1,0);\n\tint mv=0,st=0;\n\trep(i,1,n+1) mv=max(mv,diff[i]+c[i]);\n\trep(i,1,n+1) if (diff[i]+c[i]==mv) st++;\n\tprintf(\"%d %d\\n\",mv,st);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "hashing",
        "strings",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Acyclic Organic Compounds.json",
    "editorial_link": "https://codeforces.com//blog/entry/21755",
    "editorial": "Compute dif(v) in O(N) (without hashing) and then solve the problem in O(N2). You need some smart merges."
}