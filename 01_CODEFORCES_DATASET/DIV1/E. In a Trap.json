{
    "link": "https://codeforces.com//contest/840/problem/E",
    "problemId": "118960",
    "problem_idx": "E",
    "shortId": "840E",
    "contest_number": "840",
    "problem_submissions": {
        "E": [
            29579983,
            29579804,
            29577664,
            29579379,
            30931404,
            29639075,
            29617435,
            29681440,
            29681407,
            29681392,
            29681366
        ],
        "D": [
            29572451,
            29573549,
            29574893,
            29644417,
            29644402,
            29595162,
            29575013,
            29575646,
            29572436,
            29576887,
            29575628,
            29572554,
            29567189,
            29575551,
            29574764,
            29578191,
            29654756,
            29591307,
            29590747,
            29590681,
            29590673,
            29590627,
            29571509,
            29577552,
            29578628,
            29580062
        ],
        "C": [
            29567872,
            29569558,
            29567683,
            29569063,
            29562508,
            29569694,
            29567877,
            29577113,
            29566790,
            29572424,
            29577847,
            29579952,
            29584687,
            29571506,
            29571448,
            29570686,
            29578919,
            29571629,
            29571512,
            29569311
        ],
        "B": [
            29561393,
            29563952,
            29561789,
            29563624,
            29569083,
            29562635,
            29573313,
            29563716,
            29576058,
            29565857,
            29562483,
            29571100,
            29573859,
            29577034,
            29563154,
            29568606,
            29568725,
            29563595,
            29562462
        ],
        "A": [
            29557063,
            29560856,
            29557654,
            29557167,
            29564205,
            29559452,
            29556856,
            29560188,
            29575932,
            29562655,
            29557325,
            29559317,
            29562250,
            29559768,
            29556972,
            29558958,
            29556622,
            29557880,
            29558266
        ]
    },
    "name": "E. In a Trap",
    "statement": "Lech got into a tree consisting of vertices with a root in vertex number\r\n. At each vertex written integer . He will not get out until he answers\r\nqueries of the form . Answer for the query is maximal value among all\r\nvertices on path from to including and , where is number of edges on\r\npath from to . Also guaranteed that vertex is ancestor of vertex .\r\nLeha’s tastes are very singular: he believes that vertex is ancestor of\r\nitself.Help Leha to get out.The expression means the bitwise exclusive\r\nto the numbers and .Note that vertex is ancestor of vertex if vertex\r\nlies on the path from root to the vertex .\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nstruct HLD {\n\tvector<vi> paths;\n\tvector<pair<int, int> > pathParent;\n\tvector<pair<int, int> > nodePos;\n\tvector<int> nodeDepth;\n\n\tvoid build(const vector<vi> &g, int root) {\n\t\tint N = g.size();\n\t\tvector<int> t_ord, t_parent(N, -1);\n\t\tnodeDepth.assign(N, 0);\n\t\t{\n\t\t\tvector<int> stk;\n\t\t\tstk.push_back(root);\n\t\t\twhile (!stk.empty()) {\n\t\t\t\tint i = stk.back();\n\t\t\t\tstk.pop_back();\n\t\t\t\tt_ord.push_back(i);\n\t\t\t\tfor (int j : g[i]) if (j != root && t_parent[j] == -1) {\n\t\t\t\t\tt_parent[j] = i;\n\t\t\t\t\tnodeDepth[j] = nodeDepth[i] + 1;\n\t\t\t\t\tstk.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> subtsize(N, 1);\n\t\tfor (int ix = N - 1; ix > 0; -- ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tsubtsize[p] += subtsize[i];\n\t\t}\n\t\tpaths.clear();\n\t\tpaths.push_back(vi());\n\t\tpathParent.emplace_back(-1, 0);\n\t\tdfs(root, -1, g, subtsize);\n\t\tassert(paths.back().empty());\n\t\tpaths.pop_back();\n\t\tassert(paths.size() == pathParent.size());\n\n\t\tnodePos.assign(N, { -1, -1 });\n\t\trep(c, paths.size()) rep(p, paths[c].size())\n\t\t\tnodePos[paths[c][p]] = { c, p };\n\t}\n\n\tvoid get(int u, int &c, int &p) const {\n\t\ttie(c, p) = nodePos[u];\n\t}\n\n\tbool go_up(int &c, int &p) const {\n\t\ttie(c, p) = pathParent[c];\n\t\treturn c != -1;\n\t}\n\n\ttypedef tuple<int, int, int> SubPath;\n\n\tvoid getPath1(int u, int v, vector<SubPath> &path) const {\n\t\tpath.clear();\n\t\tint uc, up, vc, vp;\n\t\tget(u, uc, up);\n\t\tget(v, vc, vp);\n\t\twhile (uc != vc) {\n\t\t\tpath.emplace_back(vc, 0, vp + 1);\n\t\t\tgo_up(vc, vp);\n\t\t}\n\t\tpath.emplace_back(vc, up, vp + 1);\n\t}\n\nprivate:\n\tvoid dfs(int i, int p, const vector<vi> &g, const vector<int> &subtsize) {\n\t\tint color = (int)paths.size() - 1;\n\t\tint pos = paths.back().size();\n\t\tpaths.back().push_back(i);\n\n\t\tint c = -1;\n\t\tfor (int j : g[i]) if (j != p) {\n\t\t\tif (c == -1 || subtsize[c] < subtsize[j])\n\t\t\t\tc = j;\n\t\t}\n\n\t\tif (c == -1) {\n\t\t\tpaths.push_back(vi());\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(c, i, g, subtsize);\n\n\t\tfor (int j : g[i]) if (j != p && j != c) {\n\t\t\tpathParent.emplace_back(color, pos);\n\t\t\tdfs(j, i, g, subtsize);\n\t\t}\n\t}\n};\n\nint main() {\n\tint n; int q;\n\twhile (~scanf(\"%d%d\", &n, &q)) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d\", &a[i]);\n\t\tvector<vector<int> > g(n);\n\t\tfor (int i = 0; i < n - 1; ++ i) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tHLD hld;\n\t\thld.build(g, 0);\n\t\tmap<pii, int> memo;\n\t\tvector<tuple<int, int, int>> path;\n\t\tvector<int> offsets(hld.paths.size() + 1);\n\t\tconst int W = 8;\n\t\trep(i, hld.paths.size())\n\t\t\toffsets[i + 1] = offsets[i] + (hld.paths[i].size() / W + 1) * W;\n\t\tvector<uint16_t> values(offsets.back());\n\t\trep(i, hld.paths.size()) rep(j, hld.paths[i].size())\n\t\t\tvalues[offsets[i] + j] = a[hld.paths[i][hld.paths[i].size() - 1 - j]];\n\t\tll anssum = 0;\n\t\trep(ii, q) {\n\t\t\tint u; int v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tauto &ans = memo.emplace(make_pair(make_pair(u, v), -1)).first->second;\n\t\t\tif (ans != -1) {\n\t\t\t\tprintf(\"%d\\n\", ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thld.getPath1(u, v, path);\n\t\t\tint add = 0;\n\t\t\tint maxi = 0;\n\t\t\tfor (auto t : path) {\n\t\t\t\tint c, L, R;\n\t\t\t\ttie(c, L, R) = t;\n\t\t\t\tauto x = values.data() + offsets[c] + (hld.paths[c].size() - R);\n\t\t\t\tint len = R - L;\n\t\t\t\tfor (int i = 0; i < len; ++ i)\n\t\t\t\t\tamax(maxi, x[i] ^ (add + i));\n\t\t\t\tadd += len;\n\t\t\t}\n\t\t\tans = maxi;\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "trees"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. In a Trap.json",
    "editorial_link": "https://codeforces.com//blog/entry/53943?locale=en",
    "editorial": "The path from u to v can be divided into blocks of 256 nodes and (possibly) a single block with less than 256 nodes. We can consider this last block separately, by iterating all of its nodes.\nNow we need to deal with the blocks with length exactly 256. They are determined by two numbers: x  last node in the block, and d  8 highest bits. We can precalculate this values and then use them to answer the queries.\nLet's now talk about precalculating answer(x,?d). Let's fix x and 255 nodes after x. It's easy to notice that lowest 8 bits will always be as following: 0,?1,?...,?255. We can xor this values: 0 with ax, 1 with anextx and so on, and store the results in a trie. Now we can iterate all possible values of d (from 0 to 255) and the only thing left is to find a number stored in a trie, say q, such that q xor 255·d is maximized.",
    "hint": []
}