{"link": "https://codeforces.com//contest/1246/problem/F", "problemId": "451072", "problem_idx": "F", "shortId": "1246F", "contest_number": "1246", "problem_submissions": {"F": [63515154, 63481339, 63483227, 63527437], "E": [63477457, 63471160, 63477982, 63475906, 63518064, 63483383, 63518604, 97691403, 63517633, 63488500], "D": [63464099, 63460604, 63460125, 63467192, 63463968, 63466889, 63467829, 63473013, 63471128, 63459892, 63474479, 63467875, 63476603, 63468880, 63466274, 63468455, 63468377, 63471942, 63478598, 63471593], "C": [63452409, 63454665, 63454015, 63456906, 63457379, 63460403, 63458338, 63462999, 63457035, 63454754, 63459839, 63457021, 63458327, 63457758, 63458226, 63460931, 63460824, 63461992, 63467689, 63460739], "B": [63442019, 63440659, 63440705, 63445485, 63449371, 63449831, 63445799, 63449601, 63451011, 63449141, 63439490, 63447371, 63445988, 63447815, 63451910, 63451605, 63453470, 63443287, 63451810, 63450686], "A": [63437903, 63456370, 63443580, 63437815, 63442162, 63437666, 63439166, 63442383, 63492730, 63442467, 63438366, 63445898, 63440290, 63439417, 63440796, 63444393, 63441301, 63442558, 63437991, 63443933, 63444495]}, "name": "F. Cursor Distance", "statement": "There is a string s of lowercase English letters. A cursor is positioned\r\non one of the characters. The cursor can be moved with the following\r\noperation: choose a letter c and a direction (left or right). The cursor\r\nis then moved to the closest occurence of c in the chosen direction. If\r\nthere is no letter c in that direction, the cursor stays in place. For\r\nexample, if s =\r\nmathtt{abaab} with the cursor on the second character (\r\nmathtt{a[b]aab}), then: moving to the closest letter\r\nmathtt{a} to the left places the cursor on the first character (\r\nmathtt{[a]baab}); moving to the closest letter\r\nmathtt{a} to the right places the cursor the third character (\r\nmathtt{ab[a]ab}); moving to the closest letter\r\nmathtt{b} to the right places the cursor on the fifth character (\r\nmathtt{abaa[b]}); any other operation leaves the cursor in place.Let\r\nmathrm{dist}(i, j) be the smallest number of operations needed to move\r\nthe cursor from the i-th character to the j-th character. Compute\r\ndisplaystyle\r\nsum_{i = 1}^n\r\nsum_{j = 1}^n\r\nmathrm{dist}(i, j).\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 1e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void pr(const T& x) { \n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    \n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n    }\n    \n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n    }\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint n; ll ans = 0;\nset<char> alpha;\nchar s[MX];\narray<int,26> nex[MX], pre[MX];\nint NEX[27][MX], PRE[27][MX];\npair<int,ll> bnex[MX][17], bpre[MX][17];\nvpi preAlpha[MX], nexAlpha[MX];\npi cur[MX];\n\nvoid init() {\n\tsetIO(); str tmp; re(tmp); n = sz(tmp);\n\tF0R(i,n) s[i+1] = tmp[i];\n}\n\nint countAlpha(pi cur) {\n\tint a = 0;\n\ttrav(t,nexAlpha[cur.f]) if (t.f <= cur.s) a ++;\n\treturn a;\n}\n\nbool atMost(pi cur, int a) {\n\treturn a >= sz(nexAlpha[cur.f]) || nexAlpha[cur.f][a].f > cur.s;\n}\n\nint main() {\n\tinit();\n\tFOR(i,1,n+1) alpha.insert(s[i]);\n\tF0R(i,26) {\n\t\tpre[1][i] = -MOD;\n\t\tnex[n][i] = MOD;\n\t}\n\tFOR(i,2,n+2) {\n\t\tpre[i] = pre[i-1];\n\t\tpre[i][s[i-1]-'a'] = i-1;\n\t}\n\tROF(i,0,n) {\n\t\tnex[i] = nex[i+1];\n\t\tnex[i][s[i+1]-'a'] = i+1;\n\t}\n\tFOR(i,1,n+1) {\n\t\t{\n\t\t\tvpi v;\n\t\t\tF0R(j,26) if (pre[i+1][j] != -MOD) v.pb({pre[i+1][j],j});\n\t\t\tsort(rall(v));\n\t\t\tpreAlpha[i] = v;\n\t\t\tint r = i;\n\t\t\tFOR(z,1,27) {\n\t\t\t\tif (z-1 < sz(v)) ckmax(r,min(n,nex[i][v[z-1].s]));\n\t\t\t\tNEX[z][i] = r;\n\t\t\t\t// ps(\"HA\",z,i,r);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvpi v;\n\t\t\tF0R(j,26) if (nex[i-1][j] != MOD) v.pb({nex[i-1][j],j});\n\t\t\tsort(all(v));\n\t\t\tnexAlpha[i] = v;\n\t\t\tint l = i;\n\t\t\tFOR(z,1,27) {\n\t\t\t\tif (z-1 < sz(v)) ckmin(l,max(pre[i][v[z-1].s],1));\n\t\t\t\tPRE[z][i] = l;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,1,n+1) cur[i] = {i,i};\n\tFOR(k,1,sz(alpha)+1) {\n\t\tFOR(i,1,n+1) {\n\t\t\tbnex[i][0] = {NEX[k][i],i};\n\t\t\tbpre[i][0] = {PRE[k][i],i};\n\t\t}\n\t\tFOR(j,1,17) FOR(i,1,n+1) {\n\t\t\tbnex[i][j] = bnex[bnex[i][j-1].f][j-1];\n\t\t\tbnex[i][j].s += bnex[i][j-1].s;\n\t\t\tbpre[i][j] = bpre[bpre[i][j-1].f][j-1];\n\t\t\tbpre[i][j].s += bpre[i][j-1].s;\n\t\t}\n\t\tFOR(i,1,n+1) if (atMost(cur[i],k)) {\n\t\t\tpi& p = cur[i];\n\t\t\tR0F(j,17) {\n\t\t\t\tif (atMost({bpre[p.f][j].f,bnex[p.s][j].f},k)) {\n\t\t\t\t\tans += (ll)(n-1)<<j;\n\t\t\t\t\tans -= bnex[p.s][j].s;\n\t\t\t\t\tans += bpre[p.f][j].s;\n\t\t\t\t\tp = {bpre[p.f][j].f,bnex[p.s][j].f};\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (ll)(n-1)<<0;\n\t\t\tans -= bnex[p.s][0].s;\n\t\t\tans += bpre[p.f][0].s;\n\t\t\tp = {bpre[p.f][0].f,bnex[p.s][0].f};\n\t\t}\n\t}\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n"], "input": "", "output": "", "tags": [], "dificulty": "3500", "interactive": false}