{
    "link": "https://codeforces.com//contest/1098/problem/C",
    "problemId": "278462",
    "problem_idx": "C",
    "shortId": "1098C",
    "contest_number": "1098",
    "problem_submissions": {
        "E": [
            51775559,
            48006690,
            48011091,
            47996318,
            48015799,
            48015745,
            48015679,
            48016465
        ],
        "D": [
            47994331,
            47991784,
            48004915,
            47986667,
            47997263,
            47997207,
            47997823,
            48003406,
            48012772,
            48000542,
            48002246,
            47998686,
            48003172,
            48003847,
            48013739,
            48013700,
            48013652,
            48012961,
            48012955,
            48007481,
            48004946,
            47998449,
            48006927,
            47993907
        ],
        "C": [
            47990851,
            47988182,
            48002088,
            47984104,
            47990986,
            47992891,
            47990373,
            47996864,
            47993728,
            47992046,
            48002685,
            47997828,
            47997416,
            47983441,
            47996246,
            48004923,
            47992474,
            48000276
        ],
        "B": [
            47984141,
            47982505,
            48010238,
            47997345,
            47983353,
            47986135,
            47985242,
            47985258,
            47997818,
            47982827,
            47991394,
            47990410,
            47990108,
            47991143,
            47984918,
            47988149,
            47999187,
            48005571
        ],
        "A": [
            47975157,
            47974213,
            48009223,
            47974115,
            47975580,
            47975415,
            47977674,
            47976551,
            47976714,
            47995866,
            47975779,
            47977103,
            47975994,
            47986982,
            47978302,
            47975716,
            47976034,
            47978693
        ],
        "F": [
            54648301
        ]
    },
    "name": "C. Construct a tree",
    "statement": "Misha walked through the snowy forest and he was so fascinated by the\r\ntrees to decide to draw his own tree!Misha would like to construct a\r\nrooted tree with n vertices, indexed from 1 to n, where the root has\r\nindex 1. Every other vertex has a p_i, and i is called a of vertex p_i.\r\nVertex u belongs to the of vertex v iff v is reachable from u while\r\niterating over the parents (u, p_{u}, p_{p_{u}}, ...). Clearly, v\r\nbelongs to its own subtree, and the number of vertices in the subtree is\r\ncalled the of the subtree. Misha is only interested in trees where every\r\nvertex belongs to the subtree of vertex 1.Below there is a tree with 6\r\nvertices. The subtree of vertex 2 contains vertices 2, 3, 4, 5. Hence\r\nthe size of its subtree is 4. The of the tree is defined as the maximum\r\nnumber of children in any vertex. For example, for the tree above the\r\nbranching coefficient equals 2. Your task is to construct a tree with n\r\nvertices such that the sum of the subtree sizes for all vertices equals\r\ns, and the branching coefficient is minimum possible.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nll s;\n\nint k=1;\n\nll ile[nax];\nll lim[nax];\n\nvi tso[nax];\n\nll powy(int v)\n{\n\t//~ ll ret=1;\n\t//~ vll dp(n);\n\t//~ dp[0]=1;\n\t//~ for (int i=1; i<n; i++)\n\t//~ {\n\t\t//~ dp[i]=dp[(i-1)/v]+1;\n\t\t//~ ret+=dp[i];\n\t//~ }\n\t//~ return ret;\n\tll ret=1;\n\tll ile=1;\n\tll jesz=n-1;\n\tfor (int i=2; jesz; i++)\n\t{\n\t\tile=min(ile*v, jesz);\n\t\tjesz-=ile;\n\t\tret+=i*ile;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%lld\", &n, &s);\n\tif (s>n*(n+1LL)/2 || s<2*n-1)\n\t{\n\t\tprintf(\"No\\n\");\n\t\texit(0);\n\t}\n\twhile(powy(k)>s)\n\t\tk++;\n\t//~ int bsa=1;\n\t//~ int bsb=n;\n\t//~ int bss;\n\t//~ while(bsa<bsb)\n\t//~ {\n\t\t//~ bss=(bsa+bsb)>>1;\n\t\t//~ if (powy(bss)<)\n\t//~ }\n\t//~ k=bsa;\n\t\n\t//~ debug() << imie(k);\n\tprintf(\"Yes\\n\");\n\tlim[1]=1;\n\tfor (int i=2; i<=n; i++)\n\t\tlim[i]=min((ll)n, lim[i-1]*k);\n\tll ter=n*(n+1LL)/2;\n\tfor (int i=1; i<=n; i++)\n\t\tile[i]=1;\n\tfor (int i=n; ter>s; i--)\n\t{\n\t\tint g=1;\n\t\twhile(ile[g]==lim[g])\n\t\t\tg++;\n\t\twhile(ter-(i-g)<s)\n\t\t\tg++;\n\t\tile[i]--;\n\t\tile[g]++;\n\t\tter-=(i-g);\n\t}\n\tint m=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=0; j<ile[i]; j++)\n\t\t{\n\t\t\tm++;\n\t\t\ttso[i].push_back(m);\n\t\t\tif (m>1)\n\t\t\t\tprintf(\"%d \", tso[i-1][j/k]);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Construct a tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/64331",
    "editorial": "Note, that vertex belongs to subtrees of vertexes, which lay on its way\r\nto root. So, sum of sizes of subtrees is equal to , where is sum of\r\nlengths of ways from root to vertexes. Let\u00e2\u0080\u0099s consider which sum of sizes\r\nof subtrees can be in tree with branching coefficient less or equal than\r\n.Minimal sum can be achieved in -nary tree (it consists of root,\r\nvertexes on distance , on distance , etc, the last level can be filled\r\nnot completely).Maximal sum can be achieved in bamboo tree, which\r\nconsists of only one way with length . If is bigger than sum in this\r\ntree, the answer will be .Let\u00e2\u0080\u0099s find minimal , such that is not smaller\r\nthan sum of sizes of subtrees in -nary tree (using binary search). Now\r\nis between minimal and maximal sum of sizes of subtrees in tree with\r\nbranching coefficient, which is not bigger than .Let\u00e2\u0080\u0099s show how to build\r\ntree with the given sum, which is between these two borders. Let\u00e2\u0080\u0099s start\r\nwith -nary tree.Let\u00e2\u0080\u0099s realize recursive function, which rebuilds tree.\r\nLet we are in a subtree, and want to increase sum of sizes of subtrees\r\nby (in this subtree). We can change this subtree to bamboo with same\r\nnumber of vertexes (if the sum of sizeof of subtrees won\u00e2\u0080\u0099t be too big).\r\nOtherwise, we run this function from subtrees in some order. If we reach\r\nneeded sum, we will terminate the process. Otherwise, every subtree of\r\nchild is bamboo now, current sum of sizes is smaller than needed, but if\r\nwe merged bamboos, it would be bigger than it. Let\u00e2\u0080\u0099s move vertexes to\r\nthe end of the first bamboo from others. Over time, after next moving,\r\nsum of sizes will increase too much. We can move it to the another\r\nposition in the first bamboo, in order to make sum equal to , and\r\nterminate the process.But if we believe that every tree with sum of\r\nsizes of subtrees between maximal and minimal can be built, there is\r\nanother solution with complexity, which is easier to realize.The sum of\r\nsubtree sizes is influenced only by the number of vertices at each\r\ndistance, and not by their mutual arrangement. Sum of sizes of subtrees\r\nis equal to , where number of vertexes on distance from the root. Let\u00e2\u0080\u0099s\r\nbuilt this array of counts. These conditions must be satisfied: If the\r\n-th element is bigger than (), than -th element must be bigger than . If\r\nthe -th element is equal to , -th mustn\u00e2\u0080\u0099t be bigger than . Sum of\r\nelements must be equal to .Let we have recovered some prefix of this\r\narray (i.e we know that we can fill rest, and sum of sizes of subtrees\r\nwill be equal to ). Let\u00e2\u0080\u0099s try to put some value to the next element.We\r\nknow that the tree can be rebuilt so that the sum is any between maximum\r\nand minimum, so there are two conditions, which are satisfied (we want\r\nto put value to position ). must be big enough, so if we fill suffix\r\nwith numbers , , , ... (the last non-zero number can be smaller, sum of\r\nnumbers is ) sum of sizes of subtrees will be not greater to . must be\r\nsmall enough, so if we fill suffix with , sum of sizes of subtrees will\r\nbe not less than .Both borders form some segment of values, which could\r\nbe put to this position. We haven\u00e2\u0080\u0099t to look for the left border, just\r\nfind the right border by binsearch, and put number, which is equal to\r\nit. We can easily restore the tree, using array .\r\n"
}