{
    "link": "https://codeforces.com//contest/329/problem/C",
    "problemId": "3356",
    "problem_idx": "C",
    "shortId": "329C",
    "contest_number": "329",
    "problem_submissions": {
        "D": [
            4118984,
            4120313,
            4119660,
            4116785,
            4117605,
            4120902,
            4120215,
            4118708,
            4120010,
            4137748,
            4119968,
            4119996,
            4119672,
            4121809
        ],
        "C": [
            4117113,
            4117558,
            4116367,
            4121523,
            4143349,
            4121550,
            4117988,
            4118184,
            4122060,
            4117812,
            4137746,
            4121987,
            4121389,
            4120201,
            4115159,
            4117962,
            4119458,
            4118596
        ],
        "B": [
            4114305,
            4114368,
            4113665,
            4115021,
            4115525,
            4115412,
            4114479,
            4114580,
            4118395,
            4137745,
            4114685,
            4117097,
            4121085,
            4123377,
            4114997,
            4115233,
            4115579
        ],
        "A": [
            4112796,
            4112854,
            4120598,
            4113396,
            4112888,
            4113555,
            4112601,
            4113197,
            4113479,
            4137744,
            4112411,
            4113271,
            4115572,
            4112548,
            4113837,
            4113786,
            4113898
        ],
        "E": [
            4137719
        ]
    },
    "name": "C. Graph Reconstruction",
    "statement": "I have an undirected graph consisting of nodes, numbered 1 through .\r\nEach node has at most two incident edges. For each pair of nodes, there\r\nis at most an edge connecting them. No edge connects a node to itself.I\r\nwould like to create a new graph in such a way that: The new graph\r\nconsists of the same number of nodes and edges as the old graph. The\r\nproperties in the first paragraph still hold. For each two nodes and ,\r\nif there is an edge connecting them in the old graph, there is no edge\r\nconnecting them in the new graph. Help me construct the new graph, or\r\ntell me if it is impossible.\r\n",
    "solutions": [
        "/*\nID: espr1t\nTASK: \nKEYWORDS: \n*/\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <set>\n#include <vector>\n\nusing namespace std;\nFILE *in; FILE *out;\n\nconst int MAX = 131072;\n\nint n, m;\nset < pair <int, int> > edges;\nset < pair <int, int> > used;\nint deg[MAX];\nvector <int> v[MAX];\nint totalCycles;\nconst int maxCycles = 10000000;\n\nint rand21() {\n    int ret = 0;\n    for (int i = 0; i < 3; i++) {\n        int add = (rand() & (((1 << 7) - 1) << 7)) >> 7;\n        ret |= (add << (i * 7));\n    }\n    return ret;\n}\n\nbool eval() {\n    used.clear();\n    for (int i = 0; i < n; i++) {\n        v[i].clear();\n        deg[i] = 0;\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int node1 = -1, node2 = -1;\n        int innerCycles = 0, limit = 100000;\n        while (true) {\n            totalCycles++;\n            if (totalCycles > maxCycles)\n                return false;\n            innerCycles++;\n            if (innerCycles > limit)\n                return false;\n\n            node1 = rand21() % n;\n            while (deg[node1] >= 2) {\n                totalCycles++;\n                if (totalCycles > maxCycles)\n                    return false;\n                innerCycles++;\n                if (innerCycles > limit)\n                    return false;\n                node1 = rand21() % n;\n            }\n            node2 = rand21() % n;\n            while (deg[node2] >= 2) {\n                totalCycles++;\n                if (totalCycles > maxCycles)\n                    return false;\n                innerCycles++;\n                if (innerCycles > limit)\n                    return false;\n                node2 = rand21() % n;\n            }\n\n            if (node1 == node2) continue;\n            if (node1 > node2)\n                swap(node1, node2);\n            if (edges.find(make_pair(node1, node2)) != edges.end())\n                continue;\n            if (used.find(make_pair(node1, node2)) != used.end())\n                continue;\n            break;\n        }\n        deg[node1]++;\n        deg[node2]++;\n        v[node1].push_back(node2);\n        used.insert(make_pair(node1, node2));\n    }\n    return true;\n}\n\n\nint main(void) {\n\tin = stdin; out = stdout;\n//\tin = fopen(\"C.in\", \"rt\"); out = fopen(\"C.out\", \"wt\");\n\t\n\tfscanf(in, \"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t    int node1, node2;\n\t    fscanf(in, \"%d %d\", &node1, &node2);\n\t    node1--; node2--;\n\t    edges.insert(make_pair(min(node1, node2), max(node1, node2)));\n\t}\n\t\n    totalCycles = 0;\n    while (true) {\n        if (eval()) {\n    \t    for (int i = 0; i < n; i++) {\n    \t        for (int c = 0; c < (int)v[i].size(); c++)\n    \t            fprintf(out, \"%d %d\\n\", i + 1, v[i][c] + 1);\n    \t    }\n    \t    return 0;\n        }\n        if (totalCycles > maxCycles)\n            break;\n    }\n\tfprintf(out, \"-1\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Graph Reconstruction.json",
    "editorial_link": "https://codeforces.com//blog/entry/8417",
    "editorial": "First, I would like to apologize the missing node 3 in the picture of\r\nthe first example. It was a mistake :( Intended, deterministic solution:\r\nThe deterministic solution is very tricky. Therefore, I made the pretest\r\nquite strong. Some tricky cases: Actually, we can do brute force when n\r\n<= 6, but this requires a special handling: when the largest component\r\nhas 4 nodes, we should swap the first node with the third node (not the\r\nsecond). This is to handle the 4-cycle-and-3-cycle case. Troll solution,\r\nnondeterministic: Do the following many times: So, the question is, for\r\nlarge n what is the probability that a permutation is not \"bad\"? This\r\ncan be computed (or at least approximated) similar to computing\r\nderangement probability â I obtained a result above 0.1, which means in\r\n100 iterations it should succeed if there was a solution. ...There is a\r\nsolution if n > 7, so it should work.\r\n",
    "hint": []
}