{"link": "https://codeforces.com//contest/1149/problem/D", "problemId": "337472", "problem_idx": "D", "shortId": "1149D", "contest_number": "1149", "problem_submissions": {"E": [53524396, 53522321, 53522530, 61434525, 53525980, 53522711, 53522606, 53524594], "D": [53521434, 53526235, 53529930, 53518623, 53524984, 53524746, 53526493, 53518787, 53526308, 53526383, 53526628, 53531041, 53521860, 53522269, 53523326, 53523444], "C": [53514328, 53518841, 53519044, 53525230, 53518371, 53511307, 53515929, 53520465, 53525523, 53518004, 53522574, 53520365, 53530616, 53530825], "B": [53508704, 53508119, 53512032, 53509531, 53508225, 53520230, 53523389, 53511171, 53521543, 53521758, 53512839, 53514480, 53510228, 53510444, 53509691, 53512920, 53514615, 53513077, 53514341], "A": [53502075, 53501727, 53502902, 53502745, 53502146, 53501598, 53502759, 53502876, 53503703, 53505214, 53502973, 53503023, 53501694, 53501955, 53501687, 53504126, 53504632, 53504664, 53501821]}, "name": "D. Abandoning Roads", "statement": "Codefortia is a small island country located somewhere in the West\r\nPacific. It consists of n settlements connected by m bidirectional\r\ngravel roads. Curiously enough, the beliefs of the inhabitants require\r\nthe time needed to pass each road to be equal either to a or b seconds.\r\nIt\u2019s guaranteed that one can go between any pair of settlements by\r\nfollowing a sequence of roads.Codefortia was recently struck by the\r\nfinancial crisis. Therefore, the king decided to abandon some of the\r\nroads so that: it will be possible to travel between each pair of cities\r\nusing the remaining roads only, the sum of times required to pass each\r\nremaining road will be minimum possible (in other words, remaining roads\r\nmust form minimum spanning tree, using the time to pass the road as its\r\nweight), among all the plans minimizing the sum of times above, the time\r\nrequired to travel between the king\u2019s residence (in settlement 1) and\r\nthe parliament house (in settlement p) using the remaining roads only\r\nwill be minimum possible. The king, however, forgot where the parliament\r\nhouse was. For each settlement p = 1, 2,\r\ndots, n, can you tell what is the minimum time required to travel\r\nbetween the king\u2019s residence and the parliament house (located in\r\nsettlement p) after some roads are abandoned?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int INF = (int)1e9;\nconst int N = 71;\nconst int M = (1 << 17) + 3;\nint A, B;\nvector<pii> g[N];\nint compId[N];\nint n, m;\nint a[N][N];\nint dp[N][M];\nint dist[N];\nbool used[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d%d\", &n, &m, &A, &B);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ta[i][j] = (i == j ? 0 : INF);\n\twhile(m--) {\n\t\tint v, u, w;\n\t\tscanf(\"%d%d%d\", &v, &u, &w);\n\t\tv--;u--;\n\t\tg[v].push_back(mp(u, w));\n\t\tg[u].push_back(mp(v, w));\n\t\tif (w == A) {\n\t\t\ta[v][u] = a[u][v] = 1;\n\t\t}\n\t}\n\tfor (int k = 0; k < n; k++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\ta[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n\tm = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tcompId[i] = -1;\n\tfor (int v = 0; v < n; v++) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < v; i++)\n\t\t\tok &= a[v][i] == INF;\n\t\tif (!ok) continue;\n\t\tint sz = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[v][i] < INF)\n\t\t\t\tsz++;\n\t\tif (sz < 4) continue;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[v][i] < INF)\n\t\t\t\tcompId[i] = m;\n\t\tm++;\n\t}\n\tif (m > 17) throw;\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int mask = 0; mask < (1 << m); mask++)\n\t\t\tdp[v][mask] = INF;\n\tdp[0][(compId[0] == -1 ? 0 : (1 << compId[0]))] = 0;\n\tfor (int mask = 0; mask < (1 << m); mask++) {\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tdist[v] = dp[v][mask];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tused[i] = false;\n\t\tfor (int it = 0; it < n; it++) {\n\t\t\tint v = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (used[i]) continue;\n\t\t\t\tif (v == -1 || dist[v] > dist[i])\n\t\t\t\t\tv = i;\n\t\t\t}\n\t\t\tused[v] = 1;\n\t\t\tif (dist[v] == INF) break;\n\t\t\tfor (pii e : g[v]) {\n\t\t\t\tint u = e.first;\n\t\t\t\tif (used[u]) continue;\n\t\t\t\tif (dist[u] <= dist[v] + e.second) continue;\n\t\t\t\tif (e.second == B && a[v][u] < INF) continue;\n\t\t\t\tif (e.second == B && compId[u] != -1) continue;\n\t\t\t\tdist[u] = dist[v] + e.second;\n\t\t\t}\n\t\t}\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tdp[v][mask] = dist[v];\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tfor (pii e : g[v]) {\n\t\t\t\tif (e.second != B) continue;\n\t\t\t\tint u = e.first;\n\t\t\t\tif (compId[u] == -1) continue;\n\t\t\t\tif ((mask >> compId[u]) & 1) continue;\n\t\t\t\tdp[u][mask | (1 << compId[u])] = min(dp[u][mask | (1 << compId[u])], dp[v][mask] + e.second);\n\t\t\t}\n\t}\n\n\tfor (int v = 0; v < n; v++) {\n\t\tint ans = INF;\n\t\tfor (int mask = 0; mask < (1 << m); mask++)\n\t\t\tans = min(ans, dp[v][mask]);\n\t\tprintf(\"%d \", ans);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp", "graphs", "greedy"], "dificulty": "3000", "interactive": false}