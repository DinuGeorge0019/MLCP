{
    "link": "https://codeforces.com//contest/1149/problem/D",
    "problemId": "337472",
    "problem_idx": "D",
    "shortId": "1149D",
    "contest_number": "1149",
    "problem_submissions": {
        "E": [
            53524396,
            53522321,
            53522530,
            61434525,
            53525980,
            53522711,
            53522606,
            53524594
        ],
        "D": [
            53521434,
            53526235,
            53529930,
            53518623,
            53524984,
            53524746,
            53526493,
            53518787,
            53526308,
            53526383,
            53526628,
            53531041,
            53521860,
            53522269,
            53523326,
            53523444
        ],
        "C": [
            53514328,
            53518841,
            53519044,
            53525230,
            53518371,
            53511307,
            53515929,
            53520465,
            53525523,
            53518004,
            53522574,
            53520365,
            53530616,
            53530825
        ],
        "B": [
            53508704,
            53508119,
            53512032,
            53509531,
            53508225,
            53520230,
            53523389,
            53511171,
            53521543,
            53521758,
            53512839,
            53514480,
            53510228,
            53510444,
            53509691,
            53512920,
            53514615,
            53513077,
            53514341
        ],
        "A": [
            53502075,
            53501727,
            53502902,
            53502745,
            53502146,
            53501598,
            53502759,
            53502876,
            53503703,
            53505214,
            53502973,
            53503023,
            53501694,
            53501955,
            53501687,
            53504126,
            53504632,
            53504664,
            53501821
        ]
    },
    "name": "D. Abandoning Roads",
    "statement": "Codefortia is a small island country located somewhere in the West\r\nPacific. It consists of n settlements connected by m bidirectional\r\ngravel roads. Curiously enough, the beliefs of the inhabitants require\r\nthe time needed to pass each road to be equal either to a or b seconds.\r\nIt\u2019s guaranteed that one can go between any pair of settlements by\r\nfollowing a sequence of roads.Codefortia was recently struck by the\r\nfinancial crisis. Therefore, the king decided to abandon some of the\r\nroads so that: it will be possible to travel between each pair of cities\r\nusing the remaining roads only, the sum of times required to pass each\r\nremaining road will be minimum possible (in other words, remaining roads\r\nmust form minimum spanning tree, using the time to pass the road as its\r\nweight), among all the plans minimizing the sum of times above, the time\r\nrequired to travel between the king\u2019s residence (in settlement 1) and\r\nthe parliament house (in settlement p) using the remaining roads only\r\nwill be minimum possible. The king, however, forgot where the parliament\r\nhouse was. For each settlement p = 1, 2,\r\ndots, n, can you tell what is the minimum time required to travel\r\nbetween the king\u2019s residence and the parliament house (located in\r\nsettlement p) after some roads are abandoned?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int INF = (int)1e9;\nconst int N = 71;\nconst int M = (1 << 17) + 3;\nint A, B;\nvector<pii> g[N];\nint compId[N];\nint n, m;\nint a[N][N];\nint dp[N][M];\nint dist[N];\nbool used[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d%d\", &n, &m, &A, &B);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ta[i][j] = (i == j ? 0 : INF);\n\twhile(m--) {\n\t\tint v, u, w;\n\t\tscanf(\"%d%d%d\", &v, &u, &w);\n\t\tv--;u--;\n\t\tg[v].push_back(mp(u, w));\n\t\tg[u].push_back(mp(v, w));\n\t\tif (w == A) {\n\t\t\ta[v][u] = a[u][v] = 1;\n\t\t}\n\t}\n\tfor (int k = 0; k < n; k++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\ta[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n\tm = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tcompId[i] = -1;\n\tfor (int v = 0; v < n; v++) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < v; i++)\n\t\t\tok &= a[v][i] == INF;\n\t\tif (!ok) continue;\n\t\tint sz = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[v][i] < INF)\n\t\t\t\tsz++;\n\t\tif (sz < 4) continue;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[v][i] < INF)\n\t\t\t\tcompId[i] = m;\n\t\tm++;\n\t}\n\tif (m > 17) throw;\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int mask = 0; mask < (1 << m); mask++)\n\t\t\tdp[v][mask] = INF;\n\tdp[0][(compId[0] == -1 ? 0 : (1 << compId[0]))] = 0;\n\tfor (int mask = 0; mask < (1 << m); mask++) {\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tdist[v] = dp[v][mask];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tused[i] = false;\n\t\tfor (int it = 0; it < n; it++) {\n\t\t\tint v = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (used[i]) continue;\n\t\t\t\tif (v == -1 || dist[v] > dist[i])\n\t\t\t\t\tv = i;\n\t\t\t}\n\t\t\tused[v] = 1;\n\t\t\tif (dist[v] == INF) break;\n\t\t\tfor (pii e : g[v]) {\n\t\t\t\tint u = e.first;\n\t\t\t\tif (used[u]) continue;\n\t\t\t\tif (dist[u] <= dist[v] + e.second) continue;\n\t\t\t\tif (e.second == B && a[v][u] < INF) continue;\n\t\t\t\tif (e.second == B && compId[u] != -1) continue;\n\t\t\t\tdist[u] = dist[v] + e.second;\n\t\t\t}\n\t\t}\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tdp[v][mask] = dist[v];\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tfor (pii e : g[v]) {\n\t\t\t\tif (e.second != B) continue;\n\t\t\t\tint u = e.first;\n\t\t\t\tif (compId[u] == -1) continue;\n\t\t\t\tif ((mask >> compId[u]) & 1) continue;\n\t\t\t\tdp[u][mask | (1 << compId[u])] = min(dp[u][mask | (1 << compId[u])], dp[v][mask] + e.second);\n\t\t\t}\n\t}\n\n\tfor (int v = 0; v < n; v++) {\n\t\tint ans = INF;\n\t\tfor (int mask = 0; mask < (1 << m); mask++)\n\t\t\tans = min(ans, dp[v][mask]);\n\t\tprintf(\"%d \", ans);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "graphs",
        "greedy"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Abandoning Roads.json",
    "editorial_link": "https://codeforces.com/blog/entry/66783",
    "editorial": "Let\u00e2\u0080\u0099s partition the edges of the graph into two classes: (weight ) and\r\n(weight ). Let\u00e2\u0080\u0099s now fix a single settlement as the location of the\r\nparliament house, and consider how the path between settlements and\r\ncould look like. If there is a path between two settlements , consisting\r\nof light edges only, then they will be connected using the light edges\r\nonly in any minimum spanning tree. Consider the Kruskal minimum spanning\r\ntree algorithm (which can produce any minimum spanning tree depending on\r\nthe order we consider the edges with equal weight). After we process all\r\nlight edges, settlements and will be connected. Consider the connected\r\ncomponents in the graph with heavy edges removed. In the original graph,\r\na path can be a part of the minimum spanning tree if and only if there\r\nis we don\u00e2\u0080\u0099t leave and then reenter any of the components. If we leave\r\nand then reenter any connected component, there are two vertices , in a\r\nsingle connected component (that is, connected by a light path in the\r\noriginal graph) that has at least one heavy edge on the path in between.\r\nLemma 1 asserts that it\u00e2\u0080\u0099s impossible. However, if no such situation\r\nhappens, it\u00e2\u0080\u0099s straightforward to extend the selected path to a minimum\r\nspanning tree first add all possible light edges, then all possible\r\nheavy edges so that the graph becomes a spanning tree.This leads us to\r\nan (inefficient) solution: find the connected components in the graph\r\nwith light edges only. We want now to find the shortest path between and\r\nall other vertices that doesn\u00e2\u0080\u0099t revisit any component multiple times. In\r\norder to do so, create a graph where each state is of the following\r\nformat . This information allows us to check if we don\u00e2\u0080\u0099t reenter any\r\npreviously visited component. After we do that, we run Dijkstra\u00e2\u0080\u0099s\r\nshortest path algorithm from vertex . The shortest path between vertices\r\nand can be found in the state first visiting vertex . The beautiful\r\nthing now is that the algorithm can be sped up by the following\r\nobservation: Consider any component of size or less. It\u00e2\u0080\u0099s not optimal to\r\nleave and then reenter this component even if we don\u00e2\u0080\u0099t explicitly forbid\r\nthis. We need to use at least two heavy edges to leave and then reenter\r\nthe component, and this costs us or more. However, as the component has\r\nat most three vertices, the path between any pair of vertices costs at\r\nmost . As , it\u00e2\u0080\u0099s always more optimal to take the path inside the\r\ncomponent.Therefore, we can simply ignore all components of size or\r\nless. As we now need to remember the components having at least\r\nvertices, the number of states drops down to . This immediately allows\r\nus to finish the solution in a number of ways: Implement the vanilla\r\nDijkstra algorithm on the state graph time complexity . Notice that the\r\nedges of the graph have only two weights ( and ) and therefore the\r\npriority queue can be implemented using two queues time complexity drops\r\nto .\r\n"
}