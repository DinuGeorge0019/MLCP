{
    "link": "https://codeforces.com//contest/438/problem/E",
    "problemId": "9967",
    "problem_idx": "E",
    "shortId": "438E",
    "contest_number": "438",
    "problem_submissions": {
        "D": [
            6770791,
            6768533,
            6771704,
            6771558,
            6772564,
            6771497,
            6770667,
            6772913,
            6771311,
            6770765,
            6771398,
            6772501,
            6771788,
            6773163,
            6773332,
            6768886,
            6769122
        ],
        "C": [
            6769384,
            6771772,
            6770600,
            6769986,
            6769707,
            6770322,
            6773155,
            6770624,
            6772819,
            6772764,
            6772925,
            6771300,
            6773617,
            6772385,
            6771439,
            6774162
        ],
        "B": [
            6766623,
            6766692,
            6766851,
            6766923,
            6766505,
            6769047,
            6767842,
            6768520,
            6767461,
            6766938,
            6767311,
            6768462,
            6767303,
            6769160,
            6766952,
            6767030,
            6767555
        ],
        "A": [
            6765683,
            6765687,
            6765701,
            6765754,
            6767149,
            6765703,
            6766656,
            6766754,
            6766105,
            6765753,
            6765896,
            6765923,
            6765796,
            6768072,
            6766138,
            6765696,
            6765784
        ],
        "E": [
            6784450,
            6784415,
            39812196,
            39812172,
            6951957
        ]
    },
    "name": "E. The Child and Binary Tree",
    "statement": "Our child likes computer science very much, especially he likes binary\r\ntrees.Consider the sequence of distinct positive integers: . The child\r\ncalls a vertex-weighted rooted binary tree if and only if for every\r\nvertex , the weight of is in the set . Also our child thinks that the of\r\na vertex-weighted tree is the sum of all vertices’ weights.Given an\r\ninteger , can you for all calculate the number of good vertex-weighted\r\nrooted binary trees with weight ? Please, check the samples for better\r\nunderstanding what trees are considered different.We only want to know\r\nthe answer modulo (, a prime number).\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long LL;\ninline int\tread()\n{\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; ch < '0' || ch > '9'; ch = getchar())\tif (ch == '-')  positive = 0;\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\n#define link Link\n#define next Next\n#define elif else if\n\nconst int MOD = 998244353;\nint N, M;\nLL\tgg;\nLL\tf[400005], g[400005];\nLL\ta[4000006], b[4000006], c[4000006], d[4000006], W[2][4000006];\nint pos[4000006];\n\ninline LL\tpower(LL x, int y)\n{\n\tLL\tans = 1;\n\tfor (; y; y >>= 1)\n\t{\n\t\tif (y & 1)\tans = ans * x % MOD;\n\t\tx = x * x % MOD;\n\t}\n\treturn ans;\n}\n\nLL\te[4000006];\n\ninline void\tDFT(bool t, LL a[], int S)\n{\n\tfor (int i = 0; i < S; ++ i)\n\t\tif (i < pos[i])\n\t\t\tswap(a[i], a[pos[i]]);\n\tfor (int i = 1; i < S; i <<= 1)\n\t\tfor (int j = 0; j < S; j += 2 * i)\n\t\t\tfor (int k = 0; k < i; ++ k)\n\t\t\t{\n\t\t\t\tLL u = a[j + k], v = a[i + j + k] * W[t][k * (S / i) / 2] % MOD;\n\t\t\t\ta[j + k] = u + v;\n\t\t\t\tif (a[j + k] >= MOD)\ta[j + k] -= MOD;\n\t\t\t\ta[i + j + k] = u - v;\n\t\t\t\tif (a[i + j + k] < 0)\ta[i + j + k] += MOD;\n\t\t\t}\n}\n\ninline void Mult(LL a[], LL b[], LL c[], int N)\n{\n\tint S = 1;\n\tint K = 0;\n\twhile (S < N)\tS *= 2, K ++;\n\tS *= 2, K ++;\n\tfor (int i = 0; i < S; ++ i)\n\t{\n\t\tint j = 0;\n\t\tfor (int k = 0; k < K; ++ k)\tif (i & (1 << k))\tj |= (1 << K - k - 1);\n\t\tpos[i] = j;\n\t}\n\tLL\tg = power(gg, (1 << 23) / S), reg = power(g, MOD - 2);\n\tW[0][0] = W[1][0] = 1;\n\tfor (int i = 1; i < S; ++ i)\n\t{\n\t\tW[0][i] = W[0][i - 1] * g % MOD;\n\t\tW[1][i] = W[1][i - 1] * reg % MOD;\n\t}\n\tfor (int i = N; i <= S; ++ i)\ta[i] = b[i] = 0;\n\tDFT(0, a, S);\n\tDFT(0, b, S);\n\tfor (int i = 0; i < S; ++ i)\tc[i] = a[i] * b[i] % MOD;\n\tDFT(1, c, S);\n\tLL\trvs = power(S, MOD - 2);\n\tfor (int i = 0; i < S; ++ i)\tc[i] = c[i] * rvs % MOD;\n\t/*for (int i = 0; i < 2 * N; ++ i)\tc[i] = 0;\n\tfor (int i = 0; i < N; ++ i)\n\tfor (int j = 0; j < N; ++ j)\n\t\tc[i + j] = (c[i + j] + a[i] * b[j]) % MOD;*/\n}\n\ninline bool\tisroot(int g, int P)\n{\n\tP --;\n\tif (power(g, P / 7) == 1)\treturn 0;\n\tif (power(g, P / 17) == 1)\treturn 0;\n\tif (power(g, P / 2) == 1)\treturn 0;\n\treturn 1;\n}\n\nvoid\twork(int l, int r)\n{\n\tif (l == r)\n\t{\n\t\tif (l)\tg[l] = (g[l] + f[0] * f[l] * 2) % MOD;\n\t\telse\tf[l] = g[l] = 1;\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\twork(l, m);\n\t\n\tfor (int i = 0; i <= r - l; ++ i)\ta[i] = b[i] = 0;\n\tfor (int i = l; i <= m; ++ i)\ta[i - l] = g[i];\n\tfor (int i = 0; i <= r - l; ++ i)\tb[i] = c[i];\n\tMult(a, b, d, r - l + 1);\n\tfor (int i = m + 1; i <= r; ++ i)\tf[i] = (f[i] + d[i - l]) % MOD;\n\t//if (m + 1 <= 24 && r <= 24)\tprintf(\"%d %d\\n\", m, f[24]);\n\t\n\tfor (int i = 0; i <= r - l; ++ i)\ta[i] = b[i] = 0;\n\tfor (int i = l; i <= m; ++ i)\ta[i - l] = f[i];\n\tfor (int i = 0; i <= r - l && i <= m; ++ i)\tb[i] = f[i];\n\tMult(a, b, d, r - l + 1);\n\tfor (int i = m + 1; i <= r; ++ i)\tg[i] = (g[i] + 2 * d[i - l]) % MOD;\n\t\n\tfor (int i = 0; i <= r - l; ++ i)\ta[i] = b[i] = 0;\n\tfor (int i = l; i <= m; ++ i)\ta[i - l] = f[i];\n\tfor (int i = l; i <= r - l && i <= m; ++ i)\tb[i] = f[i];\n\tMult(a, b, d, r - l + 1);\n\tfor (int i = m + 1; i <= r; ++ i)\tg[i] = (g[i] - d[i - l] + MOD) % MOD;\n\t\n\twork(m + 1, r);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\", \"r\", stdin);\n\tfreopen(\"a.out\", \"w\", stdout);\n#endif\n\n\tfor (int i = 2; ; ++ i)\n\t\tif (isroot(i, MOD))\n\t\t{\n\t\t\tgg = i;\n\t\t\tbreak;\n\t\t}\n\tgg = power(gg, 7 * 17);\n\tN = read(), M = read();\n\tfor (int i = 1; i <= N; ++ i)\tc[read()] = 1;\n\twork(0, M);\n\t/*f[0] = g[0] = 1;\n\tfor (int i = 1; i <= M; ++ i)\n\t{\n\t\tf[i] = 0;\n\t\tfor (int j = 1; j <= i; ++ j)\tif (c[j])\n\t\t\tf[i] = (f[i] + g[i - j]) % MOD;\n\t\tg[i] = 0;\n\t\tfor (int j = 0; j <= i; ++ j)\n\t\t\tg[i] = (g[i] + f[j] * f[i - j]) % MOD;\n\t}*/\n\tfor (int i = 1; i <= M; ++ i)\tprintf(\"%d\\n\", int(f[i]));\n\t//for (int i = 1; i <= M; ++ i)\tprintf(\"%d\\n\", int(g[i]));\n\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "fft",
        "number theory"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. The Child and Binary Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/12513",
    "editorial": "Let be the number of good vertex-weighted rooted binary trees whose\r\nweight exactly equal to , then we have: Let F(z) be the generating\r\nfunction of f. That is, And then let So we have: ââ is for . Solve this\r\nequation we have: So the remaining question is: how to calculate the\r\nmultiplication inverse of a power series and the square root of a power\r\nseries? There is an interesting algorithm which calculate the inverse of\r\na power series : We use to denote that the first terms of and are the\r\nsame. We can simply calculate a formal power series which satisfies\r\nNext, if we have which satisfies , we will get: We can simplely use Fast\r\nFourier Transform to deal with multiplication. Note the unusual mod (,\r\nthus we can use Number Theoretic Transform. By doubling repeatedly, we\r\ncan get the first terms of the inverse of in time. Itâs because that We\r\ncan just use the idea of this algorithm to calculate the square root of\r\na power series : We can simply calculate a power series which satisfies\r\nNext, if we have which satisfies , we will get: So, By doubling\r\nrepeatedly, we can get the first terms of the square root of in time.\r\nThatâs all. What I want to share with others is this beautiful doubling\r\nalgorithm. So the total time complexity of the solution to the original\r\nproblem is . My code There is an algorithm solving this problem using\r\ndivide and conquer and Fast Fourier Transform, which runs in . See the\r\nC++ code and the Java code for details.\r\n",
    "hint": []
}