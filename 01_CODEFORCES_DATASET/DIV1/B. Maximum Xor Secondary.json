{"link": "https://codeforces.com//contest/280/problem/B", "problemId": "2726", "problem_idx": "B", "shortId": "280B", "contest_number": "280", "problem_submissions": {"A": [3287460, 3287361, 3276397, 3278813, 3276368, 3275958, 3278969, 3275819, 3275811, 3278894, 3281142, 3276025, 3282276, 3280827, 3278671, 3278926], "D": [3281691, 3283266, 3283731, 3285347, 3322215], "C": [3279306, 3279945, 3277746, 3276734, 3279642, 3277787, 3276636, 3278485, 3278848, 3279470, 3277629, 3279115, 3276052, 3276649, 3279355, 3279152], "B": [3276405, 3279061, 3277000, 3276260, 3284541, 3277306, 3275980, 3276370, 3276567, 3276408, 3276287, 3277081, 3278515, 3277959, 3275542, 3276177], "E": [3351075]}, "name": "B. Maximum Xor Secondary", "statement": "Bike loves looking for the second maximum element in the sequence. The\r\nsecond maximum element in the sequence of distinct numbers is such\r\nmaximum element , that the following inequality holds: .The lucky number\r\nof the sequence of distinct positive integers is the number that is\r\nequal to the bitwise excluding OR of the maximum element of the sequence\r\nand the second maximum element of the sequence.You\u2019ve got a sequence of\r\ndistinct positive integers . Let\u2019s denote sequence as . Your task is to\r\nfind the maximum number among all lucky numbers of sequences .Note that\r\nas all numbers in sequence are distinct, all the given definitions make\r\nsence.\r\n", "solutions": ["/*\nAuthor: elfness@UESTC\n*/\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long LL;\nconst int V=100100;\nint l[V],r[V],a[V],ret,n;\nint main()\n{\n    while(~scanf(\"%d\",&n))\n    {\n        ret=0;\n        for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n        for(int i=1;i<=n;i++)l[i]=r[i]=i;\n        for(int i=1;i<=n;i++)\n        {\n            while(l[i]!=1&&a[l[i]-1]<a[i])l[i]=l[l[i]-1];\n            if(l[i]!=1)ret=max(ret,a[i]^a[l[i]-1]);\n        }\n        for(int i=n;i>=1;i--)\n        {\n            while(r[i]!=n&&a[r[i]+1]<a[i])r[i]=r[r[i]+1];\n            if(r[i]!=n)ret=max(ret,a[i]^a[r[i]+1]);\n        }\n        printf(\"%d\\n\",ret);\n    }\n}\n"], "input": "", "output": "", "tags": ["data structures", "implementation", "two pointers"], "dificulty": "1800", "interactive": false}