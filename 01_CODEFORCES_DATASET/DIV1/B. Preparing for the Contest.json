{
    "link": "https://codeforces.com//contest/377/problem/B",
    "problemId": "4962",
    "problem_idx": "B",
    "shortId": "377B",
    "contest_number": "377",
    "problem_submissions": {
        "E": [
            5565104,
            5561250,
            5564607,
            5609766,
            5609753,
            16200081
        ],
        "C": [
            5557198,
            5559102,
            5556756,
            5557878,
            5557073,
            5556778,
            5561172,
            5559969,
            5556623,
            5561484,
            5557118,
            5556739,
            5555480,
            5555881,
            5556358,
            5558864,
            5562930,
            5557451
        ],
        "B": [
            5555860,
            5557367,
            5555019,
            5553998,
            5554910,
            5555169,
            5554737,
            5555727,
            5555389,
            5556153,
            5555427,
            5554761,
            5558108,
            5554728,
            5554498,
            5556897,
            5555212,
            5555735
        ],
        "D": [
            5554743,
            5555639,
            5559458,
            5563602,
            5559736,
            5559573,
            5557812,
            5558888,
            5560657,
            5558023,
            5561888,
            5561586,
            5561721,
            5561010,
            5567302,
            5562027,
            5561348,
            5557665,
            5560854
        ],
        "A": [
            5552294,
            5552852,
            5553023,
            5554895,
            5553159,
            5553613,
            5552588,
            5552740,
            5553136,
            5552790,
            5552857,
            5552997,
            5553105,
            5552479,
            5552633,
            5554023,
            5552441
        ]
    },
    "name": "B. Preparing for the Contest",
    "statement": "Soon there will be held the world’s largest programming contest, but the\r\ntesting system still has bugs. The contest organizer, a well-known\r\nuniversity, has no choice but to attract university students to fix all\r\nthe bugs. The university has students able to perform such work. The\r\nstudents realize that they are the only hope of the organizers, so they\r\ndon’t want to work for free: the -th student wants to get ’passes’ in\r\nhis subjects (regardless of the volume of his work).Bugs, like students,\r\nare not the same: every bug is characterized by complexity , and every\r\nstudent has the level of his abilities . Student can fix a bug only if\r\nthe level of his abilities is not less than the complexity of the bug: ,\r\nand he does it in one day. Otherwise, the bug will have to be fixed by\r\nanother student. Of course, no student can work on a few bugs in one\r\nday. All bugs are not dependent on each other, so they can be corrected\r\nin any order, and different students can work simultaneously.The\r\nuniversity wants to fix all the bugs as quickly as possible, but giving\r\nthe students the total of not more than passes. Determine which students\r\nto use for that and come up with the schedule of work saying which\r\nstudent should fix which bug.\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int N = 200010;\n\nint bugs, studs, exams;\n\npair <int, int> bug[N];\npair < int, pair <int, int> > stud[N];\n\nset < pair <int, int> > smart;\nint ans[N];\n\nlong long solve(int days) {\n  long long sum = 0;\n  smart.clear();\n  int last = 0;\n  for (int i = 0; i < bugs; i += days) {\n    while (last < studs && stud[last].first >= bug[i].first) {\n      smart.insert(stud[last].second);\n      last++;\n    }\n    if (smart.empty()) {\n      return (long long)1e18;\n    }\n    pair <int, int> t = *(smart.begin());\n    smart.erase(smart.begin());\n    sum += t.first;\n    for (int j = i; j < bugs && j < i + days; j++) {\n      ans[bug[j].second] = t.second;\n    }\n  }\n  return sum;\n}\n\nint main() {\n  scanf(\"%d %d %d\", &studs, &bugs, &exams);\n  for (int i = 0; i < bugs; i++) {\n    scanf(\"%d\", &(bug[i].first));\n    bug[i].second = i;\n  }\n  for (int i = 0; i < studs; i++) {\n    scanf(\"%d\", &(stud[i].first));\n  }\n  for (int i = 0; i < studs; i++) {\n    scanf(\"%d\", &(stud[i].second.first));\n    stud[i].second.second = i;\n  }\n  sort(bug, bug + bugs);\n  reverse(bug, bug + bugs);\n  sort(stud, stud + studs);\n  reverse(stud, stud + studs);\n  int ll = 1, rr = bugs + 1;\n  while (ll < rr) {\n    int mid = (ll + rr) >> 1;\n    if (solve(mid) <= exams) rr = mid;\n    else ll = mid + 1;\n  }\n  if (ll > bugs) {\n    printf(\"NO\\n\");\n    return 0;\n  }\n  solve(ll);\n  printf(\"YES\\n\");\n  for (int i = 0; i < bugs - 1; i++) printf(\"%d \", ans[i] + 1);\n  printf(\"%d\\n\", ans[bugs - 1] + 1);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Preparing for the Contest.json",
    "editorial_link": "https://codeforces.com//blog/entry/10157",
    "editorial": "Itâs obvious that the time needed to fix all bugs is the monotonic\r\nfunction: if we can do it for some time, we can do it for greater time.\r\nSo we can use binary search in these problem. We should learn how to\r\ncheck if some time is enough. At first sort all bugs by their complexity\r\nand all students by their skills. Letâs consider the hardest bug. Who\r\ncan fix it? It can be fixed by student whose skills is not less that\r\nthis bugâs complexity. Push all such students into the priority queue\r\n(sorted by studentsâ price) and pop the cheapest student. As we check\r\ntime , this student must fix hardest bugs (he definitely can do it).\r\nSave that information and go to the next bug which has not been fixed\r\nyet. Again push all students which can fix it to the priority queue and\r\npop the cheapest one. And so on. If at some moment priority queue is\r\nempty, time is not enough. If we spent too much âmoneyâ itâs not enough\r\nas well. Otherwise we get the correct schedule.\r\n",
    "hint": []
}