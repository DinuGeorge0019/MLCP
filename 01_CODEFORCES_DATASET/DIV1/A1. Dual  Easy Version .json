{"link": "https://codeforces.com//contest/1854/problem/A1", "problemId": "2119346", "problem_idx": "A1", "shortId": "1854A1", "contest_number": "1854", "problem_submissions": {"F": [216373971, 217354172, 217397292], "D": [216310150, 216289199, 216321960, 216339370, 216308614, 216330486, 216327260, 216330943, 216339614, 216349670, 216345647, 216345106, 224815766, 216547574, 216366587], "E": [216288237, 216300028, 216302036, 216268441, 216334493, 216313354, 216348664, 216267007, 216336955, 216296297, 216300153, 216312130, 216307051, 216317337, 216275749, 216320776, 216324267, 216319909, 216313856], "C": [216273942, 216261365, 216266654, 216275371, 216264423, 216276518, 216281959, 216283401, 216256269, 216270575, 216274010, 216274561, 216269163, 216301579, 216282188, 216295268, 216271804, 216301995], "A2": [216264333, 216379126, 216379111, 216318393, 216275667, 216295850, 216251357, 216257398, 216276514, 216268588, 216307226, 216280080, 216286828, 216278270, 216337810, 216308708, 216280874, 216295056, 216275828], "A1": [216258579, 216252405, 216255683, 216241030, 216251535, 216248642, 216276758, 216268768, 216282006, 216259868, 216249337, 216287041, 216244661, 216249684, 216243548, 216258618, 216238489, 216275974], "B": [216248516, 216256912, 216241500, 216256089, 216258617, 216267337, 216293058, 216272552, 216268356, 216253180, 216258044, 216262545, 216263544, 216287092, 216255748, 216251265, 216280599, 216287965]}, "name": "A1. Dual  Easy Version ", "statement": "You are given an array a_1, a_2,\r\ndots, a_n of integers (positive, negative or 0). You can perform\r\nmultiple operations on the array (possibly 0 operations).In one\r\noperation, you choose i, j (1\r\nleq i, j\r\nleq n, they can be equal) and set a_i := a_i + a_j (i.e., add a_j to\r\na_i).Make the array non-decreasing (i.e., a_i\r\nleq a_{i+1} for 1\r\nleq i\r\nleq n-1) in at most 50 operations. You do not need to minimize the\r\nnumber of operations.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nvector<pii> wyn;\n\nvoid zrob(int a, int b)\n{\n\ttab[a]+=tab[b];\n\twyn.push_back({a, b});\n}\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &tab[i]);\n\t}\n\twyn.clear();\n\tint a=1;\n\tint b=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (tab[i]>tab[a])\n\t\t\ta=i;\n\t\tif (tab[i]<tab[b])\n\t\t\tb=i;\n\t}\n\tif (tab[a]+tab[b]>0)\n\t{\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tzrob(i, a);\n\t\tfor (int i=2; i<=n; i++)\n\t\t\tzrob(i, i-1);\n\t}\n\telse\n\t{\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tzrob(i, b);\n\t\tfor (int i=n-1; i; i--)\n\t\t\tzrob(i, i+1);\n\t}\n\t\n\t\n\tprintf(\"%d\\n\", (int)wyn.size());\n\tfor (pii i : wyn)\n\t\tprintf(\"%d %d\\n\", i.first, i.second);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "1400", "interactive": false}