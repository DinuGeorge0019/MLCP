{
    "link": "https://codeforces.com//contest/1967/problem/A",
    "problemId": "2620278",
    "problem_idx": "A",
    "shortId": "1967A",
    "contest_number": "1967",
    "problem_submissions": {
        "E2": [
            258916135,
            258921598,
            280919018,
            283055351,
            258925888,
            258925224,
            258926598,
            259116859,
            258926070,
            258925546,
            259722295,
            258957419
        ],
        "E1": [
            258904834,
            258921659,
            258894575,
            258912226,
            258903044,
            258906344,
            258912831,
            258915891,
            258918877,
            258922310,
            259006535,
            258965622,
            258951459,
            258945783,
            258913874,
            258917530,
            258919711,
            258921338,
            258917617,
            258919765,
            259722116,
            258915462,
            258933640,
            258908305,
            258913393,
            258909598
        ],
        "D": [
            258893511,
            258891796,
            258909116,
            258896081,
            258913757,
            258931804,
            258897887,
            258899842,
            258900877,
            258900605,
            258900883,
            258903500,
            258906692,
            258903262,
            258903546,
            258905322,
            258906645,
            259721880,
            258919184,
            258918997,
            258920966,
            258894127
        ],
        "C": [
            258884312,
            258885547,
            258878790,
            258885577,
            258886778,
            258891500,
            258888513,
            258894435,
            258891427,
            258888089,
            258895759,
            258890296,
            258893524,
            258896216,
            258896443,
            258888021,
            258883737,
            258891226,
            258889628,
            258879732
        ],
        "B2": [
            258880311,
            258879319,
            258874379,
            258880426,
            258874860,
            258887764,
            258882431,
            258886567,
            258994245,
            258885903,
            258878827,
            258889665,
            258882193,
            258884237,
            258880372,
            258891352,
            258877071,
            258876977,
            258886917,
            258884212
        ],
        "B1": [
            258869431,
            258871590,
            258870854,
            258865105,
            258869777,
            258876404,
            258873073,
            258874727,
            258869407,
            258874121,
            258875290,
            258873932,
            258869896,
            258873122,
            258871143,
            258871635,
            258872574,
            258874952,
            258869924,
            258867671
        ],
        "A": [
            258865187,
            258866636,
            258865467,
            258874287,
            258866222,
            258865534,
            258866742,
            258868436,
            258867130,
            258868014,
            258872371,
            258870129,
            258865415,
            258868641,
            258868839,
            258866810,
            258868141,
            258871863,
            258867322,
            258865436
        ],
        "F": [
            283293514,
            273029197
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129027",
    "editorial": "If and , it\u00e2\u0080\u0099s obvious that the optimal rearrangement is , because every\r\nsubarray of length is a permutation of .WLOG, assume that . If , we can\r\ninsert more numbers at the back and form more permutations. But because\r\nis the minimum number, we can only make these subarrays become\r\npermutations:The remaining cards can be placed arbitrarily. This won\u00e2\u0080\u0099t\r\nalways be satisfied (if , the green subarray won\u00e2\u0080\u0099t exist). But this will\r\nonly happen if is also minimum. It\u00e2\u0080\u0099s the same for etc. So we can\r\ncalculate the answer:Considering cases, we find that every time we\r\nchoose a minimum and increase it by , the answer will be increased. And\r\nthe answer won\u00e2\u0080\u0099t change if we increase some other . So we have two\r\ndifferent approaches: Sort the array , enumerate the range where the\r\nminimum number will be, and check if it\u00e2\u0080\u0099s possible. If so, we can just\r\ncalculate by using the above equation. Binary search the after buying\r\ncards. After calculating the array after buying cards, we will be able\r\nto calculate the answer. Time complexity: or .\r\n",
    "name": "A. Permutation Counting",
    "statement": "You have some cards. An integer between 1 and n is written on each card:\r\nspecifically, for each i from 1 to n, you have a_i cards which have the\r\nnumber i written on them.There is also a shop which contains unlimited\r\ncards of each type. You have k coins, so you can buy k new cards in\r\ntotal, and the cards you buy can contain any integer between 1 and\r\nn.After buying the new cards, you rearrange all your cards in a line.\r\nThe score of a rearrangement is the number of (contiguous) subarrays of\r\nlength n which are a permutation of [1, 2,\r\nldots, n]. What\u2019s the maximum score you can get?\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 30.04.2024 10:26:15**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n;    int64_t k;    cin >> n >> k;    vector<int64_t> a(n);    for (int i = 0; i < n; i++) {      cin >> a[i];    }    sort(a.begin(), a.end());    for (int i = 0; i < n - 1; i++) {      int64_t steps = (a[i + 1] - a[i]) * (i + 1);      if (k > steps) {        k -= steps;      } else {        int64_t val = a[i] + k / (i + 1);        for (int j = 0; j <= i; j++) {          a[j] = val;        }        k %= (i + 1);        for (int j = 0; j < k; j++) {          a[j] += 1;        }        k = 0;        break;      }    }    int64_t ans = 0;    if (k > 0) {      ans = a.back() * n + k;    } else {      sort(a.begin(), a.end());      for (int i = 0; i < n; i++) {        ans += min(a[0] + 1, a[i]);      }    }    cout << max(int64_t(0), ans - (n - 1)) << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "implementation",
        "math",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Permutation Counting.json"
}