{
    "link": "https://codeforces.com//contest/1188/problem/C",
    "problemId": "366822",
    "problem_idx": "C",
    "shortId": "1188C",
    "contest_number": "1188",
    "problem_submissions": {
        "A2": [
            56584964,
            56567602,
            56566524,
            56572382,
            56589644,
            56583972,
            56579938,
            56582233,
            56570590,
            56576661,
            56589231,
            56587448,
            56570901,
            56587024,
            56574198,
            56581669,
            56571222
        ],
        "E": [
            56582671,
            56589474,
            56589239,
            141774833,
            57345099,
            56596996,
            56642394
        ],
        "D": [
            56576903,
            56585842,
            56583846,
            56589764,
            56584452,
            56586331,
            56584084,
            56596587,
            56577947,
            56602284
        ],
        "C": [
            56571735,
            56576008,
            56572799,
            56580329,
            56577305,
            56572037,
            56574271,
            56570306,
            56577496,
            56576142,
            56583479,
            56585009,
            56584467,
            56575353,
            56583067,
            56585221,
            56572902,
            56587295,
            56575946,
            56586708
        ],
        "B": [
            56568214,
            56570555,
            56562488,
            56571471,
            56575984,
            56607436,
            56565158,
            56574148,
            56570733,
            56572983,
            56567704,
            56568743,
            56568263,
            56575440,
            56583939,
            56576017,
            56588907,
            56575865
        ],
        "A1": [
            56561659,
            56562944,
            56561298,
            56564728,
            56563727,
            56577205,
            56564216,
            56561247,
            56563294,
            56561568,
            56563293,
            56566261,
            56569194,
            56564914,
            56561283,
            56572778,
            56565086,
            56564073,
            56561536,
            56563748
        ]
    },
    "name": "C. Array Beauty",
    "statement": "Let’s call beauty of an array b_1, b_2,\r\nldots, b_n (n > 1)\r\nmin\r\nlimits_{1\r\nleq i < j\r\nleq n} |b_i - b_j|.You’re given an array a_1, a_2,\r\nldots a_n and a number k. Calculate the sum of beauty over all\r\nsubsequences of the array of length exactly k. As this number can be\r\nvery large, output it modulo 998244353.A sequence a is a subsequence of\r\nan array b if a can be obtained from b by deletion of several (possibly,\r\nzero or all) elements.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\n\nconst int N = 1010;\nint n, k, m;\nint a[N];\nint dp[N][N];\nint ANS;\n\nint solve(int d) {\n\tfor (int i = 0; i <= k; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tdp[i][j] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tdp[1][i] = i;\n\tfor (int t = 1; t < k; t++) {\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile(a[i] - a[p] >= d) p++;\n\t\t\tdp[t + 1][i + 1] = add(dp[t + 1][i], dp[t][p]);\n\t\t}\n\t}\n\treturn dp[k][n];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tm = a[n - 1] - a[0];\n\tfor (int d = 1; d * (k - 1) <= m; d++)\n\t\tANS = add(ANS, solve(d));\n\tprintf(\"%d\\n\", ANS);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Array Beauty.json",
    "editorial_link": "https://codeforces.com//blog/entry/68079",
    "editorial": "First of all, let's learn how to solve the following subtask:\n\nFor given x\n how many subsequences of length k\n have beauty at least x\n? If we know that the answer for x\n is px\n, than the answer for original task is p1+p2++pmax(a)\n, where max(a)\n is maximum in array a\n. Let's solve subtask.\n\nSuppose, that array is sorted. We should count subsequence p1<p2,<pk\n, iff:\n\nap2?ap1+x,,apk?apk?1+x\n.\n\nWe will solve this task using dp. The slow solution is:\n\ndp[last][cnt]\n  number of subsequences of length cnt\n, which end in alast\n. There are transitions from state with last?<last,cnt?=cnt?1\n, such that alast?alast?+x\n. To optimize it we need to note, that suitable last?\n form some prefix of the array. If we know needed prefixes and prefix sums from the previous layer of dp, then we can make transitions in constant time. We can find needed prefixes using two pointers(because it's obvious, that length of prefixes doesn't decrease). So, we can solve subtask in O(nk)\n time.\n\nAnd, using solution to subtask, we can solve inital task in O(max(a)nk)\n. And here comes magic:\n\nIf x>max(a)k?1\n, than px=0\n. Indeed, ???? ap2?ap1+x,,apk?apk?1+x\n, than:\n\nan?apk?apk?1+x?apk?2+2x?ap1+(k?1)x?(k?1)x\n. It follows: (k?1)x?an?x?ank?1\n.\n\nSo we can run our dp only for x?max(a)k?1\n. In total our solution works in O(max(a)k?1nk)=O(max(a)n)\n time, because kk?1?2\n.",
    "hint": []
}