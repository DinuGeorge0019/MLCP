{"link": "https://codeforces.com//contest/704/problem/B", "problemId": "67578", "problem_idx": "B", "shortId": "704B", "contest_number": "704", "problem_submissions": {"D": [40927696, 40927622, 40927587, 40927467, 40927396, 19704142, 19710237, 19708323, 19774513, 19774457, 19774399, 19764110, 19708427, 19756062, 26821434, 22052930], "C": [19708702, 23913352, 19710963, 19714551, 19717256, 19728619, 19710982, 19720592, 22049772, 19704534], "B": [19698622, 19822826, 19698078, 19696251, 19698272, 19697250, 19698738, 19697542, 19699793, 19700128, 19700526, 19700174, 19702386, 19697314, 19708684, 19700116], "A": [19690324, 19692784, 19688619, 19690302, 19690344, 19691492, 19691120, 19689897, 19691217, 19692269, 19690729, 19691407, 19691187, 19689858, 19690147, 19691829, 19694517, 19693111, 19701512, 19690489], "E": [27277354, 20669015, 22073776, 22073733]}, "name": "B. Ant Man", "statement": "Scott Lang is at war with Darren Cross. There are chairs in a hall where\r\nthey are, numbered with from left to right. The -th chair is located at\r\ncoordinate . Scott is on chair number and Cross is on chair number .\r\nScott can jump to all other chairs (not only neighboring chairs). He\r\nwants to start at his position (chair number ), visit each chair and end\r\nup on chair number with Cross. As we all know, Scott can shrink or grow\r\nbig (grow big only to his normal size), so at any moment of time he can\r\nbe either small or large (normal). The thing is, he can only shrink or\r\ngrow big while being on a chair (not in the air while jumping to another\r\nchair). Jumping takes time, but shrinking and growing big takes no time.\r\nJumping from chair number to chair number takes seconds. Also, jumping\r\noff a chair and landing on a chair takes extra amount of time. If Scott\r\nwants to jump to a chair on his left, he can only be small, and if he\r\nwants to jump to a chair on his right he should be large.Jumping off the\r\n-th chair takes: extra seconds if he\u2019s small. extra seconds otherwise\r\n(he\u2019s large). Also, landing on -th chair takes: extra seconds if he\u2019s\r\nsmall. extra seconds otherwise (he\u2019s large). In simpler words, jumping\r\nfrom -th chair to -th chair takes exactly: seconds if . seconds\r\notherwise (). Given values of , , , , find the minimum time Scott can\r\nget to Cross, assuming he wants to visit each chair exactly once.\r\n", "solutions": ["#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdint>\n#include <climits>\n#include <numeric>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nlong long dp[2][5002][3];\n// i: seen i elts\n// j: number of pendings\n// k: +1 for more ->, 0, -1 for more <-\n\nint a[5002], b[5002], c[5002], d[5002], x[5002];\nvoid update(long long &dest, long long val) {\n  if (dest == 0 || dest > val)\n    dest = val;\n}\nint main() {\n  int n, s, e;\n  scanf(\"%d%d%d\", &n, &s, &e);\n  s--, e--;\n  for (int i = 0; i < n; i++) scanf(\"%d\", &x[i]);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &c[i]);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &d[i]);\n  if (s == 0) {\n    dp[0][0][2] = d[0];\n  }\n  else if (e == 0) {\n    dp[0][0][0] = b[0];\n  }\n  else {\n    dp[0][1][1] = b[0] + d[0];\n  }\n  for (int i = 1; i < n; i++) {\n    int ci = i % 2;\n    int li = 1 - ci;\n    memset(dp[ci], 0, sizeof(dp[ci]));\n    long long dx = x[i] - x[i - 1];\n    if (s == i) {\n      for (int j = 0; j <= i; j++) {\n        for (int k = 0; k < 2; k++) {\n          if (dp[li][j][k] == 0)\n            continue;\n          int out = j + (k == 2);\n          int in = j + (k == 0);\n          if (in + out == 0)\n            continue;\n          long long newcost = dp[li][j][k] + (out + in) * dx;\n          update(dp[ci][min(in, out + 1)][k + 1], newcost + d[i]);\n          if (in) {\n            update(dp[ci][min(in - 1, out)][k + 1], newcost + c[i]);\n          }\n        }\n      }\n    }\n    else if (e == i) {\n      for (int j = 0; j <= i; j++) {\n        for (int k = 1; k < 3; k++) {\n          if (dp[li][j][k] == 0)\n            continue;\n          int out = j + (k == 2);\n          int in = j + (k == 0);\n          if (in + out == 0)\n            continue;\n          long long newcost = dp[li][j][k] + (out + in) * dx;\n          if (out) {\n            update(dp[ci][min(in, out - 1)][k - 1], newcost + a[i]);\n          }\n          update(dp[ci][min(in + 1, out)][k - 1], newcost + b[i]);\n        }\n      }\n    }\n    else {\n      for (int j = 0; j <= i; j++) {\n        for (int k = 0; k < 3; k++) {\n          if (dp[li][j][k] == 0)\n            continue;\n          int out = j + (k == 2);\n          int in = j + (k == 0);\n          if (in + out == 0)\n            continue;\n          long long newcost = dp[li][j][k] + (out + in) * dx;\n          if (in) {\n            update(dp[ci][j][k], newcost + c[i] + b[i]);\n          }\n          update(dp[ci][j + 1][k], newcost + b[i] + d[i]);\n          if (out) {\n            update(dp[ci][j][k], newcost + a[i] + d[i]);\n          }\n          if (in && out) {\n            update(dp[ci][j - 1][k], newcost + a[i] + c[i]);\n          }\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[(n-1)%2][0][1]);\n  return 0;\n}"], "input": "", "output": "", "tags": ["dp", "graphs", "greedy"], "dificulty": "2500", "interactive": false}