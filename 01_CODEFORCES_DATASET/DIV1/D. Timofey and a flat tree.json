{
    "link": "https://codeforces.com//contest/763/problem/D",
    "problemId": "91412",
    "problem_idx": "D",
    "shortId": "763D",
    "contest_number": "763",
    "problem_submissions": {
        "D": [
            24392378,
            24392196,
            24381252,
            24386512,
            24392124,
            24394387,
            24386765,
            24382498,
            24486986,
            24394269,
            24386191,
            24424544,
            24380258,
            24380559
        ],
        "E": [
            24383804,
            24379798,
            24382054,
            24377568,
            24385205,
            24385996,
            24385356,
            24380328,
            24382103,
            24378328,
            24383177,
            24384291,
            24383316,
            24383261,
            26602690,
            26602470
        ],
        "A": [
            24374208,
            24365694,
            24369536,
            24379218,
            24368162,
            24370205,
            24368697,
            24367762,
            24372789,
            24371841,
            24370735,
            24374219,
            24381920,
            24369005,
            24365735,
            24371025,
            24372089,
            24366605,
            24368551
        ],
        "C": [
            24373544,
            24379290,
            24384264,
            24378866,
            24379343,
            24379755,
            24376326,
            24393137,
            24387552,
            24485763,
            24485746,
            24392939,
            24381638,
            24411493,
            36653644
        ],
        "B": [
            24368982,
            24386986,
            24385221,
            24380830,
            24369478,
            24372225,
            24370708,
            24368820,
            24374499,
            24373776,
            24373025,
            24382359,
            24374187,
            24370609,
            24367209,
            24373968,
            24375645,
            24368619,
            24371120
        ]
    },
    "name": "D. Timofey and a flat tree",
    "statement": "Little Timofey has a big tree an undirected connected graph with\r\nvertices and no simple cycles. He likes to walk along it. His tree is\r\nflat so when he walks along it he sees it entirely. Quite naturally,\r\nwhen he stands on a vertex, he sees the tree as a rooted tree with the\r\nroot in this vertex.Timofey assumes that the non-isomorphic subtrees are\r\nthere in the tree, the more beautiful the tree is. A subtree of a vertex\r\nis a subgraph containing this vertex and all its descendants. You should\r\ntell Timofey the vertex in which he should stand to see the most\r\nbeautiful rooted tree.Subtrees of vertices and are isomorphic if the\r\nnumber of children of equals the number of children of , and their\r\nchildren can be arranged in such a way that the subtree of the first son\r\nof is isomorphic to the subtree of the first son of , the subtree of the\r\nsecond son of is isomorphic to the subtree of the second son of , and so\r\non. In particular, subtrees consisting of single vertex are isomorphic\r\nto each other.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\ntypedef vector<int> VI;\n// head\ntypedef unsigned long long ull;\n\nconst int N=101000;\null seed[2*N],hv[N],hv2[N];\nmap<ull,int> hp;\nint ansv,ansp,n,u,v,tot,hd[N],hd2[N],hs[N*2],cnt;\nVI e[N];\nvoid dfs(int u,int f) {\n\thv[u]=seed[0];\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tdfs(v,u);\n\t\thv[u]+=seed[hd[v]];\n\t}\n\tif (!hp.count(hv[u])) hp[hv[u]]=++tot;\n\thd[u]=hp[hv[u]];\n}\nvoid dfs2(int u,int f) {\n\tull h0=hv[u];\n\tif (f!=0) h0+=seed[hd2[u]];\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\thv2[v]=h0-seed[hd[v]];\n\t\tif (!hp.count(hv2[v])) hp[hv2[v]]=++tot;\n\t\thd2[v]=hp[hv2[v]];\n\t}\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tdfs2(v,u);\n\t}\n}\n\nvoid dfs3(int u,int f) {\n\tif (cnt>ansv) {\n\t\tansv=cnt; ansp=u;\n\t}\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tcnt-=!(--hs[hd[v]]);\n\t\tcnt+=!(hs[hd2[v]]++);\n\t\tdfs3(v,u);\n\t\tcnt-=!(--hs[hd2[v]]);\n\t\tcnt+=!(hs[hd[v]]++);\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,0,2*n+2) seed[i]=((ull)rand()<<40)+((ull)rand()<<20)+(ull)rand();\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tdfs(1,0);\n\tdfs2(1,0);\n\trep(i,2,n+1) cnt+=!(hs[hd[i]]++);\n\tansp=1; ansv=cnt;\n\tdfs3(1,0);\n\tprintf(\"%d\\n\",ansp);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "hashing",
        "shortest paths",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Timofey and a flat tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/50205",
    "editorial": "There are only subtrees in the whole tree: two for each edge. Let\u00e2\u0080\u0099s\r\ncalculate hashes of each of them.We can calculate hash of a subtree, for\r\nexample, in a following. Let\u00e2\u0080\u0099s associate each vertex with a correct\r\nbracket sequence. Leaves are associated with , other vertices are\r\nassociated with their sequences according to the following rule. Assume\r\nthat the children of our vertex are associated with sequences . Let\u00e2\u0080\u0099s\r\nsort strings in some order, for example, in order of ascending hashes.\r\nThen our vertex is associated with sequence . It\u00e2\u0080\u0099s easy to check that\r\nisomorphic subtrees are associated with equal sequences and\r\nnon-isomoriphic are associated with different sequences. Then hash of a\r\nsubtree is the hash of the sequence associated with the root of the\r\nsubtree. In this problem we will calculate the polynomial hash because\r\nwe will need to count the hash of concatenation of several strings\r\nknowing only their hash and length.We know hashes for all of the leaves.\r\nLet\u00e2\u0080\u0099s do a bfs-like algorithm that will greedily count all of the\r\nhashes. Let\u00e2\u0080\u0099s count number of outer edges for vertex , for which we have\r\nalready counted hashes of their subtrees. Then we know new hashes in two\r\ncases: . Then we can calculate the hash for the inner edge of , for\r\nwhich we don\u00e2\u0080\u0099t already know the outer hash in time. . Then we can\r\ncalculate the hash for all of the inner edges, for which we don\u00e2\u0080\u0099t\r\nalready know it. Let\u00e2\u0080\u0099s calculate hashes for all of concatenations of\r\nprefixes and suffixes of the sorted array. If we count polynomial hash,\r\nwe can calculate them knowing only their hashes and length. Then when we\r\ncalculate the hash for particular edge, we just have to concatenate the\r\nprefix and the suffix of our array. This all works in time. Now we have\r\nto calculate for each vertex the number of distinct hashes in case is\r\nthe root. Let\u00e2\u0080\u0099s select some vertex and calculate this number fairly,\r\nusing dfs and storing for each hash number of its occurrences in a\r\nhashtable. Then we go through the tree in order of Euler tour and\r\nmaintain the hashtable. When we go through edge , we should add hash of\r\nthe edge and remove hash of the edge , other hashes in the hashtable\r\ndoesn\u00e2\u0080\u0099t change.This works in time.Author\u00e2\u0080\u0099s solution:\r\nhttp://pastebin.com/05KPvqN1 Find the vertex with amount of distinct\r\nsubtrees in terms of isomorphism in time.\r\n"
}