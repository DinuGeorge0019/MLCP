{"link": "https://codeforces.com//contest/700/problem/E", "problemId": "66136", "problem_idx": "E", "shortId": "700E", "contest_number": "700", "problem_submissions": {"E": [24594748, 158561725, 158550290], "C": [19345625, 19382048, 19338136, 19340095, 19340301, 19337933, 19340888, 19340881, 19340439, 19343320, 19342147, 19343241, 19336239, 19344979, 19337688, 19345735, 19344599], "D": [19338795, 19343784, 19338575, 19351010, 19367015, 19366989, 19347563, 19447172, 19403026, 19402917, 19402596, 19384510, 157407262], "B": [19331219, 19332414, 19339798, 19330514, 19333849, 19334131, 19329268, 19335879, 19332140, 19330791, 19333504, 19333302, 19336092, 19330270, 19335712, 19342616, 19337619, 19335938], "A": [19329325, 19331230, 19341005, 19330573, 19330510, 19343948, 19331088, 19333400, 19345881, 19331775, 19336434, 19335266, 19334161, 19341301, 19332102, 19332761]}, "name": "E. Cool Slogans", "statement": "Bomboslav set up a branding agency and now helps companies to create new\r\nlogos and advertising slogans. In term of this problems, of the company\r\nshould be a non-empty substring of its name. For example, if the company\r\nname is \"\", then substrings \"\" and \"\" could be its slogans, while\r\nstrings \"\" and \"\" can not.Sometimes the company performs rebranding and\r\nchanges its slogan. Slogan is considered to be than slogan if appears in\r\nas a substring (this occurrences are allowed to overlap). For example,\r\nslogan \"\" is cooler than slogan \"\", slogan \"\" is cooler than slogan \"\",\r\nbut slogan \"\" is not cooler than slogan \"\".You are given the company\r\nname and your task is to help Bomboslav determine the length of the\r\nlongest sequence of slogans , such that any slogan in the sequence is\r\ncooler than the previous one.\r\n", "solutions": ["#include<cstdio>\n#include<algorithm>\n#define pii pair<int,int>\n#define SZ 262144\nusing namespace std;\nint n, Rank[201000], SA[201000], LCP[201000][20], Low[201000], IT[SZ+SZ];\nchar p[201000];\nstruct SA{\n    int a, b, num;\n    bool operator<(const SA &p)const{\n        return a!=p.a?a<p.a:b<p.b;\n    }\n}w[201000];\nvoid Make_SA(){\n    int i, L = 1;\n    for(i=0;i<n;i++)w[i].a=p[i],w[i].b=p[i+1],w[i].num=i;\n    while(1){\n        sort(w,w+n);\n        int cnt = 0;\n        for(i=0;i<n;i++){\n            if(!i || w[i-1]<w[i])cnt++;\n            Rank[w[i].num] = cnt;\n        }\n        if(cnt==n)break;\n        L<<=1;\n        for(i=0;i<n;i++){\n            w[i].a=Rank[i];\n            if(i+L>=n)w[i].b=0;\n            else w[i].b=Rank[i+L];\n            w[i].num=i;\n        }\n    }\n    for(i=0;i<n;i++)SA[Rank[i]]=i;\n}\nvoid Make_LCP(){\n    int i, l = 0, x, y, j;\n    for(i=0;i<n;i++){\n        if(l)l--;\n        x = Rank[i];\n        if(x==n)continue;\n        y=SA[x+1];\n        while(p[i+l]==p[y+l])l++;\n        LCP[x][0]=l;\n    }\n    for(i=0;i<17;i++){\n        for(j=1;j<n;j++){\n            if(j+(1<<i)>n)continue;\n            LCP[j][i+1]=min(LCP[j+(1<<i)][i], LCP[j][i]);\n        }\n    }\n    for(i=1;i<=n;i++){\n        Low[i]=Low[i-1];\n        if((1<<(Low[i]+1)) <= i)Low[i]++;\n    }\n}\nvoid Ins(int a, int b){\n    a+=SZ;\n    IT[a]=b;\n    while(a!=1){\n        a>>=1;\n        IT[a]=min(IT[a+a],IT[a+a+1]);\n    }\n}\nint get_LCP(int a, int b){\n    if(a>b)swap(a,b);\n    int t = Low[b-a];\n    return min(LCP[a][t], LCP[b-(1<<t)][t]);\n}\npii Range(int a, int l){\n    int b = 1, e = a-1, mid, r1 = a, r2 = a;\n    while(b<=e){\n        mid=(b+e)>>1;\n        if(get_LCP(mid,a)>=l){\n            r1=mid;\n            e=mid-1;\n        }\n        else b=mid+1;\n    }\n    b = a+1, e = n;\n    while(b<=e){\n        mid=(b+e)>>1;\n        if(get_LCP(a,mid)>=l){\n            r2=mid;\n            b=mid+1;\n        }\n        else e=mid-1;\n    }\n    return pii(r1,r2);\n}\nint Min(int b, int e){\n    b+=SZ,e+=SZ;\n    int r = 1e9;\n    while(b<=e){\n        r=min(r,min(IT[b],IT[e]));\n        b=(b+1)>>1,e=(e-1)>>1;\n    }\n    return r;\n}\nint Calc(int a){\n    int c = 1, L = 1;\n    while(1){\n        pii tp = Range(Rank[a], L);\n        int t = Min(tp.first, tp.second);\n        if(t>n)return c;\n        int l = get_LCP(Rank[a],Rank[t]);\n        c += (l-L)/(t-a)+1;\n        L += t-a + (l-L)/(t-a)*(t-a);\n    }\n}\nint main(){\n    int i, res = 0;\n    scanf(\"%d\",&n);\n    scanf(\"%s\",p);\n    Make_SA();\n    Make_LCP();\n    for(i=1;i<=n;i++)Ins(i,SA[i]);\n    for(i=0;i<n;i++){\n        Ins(Rank[i],1e9);\n        res = max(res,Calc(i));\n    }\n    printf(\"%d\\n\",res);\n}"], "input": "", "output": "", "tags": ["string suffix structures", "strings"], "dificulty": "3300", "interactive": false}