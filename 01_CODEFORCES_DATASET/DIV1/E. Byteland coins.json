{
    "link": "https://codeforces.com//contest/759/problem/E",
    "problemId": "89814",
    "problem_idx": "E",
    "shortId": "759E",
    "contest_number": "759",
    "problem_submissions": {
        "D": [
            24042663,
            24044352,
            24045382,
            24043506,
            24045238,
            24043490,
            24042979,
            24045976,
            24046805,
            24046489,
            24045414,
            24046878,
            24045586,
            24044218,
            24046750,
            24048837,
            24048930,
            24045107,
            24049310,
            24047941
        ],
        "C": [
            24039992,
            24041637,
            24042097,
            24039244,
            24042431,
            24038977,
            24045787,
            24042805,
            24042270,
            24042690,
            24043790,
            24042556,
            24043437,
            24048532,
            24043622,
            24043222,
            24044113,
            29763466,
            29763430,
            24060556,
            24048425,
            24043154,
            24044032
        ],
        "B": [
            24037454,
            24038457,
            24039020,
            24040925,
            24038375,
            24044395,
            24038784,
            24039274,
            24038903,
            24039124,
            24039288,
            24039629,
            24040886,
            24038009,
            24039848,
            24039613,
            24036880,
            24038463,
            24040006,
            24040241
        ],
        "A": [
            24036272,
            24036509,
            24037538,
            24045297,
            24036223,
            24045401,
            24036423,
            24037461,
            24037032,
            24036975,
            24036471,
            24037688,
            24038305,
            24036140,
            24037910,
            24037165,
            24039125,
            24036572,
            24037614,
            24038031
        ],
        "E": [
            24052445,
            24051804,
            24055034
        ]
    },
    "name": "E. Byteland coins",
    "statement": "There are types of coins in Byteland. Conveniently, the denomination of\r\nthe coin type divides the denomination of the coin type , the\r\ndenomination of the coin type equals tugrick. The ratio of the\r\ndenominations of coin types and equals . It is known that for each there\r\nare at most coin types of denomination .Byteasar has coins of type with\r\nhim, and he needs to pay exactly tugricks. It is known that Byteasar\r\nnever has more than coins with him. Byteasar want to know how many ways\r\nthere are to pay exactly tugricks. Two ways are different if there is an\r\ninteger such that the amount of coins of type differs in these two ways.\r\nAs all Byteland citizens, Byteasar wants to know the number of ways\r\nmodulo .\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/stack:16777216\")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <assert.h>\n#include <time.h>\n#include <complex.h>\n\n\n#include <fstream>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,value) memset(A,value,sizeof(A))\n#define ALL(V) V.begin(), V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n#define Pi 3.14159265358979\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<Int, Int> PII;\n\nconst int INF = 1000000000;\nconst int MAX = 300007;\nconst int MAXD = 20;\nconst int MOD = 1000000007;\n\nconst int BASE = 1000*1000*1000;\n\nVI read(string s)\n{\n    VI a;\n    for (int i=(int)s.length(); i>0; i-=9)\n        if (i < 9)\n            a.push_back (atoi (s.substr (0, i).c_str()));\n        else\n            a.push_back (atoi (s.substr (i-9, 9).c_str()));\n    return a;\n}\n\nint div(VI & a, int b)\n{\n    if (b == 1)\n    {\n        return 0;\n    }\n        \n    \n    if (b == BASE)\n    {\n        int carry = a[0];\n        if (SZ(a) > 0)\n        {\n            a.erase(a.begin());\n        }\n        return carry;\n    }\n    \n    int carry = 0;\n    for (int i=(int)a.size()-1; i>=0; --i) {\n        long long cur = a[i] + carry * 1ll * BASE;\n        a[i] = int (cur / b);\n        carry = int (cur % b);\n    }\n    while (a.size() > 1 && a.back() == 0)\n        a.pop_back();\n    return carry;\n}\n\nVI A[MAX];\nVI C;\nint a[MAX];\nVI B;\n\nint dp[2][MAX];\nint b[MAX];\n\n\nint main()\n{\n    //freopen(\"in.txt\" , \"r\" , stdin);\n    //freopen(\"out.txt\" , \"w\" , stdout);\n    \n    int n;\n    cin >> n;\n    FOR(i,1,n)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n\n    \n    \n    FOR(i,0,n)\n    {\n        scanf(\"%d\", &b[i]);\n    }\n    \n    string s;\n    cin >> s;\n    VI num = read(s);\n    FOR(i,1,n)\n    {\n        B.push_back(div(num , a[i]));\n    }\n    if (SZ(num) > 1)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    B.push_back(num[0]);\n    \n    int sz = b[0] + 1;\n    int prev = 0;\n    int next = 1;\n    FOR(i,0,sz)\n    {\n        dp[prev][i] = 1;\n    }\n    \n    FOR(i,0,n - 1)\n    {\n        VI t;\n        int idd = 0;\n        for(int j = B[i]; j < sz; j += a[i + 1])\n        {\n            dp[next][idd ++] = dp[prev][j];\n        }\n        if (idd == 0)\n        {\n            cout << 0 << endl;\n            return 0;\n        }\n        sz = idd;\n        swap(prev , next);\n        int x = b[i + 1];\n        \n        FOR(j,0,sz + b[i + 1])\n        {\n            dp[next][j] = 0;\n            if (j) dp[next][j] = dp[next][j - 1];\n            if (j < sz)\n            {\n                dp[next][j] += dp[prev][j];\n                if (dp[next][j] >= MOD) dp[next][j] -= MOD;\n            }\n            if (j - x - 1 >= 0)\n            {\n                dp[next][j] += MOD - dp[prev][j - x - 1];\n                if (dp[next][j] >= MOD) dp[next][j] -= MOD;\n            }\n        }\n        swap(prev , next);\n        sz += x;\n        \n    }\n    \n    if (B[n - 1] >= sz)\n    {\n        cout << 0 << endl;\n    }\n    else\n    {\n        cout << dp[prev][B[n - 1]] << endl;\n    }\n        \n    \n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Byteland coins.json",
    "editorial_link": "https://codeforces.com//blog/entry/49946",
    "editorial": "Let's calculate DP[pref][x]  number of ways to pay x tugriks using only pref first types. Of course, x can be very big, but we will store DP only for those x which are not bigger than the sum of all the coins of first pref types and can lead to answer: x?=?k·D?+?(m%D) where D is the last coin denomination.\n\nEvery next layer of this DP can be calculated in O(szi) time using prefix sums where sz is the size of the new layer. .\n\n\nNow all that remains is to calculate some info about m%D to know what DP elemnts we are interested in. We should represent m in a form of ?i?=?1nci·Di. To find ci we should successively divide m by all ai, ci will be the reminders. All the divisions can be done in  time if we will not divide by 1.",
    "hint": []
}