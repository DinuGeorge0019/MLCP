{
    "link": "https://codeforces.com//contest/1630/problem/B",
    "problemId": "1275997",
    "problem_idx": "B",
    "shortId": "1630B",
    "contest_number": "1630",
    "problem_submissions": {
        "E": [
            144224769,
            144215907,
            144221628,
            144228274,
            144219804,
            144218158,
            144225764,
            144238591,
            144210990,
            144217838,
            144226182,
            144224358,
            144225778,
            144221770,
            144226514,
            144222722,
            144227026,
            144226268,
            144232930
        ],
        "F": [
            144210863,
            144246407,
            144239829,
            144237561,
            144242088,
            144244711,
            144244456,
            144246802,
            144259720,
            144255927,
            144333444,
            144255940,
            144608342,
            148502898,
            148434493,
            148432956
        ],
        "D": [
            144197307,
            144203996,
            144209276,
            144205176,
            144207016,
            144204010,
            144211325,
            144216890,
            144199054,
            144199808,
            144201432,
            144206931,
            144201023,
            144209262,
            144204729,
            144211122,
            144210123,
            144205407,
            144205842
        ],
        "C": [
            144191312,
            144195772,
            144199628,
            144200731,
            144196919,
            144198723,
            144205328,
            144206861,
            144191587,
            144193957,
            144195705,
            144198126,
            144190461,
            144203715,
            144198045,
            144205577,
            144200182,
            144197491,
            144198438
        ],
        "B": [
            144182123,
            144182453,
            144193080,
            144189508,
            144185231,
            144186871,
            144189030,
            144188822,
            144178499,
            144179435,
            144183325,
            144180542,
            144180237,
            144181268,
            144190041,
            144176578,
            144186138,
            144190693,
            144189698
        ],
        "A": [
            144175474,
            144175629,
            144182481,
            144180498,
            144176716,
            144180161,
            144180336,
            144179468,
            144172483,
            144171609,
            144171918,
            144172250,
            144173608,
            144173794,
            144181834,
            144190017,
            144177869,
            144180828,
            144177686
        ]
    },
    "name": "B. Range and Partition",
    "statement": "Given an array a of n integers, find a range of values [x, y] (x\r\nle y), and split a into k (1\r\nle k\r\nle n) subarrays in such a way that: Each subarray is formed by several\r\ncontinuous elements of a, that is, it is equal to a_l, a_{l+1},\r\nldots, a_r for some l and r (1\r\nleq l\r\nleq r\r\nleq n). Each element from a belongs to exactly one subarray. In each\r\nsubarray the number of elements inside the range [x, y] (inclusive) is\r\nthan the number of elements outside the range. An element with index i\r\nis inside the range [x, y] if and only if x\r\nle a_i\r\nle y. Print any solution that minimizes y - x.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[N];\nint cnt[N];\nint k;\n\nvoid solve() {\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tcnt[a[i]]++;\n\t}\n\tint w = (n + k + 1) / 2;\n\tint L = 1, R = n + 1;\n\tint r = 1, sum = 0;\n\tfor (int l = 1; l <= n; l++) {\n\t\twhile(r <= n && sum < w) {\n\t\t\tsum += cnt[r];\n\t\t\tr++;\n\t\t}\n\t\tif (sum < w) break;\n\t\tif (r - l < R - L) {\n\t\t\tL = l;\n\t\t\tR = r;\n\t\t}\n\t\tsum -= cnt[l];\n\t}\n\tprintf(\"%d %d\\n\", L, R - 1);\n\tint lst = 0;\n\tint p = 0;\n\tsum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (L <= a[i] && a[i] < R) {\n\t\t\tsum++;\n\t\t} else {\n\t\t\tsum--;\n\t\t}\n\t\tif (p + 1 < k && sum > p) {\n\t\t\tp++;\n\t\t\tprintf(\"%d %d\\n\", lst + 1, i + 1);\n\t\t\tlst = i + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", lst + 1, n);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Range and Partition.json",
    "editorial_link": "https://codeforces.com//blog/entry/99384",
    "editorial": "Solution Focus on how to solve the problem for a fixed interval :Let us\ndefine an array such that if or otherwise, for all .Let\u00e2\u0080\u0099s define as .We\nneed to find a partition on subarrays with positive sum of .The sum of a\nsubarray is . Then a subarray is valid if .We need to find an increasing\nsequence of of length starting at and ending at .Let\u00e2\u0080\u0099s define to be the\nfirst occurrence of the integer in .If there will be no valid sequence,\notherwise the sequence will satisfy all constraints. Note that, since ,\nfor , then exists and for .This solves the problem for a fixed\ninterval.It remains to find the smallest interval such that .For a given\ninterval , since , will be equal to the number of elements of inside the\ninterval minus the number of elements outside.Then for each , it is\npossible to find the smallest such that using binary search or two\npointers.It is also possible to note that: We need to find the smallest\ninterval with at least inside, let be the array sorted, the answer is\nthe minimum interval among all intervals for .Complexity: if solved with\nthe previous formula or binary search, or is solved with two pointers.\nCode (with the previous formula)\n"
}