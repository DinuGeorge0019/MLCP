{"link": "https://codeforces.com//contest/576/problem/B", "problemId": "34884", "problem_idx": "B", "shortId": "576B", "contest_number": "576", "problem_submissions": {"D": [12948640, 12948506, 12948354, 12937171, 12937633, 12940817, 12940388, 12940233, 12940092, 12939430, 12939063, 12935207, 12942962, 12940891, 12941506, 12939643, 12933648, 12943594], "C": [12932865, 12929775, 12930204, 12934079, 12931097, 12934157, 12932646, 12938006, 12960885, 12936499, 12932088, 12931162, 12933248, 12943319, 12926742, 12932751, 12928085, 12932873, 12935950], "B": [12930813, 12932445, 12933792, 12931978, 12932789, 12930228, 12930366, 12941663, 12931673, 12935038, 12935800, 12940912, 12931636, 12948000, 12937985, 12933306, 12935930, 12933037], "A": [12926373, 12925995, 12926783, 12926169, 12926245, 12926309, 12926740, 12939248, 12926537, 12926100, 12927525, 12926051, 12926418, 12928170, 12926649, 12926146, 12926053, 12936482], "E": [12958478, 12974224, 12948989, 13216883, 12944220]}, "name": "B. Invariance of Tree", "statement": "A tree of size is an undirected connected graph consisting of vertices\r\nwithout cycles.Consider some tree with vertices. We call a tree relative\r\nto permutation , if for any two vertices of the tree and the condition\r\nholds: \"vertices and are connected by an edge if and only if vertices\r\nand are connected by an edge\".You are given permutation of size . Find\r\nsome tree size , invariant relative to the given permutation.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100010\nint p[MAX];\nint wyn[MAX];\nint n;\nvoid nie(){\n  puts(\"NO\");\n  exit(0);\n}\nmain(){\n  make(n);\n  R(i,n){\n    make(p[i]);\n    p[i]--;\n  }\n  R(i,n){\n    if(p[i] == i){\n      puts(\"YES\");\n      R(j,n){\n        if(i!=j)\n          printf(\"%d %d\\n\",i+1,j+1);\n      }\n      return 0;\n    }\n  }\n  R(i,n)wyn[i] = -1;\n  R(i,n){\n    if(p[p[i]] == i){   \n      int k = p[i];\n      R(j,n){\n        if(wyn[j] == -1 && j != i && j!=k){\n          int ak = j;\n          int w = i;\n          while(wyn[ak] == -1){\n            wyn[ak] = w;\n            ak = p[ak];\n            w = i+k - w;\n          }\n          if(w != i)nie();\n        }\n      }\n      puts(\"YES\");\n      printf(\"%d %d\\n\",i+1,k+1);\n      R(j,n){\n        if(i!=j && j!=k)\n          printf(\"%d %d\\n\",wyn[j]+1,j+1);\n      }\n      return 0;\n    }\n  }\n  nie();\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "greedy", "trees"], "dificulty": "2100", "interactive": false}