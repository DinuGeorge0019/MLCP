{
    "link": "https://codeforces.com//contest/576/problem/B",
    "problemId": "34884",
    "problem_idx": "B",
    "shortId": "576B",
    "contest_number": "576",
    "problem_submissions": {
        "D": [
            12948640,
            12948506,
            12948354,
            12937171,
            12937633,
            12940817,
            12940388,
            12940233,
            12940092,
            12939430,
            12939063,
            12935207,
            12942962,
            12940891,
            12941506,
            12939643,
            12933648,
            12943594
        ],
        "C": [
            12932865,
            12929775,
            12930204,
            12934079,
            12931097,
            12934157,
            12932646,
            12938006,
            12960885,
            12936499,
            12932088,
            12931162,
            12933248,
            12943319,
            12926742,
            12932751,
            12928085,
            12932873,
            12935950
        ],
        "B": [
            12930813,
            12932445,
            12933792,
            12931978,
            12932789,
            12930228,
            12930366,
            12941663,
            12931673,
            12935038,
            12935800,
            12940912,
            12931636,
            12948000,
            12937985,
            12933306,
            12935930,
            12933037
        ],
        "A": [
            12926373,
            12925995,
            12926783,
            12926169,
            12926245,
            12926309,
            12926740,
            12939248,
            12926537,
            12926100,
            12927525,
            12926051,
            12926418,
            12928170,
            12926649,
            12926146,
            12926053,
            12936482
        ],
        "E": [
            12958478,
            12974224,
            12948989,
            13216883,
            12944220
        ]
    },
    "name": "B. Invariance of Tree",
    "statement": "A tree of size is an undirected connected graph consisting of vertices\r\nwithout cycles.Consider some tree with vertices. We call a tree relative\r\nto permutation , if for any two vertices of the tree and the condition\r\nholds: \"vertices and are connected by an edge if and only if vertices\r\nand are connected by an edge\".You are given permutation of size . Find\r\nsome tree size , invariant relative to the given permutation.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100010\nint p[MAX];\nint wyn[MAX];\nint n;\nvoid nie(){\n  puts(\"NO\");\n  exit(0);\n}\nmain(){\n  make(n);\n  R(i,n){\n    make(p[i]);\n    p[i]--;\n  }\n  R(i,n){\n    if(p[i] == i){\n      puts(\"YES\");\n      R(j,n){\n        if(i!=j)\n          printf(\"%d %d\\n\",i+1,j+1);\n      }\n      return 0;\n    }\n  }\n  R(i,n)wyn[i] = -1;\n  R(i,n){\n    if(p[p[i]] == i){   \n      int k = p[i];\n      R(j,n){\n        if(wyn[j] == -1 && j != i && j!=k){\n          int ak = j;\n          int w = i;\n          while(wyn[ak] == -1){\n            wyn[ak] = w;\n            ak = p[ak];\n            w = i+k - w;\n          }\n          if(w != i)nie();\n        }\n      }\n      puts(\"YES\");\n      printf(\"%d %d\\n\",i+1,k+1);\n      R(j,n){\n        if(i!=j && j!=k)\n          printf(\"%d %d\\n\",wyn[j]+1,j+1);\n      }\n      return 0;\n    }\n  }\n  nie();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Invariance of Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/20226",
    "editorial": "Let's look at the answer. It's easy to notice, that centers of that tree must turn into centers after applying the permutation. That means, permutation must have cycle with length 1 or 2 since there're at most two centers.\n\nIf permutation has cycle with length 1, we can connect all the other vertices to it.\n\nFor example, let's look at the permutation (4,?2,?1,?3). 2 is a cycle with length 2, so let's connect all the other vertices to it. The resulting tree edges would be (1,?2), (2,?3), (2,?4).\n\nIf answer has two centers, let's remove the edge between them. The tree will split into two connected parts. It's easy to see that they will turn into each other after applying permutation. That means, all cycles should be even.\n\nIt's easy to come up with answer with these restrictions. Let's connect vertices from the cycles with length 2. Then, let's connect vertices with odd position in cycles to first of these and vetices with even cycles to second one.\n\nFor example, let's consider permutation (6,?5,?4,?3,?1,?2). There are two cycles: (3,?4) ? (1,?6,?2,?5). We add edge (3,?4), all other vertices we connect to these two, obtaining edges (1,?3), (6,?4), (2,?3), (5,?4).",
    "hint": []
}