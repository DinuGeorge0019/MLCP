{
    "link": "https://codeforces.com//contest/351/problem/C",
    "problemId": "3594",
    "problem_idx": "C",
    "shortId": "351C",
    "contest_number": "351",
    "problem_submissions": {
        "D": [
            4670145,
            4670249,
            4674550,
            4670754,
            4674929,
            4684601,
            4669199,
            4669889,
            4672385,
            4680204
        ],
        "C": [
            4665748,
            4664661,
            4663479,
            4665815,
            4667455,
            4687038,
            4686935,
            4686917,
            4668439,
            4666789,
            4670720,
            4671735,
            4670649,
            4671154,
            4668837,
            4669283
        ],
        "B": [
            4661574,
            4660489,
            4662188,
            4663391,
            4665392,
            4662692,
            4661437,
            4662916,
            4663186,
            4668058,
            4662366,
            4666797,
            4662458,
            4659236,
            4659832,
            4665176,
            4659225
        ],
        "A": [
            4661298,
            4659082,
            4658665,
            4661628,
            4664159,
            4659520,
            4666420,
            4665346,
            4659838,
            4662463,
            4658356,
            4660908,
            4660765
        ],
        "E": [
            4658359,
            4666363,
            4665274,
            4666984,
            4664316,
            4666715,
            4668432,
            4666380,
            4665428,
            4663383,
            4671601,
            4671635,
            4660529,
            4661696,
            4664447,
            4673681,
            4671913,
            4664654
        ]
    },
    "name": "C. Jeff and Brackets",
    "statement": "Jeff loves regular bracket sequences.Today Jeff is going to take a piece\r\nof paper and write out the regular bracket sequence, consisting of\r\nbrackets. Let’s number all brackets of this sequence from to - from left\r\nto right. Jeff knows that he is going to spend liters of ink on the -th\r\nbracket of the sequence if he paints it opened and liters if he paints\r\nit closed.You’ve got sequences , and numbers , . What minimum amount of\r\nink will Jeff need to paint a regular bracket sequence of length\r\n?Operation means taking the remainder after dividing number by number .\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1<<29)\n\nint N;\nint open[30],clos[30];\nint dp1[30][30];\nint dp2[30][30];\nint diff[30];\n\nll func(ll M, ll cnt){\n    int i;\n    \n    ll ans = 0;\n    REP(i,N){\n        ll tmp = min(cnt, M);\n        cnt -= tmp;\n        ans += diff[i] * tmp;\n    }\n    \n    REP(i,N) ans += M * clos[i];\n    \n    return ans;\n}\n\nint main(void){\n    int M,i,j;\n    \n    cin >> N >> M;\n    REP(i,N) cin >> open[i];\n    REP(i,N) cin >> clos[i];\n    \n    REP(i,N) diff[i] = open[i] - clos[i];\n    sort(diff, diff + N);\n    \n    REP(i,N+1) REP(j,N+1) dp1[i][j] = dp2[i][j] = INF;\n    dp1[0][0] = 0;\n    REP(i,N) REP(j,N+1) if(dp1[i][j] != INF){\n        dp1[i+1][j+1] = min(dp1[i+1][j+1], dp1[i][j] + open[i]);\n        if(j > 0) dp1[i+1][j-1] = min(dp1[i+1][j-1], dp1[i][j] + clos[i]);\n    }\n    dp2[N][0] = 0;\n    for(i=N;i>0;i--) REP(j,N+1) if(dp2[i][j] != INF){\n        dp2[i-1][j+1] = min(dp2[i-1][j+1], dp2[i][j] + clos[i-1]);\n        if(j > 0) dp2[i-1][j-1] = min(dp2[i-1][j-1], dp2[i][j] + open[i-1]);\n    }\n    \n    ll ans = (1ll<<60);\n    \n    REP(i,N+1) REP(j,N+1) if(dp1[N][i] != INF && dp2[0][j] != INF){\n        ll tmp = dp1[N][i] + dp2[0][j];\n        int cnt_open = N * M / 2;\n        cnt_open -= (N + i) / 2;\n        cnt_open -= (N - j) / 2;\n        if(cnt_open >= 0 && cnt_open <= N * (M - 2)){\n        //  cout << i << ' ' << j << ' ' << tmp << endl;\n            tmp += func(M - 2, cnt_open);\n        //  cout << i << ' ' << j << ' ' << tmp << endl;\n            ans = min(ans, tmp);\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "matrices"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Jeff and Brackets.json",
    "editorial_link": "https://codeforces.com//blog/entry/9070",
    "editorial": "How to solve the problem for small ? Just use the dynamic programming\r\nminimum cost to build first brackets with the balance . Transfers are\r\nsimple:1. -> 2. -> 3. we make transfers only when balance will be\r\nnon-negative4. starting state In this problem, we can assume that the\r\nbalance will never exceed . The proof is left as homework. And by using\r\nthis fact problem can be done by erecting a matrix to the power:1. lets\r\ncost of transfer from balance to balance , using brackets2. answer to\r\nthe problem\r\n",
    "hint": []
}