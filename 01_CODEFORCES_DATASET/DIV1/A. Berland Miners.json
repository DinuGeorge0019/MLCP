{
    "link": "https://codeforces.com//contest/533/problem/A",
    "problemId": "26202",
    "problem_idx": "A",
    "shortId": "533A",
    "contest_number": "533",
    "problem_submissions": {
        "A": [
            10758806,
            41260125,
            10758808,
            10802245,
            10802137,
            10804672
        ],
        "F": [
            10756507,
            10757309,
            10756418,
            10756618,
            10756621,
            10756168,
            10757079,
            10756058,
            10757142,
            10756771,
            10757619,
            10759646,
            10756355,
            10754977,
            10755266,
            10757451,
            10757215
        ],
        "B": [
            10754115,
            10753181,
            10753247,
            10758386,
            10754046,
            10755412,
            10754879,
            10754156,
            10755561,
            10754427,
            10755399,
            10754294,
            10754859,
            10753587,
            10753864,
            10753648,
            10756961,
            10754716,
            10755774
        ],
        "E": [
            10753290,
            10754938,
            10754117,
            10754867,
            10757574,
            10755405,
            10753428,
            10753036,
            10753133,
            10753451,
            10753117,
            10753877,
            10753615,
            10753601,
            10754357,
            10753173,
            10756615,
            10756357,
            10753749,
            10753638
        ],
        "C": [
            10753054,
            10753925,
            10753515,
            10754395,
            10759452,
            10754436,
            10754096,
            10753898,
            10753485,
            10759228,
            10753726,
            10753443,
            10753028,
            10753108,
            10754551,
            10754248,
            10757723,
            10757684,
            10753241,
            10754870
        ],
        "D": [
            10759362,
            10758040,
            10759441,
            10756824,
            10799120,
            10799069
        ]
    },
    "name": "A. Berland Miners",
    "statement": "The biggest gold mine in Berland consists of caves, connected by\r\ntransitions. The entrance to the mine leads to the cave number , it is\r\npossible to go from it to any remaining cave of the mine by moving along\r\nthe transitions. The mine is being developed by the InMine Inc., miners\r\nwork for it. Each day the corporation sorts miners into caves so that\r\neach cave has at most one miner working there. For each cave we know the\r\nheight of its ceiling in meters, and for each miner we know his height ,\r\nalso in meters. If a miner\u2019s height doesn\u2019t exceed the height of the\r\ncave ceiling where he is, then he can stand there comfortably,\r\notherwise, he has to stoop and that makes him unhappy.Unfortunately,\r\nminers typically go on strike in Berland, so InMine makes all the\r\npossible effort to make miners happy about their work conditions. To\r\nensure that no miner goes on strike, you need make sure that no miner\r\nhas to stoop at any moment on his way from the entrance to the mine to\r\nhis cave (in particular, he must be able to stand comfortably in the\r\ncave where he works). To reach this goal, you can choose exactly one\r\ncave and increase the height of its ceiling by several meters. However\r\nenlarging a cave is an expensive and complex procedure. That\u2019s why\r\nInMine Inc. asks you either to determine the minimum number of meters\r\nyou should raise the ceiling of some cave so that it is be possible to\r\nsort the miners into the caves and keep all miners happy with their\r\nworking conditions or to determine that it is impossible to achieve by\r\nraising ceiling in exactly one cave.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 500100\nint n;\nset<int> skal;\nmap<int,int> m;\nint h[MAX];\nvector<int> d[MAX];\nint k;\nint s[MAX];\nvector<int> prze;\nconst int MAXX = 1<<20;\nstruct node{\n  int sum,suf;\n  void licz(node a,node b){\n    sum = a.sum + b.sum;\n    suf = min(b.suf,a.suf + b.sum);\n  }\n  void add(int il){\n    sum += il;\n    suf = min(0,sum);\n  }\n}dp[MAXX*2 + 5];\nint add(int a,int il){\n  a += MAXX;\n  dp[a].add(il);\n  while(1){\n    a/=2;\n    dp[a].licz(dp[a*2],dp[a*2+1]);\n    if(a == 1)break;\n  }\n}\nvoid dfs(int nr,int oj,int war){\n  MI(war,h[nr]);\n  prze.PB(war);\n  R(i,(int)d[nr].size())\n    if(d[nr][i]!=oj)\n      dfs(d[nr][i],nr,war);\n}\nint wyn = -1;\nint nowa;\nint stara;\nvector<int> wart;\nvoid dfsw(int nr,int oj,int war){\n  MI(war,h[nr]);\n  if(war <= stara)return;\n  wart.PB(war);\n  R(i,(int)d[nr].size())\n    if(d[nr][i]!=oj)\n      dfsw(d[nr][i],nr,war);\n}\nvoid dfsn(int nr,int oj,int war){\n  MI(war,h[nr]);\n  if(war < nowa){\n    stara = h[nr];\n    h[nr] = nowa;\n    wart.clear();\n    dfsw(nr,oj,nowa);\n    R(i,wart.size())\n      add(wart[i],1);\n    add(stara,(int)wart.size() * -1);\n    if(dp[1].suf == 0){\n      MA(wyn,stara);\n    }\n    R(i,wart.size())\n      add(wart[i],-1);\n    add(stara,(int)wart.size());\n    h[nr] = stara;\n  }else{\n    R(i,(int)d[nr].size())\n      if(d[nr][i]!=oj)\n        dfsn(d[nr][i],nr,war);\n  }\n}\nvoid licz(){\n  dfsn(0,-1,1e9);\n}\nint wyc(int szu){\n  int nr=0;\n  for(int a:skal){\n    if(nr == szu)return a;\n    nr++;\n  }\n}\nmain(){\n  make(n);\n  R(i,n){\n    make(h[i]);\n    skal.insert(h[i]);\n  }\n  R(i,n-1){\n    int a,b;\n    make2(a,b);\n    a--;b--;\n    d[a].PB(b);\n    d[b].PB(a);\n  }\n  make(k);\n  R(i,k){\n    make(s[i]);\n    skal.insert(s[i]);\n  }\n  int nr=0;\n  for(int a:skal){\n    m[a] = nr;\n    nr++;\n  }\n  R(i,n)h[i] = m[h[i]];\n  R(i,k)s[i] = m[s[i]];\n  dfs(0,-1,nr);\n  R(i,prze.size())add(prze[i],1);\n  R(i,k)add(s[i],-1);\n  if(dp[1].suf == 0){\n    puts(\"0\");\n    return 0;\n  }\n  sort(s,s+k,greater<int>());\n  sort(ALL(prze),greater<int>());\n  R(i,k){\n    if(prze[i] < s[i]){\n      nowa = s[i];\n      licz();\n      if(wyn == -1){\n        puts(\"-1\");\n        return 0;\n      }\n      printf(\"%d\\n\",wyc(nowa) - wyc(wyn));\n      return 0;\n    }\n  }\n  assert(0);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Berland Miners.json",
    "editorial_link": "https://codeforces.com//blog/entry/17458",
    "editorial": "We can add n?-?k miners with height 0 and it won't affect answer. So we can assume that numbers of miners and caves are the same.\n\nFor every cave let's define ti as maximal possible height of miner working in cave i if we wouldn't change any cave. We can calculate it from root to leaves with line ti?=?min(tfather,?hi).\n\nLet's say we don't change anything. We will try to assign all workers if it's possible or to do the best possible assignment otherwise \u0097 the one where there are few free (not occupied) caves and they are high (value ti is big). I will say later why we want them to be high. Formal definition (you don't have to read the next paragraph):\n\nFor every assignment let's sort free caves by ti. In the best assignment number of free caves is minimal possible. And for every position in such a list free cave in the best assignment has value ti not lower than in any other assignment. It can be proven that best possible assignment exists (it's not so obvious though).\n\nHow to find the best possible assignment? Let's sort caves ascending by ti and for every cave let's assign the tallest free miner who can work here. It will give us the best possibble assignment. Why? Let's say we've just made first bad decision (different than in the best assignment). It doesn't make sense to leave a cave empty if we can assign here someone. So we put a worker somewhere and we won't be able to do assignment now (we assumed that we've just made bad decision). From definition \"we put here tallest possible miner\" we know that we couldn't assign here taller guy. Maybe we want to assign here shorter miner and this \"highest possible\" goes somewhere else? But we can swap them and everything will be ok. So there remains last option: we don't want to put anyone here. But we will have to assign our guy to some higher cave so we can leave his destiny cave empty and put him here. To sum up, it's ok to assign highest possible free worker with iterating over caves sorted by ti. Almost the same sentences are the proof for other lemma:\n\nIf we want to have few free (not assigned) miners and we want them to be short it's optimal to iterate somehow over caves and to assign the tallest possible free miner in every cave. It works for every order of iterating over caves. And every order gives us the same set of free miners (but not necessarily the same set of free caves).\n\nWhy did we want free caves to be high? Because to assign everyone we must change height of cave not higher than the lowest free cave. Why? In short: otherwise that lowest free cave will remain free after running our assignment-algo (described above) on new tree. But we managed to find maximal possible height of lowest free cave. Let's call this value as LIM. And we know minimal set of free miners.\n\nChanging height of cave i from a to something bigger does something only when ti?=?a???LIM. And then in set of ti some changes happen. There were caves blocked before by cave i so they had t equal to a. These caves will have bigger t so in set of values t we have change e.g. from {5,?5,?5} to {7,?10,?8} (a was equal to 5). Let's throw out miners from caves with changed tc (maybe some of these caves were empty anyway). If we can't assign free miners (we found them before) to new caves then assigning everything isn't possible. Otherwise it is \u0097 we assign them in these caves with changed t and there are some threw out miners. But all of them were in caves with t?=?a???LIM so they are not higher than LIM. And we know that every free cave has tfree???LIM because LIM is height of lowest free cave. So we can put them there.\n\nSolution is to find result with binary search and to answer question: can we assign miners to caves with changing one cave by at most D? With our assignment-algo we calculate optimal lowest free cave and set of free miners. Then for every cave we try to increase its height by D if it had t not higher than LIM. It's also important that checking change of every cave has amortized linear complexity. If increasing height of cave A affects t of cave B below then later changing height of B does nothing \u0097 B is blocked by A anyway."
}