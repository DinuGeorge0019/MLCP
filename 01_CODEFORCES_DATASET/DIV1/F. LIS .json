{"link": "https://codeforces.com//contest/1868/problem/F", "problemId": "2185408", "problem_idx": "F", "shortId": "1868F", "contest_number": "1868", "problem_submissions": {"E": [223228586, 222815728, 231588269], "D": [223110671, 222776638, 222777162, 222782980, 222782523, 223072795, 222790549, 222790677, 222793420, 222800103, 222795470, 222793980, 222802561, 222799384, 222797784, 222800727, 222795823, 222801192, 223669050, 222801040, 222802199], "F": [223085466, 222790947, 247646963, 222898179], "C": [222763067, 222759154, 222746616, 222760340, 222756156, 222763622, 222756124, 222762393, 222751686, 222776556, 222772834, 222764583, 222781677, 222774228, 222779099, 222765233, 222774182, 222776098, 222768907], "B2": [222745832, 222748527, 222758458, 222744648, 222743313, 223073100, 222746136, 222743413, 222746166, 222738003, 222740242, 222749443, 222748125, 222749951, 222757155, 222748050, 222749211, 222753148, 222756646, 222747692], "B1": [222740122, 222740465, 222751668, 222737311, 222738981, 222739684, 222744732, 222739960, 222731387, 222735455, 222736795, 222740857, 222744073, 222747258, 222741914, 222742503, 222742541, 222746683, 222738741], "A": [222734071, 222731429, 222729599, 222732029, 222733115, 222733400, 222731753, 222727215, 222726334, 222729722, 222729267, 222729343, 222736621, 222732161, 222735584, 222730265, 222732117, 222730488, 222728959]}, "name": "F. LIS ", "statement": "Entering senior high school life, Tom is attracted by LIS problems, not\r\nonly the Longest Increasing Subsequence problem, but also the Largest\r\nInterval Sum problem. Now he gets a really interesting problem from his\r\nfriend Daniel. However, it seems too hard for him to solve it, so he\r\nasks you for help.Given an array a consisting of n integers.In one\r\noperation, you do the following: Select an interval [l,r] (1\r\nle l\r\nle r\r\nle n), such that the sum of the interval is the largest among in the\r\narray a. More formally,\r\ndisplaystyle\r\nsum_{i=l}^r a_i=\r\nmax_{1\r\nle l\u2019\r\nle r\u2019\r\nle n}\r\nsum_{i=l\u2019}^{r\u2019} a_i. Then subtract 1 from all elements a_l,a_{l+1},\r\nldots,a_r. Find the minimum number of operations you need to perform to\r\nmake a_i<0 for every 1\r\nle i\r\nle n.\r\n", "solutions": ["#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT \u00e3\u0081\u00a7\u00e6\u0095\u00b0\u00e5\u0088\u0097\u00e3\u0082\u0092\u00e7\u00ae\u00a1\u00e7\u0090\u0086\u00e3\u0081\u0099\u00e3\u0082\u008b\u00e3\u0081\u00a8\u00e3\u0081\u008d\u00e3\u0081\u00ab\u00e4\u00bd\u00bf\u00e3\u0081\u0086 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify \u00e3\u0081\u0097\u00e3\u0081\u00a6\u00e3\u0081\u00aa\u00e3\u0081\u0084\u00e3\u0082\u0084\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//\u00e3\u0082\u00bd\u00e3\u0083\u00bc\u00e3\u0083\u0088\u00e3\u0081\u0097\u00e3\u0081\u00a6 i \u00e7\u0095\u00aa\u00e7\u009b\u00ae\u00e3\u0081\u008c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//\u00e4\u00be\u008b\u00e3\u0081\u0088\u00e3\u0081\u00b0 sortidx \u00e3\u0081\u00a7\u00e5\u00be\u0097\u00e3\u0081\u009f idx \u00e3\u0082\u0092\u00e4\u00bd\u00bf\u00e3\u0081\u0088\u00e3\u0081\u00b0\u00e5\u008d\u0098\u00e3\u0081\u00ab\u00e3\u0082\u00bd\u00e3\u0083\u00bc\u00e3\u0083\u0088\u00e5\u0088\u0097\u00e3\u0081\u00ab\u00e3\u0081\u00aa\u00e3\u0081\u00a3\u00e3\u0081\u00a6\u00e8\u00bf\u0094\u00e3\u0081\u00a3\u00e3\u0081\u00a6\u00e3\u0081\u008f\u00e3\u0082\u008b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS revv(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t>\nvoid pb(vc<t>&a,const vc<t>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t>\nvc<t> cat(vc<t> a,const vc<t>&b){\n\tpb(a,b);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\n//N() \u00e3\u0081\u008c\u00e5\u008d\u0098\u00e4\u00bd\u008d\u00e5\u0085\u0083\n//VERIFY: yosupo\n//CF407E\ntemplate<class N>\nstruct segtree{\n\tvc<N> x;\n\tint n,s;\n\tsegtree(){}\n\ttemplate<class t>\n\tsegtree(const vc<t>&a){\n\t\tn=a.size();\n\t\ts=1;\n\t\twhile(s<n){s*=2;}\n\t\tx.resize(s*2);\n\t\trep(i,n)\n\t\t\tx[s+i]=N(a[i]);\n\t\tgnr(i,1,s)\n\t\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\t//NOT Verified\n\tsegtree(int nn){\n\t\tresize(nn);\n\t}\n\tvoid resize(int nn){\n\t\tn=nn;\n\t\ts=1;\n\t\twhile(s<n){s*=2;}\n\t\tx.assign(s*2,N());\n\t\tgnr(i,1,s)\n\t\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\ttemplate<class t>\n\tvoid load(const vc<t>&a){\n\t\tn=a.size();\n\t\ts=1;\n\t\twhile(s<n){s*=2;}\n\t\tx.resize(s*2);\n\t\trep(i,n)\n\t\t\tx[s+i]=N(a[i]);\n\t\trng(i,n,s)\n\t\t\tx[s+i]=N();\n\t\tgnr(i,1,s)\n\t\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid clear(){\n\t\trep(i,n)\n\t\t\tx[s+i]=N();\n\t\tgnr(i,1,s)\n\t\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tN point_get(int i){\n\t\tassert(inc(0,i,n-1));\n\t\treturn x[i+s];\n\t}\n\tvoid point_set(int i,const N&t){\n\t\tassert(inc(0,i,n-1));\n\t\ti+=s;\n\t\tx[i]=t;\n\t\twhile(i>>=1)x[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid point_merge(int i,const N&t){\n\t\tassert(inc(0,i,n-1));\n\t\ti+=s;\n\t\tx[i]=N::merge(x[i],t);\n\t\twhile(i>>=1)x[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\ttemplate<class F,class...Args>\n\tvoid point_change(int i,F f,Args&&...args){\n\t\tassert(inc(0,i,n-1));\n\t\ti+=s;\n\t\t(x[i].*f)(forward<Args>(args)...);\n\t\twhile(i>>=1)x[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tN composite(int b,int e){\n\t\tassert(0<=b&&b<=e&&e<=n);\n\t\tN lf,rt;\n\t\tfor(int l=b+s,r=e+s;l<r;l>>=1,r>>=1){\n\t\t\tif (l&1){\n\t\t\t\tlf=N::merge(lf,x[l]);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (r&1){\n\t\t\t\tr--;\n\t\t\t\trt=N::merge(x[r],rt);\n\t\t\t}\n\t\t}\n\t\treturn N::merge(lf,rt);\n\t}\n\tN getall(){\n\t\treturn x[1];\n\t}\n\t//UTPC2020E\n\t//n \u00e8\u00b6\u0085\u00e3\u0081\u0088\u00e3\u0082\u008b\u00e3\u0081\u008b\u00e3\u0082\u0082\u00e3\u0081\u0097\u00e3\u0082\u008c\u00e3\u0081\u00aa\u00e3\u0081\u0084\n\ttemplate <class F,class... Args> \n\tpair<int,N> max_right(int l,F f,Args&&... args){\n\t\tassert((N().*f)(forward<Args>(args)...));\n\t\tassert(0<=l&&l<=n);\n\t\tif(l==n)return mp(n,N());\n\t\tl+=s;\n\t\t\n\t\tN sm;\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tdo {\n\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\tif (!(N::merge(sm,x[l]).*f)(forward<Args>(args)...)){\n\t\t\t\twhile (l < s) {\n\t\t\t\t\tl = (2 * l);\n\t\t\t\t\tN tmp=N::merge(sm,x[l]);\n\t\t\t\t\tif ((tmp.*f)(forward<Args>(args)...)) {\n\t\t\t\t\t\tsm = tmp;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mp(l - s,sm);\n\t\t\t}\n\t\t\tsm = N::merge(sm, x[l]);\n\t\t\tl++;\n\t\t} while ((l & -l) != l);\n\t\treturn mp(n,sm);\n\t}\n\t//UTPC2020E\n\ttemplate <class F,class... Args> \n\tpair<int,N> min_left(int r,F f,Args&&... args){\n\t\tassert((N().*f)(forward<Args>(args)...));\n\t\tassert(0<=r&&r<=n);\n        if(r==0)return mp(0,N());\n        r+=s;\n        N sm;\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!(N::merge(x[r],sm).*f)(forward<Args>(args)...)) {\n                while (r < s) {\n                    r = (2 * r + 1);\n                    N tmp=N::merge(x[r],sm);\n                    if ((tmp.*f)(forward<Args>(args)...)) {\n                        sm = tmp;\n                        r--;\n                    }\n                }\n                return mp(r + 1 - s,sm);\n            }\n            sm = N::merge(x[r], sm);\n        } while ((r & -r) != r);\n        return mp(0,sm);\n    }\n    //\u00e8\u00a1\u008c\u00e5\u0088\u0097\u00e3\u0081\u00a8\u00e3\u0081\u008b\u00e4\u00b9\u0097\u00e3\u0081\u009b\u00e3\u0081\u00a6\u00e5\u00bf\u0085\u00e8\u00a6\u0081\u00e3\u0081\u00aa\u00e3\u0081\u00ae\u00e3\u0081\u00af\u00e3\u0083\u0099\u00e3\u0082\u00af\u00e3\u0083\u0088\u00e3\u0083\u00ab\u00e3\u0081\u00a8\u00e3\u0081\u00ae\u00e7\u00a9\u008d\u00ef\u00bc\u008c\u00e3\u0081\u00bf\u00e3\u0081\u009f\u00e3\u0081\u0084\u00e3\u0081\u00aa\u00e3\u0081\u00a8\u00e3\u0081\u008d\u00e3\u0081\u00ab\u00e4\u00bd\u00bf\u00e3\u0081\u0088\u00e3\u0082\u008b\u00ef\u00bc\u009f\n    //CF Goodbye 2016 E\n    //CF 896 F\n\ttemplate<class F,class T,class... Args>\n\tT accumulate(int l,int r,F f,T t,Args&&... args) {\n\t\tassert(0<=l&&l<=r&&r<=n);\n\t\tstatic int buf[2][30];\n\t\tint cnt[2]{};\n\t\tfor(l+=s,r+=s;l<r;l>>=1,r>>=1){\n\t\t\tif(l&1)buf[0][cnt[0]++]=l;\n\t\t\tif(r&1)buf[1][cnt[1]++]=r-1;\n\t\t\tl++;\n\t\t}\n\t\trep(i,cnt[0])t=(x[buf[0][i]].*f)(t,forward<Args>(args)...);\n\t\tper(i,cnt[1])t=(x[buf[1][i]].*f)(t,forward<Args>(args)...);\n\t\treturn t;\n\t}\n};\n\nstruct MaxNode{\n\tpi v;\n\tMaxNode(pi vv=pi(-inf,-1)):v(vv){}\n\tstatic MaxNode merge(const MaxNode&a,const MaxNode&b){\n\t\treturn MaxNode(max(a.v,b.v));\n\t}\n};\n\nstruct MinNode{\n\tpi v;\n\tMinNode(pi vv=pi(inf,-1)):v(vv){}\n\tstatic MinNode merge(const MinNode&a,const MinNode&b){\n\t\treturn MinNode(min(a.v,b.v));\n\t}\n};\n\nbool dbg=false;\n\nll cdiv(ll a, ll b) { // ceiled division\n\treturn a / b + ((a ^ b) > 0 && a % b); }\n\nint sgn(int a){\n\treturn a>0?1:(a<0?-1:0);\n}\n\nint rabs(pi a){return max(abs(a.a),abs(a.b));}\n\npi add(pi a,pi b){\n\treturn pi(a.a+b.a,a.b+b.b);\n}\n\npi sub(pi a,pi b){\n\treturn pi(a.a-b.a,a.b-b.b);\n}\n\nint crs(pi a,pi b){\n\treturn a.a*b.b-a.b*b.a;\n}\n\nint ccw(pi a,pi b){\n\treturn sgn(crs(a,b));\n}\n\nint ccw(pi a,pi b,pi c){\n\treturn sgn(crs(sub(b,a),sub(c,a)));\n}\n\nvoid add_convex(vc<pi>&ps,pi v){\n\twhile(si(ps)>=2&&ccw(ps[si(ps)-2],ps[si(ps)-1],v)<0)ps.pop_back();\n\tps.pb(v);\n}\n\nvc<pi> cat_convex(vc<pi> a,const vc<pi>&b){\n\tfor(auto v:b)add_convex(a,v);\n\treturn a;\n}\n\nint eval(pi a,int t){\n\treturn a.a*t+a.b;\n}\n\nint tilt(pi a,pi b){\n\tassert(a.a<b.a);\n\tassert(a.b<=b.b);\n\treturn (b.b-a.b)/(b.a-a.a);\n}\n\n//f(lw)=false,...,f(n-1)=false,f(n)=true,...,f(up)=true,\n//\u00e3\u0081\u00ae\u00e3\u0081\u00a8\u00e3\u0081\u008d\u00e3\u0081\u00ab n \u00e3\u0082\u0092\u00e8\u00bf\u0094\u00e3\u0081\u0099\ntemplate<class F>\nint find_min_true(int lw,int up,F f){\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(f(mid))up=mid;\n\t\telse lw=mid;\n\t}\n\treturn up;\n}\n\nstruct N{\n\tvc<pi> lw,up;\n\tint g,h;\n\tN():g(0),h(0){}\n\tN(pi v):lw{v},up{v},g(0),h(0){}\n\tstatic N merge(const N&a,const N&b){\n\t\tN res;\n\t\tres.lw=cat_convex(a.lw,b.lw);\n\t\tres.up=cat_convex(b.up,a.up);\n\t\treturn res;\n\t}\n\tpi eval_min(pi cur,int t){\n\t\twhile(g+1<si(lw)&&eval(lw[g],t)>eval(lw[g+1],t))g++;\n\t\treturn min(cur,pi(eval(lw[g],t),lw[g].a));\n\t}\n\tpi eval_max(pi cur,int t){\n\t\twhile(h+1<si(up)&&eval(up[h],t)<eval(up[h+1],t))h++;\n\t\treturn max(cur,pi(eval(up[h],t),up[h].a));\n\t}\n\tint tilt_lw(int u,pi o){\n\t\tint p=find_min_true(-1,si(lw)-1,[&](int i){\n\t\t\tassert(i+1<si(lw));\n\t\t\treturn ccw(o,lw[i],lw[i+1])>=0;\n\t\t});\n\t\treturn min(u,tilt(o,lw[p]));\n\t}\n\tint tilt_up(int u,pi o){\n\t\tint p=find_min_true(-1,si(up)-1,[&](int i){\n\t\t\tassert(i+1<si(up));\n\t\t\treturn ccw(o,up[i],up[i+1])>=0;\n\t\t});\n\t\treturn min(u,tilt(up[p],o));\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tvc<tuple<int,int,int>> st;\n\tst.eb(0,n,0);\n\tvc<pi> ls;\n\tint ans=0;\n\t\n\tvc<pi> ps(n+1);\n\trep(i,n+1){\n\t\tps[i].a=i;\n\t\tif(i)ps[i].b=ps[i-1].b+a[i-1];\n\t}\n\tsegtree<N> conv(ps);\n\t\n\twhile(si(st)){\n\t\t//dmp(st);\n\t\t//dmp(a);\n\t\tls.clear();\n\t\tint t;\n\t\t{\n\t\t\tauto [l,r,tmp]=gpp(st);\n\t\t\tt=tmp;\n\t\t\tauto dfs=[&](auto self,int x,int y)->void{\n\t\t\t\tif(x<y){\n\t\t\t\t\tauto [rval,j]=conv.accumulate(x,y+1,&N::eval_max,pi(-inf,-inf),-t);\n\t\t\t\t\tauto [lval,i]=conv.accumulate(x,j+1,&N::eval_min,pi(inf,inf),-t);\n\t\t\t\t\t//dmp2(x,y,t,i,j);\n\t\t\t\t\tif(i<j)ls.eb(i,j);\n\t\t\t\t\tself(self,x,i-1);\n\t\t\t\t\tself(self,j+1,y);\n\t\t\t\t}\n\t\t\t};\n\t\t\tdfs(dfs,l,r);\n\t\t}\n\t\tfor(auto [l,r]:ls){\n\t\t\tint u=inf;\n\t\t\tu=conv.accumulate(l+1,r+1,&N::tilt_lw,u,ps[l]);\n\t\t\tu=conv.accumulate(l,r,&N::tilt_up,u,ps[r]);\n\t\t\t//dmp2(l,r,v,u);\n\t\t\tassert(u<inf);\n\t\t\tu++;\n\t\t\t//dmp(u);\n\t\t\tans+=u-t;\n\t\t\tst.eb(l,r,u);\n\t\t}\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\t//int t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy", "implementation"], "dificulty": "3500", "interactive": false}