{
    "link": "https://codeforces.com//contest/1540/problem/D",
    "problemId": "1027090",
    "problem_idx": "D",
    "shortId": "1540D",
    "contest_number": "1540",
    "problem_submissions": {
        "E": [
            158665487,
            120671889,
            120671130,
            120611380
        ],
        "C2": [
            120605147,
            120568544,
            120579011,
            120588964,
            120605073,
            120569097,
            120574747,
            120608479,
            120579015,
            120598713,
            120577744,
            120597136,
            120595479,
            120616218,
            120596815,
            120598287
        ],
        "D": [
            120591057,
            120602670,
            120602293,
            120600949,
            120589579,
            120610881,
            120604354,
            120600348,
            120595403,
            120583946,
            120609085,
            120608380,
            120703598,
            120703586,
            120698836,
            120593678,
            120637556,
            120637415
        ],
        "C1": [
            120567535,
            120561594,
            120567326,
            120573306,
            120596169,
            120563211,
            120564500,
            120604433,
            120607536,
            120590343,
            120588571,
            120578785,
            120575407,
            120560194,
            120579656,
            120577149,
            120580975,
            120582010
        ],
        "B": [
            120551949,
            120542169,
            120552393,
            120556326,
            120559167,
            120545883,
            120578567,
            120557279,
            120559926,
            120559208,
            120581683,
            120555741,
            120556140,
            120587344,
            120581865,
            120550352,
            120557511,
            120561248,
            120559894
        ],
        "A": [
            120538111,
            120534681,
            120538291,
            120538440,
            120536907,
            120535163,
            120537026,
            120546671,
            120535419,
            120535827,
            120537631,
            120535887,
            120540241,
            120536295,
            120551816,
            120535724,
            120539352,
            120540330,
            120541623
        ]
    },
    "name": "D. Inverse Inversions",
    "statement": "You were playing with permutation p of length n, but you lost it in\r\nBlair, Alabama!Luckily, you remember some information about the\r\npermutation. More specifically, you remember an array b of length n,\r\nwhere b_i is the number of indices j such that j < i and p_j > p_i.You\r\nhave the array b, and you want to find the permutation p. However, your\r\nmemory isn\u2019t perfect, and you constantly change the values of b as you\r\nlearn more. For the next q seconds, one of the following things happen:\r\n1 i x you realize that b_i is equal to x; 2 i you need to find the value\r\nof p_i. If there\u2019s more than one answer, print any. It can be proven\r\nthat there\u2019s always at least one possible answer under the constraints\r\nof the problem. Answer the queries, so you can remember the array!\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"-Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nconst int nmax=ten(5)+10;\nint ans[nmax];\n\nvoid work(int l,int r,int v){\n\trng(i,l,r)ans[i]+=(ans[i]>=v);\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvvc<pi> bs(n);\n\trep(i,n)bs[i].eb(0,read());\n\tint q;cin>>q;\n\tint s=0;\n\tvvc<pi> qs(n);\n\trep(_,q){\n\t\tint t;cin>>t;\n\t\tif(t==1){\n\t\t\tint i,x;cin>>i>>x;\n\t\t\ti--;\n\t\t\tbs[i].eb(s,x);\n\t\t}else{\n\t\t\tint i;cin>>i;\n\t\t\ti--;\n\t\t\tqs[i].eb(s++,bs[i].back().b);\n\t\t}\n\t}\n\trep(i,n){\n\t\tbs[i].eb(s,-1);\n\t\trep(j,si(bs[i])-1){\n\t\t\twork(bs[i][j].a,bs[i][j+1].a,bs[i][j].b);\n\t\t}\n\t\tfor(auto [j,v]:qs[i])\n\t\t\tans[j]=v;\n\t}\n\trep(i,s)print(n-ans[i]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Inverse Inversions.json",
    "editorial_link": "https://codeforces.com//blog/entry/92199",
    "editorial": "We\u00e2\u0080\u0099ll assume the arrays and the final permutation are 0-indexed from\r\nthis point forward (you can shift values accordingly at the end). Let\u00e2\u0080\u0099s\r\nstart with calculating the final array, without any updates. Let be the\r\nnumber of indices such that and . It is easy to see that . Now imagine\r\nsweeping from left to right, maintaining the array . Let\u00e2\u0080\u0099s say you\u00e2\u0080\u0099re\r\ncurrently at index , and you have a list of all indices , where the\r\nlocation of some index is the value of . You know that must be the -th\r\nout of those (after inserting it into the list) as the smallest values\r\nmust be before it. This means that you can insert index at the position\r\nin the list, and you need to find the final location of index in each\r\nquery. Now, let\u00e2\u0080\u0099s support updates and queries. The first thing to note\r\nis that you don\u00e2\u0080\u0099t need the entire array in each query, you just need to\r\nquery some specific element. Assume you\u00e2\u0080\u0099re querying the -th element of\r\nthe array. Let\u00e2\u0080\u0099s repeat the algorithm mentioned above except instead of\r\nstoring the lists, you only store the location of the -th element for\r\neach query. Now, you keep some variable which stores the location of the\r\n-th element in the list. It is initialized to , as it is first inserted\r\nto the -th position. Now you sweep through all indices where , and check\r\nif is changed by the insert. This is only true if . This allows for\r\nupdates but queries, which is still too slow. To speed this up, let\u00e2\u0080\u0099s\r\nuse sqrt-decomp. Divide the array into multiple blocks. For each block,\r\nlet\u00e2\u0080\u0099s store an array where represents the final value of the variable if\r\nit passes through the block. If we have this array, you can loop over\r\nall of the blocks and \"jump\" over them using the next array, querying in\r\ntime, where is the size of the block. But how do you calculate and\r\nupdate the array? Initially, you can calculate the next array in , by\r\ngoing to each index and naively tracking its position. Updating it is\r\nharder. One observation to make is that for each index inside a block,\r\nthere is some value such that if it will be changed by the index,\r\notherwise it will not. You can find all of those values for a single\r\nblock using a binary indexed tree: sweep from left to right, query for\r\nthe the smallest update using a lower bound on the BIT, and increment a\r\nsuffix. Then, you can increment all of those suffixes in the next array\r\nusing another BIT, which would lead to , as queries are and updates are\r\n, which will probably be too slow.To make this faster, note that the\r\nsuffix that each element is responsible changes by for all non-updated\r\nelements. This means that you can update the next array in for these\r\nelements. However, the updated element\u00e2\u0080\u0099s suffix might change by . To\r\naccount for this, you can use another square root decomposition on the\r\nnext array, which allows for range updates, point updates, and point\r\nqueries. This means that updates will remain , but queries will become ,\r\nso the final complexity is with the right blocksize, which is definitely\r\nfast enough (the model solution runs in seconds).If you know of any\r\nfaster solutions ( or even let us know down in the comments).\r\n"
}