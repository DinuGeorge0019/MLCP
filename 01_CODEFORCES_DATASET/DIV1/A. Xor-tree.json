{
    "link": "https://codeforces.com//contest/429/problem/A",
    "problemId": "9402",
    "problem_idx": "A",
    "shortId": "429A",
    "contest_number": "429",
    "problem_submissions": {
        "E": [
            6595809,
            6600093,
            6592978,
            6601793,
            6652557,
            6599111,
            6619551,
            6619545,
            6597254,
            6597744
        ],
        "C": [
            6593728,
            6600070,
            6592280,
            6592740,
            6600977,
            6600868,
            6594386,
            6592397,
            6594791,
            6593656,
            6596025,
            6593807,
            6593862,
            6598107,
            6594449,
            6598559,
            6594937,
            6592148,
            6594524,
            6592432,
            6594909,
            6590473
        ],
        "D": [
            6591664,
            6600092,
            6591240,
            6590624,
            6590639,
            6591834,
            6591461,
            6591644,
            6590500,
            6592190,
            6591828,
            6591578,
            6591777,
            6592587,
            27994201,
            6591983,
            6594641,
            6604627,
            6593023,
            6594793,
            6591937,
            6593041
        ],
        "B": [
            6589690,
            6600091,
            6589488,
            6589367,
            6588962,
            6590036,
            6588367,
            6590786,
            6591308,
            6589466,
            6590642,
            6589551,
            6589761,
            6589966,
            6589108,
            6590082,
            6589028,
            6590294,
            6589190,
            6595125
        ],
        "A": [
            6588164,
            6600088,
            6588109,
            6588114,
            6588105,
            6588288,
            6588966,
            6588346,
            6592136,
            6588117,
            6588421,
            6588130,
            6588989,
            6588112,
            27994125,
            6589842,
            6588200,
            6588169,
            6588529,
            6590124,
            6593587
        ]
    },
    "name": "A. Xor-tree",
    "statement": "Iahub is very proud of his recent discovery, propagating trees. Right\r\nnow, he invented a new tree, called xor-tree. After this new\r\nrevolutionary discovery, he invented a game for kids which uses\r\nxor-trees.The game is played on a tree having nodes, numbered from to .\r\nEach node has an initial value , which is either 0 or 1. The root of the\r\ntree is node 1.One can perform several (possibly, zero) operations on\r\nthe tree during the game. The only available type of operation is to\r\npick a node . Right after someone has picked node , the value of node\r\nflips, the values of sons of remain the same, the values of sons of sons\r\nof flips, the values of sons of sons of sons of remain the same and so\r\non.The goal of the game is to get each node to have value , which can\r\nalso be only 0 or 1. You need to reach the goal of the game by using\r\nminimum number of operations.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nvector<int> g[100500];\nint a[100500];\nint b[100500];\nvector<int> ans;\n\nvoid go(int v, int p, int x, int y) {\n\ta[v] ^= x;\n\tif (a[v] != b[v]) {\n\t\tans.pb(v + 1);\n\t\tx ^= 1;\n\t}\t\n\tforn(i, g[v].size())\n\t\tif (g[v][i] != p)\n\t\t\tgo(g[v][i], v, y, x);\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tscanf(\"%d\", &n);\n\tforn(i, n-1) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\tforn(i, n)\n\t\tscanf(\"%d\", &b[i]);\n\tans.clear();\n\tgo(0, -1, 0, 0);\n\tprintf(\"%d\\n\", ans.size());\n\tforn(i, ans.size())\n\t\tprintf(\"%d\\n\", ans[i]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "trees"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Xor-tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/12265",
    "editorial": "There is something to learn from propagating tree problem, used in round\r\n225. It s how the special operation works. I ll copy paste the\r\nexplanation from there (with some modification, corresponding to the\r\nproblem): Let s define level of a node the number of edges in the path\r\nfrom root to the node. Root (node 1) is at level 0, sons of root are at\r\nlevel 1, sons of sons of root are at level 2 and so on. Now suppose you\r\nwant to do a special operation to a node x. What nodes from subtree of x\r\nwill be flipped? Obviously, x will be first, being located at level L.\r\nSons of x, located at level L + 1 will not be flipped. Sons of sons,\r\nlocated at level L + 2, will be flipped again. So, nodes from subtree of\r\nx located at levels L, L + 2, L + 4, ... will be flipped, and nodes\r\nlocated at levels L + 1, L + 3, L + 5 won t be flipped. Let s take those\r\nvalues of L modulo 2. All nodes having remainder L modulo 2 will be\r\nflipped, and nodes having reminder (L + 1) modulo 2 will not. In other\r\nwords, for a fixed x, at a level L, let y a node from subtree of x, at\r\nlevel L2. If L and L2 have same parity, y will be flipped, otherwise it\r\nwon t. We ll use this fact later. For now, let s think what should be\r\nour first operation. Let s consider some nodes {x1, x2, ..., xk} with\r\nproperty that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk\r\nand parity of levels of these nodes is the same. Suppose by now we fixed\r\n{x1, x2, ..., xk-1} (their current value is equal to their goal value),\r\nbut xk is still not fixed. After some time, we ll have to fix xk. Now,\r\nby doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence\r\nunfixed. We ve done some useless operations, so our used strategy is not\r\nthe one that gives minimal number of operations. What we learn from this\r\nexample? Suppose I want to currently fix a node X. There is no point to\r\nfix it now, unless all ancestors Y of X with property level(Y) =\r\nlevel(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed\r\nyet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer\r\nis yes, as future operations done on Y won t affect X. But, by same\r\nlogic, I can firstly fix Y and then fix X, because again operations done\r\non Y won t affect X. We get a nice property: there is no point to make\r\nan operation on a node X unless all ancestors of X are fixed. How can we\r\nuse this property? What should be the first operation? We know that node\r\n1 is the root, hence it always won t have any ancestor. All other nodes\r\nmight have sometimes not fixed ancestors, but we know for sure, for\r\nbeginning, node 1 won t have any unfixed ancestor (because it won t have\r\nany). So, for beginning we can start with node 1. More, suppose node 1\r\nis unfixed. The only way to fix it is to make an operation on it. Since\r\nit s unfixed and this is the only way to fix it, you ll be obligated to\r\ndo this operation. This means, in an optimal sequence of operations, you\r\nll be obligated to do this operation, too. So, if node 1 was unfixed, we\r\ndid an operation on it. If it was already fixed, we re done with it.\r\nWhat are next nodes we know for sure that will have all ancestors fixed?\r\nSons of 1, because they have only one ancestor (node 1), which we know\r\nit s fixed. We can only fix them by doing operations of them (doing\r\noperations on node 1 / sons of them won t affect them). Since eventually\r\nthey have to be fixed and only way to be fixed is to do an operation on\r\nthem, in an optimal sequence of operations, we ll have to make\r\noperations on them. Let s move on. What are next nodes that we know for\r\nsure all ancestors of them will be fixed? Sons of sons of 1. We can fix\r\nthem by doing an operation of them, or by doing an operation on 1. But\r\ndoing an operation on 1 isn t helpful, because even if it fixes this\r\nnode, it unfixes 1. Then, you ll have to do one more operation on 1,\r\nwhich will unfix current node, so we do two useless operations. It turns\r\nout, the only way to fix them is to do an operation on them. Generally,\r\nsuppose all ancestors of node x are fixed. We get the current value of\r\nnode x after the operations done on ancestors of x. If the current value\r\nis not the expected one, we ll have to do an operation on node x (this\r\nis the only way to fix the node x). Now, after node x is fixed, we can\r\nprocess sons of it. This strategy guarantees minimal number of\r\noperations, because we do an operation only when we re forced to do it.\r\nThis leads immediately to an O(N ^ 2) algorithm, by every time we need\r\nto do an operation to update it to nodes from its subtree. How to get\r\nO(N)? Suppose we are at node x and want to know its current value after\r\noperations done for its ancestors. Obviously, it is defined by initial\r\nvalue. If we know number of operations done so far by even levels for\r\nits ancestors, number of operations done so far by odd levels and\r\ncurrent level, we can determine the current value. Suppose these values\r\nare (initial_value, odd_times, even_times, level). We observe that 2\r\noperations cancel each other, so we can take this number modulo 2. If\r\nlevel mod 2 = 0, then only even_times will matter, and current_value =\r\n(initial_value + even_times)\r\n"
}