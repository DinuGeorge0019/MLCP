{"link": "https://codeforces.com//contest/429/problem/A", "problemId": "9402", "problem_idx": "A", "shortId": "429A", "contest_number": "429", "problem_submissions": {"E": [6595809, 6600093, 6592978, 6601793, 6652557, 6599111, 6619551, 6619545, 6597254, 6597744], "C": [6593728, 6600070, 6592280, 6592740, 6600977, 6600868, 6594386, 6592397, 6594791, 6593656, 6596025, 6593807, 6593862, 6598107, 6594449, 6598559, 6594937, 6592148, 6594524, 6592432, 6594909, 6590473], "D": [6591664, 6600092, 6591240, 6590624, 6590639, 6591834, 6591461, 6591644, 6590500, 6592190, 6591828, 6591578, 6591777, 6592587, 27994201, 6591983, 6594641, 6604627, 6593023, 6594793, 6591937, 6593041], "B": [6589690, 6600091, 6589488, 6589367, 6588962, 6590036, 6588367, 6590786, 6591308, 6589466, 6590642, 6589551, 6589761, 6589966, 6589108, 6590082, 6589028, 6590294, 6589190, 6595125], "A": [6588164, 6600088, 6588109, 6588114, 6588105, 6588288, 6588966, 6588346, 6592136, 6588117, 6588421, 6588130, 6588989, 6588112, 27994125, 6589842, 6588200, 6588169, 6588529, 6590124, 6593587]}, "name": "A. Xor-tree", "statement": "Iahub is very proud of his recent discovery, propagating trees. Right\r\nnow, he invented a new tree, called xor-tree. After this new\r\nrevolutionary discovery, he invented a game for kids which uses\r\nxor-trees.The game is played on a tree having nodes, numbered from to .\r\nEach node has an initial value , which is either 0 or 1. The root of the\r\ntree is node 1.One can perform several (possibly, zero) operations on\r\nthe tree during the game. The only available type of operation is to\r\npick a node . Right after someone has picked node , the value of node\r\nflips, the values of sons of remain the same, the values of sons of sons\r\nof flips, the values of sons of sons of sons of remain the same and so\r\non.The goal of the game is to get each node to have value , which can\r\nalso be only 0 or 1. You need to reach the goal of the game by using\r\nminimum number of operations.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nvector<int> g[100500];\nint a[100500];\nint b[100500];\nvector<int> ans;\n\nvoid go(int v, int p, int x, int y) {\n\ta[v] ^= x;\n\tif (a[v] != b[v]) {\n\t\tans.pb(v + 1);\n\t\tx ^= 1;\n\t}\t\n\tforn(i, g[v].size())\n\t\tif (g[v][i] != p)\n\t\t\tgo(g[v][i], v, y, x);\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tscanf(\"%d\", &n);\n\tforn(i, n-1) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\tforn(i, n)\n\t\tscanf(\"%d\", &b[i]);\n\tans.clear();\n\tgo(0, -1, 0, 0);\n\tprintf(\"%d\\n\", ans.size());\n\tforn(i, ans.size())\n\t\tprintf(\"%d\\n\", ans[i]);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "trees"], "dificulty": "1300", "interactive": false}