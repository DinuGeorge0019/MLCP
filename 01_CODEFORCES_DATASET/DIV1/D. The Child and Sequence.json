{
    "link": "https://codeforces.com//contest/438/problem/D",
    "problemId": "9966",
    "problem_idx": "D",
    "shortId": "438D",
    "contest_number": "438",
    "problem_submissions": {
        "D": [
            6770791,
            6768533,
            6771704,
            6771558,
            6772564,
            6771497,
            6770667,
            6772913,
            6771311,
            6770765,
            6771398,
            6772501,
            6771788,
            6773163,
            6773332,
            6768886,
            6769122
        ],
        "C": [
            6769384,
            6771772,
            6770600,
            6769986,
            6769707,
            6770322,
            6773155,
            6770624,
            6772819,
            6772764,
            6772925,
            6771300,
            6773617,
            6772385,
            6771439,
            6774162
        ],
        "B": [
            6766623,
            6766692,
            6766851,
            6766923,
            6766505,
            6769047,
            6767842,
            6768520,
            6767461,
            6766938,
            6767311,
            6768462,
            6767303,
            6769160,
            6766952,
            6767030,
            6767555
        ],
        "A": [
            6765683,
            6765687,
            6765701,
            6765754,
            6767149,
            6765703,
            6766656,
            6766754,
            6766105,
            6765753,
            6765896,
            6765923,
            6765796,
            6768072,
            6766138,
            6765696,
            6765784
        ],
        "E": [
            6784450,
            6784415,
            39812196,
            39812172,
            6951957
        ]
    },
    "name": "D. The Child and Sequence",
    "statement": "At the children\u2019s day, the child came to Picks\u2019s house, and messed his\r\nhouse up. Picks was angry at him. A lot of important things were lost,\r\nin particular the favorite sequence of Picks.Fortunately, Picks\r\nremembers how to repair the sequence. Initially he should create an\r\ninteger array . Then he should perform a sequence of operations. An\r\noperation can be one of the following: Print operation . Picks should\r\nwrite down the value of . Modulo operation . Picks should perform\r\nassignment for each . Set operation . Picks should set the value of to\r\n(in other words perform an assignment ). Can you help Picks to perform\r\nthe whole sequence of operations?\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME \"\"\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\" #x \"] Time = %.3lfs\\n\",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef linux\n#define LLD \"%lld\"\n#else\n#define LLD \"%I64d\"\n#endif\n\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, ll> pli;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst double INF = inf;\nconst double EPS = eps;\n\npli operator + (const pli& a, const pli& b)\n{\n  return mp(a.first+b.first,max(a.second,b.second));\n}\n\npli A[(1<<18)+100];\n                     \nll sum (int l, int r)\n{\n  l+=(1<<17), r+=(1<<17);\n  ll res=0;\n // cerr<<l<<\"  :::  \"<<r<<endl;\n  while (l<r)\n  {\n    //cerr<<r-1<<\" \"<<A[r-1].first<<endl;\n    if (l&1)\n      res+=A[l].first, l++;\n    if (r&1)\n      r--, res+=A[r].first;\n    l>>=1, r>>=1;\n  }\n  return res;\n}\n\nvoid mod (int v, int L, int R, int l, int r, int x)\n{\n  if (R<=l || r<=L || A[v].second<x)\n    return;\n  if (R-L==1)\n  {\n    #ifdef LOCAL\n    assert(A[v].second==A[v].first && A[v].second>=x);\n    #endif\n    //cerr<<\"?? \"<<L<<\" \"<<x<<\" \"<<A[v].first<<\"    \"<<v<<endl;\n    A[v].second%=x;\n    A[v].first=A[v].second;\n    return;\n  }\n  mod(v<<1,L,(L+R)>>1,l,r,x);\n  mod((v<<1)|1,(L+R)>>1,R,l,r,x);\n  A[v]=A[v<<1]+A[(v<<1)|1];\n}\n\nint main()\n{\n  int n, m, l, r, i, x, v, tp;\n  #ifdef LOCAL\n  freopen(TASKNAME\".in\",\"r\",stdin);\n  freopen(TASKNAME\".out\",\"w\",stdout);\n  #endif\n  scanf(\"%d%d\", &n, &m);\n  for (i=0; i<n; i++)\n    scanf(\"%d\", &v), A[i+(1<<17)]=mp(v,v);\n  for (i=(1<<17)-1; i>0; i--)\n    A[i]=A[2*i]+A[2*i+1];\n  while (m) \n  {\n    m--;\n    scanf(\"%d\", &tp);\n    if (tp==1)\n    {\n      scanf(\"%d%d\", &l, &r), l--;\n      printf(LLD\"\\n\", sum(l,r));\n      continue;\n    }\n    if (tp==2)\n    {\n      scanf(\"%d%d%d\", &l, &r, &x), l--;\n      mod(1,0,(1<<17),l,r,x);      \n      continue;\n    }\n    assert(tp==3);\n    scanf(\"%d%d\", &v, &x), v+=(1<<17)-1, A[v]=mp(x,x), v>>=1;\n    while (v)\n      A[v]=A[2*v]+A[2*v+1], v>>=1;\n  }\n  TIMESTAMP(end);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. The Child and Sequence.json",
    "editorial_link": "https://codeforces.com/blog/entry/12513",
    "editorial": "The important idea of this problem is the property of . Let . So, . If ,\r\nremains to be . If , . We realize every time a change happening on ,\r\nwill be reduced by at least a half. So let the energy of become . Every\r\ntime when we modify , it may take at least energy. The initial energy of\r\nthe sequence is . We use a segment tree to support the query to the\r\nmaximum among an interval. When we need to deal with the operation , we\r\nmodify the maximum of the segment until it is less than . Now let\u00e2\u0080\u0099s face\r\nwith the operation 3. Every time we modify an element on the segment\r\ntree, we\u00e2\u0080\u0099ll charge a element with power. So the total time complexity is\r\n: . By the way, we can extend the operation to assign all the elements\r\nin the interval to the same number in the same time complexity. This is\r\nan interesting idea also, but a bit harder. You can think of it.\r\n"
}