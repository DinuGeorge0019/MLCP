{"link": "https://codeforces.com//contest/573/problem/D", "problemId": "34313", "problem_idx": "D", "shortId": "573D", "contest_number": "573", "problem_submissions": {"E": [12759251, 12766903, 12766685, 12854212], "C": [12753961, 12751834, 12752631, 12751871, 12753878, 12754621, 12753383, 12752808, 12753460, 12750581, 12750687, 12754051, 12757263, 12753734, 12752897, 12751281, 12753745, 12753332], "B": [12746992, 12747515, 12746798, 12748316, 12747498, 12747954, 12747704, 12747330, 12747866, 12747572, 12747495, 12748230, 12747423, 12748530, 12748216, 12747086, 12747056, 12748571], "A": [12746189, 12746077, 12746084, 12746660, 12746402, 12746165, 12746157, 12746206, 12746195, 12746103, 12746141, 12746264, 12746158, 12746252, 12746081, 12746225, 12746120, 12746512], "D": [12760293, 12767357, 12767345, 12767321, 12767302, 12767261, 12766285, 12766274, 12759069, 12759185, 12761792, 12787796, 12787738, 12787732, 12762112, 12766448, 12762456, 12761429, 12791178, 12769647, 12769635]}, "name": "D. Bear and Cavalry", "statement": "Would you want to fight against bears riding horses? Me neither.Limak is\r\na grizzly bear. He is general of the dreadful army of Bearland. The most\r\nimportant part of an army is cavalry of course.Cavalry of Bearland\r\nconsists of warriors and horses. -th warrior has strength and -th horse\r\nhas strength . Warrior together with his horse is called a unit.\r\nStrength of a unit is equal to multiplied strengths of warrior and\r\nhorse. Total strength of cavalry is equal to sum of strengths of all\r\nunits. Good assignment of warriors and horses makes cavalry truly\r\npowerful.Initially, -th warrior has -th horse. You are given queries. In\r\neach query two warriors swap their horses with each other.General Limak\r\nmust be ready for every possible situation. What if warriors weren\u2019t\r\nallowed to ride their own horses? After each query find the maximum\r\npossible strength of cavalry if we consider assignments of all warriors\r\nto all horses that no warrior is assigned to his own horse (it can be\r\nproven that for there is always at least one correct assignment).Note\r\nthat we can\u2019t leave a warrior without a horse.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate<typename TH>\nvoid debug_vars(const char* data, TH head){\n    cerr << data << \"=\" << head << \"\\n\";\n}\n\ntemplate<typename TH, typename... TA>\nvoid debug_vars(const char* data, TH head, TA... tail){\n    while(*data != ',') cerr << *data++;\n    cerr << \"=\" << head << \",\";\n    debug_vars(data+1, tail...);\n}\n\n#ifdef LOCAL\n#define debug(...) debug_vars(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) {}\n#endif\n\n/////////////////////////////////////////////////////////\n\n\nconst LL Infty = 1e18;\nconst int MaxN = (1<<15);\n\nstruct Node {\n    LL scores[3][3];\n    int left, right;\n\n    Node(){\n        for(int i = 0; i < 3; i++){\n            for(int j =0 ; j < 3; j++){\n                scores[i][j] = -Infty;\n            }\n        }\n        left = right = -1;\n    }\n};\n\n\nint badHorse[MaxN];\nint mappingMen[MaxN];\nint mappingHorses[MaxN];\nLL pointsMen[MaxN], pointsHorses[MaxN];\n\nLL find_best(int left, int right){\n    if(left == right+1) return 0;\n    assert(left <= right);\n    assert(right - left <= 3);\n    \n    vector<int> perm(right-left+1);\n    iota(perm.begin(), perm.end(), 0);\n    LL result = -Infty;\n\n    do {\n        bool ok = true;\n        for(int i = 0; i < (int)perm.size(); i++){\n            if(badHorse[left+i] == left+perm[i]) ok = false;\n        }\n        if(ok){\n            LL nowRes = 0;\n            for(int i = 0; i < (int)perm.size(); i++){\n                nowRes += pointsMen[left+i] * pointsHorses[left+perm[i]];\n            }\n            result = max(result, nowRes);\n        }\n    } while(next_permutation(perm.begin(), perm.end()));\n    debug(\"find_best\", left, right, result);\n    return result;\n}\n\nNode merge(const Node& L, const Node& R){\n    if(L.left == -1) return R;\n    if(R.left == -1) return L;\n\n    Node result;\n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++){\n            result.scores[i][j] = -Infty;\n        }\n    }\n\n    for(int finCutL = 0; finCutL < 3; finCutL++){\n        for(int finCutR = 0; finCutR < 3; finCutR++){\n            for(int midCutR = 0; midCutR < 3; midCutR++){\n                for(int midCutL = 0; midCutL < 3; midCutL++){\n                    int dist = midCutR + midCutL;\n                    if(dist != 0 && dist != 2 && dist != 3) continue;\n                    int lft = L.right - midCutR + 1,\n                        rgt = R.left + midCutL - 1;\n                    result.scores[finCutL][finCutR] =\n                        max(result.scores[finCutL][finCutR],\n                                L.scores[finCutL][midCutR]\n                              + R.scores[midCutL][finCutR]\n                              + find_best(lft, rgt));\n                    debug(finCutL, finCutR, midCutR, midCutL,\n                            result.scores[finCutL][finCutR]);\n                }\n            }\n        }\n    }\n\n    result.left = L.left;\n    result.right = R.right;\n    return result;\n}\n\n\nint N, Q;\n\nvoid input(){\n    ios_base::sync_with_stdio(false);\n    cin >> N >> Q;\n    for(int i = 0; i < N; i++){\n        cin >> pointsMen[i];\n    }\n    for(int i = 0; i < N; i++){\n        cin >> pointsHorses[i];\n    }\n}\n\nvoid preprocess_arrays(){\n    vector<int> orderMen(N);\n    iota(orderMen.begin(), orderMen.end(), 0);\n    sort(orderMen.begin(), orderMen.end(), [&](int lhs, int rhs){\n                return make_pair(pointsMen[lhs], lhs)\n                     < make_pair(pointsMen[rhs], rhs);\n            });\n\n    for(int i = 0; i < N; i++){\n        mappingMen[orderMen[i]+1] = i;\n    }\n\n\n    vector<int> orderHorses(N);\n    iota(orderHorses.begin(), orderHorses.end(), 0);\n    sort(orderHorses.begin(), orderHorses.end(), [&](int lhs, int rhs){\n                return make_pair(pointsHorses[lhs], lhs)\n                     < make_pair(pointsHorses[rhs], rhs);\n            });\n    for(int i = 0; i < N; i++){\n        mappingHorses[orderHorses[i]+1] = i;\n    }\n\n    for(int i = 1; i <= N; i++){\n        badHorse[mappingMen[i]] = mappingHorses[i];\n    }\n\n    sort(pointsHorses, pointsHorses+N);\n    sort(pointsMen, pointsMen+N);\n}\n\n\nNode tree[MaxN];\nconst int Base = MaxN/2;\n\n\nvoid propag(int L, int R){\n    L /= 2; R /= 2;\n    while(L){\n        for(int i = L; i <= R; i++){\n            tree[i] = merge(tree[i*2], tree[i*2+1]);\n            debug(i, tree[i].scores[0][0]);\n        }\n        L /= 2; R /= 2;\n    }\n}\n\nvoid recalc_leaf(int num){\n    int left = num*4,\n        right = min(N-1, num*4+3);\n    int len = right-left+1;\n\n    for(int cutL = 0; cutL < 3; cutL++){\n        for(int cutR = 0; cutR < 3; cutR++){\n            if(cutL+cutR > len) continue;\n            tree[Base+num].scores[cutL][cutR] = find_best(left+cutL, right-cutR);\n            debug(num, cutL, cutR, tree[Base+num].scores[cutL][cutR]);\n        }\n    }\n}\n\nvoid recalc_up(int num){\n    num = (Base+num)/2;\n    while(num){\n        tree[num] = merge(tree[num*2], tree[num*2+1]);\n        num /= 2;\n        debug(num, tree[num].scores[0][0]);\n    }\n}\n\n\nint main(){\n    input();\n    preprocess_arrays();\n    for(int i = 0; i < N; i++){\n        debug(i, badHorse[i]);\n    }\n\n    for(int i = 0; i < (N+3)/4; i++){\n        recalc_leaf(i);\n        \n        tree[Base+i].left = i*4;\n        tree[Base+i].right = min(N-1, i*4+3);\n    }\n\n    propag(Base, Base+(N+3)/4);\n\n    debug(tree[1].scores[0][0]);\n    for(int query = 1; query <= Q; query++){\n        int p, q;\n        cin >> p >> q;\n        p = mappingMen[p];\n        q = mappingMen[q];\n        swap(badHorse[p], badHorse[q]);\n        recalc_leaf(p/4); recalc_up(p/4);\n        recalc_leaf(q/4); recalc_up(q/4);\n\n        cout << tree[1].scores[0][0] << \"\\n\";\n    }\n}\n"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "dp"], "dificulty": "3000", "interactive": false}