{
    "link": "https://codeforces.com//contest/573/problem/D",
    "problemId": "34313",
    "problem_idx": "D",
    "shortId": "573D",
    "contest_number": "573",
    "problem_submissions": {
        "E": [
            12759251,
            12766903,
            12766685,
            12854212
        ],
        "C": [
            12753961,
            12751834,
            12752631,
            12751871,
            12753878,
            12754621,
            12753383,
            12752808,
            12753460,
            12750581,
            12750687,
            12754051,
            12757263,
            12753734,
            12752897,
            12751281,
            12753745,
            12753332
        ],
        "B": [
            12746992,
            12747515,
            12746798,
            12748316,
            12747498,
            12747954,
            12747704,
            12747330,
            12747866,
            12747572,
            12747495,
            12748230,
            12747423,
            12748530,
            12748216,
            12747086,
            12747056,
            12748571
        ],
        "A": [
            12746189,
            12746077,
            12746084,
            12746660,
            12746402,
            12746165,
            12746157,
            12746206,
            12746195,
            12746103,
            12746141,
            12746264,
            12746158,
            12746252,
            12746081,
            12746225,
            12746120,
            12746512
        ],
        "D": [
            12760293,
            12767357,
            12767345,
            12767321,
            12767302,
            12767261,
            12766285,
            12766274,
            12759069,
            12759185,
            12761792,
            12787796,
            12787738,
            12787732,
            12762112,
            12766448,
            12762456,
            12761429,
            12791178,
            12769647,
            12769635
        ]
    },
    "name": "D. Bear and Cavalry",
    "statement": "Would you want to fight against bears riding horses? Me neither.Limak is\r\na grizzly bear. He is general of the dreadful army of Bearland. The most\r\nimportant part of an army is cavalry of course.Cavalry of Bearland\r\nconsists of warriors and horses. -th warrior has strength and -th horse\r\nhas strength . Warrior together with his horse is called a unit.\r\nStrength of a unit is equal to multiplied strengths of warrior and\r\nhorse. Total strength of cavalry is equal to sum of strengths of all\r\nunits. Good assignment of warriors and horses makes cavalry truly\r\npowerful.Initially, -th warrior has -th horse. You are given queries. In\r\neach query two warriors swap their horses with each other.General Limak\r\nmust be ready for every possible situation. What if warriors weren\u2019t\r\nallowed to ride their own horses? After each query find the maximum\r\npossible strength of cavalry if we consider assignments of all warriors\r\nto all horses that no warrior is assigned to his own horse (it can be\r\nproven that for there is always at least one correct assignment).Note\r\nthat we can\u2019t leave a warrior without a horse.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate<typename TH>\nvoid debug_vars(const char* data, TH head){\n    cerr << data << \"=\" << head << \"\\n\";\n}\n\ntemplate<typename TH, typename... TA>\nvoid debug_vars(const char* data, TH head, TA... tail){\n    while(*data != ',') cerr << *data++;\n    cerr << \"=\" << head << \",\";\n    debug_vars(data+1, tail...);\n}\n\n#ifdef LOCAL\n#define debug(...) debug_vars(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) {}\n#endif\n\n/////////////////////////////////////////////////////////\n\n\nconst LL Infty = 1e18;\nconst int MaxN = (1<<15);\n\nstruct Node {\n    LL scores[3][3];\n    int left, right;\n\n    Node(){\n        for(int i = 0; i < 3; i++){\n            for(int j =0 ; j < 3; j++){\n                scores[i][j] = -Infty;\n            }\n        }\n        left = right = -1;\n    }\n};\n\n\nint badHorse[MaxN];\nint mappingMen[MaxN];\nint mappingHorses[MaxN];\nLL pointsMen[MaxN], pointsHorses[MaxN];\n\nLL find_best(int left, int right){\n    if(left == right+1) return 0;\n    assert(left <= right);\n    assert(right - left <= 3);\n    \n    vector<int> perm(right-left+1);\n    iota(perm.begin(), perm.end(), 0);\n    LL result = -Infty;\n\n    do {\n        bool ok = true;\n        for(int i = 0; i < (int)perm.size(); i++){\n            if(badHorse[left+i] == left+perm[i]) ok = false;\n        }\n        if(ok){\n            LL nowRes = 0;\n            for(int i = 0; i < (int)perm.size(); i++){\n                nowRes += pointsMen[left+i] * pointsHorses[left+perm[i]];\n            }\n            result = max(result, nowRes);\n        }\n    } while(next_permutation(perm.begin(), perm.end()));\n    debug(\"find_best\", left, right, result);\n    return result;\n}\n\nNode merge(const Node& L, const Node& R){\n    if(L.left == -1) return R;\n    if(R.left == -1) return L;\n\n    Node result;\n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++){\n            result.scores[i][j] = -Infty;\n        }\n    }\n\n    for(int finCutL = 0; finCutL < 3; finCutL++){\n        for(int finCutR = 0; finCutR < 3; finCutR++){\n            for(int midCutR = 0; midCutR < 3; midCutR++){\n                for(int midCutL = 0; midCutL < 3; midCutL++){\n                    int dist = midCutR + midCutL;\n                    if(dist != 0 && dist != 2 && dist != 3) continue;\n                    int lft = L.right - midCutR + 1,\n                        rgt = R.left + midCutL - 1;\n                    result.scores[finCutL][finCutR] =\n                        max(result.scores[finCutL][finCutR],\n                                L.scores[finCutL][midCutR]\n                              + R.scores[midCutL][finCutR]\n                              + find_best(lft, rgt));\n                    debug(finCutL, finCutR, midCutR, midCutL,\n                            result.scores[finCutL][finCutR]);\n                }\n            }\n        }\n    }\n\n    result.left = L.left;\n    result.right = R.right;\n    return result;\n}\n\n\nint N, Q;\n\nvoid input(){\n    ios_base::sync_with_stdio(false);\n    cin >> N >> Q;\n    for(int i = 0; i < N; i++){\n        cin >> pointsMen[i];\n    }\n    for(int i = 0; i < N; i++){\n        cin >> pointsHorses[i];\n    }\n}\n\nvoid preprocess_arrays(){\n    vector<int> orderMen(N);\n    iota(orderMen.begin(), orderMen.end(), 0);\n    sort(orderMen.begin(), orderMen.end(), [&](int lhs, int rhs){\n                return make_pair(pointsMen[lhs], lhs)\n                     < make_pair(pointsMen[rhs], rhs);\n            });\n\n    for(int i = 0; i < N; i++){\n        mappingMen[orderMen[i]+1] = i;\n    }\n\n\n    vector<int> orderHorses(N);\n    iota(orderHorses.begin(), orderHorses.end(), 0);\n    sort(orderHorses.begin(), orderHorses.end(), [&](int lhs, int rhs){\n                return make_pair(pointsHorses[lhs], lhs)\n                     < make_pair(pointsHorses[rhs], rhs);\n            });\n    for(int i = 0; i < N; i++){\n        mappingHorses[orderHorses[i]+1] = i;\n    }\n\n    for(int i = 1; i <= N; i++){\n        badHorse[mappingMen[i]] = mappingHorses[i];\n    }\n\n    sort(pointsHorses, pointsHorses+N);\n    sort(pointsMen, pointsMen+N);\n}\n\n\nNode tree[MaxN];\nconst int Base = MaxN/2;\n\n\nvoid propag(int L, int R){\n    L /= 2; R /= 2;\n    while(L){\n        for(int i = L; i <= R; i++){\n            tree[i] = merge(tree[i*2], tree[i*2+1]);\n            debug(i, tree[i].scores[0][0]);\n        }\n        L /= 2; R /= 2;\n    }\n}\n\nvoid recalc_leaf(int num){\n    int left = num*4,\n        right = min(N-1, num*4+3);\n    int len = right-left+1;\n\n    for(int cutL = 0; cutL < 3; cutL++){\n        for(int cutR = 0; cutR < 3; cutR++){\n            if(cutL+cutR > len) continue;\n            tree[Base+num].scores[cutL][cutR] = find_best(left+cutL, right-cutR);\n            debug(num, cutL, cutR, tree[Base+num].scores[cutL][cutR]);\n        }\n    }\n}\n\nvoid recalc_up(int num){\n    num = (Base+num)/2;\n    while(num){\n        tree[num] = merge(tree[num*2], tree[num*2+1]);\n        num /= 2;\n        debug(num, tree[num].scores[0][0]);\n    }\n}\n\n\nint main(){\n    input();\n    preprocess_arrays();\n    for(int i = 0; i < N; i++){\n        debug(i, badHorse[i]);\n    }\n\n    for(int i = 0; i < (N+3)/4; i++){\n        recalc_leaf(i);\n        \n        tree[Base+i].left = i*4;\n        tree[Base+i].right = min(N-1, i*4+3);\n    }\n\n    propag(Base, Base+(N+3)/4);\n\n    debug(tree[1].scores[0][0]);\n    for(int query = 1; query <= Q; query++){\n        int p, q;\n        cin >> p >> q;\n        p = mappingMen[p];\n        q = mappingMen[q];\n        swap(badHorse[p], badHorse[q]);\n        recalc_leaf(p/4); recalc_up(p/4);\n        recalc_leaf(q/4); recalc_up(q/4);\n\n        cout << tree[1].scores[0][0] << \"\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dp"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Bear and Cavalry.json",
    "editorial_link": "https://codeforces.com//blog/entry/20040",
    "editorial": "Let\u00e2\u0080\u0099s sort warriors and horses separately (by strength). For a moment we\r\nforget about forbidden assignments. Inversion is a pair of warriors that\r\nstronger one is assigned to weaker horse. We don\u00e2\u0080\u0099t like inversions\r\nbecause it\u00e2\u0080\u0099s not worse to assign strong warriors to strong horses: for\r\nand . Note that repairing an inversion (by swapping assigned horses)\r\ndecreases number of inversions prove it by yourself (drawing a matching\r\nwith intersections could be helpful). Without any restrictions the\r\noptimal matching is when we assign -th warrior to -th horse (indexed\r\nafter sorting) to get no inversions. Let\u00e2\u0080\u0099s go back to version with\r\nforbidden connections. We have disjoint pairs which we can\u00e2\u0080\u0099t use. We\r\nwill prove that there exists an optimal assignment where (for all ) -th\r\nwarrior is assigned to -th horse where . Let\u00e2\u0080\u0099s take an optimal\r\nassignment. In case of ties we take the one with the lowest number of\r\ninversions. Let\u00e2\u0080\u0099s assume that is assigned to . There are at least\r\nwarriors assigned to horses with indices lower than . So we have at\r\nleast inversions with edge from to (warriors on the left, horses on the\r\nright): Above, connection warrior-horse is an edge. Then inversions are\r\nintersections. Swapping horses for warriors and (where belongs so some\r\nred edge) would decrease number of inversions and it wouldn\u00e2\u0080\u0099t decrease a\r\nscore. We took an optimal assignment so it means that it\u00e2\u0080\u0099s impossible to\r\nswap horses for them. Hence, for each red edge we can\u00e2\u0080\u0099t change pair\r\n(black, read) into the following blue edges: So one of these blue edges\r\nis forbidden. Three red edges generate three pairs of blue edges and in\r\neach pair at least one blue edge must be forbidden. Note that all six\r\nblue edges are different. All blue edges are incident to warrior or to\r\nhorse but only one forbidden edge can be incident to warrior and only\r\none forbidden edge can be incident to horse . We have at most two\r\nforbidden edges incident to them so it can\u00e2\u0080\u0099t be true that three blue\r\nedges are forbidden. By cases analysis we can prove something more that\r\nthere can be only three possible types of connecting in an optimal\r\nassignment. First type: can be connected to . Second: warrior with horse\r\nand warrior with horse . Third: warriors , and are connected with horses\r\n, , . It gives us solution with calculating queries independently with\r\ndefined as \"what result can we get for assigning everything with indices\r\nlower than ?\". To calculate we must know , and . It wasn\u00e2\u0080\u0099t intended\r\nsolution because we can get better complexity. We can create a segment\r\ntree and for intervals we should keep info \"result we can get for this\r\ninterval with 0/1/2 first and 0/1/2 last elements removed\". For an\r\ninterval we keep matrix 3x3 and actualizing forbidden edge for single\r\nconsists of: 1. calculating values of 3x3 matrix for a small interval\r\nwith 2. actualizing a tree with times multiplying matrices Complexity is\r\n.\r\n"
}