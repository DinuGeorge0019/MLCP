{"link": "https://codeforces.com//contest/827/problem/F", "problemId": "113850", "problem_idx": "F", "shortId": "827F", "contest_number": "827", "problem_submissions": {"F": [28447535, 28704912], "B": [28442493, 28434829, 28432891, 28434941, 28434124, 28440743, 28434219, 28434038, 28435758, 28436170, 28442340, 28436191, 28436588, 28434003, 28436389, 28434757, 28437055, 28448594, 28438989], "C": [28440487, 28438660, 28438441, 28438938, 28437666, 28446435, 28437809, 28439569, 28439405, 28439836, 28438472, 28441170, 28440770, 28437931, 28442353, 28442274, 28441410, 28437286, 28455031, 28442955], "E": [28436548, 28441080, 28466758, 28444795, 28441962, 28439200, 28445462, 28450329, 28446470, 28443820, 28444149, 28441607, 28444424, 28451564, 28465030, 28453083, 28453061, 28452855, 28445979, 28445398, 28447328, 28450262, 28443711, 28447639], "A": [28432871, 28432173, 28431465, 28433215, 28452981, 28437424, 28432872, 28451754, 28432696, 28432687, 28432382, 28432827, 28432606, 28431751, 28435184, 28437702, 28433063, 28446111, 28434053], "D": [28445554, 28441989, 28447486, 28446928, 28441195, 28445740, 28448719, 28454047, 28460505, 28543175, 28454400, 28446342, 28447977, 29638472, 28445305, 28443739]}, "name": "F. Dirty Arkady s Kitchen", "statement": "Arkady likes to walk around his kitchen. His labyrinthine kitchen\r\nconsists of several important places connected with passages.\r\nUnfortunately it happens that these passages are flooded with milk so\r\nthat it\u2019s impossible to pass through them. Namely, it\u2019s possible to pass\r\nthrough each passage in any direction only during some time interval.The\r\nlengths of all passages are equal and Arkady makes through them in one\r\nsecond. For security reasons, Arkady can never stop, also, he can\u2019t\r\nchange direction while going through a passage. In other words, if he\r\nstarts walking in some passage, he should reach its end and immediately\r\nleave the end.Today Arkady needs to quickly reach important place from\r\nplace . He plans to exit the place at time moment and reach the place as\r\nearly as he can. Please find the minimum time he should spend on his\r\nway.\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef int in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct eg{\n  in ot,l,r;\n  eg(in pot, in pl, in pr){\n    ot=pot;\n    l=pl;\n    r=pr;\n  }\n  bool operator<(const eg cp)const{\n    if(l!=cp.l)\n      return l<cp.l;\n    if(r!=cp.r)\n      return r<cp.r;\n    return ot<cp.ot;\n  }\n};\nconst in inf=2e9;\nin bst=inf;\nin n,m;\nvector<vector<eg> > egs;\npriority_queue<tuple<in,in,in> > pq;\nvector<map<in,in> > optim;\nVI nxtcand;\nvoid ad(in u, in tarr, in tlv){\n  pq.push(tuple<in,in,in>(-tarr,-tlv,u));\n}\nvoid proc(in u, in tarr, in tlv){\n  if(nxtcand[u]==sz(egs[u]))\n    return;\n  eg& e=egs[u][nxtcand[u]];\n  if(e.l>tlv)\n    return;\n  ++nxtcand[u];\n  if(e.r>=tarr)\n    ad(e.ot,max(e.l+1,tarr+1),e.r+1);\n  proc(u,tarr,tlv);\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>n>>m;\n  egs.resize(2*n);\n  optim.resize(2*n);\n  nxtcand.resize(2*n);\n  in ta,tb,l,r;\n  forn(zz,m){\n    cin>>ta>>tb>>l>>r;\n    --ta;\n    --tb;\n    if(!(r==l+1 && l%2==1)){\n      egs[ta].PB(eg(tb+n,l+l%2,r-1-(r-1)%2));\n      egs[tb].PB(eg(ta+n,l+l%2,r-1-(r-1)%2));\n    }\n    if(!(r==l+1 && l%2==0)){\n      egs[ta+n].PB(eg(tb,l+(l+1)%2,r-1-r%2));\n      egs[tb+n].PB(eg(ta,l+(l+1)%2,r-1-r%2));\n    }\n  }\n  forv(i,egs)\n    sort(all(egs[i]));\n  optim[0][0]=1;\n  optim[0][2]=-1;\n  pq.push(tuple<in,in,in>(-0,-0,0));\n  in u,tarr,tlv;\n  while(!pq.empty()){\n    tie(tarr,tlv,u)=pq.top();\n    pq.pop();\n    tarr=-tarr;\n    tlv=-tlv;\n    if(u==n-1 || u==2*n-1){\n      bst=min(bst,tarr);\n    }\n    proc(u,tarr,tlv);\n  }\n  if(bst==inf)\n    cout<<-1<<\"\\n\";\n  else\n    cout<<bst<<\"\\n\";\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "graphs", "shortest paths"], "dificulty": "3200", "interactive": false}