{
    "link": "https://codeforces.com//contest/827/problem/F",
    "problemId": "113850",
    "problem_idx": "F",
    "shortId": "827F",
    "contest_number": "827",
    "problem_submissions": {
        "F": [
            28447535,
            28704912
        ],
        "B": [
            28442493,
            28434829,
            28432891,
            28434941,
            28434124,
            28440743,
            28434219,
            28434038,
            28435758,
            28436170,
            28442340,
            28436191,
            28436588,
            28434003,
            28436389,
            28434757,
            28437055,
            28448594,
            28438989
        ],
        "C": [
            28440487,
            28438660,
            28438441,
            28438938,
            28437666,
            28446435,
            28437809,
            28439569,
            28439405,
            28439836,
            28438472,
            28441170,
            28440770,
            28437931,
            28442353,
            28442274,
            28441410,
            28437286,
            28455031,
            28442955
        ],
        "E": [
            28436548,
            28441080,
            28466758,
            28444795,
            28441962,
            28439200,
            28445462,
            28450329,
            28446470,
            28443820,
            28444149,
            28441607,
            28444424,
            28451564,
            28465030,
            28453083,
            28453061,
            28452855,
            28445979,
            28445398,
            28447328,
            28450262,
            28443711,
            28447639
        ],
        "A": [
            28432871,
            28432173,
            28431465,
            28433215,
            28452981,
            28437424,
            28432872,
            28451754,
            28432696,
            28432687,
            28432382,
            28432827,
            28432606,
            28431751,
            28435184,
            28437702,
            28433063,
            28446111,
            28434053
        ],
        "D": [
            28445554,
            28441989,
            28447486,
            28446928,
            28441195,
            28445740,
            28448719,
            28454047,
            28460505,
            28543175,
            28454400,
            28446342,
            28447977,
            29638472,
            28445305,
            28443739
        ]
    },
    "name": "F. Dirty Arkady s Kitchen",
    "statement": "Arkady likes to walk around his kitchen. His labyrinthine kitchen\r\nconsists of several important places connected with passages.\r\nUnfortunately it happens that these passages are flooded with milk so\r\nthat it\u2019s impossible to pass through them. Namely, it\u2019s possible to pass\r\nthrough each passage in any direction only during some time interval.The\r\nlengths of all passages are equal and Arkady makes through them in one\r\nsecond. For security reasons, Arkady can never stop, also, he can\u2019t\r\nchange direction while going through a passage. In other words, if he\r\nstarts walking in some passage, he should reach its end and immediately\r\nleave the end.Today Arkady needs to quickly reach important place from\r\nplace . He plans to exit the place at time moment and reach the place as\r\nearly as he can. Please find the minimum time he should spend on his\r\nway.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef int in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct eg{\n  in ot,l,r;\n  eg(in pot, in pl, in pr){\n    ot=pot;\n    l=pl;\n    r=pr;\n  }\n  bool operator<(const eg cp)const{\n    if(l!=cp.l)\n      return l<cp.l;\n    if(r!=cp.r)\n      return r<cp.r;\n    return ot<cp.ot;\n  }\n};\nconst in inf=2e9;\nin bst=inf;\nin n,m;\nvector<vector<eg> > egs;\npriority_queue<tuple<in,in,in> > pq;\nvector<map<in,in> > optim;\nVI nxtcand;\nvoid ad(in u, in tarr, in tlv){\n  pq.push(tuple<in,in,in>(-tarr,-tlv,u));\n}\nvoid proc(in u, in tarr, in tlv){\n  if(nxtcand[u]==sz(egs[u]))\n    return;\n  eg& e=egs[u][nxtcand[u]];\n  if(e.l>tlv)\n    return;\n  ++nxtcand[u];\n  if(e.r>=tarr)\n    ad(e.ot,max(e.l+1,tarr+1),e.r+1);\n  proc(u,tarr,tlv);\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>n>>m;\n  egs.resize(2*n);\n  optim.resize(2*n);\n  nxtcand.resize(2*n);\n  in ta,tb,l,r;\n  forn(zz,m){\n    cin>>ta>>tb>>l>>r;\n    --ta;\n    --tb;\n    if(!(r==l+1 && l%2==1)){\n      egs[ta].PB(eg(tb+n,l+l%2,r-1-(r-1)%2));\n      egs[tb].PB(eg(ta+n,l+l%2,r-1-(r-1)%2));\n    }\n    if(!(r==l+1 && l%2==0)){\n      egs[ta+n].PB(eg(tb,l+(l+1)%2,r-1-r%2));\n      egs[tb+n].PB(eg(ta,l+(l+1)%2,r-1-r%2));\n    }\n  }\n  forv(i,egs)\n    sort(all(egs[i]));\n  optim[0][0]=1;\n  optim[0][2]=-1;\n  pq.push(tuple<in,in,in>(-0,-0,0));\n  in u,tarr,tlv;\n  while(!pq.empty()){\n    tie(tarr,tlv,u)=pq.top();\n    pq.pop();\n    tarr=-tarr;\n    tlv=-tlv;\n    if(u==n-1 || u==2*n-1){\n      bst=min(bst,tarr);\n    }\n    proc(u,tarr,tlv);\n  }\n  if(bst==inf)\n    cout<<-1<<\"\\n\";\n  else\n    cout<<bst<<\"\\n\";\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Dirty Arkady s Kitchen.json",
    "editorial_link": "https://codeforces.com//blog/entry/53268",
    "editorial": "Let\u00e2\u0080\u0099s consider undirected edge as two directed edges and . Let Arkady\r\ncame to the vertex in moment of time . Then he can come to in moments of\r\ntime until the edge is existing. We will expand each directed edge: on\r\none of them we can come in even moments of time and leave in odd; on the\r\nother edge we can come in odd moments of time and leave in even. So,\r\neach of the edges from initial graph has turned in 4 edges of the new\r\ngraph. Let\u00e2\u0080\u0099s calculate for each edge the minimal moment of time when we\r\ncan come on the edge . Let\u00e2\u0080\u0099s count this values with help of sorting of\r\nevents like \"edge appeared\". For each vertex and parity we will remember\r\nthe edge for which we can appear in this vertex in moments of time with\r\nsuch a parity which will disappear later than others. When the event of\r\nappearing edge became we need to check if it is possible in this moment\r\nof time come to the beginning of this edge. If it is possible then ,\r\nwhere the minimal moment of time when it is possible to come to the\r\nbeginning of the edge to go through this edge. Every time when some\r\nvertex became reachable with needed parity we say that value of is\r\nequals to this time for all edges which wait in this vertex this parity.\r\nTotally each edge will processed no more than two times, so totally\r\nsolution works in .\r\n"
}