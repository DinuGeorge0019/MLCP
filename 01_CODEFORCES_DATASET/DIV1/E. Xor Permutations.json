{"link": "https://codeforces.com//contest/1168/problem/E", "problemId": "349592", "problem_idx": "E", "shortId": "1168E", "contest_number": "1168", "problem_submissions": {"D": [54689933, 54709717, 54687414, 54689247, 54692817, 54690951, 54687623, 54690825, 54690084, 54693991, 54691003, 54691066, 54691626, 54692507, 54689961, 54693988, 54752028, 54747584, 54782050, 54716017, 54694558], "B": [54688206, 54684470, 54672670, 54675422, 54672484, 54674963, 54674803, 54682027, 54675650, 54680245, 54677508, 54680443, 54678955, 54683400, 54673481, 54675324, 54675597, 54675910, 54676117], "A": [54679849, 54670251, 54678124, 54670773, 54670009, 54671023, 54672077, 54670763, 54669908, 54672903, 54670896, 54674583, 54671922, 54670734, 54670514, 54670263, 54670924, 54670411, 54671870], "C": [54678044, 54685816, 54846089, 54676677, 54679735, 54675366, 54680183, 54677459, 54678103, 54681414, 54678145, 54682238, 54682671, 54681429, 54681732, 54676972, 54678213, 54678234, 54678543, 54679007], "E": [54672350, 54679530, 156967221, 54891863, 54891597]}, "name": "E. Xor Permutations", "statement": "Toad Mikhail has an array of 2^k integers a_1, a_2,\r\nldots, a_{2^k}.Find two permutations p and q of integers 0, 1,\r\nldots, 2^k-1, such that a_i is equal to p_i\r\noplus q_i for all possible i, or determine there are no such\r\npermutations. Here\r\noplus denotes the bitwise XOR operation.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define maxN 5678\n\nmt19937 mrand(random_device{}());\n\nint k, a[maxN], posb[maxN], posc[maxN], b[maxN], c[maxN];\n\nint main() {\n\tscanf(\"%d\", &k);\n\tint n = 1 << k;\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", a + i);\n\t\ts ^= a[i];\n\t}\n\tmemset(posb, -1, sizeof(posb));\n\tmemset(posc, -1, sizeof(posc));\n\tauto nextInt = [&](int *pos) {\n\t\twhile (true) {\n\t\t\tint x = mrand() % n;\n\t\t\tif (pos[x] == -1)\n\t\t\t\treturn x;\n\t\t}\n\t};\n\tif (s != 0) {\n\t\tprintf(\"Fou\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = nextInt(posb);\n\t\tposb[b[i]] = i;\n\t\tc[i] = a[i] ^ b[i];\n\t\tint which = 0;\n\t\tint idx = i;\n\t\twhile (1) {\n\t\t\tif (which == 0) {\n\t\t\t\tif (posc[c[idx]] == -1) {\n\t\t\t\t\tposc[c[idx]] = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tswap(posc[c[idx]], idx);\n\t\t\t\t\tc[idx] = nextInt(posc);\n\t\t\t\t\tposc[c[idx]] = idx;\n\t\t\t\t\tposb[b[idx]] = -1;\n\t\t\t\t\tb[idx] = a[idx] ^ c[idx];\n\t\t\t\t\twhich = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (posb[b[idx]] == -1) {\n\t\t\t\t\tposb[b[idx]] = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tswap(posb[b[idx]], idx);\n\t\t\t\t\tb[idx] = nextInt(posb);\n\t\t\t\t\tposb[b[idx]] = idx;\n\t\t\t\t\tposc[c[idx]] = -1;\n\t\t\t\t\tc[idx] = a[idx] ^ b[idx];\n\t\t\t\t\twhich = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Shi\\n\");\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", b[i]);\n\tprintf(\"\\n\");\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", c[i]);\n\tprintf(\"\\n\");\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "3100", "interactive": false}