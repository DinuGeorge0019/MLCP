{
    "link": "https://codeforces.com//contest/1168/problem/E",
    "problemId": "349592",
    "problem_idx": "E",
    "shortId": "1168E",
    "contest_number": "1168",
    "problem_submissions": {
        "D": [
            54689933,
            54709717,
            54687414,
            54689247,
            54692817,
            54690951,
            54687623,
            54690825,
            54690084,
            54693991,
            54691003,
            54691066,
            54691626,
            54692507,
            54689961,
            54693988,
            54752028,
            54747584,
            54782050,
            54716017,
            54694558
        ],
        "B": [
            54688206,
            54684470,
            54672670,
            54675422,
            54672484,
            54674963,
            54674803,
            54682027,
            54675650,
            54680245,
            54677508,
            54680443,
            54678955,
            54683400,
            54673481,
            54675324,
            54675597,
            54675910,
            54676117
        ],
        "A": [
            54679849,
            54670251,
            54678124,
            54670773,
            54670009,
            54671023,
            54672077,
            54670763,
            54669908,
            54672903,
            54670896,
            54674583,
            54671922,
            54670734,
            54670514,
            54670263,
            54670924,
            54670411,
            54671870
        ],
        "C": [
            54678044,
            54685816,
            54846089,
            54676677,
            54679735,
            54675366,
            54680183,
            54677459,
            54678103,
            54681414,
            54678145,
            54682238,
            54682671,
            54681429,
            54681732,
            54676972,
            54678213,
            54678234,
            54678543,
            54679007
        ],
        "E": [
            54672350,
            54679530,
            156967221,
            54891863,
            54891597
        ]
    },
    "name": "E. Xor Permutations",
    "statement": "Toad Mikhail has an array of 2^k integers a_1, a_2,\r\nldots, a_{2^k}.Find two permutations p and q of integers 0, 1,\r\nldots, 2^k-1, such that a_i is equal to p_i\r\noplus q_i for all possible i, or determine there are no such\r\npermutations. Here\r\noplus denotes the bitwise XOR operation.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define maxN 5678\n\nmt19937 mrand(random_device{}());\n\nint k, a[maxN], posb[maxN], posc[maxN], b[maxN], c[maxN];\n\nint main() {\n\tscanf(\"%d\", &k);\n\tint n = 1 << k;\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", a + i);\n\t\ts ^= a[i];\n\t}\n\tmemset(posb, -1, sizeof(posb));\n\tmemset(posc, -1, sizeof(posc));\n\tauto nextInt = [&](int *pos) {\n\t\twhile (true) {\n\t\t\tint x = mrand() % n;\n\t\t\tif (pos[x] == -1)\n\t\t\t\treturn x;\n\t\t}\n\t};\n\tif (s != 0) {\n\t\tprintf(\"Fou\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = nextInt(posb);\n\t\tposb[b[i]] = i;\n\t\tc[i] = a[i] ^ b[i];\n\t\tint which = 0;\n\t\tint idx = i;\n\t\twhile (1) {\n\t\t\tif (which == 0) {\n\t\t\t\tif (posc[c[idx]] == -1) {\n\t\t\t\t\tposc[c[idx]] = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tswap(posc[c[idx]], idx);\n\t\t\t\t\tc[idx] = nextInt(posc);\n\t\t\t\t\tposc[c[idx]] = idx;\n\t\t\t\t\tposb[b[idx]] = -1;\n\t\t\t\t\tb[idx] = a[idx] ^ c[idx];\n\t\t\t\t\twhich = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (posb[b[idx]] == -1) {\n\t\t\t\t\tposb[b[idx]] = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tswap(posb[b[idx]], idx);\n\t\t\t\t\tb[idx] = nextInt(posb);\n\t\t\t\t\tposb[b[idx]] = idx;\n\t\t\t\t\tposc[c[idx]] = -1;\n\t\t\t\t\tc[idx] = a[idx] ^ b[idx];\n\t\t\t\t\twhich = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Shi\\n\");\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", b[i]);\n\tprintf(\"\\n\");\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", c[i]);\n\tprintf(\"\\n\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Xor Permutations.json",
    "editorial_link": "https://codeforces.com//blog/entry/67241",
    "editorial": "If xor of all elements of the array is not zero, then the answer is\r\n\"Fou\".Now letâs assume that you have two permutations and when xored\r\nthey are producing an array .I will show that it is possible to change\r\nany two elements to elements with some transformation of the given\r\npermutations. Letâs change to .Letâs find such , that .If is equal to or\r\n, then you can make some swaps to \"fix\" the array, to make it satisfy\r\nfor all .Now you have: at position at position at position Letâs make\r\nsome swaps at these positions to transform it to: at position at\r\nposition at position Now, after you make these transition, you will have\r\n, and now you need to \"fix\" positions and , and just process\r\nrecursively.Lemma: this thing will end in\r\noperations.______________________________________________________________________________________Proof:\r\nLetâs assume that at some two moments you have coincided with some\r\nearlier, letâs check the first that moment.For simplicity of the proof,\r\nletâs assume that numbers are moving like that: at position at position\r\nat position (So âs are constant, and âs are changing now. Obviously, it\r\nis equivalent to the previous transformation)Now, assume, that you had\r\nnumbers: at position at position (1) at position (2)and then, you will\r\nmake one transformation, and everything will go to: at position at\r\nposition at position After that, before you will be stuck into described\r\nearlier equality: at position at position at position And after swapping\r\nwith at position (3) at position (4)Letâs look at (1), (2) and (3),\r\n(4)From (1), (2), we can see From (3), (4), we can see So , but , so it\r\nis a contradiction, because is a permutation..\r\n_________________________________________________________________________________Ok,\r\nusing these operations it is pretty simple to get an arbitrary array.\r\nJust start with (two equal permutations). And then make , at the end you\r\nwill have one element rest and it will be good because initially xor was\r\nzero.My solution.\r\n",
    "hint": []
}