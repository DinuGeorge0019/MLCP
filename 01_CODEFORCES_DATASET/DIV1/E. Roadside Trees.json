{"link": "https://codeforces.com//contest/264/problem/E", "problemId": "2530", "problem_idx": "E", "shortId": "264E", "contest_number": "264", "problem_submissions": {"D": [2970633, 2970188, 2969616, 2972161, 2970655, 2972191, 2971577, 2970650, 2971498, 2971572, 2972055, 2972383, 2971674, 2972692, 2971818, 2972335], "C": [2968127, 2967219, 2967855, 2968130, 2966487, 2966588, 2967563, 2967148, 2967835, 2968495, 2969405, 2968262, 2968182, 2968431, 2970284, 2968742, 2969164, 2966742], "B": [2965253, 2965388, 2965967, 2964982, 2964487, 2965047, 2964632, 2965554, 2964885, 2965097, 2966188, 2965309, 2965972, 2965497, 2965546, 2967550, 2966171], "A": [2963692, 2963886, 2964531, 2963631, 2963360, 2963339, 2963656, 2963270, 2995453, 2963462, 2963614, 2963459, 2963970, 2964239, 2963708, 2963681, 2964333, 2963722], "E": [2971453, 3192402, 2977035, 2974561, 2972662]}, "name": "E. Roadside Trees", "statement": "Squirrel Liss loves nuts. Liss asks you to plant some nut trees.There\r\nare positions (numbered 1 to from west to east) to plant a tree along a\r\nstreet. Trees grow one meter per month. At the beginning of each month\r\nyou should process one query. The query is one of the following types:\r\nPlant a tree of height at position . Cut down the -th existent (not cut)\r\ntree from the west (where is 1-indexed). When we cut the tree it drops\r\ndown and takes all the available place at the position where it has\r\nstood. So no tree can be planted at this position anymore. After\r\nprocessing each query, you should print the length of the longest\r\nincreasing subsequence. A subset of existent trees is called an if the\r\nheight of the trees in the set is strictly increasing from west to east\r\n(for example, the westmost tree in the set must be the shortest in the\r\nset). The length of the increasing subsequence is the number of trees in\r\nit.Note that Liss don\u2019t like the trees with the same heights, so it is\r\nguaranteed that at any time no two trees have the exactly same heights.\r\n", "solutions": ["#pragma comment(linker,\"/STACK:256000000\")\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <cstring>\n#include <memory.h>\nusing namespace std;\n#define sz(v) ((int)(v).size())\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define pb push_back\n#define mp make_pair\n#define istr stringstream\n#define fi first\n#define se second\n#define X first\n#define Y second\n#define clr(a,v) memset((a),(v),sizeof(a))\n#define y0 asdy0\n#define y1 asdy1\n#define j0 asdj0\n#define j1 asdj1\n#define next asdnext\n#define prev asdprev\n#define link asdlink\n#define unlink asdunlink\n#define left asdleft\n#define right asdright\n#define hash asdhash\n#define div asddiv\n#define all(v) (v).begin(),(v).end()\ntypedef long long lng;\ntypedef unsigned int uint;\ntypedef unsigned long long ulng;\ntypedef unsigned char uchar;\ntypedef double ld;\ntypedef pair<int,int> PII;\ntypedef pair<ld,ld> PDD;\ntypedef pair<lng,lng> PLL;\ntypedef complex<double> com;\nconst ld PI=3.1415926535897932384626433832795;\nconst ld EPS=1e-12;\nconst int inf=1000000000;\nconst lng linf=1000000000000000000LL;\ntemplate<class T> inline T sqr(T x) { return x * x; }\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\n\nint tree[510000];\n\nvoid setv(int p,int v,int a,int b,int k){\n\tif(b==a+1){\n\t\ttree[k]=v;\n\t\treturn;\n\t}\n\tint c=(a+b)/2;\n\tif(p<c)\n\t\tsetv(p,v,a,c,k*2+1);\n\telse\n\t\tsetv(p,v,c,b,k*2+2);\n\ttree[k]=max(tree[k*2+1],tree[k*2+2]);\n}\n\nint getmax(int l,int r,int a,int b,int k){\n\tif(l<=a&&r>=b)\n\t\treturn tree[k];\n\tif(r<=a||l>=b)\n\t\treturn 0;\n\tint c=(a+b)/2;\n\treturn max(getmax(l,r,a,c,k*2+1),getmax(l,r,c,b,k*2+2));\n}\n\nconst int B=201000;\nint dp[110000];\nint hei[110000];\nint pos[310000];\nset<int> anset[110000];\nset<int> allset;\n\nint main() {\n#ifdef __ASD__\n    freopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tclr(pos,-1);\n\tint n,m;\n\tcin>>n>>m;\n\tforn(qqq,m){\n\t\tint type;\n\t\tscanf(\"%d\",&type);\n\t\tif(type==1){\n\t\t\tint p,h;\n\t\t\tscanf(\"%d%d\",&p,&h);\n\t\t\t--p;\n\t\t\th+=m-qqq;\n\t\t\thei[p]=h;\n\t\t\tpos[h]=p;\n\t\t\tallset.insert(p);\n\t\t\tvector<int> small;\n\t\t\tfor(int hh=h;hh>=h-20 && hh>=0;--hh){\n\t\t\t\tif(pos[hh]!=-1)\n\t\t\t\t\tsmall.pb(pos[hh]);\n\t\t\t}\n\t\t\tsmall.pb(n);\n\t\t\tsort(all(small));\n\t\t\tint mx=0;\n\t\t\tfor(int i=sz(small)-2;i>=0;--i){\n\t\t\t\tint pp=small[i];\n\t\t\t\tmx=max(mx,getmax(pp+1,small[i+1],0,n,0));\n\t\t\t\tint r=mx;\n\t\t\t\tfor(int j=i+1;j<sz(small)-1;++j){\n\t\t\t\t\tint ppp=small[j];\n\t\t\t\t\tif(hei[ppp]>hei[pp])\n\t\t\t\t\t\tr=max(r,dp[ppp]);\n\t\t\t\t}\n\t\t\t\t++r;\n\t\t\t\tif(pp==p || r!=dp[pp]){\n\t\t\t\t\tif(r<dp[pp])\n\t\t\t\t\t\texit(33);\n\t\t\t\t\tanset[dp[pp]].erase(pp);\n\t\t\t\t\tdp[pp]=r;\n\t\t\t\t\tanset[dp[pp]].insert(pp);\n\t\t\t\t\tsetv(pp,r,0,n,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\t--x;\n\t\t\tvector<int> ps;\n\t\t\t\n\t\t\tset<int>::iterator it=allset.begin();\n\t\t\tforn(qq,x){\n\t\t\t\tif(it==allset.end())\n\t\t\t\t\texit(44);\n\t\t\t\tps.pb(*it);\n\t\t\t\t++it;\n\t\t\t}\n\t\t\tif(it==allset.end())\n\t\t\t\texit(44);\n\t\t\tint p=*it;\n\t\t\t\n\t\t\tfor(int i=sz(ps)-1;i>=0;--i){\n\t\t\t\tint pp=ps[i];\n\t\t\t\tint d=dp[pp];\n\t\t\t\tif(d>1){\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tfor(set<int>::iterator it=anset[d-1].begin();it!=anset[d-1].end();++it){\n\t\t\t\t\t\tint ppp=*it;\n\t\t\t\t\t\tif(ppp>pp && ppp!=p){\n\t\t\t\t\t\t\tif(hei[ppp]>hei[pp])\n\t\t\t\t\t\t\t\tok=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok){\n\t\t\t\t\t\tanset[dp[pp]].erase(pp);\n\t\t\t\t\t\t--dp[pp];\n\t\t\t\t\t\tanset[dp[pp]].insert(pp);\n\t\t\t\t\t\tsetv(pp,dp[pp],0,n,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpos[hei[p]]=-1;\n\t\t\tanset[dp[p]].erase(p);\n\t\t\tallset.erase(p);\n\t\t\tsetv(p,0,0,n,0);\n\t\t\thei[p]=0;\n\t\t\tdp[p]=0;\n\t\t}\n\t\t\n\t\t/*\n\t\tcout<<endl;\n\t\tforn(i,n){\n\t\t\tcout<<hei[i]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t\tforn(i,m+12){\n\t\t\tif(pos[i]!=-1)\n\t\t\t\tcout<<i<<\":\"<<pos[i]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t\tforn(i,n){\n\t\t\tcout<<dp[i]<<' ';\n\t\t}\n\t\tcout<<endl;//*/\n\t\t\n\t\tprintf(\"%d\\n\",getmax(0,n,0,n,0));\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp"], "dificulty": "3000", "interactive": false}