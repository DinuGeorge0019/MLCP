{"link": "https://codeforces.com//contest/1685/problem/D2", "problemId": "1410456", "problem_idx": "D2", "shortId": "1685D2", "contest_number": "1685", "problem_submissions": {"E": [158459552, 158470179, 158498551, 158474226, 158469548, 163064811, 163064579, 162972274, 161995310], "D1": [158446537, 158446179, 158436497, 158441308, 158450152, 158437819, 158438771, 158444550, 158444057, 158444961, 158450485, 158456436, 158455279, 158451423, 158456717, 158456702, 158458839, 158450419, 158454329], "C": [158440149, 158436682, 158456408, 158436985, 158433630, 158430630, 158430086, 158437803, 158438284, 158438857, 158446162, 158444048, 158440132, 158447129, 158447895, 158449525, 158447760, 158457006, 158449988], "B": [158430617, 158426337, 158489620, 158427132, 158430769, 158427058, 158419568, 158419647, 158422845, 158428180, 158427930, 158426993, 158428289, 158433041, 158438360, 158432708, 158432524, 158429703, 158431029, 158439177], "A": [158416845, 158416623, 158416445, 158417978, 158414637, 158414483, 158414377, 158414577, 158419066, 158418105, 158416435, 158417522, 158415887, 158415929, 158418032, 158416211, 158417132, 158417328, 158424448], "D2": [158457366, 158450783, 158467580, 158467275, 158561732, 166382774, 166382436]}, "name": "D2. Permutation Weight  Hard Version ", "statement": ".You are given a permutation p_1, p_2,\r\nldots, p_n of integers from 1 to n.Let\u2019s define the weight of the\r\npermutation q_1, q_2,\r\nldots, q_n of integers from 1 to n as |q_1 - p_{q_{2}}| + |q_2 -\r\np_{q_{3}}| +\r\nldots + |q_{n-1} - p_{q_{n}}| + |q_n - p_{q_{1}}|You want your\r\npermutation to be as lightweight as possible. Among the permutations q\r\nwith the smallest possible weight, find the lexicographically\r\nsmallest.Permutation a_1, a_2,\r\nldots, a_n is lexicographically smaller than permutation b_1, b_2,\r\nldots, b_n, if there exists some 1\r\nle i\r\nle n such that a_j = b_j for all 1\r\nle j < i and a_i<b_i.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> p(n), h(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> p[i];\n        p[i]--;\n        h[p[i]] = i;\n    }\n    \n    DSU dsu(n);\n    std::vector<bool> vis(n);\n    for (int i = 0; i < n; i++) {\n        if (vis[i]) {\n            continue;\n        }\n        for (int j = i; !vis[j]; j = p[j]) {\n            vis[j] = true;\n            dsu.merge(j, i);\n        }\n    }\n    // for (int i = 0; i + 1 < n; i++) {\n    //     if (!dsu.same(i, i + 1)) {\n    //         int x = h[i];\n    //         int y = h[i + 1];\n    //         std::swap(p[x], p[y]);\n    //         std::swap(h[i], h[i + 1]);\n    //         dsu.merge(i, i + 1);\n    //     }\n    // }\n    \n    std::vector<int> ans(n, -1);\n    \n    auto check = [&]() {\n        DSU g = dsu;\n        \n        std::vector<bool> need(n - 1);\n        for (int i = 0; i < n; i++) {\n            if (ans[i] != -1) {\n                int x = p[ans[i]];\n                if (x < i) {\n                    for (int j = x; j < i; j++) {\n                        need[j] = true;\n                    }\n                } else {\n                    for (int j = i; j < x; j++) {\n                        need[j] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (need[i] && !g.merge(i, i + 1)) {\n                return false;\n            }\n        }\n        \n        std::vector<int> dir(n - 2, -1);\n        std::vector<bool> cant(n - 1);\n        \n        auto work = [&](int x, int d) {\n            if (dir[x] >= 0 && dir[x] != d) {\n                dir[x] = 0;\n            } else {\n                dir[x] = d;\n            }\n        };\n        \n        for (int i = 0; i < n; i++) {\n            if (ans[i] != -1) {\n                int x = p[ans[i]];\n                if (x < i) {\n                    for (int j = x; j + 1 < i; j++) {\n                        work(j, 1);\n                    }\n                    if (x > 0) {\n                        work(x - 1, 2);\n                    }\n                    if (i + 1 < n) {\n                        work(i - 1, 2);\n                    }\n                } else if (x > i) {\n                    for (int j = x - 1; j > i; j--) {\n                        work(j - 1, 2);\n                    }\n                    if (x + 1 < n) {\n                        work(x - 1, 1);\n                    }\n                    if (i > 0) {\n                        work(i - 1, 1);\n                    }\n                } else {\n                    if (x + 1 < n) {\n                        cant[x] = true;\n                    }\n                    if (x > 0) {\n                        cant[x - 1] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i + 2 < n; i++) {\n            if (need[i] && need[i + 1] && dir[i] == 0) {\n                return false;\n            }\n        }\n        for (int i = 0; i + 1 < n; i++) {\n            if (need[i] && cant[i]) {\n                return false;\n            }\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (need[i]) {\n                continue;\n            }\n            if (cant[i]) {\n                continue;\n            }\n            if (i > 0 && dir[i - 1] == 0) {\n                continue;\n            }\n            if (i < n - 2 && dir[i] == 0) {\n                continue;\n            }\n            g.merge(i, i + 1);\n        }\n        for (int i = 0; i < n; i++) {\n            if (!g.same(0, i)) {\n                return false;\n            }\n        }\n        \n        return true;\n    };\n    \n    std::vector<bool> cyc(n);\n    int cnt = 0;\n    for (int i = 0; ; i = ans[i]) {\n        std::cout << i + 1;\n        cyc[i] = true;\n        cnt++;\n        \n        ans[i] = 0;\n        while ((cnt < n && cyc[ans[i]]) || !check()) {\n            ans[i]++;\n        }\n        \n        if (ans[i] == 0) {\n            std::cout << \"\\n\";\n            return;\n        } else {\n            std::cout << \" \";\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "3500", "interactive": false}