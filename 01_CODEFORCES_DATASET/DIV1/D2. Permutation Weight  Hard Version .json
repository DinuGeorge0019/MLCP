{
    "link": "https://codeforces.com//contest/1685/problem/D2",
    "problemId": "1410456",
    "problem_idx": "D2",
    "shortId": "1685D2",
    "contest_number": "1685",
    "problem_submissions": {
        "E": [
            158459552,
            158470179,
            158498551,
            158474226,
            158469548,
            163064811,
            163064579,
            162972274,
            161995310
        ],
        "D1": [
            158446537,
            158446179,
            158436497,
            158441308,
            158450152,
            158437819,
            158438771,
            158444550,
            158444057,
            158444961,
            158450485,
            158456436,
            158455279,
            158451423,
            158456717,
            158456702,
            158458839,
            158450419,
            158454329
        ],
        "C": [
            158440149,
            158436682,
            158456408,
            158436985,
            158433630,
            158430630,
            158430086,
            158437803,
            158438284,
            158438857,
            158446162,
            158444048,
            158440132,
            158447129,
            158447895,
            158449525,
            158447760,
            158457006,
            158449988
        ],
        "B": [
            158430617,
            158426337,
            158489620,
            158427132,
            158430769,
            158427058,
            158419568,
            158419647,
            158422845,
            158428180,
            158427930,
            158426993,
            158428289,
            158433041,
            158438360,
            158432708,
            158432524,
            158429703,
            158431029,
            158439177
        ],
        "A": [
            158416845,
            158416623,
            158416445,
            158417978,
            158414637,
            158414483,
            158414377,
            158414577,
            158419066,
            158418105,
            158416435,
            158417522,
            158415887,
            158415929,
            158418032,
            158416211,
            158417132,
            158417328,
            158424448
        ],
        "D2": [
            158457366,
            158450783,
            158467580,
            158467275,
            158561732,
            166382774,
            166382436
        ]
    },
    "name": "D2. Permutation Weight  Hard Version ",
    "statement": ".You are given a permutation p_1, p_2,\r\nldots, p_n of integers from 1 to n.Let’s define the weight of the\r\npermutation q_1, q_2,\r\nldots, q_n of integers from 1 to n as |q_1 - p_{q_{2}}| + |q_2 -\r\np_{q_{3}}| +\r\nldots + |q_{n-1} - p_{q_{n}}| + |q_n - p_{q_{1}}|You want your\r\npermutation to be as lightweight as possible. Among the permutations q\r\nwith the smallest possible weight, find the lexicographically\r\nsmallest.Permutation a_1, a_2,\r\nldots, a_n is lexicographically smaller than permutation b_1, b_2,\r\nldots, b_n, if there exists some 1\r\nle i\r\nle n such that a_j = b_j for all 1\r\nle j < i and a_i<b_i.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> p(n), h(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> p[i];\n        p[i]--;\n        h[p[i]] = i;\n    }\n    \n    DSU dsu(n);\n    std::vector<bool> vis(n);\n    for (int i = 0; i < n; i++) {\n        if (vis[i]) {\n            continue;\n        }\n        for (int j = i; !vis[j]; j = p[j]) {\n            vis[j] = true;\n            dsu.merge(j, i);\n        }\n    }\n    // for (int i = 0; i + 1 < n; i++) {\n    //     if (!dsu.same(i, i + 1)) {\n    //         int x = h[i];\n    //         int y = h[i + 1];\n    //         std::swap(p[x], p[y]);\n    //         std::swap(h[i], h[i + 1]);\n    //         dsu.merge(i, i + 1);\n    //     }\n    // }\n    \n    std::vector<int> ans(n, -1);\n    \n    auto check = [&]() {\n        DSU g = dsu;\n        \n        std::vector<bool> need(n - 1);\n        for (int i = 0; i < n; i++) {\n            if (ans[i] != -1) {\n                int x = p[ans[i]];\n                if (x < i) {\n                    for (int j = x; j < i; j++) {\n                        need[j] = true;\n                    }\n                } else {\n                    for (int j = i; j < x; j++) {\n                        need[j] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (need[i] && !g.merge(i, i + 1)) {\n                return false;\n            }\n        }\n        \n        std::vector<int> dir(n - 2, -1);\n        std::vector<bool> cant(n - 1);\n        \n        auto work = [&](int x, int d) {\n            if (dir[x] >= 0 && dir[x] != d) {\n                dir[x] = 0;\n            } else {\n                dir[x] = d;\n            }\n        };\n        \n        for (int i = 0; i < n; i++) {\n            if (ans[i] != -1) {\n                int x = p[ans[i]];\n                if (x < i) {\n                    for (int j = x; j + 1 < i; j++) {\n                        work(j, 1);\n                    }\n                    if (x > 0) {\n                        work(x - 1, 2);\n                    }\n                    if (i + 1 < n) {\n                        work(i - 1, 2);\n                    }\n                } else if (x > i) {\n                    for (int j = x - 1; j > i; j--) {\n                        work(j - 1, 2);\n                    }\n                    if (x + 1 < n) {\n                        work(x - 1, 1);\n                    }\n                    if (i > 0) {\n                        work(i - 1, 1);\n                    }\n                } else {\n                    if (x + 1 < n) {\n                        cant[x] = true;\n                    }\n                    if (x > 0) {\n                        cant[x - 1] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i + 2 < n; i++) {\n            if (need[i] && need[i + 1] && dir[i] == 0) {\n                return false;\n            }\n        }\n        for (int i = 0; i + 1 < n; i++) {\n            if (need[i] && cant[i]) {\n                return false;\n            }\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (need[i]) {\n                continue;\n            }\n            if (cant[i]) {\n                continue;\n            }\n            if (i > 0 && dir[i - 1] == 0) {\n                continue;\n            }\n            if (i < n - 2 && dir[i] == 0) {\n                continue;\n            }\n            g.merge(i, i + 1);\n        }\n        for (int i = 0; i < n; i++) {\n            if (!g.same(0, i)) {\n                return false;\n            }\n        }\n        \n        return true;\n    };\n    \n    std::vector<bool> cyc(n);\n    int cnt = 0;\n    for (int i = 0; ; i = ans[i]) {\n        std::cout << i + 1;\n        cyc[i] = true;\n        cnt++;\n        \n        ans[i] = 0;\n        while ((cnt < n && cyc[ans[i]]) || !check()) {\n            ans[i]++;\n        }\n        \n        if (ans[i] == 0) {\n            std::cout << \"\\n\";\n            return;\n        } else {\n            std::cout << \" \";\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D2. Permutation Weight  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/103198",
    "editorial": "We will start by proving that the weight is at least (where is the\r\nnumber of cycles), and understanding the structure of optimal\r\npermutations in the process.Again, consider splitting of into cycles\r\n(where a cycle is an array such that for ). Letâs say there are of such\r\ncycles.Now, consider a graph on nodes, and draw an edge from to for each\r\nfrom to (there may be self-loops and multi-edges here). Each node has\r\none incoming and outgoing edge, so the entire graph is split into\r\nseveral cycles. Consider any such cycle , where all are distinct. Its\r\ncontribution to the answer is . We will show that:This value is at least\r\n. Wlog is the smallest among and is the largest, with . Then .Itâs only\r\nwhen the numbers on the cycle are some consecutive numbers and are\r\nincreasing on the path from the smallest number to the largest and\r\ndecreasing on the way back. Itâs just the case when all the inequalities\r\nin the expression above become equalities.Now, assign each cycle of a\r\nnumber from to and consider the graph on nodes, draw an edge between the\r\nnodes corresponding to the cycles where and belong. As and are in the\r\nsame cycle for each , we get that every two consecutive edges we draw\r\nshare a node. As we will draw an edge from every cycle, the graph is\r\nconnected.Each edge in corresponds to an edge in (edge between and in\r\ncorresponds to an edge in between the nodes corresponding to the cycles\r\nwhere and belong).Now, consider any spanning tree in graph . Clearly,\r\nany cycle of length in can contain at most edges from it (if it\r\ncontained edges from it, we would have a cycle in ). So, the total sum\r\nof over all cycles in is at least , and therefore the total contribution\r\nto the weight is at least .Now letâs give a characterization of all\r\npermutations which have the weight . It turns out, that they are in\r\ncorrespondence with graphs on nodes which satisfy the following\r\nconditions: Each node has one incoming and one outgoing edge (and\r\ntherefore graph is split into cycles).In , if a cycle has length , then\r\nit consists of consecutive integers, where numbers go up from the\r\nsmallest number to the largest and down on the way backThe sum of over\r\nall cycles is precisely .If we draw an edge between two cycles of if an\r\nelement of the first cycle is connected to the element of the second\r\ncycle in , this graph on nodes is connected.Each such graph is a\r\ncorresponding graph of some optimal permutation . The proof is left for\r\nthe reader as an exercise.Now, how to solve our problem? Letâs build\r\nelement by element. The weights of all cyclic shifts of the same\r\npermutation are the same, so we start with . Now, the only subproblem we\r\nhave to be able to solve is to check if the current prefix of length is\r\na prefix of some permutation with weight . So, we have to check if our\r\ncurrent edges can be a subset of some graph satisfying all the\r\nconditions above.Denote these edges . If edge has , consider segment ,\r\nand call it segment. If edge has , consider segment , and call it\r\nsegment. If , call node.We can show that the following criteria are\r\nsufficient:No two right segments intersect internally.No two left\r\nsegments intersect internally.No right/left segment contains a loop\r\nnode.Consider a graph on nodes, corresponding to the cycles of . For\r\neach , if is contained in some segment, draw an edge between the\r\ncorresponding cycles in which , are. Then, this graph canât have a cycle\r\n(has to be a forest).Consider a graph on nodes, corresponding to the\r\ncycles of . For each , unless or are loop nodes, or is the right end of\r\ntwo segments, or is the left end of two segments, draw an edge between\r\nthe corresponding cycles in which , are. Then, this graph must be\r\nconnected.These conditions may sound complicated but they are very\r\nsimple implications of the conditions on above. The proof that if these\r\nconditions are satisfied then edges form a subset of some valid is left\r\nto the reader as an exercise too (tutorial is already too long,\r\nsorry).Total complexity is , as we can do up checks, and each check\r\ntakes time.\r\n",
    "hint": []
}