{
    "link": "https://codeforces.com//contest/132/problem/B",
    "problemId": "707",
    "problem_idx": "B",
    "shortId": "132B",
    "contest_number": "132",
    "problem_submissions": {
        "E": [
            925463,
            924045,
            926495,
            927129,
            930757,
            927949,
            927053
        ],
        "B": [
            923684,
            925104,
            927721,
            923959,
            924110,
            922324,
            922978,
            923016,
            925081,
            924882,
            922141,
            926108,
            923013,
            925452,
            925520,
            925045,
            926157,
            926077
        ],
        "D": [
            922457,
            922554,
            924871,
            922974,
            924948,
            924454,
            924331,
            923366,
            923651,
            925293,
            923560,
            925565,
            922791,
            924076,
            923184,
            923568,
            923999
        ],
        "C": [
            920611,
            921352,
            922698,
            921318,
            922939,
            921777,
            922465,
            921286,
            921687,
            923127,
            921959,
            921893,
            920032,
            922242,
            921743,
            922634,
            922920
        ],
        "A": [
            919809,
            919078,
            921073,
            919691,
            920209,
            919403,
            919950,
            919419,
            920157,
            919937,
            920116,
            920376,
            920930,
            921451,
            922067,
            920124,
            920860
        ]
    },
    "name": "B. Piet",
    "statement": "Piet is one of the most known visual esoteric programming languages. The\r\nprograms in Piet are constructed from colorful blocks of pixels and\r\ninterpreted using pretty complicated rules. In this problem we will use\r\na subset of Piet language with simplified rules.The program will be a\r\nrectangular image consisting of colored and black pixels. The color of\r\neach pixel will be given by an integer number between 0 and 9,\r\ninclusive, with 0 denoting black. A block of pixels is defined as a\r\nrectangle of pixels of the same color (not black). It is guaranteed that\r\nall connected groups of colored pixels of the same color will form\r\nrectangular blocks. Groups of black pixels can form arbitrary shapes.The\r\nprogram is interpreted using movement of instruction pointer (IP) which\r\nconsists of three parts: current block pointer (BP); note that there is\r\nno concept of current pixel within the block; direction pointer (DP)\r\nwhich can point left, right, up or down; block chooser (CP) which can\r\npoint to the left or to the right from the direction given by DP; in\r\nabsolute values CP can differ from DP by 90 degrees counterclockwise or\r\nclockwise, respectively.Initially BP points to the block which contains\r\nthe top-left corner of the program, DP points to the right, and CP\r\npoints to the left (see the orange square on the image below).One step\r\nof program interpretation changes the state of IP in a following way.\r\nThe interpreter finds the furthest edge of the current color block in\r\nthe direction of the DP. From all pixels that form this edge, the\r\ninterpreter selects the furthest one in the direction of . After this,\r\nBP attempts to move from this pixel into the next one in the direction\r\nof DP. If the next pixel belongs to a colored block, this block becomes\r\nthe current one, and two other parts of IP stay the same. It the next\r\npixel is black or outside of the program, BP stays the same but two\r\nother parts of IP change. If CP was pointing to the left, now it points\r\nto the right, and DP stays the same. If CP was pointing to the right,\r\nnow it points to the left, and DP is rotated 90 degrees clockwise.This\r\nway BP will never point to a black block (it is guaranteed that top-left\r\npixel of the program will not be black).You are given a Piet program.\r\nYou have to figure out which block of the program will be current after\r\nsteps.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:65777216\")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n,m,t;\nchar s[55][55];\nint c[55][55];\nchar color[55*55];\nint per[55*55][5][5];\n\nvoid dfs(int x,int y,int comp){\n\tif(c[x][y]!=-1) return;\n\tc[x][y]=comp;\n\tFOR(dx,-1,2)FOR(dy,-1,2)if(abs(dx)+abs(dy)==1){\n\t\tint nx = x + dx;\n\t\tint ny = y + dy;\n\t\tif(nx>=0 && nx<n && ny>=0 && ny<m && s[nx][ny]==s[x][y])\n\t\t\tdfs(nx,ny,comp);\n\t}\n}\n\nbool parsed[55*55];\n\nint main(){\n#ifdef LocalHost\n\n    freopen(\"input.txt\",\"r\",stdin);\n//  freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tcin>>n>>t;\n\tREP(i,n) cin>>s[i],m=strlen(s[i]);\n\tint comp=0;\n\tCL(c,-1);\n\tREP(i,n)REP(j,m) if(s[i][j]!='0' && c[i][j]==-1){\n\t\tcolor[comp]=s[i][j];\n\t\tdfs(i,j,comp);\n\t\tcomp++;\n\t}\n\tCL(per,-1);\n\n\tREP(i,n)REP(j,m)if(c[i][j]!=-1 && !parsed[c[i][j]]){\n\t\tparsed[c[i][j]]=1;\n\n\t\tREP(dp,4)REP(bc,4){\n\t\t\tint x = i, y = j;\n\t\t\twhile(1){\n\t\t\t\tint nx = x + dx[dp];\n\t\t\t\tint ny = y + dy[dp];\n\t\t\t\tif(nx<0 || nx>=n || ny<0 || ny>=m || s[nx][ny]!=s[x][y]) break;\n\t\t\t\tx = nx, y = ny;\n\t\t\t}\n\n\t\t\twhile(1){\n\t\t\t\tint nx = x + dx[bc];\n\t\t\t\tint ny = y + dy[bc];\n\t\t\t\tif(nx<0 || nx>=n || ny<0 || ny>=m || s[nx][ny]!=s[x][y]) break;\n\t\t\t\tx = nx, y = ny;\n\t\t\t}\n\n\t\t\tx = x + dx[dp];\n\t\t\ty = y + dy[dp];\n\n\t\t\tif(x>=0 && x<n && y>=0 && y<m && s[x][y]!='0'){\n\t\t\t\tper[c[i][j]][dp][bc] = c[x][y];\n\t\t\t}\n\t\t}\n\t}\n\n\tint bpointer = 0;\n\tint dpointer = 0;\n\tint bchooser = 3;\n\n\tfor(;t;t--){\n\t\tint val = per[bpointer][dpointer][bchooser];\n\t\tif(val==-1){\n\t\t\tif(bchooser == (dpointer+3)%4) bchooser = (dpointer+1)%4;\n\t\t\telse{\n\t\t\t\tdpointer = (dpointer+1)%4;\n\t\t\t\tbchooser = (dpointer+3)%4;\n\t\t\t}\n\t\t}else{\n\t\t\tbpointer = val;\n\t\t}\n\t}\n\n\tcout<<color[bpointer]<<endl;\n\t\n#ifdef LocalHost\n    cout<<endl<<endl<<\"TIME: \"<<clock()<<endl;\n#endif\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Piet.json",
    "editorial_link": "https://codeforces.com//blog/entry/3302",
    "editorial": "As you've already noticed, Piet differs from most other esoteric programming languages in the way it interprets the image  the problem offered a very simplified version of it, and still it was quite cruel.\n\nThe first step of the solution is finding colored blocks. Given that they are rectangular, this can be done without BFS; once you've found a colored pixel which is not part of any block you've seen before, you just find the maximal contiguous sequence of pixels of the same color in the same line that starts with this pixel, and assume that it's horizontal dimension of its block.\n\n............\n..X----->...\n..|XXXXXX...\n..vXXXXXX...\n............\nI found it convenient to index the blocks and store their colors and dimensions at this point, so that this doesn't need to be re-done later. After this I calculated \"state transition function\"  a function which for each state of instruction pointer defined the next state. The IP has at most 50x50x4x2 states, and they can be indexed with 8*(index of current block) + 2*(direction pointer) + (block chooser). Thus, the transition function can be described with a one-dimensional array (index is current state of IP, and value is the next one), and the simulation of interpretation steps becomes just updating the current state of IP, which is easier than repeating the full procedure described in the statement on each step.\n\nIt was also possible to note that at some point there will be a loop in the states of the IP, since the maximal possible number of distinct states is less than the number of steps to be done. But exploiting this wasn't necessary.",
    "hint": []
}