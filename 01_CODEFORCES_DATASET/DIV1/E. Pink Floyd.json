{"link": "https://codeforces.com//contest/1142/problem/E", "problemId": "322165", "problem_idx": "E", "shortId": "1142E", "contest_number": "1142", "problem_submissions": {"D": [52052698, 52044696, 52050424, 52048816, 52048203, 52050242, 52051279, 52044155, 52053707, 52051199, 52050499, 52052944, 52052302, 52053535, 52051490, 52049907], "E": [52047622, 52057339, 52048974, 77087643, 52277900, 52277787, 52050784], "C": [52040660, 52041212, 52036496, 52039629, 52044262, 52039609, 52039348, 52038404, 52053341, 52038044, 52046718, 52044023, 52041812, 52045982, 52050483, 52043132, 52044496, 52082020], "B": [52036028, 52037384, 52034327, 52035419, 52038173, 52037529, 52042911, 52035003, 52038458, 52035088, 52037475, 52037895, 52038479, 52041354, 52037902, 52038519, 52055164, 52037338], "A": [52032007, 52031522, 52030850, 52033382, 52032139, 52033225, 52032107, 52040214, 52033698, 52034088, 52034385, 52034757, 52033255, 52055588, 52032995, 52035070]}, "name": "E. Pink Floyd", "statement": "Scientists are about to invent a new optimization for the Floyd-Warshall\r\nalgorithm, which will allow it to work in linear time. There is only one\r\npart of the optimization still unfinished.It is well known that the\r\nFloyd-Warshall algorithm takes a graph with n nodes and exactly one edge\r\nbetween each pair of nodes. The scientists have this graph, what is\r\nmore, they have directed each edge in one of the two possible\r\ndirections.To optimize the algorithm, exactly m edges are colored in\r\npink color and all the rest are colored in green. You know the direction\r\nof all m pink edges, but the direction of green edges is unknown to you.\r\nIn one query you can ask the scientists about the direction of exactly\r\none green edge, however, you can perform at most 2\r\ncdot n such queries.Your task is to find the node from which every other\r\nnode can be reached by a path consisting of edges of same color. Be\r\naware that the scientists may have lied that they had fixed the\r\ndirection of all edges beforehand, so their answers may depend on your\r\nqueries.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nbool query(int v, int u) {\n\tprintf(\"? %d %d\\n\", v, u);\n\tfflush(stdout);\n\tscanf(\"%d\", &v);\n\tif (v == -1) throw;\n\treturn v;\n}\n\nconst int N = 100100;\nbool used[N];\nint ord[N];\nint ordSz;\nint col[N];\nint n, m;\nvector<int> g[N], rg[N];\nvector<int> G[N];\nint deg[N];\nint q[N];\nint topQ;\nvector<int> comp[N];\n\nvoid dfsOrd(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v])\n\t\tif (!used[u])\n\t\t\tdfsOrd(u);\n\tord[ordSz++] = v;\n}\nvoid dfsCol(int v) {\n\tcol[v] = m;\n\tcomp[m].push_back(v);\n\tfor (int u : rg[v])\n\t\tif (col[u] == -1)\n\t\t\tdfsCol(u);\n}\n\nvoid myFree(int v) {\n\tfor (int u : G[v]) {\n\t\tdeg[u]--;\n\t\tif (deg[u] == 0)\n\t\t\tq[topQ++] = u;\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tg[v].push_back(u);\n\t\trg[u].push_back(v);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (used[i]) continue;\n\t\tdfsOrd(i);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcol[i] = -1;\n\tm = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint v = ord[i];\n\t\tif (col[v] != -1) continue;\n\t\tdfsCol(v);\n\t\tm++;\n\t}\n\t/*\n\tfor (int i = 1; i <= n; i++)\n\t\teprintf(\"%d \", col[i]);\n\teprintf(\"\\n\");\n\t*/\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int u : g[v])\n\t\t\tif (col[v] != col[u])\n\t\t\t\tG[col[v]].push_back(col[u]);\n\tfor (int v = 0; v < m; v++) {\n\t\tsort(G[v].begin(), G[v].end());\n\t\tG[v].resize(unique(G[v].begin(), G[v].end()) - G[v].begin());\n\t\tfor (int u : G[v]) {\n\t\t\t//eprintf(\"edge %d %d\\n\", v, u);\n\t\t\tdeg[u]++;\n\t\t}\n\t}\n\tfor (int v = 0; v < m; v++)\n\t\tif (deg[v] == 0) {\n\t\t\tq[topQ++] = v;\n\t\t}\n\t\n\tint V = q[0];\n\tfor (int i = 1; i < topQ; i++) {\n\t\tint U = q[i];\n\t\twhile(!comp[V].empty() && !comp[U].empty()) {\n\t\t\tint v = comp[V].back(), u = comp[U].back();\n\t\t\tif (query(v, u))\n\t\t\t\tcomp[U].pop_back();\n\t\t\telse\n\t\t\t\tcomp[V].pop_back();\n\t\t}\n\t\tif (comp[V].empty()) {\n\t\t\tswap(V, U);\n\t\t}\n\t\tmyFree(U);\n\t}\n\tprintf(\"! %d\\n\", comp[V].back());\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "interactive"], "dificulty": "3200", "interactive": false}