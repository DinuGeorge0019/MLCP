{"link": "https://codeforces.com//contest/273/problem/E", "problemId": "2631", "problem_idx": "E", "shortId": "273E", "contest_number": "273", "problem_submissions": {"E": [3122057, 3120720, 3116725, 3122040, 3119368, 3121838, 3121574, 3121579, 3125606, 3120011], "D": [3119497, 3117520, 3123565, 3124849, 3121281, 3120768, 3117933, 3118228, 3123569, 3119311, 3122877, 3126278], "C": [3115563, 3119236, 3114688, 3117048, 3114860, 3116598, 3116734, 3117277, 3123467, 3122916, 3115814, 3123127, 3120446, 3126351], "B": [3113600, 3113886, 3112899, 3112808, 3114287, 3114846, 3113647, 3114818, 3114980, 3115379, 3114362, 3114126, 3114530, 3115262, 3115087, 3115234, 3115233], "A": [3112248, 3112373, 3112176, 3115660, 3112665, 3115057, 3112184, 3113078, 3122087, 3114179, 3112232, 3112611, 3112527, 3114570, 3113385, 3113821, 3112715]}, "name": "E. Dima and Game", "statement": "Dima and Anya love playing different games. Now Dima has imagined a new\r\ngame that he wants to play with Anya.Dima writes pairs of integers on a\r\npiece of paper . Then players take turns. On his turn the player can do\r\nthe following actions: choose the number of the pair , such that ;\r\nreplace pair number by pair or by pair . Notation means rounding down to\r\nthe closest integer. The player who can\u2019t make a move loses.Of course,\r\nDima wants Anya, who will move first, to win. That\u2019s why Dima should\r\nwrite out such pairs of integers , that if both players play optimally\r\nwell, the first one wins. Count the number of ways in which Dima can do\r\nit. Print the remainder after dividing the answer by number .Two ways\r\nare considered distinct, if the sequences of the written pairs are\r\ndistinct.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define SZ(c) ((int)(c).size())\n\ntypedef long long LL;\nconst int N = 100000;\nclass SG{\n    public:\n        int l, r, sg;\n        SG(){}\n        SG(int _l, int _r, int _sg) { l=_l; r=_r; sg=_sg;}\n} a[1005];\nint getsg(int x, int y) {\n    if(x!=0 && y!=0) return 0;\n    if(x!=1 && y!=1) return 1;\n    return 2;\n}\nconst int MOD = 1e9+7;\n\nLL trapezoid(int top, int bot) {\n    return (top + bot) * 1LL * (top - bot + 1) / 2;\n}\nvoid add(LL &x, LL v) {\n    x = (x+v)%MOD;\n}\n\nint main(void) {\n    int n, p;\n    scanf(\"%d%d\", &n, &p);\n\n    int m = 1, last=2;\n    a[0] = SG(0, 2, 0);\n    while(last < p) {\n        int x, u, v, i, j;\n        x = last+1;\n        u = x/3; v = x-x/3;\n        for(i=0;i<m;i++) if(u<=a[i].r && u>=a[i].l) break;\n        for(j=0;j<m;j++) if(v<=a[j].r && v>=a[j].l) break;\n        int ll=x, rr=p, mm, xx=x;\n        while(ll<=rr) {\n            mm=(ll+rr)/2;\n            if(mm/3 > a[i].r || mm - mm/3 > a[j].r) rr=mm-1;\n            else { xx=mm; ll = mm+1; }\n        }\n        a[m++] = SG(last+1, xx, getsg(a[i].sg, a[j].sg));\n        if(m>1 && a[m-1].sg == a[m-2].sg) {\n            --m;\n            a[m-1].r = a[m].r;\n        }\n        last = xx;\n        //printf(\"%d %d %d\\n\", a[m-1].l, a[m-1].r, a[m-1].sg);\n    }\n    \n    a[0].l = 1;\n    LL c[4]={};\n    for(int i=0;i<m;i++) {\n        add(c[a[i].sg], trapezoid(p-a[i].l, p-a[i].r));\n    }\n    LL ans[1005][4]={};\n    ans[0][0] = 1;\n    for(int i=0;i<n;i++) {\n        for(int j=0;j<4;j++)\n            for(int k=0;k<3;k++)\n                add(ans[i+1][j^k], ans[i][j] * c[k] % MOD);\n    }\n    LL sol = 0;\n    sol = ans[n][1] + ans[n][2] + ans[n][3];\n    sol = (sol % MOD+ MOD) % MOD;\n    printf(\"%I64d\\n\", sol);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "games"], "dificulty": "2600", "interactive": false}