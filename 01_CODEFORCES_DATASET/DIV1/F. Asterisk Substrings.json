{"link": "https://codeforces.com//contest/1276/problem/F", "problemId": "495593", "problem_idx": "F", "shortId": "1276F", "contest_number": "1276", "problem_submissions": {"D": [66855093, 66857065, 66845974, 66997276, 66858540, 66861684, 66862730, 66868898, 66866703, 66862266, 66863710, 66863337, 66865506, 66863170, 66863353, 66867792, 66869234, 66868492, 66866182, 66863049], "C": [66843940, 66846263, 66855304, 66856299, 66850349, 66850097, 66849241, 66845111, 66840733, 66851808, 66846583, 66853445, 66848190, 66854997, 66857353, 66855797, 66855510, 66860652, 66856100, 66851090], "B": [66838883, 66837202, 66851887, 66837950, 66845504, 66843521, 66841052, 66839337, 66846582, 66845011, 66837082, 66842169, 66845204, 66846655, 66853297, 66842949, 66842748, 66847818, 66847458, 66873447, 66868214], "A": [66836393, 66834386, 66848931, 66834574, 66835090, 66834499, 66835628, 66834748, 66844259, 66835765, 66834448, 66836891, 66834649, 66835369, 66834624, 66839341, 66838551, 66839846, 66837852, 66838233], "F": [66875333, 66866989, 68039784, 67198171, 67466141], "E": [93753835, 67190434, 67455260, 81662494]}, "name": "F. Asterisk Substrings", "statement": "Consider a string s of n lowercase English letters. Let t_i be the\r\nstring obtained by replacing the i-th character of s with an asterisk\r\ncharacter . For example, when s =\r\nmathtt{abc}, we have t_1 =\r\ntt{*bc}, t_2 =\r\ntt{a*c}, and t_3 =\r\ntt{ab*}.Given a string s, count the number of distinct strings of\r\nlowercase English letters and asterisks that occur as a substring of at\r\nleast one string in the set\r\n{s, t_1,\r\nldots, t_n\r\n}. The empty string should be counted.Note that \u2019s are just characters\r\nand do not play any special role as in, for example, regex matching.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\n\nstruct suffix_automaton {\n\tvector<map<char,int>> edges;\n\tvector<int> link, length;\n\tint last;\n\tsuffix_automaton(string s) {\n\t\tedges.push_back(map<char,int>());\n\t\tlink.push_back(-1);\n\t\tlength.push_back(0);\n\t\tlast = 0;\n\t\tfor (int i=0; i<(int)s.size(); i++) {\n\t\t\tedges.push_back(map<char,int>());\n\t\t\tlength.push_back(i+1);\n\t\t\tlink.push_back(0);\n\t\t\tint r = edges.size() - 1;\n\t\t\tint p = last;\n\t\t\twhile (p >= 0 && !edges[p].count(s[i])) {\n\t\t\t\tedges[p][s[i]] = r;\n\t\t\t\tp = link[p];\n\t\t\t}\n\t\t\tif (p != -1) {\n\t\t\t\tint q = edges[p][s[i]];\n\t\t\t\tif (length[p] + 1 == length[q]) {\n\t\t\t\t\tlink[r] = q;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tedges.push_back(edges[q]);\n\t\t\t\t\tlength.push_back(length[p] + 1);\n\t\t\t\t\tlink.push_back(link[q]);\n\t\t\t\t\tint qq = edges.size()-1;\n\t\t\t\t\tlink[q] = link[r] = qq;\n\t\t\t\t\twhile (p >= 0 && edges[p][s[i]] == q) {\n\t\t\t\t\t\tedges[p][s[i]] = qq;\n\t\t\t\t\t\tp = link[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = r;\n\t\t}\n\t}\n};\n\nsuffix_automaton X=suffix_automaton(\"\");\nsuffix_automaton Y=suffix_automaton(\"\");\n\nint n;\nchar wcz[nax];\n\nvi drz[nax][2];\n\nint m, k;\nll ma[nax][2];\n\nll sum[nax];\n\nll wyn;\n\nset <int> setel[nax];\nll trz[nax];\n\nint roz[nax], jump[nax], pre[nax], post[nax], fad[nax], czas, kt[nax];\nvoid dfs_roz(int v) {\n\troz[v]=1;                        // drz[] ma nie zawiera\u0107 kraw\u0119dzi\n\tfor (int &i : drz[v][1]) {          // do ojca.\n\t\tfad[i]=v;                    // Init:\n\t\tdfs_roz(i);                  // dfs_roz(root);\n\t\troz[v]+=roz[i];              // dfs_pre(root);\n\t\tif (roz[i]>roz[drz[v][1][0]])   // U\u017cycie get_path(v, u) zwr\u00f3ci\n\t\t\tswap(i, drz[v][1][0]);      // przedzia\u0142y odpowiadaj\u0105ce \u015bcie\u017cce\n\t}                                // z v do u. Przedzia\u0142y odpowiadaj\u0105ce\n}                                    // \u015bcie\u017cce z v do lca maj\u0105\nvoid dfs_pre(int v)                  // first>=second, za\u015b te dla \u015bcie\u017cki\n{                                    // z lca do u maj\u0105 first<=second.\n\tif (!jump[v])                    // Przedzia\u0142y s\u0105 po kolei.\n\t\tjump[v]=v;                   // Lca wyst\u0119puje w nich dwa razy,\n\tpre[v]=(++czas);                 // najpierw jako second,\n\tkt[pre[v]]=v;\n\tif (!drz[v][1].empty())             // a zaraz potem jako first.\n\t\tjump[drz[v][1][0]]=jump[v];\n\tfor (int i : drz[v][1])\n\t\tdfs_pre(i);\n\tpost[v]=czas;\n}\nint lca(int v, int u) {\n\twhile(jump[v]!=jump[u]) {\n\t\tif (pre[v]<pre[u])\n\t\t\tswap(v, u);\n\t\tv=fad[jump[v]];\n\t}\n\treturn (pre[v]<pre[u] ? v : u);\n}\nvector < pair <int,int> > path_up(int v, int u) {\n\tvector < pair <int,int> > ret;\n\twhile(jump[v]!=jump[u]) {\n\t\tret.push_back({pre[jump[v]], pre[v]});\n\t\tv=fad[jump[v]];\n\t}\n\tret.push_back({pre[u], pre[v]});\n\treturn ret;\n}\nvector < pair <int,int> > get_path(int v, int u) {\n\tint w=lca(v, u);\n\tauto ret=path_up(v, w);\n\tauto pom=path_up(u, w);\n\tfor (auto &i : ret)\n\t\tswap(i.first, i.second);\n\twhile(!pom.empty()) {\n\t\tret.push_back(pom.back());\n\t\tpom.pop_back();\n\t}\n\treturn ret;\n}\n\nvoid dfs1(int v)\n{\n\tsum[v]+=ma[v][1];\n\tfor (int i : drz[v][1])\n\t{\n\t\tsum[i]=sum[v];\n\t\tdfs1(i);\n\t}\n\t//~ debug() << \"dfs1 \" << v << \"    \" << ma[v][1] << \" \" << sum[v];\n}\n\nvoid dodaj(int v, int x)\n{\n\t//~ debug() << v << \" dodaje \" << x;\n\tif (setel[v].count(x))\n\t\treturn;\n\t//~ debug() << \"siedzi\";\n\tsetel[v].insert(x);\n\ttrz[v]+=sum[kt[x]];\n\tauto it=setel[v].find(x);\n\tint a=-1;\n\tif (it!=setel[v].begin())\n\t{\n\t\tit--;\n\t\tint y=(*it);\n\t\tit++;\n\t\ta=y;\n\t\ttrz[v]-=sum[lca(kt[y], kt[x])];\n\t}\n\tit++;\n\tint b=-1;\n\tif (it!=setel[v].end())\n\t{\n\t\tint y=(*it);\n\t\tb=y;\n\t\ttrz[v]-=sum[lca(kt[y], kt[x])];\n\t}\n\tif (a>0 && b>0)\n\t\ttrz[v]+=sum[lca(kt[a], kt[b])];\n\tit--;\n}\n\nvi pol[nax];\n\nint ga[nax];\nint gb[nax];\n\nvoid dfs2(int v)\n{\n\tfor (int i : pol[v])\n\t\tdodaj(v, pre[i]);\n\t//~ debug() << v << \" \" << pol[v] << \" \" << setel[v] << \"   \" << drz[v][0];\n\tfor (int i : drz[v][0])\n\t{\n\t\tdfs2(i);\n\t\tif ((int)setel[i].size()>(int)setel[v].size())\n\t\t{\n\t\t\tsetel[v].swap(setel[i]);\n\t\t\tswap(trz[v], trz[i]);\n\t\t}\n\t\tfor (int j : setel[i])\n\t\t\tdodaj(v, j);\n\t\tsetel[i].clear();\n\t}\n\t//~ debug() << v << \" \" << setel[v] << \"   \" << trz[v] << \" \" << ma[v][0];\n\t\n\twyn+=trz[v]*ma[v][0];\n}\n\nint main()\n{\n\tscanf(\"%s\", wcz+1);\n\tn=strlen(wcz+1);\n\tstring s=\"\";\n\tfor (int i=1; i<=n; i++)\n\t\ts.push_back(wcz[i]);\n\tX=suffix_automaton(s);\n\treverse(s.begin(), s.end());\n\tY=suffix_automaton(s);\n\treverse(s.begin(), s.end());\n\t\n\tm=X.edges.size();\n\tk=Y.edges.size();\n\tfor (int i=1; i<m; i++)\n\t{\n\t\tdrz[X.link[i]][0].push_back(i);\n\t\tma[i][0]=X.length[i]-X.length[X.link[i]];\n\t\t//~ debug() << \"1 \" << i << \"  \" << X.link[i] << \" \" << X.length[i];\n\t}\n\tfor (int i=1; i<k; i++)\n\t{\n\t\tdrz[Y.link[i]][1].push_back(i);\n\t\tma[i][1]=Y.length[i]-Y.length[Y.link[i]];\n\t\t//~ debug() << \"2 \" << i << \"  \" << Y.link[i] << \" \" << Y.length[i];\n\t}\n\tma[0][0]=ma[0][1]=1;\n\tfor (int i=0; i<m; i++)\n\t\twyn+=ma[i][0];\n\t//~ debug() << imie(wyn);\n\tdfs_roz(0);\n\tdfs_pre(0);\n\tdfs1(0);\n\t\n\tint v=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tga[i]=v;\n\t\tv=X.edges[v][wcz[i]];\n\t}\n\tv=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\tgb[i]=v;\n\t\tv=Y.edges[v][wcz[i]];\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\t//~ debug() << i << \" \" << ga[i] << \" \" << gb[i];\n\t\tpol[ga[i]].push_back(gb[i]);\n\t}\n\tdfs2(0);\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["string suffix structures"], "dificulty": "3400", "interactive": false}