{"link": "https://codeforces.com//contest/1630/problem/D", "problemId": "1275999", "problem_idx": "D", "shortId": "1630D", "contest_number": "1630", "problem_submissions": {"E": [144224769, 144215907, 144221628, 144228274, 144219804, 144218158, 144225764, 144238591, 144210990, 144217838, 144226182, 144224358, 144225778, 144221770, 144226514, 144222722, 144227026, 144226268, 144232930], "F": [144210863, 144246407, 144239829, 144237561, 144242088, 144244711, 144244456, 144246802, 144259720, 144255927, 144333444, 144255940, 144608342, 148502898, 148434493, 148432956], "D": [144197307, 144203996, 144209276, 144205176, 144207016, 144204010, 144211325, 144216890, 144199054, 144199808, 144201432, 144206931, 144201023, 144209262, 144204729, 144211122, 144210123, 144205407, 144205842], "C": [144191312, 144195772, 144199628, 144200731, 144196919, 144198723, 144205328, 144206861, 144191587, 144193957, 144195705, 144198126, 144190461, 144203715, 144198045, 144205577, 144200182, 144197491, 144198438], "B": [144182123, 144182453, 144193080, 144189508, 144185231, 144186871, 144189030, 144188822, 144178499, 144179435, 144183325, 144180542, 144180237, 144181268, 144190041, 144176578, 144186138, 144190693, 144189698], "A": [144175474, 144175629, 144182481, 144180498, 144176716, 144180161, 144180336, 144179468, 144172483, 144171609, 144171918, 144172250, 144173608, 144173794, 144181834, 144190017, 144177869, 144180828, 144177686]}, "name": "D. Flipping Range", "statement": "You are given an array a of n integers and a set B of m positive\r\nintegers such that 1\r\nleq b_i\r\nleq\r\nlfloor\r\nfrac{n}{2}\r\nrfloor for 1\r\nle i\r\nle m, where b_i is the i-th element of B. You can make the following\r\noperation on a: Select some x such that x appears in B. Select an\r\ninterval from array a of size x and multiply by -1 every element in the\r\ninterval. Formally, select l and r such that 1\r\nleq l\r\nleq r\r\nleq n and r-l+1=x, then assign a_i:=-a_i for every i such that l\r\nleq i\r\nleq r. Consider the following example, let a=[0,6,-2,1,-4,5] and B=\r\n{1,2\r\n}: [0,6,-2,-1,4,5] is obtained after choosing size 2 and l=4, r=5.\r\n[0,6,2,-1,4,5] is obtained after choosing size 1 and l=3, r=3. Find the\r\nmaximum\r\nsum\r\nlimits_{i=1}^n {a_i} you can get after applying such operation any\r\nnumber of times (possibly zero).\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nint gcd(int x, int y) {\n\treturn (y == 0 ? x : gcd(y, x % y));\n}\n\nconst ll INF = (ll)1e17;\nconst int N = (int)1e6 + 7;\nll a[N];\nint n, g;\nll dp[2][2];\n\nll solveDp(int r) {\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tdp[i][j] = -INF;\n\tdp[0][0] = 0;\n\tfor (int i = r; i < n; i += g) {\n\t\tdp[1][0] = dp[1][1] = -INF;\n\t\tfor (int x = 0; x < 2; x++)\n\t\t\tfor (int y = 0; y < 2; y++) {\n\t\t\t\tll w = a[i];\n\t\t\t\tif (x ^ y) w *= -1;\n\t\t\t\tw += dp[0][x];\n\t\t\t\tdp[1][y] = max(dp[1][y], w);\n\t\t\t}\n\t\tdp[0][0] = dp[1][0];\n\t\tdp[0][1] = dp[1][1];\n\t}\n\treturn dp[0][0];\n}\nll solve2() {\n\tll ans = 0;\n\tfor (int r = 0; r < g; r++)\n\t\tans += solveDp(r);\n\treturn ans;\n}\nvoid solve() {\n\tint m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tg = 0;\n\twhile(m--) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tg = gcd(g, x);\n\t}\n\tll ans = solve2();\n\tfor (int i = 0; i < g; i++)\n\t\ta[i] *= -1;\n\tans = max(ans, solve2());\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "greedy", "number theory"], "dificulty": "2400", "interactive": false}