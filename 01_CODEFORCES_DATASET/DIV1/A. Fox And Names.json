{
    "link": "https://codeforces.com//contest/512/problem/A",
    "problemId": "21642",
    "problem_idx": "A",
    "shortId": "512A",
    "contest_number": "512",
    "problem_submissions": {
        "E": [
            9689055,
            9689637,
            9689329,
            9688006,
            9687653,
            9689489,
            9689150,
            9686860,
            9690989,
            9687876
        ],
        "D": [
            9687125,
            9687387,
            9685060,
            9686450,
            9688310,
            9687526,
            9848172,
            9687098,
            9689725
        ],
        "C": [
            9684294,
            9683675,
            9686457,
            9682885,
            9681860,
            9683241,
            9686129,
            9685822,
            9688905,
            9683891,
            9686124,
            9685967,
            9682813,
            9687765,
            9684696,
            9686605,
            9690364,
            9690022
        ],
        "B": [
            9681311,
            9680720,
            9682911,
            9680295,
            9679957,
            9680851,
            9679895,
            9681573,
            9681772,
            9685086,
            9682711,
            9681029,
            9681643,
            9680950,
            9691594,
            9680058
        ],
        "A": [
            9679078,
            9679241,
            9683617,
            9678600,
            9678498,
            9679465,
            9682231,
            9681794,
            9679166,
            9679612,
            9683011,
            9689408,
            9679816,
            9678578,
            9678585,
            9679972,
            9678357
        ]
    },
    "name": "A. Fox And Names",
    "statement": "Fox Ciel is going to publish a paper on FOCS (Foxes Operated Computer\r\nSystems, pronounce: \"Fox\"). She heard a rumor: the authors list on the\r\npaper is always sorted in the order. After checking some examples, she\r\nfound out that sometimes it wasn\u2019t true. On some papers authors\u2019 names\r\nweren\u2019t sorted in order in normal sense. But it was always true that\r\nafter some modification of the order of letters in alphabet, the order\r\nof authors becomes !She wants to know, if there exists an order of\r\nletters in Latin alphabet such that the names on the paper she is\r\nsubmitting are following in the order. If so, you should find out any\r\nsuch order. order is defined in following way. When we compare and ,\r\nfirst we find the leftmost position with differing characters: . If\r\nthere is no such position (i. e. is a prefix of or vice versa) the\r\nshortest string is less. Otherwise, we compare characters and according\r\nto their order in alphabet.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T>\nbool uin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool uax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvi e[30];\nint vis[30];\n\nvi ord;\n\nbool dfs(int v) {\n    if (vis[v] == 2) return true;\n    if (vis[v] == 1) return false;\n    vis[v] = 1;\n    for (int u: e[v]) {\n        if (!dfs(u)) return false;\n    }\n    vis[v] = 2;\n    ord.pb(v);\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    vector<string> a(N);\n    forn(i, N) cin >> a[i];\n    bool ok = true;\n    forn(i, N - 1) {\n        int j = 0;\n        while (j < a[i].size() && j < a[i + 1].size() && a[i + 1][j] == a[i][j]) ++j;\n        if (j == a[i + 1].size() && j < a[i].size()) ok = false;\n        else if (j < a[i].size() && j < a[i + 1].size()) {\n            e[a[i][j] - 'a'].pb(a[i + 1][j] - 'a');\n//            cerr << a[i][j] << ' ' << a[i + 1][j] << '\\n';\n        }\n    }\n    forn(i, 26) ok &= dfs(i);\n    if (!ok) cout << \"Impossible\\n\";\n    else {\n        reverse(all(ord));\n        forn(i, 26) cout << (char)('a' + ord[i]);\n        cout << '\\n';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Fox And Names.json",
    "editorial_link": "https://codeforces.com/blog/entry/16173",
    "editorial": "Let\u00e2\u0080\u0099s first think about what can tell us: suppose and . Then we know\r\nthat if and only if by the definition. So we can transform the\r\nconditions , ... into the order of letters. Then the question become: do\r\nwe have a permutation that satisfy those conditions. It is actually the\r\nclassic topological order question. One trick in this task is that, if\r\nwe have something like then there is no solution. This is not covered in\r\npretests. :)\r\n"
}