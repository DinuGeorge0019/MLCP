{
    "link": "https://codeforces.com//contest/1817/problem/A",
    "problemId": "1897389",
    "problem_idx": "A",
    "shortId": "1817A",
    "contest_number": "1817",
    "problem_submissions": {
        "F": [
            204497444,
            204371393,
            203993098,
            203987643,
            204188728,
            204003142,
            203943098,
            204213507
        ],
        "D": [
            203955544,
            203961086,
            203937236,
            203945800,
            203945643,
            203942818,
            203943723,
            203947591,
            203989196,
            203948036,
            204052212,
            203947419,
            203952089,
            203947882,
            203954628
        ],
        "A": [
            203949751,
            203917796,
            203915319,
            203915702,
            203915256,
            203915135,
            203915119,
            203915216,
            203933837,
            203916532,
            203915895,
            203917033,
            203915580,
            203915390,
            203917321,
            203916497,
            203915656,
            203929967,
            203917829
        ],
        "E": [
            203947509,
            203943737,
            203948086,
            203949930,
            204001172,
            203962099,
            204158074,
            203951990,
            204009291,
            203987561,
            203984105,
            203980085,
            203953471,
            203990042,
            203976606,
            203976302,
            203953675,
            204066570,
            204065539,
            204106022
        ],
        "B": [
            203928063,
            203919631,
            203920186,
            203920581,
            203923300,
            203919216,
            203918930,
            203922691,
            203924157,
            203921090,
            203921763,
            203924664,
            203924354,
            203989898,
            203930016,
            203924048,
            203922828,
            203936658,
            203924723
        ],
        "C": [
            203916741,
            203929205,
            203922679,
            203923849,
            203928212,
            203926222,
            203931210,
            203933759,
            203932269,
            203931148,
            203930247,
            203931616,
            203931791,
            203922648,
            203924454,
            204016237,
            203932091,
            203930473,
            203925061,
            203933416
        ]
    },
    "name": "A. Almost Increasing Subsequence",
    "statement": "A sequence is if it does not contain three elements x, y, z such that x\r\nge y\r\nge z.You are given an array a_1, a_2,\r\ndots, a_n and q queries.Each query consists of two integers 1\r\nle l\r\nle r\r\nle n. For each query, find the length of the longest subsequence of the\r\nsubarray a_l, a_{l+1},\r\ndots, a_r. A subsequence is a sequence that can be derived from the\r\ngiven sequence by deleting zero or more elements without changing the\r\norder of the remaining elements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n), b(n);\n  for (int& x: a) cin >> x;\n  for (int i = 2; i < n; i++) {\n    b[i] = b[i-1] + (a[i] <= a[i-1] && a[i-1] <= a[i-2]);\n  }\n\n  while (q--) {\n    int l, r;\n    cin >> l >> r;\n    cout << r-l+1-(r == l ? 0 : b[r-1]-b[l]) << '\\n';\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Almost Increasing Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/115586",
    "editorial": "It is not obvious how the condition in the statement for an\r\nalmost-increasing subsequence can be turned into a fast data structure\r\nthat can support queries. So instead of tackling the problem head on,\r\nlet\u00e2\u0080\u0099s try to make an upperbound for how many elements can be in the\r\nmaximum length almost-increasing subsequence.Assume you\u00e2\u0080\u0099re given a query\r\nabout the subarray of the original array . Let\u00e2\u0080\u0099s partition this array\r\ninto decreasing subarrays. This means everytime when we place a cut\r\nbetween and . For example, consider the array , it will be cut into .\r\nAll these small subarrays are non-increasing, which means that any\r\nsubsequence of such a subarray is non-increasing. Because an\r\nalmost-increasing subsequence cannot have three consecutive elements ,\r\nin each of the subarrays of our partition at most elements can be chosen\r\nto insert into our almost-increasing subsequence. Actually we can put\r\nexactly elements of each subarray into the increasing subsequence, by\r\ntaking the first and the last element of each subarray. This is valid,\r\nbecause the cuts for the partition were made at places where , so every\r\nin our candidate subsequence is preceded and followed by a . By our\r\nupperbound, this construction is optimal.The sum, can be calculated for\r\none query in linear time, giving a solution. To optimize this, the sum\r\ncan be rewritten to , where inner elements of a subarray are all the\r\nelements that are not the first or last element. For such elements , we\r\nknow that . The sum of lengths over the partition sums to . So we\u00e2\u0080\u0099re\r\nleft with counting the number of indices such that . This can be done\r\nwith preprocessing and queries using prefix sums. For a query we can\r\noutput . There are some literal edgecases, where some care in the\r\nimplementation is needed.The total time complexity is .\r\n"
}