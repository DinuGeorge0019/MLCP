{
    "link": "https://codeforces.com//contest/1648/problem/D",
    "problemId": "1318592",
    "problem_idx": "D",
    "shortId": "1648D",
    "contest_number": "1648",
    "problem_submissions": {
        "E": [
            148585486,
            148584955,
            148581597,
            148589473,
            148591135,
            148593463,
            148593416,
            148597505,
            148594995,
            148595032,
            148597135,
            148605923,
            148598836,
            148596396,
            148600942,
            148602000,
            148600796,
            148581620,
            148583646,
            148661874,
            148661844,
            148587369
        ],
        "D": [
            148564585,
            148566578,
            148571497,
            148568116,
            148573822,
            148573519,
            148574211,
            148573964,
            148574945,
            148580191,
            148578139,
            148578497,
            148607894,
            148582725,
            148577475,
            148577301,
            148585962,
            148619534,
            148575997,
            148608357
        ],
        "C": [
            148552509,
            148552464,
            148553813,
            148558198,
            148558432,
            148554501,
            148557954,
            148555117,
            148558520,
            148556243,
            148554082,
            148553770,
            148555702,
            148554883,
            148560099,
            148557117,
            148552206,
            148558570,
            148554233,
            148559666
        ],
        "B": [
            148545010,
            148546110,
            148555976,
            148548495,
            148550449,
            148545480,
            148551044,
            148549564,
            148551420,
            148544796,
            148546968,
            148558793,
            148547056,
            148545781,
            148549549,
            148547973,
            148544722,
            148548048,
            148546238,
            148550231
        ],
        "A": [
            148541636,
            148541670,
            148541532,
            148543210,
            148543257,
            148541615,
            148546248,
            148544655,
            148547990,
            148541584,
            148542460,
            148542006,
            148542056,
            148542119,
            148542975,
            148543237,
            148541644,
            148542337,
            148541655,
            148542140
        ],
        "F": [
            148613542,
            151414821,
            211208832,
            211208769,
            211208727,
            211208586
        ]
    },
    "name": "D. Serious Business",
    "statement": "Dima is taking part in a show organized by his friend Peter. In this\r\nshow Dima is required to cross a 3\r\ntimes n rectangular field. Rows are numbered from 1 to 3 and columns are\r\nnumbered from 1 to n.The cell in the intersection of the i-th row and\r\nthe j-th column of the field contains an integer a_{i,j}. Initially\r\nDima\u2019s score equals zero, and whenever Dima reaches a cell in the row i\r\nand the column j, his score changes by a_{i,j}. Note that the score can\r\nbecome negative.Initially all cells in the first and the third row are\r\nmarked as available, and all cells in the second row are marked as\r\nunavailable. However, Peter offered Dima some help: there are q special\r\noffers in the show, the i-th special offer allows Dima to mark cells in\r\nthe second row between l_i and r_i as available, though Dima\u2019s score\r\nreduces by k_i whenever he accepts a special offer. Dima is allowed to\r\nuse as many special offers as he wants, and might mark the same cell as\r\navailable multiple times.Dima starts his journey in the cell (1, 1) and\r\nwould like to reach the cell (3, n). He can move either down to the next\r\nrow or right to the next column (meaning he could increase the current\r\nrow or column by 1), thus making n + 1 moves in total, out of which\r\nexactly n - 1 would be horizontal and 2 would be vertical.Peter promised\r\nDima to pay him based on his final score, so the sum of all numbers of\r\nall visited cells minus the cost of all special offers used. Please help\r\nDima to maximize his final score.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class Info,\n    class Merge = std::plus<Info>>\nstruct SegmentTree {\n    const int n;\n    const Merge merge;\n    std::vector<Info> info;\n    SegmentTree(int n) : n(n), merge(Merge()), info(4 << std::__lg(n)) {}\n    SegmentTree(std::vector<Info> init) : SegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = merge(info[2 * p], info[2 * p + 1]);\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y));\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n};\n\nstruct Max {\n    i64 x;\n    Max(i64 x = -1E18) : x(x) {};\n};\n\nMax operator+(const Max &a, const Max &b) {\n    return std::max(a.x, b.x);\n}\n\nstruct Pair {\n    i64 ans;\n    i64 a;\n    i64 b;\n    Pair() : ans(-1E18), a(-1E18), b(-1E18) {}\n    Pair(i64 a, i64 b) : ans(a + b), a(a), b(b) {}\n};\n\nPair operator+(const Pair &a, const Pair &b) {\n    Pair c;\n    c.ans = std::max({a.ans, b.ans, a.a + b.b});\n    c.a = std::max(a.a, b.a);\n    c.b = std::max(a.b, b.b);\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, q;\n    std::cin >> n >> q;\n    \n    std::vector c(3, std::vector<int>(n));\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < n; j++) {\n            std::cin >> c[i][j];\n        }\n    }\n    \n    std::vector<i64> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        a[i] += c[0][i];\n        if (i > 0) {\n            a[i] += a[i - 1];\n            a[i] -= c[1][i - 1];\n        }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n        b[i] += c[2][i];\n        if (i < n - 1) {\n            b[i] += b[i + 1];\n            b[i] -= c[1][i + 1];\n        }\n    }\n    \n    i64 ans = -1E18;\n    \n    SegmentTree<Max> seg(n);\n    for (int i = 0; i < n; i++) {\n        seg.modify(i, a[i]);\n    }\n    \n    std::vector<std::array<int, 3>> ranges(q);\n    for (int i = 0; i < q; i++) {\n        int l, r, k;\n        std::cin >> l >> r >> k;\n        l--;\n        ranges[i] = {l, r, k};\n    }\n    std::sort(ranges.begin(), ranges.end());\n    \n    for (auto [l, r, k] : ranges) {\n        auto v = seg.rangeQuery(l, r).x;\n        if (r < n) {\n            a[r] = std::max(a[r], v - k);\n            seg.modify(r, a[r]);\n        }\n    }\n    \n    SegmentTree<Pair> seg2(n);\n    for (int i = 0; i < n; i++) {\n        seg2.modify(i, Pair(a[i], b[i]));\n    }\n    \n    for (auto [l, r, k] : ranges) {\n        ans = std::max(ans, seg2.rangeQuery(l, r).ans - k);\n    }\n    \n    ans += std::accumulate(c[1].begin(), c[1].end(), 0LL);\n    \n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dp",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Serious Business.json",
    "editorial_link": "https://codeforces.com//blog/entry/100592",
    "editorial": "Let\u00e2\u0080\u0099s denote . Then define and as follows:Now we can transform the\r\nproblem to following: compute where is the minimal cost of unlocking\r\nsegment . Let\u00e2\u0080\u0099s define as the maximum profit for going from to , if the\r\nrightmost segment that we have used ends in (so it\u00e2\u0080\u0099s for some minus cost\r\nof covering segment , when we know that there\u00e2\u0080\u0099s a segment ending at\r\n).The calculation of is as follows: for all look through each segment,\r\nwhich ends at , and relax with . It can be calculated using segment\r\ntree.Now consider the optimal usage of segments. Fix the rightmost\r\nsegment. The profit for this segment usage should be for some on this\r\nsegment. So we can bruteforce the rightmost segment in our answer and\r\nrelax the overall answer with . Also there\u00e2\u0080\u0099s a case where taking only 1\r\nsegment is optimal, then we should relax the answer with . We can\r\ncalculate all of this using segment tree.Overall complexity is .\r\n"
}