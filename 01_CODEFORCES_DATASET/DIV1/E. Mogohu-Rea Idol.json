{
    "link": "https://codeforces.com//contest/87/problem/E",
    "problemId": "461",
    "problem_idx": "E",
    "shortId": "87E",
    "contest_number": "87",
    "problem_submissions": {
        "E": [
            480522,
            480373,
            480563,
            481052,
            487220,
            487031,
            486475,
            483729,
            480251,
            482514,
            479707,
            481257
        ],
        "D": [
            479023,
            478767,
            478527,
            480005,
            478079,
            479874,
            481953,
            479744,
            478788,
            480461,
            479633,
            479612,
            480061,
            1186292,
            480377
        ],
        "C": [
            477696,
            477515,
            477634,
            477346,
            478564,
            477717,
            482287,
            482259,
            482254,
            482249,
            478031,
            477748,
            478549,
            478513,
            478021,
            477556,
            477965,
            477701,
            478643,
            478646
        ],
        "B": [
            477395,
            477959,
            480915,
            478219,
            479510,
            478272,
            478602,
            479590,
            477948,
            477912,
            477626,
            478345,
            478853,
            480591,
            477860,
            478043
        ],
        "A": [
            477178,
            477245,
            477382,
            477797,
            478932,
            477255,
            477225,
            477234,
            477375,
            477368,
            477236,
            477191,
            477429,
            479893,
            477216,
            477325
        ]
    },
    "name": "E. Mogohu-Rea Idol",
    "statement": "A long time ago somewhere in the depths of America existed a powerful\r\ntribe governed by the great leader Pinnie-the-Wooh. Once the tribe\r\nconquered three Maya cities. Pinnie-the-Wooh grew concerned: there had\r\nto be some control over the conquered territories. That\u2019s why he\r\nappealed to the priests of the supreme god Mogohu-Rea for help.The\r\npriests conveyed the god\u2019s will to him: to control these three cities he\r\nshould put an idol to Mogohu-Rea that will create a religious field over\r\nthe cities. However, the idol is so powerful that it can easily drive\r\nthe people around it mad unless it is balanced by exactly three\r\nsacrifice altars, placed one in each city. To balance the idol the\r\naltars should be placed so that the center of mass of the system of\r\nthese three points coincided with the idol. When counting the center of\r\nmass consider that all the altars have the same mass.Now Pinnie-the-Wooh\r\nis thinking where to put the idol. He has a list of hills, that are\r\nsuitable to put an idol there. Help him to identify on which of them you\r\ncan put an idol without risking to fry off the brains of the cities\u2019\r\npopulation with the religious field.Each city has a shape of a convex\r\npolygon such that no three vertexes lie on a straight line. The cities\r\ncan intersect. Each altar should be attached to the city through a\r\nspecial ceremony, besides, it must be situated on the city\u2019s territory\r\n(possibly at the border). Thus, there may be several altars on a city\u2019s\r\nterritory, but exactly one of them will be attached to the city. The\r\naltars, the idol and the hills are points on the plane, some of them may\r\ncoincide.The hills are taken into consideration independently from each\r\nother, the altars\u2019 location for different hills may also be different.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <bitset>\n#include <cmath>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#define mp make_pair\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef long long int64;\ntypedef vector<int> vi;\n\ntemplate<class T> T abs(T x) {return x > 0 ? x : (-x); }\ntemplate<class T> T sqr(T x) {return x * x; }\n\ntypedef int64 D;\n\nstruct P {\n    D x, y;\n    P(D x = 0, D y = 0) : x(x), y(y) {} \n    P operator+(P a) {\n        return P(x + a.x, y + a.y);\n    }\n    P operator-(P a) {\n        return P(x - a.x, y - a.y);\n    }\n    P operator*(D k) {\n        return P(x * k, y * k);\n    }\n    D operator *(P a) {\n        return x * a.y - y * a.x;\n    }\n    D operator ^(P a) {\n        return x * a.x + y * a.y;\n    }\n    D len2() {\n        return x * x + y * y;\n    }\n    P perp() {\n        return P(y, -x);\n    }\n    bool operator==(P a) {\n        return x == a.x && y == a.y;\n    }\n    void load() {\n        int _x, _y;\n        scanf(\"%d%d\", &_x, &_y);\n        x = _x, y = _y;\n    }\n    int getPl() {\n        if (x < 0) return 1;\n        if (x == 0 && y < 0) return 1;\n        return 0;\n    }\n};\n\nbool cmp(P p, P q) {\n    int pl1 = p.getPl();\n    int pl2 = q.getPl();\n    if (pl1 != pl2) return pl1 < pl2;\n    return p * q > 0;\n}\n\nbool inside(P p1, P p2, P p3, P q) {\n    int64 s1 = (p2 - p1) * (p3 - p1);\n    int64 s2 = abs((p1 - q) * (p2 - q)) + abs((p2 - q) * (p3 - q)) + abs((p3 - q) * (p1 - q));\n    return abs(s1) == abs(s2);\n}\n\nP cv;\n\nbool cmp0(P p, P q) {\n    return cmp(p - cv, q - cv);\n}\n\nint main()\n{\n    vector<P> v;\n    P c(0, 0);\n    for (int it = 0; it < 3; ++it) {\n        int n;\n        cin >> n;\n        vector<P> w(n);\n        for (int i = 0; i < n; ++i)\n            w[i].load();\n        int ind = 0;\n        for (int i = 0; i < n; ++i)\n            if (mp(w[i].x, w[i].y) < mp(w[ind].x, w[ind].y))\n                ind = i;\n        rotate(w.begin(), w.begin() + ind, w.end());\n        c = c + w[0];\n        for (int i = 0; i < n; ++i) {\n            int j = (i + 1) % n;\n            v.pb(w[j] - w[i]);\n        }\n    }\n    sort(all(v), cmp);\n    vector<P> a;\n    for (int i = 0; i < sz(v); ) {\n        if (v[i].x == 0 && v[i].y == 0) {\n            ++i;\n            continue;\n        }\n        a.pb(c);\n        int j = i;\n        while (j < sz(v) && v[j] * v[i] == 0) {\n            c = c + v[j];\n            ++j;\n        }       \n        i = j;\n    }\n    int m;\n    cin >> m;\n    cv = a[0];\n    for (int i = 0; i < m; ++i) {\n        P p;\n        p.load();\n        p = p * 3LL;\n        int ind = lower_bound(a.begin() + 1, a.end(), p, cmp0) - a.begin();\n        ind %= sz(a);\n        if (ind == 0) ++ind;\n        int ind0 = (ind - 1 + sz(a)) % sz(a);\n        while (ind0 == ind || ind0 == 0) ind0 = (ind0 + 1) % sz(a);\n        bool res = inside(a[0], a[ind], a[ind0], p);\n        printf(\"%s\\n\", res ? \"YES\" : \"NO\");\n    }   \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Mogohu-Rea Idol.json",
    "editorial_link": "https://codeforces.com//blog/entry/2121",
    "editorial": "In this task we had to verify that the point is the centroid of the triangle formed by points of the given three polygons. Lets reformulate the problem. We should verify the existence of three points A, B, C, such that A belongs to the first polygon, B - to the second one, C - to the third one, and . Logically, you should understand what set of points determines this ,  you should understand how to build it and test a point on whether it belongs to the set or not. This set is called Minkowski sum. We will need only one of its properties: the sum of two convex polygons is a convex polygon whose sides coincide as vectors, with the sides of the original polygons. We will prove this later.\n\nHow do we use it now? The first thing that this property gives us is an algorithm to test for belonging. Once the sum is built you can test whether or not a point belongs to the sum using a standard algorithm of testing a point being inside of a convex polygon in logarithmic time. Also the constructing algorithm is immediately obtained. We just need to add the coordinates of the lowest (the leftmost of them) points of all three polygons. As a result, we get a point, which is the lower left for the sum polygon. The sides are now represented as a sorted by the polar angles list of parties of the original polygons (instead of sorting we may merge sorted arrays).\n\nProof.\n\nWe shall prove the correctness of the algorithm for two polygons, for three polygons the proof is just the same. Let the first polygon be represented by A and the second one - by B. Denote the sum as M.\n\nWe will prove that M is a convex set.\n\nChoose some . By definition,  Q,  (here and below the point is identified with its radius vector).\n\nLet\u0092s take some point .  We shall prove that .\n\nAs G lies on the [AB], .\n\nNote that the first bracket is obviously some point lying on the segment [PE]. That means the point lying inside the polygon A, since A is convex. Similarly, the second bracket is inside B. Hence, their sum, i.e., G, lies in the Minkowski sum. This means that the Minkowski sum is a convex set.\n\n\nLet us consider some side XY of the first polygon. Let's rotate the plane so that the side XY was horizontal and that the polygon lied above the XY line.\n\nConsider the lowest horizontal line intersecting B. Let it cross B along the segment of PR, where point P does not lie further to the right of the R (it is clear that PR can turn out to be a degenerate segment from one vertex or the segment between two consquent verteces). Let's call PR the lowest segment of the polygon. Then we construct in the similar way the lowest segment UV of polygon M.\n\nLet's prove that - if not, let  . It is clear that x and p are the lowest points of the polygons A and B - otherwise one of them can be moved to a small vector d, which lies in the lower half-plane, so that the point remained within its polygon. In this case U will move the same way to d, which contradicts the fact that U is one of the lowest points of the polygon.\n\nThus, x and p are the lowest points of their polygons. Similarly, x and p are the leftmost points on the lowest segments of their polygons - otherwise we shift x or p to vector d that is directed to the left. It is also a contradiction - the U point stops to be the leftmost lower point.\n\nHence, U = X + P. Similarly, V = Y + Q. Hence, .\n\n\nThus, the sequence of sides M as vectors in the, for instance, counterclockwise order, is nothing other than the union of sides of A and B as vectors in the counterclockwise order, that immediately proves the correctness of the algorithm."
}