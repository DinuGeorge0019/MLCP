{"link": "https://codeforces.com//contest/380/problem/B", "problemId": "5530", "problem_idx": "B", "shortId": "380B", "contest_number": "380", "problem_submissions": {"A": [5676030, 5677444, 5667291, 5667878, 5667181, 5667622, 5667888, 5676828, 5666938, 5673846, 5670879, 5671395, 5669327, 5667863, 5667948, 5667971], "B": [5675030, 5677446, 5675293, 5674969, 5675596, 5677558], "E": [5673042, 5677453, 5674068, 5676554, 5676509, 5676152, 5673443, 5674960, 5673247, 5668823, 5671385, 5675127, 5674081, 6260429, 6260427, 6260419, 6260414, 6260386, 6260376, 6260372], "C": [5670663, 5677450, 5668629, 5669869, 5669624, 5673114, 5670447, 5670550, 5670519, 5668457, 5669925, 5671669, 5675539, 5669908, 5671123], "D": [5669162, 5677451, 5672118, 5672469, 5675471, 5671822, 5674127, 5674948, 5672625, 5672722, 5676148, 5674145, 5674258, 5673843, 5674777]}, "name": "B. Sereja and Tree", "statement": "Sereja adores trees. Today he came up with a revolutionary new type of\r\nbinary root trees.His new tree consists of levels, each vertex is\r\nindexed by two integers: the number of the level and the number of the\r\nvertex on the current level. The tree root is at level , its index is .\r\nHere is a pseudo code of tree construction.//the global data are integer\r\narrays cnt[], left[][], right[][]cnt[1] = 1;fill arrays left[][],\r\nright[][] with values -1;for(level = 1; level < n; level = level + 1){\r\ncnt[level + 1] = 0; for(position = 1; position <= cnt[level]; position =\r\nposition + 1){ if(the value of position is a power of two){ // that is,\r\n1, 2, 4, 8... left[level][position] = cnt[level + 1] + 1;\r\nright[level][position] = cnt[level + 1] + 2; cnt[level + 1] =\r\ncnt[level + 1] + 2; }else{ right[level][position] = cnt[level + 1] + 1;\r\ncnt[level + 1] = cnt[level + 1] + 1; } }}After the pseudo code is run,\r\ncell contains the number of vertices on level . Cell contains the number\r\nof the vertex on the level , which is the left child of the vertex with\r\nindex , or it contains -1, if the vertex doesn\u2019t have a left child.\r\nSimilarly, cell is responsible for the right child. You can see how the\r\ntree with looks like in the notes.Serja loves to make things\r\ncomplicated, so he first made a tree and then added an empty set for\r\neach vertex. Then Sereja executes operations. Each operation is of one\r\nof the two following types: The format of the operation is \" \". For all\r\nvertices add value to set . The format of the operation is \" \". For\r\nvertex , find the union of all sets of vertices that are in the subtree\r\nof vertex . Print the size of the union of these sets. Help Sereja\r\nexecute the operations. In this problem a set contains only distinct\r\nvalues like std::set in C++.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define MAX 200000\nint L[MAX],R[MAX];\n\nbool two(int x){\n    while(x % 2 == 0) x /= 2;\n    return (x == 1);\n}\n\nint query[7010][5];\nint low[7010],high[7010];\nbool used[1000010];\n\nint main(void){\n    int H,Q,i,j;\n    \n    int next = 1;\n    for(i=1;i<MAX;i++){\n        if(two(i)){\n            L[i] = next;\n            R[i] = next + 1;\n            next += 2;\n        } else {\n            L[i] = R[i] = next;\n            next++;\n        }\n    }\n    \n    cin >> H >> Q;\n    REP(i,Q){\n        scanf(\"%d\", &query[i][0]);\n        if(query[i][0] == 1){\n            scanf(\"%d%d%d%d\", &query[i][1], &query[i][2], &query[i][3], &query[i][4]);\n        } else {\n            scanf(\"%d%d\", &query[i][1], &query[i][2]);\n        }\n    }\n    \n    REP(i,Q) if(query[i][0] == 2){\n        REP(j,7010) low[j] = high[j] = -1;\n        low[query[i][1]] = high[query[i][1]] = query[i][2];\n        for(j=query[i][1]+1;j<=H;j++){\n            low[j] = L[low[j-1]];\n            high[j] = R[high[j-1]];\n        }\n        \n        int ans = 0;\n        REP(j,i) if(query[j][0] == 1){\n            int h = query[j][1];\n            int l = query[j][2];\n            int r = query[j][3];\n            int x = query[j][4];\n            if(low[h] <= r && high[h] >= l && !used[x]){\n                used[x] = true;\n                ans++;\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n        \n        REP(j,i) if(query[j][0] == 1){\n            int x = query[j][4];\n            used[x] = false;\n        }\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "implementation"], "dificulty": "2400", "interactive": false}