{
    "link": "https://codeforces.com//contest/715/problem/B",
    "problemId": "71751",
    "problem_idx": "B",
    "shortId": "715B",
    "contest_number": "715",
    "problem_submissions": {
        "C": [
            20696388,
            20695004,
            21061298,
            20699940,
            20701250,
            20701868,
            20701116,
            20702792,
            20705491,
            20706113,
            20706200,
            20706281,
            20707436,
            24089587,
            24089381,
            24088919,
            20705717,
            20710613,
            20711318,
            20708989,
            20702215
        ],
        "B": [
            20690967,
            20701021,
            20694773,
            20689928,
            20695175,
            20694958,
            20694279,
            20691617,
            20695201,
            20696087,
            20696649,
            20697145,
            20700774,
            20699191,
            20696353,
            20693835,
            20699900,
            20710746
        ],
        "A": [
            20686008,
            20686996,
            20686577,
            20686363,
            20687890,
            20687984,
            20686198,
            20687360,
            20686283,
            20689813,
            20687583,
            20686153,
            20687354,
            20704067,
            20689971,
            20689194,
            20690664,
            20687863,
            20690670,
            20692537
        ],
        "D": [
            20709863,
            20712963,
            20746777,
            20704223,
            20700524
        ]
    },
    "name": "B. Complete The Graph",
    "statement": "ZS the Coder has drawn an undirected graph of vertices numbered from to\r\nand edges between them. Each edge of the graph is weighted, each weight\r\nis a .The next day, ZS the Coder realized that some of the weights were\r\nerased! So he wants to reassign weight to each of the edges which\r\nweights were erased, so that the length of the shortest path between\r\nvertices and in the resulting graph is exactly . Can you help him?\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst ll inf=1ll<<60;\nconst int N=10100;\nvector<PII> e[N];\nll dis[N];\nint vis[N];\nset<pair<ll,int> > hs;\nint u[N],v[N],w[N],n,m,L,s,t;\nVI eg;\nvoid dijkstra(int S,int n) {\n\trep(i,0,n) dis[i]=inf,vis[i]=0;\n\tdis[S]=0;\n\trep(i,0,n) hs.insert(mp(dis[i],i));\n\trep(i,0,n) {\n\t\tint u=hs.begin()->se; hs.erase(hs.begin());\n\t\tvis[u]=1;\n\t\trep(j,0,SZ(e[u])) {\n\t\t\tint v=e[u][j].fi;\n\t\t\tif (dis[v]>dis[u]+e[u][j].se) {\n\t\t\t\ths.erase(mp(dis[v],v));\n\t\t\t\tdis[v]=dis[u]+e[u][j].se;\n\t\t\t\ths.insert(mp(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll check(ll x) {\n\trep(i,0,SZ(eg)) {\n\t\tw[eg[i]]=1+min(x,1000000000ll);\n\t\tx-=w[eg[i]]-1;\n\t}\n\trep(i,0,n) e[i].clear();\n\trep(i,0,m) {\n\t\te[u[i]].pb(mp(v[i],w[i]));\n\t\te[v[i]].pb(mp(u[i],w[i]));\n\t}\n\tdijkstra(s,n);\n\treturn dis[t];\n}\nint main() {\n\tscanf(\"%d%d%d%d%d\",&n,&m,&L,&s,&t);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",u+i,v+i,w+i);\n\t\tif (w[i]==0) eg.pb(i);\n\t}\n\tll l=-1,r=1000000000ll*SZ(eg);\n\tif (check(0)>L||check(r)<L) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n\twhile (l+1<r) {\n\t\tll md=(l+r)>>1;\n\t\tif (check(md)>=L) r=md; else l=md;\n\t}\n\tcheck(r);\n\trep(i,0,m) {\n\t\tprintf(\"%d %d %d\\n\",u[i],v[i],w[i]);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Complete The Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/47169",
    "editorial": "Prerequisites : Dijkstraâs Algorithm This problem is actually quite\r\nsimple if you rule out the impossible conditions. Call the edges that\r\ndoes not have fixed weight variable edges. First, weâll determine when a\r\nsolution exists. Firstly, we ignore the variable edges. Now, find the\r\nlength of the shortest path from to . If this length is , there is no\r\nsolution, since even if we replace the weights with any positive weight\r\nthe shortest path will never exceed this shortest path. Thus, if the\r\nlength of this shortest path is , there is no solution. (If no path\r\nexists we treat the length as .) Next, we replace the edges with weight\r\nwith weight . Clearly, among all the possible graphs you can generate by\r\nreplacing the weights, this graph will give the minimum possible\r\nshortest path from to , since increasing any weight will not decrease\r\nthe length of the shortest path. Thus, if the shortest path of this\r\ngraph is , there is no solution, since the shortest path will always be\r\n. If no path exists we treat the length as . Other than these two\r\nconditions, there will always be a way to assign the weights so that the\r\nshortest path from to is exactly ! How do we prove this? First, consider\r\nall paths from to that has at least one weight edge, as changing weights\r\nwonât affect the other paths. Now, we repeat this algorithm. Initially,\r\nassign all the weights as . Then, sort the paths in increasing order of\r\nlength. If the length of the shortest path is equal to , weâre done.\r\nOtherwise, increase the weight of one of the variable edges on the\r\nshortest path by . Note that this will increase the lengths of some of\r\nthe paths by . It is not hard to see that by repeating these operations\r\nthe shortest path will eventually have length , so an assignment indeed\r\nexists. Now, we still have to find a valid assignment of weights. We can\r\nuse a similar algorithm as our proof above. Assign to all variable edges\r\nfirst. Next, we first find and keep track of the shortest path from to .\r\nNote that if this path has no variable edges it must have length exactly\r\nor strictly more than , so either weâre already done or the shortest\r\npath contains variable edges and the length is strictly less than .\r\n(otherwise weâre done) From now on, whenever we assign weight to a\r\nvariable edge (after assigning to every variable edge), we call the edge\r\nassigned. Now, mark all variable edges not on the shortest path we found\r\nas weight. (we can choose any number greater than as ) Next, we will\r\nfind the shortest path from to , and replace the weight of an unassigned\r\nvariable edge such that the length of the path becomes equal to . Now,\r\nwe donât touch the assigned edges again. While the shortest path from to\r\nis still strictly less than , we repeat the process and replace a\r\nvariable edge that is not assigned such that the path length is equal to\r\n. Note that this is always possible, since otherwise this wouldâve been\r\nthe shortest path in one of the previous steps. Eventually, the shortest\r\npath from to will have length exactly . It is easy to see that we can\r\nrepeat this process at most times because we are only replacing the\r\nedges which are on the initial shortest path we found and there are less\r\nthan edges to replace (we only touch each edge at most once). Thus, we\r\ncan find a solution after less than iterations. So, the complexity\r\nbecomes . This is sufficient to pass all tests. What if the constraints\r\nwere ? Can we do better? Yes! Thanks to HellKitsune who found this\r\nsolution during testing. First, we rule out the impossible conditions\r\nlike we did above. Then, we assign all the variable edges with weight.\r\nWe enumerate the variable edges arbitarily. Now, we binary search to\r\nfind the minimal value such that if we make all the variable edges\r\nnumbered from to have weight and the rest , then the shortest path from\r\nto has length . Now, note that if we change the weight of to the length\r\nof shortest path will be more than . (if equals the number of variable\r\nedges, the length of the shortest path is still more than or it will\r\ncontradict the impossible conditions) If the weight is , the length of\r\nthe shortest path is . So, if we increase the weight of edge by\r\nrepeatedly, the length of the shortest path from to will eventually\r\nreach , since this length can increase by at most in each move. So,\r\nsince the length of shortest path is non-decreasing when we increase the\r\nweight of this edge, we can binary search for the correct weight. This\r\ngives an solution. Time Complexity : or Code (O(mnlogn))\r\n",
    "hint": []
}