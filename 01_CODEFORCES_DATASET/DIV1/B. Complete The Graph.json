{"link": "https://codeforces.com//contest/715/problem/B", "problemId": "71751", "problem_idx": "B", "shortId": "715B", "contest_number": "715", "problem_submissions": {"C": [20696388, 20695004, 21061298, 20699940, 20701250, 20701868, 20701116, 20702792, 20705491, 20706113, 20706200, 20706281, 20707436, 24089587, 24089381, 24088919, 20705717, 20710613, 20711318, 20708989, 20702215], "B": [20690967, 20701021, 20694773, 20689928, 20695175, 20694958, 20694279, 20691617, 20695201, 20696087, 20696649, 20697145, 20700774, 20699191, 20696353, 20693835, 20699900, 20710746], "A": [20686008, 20686996, 20686577, 20686363, 20687890, 20687984, 20686198, 20687360, 20686283, 20689813, 20687583, 20686153, 20687354, 20704067, 20689971, 20689194, 20690664, 20687863, 20690670, 20692537], "D": [20709863, 20712963, 20746777, 20704223, 20700524]}, "name": "B. Complete The Graph", "statement": "ZS the Coder has drawn an undirected graph of vertices numbered from to\r\nand edges between them. Each edge of the graph is weighted, each weight\r\nis a .The next day, ZS the Coder realized that some of the weights were\r\nerased! So he wants to reassign weight to each of the edges which\r\nweights were erased, so that the length of the shortest path between\r\nvertices and in the resulting graph is exactly . Can you help him?\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst ll inf=1ll<<60;\nconst int N=10100;\nvector<PII> e[N];\nll dis[N];\nint vis[N];\nset<pair<ll,int> > hs;\nint u[N],v[N],w[N],n,m,L,s,t;\nVI eg;\nvoid dijkstra(int S,int n) {\n\trep(i,0,n) dis[i]=inf,vis[i]=0;\n\tdis[S]=0;\n\trep(i,0,n) hs.insert(mp(dis[i],i));\n\trep(i,0,n) {\n\t\tint u=hs.begin()->se; hs.erase(hs.begin());\n\t\tvis[u]=1;\n\t\trep(j,0,SZ(e[u])) {\n\t\t\tint v=e[u][j].fi;\n\t\t\tif (dis[v]>dis[u]+e[u][j].se) {\n\t\t\t\ths.erase(mp(dis[v],v));\n\t\t\t\tdis[v]=dis[u]+e[u][j].se;\n\t\t\t\ths.insert(mp(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll check(ll x) {\n\trep(i,0,SZ(eg)) {\n\t\tw[eg[i]]=1+min(x,1000000000ll);\n\t\tx-=w[eg[i]]-1;\n\t}\n\trep(i,0,n) e[i].clear();\n\trep(i,0,m) {\n\t\te[u[i]].pb(mp(v[i],w[i]));\n\t\te[v[i]].pb(mp(u[i],w[i]));\n\t}\n\tdijkstra(s,n);\n\treturn dis[t];\n}\nint main() {\n\tscanf(\"%d%d%d%d%d\",&n,&m,&L,&s,&t);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",u+i,v+i,w+i);\n\t\tif (w[i]==0) eg.pb(i);\n\t}\n\tll l=-1,r=1000000000ll*SZ(eg);\n\tif (check(0)>L||check(r)<L) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n\twhile (l+1<r) {\n\t\tll md=(l+r)>>1;\n\t\tif (check(md)>=L) r=md; else l=md;\n\t}\n\tcheck(r);\n\trep(i,0,m) {\n\t\tprintf(\"%d %d %d\\n\",u[i],v[i],w[i]);\n\t}\n}\n"], "input": "", "output": "", "tags": ["binary search", "constructive algorithms", "graphs", "shortest paths"], "dificulty": "2300", "interactive": false}