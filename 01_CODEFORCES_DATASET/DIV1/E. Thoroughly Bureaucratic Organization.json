{
    "link": "https://codeforces.com//contest/201/problem/E",
    "problemId": "1459",
    "problem_idx": "E",
    "shortId": "201E",
    "contest_number": "201",
    "problem_submissions": {
        "D": [
            1842426,
            1845322,
            1848015,
            2017065,
            1845704,
            1843679,
            1843165,
            1843645,
            1843721,
            1842642,
            3962764,
            1843892
        ],
        "E": [
            1841059,
            1842295,
            1842570,
            1848002,
            1842412,
            1843333,
            1841361,
            1842083,
            1843064,
            1842151,
            1843347
        ],
        "A": [
            1840364,
            1839374,
            1839153,
            1847954,
            1840731,
            1839399,
            1844333,
            1839094,
            1839993,
            1841295,
            1840073,
            1839956,
            1838952,
            1839521,
            1838849,
            1839719,
            1839105,
            1839524
        ],
        "C": [
            1840066,
            1840781,
            1840491,
            1847992,
            1840261,
            1840947,
            1839278,
            1840815,
            1841258,
            1842024,
            1841894,
            1844043,
            1841094,
            1844134,
            1840094,
            1867350,
            1840802,
            1840979
        ],
        "B": [
            1839596,
            1838940,
            1839961,
            1847965,
            1841485,
            1840001,
            1840567,
            1839860,
            1841578,
            1839437,
            1840889,
            1840454,
            1839972,
            1839833,
            1841387,
            1839459,
            1840240,
            1840100,
            1840475
        ]
    },
    "name": "E. Thoroughly Bureaucratic Organization",
    "statement": "Once people simultaneously signed in to the reception at the recently\r\nopened, but already thoroughly bureaucratic organization (abbreviated\r\nTBO). As the organization is thoroughly bureaucratic, it can accept and\r\ncater for exactly one person per day. As a consequence, each of people\r\nmade an appointment on one of the next days, and no two persons have an\r\nappointment on the same day.However, the organization workers are very\r\nirresponsible about their job, so none of the signed in people was told\r\nthe exact date of the appointment. The only way to know when people\r\nshould come is to write some requests to TBO.The request form consists\r\nof empty lines. Into each of these lines the name of a signed in person\r\ncan be written (it can be left blank as well). Writing a person\u2019s name\r\nin the same form twice is forbidden, such requests are ignored. TBO\r\nresponds very quickly to written requests, but the reply format is of\r\nvery poor quality that is, the response contains the correct appointment\r\ndates for all people from the request form, but the dates are in\r\ncompletely random order. Responds to all requests arrive simultaneously\r\nat the end of the day (each response specifies the request that it\r\nanswers).Fortunately, you aren\u2019t among these lucky guys. As an observer,\r\nyou have the following task given and , determine the minimum number of\r\nrequests to submit to TBO to clearly determine the appointment date for\r\neach person.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nbool can(ll N, ll M, ll K){\n    int i;\n    \n    if(K < 40 && (1ll<<K) < N) return false;\n    \n    ll cnt = 0, sum = 0, x = 1;\n    for(i=0;;i++){\n        ll tmp = min(N-cnt,x);\n        cnt += tmp; sum += tmp * i;\n        if(cnt == N) break;\n        x = x * (K - i) / (i + 1);\n    }\n    \n    M = min(M,N-M);\n    return (sum <= K * M);\n}\n\nint theMin(int N, int M){\n    int high = N-1, low = 0;\n    \n    if(N == 1) return 0;\n    \n    while(high-low > 1){\n        int mid = (high + low) / 2;\n        if(can(N,M,mid)) high = mid; else low = mid;\n    }\n    \n    return high;\n}\n    \nint main(void){\n    int T,t,N,M;\n        \n    cin >> T;\n    REP(t,T){\n        cin >> N >> M;\n        if(M > N/2) M = N/2;\n        int ans = theMin(N,M);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Thoroughly Bureaucratic Organization.json",
    "editorial_link": "https://codeforces.com/blog/entry/4808",
    "editorial": "Let's imagine that we have a magic function maxN(m,?k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.\n\nSuppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.\n\nThe constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m,?k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k\u00b7m. As we'll prove later, the answer won't change.\n\nWith this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k\u00b7m). Then at the i-th step we can take at most  strings containing i ones. Let's add p to the answer and subtract p\u00b7i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.\n\nIt can be shown that the overall complexity of this algorithm is at most O(log2 n).\n\nThe remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).\n\nLet's solve the problem with a greedy algorithm with the k\u00b7m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x?>?y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x?>?y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal."
}