{"link": "https://codeforces.com//contest/201/problem/E", "problemId": "1459", "problem_idx": "E", "shortId": "201E", "contest_number": "201", "problem_submissions": {"D": [1842426, 1845322, 1848015, 2017065, 1845704, 1843679, 1843165, 1843645, 1843721, 1842642, 3962764, 1843892], "E": [1841059, 1842295, 1842570, 1848002, 1842412, 1843333, 1841361, 1842083, 1843064, 1842151, 1843347], "A": [1840364, 1839374, 1839153, 1847954, 1840731, 1839399, 1844333, 1839094, 1839993, 1841295, 1840073, 1839956, 1838952, 1839521, 1838849, 1839719, 1839105, 1839524], "C": [1840066, 1840781, 1840491, 1847992, 1840261, 1840947, 1839278, 1840815, 1841258, 1842024, 1841894, 1844043, 1841094, 1844134, 1840094, 1867350, 1840802, 1840979], "B": [1839596, 1838940, 1839961, 1847965, 1841485, 1840001, 1840567, 1839860, 1841578, 1839437, 1840889, 1840454, 1839972, 1839833, 1841387, 1839459, 1840240, 1840100, 1840475]}, "name": "E. Thoroughly Bureaucratic Organization", "statement": "Once people simultaneously signed in to the reception at the recently\r\nopened, but already thoroughly bureaucratic organization (abbreviated\r\nTBO). As the organization is thoroughly bureaucratic, it can accept and\r\ncater for exactly one person per day. As a consequence, each of people\r\nmade an appointment on one of the next days, and no two persons have an\r\nappointment on the same day.However, the organization workers are very\r\nirresponsible about their job, so none of the signed in people was told\r\nthe exact date of the appointment. The only way to know when people\r\nshould come is to write some requests to TBO.The request form consists\r\nof empty lines. Into each of these lines the name of a signed in person\r\ncan be written (it can be left blank as well). Writing a person\u2019s name\r\nin the same form twice is forbidden, such requests are ignored. TBO\r\nresponds very quickly to written requests, but the reply format is of\r\nvery poor quality that is, the response contains the correct appointment\r\ndates for all people from the request form, but the dates are in\r\ncompletely random order. Responds to all requests arrive simultaneously\r\nat the end of the day (each response specifies the request that it\r\nanswers).Fortunately, you aren\u2019t among these lucky guys. As an observer,\r\nyou have the following task given and , determine the minimum number of\r\nrequests to submit to TBO to clearly determine the appointment date for\r\neach person.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nbool can(ll N, ll M, ll K){\n    int i;\n    \n    if(K < 40 && (1ll<<K) < N) return false;\n    \n    ll cnt = 0, sum = 0, x = 1;\n    for(i=0;;i++){\n        ll tmp = min(N-cnt,x);\n        cnt += tmp; sum += tmp * i;\n        if(cnt == N) break;\n        x = x * (K - i) / (i + 1);\n    }\n    \n    M = min(M,N-M);\n    return (sum <= K * M);\n}\n\nint theMin(int N, int M){\n    int high = N-1, low = 0;\n    \n    if(N == 1) return 0;\n    \n    while(high-low > 1){\n        int mid = (high + low) / 2;\n        if(can(N,M,mid)) high = mid; else low = mid;\n    }\n    \n    return high;\n}\n    \nint main(void){\n    int T,t,N,M;\n        \n    cin >> T;\n    REP(t,T){\n        cin >> N >> M;\n        if(M > N/2) M = N/2;\n        int ans = theMin(N,M);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "combinatorics"], "dificulty": "2600", "interactive": false}