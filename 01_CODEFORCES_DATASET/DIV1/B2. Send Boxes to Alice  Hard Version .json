{
    "link": "https://codeforces.com//contest/1254/problem/B2",
    "problemId": "475571",
    "problem_idx": "B2",
    "shortId": "1254B2",
    "contest_number": "1254",
    "problem_submissions": {
        "E": [
            65385076,
            65389059,
            65387406,
            65386461,
            65391860,
            65388358,
            65363435,
            65898589,
            65898484,
            65394164,
            65399861,
            66201727,
            65511222,
            65387985,
            65459118,
            65393939,
            65393500,
            65393329
        ],
        "D": [
            65367776,
            65371157,
            65363228,
            65371547,
            65376523,
            65913436,
            65376504,
            65392793,
            65392745,
            65392458,
            65378396,
            65374788,
            65374479,
            65375973,
            72224123,
            72224118,
            72222073,
            66201641,
            66201609,
            65765881,
            65505837,
            65498656,
            65498523,
            65498350,
            65448275,
            65421529,
            65421428,
            65420506,
            65420496,
            65420340,
            65420220,
            65419939,
            65419809,
            65419466,
            65419306,
            65410495,
            65410139,
            65394253,
            65394071,
            65393989,
            65393862,
            65393694,
            65393607,
            65393012,
            65391960,
            65391551,
            65372156,
            65379236,
            65379295,
            65458244,
            65380498,
            65379619,
            65398630,
            65392892,
            65392821,
            65392515,
            65379510,
            65376362,
            65378466,
            65385723
        ],
        "C": [
            65362906,
            65363606,
            65372750,
            65364742,
            65368283,
            65376926,
            65364286,
            65368353,
            65366513,
            65367352,
            65362577,
            65365184,
            65369353,
            65366181,
            65364840,
            65369974,
            65366318,
            65369506
        ],
        "B1": [
            65358065,
            65358880,
            65365540,
            65357743,
            65359033,
            65368715,
            65359200,
            65362593,
            65360678,
            65362903,
            65376471,
            65360693,
            65359085,
            65359111,
            65357280,
            65361721,
            65360645,
            65360620,
            65355048
        ],
        "B2": [
            65357919,
            65358760,
            65365394,
            65357802,
            65363382,
            65368676,
            65359261,
            65362680,
            65360774,
            65362731,
            65376512,
            65360901,
            65359018,
            65358907,
            65360708,
            65398529,
            65398522,
            65398389,
            65398370,
            65398329,
            65398291,
            65398212,
            65361653,
            65360607,
            65360509,
            65354503
        ],
        "A": [
            65355800,
            65355044,
            65354936,
            65355999,
            65356253,
            65372457,
            65355826,
            65357065,
            65357334,
            65359043,
            65356279,
            65357553,
            65355832,
            65355374,
            65354099,
            65354766,
            65367155,
            65356549,
            65357393
        ]
    },
    "name": "B2. Send Boxes to Alice  Hard Version ",
    "statement": "Christmas is coming, and our protagonist, Bob, is preparing a\r\nspectacular present for his long-time best friend Alice. This year, he\r\ndecides to prepare n boxes of chocolate, numbered from 1 to n.\r\nInitially, the i-th box contains a_i chocolate pieces.Since Bob is a\r\ntypical nice guy, he will not send Alice n empty boxes. In other words,\r\n. Since Alice dislikes coprime sets, she will be happy only if there\r\nexists some integer k > 1 such that the number of pieces in each box is\r\ndivisible by k. Note that Alice won\u2019t mind if there exists some empty\r\nboxes. Charlie, Alice\u2019s boyfriend, also is Bob\u2019s second best friend, so\r\nhe decides to help Bob by rearranging the chocolate pieces. In one\r\nsecond, Charlie can pick up a piece in box i and put it into either box\r\ni-1 or box i+1 (if such boxes exist). Of course, he wants to help his\r\nfriend as quickly as possible. Therefore, he asks you to calculate the\r\nminimum number of seconds he would need to make Alice happy.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e18;\n\nint n;\nll tab[nax];\n\nll s;\n\nvll pie;\n\nll wyn=inf;\n\nvoid check(ll v)\n{\n\tll ret=0;\n\ts=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ts+=tab[i];\n\t\ts%=v;\n\t\tret+=min(s, v-s);\n\t}\n\twyn=min(wyn, ret);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld\", &tab[i]);\n\t\ts+=tab[i];\n\t}\n\tif (s==1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (ll i=2; i*i<=s; i++)\n\t{\n\t\tif (!(s%i))\n\t\t{\n\t\t\tpie.push_back(i);\n\t\t\ts/=i;\n\t\t\ti--;\n\t\t}\n\t}\n\tpie.push_back(s);\n\tfor (ll i : pie)\n\t\tcheck(i);\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math",
        "number theory",
        "ternary search",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B2. Send Boxes to Alice  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/71594",
    "editorial": "Let\u00e2\u0080\u0099s start by choosing vertices and as pivots.Recall that if the cross\r\nproduct of two vectors and is positive, point lies to the left of ; if\r\nthe product is negative, point lies to the right of ; and if the product\r\nis zero, the 3 points , , are collinear.With queries of type 2, we can\r\nknow which vertices lie to the left or to the right of edge and then\r\nsolve the two sides separately.Consider the left side and there are\r\nvertices lie to the left, we can use queries of type 1 to calculate the\r\ndistance from those vertices to edge (the distance from vertex to edge\r\nis twice the area of the triangle forms by , , , divides by the length\r\nof edge ). Let Y be the farthest from (there can be at most 2 such\r\nvertices). We can use queries of type 2 to see if the others vertices\r\nlie between or between , then sort them counter-clockwise with the asked\r\ndistances. So we will use queries to calculate the distances from\r\nvertices to edge and at most for the latter step. This solution uses at\r\nmost queries.Another solution is to find the vertex that is consecutive\r\nto in queries and do the same as the solution above.\r\n"
}