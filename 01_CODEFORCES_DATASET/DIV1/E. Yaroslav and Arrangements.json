{"link": "https://codeforces.com//contest/301/problem/E", "problemId": "2973", "problem_idx": "E", "shortId": "301E", "contest_number": "301", "problem_submissions": {"E": [3682464, 3681114, 4247515], "D": [3677749, 3677901, 3677912, 3678115, 3677526, 3679062, 3677723, 3677856, 3679979, 3679661, 3680028, 3677527, 3675796, 3683550, 3682695, 3682463, 3677874, 3677050, 3678347, 3678222, 3680032], "B": [3675021, 3674605, 3676912, 3676771, 3675890, 3677633, 3681284, 3684667, 3684661, 3684653, 3684635, 3678354, 3678161, 3680771, 3678425, 3681027, 3676146, 3677734, 3676031, 3675130], "A": [3674025, 3673473, 3675526, 3674656, 3679541, 3673757, 3674334, 3676412, 3677059, 3674545, 3673945, 3673341, 3675089, 3673194, 3673129, 3673585, 3673171, 3675681], "C": [3679265, 3679801, 3681253, 3680718, 3680819, 3680781, 3681151, 3681956, 3682034, 3680652, 3688897, 3683565, 3679128, 3680822]}, "name": "E. Yaroslav and Arrangements", "statement": "Yaroslav calls an array of integers , if it meets the following\r\nconditions: , at that . An array of integers is called , if it meets the\r\nfollowing conditions: The elements in it do not decrease . If the\r\ninequalities and hold. If we can rearrange its elements and get at least\r\none and at most distinct good arrays. Yaroslav has three integers . He\r\nneeds to count the number of distinct great arrays. Help Yaroslav! As\r\nthe answer may be rather large, print the remainder after dividing it by\r\n.Two arrays are considered distinct if there is a position in which they\r\nhave distinct numbers.\r\n", "solutions": ["#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n#define MOD 1000000007\n\ninline void add(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nconst int mod = 65536;\nconst int N = 100002;\nstruct hmap {\n    pair<int, string> key[N + 1];\n    unsigned ll ck[N + 1];\n    int val[N + 1], nx[N + 1], last[mod], hc;\n    hmap() {\n        reset();\n    }\n    inline void reset() {\n        memset(last, -1, sizeof(last));\n        hc = 0;\n    }\n    inline unsigned ll gh(const pair<int, string> &k) {\n        unsigned ll h = 1;\n        h = (h * 1000000009) ^ (k.x + 101);\n        rept(i, L(k.y)) {\n            h = (h * 10000019) ^ (k.y[i] + 2);\n        }\n        return h;\n    }\n    inline int &add(const pair<int, string> &k) {\n        unsigned ll h = gh(k);\n        int th = h & (mod - 1);\n        for (int w = last[th]; w >= 0; w = nx[w]) {\n            if (ck[w] == h) return val[w];\n        }\n        key[hc] = k; ck[hc] = h; val[hc] = 0; nx[hc] = last[th]; last[th] = hc++;\n        return val[hc - 1];\n    }\n};\n\nint a,b,c,d,n,m,k;\nhmap dp[2];\n//map<pair<int, string>, int> cur, nx;\nchar now[52], tmp[52];\nint ce[102][102];\ninline void decode(string s, char *a) {\n    memset(a, 0, 52 * sizeof(char));\n    rept(i, min(51, L(s))) {\n        a[i] = s[i] - 1;\n    }\n}\ninline void code(char *a, string &s) {\n    int last = 0;\n    rept(i, 51) {\n        if (a[i]) last = i;\n    }\n    s.resize(last + 1);\n    rept(i, last + 1) {\n        s[i] = a[i] + 1;\n    }\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    rept(i, 101) {\n        ce[i][0] = ce[i][i] = 1;\n        rep(j, i - 1) {\n            ce[i][j] = ce[i - 1][j - 1] + ce[i - 1][j];\n            if (ce[i][j] > 101) ce[i][j] = 101;\n        }\n    }\n\n    scanf(\"%d%d%d\", &n, &m, &k);\n    int cur = 1, nx = 0;\n    rep(i, 50) {\n        C(now);\n        now[i] = 1;\n        string s;\n        code(now, s);\n        int &t = dp[nx].add(mp(n - i, s));\n        t  = 1;\n    }\n\n    int ans = 0;\n    int ms = 0;\n    FOR(i, 2, m) {\n        swap(cur, nx);\n        ms = max(ms, dp[cur].hc);\n        dp[nx].reset();\n        rept(it, dp[cur].hc) {\n            int cd = dp[cur].val[it];\n            if (!cd) continue;\n            decode(dp[cur].key[it].y, now);\n            int can = dp[cur].key[it].x, last = 0;\n            rept(j, 51) {\n                if (now[j]) last = j;\n            }\n            rep(cadd, can) {\n\t\t\t\tif (cadd > 50) break;\n                C(tmp);\n                rep(fr, last) {\n                    if (!now[fr]) continue;\n                    if (cadd < fr) break;\n                    int ways = now[fr];\n                    ways *= ce[cadd - 1][fr - 1];\n                    if (ways > k) ways = k + 1;\n                    if (cadd - fr == 0) {\n                        if (ways <= k && ways) {\n                            ans = (ans + (ll)cd * (m - i + 1)) % MOD;\n                        }\n                        continue;\n                    }\n                    tmp[cadd - fr] += ways;\n                    if (tmp[cadd - fr] > k) tmp[cadd - fr] = k + 1;\n                }\n                int ns = can - cadd;\n                rep(j, last) {\n                    if (j > ns) {\n                        tmp[j] = 0;\n                    }\n                    if (tmp[j] > k) {\n                        FOR(z, j, last) tmp[z] = 0;\n                        ns = min(ns, j - 1);\n                        break;\n                    }\n                }\n                if (!ns) continue;\n                string h;\n                code(tmp, h);\n                \n                int &t = dp[nx].add(mp(ns, h));\n                add(t, cd);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2800", "interactive": false}