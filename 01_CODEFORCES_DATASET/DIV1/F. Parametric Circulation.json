{
    "link": "https://codeforces.com//contest/966/problem/F",
    "problemId": "179480",
    "problem_idx": "F",
    "shortId": "966F",
    "contest_number": "966",
    "problem_submissions": {
        "E": [
            37728467,
            37721887,
            37727395,
            37722353,
            46428064,
            37735854,
            37726097,
            37728168,
            37731395,
            37731373
        ],
        "D": [
            37722933,
            37721182,
            37720577,
            37745366,
            37727547,
            37724656,
            37720856,
            37720615,
            37721601,
            37723190,
            37720741,
            37720916,
            37854456,
            37723453,
            37723867,
            37723823,
            37723640,
            37725199
        ],
        "C": [
            37716531,
            37723619,
            37716233,
            37716062,
            37721394,
            37719905,
            37724974,
            37710146,
            37715347,
            37715961,
            37715642,
            37715427,
            37717480,
            37715886,
            37716616,
            37716460,
            37712823,
            37718703,
            37718856
        ],
        "B": [
            37712342,
            37710216,
            37712076,
            37714505,
            37717238,
            37717093,
            37713464,
            37712937,
            37711956,
            37712143,
            37712153,
            37712830,
            37714037,
            37717527,
            37712504,
            37714456,
            37719214,
            37710052,
            37715647
        ],
        "A": [
            37709493,
            37711125,
            37709073,
            37709222,
            37711428,
            37711424,
            37710230,
            37723341,
            37715473,
            37709490,
            37710976,
            37717218,
            37726403,
            37716138,
            37716852,
            37710495,
            37715732,
            37712927,
            37711795
        ],
        "F": [
            37856043
        ]
    },
    "name": "F. Parametric Circulation",
    "statement": "Vova has recently learned what a in a graph is. Recall the definition:\r\nlet G = (V, E) be a directed graph. A circulation f is such a collection\r\nof non-negative real numbers f_e (e\r\nin E), that for each vertex v\r\nin V the following condition holds:\r\nsum\r\nlimits_{e\r\nin\r\ndelta^{-}(v)} f_e =\r\nsum\r\nlimits_{e\r\nin\r\ndelta^{+}(v)} f_ewhere\r\ndelta^{+}(v) is the set of edges that end in the vertex v, and\r\ndelta^{-}(v) is the set of edges that start in the vertex v. In other\r\nwords, for each vertex the total incoming flow should be equal to the\r\ntotal outcoming flow.Let a lr-circulation be such a circulation f that\r\nfor each edge the condition l_e\r\nleq f_e\r\nleq r_e holds, where l_e and r_e for each edge e\r\nin E are two non-negative real numbers denoting the lower and upper\r\nbounds on the value of the circulation on this edge e.Vova can’t stop\r\nthinking about applications of a new topic. Right now he thinks about\r\nthe following question: let the graph be fixed, and each value l_e and\r\nr_e be a linear function of a real variable t:l_e(t) = a_e t + b_e\r\nr_e(t) = c_e t + d_eNote that t is the for all edges.Let t be chosen at\r\nrandom from uniform distribution on a segment [0, 1]. What is the\r\nprobability of existence of lr-circulation in the graph?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define MN 2000\n#define S 0\n#define T 1001\n#define eps 1e-9\n#define ld long double\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nld d[T+5],in[T+5];\nint n,m,q[T+5],head[T+5],cnt,top,c[T+5];\nstruct Edge{int u,v,a,b,c,d;}s[MN+5];\nstruct edge{int to,next;ld w;}e[100005];\ninline void ins(int f,int t,ld w)\n{\n\te[++cnt]=(edge){t,head[f],w};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t],0};head[t]=cnt;\t\n}\nbool bfs()\n{\n\tfor(int i=1;i<=T;++i) d[i]=1e9;int i,j;\n\tfor(d[q[top=i=1]=S]=0;i<=top;++i)\n\t\tfor(j=c[q[i]]=head[q[i]];j;j=e[j].next)\n\t\t\tif(e[j].w>eps&&d[q[i]]+1<d[e[j].to])\n\t\t\t\td[q[++top]=e[j].to]=d[q[i]]+1;\n\treturn d[T]<1e8;\n}\nld dfs(int x,ld f)\n{\n\tif(x==T) return f;ld used=0;\n\tfor(int&i=c[x];i;i=e[i].next)\n\t\tif(e[i].w>eps&&d[e[i].to]==d[x]+1)\n\t\t{\n\t\t\tld w=dfs(e[i].to,min(f-used,e[i].w));\n\t\t\tused+=w;e[i].w-=w;e[i^1].w+=w;\n\t\t\tif(f-used<eps) return f;\t\n\t\t}\n\treturn used;\n}\nld Solve(ld t)\n{\n\tcnt=1;memset(head,0,sizeof(head));\n\tmemset(in,0,sizeof(in));\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tld l=t*s[i].a+s[i].b,r=t*s[i].c+s[i].d;\n\t\tins(s[i].u,s[i].v,r-l);\n\t\tin[s[i].v]+=l;in[s[i].u]-=l;\n\t}\n\tld res=0;\n\tfor(int i=1;i<=n;++i) \n\t\tif(in[i]>0) res+=in[i],ins(S,i,in[i]);\n\t\telse ins(i,T,-in[i]);\n\twhile(bfs()) res-=dfs(S,1e9);\n\treturn res;\n}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=m;++i) \n\t\ts[i].u=read(),s[i].v=read(),\n\t\ts[i].a=read(),s[i].b=read(),\n\t\ts[i].c=read(),s[i].d=read();\n\tld l=0,r=1,ok=-1;\n\tfor(int i=1;i<=50;++i)\n\t{\n\t\tld m1=l+(r-l)/3,m2=m1+(r-l)/3;\n\t\tld r1=Solve(m1),r2=Solve(m2);\n\t\tif(r1<eps) {ok=m1;break;}\n\t\tif(r2<eps) {ok=m2;break;}\n\t\tif(r1<r2) r=m2; else l=m1;\n\t}\n\tif(ok<0) return 0*puts(\"0\");\n\tl=0,r=ok;ld L=ok,R=ok;\n\tfor(int i=1;i<=50;++i)\n\t{\n\t\tld mid=(l+r)*0.5;\n\t\tif(Solve(mid)<eps) L=mid,r=mid;\n\t\telse l=mid;\t\n\t}\n\tl=ok;r=1;\n\tfor(int i=1;i<=50;++i)\n\t{\n\t\tld mid=(l+r)*0.5;\n\t\tif(Solve(mid)<eps) R=mid,l=mid;\n\t\telse r=mid;\t\n\t}\n\tprintf(\"%.10lf\\n\",(double)(R-L));\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Parametric Circulation.json",
    "editorial_link": "https://codeforces.com//blog/entry/59173",
    "editorial": "First, let's use the classical reduction of lr\n-circulation problem to the maximum flow problem. Consider a network G?=(V?{s,t},E?)\n where for each e=uv?E\n there are three edges:\n\ne0=uv\n with capacity ce0=re?le\ne1=sv\n with capacity ce1=le\ne2=ut\n with capacity ce2=le\nStatement: it is possible to provide a bisection between s?t\n flows of value ?e?Ele\n in G?\n and lr\n-circulations in G\n. Indeed, consider a flow f?\n in G?\n, that saturates all edges going from s\n (and all the edges leading into t\n at the same time). Let fe=f?e0+le\n. Notice that it is a correct circulation: for any vertex v\n\n?e??+(v)fe=?e??+(v)f?e0+?e??+le=?e??+(v)f?e0+?e??+fe1=?e???(v)f?e0+?e???fe2=?e???(v)f?e0+?e???le=?e???(v)fe\n\nwhere the middle equation is immediately following from the conservation condition for any vertex from V\n for a flow f?\n.\n\nOn the other hand, the obtained circulation is indeed an lr\n-circulation because of how we got values of f?e\n. By performing all the steps in the reverse direction, we may recover a maximum flow in G?\n by any lr\n-circulation that finishes our proof.\n\nNow we are going to answer the following question: we have a parametric network G?(t)\n in which all capacities linearly depend on t\n, we have to find the probability that G?\n allows a flow that saturates all edges from the source under condition that t\n is sampled from U[0,1]\n.\n\nLet us show that the set of t\n that allow existence of a sought flow is a segment. It follows from the fact that the value maxflow(t)\n of a maximum flow in G?(t)\n is concave: suppose f?(t1)\n is a an admissible flow in G?(t1)\n and f?(t2)\n is an admissible flow in G?t2\n. Then it is easy to see that ?f?(t1)+(1??)f?(t2)\n is an admissible flow in G?(?t1+(1??)t2)\n for any ??[0,1]\n (as all the constraints on variables f?e\n are linear inequalities), from which immediately follows that maxflow(?t1+(1??)t2)??maxflow(t1)+(1??)maxflow(t2)\n.\n\nDenote suml(t)=?e?El(t)\n. Let us notices that gap(t)=suml(t)?maxflow(t)?0\n for any t\n and we are interested in precisely those values of t\n, such that gap(t)=0\n. Thus, the sought values of t\n form a segment as the function gap(t)\n is convex.\n\nThe remaining part of the solution is very simple: find a minimum of a convexvalue gap(t)\n over a segment [0,1]\n. If it is non-zero, then the answer is 0. Otherwise, we can locate the boundaries of an answer segment using two binary searches and print the difference between them.\n\nWhile implementing such a solution, one may face several difficulties arising from the precision issues, so we will provide two observations that may help you deal with them.\n\nOne may notice that maxflow(t)\n is actually a piecewise linear function, all pieces of which have the integer slope. Actually, maxflow(t)=mincut(t)=mincut Ccost(C,t)\n, and the cost of any fixed cut in G?(t)\n is a linear function of t\n with an integer slope. Thus, maxflow(t)\n is a lower envelope of a family of linear functions with integer slopes. The similar fact holds for a function gap(t)\n also. And we are interested in a horizontal segment in gap(t)\n which may be found using the binary search over a sign of a derivative gap?(t)\n. Finally notice that calculating a derivative gap?(t)\n may be done by finding a maximum flow and adding up all slopes of capacities of the edges defining a minimum cut restricting given maximum flow (since exactly this cut provides a linear constraint defining a segment of a function gap(t)\n, which a point t\n belongs to).\n\nAn alternative observation  consider only the points t\n such that t=k107\n where k\n is integer. If we keep only such points on the sought segment, its length will decrease by no more than 2?10?7\n which is allowed by a required answer precision. Finally, we can multiply all be\n and de\n by 107\n and consider t\n to be an integer between 0\n and 107\n which allows you to implement a solution that only uses integer data types.\n\nWe get a solution with a running time of O(maxflow?logprec?1)\n where prec\n is a required precision equal to 10?6\n under conditions of a given problem and maxflow\n is a running time of your favourite maximum flow algorithm. Practically you could use Dinic algorithm or Edmonds-Karp algorithm with capacity scaling.",
    "hint": []
}