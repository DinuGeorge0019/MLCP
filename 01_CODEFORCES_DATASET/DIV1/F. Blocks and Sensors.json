{
    "link": "https://codeforces.com//contest/1320/problem/F",
    "problemId": "551759",
    "problem_idx": "F",
    "shortId": "1320F",
    "contest_number": "1320",
    "problem_submissions": {
        "F": [
            72202332,
            72223011,
            72205107,
            72198337,
            72222998,
            72196293,
            72223902
        ],
        "E": [
            72193224,
            72190175,
            72191679,
            72192473,
            72195171,
            89517976,
            72207354,
            72207256,
            72196434,
            72194256,
            72192283,
            72199164,
            72195289,
            72197732,
            72223673,
            72193338,
            72195901,
            72200544,
            72200353,
            72200814,
            72198992,
            72200456
        ],
        "C": [
            72184867,
            72177670,
            72177948,
            72173628,
            72175737,
            72172966,
            72176352,
            72179230,
            72175568,
            72177066,
            72173843,
            72175840,
            72176052,
            72179445,
            72190361,
            72188981,
            72179839,
            72183510,
            72186001,
            72181401
        ],
        "B": [
            72179476,
            72169823,
            72171581,
            72177394,
            72169041,
            72168596,
            72168669,
            72172513,
            72171074,
            72169530,
            72169385,
            72171115,
            72178856,
            72172293,
            72186108,
            72169156,
            72173456,
            72185954,
            72172093,
            72178248
        ],
        "D": [
            72176425,
            72181800,
            72183448,
            72260282,
            72184393,
            72182092,
            72185033,
            72188594,
            72279361,
            72184633,
            72186338,
            72185288,
            72188013,
            72184398,
            72189053,
            72517140,
            72199444,
            72180732,
            72186150,
            72193094,
            72172140,
            72191769,
            72190479
        ],
        "A": [
            72166896,
            72166972,
            72167131,
            72166858,
            72166891,
            72166853,
            72166967,
            72167271,
            72166947,
            72166915,
            72167040,
            72167216,
            72167056,
            72167066,
            72166886,
            72170109,
            72167510,
            72181754,
            72167043,
            72167049
        ]
    },
    "name": "F. Blocks and Sensors",
    "statement": "Polycarp plays a well-known computer game (we won’t mention its name).\r\nEvery object in this game consists of three-dimensional blocks\r\naxis-aligned cubes of size 1\r\ntimes 1\r\ntimes 1. These blocks are unaffected by gravity, so they can float in\r\nthe air without support. The blocks are placed in cells of size 1\r\ntimes 1\r\ntimes 1; each cell either contains exactly one block or is empty. Each\r\ncell is represented by its coordinates (x, y, z) (the cell with these\r\ncoordinates is a cube with opposite corners in (x, y, z) and (x + 1, y +\r\n1, z + 1)) and its contents a_{x, y, z}; if the cell is empty, then\r\na_{x, y, z} = 0, otherwise a_{x, y, z} is equal to the type of the block\r\nplaced in it (the types are integers from 1 to 2\r\ncdot 10^5).Polycarp has built a large structure consisting of blocks.\r\nThis structure can be enclosed in an axis-aligned rectangular\r\nparallelepiped of size n\r\ntimes m\r\ntimes k, containing all cells (x, y, z) such that x\r\nin [1, n], y\r\nin [1, m], and z\r\nin [1, k]. After that, Polycarp has installed 2nm + 2nk + 2mk sensors\r\naround this parallelepiped. A sensor is a special block that sends a ray\r\nin some direction and shows the type of the first block that was hit by\r\nthis ray (except for other sensors). The sensors installed by Polycarp\r\nare adjacent to the borders of the parallelepiped, and the rays sent by\r\nthem are parallel to one of the coordinate axes and directed inside the\r\nparallelepiped. More formally, the sensors can be divided into 6 types:\r\nthere are mk sensors of the first type; each such sensor is installed in\r\n(0, y, z), where y\r\nin [1, m] and z\r\nin [1, k], and it sends a ray that is parallel to the Ox axis and has\r\nthe same direction; there are mk sensors of the second type; each such\r\nsensor is installed in (n + 1, y, z), where y\r\nin [1, m] and z\r\nin [1, k], and it sends a ray that is parallel to the Ox axis and has\r\nthe opposite direction; there are nk sensors of the third type; each\r\nsuch sensor is installed in (x, 0, z), where x\r\nin [1, n] and z\r\nin [1, k], and it sends a ray that is parallel to the Oy axis and has\r\nthe same direction; there are nk sensors of the fourth type; each such\r\nsensor is installed in (x, m + 1, z), where x\r\nin [1, n] and z\r\nin [1, k], and it sends a ray that is parallel to the Oy axis and has\r\nthe opposite direction; there are nm sensors of the fifth type; each\r\nsuch sensor is installed in (x, y, 0), where x\r\nin [1, n] and y\r\nin [1, m], and it sends a ray that is parallel to the Oz axis and has\r\nthe same direction; finally, there are nm sensors of the sixth type;\r\neach such sensor is installed in (x, y, k + 1), where x\r\nin [1, n] and y\r\nin [1, m], and it sends a ray that is parallel to the Oz axis and has\r\nthe opposite direction. Polycarp has invited his friend Monocarp to play\r\nwith him. Of course, as soon as Monocarp saw a large parallelepiped\r\nbounded by sensor blocks, he began to wonder what was inside of it.\r\nPolycarp didn’t want to tell Monocarp the exact shape of the figure, so\r\nhe provided Monocarp with the data from all sensors and told him to try\r\nguessing the contents of the parallelepiped by himself.After some hours\r\nof thinking, Monocarp has no clue about what’s inside the sensor-bounded\r\nspace. But he does not want to give up, so he decided to ask for help.\r\nCan you write a program that will analyze the sensor data and construct\r\nany figure that is consistent with it?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vvvvi = vector<vvvi>;\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tvvi x0, x1, y0, y1, z0, z1;\n\tvvvi output;\n\tvvvi what;\n\tconst vector<int> dx = {1, -1, 0, 0, 0, 0};\n\tconst vector<int> dy = {0, 0, 1, -1, 0, 0};\n\tconst vector<int> dz = {0, 0, 0, 0, 1, -1};\n\n\tint n, m, p;\n\tcin >> n >> m >> p;\n\tx0.assign(m, vi(p, 0));\n\tx1.assign(m, vi(p, 0));\n\ty0.assign(n, vi(p, 0));\n\ty1.assign(n, vi(p, 0));\n\tz0.assign(n, vi(m, 0));\n\tz1.assign(n, vi(m, 0));\n\toutput.assign(n, vvi(m, vi(p, -1)));\n\twhat.assign(n, vvi(m, vi(p, 0)));\n\tfor(int i = 0; i < m; i++) for(int j = 0; j < p; j++) cin >> x0[i][j];\n\tfor(int i = 0; i < m; i++) for(int j = 0; j < p; j++) cin >> x1[i][j];\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < p; j++) cin >> y0[i][j];\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < p; j++) cin >> y1[i][j];\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) cin >> z0[i][j];\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) cin >> z1[i][j];\n\n\tauto fail = [](){\n\t\tcout << -1 << '\\n';\n\t\texit(0);\n\t};\n\n\tauto cons = [&](int x, int y, int z, int id){\n\t\tif(id == 0) return x0[y][z];\n\t\tif(id == 1) return x1[y][z];\n\t\tif(id == 2) return y0[x][z];\n\t\tif(id == 3) return y1[x][z];\n\t\tif(id == 4) return z0[x][y];\n\t\tif(id == 5) return z1[x][y];\n\t\tassert(false);\n\t};\n\n\tvector<vector<int> > q;\n\tauto add = [&](int x, int y, int z, int id){\n\t\t// cerr << x << ' ' << y << ' ' << z << ' ' << id << '\\n';\n\t\tint f = cons(x, y, z, id);\n\t\tif(x < 0 || y < 0 || z < 0 || x >= n || y >= m || z >= p){\n\t\t\t// cerr << x << ' ' << y << ' ' << z << ' ' << id << ' ' << f << '\\n';\n\t\t\tif(f > 0) fail();\n\t\t\treturn;\n\t\t}\n\t\twhat[x][y][z] |= (1 << id);\n\t\tq.push_back({x, y, z});\n\t};\n\tint s = 0;\n\tfor(int i = 0; i < m; i++) for(int j = 0; j < p; j++) { add(0, i, j, 0); add(n-1, i, j, 1); }\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < p; j++) { add(i, 0, j, 2); add(i, m-1, j, 3); }\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) { add(i, j, 0, 4); add(i, j, p-1, 5); }\n\n\twhile(s < (int)q.size()){\n\t\tvector<int> r = q[s];\n\t\ts++;\n\t\tint x = r[0];\n\t\tint y = r[1];\n\t\tint z = r[2];\n\t\tvector<int> needs;\n\t\tfor(int f = 0; f < 6; f++){\n\t\t\tif((what[x][y][z] >> f) & 1) needs.push_back(cons(x, y, z, f));\n\t\t}\n\t\tfor(int a : needs){\n\t\t\tif(a == 0) output[x][y][z] = 0;\n\t\t\tfor(int b : needs){\n\t\t\t\tif(a != b) output[x][y][z] = 0;\n\t\t\t}\n\t\t}\n\t\tif(output[x][y][z] == 0){\n\t\t\tfor(int f = 0; f < 6; f++){\n\t\t\t\tif((what[x][y][z] >> f) & 1){\n\t\t\t\t\tint nx = x + dx[f];\n\t\t\t\t\tint ny = y + dy[f];\n\t\t\t\t\tint nz = z + dz[f];\n\t\t\t\t\tadd(nx, ny, nz, f);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhat[x][y][z] = 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) for(int k = 0; k < p; k++){\n\t\tif(output[i][j][k] == -1){\n\t\t\tvector<int> needs;\n\t\t\tfor(int f = 0; f < 6; f++){\n\t\t\t\tif((what[i][j][k] >> f) & 1) needs.push_back(cons(i, j, k, f));\n\t\t\t}\n\t\t\tfor(int a : needs){\n\t\t\t\tassert(a != 0);\n\t\t\t\tfor(int b : needs){\n\t\t\t\t\tassert(a == b);\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput[i][j][k] = (needs.empty() ? 0 : needs.front());\n\t\t}\n\t\tcout << output[i][j][k] << ' ';\n\t}\n\tcout << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Blocks and Sensors.json",
    "editorial_link": "https://codeforces.com//blog/entry/74431",
    "editorial": "Initially fill each cell with a colorless block, and then try to paint\r\nblocks and delete them if they definitely contradict the sensor data.We\r\nhave to delete a block if: it is observed by a sensor which should see\r\nno blocks; it is observed by at least two sensors that report different\r\nblock types. In any of these cases, we delete a block. Then we update\r\nall sensors which were looking at it: for each of them, find the next\r\nblock which they are looking at, and maybe delete it (if the information\r\nfor it is contradictory). If this results in deleting all blocks for a\r\nsensor that should see a block, then the answer is .If this process\r\nterminates without any contradictions, we can construct the answer. Now\r\nall sensors that should not see any blocks donât see them, and each\r\nblock observed by sensors can be assigned a type that does not\r\ncontradict the sensor data. If some block is not observed by sensors at\r\nall, we may assign any color to it (or even delete it).To maintain\r\nblocks that should be deleted, we may use a BFS-like approach with a\r\nqueue, or a DFS-like function that deletes a block, updates the sensors\r\nlooking at it, and maybe calls itself recursively for the blocks that\r\nhave to be deleted after the updates.\r\n",
    "hint": []
}