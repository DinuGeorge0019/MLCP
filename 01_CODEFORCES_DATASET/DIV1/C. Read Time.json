{
    "link": "https://codeforces.com//contest/343/problem/C",
    "problemId": "3469",
    "problem_idx": "C",
    "shortId": "343C",
    "contest_number": "343",
    "problem_submissions": {
        "E": [
            31188435,
            31188116,
            31188087,
            31187398,
            31187368,
            31187305,
            31187274,
            31186747,
            31186631,
            31186607,
            31177883,
            31177811,
            31177677,
            31177529,
            31177512,
            31177472,
            31174332,
            31174236,
            31174170,
            31174117,
            31174081,
            31173996,
            31173900,
            31173784,
            31168439,
            31168047,
            31166077,
            31166040,
            31165937,
            31165886,
            31165811,
            31165582,
            4470358,
            4472396,
            4467502,
            4481337,
            4469008,
            4469285,
            4479327,
            4479319
        ],
        "D": [
            4464141,
            4463979,
            4464572,
            4466164,
            4464136,
            4464708,
            4465038,
            4464000,
            4465958,
            4466077,
            4464624,
            4465035,
            4466293,
            4465384,
            4466009,
            4465578,
            4464050,
            4465103
        ],
        "C": [
            4460935,
            4462263,
            4462661,
            4463142,
            4461571,
            4460298,
            4462624,
            4461379,
            4461808,
            4462541,
            4462074,
            4461269,
            4462489,
            4463445,
            4463917,
            4463308,
            4465676,
            4463306
        ],
        "B": [
            4459735,
            4460433,
            4460596,
            4461468,
            4460532,
            4461066,
            4460953,
            4459496,
            4459676,
            4461679,
            4460850,
            4460112,
            4461095,
            4461548,
            4461352,
            4461258,
            4460882,
            4461288
        ],
        "A": [
            4458959,
            4458766,
            4460268,
            4460108,
            4459407,
            4461767,
            4460061,
            4464549,
            4459033,
            4459762,
            4460186,
            4459277,
            4459980,
            4460247,
            4461189,
            4460304,
            4459784,
            4460498
        ]
    },
    "name": "C. Read Time",
    "statement": "Mad scientist Mike does not use slow hard disks. His modification of a\r\nhard drive has not one, but different heads that can read data in\r\nparallel.When viewed from the side, Mike\u2019s hard drive is an endless\r\narray of tracks. The tracks of the array are numbered from left to right\r\nwith integers, starting with 1. In the initial state the -th reading\r\nhead is above the track number . For each of the reading heads, the hard\r\ndrive\u2019s firmware can move the head exactly one track to the right or to\r\nthe left, or leave it on the current track. During the operation each\r\nhead\u2019s movement does not affect the movement of the other heads: the\r\nheads can change their relative order; there can be multiple reading\r\nheads above any of the tracks. A track is considered if at least one\r\nhead has visited this track. In particular, all of the tracks numbered ,\r\n, , have been read at the beginning of the operation. Mike needs to read\r\nthe data on distinct tracks with numbers , , , . Determine the minimum\r\ntime the hard drive firmware needs to move the heads and read all the\r\ngiven tracks. Note that an arbitrary number of other tracks can also be\r\nread.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ninline bool can_visit(long long s, long long a, long long b, long long t) {\n  if (a > s) a = s;\n  if (b < s) b = s;\n  long long x = s - a;\n  long long y = b - s;\n  long long z;\n  if (x < y) z = 2 * x + y;\n  else z = x + 2 * y;\n  return (z <= t);\n}\n\nlong long h[1234567], p[1234567];\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) scanf(\"%I64d\", h + i);\n  for (int i = 0; i < m; i++) scanf(\"%I64d\", p + i);\n  long long ll = 0, rr = (long long)1e11;\n  while (ll < rr) {\n    long long mid = (ll + rr) >> 1;\n    int last = 0;\n    for (int i = 0; i < n; i++) {\n      int low = last, high = m;\n      while (low < high) {\n        int center = (low + high + 1) >> 1;\n        if (can_visit(h[i], p[last], p[center - 1], mid)) low = center;\n        else high = center - 1;\n      }\n      last = low;\n    }\n    if (last == m) rr = mid;\n    else ll = mid + 1;\n  }\n  cout << ll << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Read Time.json",
    "editorial_link": "https://codeforces.com//blog/entry/8860",
    "editorial": "Let\u00e2\u0080\u0099s search the answer with the binary search. Fix some value of . Look\r\nat the first head from the left that can read track . If , then goes to\r\nthe right seconds and reads all tracks on its way. Otherwise if , then\r\nthe head has two choices: Obviously, for it is more advantageous to\r\nvisit the track positioned as much as possible to the right. So we\r\nchoose by . Then we move the pointer onto the first unread track, and\r\nrepeat the algorithm for , and so on with each head. Solution\r\ncomplexity: . Problem authors: gen, gorbunov. Bonus: The problem is\r\ncompletely real, if the disk has only a single head, if we know, what\r\ntracks should be read; then the optimal algorithm chooses between the\r\ntwo choices described above. I and gorbunov were listening this on a\r\nlecture, and created the given problem out of boredom ;]\r\n"
}