{
    "link": "https://codeforces.com//contest/1893/problem/E",
    "problemId": "2312789",
    "problem_idx": "E",
    "shortId": "1893E",
    "contest_number": "1893",
    "problem_submissions": {
        "E": [
            231818167,
            231817045,
            231803415,
            231804844,
            231833815,
            231833792,
            231839797,
            231826618,
            231788620
        ],
        "D": [
            231763066,
            231768313,
            231775868,
            231774336,
            231770732,
            231769775,
            231771277,
            231770838,
            231774100,
            231773287,
            231775381,
            231774387,
            231832770,
            231774153,
            231769693,
            231780037,
            231776516,
            231776656,
            231779055
        ],
        "C": [
            231757417,
            231760822,
            231765401,
            231765935,
            231760863,
            231764311,
            231759097,
            231765007,
            231765215,
            231764112,
            231761220,
            231764299,
            231762636,
            231765852,
            231774795,
            231767240,
            231761295,
            231769751,
            231762047
        ],
        "B": [
            231750021,
            231753071,
            231755044,
            231752698,
            231750927,
            231757036,
            231753427,
            231755766,
            231751594,
            231755964,
            231754775,
            231753064,
            231752377,
            231758243,
            231759945,
            231750768,
            231749008,
            231758152,
            231754355
        ],
        "A": [
            231747160,
            231749247,
            231747103,
            231747730,
            231747688,
            231747436,
            231748241,
            231747116,
            231747649,
            231748263,
            231747534,
            231747816,
            231839115,
            231749267,
            231748700,
            231749546,
            231747452,
            231747587,
            231748316,
            231747435
        ]
    },
    "name": "E. Cacti Symphony",
    "statement": "You are given an undirected connected graph in which any two distinct\r\nsimple cycles common vertices. Since the graph can be very large, it is\r\ngiven to you in a compressed form: for each edge, you are also given a\r\nnumber d, which indicates that there are d additional vertices on this\r\nedge.You need to assign a weight to each vertex and each edge of the\r\ngraph an integer from 1 to 3.An edge of the graph is called if the\r\nbitwise XOR of the weights of its adjacent vertices is 0 and the weight\r\nof that edge.Similarly, a vertex of the graph is called if the bitwise\r\nXOR of the weights of its adjacent edges is 0 and the weight of that\r\nvertex.You need to determine how many ways there are to assign weights\r\nto the vertices and edges of the graph so that all vertices and edges\r\nare . Since the answer can be quite large, you need to calculate the\r\nremainder of the answer divided by 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//extern constexpr modinfo base{2147483579,0};//2^31 未満の最大の安全素数\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n//KUPC 2020 C\n//XXII Opencup GP of Gomel E\n//非連結な場合はverifyされてない\n\n//多重辺なしの cactus を分解する\n//cs にサイクルに使われた辺の集合が入る\n//順番は，dfs 木を下る->後退辺で上がる，の順\n//cs のサイズが 2 のときはシンプルに辺があるだけ\n//連結性を仮定せず\ntemplate<class E>\nstruct cactus{\n\tconst vvc<E>&g;\n\tconst int n;\n\tvvc<E> cs;\n\tvi vis,par,u;\n\tvc<E> come;\n\tvc<bool> done;\n\tvoid dfs(int v,int p,E co){\n\t\tassert(vis[v]==0);\n\t\tvis[v]=1;\n\t\tpar[v]=p;\n\t\tcome[v]=co;\n\t\tE gopar;\n\t\tfor(auto e:g[v]){\n\t\t\tif(e==p){\n\t\t\t\tgopar=e;\n\t\t\t}else if(vis[e]==0){\n\t\t\t\tdfs(e,v,e);\n\t\t\t}else if(vis[e]==1){\n\t\t\t\tint x=v;\n\t\t\t\tvc<E> z{e};\n\t\t\t\twhile(x!=e){\n\t\t\t\t\tassert(!done[x]);\n\t\t\t\t\tdone[x]=true;\n\t\t\t\t\tz.pb(come[x]);\n\t\t\t\t\tx=par[x];\n\t\t\t\t}\n\t\t\t\treverse(all(z));\n\t\t\t\tcs.pb(z);\n\t\t\t}\n\t\t}\n\t\tif(p!=-1&&!done[v]){\n\t\t\tdone[v]=true;\n\t\t\tcs.pb({co,gopar});\n\t\t}\n\t\tvis[v]=2;\n\t}\n\tcactus(const vvc<E>&gg):g(gg),n(g.size()),vis(n),par(n),u(n),come(n),done(n){\n\t\trep(i,n)if(!vis[i])\n\t\t\tdfs(i,-1,E());\n\t}\n};\nstruct E{\n\tint to,dist;\n\toperator int()const{return to;}\n};\n\nbool dbg=false;\n\nconst int D=40000;\nmint transA[4][D+1][4];\nmint transB[4][D+1][4];\nvoid inittrans(){\n\trng(init,1,4){\n\t\ttransA[init][0][init]=1;\n\t\trep(i,D){\n\t\t\trng(j,1,4)rng(k,1,4)if(j!=k){\n\t\t\t\ttransA[init][i+1][k]+=transA[init][i][j];\n\t\t\t}\n\t\t}\n\t}\n\trng(init,1,4){\n\t\ttransB[init][0][init]=1;\n\t\trep(i,D){\n\t\t\trng(j,1,4)rng(k,1,4){\n\t\t\t\ttransB[init][i+1][k]+=transB[init][i][j]*transA[j][D][k];\n\t\t\t}\n\t\t}\n\t}\n}\n\nmint trans(int init,int d,int to){\n\tint u=d/D,v=d%D;\n\tmint res;\n\trng(k,1,4)res+=transB[init][u][k]*transA[k][v][to];\n\treturn res;\n}\n\nusing A=array<array<mint,4>,4>;\n\nA mg(const A&a,const A&b){\n\tA res{};\n\trng(x,1,4)rep(y,4)rep(z,4){\n\t\tres[x][y^z]+=a[x][y]*b[x][z];\n\t}\n\treturn res;\n}\n\nA up(const A&a,int d){\n\tA res;\n\trng(x,1,4)rep(y,4)rng(z,1,4)if(0!=(y^z)&&x!=(y^z)){\n\t\tif(z==x){\n\t\t\trng(w,1,4)rng(v,1,4)if(w!=v)\n\t\t\t\tres[v][w]+=a[x][y]*trans(z,d-1,w);\n\t\t}else{\n\t\t\trng(w,1,4)\n\t\t\t\tres[w][w]+=a[x][y]*trans(z,d-1,w);\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tvvc<E> g(n);\n\trep(i,m){\n\t\tint a,b,d;cin>>a>>b>>d;\n\t\ta--;b--;\n\t\td++;\n\t\tg[a].pb({b,d});\n\t\tg[b].pb({a,d});\n\t}\n\t\n\tcactus<E> cc(g);\n\t\n\t//int s=n+si(cc.cs);\n\t//vvc<int> t(s);\n\tvvc<int> t(n);\n\trep(i,si(cc.cs)){\n\t\t/*rep(j,si(cc.cs[i])){\n\t\t\tint v=cc.cs[i][j];\n\t\t\tif(j+1<si(cc.cs[i])-1)\n\t\t\t\tt[n+i].pb(v);\n\t\t\telse\n\t\t\t\tt[v].pb(n+i);\n\t\t}*/\n\t\tt[cc.cs[i].back()].pb(i);\n\t}\n\t\n\tauto dfs=[&](auto self,int v)->A{\n\t\tdmp(v);\n\t\tassert(v<n);\n\t\tA res;\n\t\trng(x,1,4)res[x][0]=1;\n\t\tfor(int c:t[v]){\n\t\t\tint len=si(cc.cs[c])-1;\n\t\t\tvc<A> buf(len);\n\t\t\trep(i,len)buf[i]=self(self,cc.cs[c][i]);\n\t\t\tif(len==1){\n\t\t\t\t//edge\n\t\t\t\tres=mg(res,up(buf[0],cc.cs[c][0].dist));\n\t\t\t}else if(len>=2){\n\t\t\t\tA sum{};\n\t\t\t\tint d=cc.cs[c].back().dist;\n\t\t\t\t{\n\t\t\t\t\trng(w,1,4){\n\t\t\t\t\t\tA cur{};\n\t\t\t\t\t\tper(step,len){\n\t\t\t\t\t\t\t//dmp(step);\n\t\t\t\t\t\t\tif(step==len-1){\n\t\t\t\t\t\t\t\trng(x,1,4)if(x==w)rep(y,4)cur[x][y^w]+=buf[len-1][x][y];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcur=mg(cur,buf[step]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//dmp2(cur);\n\t\t\t\t\t\t\tcur=up(cur,cc.cs[c][step].dist);\n\t\t\t\t\t\t\t//dmp2(cur);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trng(u,1,4)rng(x,1,4)if(u!=x)rep(y,4)\n\t\t\t\t\t\t\tsum[x][y^u]+=cur[x][y]*trans(w,d-1,u);\n\t\t\t\t\t\tdmp(sum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\trng(w,1,4){\n\t\t\t\t\t\tA cur{};\n\t\t\t\t\t\tper(step,len){\n\t\t\t\t\t\t\tif(step==len-1){\n\t\t\t\t\t\t\t\trng(x,1,4)if(x!=w)rep(y,4)cur[x][y^w]+=buf[len-1][x][y];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcur=mg(cur,buf[step]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur=up(cur,cc.cs[c][step].dist);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trng(u,1,4)rng(x,1,4)if(u==x)rep(y,4)\n\t\t\t\t\t\t\tsum[x][y^u]+=cur[x][y]*trans(w,d-1,u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdmp(sum);\n\t\t\t\tres=mg(res,sum);\n\t\t\t}else{\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t};\n\tA ans=dfs(dfs,0);\n\t\n\tmint res=0;\n\trng(x,1,4)rng(y,1,4)if(x!=y)res+=ans[x][y];\n\tprint(res);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinittrans();\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\t//int t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dp",
        "graphs"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Cacti Symphony.json",
    "editorial_link": "https://codeforces.com//blog/entry/122074",
    "editorial": "First observation: for each edge, the vertices connected by it have\r\ndifferent weights, otherwise the XOR of the weights of the adjacent\r\nvertices of this edge is equal to .Second observation: for each edge,\r\none of its adjacent vertices has a weight equal to the weight of the\r\nedge, since .From these two observations, it follows that each edge has\r\nthe same weight as one of the vertices it is connected to. Letâs say\r\nthat a vertex all the adjacent edges with the same weight. Then each\r\nedge is controlled by exactly one vertex.Third observation: if a vertex\r\nhas an even degree, then the number of edges controlled by it must be\r\nodd, and this is a sufficient condition for the vertex to be good.Fourth\r\nobservation: if a vertex has an odd degree, then the number of edges\r\ncontrolled by it must be even, and this is a sufficient condition for\r\nthe vertex to be good.Therefore, in order for all vertices to be good,\r\nit is necessary to choose who controls each edge in such a way that the\r\nparity of the vertex degree and the parity of the number of edges\r\ncontrolled by it are different.And in order for all edges to be good, it\r\nis necessary to assign weights from to to the vertices in such a way\r\nthat no two adjacent vertices have the same weight. The weight of each\r\nedge will then be equal to the weight of the vertex it is controlled\r\nby.Now the problem is divided into two independent parts: finding the\r\nnumber of ways to assign weights to the vertices, and finding the number\r\nof ways to orient the edges. The answer to the original problem will be\r\nthe product of the answers to these two parts. How many ways are there\r\nto color the vertices with colors, such that two adjacent vertices are\r\ncolored differently? How many ways are there to orient the edges, such\r\nthat a vertex with an even degree has an odd number of outgoing edges,\r\nand a vertex with an odd degree has an even number of outgoing\r\nedges?Solution to problem 1: note that if there is a bridge in the graph\r\n, and it divides the graph into graphs and , then the answer for is the\r\nproduct of the answers for and multiplied by . Then we can identify all\r\nthe bridges, and since the graph is a vertex cactus, after removing the\r\nbridges, the graph will be divided into cycle components. For a cycle of\r\nlength , the number of ways to color the vertices can be calculated\r\nusing simple dynamic programming: . To prove this dynamic programming,\r\nconsider any two vertices that are one apart in a cycle of length . If\r\nthey have the same color, then the vertex between them has possible\r\ncolors, and the rest have possibilities. If they have different colors,\r\nthen there are possibilities. Knowing the transition formula, we can\r\nnotice that . This formula can be trivially proved by induction.Solution\r\nto problem 2: we will solve the same problem, but requiring that each\r\nvertex has an odd number of outgoing edges (if we invert all the edges\r\nin such a graph, we will get what is required). If and have different\r\nparity, then the answer is , since the sum of odd numbers, which are the\r\ndegrees of the vertices, must be equal to . Otherwise, the answer is .\r\nAt any moment, we can remove any leaf, as it does not solve anything. We\r\nwill remove the leaves as long as they exist. After this, one of the\r\ncycles in the graph will be a \"leaf\" - connected only to one other\r\ncycle. For all vertices of this cycle, the necessary parities of the\r\ndegrees are known. Choose any edge of the cycle and orient it (there are\r\nways to orient it, both will work). After that, all other edges in the\r\ncycle are oriented uniquely. After that, the bridge between this cycle\r\nand the other one is also uniquely oriented. Now we have one less cycle,\r\nand we also know all the necessary parities of the vertices (the parity\r\nchanges for the vertex where the bridge came in). In this way, we can\r\ngradually reduce the number of cycles. With each removal of a cycle, the\r\nanswer is multiplied by , since there are ways to orient the edge in the\r\ncycle. In the end, we get ways.The final answer to the problem if and\r\nhave same parity is: where are the sizes of cycles (cycle can be a\r\nsingle vertice if it did not lie on any other cycle, and in this case).\r\n",
    "hint": [
        "Hint 1 Cacti is a trap, don't think about it for now, it will help later.",
        "Hint 2 Well, you need to make some observations. Start with observations about determining edges weights, it seems reasonable because edge always have exactly adjacent vertices.",
        "Hint 3 Edge is good <=> Exactly one of the adjacent vertexes have a same weight as an edge.",
        "Hint 4 Direct edges, such that every edge goes from vertex with same weight as edge to another vertex. In this reality try to find easier equivalent condition for ``vertice is good``.",
        "Hint 5 Vertex is good <=> InDegree of vertex is an odd integer.",
        "Hint 6 Now you just have two separate problems: 1) Direct all edges, such that InDegree of each vertex is odd; 2) Color all vertexes in 3 colors such that any 2 adjacent vertexes have different color. Time to remember about cacti."
    ]
}