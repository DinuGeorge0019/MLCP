{"link": "https://codeforces.com//contest/138/problem/E", "problemId": "736", "problem_idx": "E", "shortId": "138E", "contest_number": "138", "problem_submissions": {"D": [980256, 979660, 979865, 981459, 981782, 980490, 980859, 981836, 980983, 981220, 982093], "C": [977164, 977134, 978135, 978148, 979334, 977388, 977560, 980285, 976404, 978363, 977955, 977707, 978190, 978555, 976840, 982255, 978719], "B": [976212, 977359, 976881, 978412, 978151, 981022, 984515, 979243, 978060, 990834, 976636, 980026, 976613, 976894, 979990, 982256, 976694], "A": [975301, 975042, 975181, 979365, 975615, 980600, 975885, 975355, 975294, 974907, 975053, 982540, 975212, 975316, 978556], "E": [984982]}, "name": "E. Hellish Constraints", "statement": "Katya recently started to invent programming tasks and prepare her own\r\ncontests. What she does not like is boring and simple constraints. Katya\r\nis fed up with all those \" does not exceed a thousand\" and \"the sum of\r\ndoes not exceed a million\" and she decided to come up with something a\r\nlittle more complicated.The last problem written by Katya deals with\r\nstrings. The input is a string of small Latin letters. To make the\r\nstatement longer and strike terror into the people who will solve the\r\ncontest, Katya came up with the following set of restrictions of the\r\nsame type (characters in restrictions can be repeated and some\r\nrestrictions may contradict each other): The number of characters in a\r\nstring is not less than and not more than . ... The number of characters\r\nin a string is not less than and not more than . ... The number of\r\ncharacters in a string is not less than and not more than . However,\r\nhaving decided that it is too simple and obvious, Katya added the\r\nfollowing condition: a string meets no less than and not more than\r\nconstraints from the above given list.Katya does not like to compose\r\ndifficult and mean tests, so she just took a big string and wants to add\r\nto the tests all its substrings that meet the constraints. However,\r\nKatya got lost in her conditions and asked you to count the number of\r\nsubstrings of the string that meet the conditions (each occurrence of\r\nthe substring is counted separately).\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int MAXL = 1e6;\nchar s[MAXL + 1];\n\nint main() {\n  #ifdef DEBUG\n  freopen(\"std.in\", \"r\", stdin);\n  freopen(\"std.out\", \"w\", stdout);\n  #endif\n\n  int k, L, R;\n  while (scanf(\"%s%d%d%d\", s, &k, &L, &R) >= 1) {\n    k *= 2;\n    vector<char> cs(k);\n    vi mivs(k), ks(k);\n    for (int i = 0; i < k;) {\n      int l, r;\n      scanf(\" %c%d%d\", &cs[i], &l, &r), cs[i];\n      mivs[i] = r + 1; ks[i] = -1;\n      i++;\n\n      cs[i] = cs[i - 1];\n      mivs[i] = l; ks[i] = 1;\n      i++;\n    }\n    int n = strlen(s);\n\n    vvi poses(128);\n    vi pid(n);\n    for (int i = n - 1; i >= 0; i--) {\n      int c = s[i];\n      pid[i] = sz(poses[c]);\n      poses[c].pb(i);\n    }\n\n    int zcnt = 0;\n    for (int i = 0; i < k; i++)\n      if (mivs[i] == 0)\n        zcnt += ks[i];\n\n    vi cnt(n, zcnt);\n    int ccnt = 0;\n    ll ans = 0;\n    for (int st = n - 1; st >= 0; st--) {\n      int c = s[st];\n//      eprintf(\"st=%d: %c; cnt=%d\\n\", st, c, cnt[st]);\n\n      if (L <= cnt[st] && cnt[st] <= R)\n        ccnt++;\n\n      for (int i = 0; i < k; i++) if (cs[i] == c && mivs[i] >= 1 && mivs[i] <= pid[st] + 1) {\n//        eprintf(\"  cond: >=%d, k=%d\\n\", mivs[i], ks[i]);\n        int npid = pid[st] - mivs[i] + 1;\n        assert(npid >= 0);\n        int l = poses[c][npid];\n        int r = npid > 0 ? poses[c][npid - 1] : n;\n//        eprintf(\"  l=%d, r=%d\\n\", l, r);\n\n        assert(st <= l && l <= r && r <= n);\n        for (int i2 = l; i2 < r; i2++) {\n          bool ov = L <= cnt[i2] && cnt[i2] <= R;\n          cnt[i2] += ks[i];\n//          eprintf(\"  cnt[%d]=%d\\n\", i2, cnt[i2]);\n          bool nv = L <= cnt[i2] && cnt[i2] <= R;\n          ccnt += ((int)nv - ov);\n        }\n      }\n\n//      eprintf(\" ccnt=%d\\n\", ccnt);\n      ans += ccnt;\n    }\n    printf(\"%I64d\\n\", ans);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp", "two pointers"], "dificulty": "2900", "interactive": false}