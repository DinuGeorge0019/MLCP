{
    "link": "https://codeforces.com//contest/1801/problem/G",
    "problemId": "1817550",
    "problem_idx": "G",
    "shortId": "1801G",
    "contest_number": "1801",
    "problem_submissions": {
        "G": [
            203657914,
            201155712,
            196755049,
            196760812,
            203134482
        ],
        "E": [
            196675152,
            196635209,
            196644302,
            196640748,
            196641519,
            196635379,
            196630013,
            196657513,
            196650893,
            196653405,
            196644576,
            196654360,
            196640172,
            196683603,
            196680417,
            196653431,
            196644218,
            196626389,
            199502352,
            199501873,
            199501660,
            199501455,
            199501378,
            199501277,
            199501214,
            199501173,
            199500937,
            199500810,
            196645808,
            196668272,
            196658312,
            196656102,
            196652330
        ],
        "F": [
            196622978,
            196623206,
            196631833,
            196626066,
            196642170,
            196635485,
            196619644,
            196630879,
            196631678,
            196626069,
            196641735,
            196624132,
            196623158,
            196622410,
            196637181,
            196627815,
            196619025,
            196627461,
            196633301,
            196628988
        ],
        "D": [
            196614757,
            196616104,
            196610930,
            196615603,
            196617463,
            196615380,
            196614983,
            196615414,
            196624090,
            196611332,
            196624396,
            196619261,
            196612951,
            196616838,
            196613243,
            196620716,
            196612736,
            196620435,
            196615283,
            196621604
        ],
        "C": [
            196609472,
            196608959,
            196606372,
            196605050,
            196609433,
            196606282,
            196610970,
            196610779,
            196613465,
            196606986,
            196612839,
            196609050,
            196607813,
            196663784,
            196670930,
            196612044,
            196605520,
            196611174,
            196610757,
            196615745
        ],
        "B": [
            196607492,
            196604951,
            196602514,
            196611006,
            196605854,
            196603175,
            196607224,
            196607805,
            196609864,
            196732242,
            196608899,
            196725334,
            196673072,
            196604282,
            196604121,
            196602391,
            196666183
        ],
        "A": [
            196601824,
            196601543,
            196601334,
            196601281,
            196602802,
            196601554,
            196623981,
            196603178,
            196605892,
            196601290,
            196604431,
            196602393,
            196602511,
            196601410,
            196601549,
            196603512,
            196601416,
            196607954,
            196604235,
            196602401
        ]
    },
    "name": "G. A task for substrings",
    "statement": "Philip is very fond of tasks on the lines. He had already solved all the\r\nproblems known to him, but this was not enough for him. Therefore,\r\nPhilip decided to come up with his own task.To do this, he took the\r\nstring t and a set of n strings s_1, s_2, s_3, ..., s_n. Philip has m\r\nqueries, in the ith of them, Philip wants to take a substring of the\r\nstring t from l_ith to r_ith character, and count the number of its\r\nsubstrings that match some string from the set. More formally, Philip\r\nwants to count the number of pairs of positions a, b, such that l_i\r\nle a\r\nle b\r\nle r_i, and the substring of the string t from ath to bth character\r\ncoincides with some string s_j from the set.A substring of the string t\r\nfrom ath to bth character is a string obtained from t by removing the\r\na - 1 character from the beginning and |t| - b characters from the end,\r\nwhere |t| denotes the length of the string t.Philip has already solved\r\nthis problem, but can you?\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n//fast IO by yosupo\n//sc.read(string) だと append される\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        ref.clear();\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();            \n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(vector<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val;  // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const vector<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n    void write_single(long double d){\n\t\t{\n\t\t\tlong long v=d;\n\t\t\twrite_single(v);\n\t\t\td-=v;\n\t\t}\n\t\twrite_single('.');\n\t\tfor(int _=0;_<8;_++){\n\t\t\td*=10;\n\t\t\tlong long v=d;\n\t\t\twrite_single(v);\n\t\t\td-=v;\n\t\t}\n    }\n};\n\nScanner sc(stdin);\nPrinter pr(stdout);\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS getrev(S s){\n\treverse(all(s));\n\treturn s;\n}\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tBIT(const vc<t>&a){init(a);}\n\tvoid init(int n){buf.clear();buf.resize(s=n);}\n\tvoid init(const vc<t>&a){\n\t\ts=si(a);\n\t\tbuf.resize(s);\n\t\trep(i,s)buf[i]=a[i];\n\t\trep(i,s){\n\t\t\tint j=i+((i+1)&(-i-1));\n\t\t\tif(j<s)buf[j]+=buf[i];\n\t\t}\n\t}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=t();\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tvoid add_range(int b,int e,t v){\n\t\tadd(b,v);\n\t\tadd(e,-v);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\n//長方形領域に加算，点取得\n//query のソート関数が微妙にほかと違う\nstruct point2d{\n\tstruct query{\n\t\tint x,i,l,r;\n\t\tbool operator<(const query&rhs)const{\n\t\t\treturn pi(x,i)<pi(rhs.x,rhs.i);\n\t\t}\n\t};\n\tvi ys,ans;\n\tvc<query> qs;\n\tpoint2d(const vc<pi>&ps){\n\t\tfor(auto p:ps)\n\t\t\tys.pb(p.b);\n\t\tmkuni(ys);\n\t\tans.resize(si(ps));\n\t\trep(i,si(ps))\n\t\t\tqs.pb({ps[i].a,inf+i,lwb(ys,ps[i].b),-1});\n\t}\n\tvoid aq(int x1,int x2,int y1,int y2,int w){\n\t\ty1=lwb(ys,y1);\n\t\ty2=lwb(ys,y2);\n\t\tqs.pb({x1,w,y1,y2});\n\t\tqs.pb({x2,-w,y1,y2});\n\t}\n\tvi calc(){\n\t\tsort(all(qs));\n\t\tBIT<int> bit(si(ys));\n\t\tfor(auto q:qs){\n\t\t\tif(q.i<inf){\n\t\t\t\tbit.add_range(q.l,q.r,q.i);\n\t\t\t}else{\n\t\t\t\tans[q.i-inf]=bit.get(q.l);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n//内部でグラフをいじるから in,out を使うときは注意\n//hei[v] -> heavy edge で潜っていった時，自分含めて何個あるか\n//pe[v]: v->par[v] の辺の情報\n//-有向木のときは上から下の辺を入れてる\n//-無向木のときは下から上の辺を入れてる\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep,hei,ni;\n\tvc<E> pe;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tfor(auto itr=g[v].bg;itr!=g[v].ed;itr++)\n\t\t\tif(*itr==p){\n\t\t\t\tpe[v]=*itr;\n\t\t\t\tg[v].erase(itr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(auto&e:g[v]){\n\t\t\tpe[e]=e;\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t\tif(si(g[v]))hei[v]=hei[g[v][0]]+1;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n),hei(n,1),ni(n),\n\t\tpe(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t\trep(i,n)ni[in[i]]=i;\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\t//CF692F\n\tint getpar(int v,int len){\n\t\tassert(dep[v]>=len);\n\t\tint tar=dep[v]-len;\n\t\twhile(1){\n\t\t\tint h=head[v];\n\t\t\tif(dep[h]<=tar){\n\t\t\t\treturn ni[in[h]+(tar-dep[h])];\n\t\t\t}\n\t\t\tv=par[h];\n\t\t}\n\t\tassert(false);\n\t}\n\t//1st UCUP 13 G\n\tint jump(int a,int b,int d){\n\t\tint c=lca(a,b);\n\t\tif(d<=(dep[a]-dep[c])){\n\t\t\treturn getpar(a,d);\n\t\t}else{\n\t\t\td=(dep[a]+dep[b]-dep[c]*2)-d;\n\t\t\tassert(d>=0);\n\t\t\treturn getpar(b,d);\n\t\t}\n\t}\n\t//root-v パス上で f(x)=true となる最も深い頂点を返す\n\t//CF857G\n\ttemplate<class F>\n\tint find_lowest(int v,F f){\n\t\twhile(v>=0){\n\t\t\tint h=head[v];\n\t\t\tif(!f(h)){\n\t\t\t\tv=par[h];\n\t\t\t}else{\n\t\t\t\tint l=0,r=dep[v]-dep[h]+1;\n\t\t\t\twhile(r-l>1){\n\t\t\t\t\tconst int mid=(l+r)/2;\n\t\t\t\t\tif(f(ni[in[h]+mid]))l=mid;\n\t\t\t\t\telse r=mid;\n\t\t\t\t}\n\t\t\t\treturn ni[in[h]+l];\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//XX Opencup GP of Korea\n\t//CF625 F\n\t//2020 Multi-Uni Contest Day5 G\n\t//CF415E\n\t//Universal Cup 2023 Stage 1 G\n\tvi index;\n\t//vs を含む virtual tree を返す\n\t//返すのは virtual tree に使われた頂点と，辺の集合\n\t//辺の端点は，virtual tree における番号\n\t//元の木における番号を virtual tree の頂点番号に写すのが，index という変数\n\t//辺は ch->par の順\n\t//virtual tree は行き掛け順で番号がついている\n\t//特に，頂点 0 が根になるようにできている\n\t//pair<vi,vc<pi>> tree_compress(vi vs){\n\tvoid tree_compress(vi&vs,vc<pi>&es){\n\t\tif(si(index)==0)index.resize(n);\n\t\tassert(index.size());\n\t\tauto comp = [&](int x,int y){\n\t\t\treturn in[x] < in[y];\n\t\t};\n\t\t//sort(all(vs),comp);\n\t\tassert(is_sorted(all(vs),comp));\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tint k = vs.size();\n\t\trep(i,k-1){\n\t\t\tvs.pb(lca(vs[i],vs[i+1]));\n\t\t}\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tk = vs.size();\n\t\trep(i,k) index[vs[i]] = i;\n\t\tes.clear();\n\t\trng(i,1,k){\n\t\t\tint p = lca(vs[i-1],vs[i]);\n\t\t\tes.eb(i,index[p]);\n\t\t}\n\t\t//return mp(vs,es);\n\t}\n\t//assume a is desdendant of b\n\t//ex=true <=> exclude b\n\ttemplate<class F>\n\tvoid subpath_work(int a,int b,bool ex,F f){\n\t\twhile(1){\n\t\t\tif(head[a]==head[b]){\n\t\t\t\tf(in[b]+ex,in[a]+1);\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tint h=head[a];\n\t\t\t\tf(in[h],in[a]+1);\n\t\t\t\ta=par[h];\n\t\t\t}\n\t\t}\n\t}\n\t//KUPC2021E\n\t//パスに対する操作順に注意\n\t//euler-tour 順にしたときの区間に作用していることに注意\n\t//ex=true exclude lca(a,b) (=apply path edges)\n\ttemplate<class F>\n\tvoid path_work(int a,int b,bool ex,F f){\n\t\tint c=lca(a,b);\n\t\tsubpath_work(a,c,ex,f);\n\t\tsubpath_work(b,c,true,f);\n\t}\n};\n\n\n//ARC141F\n//idx がノードの BFS 順序 (index 順だと fail 周りで壊れる)\n//pos が各文字列の最後に対応するノード\n//nx[c] は failure-link を辿れるだけたどり nx に遷移した先を表す\ntemplate<int K>\nstruct Aho2{\n\tstruct N{\n\t\tint nx[K],fail,len;\n\t\tN(int l):fail(-1),len(l){one(nx);}\n\t};\n\tvc<N> x;\n\tvi idx,pos;\n\tvoid dfs(int cur,const vi&s,int i){\n\t\tif(i<(int)s.size()){\n\t\t\tif(x[cur].nx[s[i]]==-1){\n\t\t\t\tx[cur].nx[s[i]]=si(x);\n\t\t\t\tx.eb(x[cur].len+1);\n\t\t\t}\n\t\t\tdfs(x[cur].nx[s[i]],s,i+1);\n\t\t}else pos.pb(cur);\n\t}\n\tAho2(const vc<vi>&ss):x(1,0){\n\t\t{\n\t\t\tint tot=1;\n\t\t\tfor(const auto&s:ss)tot+=si(s);\n\t\t\tx.reserve(tot);\n\t\t\tidx.reserve(tot);\n\t\t\tpos.reserve(tot);\n\t\t}\n\t\tfor(auto&s:ss)dfs(0,s,0);\n\t\tidx.pb(0);\n\t\tint h=0;\n\t\twhile(h<(int)idx.size()){\n\t\t\tint i=idx[h++];\n\t\t\trep(c,K)if(x[i].nx[c]!=-1){\n\t\t\t\tint j=x[i].nx[c],f=x[i].fail;\n\t\t\t\tif(f!=-1)x[j].fail=x[f].nx[c];\n\t\t\t\telse x[j].fail=0;\n\t\t\t\tidx.pb(j);\n\t\t\t}else{\n\t\t\t\tint f=x[i].fail;\n\t\t\t\tif(f!=-1)x[i].nx[c]=x[f].nx[c];\n\t\t\t\telse x[i].nx[c]=0;\n\t\t\t}\n\t\t}\n\t}\n\tN& operator[](int i){return x[i];}\n\tsize_t size()const{return si(x);}\n\tvoid debug_show(){\n\t\t#ifdef LOCAL\n\t\tvvc<int> ls(si(x));\n\t\tfor(auto i:idx){\n\t\t\trep(k,K){\n\t\t\t\tint j=x[i].nx[k];\n\t\t\t\tif(x[i].len<x[j].len){\n\t\t\t\t\tls[j]=ls[i];\n\t\t\t\t\tls[j].pb(k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcerr<<\"Aho of Size \"<<si(x)<<endl;\n\t\trep(i,si(x)){\n\t\t\tcerr<<i<<\" \"<<x[i].fail<<\" \"<<ls[i]<<endl;\n\t\t}\n\t\t#endif\n\t}\n};\n\nvi reads2i(){\n\tstring s;sc.read(s);\n\tvi x(si(s));\n\trep(i,si(s))x[i]=s[i]-'a';\n\treturn x;\n}\n\nvoid slv(){\n\tint n,qnum;sc.read(n,qnum);\n\tvi t=reads2i();\n\tint len=si(t);\n\tvvc<int> s(n),rev(n);\n\trep(i,n){\n\t\ts[i]=reads2i();\n\t\trev[i]=getrev(s[i]);\n\t}\n\tAho2<26> x(s),y(rev);\n\tvi pre(len+1),suf(len+1);\n\trep(i,len)pre[i+1]=x[pre[i]].nx[t[i]];\n\tper(i,len)suf[i]=y[suf[i+1]].nx[t[i]];\n\tvvc<int> g(si(x)),h(si(y));\n\trng(i,1,si(x))g[x[i].fail].pb(i);\n\trng(i,1,si(y))h[y[i].fail].pb(i);\n\t\n\tvi cnt(si(x));\n\tfor(auto i:x.pos)cnt[i]++;\n\tfor(auto i:x.idx)if(i)cnt[i]+=cnt[x[i].fail];\n\tvc<ll> sum(len+1);\n\trep(i,len)sum[i+1]=sum[i]+cnt[pre[i+1]];\n\t\n\tx.debug_show();\n\ty.debug_show();\n\t\n\tHLD<int> a(g,0),b(h,0);\n\tvc<ll> ans(qnum);\n\tvc<pi> ask;\n\trep(i,qnum){\n\t\tint l,r;sc.read(l,r);\n\t\tl--;\n\t\tans[i]=sum[r]-sum[l];\n\t\t\n\t\tint u=pre[l],v=suf[l];\n\t\tv=b.find_lowest(v,[&](int e){\n\t\t\treturn y[e].len<=r-l;\n\t\t});\n\t\tdmp2(u,v);\n\t\task.eb(a.in[u],b.in[v]);\n\t}\n\tpoint2d p2d(ask);\n\t\n\tfor(auto line:s){\n\t\tdmp(line);\n\t\tint m=si(line);\n\t\tvi p(m+1),q(m+1);\n\t\trep(i,m)p[i+1]=x[p[i]].nx[line[i]];\n\t\tper(i,m)q[i]=y[q[i+1]].nx[line[i]];\n\t\trng(i,1,m){\n\t\t\tdmp2(p[i],q[i]);\n\t\t\tp2d.aq(a.in[p[i]],a.out[p[i]],b.in[q[i]],b.out[q[i]],1);\n\t\t}\n\t}\n\t\n\tdmp(ans);\n\t\n\tvi dif=p2d.calc();\n\trep(i,qnum)ans[i]-=dif[i];\n\t\n\trep(i,qnum){\n\t\tpr.write(ans[i]);\n\t\tpr.write(i+1<qnum?' ':'\\n');\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\G. A task for substrings.json",
    "editorial_link": "https://codeforces.com//blog/entry/113857",
    "editorial": "Letâs use the Aho-Korasik structure\nto store strings from . Letâs build compressed suffix links on it. This\nway it is a little more optimal to find all the lines from ending in\nthis position .Denote by the number of substrings of in the prefix of\nlength .Denote by the number of substrings of in the suffix starting\nfrom the position .Note that is equal to the number of substrings of the\nstring for from on the segment minus the number of substrings of from\nthat begin before and end later than .For each query, we will find a\nsubstring that matches , which covers the string and ends as close as\npossible to . If there is no such thing, then the answer can be\ncalculated using the previous formula. Otherwise, is invested in . At\nthe same time, there are no substrings of in the string that begin\nbefore and end later than . To get the answer, we apply the previous\nformula with the string and the sub-section .Asymptotics:\n",
    "hint": []
}