{
    "link": "https://codeforces.com//contest/790/problem/A",
    "problemId": "98949",
    "problem_idx": "A",
    "shortId": "790A",
    "contest_number": "790",
    "problem_submissions": {
        "D": [
            25675131,
            25621791,
            25620770,
            25622633,
            25623312,
            25623816,
            25680670,
            25648868
        ],
        "E": [
            25623895,
            26123540,
            26123499,
            26123493,
            26123456,
            26123432,
            26123251,
            25617517
        ],
        "C": [
            25613244,
            25614979,
            25616936,
            25615762,
            25617856,
            25618954,
            25661266,
            25614888,
            25615074,
            25614005,
            25609588,
            25614426,
            25615773,
            25615586,
            25615794,
            25615992,
            25615935,
            25616033
        ],
        "B": [
            25609297,
            25610960,
            25614995,
            25612479,
            25611945,
            25614279,
            25608753,
            25610247,
            25611326,
            25609739,
            25611787,
            25609929,
            25612272,
            25613816,
            25610322,
            25610272,
            25611239,
            25970156,
            25970140,
            25970114,
            25970098,
            25969741,
            25969717,
            25967914,
            25967797,
            25967715,
            25967642,
            25967579,
            25967531,
            25967441,
            25967437,
            25967418,
            25967341,
            25628594,
            25611848
        ],
        "A": [
            25606141,
            25607710,
            25610915,
            25606934,
            25606698,
            25609653,
            25606498,
            25607278,
            25607609,
            25607400,
            25613182,
            25606914,
            25607776,
            25606578,
            25607601,
            25607434,
            25608027,
            25628141,
            25608400
        ]
    },
    "name": "A. Bear and Different Names",
    "statement": "In the army, it isn\u2019t easy to form a group of soldiers that will be\r\neffective on the battlefield. The communication is crucial and thus no\r\ntwo soldiers should share a name (what would happen if they got an order\r\nthat Bob is a scouter, if there are two Bobs?).A group of soldiers is\r\neffective if and only if their names are different. For example, a group\r\n(John, Bob, Limak) would be effective, while groups (Gary, Bob, Gary)\r\nand (Alice, Alice) wouldn\u2019t.You are a spy in the enemy\u2019s camp. You\r\nnoticed soldiers standing in a row, numbered through . The general wants\r\nto choose a group of consecutive soldiers. For every consecutive\r\nsoldiers, the general wrote down whether they would be an effective\r\ngroup or not.You managed to steal the general\u2019s notes, with strings ,\r\neach either \"\" or \"\". The string describes a group of soldiers through\r\n(\"\" if the group is effective, and \"\" otherwise). The string describes a\r\ngroup of soldiers through . And so on, till the string that describes a\r\ngroup of soldiers through . Your task is to find possible names of\r\nsoldiers. Names should match the stolen notes. Each name should be a\r\nstring that consists of between and English letters, inclusive. The\r\nfirst letter should be uppercase, and all other letters should be\r\nlowercase. Names don\u2019t have to be existing names it\u2019s allowed to print\r\n\"\" or \"\" for example.Find and print any solution. It can be proved that\r\nthere always exists at least one solution.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nint n, k;\n\nint read() {\n  if (scanf(\"%d%d\", &n, &k) < 2) {\n    return 0;\n  }\n  return 1;\n}\n\nconst int maxn = 55;\nint a[maxn];\n\nvoid solve() {\n  for (int i = 0; i < n; ++i) {\n    a[i] = i;\n  }\n\n  for (int i = 0; i <= n - k; ++i) {\n    char s[10];\n    scanf(\"%s\", s);\n    if (!strcmp(s, \"NO\")) {\n      a[i + k - 1] = a[i];\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    printf(\"%c%c%c\", 'A' + (a[i] / 26), 'a' + (a[i] % 26), \" \\n\"[i == n - 1]);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Bear and Different Names.json",
    "editorial_link": "https://codeforces.com//blog/entry/51068",
    "editorial": "First generate n different names. If the i-th given string is \"NO\", make names i and i?+?k?-?1 equal. Note that it doesn't affect other groups of k consecutive names."
}