{
    "link": "https://codeforces.com//contest/1854/problem/E",
    "problemId": "2119351",
    "problem_idx": "E",
    "shortId": "1854E",
    "contest_number": "1854",
    "problem_submissions": {
        "F": [
            216373971,
            217354172,
            217397292
        ],
        "D": [
            216310150,
            216289199,
            216321960,
            216339370,
            216308614,
            216330486,
            216327260,
            216330943,
            216339614,
            216349670,
            216345647,
            216345106,
            224815766,
            216547574,
            216366587
        ],
        "E": [
            216288237,
            216300028,
            216302036,
            216268441,
            216334493,
            216313354,
            216348664,
            216267007,
            216336955,
            216296297,
            216300153,
            216312130,
            216307051,
            216317337,
            216275749,
            216320776,
            216324267,
            216319909,
            216313856
        ],
        "C": [
            216273942,
            216261365,
            216266654,
            216275371,
            216264423,
            216276518,
            216281959,
            216283401,
            216256269,
            216270575,
            216274010,
            216274561,
            216269163,
            216301579,
            216282188,
            216295268,
            216271804,
            216301995
        ],
        "A2": [
            216264333,
            216379126,
            216379111,
            216318393,
            216275667,
            216295850,
            216251357,
            216257398,
            216276514,
            216268588,
            216307226,
            216280080,
            216286828,
            216278270,
            216337810,
            216308708,
            216280874,
            216295056,
            216275828
        ],
        "A1": [
            216258579,
            216252405,
            216255683,
            216241030,
            216251535,
            216248642,
            216276758,
            216268768,
            216282006,
            216259868,
            216249337,
            216287041,
            216244661,
            216249684,
            216243548,
            216258618,
            216238489,
            216275974
        ],
        "B": [
            216248516,
            216256912,
            216241500,
            216256089,
            216258617,
            216267337,
            216293058,
            216272552,
            216268356,
            216253180,
            216258044,
            216262545,
            216263544,
            216287092,
            216255748,
            216251265,
            216280599,
            216287965
        ]
    },
    "name": "E. Game Bundles",
    "statement": "Rishi is developing games in the 2D metaverse and wants to offer game\r\nbundles to his customers. Each game has an associated enjoyment value. A\r\ngame bundle consists of a subset of games whose total enjoyment value\r\nadds up to 60.Your task is to choose k games, where 1\r\nleq k\r\nleq 60, along with their respective enjoyment values a_1, a_2,\r\ndots, a_k, in such a way that exactly m distinct game bundles can be\r\nformed.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nconst int d=60;\n\nll m;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid dorzuc(vll &wek, int dod)\n{\n\tfor (int i=d; i>=dod; i--)\n\t\twek[i]+=wek[i-dod];\n}\n\nint los(int a, int b)\n{\n\treturn a+rand()%(b-a+1);\n}\n\nvi zbi;\n\nvoid check(vll &wek)\n{\n\tif (wek[d]>m)\n\t\treturn;\n\tll ile=zbi.size();\n\tvector<pll> jakie;\n\tll s=wek[d];\n\twhile(s<m)\n\t{\n\t\tint g=0;\n\t\tfor (int i=0; i<d/2; i++)\n\t\t\tif (s+wek[i]<=m && wek[i]>wek[g])\n\t\t\t\tg=i;\n\t\tll moge=(m-s)/wek[g];\n\t\tile+=moge;\n\t\ts+=moge*wek[g];\n\t\tjakie.push_back({d-g, moge});\n\t}\n\t//~ debug() << imie(ile);\n\tif (ile<=d)\n\t{\n\t\tfor (pll i : jakie)\n\t\t\tfor (int j=0; j<i.second; j++)\n\t\t\t\tzbi.push_back(i.first);\n\t\tvll now(d+1);\n\t\tnow[0]=1;\n\t\tfor (int i : zbi)\n\t\t\tdorzuc(now, i);\n\t\tassert(now[d]==m);\n\t\tprintf(\"%d\\n\", (int)zbi.size());\n\t\tfor (int i : zbi)\n\t\t\tprintf(\"%d \", i);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%lld\", &m);\n\tfor (int p=1; 1; p++)\n\t{\n\t\t//~ debug() << \"proba \" << p;\n\t\tvll dp(d+1);\n\t\tdp[0]=1;\n\t\tzbi.clear();\n\t\tint lim=los(1, 29);\n\t\tfor (int h=1; h<=60; h++)\n\t\t{\n\t\t\tcheck(dp);\n\t\t\t//~ int x=los(1, 29);\n\t\t\tint x=los(1, lim);\n\t\t\tzbi.push_back(x);\n\t\t\tdorzuc(dp, x);\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Game Bundles.json",
    "editorial_link": "https://codeforces.com//blog/entry/118540",
    "editorial": "SolutionWe describe a randomized solution that solves the problem for up\r\nto (and, with some additional care, may be able to solve also up to ).\r\nWe decided to give the problem with the smaller constraint to make the\r\nproblem more accessible and because there may be some rare cases below\r\nfor which our solution is too slow (even though we could not find any).\r\nWe donât know any provably correct solution, if you have one we would be\r\ncurious to see it. We expect to see many different solutions for this\r\nproblem.Main idea: Choose suitably the values that belong to and then\r\nfind in by solving a backpack-like problem.Let us describe more\r\nprecisely the main idea. Assume that are fixed and they satisfy . For\r\nany , let be the number of subsets so that . If we can find some values\r\nso that , then by setting for we have found a valid solution to the\r\nproblem.There are two main difficulties: How can we find ? How should we\r\nchoose ? Since it is important to get a good intuitive understanding of\r\nthe computational complexity of the algorithm, let us say now that we\r\nwill choose and (accordingly) . These values are flexible (the solution\r\nwould still work with and for example). We will say something more about\r\nthe choice of these values when we will describe how shall be chosen.The\r\nbackpack problem to find .The naive way to find would be to try all of\r\nthem. There are possible ways (up to order, which does not matter).\r\nSince this number is which is too much to fit in the time limit.To speed\r\nup the process, we will do as follows. Partition randomly into two sets\r\nof size . We iterate over all possible and over all possible and check\r\nwhether the sum of one choice from the first group and one choice from\r\nthe second group yields the result. This is a standard optimization for\r\nthe subset sum problem. What is its complexity? It can be implemented in\r\nlinear time in the size of the two groups we have to iterate over, which\r\nhave size . Notice that in this faster way we will not visit all the\r\npossible choices because we are assuming that exactly half of them\r\nbelong to and exactly half of them belong to . This is not a big deal\r\nbecause with sufficiently high probability we will find a solution in\r\nany case.The choice of .It remains to decide how we should select . The\r\nfollowing choice works: Approximately the first values are set equal to\r\n. Five additional values are chosen randomly from so that the total sum\r\nstays below . One should repeat the whole process until a solution is\r\nfound.Some intuition on the construction. The choice of may seem\r\narbitrary; let us try to justify it. The goal is to generate a set of\r\nvalues that are simultaneously ârandom enoughâ and with size smaller but\r\ncomparable to . These two conditions are necessary to expect that the\r\nbackpacking problem finds a solution with high enough probability.If ,\r\nthen and these numbers have size comparable to if is comparable to .\r\nThis observation explains why we start with approximately ones. The\r\nissue is that we need some flexibility in the process as we may need to\r\nrepeat it many times, this flexibility is provided by the addition of\r\nsome additional random elements which donât change the magnitude of the\r\nvalues but that modify them as much as possible (if we added a large\r\nnumber it would not affect many and thus it would not be very useful).\r\n",
    "hint": [
        "Hint 1 Go for a randomized approach.",
        "Hint 2 Many ones are useful.",
        "Hint 3 Either you go for a greedy or for a backpack."
    ]
}