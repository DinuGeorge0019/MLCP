{"link": "https://codeforces.com//contest/240/problem/D", "problemId": "1966", "problem_idx": "D", "shortId": "240D", "contest_number": "240", "problem_submissions": {"E": [27068673, 2369567, 6952646, 2369757, 2372786, 5412996, 2514695], "F": [2367683, 2368675, 2369245, 2369452, 2368590, 2369852, 2369859, 5410059, 2375572, 2369032, 2369175, 2372869, 2372867, 2372756, 2381339, 2372940, 2385773, 2373920, 2373882, 2373878, 2373867], "D": [2366591, 2366807, 2363963, 2366681, 2367043, 2367828, 2368196, 2368922, 2368559, 2366576, 2366169, 2366259, 2366076, 2366376, 2367080, 2367061, 2367534, 2366309], "B": [2364839, 2363209, 2363076, 2364268, 2364613, 2366303, 2366338, 2365433, 2365795, 2362822, 2364543, 2364502, 2364524, 2365151, 2363226, 2365069, 2363254, 2365130], "C": [2364074, 2363771, 2362766, 2363402, 2365229, 2364773, 2365070, 2366607, 2366758, 2363283, 2363525, 2363778, 2363522, 2364178, 2364017, 2363965, 2364497, 2363876], "A": [2363037, 2364923, 2364871, 2365199, 2363710, 2364055, 2364242, 2363918, 2364327, 2364439, 2363218, 2363258, 2363183, 2363585, 2365038, 2363271, 2365712, 2363292]}, "name": "D. Merging Two Decks", "statement": "There are two decks of cards lying on the table in front of you, some\r\ncards in these decks lay face up, some of them lay face down. You want\r\nto merge them into one deck in which each card is face down. You\u2019re\r\ngoing to do it in two stages.The first stage is to merge the two decks\r\nin such a way that the relative order of the cards from the same deck\r\ndoesn\u2019t change. That is, for any two different cards and in one deck, if\r\ncard lies above card , then after the merge card must also be above card\r\n.The second stage is performed on the deck that resulted from the first\r\nstage. At this stage, the executed operation is the turning operation.\r\nIn one turn you can take a few of the top cards, turn all of them, and\r\nput them back. Thus, each of the taken cards gets turned and the order\r\nof these cards is reversed. That is, the card that was on the bottom\r\nbefore the turn, will be on top after it.Your task is to make sure that\r\nall the cards are lying face down. Find such an order of merging cards\r\nin the first stage and the sequence of turning operations in the second\r\nstage, that make all the cards lie face down, and the number of turns is\r\nminimum.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\nusing namespace std;\nconst int MAX_N = int(1e5) + 10;\nint n, a[MAX_N], m, b[MAX_N];\n\nvector<pair<int, pair<int, int> > > parse(int a[], int n, int st) {\n\tvector<pair<int, pair<int, int> > > ret;\n\tfor (int i = 0, j; i < n; i = j) {\n\t\tfor (j = i; j < n && a[i] == a[j]; ++j)\n\t\t\t;\n\t\tret.push_back(make_pair(a[i], make_pair(i + st, j + st - 1)));\n\t}\n\treturn ret;\n}\n\nvoid push(vector<int>&order, vector<int>&color, pair<int, int> p,int c) {\n\tfor (int i = p.first; i <= p.second; ++i) {\n\t\torder.push_back(i);\n\t\tcolor.push_back(c);\n\t}\n}\n\nint main() {\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf(\"%d\", b + i);\n\t}\n\n\tvector<pair<int, pair<int, int> > > pa = parse(a, n, 1);\n\tvector<pair<int, pair<int, int> > > pb = parse(b, m, n + 1);\n\tif (pa.size() < pb.size())\n\t\tswap(pa, pb);\n\t//|pa|>=|pb|\n\t//insert pb into pa\n\tvector<int> order;\n\tvector<int> color;\n\tif (pa[0].first == pb[0].first) {\n\t\tfor (int i = 0; i < pa.size(); ++i) {\n\t\t\tpush(order, color, pa[i].second, pa[i].first);\n\t\t\tif (i < pb.size())\n\t\t\t\tpush(order, color, pb[i].second, pb[i].first);\n\t\t}\n\t} else if (pb.size() < pa.size()) {\n\t\tfor (int i = 0; i < pa.size() || i < pb.size(); ++i) {\n\t\t\tif (i < pa.size())\n\t\t\t\tpush(order, color, pa[i].second, pa[i].first);\n\t\t\tif (i < pb.size())\n\t\t\t\tpush(order, color, pb[i].second, pb[i].first);\n\t\t}\n\t} else {\n\t\t//who go first?\n\t\tint n = pa.size();\n\t\tint first;\n\t\tif (n % 2 == 0) {\n\t\t\t//0\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tfirst = 1;\n\t\t}\n\t\tif (pa[0].first != first)\n\t\t\tswap(pa, pb);\n\t\tfor (int i = 0; i < pa.size() || i < pb.size(); ++i) {\n\t\t\tif (i < pa.size())\n\t\t\t\tpush(order, color, pa[i].second, pa[i].first);\n\t\t\tif (i < pb.size())\n\t\t\t\tpush(order, color, pb[i].second, pb[i].first);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < order.size(); ++i) {\n\t\tprintf(\"%d \", order[i]);\n\t}\n\tputs(\"\");\n\tvector<int> opts;\n//\tcopy(color.begin(), color.end(), ostream_iterator<int>(cout, \" \"));\n//\tputs(\"\");\n\tfor (int i = 0, j; i < color.size(); i = j) {\n\t\tfor (j = i; j < color.size() && color[i] == color[j]; ++j)\n\t\t\t;\n\t\t//[i,j)\n\t\tif (color[i] == 1) {\n\t\t\tif (i > 0)\n\t\t\t\topts.push_back(i - 1);\n\t\t\topts.push_back(j - 1);\n\t\t}\n\t}\n\tcout << opts.size() << endl;\n\tfor (int i = 0; i < opts.size(); ++i) {\n\t\tprintf(\"%d \", opts[i] + 1);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "2000", "interactive": false}