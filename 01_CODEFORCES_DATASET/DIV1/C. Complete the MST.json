{"link": "https://codeforces.com//contest/1508/problem/C", "problemId": "958783", "problem_idx": "C", "shortId": "1508C", "contest_number": "1508", "problem_submissions": {"D": [113258208, 113225842, 113232066, 113242382, 113242310, 113248310, 113252824, 113256393, 113240058, 113236672, 113233206, 113240165, 113242005, 113242817, 113243142], "F": [113247954, 113415583, 113275748, 113263512, 113569093, 113516939], "C": [113237315, 113213039, 113214478, 113213780, 113212574, 113213010, 113224842, 113226169, 113232722, 113215825, 113215542, 113224987, 113223453, 113228420, 113228228, 113217788, 113226078, 113229271, 113230097], "E": [113228353, 113239041, 113241831, 113228851, 113231701, 113244425, 113243109, 113247201, 113253919, 113253035, 113238610, 113246155, 113333091, 113246539, 113240797, 113246922], "A": [113201428, 113189518, 113189456, 113190605, 113198010, 113192641, 113194080, 113204739, 113207875, 113194317, 113200012, 113222414, 113194745, 113195037, 113199971, 113199286, 113193286, 113195565, 113191574, 113194231], "B": [113197951, 113196658, 113192904, 113196665, 113201215, 113199153, 113202442, 113210198, 113217372, 113203624, 113208530, 113197629, 113206458, 113203987, 113206383, 113212945, 113200476, 113197819, 113199529, 113200558]}, "name": "C. Complete the MST", "statement": "As a teacher, Riko Hakozaki often needs to help her students with\r\nproblems from various subjects. Today, she is asked a programming task\r\nwhich goes as follows.You are given an undirected complete graph with n\r\nnodes, where some edges are pre-assigned with a positive weight while\r\nthe rest aren\u2019t. You need to assign all unassigned edges with so that in\r\nthe resulting fully-assigned complete graph the XOR sum of all weights\r\nwould be equal to 0.Define the of a fully-assigned complete graph the\r\nweight of its minimum spanning tree, where the weight of a spanning tree\r\nequals the sum of weights of its edges. You need to assign the weights\r\nso that the ugliness of the resulting graph is as small as possible.As a\r\nreminder, an undirected complete graph with n nodes contains all edges\r\n(u, v) with 1\r\nle u < v\r\nle n; such a graph has\r\nfrac{n(n-1)}{2} edges.She is not sure how to solve this problem, so she\r\nasks you to solve it for her.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N, M; cin >> N >> M;\n\tstruct edge_t {\n\t\tarray<int, 2> V;\n\t\tint W;\n\t};\n\tvector<edge_t> edges(M);\n\tvector<set<int>> adj(N);\n\tint totW = 0;\n\tfor (auto& e : edges) {\n\t\tcin >> e.V[0] >> e.V[1] >> e.W; e.V[0]--, e.V[1]--;\n\t\ttotW ^= e.W;\n\t\tadj[e.V[0]].insert(e.V[1]);\n\t\tadj[e.V[1]].insert(e.V[0]);\n\t}\n\tsort(edges.begin(), edges.end(), [&](const auto& a, const auto& b) { return a.W < b.W; });\n\n\tint64_t num_unassigned = int64_t(N) * int64_t(N-1) / 2 - M;\n\n\tvector<int> par(N, -1);\n\tauto reset_par = [&]() -> void { fill(par.begin(), par.end(), -1); };\n\tauto get_par = [&](int a) -> int {\n\t\twhile (par[a] >= 0) {\n\t\t\tif (par[par[a]] >= 0) par[a] = par[par[a]];\n\t\t\ta = par[a];\n\t\t}\n\t\treturn a;\n\t};\n\tauto merge = [&](int a, int b) -> bool {\n\t\ta = get_par(a), b = get_par(b);\n\t\tif (a == b) return false;\n\t\tif (par[a] > par[b]) swap(a, b);\n\t\tpar[a] += par[b];\n\t\tpar[b] = a;\n\t\treturn true;\n\t};\n\n\t{\n\t\tint nm = 0;\n\t\tfor (int z = 0; z < M; z++) {\n\t\t\tedge_t e = edges[z];\n\t\t\tif (merge(e.V[0], e.V[1])) {\n\t\t\t\tedges[nm++] = e;\n\t\t\t}\n\t\t}\n\t\tM = nm;\n\t\tedges.resize(M);\n\t}\n\n\treset_par();\n\n\tvector<int> unvis(N); iota(unvis.begin(), unvis.end(), 0);\n\tvector<int> q; q.reserve(N);\n\twhile (!unvis.empty()) {\n\t\tq.push_back(unvis.back()); unvis.pop_back();\n\t\tfor (int z = int(q.size())-1; z < int(q.size()); z++) {\n\t\t\tint cur = q[z];\n\t\t\tint b = 0;\n\t\t\tfor (int a = 0; a < int(unvis.size()); a++) {\n\t\t\t\tint nxt = unvis[a];\n\t\t\t\tif (adj[cur].count(nxt)) {\n\t\t\t\t\tunvis[b++] = nxt;\n\t\t\t\t} else {\n\t\t\t\t\tmerge(cur, nxt);\n\t\t\t\t\tnum_unassigned--;\n\t\t\t\t\tq.push_back(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunvis.resize(b);\n\t\t}\n\t}\n\n\tint64_t ans = 0;\n\tfor (auto e : edges) {\n\t\tif (merge(e.V[0], e.V[1])) {\n\t\t\tans += e.W;\n\t\t} else if (num_unassigned == 0) {\n\t\t\tans += min(totW, e.W);\n\t\t\tnum_unassigned = -1;\n\t\t}\n\t}\n\n\tif (num_unassigned == 0) {\n\t\tans += totW;\n\t\tnum_unassigned = -1;\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "data structures", "dfs and similar", "dsu", "graphs", "greedy", "trees"], "dificulty": "2500", "interactive": false}