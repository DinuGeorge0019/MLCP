{
    "link": "https://codeforces.com//contest/1508/problem/C",
    "problemId": "958783",
    "problem_idx": "C",
    "shortId": "1508C",
    "contest_number": "1508",
    "problem_submissions": {
        "D": [
            113258208,
            113225842,
            113232066,
            113242382,
            113242310,
            113248310,
            113252824,
            113256393,
            113240058,
            113236672,
            113233206,
            113240165,
            113242005,
            113242817,
            113243142
        ],
        "F": [
            113247954,
            113415583,
            113275748,
            113263512,
            113569093,
            113516939
        ],
        "C": [
            113237315,
            113213039,
            113214478,
            113213780,
            113212574,
            113213010,
            113224842,
            113226169,
            113232722,
            113215825,
            113215542,
            113224987,
            113223453,
            113228420,
            113228228,
            113217788,
            113226078,
            113229271,
            113230097
        ],
        "E": [
            113228353,
            113239041,
            113241831,
            113228851,
            113231701,
            113244425,
            113243109,
            113247201,
            113253919,
            113253035,
            113238610,
            113246155,
            113333091,
            113246539,
            113240797,
            113246922
        ],
        "A": [
            113201428,
            113189518,
            113189456,
            113190605,
            113198010,
            113192641,
            113194080,
            113204739,
            113207875,
            113194317,
            113200012,
            113222414,
            113194745,
            113195037,
            113199971,
            113199286,
            113193286,
            113195565,
            113191574,
            113194231
        ],
        "B": [
            113197951,
            113196658,
            113192904,
            113196665,
            113201215,
            113199153,
            113202442,
            113210198,
            113217372,
            113203624,
            113208530,
            113197629,
            113206458,
            113203987,
            113206383,
            113212945,
            113200476,
            113197819,
            113199529,
            113200558
        ]
    },
    "name": "C. Complete the MST",
    "statement": "As a teacher, Riko Hakozaki often needs to help her students with\r\nproblems from various subjects. Today, she is asked a programming task\r\nwhich goes as follows.You are given an undirected complete graph with n\r\nnodes, where some edges are pre-assigned with a positive weight while\r\nthe rest aren’t. You need to assign all unassigned edges with so that in\r\nthe resulting fully-assigned complete graph the XOR sum of all weights\r\nwould be equal to 0.Define the of a fully-assigned complete graph the\r\nweight of its minimum spanning tree, where the weight of a spanning tree\r\nequals the sum of weights of its edges. You need to assign the weights\r\nso that the ugliness of the resulting graph is as small as possible.As a\r\nreminder, an undirected complete graph with n nodes contains all edges\r\n(u, v) with 1\r\nle u < v\r\nle n; such a graph has\r\nfrac{n(n-1)}{2} edges.She is not sure how to solve this problem, so she\r\nasks you to solve it for her.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N, M; cin >> N >> M;\n\tstruct edge_t {\n\t\tarray<int, 2> V;\n\t\tint W;\n\t};\n\tvector<edge_t> edges(M);\n\tvector<set<int>> adj(N);\n\tint totW = 0;\n\tfor (auto& e : edges) {\n\t\tcin >> e.V[0] >> e.V[1] >> e.W; e.V[0]--, e.V[1]--;\n\t\ttotW ^= e.W;\n\t\tadj[e.V[0]].insert(e.V[1]);\n\t\tadj[e.V[1]].insert(e.V[0]);\n\t}\n\tsort(edges.begin(), edges.end(), [&](const auto& a, const auto& b) { return a.W < b.W; });\n\n\tint64_t num_unassigned = int64_t(N) * int64_t(N-1) / 2 - M;\n\n\tvector<int> par(N, -1);\n\tauto reset_par = [&]() -> void { fill(par.begin(), par.end(), -1); };\n\tauto get_par = [&](int a) -> int {\n\t\twhile (par[a] >= 0) {\n\t\t\tif (par[par[a]] >= 0) par[a] = par[par[a]];\n\t\t\ta = par[a];\n\t\t}\n\t\treturn a;\n\t};\n\tauto merge = [&](int a, int b) -> bool {\n\t\ta = get_par(a), b = get_par(b);\n\t\tif (a == b) return false;\n\t\tif (par[a] > par[b]) swap(a, b);\n\t\tpar[a] += par[b];\n\t\tpar[b] = a;\n\t\treturn true;\n\t};\n\n\t{\n\t\tint nm = 0;\n\t\tfor (int z = 0; z < M; z++) {\n\t\t\tedge_t e = edges[z];\n\t\t\tif (merge(e.V[0], e.V[1])) {\n\t\t\t\tedges[nm++] = e;\n\t\t\t}\n\t\t}\n\t\tM = nm;\n\t\tedges.resize(M);\n\t}\n\n\treset_par();\n\n\tvector<int> unvis(N); iota(unvis.begin(), unvis.end(), 0);\n\tvector<int> q; q.reserve(N);\n\twhile (!unvis.empty()) {\n\t\tq.push_back(unvis.back()); unvis.pop_back();\n\t\tfor (int z = int(q.size())-1; z < int(q.size()); z++) {\n\t\t\tint cur = q[z];\n\t\t\tint b = 0;\n\t\t\tfor (int a = 0; a < int(unvis.size()); a++) {\n\t\t\t\tint nxt = unvis[a];\n\t\t\t\tif (adj[cur].count(nxt)) {\n\t\t\t\t\tunvis[b++] = nxt;\n\t\t\t\t} else {\n\t\t\t\t\tmerge(cur, nxt);\n\t\t\t\t\tnum_unassigned--;\n\t\t\t\t\tq.push_back(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunvis.resize(b);\n\t\t}\n\t}\n\n\tint64_t ans = 0;\n\tfor (auto e : edges) {\n\t\tif (merge(e.V[0], e.V[1])) {\n\t\t\tans += e.W;\n\t\t} else if (num_unassigned == 0) {\n\t\t\tans += min(totW, e.W);\n\t\t\tnum_unassigned = -1;\n\t\t}\n\t}\n\n\tif (num_unassigned == 0) {\n\t\tans += totW;\n\t\tnum_unassigned = -1;\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Complete the MST.json",
    "editorial_link": "https://codeforces.com//blog/entry/89644",
    "editorial": "Call the XOR sum of the weights of all pre-assigned edges. All but one\r\nunassigned edges are assigned with , while the remaining unassigned edge\r\nis assigned with . Consider any assignment of unassigned edges. There\r\nare two cases on the minimum spanning tree: The MST does not use all\r\nunassigned edges: We can assign one unused unassigned edge with , while\r\nall other unassigned edges (including all used in the MST) are assigned\r\nwith . This reduces the weight of the MST. The MST uses all unassigned\r\nedges: We can prove that the sum of weights of unassigned edges is at\r\nleast , and the equality can be achieved with the construction from the\r\nlemma. Intuitively, the XOR sum is an \"uncarried\" summation, and the\r\nconstruction from the lemma removes any digit carry. Letâs DFS on the\r\nunassigned edges. It can happen that the unassigned edges may separate\r\nthe graph into multiple components, and we might need to use some\r\npre-assigned edges in our MST. I will divide the collection of\r\npre-assigned edges into 3 types: Edges that must be included in the MST:\r\nthese are edges with smallest weights that connect the components after\r\ntraversing through unassigned edges. Edges that cannot be included in\r\nthe MST: these are edges that form cycles with smaller-weighted\r\npre-assigned edges. In other words, these are edges that do not exist in\r\nthe minimum spanning forest of the pre-assigned edges. Edges that are in\r\nneither of the previous types. For the unassigned edges, there are two\r\ncases: The unassigned edges form at least a cycle: We can assign any\r\nedge on this cycle as , the rest as , then build an MST using the\r\n-weighted edges with pre-assigned edges of type 1. The unassigned edges\r\ndoes not form a cycle. Suppose we build the tree using only unassigned\r\nedges and edges of type 1. Then any edge of type 3 can replace an\r\nunassigned edge in the tree. That is because the edges of type 3 must\r\nform a cycle with edges of type 1 and unassigned edges (else it would\r\neither be in type 1 or type 2). We can simply replace an unassigned edge\r\nin that cycle with this type 3 edge. Therefore, for this case, our\r\nsolution is to first form the tree with all edges of type 1 and\r\nunassigned edge. Then, if the smallest weighted type 3 edge has weight ,\r\nwe can replace an unassigned edge with this edge; else, we keep the\r\ntree.\r\n",
    "hint": [
        "Hint 1 How can we solve this problem without the restriction that the xor of all edge weights is ? Answer Just assign to every unassigned edge :P",
        "Hint 2 When does the solution to the unrestricted problem fail for the real problem? Answer When any minimum spanning tree (of the graph with every unassigned edge having weight ) contains every unassigned edge, and the xor sum of all the edge weights is not .",
        "Hint 3 Leave the xor sum of the weights of the unassigned edges in the spanning tree fixed. How do we minimize their sum? Answer Assign the entire xor sum to a single edge, and assign weight to every other edge.",
        "Hint 4 Exactly one unassigned edge ends up with a non-zero weight. If we don't use all unassigned edges, which others can we use? Answer Any edge that isn't part of the MST when we consider unassigned edges to have weight , and that doesn't form a cycle with pre-assigned edges with smaller weights."
    ]
}