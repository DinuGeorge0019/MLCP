{"link": "https://codeforces.com//contest/128/problem/A", "problemId": "672", "problem_idx": "A", "shortId": "128A", "contest_number": "128", "problem_submissions": {"B": [868631, 867052, 866131, 868093, 864920, 867712, 867635, 868241, 868954, 866973, 868225, 869082, 869329, 868786], "C": [867417, 865854, 866628, 866135, 867141, 866532, 866167, 866639, 866961, 867655, 868770, 866966, 867088, 867033], "D": [865898, 866482, 867528, 866945, 868692, 868382, 868718, 867247, 867493, 868514, 866507, 867640, 867746, 867494], "A": [865243, 865123, 865205, 865177, 867354, 866061, 865379, 868310, 865524, 866301, 865222, 865534, 865830, 866105]}, "name": "A. Statues", "statement": "In this task Anna and Maria play a game with a very unpleasant rival.\r\nAnna and Maria are in the opposite squares of a chessboard (): Anna is\r\nin the upper right corner, and Maria is in the lower left one. Apart\r\nfrom them, the board has several statues. Each statue occupies exactly\r\none square. A square that contains a statue cannot have anything or\r\nanyone neither any other statues, nor Anna, nor Maria.Anna is present on\r\nthe board as a figurant (she stands still and never moves), and Maria\r\nhas been actively involved in the game. Her goal is to come to Anna\u2019s\r\nsquare. Maria and statues move in turn, Maria moves first. During one\r\nmove Maria can go to any adjacent on the side or diagonal cell in which\r\nthere is no statue, or she can stay in the cell where she is. The\r\nstatues during their move must go one square down simultaneously, and\r\nthose statues that were in the bottom row fall from the board and are no\r\nlonger appeared.At that moment, when one of the statues is in the cell\r\nin which the Maria is, the statues are declared winners. At the moment\r\nwhen Maria comes into the cell where Anna has been waiting, Maria is\r\ndeclared the winner.Obviously, nothing depends on the statues, so it all\r\ndepends on Maria. Determine who will win, if Maria does not make a\r\nstrategic error.\r\n", "solutions": ["#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long double real;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf (stderr, __VA_ARGS__)\n#else\n#define eprintf(...) assert (true)\n#endif\n\n#ifdef WIN32\n#define INT64 \"%I64d\"\n#else\n#define INT64 \"%lld\"\n#endif\n\nusing namespace std;\n\nconst int MaxN = 10, NA = -1, MaxC = 0x3F3F3F3F;\n\nchar a [2] [MaxN] [MaxN];\n\nint main (void)\n{\n int i, j, k, l, m;\n bool win;\n\n while (1)\n {\n  memset (a, 0, sizeof (a));\n  for (i = 1; i <= 8; i++)\n   for (j = 1; j <= 8; j++)\n    if (scanf (\" %c\", &a[0][i][j]) == EOF)\n     return 0;\n\n  win = false;\n  for (m = 0; m < 64; m++)\n  {\n   memmove (a[1], a[0], sizeof (a[0]));\n   for (i = 1; i <= 8; i++)\n    for (j = 1; j <= 8; j++)\n     if (a[0][i][j] == 'M')\n      for (k = -1; k <= +1; k++)\n       for (l = -1; l <= +1; l++)\n        if (a[1][i + k][j + l] != 'S')\n         a[1][i + k][j + l] = 'M';\n   if (a[1][1][8] == 'M')\n   {\n    win = true;\n    break;\n   }\n\n   memmove (a[0], a[1], sizeof (a[1]));\n//   for (i = 1; i <= 7; i++)\n   for (i = 7; i >= 1; i--)\n    for (j = 1; j <= 8; j++)\n     if (a[1][i][j] == 'S')\n     {\n      a[0][i][j] = '.';\n      a[0][i + 1][j] = 'S';\n     }\n  }\n\n  printf (\"%s\\n\", win ? \"WIN\" : \"LOSE\");\n }\n return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar"], "dificulty": "1500", "interactive": false}