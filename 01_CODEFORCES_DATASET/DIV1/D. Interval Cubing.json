{"link": "https://codeforces.com//contest/311/problem/D", "problemId": "3071", "problem_idx": "D", "shortId": "311D", "contest_number": "311", "problem_submissions": {"D": [3779247, 3776962, 3778512, 3778294, 7187096, 3778596, 3778655, 3779595, 3782423, 3776852, 3786173, 3776817, 3777538, 3777530, 3777687, 3778930, 3778715, 3781988, 3781985, 3780451, 3778559], "C": [3778239, 3780359, 3778509, 3777340, 3780975], "A": [3773410, 3772638, 3772385, 3772049, 3772839, 3772053, 3772233, 3773330, 3772046, 3773286, 3772169, 3772655, 3772327, 3772092, 3778118, 3777958, 3772079, 3772167, 3778901], "B": [3779559, 3776732, 3776480, 3777959, 3776688, 3778706, 3777594, 3778546], "E": [3786260, 3786243, 3779354, 3780972, 3779369]}, "name": "D. Interval Cubing", "statement": "While learning Computational Geometry, Tiny is simultaneously learning a\r\nuseful data structure called segment tree or interval tree. He has\r\nscarcely grasped it when comes out a strange problem:Given an integer\r\nsequence . You should run queries of two types: Given two integers and\r\n(), ask the sum of all elements in the sequence . Given two integers and\r\n(), let each element in the sequence becomes . In other words, apply an\r\nassignments . For every query of type 1, output the answer to it.Tiny\r\nhimself surely cannot work it out, so he asks you for help. In addition,\r\nTiny is a prime lover. He tells you that because the answer may be too\r\nhuge, you should only output it modulo (this number is a prime number).\r\n", "solutions": ["#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define fr(i,n)for(int i=0;i<n;i++)\n#define fo(i,n)for(int i=1;i<=n;i++)\n#define fe(i,n)for(__typeof(n.begin())i=n.begin();i!=n.end();i++)\nconst int p=95542721;\nstruct N\n{\n\tint s[48],w;\n}T[300000];\nint v[300000];\n#define P(l,r)(((l)+(r)-1)|((l)!=(r)-1))\nvoid update(N *t,N *l,N *r)\n{\n\tfr(i,48)\n\t{\n\t\tt->s[i]=l->s[(i+l->w)%48]+r->s[(i+r->w)%48];\n\t\tif(t->s[i]>=p)\n\t\t\tt->s[i]-=p;\n\t}\n}\nvoid put_w(N *t,int x)\n{\n\t(t->w+=x)%=48;\n}\nvoid cg(int L,int R,int t,int l,int r)\n{\n\tif(L<=l&&r<=R)\n\t\treturn put_w(T+t,1);\n\tint m=(l+r+1)>>1,lc=P(l,m),rc=P(m,r);\n\tif(L<m)\n\t\tcg(L,R,lc,l,m);\n\tif(m<R)\n\t\tcg(L,R,rc,m,r);\n\tupdate(T+t,T+lc,T+rc);\n}\nvoid ___(N *t,int x)\n{\n\tt->w=0,t->s[0]=v[x];\n\tfo(i,47)\n\t\tt->s[i]=(long long)t->s[i-1]*t->s[i-1]%p*t->s[i-1]%p;\n}\nvoid bd(int t,int l,int r)\n{\n\tif(l+1==r)\n\t\treturn ___(T+t,r);\n\tint m=(l+r+1)>>1,lc=P(l,m),rc=P(m,r);\n\tbd(lc,l,m);\n\tbd(rc,m,r);\n\tupdate(T+t,T+lc,T+rc);\n}\n\nint qy(int L,int R,int t,int l,int r,int w)\n{\n\tif(L<=l&&r<=R)\n\t\treturn T[t].s[(T[t].w+w)%48];\n\tint m=(l+r+1)>>1,lc=P(l,m),rc=P(m,r),re=0;\n\tw+=T[t].w;\n\tif(L<m)\n\t\tre+=qy(L,R,lc,l,m,w);\n\tif(m<R)\n\t\tre+=qy(L,R,rc,m,r,w);\n\treturn re>=p?(re-p):re;\n}\nint main()\n{\n\tint n,m;\n\tcin>>n;\n\tfo(i,n)\n\t{\n\t\tscanf(\"%d\",v+i);\n\t\tv[i]%=p;\n\t}\n\tbd(P(0,n),0,n);\n\tcin>>m;\n\tfor(;m--;)\n\t{\n\t\tint o,L,R;\n\t\tscanf(\"%d%d%d\",&o,&L,&R);\n\t\tif(o==2)\n\t\t\tcg(L-1,R,P(0,n),0,n);\n\t\telse\n\t\t\tprintf(\"%d\\n\",qy(L-1,R,P(0,n),0,n,0));\n\t}\n\treturn 0; \n}"], "input": "", "output": "", "tags": ["data structures", "math"], "dificulty": "2600", "interactive": false}