{
    "link": "https://codeforces.com//contest/497/problem/A",
    "problemId": "19571",
    "problem_idx": "A",
    "shortId": "497A",
    "contest_number": "497",
    "problem_submissions": {
        "E": [
            9174487,
            9174196,
            9175010,
            9199333,
            9175252,
            9176527,
            9176653,
            9180194
        ],
        "D": [
            9170679,
            9173274,
            9174804,
            9174751,
            9171031,
            9176067,
            9175754
        ],
        "C": [
            9168733,
            9168537,
            9168027,
            43565108,
            9170031,
            9168979,
            9168260,
            9169684,
            9168763,
            9174362,
            9172330,
            9171998,
            9173920,
            9168319,
            9168825,
            9168629,
            43565576,
            9168203
        ],
        "B": [
            9166459,
            9166265,
            9166436,
            9199442,
            9167203,
            9166878,
            9166797,
            9166926,
            9170793,
            9172501,
            9170015,
            9168743,
            9169417,
            9166154,
            9166746,
            9166737,
            9165998
        ],
        "A": [
            9164122,
            9164273,
            9164359,
            9164060,
            9163922,
            9164065,
            9163958,
            9164600,
            9164390,
            9164526,
            9164902,
            9167522,
            9163923,
            9163921,
            9164484,
            9163952
        ]
    },
    "name": "A. Removing Columns",
    "statement": "You are given an rectangular table consisting of lower case English\r\nletters. In one operation you can completely remove one column from the\r\ntable. The remaining parts are combined forming a new table. For\r\nexample, after removing the second column from the tableabcdedfghijk we\r\nobtain the table:acdefghjk A table is called if its rows are ordered\r\nfrom top to bottom lexicographically, i.e. each row is lexicographically\r\nno larger than the following one. Determine the minimum number of\r\noperations of removing a column needed to make a given table good.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define ford(i,n) for (int i = int(n) - 1; i >= 0; --i)\n#define forv(i,v) for (auto i = v.begin(); i != v.end(); ++i)\n#define forr(i,v) for (auto i = v.end(); i != v.begin() && (--i, 1); )\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T> inline T abs (T x) {return x > T() ? x : -x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 1000;\n\nstruct Input {\n\tint n, m;\n\tstring s[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n >> m)) {\n\t\t\treturn 0;\n\t\t}\n\t\tgetline(cin, s[0]);\n\t\tforn (i, n) {\n\t\t\tgetline(cin, s[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tint ans;\n\t\n\tvoid write () {\n\t\tcout << ans << endl;\n\t}\n\t\n\tvirtual void solve () {}\n\t\n\tvirtual void clear () {\n\t\t*this = Data();\n\t}\n};\n\nstruct Solution: Data {\n\tbool done[N];\n\t\n\tvoid solve () {\n\t\tmemset(done, 0, sizeof done);\n\t\tans = 0;\n\t\tforn (i, m) {\n\t\t\tbool ok = 1;\n\t\t\tforn (j, n - 1) {\n\t\t\t\tif (!done[j] && s[j][i] > s[j + 1][i]) {\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tans++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tforn (j, n - 1) {\n\t\t\t\tif (s[j][i] < s[j + 1][i]) {\n\t\t\t\t\tdone[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid clear () {\n\t\t*this = Solution();\n\t}\n};\n\nSolution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\twhile (sol.read()) {\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n#else\n\tsol.read();\n\tsol.solve();\n\tsol.write();\n#endif\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Removing Columns.json",
    "editorial_link": "https://codeforces.com/blog/entry/15208",
    "editorial": "Letâs look at the first column of the table. If its letters are not\r\nsorted alphabetically, then in any valid choice of removing some columns\r\nit has to be removed. However, if its letters are sorted, then for every\r\nvalid choice that has this column removed it can be restored back to the\r\ntable; it is clear that the new choice is valid (that is, the rows of\r\nthe new table are sorted lexicographically) and the answer (that is, the\r\nnumber of removed columns) has just became smaller. Consider all columns\r\nfrom left to right. We have already chosen which columns to remove among\r\nall the columns to the left of the current one; if leaving the current\r\ncolumn in place breaks the lexicographical order of rows, then we have\r\nto remove it; otherwise, we may leave it in place to no harm. Arguing in\r\nthe way of the previous paragraph we can prove that this greedy method\r\nyields an optimal (moreover, the only optimal) solution. The complexity\r\nis . Challenge: compute how many (say, modulo ) tables are there for\r\nwhich the answer for this problem is ? The more efficient solution you\r\ncome up with, the better.\r\n",
    "hint": []
}