{
    "link": "https://codeforces.com//contest/687/problem/B",
    "problemId": "63911",
    "problem_idx": "B",
    "shortId": "687B",
    "contest_number": "687",
    "problem_submissions": {
        "E": [
            18802309,
            18806260,
            18805246,
            18803372,
            18799334,
            18807280,
            18805272,
            18806337,
            18807252,
            18806390,
            18807620,
            18803706,
            18810595,
            18816088,
            18805681
        ],
        "D": [
            18793799,
            18802718,
            18796900,
            18797754,
            18807683,
            18798362,
            18797604,
            18800141,
            18800702,
            18803058,
            18801619,
            18800190,
            18801266,
            18807597,
            18797518,
            18800453,
            18798281
        ],
        "A": [
            18790806,
            18786960,
            18787408,
            18787163,
            18787741,
            18788893,
            18788129,
            18787797,
            18786842,
            18788168,
            18789518,
            18787023,
            18787148,
            18787130,
            18787967,
            18788569,
            18787232,
            18787389
        ],
        "C": [
            18788685,
            18790045,
            18790813,
            18791514,
            18792644,
            18791092,
            18793279,
            18795089,
            18793603,
            18792159,
            18795767,
            18790356,
            18792828,
            18792310,
            18792853,
            18794074,
            18789915,
            18792958
        ],
        "B": [
            18786970,
            18788540,
            18789247,
            18789185,
            18796167,
            18786909,
            18790772,
            18789737,
            20295221,
            20295216,
            20295180,
            20295158,
            20295119,
            20295105,
            18790246,
            18790367,
            18793463,
            18789273,
            20295043,
            20295033,
            20295023,
            20295001,
            20294990,
            20292826,
            18789797,
            18790852,
            18792280,
            18796842,
            18789369
        ]
    },
    "name": "B. Remainders Game",
    "statement": "Today Pari and Arya are playing a game called Remainders.Pari chooses\r\ntwo positive integer and , and tells Arya but not . Arya have to find\r\nthe value . There are ancient numbers and Pari has to tell Arya if Arya\r\nwants. Given and the ancient values, tell us if Arya has a winning\r\nstrategy independent of value of or not. Formally, is it true that Arya\r\ncan understand the value for any positive integer ?Note, that means the\r\nremainder of after dividing it by .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\ntypedef pair<ll,ll> PLL;\nnamespace Factor {\n\tconst int N=1010000;\n\tll C,fac[10010],n,mut,a[1001000];\n\tint T,cnt,i,l,prime[N],p[N],psize,_cnt;\n\tll _e[100],_pr[100];\n\tvector<ll> d;\n\tinline ll mul(ll a,ll b,ll p) {\n\t\tif (p<=1000000000) return a*b%p;\n\t\telse if (p<=1000000000000ll) return (((a*(b>>20)%p)<<20)+(a*(b&((1<<20)-1))))%p;\n\t\telse {\n\t\t\tll d=(ll)floor(a*(long double)b/p+0.5);\n\t\t\tll ret=(a*b-d*p)%p;\n\t\t\tif (ret<0) ret+=p;\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvoid prime_table(){\n\t\tint i,j,tot,t1;\n\t\tfor (i=1;i<=psize;i++) p[i]=i;\n\t\tfor (i=2,tot=0;i<=psize;i++){\n\t\t\tif (p[i]==i) prime[++tot]=i;\n\t\t\tfor (j=1;j<=tot && (t1=prime[j]*i)<=psize;j++){\n\t\t\t\tp[t1]=prime[j];\n\t\t\t\tif (i%prime[j]==0) break;\n\t\t\t}\n\t\t}\n\t}\n\tvoid init(int ps) {\n\t\tpsize=ps;\n\t\tprime_table();\n\t}\n\tll powl(ll a,ll n,ll p) {\n\t\tll ans=1;\n\t\tfor (;n;n>>=1) {\n\t\t\tif (n&1) ans=mul(ans,a,p);\n\t\t\ta=mul(a,a,p);\n\t\t}\n\t\treturn ans;\n\t}\n\tbool witness(ll a,ll n) {\n\t\tint t=0;\n\t\tll u=n-1;\n\t\tfor (;~u&1;u>>=1) t++;\n\t\tll x=powl(a,u,n),_x=0;\n\t\tfor (;t;t--) {\n\t\t\t_x=mul(x,x,n);\n\t\t\tif (_x==1 && x!=1 && x!=n-1) return 1;\n\t\t\tx=_x;\n\t\t}\n\t\treturn _x!=1;\n\t}\n\tbool miller(ll n) {\n\t\tif (n<2) return 0;\n\t\tif (n<=psize) return p[n]==n;\n\t\tif (~n&1) return 0;\n\t\tfor (int j=0;j<=7;j++) if (witness(rand()%(n-1)+1,n)) return 0;\n\t\treturn 1;\n\t}\n\tll gcd(ll a,ll b) {\n\t\tll ret=1;\n\t\twhile (a!=0) {\n\t\t\tif ((~a&1) && (~b&1)) ret<<=1,a>>=1,b>>=1;\n\t\t\telse if (~a&1) a>>=1; else if (~b&1) b>>=1;\n\t\t\telse {\n\t\t\t\tif (a<b) swap(a,b);\n\t\t\t\ta-=b;\n\t\t\t}\n\t\t}\n\t\treturn ret*b;\n\t}\n\tll rho(ll n) {\n\t\tfor (;;) {\n\t\t\tll X=rand()%n,Y,Z,T=1,*lY=a,*lX=lY;\n\t\t\tint tmp=20;\n\t\t\tC=rand()%10+3;\n\t\t\tX=mul(X,X,n)+C;*(lY++)=X;lX++;\n\t\t\tY=mul(X,X,n)+C;*(lY++)=Y;\n\t\t\tfor(;X!=Y;) {\n\t\t\t\tll t=X-Y+n;\n\t\t\t\tZ=mul(T,t,n);\n\t\t\t\tif(Z==0) return gcd(T,n);\n\t\t\t\ttmp--;\n\t\t\t\tif (tmp==0) {\n\t\t\t\t\ttmp=20;\n\t\t\t\t\tZ=gcd(Z,n);\n\t\t\t\t\tif (Z!=1 && Z!=n) return Z;\n\t\t\t\t}\n\t\t\t\tT=Z;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tX=*(lX++);\n\t\t\t}\n\t\t}\n\t}\n\tvoid _factor(ll n) {\n\t\tfor (int i=0;i<cnt;i++) {\n\t\t\tif (n%fac[i]==0) n/=fac[i],fac[cnt++]=fac[i];}\n\t\tif (n<=psize) {\n\t\t\tfor (;n!=1;n/=p[n]) fac[cnt++]=p[n];\n\t\t\treturn;\n\t\t}\n\t\tif (miller(n)) fac[cnt++]=n;\n\t\telse {\n\t\t\tll x=rho(n);\n\t\t\t_factor(x);_factor(n/x);\n\t\t}\n\t}\n\tvoid dfs(ll x,int dep) {\n\t\tif (dep==_cnt) d.pb(x);\n\t\telse {\n\t\t\tdfs(x,dep+1);\n\t\t\tfor (int i=1;i<=_e[dep];i++) dfs(x*=_pr[dep],dep+1);\n\t\t}\n\t}\n\tvoid norm() {\n\t\tsort(fac,fac+cnt);\n\t\t_cnt=0;\n\t\trep(i,0,cnt) if (i==0||fac[i]!=fac[i-1]) _pr[_cnt]=fac[i],_e[_cnt++]=1;\n\t\t\telse _e[_cnt-1]++;\n\t}\n\tvector<ll> getd() {\n\t\td.clear();\n\t\tdfs(1,0);\n\t\treturn d;\n\t}\n\tvector<ll> factor(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\treturn getd();\n\t}\n\tvector<PLL> factorG(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\tvector<PLL> d;\n\t\trep(i,0,_cnt) d.pb(mp(_pr[i],_e[i]));\n\t\treturn d;\n\t}\n\tbool is_primitive(ll a,ll p) {\n\t\tassert(miller(p));\n\t\tvector<PLL> D=factorG(p-1);\n\t\trep(i,0,SZ(D)) if (powl(a,(p-1)/D[i].fi,p)==1) return 0;\n\t\treturn 1;\n\t}\n}\n\nint n,k,c;\nint val[10100000];\nint main() {\n\tFactor::init(1000000);\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,0,n) {\n\t\tscanf(\"%d\",&c);\n\t\tvector<PLL> d=Factor::factorG(c);\n\t\tfor (auto p:d) val[p.fi]=max(val[p.fi],(int)p.se);\n\t}\n\tvector<PLL> d=Factor::factorG(k);\n\tfor (auto p:d) {\n\t\tif (val[p.fi]<p.se) {\n\t\t\tputs(\"No\"); return 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "chinese remainder theorem",
        "math",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Remainders Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/45770",
    "editorial": "Hint\nAssume the answer of a test is No. There must exist a pair of integers x1 and x2 such that both of them have the same remainders after dividing by any ci, but they differ in remainders after dividing by k. Find more facts about x1 and x2!\n\nSolution\nConsider the x1 and x2 from the hint part. We have x1?-?x2???0 () for each 1???i???n.\n\nSo:\n\n\nWe also have  (). As a result:\n\n\nWe've found a necessary condition. And I have to tell you it's also sufficient!\n\nAssume , we are going to prove there exists x1,?x2 such that x1?-?x2???0 () (for each 1???i???n), and  ().\n\nA possible solution is x1?=?lcm(c1,?c2,?...,?cn) and x2?=?2?Ã—?lcm(c1,?c2,?...,?cn), so the sufficiency is also proved.\n\nSo you have to check if lcm(c1,?c2,?...,?cn) is divisible by k, which could be done using prime factorization of k and ci values.\n\nFor each integer x smaller than MAXC, find it's greatest prime divisor gpdx using sieve of Eratosthenes in .\n\nThen using gpd array, you can write the value of each coin as p1q1p2q2...pmqm where pi is a prime integer and 1???qi holds. This could be done in  by moving from ci to  and adding gpdci to the answer. And you can factorize k by the same way. Now for every prime p that , see if there exists any coin i that the power of p in the factorization of ci is not smaller than the power of p in the factorization of k.",
    "hint": []
}