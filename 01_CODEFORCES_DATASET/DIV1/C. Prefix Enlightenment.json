{
    "link": "https://codeforces.com//contest/1290/problem/C",
    "problemId": "529279",
    "problem_idx": "C",
    "shortId": "1290C",
    "contest_number": "1290",
    "problem_submissions": {
        "C": [
            70096929,
            70064543,
            70052395,
            70054161,
            70047406,
            70047992,
            70053917,
            70053152,
            70054979,
            70214121,
            70054528,
            70058183,
            70057014,
            70052660,
            70052531,
            70060568,
            70059018,
            70063715,
            70055920,
            70058007,
            70059153,
            70056438
        ],
        "D": [
            70071102,
            70083418,
            70081951,
            70059761,
            70062540,
            70064117,
            70088222,
            70088118,
            70087893,
            70066142,
            71762685,
            70214194,
            70214147,
            70068516,
            70069978,
            70069936,
            70074018,
            70075546,
            70074118,
            70071674,
            70072917,
            70077679,
            70075595,
            70065164,
            70078630
        ],
        "F": [
            70059398,
            70084031,
            70111116,
            70110928,
            75833689,
            70089144,
            70131709
        ],
        "A": [
            70040962,
            70037530,
            70037805,
            70036026,
            70036076,
            70037499,
            70037219,
            70040023,
            70214047,
            70038241,
            70036901,
            70036876,
            70037974,
            70038261,
            70038975,
            70040060,
            70041968,
            70036027,
            70043312,
            70045091,
            70039900
        ],
        "B": [
            70038396,
            70041221,
            70041673,
            70039846,
            70040515,
            70043644,
            70043914,
            70045743,
            70214060,
            70047838,
            70043116,
            70043411,
            70045228,
            70046548,
            70048357,
            70051227,
            70051419,
            70047415,
            70062917,
            70075181,
            70045909
        ],
        "E": [
            70074704,
            70107871,
            70086286,
            70079191,
            70214607,
            70086883,
            70085799,
            70123893,
            70086530,
            70158475,
            70100288,
            70111014
        ]
    },
    "name": "C. Prefix Enlightenment",
    "statement": "There are n lamps on a line, numbered from 1 to n. Each one has an\r\ninitial state off (0) or on (1).You\u2019re given k subsets A_1,\r\nldots, A_k of\r\n{1, 2,\r\ndots, n\r\n}, such that the intersection of any three subsets is empty. In other\r\nwords, for all 1\r\nle i_1 < i_2 < i_3\r\nle k, A_{i_1}\r\ncap A_{i_2}\r\ncap A_{i_3} =\r\nvarnothing.In one operation, you can choose one of these k subsets and\r\nswitch the state of all lamps in it. It is guaranteed that, with the\r\ngiven subsets, it\u2019s possible to make all lamps be simultaneously on\r\nusing this type of operation.Let m_i be the minimum number of operations\r\nyou have to do in order to make the i first lamps be simultaneously on.\r\nNote that there is no condition upon the state of other lamps (between\r\ni+1 and n), they can be either off or on.You have to compute m_i for all\r\n1\r\nle i\r\nle n.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 02.02.2020 17:22:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass dsu {\n public:\n  vector<int> p;\n  vector<long long> k0;\n  vector<long long> k1;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n    k0.resize(n);\n    k1.resize(n);\n    for (int i = 0; i < n / 2; i++) {\n      k0[i] = 1;\n    }\n    for (int i = n / 2; i < n; i++) {\n      k1[i] = 1;\n    }\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      k0[y] += k0[x];\n      k1[y] += k1[x];\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<vector<int>> at(n);\n  for (int i = 0; i < k; i++) {\n    int foo;\n    cin >> foo;\n    for (int j = 0; j < foo; j++) {\n      int x;\n      cin >> x;\n      --x;\n      at[x].push_back(i);\n    }\n  }\n  dsu d(2 * k);\n  const int inf = (int) 1e9;\n  long long ans = 0;\n  auto P = [&](int x) {\n    return x < k ? x + k : x - k;\n  };\n  auto Unite = [&](int u, int v) {\n    u = d.get(u);\n    v = d.get(v);\n    if (u == v) {\n      return;\n    }\n    ans -= min(d.k1[u], d.k1[P(u)]);\n    ans -= min(d.k1[v], d.k1[P(v)]);\n    d.unite(u, v);\n    d.unite(P(u), P(v));\n    ans += min(d.k1[v], d.k1[P(v)]);\n  };\n  for (int i = 0; i < n; i++) {\n    if (at[i].size() == 0) {\n      assert(s[i] == '1');\n    } else {\n      if (at[i].size() == 1) {\n        int v = d.get(s[i] == '0' ? at[i][0] : at[i][0] + k);\n        ans -= min(d.k1[v], d.k1[P(v)]);\n        d.k1[v] = inf;\n        ans += min(d.k1[v], d.k1[P(v)]);\n      } else {\n        int v = at[i][0];\n        int u = at[i][1];\n        if (s[i] == '1') {\n          Unite(u, v);\n        } else {\n          Unite(u, v + k);\n        }\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Prefix Enlightenment.json",
    "editorial_link": "https://codeforces.com//blog/entry/73563",
    "editorial": "The condition \"the intersection of any three subsets is empty\" can be\r\neasily rephrased in a more useful way: each element appears in two\r\nsubsets.Let\u00e2\u0080\u0099s suppose for the moment that each elements appears in\r\nexactly two subsets. We can think of each element as an edge between the\r\nsubsets, it\u00e2\u0080\u0099s a classical point of view. If we see subsets as nodes, we\r\ncan model the subsets choice by coloring nodes into two colors, \"taken\"\r\nor \"non-taken\". If an element is initially off, we need to take exactly\r\none of the subsets containing it. The corresponding edge should have\r\nendpoints with different color. If an element is initially on, we must\r\ntake none or both subsets : endpoints with same color.We recognize a\r\nsort of bipartition, obviously there are at most two correct colorings\r\nfor each connected component: fixing the color of a node fix the color\r\nof all connected nodes.Hence, the final answer is the sum for each\r\ncomponent, of the size of the smaller side of the partition.Since the\r\nanswer exists for , there exists a such partition of the graph (into\r\n\"red\" and \"blue\" nodes). We can find it with usual dfs, and keep it for\r\nlower values of .In order to compute all efficiently, we start from a\r\ngraph with no edges (), and we add edges with DSU, maintaining in each\r\nconnected component the count of nodes in red side, and the count of\r\nnodes in blue side.Now, how to deal with elements that appears in\r\nexactly one subset? They don\u00e2\u0080\u0099t add any edge in the graph, but they force\r\nto take one of the sides of the connected component. To simulate this,\r\nwe can use a special forced flag, or just fix the count of the other\r\nside to (but be careful about overflow if you do that).Final complexity\r\n: .\r\n"
}