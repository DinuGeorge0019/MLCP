{
    "link": "https://codeforces.com//contest/1286/problem/C1",
    "problemId": "509641",
    "problem_idx": "C1",
    "shortId": "1286C1",
    "contest_number": "1286",
    "problem_submissions": {
        "E": [
            68277312,
            68282070,
            68274194,
            68303699,
            68303260,
            68305269,
            68280891,
            68275520,
            68485018,
            68484885,
            68281607,
            68589901,
            71865785,
            101133015,
            68300396
        ],
        "C2": [
            68266879,
            68290041,
            68261617,
            68262301,
            68264579,
            68294367,
            68270650,
            68281404,
            68295029,
            68426335,
            68286377,
            68264588,
            68267031
        ],
        "D": [
            68263572,
            68264108,
            68884999,
            68884847,
            68884788,
            68283246,
            68268908,
            68270542,
            68266913,
            68271305,
            68294377,
            68276847,
            68262972,
            68265436,
            68273176,
            68274949,
            68277188,
            68266253,
            68271981,
            68278589,
            68338459,
            68281162,
            68264815
        ],
        "C1": [
            68253495,
            68254635,
            68259019,
            68259783,
            68260037,
            68294288,
            68263649,
            68253659,
            68276644,
            68259313,
            68260800,
            68257683,
            68278462,
            68275645,
            68260838,
            68264488,
            68260121
        ],
        "B": [
            68249656,
            68250720,
            68252206,
            68250842,
            68249851,
            68249360,
            68294267,
            68254854,
            68250823,
            68250630,
            68252322,
            68250475,
            68253134,
            68252948,
            68253877,
            68249986,
            68255559,
            68256077,
            68252468,
            68253101,
            68252113
        ],
        "A": [
            68245108,
            68248019,
            68248101,
            68248225,
            68245837,
            68246154,
            68294224,
            68250492,
            68248558,
            68247246,
            68248005,
            68247110,
            68249600,
            68246667,
            68250822,
            68253310,
            68252365,
            68251609,
            68247685,
            68248520,
            68246550
        ],
        "F": [
            68288717,
            68426651,
            68284858,
            68284592,
            68283300,
            68321599,
            68593980,
            68272947,
            68281697,
            68274721,
            75028012
        ]
    },
    "name": "C1. Madhouse  Easy version ",
    "statement": "Venya joined a tour to the madhouse, in which orderlies play with\r\npatients the following game. Orderlies pick a string s of length n,\r\nconsisting only of lowercase English letters. The player can ask two\r\ntypes of queries: ask to list all substrings of s[l..r]. Substrings will\r\nbe returned in random order, and in every substring, all characters will\r\nbe randomly shuffled. guess the string picked by the orderlies. This\r\nquery can be asked exactly once, after that the game will finish. If the\r\nstring is guessed correctly, the player wins, otherwise he loses. The\r\nplayer can ask of the first type.To make it easier for the orderlies,\r\nthere is an additional limitation: the total number of returned\r\nsubstrings in all queries of the first type must not exceed\r\n(n+1)^2.Venya asked you to write a program, which will guess the string\r\nby interacting with the orderlies’ program and acting by the game’s\r\nrules.Your program should immediately terminate after guessing the\r\nstring using a query of the second type. In case your program guessed\r\nthe string incorrectly, or it violated the game rules, it will receive\r\nverdict .Note that in every test case the string is fixed beforehand and\r\nwill not change during the game, which means that the interactor is not\r\nadaptive.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n;\nchar p[120], A[10100][120], B[10100][120], res[120];\nint SA[110], SB[110], Z[110];\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\n\tprintf(\"? %d %d\\n\", 1, n);\n\tfflush(stdout);\n\tif (n == 1) {\n\t\tscanf(\"%s\", p);\n\t\tprintf(\"! %s\\n\", p);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < n*(n + 1) / 2; i++) {\n\t\tscanf(\"%s\", A[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; A[i][j]; j++)c += A[i][j] - 'a';\n\t\tint L = j;\n\t\tSA[L] += c;\n\t}\n\tprintf(\"? %d %d\\n\", 1, n - 1);\n\tfflush(stdout);\n\n\tfor (i = 0; i < n*(n - 1) / 2; i++) {\n\t\tscanf(\"%s\", B[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; B[i][j]; j++)c += B[i][j] - 'a';\n\t\tint L = j;\n\t\tSB[L] += c;\n\t}\n\n\tfor (i = 1; i <= n; i++) {\n\t\tZ[i] = SA[i] - SB[i];\n\t\tres[n - i] = Z[i] - Z[i - 1] + 'a';\n\t}\n\tprintf(\"! %s\\n\", res);\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "interactive",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C1. Madhouse  Easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/72867",
    "editorial": "Let's consider the solution that uses 2\n queries with the lengths n\n and n?1\n (it asks about too many substrings, so it will not pass all the tests, but it will help us further). Let's ask about substrings [1..n]\n and [1..n?1]\n. For convenience, rearrange the letters in all strings in alphabetical order. Then note that all the suffixes of S\n correspond to those strings that we get in the first case, and do not get in the second. Having found all such strings, we can easily find all suffixes of S\n by looking at them from smaller ones to bigger.\n\nFor a complete solution we should first find the first n/2\n characters of the string by the solution described above. Then ask about the whole string. Let cnti,x\n be the number of times that the symbol x\n occurs in total in all substrings of length i\n in the last query. Note that the symbol at position j\n is counted in cnti,x\n exactly min(i,j,n?j+1)\n times. Then for all i\n from 1\n to n/2\n, the value cnti+1,x\n - cnti,x\n is equal to the number of times that x\n occurs on positions with indices from i+1\n to n?i\n. Knowing these quantities, it is possible to find out how many times the element x occurs on positions i\n and n?i+1\n in sum for each i\n from 1\n to n/2\n. Since we already know the first half of the string, it is not difficult to restore the character at the position n?i+1\n, and therefore the entire string.\n\nIn total, we asked about the substrings [1..n/2]\n, [1..n/2?1]\n and [1..n]\n, the total number of substrings received is ?(n+12)22+(n+12)22+(n+1)22=0.75(n+1)2\n, and that quite satisfies the limitations of the problem.",
    "hint": []
}