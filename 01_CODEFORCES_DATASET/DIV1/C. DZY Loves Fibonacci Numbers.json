{
    "link": "https://codeforces.com//contest/446/problem/C",
    "problemId": "11401",
    "problem_idx": "C",
    "shortId": "446C",
    "contest_number": "446",
    "problem_submissions": {
        "D": [
            7086133,
            7088502,
            7303572,
            7094524,
            7087369,
            7108964,
            7108953,
            7108945,
            7108928,
            7108912,
            7089186,
            7086153,
            7256786,
            7256781,
            7111708
        ],
        "B": [
            7082083,
            7079232,
            7078714,
            7083465,
            7077013,
            7081087,
            7303292,
            7079381,
            7081269,
            7080767,
            7080268,
            7085675,
            7089437,
            7079048,
            7081011,
            7082061,
            7081382,
            7083005,
            7082149
        ],
        "C": [
            7079856,
            7085393,
            7084759,
            7079794,
            7695226,
            7082368,
            7303421,
            7094356,
            7085833,
            7086068,
            7088271,
            7087032,
            7088166,
            7086187,
            7087998,
            7087654,
            7091193,
            7088707
        ],
        "A": [
            7075913,
            7076352,
            7074747,
            7080779,
            7084765,
            7075635,
            7303252,
            7075476,
            7075873,
            7075184,
            7076974,
            7078214,
            7075141,
            7075542,
            7077127,
            7075653,
            7075563,
            7076924,
            7075972
        ],
        "E": [
            7093796,
            7093681
        ]
    },
    "name": "C. DZY Loves Fibonacci Numbers",
    "statement": "In mathematical terms, the sequence of Fibonacci numbers is defined by\r\nthe recurrence relation DZY loves Fibonacci numbers very much. Today DZY\r\ngives you an array consisting of integers: . Moreover, there are\r\nqueries, each query has one of the two types: Format of the query \"\". In\r\nreply to the query, you need to add to each element , where . Format of\r\nthe query \"\". In reply to the query you should output the value of\r\nmodulo . Help DZY reply to all the queries.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n#include <deque>\n#include <cassert>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(abs(x))\n#define y0 y3487465\n#define y1 y8687969\n#define fill(x,y) memset(x,y,sizeof(x))\n#define prev PREV\n#define j0 j1347829\n#define j1 j234892\n                         \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double D;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) { re x > 0 ? x : -x; }\n\nconst int mod = 1000*1000*1000+9;\nconst int N = 300000;\nconst int M = 1 << 19;\n\nint n;\nint m;\nii f[N + 1];\nii s[N + 1];\nint tree[2 * M + 10];\nii add[2 * M + 10];\nint x[N + 1];\n\nii mrg (ii a, ii b) {\n    re mp ((a.fi + b.fi) % mod, (a.se + b.se) % mod);\n}\n\nint build (int x, int l, int r) {\n    if (l == r) re tree[x] = ::x[l];\n    int s = (l + r) / 2;\n    re tree[x] = (build (x * 2 + 1, l, s) + build (x * 2 + 2, s + 1, r)) % mod;\n}\n\nii shift (ii x, int len) {\n    int a = ((ll)f[len + 1].fi * x.fi + (ll)f[len + 1].se * x.se) % mod;\n    int b = ((ll)f[len + 2].fi * x.fi + (ll)f[len + 2].se * x.se) % mod;\n    re mp (a, b);\n}\n\nint getsum (ii x, int len) {\n    re ((ll)s[len].fi * x.fi + (ll)s[len].se * x.se) % mod;\n}\n\nint push (int x, int l, int r) {\n    if (add[x].fi == 0 && add[x].se == 0) re 0;\n    if (l != r) {\n        int s = (l + r) / 2;\n        add[x * 2 + 1] = mrg (add[x * 2 + 1], add[x]);\n        add[x * 2 + 2] = mrg (add[x * 2 + 2], shift (add[x], s - l + 1));\n    }\n    tree[x] = (tree[x] + getsum (add[x], r - l + 1)) % mod;\n    add[x] = mp (0, 0);\n    re 0;\n}     \n\nint get (int x, int l, int r, int lc, int rc) {\n    push (x, l, r);\n    if (r < lc || l > rc) re 0;\n    if (l >= lc && r <= rc) re tree[x];\n    int s = (l + r) / 2;\n    re (get (x * 2 + 1, l, s, lc, rc) + get (x * 2 + 2, s + 1, r, lc, rc)) % mod;\n}       \n\nint upd (int x, int l, int r, int lc, int rc, ii y) {\n    push (x, l, r);\n    if (r < lc || l > rc) re tree[x];\n    if (l >= lc && r <= rc) {\n        y = shift (y, l - lc);\n        add[x] = mrg (add[x], y);\n        push (x, l, r);\n        re tree[x];\n    }\n    int s = (l + r) / 2;\n    re tree[x] = (upd (x * 2 + 1, l, s, lc, rc, y) + upd (x * 2 + 2, s + 1, r, lc, rc, y)) % mod;\n}\n                              \nint main () {\n    ii a (1, 0), b (0, 1), cur (1, 1);\n    f[1] = a;\n    f[2] = b;\n    s[1] = a;\n    s[2] = cur;\n    for (int i = 3; i <= N; i++) {\n        ii c = mrg (a, b);\n        f[i] = c;\n        cur = mrg (cur, c);\n        s[i] = cur;\n        a = b;\n        b = c;\n    }\n    scanf (\"%d%d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf (\"%d\", &x[i]);\n    build (0, 0, n - 1);\n    for (int i = 0; i < m; i++) {\n        int t, a, b;\n        scanf (\"%d%d%d\", &t, &a, &b); a--; b--;\n        if (t == 1) {\n            upd (0, 0, n - 1, a, b, mp (1, 1));\n        } else {\n            printf (\"%d\\n\", get (0, 0, n - 1, a, b));\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. DZY Loves Fibonacci Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/13036",
    "editorial": "As we know, Fortunately, we find that So, With multiplicative inverse,\r\nwe find, Now, As you see, we can just maintain the sum of a Geometric\r\nprogression This is a simple problem which can be solved with segment\r\ntree in .\r\n"
}