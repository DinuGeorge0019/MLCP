{
    "link": "https://codeforces.com//contest/1687/problem/A",
    "problemId": "1419365",
    "problem_idx": "A",
    "shortId": "1687A",
    "contest_number": "1687",
    "problem_submissions": {
        "E": [
            159400142,
            159409445,
            159415903
        ],
        "D": [
            159385709,
            159382982,
            159386487,
            159387507,
            159397573,
            159399320,
            159391569,
            159397786,
            159396436,
            159395456,
            159398210,
            159399180,
            159407593,
            159403303,
            159404538,
            159409257,
            180746841,
            159402849,
            159401651,
            159407966,
            160388189,
            159436063,
            159436040,
            159435984,
            159419781,
            159403828
        ],
        "C": [
            159372815,
            159372262,
            159366644,
            159367127,
            159364840,
            159377203,
            159381172,
            159372251,
            159382727,
            159384371,
            159375023,
            159388232,
            159376434,
            159382167,
            159380993,
            159376872,
            159376695,
            159388502,
            159386180,
            159388678
        ],
        "B": [
            159359094,
            159359944,
            159359502,
            159356648,
            159356713,
            159358784,
            159359353,
            159359146,
            159369441,
            159357746,
            159365304,
            159359951,
            159364501,
            159359761,
            159371294,
            159365665,
            159363760,
            159364175,
            159366158,
            159367949
        ],
        "A": [
            159352673,
            159354526,
            159354098,
            159352807,
            159352456,
            159352554,
            159353893,
            159353089,
            159361438,
            159353196,
            159354069,
            159353562,
            159353431,
            159353777,
            159361194,
            159354902,
            159354475,
            159353974,
            159355709,
            159356539
        ]
    },
    "name": "A. The Enchanted Forest",
    "statement": "The enchanted forest got its name from the magical mushrooms growing\r\nhere. They may cause illusions and generally should not be approached.\r\nMarisa comes to pick mushrooms in the Enchanted Forest. The Enchanted\r\nforest can be represented by n points on the X-axis numbered 1 through\r\nn. Before Marisa started, her friend, Patchouli, used magic to detect\r\nthe initial number of mushroom on each point, represented by a_1,a_2,\r\nldots,a_n.Marisa can start out at point in the forest on minute 0. Each\r\nminute, the followings happen in order: She moves from point x to y\r\n(|x-y|\r\nle 1, possibly y=x). She collects all mushrooms on point y. A new\r\nmushroom appears on each point in the forest. Note that she collect\r\nmushrooms on minute 0.Now, Marisa wants to know the maximum number of\r\nmushrooms she can pick after k minutes.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nll a[N];\nint n, k;\n\nvoid solve() {\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tif (k > n) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] += k - n;\n\t\tk = n;\n\t}\n\tll ans = 0;\n\tll sum = 0;\n\tfor (int i = 0; i < k; i++)\n\t\tsum += a[i];\n\tans = max(ans, sum);\n\tfor (int i = k; i < n; i++) {\n\t\tsum += a[i] - a[i - k];\n\t\tans = max(ans, sum);\n\t}\n\tans += (ll)k * (k - 1) / 2;\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. The Enchanted Forest.json",
    "editorial_link": "https://codeforces.com//blog/entry/103493",
    "editorial": "Consider how to maximize the initial mushrooms she\ncollects. Obviously she will not walk into one position more than one\ntimes, and the answer is . Consider how to maximize the additional\nmushrooms she collects. Obviously she will not walk into one position\nmore than one times, and the answer is . We can find that maximizing the\ntwo parts shares the same strategy. So add up the answers of the two\nparts. If : Consider how to maximize the initial mushrooms she collects.\nObviously she can collect all of them. The answer is . Consider how to\nmaximize the additional mushrooms she collects. Let be her position on\nminute (). After she collects the mushrooms on position , a mushroom\nappears on each point, and she can not collect more than of them. In\nother words, she leaves at least mushrooms in the forest. Let , she will\nleave exactly mushrooms in the forest. We can find that maximizing the\ntwo parts shares the same strategy. So add up the answers of the two\nparts. The time complexity is .\n",
    "hint": [
        "Hint1 Consider Unable to parse markup [type=CF_MATHJAX] and Unable to parse markup [type=CF_MATHJAX] separately.",
        "Hint2 Consider maximizing the initial mushrooms and the additional mushrooms separately.",
        "Hint3 Is there any common strategy?"
    ]
}