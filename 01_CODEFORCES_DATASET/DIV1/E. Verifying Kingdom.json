{
    "link": "https://codeforces.com//contest/800/problem/E",
    "problemId": "103099",
    "problem_idx": "E",
    "shortId": "800E",
    "contest_number": "800",
    "problem_submissions": {
        "A": [
            26437824,
            26437413,
            26424399,
            26417348,
            26417549,
            26416882,
            26417345,
            26417672,
            26417220,
            26417679,
            26421663,
            26417804,
            26418603,
            26418392,
            26418074,
            26417524,
            26460923,
            26420581,
            26435242,
            26677047,
            26429059
        ],
        "E": [
            26433415,
            26477309,
            26437062,
            26436411
        ],
        "D": [
            26430216,
            26421580,
            26427879,
            26424854,
            26429250,
            26431239,
            26427030,
            26429935,
            26430978,
            26427918,
            26431811,
            26431775,
            26432322,
            26483339,
            26483333,
            26483260,
            26429237,
            26433768,
            26460903,
            26434200,
            26431466,
            26431322,
            26427768
        ],
        "C": [
            26426299,
            26426474,
            26424315,
            26429087,
            26424916,
            26425781,
            26430517,
            26426280,
            26425889,
            26430194,
            26427437,
            26427899,
            26428225,
            26431339,
            26426820,
            26427120,
            26426356,
            26426998,
            26421900
        ],
        "B": [
            26421783,
            26423033,
            26420771,
            26420198,
            26421833,
            26421342,
            26421711,
            26421555,
            26422110,
            26423813,
            26422982,
            26422079,
            26421473,
            26421858,
            26421532,
            26422706,
            26418487,
            26420698,
            26435223,
            26435196,
            26435077
        ]
    },
    "name": "E. Verifying Kingdom",
    "statement": "The judge has a hidden rooted full binary tree with leaves. A full\r\nbinary tree is one where every node has either or children. The nodes\r\nwith children are called the leaves of the tree. Since this is a full\r\nbinary tree, there are exactly nodes in the tree. The leaves of the\r\njudge’s tree has labels from to . You would like to reconstruct a tree\r\nthat is isomorphic to the judge’s tree. To do this, you can ask some\r\nquestions.A question consists of printing the label of three distinct\r\nleaves . Let the of a node be the shortest distance from the node to the\r\nroot of the tree. Let denote the node with maximum depth that is a\r\ncommon ancestor of the nodes and .Consider . The judge will tell you\r\nwhich one of has the maximum depth. Note, this pair is uniquely\r\ndetermined since the tree is a binary tree; there can’t be any ties.\r\nMore specifically, if (or , respectively) maximizes the depth, the judge\r\nwill respond with the string \"\" (or \"\", \"\" respectively). You may only\r\nask at most questions.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 1000;\n\nint p[2 * N - 1], el[2 * N - 1], er[2 * N - 1];\nint numl[2 * N - 1];\nint cnt[2 * N - 1];\nbool isl[2 * N - 1];\n\nvoid dfs (int v) {\n\tcnt[v] = 1;\n\tif (isl[v]) {\n\t\treturn;\n\t}\n\tdfs(el[v]);\n\tcnt[v] += cnt[el[v]];\n\tdfs(er[v]);\n\tcnt[v] += cnt[er[v]];\n}\n\nvoid solve (int n) {\n\tint rt = -1;\n\tmemset(isl, 0, sizeof isl);\n\tforn (i, 2 * n - 1) {\n\t\tif (p[i] == -1) {\n\t\t\trt = i;\n\t\t}\n\t\tif (el[i] == -1) {\n\t\t\tisl[i] = 1;\n\t\t}\n\t}\n\twhile (!isl[rt]) {\n\t\tdfs(rt);\n\t\tint v = rt;\n\t\twhile (1) {\n\t\t\tif (!isl[el[v]] && 2 * cnt[el[v]] > cnt[rt]) {\n\t\t\t\tv = el[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!isl[er[v]] && 2 * cnt[er[v]] > cnt[rt]) {\n\t\t\t\tv = er[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tint v1 = numl[el[v]];\n\t\tint v2 = numl[er[v]];\n\t\tint v3 = n;\n\t\tprintf(\"%d %d %d\\n\", v1 + 1, v2 + 1, v3 + 1);\n\t\tfflush(stdout);\n\t\tchar res;\n\t\tscanf(\" %c\", &res);\n\t\tif (res == 'X') {\n\t\t\tisl[v] = 1;\n\t\t\tcontinue;\n\t\t} else if (res == 'Y') {\n\t\t\trt = er[v];\n\t\t\tcontinue;\n\t\t} else if (res == 'Z') {\n\t\t\trt = el[v];\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\t\n\tp[2 * n - 1] = p[rt];\n\tif (p[rt] != -1) {\n\t\tint done = 0;\n\t\tif (el[p[rt]] == rt) {\n\t\t\tel[p[rt]] = 2 * n - 1;\n\t\t\tdone++;\n\t\t}\n\t\tif (er[p[rt]] == rt) {\n\t\t\ter[p[rt]] = 2 * n - 1;\n\t\t\tdone++;\n\t\t}\n\t\tassert(done == 1);\n\t}\n\tp[rt] = 2 * n - 1;\n\tel[2 * n - 1] = rt;\n\tp[2 * n] = 2 * n - 1;\n\ter[2 * n - 1] = 2 * n;\n\tnuml[2 * n - 1] = numl[2 * n] = n;\n}\n\nint main () {\n\tint n;\n\tcin >> n;\n\tmemset(p, -1, sizeof p);\n\tmemset(el, -1, sizeof el);\n\tmemset(er, -1, sizeof er);\n\tnuml[0] = 0;\n\tforn (i, 1, n) {\n\t\tsolve(i);\n\t}\n\tputs(\"-1\");\n\tforn (i, 2 * n - 1) {\n\t\tif (i) {\n\t\t\tprintf(\" \");\n\t\t}\n\t\tprintf(\"%d\", p[i] + (p[i] != -1));\n\t}\n\tputs(\"\");\n\tfflush(stdout);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "interactive"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Verifying Kingdom.json",
    "editorial_link": "https://codeforces.com//blog/entry/51598",
    "editorial": "Consider building the tree leaf by leaf.\n\nThe base case of two leaves is trivial.\n\nNow, suppose want to add another leaf wi.\n\nWe can define the \"centroid\" as a tree such that after removing the centroid, all remaining connected components has at most half the number of leaves (note this is different from the standard definition of centroid).\n\nNotice, each internal node can be represented as a pair of leaves (x,y), where x comes from the left child, and y comes from the right child.\n\nAsk the judge (x,y,w_i).\n\nDepending on the response, we can remove the centroid, and know which subtree that w_i lies in (i.e. either the left child, right child, or upper child). So, we can recurse on that tree.\n\nSo, inserting a node takes log_2 i questions and O(i) time, so overall we ask n log n questions and take n^2 time.",
    "hint": []
}