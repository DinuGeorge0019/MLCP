{
    "link": "https://codeforces.com//contest/1817/problem/E",
    "problemId": "1897393",
    "problem_idx": "E",
    "shortId": "1817E",
    "contest_number": "1817",
    "problem_submissions": {
        "F": [
            204497444,
            204371393,
            203993098,
            203987643,
            204188728,
            204003142,
            203943098,
            204213507
        ],
        "D": [
            203955544,
            203961086,
            203937236,
            203945800,
            203945643,
            203942818,
            203943723,
            203947591,
            203989196,
            203948036,
            204052212,
            203947419,
            203952089,
            203947882,
            203954628
        ],
        "A": [
            203949751,
            203917796,
            203915319,
            203915702,
            203915256,
            203915135,
            203915119,
            203915216,
            203933837,
            203916532,
            203915895,
            203917033,
            203915580,
            203915390,
            203917321,
            203916497,
            203915656,
            203929967,
            203917829
        ],
        "E": [
            203947509,
            203943737,
            203948086,
            203949930,
            204001172,
            203962099,
            204158074,
            203951990,
            204009291,
            203987561,
            203984105,
            203980085,
            203953471,
            203990042,
            203976606,
            203976302,
            203953675,
            204066570,
            204065539,
            204106022
        ],
        "B": [
            203928063,
            203919631,
            203920186,
            203920581,
            203923300,
            203919216,
            203918930,
            203922691,
            203924157,
            203921090,
            203921763,
            203924664,
            203924354,
            203989898,
            203930016,
            203924048,
            203922828,
            203936658,
            203924723
        ],
        "C": [
            203916741,
            203929205,
            203922679,
            203923849,
            203928212,
            203926222,
            203931210,
            203933759,
            203932269,
            203931148,
            203930247,
            203931616,
            203931791,
            203922648,
            203924454,
            204016237,
            203932091,
            203930473,
            203925061,
            203933416
        ]
    },
    "name": "E. Half-sum",
    "statement": "You’re given a multiset of non-negative integers\r\n{a_1, a_2,\r\ndots, a_n\r\n}.In one step you take two elements x and y of the multiset, remove them\r\nand insert their mean value\r\nfrac{x + y}{2} back into the multiset.You repeat the step described\r\nabove until you are left with only two numbers A and B. What is the\r\nmaximum possible value of their absolute difference |A-B|?Since the\r\nanswer is not an integer number, output it modulo 10^9+7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& x: a) cin >> x;\n    sort(a.begin(), a.end());\n    vector<pair<int, int>> terms;\n    auto get_sign = [&] () {\n      sort(terms.begin(), terms.end(), greater<>());\n      int eps = 0;\n      int cur = 1e9;\n      long long sum = 0;\n      for (auto& [e, x]: terms) {\n        if (e < cur) {\n          while (sum && cur > e) {\n            if (sum&1) {\n              if (sum > 0) eps = 1;\n              else if (sum < 0) eps = -1;\n            }\n            sum /= 2;\n            cur--;\n          }\n          cur = e;\n        }\n        sum += x;\n        //cout << e << ' ' << x << ' ' << sum << ' ' << eps << endl;\n      }\n      if (sum > 0) return 1;\n      if (sum < 0) return -1;\n      if (eps > 0) return 1;\n      if (eps < 0) return -1;\n      return 0;\n    };\n\n    auto calc = [&] (auto&& self, int l, int r) {\n      if (l == r) return l;\n      int m = (l+r)/2;\n      int x1 = self(self, l, m);\n      int x2 = self(self, m+1, r);\n      terms.clear();\n      terms.emplace_back(x1, -a[x1]);\n      for (int i = x1+1; i <= x2+1; i++) {\n        terms.emplace_back(n-i-(i == x1+1), a[i]);\n      }\n      for (int i = x1; i <= x2; i++) {\n        terms.emplace_back(i+1-(i == x2), a[i]);\n      }\n      terms.emplace_back(n-2-x2, -a[x2+1]);\n      //cout << \"split \" << x1 << ' ' << x2 << endl;\n      //for (auto& [e, x]: terms) cout << e << ' ' << x << endl;\n      if (get_sign() > 0) return x1;\n      return x2;\n    };\n    int c = calc(calc, 0, n-2);\n    //cout << c << endl;\n\n    int ans = 0;\n    int pw = 1;\n    for (int i = 0; i <= c; i++) {\n      if (i != c) pw = 1LL*pw*(MOD+1)/2 % MOD;\n      ans = (ans-1LL*pw*a[i]) % MOD;\n    }\n    pw = 1;\n    for (int i = n-1; i >= c+1; i--) {\n      if (i != c+1) pw = 1LL*pw*(MOD+1)/2 % MOD;\n      ans = (ans+1LL*pw*a[i]) % MOD;\n    }\n    if (ans < 0) ans += MOD;\n    cout << ans << '\\n';\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "divide and conquer",
        "greedy"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Half-sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/115586",
    "editorial": "Similar to the Huffman encoding, the process described in the statement\r\ncan be represented as constructing a tree, in which on every step we\r\ntake two trees with weights and , and connect them with a shared root\r\ninto a single tree with weight .In the end of the process, we have two\r\ntrees with weights and , and we want to maximize . In these trees, let\r\nbe the height of the leaf corresponding to . Then contributes to the\r\nfinal answer with the coefficient either , or , depending on which tree\r\nit is in.If we fix any set and would need to distribute between the\r\nheights, assuming , it would always be better to send smaller numbers to\r\nthe -tree and bigger numbers to the -tree, so that the positive impact\r\nbelongs to bigger numbers and the negative impact belongs to the smaller\r\nnumbers. That being said, if , it is always optimal to choose a number\r\nand send to the -tree, while sending to the -tree. Now we need to\r\nunderstand, how to pick an optimal and how to construct optimal trees\r\nwith a fixed .Assume that will all go to the -tree, for which we want to\r\nminimize the weight. What is the optimal distribution of ? Turns out,\r\nthere always exists an optimal configuration, in which the constructed\r\ntree is very skewed, in a way that each vertex has at most child that is\r\nnot a leaf.Indeed, consider a vertex which has two children and , both\r\nof which have children of its own. Let be a leaf with the smallest\r\nweight in the whole sub-tree of (without loss of generality, assume that\r\nitâs a descendant of ). If we swap with , we will effectively swap\r\ncoefficients with which and contribute to the weight of overall.In other\r\nwords, if the initial contribution was , it will become . Note that and\r\n. As a consequence, the later sum is not worse than the former and itâs\r\nalways optimal to swap and due to the rearrangement inequality.Similar\r\nargument works for the tree , except for we want to maximize sum in it,\r\nrather than minimize it.With this in mind, if the split is and , then\r\nthe heights are for the first block, and similar (but reversed) for the\r\nsecond block. This allows us to find a specific value of for each\r\nspecific in .How to improve from that? We suggest two possible\r\napproaches here.. Assume that the optimal belongs to the interval . In\r\nthis case, all numbers outside the interval will have the same\r\ncoefficients regardless of specific , as long as itself is from the\r\ninterval. This means that we can solve the problem with divide and\r\nconquer approach: Let ; Find best recursively on and ; Compare them on\r\nthe whole , and return the best of them. Which makes overall\r\ncomplexity.. Letâs compare the distribution of coefficients for and : As\r\nyou see, almost all coefficients stay the same, except for coefficients\r\nnear , and : Therefore, let be the optimal answer for , and let , we may\r\nsay thatOr, multiplying it with we getWe can sum it up to get the\r\ndifference between and for arbitrary :where . Then, assuming , we can\r\nbound it asThe later means that when , which is the case when and . By\r\nthe same argument, we may show that when and . In other words, it means\r\nthat one of the following holds for the value , on which the maximum\r\nvalue of is achieved: is the first position in the array, at which , is\r\nthe last position in the array, at which , belongs to the segment .\r\nTherefore, there are at most positions of interest in the array which\r\ncan be checked manually. Moreover, optimal value in the segment can be\r\nfound by checking every possible position while ignoring all the\r\nelements outside of the segment (due to the result from the divide and\r\nconquer approach). This allows, assuming , to resolve the problem in .\r\n",
    "hint": []
}