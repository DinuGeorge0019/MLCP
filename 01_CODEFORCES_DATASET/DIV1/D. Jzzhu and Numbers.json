{"link": "https://codeforces.com//contest/449/problem/D", "problemId": "11568", "problem_idx": "D", "shortId": "449D", "contest_number": "449", "problem_submissions": {"E": [7172419, 7172014, 7174895, 7169365, 7240994, 7177576, 9954696, 9954686], "A": [7167638, 7162064, 7159189, 7170577, 7159566, 7171912, 7174755, 7177754, 7174429, 7180997, 7161684, 7182849, 7192923, 7180517, 7168378, 7168819, 7159358], "C": [7166638, 7168442, 7168589, 7167422, 7169338, 7166871, 7167683, 7167793, 7161177, 7181293, 7173309, 7170890, 7173119, 7170721, 7171917, 7171483, 7167450, 7178771, 7171038], "D": [7161895, 7168837, 7161219, 7163790, 7163207, 7165070, 7164972, 7165472, 7166314, 7182041, 7171873, 7166502, 7159887, 7192953, 7166535, 7169239, 7169537, 7165449, 7159363, 7166505], "B": [7159593, 7164450, 7164390, 7162671, 7166735, 7162159, 7160515, 7161879, 7168809, 7176245, 7164684, 7165872, 7161265, 7163102, 7161569, 7175028, 7162358, 7183380]}, "name": "D. Jzzhu and Numbers", "statement": "Jzzhu have non-negative integers . We will call a sequence of indexes a\r\ngroup of size . Jzzhu wonders, how many groups exists such that & & ...\r\n& ? Help him and print this number modulo . Operation & denotes bitwise\r\nAND operation of two numbers.\r\n", "solutions": ["#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X, Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64;\n\nint N;\nint A[1000000];\nint cnt[1 << 20];\ni64 pows[1100000];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor(int i=0;i<N;i++) {\n\t\tscanf(\"%d\", A+i);\n\t}\n\tpows[0] = 1;\n\tfor(int i=1;i<=N;i++) pows[i] = (pows[i-1] * 2) % MOD;\n\n\tfor(int i=0;i<(1<<20);i++) cnt[i] = 0;\n\tfor(int i=0;i<N;i++) {\n\t\tcnt[1048575 ^ A[i]]++;\n\t}\n\tfor(int i=0;i<20;i++) {\n\t\tfor(int j=0;j<(1<<20);j++) {\n\t\t\tif(0 == (j & (1<<i))) {\n\t\t\t\tcnt[j | (1<<i)] += cnt[j];\n\t\t\t}\n\t\t}\n\t}\n\ti64 ret = 0;\n\tfor(int i=0;i<(1<<20);i++) {\n\t\tint mask = 20 % 2;\n\t\tfor(int j=0;j<20;j++) if(i & (1<<j)) mask ^= 1;\n\n\t\tif(mask == 0) ret = (ret + pows[cnt[i]]) % MOD;\n\t\telse ret = (ret + MOD - pows[cnt[i]]) % MOD;\n\t}\n\tprintf(\"%d\\n\", (int) ret);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "combinatorics", "dp"], "dificulty": "2400", "interactive": false}