{"link": "https://codeforces.com//contest/1149/problem/B", "problemId": "337470", "problem_idx": "B", "shortId": "1149B", "contest_number": "1149", "problem_submissions": {"E": [53524396, 53522321, 53522530, 61434525, 53525980, 53522711, 53522606, 53524594], "D": [53521434, 53526235, 53529930, 53518623, 53524984, 53524746, 53526493, 53518787, 53526308, 53526383, 53526628, 53531041, 53521860, 53522269, 53523326, 53523444], "C": [53514328, 53518841, 53519044, 53525230, 53518371, 53511307, 53515929, 53520465, 53525523, 53518004, 53522574, 53520365, 53530616, 53530825], "B": [53508704, 53508119, 53512032, 53509531, 53508225, 53520230, 53523389, 53511171, 53521543, 53521758, 53512839, 53514480, 53510228, 53510444, 53509691, 53512920, 53514615, 53513077, 53514341], "A": [53502075, 53501727, 53502902, 53502745, 53502146, 53501598, 53502759, 53502876, 53503703, 53505214, 53502973, 53503023, 53501694, 53501955, 53501687, 53504126, 53504632, 53504664, 53501821]}, "name": "B. Three Religions", "statement": "During the archaeological research in the Middle East you found the\r\ntraces of three ancient religions: First religion, Second religion and\r\nThird religion. You compiled the information on the evolution of each of\r\nthese beliefs, and you now wonder if the followers of each religion\r\ncould coexist in peace.The is a long word containing the lowercase\r\nEnglish characters only. At each moment of time, each of the religion\r\nbeliefs could be described by a word consisting of lowercase English\r\ncharacters.The three religions can coexist in peace if their\r\ndescriptions form disjoint subsequences of the . More formally, one can\r\npaint some of the characters of the in three colors: 1, 2, 3, so that\r\neach character is painted in one color, and the description of the i-th\r\nreligion can be constructed from the by removing all characters that\r\naren\u2019t painted in color i.The religions however evolve. In the\r\nbeginning, each religion description is empty. Every once in a while,\r\neither a character is appended to the end of the description of a single\r\nreligion, or the last character is dropped from the description. After\r\neach change, determine if the religions could coexist in peace.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int A = 26;\nconst int N = 100100;\nconst int M = 255;\nchar s[N];\nint n, q;\nint nxt[N][A];\nint dp[M][M][M];\nint p[3][M];\nint sz[3];\n\nint getPos(int pos, int c) {\n\tif (pos >= n || nxt[pos][c] == n) return N;\n\treturn nxt[pos][c] + 1;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &q);\n\tscanf(\"%s\", s);\n\tfor (int c = 0; c < A; c++)\n\t\tnxt[n][c] = N;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int c = 0; c < A; c++)\n\t\t\tnxt[i][c] = nxt[i + 1][c];\n\t\tnxt[i][(int)(s[i] - 'a')] = i;\n\t}\n\tfor (int x = 0; x < M; x++)\n\t\tfor (int y = 0; y < M; y++)\n\t\t\tfor (int z = 0; z < M; z++)\n\t\t\t\tdp[x][y][z] = N;\n\tdp[0][0][0] = 0;\n\twhile(q--) {\n\t\tchar t;\n\t\tint w;\n\t\tscanf(\" %c %d\", &t, &w);\n\t\tw--;\n\t\tif (t == '+') {\n\t\t\tint c;\n\t\t\tscanf(\" %c\", &t);\n\t\t\tc = (int)(t - 'a');\n\t\t\tp[w][sz[w]++] = c;\n\t\t\tif (w == 0) {\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[sz[0]][y][z] = N;\n\t\t\t\t\t}\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[sz[0]][y][z] = min(dp[sz[0]][y][z], getPos(dp[sz[0] - 1][y][z], c));\n\t\t\t\t\t\tif (y < sz[1])\n\t\t\t\t\t\t\tdp[sz[0]][y + 1][z] = min(dp[sz[0]][y + 1][z], getPos(dp[sz[0]][y][z], p[1][y]));\n\t\t\t\t\t\tif (z < sz[2])\n\t\t\t\t\t\t\tdp[sz[0]][y][z + 1] = min(dp[sz[0]][y][z + 1], getPos(dp[sz[0]][y][z], p[2][z]));\n\t\t\t\t\t}\n\t\t\t} else if (w == 1) {\n\t\t\t\tfor (int x = 0; x <= sz[0]; x++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[x][sz[1]][z] = N;\n\t\t\t\t\t}\n\t\t\t\tfor (int x = 0; x <= sz[0]; x++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[x][sz[1]][z] = min(dp[x][sz[1]][z], getPos(dp[x][sz[1] - 1][z], c));\n\t\t\t\t\t\tif (x < sz[0])\n\t\t\t\t\t\t\tdp[x + 1][sz[1]][z] = min(dp[x + 1][sz[1]][z], getPos(dp[x][sz[1]][z], p[0][x]));\n\t\t\t\t\t\tif (z < sz[2])\n\t\t\t\t\t\t\tdp[x][sz[1]][z + 1] = min(dp[x][sz[1]][z + 1], getPos(dp[x][sz[1]][z], p[2][z]));\n\t\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int x = 0; x <= sz[0]; x++) {\n\t\t\t\t\t\tdp[x][y][sz[2]] = N;\n\t\t\t\t\t}\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int x = 0; x <= sz[0]; x++) {\n\t\t\t\t\t\tdp[x][y][sz[2]] = min(dp[x][y][sz[2]], getPos(dp[x][y][sz[2] - 1], c));\n\t\t\t\t\t\tif (y < sz[1])\n\t\t\t\t\t\t\tdp[x][y + 1][sz[2]] = min(dp[x][y + 1][sz[2]], getPos(dp[x][y][sz[2]], p[1][y]));\n\t\t\t\t\t\tif (x < sz[0])\n\t\t\t\t\t\t\tdp[x + 1][y][sz[2]] = min(dp[x + 1][y][sz[2]], getPos(dp[x][y][sz[2]], p[0][x]));\n\t\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tsz[w]--;\n\t\t}\n\t\tif (dp[sz[0]][sz[1]][sz[2]] <= n)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "implementation", "strings"], "dificulty": "2200", "interactive": false}