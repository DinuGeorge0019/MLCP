{
    "link": "https://codeforces.com//contest/1149/problem/B",
    "problemId": "337470",
    "problem_idx": "B",
    "shortId": "1149B",
    "contest_number": "1149",
    "problem_submissions": {
        "E": [
            53524396,
            53522321,
            53522530,
            61434525,
            53525980,
            53522711,
            53522606,
            53524594
        ],
        "D": [
            53521434,
            53526235,
            53529930,
            53518623,
            53524984,
            53524746,
            53526493,
            53518787,
            53526308,
            53526383,
            53526628,
            53531041,
            53521860,
            53522269,
            53523326,
            53523444
        ],
        "C": [
            53514328,
            53518841,
            53519044,
            53525230,
            53518371,
            53511307,
            53515929,
            53520465,
            53525523,
            53518004,
            53522574,
            53520365,
            53530616,
            53530825
        ],
        "B": [
            53508704,
            53508119,
            53512032,
            53509531,
            53508225,
            53520230,
            53523389,
            53511171,
            53521543,
            53521758,
            53512839,
            53514480,
            53510228,
            53510444,
            53509691,
            53512920,
            53514615,
            53513077,
            53514341
        ],
        "A": [
            53502075,
            53501727,
            53502902,
            53502745,
            53502146,
            53501598,
            53502759,
            53502876,
            53503703,
            53505214,
            53502973,
            53503023,
            53501694,
            53501955,
            53501687,
            53504126,
            53504632,
            53504664,
            53501821
        ]
    },
    "name": "B. Three Religions",
    "statement": "During the archaeological research in the Middle East you found the\r\ntraces of three ancient religions: First religion, Second religion and\r\nThird religion. You compiled the information on the evolution of each of\r\nthese beliefs, and you now wonder if the followers of each religion\r\ncould coexist in peace.The is a long word containing the lowercase\r\nEnglish characters only. At each moment of time, each of the religion\r\nbeliefs could be described by a word consisting of lowercase English\r\ncharacters.The three religions can coexist in peace if their\r\ndescriptions form disjoint subsequences of the . More formally, one can\r\npaint some of the characters of the in three colors: 1, 2, 3, so that\r\neach character is painted in one color, and the description of the i-th\r\nreligion can be constructed from the by removing all characters that\r\naren\u2019t painted in color i.The religions however evolve. In the\r\nbeginning, each religion description is empty. Every once in a while,\r\neither a character is appended to the end of the description of a single\r\nreligion, or the last character is dropped from the description. After\r\neach change, determine if the religions could coexist in peace.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int A = 26;\nconst int N = 100100;\nconst int M = 255;\nchar s[N];\nint n, q;\nint nxt[N][A];\nint dp[M][M][M];\nint p[3][M];\nint sz[3];\n\nint getPos(int pos, int c) {\n\tif (pos >= n || nxt[pos][c] == n) return N;\n\treturn nxt[pos][c] + 1;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &q);\n\tscanf(\"%s\", s);\n\tfor (int c = 0; c < A; c++)\n\t\tnxt[n][c] = N;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int c = 0; c < A; c++)\n\t\t\tnxt[i][c] = nxt[i + 1][c];\n\t\tnxt[i][(int)(s[i] - 'a')] = i;\n\t}\n\tfor (int x = 0; x < M; x++)\n\t\tfor (int y = 0; y < M; y++)\n\t\t\tfor (int z = 0; z < M; z++)\n\t\t\t\tdp[x][y][z] = N;\n\tdp[0][0][0] = 0;\n\twhile(q--) {\n\t\tchar t;\n\t\tint w;\n\t\tscanf(\" %c %d\", &t, &w);\n\t\tw--;\n\t\tif (t == '+') {\n\t\t\tint c;\n\t\t\tscanf(\" %c\", &t);\n\t\t\tc = (int)(t - 'a');\n\t\t\tp[w][sz[w]++] = c;\n\t\t\tif (w == 0) {\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[sz[0]][y][z] = N;\n\t\t\t\t\t}\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[sz[0]][y][z] = min(dp[sz[0]][y][z], getPos(dp[sz[0] - 1][y][z], c));\n\t\t\t\t\t\tif (y < sz[1])\n\t\t\t\t\t\t\tdp[sz[0]][y + 1][z] = min(dp[sz[0]][y + 1][z], getPos(dp[sz[0]][y][z], p[1][y]));\n\t\t\t\t\t\tif (z < sz[2])\n\t\t\t\t\t\t\tdp[sz[0]][y][z + 1] = min(dp[sz[0]][y][z + 1], getPos(dp[sz[0]][y][z], p[2][z]));\n\t\t\t\t\t}\n\t\t\t} else if (w == 1) {\n\t\t\t\tfor (int x = 0; x <= sz[0]; x++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[x][sz[1]][z] = N;\n\t\t\t\t\t}\n\t\t\t\tfor (int x = 0; x <= sz[0]; x++)\n\t\t\t\t\tfor (int z = 0; z <= sz[2]; z++) {\n\t\t\t\t\t\tdp[x][sz[1]][z] = min(dp[x][sz[1]][z], getPos(dp[x][sz[1] - 1][z], c));\n\t\t\t\t\t\tif (x < sz[0])\n\t\t\t\t\t\t\tdp[x + 1][sz[1]][z] = min(dp[x + 1][sz[1]][z], getPos(dp[x][sz[1]][z], p[0][x]));\n\t\t\t\t\t\tif (z < sz[2])\n\t\t\t\t\t\t\tdp[x][sz[1]][z + 1] = min(dp[x][sz[1]][z + 1], getPos(dp[x][sz[1]][z], p[2][z]));\n\t\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int x = 0; x <= sz[0]; x++) {\n\t\t\t\t\t\tdp[x][y][sz[2]] = N;\n\t\t\t\t\t}\n\t\t\t\tfor (int y = 0; y <= sz[1]; y++)\n\t\t\t\t\tfor (int x = 0; x <= sz[0]; x++) {\n\t\t\t\t\t\tdp[x][y][sz[2]] = min(dp[x][y][sz[2]], getPos(dp[x][y][sz[2] - 1], c));\n\t\t\t\t\t\tif (y < sz[1])\n\t\t\t\t\t\t\tdp[x][y + 1][sz[2]] = min(dp[x][y + 1][sz[2]], getPos(dp[x][y][sz[2]], p[1][y]));\n\t\t\t\t\t\tif (x < sz[0])\n\t\t\t\t\t\t\tdp[x + 1][y][sz[2]] = min(dp[x + 1][y][sz[2]], getPos(dp[x][y][sz[2]], p[0][x]));\n\t\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tsz[w]--;\n\t\t}\n\t\tif (dp[sz[0]][sz[1]][sz[2]] <= n)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation",
        "strings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Three Religions.json",
    "editorial_link": "https://codeforces.com/blog/entry/66783",
    "editorial": "For our convenience, construct a two-dimensional helper array where is\r\nthe location of the first occurrence of character in the on position or\r\nlater (or if no such character exists). This array can be created in a\r\nstraightforward in time, by iterating the word from the end to the\r\nbeginning. Consider the equal to . The helper array looks as follows:\r\nActually, for our purposes it\u00e2\u0080\u0099s easier to set (in our example, ) and\r\nalso consider additional links from indices and to index . Why? We\u00e2\u0080\u0099ll\r\nlater need the index of the first occurrence of some character some\r\nlocation . If this already happens to be (, as we already established),\r\nwe can easily see that no requested occurrence exists: Let\u00e2\u0080\u0099s now try to\r\nanswer each query in time. We can do it using dynamic programming: let\r\nbe the length of the shortest prefix of the that contains the disjoint\r\noccurrences of the prefix of length of the first religion\u00e2\u0080\u0099s description,\r\nthe prefix of length of the second religion\u00e2\u0080\u0099s description, and the\r\nprefix of length of the third religion\u00e2\u0080\u0099s description. Each state can be\r\nevaluated in constant time by checking for each religion , what the\r\nprefix length would be if the last character of the prefix is a part of\r\nthe -th religion\u00e2\u0080\u0099s description. (We use the helper array to speed up the\r\nsearch.)How to write the state transitions? For each : chop the last\r\ncharacter of the -th description\u00e2\u0080\u0099s prefix, find the shortest prefix of\r\nthe containing all three descriptions, and then reappend this last\r\ncharacter. We can do that using our helper array:Now, if the lengths of\r\nthe descriptions are , , and , respectively, then the embedding of these\r\ndescriptions as distinct subsequences exists if and only if .However,\r\ndue to the nature of queries, we can do a single update in time: if we\r\ndrop a character, we don\u00e2\u0080\u0099t need to recompute any states; if we add a\r\ncharacter to the -th description, we only need to recompute the states\r\nwith equal to the length of the description and there are at most of\r\nthem! This allows us to solve the problem in time.\r\n"
}