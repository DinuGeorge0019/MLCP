{
    "link": "https://codeforces.com//contest/1483/problem/C",
    "problemId": "931272",
    "problem_idx": "C",
    "shortId": "1483C",
    "contest_number": "1483",
    "problem_submissions": {
        "F": [
            110657198,
            110657366,
            110680394,
            110676074,
            110665233,
            113439308,
            113059400,
            111430671,
            111430417
        ],
        "D": [
            110640647,
            110642867,
            110640739,
            110649362,
            110656109,
            110648351,
            110669875,
            110646025,
            110641671,
            110641253,
            110642818,
            110645567,
            110644771,
            110644923,
            110644779,
            110648343,
            110645625,
            110649200,
            110647913
        ],
        "C": [
            110637482,
            110639495,
            110638107,
            110639034,
            110636245,
            110643783,
            110646712,
            110639119,
            110637748,
            110637078,
            110639242,
            110639215,
            110640002,
            110638528,
            110640575,
            110640398,
            110641125,
            110641145,
            110641078,
            110642087
        ],
        "B": [
            110634536,
            110634072,
            110635529,
            110635361,
            110642670,
            110636167,
            110639544,
            110634766,
            110633516,
            110637084,
            110643607,
            110635632,
            110634992,
            110636625,
            110637243,
            110635431,
            110638777,
            110635673,
            110637846
        ],
        "A": [
            110629442,
            110628350,
            110629067,
            110628964,
            110631520,
            110629138,
            110634726,
            110632933,
            110628500,
            110629504,
            110630632,
            110632453,
            110628740,
            110630017,
            110629975,
            110630962,
            110628508,
            110633725,
            110630402,
            110630508
        ],
        "E": [
            110660726,
            110669157,
            204375141,
            110665918,
            110662689,
            110666386,
            110657015,
            113441196,
            113891758,
            110672789,
            111426124,
            110692107
        ]
    },
    "name": "C. Skyline Photo",
    "statement": "Alice is visiting New York City. To make the trip fun, Alice will take\r\nphotos of the city skyline and give the set of photos as a present to\r\nBob. However, she wants to find the set of photos with maximum beauty\r\nand she needs your help. There are n buildings in the city, the i-th of\r\nthem has positive height h_i. All n building heights in the city are\r\ndifferent. In addition, each building has a beauty value b_i. Note that\r\nbeauty can be positive or negative, as there are ugly buildings in the\r\ncity too. A set of photos consists of one or more photos of the\r\nbuildings in the skyline. Each photo includes one or more buildings in\r\nthe skyline that form a contiguous segment of indices. Each building\r\nneeds to be in photo. This means that if a building does not appear in\r\nany photo, or if a building appears in more than one photo, the set of\r\npictures is not valid. The beauty of a photo is equivalent to the beauty\r\nb_i of the shortest building in it. The total beauty of a set of photos\r\nis the sum of the beauty of all photos in it. Help Alice to find the\r\nmaximum beauty a valid set of photos can have.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\ntemplate <typename T, class Compare = std::less<T>> class RangeMinQuery : private Compare {\n\tstatic const int BUCKET_SIZE = 32;\n\tstatic const int BUCKET_SIZE_LOG = 5;\n\tstatic_assert(BUCKET_SIZE == (1 << BUCKET_SIZE_LOG), \"BUCKET_SIZE should be a power of 2\");\n\tstatic const int CACHE_LINE_ALIGNMENT = 64;\n\tint n = 0;\n\tstd::vector<T> data;\n\tstd::vector<T> pref_data;\n\tstd::vector<T> suff_data;\n\tstd::vector<T> sparse_table;\n\tstd::vector<uint32_t> range_mask;\n\nprivate:\n\tint num_buckets() const {\n\t\treturn n >> BUCKET_SIZE_LOG;\n\t}\n\tint num_levels() const {\n\t\treturn num_buckets() ? 32 - __builtin_clz(num_buckets()) : 0;\n\t}\n\tint sparse_table_size() const {\n\t\treturn num_buckets() * num_levels();\n\t}\nprivate:\n\tconst T& min(const T& a, const T& b) const {\n\t\treturn Compare::operator()(a, b) ? a : b;\n\t}\n\tvoid setmin(T& a, const T& b) const {\n\t\tif (Compare::operator()(b, a)) a = b;\n\t}\n\n\ttemplate <typename Vec> static int get_size(const Vec& v) { using std::size; return int(size(v)); }\n\npublic:\n\tRangeMinQuery() {}\n\ttemplate <typename Vec> explicit RangeMinQuery(const Vec& data_, const Compare& comp_ = Compare())\n\t\t: Compare(comp_)\n\t\t, n(get_size(data_))\n\t\t, data(n)\n\t\t, pref_data(n)\n\t\t, suff_data(n)\n\t\t, sparse_table(sparse_table_size())\n\t\t, range_mask(n)\n\t{\n\t\tfor (int i = 0; i < n; i++) data[i] = data_[i];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i & (BUCKET_SIZE-1)) {\n\t\t\t\tuint32_t m = range_mask[i-1];\n\t\t\t\twhile (m && !Compare::operator()(data[(i | (BUCKET_SIZE-1)) - __builtin_clz(m)], data[i])) {\n\t\t\t\t\tm -= uint32_t(1) << (BUCKET_SIZE - 1 - __builtin_clz(m));\n\t\t\t\t}\n\t\t\t\tm |= uint32_t(1) << (i & (BUCKET_SIZE - 1));\n\t\t\t\trange_mask[i] = m;\n\t\t\t} else {\n\t\t\t\trange_mask[i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpref_data[i] = data[i];\n\t\t\tif (i & (BUCKET_SIZE-1)) {\n\t\t\t\tsetmin(pref_data[i], pref_data[i-1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tsuff_data[i] = data[i];\n\t\t\tif (i+1 < n && ((i+1) & (BUCKET_SIZE-1))) {\n\t\t\t\tsetmin(suff_data[i], suff_data[i+1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < num_buckets(); i++) {\n\t\t\tsparse_table[i] = data[i * BUCKET_SIZE];\n\t\t\tfor (int v = 1; v < BUCKET_SIZE; v++) {\n\t\t\t\tsetmin(sparse_table[i], data[i * BUCKET_SIZE + v]);\n\t\t\t}\n\t\t}\n\t\tfor (int l = 0; l+1 < num_levels(); l++) {\n\t\t\tfor (int i = 0; i + (1 << (l+1)) <= num_buckets(); i++) {\n\t\t\t\tsparse_table[(l+1) * num_buckets() + i] = min(sparse_table[l * num_buckets() + i], sparse_table[l * num_buckets() + i + (1 << l)]);\n\t\t\t}\n\t\t}\n\t}\n\n\tT query(int l, int r) const {\n\t\tassert(l <= r);\n\t\tint bucket_l = (l >> BUCKET_SIZE_LOG);\n\t\tint bucket_r = (r >> BUCKET_SIZE_LOG);\n\t\tif (bucket_l == bucket_r) {\n\t\t\tuint32_t msk = range_mask[r] & ~((uint32_t(1) << (l & (BUCKET_SIZE-1))) - 1);\n\t\t\tint ind = (l & ~(BUCKET_SIZE-1)) + __builtin_ctz(msk);\n\t\t\treturn data[ind];\n\t\t} else {\n\t\t\tT ans = min(suff_data[l], pref_data[r]);\n\t\t\tbucket_l++;\n\t\t\tif (bucket_l < bucket_r) {\n\t\t\t\tint level = (32 - __builtin_clz(bucket_r - bucket_l)) - 1;\n\t\t\t\tsetmin(ans, sparse_table[level * num_buckets() + bucket_l]);\n\t\t\t\tsetmin(ans, sparse_table[level * num_buckets() + bucket_r - (1 << level)]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N; cin >> N;\n\tvector<int> H(N); for (auto& h : H) { cin >> h; h--; }\n\tvector<int64_t> B(N); for (auto& b : B) cin >> b;\n\n\tvector<pair<int, int>> heights(N); for (int i = 0; i < N; i++) heights[i] = {H[i], i};\n\tRangeMinQuery<pair<int, int>> rmq(heights);\n\n\tint64_t ans = std::y_combinator([&](auto self, int l, int r) -> int64_t {\n\t\tif (l > r) return 0;\n\t\tint m = rmq.query(l, r).second;\n\t\tint64_t lval = self(l, m-1);\n\t\tint64_t rval = self(m+1, r);\n\t\tint64_t res = B[m] + lval + rval;\n\t\tif (l != 0) {\n\t\t\t// we can cover from the left\n\t\t\tres = max(res, rval);\n\t\t}\n\t\tif (r != N-1) {\n\t\t\tres = max(res, lval);\n\t\t}\n\t\treturn res;\n\t})(0, N-1);\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Skyline Photo.json",
    "editorial_link": "https://codeforces.com//blog/entry/88963",
    "editorial": "We can solve this problem with DP. A trivial O(n2)\n algorithm would look like this: Define dpi\n as the maximum beauty that can be achieved if we have a set of photos of buildings from 1\n to i\n. We can check every possible splitting point j?i\n for the rightmost picture of the set, and keep the biggest answer. dpi=maxj?i(dpj?1+bj..i)\n.\n\nNow we just need to optimize this solution. Assume we are calculating dpi\n First important thing we need to realize is that, if we find the position of the closest smaller number to the left of i\n, on position j\n, and we choose to add it in the rightmost photo with building i\n, then the best solution would be on dpj\n, because all numbers after j\n are bigger than hj\n, so they would not change the beauty of the picture (this is assuming that i\n and j\n are on the same photo). Note that we had already calculated the max beauty of dpj\n, so it is not necessary to go back any further, as we have the best answer stored at dpj\n\nHaving this observation, we are just left to check numbers between j\n and i\n as possible splitting points for the rightmost picture (the case where building j\n and building i\n are in different pictures). But we now know that every height from j+1\n to i?1\n is bigger than hi\n ( this is because j\n is the closets smaller height), so the answer will just be dpk?1\n + bi\n for any k\n between j+1\n and i\n. We want to maximize the answer, so we just want to look for the max dpk\n value in this range. To do this, we can keep a max segment tree with dp values, and query it in O(lgn)\n time. After we calculate dpi\n, we insert it to the segment tree. This gives un an O(n?lgn)\n solution, enough to solve the problem.\n\nFor the final implementation, we can iterate from 1 to n\n, keeping a stack with height values, to calculate the closest smaller building for each building. We just pop the stack while the current building is smaller than the top value of the stack, and insert the current building on top of the stack. Actually, by using this trick right, a segment tree is not really necessary. We can calculate the minimum answer for the ranges by updating information as we delete or add numbers in the stack. So it is possible to achieve a linear time solution. However, O(n?lgn)\n is enough to solve the problem, so this optimization is not necessary.",
    "hint": []
}