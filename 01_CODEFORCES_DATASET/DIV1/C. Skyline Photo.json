{"link": "https://codeforces.com//contest/1483/problem/C", "problemId": "931272", "problem_idx": "C", "shortId": "1483C", "contest_number": "1483", "problem_submissions": {"F": [110657198, 110657366, 110680394, 110676074, 110665233, 113439308, 113059400, 111430671, 111430417], "D": [110640647, 110642867, 110640739, 110649362, 110656109, 110648351, 110669875, 110646025, 110641671, 110641253, 110642818, 110645567, 110644771, 110644923, 110644779, 110648343, 110645625, 110649200, 110647913], "C": [110637482, 110639495, 110638107, 110639034, 110636245, 110643783, 110646712, 110639119, 110637748, 110637078, 110639242, 110639215, 110640002, 110638528, 110640575, 110640398, 110641125, 110641145, 110641078, 110642087], "B": [110634536, 110634072, 110635529, 110635361, 110642670, 110636167, 110639544, 110634766, 110633516, 110637084, 110643607, 110635632, 110634992, 110636625, 110637243, 110635431, 110638777, 110635673, 110637846], "A": [110629442, 110628350, 110629067, 110628964, 110631520, 110629138, 110634726, 110632933, 110628500, 110629504, 110630632, 110632453, 110628740, 110630017, 110629975, 110630962, 110628508, 110633725, 110630402, 110630508], "E": [110660726, 110669157, 204375141, 110665918, 110662689, 110666386, 110657015, 113441196, 113891758, 110672789, 111426124, 110692107]}, "name": "C. Skyline Photo", "statement": "Alice is visiting New York City. To make the trip fun, Alice will take\r\nphotos of the city skyline and give the set of photos as a present to\r\nBob. However, she wants to find the set of photos with maximum beauty\r\nand she needs your help. There are n buildings in the city, the i-th of\r\nthem has positive height h_i. All n building heights in the city are\r\ndifferent. In addition, each building has a beauty value b_i. Note that\r\nbeauty can be positive or negative, as there are ugly buildings in the\r\ncity too. A set of photos consists of one or more photos of the\r\nbuildings in the skyline. Each photo includes one or more buildings in\r\nthe skyline that form a contiguous segment of indices. Each building\r\nneeds to be in photo. This means that if a building does not appear in\r\nany photo, or if a building appears in more than one photo, the set of\r\npictures is not valid. The beauty of a photo is equivalent to the beauty\r\nb_i of the shortest building in it. The total beauty of a set of photos\r\nis the sum of the beauty of all photos in it. Help Alice to find the\r\nmaximum beauty a valid set of photos can have.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\ntemplate <typename T, class Compare = std::less<T>> class RangeMinQuery : private Compare {\n\tstatic const int BUCKET_SIZE = 32;\n\tstatic const int BUCKET_SIZE_LOG = 5;\n\tstatic_assert(BUCKET_SIZE == (1 << BUCKET_SIZE_LOG), \"BUCKET_SIZE should be a power of 2\");\n\tstatic const int CACHE_LINE_ALIGNMENT = 64;\n\tint n = 0;\n\tstd::vector<T> data;\n\tstd::vector<T> pref_data;\n\tstd::vector<T> suff_data;\n\tstd::vector<T> sparse_table;\n\tstd::vector<uint32_t> range_mask;\n\nprivate:\n\tint num_buckets() const {\n\t\treturn n >> BUCKET_SIZE_LOG;\n\t}\n\tint num_levels() const {\n\t\treturn num_buckets() ? 32 - __builtin_clz(num_buckets()) : 0;\n\t}\n\tint sparse_table_size() const {\n\t\treturn num_buckets() * num_levels();\n\t}\nprivate:\n\tconst T& min(const T& a, const T& b) const {\n\t\treturn Compare::operator()(a, b) ? a : b;\n\t}\n\tvoid setmin(T& a, const T& b) const {\n\t\tif (Compare::operator()(b, a)) a = b;\n\t}\n\n\ttemplate <typename Vec> static int get_size(const Vec& v) { using std::size; return int(size(v)); }\n\npublic:\n\tRangeMinQuery() {}\n\ttemplate <typename Vec> explicit RangeMinQuery(const Vec& data_, const Compare& comp_ = Compare())\n\t\t: Compare(comp_)\n\t\t, n(get_size(data_))\n\t\t, data(n)\n\t\t, pref_data(n)\n\t\t, suff_data(n)\n\t\t, sparse_table(sparse_table_size())\n\t\t, range_mask(n)\n\t{\n\t\tfor (int i = 0; i < n; i++) data[i] = data_[i];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i & (BUCKET_SIZE-1)) {\n\t\t\t\tuint32_t m = range_mask[i-1];\n\t\t\t\twhile (m && !Compare::operator()(data[(i | (BUCKET_SIZE-1)) - __builtin_clz(m)], data[i])) {\n\t\t\t\t\tm -= uint32_t(1) << (BUCKET_SIZE - 1 - __builtin_clz(m));\n\t\t\t\t}\n\t\t\t\tm |= uint32_t(1) << (i & (BUCKET_SIZE - 1));\n\t\t\t\trange_mask[i] = m;\n\t\t\t} else {\n\t\t\t\trange_mask[i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpref_data[i] = data[i];\n\t\t\tif (i & (BUCKET_SIZE-1)) {\n\t\t\t\tsetmin(pref_data[i], pref_data[i-1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tsuff_data[i] = data[i];\n\t\t\tif (i+1 < n && ((i+1) & (BUCKET_SIZE-1))) {\n\t\t\t\tsetmin(suff_data[i], suff_data[i+1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < num_buckets(); i++) {\n\t\t\tsparse_table[i] = data[i * BUCKET_SIZE];\n\t\t\tfor (int v = 1; v < BUCKET_SIZE; v++) {\n\t\t\t\tsetmin(sparse_table[i], data[i * BUCKET_SIZE + v]);\n\t\t\t}\n\t\t}\n\t\tfor (int l = 0; l+1 < num_levels(); l++) {\n\t\t\tfor (int i = 0; i + (1 << (l+1)) <= num_buckets(); i++) {\n\t\t\t\tsparse_table[(l+1) * num_buckets() + i] = min(sparse_table[l * num_buckets() + i], sparse_table[l * num_buckets() + i + (1 << l)]);\n\t\t\t}\n\t\t}\n\t}\n\n\tT query(int l, int r) const {\n\t\tassert(l <= r);\n\t\tint bucket_l = (l >> BUCKET_SIZE_LOG);\n\t\tint bucket_r = (r >> BUCKET_SIZE_LOG);\n\t\tif (bucket_l == bucket_r) {\n\t\t\tuint32_t msk = range_mask[r] & ~((uint32_t(1) << (l & (BUCKET_SIZE-1))) - 1);\n\t\t\tint ind = (l & ~(BUCKET_SIZE-1)) + __builtin_ctz(msk);\n\t\t\treturn data[ind];\n\t\t} else {\n\t\t\tT ans = min(suff_data[l], pref_data[r]);\n\t\t\tbucket_l++;\n\t\t\tif (bucket_l < bucket_r) {\n\t\t\t\tint level = (32 - __builtin_clz(bucket_r - bucket_l)) - 1;\n\t\t\t\tsetmin(ans, sparse_table[level * num_buckets() + bucket_l]);\n\t\t\t\tsetmin(ans, sparse_table[level * num_buckets() + bucket_r - (1 << level)]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N; cin >> N;\n\tvector<int> H(N); for (auto& h : H) { cin >> h; h--; }\n\tvector<int64_t> B(N); for (auto& b : B) cin >> b;\n\n\tvector<pair<int, int>> heights(N); for (int i = 0; i < N; i++) heights[i] = {H[i], i};\n\tRangeMinQuery<pair<int, int>> rmq(heights);\n\n\tint64_t ans = std::y_combinator([&](auto self, int l, int r) -> int64_t {\n\t\tif (l > r) return 0;\n\t\tint m = rmq.query(l, r).second;\n\t\tint64_t lval = self(l, m-1);\n\t\tint64_t rval = self(m+1, r);\n\t\tint64_t res = B[m] + lval + rval;\n\t\tif (l != 0) {\n\t\t\t// we can cover from the left\n\t\t\tres = max(res, rval);\n\t\t}\n\t\tif (r != N-1) {\n\t\t\tres = max(res, lval);\n\t\t}\n\t\treturn res;\n\t})(0, N-1);\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "dp", "greedy"], "dificulty": "2100", "interactive": false}