{
    "link": "https://codeforces.com//contest/1268/problem/E",
    "problemId": "499896",
    "problem_idx": "E",
    "shortId": "1268E",
    "contest_number": "1268",
    "problem_submissions": {
        "E": [
            67361424,
            67355016,
            67380799,
            67371033,
            67446934,
            67376813,
            68023098,
            68022997
        ],
        "D": [
            67348266,
            67347319,
            67365084,
            67357673,
            67360949,
            67364747,
            67359296,
            67368756,
            67411806,
            68016271
        ],
        "C": [
            67338375,
            67339405,
            67344042,
            67338561,
            67344169,
            67346111,
            67349295,
            67348401,
            67341037,
            67348166,
            67347179,
            67340159,
            67353050,
            67348258,
            67346505,
            67347427,
            67342845,
            67349401,
            67353151,
            67341052
        ],
        "B": [
            67331667,
            67334127,
            67337536,
            67334592,
            67334504,
            67337007,
            67342216,
            67338670,
            67336021,
            67336364,
            67336274,
            67334552,
            67335765,
            67336571,
            67336933,
            67336456,
            67331340,
            67342411,
            67336844,
            67347736
        ],
        "A": [
            67329853,
            67333177,
            67334199,
            67331820,
            67331197,
            67332489,
            67334260,
            67332404,
            67331188,
            67334825,
            67333497,
            67332015,
            67333739,
            67334436,
            67335762,
            67333434,
            67335595,
            67333162,
            67332954,
            67335847
        ]
    },
    "name": "E. Happy Cactus",
    "statement": "You are given a cactus graph, in this graph each edge lies on at most\r\none simple cycle.It is given as m edges a_i, b_i, weight of i-th edge is\r\ni.Let’s call a path in cactus if the weights of edges on this path are\r\nincreasing.Let’s call a pair of vertices (u,v) if there exists an\r\nincreasing path that starts in u and ends in v.For each vertex u find\r\nthe number of other vertices v, such that pair (u,v) is happy.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 21.12.2019 15:33:45       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass undigraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  undigraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nvector<vector<int>> find_cycles(const graph<T> &g, int bound_cnt = 1 << 30, int bound_size = 1 << 30) {\n  vector<int> was(g.n, -1);\n  vector<int> st;\n  vector<vector<int>> cycles;\n  int total_size = 0;\n  function<void(int, int)> dfs = [&](int v, int pe) {\n    if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\n      return;\n    }\n    was[v] = (int) st.size();\n    for (int id : g.g[v]) {\n      if (id == pe) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int to = e.from ^ e.to ^ v;\n      if (was[to] >= 0) {\n        vector<int> cycle(1, id);\n        for (int j = was[to]; j < (int) st.size(); j++) {\n          cycle.push_back(st[j]);\n        }\n        cycles.push_back(cycle);\n        total_size += (int) cycle.size();\n        if ((int) cycles.size() >= bound_cnt || total_size >= bound_size) {\n          return;\n        }\n        continue;\n      }\n      if (was[to] == -1) {\n        st.push_back(id);\n        dfs(to, id);\n        st.pop_back();\n      }\n    }\n    was[v] = -2;\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (was[i] == -1) {\n      dfs(i, -1);\n    }\n  }\n  return cycles;\n  // cycles are given by edge ids, all cycles are simple\n  // breaks after getting bound_cnt cycles or total_size >= bound_size\n  // digraph: finds at least one cycle in every connected component (if not broken)\n  // undigraph: finds cycle basis\n}\n\ntemplate <typename T>\nvector<int> edges_to_vertices(const graph<T> &g, const vector<int> &edge_cycle) {\n  int sz = (int) edge_cycle.size();\n  vector<int> vertex_cycle;\n  if (sz <= 2) {\n    vertex_cycle.push_back(g.edges[edge_cycle[0]].from);\n    if (sz == 2) {\n      vertex_cycle.push_back(g.edges[edge_cycle[0]].to);\n    }\n  } else {\n    for (int i = 0; i < sz; i++) {\n      int j = (i + 1) % sz;\n      auto &e = g.edges[edge_cycle[i]];\n      auto &other = g.edges[edge_cycle[j]];\n      if (other.from == e.from || other.to == e.from) {\n        vertex_cycle.push_back(e.to);\n      } else {\n        vertex_cycle.push_back(e.from);\n      }\n    }\n  }\n  return vertex_cycle;\n  // only for simple cycles!\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  undigraph<int> g(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g.add(x, y);\n  }\n  vector<vector<int>> cycles = find_cycles(g);\n  vector<vector<int>> events(m);\n  for (auto& cycle : cycles) {\n    int sz = (int) cycle.size();\n    int pos = (int) (min_element(cycle.begin(), cycle.end()) - cycle.begin());\n    rotate(cycle.begin(), cycle.begin() + pos, cycle.end());\n    pos = (int) (max_element(cycle.begin(), cycle.end()) - cycle.begin());\n    bool ok = true;\n    for (int i = 0; i < pos - 1; i++) {\n      if (cycle[i] > cycle[i + 1]) {\n        ok = false;\n        break;\n      }\n    }\n    for (int i = pos; i < sz - 1; i++) {\n      if (cycle[i] < cycle[i + 1]) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) {\n      events[cycle[pos]].push_back(cycle[0]);\n    }\n  }\n  vector<int> sub(m, 0);\n  vector<int> ans(n, 1);\n  for (int i = m - 1; i >= 0; i--) {\n    auto& e = g.edges[i];\n    int x = e.from;\n    int y = e.to;\n    int cur = ans[x] + ans[y] - sub[i];\n    ans[x] = ans[y] = cur;\n    for (int j : events[i]) {\n      sub[j] += cur;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << ans[i] - 1;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Happy Cactus.json",
    "editorial_link": "https://codeforces.com//blog/entry/72358",
    "editorial": "At first, letâs solve for the tree. Let be the number of answer for\r\nvertex .Letâs look at edges in the order of decreasing weight.How is\r\nchanging when you are looking at edge ?I claim that for and .And .Why? I\r\nlike this thinking about this problem: in each vertex sitting a rat,\r\ninitially -th rat is infected by -th type of infection. After that, rats\r\nand , and , ..., and bite each other. When two rats bite each other,\r\nthey have a union of their infections.I claim that the number of\r\ninfections of -th vertex, in the end, is equal to the required value.So\r\non the tree, it is easy to see that the infections are not intersecting\r\nwhen two rats bite each other, so they just change the number to sum.But\r\non the cactus, they may have some non-empty intersection.Now, it is easy\r\nto see that: Letâs say that is equal to the number of infections of\r\n(same as the number of infections of ) after the moment when you meet\r\nthis edge. Similar to the tree case, when -th edge connects different\r\nconnected components, is just equal to the sum of the number of\r\ninfections. When -th edge connects connected components, is equal to the\r\nsum of the number of infections (letâs call this value ). Or is equal to\r\nwhere is some edge on the path between and (note that it is a cactus, so\r\nthis path is unique). This is always the largest edge on the path, and\r\nit is subtracted if and only if the path from it to and from it to is\r\ndecreasing.So, we can solve the problem in .\r\n",
    "hint": []
}