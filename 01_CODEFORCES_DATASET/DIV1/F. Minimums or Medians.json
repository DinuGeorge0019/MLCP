{"link": "https://codeforces.com//contest/1785/problem/F", "problemId": "1767289", "problem_idx": "F", "shortId": "1785F", "contest_number": "1785", "problem_submissions": {"F": [192340988, 192367706, 192347284, 192344077, 192349198, 192347771, 192385993, 192336126, 192406311, 192343375, 192348787, 192366544, 192344262, 192411258, 192345259, 192363821, 192484658], "E": [192334775, 192378839, 192330680, 192327219, 192332119, 192339722, 192385982, 192341740, 192412077, 192337184, 192336634, 192325309, 192324682, 192330314, 192339341, 192328941, 192342934, 192342640, 192343285, 192338492, 192348718], "D": [192309677, 192304720, 192308363, 192312353, 192300737, 192385972, 192323435, 192411822, 192411698, 192411631, 192411452, 192307092, 192297940, 192289422, 192305735, 192292206, 192306351, 192303021, 192324811, 192312541, 192301962, 192316529, 192316093, 192321567, 192314574], "C": [192301226, 192367208, 192300659, 192294893, 192304774, 192305847, 192385966, 192316174, 192318962, 192301773, 192292324, 192299527, 193510779, 192315363, 192293483, 192308504, 192291605, 192310063, 192307486, 192299043, 192314808, 192308858], "B": [192291042, 192291589, 192316742, 192291514, 192291590, 192385951, 192288659, 192292597, 192289761, 192297426, 192300042, 192305089, 192297247, 192288814, 192295447, 192337551, 192290254, 192297732, 192303838, 192303907, 192291091], "A": [192284331, 192283441, 192283155, 192282660, 192283131, 192385935, 192282844, 192284622, 192283277, 192290652, 192292611, 192296096, 192286915, 192282931, 192283418, 192285228, 192283044, 192283110, 192282987, 192288048, 192282867]}, "name": "F. Minimums or Medians", "statement": "Vika has a set of all consecutive positive integers from 1 to 2n,\r\ninclusive.Exactly k times Vika will choose and perform one of the\r\nfollowing two actions: take two smallest integers from her current set\r\nand remove them; take two median integers from her current set and\r\nremove them. Recall that medians are the integers located exactly in the\r\nmiddle of the set if you write down its elements in increasing order.\r\nNote that Vika\u2019s set always has an even size, thus the pair of median\r\nintegers is uniquely defined. For example, two median integers of the\r\nset\r\n{1, 5, 6, 10, 15, 16, 18, 23\r\n} are 10 and 15.How many different sets can Vika obtain in the end,\r\nafter k actions? Print this number modulo 998\r\n,244\r\n,353. Two sets are considered different if some integer belongs to one\r\nof them but not to the other.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 3100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint K, N;\n\tcin >> N >> K;\n\tint slots = (N-K);\n\tnum ans = 0;\n\tans += 1;\n\tif(1 <= slots){\n\t\tans += K;\n\t}\n\tfor(int m = 2; m <= slots; m++){\n\t\tint sum = K - m;\n\t\tint lim = sum / 2;\n\t\tnum v1 = ncr(m-1 + lim, m-1);\n\t\tnum v2 = (m-1) * ncr(m + lim, m);\n\t\tans += -2 * v2 + (sum + 1 + 2 * m - 2) * v1;\n\t}\n\tcout << ans << '\\n';\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "two pointers"], "dificulty": "3400", "interactive": false}