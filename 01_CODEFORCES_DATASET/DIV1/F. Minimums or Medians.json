{
    "link": "https://codeforces.com//contest/1785/problem/F",
    "problemId": "1767289",
    "problem_idx": "F",
    "shortId": "1785F",
    "contest_number": "1785",
    "problem_submissions": {
        "F": [
            192340988,
            192367706,
            192347284,
            192344077,
            192349198,
            192347771,
            192385993,
            192336126,
            192406311,
            192343375,
            192348787,
            192366544,
            192344262,
            192411258,
            192345259,
            192363821,
            192484658
        ],
        "E": [
            192334775,
            192378839,
            192330680,
            192327219,
            192332119,
            192339722,
            192385982,
            192341740,
            192412077,
            192337184,
            192336634,
            192325309,
            192324682,
            192330314,
            192339341,
            192328941,
            192342934,
            192342640,
            192343285,
            192338492,
            192348718
        ],
        "D": [
            192309677,
            192304720,
            192308363,
            192312353,
            192300737,
            192385972,
            192323435,
            192411822,
            192411698,
            192411631,
            192411452,
            192307092,
            192297940,
            192289422,
            192305735,
            192292206,
            192306351,
            192303021,
            192324811,
            192312541,
            192301962,
            192316529,
            192316093,
            192321567,
            192314574
        ],
        "C": [
            192301226,
            192367208,
            192300659,
            192294893,
            192304774,
            192305847,
            192385966,
            192316174,
            192318962,
            192301773,
            192292324,
            192299527,
            193510779,
            192315363,
            192293483,
            192308504,
            192291605,
            192310063,
            192307486,
            192299043,
            192314808,
            192308858
        ],
        "B": [
            192291042,
            192291589,
            192316742,
            192291514,
            192291590,
            192385951,
            192288659,
            192292597,
            192289761,
            192297426,
            192300042,
            192305089,
            192297247,
            192288814,
            192295447,
            192337551,
            192290254,
            192297732,
            192303838,
            192303907,
            192291091
        ],
        "A": [
            192284331,
            192283441,
            192283155,
            192282660,
            192283131,
            192385935,
            192282844,
            192284622,
            192283277,
            192290652,
            192292611,
            192296096,
            192286915,
            192282931,
            192283418,
            192285228,
            192283044,
            192283110,
            192282987,
            192288048,
            192282867
        ]
    },
    "name": "F. Minimums or Medians",
    "statement": "Vika has a set of all consecutive positive integers from 1 to 2n,\r\ninclusive.Exactly k times Vika will choose and perform one of the\r\nfollowing two actions: take two smallest integers from her current set\r\nand remove them; take two median integers from her current set and\r\nremove them. Recall that medians are the integers located exactly in the\r\nmiddle of the set if you write down its elements in increasing order.\r\nNote that Vika’s set always has an even size, thus the pair of median\r\nintegers is uniquely defined. For example, two median integers of the\r\nset\r\n{1, 5, 6, 10, 15, 16, 18, 23\r\n} are 10 and 15.How many different sets can Vika obtain in the end,\r\nafter k actions? Print this number modulo 998\r\n,244\r\n,353. Two sets are considered different if some integer belongs to one\r\nof them but not to the other.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 3100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint K, N;\n\tcin >> N >> K;\n\tint slots = (N-K);\n\tnum ans = 0;\n\tans += 1;\n\tif(1 <= slots){\n\t\tans += K;\n\t}\n\tfor(int m = 2; m <= slots; m++){\n\t\tint sum = K - m;\n\t\tint lim = sum / 2;\n\t\tnum v1 = ncr(m-1 + lim, m-1);\n\t\tnum v2 = (m-1) * ncr(m + lim, m);\n\t\tans += -2 * v2 + (sum + 1 + 2 * m - 2) * v1;\n\t}\n\tcout << ans << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "two pointers"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Minimums or Medians.json",
    "editorial_link": "https://codeforces.com//blog/entry/112875",
    "editorial": "Letâs denote removing minimums with , and removing medians with . Now a\r\nsequence of Vikaâs actions can be described with a string of length\r\nconsisting of characters and .Observe that if we have a substring , we\r\ncan replace it with , and the set of removed numbers will not change. We\r\ncan keep applying this transformation until there are no substrings in\r\n.Now, a string of our interest looks as a concatenation of: letters ,\r\nfor some ; if , then a letter ; letters and , without two letters in a\r\nrow. Letâs denote the number of letters in part 3 above as .Can\r\ndifferent strings still lead to equal sets in the end?First, letâs\r\nsuppose that . We will prove that all strings that match the above\r\npattern result in distinct integer sets.Part 1 in the above\r\nconcatenation means that integers from to are removed. Since there are\r\nletters in in total, integers from to are removed too. However, integers\r\nin the range are not removed, and note that is equivalent to . Hence,\r\nthis range is never empty when . Thus, we can see that for all pairs of\r\nand , the leftmost non-removed ranges are distinct.Now, also note that\r\nin part 3 of the concatenation, any letter always removes some two\r\nconsecutive integers (since there is no substring ), and letters serve\r\nas \"shifts\" for these removals, and different sets of \"shifts\" result in\r\ndifferent final sets of integers. This finishes the proof.It is easy to\r\nfind the number of ways to fill part 3 for fixed and : there are ways to\r\nchoose positions out of so that no two consecutive positions are chosen.\r\nNow we have just iterate over all valid pairs of and to get an solution\r\nfor the case.Before optimizing it to , letâs get back to the case. Some\r\nstrings can result in the same final set. Let be the smallest integer in\r\nthe final set. Note that is always odd. We will only look for a string\r\nthat contains letters : that is, a string that removes integers from to\r\nonly via removing minimums. We can see that there is always a unique\r\nsuch string.Recall the uniqueness proof for . When , we will now force\r\nthat leftmost non-removed range, , to be non-empty. If the range is\r\nempty, our sequence of actions does not satisfy the condition from the\r\nprevious paragraph, so we can skip this pair of and . When , things are\r\na bit different. Suppose we have fixed . It means there are letters in\r\nthe string. These operations remove integers from to . Thus, we need the\r\nfirst letter to remove integers strictly greater than , which gives us a\r\nlower bound on the number of letters at the start of the string.\r\nOtherwise, we can use the same binomial coefficient formula for\r\ncounting.This should finish the solution for any .To optimize it, letâs\r\niterate over first and iterate over inside. It turns out that all valid\r\nvalues of form a range, and if we look at what we are summing up, it is\r\nfor some integer . This sum is equal to by the hockey-stick identity.\r\nThus, we finally have an solution.\r\n",
    "hint": []
}