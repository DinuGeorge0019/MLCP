{
    "link": "https://codeforces.com//contest/1280/problem/D",
    "problemId": "495763",
    "problem_idx": "D",
    "shortId": "1280D",
    "contest_number": "1280",
    "problem_submissions": {
        "E": [
            66917544,
            66918710,
            66922267,
            66921342,
            66922263,
            66926965,
            66926660,
            66927067,
            66925334,
            66928850,
            66995264,
            66984642,
            66984352,
            66984306,
            66929552,
            66927288,
            66928819,
            66918756,
            67988551,
            66935139,
            67027185,
            66930594
        ],
        "D": [
            66910755,
            66913056,
            66911496,
            66913696,
            66913107,
            66913708,
            66913839,
            66916865,
            66916639,
            66915491,
            66986758,
            66986656,
            66986610,
            66986506,
            66986162,
            66985974,
            66985915,
            66985866,
            66985681,
            66985603,
            66985529,
            66917639,
            66918143,
            66919046,
            66912800,
            66915483,
            66915027,
            67988467,
            66920051,
            66917432,
            66918759,
            66917692
        ],
        "C": [
            66906002,
            66909093,
            66907333,
            66908961,
            66908129,
            66909339,
            66908240,
            66909052,
            66911854,
            66908829,
            66908393,
            66909027,
            66913164,
            66908797,
            66903678,
            66908260,
            67988454,
            66908965,
            66910137,
            66910802,
            66910959
        ],
        "B": [
            66904540,
            66906897,
            66902891,
            66906439,
            66906232,
            66906362,
            66905756,
            66906434,
            66909740,
            66905894,
            66905319,
            66906149,
            66910474,
            66930936,
            66909557,
            66906748,
            67988445,
            66907466,
            66906183,
            66908402,
            66907579
        ],
        "A": [
            66901496,
            66903238,
            66905004,
            66902693,
            66904062,
            66902839,
            66902110,
            66903240,
            66903755,
            66903072,
            66902272,
            66903347,
            66905647,
            66902258,
            66906539,
            66904016,
            67988407,
            66934409,
            66903855,
            66903188,
            66903009,
            66902847
        ],
        "F": [
            66936996,
            66936445,
            69949014,
            71271095,
            66930593,
            67311416
        ]
    },
    "name": "D. Miss Punyverse",
    "statement": "The Oak has n nesting places, numbered with integers from 1 to n.\r\nNesting place i is home to b_i bees and w_i wasps.Some nesting places\r\nare connected by branches. We call two nesting places if there exists a\r\nbranch between them. A from nesting place x to y is given by a sequence\r\ns_0,\r\nldots, s_p of distinct nesting places, where p is a non-negative\r\ninteger, s_0 = x, s_p = y, and s_{i-1} and s_{i} are adjacent for each i\r\n= 1,\r\nldots, p. The branches of The Oak are set up in such a way that for any\r\ntwo pairs of nesting places x and y, there exists a unique simple path\r\nfrom x to y. Because of this, biologists and computer scientists agree\r\nthat The Oak is in fact, a tree.A is a set V of nesting places such that\r\nfor any two x and y in V, there exists a simple path from x to y whose\r\nintermediate nesting places all lie in V. A set of villages\r\ncal P is called a if each of the n nesting places is contained in\r\nexactly one of the villages in\r\ncal P. In other words, no two villages in\r\ncal P share any common nesting place, and altogether, they contain all n\r\nnesting places.The Oak holds its annual Miss Punyverse beauty pageant.\r\nThe two contestants this year are Ugly Wasp and Pretty Bee. The winner\r\nof the beauty pageant is determined by voting, which we will now\r\nexplain. Suppose\r\nmathcal{P} is a partition of the nesting places into m villages V_1,\r\nldots, V_m. There is a local election in each village. Each of the\r\ninsects in this village vote for their favorite contestant. If there are\r\nmore votes for Ugly Wasp than Pretty Bee, then Ugly Wasp is said to in\r\nthat village. Otherwise, Pretty Bee . Whoever wins in the most number of\r\nvillages wins.As it always goes with these pageants, bees always vote\r\nfor the bee (which is Pretty Bee this year) and wasps always vote for\r\nthe wasp (which is Ugly Wasp this year). Unlike their general elections,\r\nno one abstains from voting for Miss Punyverse as everyone takes it very\r\nseriously.Mayor Waspacito, and his assistant Alexwasp, wants Ugly Wasp\r\nto win. He has the power to choose how to partition The Oak into exactly\r\nm villages. If he chooses the partition optimally, determine the maximum\r\nnumber of villages in which Ugly Wasp wins.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nvector<vector<int> > edges;\nvector<int> votes;\n\nvoid chk_max(pair<int, ll>& a, pair<int, ll> b){\n\tif(b > a) a = b;\n}\n\nvector<pair<int, ll> > dfs(int v, int p){\n\tvector<pair<int, ll> > f = {{0, votes[v]}};\n\tfor(int w : edges[v]){\n\t\tif(w == p) continue;\n\t\tvector<pair<int, ll> > x = dfs(w, v);\n\t\tvector<pair<int, ll> > newf(f.size() + x.size(), {0, -1e16});\n\t\tfor(int i = 0; i < (int)f.size(); i++){\n\t\t\tfor(int j = 0; j < (int)x.size(); j++){\n\t\t\t\tpair<int, ll> r = f[i], s = x[j];\n\t\t\t\t{\n\t\t\t\t\tchk_max(newf[i + j], {r.first + s.first, r.second + s.second});\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tchk_max(newf[i + j + 1], {r.first + s.first + (s.second > 0), r.second});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf = newf;\n\t}\n\treturn f;\n}\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvotes.assign(n, 0);\n\tedges.assign(n, {});\n\tfor(int i = 0; i < n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tvotes[i] -= x;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tvotes[i] += x;\n\t}\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tvector<pair<int,ll> > res = dfs(0, -1);\n\tint ans = res[m-1].first;\n\tif(res[m-1].second > 0) ans++;\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}\n// maximum # of villages, how many at top"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Miss Punyverse.json",
    "editorial_link": "https://codeforces.com//blog/entry/72212",
    "editorial": "Let's say a region is winning if there are strictly more wasps than bees. Thus, we're maximizing the number of winning regions.\n\nTree DP seems natural in this sort of situation. For example, after rooting the tree arbitrarily, you could probably come up with something like f(i,r)\n: Given the subtree rooted at i\n and the number of regions r\n, find the maximum number of winning regions if we partition that subtree into r\n regions. However, this has an issue: we also need to merge our topmost component with the topmost component of some subtrees, so the subtrees' vote advantage at their topmost components matter, and must also be considered in the DP. Unfortunately, if we just naively insert the vote advantage to our DP state (or output), this means that there could potentially be too many states/outputs to fit in the time limit.\n\nFortunately, we can keep the number of states the same by using the following greedy observation: It is optimal to maximize the number of winning regions first, and then to maximize the vote advantage at the top second. In other words, in a subtree,\n(x winning regions,?? vote advantage)\nis better than\n(x?1 winning regions,+? vote advantage).\nThis is because the +?\n vote advantage at the top component, at best, can increase the number of winning regions by 1\n, but we can already guarantee to achieve that with (x,??)\n.\n\nSo the DP now becomes f(i,r)\n: Given the subtree rooted at i\n and the number of regions r\n, find the maximum number of winning regions, and among all such possibilities, find the maximum vote advantage of the top component.\n\nJust be careful that your DP solution doesn't construct size-0\n partitions.\n\nNow, what about the time complexity? We have a state that looks like (i,r)\n, where 1?r?size(i)\n, and a transition that runs in O(r)\n, so naively it feels like it runs in O(n3)\n in the worst case. However, if you've seen this before, this is actually the sort of DP pattern that is really O(n2)\n, at least with the right implementation.\n\nSpecifically, if we ensure that we only loop across the range where the substates are both valid, then you may check that the total amount of work done in each node is O(size(i)2??j is a child of isize(j)2)\n, and such a recurrence can be analyzed to be O(n2)\n."
}