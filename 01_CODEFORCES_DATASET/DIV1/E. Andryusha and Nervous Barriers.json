{
    "link": "https://codeforces.com//contest/781/problem/E",
    "problemId": "96953",
    "problem_idx": "E",
    "shortId": "781E",
    "contest_number": "781",
    "problem_submissions": {
        "B": [
            25258392,
            25257297,
            25250177,
            25250748,
            25251116,
            25249653,
            25250716,
            25250834,
            25250705,
            25251947,
            25250575,
            31121662,
            25252893,
            25252683,
            25253146,
            25255775,
            25252991,
            25253498
        ],
        "E": [
            25256397,
            25254067,
            25258825,
            25260075,
            26145785,
            25259028,
            25259758,
            25260563,
            25260848,
            25261488,
            25260086,
            25703349,
            25261912,
            25262169,
            25262264,
            25261946,
            25261665,
            25262876,
            25262009
        ],
        "D": [
            25252423,
            25259248,
            25255529,
            25254368,
            25256042,
            25256267,
            25256774,
            25256075,
            25254834,
            25256057,
            25266603,
            25256151,
            25257817,
            25258124,
            25258109,
            25258052,
            25258679,
            25258333
        ],
        "C": [
            25249500,
            25249747,
            25251802,
            25252056,
            25252378,
            25250971,
            25252726,
            25253382,
            25252087,
            25253151,
            25252105,
            25254478,
            25253975,
            25254827,
            25254070,
            25255284,
            25254950
        ],
        "A": [
            25247143,
            25247027,
            25247783,
            25247695,
            25248775,
            25247133,
            25247620,
            25248678,
            25249108,
            25249147,
            25247139,
            25249553,
            25248502,
            25248323,
            25249740,
            25249518,
            25247402
        ],
        "F": [
            25268984,
            25267317,
            25271843,
            25271410,
            25271394,
            25271157,
            25270611,
            26202615
        ]
    },
    "name": "E. Andryusha and Nervous Barriers",
    "statement": "Andryusha has found a perplexing arcade machine. The machine is a\r\nvertically adjusted board divided into square cells. The board has\r\ncolumns numbered from to from left to right, and rows numbered from to\r\nfrom the bottom to the top.Further, there are barriers in some of board\r\nrows. There are barriers in total, and -th of them occupied the cells\r\nthrough of the row . Andryusha recollects well that no two barriers\r\nshare the same row. Furthermore, no row is completely occupied with a\r\nbarrier, that is, at least one cell in each row is free.The player can\r\nthrow a marble to any column of the machine from above. A marble falls\r\ndownwards until it encounters a barrier, or falls through the bottom of\r\nthe board. A marble disappears once it encounters a barrier but is\r\nreplaced by two more marbles immediately to the left and to the right of\r\nthe same barrier. In a situation when the barrier is at an edge of the\r\nboard, both marbles appear next to the barrier at the side opposite to\r\nthe edge. More than one marble can occupy the same place of the board,\r\nwithout obstructing each other\u2019s movement. Ultimately, all marbles are\r\nbound to fall from the bottom of the machine. Peculiarly, sometimes\r\nmarbles can go through barriers as if they were free cells. That is so\r\nbecause the barriers are in fact alive, and frightened when a marble was\r\ncoming at them from a very high altitude. More specifically, if a marble\r\nfalls towards the barrier from relative height more than (that is, it\r\nstarted its fall strictly higher than ), then the barrier evades the\r\nmarble. If a marble is thrown from the top of the board, it is\r\nconsidered to appear at height .Andryusha remembers to have thrown a\r\nmarble once in each of the columns. Help him find the total number of\r\nmarbles that came down at the bottom of the machine. Since the answer\r\nmay be large, print it modulo .\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:1000000000\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <memory>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <ctime> \n#include <stack>\n\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\n\nusing namespace std;\n\nconst int MAXN = 100001;\nconst int INF = 1000 * 1000 * 1000 + 2;\nconst int MODULE = 1000 * 1000 * 1000 + 7;\n\nstruct lane\n{\n\tint l, r, s, u;\n};\n\nstack <pair <int, int> > sc[MAXN];\nint top[MAXN];\nlane a[MAXN];\nint rid[MAXN];\n\n\n\nvoid er(int id)\n{\n\tsc[id].pop();\n\ttop[id] = sc[id].top().first;\n}\n\nbool cmp(lane l1, lane l2)\n{\n\treturn l1.s > l2.s;\n}\n\nint rmq[4 * MAXN];\n\ninline int bst(int i1, int i2)\n{\n\treturn (top[i1] < top[i2]) ? i1 : i2;\n}\n\nvoid create_rmq(int v, int l, int r)\n{\n\tif (l == r)\n\t{\n\t\trid[l] = v;\n\t\trmq[v] = l;\n\t\treturn;\n\t}\n\tcreate_rmq(v * 2 + 1, l, (l + r) / 2);\n\tcreate_rmq(v * 2 + 2, (l + r) / 2 + 1, r);\n\trmq[v] = bst(rmq[v * 2 + 1], rmq[v * 2 + 2]);\n}\n\nint lv, rv;\n\nint get_rmq(int v, int l, int r)\n{\n\tif ((lv > r) || (l > rv)) return 0;\n\tif ((lv <= l) && (r <= rv)) return rmq[v];\n\treturn bst(get_rmq(v * 2 + 1, l, (l + r) / 2), get_rmq(v * 2 + 2, (l + r) / 2 + 1, r));\n}\n\nvoid modify_rmq(int l)\n{\n\tint v = rid[l];\n\twhile (v != 0)\n\t{\n\t\tv = (v - 1) / 2;\n\t\trmq[v] = bst(rmq[v * 2 + 1], rmq[v * 2 + 2]);\n\t}\n}\n\nvoid psh(int id, int x, int y)\n{\n\tsc[id].push(mp(x, y));\n\ttop[id] = x;\n\tmodify_rmq(id);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tint h, w, n;\n\tcin >> h >> w >> n;\n\ttop[0] = 2 * INF + 4;\n\tfor (int i = 1; i <= w; i++)\n\t{\n\t\tpsh(i, 2 * INF + 3, 0);\n\t\tpsh(i, h + 1, 1);\n\t}\n\tcreate_rmq(0, 1, w);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i].s >> a[i].l >> a[i].r >> a[i].u;\n\t}\n\tsort(a, a + n, cmp);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlv = a[i].l, rv = a[i].r;\n\t\tint y = a[i].s;\n\t\tint ly = a[i].s + a[i].u;\n\t\tint cur = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tint v = get_rmq(0, 1, w);\n\t\t\tif (top[v] > ly) break;\n\t\t\tcur = (cur + sc[v].top().second) % MODULE;\n\t\t\ter(v);\n\t\t\tmodify_rmq(v);\n\t\t}\n\t\tif (lv == 1)\n\t\t\tpsh(rv + 1, y, (cur * 2) % MODULE);\n\t\telse if (rv == w) psh(lv - 1, y, (cur * 2) % MODULE);\n\t\telse psh(lv - 1, y, cur), psh(rv + 1, y, cur);\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= w; i++)\n\t{\n\t\twhile (!sc[i].empty())\n\t\t{\n\t\t\tans += sc[i].top().second;\n\t\t\tans %= MODULE;\n\t\t\tsc[i].pop();\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Andryusha and Nervous Barriers.json",
    "editorial_link": "https://codeforces.com//blog/entry/50854",
    "editorial": "Solution 1: Let us move a sweep-line from the bottom to the top, and say\r\nthat -th barrier is active if the current -coordinate satisfies . If we\r\nwant to find the result of dropping a ball in column at a certain\r\nmoment, we have to find the highest active barrier that covers at the\r\nmoment.Let us store a segment tree, with a set of active segments in\r\neach tree node. When introducing a new active segment, we represent it\r\nas a union of tree nodes, and add this segment in each of these nodes\u00e2\u0080\u0099\r\nset; when a segment becomes non-active, we delete these entries. If at\r\nany point we are interested in finding the highest active barrier for a\r\ncolumn , we consider all tree nodes covering and look at their highest\r\nentries only. Also, for each segment we store the number of resulting\r\nballs after hitting this segment; this number can be found by making two\r\nqueries to the tree (for the two balls resulting from the collision) at\r\nthe same time we activate the barrier. To find the final answer, for\r\neach column drop a ball in it from height and sum the results. Thus, the\r\nanswer can be found in time (with the second logarithm for working\r\ntime).Solution 2: Let us go from the top to the bottom instead, and\r\nmaintain positions of all balls to be dropped. If any of these balls\r\noccupy the same position, we group them together and store the size of\r\nthe group. Each column will have a separate stack of groups, with lower\r\ngroups on top of the stack.Let\u00e2\u0080\u0099s see how a new barrier changes our\r\nconfiguration. For each column we want to drop several lowest groups on\r\nthe barrier, which will result in creating at most two new groups next\r\nto the barrier. Let us store a segment tree of size , with -th entry\r\nequal to the height of the lowest group in column . While range minimum\r\nin the segment tree is low enough, we pop the lowest group from the\r\ncorresponding stack (and update the segment tree accordingly). Finally,\r\nwe create the new groups, and push them to their respective stacks.\r\nAfter processing all barriers, the rest groups will fall straight to the\r\nbottom.A standard amortized estimate shows that operations will be\r\nperformed, for time complexity.\r\n"
}