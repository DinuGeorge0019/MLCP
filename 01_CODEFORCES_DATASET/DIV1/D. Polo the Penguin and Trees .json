{
    "link": "https://codeforces.com//contest/288/problem/D",
    "problemId": "2804",
    "problem_idx": "D",
    "shortId": "288D",
    "contest_number": "288",
    "problem_submissions": {
        "E": [
            3461335,
            3458641,
            3460719,
            3463436,
            3464512,
            3465599,
            3463363
        ],
        "D": [
            3459154,
            3461432,
            3462104,
            3459195,
            3461788,
            3463179,
            3460795,
            3460033,
            3460203,
            3460132,
            3460594,
            3462546,
            3461278,
            3460741,
            3460872,
            3463288,
            3461898,
            3463050,
            3459096
        ],
        "C": [
            3456557,
            3456008,
            3456566,
            3460063,
            3459414,
            3455119,
            3457015,
            3455658,
            3456591,
            3461209,
            3457290,
            3458346,
            3456693,
            3458697,
            3459031,
            3457702,
            3456625,
            3456183,
            3459280,
            3461683
        ],
        "B": [
            3454685,
            3454711,
            3454445,
            3455354,
            3456458,
            3458036,
            3455646,
            3457997,
            3455444,
            3455146,
            3455413,
            3456413,
            3455198,
            3455816,
            3455015,
            3456234,
            3455164,
            3454216,
            3456654,
            3456132
        ],
        "A": [
            3453504,
            3453349,
            3455471,
            3453867,
            3453397,
            3453393,
            3454113,
            3453524,
            3454252,
            3453356,
            3454346,
            3454163,
            3455311,
            3454507,
            3455240,
            3454740,
            3453430,
            3455107,
            3453891,
            3453666
        ]
    },
    "name": "D. Polo the Penguin and Trees ",
    "statement": "Little penguin Polo has got a tree a non-directed connected acyclic\r\ngraph, containing nodes and edges. We will consider the tree nodes\r\nnumbered by integers from 1 to .Today Polo wonders, how to find the\r\nnumber of pairs of paths that don’t have common nodes. More formally, he\r\nshould find the number of groups of four integers and such that: ; ;\r\nthere’s no such node that lies on both the shortest path from node to\r\nnode and from node to node . The shortest path betweem two nodes is the\r\npath that is shortest in the number of edges.Help Polo solve this\r\nproblem.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define N 100010\nint he[N],ne[N*2],ad[N*2],fa[N],q[N],n,s[N];ll f[N],fs[N];\nvoid add(int x,int y)\n{\n    static int t=0;\n    ++t,ne[t]=he[x],he[x]=t,ad[t]=y,\n    ++t,ne[t]=he[y],he[y]=t,ad[t]=x;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,x,y;i<n;i++)\n        scanf(\"%d%d\",&x,&y),add(x,y);\n    int le=1,ri=1;q[1]=1;\n    while(le<=ri)\n    {\n        int x=q[le++];\n        for(int p=he[x];p;p=ne[p])\n            if(ad[p]!=fa[x])fa[ad[p]]=x,q[++ri]=ad[p];\n    }\n    for(int i=n;i>=1;i--)\n    {\n        int x=q[i];\n        s[x]++;\n        if(fa[x])s[fa[x]]+=s[x];\n    }\n    for(int i=1;i<=n;i++)\n    {\n        ll S=0;\n        for(int p=he[i];p;p=ne[p])if(ad[p]!=fa[i])\n            S+=(ll)s[ad[p]]*(s[i]-s[ad[p]]-1);\n        f[i]=S/2+s[i]-1;\n    }\n    for(int i=n;i>=1;i--)\n    {\n        int x=q[i];\n        fs[x]+=f[x]*s[x];\n        if(fa[x])fs[fa[x]]+=fs[x];\n    }\n    ll T=0;\n    for(int i=1;i<=n;i++)T+=f[i];\n    T*=T;\n    for(int i=1;i<=n;i++)T-=f[i]*f[i];\n    ll S=0;\n    for(int i=1;i<=n;i++)\n    {\n        for(int p=he[i];p;p=ne[p])if(ad[p]!=fa[i])\n            S+=fs[ad[p]]*(s[i]-s[ad[p]]);\n    }\n    cout<<T-S*2<<endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Polo the Penguin and Trees .json",
    "editorial_link": "https://codeforces.com/blog/entry/7241",
    "editorial": "As always in such problems, root our tree at some vertex, for example vertex with number 1. We need to find out, what will happen when we have already chosen one path. Obviously, after deleting all vertices and their edges from that path, tree will disintegrate in some set of trees. Denote their sizes by c1,?c2,?...,?ck, where k is the number of trees. Then the number of ways to choose the second path is equal to . This gives us O(n2) solution  just to brute force all pathes and count the number of second paths by this formula. We need to do it in O(n). To do so, dfs our graph and fix some vertex during dfs, we will consider this vertex as the last vertex in the first path. Now we need to find the sum of above formula for the rest of the vertex. Here you can separately solve this problem for all vertex inside subtree of current vertex and for the rest of the vertices. For subtree vertices, you can, after finding the answers for all vertices of subtree, find the answer for root of subtree. To do so, you need to iterate all edges from current vertex and sum up results for that vetices. Also you need to add the sum of values  multiplied by the number of vertices in subtree, where di are all sizes of subtrees of vertices from current vertex, not including from current edge). You can use some partial sums of something like that to make it linear. For the rest of the vertices (not in subtree) it is actually similar, but a bit harder. Here you need to keep current result as a parameter of dfs and when you entering some vertex you should add some additional counts to the current sum (similarly as in first case).",
    "hint": []
}