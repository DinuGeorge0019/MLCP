{
    "link": "https://codeforces.com//contest/1874/problem/G",
    "problemId": "2236842",
    "problem_idx": "G",
    "shortId": "1874G",
    "contest_number": "1874",
    "problem_submissions": {
        "F": [
            226041334,
            226055202,
            226083158,
            226054781,
            226061315,
            226045179,
            226057161,
            226024417,
            226094016,
            226151126,
            226979730,
            226372437,
            226704730,
            226099033,
            226098861,
            226001871
        ],
        "B": [
            225998357,
            225944596,
            225961498,
            226022662,
            225970503,
            226048661,
            225965106,
            225956535,
            225974109,
            226024200,
            226979960,
            226057337,
            225972372,
            225968693,
            225962068,
            226040739,
            225981051,
            226047279,
            226046003,
            225948785
        ],
        "D": [
            225989950,
            226004287,
            225983656,
            225994935,
            225998958,
            226008015,
            225977564,
            226002115,
            225985427,
            226003081,
            225989658,
            226979804,
            225989175,
            226003010,
            226023529,
            226002830,
            226078484,
            226078353,
            226002716,
            226024255,
            226018418,
            226137164,
            225986804
        ],
        "E": [
            225973607,
            225981897,
            226000134,
            225978662,
            226074388,
            226073614,
            226073223,
            226072631,
            226071563,
            226069387,
            226068777,
            226021358,
            225958738,
            226070894,
            225983588,
            226039851,
            226021998,
            226007010,
            226979776,
            226006499,
            226036184,
            226038920,
            226053631,
            226068817,
            226063126,
            226059742,
            226057237
        ],
        "C": [
            225967620,
            225968755,
            225972644,
            225961410,
            225983858,
            225989707,
            225987635,
            225970993,
            225986658,
            225975231,
            226979908,
            225973609,
            225986638,
            225980254,
            225971024,
            227431342,
            225959672,
            225996237,
            225972869,
            226057682,
            225972171
        ],
        "A": [
            225936409,
            225922035,
            225921764,
            225934682,
            225931922,
            225937474,
            225923760,
            225922674,
            225923828,
            225922214,
            226979999,
            225944454,
            225937163,
            225922982,
            225921695,
            226083093,
            226083061,
            225937017,
            225941961,
            225925562,
            226022851,
            225923156
        ],
        "G": [
            226095099,
            226164597,
            226979660,
            226967841,
            230907178
        ]
    },
    "name": "G. Jellyfish and Inscryption",
    "statement": "Jellyfish loves playing a game called \"Inscryption\" which is played on a\r\ndirected acyclic graph with n vertices and m edges. All edges a\r\nto b satisfy a < b.You need to move from vertex 1 to vertex n along the\r\ndirected edges, and then fight with the final boss.You will collect and\r\nin the process.Each has two attributes: HP and damage. If a HP is a and\r\nits damage is b, then the power of the is a\r\ntimes b.Each has only one attribute: power.In addition to vertex 1 and\r\nvertex n, there are some vertices that trigger special events. The\r\nspecial events are: You will get a with a HP, and b damage. If you have\r\nat least one , choose one of your and increase its HP by x. If you have\r\nat least one , choose one of your and increase its damage by y. You will\r\nget a with w power. When you get to vertex n, you can choose of your and\r\nmultiply its damage by 10^9.The final boss is very strong, so you want\r\nto maximize the sum of the power of all your and . Find the maximum\r\npossible sum of power of all your and if you play the game optimally.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? \",\" : \"\"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n'\n\t\t                                                             : ' ';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << '{';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << '}';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << '(';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << ')';\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << \"\\033[0;31m\";\n\t\tImpl(t);\n\t\tif (debug) os << \"\\033[0m\";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << '\\n'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep(\" | \", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep(\" | \", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m\"\n\t     << \" | \"\n\t     << \"\\u001b[34m\" << func << \"\\033[0m\"\n\t     << \":\"\n\t     << \"\\u001b[34m\" << line << \"\\033[0m\"\n\t     << \" - \"\n\t     << \"[\" << args << \"] = \";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\n}\n}  // namespace FileIO\n\n// slow ...\n\nconst int K = 200;\nint N, M;\nvi type, hp, damage, power;\nvpi card;\nll ans = 0;\nV<vi> in, out;\n\nV<vpi> dp_flash;\nV<V<vi>> F;\n\nconst pi EMP{-1, 0};\nvoid solve_flash() {\n\tdp_flash.rsz(N + 1);\n\tvi max_power(N + 1);\n\t// vpi(N * K + 1, {-1, 0})\n\tROF(x, 1, N + 1) {\n\t\t// dp[x][a]: have a upon entering this\n\t\tdp_flash.at(x) = vpi((N - x) * K + 1, EMP);\n\t\tdp_flash.at(x).at(0) = {0, 0};\n\t\tfor (int y : out[x]) {\n\t\t\tckmax(max_power[x], max_power[y]);\n\t\t\tF0R(a, sz(dp_flash.at(y))) {\n\t\t\t\tckmax(dp_flash.at(x).at(a), dp_flash.at(y).at(a));\n\t\t\t}\n\t\t}\n\t\tif (type[x] == 0) {\n\t\t\t// nothing\n\t\t} else if (type[x] == 1) {\n\t\t\tassert(card[x].f);\n\t\t\teach(t, dp_flash.at(x)) if (t != EMP) t.s += card[x].f * card[x].s;\n\t\t} else if (type[x] == 2) {\n\t\t\tassert(hp[x]);\n\t\t\tdp_flash.at(x).ins(begin(dp_flash.at(x)), hp[x], EMP);\n\t\t} else if (type[x] == 3) {\n\t\t\teach(t, dp_flash.at(x)) if (t != EMP) t.f += damage[x];\n\t\t} else if (type[x] == 4) {\n\t\t\tmax_power[x] += power[x];\n\t\t\tassert(power[x]);\n\t\t\teach(t, dp_flash.at(x)) if (t != EMP) t.s += power[x];\n\t\t}\n\t}\n\tckmax(ans, (ll)max_power[1]);\n\t// each(t, dp_flash.at(1)) ckmax(ans, (ll)t.s);  // no cards\n}\n\nvoid finish_slow() {\n\tV<V<vi>> G;\n\tF.rsz(N + 1), G.rsz(N + 1);\n\tFOR(x, 1, N + 1) {\n\t\tF[x] = V<vi>(K + 1, vi(x * K + 1, -1));\n\t\tG[x] = V<vi>(K + 1, vi(x * K + 1, -1));\n\t\tF[x].at(0).at(0) = 0;\n\t\tfor (int y : in.at(x)) {\n\t\t\tF0R(a, sz(F[y])) F0R(b, sz(F[y][a])) {\n\t\t\t\tckmax(F[x].at(a).at(b), F[y].at(a).at(b));\n\t\t\t}\n\t\t\tF0R(a, sz(G[y])) F0R(b, sz(G[y][a])) {\n\t\t\t\tckmax(G[x].at(a).at(b), G[y].at(a).at(b));\n\t\t\t}\n\t\t}\n\t\tif (type[x] == 0) {\n\n\t\t} else if (type[x] == 1) {  // add card\n\t\t\tint max_ans = 0;\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) ckmax(max_ans, F[x][a][b]);\n\t\t\tF0R(a, sz(G[x]))\n\t\t\tF0R(b, sz(G[x][a]))\n\t\t\tif (G[x][a][b] != -1) ckmax(max_ans, G[x][a][b] + a * b);\n\t\t\t{  // case: start flash here\n\t\t\t\t// dbg(\"BEFORE\", x, ans, max_ans);\n\t\t\t\tF0R(a, sz(dp_flash.at(x))) if (dp_flash.at(x).at(a) != EMP) {\n\t\t\t\t\tconst ll MUL = 1e9;\n\t\t\t\t\tauto [b, extra] = dp_flash.at(x).at(a);\n\t\t\t\t\tckmax(ans, max_ans + extra +\n\t\t\t\t\t               (card[x].f + a) * (card[x].s + b) * MUL -\n\t\t\t\t\t               card[x].f * card[x].s);\n\t\t\t\t\t// dbg(\"GOT\", a, b, card[x], ans);\n\t\t\t\t}\n\t\t\t\t// dbg(\"AFTER\", x, ans);\n\t\t\t}\n\t\t\t{  // F -> F\n\t\t\t\tF0R(a, sz(F[x]))\n\t\t\t\tF0R(b, sz(F[x][a]))\n\t\t\t\tif (F[x][a][b] != -1) F[x][a][b] += card[x].f * card[x].s;\n\t\t\t\tR0F(a, sz(F[x]))\n\t\t\t\tR0F(b, sz(F[x][a])) {\n\t\t\t\t\tckmax(F[x].at(a).at(card[x].s), F[x][a][b]);\n\t\t\t\t\tckmax(F[x].at(card[x].f).at(b), F[x][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{  // G -> F\n\t\t\t\tF0R(a, sz(G[x]))\n\t\t\t\tF0R(b, sz(G[x][a]))\n\t\t\t\tif (G[x][a][b] != -1) {\n\t\t\t\t\tG[x][a][b] += card[x].f * card[x].s;\n\t\t\t\t\tckmax(F[x][a][card[x].s], G[x][a][b] + a * b);\n\t\t\t\t\tckmax(F[x][card[x].f][b], G[x][a][b] + a * b);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// -> G\n\t\t\tckmax(G[x].at(card[x].f).at(card[x].s), max_ans);\n\t\t} else if (type[x] == 2) {  // increase HP\n\t\t\tassert(hp[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += hp[x] * b;\n\t\t\t}\n\t\t\tR0F(a, sz(G[x]))\n\t\t\tR0F(b, sz(G[x][a])) if (a + hp[x] <= K) {\n\t\t\t\tckmax(G[x][a + hp[x]][b], G[x][a][b]);\n\t\t\t}\n\t\t} else if (type[x] == 3) {  // increase damage\n\t\t\tassert(damage[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += a * damage[x];\n\t\t\t}\n\t\t\tR0F(a, sz(G[x]))\n\t\t\tR0F(b, sz(G[x][a])) if (b + K < sz(G[x][a])) {\n\t\t\t\tckmax(G[x][a][b + damage[x]], G[x][a][b]);\n\t\t\t}\n\t\t} else {\n\t\t\tassert(type[x] == 4);\n\t\t\teach(a, F[x]) each(b, a) if (b != -1) b += power[x];\n\t\t\teach(a, G[x]) each(b, a) if (b != -1) b += power[x];\n\t\t}\n\t}\n}\n\nvoid finish_fast() {\n\tV<V<vi>> G_a;\n\tF.rsz(N + 1), G_a.rsz(N + 1);\n\tFOR(x, 1, N + 1) {\n\t\tF[x] = V<vi>(K + 1, vi(K + 1, -1));\n\t\tG_a[x] = V<vi>(K + 1, vi(K + 1, -1));\n\t\tF[x].at(0).at(0) = 0;\n\t\tfor (int y : in.at(x)) {\n\t\t\tF0R(a, sz(F[y])) F0R(b, sz(F[y][a])) {\n\t\t\t\tckmax(F[x].at(a).at(b), F[y].at(a).at(b));\n\t\t\t}\n\t\t\tF0R(a, sz(G_a[y])) F0R(b, sz(G_a[y][a])) {\n\t\t\t\tckmax(G_a[x].at(a).at(b), G_a[y].at(a).at(b));\n\t\t\t}\n\t\t}\n\t\tif (type[x] == 0) {\n\n\t\t} else if (type[x] == 1) {  // add card\n\t\t\t// TODO: fix\n\t\t\tint max_ans = 0;\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) ckmax(max_ans, F[x][a][b]);\n\t\t\t{  // case: start flash here\n\t\t\t\t// dbg(\"BEFORE\", x, ans, max_ans);\n\t\t\t\tF0R(a, sz(dp_flash.at(x))) if (dp_flash.at(x).at(a) != EMP) {\n\t\t\t\t\tconst ll MUL = 1e9;\n\t\t\t\t\tauto [b, extra] = dp_flash.at(x).at(a);\n\t\t\t\t\tckmax(ans, max_ans + extra +\n\t\t\t\t\t               (card[x].f + a) * (card[x].s + b) * MUL -\n\t\t\t\t\t               card[x].f * card[x].s);\n\t\t\t\t\t// dbg(\"GOT\", a, b, card[x], ans);\n\t\t\t\t}\n\t\t\t\t// dbg(\"AFTER\", x, ans);\n\t\t\t}\n\t\t\t{  // F -> F\n\t\t\t\tF0R(a, sz(F[x]))\n\t\t\t\tF0R(b, sz(F[x][a]))\n\t\t\t\tif (F[x][a][b] != -1) F[x][a][b] += card[x].f * card[x].s;\n\t\t\t\tR0F(a, sz(F[x]))\n\t\t\t\tR0F(b, sz(F[x][a])) {\n\t\t\t\t\tckmax(F[x].at(a).at(card[x].s), F[x][a][b]);\n\t\t\t\t\tckmax(F[x].at(card[x].f).at(b), F[x][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{  // G_a: replace a\n\t\t\t\tF0R(a, sz(G_a[x]))\n\t\t\t\tF0R(b, sz(G_a[x][a]))\n\t\t\t\tif (G_a[x][a][b] != -1) G_a[x][a][b] += card[x].f * card[x].s;\n\t\t\t\tF0R(a, sz(G_a[x]))\n\t\t\t\tF0R(b, sz(G_a[x][a])) ckmax(G_a[x][card[x].f][b], G_a[x][a][b]);\n\t\t\t}\n\t\t\t// -> G_a\n\t\t\tF0R(b, K - card[x].f + 1) {\n\t\t\t\tckmax(G_a[x][card[x].f + b][b],\n\t\t\t\t      max_ans + (card[x].f + b) * card[x].s);\n\t\t\t}\n\t\t} else if (type[x] == 2) {  // OK\n\t\t\t                        // increase HP\n\t\t\tassert(hp[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += hp[x] * b;\n\t\t\t}\n\t\t\tR0F(a, sz(G_a[x]))\n\t\t\tF0R(b, sz(G_a[x][a])) if (b >= hp[x] && G_a[x][a][b] != -1) {\n\t\t\t\tckmax(G_a[x][a][b - hp[x]], G_a[x][a][b]);\n\t\t\t}\n\t\t} else if (type[x] == 3) {  // OK\n\t\t\t                        // increase damage\n\t\t\tassert(damage[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += a * damage[x];\n\t\t\t}\n\t\t\tR0F(a, sz(G_a[x]))\n\t\t\tR0F(b, sz(G_a[x][a])) if (G_a[x][a][b] != -1) {\n\t\t\t\tG_a[x][a][b] += a * damage[x];\n\t\t\t\t// ckmax(G[x][a][b + damage[x]], G[x][a][b]);\n\t\t\t}\n\t\t} else {  // OK\n\t\t\tassert(type[x] == 4);\n\t\t\teach(a, F[x]) each(b, a) if (b != -1) b += power[x];\n\t\t\teach(a, G_a[x]) each(b, a) if (b != -1) b += power[x];\n\t\t}\n\t\tFOR(a, 1, sz(G_a[x])) ckmax(F[x][a][0], G_a[x][a][0]);\n\t}\n}\n\nvoid solve() {\n\tsolve_flash();\n\t// finish_slow();\n\tfinish_fast();\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tre(N, M);\n\ttype.rsz(N + 1);\n\thp.rsz(N + 1);\n\tdamage.rsz(N + 1);\n\tcard.rsz(N + 1);\n\tpower.rsz(N + 1);\n\tFOR(i, 1, N + 1) {\n\t\tre(type[i]);\n\t\tif (type[i] == 0) {\n\t\t} else if (type[i] == 1) re(card[i]);\n\t\telse if (type[i] == 2) re(hp[i]);\n\t\telse if (type[i] == 3) re(damage[i]);\n\t\telse {\n\t\t\tassert(type[i] == 4);\n\t\t\tre(power[i]);\n\t\t}\n\t}\n\t// dbg(card[2]);\n\tin.rsz(N + 1);\n\tout.rsz(N + 1);\n\trep(M) {\n\t\tdef(int, u, v);\n\t\tout[u].pb(v), in[v].pb(u);\n\t}\n\tsolve();\n\tdbg(\"MID\", ans);\n\teach(t, card) swap(t.f, t.s);\n\tswap(hp, damage);\n\tFOR(i, 1, N + 1) if (2 <= type[i] && type[i] <= 3) type[i] ^= 1;\n\tsolve();\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON'T GET STUCK ON ONE APPROACH\n */\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\G. Jellyfish and Inscryption.json",
    "editorial_link": "https://codeforces.com//blog/entry/120943",
    "editorial": "TutorialFor convenience, let\u00e2\u0080\u0099s define , use operation 1 for \"You will\r\nget a card with HP, and damage\", operation 2 for \"If you have at least\r\none card, choose one of your cards and increase its HP by \" and\r\noperation 3 for \"If you have at least one card, choose one of your cards\r\nand increase its damage by \", operation 4 for \"You will get a prop with\r\npower\", operation 5 for \"You can choose at most one of your cards and\r\nmultiply its damage by \", \"the -th card\" for the card we get from vertex\r\n(It must be operation 1 on vertex ), \"do operation 2/3/5 onto card \" for\r\n\"When we do this operation 2/3/5, we will choose the card and increase\r\nhis HP or damage\".Let us consider the problem without the operation 5,\r\nwhat\u00e2\u0080\u0099s the maximum possible answer. If you want to maximize the the sum\r\nof the power of your cards, the answer will not exceeding ; If you you\r\nwant to maximize the the sum of the power of your props, the answer will\r\nnot exceeding . Because , so the operation is the most important. Let\u00e2\u0080\u0099s\r\ncalled the card we wil do the operation 5 onto it the \"flash card\".\r\nLet\u00e2\u0080\u0099s use meet-in-the-middle, the problem is divided into two\r\nsubproblems the game before we get the flash card and the game after we\r\nget the flash card.1. The game after we get the flash cardIt\u00e2\u0080\u0099s a easy\r\nproblem, we can use dynamic programming to solve this problem.Since the\r\nmost important thing is the HP and damage of the flash card, so we\r\ndefine the following dynamic programming state: means we are current at\r\nvertex , the current HP of the flash card is , the maximum damage of the\r\nflash card. means we are current at vertex , the current HP of the flash\r\ncard is , the damage of the flash card is , the maximum sum of the power\r\nof all the other cards and props. Since , the time complexity of the\r\ntransition is .2. The game before we get the flash cardThis is the key\r\nof the problem, and since it\u00e2\u0080\u0099s much more difficult, we first consider\r\nthe subproblems of this problem.I. If the graph is a chain, and all the\r\noperation 2 and operation 3 is after the operation 1Lemma. We will do\r\nall the operation 2 onto one of the cards, symmetrically we will also do\r\nall the operation 3 onto one of the cards.Proof. We consider a sequence\r\nof operations, let\u00e2\u0080\u0099s consider if we do all the operation 1 on the card\r\nwith the max damage after doing all the operation 2, the answer won\u00e2\u0080\u0099t be\r\nworse, we can do all the operation 1 onto this card instead, then we\r\nmake a symmetrical adjustment, the answer won\u00e2\u0080\u0099t be worse, and all the\r\noperation 2 is done onto one of the cards, all the operation 3 is done\r\nonto one of the cards.II. If the graph is a chainIt\u00e2\u0080\u0099s similar to the\r\nsubproblem I. If we say subproblem I is like a \"global max value\", then\r\nsubproblem II is like a \"prefix max value\".Let\u00e2\u0080\u0099s define means we will do\r\nthe operation 2/3 on vertex onto the -th card.Lemma1. If there is a\r\noperation 2 on vertex and a operation 2 on vertex , if , we will have\r\n.Proof. Let\u00e2\u0080\u0099s consider the final HP and damage of the cards after all\r\nthe operations. Because we do the operation 2 on vertex onto the -th\r\ncard, for all , the damage of the -th card is not larger than the -th\r\ncard. So for , if we don\u00e2\u0080\u0099t do the operation 2 on vertex j onto the -th\r\ncard, we can do it onto the -th card instead, the answer won\u00e2\u0080\u0099t be\r\nworse.Symmetrically, Lemma1 is also correct for operation 3.Now we can\r\nuse dynamic programming to solve the problem, we define the following\r\ndynamic programming state: means we are current at vertex , we will do\r\nthe next several operation 3 onto a card with HP after all the\r\noperations and we will do the next several operation 2 onto a card with\r\ndamage after all the operations, and this two cards are not the same.\r\nmeans we are current at vertex , We will do the next several operation 2\r\nand operation 3 onto a card currently having HP and damage. The time\r\ncomplexity is , but it\u00e2\u0080\u0099s not enough.Lemma2. If a card has HP and damage\r\nafter all the operations and it\u00e2\u0080\u0099s not the flash card, .Proof. If we use\r\nthis card as the flash card instead of the last one, and do all the\r\noperations done onto the last flash card onto this card, the power of\r\nthe flash card will be larger. So it won\u00e2\u0080\u0099t exist in this half\r\nproblem.Now the time complexity becomes , it\u00e2\u0080\u0099s still not enough.Lemma3.\r\nLet\u00e2\u0080\u0099s define as the maximum HP of all the cards except the flash card\r\nafter all the operations, as the maximum damage of all the cards except\r\nthe flash card after all the operations, .Proof. Let\u00e2\u0080\u0099s assume that the\r\n-th card has HP after all the operations, the -th card has damage after\r\nall the operations and . If , it conflicts with Lemma 2; If , because of\r\nthe Lemma 2, the HP of the -th card after all the operations won\u00e2\u0080\u0099t\r\nexceed , let\u00e2\u0080\u0099s use as the HP of the -th card after all the operations,\r\nand , so we have done some operation 3 onto the -th card. But because ,\r\nif we do these operations onto the -th card, the answer will be better;\r\nIf , it\u00e2\u0080\u0099s symmetric with .But we can make the dynamic programming state\r\nbetter: means we are current at vertex , we will do the next several\r\noperation 3 onto a card with HP after all the operations and we will do\r\nthe next several operation 2 onto a card with damage after all the\r\noperations, and this two cards are not the same. means we are current at\r\nvertex , we will do the next several operation 3 onto a card with HP\r\nafter all the operations, we will do the next several operation 2 onto a\r\ncard and totally increase HP in the next several operations to reach\r\nit\u00e2\u0080\u0099s HP after all the operations. it\u00e2\u0080\u0099s symmetric with , just swap \"HP\"\r\nand \"damage\". Let\u00e2\u0080\u0099s define as the maximum HP of all the cards except the\r\nflash card after all the operations, as the maximum damage of all the\r\ncards except the flash card after all the operations. We will find the\r\nin is because if , using we can get the right answer, if , using we can\r\nget the right answer.the time complexity of the transition is .The\r\ntransition is very complex, you can see more details in my code : )In my\r\ncode, I use to make the transition better. When or reaches , we reaches\r\nthe vertex and there is a operation 1 on vertex , I don\u00e2\u0080\u0099t enumerate the\r\nvalue of the next and while transiting. I transit it to first, and\r\nenumerate the value of the next and together.III. the problem\r\nitselfSince the path is a chain, and we use dynamic programming to solve\r\nthe problem. There\u00e2\u0080\u0099s no difference whether the graph is a chain.Time\r\ncomplexity: Memory complexity:\r\n"
}