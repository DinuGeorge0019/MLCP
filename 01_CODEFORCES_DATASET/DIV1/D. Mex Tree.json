{
    "link": "https://codeforces.com//contest/1830/problem/D",
    "problemId": "1942558",
    "problem_idx": "D",
    "shortId": "1830D",
    "contest_number": "1830",
    "problem_submissions": {
        "F": [
            234326044,
            207652053,
            207663837,
            207807721,
            208075080,
            208075031,
            207678271
        ],
        "D": [
            207640246,
            207630410,
            207637627,
            207621354,
            207615321,
            207636175,
            207642613,
            207640107,
            207677598,
            207636486,
            207674640,
            207643231,
            207672649,
            207672513,
            207643891,
            207672422,
            207672033,
            207644310,
            207746469,
            207746389,
            207650197,
            207645186,
            207822601,
            207822565,
            207645978,
            207642565,
            207658410,
            207638831
        ],
        "C": [
            207608017,
            207600613,
            207612008,
            207600441,
            207604832,
            207598385,
            207603497,
            207608198,
            207613818,
            207614226,
            207616264,
            207606682,
            207610887,
            234877458,
            207617296,
            207626821,
            207621747,
            207647815,
            207622607,
            207619463
        ],
        "B": [
            207599759,
            207593405,
            207597186,
            207596843,
            207596098,
            207591556,
            207609227,
            207602206,
            207592261,
            207601856,
            207592644,
            207601118,
            207592805,
            207603544,
            207613114,
            207602486,
            207597786,
            207598115,
            207609684
        ],
        "A": [
            207586682,
            207582994,
            207583697,
            207581917,
            207581457,
            207583108,
            207588869,
            207586429,
            207584682,
            207584850,
            207583599,
            207583185,
            207584377,
            207587215,
            207597686,
            207589557,
            207585837,
            207585764,
            207588046
        ],
        "E": [
            207715760,
            207661818,
            207884996,
            207884714,
            207713105,
            208057779
        ]
    },
    "name": "D. Mex Tree",
    "statement": "You are given a tree with n nodes. For each node, you either color it in\r\n0 or 1.The value of a path (u,v) is equal to the MEX^\r\ndagger of the colors of the nodes from the shortest path between u and\r\nv.The value of a coloring is equal to the sum of values of all paths\r\n(u,v) such that 1\r\nleq u\r\nleq v\r\nleq n.What is the maximum possible value of any coloring of the tree?^{\r\ndagger} The MEX (minimum excluded) of an array is the smallest\r\nnon-negative integer that does not belong to the array. For instance:\r\nThe MEX of [2,2,1] is 0, because 0 does not belong to the array. The MEX\r\nof [3,1,0,1] is 2, because 0 and 1 belong to the array, but 2 does not.\r\nThe MEX of [0,3,1,2] is 4 because 0, 1, 2, and 3 belong to the array,\r\nbut 4 does not.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\n#define rep1n(i, n) for (int i = 1; i <= (n); ++i)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define each(x, a) for (auto &x : a)\n#define ar array\n#define vec vector\n#define range(i, n) rep(i, n)\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing str = string;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\n\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nint Bit(int mask, int b) { return (mask >> b) & 1; }\n\ntemplate<class T>\nbool ckmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool ckmax(T &a, const T &b) {\n    if (b > a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst int INFi = 1e9;\nconst ll INF = 3e18;\nconst int LG = 20;\n\nconst int maxN = 2e5 + 100;\nvi g[maxN];\nvector<pair<int, int>> dp[maxN][2];\n\nvoid Merge(int v, int u) {\n    int tmp = maxN - 1;\n    dp[tmp][0].clear();\n    dp[tmp][1].clear();\n    rep(x, 2) {\n        for (auto &[was, value]: dp[v][x]) {\n            dp[tmp][x].emplace_back(was, value + dp[u][x ^ 1].back().second);\n        }\n        for (auto &[was, value]: dp[v][x]) {\n            for (auto &[was2, value2]: dp[u][x]) {\n                dp[tmp][x].emplace_back(was + was2, value + value2 + 1ll * was * was2 * (x + 1));\n            }\n        }\n    }\n    swap(dp[tmp], dp[v]);\n    rep(x, 2) {\n        sort(all(dp[v][x]));\n        int j = 0;\n        for (int i = 1; i < dp[v][x].size(); ++i) {\n            if (dp[v][x][j].second <= dp[v][x][i].second) continue;\n            swap(dp[v][x][++j], dp[v][x][i]);\n        }\n        dp[v][x].resize(j + 1);\n    }\n}\n\nvoid dfs(int v, int p) {\n    dp[v][0].emplace_back(1, 0);\n    dp[v][1].emplace_back(1, 1);\n    for (auto &u: g[v]) {\n        if (u == p) continue;\n        dfs(u, v);\n        Merge(v, u);\n    }\n//    cout << \"KEK\\n\";\n}\n\n\nvoid solve() {\n    int n;\n    cin >> n;\n    if (n == 1) {\n        cout << \"1\\n\";\n        return;\n    }\n    rep(_, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n    dfs(1, -1);\n    ll ans = 1ll * n * (n - 1) + n;\n    cout << ans - min(dp[1][1].back().second, dp[1][0].back().second) << '\\n';\n    for (int i = 1; i <= n; ++i) {\n        g[i].clear();\n        dp[i][0].clear();\n        dp[i][1].clear();\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(12) << fixed;\n    int t = 1;\n    cin >> t;\n    rep(i, t) {\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Mex Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/116527",
    "editorial": "If we analyze how good a bipartite coloring of the given\ntree is we can note that Now suppose the tree has a connected component\nof size . We can note that in such a coloring By the claims above, we\ncan note that in an optimal coloring, the maximum size of a connected\ncomponent respects . Thus we can safely say .Now let be the minimum loss\nif we color the subtree of and the connected component of vertex has\nsize . We can calculate this in a knapsack style by adding subtrees\nsuccessively. The computation takes if we use the -th trick from this\nblog.Now we are only left to optimize memory, since now itâs . We can\ndirectly apply this to get linear memory.However, the bound of is\noverestimated, for it can be proven that the worst case for is . Proof\nSketchAssume have a connected component of size we want it to be colored\nacross all optimal colorings. Then we can attach to each node some\nsubtrees such that after flipping its whole subtree the total cost\ndoesnât increase. We will assume all subtrees are leaves for simplicity.\nDoing such, we can get some inequalities about the number of leaves we\nneed to attatch to each node. In a star tree, the number of leaves we\nshould attatch to nodes has the smallest sum.\n",
    "hint": [
        "Hint 1 Why is bipartite coloring not always optimal?",
        "Hint 2 How good is a bipartite coloring actually?"
    ]
}