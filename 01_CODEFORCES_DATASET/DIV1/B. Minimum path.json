{"link": "https://codeforces.com//contest/1071/problem/B", "problemId": "240847", "problem_idx": "B", "shortId": "1071B", "contest_number": "1071", "problem_submissions": {"D": [44637237, 44635977, 44641232, 44642034, 44645226, 44644969, 44641119, 44687822, 44647598, 44647731, 44636247, 44657719, 44657573, 44656873, 44656778, 44656490, 44656434, 44656391, 44656371, 44656287, 44656203, 44656003, 44655947, 44655816, 44655752, 44655740, 44655723, 44655702, 44655688, 44655676, 44655623, 44655613, 44655594, 44655569, 44655560, 44655438, 44655419, 44655291, 44647784, 44642810, 44645755, 44645396, 44646118, 44644322, 44654399], "C": [44633806, 44636722, 44637213, 44636382, 44638429, 44646089, 44638832, 44640208, 44642096, 44639762, 44646904, 44636416, 44638641, 44637725], "B": [44628020, 44627991, 44628766, 44629645, 44629488, 44629819, 44628230, 44629653, 44629034, 44630394, 44631138, 44629791, 44632540, 44629581, 44629264, 44627767, 44636293, 44628785], "A": [44624756, 44630092, 44624598, 44626465, 44625487, 44624461, 44624565, 44624711, 44624763, 44626685, 44624210, 44625000, 44627102, 44624838, 44625068, 44629237, 44625506, 44625349], "E": [44647746, 45395419, 45395353, 44682935, 44682924]}, "name": "B. Minimum path", "statement": "You are given a matrix of size n\r\ntimes n filled with lowercase English letters. You can change no more\r\nthan k letters in this matrix.Consider all paths from the upper left\r\ncorner to the lower right corner that move from a cell to its\r\nneighboring cell to the right or down. Each path is associated with the\r\nstring that is formed by all the letters in the cells the path visits.\r\nThus, the length of each string is 2n - 1.Find the lexicographically\r\nsmallest string that can be associated with a path after changing\r\nletters in at most k cells of the matrix.A string a is lexicographically\r\nsmaller than a string b, if the first different letter in a and b is\r\nsmaller in a.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=2007;\nconst int inf=1e9;\n\nint n, k;\n\nchar tab[nax][nax];\n\nint dp[nax][nax];\nvector <pii> war[nax*2];\n\nvoid zbi(int &a, int b)\n{\n\ta=min(a, b);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%s\", tab[i]+1);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tdp[i][j]=inf;\n\tdp[1][1]=0;\n\tif (k && tab[1][1]!='a')\n\t{\n\t\tk--;\n\t\ttab[1][1]='a';\n\t}\n\tprintf(\"%c\", tab[1][1]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\twar[i+j].push_back({i, j});\n\tfor (int i=2; i<2*n; i++)\n\t{\n\t\tchar mini='z';\n\t\tfor (pii j : war[i])\n\t\t{\n\t\t\tint a=j.first;\n\t\t\tint b=j.second;\n\t\t\tif (dp[a][b]<=k)\n\t\t\t{\n\t\t\t\tif (a<n)\n\t\t\t\t\tmini=min(mini, tab[a+1][b]);\n\t\t\t\tif (b<n)\n\t\t\t\t\tmini=min(mini, tab[a][b+1]);\n\t\t\t}\n\t\t\tif (dp[a][b]<k)\n\t\t\t{\n\t\t\t\tmini='a';\n\t\t\t}\n\t\t}\n\t\tprintf(\"%c\", mini);\n\t\tfor (pii j : war[i])\n\t\t{\n\t\t\tint a=j.first;\n\t\t\tint b=j.second;\n\t\t\tif (dp[a][b]<=k)\n\t\t\t{\n\t\t\t\tif (a<n)\n\t\t\t\t\tzbi(dp[a+1][b], dp[a][b]+(tab[a+1][b]!=mini));\n\t\t\t\tif (b<n)\n\t\t\t\t\tzbi(dp[a][b+1], dp[a][b]+(tab[a][b+1]!=mini));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "greedy", "hashing"], "dificulty": "1900", "interactive": false}