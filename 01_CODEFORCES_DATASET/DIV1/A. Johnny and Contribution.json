{
    "link": "https://codeforces.com//contest/1361/problem/A",
    "problemId": "640968",
    "problem_idx": "A",
    "shortId": "1361A",
    "contest_number": "1361",
    "problem_submissions": {
        "F": [
            82547256,
            82558388,
            82548841,
            82560787,
            82546613,
            82571701,
            82569539,
            82568479,
            82553474,
            82561525
        ],
        "D": [
            82532533,
            82534707,
            82556057,
            82527759,
            82536652,
            82533679,
            82553972,
            82540929,
            82539127,
            82540566,
            86424872,
            82526480,
            82568104,
            82567738,
            82567880
        ],
        "E": [
            82521789,
            82543705,
            82541718,
            82540946,
            82583418,
            82541333,
            82541041,
            82533619,
            82550465,
            82553317,
            82579674,
            82579569,
            82559988,
            82559485,
            82543445,
            82543446,
            82551504,
            82544569,
            82550130,
            82547325,
            82579220,
            82517696
        ],
        "C": [
            82504494,
            82509183,
            82560689,
            82519634,
            82513804,
            82519054,
            82526119,
            82516120,
            82517904,
            82521411,
            82523427,
            82525691,
            82518977,
            82516229,
            82512604,
            82516960,
            82527524,
            82521519,
            82527700,
            82553581
        ],
        "B": [
            82495175,
            82498230,
            82507103,
            82567148,
            82501464,
            82497400,
            82516527,
            82498261,
            82504352,
            82509962,
            82510314,
            82502680,
            82509498,
            82502669,
            82499583,
            82499214,
            82513823,
            82505015,
            82504805,
            82531052
        ],
        "A": [
            82492363,
            82493600,
            82494974,
            82494327,
            82492565,
            82492329,
            82494389,
            82493605,
            82492642,
            82494930,
            82499298,
            82494769,
            82492795,
            82495342,
            82493416,
            82492640,
            82495622,
            82493415,
            82512573,
            82523180
        ]
    },
    "name": "A. Johnny and Contribution",
    "statement": "Today Johnny wants to increase his contribution. His plan assumes\r\nwriting n blogs. One blog covers one topic, but one topic can be covered\r\nby many blogs. Moreover, some blogs have references to each other. Each\r\npair of blogs that are connected by a reference has to cover different\r\ntopics because otherwise, the readers can notice that they are split\r\njust for more contribution. Set of blogs and bidirectional references\r\nbetween some pairs of them is called blogs network.There are n different\r\ntopics, numbered from 1 to n sorted by Johnny’s knowledge. The structure\r\nof the blogs network is already prepared. Now Johnny has to write the\r\nblogs in some order. He is lazy, so each time before writing a blog, he\r\nlooks at it’s already written neighbors (the blogs referenced to current\r\none) and chooses the topic with the smallest number which is not covered\r\nby neighbors. It’s easy to see that this strategy will always allow him\r\nto choose a topic because there are at most n - 1 neighbors.For example,\r\nif already written neighbors of the current blog have topics number 1,\r\n3, 1, 5, and 2, Johnny will choose the topic number 4 for the current\r\nblog, because topics number 1, 2 and 3 are already covered by neighbors\r\nand topic number 4 isn’t covered.As a good friend, you have done some\r\nresearch and predicted the best topic for each blog. Can you tell\r\nJohnny, in which order he has to write the blogs, so that his strategy\r\nproduces the topic assignment chosen by you?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 04.06.2020 17:34:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> t(n);\n  for (int i = 0; i < n; i++) {\n    cin >> t[i];\n    --t[i];\n  }\n  vector<int> order(n);\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&](int i, int j) {\n    return t[i] < t[j];\n  });\n  vector<int> was(n);\n  int T = 0;\n  for (int i : order) {\n    ++T;\n    int cnt = 0;\n    for (int j : g[i]) {\n      if (t[i] == t[j]) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      if (t[j] < t[i] && was[t[j]] != T) {\n        was[t[j]] = T;\n        cnt += 1;\n      }\n    }\n    if (cnt != t[i]) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << order[i] + 1;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Johnny and Contribution.json",
    "editorial_link": "https://codeforces.com//blog/entry/78355",
    "editorial": "We can view blogs as a graph, references as edges, and topics as colors.\r\nNow we can reformulate our problem as finding a permutation of vertices\r\nsuch that given in the statement greedy coloring algorithm returns\r\ncoloring as described in the input.Let us start with two observations:\r\nIf there is an edge between vertices with the same color, then the\r\nanswer is . If for a vertex with color there exist a color such that has\r\nno edge to any vertex with color then the answer is .Both observations\r\nare rather straightforward to prove, so we skip it. Let us create\r\npermutation where vertices are sorted firstly by desired color and\r\nsecondly by indices. We claim that if there exists any ordering\r\nfulfilling given regulations, then this permutation fulfills these too.\r\nLet us prove it:Let us analyze vertex with color . From observation we\r\nknow that for each color there exist with color such that and are\r\nconnected by an edge. Because vertices are sorted by colors in our\r\npermutation, is before in ordering. So the greedy algorithm will assign\r\nthat vertex color . From observation , we now that does not have an edge\r\nto vertex with color , so the greedy algorithm has to assign to color .\r\nCombining both inequalities, we reach that greedy must assign color ,\r\nwhich completes our proof.So now the algorithm is rather straightforward\r\nsort vertices by colors, check if that ordering fulfills given\r\nregulations, if so, then write it down, otherwise print . This can be\r\nimplemented in or .\r\n",
    "hint": []
}