{
    "link": "https://codeforces.com//contest/1329/problem/D",
    "problemId": "582576",
    "problem_idx": "D",
    "shortId": "1329D",
    "contest_number": "1329",
    "problem_submissions": {
        "E": [
            75408443,
            75525199,
            75525023,
            75681621,
            76019995,
            76016936,
            75967053,
            75966418
        ],
        "D": [
            75389063,
            75398925,
            75385191,
            75401307,
            75408075,
            75405008,
            75403445,
            75404364,
            75403371,
            75659972,
            75411387,
            75407920,
            75411250,
            75412465,
            75413663,
            75407247,
            75409435,
            75922378,
            75921522,
            75921098,
            75920566,
            75920416,
            75919758,
            75919734,
            75806069,
            75805925,
            75803536,
            75803307,
            75803058,
            75802910,
            75800662,
            75395261,
            75399040
        ],
        "C": [
            75374256,
            75371549,
            75396568,
            75381813,
            75372171,
            75376833,
            75380449,
            75377512,
            75386022,
            75659958,
            75378281,
            75378362,
            75487924,
            75487540,
            75487429,
            75487406,
            75386768,
            75380568,
            75386156,
            75382219,
            75387697,
            75369638,
            76036841,
            75372968,
            75421067
        ],
        "B": [
            75357516,
            75353754,
            75360937,
            75361445,
            75363313,
            75362516,
            75363699,
            75367490,
            75367087,
            75659949,
            75361718,
            75364241,
            75358119,
            75363158,
            75368163,
            75368647,
            75364635,
            75360193,
            76036829,
            75359511,
            75363649,
            75368965
        ],
        "A": [
            75354673,
            75356344,
            75356602,
            75357362,
            75359450,
            75355169,
            75357071,
            75359811,
            75354137,
            75659929,
            75354669,
            75356764,
            75372979,
            75355330,
            75359586,
            75360814,
            75615883,
            75354430,
            76036826,
            75355988,
            75360416,
            75354524
        ]
    },
    "name": "D. Dreamoon Likes Strings",
    "statement": "Dreamoon likes strings. Today he created a game about strings:String\r\ns_1, s_2,\r\nldots, s_n is if and only if for each 1\r\nle i < n, s_i\r\nne s_{i+1}.Initially, Dreamoon has a string a. In each step Dreamoon can\r\nchoose a substring of a and remove it. Then he should concatenate the\r\nremaining characters (in the same order).Dreamoon wants to use the\r\nsmallest number of steps to make a empty. Please help Dreamoon, and\r\nprint any sequence of the smallest number of steps to make a empty.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int A = 26;\nchar s[N];\nint n;\nint cnt[A];\nset<int> hv[A][A];\nset<int> setik;\npii ans[N];\nint ansSz;\nint fenv[N];\n\nvoid addFenv(int p, int x) {\n\tfor(; p < N; p |= p + 1)\n\t\tfenv[p] += x;\n}\nint getFenv(int r) {\n\tint res = 0;\n\tfor(; r >= 0; r = (r & (r + 1)) - 1)\n\t\tres += fenv[r];\n\treturn res;\n}\n\nvoid add(int x, int y) {\n\tint c1 = (int)(s[x] - 'a');\n\tint c2 = (int)(s[y] - 'a');\n\thv[c1][c2].insert(x);\n}\nvoid del(int x, int y) {\n\tint c1 = (int)(s[x] - 'a');\n\tint c2 = (int)(s[y] - 'a');\n\thv[c1][c2].erase(x);\n}\n\nvoid eraseSet(int x) {\n\tauto it = setik.lower_bound(x);\n\tif (*it != x) throw;\n\tint l = 0, r = n;\n\tif (it != setik.begin()) {\n\t\tit--;\n\t\tl = *it;\n\t\tit++;\n\t}\n\tit++;\n\tif (it != setik.end()) {\n\t\tr = *it;\n\t}\n\tif (l != 0) {\n\t\tdel(l, x);\n\t}\n\tif (r != n) {\n\t\tdel(x, r);\n\t}\n\tif (l != 0 && r != n) {\n\t\tadd(l, r);\n\t}\n\tsetik.erase(x);\n}\nvoid myErase(int x) {\n\tint y = n;\n\tauto it = setik.upper_bound(x);\n\tif (it != setik.end()) y = *it;\n\tint c1 = (int)(s[x] - 'a');\n\tint c2 = c1;\n\tif (y != n) c2 = (int)(s[y] - 'a');\n\tans[ansSz++] = mp(x, y);\n\tif (c1 != c2) {\n\t\tcnt[c1]--;\n\t\tcnt[c2]--;\n\t\teraseSet(x);\n\t\teraseSet(y);\n\t} else {\n\t\tcnt[c1]--;\n\t\teraseSet(x);\n\t}\n}\n\nvoid printAns() {\n\tprintf(\"%d\\n\", ansSz);\n\tfor (int i = 0; i <= n; i++)\n\t\tfenv[i] = 0;\n\tfor (int i = 0; i < ansSz; i++) {\n\t\tint l = ans[i].first, r = ans[i].second;\n\t\tl -= getFenv(l - 1);\n\t\tr -= getFenv(r - 1);\n\t\tprintf(\"%d %d\\n\", l + 1, r);\n\t\taddFenv(ans[i].first, r - l);\n\t}\n}\n\nvoid solve() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tsetik.clear();\n\tfor (int i = 0; i < A; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (s[i] != s[i - 1]) continue;\n\t\tif (!setik.empty()) {\n\t\t\tint lst = *setik.rbegin();\n\t\t\tadd(lst, i);\n\t\t}\n\t\tint c = (int)(s[i] - 'a');\n\t\tcnt[c]++;\n\t\tsetik.insert(i);\n\t}\n\tansSz = 0;\n\twhile(true) {\n\t\tint mc = 0;\n\t\tfor (int i = 0; i < A; i++)\n\t\t\tif (cnt[i] > cnt[mc])\n\t\t\t\tmc = i;\n\t\tif (cnt[mc] == (int)setik.size()) break;\n\t\tbool fnd = false;\n\t\tfor (int c = 0; c < A; c++) {\n\t\t\tif (c == mc) continue;\n\t\t\tif (!hv[c][mc].empty()) {\n\t\t\t\tmyErase(*hv[c][mc].begin());\n\t\t\t\tfnd = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!hv[mc][c].empty()) {\n\t\t\t\tmyErase(*hv[mc][c].begin());\n\t\t\t\tfnd = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(fnd);\n\t}\n\twhile(!setik.empty()) {\n\t\tint p = *setik.begin();\n\t\tmyErase(p);\n\t}\n\tans[ansSz++] = mp(0, n);\n\tprintAns();\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Dreamoon Likes Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/75559",
    "editorial": "Denoting a string of length two which contains two -th letter as . For\r\nexample, is \"aa\", is \"bb\" . And let be the occurrence count of as a\r\nsubstring in . For example, when \"aaabbcaa\", , and for other , .In this\r\nproblem, if only asking contestants output the smallest number of steps\r\nto make empty, the answer is simple. You just need to output . (I will\r\ncall this fomula for a given string as behind.)Firstly, letâs see how\r\nthe value of all change in one step. There are only four kinds of\r\npossible change for all .1. For some , is decreased by one. For example,\r\ndeleting the first two letters of \"abb\".2. For two different values and\r\n. and are both decrease by one. For example, deleting the second and\r\nthird letter of \"aabb\".3. Nothing changes for all . For example,\r\ndeleting the first letter from \"abb\".4. For some , is added by one. For\r\nexample, deleting the second letter from \"aba\".Now, Letâs consider how\r\nwill these changes affect the . Amazing! All possible changes will\r\ndecrease the value of at most one! So if we can construct an algorithm\r\nto achieve it, then we solve it.Now I introduce an algorithm of which\r\ntime complexity is .The algorithm can be divided into three phases.1.In\r\nthis phase, we maintain a stack that stores the position of substring in\r\nthe current string from left to right. When we iterate to a string ,\r\nthere are two cases. Assum the top element in the stack is . When is\r\nequal to , we just add t_i into the stack. But if , we do a step that\r\nremoving all letters from the second letter of to the first letter of .\r\nand pop from the stack. If there is any moment that is hold (So maybe\r\nyou wonât do anything in this phase), the phase will be terminated.2. In\r\nthis phase, there must be an unique satisifying .we also maintain a\r\nstack that stores the position of substring in the current string from\r\nleft to right. But when we iterate to a string , the action we should do\r\nare different from the first phase. Assum the top element in the stack\r\nis . When there is exactly one number among and is , we do a step that\r\nremoving all letters from the second letter of to the first letter of .\r\nand pop from the stack. Otherwise, we just add into the stack.3. When\r\nthe algorithm enters the phase, for all except , will be . So we can use\r\nall occurrence of to divide the string into segment and remove each\r\nsegment one by on. After that the string will become empty.Please see\r\nthe reference code for the implementation detail.\r\n",
    "hint": []
}