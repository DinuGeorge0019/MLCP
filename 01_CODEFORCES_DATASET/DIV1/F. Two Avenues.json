{
    "link": "https://codeforces.com//contest/1648/problem/F",
    "problemId": "1318594",
    "problem_idx": "F",
    "shortId": "1648F",
    "contest_number": "1648",
    "problem_submissions": {
        "E": [
            148585486,
            148584955,
            148581597,
            148589473,
            148591135,
            148593463,
            148593416,
            148597505,
            148594995,
            148595032,
            148597135,
            148605923,
            148598836,
            148596396,
            148600942,
            148602000,
            148600796,
            148581620,
            148583646,
            148661874,
            148661844,
            148587369
        ],
        "D": [
            148564585,
            148566578,
            148571497,
            148568116,
            148573822,
            148573519,
            148574211,
            148573964,
            148574945,
            148580191,
            148578139,
            148578497,
            148607894,
            148582725,
            148577475,
            148577301,
            148585962,
            148619534,
            148575997,
            148608357
        ],
        "C": [
            148552509,
            148552464,
            148553813,
            148558198,
            148558432,
            148554501,
            148557954,
            148555117,
            148558520,
            148556243,
            148554082,
            148553770,
            148555702,
            148554883,
            148560099,
            148557117,
            148552206,
            148558570,
            148554233,
            148559666
        ],
        "B": [
            148545010,
            148546110,
            148555976,
            148548495,
            148550449,
            148545480,
            148551044,
            148549564,
            148551420,
            148544796,
            148546968,
            148558793,
            148547056,
            148545781,
            148549549,
            148547973,
            148544722,
            148548048,
            148546238,
            148550231
        ],
        "A": [
            148541636,
            148541670,
            148541532,
            148543210,
            148543257,
            148541615,
            148546248,
            148544655,
            148547990,
            148541584,
            148542460,
            148542006,
            148542056,
            148542119,
            148542975,
            148543237,
            148541644,
            148542337,
            148541655,
            148542140
        ],
        "F": [
            148613542,
            151414821,
            211208832,
            211208769,
            211208727,
            211208586
        ]
    },
    "name": "F. Two Avenues",
    "statement": "In order to make the capital of Berland a more attractive place for\r\ntourists, the great king came up with the following plan: choose two\r\nstreets of the city and call them avenues. Certainly, these avenues will\r\nbe proclaimed extremely important historical places, which should\r\nattract tourists from all over the world.The capital of Berland can be\r\nrepresented as a graph, the vertices of which are crossroads, and the\r\nedges are streets connecting two crossroads. In total, there are n\r\nvertices and m edges in the graph, you can move in both directions along\r\nany street, you can get from any crossroad to any other by moving only\r\nalong the streets, each street connects two different crossroads, and no\r\ntwo streets connect the same pair of crossroads.In order to reduce the\r\nflow of ordinary citizens moving along the great avenues, it was decided\r\nto introduce a toll on each avenue in both directions. Now you need to\r\npay 1 tugrik for one passage along the avenue. You don\u2019t have to pay for\r\nthe rest of the streets.Analysts have collected a sample of k citizens,\r\ni-th of them needs to go to work from the crossroad a_i to the crossroad\r\nb_i. After two avenues are chosen, each citizen will go to work along\r\nthe path with minimal cost.In order to earn as much money as possible,\r\nit was decided to choose two streets as two avenues, so that the total\r\nnumber of tugriks paid by these k citizens is maximized. Help the king:\r\naccording to the given scheme of the city and a sample of citizens, find\r\nout which two streets should be made avenues, and how many tugriks the\r\ncitizens will pay according to this choice.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class t,class u>\nvoid print_offset(const pair<t,u>&p,ll off,int suc=1){\n\tprint(p.a+off,2);\n\tprint(p.b+off,suc);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\n//\u5185\u90e8\u3067\u30b0\u30e9\u30d5\u3092\u3044\u3058\u308b\u304b\u3089 in,out \u3092\u4f7f\u3046\u3068\u304d\u306f\u6ce8\u610f\n//hei[v] -> heavy edge \u3067\u6f5c\u3063\u3066\u3044\u3063\u305f\u6642\uff0c\u81ea\u5206\u542b\u3081\u3066\u4f55\u500b\u3042\u308b\u304b\n//pe[v]: v->par[v] \u306e\u8fba\u306e\u60c5\u5831\n//-\u6709\u5411\u6728\u306e\u3068\u304d\u306f\u4e0a\u304b\u3089\u4e0b\u306e\u8fba\u3092\u5165\u308c\u3066\u308b\n//-\u7121\u5411\u6728\u306e\u3068\u304d\u306f\u4e0b\u304b\u3089\u4e0a\u306e\u8fba\u3092\u5165\u308c\u3066\u308b\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep,hei,ni;\n\tvc<E> pe;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tfor(auto itr=g[v].bg;itr!=g[v].ed;itr++)\n\t\t\tif(*itr==p){\n\t\t\t\tpe[v]=*itr;\n\t\t\t\tg[v].erase(itr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(auto&e:g[v]){\n\t\t\tpe[e]=e;\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t\tif(si(g[v]))hei[v]=hei[g[v][0]]+1;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n),hei(n,1),ni(n),\n\t\tpe(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t\trep(i,n)ni[in[i]]=i;\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\t//CF692F\n\tint getpar(int v,int len){\n\t\tassert(dep[v]>=len);\n\t\tint tar=dep[v]-len;\n\t\twhile(1){\n\t\t\tint h=head[v];\n\t\t\tif(dep[h]<=tar){\n\t\t\t\treturn ni[in[h]+(tar-dep[h])];\n\t\t\t}\n\t\t\tv=par[h];\n\t\t}\n\t\tassert(false);\n\t}\n\t//XX Opencup GP of Korea\n\t//CF625 F\n\t//2020 Multi-Uni Contest Day5 G\n\t//CF415E\n\tvi index;\n\t//vs \u3092\u542b\u3080 virtual tree \u3092\u8fd4\u3059\n\t//\u8fd4\u3059\u306e\u306f virtual tree \u306b\u4f7f\u308f\u308c\u305f\u9802\u70b9\u3068\uff0c\u8fba\u306e\u96c6\u5408\n\t//\u8fba\u306e\u7aef\u70b9\u306f\uff0cvirtual tree \u306b\u304a\u3051\u308b\u756a\u53f7\n\t//\u5143\u306e\u6728\u306b\u304a\u3051\u308b\u756a\u53f7\u3092 virtual tree \u306e\u9802\u70b9\u756a\u53f7\u306b\u5199\u3059\u306e\u304c\uff0cindex \u3068\u3044\u3046\u5909\u6570\n\t//\u8fba\u306f ch->par \u306e\u9806\n\t//virtual tree \u306f\u884c\u304d\u639b\u3051\u9806\u3067\u756a\u53f7\u304c\u3064\u3044\u3066\u3044\u308b\n\t//\u7279\u306b\uff0c\u9802\u70b9 0 \u304c\u6839\u306b\u306a\u308b\u3088\u3046\u306b\u3067\u304d\u3066\u3044\u308b\n\tpair<vi,vc<pi>> tree_compress(vi vs){\n\t\tif(si(index)==0)index.resize(n);\n\t\tassert(index.size());\n\t\tauto comp = [&](int x,int y){\n\t\t\treturn in[x] < in[y];\n\t\t};\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tint k = vs.size();\n\t\trep(i,k-1){\n\t\t\tvs.pb(lca(vs[i],vs[i+1]));\n\t\t}\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tk = vs.size();\n\t\trep(i,k) index[vs[i]] = i;\n\t\tvc<pi> es;\n\t\trng(i,1,k){\n\t\t\tint p = lca(vs[i-1],vs[i]);\n\t\t\tes.eb(i,index[p]);\n\t\t}\n\t\treturn mp(vs,es);\n\t}\n\t//assume a is desdendant of b\n\t//ex=true <=> exclude b\n\ttemplate<class F>\n\tvoid subpath_work(int a,int b,bool ex,F f){\n\t\twhile(1){\n\t\t\tif(head[a]==head[b]){\n\t\t\t\tf(in[b]+ex,in[a]+1);\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tint h=head[a];\n\t\t\t\tf(in[h],in[a]+1);\n\t\t\t\ta=par[h];\n\t\t\t}\n\t\t}\n\t}\n\t//KUPC2021E\n\t//\u30d1\u30b9\u306b\u5bfe\u3059\u308b\u64cd\u4f5c\u9806\u306b\u6ce8\u610f\n\t//euler-tour \u9806\u306b\u3057\u305f\u3068\u304d\u306e\u533a\u9593\u306b\u4f5c\u7528\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u6ce8\u610f\n\t//ex=true exclude lca(a,b) (=apply path edges)\n\ttemplate<class F>\n\tvoid path_work(int a,int b,bool ex,F f){\n\t\tint c=lca(a,b);\n\t\tsubpath_work(a,c,ex,f);\n\t\tsubpath_work(b,c,true,f);\n\t}\n};\n\n//atcoder-library \u3092\u307e\u3042\u307e\u3042\u30b3\u30d4\u30fc\u3057\u3066\u4f7f\u3063\u3066\u3044\u308b\n\n//N() \u304c\u5358\u4f4d\u5143\n\n//merge \u3067\u7247\u65b9\u304c inactive \u306e\u3068\u304d\u306f\u3082\u3046\u7247\u65b9\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\uff0c\n//\u3068\u3044\u3063\u305f\u3068\u304d\u306b\uff0clazy \u306e\u60c5\u5831\u307e\u3067\u30b3\u30d4\u30fc\u3057\u3066\u6e21\u3055\u306a\u3044\u3088\u3046\u306b\u3059\u308b\n\n//get \u306e\u6700\u5f8c\u306e\u5f15\u6570\u306f\u5358\u4f4d\u5143\u3068\u53e3\u3067\u306f\u8a00\u3044\u3064\u3064\u30fb\u30fb\u30fb\uff1f\n//\u305f\u3068\u3048\u3070 min \u3067\u6700\u5f8c\u306e\u5f15\u6570\u3092 0 \u306b\u3057\u3066\u3082 1 \u3068\u304b\u304c\u8fd4\u3063\u3066\u304f\u308b\u3053\u3068\u306f\u3042\u308b\uff08\u4e00\u6557\uff09\n\n//VERIFY:\n//https://atcoder.jp/contests/practice2/tasks/practice2_k\ntemplate<class N>\nstruct seglazy{\n\tvc<N> x;\n\tint L,s;\n\tseglazy(){}\n\ttemplate<class T>\n\tseglazy(const vc<T>& a){\n\t\tint n=a.size();\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.resize(s*2);\n\t\trep(i,n)x[s+i]=N(a[i]);\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tvoid upd(int i){\n\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid push(int i){\n\t\tx[i].push(x[i*2],x[i*2+1]);\n\t}\n\tN composite(int l,int r){\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif(l==r)return N();\n\t\t\n\t\tl+=s;\n\t\tr+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tN sml,smr;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) sml = N::merge(sml, x[l++]);\n\t\t\tif (r & 1) smr = N::merge(x[--r], smr);\n\t\t\tl >>= 1;\n\t\t\tr >>= 1;\n\t\t}\n\n\t\treturn N::merge(sml, smr);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid ch(int l, int r, F f,Args&&... args) {\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif (l == r) return;\n\n\t\tl+=s;\n\t\tr+=s;\n\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tstatic int buf[2][30];\n\t\tint cnt[2]{};\n\t\t{\n\t\t\tint l2 = l, r2 = r;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1){\n\t\t\t\t\t//(x[l++].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[0][cnt[0]++]=l++;\n\t\t\t\t}\n\t\t\t\tif (r & 1){\n\t\t\t\t\t//(x[--r].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[1][cnt[1]++]=--r;\n\t\t\t\t}\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\tl = l2;\n\t\t\tr = r2;\n\t\t}\n\t\trep(i,cnt[0])(x[buf[0][i]].*f)(forward<Args>(args)...);\n\t\tper(i,cnt[1])(x[buf[1][i]].*f)(forward<Args>(args)...);\n\n\t\tfor (int i = 1; i <= L; i++) {\n\t\t\tif (((l >> i) << i) != l) upd(l >> i);\n\t\t\tif (((r >> i) << i) != r) upd((r - 1) >> i);\n\t\t}\n\t}\n\tN getall(){return x[1];}\n\ttemplate <class F,class... Args> \n\tpair<int,N> max_right(int l,F f,Args&&... args){\n\t\tassert(0<=l&&l<=s);\n\t\tif(l==s)return mp(s,N());\n\t\tl+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) push(l >> i);\n\t\tN sm;\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tdo {\n\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\tif (!(N::merge(sm,x[l]).*f)(forward<Args>(args)...)){\n\t\t\t\twhile (l < s) {\n\t\t\t\t\tpush(l);\n\t\t\t\t\tl = (2 * l);\n\t\t\t\t\tN tmp=N::merge(sm,x[l]);\n\t\t\t\t\tif ((tmp.*f)(forward<Args>(args)...)) {\n\t\t\t\t\t\tsm = tmp;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mp(l - s,sm);\n\t\t\t}\n\t\t\tsm = N::merge(sm, x[l]);\n\t\t\tl++;\n\t\t} while ((l & -l) != l);\n\t\treturn mp(s,sm);\n\t}\n\t//XXI Opencup Krakow M\n\ttemplate <class F,class... Args> \n\tpair<int,N> min_left(int r,F f,Args&&... args){\n\t\tassert(0<=r&&r<=s);\n        if(r==0)return mp(0,N());\n        r+=s;\n        for (int i = L; i >= 1; i--) push((r - 1) >> i);\n        N sm;\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!(N::merge(x[r],sm).*f)(forward<Args>(args)...)) {\n                while (r < s) {\n                    push(r);\n                    r = (2 * r + 1);\n                    N tmp=N::merge(x[r],sm);\n                    if ((tmp.*f)(forward<Args>(args)...)) {\n                        sm = tmp;\n                        r--;\n                    }\n                }\n                return mp(r + 1 - s,sm);\n            }\n            sm = N::merge(x[r], sm);\n        } while ((r & -r) != r);\n        return mp(0,sm);\n    }\n\ttemplate<class F,class...Args>\n\tvoid point_change(int p,F f,Args&&...args){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\t(x[p].*f)(forward<Args>(args)...);\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tN point_get(int p){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\treturn x[p];\n\t}\n\tvoid point_set(int p,N val){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\tx[p]=val;\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tvoid enumerater(int l,int r,int i,int b,int e,vc<N>&dst){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.pb(x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerater(l,m,i*2,b,e,dst);\n\t\tenumerater(m,r,i*2+1,b,e,dst);\n\t}\n\tvoid enumerate(int b,int e,vc<N>&dst){\n\t\tassert(b<=e);\n\t\treturn enumerater(0,s,1,b,e,dst);\n\t}\n};\n\n//Range add,min\nstruct N{\n\tll lz,mn;\n\tN(ll v=infLL):lz(0),mn(v){}\n\tvoid add(ll v){\n\t\tmn+=v;\n\t\tlz+=v;\n\t}\n\tvoid push(N&x,N&y){\n\t\tx.add(lz);\n\t\ty.add(lz);\n\t\tlz=0;\n\t}\n\tstatic N merge(N x,N y){\n\t\treturn N(min(x.getm(),y.getm()));\n\t}\n\tll getm(){return mn;}\n\tbool ok(ll v){\n\t\treturn mn>v;\n\t}\n};\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tvvc<int> g=readGraph(n,m);\n\tvvc<int> t(n),z(n);\n\t{\n\t\tvi vis(n);\n\t\tauto dfs=[&](auto self,int v,int p)->void{\n\t\t\tassert(vis[v]==0);\n\t\t\tvis[v]=1;\n\t\t\tfor(auto to:g[v])if(to!=p){\n\t\t\t\tif(vis[to]==0){\n\t\t\t\t\tt[v].pb(to);\n\t\t\t\t\tself(self,to,v);\n\t\t\t\t}else if(vis[to]==1){\n\t\t\t\t\tz[v].pb(to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis[v]=2;\n\t\t};\n\t\tdfs(dfs,0,-1);\n\t}\n\tHLD<int> hld(t,0);\n\t\n\tauto work=[&](vc<pi> ls){\n\t\tvi res(n);\n\t\tfor(auto [a,b]:ls){\n\t\t\tres[a]++;\n\t\t\tres[b]++;\n\t\t\tres[hld.lca(a,b)]-=2;\n\t\t}\n\t\tauto dfs=[&](auto self,int v)->void{\n\t\t\tfor(auto ch:t[v]){\n\t\t\t\tself(self,ch);\n\t\t\t\tres[v]+=res[ch];\n\t\t\t}\n\t\t};\n\t\tdfs(dfs,0);\n\t\treturn res;\n\t};\n\t\n\tint qnum;cin>>qnum;\n\tvc<pi> qs(qnum);\n\tvvc<int> qup(n);\n\trep(i,qnum){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tqs[i]=pi(a,b);\n\t\tint c=hld.lca(a,b);\n\t\tqup[a].pb(c);\n\t\tqup[b].pb(c);\n\t}\n\t\n\tvi pass=work(qs);\n\tvi block;\n\tvi cov(n,0);\n\tvc<pi> binfo(n);\n\t{\n\t\tvc<pi> tmp;\n\t\trep(i,n)for(auto j:z[i])tmp.eb(i,j);\n\t\tblock=work(tmp);\n\t\tsort(all(tmp),[&](pi a,pi b){return hld.dep[a.b]>hld.dep[b.b];});\n\t\tunionfind uf(n);\n\t\tfor(auto [from,to]:tmp){\n\t\t\tpi e(from,to);\n\t\t\tfrom=uf.find(from);\n\t\t\twhile(hld.dep[from]>hld.dep[to]){\n\t\t\t\tcov[from]=hld.dep[to];\n\t\t\t\tbinfo[from]=e;\n\t\t\t\tint p=uf.find(hld.par[from]);\n\t\t\t\tuf.unite(p,from);\n\t\t\t\tfrom=p;\n\t\t\t}\n\t\t}\n\t}\n\tusing A=array<int,2>;\n\tvc<A> zup(n,A{inf,inf});\n\tauto updzup=[&](int v,int d){\n\t\trep(k,2){\n\t\t\tif(d<zup[v][k])swap(d,zup[v][k]);\n\t\t}\n\t};\n\t{\n\t\tauto dfs=[&](auto self,int v)->void{\n\t\t\tfor(auto j:z[v])updzup(v,hld.dep[j]);\n\t\t\tfor(auto ch:t[v]){\n\t\t\t\tself(self,ch);\n\t\t\t\tupdzup(v,zup[ch][0]);\n\t\t\t}\n\t\t};\n\t\tdfs(dfs,0);\n\t}\n\t\n\tint ans=-1;\n\tpi e1,e2;\n\tauto updans=[&](int val,pi x,pi y){\n\t\tif(chmax(ans,val)){\n\t\t\te1=x;\n\t\t\te2=y;\n\t\t}\n\t};\n\t{\n\t\tint x[2]{-inf,-inf};\n\t\tpi e[2]{};\n\t\trng(i,1,n){\n\t\t\tint v=block[i]==0?pass[i]:0;\n\t\t\tpi cur=pi(i,hld.par[i]);\n\t\t\trep(k,2)if(v>x[k]){\n\t\t\t\tswap(v,x[k]);\n\t\t\t\tswap(cur,e[k]);\n\t\t\t}\n\t\t}\n\t\tupdans(x[0]+x[1],e[0],e[1]);\n\t}\n\trng(i,1,n)if(block[i]==1){\n\t\tupdans(pass[i],pi(i,hld.par[i]),binfo[i]);\n\t}\n\t\n\tseglazy<N> seg(vc<ll>(n,0));\n\t\n\tconst int V=1<<30;\n\t\n\tauto upd=[&](int v,int w){\n\t\tfor(auto up:qup[v]){\n\t\t\tseg.ch(hld.dep[up],hld.dep[v],&N::add,w*2);\n\t\t}\n\t};\n\t\n\tauto sub=[&](auto self,int v,int w)->void{\n\t\tupd(v,w);\n\t\tfor(auto ch:t[v])self(self,ch,w);\n\t};\n\t\n\tvc<pi> ebuf;\n\t\n\tauto dfs=[&](auto self,int v)->void{\n\t\tint p=hld.par[v];\n\t\tint ban;\n\t\tif(p!=-1){\n\t\t\tebuf.eb(v,p);\n\t\t\tban=zup[p][0];\n\t\t\tif(ban==zup[v][0])ban=zup[p][1];\n\t\t\tif(ban<hld.dep[p]){\n\t\t\t\tseg.ch(ban,hld.dep[p],&N::add,V);\n\t\t\t}\n\t\t\tseg.point_change(hld.dep[p],&N::add,-pass[v]);\n\t\t}\n\t\tint hc=si(t[v])?hld.g[v][0]:-1;\n\t\tfor(auto ch:hld.g[v]){\n\t\t\tif(ch!=hc){\n\t\t\t\tself(self,ch);\n\t\t\t}\n\t\t}\n\t\tif(hc!=-1)self(self,hc);\n\t\tif(p!=-1){\n\t\t\tupd(v,1);\n\t\t\tfor(auto ch:hld.g[v]){\n\t\t\t\tif(ch!=hc){\n\t\t\t\t\tsub(sub,ch,1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cov[v]<hld.dep[p]){\n\t\t\t\tll val=seg.composite(cov[v],hld.dep[p]).mn;\n\t\t\t\tll unko=pass[v]-val;\n\t\t\t\tif(ans<unko){\n\t\t\t\t\tint pos=seg.max_right(cov[v],&N::ok,val).a;\n\t\t\t\t\tupdans(unko,ebuf.back(),ebuf[pos]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ban<hld.dep[p]){\n\t\t\t\tseg.ch(ban,hld.dep[p],&N::add,-V);\n\t\t\t}\n\t\t\tseg.point_change(hld.dep[p],&N::add,pass[v]);\n\t\t\tebuf.pop_back();\n\t\t}\n\t\tif(hld.head[v]==v){\n\t\t\tsub(sub,v,-1);\n\t\t}\n\t};\n\tdfs(dfs,0);\n\t\n\tprint(ans);\n\tprint_offset(e1,1);\n\tprint_offset(e2,1);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Two Avenues.json",
    "editorial_link": "https://codeforces.com//blog/entry/100592",
    "editorial": "Let\u00e2\u0080\u0099s consider two edges from the answer , . At least one of them should\r\nlie on dfs tree, otherwise the graph will be connected after removing ,\r\nand the answer will be .Let the answer be , , where lies on dfs tree.\r\nWhat cases can be for edges , ? The edge should be a bridge of the graph\r\nwithout edge (otherwise can be any). Using this we can highlight\r\npossible cases: Both edges , are bridges of the graph. The edge is the\r\nbridge of the graph, the edge does not matter. The edge lies on dfs\r\ntree, the edge is the only outer edge covering the edge . Both edges ,\r\nlies on dfs tree, sets of outer edges covering , and covering are equal.\r\nFor each case let\u00e2\u0080\u0099s find the maximum answer.For each of pairs of\r\nvertices let\u00e2\u0080\u0099s consider the path between vertices in the pair.For each\r\nedge of dfs tree let\u00e2\u0080\u0099s calculate three values: the number of paths,\r\ncontaining the edge . the number of outer edges, covering the edge . the\r\nhash of all outer edges, covering the edge . For each outer edge let\u00e2\u0080\u0099s\r\ngive random -bit integer, the hash will be equal to the sum of values.\r\nIn the first case, the answer for two bridges , is equal to . So we\r\nshould find two brides with maximum value .In the second case, the\r\nanswer for one bridge is equal to . So we should find the bridge with\r\nmaximum value .In the third case, we consider edges , such that . The\r\nanswer is . So we should find edge of dfs tree, such that with maximum\r\nvalue .The fourth case is very hard. We consider two edges , , such that\r\n. The answer is equal to the number of paths, containing exactly one\r\nedge from , . We can divide each path into two vertical paths, the\r\nanswer won\u00e2\u0080\u0099t change.The plan of the solution will be: let\u00e2\u0080\u0099s make a dfs\r\nof the dfs tree and maintain the segment tree with operations add on\r\nsegment, and maximum on segment. The prefix of the segment tree\r\ncorresponds to edges on the path from the root to the current edge . The\r\nvalue in the cell corresponding to the edge is equal to the answer for\r\nthe pair of edges , .It is possible to recalculate this segment tree\r\nwith updates during the dfs tree traversal.The unsolved problem now is\r\nhow to consider only edges , such that in the maximum on segment. Let\u00e2\u0080\u0099s\r\ncall a cluster all edges with equal hash. All edges from one cluster lie\r\non the vertical path. Let\u00e2\u0080\u0099s consider the vertical path for each cluster:\r\nfrom the first occurrence of edge from the cluster to the last\r\noccurrence of edge from the cluster. Any two paths for two clusters\r\neither do not intersect or nested into each other.When making a\r\ntraversal let\u00e2\u0080\u0099s add on the segment from the last edge with hash to the\r\nedge . This move will exclude edges from the maximum. This won\u00e2\u0080\u0099t\r\ninterfere the values, because all hashes from the segment won\u00e2\u0080\u0099t be found\r\nlater in the traversal (due to the clusters structure). After that,\r\nlet\u00e2\u0080\u0099s find the maximum on the segment from the first edge with hash to\r\nthe edge . In that maximum all edges with the hash will participate.The\r\ntotal solution has the complexity .\r\n"
}