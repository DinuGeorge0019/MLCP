{
    "link": "https://codeforces.com//contest/788/problem/E",
    "problemId": "100725",
    "problem_idx": "E",
    "shortId": "788E",
    "contest_number": "788",
    "problem_submissions": {
        "E": [
            25924862,
            25925377,
            25915904,
            25922582,
            25915050,
            25918684,
            25941153,
            25921354,
            25925269,
            25935314,
            25926533,
            25926046,
            25936552,
            25927749,
            25926831,
            25919133,
            25921191
        ],
        "D": [
            25915542,
            25915181,
            25939395,
            25930075,
            25941576,
            25921672,
            25929951,
            25917640,
            25923984,
            26061916,
            26104610,
            25928092,
            25925001,
            25924944,
            26043257
        ],
        "C": [
            25904961,
            25906051,
            25905059,
            25908402,
            25906489,
            25909800,
            25905943,
            25913627,
            25910389,
            25907305,
            25913724,
            25911198,
            25913363,
            25908585,
            25910198,
            25909085,
            25915912,
            25913369,
            25907071,
            25907012
        ],
        "B": [
            25903079,
            25903720,
            25902453,
            25904332,
            25903705,
            25904849,
            25903086,
            25902909,
            25905715,
            25902462,
            25905159,
            25905547,
            25906945,
            25904624,
            25903809,
            25910532,
            25906509,
            25927693,
            25946077
        ],
        "A": [
            25900169,
            25901048,
            25900244,
            25901169,
            25900572,
            25900694,
            25900718,
            25900816,
            25901339,
            25905048,
            25900137,
            25900587,
            25901139,
            25902041,
            25900581,
            25899979,
            25900864,
            25900329,
            25900280,
            25900541
        ]
    },
    "name": "E. New task",
    "statement": "On the 228-th international Uzhlyandian Wars strategic game tournament\r\nteams from each country are called. The teams should consist of\r\nparticipants.The team of Uzhlyandia will consist of soldiers, because\r\nthere are no gamers.Masha is a new minister of defense and gaming. The\r\nprime duty of the minister is to calculate the efficiency of the\r\nUzhlandian army. The army consists of soldiers standing in a row,\r\nenumerated from to . For each soldier we know his in Uzhlyandian Wars:\r\nthe -th soldier’s skill is .It was decided that the team will consist of\r\nthree players and two assistants. The skills of players should be same,\r\nand the assistants’ skills should not be greater than the players’\r\nskill. Moreover, it is important for Masha that one of the assistants\r\nshould stand in the row to the left of the players, and the other one\r\nshould stand in the row to the right of the players. Formally, a team is\r\nfive soldiers with indexes , , , , , such that and . The efficiency of\r\nthe army is the number of different teams Masha can choose. Two teams\r\nare considered different if there is such such that the -th soldier is a\r\nmember of one team, but not a member of the other team.Initially, all\r\nplayers are able to be players. For some reasons, sometimes some\r\nsoldiers become unable to be players. Sometimes some soldiers, that were\r\nunable to be players, become able to be players. At any time any soldier\r\nis able to be an assistant. Masha wants to control the efficiency of the\r\narmy, so she asked you to tell her the number of different possible\r\nteams modulo () after each change.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nvoid precalc() {\n}\n\nstruct V {\n  int cnt;\n  int suma, sumb;\n  int dsuma, dsumb;\n\n  V() : cnt(0), suma(0), sumb(0), dsuma(0), dsumb(0) {}\n  V(int a, int b) : cnt(1), suma(a), sumb(b), dsuma(0), dsumb(0) {}\n\n  V(const V &l, const V &r) {\n    cnt = l.cnt + r.cnt;\n    suma = sum(l.suma, r.suma);\n    sumb = sum(l.sumb, r.sumb);\n    dsuma = sum(l.dsuma, r.dsuma);\n    dsumb = sum(l.dsumb, r.dsumb);\n    add(dsuma, mult(l.suma, r.cnt));\n    add(dsumb, mult(r.sumb, l.cnt));\n  }\n};\n\nstruct T {\n  int n;\n\n  int *ca, *cb;\n  V *a;\n  bool *ison;\n\n  T(vector<int> &a_, vector<int> &b_, int &res) {\n    assert(sz(a_) == sz(b_));\n    if (0) {\n      eprintf(\"sz = %d\\n\", sz(a_));\n      for (int i = 0; i < sz(a_); ++i) {\n        eprintf(\"%d,%d\\n\", a_[i], b_[i]);\n      }\n    }\n    for (n = 1; n < sz(a_); n <<= 1) ;\n    a = new V[2 * n - 1];\n    --a;\n\n    ca = new int[n];\n    cb = new int[n];\n    ison = new bool[n];\n\n    for (int i = 0; i < n; ++i) {\n      if (i < sz(a_)) {\n        ca[i] = a_[i];\n        cb[i] = b_[i];\n      } else {\n        ca[i] = cb[i] = 0;\n      }\n      ison[i] = 0;\n    }\n\n    for (int i = 1; i < 2 * n; ++i) {\n      a[i] = V();\n    }\n\n    for (int i = 0; i < sz(a_); ++i) {\n      int toadd = get(i);\n      //eprintf(\"add %d\\n\", toadd);\n      add(res, toadd);\n      change(i, 1);\n    }\n  }\n\n  V get(int v, int l, int r, int l0, int r0) {\n    if (l >= r0 || l0 >= r) {\n      return V();\n    }\n\n    if (l0 <= l && r <= r0) {\n      return a[v];\n    }\n\n    int m = (l + r) / 2;\n    return V(get(2 * v, l, m, l0, r0), get(2 * v + 1, m, r, l0, r0));\n  }\n\n  V get(int l, int r) {\n    return get(1, 0, n, l, r);\n  }\n\n  int get(int x) {\n    auto left = get(0, x);\n    auto right = get(x + 1, n);\n    int res = 0;\n    add(res, mult(ca[x], right.dsumb));\n    add(res, mult(cb[x], left.dsuma));\n    add(res, mult(left.suma, right.sumb));\n    return res;\n  }\n\n  void change(int x, int nval) {\n    assert(ison[x] != nval);\n    ison[x] = nval;\n    if (nval) {\n      a[x + n] = V(ca[x], cb[x]);\n    } else {\n      a[x + n] = V();\n    }\n    x += n;\n\n    for (x /= 2; x; x /= 2) {\n      a[x] = V(a[2 * x], a[2 * x + 1]);\n    }\n  }\n};\n\n\nconst int maxn = (int) 1e5 + 10;\nint a[maxn];\nint n, m;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  scanf(\"%d\", &m);\n  return 1;\n}\n\nstruct FTree {\n  int n;\n  int a[maxn];\n\n  void build(int n_) {\n    n = n_;\n    for (int i = 0; i < n; ++i) {\n      a[i] = 0;\n    }\n  }\n\n  void add(int x, int toadd) {\n    for (; x < n; x |= (x + 1)) {\n      a[x] += toadd;\n    }\n  }\n\n  int get(int x) {\n    int res = 0;\n    for (; x >= 0; x = (x & (x + 1)) - 1) {\n      res += a[x];\n    }\n    return res;\n  }\n} ftree;\n\npair<int, int> tosort[maxn];\n\nint b[maxn];\n\nint cnts[2][maxn];\n\nint ids[maxn];\n\nvoid solve() {\n  for (int i = 0; i < n; ++i) {\n    tosort[i] = mp(a[i], i);\n  }\n  sort(tosort, tosort + n);\n\n  int cnt = 0;\n  for (int i = 0; i < n;) {\n    int i0 = i;\n\n    while (i < n && tosort[i].first == tosort[i0].first) {\n      b[tosort[i].second] = cnt;\n      ++i;\n    }\n    ++cnt;\n  }\n\n\n  for (int iter = 0; iter < 2; ++iter) {\n    ftree.build(cnt);\n    for (int ri = 0; ri < n; ++ri) {\n      int i = ri;\n      if (iter) {\n        i = n - 1 - i;\n      }\n\n      int y = b[i];\n      cnts[iter][i] = ftree.get(y);\n      ftree.add(y, 1);\n    }\n  }\n\n  int res = 0;\n\n  map<int, T*> tree;\n  for (int i = 0; i < n;) {\n    int i0 = i;\n\n    while (i < n && tosort[i].first == tosort[i0].first) {\n      ++i;\n    }\n\n    vector<int> as(i - i0);\n    vector<int> bs(i - i0);\n    for (int j = i0; j < i; ++j) {\n      int pos = tosort[j].second;\n      ids[pos] = j - i0;\n      as[j - i0] = cnts[0][pos];\n      bs[j - i0] = cnts[1][pos];\n    }\n    tree[tosort[i0].first] = new T(as, bs, res);\n  }\n\n  for (int iter = 0; iter < m; ++iter) {\n    int type, x;\n    scanf(\"%d%d\", &type, &x);\n    --type;\n    --x;\n\n    auto &t = *(tree[a[x]]);\n\n    if (!type) {\n      t.change(ids[x], 0);\n    }\n\n    int delta = t.get(ids[x]);\n    if (!type) {\n      add(res, mod - delta);\n    } else {\n      add(res, delta);\n    }\n\n    if (type) {\n      t.change(ids[x], 1);\n    }\n\n    printf(\"%d\\n\", res);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. New task.json",
    "editorial_link": "https://codeforces.com//blog/entry/51312",
    "editorial": "To begin with, we apply scaling to all numbers and replace each element\r\nof the array with its position in the sorted array.Count the answer for\r\nthe original array. For each , calculate as the quantity of such that ,\r\nand the number of such that , . This can be done with a segment tree or\r\na Fenwick tree. If we consider each element as from the command , then\r\nthe answer for fives with this is . The common answer is the sum of the\r\nanswers for each possible . Now after each request we will update the\r\nanswer. We will support for each type of number for the prefix and\r\nsuffix for 2 segment tree. Since when, an element turns on/off it is\r\nimportant to know only information about elements with the same value,\r\nthen you can update the answer using only it. Consider array b as a\r\nnumber vector of occurrences of the form .In the first \"suffix tree\" in\r\nthe sheet we store , if the element with the number is included,\r\notherwise 0, and in the remaining vertices the sum in the sons. In the\r\nsecond suffix tree we store in the sheet ((the number , such that , ,\r\nelement with the number is included) + 1), if the element with the\r\nnumber is included, otherwise 0, and in the remaining vertices the sum\r\nin the sons.For the prefix, you need to do exactly the same thing.Let be\r\nthe number of numbers of the form .Now when the request for turning\r\noff/on the element with number came, we need to subtract/add to the\r\nanswer the number of such pentads [, , , , ] where , , . Further ((the\r\nquantity , , ) + 1). In other words, is the number in the occurrence\r\nvector of numbers of the form ). First, consider the number of fives\r\nwhere . Them is (the sum on the interval [1;-1] in the first prefix\r\ntree) (the sum on the segment [+1;] in the first \"suffix tree\").The\r\nnumber of fives where is ((the sum on the segment [+2;] in the second\r\n\"suffix tree\" segments) - ((the number of elements j, , , the element\r\nwith the number is included) +1) (the sum on the segment [+2;] in the\r\nfirst \"suffix tree\" segments )). The number of fives where must be\r\ncalculated in the same way as for , only in the other direction.: When\r\nthe item is turned off, you need: Take the sum on the segment [+1;] in\r\nthe second segment tree in the same segment in the first tree. Assign\r\nthe element with the number to the element in the second segments tree\r\n0. Assign the element with the number in the first tree 0. When you\r\nenable an item, you need: Add on the segment [+1;] in the second segment\r\ntree the sum on the same line in the first tree. Assign the element with\r\nthe number in the second tree (the number of such , , , the element j is\r\nincluded) + 1). Assign the element with the number in the first tree .\r\nThe update in the tree with the prefix is the same.Adding on the segment\r\nwill be done by a kind of lazy pushing in the second segment tree you\r\nneed to have access to the corresponding vertex of the first tree, when\r\nchanging the vertex, add/subtract the sum at the top of the first\r\nsegment tree.The complexity of the solution is by time, by memory.\r\n",
    "hint": []
}