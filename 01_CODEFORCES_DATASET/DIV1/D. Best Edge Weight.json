{"link": "https://codeforces.com//contest/827/problem/D", "problemId": "113848", "problem_idx": "D", "shortId": "827D", "contest_number": "827", "problem_submissions": {"F": [28447535, 28704912], "B": [28442493, 28434829, 28432891, 28434941, 28434124, 28440743, 28434219, 28434038, 28435758, 28436170, 28442340, 28436191, 28436588, 28434003, 28436389, 28434757, 28437055, 28448594, 28438989], "C": [28440487, 28438660, 28438441, 28438938, 28437666, 28446435, 28437809, 28439569, 28439405, 28439836, 28438472, 28441170, 28440770, 28437931, 28442353, 28442274, 28441410, 28437286, 28455031, 28442955], "E": [28436548, 28441080, 28466758, 28444795, 28441962, 28439200, 28445462, 28450329, 28446470, 28443820, 28444149, 28441607, 28444424, 28451564, 28465030, 28453083, 28453061, 28452855, 28445979, 28445398, 28447328, 28450262, 28443711, 28447639], "A": [28432871, 28432173, 28431465, 28433215, 28452981, 28437424, 28432872, 28451754, 28432696, 28432687, 28432382, 28432827, 28432606, 28431751, 28435184, 28437702, 28433063, 28446111, 28434053], "D": [28445554, 28441989, 28447486, 28446928, 28441195, 28445740, 28448719, 28454047, 28460505, 28543175, 28454400, 28446342, 28447977, 29638472, 28445305, 28443739]}, "name": "D. Best Edge Weight", "statement": "You are given a connected weighted graph with vertices and edges. The\r\ngraph doesn\u2019t contain loops nor multiple edges. Consider some edge with\r\nid . Let\u2019s determine for this edge the maximum integer weight we can\r\ngive to it so that it is contained in all minimum spanning trees of the\r\ngraph if we don\u2019t change the other weights.You are to determine this\r\nmaximum weight described above for each edge. You should calculate the\r\nanswer for each edge independently, it means there can\u2019t be two edges\r\nwith changed weights at the same time.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int inf=(1<<30);\nconst int N=201000;\nint n,m,f[N],u,v,w,dep[N],ret[N];\nvector<VI> E,Ew;\nvector<PII> e[N];\nint mark[N],p[N][20],pe[N][20],pid[N];\nvoid dfs(int u,int f) {\n\tdep[u]=dep[f]+1;\n\tfor (auto w:e[u]) {\n\t\tint v=w.fi;\n\t\tif (v==f) continue;\n\t\tp[v][0]=u;\n\t\tpid[v]=w.se;\n\t\tpe[v][0]=Ew[pid[v]][0];\n\t\tdfs(v,u);\n\t}\n}\nint find(int x) {\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\n#define LOGN 18\n\nint lca(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tint mv=0;\n\tper(i,0,LOGN) if (dep[p[v][i]]>=dep[u]) mv=max(mv,pe[v][i]),v=p[v][i];\n\tif (u==v) return mv;\n\tper(i,0,LOGN) if (p[v][i]!=p[u][i]) mv=max(mv,max(pe[u][i],pe[v][i])),u=p[u][i],v=p[v][i];\n\treturn max(mv,max(pe[u][0],pe[v][0]));\n}\n\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n+1) f[i]=i;\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tE.pb(VI{w,u,v,i});\n\t\tEw.pb(VI{w,u,v,i});\n\t}\n\tsort(all(E));\n\trep(i,0,m) {\n\t\tint id=E[i][3],u=E[i][2],v=E[i][1];\n\t\tif (find(u)!=find(v)) {\n\t\t\tmark[id]=1;\n\t\t\te[u].pb(mp(v,id)); e[v].pb(mp(u,id));\n\t\t\tf[find(u)]=find(v);\n\t\t}\n\t}\n\tdfs(1,0);\n\trep(j,1,LOGN) {\n\t\trep(i,1,n+1) {\n\t\t\tp[i][j]=p[p[i][j-1]][j-1];\n\t\t\tpe[i][j]=max(pe[i][j-1],pe[p[i][j-1]][j-1]);\n\t\t}\n\t}\n\trep(i,1,n+1) f[i]=i;\n\trep(i,0,m) ret[i]=inf;\n\trep(i,0,m) {\n\t\tint id=E[i][3],u=E[i][2],v=E[i][1];\n\t\tif (!mark[id]) {\n\t\t\tret[id]=lca(u,v);\n\t\t\twhile (1) {\n\t\t\t\tu=find(u);\n\t\t\t\tv=find(v);\n\t\t\t\tif (u==v) break;\n\t\t\t\tif (dep[v]>dep[u]) swap(u,v);\n\t\t\t\tret[pid[u]]=E[i][0];\n\t\t\t\tf[u]=find(p[u][0]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,m) {\n\t\tif (ret[i]==inf) ret[i]=0;\n\t\tprintf(\"%d\\n\",ret[i]-1);\n\t}\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "graphs", "trees"], "dificulty": "2700", "interactive": false}