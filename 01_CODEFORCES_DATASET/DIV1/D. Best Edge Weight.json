{
    "link": "https://codeforces.com//contest/827/problem/D",
    "problemId": "113848",
    "problem_idx": "D",
    "shortId": "827D",
    "contest_number": "827",
    "problem_submissions": {
        "F": [
            28447535,
            28704912
        ],
        "B": [
            28442493,
            28434829,
            28432891,
            28434941,
            28434124,
            28440743,
            28434219,
            28434038,
            28435758,
            28436170,
            28442340,
            28436191,
            28436588,
            28434003,
            28436389,
            28434757,
            28437055,
            28448594,
            28438989
        ],
        "C": [
            28440487,
            28438660,
            28438441,
            28438938,
            28437666,
            28446435,
            28437809,
            28439569,
            28439405,
            28439836,
            28438472,
            28441170,
            28440770,
            28437931,
            28442353,
            28442274,
            28441410,
            28437286,
            28455031,
            28442955
        ],
        "E": [
            28436548,
            28441080,
            28466758,
            28444795,
            28441962,
            28439200,
            28445462,
            28450329,
            28446470,
            28443820,
            28444149,
            28441607,
            28444424,
            28451564,
            28465030,
            28453083,
            28453061,
            28452855,
            28445979,
            28445398,
            28447328,
            28450262,
            28443711,
            28447639
        ],
        "A": [
            28432871,
            28432173,
            28431465,
            28433215,
            28452981,
            28437424,
            28432872,
            28451754,
            28432696,
            28432687,
            28432382,
            28432827,
            28432606,
            28431751,
            28435184,
            28437702,
            28433063,
            28446111,
            28434053
        ],
        "D": [
            28445554,
            28441989,
            28447486,
            28446928,
            28441195,
            28445740,
            28448719,
            28454047,
            28460505,
            28543175,
            28454400,
            28446342,
            28447977,
            29638472,
            28445305,
            28443739
        ]
    },
    "name": "D. Best Edge Weight",
    "statement": "You are given a connected weighted graph with vertices and edges. The\r\ngraph doesn\u2019t contain loops nor multiple edges. Consider some edge with\r\nid . Let\u2019s determine for this edge the maximum integer weight we can\r\ngive to it so that it is contained in all minimum spanning trees of the\r\ngraph if we don\u2019t change the other weights.You are to determine this\r\nmaximum weight described above for each edge. You should calculate the\r\nanswer for each edge independently, it means there can\u2019t be two edges\r\nwith changed weights at the same time.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int inf=(1<<30);\nconst int N=201000;\nint n,m,f[N],u,v,w,dep[N],ret[N];\nvector<VI> E,Ew;\nvector<PII> e[N];\nint mark[N],p[N][20],pe[N][20],pid[N];\nvoid dfs(int u,int f) {\n\tdep[u]=dep[f]+1;\n\tfor (auto w:e[u]) {\n\t\tint v=w.fi;\n\t\tif (v==f) continue;\n\t\tp[v][0]=u;\n\t\tpid[v]=w.se;\n\t\tpe[v][0]=Ew[pid[v]][0];\n\t\tdfs(v,u);\n\t}\n}\nint find(int x) {\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\n#define LOGN 18\n\nint lca(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tint mv=0;\n\tper(i,0,LOGN) if (dep[p[v][i]]>=dep[u]) mv=max(mv,pe[v][i]),v=p[v][i];\n\tif (u==v) return mv;\n\tper(i,0,LOGN) if (p[v][i]!=p[u][i]) mv=max(mv,max(pe[u][i],pe[v][i])),u=p[u][i],v=p[v][i];\n\treturn max(mv,max(pe[u][0],pe[v][0]));\n}\n\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n+1) f[i]=i;\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tE.pb(VI{w,u,v,i});\n\t\tEw.pb(VI{w,u,v,i});\n\t}\n\tsort(all(E));\n\trep(i,0,m) {\n\t\tint id=E[i][3],u=E[i][2],v=E[i][1];\n\t\tif (find(u)!=find(v)) {\n\t\t\tmark[id]=1;\n\t\t\te[u].pb(mp(v,id)); e[v].pb(mp(u,id));\n\t\t\tf[find(u)]=find(v);\n\t\t}\n\t}\n\tdfs(1,0);\n\trep(j,1,LOGN) {\n\t\trep(i,1,n+1) {\n\t\t\tp[i][j]=p[p[i][j-1]][j-1];\n\t\t\tpe[i][j]=max(pe[i][j-1],pe[p[i][j-1]][j-1]);\n\t\t}\n\t}\n\trep(i,1,n+1) f[i]=i;\n\trep(i,0,m) ret[i]=inf;\n\trep(i,0,m) {\n\t\tint id=E[i][3],u=E[i][2],v=E[i][1];\n\t\tif (!mark[id]) {\n\t\t\tret[id]=lca(u,v);\n\t\t\twhile (1) {\n\t\t\t\tu=find(u);\n\t\t\t\tv=find(v);\n\t\t\t\tif (u==v) break;\n\t\t\t\tif (dep[v]>dep[u]) swap(u,v);\n\t\t\t\tret[pid[u]]=E[i][0];\n\t\t\t\tf[u]=find(p[u][0]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,m) {\n\t\tif (ret[i]==inf) ret[i]=0;\n\t\tprintf(\"%d\\n\",ret[i]-1);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Best Edge Weight.json",
    "editorial_link": "https://codeforces.com//blog/entry/53268",
    "editorial": "Find MST in the initial graph and name it . Now there are edges of two\r\ntypes: in the tree, and not in the tree. Process them in a different\r\nway. For edges not in the MST, the answer is the maximum weight of MST\r\nedges on the path between the edge\u00e2\u0080\u0099s ends, minus one.Proof: Consider the\r\nedge such that it doesn\u00e2\u0080\u0099t appear in our MST and its weight is and\r\nconsider the maximum weight of MST edges on the path between the edge\u00e2\u0080\u0099s\r\nends is .It\u00e2\u0080\u0099s obvious that if there is an MST such that will not appear\r\nin that (at least it will not appear in ).Now let\u00e2\u0080\u0099s prove that if it\r\nwill appear in any MST. Consider an MST like that does not appear in\r\nthat, let\u00e2\u0080\u0099s prove was not an MST and it\u00e2\u0080\u0099s a contradiction. Let ends of\r\nbe . Look, consider the path between in , there is an edge with weight\r\nin this path but there isn\u00e2\u0080\u0099t any edge in with weight greater than or\r\nequal to . So is not an MST because when we build an MST we sort edges\r\nby their weight and add them greedily (Kruskal\u00e2\u0080\u0099s algorithm). For an edge\r\nin the MST, let non-MST edges such that MST path between their ends go\r\nthrough be bad edges, the answer is the minimum weight of bad edges,\r\nminus one.Proof: Let the minimum weight of bad edges be and weight of be\r\n. It is obvious that if there is an MST such that will not appear in\r\nthat. Now if so we will check before bad edges and we will add it.The\r\nremaining part is easy: for non-MST edges, one can just query the\r\nmaximum on a tree path with binary lifts or whatever other structure on\r\na tree. For MST edges, we can do the same, but in the other direction,\r\nlike range queries, or even easier with centroid decomposition, HLD or\r\nusing sets and the smaller-to-larger optimization.\r\n"
}