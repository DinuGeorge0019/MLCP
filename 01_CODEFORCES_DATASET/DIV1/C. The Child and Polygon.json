{
    "link": "https://codeforces.com//contest/438/problem/C",
    "problemId": "9965",
    "problem_idx": "C",
    "shortId": "438C",
    "contest_number": "438",
    "problem_submissions": {
        "D": [
            6770791,
            6768533,
            6771704,
            6771558,
            6772564,
            6771497,
            6770667,
            6772913,
            6771311,
            6770765,
            6771398,
            6772501,
            6771788,
            6773163,
            6773332,
            6768886,
            6769122
        ],
        "C": [
            6769384,
            6771772,
            6770600,
            6769986,
            6769707,
            6770322,
            6773155,
            6770624,
            6772819,
            6772764,
            6772925,
            6771300,
            6773617,
            6772385,
            6771439,
            6774162
        ],
        "B": [
            6766623,
            6766692,
            6766851,
            6766923,
            6766505,
            6769047,
            6767842,
            6768520,
            6767461,
            6766938,
            6767311,
            6768462,
            6767303,
            6769160,
            6766952,
            6767030,
            6767555
        ],
        "A": [
            6765683,
            6765687,
            6765701,
            6765754,
            6767149,
            6765703,
            6766656,
            6766754,
            6766105,
            6765753,
            6765896,
            6765923,
            6765796,
            6768072,
            6766138,
            6765696,
            6765784
        ],
        "E": [
            6784450,
            6784415,
            39812196,
            39812172,
            6951957
        ]
    },
    "name": "C. The Child and Polygon",
    "statement": "This time our child has a simple polygon. He has to find the number of\r\nways to split the polygon into non-degenerate triangles, each way must\r\nsatisfy the following requirements: each vertex of each triangle is one\r\nof the polygon vertex; each side of the polygon must be the side of\r\nexactly one triangle; the area of intersection of every two triangles\r\nequals to zero, and the sum of all areas of triangles equals to the area\r\nof the polygon; each triangle must be completely inside the polygon; .\r\nThe picture below depicts an example of a correct splitting. Please,\r\nhelp the child. Calculate the described number of ways modulo for him.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME \"\"\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\" #x \"] Time = %.3lfs\\n\",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef linux\n#define LLD \"%lld\"\n#else\n#define LLD \"%I64d\"\n#endif\n\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst double INF = inf;\nconst double EPS = eps;\n\nconst int mod = inf+7;\n\ninline void madd (int& a, int b)\n{\n  a+=b;\n  if (a>=mod)\n    a-=mod;\n}\n\nint mul (int a, int b)\n{\n  return (a*1ll*b)%mod;\n}\n\npii operator - (const pii& a, const pii& b)\n{\n  return mp(a.first-b.first,a.second-b.second);\n}\n                         \nll operator ^ (const pii& a, const pii& b)\n{\n  return a.first*1ll*b.second-a.second*1ll*b.first;\n}\n\nint n;\n//bool can[210][210];\nint D[210][210];\npii P[410];\nll S[210][210][210];\n\ninline bool check (int a, int b, int c)\n{\n  //cerr<<a<<\" \"<<b<<\" \"<<c<<endl;\n  int i;\n  ll s=S[a][b][c];\n  for (i=0; i<a; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  for (i=a+1; i<b; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  for (i=b+1; i<c; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  for (i=c+1; i<n; i++)\n    if (S[a][b][i]+S[b][c][i]+S[c][a][i]==s)\n      return 0;\n  //cerr<<a<<\" \"<<b<<\" \"<<c<<endl;\n  return 1;\n}\n\nint main()\n{\n  int i, j, len, k;//l, r;\n  #ifdef LOCAL\n  freopen(TASKNAME\".in\",\"r\",stdin);\n  freopen(TASKNAME\".out\",\"w\",stdout);\n  #endif\n  scanf(\"%d\", &n);\n  for (i=0; i<n; i++)\n    scanf(\"%d%d\", &P[i].first, &P[i].second);\n  for (i=n-1; i>=0; i--)\n    P[i]=P[i]-P[0];\n  ll s=0;\n  for (i=1; i<n-1; i++)\n    s+=(P[i]^P[i+1]);\n  if (s<0)\n    reverse(P+1,P+n);\n  for (i=0; i<n; i++)\n    P[i+n]=P[i];\n  for (i=0; i<n; i++)\n    for (j=0; j<n; j++)\n      for (k=0; k<n; k++)\n        S[i][j][k]=abs((P[i]-P[k])^(P[j]-P[k]));\n  //TIMESTAMP(cs);\n  /*for (i=0; i<n; i++)\n    for (j=0; j<n; j++)\n      if (i!=j)\n      {\n        can[i][j]=1;\n        pii diff=P[j]-P[i];\n        if (i<j)\n          l=i+1, r=j;\n        else\n          l=i+1, r=j+n;\n        while (l<r)\n        {\n          if (((P[l]-P[i])^diff)<=0)\n          {\n            can[i][j]=0;\n            break;\n          }\n          l++;\n        }\n        //cerr<<i<<\" \"<<j<<\" \"<<can[i][j]<<endl;\n      }   */\n  for (i=0; i<n-1; i++)\n    D[i][i+1]=1;\n  for (len=2; len<n; len++)\n    for (i=0; i+len<n; i++)\n    {\n      for (j=i+1; j<i+len; j++)\n      {\n        if (check(i,j,i+len))\n          madd(D[i][i+len],mul(D[i][j],D[j][i+len]));\n      }\n      //cerr<<len<<\" \"<<i<<\" \"<<D[[j]\n    }\n  printf(\"%d\\n\", D[0][n-1]);\n  TIMESTAMP(end);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "geometry"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. The Child and Polygon.json",
    "editorial_link": "https://codeforces.com/blog/entry/12513",
    "editorial": "In this problem, you are asked to count the triangulations of a simple polygon.\n\nFirst we label the vertex of polygon from 0 to n?-?1.\n\nThen we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)\n\nIf the line segment (i,?j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.\n\nOtherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i,?k,?j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.\n\nFinally,the answer is f[0][n?-?1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.",
    "hint": []
}