{
    "link": "https://codeforces.com//contest/1349/problem/C",
    "problemId": "619061",
    "problem_idx": "C",
    "shortId": "1349C",
    "contest_number": "1349",
    "problem_submissions": {
        "D": [
            79861873,
            79861806,
            79948658,
            79858494,
            79903166,
            131108532,
            79877857,
            79879188,
            79879019,
            79872081,
            80757765,
            79874857,
            79891331
        ],
        "C": [
            79835117,
            79843720,
            79834387,
            79845607,
            79830281,
            79843236,
            79849443,
            79848794,
            79845617,
            79852466,
            79831253,
            79854349,
            79853472,
            79844058,
            79856498,
            79879255,
            79856862,
            79848324,
            79861537
        ],
        "B": [
            79827155,
            79837122,
            79822255,
            79821907,
            79838530,
            79834646,
            79835497,
            79841171,
            79842066,
            79829421,
            79839013,
            79841661,
            79841348,
            79839739,
            79833357,
            79841018,
            79840476,
            79842544,
            79837256,
            79834808
        ],
        "A": [
            79817454,
            79821533,
            79816750,
            79834360,
            79820968,
            90907998,
            90906860,
            90496887,
            79817368,
            94393615,
            79825623,
            79828847,
            79817688,
            79819374,
            79828023,
            79820779,
            79831851,
            79831246,
            79823300,
            79821494,
            79829816,
            79823411,
            79929306,
            79822107
        ],
        "E": [
            85193181,
            79886501,
            80023736
        ],
        "F2": [
            81605329,
            85716790,
            84837609,
            84835671,
            80416603,
            80415302,
            80161085
        ],
        "F1": [
            79982046,
            79890867,
            79859528,
            80154258,
            79886462,
            79874667,
            79884418,
            79878453,
            79892295,
            79881330,
            79892657,
            79875367,
            79882448,
            79932700
        ]
    },
    "name": "C. Orac and Game of Life",
    "statement": "Orac likes games. Recently he came up with the new game, \"\".You should\r\nplay this game on a black and white grid with n rows and m columns. Each\r\ncell is either black or white.For each iteration of the game (the\r\ninitial iteration is 0), the color of each cell will change under the\r\nfollowing rules: If there are no adjacent cells with the same color as\r\nthis cell on the current iteration, the color of it on the next\r\niteration will be the same. Otherwise, the color of the cell on the next\r\niteration will be different.Two cells are adjacent if they have a mutual\r\nedge.Now Orac has set an initial situation, and he wants to know for the\r\ncell (i,j) (in i-th row and j-th column), what will be its color at the\r\niteration p. He may ask you these questions several times.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll INF = (ll)2e18;\nconst int N = 1010;\nchar s[N][N];\nint n, m;\nconst int DX[] = {-1, 1, 0, 0};\nconst int DY[] = {0, 0, -1, 1};\nll dist[N][N];\npii q[N * N];\nint topQ;\n\nbool checkCell(int x, int y) {\n\treturn 0 <= x && x < n && 0 <= y && y <= m;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%s\", s[i]);\n\tfor (int x = 0; x < n; x++)\n\t\tfor (int y = 0; y < m; y++) {\n\t\t\tdist[x][y] = INF;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint xx = x + DX[i], yy = y + DY[i];\n\t\t\t\tif (!checkCell(xx, yy)) continue;\n\t\t\t\tif (s[xx][yy] == s[x][y]) dist[x][y] = 0;\n\t\t\t}\n\t\t\tif (dist[x][y] == 0) q[topQ++] = mp(x, y);\n\t\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint x = q[i].first, y = q[i].second;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint xx = x + DX[j], yy = y + DY[j];\n\t\t\tif (!checkCell(xx, yy)) continue;\n\t\t\tif (dist[xx][yy] <= dist[x][y] + 1) continue;\n\t\t\tdist[xx][yy] = dist[x][y] + 1;\n\t\t\tq[topQ++] = mp(xx, yy);\n\t\t}\n\t}\n\twhile(k--) {\n\t\tint x, y;\n\t\tll t;\n\t\tscanf(\"%d%d%lld\", &x, &y, &t);\n\t\tx--;y--;\n\t\tchar ans = s[x][y];\n\t\tif (t >= dist[x][y] && (t - dist[x][y]) % 2 == 1) ans ^= 1;\n\t\tprintf(\"%c\\n\", ans);\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Orac and Game of Life.json",
    "editorial_link": "https://codeforces.com//blog/entry/77284",
    "editorial": "A cell is said to be if and only if there is a cell adjacent to which\r\nhas the same color to . If a cell is not good, it is said to be .\r\nTherefore, the color of a cell changes after a turn if and only if the\r\ncell is good.According to the definition, any cell never changes its\r\ncolor if every cell is bad. Also, a good cell would never turn into a\r\nbad cell .For a bad cell , if there is a good cell adjacent to , will\r\nturn into a good cell after a turn because currently has a different\r\ncolor from and the color of will change after a turn but the color of\r\nwonât change; otherwise, after a turn, the color of and cells adjacent\r\nto stays the same, so is still bad.For a cell , let be the number of\r\nturns needed for that becomes a good cell. According to the paragraph\r\nabove, equals to the minimal Manhattan distance from to a good cell.\r\nTherefore, can be figured out by BFS. Notice that for , the color of\r\nstays the same after the -th turn; for , the color of changes after the\r\n-th turn. Therefore, each query can be processed with time complexity.\r\nThe total time complexity is .\r\n",
    "hint": []
}