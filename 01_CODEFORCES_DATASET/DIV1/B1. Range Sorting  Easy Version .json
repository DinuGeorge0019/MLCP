{
    "link": "https://codeforces.com//contest/1827/problem/B1",
    "problemId": "1922410",
    "problem_idx": "B1",
    "shortId": "1827B1",
    "contest_number": "1827",
    "problem_submissions": {
        "B1": [
            205909125,
            205871229,
            205860094,
            205853484,
            205858214,
            205884799,
            205855785,
            205857268,
            205859721,
            205854125,
            205853990,
            205854393,
            205857685,
            205856108,
            205871852,
            205864517,
            205849753,
            205856355,
            206036248,
            205883111,
            205857458,
            205852308
        ],
        "C": [
            205887704,
            205865086,
            205862189,
            205877784,
            205865401,
            205880693,
            205873972,
            205883370,
            205896807,
            205874900,
            205883582,
            205869590,
            205872529,
            205865317,
            205875560,
            205870203,
            205870915,
            206036332,
            205857923,
            205878002,
            205869836
        ],
        "E": [
            205882857,
            205890682,
            205893722,
            205893207,
            205891321,
            205895989,
            205901490,
            205897572,
            205894529,
            205889627,
            205900528,
            205921803,
            205921497,
            205921364,
            205921183,
            205920554,
            205920187,
            205928602,
            205907318,
            205907019,
            205906136,
            205905793,
            205905368,
            205905221,
            205903986
        ],
        "B2": [
            205871376,
            205860123,
            205854465,
            205857731,
            205884857,
            205854446,
            205857708,
            205859949,
            205855049,
            205892922,
            205864074,
            205856597,
            205855367,
            205871926,
            205864651,
            205863717,
            205856284,
            206036255,
            205889062,
            205869038,
            205876542
        ],
        "D": [
            205863885,
            205875931,
            205878262,
            205884073,
            205878863,
            205877520,
            205881913,
            205884050,
            205871773,
            205899731,
            205892557,
            205885814,
            205881313,
            205883473,
            205884864,
            205888365,
            205888201,
            206036361,
            205877449,
            205886393,
            205963414,
            205889611
        ],
        "A": [
            205845172,
            205844037,
            205843466,
            205843847,
            205844462,
            205843511,
            205844799,
            205845695,
            205844273,
            205843867,
            205845548,
            205843654,
            205843208,
            205846139,
            205845358,
            205843530,
            206036234,
            205846931,
            205848794,
            205843958
        ],
        "F": [
            207299235,
            207299224,
            207299166,
            207299023,
            207298779,
            207298502,
            207298128
        ]
    },
    "name": "B1. Range Sorting  Easy Version ",
    "statement": "You are given an array a, consisting of n distinct integers a_1, a_2,\r\nldots, a_n. Define the of an array p_1, p_2,\r\nldots p_k as the minimum amount of time needed to sort this array using\r\nan arbitrary number of operations. In each range-sort operation, you\r\nwill do the following: Choose two integers l and r (1\r\nle l < r\r\nle k). Sort the subarray p_l, p_{l + 1},\r\nldots, p_r in r - l seconds. Please calculate the sum of beauty over all\r\nsubarrays of array a.A subarray of an array is defined as a sequence of\r\nconsecutive elements of the array.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = int64_t;\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor(int& x : A) cin >> x;\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tvector<pair<int,int> > cur = {};\n\t\tfor(int j = i; j < N; j++){\n\t\t\tpair<int, int> v = {A[j], A[j]};\n\t\t\twhile(!cur.empty() && cur.back().second >= v.first){\n\t\t\t\tv.first = min(v.first, cur.back().first);\n\t\t\t\tv.second = max(v.second, cur.back().second);\n\t\t\t\tcur.pop_back();\n\t\t\t}\n\t\t\tcur.push_back(v);\n\t\t\tans += (j-i+1) - (int)cur.size();\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "dsu",
        "greedy",
        "trees",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B1. Range Sorting  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/116109",
    "editorial": "Let a[l..r]\n denotes the subarray al,al+1,,ar\n.\n\nObservation 1: In an optimal sequence of operations for one subarray, there will be no two operations that intersect each other. In other words, a subarray will be divided into non-overlapping subarrays, and we will apply a range-sort operation to each subarray.\n\nProof: Suppose there are two operations [l1,r1]\n and [l2,r2]\n that intersect each other, we can replace them with one operation [min(l1,l2),max(r1,r2)]\n which does not increase the cost.\n\nObservation 2: Consider k\n positions l?i1<i2<<ik<r\n, then we can sort subarrays a[l..i1],\n a[i1+1..i2],\n ,\n a[ik+1..r]\n independently iff max(a[l..ix])<min(a[ix+1..r])\n for all 1?x?k\n.\n\nProof: The obvious necessary and sufficient condition required to sort subarrays a[l..i1],\n a[i1+1..i2],\n ,\n a[ik+1..r]\n independently is max(a[ix?1+1..ix])<min(a[ix+1..ix+1])\n for all 1?x?k\n, here we denote x0=l?1\n and xk+1=r\n. It is not hard to prove that this condition is equal to the one stated above.\n\nWith these observations, we can conclude that the answer for a subarray a[l..r]\n equals the r?l\n minus the number of positions k\n such that l?k<r\n and max(a[l..k])<min(a[k+1..r])\n (?)\n. Let us analyze how to calculate the sum of this value over all possible l\n and r\n.\n\nConsider a position i\n (1?i?n\n), let's count how many triplets (l,k,r)\n satisfy (?)\n and min(a[k+1..r])=ai\n. It means that k\n must be the closest position to the left of i\n satisfying ak<ai\n. Denotes x\n as the closest position to the left of k\n such that ax>ai\n, and y\n as the closest position to the right of i\n such that ay<ai\n.\n\nWe can see that a triplet (l,k,r)\n with x<l?k\n and i?r<y\n will match our condition. In other words, we will add to the answer (k?x)?(y?i)\n.\n\nIn the easy version, we can find such values of x,k,y\n for each i\n in O(n)\n and end up with a total complexity of O(n2)\n. We can further optimize the algorithm by using sparse table and binary lifting and achieve a time complexity of O(nlogn)\n, which is enough to solve the hard version.",
    "hint": []
}