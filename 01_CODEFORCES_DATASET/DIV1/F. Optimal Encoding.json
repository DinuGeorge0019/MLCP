{"link": "https://codeforces.com//contest/1508/problem/F", "problemId": "958786", "problem_idx": "F", "shortId": "1508F", "contest_number": "1508", "problem_submissions": {"D": [113258208, 113225842, 113232066, 113242382, 113242310, 113248310, 113252824, 113256393, 113240058, 113236672, 113233206, 113240165, 113242005, 113242817, 113243142], "F": [113247954, 113415583, 113275748, 113263512, 113569093, 113516939], "C": [113237315, 113213039, 113214478, 113213780, 113212574, 113213010, 113224842, 113226169, 113232722, 113215825, 113215542, 113224987, 113223453, 113228420, 113228228, 113217788, 113226078, 113229271, 113230097], "E": [113228353, 113239041, 113241831, 113228851, 113231701, 113244425, 113243109, 113247201, 113253919, 113253035, 113238610, 113246155, 113333091, 113246539, 113240797, 113246922], "A": [113201428, 113189518, 113189456, 113190605, 113198010, 113192641, 113194080, 113204739, 113207875, 113194317, 113200012, 113222414, 113194745, 113195037, 113199971, 113199286, 113193286, 113195565, 113191574, 113194231], "B": [113197951, 113196658, 113192904, 113196665, 113201215, 113199153, 113202442, 113210198, 113217372, 113203624, 113208530, 113197629, 113206458, 113203987, 113206383, 113212945, 113200476, 113197819, 113199529, 113200558]}, "name": "F. Optimal Encoding", "statement": "Touko\u2019s favorite sequence of numbers is a permutation a_1, a_2,\r\ndots, a_n of 1, 2,\r\ndots, n, and she wants some collection of permutations that are similar\r\nto her favorite permutation.She has a collection of q intervals of the\r\nform [l_i, r_i] with 1\r\nle l_i\r\nle r_i\r\nle n. To create permutations that are similar to her favorite\r\npermutation, she coined the following definition: A permutation b_1,\r\nb_2,\r\ndots, b_n allows an interval [l\u2019, r\u2019] to if for any pair of integers (x,\r\ny) such that l\u2019\r\nle x < y\r\nle r\u2019, we have b_x < b_y if and only if a_x < a_y. A permutation b_1,\r\nb_2,\r\ndots, b_n is if b allows all intervals [l_i, r_i] for all 1\r\nle i\r\nle k to hold their shapes. Yuu wants to figure out all k-similar\r\npermutations for Touko, but it turns out this is a very hard task;\r\ninstead, Yuu will the set of all k-similar permutations with directed\r\nacylic graphs (DAG). Yuu also coined the following definitions for\r\nherself: A permutation b_1, b_2,\r\ndots, b_n a DAG G\u2019 if for all edge u\r\nto v in G\u2019, we must have b_u < b_v. A is a DAG G_k on the set of\r\nvertices 1, 2,\r\ndots, n such that a permutation b_1, b_2,\r\ndots, b_n satisfies G_k if and only if b is k-similar. Since Yuu is free\r\ntoday, she wants to figure out the minimum number of edges among all\r\nk-encodings for each k from 1 to q.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N, Q; cin >> N >> Q;\n\tvector<int> A(N); for (auto& a : A) { cin >> a; a--; }\n\tvector<int> leftmost(N); iota(leftmost.begin(), leftmost.end(), 0);\n\tstruct vert_dat {\n\t\tpair<int, int> prv_pred;\n\t\tpair<int, int> prv_succ;\n\t\tpair<int, int> nxt_pred;\n\t\tpair<int, int> nxt_succ;\n\t};\n\tvector<vert_dat> verts(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tverts[i].prv_pred = {-1, -1};\n\t\tverts[i].prv_succ = {N, -1};\n\t\tverts[i].nxt_pred = {-1, -1};\n\t\tverts[i].nxt_succ = {N, -1};\n\t}\n\n\tint ans = 0;\n\tfor (int q = 0; q < Q; q++) {\n\t\tint L, R; cin >> L >> R; L--;\n\t\tint b = R;\n\t\twhile (leftmost[b-1] > L) b--;\n\t\tfor (; b < R; b++) {\n\t\t\tassert(b > L && leftmost[b-1] <= L);\n\t\t\twhile (leftmost[b] > L) {\n\t\t\t\tleftmost[b]--;\n\t\t\t\tint a = leftmost[b];\n\t\t\t\t// insert the a-b constraint\n\t\t\t\tif (A[a] < A[b] && A[b] < verts[a].nxt_succ.first) {\n\t\t\t\t\tif (verts[a].nxt_succ.second != -1) {\n\t\t\t\t\t\tint c = verts[a].nxt_succ.second;\n\t\t\t\t\t\tverts[c].prv_pred.second = -1;\n\t\t\t\t\t\tans--;\n\t\t\t\t\t}\n\t\t\t\t\tverts[a].nxt_succ = {A[b], b};\n\t\t\t\t\tif (verts[b].prv_pred.second != -1) {\n\t\t\t\t\t\tint c = verts[b].prv_pred.second;\n\t\t\t\t\t\tverts[c].nxt_succ.second = -1;\n\t\t\t\t\t\tans--;\n\t\t\t\t\t}\n\t\t\t\t\tverts[b].prv_pred = {A[a], a};\n\t\t\t\t\tans++;\n\t\t\t\t} else if (A[a] > A[b] && A[b] > verts[a].nxt_pred.first) {\n\t\t\t\t\tif (verts[a].nxt_pred.second != -1) {\n\t\t\t\t\t\tint c = verts[a].nxt_pred.second;\n\t\t\t\t\t\tverts[c].prv_succ.second = -1;\n\t\t\t\t\t\tans--;\n\t\t\t\t\t}\n\t\t\t\t\tif (verts[b].prv_succ.second != -1) {\n\t\t\t\t\t\tint c = verts[b].prv_succ.second;\n\t\t\t\t\t\tverts[c].nxt_pred.second = -1;\n\t\t\t\t\t\tans--;\n\t\t\t\t\t}\n\t\t\t\t\tverts[a].nxt_pred = {A[b], b};\n\t\t\t\t\tverts[b].prv_succ = {A[a], a};\n\t\t\t\t\tans++;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures"], "dificulty": "3500", "interactive": false}