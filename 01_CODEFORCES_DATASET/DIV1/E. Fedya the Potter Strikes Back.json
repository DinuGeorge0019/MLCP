{
    "link": "https://codeforces.com//contest/1286/problem/E",
    "problemId": "509644",
    "problem_idx": "E",
    "shortId": "1286E",
    "contest_number": "1286",
    "problem_submissions": {
        "E": [
            68277312,
            68282070,
            68274194,
            68303699,
            68303260,
            68305269,
            68280891,
            68275520,
            68485018,
            68484885,
            68281607,
            68589901,
            71865785,
            101133015,
            68300396
        ],
        "C2": [
            68266879,
            68290041,
            68261617,
            68262301,
            68264579,
            68294367,
            68270650,
            68281404,
            68295029,
            68426335,
            68286377,
            68264588,
            68267031
        ],
        "D": [
            68263572,
            68264108,
            68884999,
            68884847,
            68884788,
            68283246,
            68268908,
            68270542,
            68266913,
            68271305,
            68294377,
            68276847,
            68262972,
            68265436,
            68273176,
            68274949,
            68277188,
            68266253,
            68271981,
            68278589,
            68338459,
            68281162,
            68264815
        ],
        "C1": [
            68253495,
            68254635,
            68259019,
            68259783,
            68260037,
            68294288,
            68263649,
            68253659,
            68276644,
            68259313,
            68260800,
            68257683,
            68278462,
            68275645,
            68260838,
            68264488,
            68260121
        ],
        "B": [
            68249656,
            68250720,
            68252206,
            68250842,
            68249851,
            68249360,
            68294267,
            68254854,
            68250823,
            68250630,
            68252322,
            68250475,
            68253134,
            68252948,
            68253877,
            68249986,
            68255559,
            68256077,
            68252468,
            68253101,
            68252113
        ],
        "A": [
            68245108,
            68248019,
            68248101,
            68248225,
            68245837,
            68246154,
            68294224,
            68250492,
            68248558,
            68247246,
            68248005,
            68247110,
            68249600,
            68246667,
            68250822,
            68253310,
            68252365,
            68251609,
            68247685,
            68248520,
            68246550
        ],
        "F": [
            68288717,
            68426651,
            68284858,
            68284592,
            68283300,
            68321599,
            68593980,
            68272947,
            68281697,
            68274721,
            75028012
        ]
    },
    "name": "E. Fedya the Potter Strikes Back",
    "statement": "Fedya has a string S, initially empty, and an array W, also initially\r\nempty.There are n queries to process, one at a time. Query i consists of\r\na lowercase English letter c_i and a nonnegative integer w_i. First, c_i\r\nmust be appended to S, and w_i must be appended to W. The answer to the\r\nquery is the sum of for all subsegments of W [L,\r\nR], (1\r\nleq L\r\nleq R\r\nleq i).We define the of a subsegment as follows: if the substring of S\r\ncorresponding to this subsegment (that is, a string of consecutive\r\ncharacters from L-th to R-th, inclusive) matches the prefix of S of the\r\nsame length (that is, a substring corresponding to the subsegment [1,\r\nR - L + 1]), then its suspiciousness is equal to the minimum in the\r\narray W on the [L,\r\nR] subsegment. Otherwise, in case the substring does not match the\r\ncorresponding prefix, the suspiciousness is 0.Help Fedya answer all the\r\nqueries before the orderlies come for him!\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 601000\n#define SZ 1048576\nusing namespace std;\nint w[N_], oto[N_], par[N_][20];\nchar p[N_];\nint n, st[N_][2];\nlong long ans;\n\nstruct Tree {\n\tlong long S[SZ + SZ];\n\tint C[SZ + SZ], K[SZ + SZ];\n\n\tvoid init() {\n\t\tfor (int i = 0; i < SZ + SZ; i++)K[i] = -1;\n\t}\n\n\tvoid UDT(int nd) {\n\t\tS[nd] = S[nd * 2] + S[nd * 2 + 1];\n\t\tC[nd] = C[nd * 2] + C[nd * 2 + 1];\n\t}\n\tvoid Put2(int nd, int x) {\n\t\tK[nd] = x;\n\t\tS[nd] = (long long)C[nd] * x;\n\t}\n\tvoid Spread(int nd) {\n\t\tif (K[nd] != -1) {\n\t\t\tPut2(nd * 2, K[nd]);\n\t\t\tPut2(nd * 2 + 1, K[nd]);\n\t\t}\n\t\tK[nd] = -1;\n\t}\n\n\tvoid Off(int nd, int b, int e, int x) {\n\t\tif (b == e) {\n\t\t\tC[nd] = 0;\n\t\t\tS[nd] = 0;\n\t\t\treturn;\n\t\t}\n\t\tSpread(nd);\n\t\tint m = (b + e) >> 1;\n\t\tif(x<=m)Off(nd * 2, b, m, x);\n\t\telse Off(nd * 2 + 1, m + 1, e, x);\n\t\tUDT(nd);\n\t}\n\tvoid On(int nd, int b, int e, int x) {\n\t\tif (b == e) {\n\t\t\tC[nd] = 1;\n\t\t\tS[nd] = 0;\n\t\t\treturn;\n\t\t}\n\t\tSpread(nd);\n\t\tint m = (b + e) >> 1;\n\t\tif (x <= m)On(nd * 2, b, m, x);\n\t\telse On(nd * 2 + 1, m + 1, e, x);\n\t\tUDT(nd);\n\t}\n\tvoid Put(int nd, int b, int e, int s, int l, int x) {\n\t\tif (s > l)return;\n\t\tif (s <= b && e <= l) {\n\t\t\tPut2(nd, x);\n\t\t\treturn;\n\t\t}\n\t\tSpread(nd);\n\t\tint m = (b + e) >> 1;\n\t\tif (s <= m)Put(nd * 2, b, m, s, l, x);\n\t\tif (l > m)Put(nd * 2 + 1, m + 1, e, s, l, x);\n\t\tUDT(nd);\n\t}\n\n}T;\n\n\n\n\n\nvoid Go(int a, int b, int len) {\n\tint i;\n\tfor (i = 19; i >= 0; i--) if (par[a][i] > par[b][i])a = par[a][i], b = par[b][i];\n\tif (par[b][0] == 0) {\n\t\treturn;\n\t}\n\ta = par[a][0], b = par[b][0];\n\twhile (b >= a && b) {\n\t\tT.Off(1, 1, n, len - b);\n\t\tb = par[b][0];\n\t}\n\tif (a&&b) {\n\t\tGo(a, b, len);\n\t}\n\n}\n\nint main() {\n\tchar pp[3];\n\tint i, j, top = 0;\n\tscanf(\"%d\", &n);\n\toto[0] = -1;\n\tT.init();\n\tlong long mask = (1 << 30) - 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", pp);\n\t\tlong long a;\n\t\tscanf(\"%lld\", &a);\n\t\tpp[0] = (pp[0] - 'a' + ans) % 26 + 'a';\n\t\ta = (ans&mask) ^ a;\n\t\tw[i] = a;\n\t\tp[i - 1] = pp[0];\n\t\tint t = oto[i - 1];\n\t\twhile (t != -1 && p[i - 1] != p[t]) t = oto[t];\n\t\toto[i] = t + 1;\n\n\t\twhile (top && st[top][0] >= w[i]) top--;\n\t\ttop++;\n\t\tst[top][0] = w[i];\n\t\tst[top][1] = i;\n\t\tif (p[0] == p[i - 1]) {\n\t\t\tT.On(1, 1, n, i);\n\t\t}\n\t\tT.Put(1, 1, n, st[top - 1][1] + 1, i, w[i]);\n\n\t\tpar[i][0] = oto[i];\n\t\tfor (j = 0; j < 19; j++)par[i][j + 1] = par[par[i][j]][j];\n\t\tGo(i, i - 1, i);\n\n\t\tans += T.S[1];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "strings"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Fedya the Potter Strikes Back.json",
    "editorial_link": "https://codeforces.com//blog/entry/72867",
    "editorial": "Let be the answer for the moment after queries. Then, is equal to the\r\nsum of suspiciousness of suffixes of the string after queries. If we\r\ncalculate , will be the prefix sums of this array.Letâs maintain the KMP\r\ntree of the string. Each vertex of the tree corresponds to a prefix of\r\nthe string. Let be the subset of suffixes, which are equal to the\r\ncorresponding prefixes. We can note that is exactly the path from the\r\nroot to the current vertex in the tree.Let be the character of vertex of\r\nKMP, which corresponds to the prefix with length (the string is indexed\r\nfrom ). Letâs find out what happens after adding a new character to the\r\nend of the string. Some suffixes from canât be extended with this\r\ncharacter (keeping the condition about equality to the prefix), so they\r\nwill be removed from the set. Also, if the new character is equal to , a\r\nsuffix with length will be added to the set. These are the only\r\nmodifications that will be applied to .We want to find all elements of ,\r\nwhich will be removed after a certain query. Letâs denote the number of\r\nthese elements by . If we find them in , the amortized time will be . A\r\nsuffix canât be extended if and only if the character of its vertex is\r\nnot equal to the new character. We need to find all these vertexes on\r\nthe way up from the last vertex. Let be the closest ancestor of with the\r\ndifferent next character (we can calculate it for each vertex when it is\r\nadded). Letâs ascend from vertex . If we are in a vertex with the same\r\nnext character as in the vertex , then we will go to the , otherwise, we\r\nwill handle this vertex as a removing suffix and go to the parent\r\nvertex. Itâs clear that it works in .Now our task is just adding a\r\nsuffix with length , removing suffixes and adding an element to all\r\nsuffixes. We can create a segment tree for minimum on in order to get\r\nthe minimum on the removing segment. Letâs maintain a mulitset of\r\nminimums on current suffixes. So, our queries are: Add element Remove\r\nelement For each element make Get the sum of the elements Letâs store a\r\nmap from an element to the number of its occurrences. Queries 1 and 2\r\ncan be done obviously. To perform the 3-rd query, we can just iterate\r\nthrough elements, which are bigger than , remove them from the map, and\r\nadd as many elements with value . The amortized complexity of this\r\nsolution is . solve it when a suspiciousness of a \"suspicious\" segment\r\nis the of elements instead of .Code (with BigInt realization)\r\n",
    "hint": []
}