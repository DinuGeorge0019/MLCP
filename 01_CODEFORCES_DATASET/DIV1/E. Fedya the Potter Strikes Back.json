{"link": "https://codeforces.com//contest/1286/problem/E", "problemId": "509644", "problem_idx": "E", "shortId": "1286E", "contest_number": "1286", "problem_submissions": {"E": [68277312, 68282070, 68274194, 68303699, 68303260, 68305269, 68280891, 68275520, 68485018, 68484885, 68281607, 68589901, 71865785, 101133015, 68300396], "C2": [68266879, 68290041, 68261617, 68262301, 68264579, 68294367, 68270650, 68281404, 68295029, 68426335, 68286377, 68264588, 68267031], "D": [68263572, 68264108, 68884999, 68884847, 68884788, 68283246, 68268908, 68270542, 68266913, 68271305, 68294377, 68276847, 68262972, 68265436, 68273176, 68274949, 68277188, 68266253, 68271981, 68278589, 68338459, 68281162, 68264815], "C1": [68253495, 68254635, 68259019, 68259783, 68260037, 68294288, 68263649, 68253659, 68276644, 68259313, 68260800, 68257683, 68278462, 68275645, 68260838, 68264488, 68260121], "B": [68249656, 68250720, 68252206, 68250842, 68249851, 68249360, 68294267, 68254854, 68250823, 68250630, 68252322, 68250475, 68253134, 68252948, 68253877, 68249986, 68255559, 68256077, 68252468, 68253101, 68252113], "A": [68245108, 68248019, 68248101, 68248225, 68245837, 68246154, 68294224, 68250492, 68248558, 68247246, 68248005, 68247110, 68249600, 68246667, 68250822, 68253310, 68252365, 68251609, 68247685, 68248520, 68246550], "F": [68288717, 68426651, 68284858, 68284592, 68283300, 68321599, 68593980, 68272947, 68281697, 68274721, 75028012]}, "name": "E. Fedya the Potter Strikes Back", "statement": "Fedya has a string S, initially empty, and an array W, also initially\r\nempty.There are n queries to process, one at a time. Query i consists of\r\na lowercase English letter c_i and a nonnegative integer w_i. First, c_i\r\nmust be appended to S, and w_i must be appended to W. The answer to the\r\nquery is the sum of for all subsegments of W [L,\r\nR], (1\r\nleq L\r\nleq R\r\nleq i).We define the of a subsegment as follows: if the substring of S\r\ncorresponding to this subsegment (that is, a string of consecutive\r\ncharacters from L-th to R-th, inclusive) matches the prefix of S of the\r\nsame length (that is, a substring corresponding to the subsegment [1,\r\nR - L + 1]), then its suspiciousness is equal to the minimum in the\r\narray W on the [L,\r\nR] subsegment. Otherwise, in case the substring does not match the\r\ncorresponding prefix, the suspiciousness is 0.Help Fedya answer all the\r\nqueries before the orderlies come for him!\r\n", "solutions": ["#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 601000\n#define SZ 1048576\nusing namespace std;\nint w[N_], oto[N_], par[N_][20];\nchar p[N_];\nint n, st[N_][2];\nlong long ans;\n\nstruct Tree {\n\tlong long S[SZ + SZ];\n\tint C[SZ + SZ], K[SZ + SZ];\n\n\tvoid init() {\n\t\tfor (int i = 0; i < SZ + SZ; i++)K[i] = -1;\n\t}\n\n\tvoid UDT(int nd) {\n\t\tS[nd] = S[nd * 2] + S[nd * 2 + 1];\n\t\tC[nd] = C[nd * 2] + C[nd * 2 + 1];\n\t}\n\tvoid Put2(int nd, int x) {\n\t\tK[nd] = x;\n\t\tS[nd] = (long long)C[nd] * x;\n\t}\n\tvoid Spread(int nd) {\n\t\tif (K[nd] != -1) {\n\t\t\tPut2(nd * 2, K[nd]);\n\t\t\tPut2(nd * 2 + 1, K[nd]);\n\t\t}\n\t\tK[nd] = -1;\n\t}\n\n\tvoid Off(int nd, int b, int e, int x) {\n\t\tif (b == e) {\n\t\t\tC[nd] = 0;\n\t\t\tS[nd] = 0;\n\t\t\treturn;\n\t\t}\n\t\tSpread(nd);\n\t\tint m = (b + e) >> 1;\n\t\tif(x<=m)Off(nd * 2, b, m, x);\n\t\telse Off(nd * 2 + 1, m + 1, e, x);\n\t\tUDT(nd);\n\t}\n\tvoid On(int nd, int b, int e, int x) {\n\t\tif (b == e) {\n\t\t\tC[nd] = 1;\n\t\t\tS[nd] = 0;\n\t\t\treturn;\n\t\t}\n\t\tSpread(nd);\n\t\tint m = (b + e) >> 1;\n\t\tif (x <= m)On(nd * 2, b, m, x);\n\t\telse On(nd * 2 + 1, m + 1, e, x);\n\t\tUDT(nd);\n\t}\n\tvoid Put(int nd, int b, int e, int s, int l, int x) {\n\t\tif (s > l)return;\n\t\tif (s <= b && e <= l) {\n\t\t\tPut2(nd, x);\n\t\t\treturn;\n\t\t}\n\t\tSpread(nd);\n\t\tint m = (b + e) >> 1;\n\t\tif (s <= m)Put(nd * 2, b, m, s, l, x);\n\t\tif (l > m)Put(nd * 2 + 1, m + 1, e, s, l, x);\n\t\tUDT(nd);\n\t}\n\n}T;\n\n\n\n\n\nvoid Go(int a, int b, int len) {\n\tint i;\n\tfor (i = 19; i >= 0; i--) if (par[a][i] > par[b][i])a = par[a][i], b = par[b][i];\n\tif (par[b][0] == 0) {\n\t\treturn;\n\t}\n\ta = par[a][0], b = par[b][0];\n\twhile (b >= a && b) {\n\t\tT.Off(1, 1, n, len - b);\n\t\tb = par[b][0];\n\t}\n\tif (a&&b) {\n\t\tGo(a, b, len);\n\t}\n\n}\n\nint main() {\n\tchar pp[3];\n\tint i, j, top = 0;\n\tscanf(\"%d\", &n);\n\toto[0] = -1;\n\tT.init();\n\tlong long mask = (1 << 30) - 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", pp);\n\t\tlong long a;\n\t\tscanf(\"%lld\", &a);\n\t\tpp[0] = (pp[0] - 'a' + ans) % 26 + 'a';\n\t\ta = (ans&mask) ^ a;\n\t\tw[i] = a;\n\t\tp[i - 1] = pp[0];\n\t\tint t = oto[i - 1];\n\t\twhile (t != -1 && p[i - 1] != p[t]) t = oto[t];\n\t\toto[i] = t + 1;\n\n\t\twhile (top && st[top][0] >= w[i]) top--;\n\t\ttop++;\n\t\tst[top][0] = w[i];\n\t\tst[top][1] = i;\n\t\tif (p[0] == p[i - 1]) {\n\t\t\tT.On(1, 1, n, i);\n\t\t}\n\t\tT.Put(1, 1, n, st[top - 1][1] + 1, i, w[i]);\n\n\t\tpar[i][0] = oto[i];\n\t\tfor (j = 0; j < 19; j++)par[i][j + 1] = par[par[i][j]][j];\n\t\tGo(i, i - 1, i);\n\n\t\tans += T.S[1];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"], "input": "", "output": "", "tags": ["data structures", "strings"], "dificulty": "3200", "interactive": false}