{
    "link": "https://codeforces.com//contest/1824/problem/B2",
    "problemId": "1909039",
    "problem_idx": "B2",
    "shortId": "1824B2",
    "contest_number": "1824",
    "problem_submissions": {
        "E": [
            205128571,
            205139739,
            205144104,
            205137280,
            205130495,
            205118718,
            205194940,
            205235861,
            205235298,
            205232550,
            205700234,
            205699976
        ],
        "D": [
            205099783,
            205099421,
            205104253,
            205142283,
            205135430,
            205107363,
            205103358,
            205109375,
            205130576,
            205106777,
            205111380,
            205108131,
            205113889,
            205109692,
            205110237,
            205111676,
            205111818,
            205116723,
            205113358,
            205116564,
            205115264,
            205122150
        ],
        "C": [
            205092605,
            205093858,
            205095306,
            205093905,
            205096370,
            205095737,
            205137755,
            205100625,
            205100857,
            205099284,
            205101290,
            205097496,
            205098177,
            205101207,
            205099752,
            205104989,
            205095505,
            205095555,
            205103206,
            205102161,
            205098628
        ],
        "B2": [
            205086508,
            205087676,
            205086929,
            205087663,
            205088713,
            205084760,
            205087488,
            205094809,
            205089113,
            205089568,
            205090318,
            205089714,
            205087793,
            205096844,
            205101610,
            205090439,
            205094629,
            205091373,
            205087601
        ],
        "B1": [
            205086422,
            205087787,
            205086792,
            205087589,
            205088569,
            205084970,
            205085855,
            205089877,
            205088994,
            205089640,
            205089081,
            205087696,
            205087867,
            205095794,
            205087977,
            205088492,
            205094450,
            205090371,
            205087429
        ],
        "A": [
            205083763,
            205085457,
            205082241,
            205082782,
            205083768,
            205088956,
            205081132,
            205083777,
            205081787,
            205082991,
            205086125,
            205082070,
            205083612,
            205083399,
            205081591,
            205083847,
            205088554,
            205081833,
            205083848
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/116328",
    "editorial": "Call a node special if there is a person in it.\n\nWhen k\n is odd, we find that there is only one node satisfying the conditions.\n\nProof.\n Assume distinct node x\n and node y\n are good nodes. Let x\n be the root of the tree. Define si\n as the number of special nodes in subtree i\n. Think about the process we move from x\n to y\n. If we try to move the chosen node from its father to i\n, the variation of cost is k?2si\n. When move from x\n to its son i\n which si\n is maximal, k?2si?0\n is held (Otherwise, x\n isn't a good node). And we can get k?2si>0\n further because k\n is odd and 2si\n is even. Since min1?j?nk?2sj=k?2si\n, we find k?2sj>0\n for all j\n. So y\n can't be good node.\n\nThen think about the situation that k\n is even. Choose a node as root arbitrarily. With the same method, we find that good nodes satisfy 2si=k\n. It's also sufficient. Define pi\n as the possibility that si=k2\n, then the answer is 1+?ni=1pi\n.\n\nDefine Si\n as the size of subtree i\n. When si=k2\n, there are k2\n special nodes in subtree i\n and k2\n in the other part. The number of ways to place special nodes is (nk)\n, and (Sik2)(n?Sik2)\n of them satisfying the condition. So pi=(Sik2)(n?Sik2)(nk)\n.",
    "name": "B2. LuoTianyi and the Floating Islands  Hard Version ",
    "statement": "LuoTianyi now lives in a world with n floating islands. The floating\r\nislands are connected by n-1 undirected air routes, and any two of them\r\ncan reach each other by passing the routes. That means, the n floating\r\nislands form a tree.One day, LuoTianyi wants to meet her friends:\r\nChtholly, Nephren, William, .... Totally, she wants to meet k people.\r\nShe doesn’t know the exact positions of them, but she knows that they\r\nare in islands. She define an island is if and only if the sum of the\r\ndistances^{\r\ndagger} from it to the islands with k people is the minimal among all\r\nthe n islands.Now, LuoTianyi wants to know that, if the k people are\r\nrandomly set in k distinct of the n islands, then what is the expect\r\nnumber of the good islands? You just need to tell her the expect number\r\nmodulo 10^9+7.^{\r\ndagger}The distance between two islands is the minimum number of air\r\nroutes you need to take to get from one island to the other.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;template<class T>constexpr T power(T a, i64 b) {    T res = 1;    for (; b; b /= 2, a *= a) {        if (b % 2) {            res *= a;        }    }    return res;} constexpr i64 mul(i64 a, i64 b, i64 p) {    i64 res = a * b - i64(1.L * a * b / p) * p;    res %= p;    if (res < 0) {        res += p;    }    return res;}template<i64 P>struct MLong {    i64 x;    constexpr MLong() : x{} {}    constexpr MLong(i64 x) : x{norm(x % getMod())} {}        static i64 Mod;    constexpr static i64 getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(i64 Mod_) {        Mod = Mod_;    }    constexpr i64 norm(i64 x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr i64 val() const {        return x;    }    explicit constexpr operator i64() const {        return x;    }    constexpr MLong operator-() const {        MLong res;        res.x = norm(getMod() - x);        return res;    }    constexpr MLong inv() const {        assert(x != 0);        return power(*this, getMod() - 2);    }    constexpr MLong &operator*=(MLong rhs) & {        x = mul(x, rhs.x, getMod());        return *this;    }    constexpr MLong &operator+=(MLong rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MLong &operator-=(MLong rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MLong &operator/=(MLong rhs) & {        return *this *= rhs.inv();    }    friend constexpr MLong operator*(MLong lhs, MLong rhs) {        MLong res = lhs;        res *= rhs;        return res;    }    friend constexpr MLong operator+(MLong lhs, MLong rhs) {        MLong res = lhs;        res += rhs;        return res;    }    friend constexpr MLong operator-(MLong lhs, MLong rhs) {        MLong res = lhs;        res -= rhs;        return res;    }    friend constexpr MLong operator/(MLong lhs, MLong rhs) {        MLong res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {        i64 v;        is >> v;        a = MLong(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {        return os << a.val();    }    friend constexpr bool operator==(MLong lhs, MLong rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MLong lhs, MLong rhs) {        return lhs.val() != rhs.val();    }}; template<>i64 MLong<0LL>::Mod = 1; template<int P>struct MInt {    int x;    constexpr MInt() : x{} {}    constexpr MInt(i64 x) : x{norm(x % getMod())} {}        static int Mod;    constexpr static int getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(int Mod_) {        Mod = Mod_;    }    constexpr int norm(int x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr int val() const {        return x;    }    explicit constexpr operator int() const {        return x;    }    constexpr MInt operator-() const {        MInt res;        res.x = norm(getMod() - x);        return res;    }    constexpr MInt inv() const {        assert(x != 0);        return power(*this, getMod() - 2);    }    constexpr MInt &operator*=(MInt rhs) & {        x = 1LL * x * rhs.x % getMod();        return *this;    }    constexpr MInt &operator+=(MInt rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MInt &operator-=(MInt rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MInt &operator/=(MInt rhs) & {        return *this *= rhs.inv();    }    friend constexpr MInt operator*(MInt lhs, MInt rhs) {        MInt res = lhs;        res *= rhs;        return res;    }    friend constexpr MInt operator+(MInt lhs, MInt rhs) {        MInt res = lhs;        res += rhs;        return res;    }    friend constexpr MInt operator-(MInt lhs, MInt rhs) {        MInt res = lhs;        res -= rhs;        return res;    }    friend constexpr MInt operator/(MInt lhs, MInt rhs) {        MInt res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {        i64 v;        is >> v;        a = MInt(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {        return os << a.val();    }    friend constexpr bool operator==(MInt lhs, MInt rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MInt lhs, MInt rhs) {        return lhs.val() != rhs.val();    }}; template<>int MInt<0>::Mod = 1; template<int V, int P>constexpr MInt<P> CInv = MInt<P>(V).inv(); constexpr int P = 1000000007;using Z = MInt<P>; struct Comb {    int n;    std::vector<Z> _fac;    std::vector<Z> _invfac;    std::vector<Z> _inv;        Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}    Comb(int n) : Comb() {        init(n);    }        void init(int m) {        if (m <= n) return;        _fac.resize(m + 1);        _invfac.resize(m + 1);        _inv.resize(m + 1);                for (int i = n + 1; i <= m; i++) {            _fac[i] = _fac[i - 1] * i;        }        _invfac[m] = _fac[m].inv();        for (int i = m; i > n; i--) {            _invfac[i - 1] = _invfac[i] * i;            _inv[i] = _invfac[i] * _fac[i - 1];        }        n = m;    }        Z fac(int m) {        if (m > n) init(2 * m);        return _fac[m];    }    Z invfac(int m) {        if (m > n) init(2 * m);        return _invfac[m];    }    Z inv(int m) {        if (m > n) init(2 * m);        return _inv[m];    }    Z binom(int n, int m) {        if (n < m || m < 0) return 0;        return fac(n) * invfac(m) * invfac(n - m);    }} comb; int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n, k;    std::cin >> n >> k;        std::vector<std::vector<int>> adj(n);    for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--, v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        Z ans = 1;        if (k % 2 == 0) {        Z inv = 1 / comb.binom(n, k);        std::vector<int> siz(n);        std::function<void(int, int)> dfs = [&](int x, int p) {            siz[x] = 1;            for (auto y : adj[x]) {                if (y == p) {                    continue;                }                dfs(y, x);                siz[x] += siz[y];                ans += comb.binom(siz[y], k / 2) * comb.binom(n - siz[y], k / 2) * inv;            }        };        dfs(0, -1);    }    std::cout << ans << \"\\n\";        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "math",
        "probabilities",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B2. LuoTianyi and the Floating Islands  Hard Version .json",
    "hint": []
}