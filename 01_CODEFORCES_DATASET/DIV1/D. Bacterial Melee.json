{
    "link": "https://codeforces.com//contest/759/problem/D",
    "problemId": "89813",
    "problem_idx": "D",
    "shortId": "759D",
    "contest_number": "759",
    "problem_submissions": {
        "D": [
            24042663,
            24044352,
            24045382,
            24043506,
            24045238,
            24043490,
            24042979,
            24045976,
            24046805,
            24046489,
            24045414,
            24046878,
            24045586,
            24044218,
            24046750,
            24048837,
            24048930,
            24045107,
            24049310,
            24047941
        ],
        "C": [
            24039992,
            24041637,
            24042097,
            24039244,
            24042431,
            24038977,
            24045787,
            24042805,
            24042270,
            24042690,
            24043790,
            24042556,
            24043437,
            24048532,
            24043622,
            24043222,
            24044113,
            29763466,
            29763430,
            24060556,
            24048425,
            24043154,
            24044032
        ],
        "B": [
            24037454,
            24038457,
            24039020,
            24040925,
            24038375,
            24044395,
            24038784,
            24039274,
            24038903,
            24039124,
            24039288,
            24039629,
            24040886,
            24038009,
            24039848,
            24039613,
            24036880,
            24038463,
            24040006,
            24040241
        ],
        "A": [
            24036272,
            24036509,
            24037538,
            24045297,
            24036223,
            24045401,
            24036423,
            24037461,
            24037032,
            24036975,
            24036471,
            24037688,
            24038305,
            24036140,
            24037910,
            24037165,
            24039125,
            24036572,
            24037614,
            24038031
        ],
        "E": [
            24052445,
            24051804,
            24055034
        ]
    },
    "name": "D. Bacterial Melee",
    "statement": "Julia is conducting an experiment in her lab. She placed several\r\nluminescent bacterial colonies in a horizontal testtube. Different types\r\nof bacteria can be distinguished by the color of light they emit. Julia\r\nmarks types of bacteria with small Latin letters \"\", ..., \"\".The\r\ntesttube is divided into consecutive regions. Each region is occupied by\r\na single colony of a certain bacteria type at any given moment. Hence,\r\nthe population of the testtube at any moment can be described by a\r\nstring of Latin characters.Sometimes a colony can decide to conquer\r\nanother colony in one of the adjacent regions. When that happens, the\r\nattacked colony is immediately eliminated and replaced by a colony of\r\nthe same type as the attacking colony, while the attacking colony keeps\r\nits type. Note that a colony can only attack its neighbours within the\r\nboundaries of the testtube. At any moment, at most one attack can take\r\nplace.For example, consider a testtube with population \"\". There are six\r\noptions for an attack that may happen next: the first colony attacks the\r\nsecond colony (), the resulting population is \"\"; , the result is \"\"; ,\r\nthe result is \"\"; , the result is \"\" (note that the result is the same\r\nas the first option); or , the population does not change.The pattern of\r\nattacks is rather unpredictable. Julia is now wondering how many\r\ndifferent configurations of bacteria in the testtube she can obtain\r\nafter a sequence of attacks takes place (it is possible that no attacks\r\nwill happen at all). Since this number can be large, find it modulo .\r\n",
    "solutions": [
        "#include <cstdio>\n\nconst int p = 1000000007;\n\nchar a[5005];\nint c[5005][26];\nint d[5005];\n\nint main() {\n\tint i, j, k, n;\n\tscanf(\"%d%s\", &n, a + 1);\n\td[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tk = (d[j - 1] - c[j][a[i] - 'a'] + p) % p;\n\t\t\tc[j][a[i] - 'a'] = (c[j][a[i] - 'a'] + k) % p;\n\t\t\td[j] = (d[j] + k) % p;\n\t\t}\n\t}\n\tprintf(\"%d\", d[n]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Bacterial Melee.json",
    "editorial_link": "https://codeforces.com//blog/entry/49946",
    "editorial": "Hint: find a condition when a string is reachable from another string in terms of subsequences, then apply DP for counting suitable subsequences.\n\nSolution: How to determine if a string can be obtained from another string after a number of operations? It helps to consider (maximal) blocks of adjacent characters. Let us define comp(s) as a \"compressed\" version of s that keeps a single character from each block of s in the same order, for example, . It is not hard to see that each operation either preserves the sequence of blocks (if we ignore their lengths) or erases a single block (when it consists of a single character and is overwritten by an adjacent character). This is the same as saying that each operation applied to s either doesn't change comp(s) or erases a single character from it. Therefore, if t can be obtained from s after a number of operations, then comp(t) must be a subsequence of comp(s).\n\nIn fact, this is an \"if and only if\" condition. Indeed, suppose that comp(t) is a subsequence of comp(s). We start our process of making t from s by eliminating the blocks not present in t, effectively making comp(s)?=?comp(t). After that, it can be seen that the borders of the blocks can be moved rather freely (but carefully enough not to murder any block) so that s can be indeed made equal to t.\n\nWe can see from the last argument that from the reachability point of view the two strings s and t are essentially different if comp(s)???comp(t). If s is the given string, and a string u is a subsequence of comp(s) that doesn't have equal adjacent characters, then there are  reachable strings with comp(...)?=?u; indeed, this is exactly the number of ways to split n characters into |u| non-empty blocks.\n\nNow, for each l we have to count the number of subsequences of s with length l that do not have equal adjacent characters. There are several ways to do that. One way is storing dpc,?l Â— the number of valid subsequences of length l that end in character c. We now process characters one by one and recompute values of dpc,?l. If the new character is ci, then clearly values of dpc,?l with c???ci do not change. We can also see that we can find the new values of dpci,?l with the formula\n\n\nIndeed, consider a valid subsequence that ends in ci. If we take any occurence of this subsequence, we are free to move the last character to the newly appended occurence of ci. It follows that there is a bijection between valid subsequences that end in ci and valid subsequences that end in anything but ci (that includes an empty subsequence). This solution takes O(kn2) time (where k?=?26 is the number of different characters), but can easily by optimized to O(n2) time.",
    "hint": []
}