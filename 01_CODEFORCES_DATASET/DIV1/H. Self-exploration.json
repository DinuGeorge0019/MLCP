{"link": "https://codeforces.com//contest/1045/problem/H", "problemId": "223470", "problem_idx": "H", "shortId": "1045H", "contest_number": "1045", "problem_submissions": {"E": [43261410, 43577517], "J": [43258702, 43260133, 43575980, 43263093, 43266033], "A": [43255060, 43256216, 43263322, 43263783, 43258806, 43275613], "D": [43251490, 43264794, 43257475, 43253807, 43257410, 43253327, 43248880], "C": [43250229, 43244156, 43255852, 43252661, 43258515, 43251235, 43259397], "G": [43247867, 43248087, 43251069, 43250948, 43255077, 43249900, 43251360], "H": [43246289, 43252595, 43260022, 43258468, 43261064, 43264435, 43263084], "B": [43243648, 43248788, 43247063, 43264324, 43264189, 43246587, 43256450, 43248333, 43254638], "I": [43243009, 43244706, 43243112, 43242671, 43255452, 43243089, 43243594], "F": [43577952]}, "name": "H. Self-exploration", "statement": "Being bored of exploring the Moon over and over again Wall-B decided to\r\nexplore something he is made of binary numbers. He took a binary number\r\nand decided to count how many times different substrings of length two\r\nappeared. He stored those values in c_{00}, c_{01}, c_{10} and c_{11},\r\nrepresenting how many times substrings , , and appear in the number\r\nrespectively. For example: 10111100\r\nrightarrow c_{00} = 1,\r\nc_{01} = 1,\r\nc_{10} = 2,\r\nc_{11} = 3 10000\r\nrightarrow c_{00} = 3,\r\nc_{01} = 0,\r\nc_{10} = 1,\r\nc_{11} = 0 10101001\r\nrightarrow c_{00} = 1,\r\nc_{01} = 3,\r\nc_{10} = 3,\r\nc_{11} = 0 1\r\nrightarrow c_{00} = 0,\r\nc_{01} = 0,\r\nc_{10} = 0,\r\nc_{11} = 0Wall-B noticed that there can be multiple binary numbers\r\nsatisfying the same c_{00}, c_{01}, c_{10} and c_{11} constraints.\r\nBecause of that he wanted to count how many binary numbers satisfy the\r\nconstraints c_{xy} given the interval [A, B]. Unfortunately, his\r\nprocessing power wasn\u2019t strong enough to handle large intervals he was\r\ncurious about. Can you help him? Since this number can be large print it\r\nmodulo 10^9 + 7.\r\n", "solutions": ["#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst ll MOD = 1e9 + 7;\n\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\nconst int MX = 410000;\n\nstring a, b;\nint c[4];\nint ctmp[4];\nint cc[4];\nll fc[MX];\nll bfc[MX];\n\nll cnk(int n, int k) {\n\tif (k > n)\n\t\treturn 0;\n\treturn fc[n] * bfc[k] % MOD * bfc[n - k] % MOD;\n}\n\nll get2(int a, int b) {\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\treturn cnk(a - 1 + b, b);\n}\n\nll get(int st) {\n\tfor (int i = 0; i < 4; ++i)\n\t\tif (c[i] < 0)\n\t\t\treturn 0;\n\tfor (int i = 0; i < 4; ++i)\n\t\tcc[i] = c[i];\n\tif (st == 1)\n\t\tswap(cc[0], cc[3]), swap(cc[1], cc[2]);\n\tif (cc[1] == cc[2]) {\n\t\treturn get2(cc[1] + 1, cc[0]) * get2(cc[1], cc[3]) % MOD;\n\t}\n\telse if (cc[1] == cc[2] + 1) {\n\t\treturn get2(cc[1], cc[0]) * get2(cc[1], cc[3]) % MOD;\n\t}\n\telse\n\t\treturn 0;\n}\n\nll solve(string b) {\n\tint sm = 1 + c[0] + c[1] + c[2] + c[3];\n\tif (sm < b.size())\n\t\treturn get(1);\n\tif (sm > b.size())\n\t\treturn 0;\n\tll ans = 0;\n\tfor (int i = (int)b.size() - 2; i >= 0; --i) {\n\t\tint x = (b[i + 1] - '0') * 2;\n\t\tif (b[i] == '1') {\n\t\t\t--c[x];\n\t\t\tans = (ans + get(0)) % MOD;\n\t\t\t++c[x];\n\t\t}\n\t\tx += b[i] - '0';\n\t\t--c[x];\n\t}\n\treturn ans;\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tfc[0] = 1;\n\tfor (int i = 1; i < MX; ++i)\n\t\tfc[i] = (fc[i - 1] * i) % MOD;\n\tbfc[MX - 1] = pw(fc[MX - 1], MOD - 2);\n\tfor (int i = MX - 2; i >= 0; --i)\n\t\tbfc[i] = (bfc[i + 1] * (i + 1)) % MOD;\n\tcin >> a >> b;\n\tfor (int i = 0; i < 4; ++i)\n\t\tcin >> c[i], ctmp[i] = c[i];\n\treverse(a.begin(), a.end());\n\treverse(b.begin(), b.end());\n\tint cur = 0;\n\twhile (cur < b.size() && b[cur] == '1')\n\t\tb[cur] = '0', ++cur;\n\tif (cur == b.size())\n\t\tb += '1';\n\telse\n\t\tb[cur] = '1';\n\tll ans = solve(b);\n\tfor (int i = 0; i < 4; ++i)\n\t\tc[i] = ctmp[i];\n\tans = (ans + MOD - solve(a)) % MOD;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["math"], "dificulty": "2400", "interactive": false}