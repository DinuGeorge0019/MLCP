{
    "link": "https://codeforces.com//contest/1710/problem/B",
    "problemId": "1478268",
    "problem_idx": "B",
    "shortId": "1710B",
    "contest_number": "1710",
    "problem_submissions": {
        "D": [
            165580964,
            165583659,
            165582423,
            165579985,
            165578292,
            165621030,
            165665623,
            165863180,
            165686266,
            165622179,
            253472539,
            253472055,
            253196732
        ],
        "C": [
            165561993,
            165571937,
            165567266,
            165564305,
            165560493,
            165557009,
            165565561,
            165573369,
            167610382,
            165564040,
            165565611,
            165559918,
            165863165,
            165574164,
            165561713,
            165562795,
            166635016,
            165567222,
            165574139,
            165575303,
            165568215,
            165580670,
            165575504
        ],
        "B": [
            165557184,
            165556433,
            165562218,
            165559397,
            165550455,
            165567723,
            165557989,
            165562869,
            167610352,
            165552192,
            165580788,
            165551441,
            165863147,
            165568559,
            165640205,
            165639837,
            165621062,
            165556086,
            165556541,
            167747535,
            165575476,
            165569308,
            165567541,
            165555460,
            165570664,
            165584416
        ],
        "E": [
            165552045,
            165543060,
            165549416,
            165565765,
            165563275,
            165541229,
            165548123,
            165548892,
            165559843,
            165548838,
            165565641,
            165863198,
            165549459,
            165565050,
            165564177,
            166635025,
            165555617,
            165553406,
            165554497,
            165569888,
            165555183,
            165548602
        ],
        "A": [
            165540652,
            165547446,
            165541424,
            165545863,
            165540100,
            165538811,
            165546951,
            165544526,
            167610720,
            167610305,
            165540896,
            165542843,
            165539482,
            165863070,
            165547951,
            165543234,
            165543554,
            165541413,
            165551173,
            165542506,
            165539602,
            165547656,
            165544347
        ]
    },
    "name": "B. Rain",
    "statement": "You are the owner of a harvesting field which can be modeled as an\r\ninfinite line, whose positions are identified by integers.It will rain\r\nfor the next n days. On the i-th day, the rain will be centered at\r\nposition x_i and it will have intensity p_i. Due to these rains, some\r\nrainfall will accumulate; let a_j be the amount of rainfall accumulated\r\nat integer position j. Initially a_j is 0, and it will increase by\r\nmax(0,p_i-|x_i-j|) after the i-th day\u2019s rain.A flood will hit your field\r\nif, at any moment, there is a position j with accumulated rainfall\r\na_j>m.You can use a magical spell to erase day\u2019s rain, i.e., setting\r\np_i=0. For each i from 1 to n, check whether in case of erasing the i-th\r\nday\u2019s rain there is no flood.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int maxn=666666,mod=998244353;\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline ll read(){\n\tchar ch=getchar();ll x=0,f=0;\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint n,x[maxn],p[maxn],tmp[maxn],tl;\nll m,d1[maxn],d2[maxn],w[maxn],pre[maxn],suf[maxn];\ninline int find(int x){\n\treturn lower_bound(tmp+1,tmp+tl+1,x)-tmp;\n}\nvoid clear(){\n\tFOR(i,0,tl+1) d1[i]=d2[i]=w[i]=pre[i]=suf[i]=tmp[i]=0;\n\ttl=0;\n}\nvoid solve(){\n\tn=read();m=read();\n\tFOR(i,1,n){\n\t\tx[i]=read();p[i]=read();\n\t\ttmp[++tl]=x[i];\n\t\ttmp[++tl]=x[i]-p[i];\n\t\ttmp[++tl]=x[i]+p[i];\n\t}\n\tsort(tmp+1,tmp+tl+1);\n\ttl=unique(tmp+1,tmp+tl+1)-tmp-1;\n\tFOR(i,1,n){\n\t\tint l=find(x[i]-p[i]),at=find(x[i]),r=find(x[i]+p[i]);\n\t\t// l~at += pos-(x[i]-p[i])\n\t\t// at+1~r += (p[i]+x[i])-pos\n\t\td1[l]++;d1[at+1]--;\n\t\td2[l]-=x[i]-p[i];d2[at+1]+=x[i]-p[i];\n\t\td1[at+1]--;d1[r+1]++;\n\t\td2[at+1]+=x[i]+p[i];d2[r+1]-=x[i]+p[i]; \n\t}\n\tpre[0]=-1e18;\n\tFOR(i,1,tl){\n\t\td1[i]+=d1[i-1],d2[i]+=d2[i-1]; \n\t\tw[i]=1ll*d1[i]*tmp[i]+d2[i];\n\t\tw[i]=w[i]>m?w[i]-m:-1e18;\n\t\tpre[i]=max(w[i],pre[i-1]+tmp[i]-tmp[i-1]);\n\t}\n\tsuf[tl+1]=-1e18;\n\tROF(i,tl,1) suf[i]=max(w[i],suf[i+1]+tmp[i+1]-tmp[i]);\n\tFOR(i,1,n){\n\t\tint at=find(x[i]);\n\t\tputchar(max(pre[at],suf[at])<=p[i]?'1':'0');\n\t}\n\tputs(\"\");\n\tclear();\n}\nint main(){\n\tint T=read();\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "geometry",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Rain.json",
    "editorial_link": "https://codeforces.com//blog/entry/105232",
    "editorial": "hint1.The maximum can always be achieved in the center position of one\r\nday\u00e2\u0080\u0099s rain.\r\n"
}