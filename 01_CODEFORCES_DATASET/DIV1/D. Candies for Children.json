{
    "link": "https://codeforces.com//contest/1063/problem/D",
    "problemId": "236988",
    "problem_idx": "D",
    "shortId": "1063D",
    "contest_number": "1063",
    "problem_submissions": {
        "F": [
            44321779,
            44310989,
            44539942,
            44524512,
            44473039,
            44472562,
            50480317,
            51150998,
            44317621,
            44317615,
            44312825,
            44373124
        ],
        "D": [
            44311197,
            44305997,
            44303323,
            44313702,
            44361765,
            44361136,
            44376357,
            44376258,
            44307498,
            44337552,
            44311559,
            44305058,
            44311516,
            44304459,
            44311498,
            44312697,
            44315110
        ],
        "E": [
            44305503,
            44313651,
            44315069,
            44307031,
            44313364,
            44308262,
            44337210,
            44313717,
            44317640,
            44314472,
            44311650
        ],
        "C": [
            44298733,
            44296257,
            44305349,
            44298667,
            44298705,
            44299697,
            44299069,
            44300205,
            44299465,
            44299657,
            44301626,
            44302301,
            44304486,
            44306960,
            44302436,
            44309287,
            44301972,
            44304513,
            44301966
        ],
        "A": [
            44295781,
            44291759,
            44291627,
            44296582,
            44291453,
            44291198,
            44292770,
            44291128,
            44296111,
            44296432,
            44292644,
            44293693,
            44292723,
            44296227,
            44292099,
            44305135,
            44297417,
            44292247,
            44291472
        ],
        "B": [
            44295123,
            44298986,
            44296043,
            44295205,
            44297251,
            44302092,
            44296710,
            44297936,
            44295873,
            44297588,
            44298080,
            44299136,
            44294684,
            44297166,
            44295722,
            44296834,
            44296659,
            44296927
        ]
    },
    "name": "D. Candies for Children",
    "statement": "At the children\u2019s festival, children were dancing in a circle. When\r\nmusic stopped playing, the children were still standing in a circle.\r\nThen Lena remembered, that her parents gave her a candy box with exactly\r\nk candies \"Wilky May\". Lena is not a greedy person, so she decided to\r\npresent all her candies to her friends in the circle. Lena knows, that\r\nsome of her friends have a sweet tooth and others do not. Sweet tooth\r\ntakes out of the box two candies, if the box has at least two candies,\r\nand otherwise takes one. The rest of Lena\u2019s friends always take exactly\r\none candy from the box.Before starting to give candies, Lena step out of\r\nthe circle, after that there were exactly n people remaining there. Lena\r\nnumbered her friends in a clockwise order with positive integers\r\nstarting with 1 in such a way that index 1 was assigned to her best\r\nfriend Roma.Initially, Lena gave the box to the friend with number l,\r\nafter that each friend (starting from friend number l) took candies from\r\nthe box and passed the box to the next friend in clockwise order. The\r\nprocess ended with the friend number r taking the last candy (or two,\r\nwho knows) and the empty box. Please note that it is possible that some\r\nof Lena\u2019s friends took candy from the box several times, that is, the\r\nbox could have gone several full circles before becoming empty.Lena does\r\nnot know which of her friends have a sweet tooth, but she is interested\r\nin the maximum possible number of friends that can have a sweet tooth.\r\nIf the situation could not happen, and Lena have been proved wrong in\r\nher observations, please tell her about this.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nLL N, K, L, R;\nLL g1, d1, g2, d2;\nLL answer = -1;\n\nint CheckTotalG(LL total_g) {\n  if (total_g > N) { return 1; }\n  if (total_g < 0) { return -1; }\n  const LL div = N + total_g;\n  LL m = K % div;\n  if (m == 0) { m = div; }\n  const LL min_left = max<LL>(0, total_g - d2);\n  debug(N, total_g, min_left, m);\n  if (m < d1 + max<LL>(0, min_left - 1)) { return 1; }\n  if (m > d1 + min<LL>(d1, total_g)) { return -1; }\n  debug(\"ok\");\n  maxi(answer, total_g);\n  return 0;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> L >> R >> K;\n\n  R = (R - L + N) % N;\n  L = 0;\n  debug(N, K, L, R);\n\n  d1 = R + 1;\n  d2 = N - d1;\n  debug(d1, d2);\n  // max_g = N;\n\n  // const LL max_iter_g = max_g;\n  const LL max_iter_g = min(N, (int)(sqrt(K) + 3));\n\n  for (LL tot_g = 0; tot_g <= max_iter_g; ++tot_g)\n    CheckTotalG(tot_g);\n\n  for (LL alpha = 0; alpha <= max_iter_g; ++alpha) {\n    if (K - alpha * N < 0) { break; }\n    LL max_g = alpha ? (K - alpha * N) / alpha : N;\n    LL min_g = (K - (alpha + 1) * N + alpha) / (alpha + 1);\n    maxi<LL>(min_g, 0);\n    mini<LL>(max_g, N);\n    if (max_g < min_g) { continue; }\n\n    debug(alpha, min_g, max_g);\n    ++max_g;\n\n    while (max_g - min_g > 1) {\n      const LL mid_g = (max_g + min_g) / 2;\n      if (CheckTotalG(mid_g) == 1)\n        max_g = mid_g;\n      else\n        min_g = mid_g;\n    }\n\n    CheckTotalG(max_g);\n    CheckTotalG(max_g - 1);\n    CheckTotalG(max_g - 2);\n\n  }\n\n  cout << answer << \"\\n\";\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Candies for Children.json",
    "editorial_link": "https://codeforces.com/blog/entry/62455",
    "editorial": "Solution works in time. Also I will drop the case about the last person\r\nbeing sweet tooth eating one candy instead of two.This adds few more\r\ncases but the idea stays the same. Basically in the formulas below just\r\nfew will appear, however there must be condition that there is at least\r\none sweet tooth in corresponding part of the circle.Note, that basically\r\nwe have two parts of the circle the part between which get\u00e2\u0080\u0099s candies one\r\ntimes more than the rest and the other one.Since we don\u00e2\u0080\u0099t care about\r\nabsolute values we can only worry about the lengths of this parts, let\u00e2\u0080\u0099s\r\ndenote them as and .To solve in let\u00e2\u0080\u0099s bruteforce the number of sweet\r\ntooth on first part () and the number of sweet tooth on the second part\r\n().Suppose that there were full loops. This way the number of eaten\r\ncandies is .This should be equal to . Since we just bruteforced the\r\nvalues of and we now just have linear equation. If it is solvable,\r\nconsider relaxing answer with .So as the asymptotic suggests the amount\r\nof turns , so we can bruteforce it instead.Also it is worthy to handle\r\ncase of turns specifically here since it produces some unpleasant\r\neffects otherwise.So each person in \"\" part of the circle eats candies\r\ntimes (so each person contributes or ) and the other persons have eaten\r\ncandies times (so each person contributes or ).Let\u00e2\u0080\u0099s account all persons\r\nas if they are not sweet tooths.So now each person in contributes or and\r\neach person in contributes or .So we basically have . A Diophantine\r\nequation.Careful analysis or bits of theory suggest that the solutions\r\nare, , for all integer .Where and some arbitrary solutions which we can\r\nget with formulas.Also we need to have , , and the .These bounds imply\r\nthat takes values only in some range .Since the is linear function we\r\ncan only consider and while searching for maximum .\r\n"
}