{"link": "https://codeforces.com//contest/229/problem/E", "problemId": "1894", "problem_idx": "E", "shortId": "229E", "contest_number": "229", "problem_submissions": {"E": [2282826, 2281727, 2285054, 2283563, 2285346, 2285087, 2285039, 2284707, 2406707, 2284567, 2285340, 2286716], "D": [2279442, 2279718, 2280046, 2280344, 2282950, 2281962, 2282776, 2282602, 2281974, 2283282, 2282070, 2283551, 2282480, 2282427, 2282188, 2281610, 2283171], "B": [2276814, 2277758, 2276080, 2280606, 2279078, 2281037, 2280028, 2279270, 2278615, 2280162, 2280493, 2279459, 2280601, 2279970, 2281238], "C": [2274858, 2273646, 2277243, 2277231, 2276597, 2280255, 2276975, 2277162, 2279947, 2277171, 2276063, 2277931, 2277827, 2275487, 2283199, 2278070], "A": [2274032, 2286414, 2274348, 2275349, 2275192, 2274716, 2276132, 2302218, 2286476, 2274187, 2274224, 2275364, 2275231, 2276851, 2274395, 2275579]}, "name": "E. Gifts", "statement": "Once upon a time an old man and his wife lived by the great blue sea.\r\nOne day the old man went fishing and caught a real live gold fish. The\r\nfish said: \"Oh ye, old fisherman! Pray set me free to the ocean and I\r\nwill grant you with gifts, any gifts you wish!\". Then the fish gave the\r\nold man a list of gifts and their prices. Some gifts on the list can\r\nhave the same names but distinct prices. However, there can\u2019t be two\r\ngifts with the same names and the same prices. Also, there can be gifts\r\nwith distinct names and the same prices. The old man can ask for names\r\nof items from the list. If the fish\u2019s list has occurrences of the given\r\nname, then the old man can\u2019t ask for this name of item more than\r\ntimes.The old man knows that if he asks for gifts of the same name, the\r\nfish will randomly (i.e. uniformly amongst all possible choices) choose\r\ngifts of distinct prices with such name from the list. The old man wants\r\nto please his greedy wife, so he will choose the names in such a way\r\nthat he can get gifts with the maximum price. Besides, he isn\u2019t the\r\nbrightest of fishermen, so if there are several such ways, he chooses\r\none of them uniformly.The old man wondered, what is the probability that\r\nhe can get most expensive gifts. As the old man isn\u2019t good at\r\nprobability theory, he asks you to help him.\r\n", "solutions": ["/*\n * e.cpp\n *\n *  Created on: 2012-10-2\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\nconst int MAX_N = 1000 + 10;\nint n, m;\nint a[MAX_N], h[MAX_N];\nvector<int> val;\nvector<int> have[MAX_N];\ntypedef long double ld;\nld dp[MAX_N][MAX_N]; //i,nthrow\nld cnt[MAX_N][MAX_N];\nld p[MAX_N][MAX_N];\nld comb[MAX_N][MAX_N];\n\nint main() {\n\tfor (int r = 0; r < MAX_N; ++r) {\n\t\tfor (int c = 0; c <= r; ++c) {\n\t\t\tcomb[r][c] = (r == 0 || c == 0) ? 1 : comb[r - 1][c] + comb[r - 1][c - 1];\n\t\t}\n\t}\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\thave[i].push_back(x);\n\t\t\tval.push_back(x);\n\t\t}\n\t}\n\tsort(val.rbegin(), val.rend());\n\tint cut = val[n - 1];\n\tint sumA = 0;\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (vector<int>::iterator e = have[i].begin(); e != have[i].end(); ++e) {\n\t\t\tif (*e > cut)\n\t\t\t\t++a[i];\n\t\t\tif (*e == cut)\n\t\t\t\t++h[i];\n\t\t}\n\t\tsumA += a[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = a[i]; j <= a[i] + h[i]; ++j) {\n\t\t\tint A = a[i], H = h[i], O = have[i].size() - A - H;\n\t\t\tp[i][j] = comb[H][j - A] / comb[A + H + O][j];\n\t\t}\n\t}\n\tmemset(dp, 0, sizeof dp);\n\tmemset(cnt, 0, sizeof cnt);\n\tcnt[0][0] = 1;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tld c = dp[i][j];\n\t\t\tif (fabs(c) > 1e-12) {\n\t\t\t\tfor (int k = a[i]; k <= a[i] + h[i] && j + k <= n; ++k) {\n\t\t\t\t\tdp[i + 1][j + k] += c * p[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = cnt[i][j];\n\t\t\tif (fabs(c) > 1e-12) {\n\t\t\t\tfor (int k = a[i]; k <= a[i] + h[i] && j + k <= n; ++k) {\n\t\t\t\t\tcnt[i + 1][j + k] += c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"%0.15lf\\n\", (double) ());\n\tcout.setf(ios::fixed);\n\tcout << setprecision(15) << dp[m][n] / cnt[m][n] << endl; //\ufffd\ufffd\ufffd0.10\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "math", "probabilities"], "dificulty": "2600", "interactive": false}