{
    "link": "https://codeforces.com//contest/229/problem/E",
    "problemId": "1894",
    "problem_idx": "E",
    "shortId": "229E",
    "contest_number": "229",
    "problem_submissions": {
        "E": [
            2282826,
            2281727,
            2285054,
            2283563,
            2285346,
            2285087,
            2285039,
            2284707,
            2406707,
            2284567,
            2285340,
            2286716
        ],
        "D": [
            2279442,
            2279718,
            2280046,
            2280344,
            2282950,
            2281962,
            2282776,
            2282602,
            2281974,
            2283282,
            2282070,
            2283551,
            2282480,
            2282427,
            2282188,
            2281610,
            2283171
        ],
        "B": [
            2276814,
            2277758,
            2276080,
            2280606,
            2279078,
            2281037,
            2280028,
            2279270,
            2278615,
            2280162,
            2280493,
            2279459,
            2280601,
            2279970,
            2281238
        ],
        "C": [
            2274858,
            2273646,
            2277243,
            2277231,
            2276597,
            2280255,
            2276975,
            2277162,
            2279947,
            2277171,
            2276063,
            2277931,
            2277827,
            2275487,
            2283199,
            2278070
        ],
        "A": [
            2274032,
            2286414,
            2274348,
            2275349,
            2275192,
            2274716,
            2276132,
            2302218,
            2286476,
            2274187,
            2274224,
            2275364,
            2275231,
            2276851,
            2274395,
            2275579
        ]
    },
    "name": "E. Gifts",
    "statement": "Once upon a time an old man and his wife lived by the great blue sea.\r\nOne day the old man went fishing and caught a real live gold fish. The\r\nfish said: \"Oh ye, old fisherman! Pray set me free to the ocean and I\r\nwill grant you with gifts, any gifts you wish!\". Then the fish gave the\r\nold man a list of gifts and their prices. Some gifts on the list can\r\nhave the same names but distinct prices. However, there can\u2019t be two\r\ngifts with the same names and the same prices. Also, there can be gifts\r\nwith distinct names and the same prices. The old man can ask for names\r\nof items from the list. If the fish\u2019s list has occurrences of the given\r\nname, then the old man can\u2019t ask for this name of item more than\r\ntimes.The old man knows that if he asks for gifts of the same name, the\r\nfish will randomly (i.e. uniformly amongst all possible choices) choose\r\ngifts of distinct prices with such name from the list. The old man wants\r\nto please his greedy wife, so he will choose the names in such a way\r\nthat he can get gifts with the maximum price. Besides, he isn\u2019t the\r\nbrightest of fishermen, so if there are several such ways, he chooses\r\none of them uniformly.The old man wondered, what is the probability that\r\nhe can get most expensive gifts. As the old man isn\u2019t good at\r\nprobability theory, he asks you to help him.\r\n",
    "solutions": [
        "/*\n * e.cpp\n *\n *  Created on: 2012-10-2\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\nconst int MAX_N = 1000 + 10;\nint n, m;\nint a[MAX_N], h[MAX_N];\nvector<int> val;\nvector<int> have[MAX_N];\ntypedef long double ld;\nld dp[MAX_N][MAX_N]; //i,nthrow\nld cnt[MAX_N][MAX_N];\nld p[MAX_N][MAX_N];\nld comb[MAX_N][MAX_N];\n\nint main() {\n\tfor (int r = 0; r < MAX_N; ++r) {\n\t\tfor (int c = 0; c <= r; ++c) {\n\t\t\tcomb[r][c] = (r == 0 || c == 0) ? 1 : comb[r - 1][c] + comb[r - 1][c - 1];\n\t\t}\n\t}\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\thave[i].push_back(x);\n\t\t\tval.push_back(x);\n\t\t}\n\t}\n\tsort(val.rbegin(), val.rend());\n\tint cut = val[n - 1];\n\tint sumA = 0;\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (vector<int>::iterator e = have[i].begin(); e != have[i].end(); ++e) {\n\t\t\tif (*e > cut)\n\t\t\t\t++a[i];\n\t\t\tif (*e == cut)\n\t\t\t\t++h[i];\n\t\t}\n\t\tsumA += a[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = a[i]; j <= a[i] + h[i]; ++j) {\n\t\t\tint A = a[i], H = h[i], O = have[i].size() - A - H;\n\t\t\tp[i][j] = comb[H][j - A] / comb[A + H + O][j];\n\t\t}\n\t}\n\tmemset(dp, 0, sizeof dp);\n\tmemset(cnt, 0, sizeof cnt);\n\tcnt[0][0] = 1;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tld c = dp[i][j];\n\t\t\tif (fabs(c) > 1e-12) {\n\t\t\t\tfor (int k = a[i]; k <= a[i] + h[i] && j + k <= n; ++k) {\n\t\t\t\t\tdp[i + 1][j + k] += c * p[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = cnt[i][j];\n\t\t\tif (fabs(c) > 1e-12) {\n\t\t\t\tfor (int k = a[i]; k <= a[i] + h[i] && j + k <= n; ++k) {\n\t\t\t\t\tcnt[i + 1][j + k] += c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"%0.15lf\\n\", (double) ());\n\tcout.setf(ios::fixed);\n\tcout << setprecision(15) << dp[m][n] / cnt[m][n] << endl; //\ufffd\ufffd\ufffd0.10\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Gifts.json",
    "editorial_link": "https://codeforces.com//blog/entry/5437",
    "editorial": "First let\u00e2\u0080\u0099s establish some facts that we will use in the solution. With\r\nhow much probability can the fisherman get a particular set of gifts,\r\namong which there are gifts of -th name? In total there are such sets,\r\nsince there are exactly subsets of gifts with -th name of size , and two\r\ndifferent names are independent during the gold fish\u00e2\u0080\u0099s choice. Then the\r\ndescribed particular set of gifts we can get with the probability of ,\r\nby asking gifts of -th name. Now we know the probability of obtaining\r\none particular gift set . Now observe that from we can calculate the\r\nprobabiltity of obtaining the set along with some one other gift of -th\r\nname in constant time. Say there are already elements of -th name in .\r\nUsing the formula from the first paragraph, we can deduce that: Let\u00e2\u0080\u0099s\r\nsolve the main problem now. We sort all the gifts in descending order of\r\ntheir prices. It is clear that the fisherman will definitely ask the\r\nnames of all the gifts among the first ones whose prices are not equal\r\nto the price of the -th gift in the list. Let\u00e2\u0080\u0099s say that this set of\r\ngifts is the base, and it has elements. Then there is still unchosen\r\ngifts, and we know that all of them will have the price equal to the\r\nprice of the -th gift in the list. Say the price of the -th gift is ,\r\nand there are exactly gifts with the price (keep in mind that each of\r\nthem has a different name); also call these gifts dubious. We can also\r\ndeduce that the fisherman can make different decisions, where . So now\r\nwe have some dubious gifts with the price of ; let\u00e2\u0080\u0099s enumerate them in\r\nany order. We calculate the dynamics the cumulative probability of\r\nobtaining most valuable gifts, if there are chosen from the first in the\r\nlist. It is clear that , and contains the answer to the problem. Using\r\nthe coefficients we have deduced earlier, we get two transitions in the\r\ndynamics: The complexity of the solution is . Sample solution:\r\nhttp://pastie.org/4897519 (archived copy)\r\n"
}