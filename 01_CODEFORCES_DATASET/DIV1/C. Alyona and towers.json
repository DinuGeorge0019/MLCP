{"link": "https://codeforces.com//contest/739/problem/C", "problemId": "81534", "problem_idx": "C", "shortId": "739C", "contest_number": "739", "problem_submissions": {"C": [22442698, 22439403, 22439035, 22441010, 22452684, 22437700, 22438882, 22439230, 22438925, 22440648, 22439930, 22440447, 22440445, 22442265, 22442505, 22443020, 22443464, 22471543], "A": [22439350, 22427880, 22428059, 22427929, 22427879, 22427835, 22427894, 22569748, 22427875, 22427910, 22428905, 22428165, 22427839, 22428416, 22427876, 22427815, 22428207, 22427895, 22461370, 22461352, 22428531], "B": [22438821, 22430420, 22433537, 22432542, 22430611, 22432279, 22431221, 22432719, 22432020, 22433235, 22432524, 22433360, 22434177, 22433963, 22430137, 22435255, 22433707, 22459456, 22459424, 22459398, 22442832], "E": [22435846, 23367614, 23367585, 23236778, 22443543, 31723439, 22934699, 22934399, 22516029, 22515992, 22463839, 22463413, 22443763, 22446956, 22453608, 22445886, 22461332, 22692840, 22455977, 22471655, 22471636, 22461535, 22447302], "D": [22462793, 22462750, 22462690, 22450389, 22469047, 22498066]}, "name": "C. Alyona and towers", "statement": "Alyona has built towers by putting small cubes some on the top of\r\nothers. Each cube has size . A tower is a non-zero amount of cubes\r\nstanding on the top of each other. The towers are next to each other,\r\nforming a row.Sometimes Alyona chooses some segment towers, and put on\r\nthe top of each tower several cubes. Formally, Alyouna chooses some\r\nsegment of towers from to and adds cubes on the top of them.Let the\r\nsequence be the heights of the towers from left to right. Let\u2019s call as\r\na segment of towers a hill if the following condition holds: there is\r\ninteger () such that .After each addition of cubes on the top of the\r\ntowers from to , Alyona wants to know the maximum width among all hills.\r\nThe width of a hill is the number of towers in it.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=301000;\nstruct node {\n\tll fg,l,r;\n\tint ld,lu,rd,ru,f,sz;\n}nd[4*N];\nint a[N],l,r,v,n,m;\nvoid upd(int p) {\n\tbool lg=nd[p+p].r>nd[p+p+1].l,rg=nd[p+p].r<nd[p+p+1].l;\n\tif (nd[p+p].ld==nd[p+p].sz&&lg) \n\t\tnd[p].ld=nd[p+p].sz+nd[p+p+1].ld;\n\telse nd[p].ld=nd[p+p].ld;\n\tif (nd[p+p+1].rd==nd[p+p+1].sz&&rg)\n\t\tnd[p].rd=nd[p+p+1].sz+nd[p+p].rd;\n\telse nd[p].rd=nd[p+p+1].rd;\n\tif (nd[p+p].lu==nd[p+p].sz) {\n\t\tif (nd[p+p].rd==nd[p+p].sz) {\n\t\t\tif (rg) nd[p].lu=nd[p+p].sz+nd[p+p+1].lu;\n\t\t\tif (lg) nd[p].lu=nd[p+p].sz+nd[p+p+1].ld;\n\t\t\tif (!lg&&!rg) nd[p].lu=nd[p+p].sz;\n\t\t} else {\n\t\t\tif (!lg) nd[p].lu=nd[p+p].sz;\n\t\t\tif (lg) nd[p].lu=nd[p+p].sz+nd[p+p+1].ld;\n\t\t}\n\t} else nd[p].lu=nd[p+p].lu;\n\tif (nd[p+p+1].ru==nd[p+p+1].sz) {\n\t\tif (nd[p+p+1].ld==nd[p+p+1].sz) {\n\t\t\tif (lg) nd[p].ru=nd[p+p+1].sz+nd[p+p].ru;\n\t\t\tif (rg) nd[p].ru=nd[p+p+1].sz+nd[p+p].rd;\n\t\t\tif (!lg&&!rg) nd[p].ru=nd[p+p+1].sz;\n\t\t} else {\n\t\t\tif (!rg) nd[p].ru=nd[p+p+1].sz;\n\t\t\tif (rg) nd[p].ru=nd[p+p+1].sz+nd[p+p].rd;\n\t\t}\n\t} else nd[p].ru=nd[p+p+1].ru;\n\tnd[p].f=max(nd[p+p].f,nd[p+p+1].f);\n\tif (lg) nd[p].f=max(nd[p].f,nd[p+p].ru+nd[p+p+1].ld);\n\tif (rg) nd[p].f=max(nd[p].f,nd[p+p].rd+nd[p+p+1].lu);\n\tnd[p].l=nd[p+p].l;\n\tnd[p].r=nd[p+p+1].r;\n}\nvoid setf(int p,ll v) {\n\tnd[p].fg+=v; nd[p].l+=v; nd[p].r+=v;\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tnd[p].sz=r-l+1;\n\tnd[p].l=a[l]; nd[p].r=a[r];\n\tif (l==r) {\n\t\tnd[p].fg=0;\n\t\tnd[p].ld=nd[p].lu=nd[p].rd=nd[p].ru=nd[p].f=1;\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nvoid push(int p) {\n\tif (nd[p].fg) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,ll v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",a+i);\n\tbuild(1,1,n);\n\tscanf(\"%d\",&m);\n//\tprintf(\"%d\\n\",nd[1].f);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",&l,&r,&v);\n\t\tmodify(1,1,n,l,r,v);\n\t\tprintf(\"%d\\n\",nd[1].f);\n\t}\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2500", "interactive": false}