{
    "link": "https://codeforces.com//contest/1603/problem/F",
    "problemId": "1163974",
    "problem_idx": "F",
    "shortId": "1603F",
    "contest_number": "1603",
    "problem_submissions": {
        "D": [
            133678384,
            133698397,
            133689761,
            133665373,
            133663811,
            133667904,
            133870635,
            133666377,
            133712181,
            133672518,
            133669513,
            133671913,
            133674123,
            133668504,
            133670450,
            134053883,
            133670044
        ],
        "E": [
            133654251,
            133698597,
            133670917,
            133670921,
            133674718,
            133678832,
            133691448,
            133677480,
            133745184,
            133682168,
            158346606
        ],
        "C": [
            133634336,
            133654076,
            133641887,
            133643661,
            133700965,
            133639890,
            133639559,
            133648557,
            133635180,
            133642566,
            133633281,
            133658219,
            133645221,
            133638128,
            133655485,
            133647398,
            133646553,
            133645458,
            133645891,
            133650269,
            134161088,
            133646180
        ],
        "B": [
            133625504,
            133622630,
            133627460,
            133627705,
            133633891,
            133623525,
            133628792,
            133627917,
            133622898,
            133644787,
            133630406,
            133626809,
            133635643,
            133632995,
            133629432,
            133625758,
            133629935,
            133631448,
            134161095,
            133621172
        ],
        "A": [
            133616996,
            133617371,
            133618050,
            133618145,
            133618661,
            133618290,
            133617671,
            133620309,
            133617150,
            133619091,
            133618690,
            133618619,
            133622033,
            133621990,
            133618626,
            133617653,
            133618140,
            133620543,
            134161100,
            133617177
        ],
        "F": [
            133669341,
            133700346,
            133679782,
            133709673,
            133694728,
            133720215,
            133975676,
            134484874,
            158277914
        ]
    },
    "name": "F. October 18, 2017",
    "statement": "You are given three integers n, k and x. Find the number, modulo 998\r\n,244\r\n,353, of integer sequences a_1, a_2,\r\nldots, a_n such that the following conditions are satisfied: 0\r\nle a_i\r\nlt 2^k for each integer i from 1 to n. There is no non-empty subsequence\r\nin a such that the bitwise XOR of the elements of the subsequence is x.\r\nA sequence b is a subsequence of a sequence c if b can be obtained from\r\nc by deletion of several (possibly, zero or all) elements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int MAXB = 10000000, INV2 = (MOD + 1) / 2;\n\nint ppw[10000005], prp[10000005], pinv[10000005];\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1ULL * ret * x % MOD;\n\t\tx = 1ULL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, k, x;\nvoid solve()\n{\n\tscanf(\"%d%d%d\", &n, &k, &x);\n\tif(x == 0) {\n\t\tif(n > k) {\n\t\t\tprintf(\"0\\n\"); return;\n\t\t}\n\t\tint ret = 1ULL * prp[k] * pinv[k - n] % MOD;\n\t\trep(i, n) ret = 1ULL * ret * ppw[i] % MOD;\n\t\tprintf(\"%d\\n\", ret);\n\t} else {\n\t\tint ret = 0, ccf = 1, tmp = power(2, n);\n\t\tfor(int i = 0; i <= k; i ++) {\n\t\t\tint prob = i == 0 ? 1 : (1 + 1ULL * pinv[k] * prp[k - 1] % MOD * (MOD - ppw[i] + 1)) % MOD;\n\t\t\tret = (ret + 1ULL * ccf * pinv[i] % MOD * prob) % MOD;\n\t\t\tccf = 1ULL * ccf * (tmp - 1) % MOD * (ppw[k - i] - 1) % MOD;\n\t\t\ttmp = 1ULL * tmp * INV2 % MOD;\n\t\t\tccf = 1ULL * ccf * ppw[i] % MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n}\n\nint main()\n{\n\tppw[0] = 1;\n\trep1(i, MAXB) ppw[i] = 2 * ppw[i - 1] % MOD;\n\tprp[0] = 1;\n\trep1(i, MAXB) prp[i] = 1ULL * prp[i - 1] * (ppw[i] - 1) % MOD;\n\tpinv[MAXB] = power(prp[MAXB], MOD - 2);\n\tfor(int i = MAXB; i >= 1; i --) pinv[i - 1] = 1ULL * pinv[i] * (ppw[i] - 1) % MOD;\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile(T --) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. October 18, 2017.json",
    "editorial_link": "https://codeforces.com//blog/entry/96460",
    "editorial": "When , we need to count the\nnumber of sequences , such that the s are linearly independent. Clearly,\nfor there are no such sequences, and for , the answer is , as can be any\nelement not generated by the elements , and they generate exactly\nelements.Now, let\u00e2\u0080\u0099s deal with the case . It\u00e2\u0080\u0099s easy to see that the exact\nvalue of doesn\u00e2\u0080\u0099t matter here, it\u00e2\u0080\u0099s easy to construct a bijection between\nsuch sequences for this problem and such sequences for the case , by\nchange of basis from the one which has as the first element to one which\nhas as the first element. So from now on .We will show that the answer\nfor given is More generally, it\u00e2\u0080\u0099s This is easy to calculate in , by\ncalculating prefix products in , and finding in and its powers in . Now,\nlet\u00e2\u0080\u0099s prove the formula.It\u00e2\u0080\u0099s possible to prove the formula by some\ninclusion-exclusion arguments, but here we will present a bit more\ncombinatorial approach. Let\u00e2\u0080\u0099s just look at and find some combinatorial\ninterpretation for it. Let\u00e2\u0080\u0099s consider a linear space of dimension (with\nelements), containing . Consider all its subspaces of dimension .\nFirstly, how many of them are there? Exactly , each corresponding to the\nonly nonzero element of the orthogonal complement of the subspace. It\u00e2\u0080\u0099s\neasy to see that exactly of them will contain , and other won\u00e2\u0080\u0099t.Then,\nthere is a natural representation of the number it\u00e2\u0080\u0099s the number of\nsequences of spaces , where: is the whole space of our problem, of\ndimension , For from to , is a subspace of of dimension , containing .\nis a subspace of of dimension , containing .Then, is the number of\nsequences , where sets are described as above, and all elements of lie\nin (as there are ways to choose each of them).This starts to resemble\nwhat we need... As in such structure, space generated by won\u00e2\u0080\u0099t be able\nto contain , and it\u00e2\u0080\u0099s exactly the kind of arrays we are interested\nin.So, we want to show that the actual number of arrays from the\nstatement is equal to the number of tuples , where the tuple is counted\nwith a plus sign for even and with a minus sign for odd . It\u00e2\u0080\u0099s enough to\nprove that each array will be counted exactly once this way (meaning\nthat it will be in tuples taken with plus one more time than in tuples\ntaken with a minus). Fine, let\u00e2\u0080\u0099s consider an array such that subspace\nspanned by it doesn\u00e2\u0080\u0099t contain and look at the sequences of sets such\nthat is contained in . If the subspace generated by is , we just need\nall spaces to contain . If size of is , there is a bijection between\nsuch sequences and sequences , where is the space orthogonal to subspace\n, of dimension , For from to , is a subspace of of dimension ,\ncontaining . is a subspace of of dimension , containing .But the number\nof such sequences for a fixed is precisely ! So, we need to show that\nthe sum of this (with correspondent signs) over from to is . Let\u00e2\u0080\u0099s\nreplace by , we need to show that This is easy to prove by induction, as\nafter moving to the right side it\u00e2\u0080\u0099s equivalent to , and we can cancel\nfrom both sides and get the same equation, but now for .\n"
}