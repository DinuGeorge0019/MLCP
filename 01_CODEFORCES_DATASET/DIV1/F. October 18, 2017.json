{"link": "https://codeforces.com//contest/1603/problem/F", "problemId": "1163974", "problem_idx": "F", "shortId": "1603F", "contest_number": "1603", "problem_submissions": {"D": [133678384, 133698397, 133689761, 133665373, 133663811, 133667904, 133870635, 133666377, 133712181, 133672518, 133669513, 133671913, 133674123, 133668504, 133670450, 134053883, 133670044], "E": [133654251, 133698597, 133670917, 133670921, 133674718, 133678832, 133691448, 133677480, 133745184, 133682168, 158346606], "C": [133634336, 133654076, 133641887, 133643661, 133700965, 133639890, 133639559, 133648557, 133635180, 133642566, 133633281, 133658219, 133645221, 133638128, 133655485, 133647398, 133646553, 133645458, 133645891, 133650269, 134161088, 133646180], "B": [133625504, 133622630, 133627460, 133627705, 133633891, 133623525, 133628792, 133627917, 133622898, 133644787, 133630406, 133626809, 133635643, 133632995, 133629432, 133625758, 133629935, 133631448, 134161095, 133621172], "A": [133616996, 133617371, 133618050, 133618145, 133618661, 133618290, 133617671, 133620309, 133617150, 133619091, 133618690, 133618619, 133622033, 133621990, 133618626, 133617653, 133618140, 133620543, 134161100, 133617177], "F": [133669341, 133700346, 133679782, 133709673, 133694728, 133720215, 133975676, 134484874, 158277914]}, "name": "F. October 18, 2017", "statement": "You are given three integers n, k and x. Find the number, modulo 998\r\n,244\r\n,353, of integer sequences a_1, a_2,\r\nldots, a_n such that the following conditions are satisfied: 0\r\nle a_i\r\nlt 2^k for each integer i from 1 to n. There is no non-empty subsequence\r\nin a such that the bitwise XOR of the elements of the subsequence is x.\r\nA sequence b is a subsequence of a sequence c if b can be obtained from\r\nc by deletion of several (possibly, zero or all) elements.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int MAXB = 10000000, INV2 = (MOD + 1) / 2;\n\nint ppw[10000005], prp[10000005], pinv[10000005];\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1ULL * ret * x % MOD;\n\t\tx = 1ULL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, k, x;\nvoid solve()\n{\n\tscanf(\"%d%d%d\", &n, &k, &x);\n\tif(x == 0) {\n\t\tif(n > k) {\n\t\t\tprintf(\"0\\n\"); return;\n\t\t}\n\t\tint ret = 1ULL * prp[k] * pinv[k - n] % MOD;\n\t\trep(i, n) ret = 1ULL * ret * ppw[i] % MOD;\n\t\tprintf(\"%d\\n\", ret);\n\t} else {\n\t\tint ret = 0, ccf = 1, tmp = power(2, n);\n\t\tfor(int i = 0; i <= k; i ++) {\n\t\t\tint prob = i == 0 ? 1 : (1 + 1ULL * pinv[k] * prp[k - 1] % MOD * (MOD - ppw[i] + 1)) % MOD;\n\t\t\tret = (ret + 1ULL * ccf * pinv[i] % MOD * prob) % MOD;\n\t\t\tccf = 1ULL * ccf * (tmp - 1) % MOD * (ppw[k - i] - 1) % MOD;\n\t\t\ttmp = 1ULL * tmp * INV2 % MOD;\n\t\t\tccf = 1ULL * ccf * ppw[i] % MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n}\n\nint main()\n{\n\tppw[0] = 1;\n\trep1(i, MAXB) ppw[i] = 2 * ppw[i - 1] % MOD;\n\tprp[0] = 1;\n\trep1(i, MAXB) prp[i] = 1ULL * prp[i - 1] * (ppw[i] - 1) % MOD;\n\tpinv[MAXB] = power(prp[MAXB], MOD - 2);\n\tfor(int i = MAXB; i >= 1; i --) pinv[i - 1] = 1ULL * pinv[i] * (ppw[i] - 1) % MOD;\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile(T --) solve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "dp", "implementation", "math"], "dificulty": "2700", "interactive": false}