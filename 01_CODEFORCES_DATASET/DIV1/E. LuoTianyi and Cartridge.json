{
    "link": "https://codeforces.com//contest/1824/problem/E",
    "problemId": "1909042",
    "problem_idx": "E",
    "shortId": "1824E",
    "contest_number": "1824",
    "problem_submissions": {
        "E": [
            205128571,
            205139739,
            205144104,
            205137280,
            205130495,
            205118718,
            205194940,
            205235861,
            205235298,
            205232550,
            205700234,
            205699976
        ],
        "D": [
            205099783,
            205099421,
            205104253,
            205142283,
            205135430,
            205107363,
            205103358,
            205109375,
            205130576,
            205106777,
            205111380,
            205108131,
            205113889,
            205109692,
            205110237,
            205111676,
            205111818,
            205116723,
            205113358,
            205116564,
            205115264,
            205122150
        ],
        "C": [
            205092605,
            205093858,
            205095306,
            205093905,
            205096370,
            205095737,
            205137755,
            205100625,
            205100857,
            205099284,
            205101290,
            205097496,
            205098177,
            205101207,
            205099752,
            205104989,
            205095505,
            205095555,
            205103206,
            205102161,
            205098628
        ],
        "B2": [
            205086508,
            205087676,
            205086929,
            205087663,
            205088713,
            205084760,
            205087488,
            205094809,
            205089113,
            205089568,
            205090318,
            205089714,
            205087793,
            205096844,
            205101610,
            205090439,
            205094629,
            205091373,
            205087601
        ],
        "B1": [
            205086422,
            205087787,
            205086792,
            205087589,
            205088569,
            205084970,
            205085855,
            205089877,
            205088994,
            205089640,
            205089081,
            205087696,
            205087867,
            205095794,
            205087977,
            205088492,
            205094450,
            205090371,
            205087429
        ],
        "A": [
            205083763,
            205085457,
            205082241,
            205082782,
            205083768,
            205088956,
            205081132,
            205083777,
            205081787,
            205082991,
            205086125,
            205082070,
            205083612,
            205083399,
            205081591,
            205083847,
            205088554,
            205081833,
            205083848
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/116328",
    "editorial": "Consider finding the maximum value of B+D\n for every min(A,C)\n. Denote min(A,C)\n as x\n. We call a vertex u\n satisfying au?x\n or an edge satisfying ce?x\n optional. Denote as V\n the optional vertex set and as E0\n the optional edge set.\n\nFirstly, if all optional vertices are on the same side of an edge, this edge mustn't be chosen. Delete these edges from E0\n and we get the edge set E\n. Formally, an edge e\n is in E\n if and only if ce?x\n and there exists u,v\n so that e\n is on the path between them.\n\nLemma.\n There exists an optimal Tans=(Vans,Eans)\n that either V=Vans\n or E=Eans\n.\n\nProof.\n Assume an optimal T?=(V?,E?)\n with V??V,E??E\n. Choose an edge e\n that is in E\n but not in E?\n. Because V??V\n, there must exist two vertices u,v\n on different sides of edge e\n and u?V?,v?V?\n. Consider adding the edge e\n and the vertex v\n into our chosen tree, the resulting graph is obviously a tree. Note that bv,de?0\n, so the resulting choice is no worse than T?\n.\n\nWhen we delete the edges in E\n from the original tree, we get some connected components. Shrink one component into a single vertex to get V?\n, and then for all edges (u,v)?E\n, connect u\n's and v\n's component together in the new graph and get E?\n. Obviously, the new graph T?=(V?,E?)\n is a tree.\n\nFor any leaf vertex u?\n on the new tree T?\n, there must exist a vertex u\n in the component u?\n that is chosen, otherwise the edge connecting to u?\n, let's say, e?\n is not chosen either. Adding u\n and e?\n into our answer tree achieves a better answer.\n\nAssume that now we have chosen a vertex u\n for every leaf u?\n, denote the set of chosen vertices as Vx\n. Consider an arbitary choice of vertex for components Vc\n and edge choice Ec\n satisfying Vx?Vc?V,Ec?E,|Vc|?1=|Ec|\n. It's easy to prove that the choice is a legal answer, given the fact that every e?Ec\n has at least one leaf component on each side and every leaf component contains a chosen vertex.\n\nReconsider the lemma, and we can get a solution for a fixed x\n:\n\nFind V,E\n. Calculate the components and get V?,E?\n.\nFind the vertex with the maximum b\n in every leaf-component in V?\n and get Vx\n.\nLet m\n be min(|V|,|E|+1)\n, and m?\n be |Vx|\n. Choose the vertices in V?Vx\n with the first m?m?\n largest b\n, and the edges in E\n with the first m?1\n largest d\n and get the answer.\nConsider the process when x\n gets larger, the sets V,E\n get smaller and smaller while the components merge into each other. We use segment trees to maintain the b\n value of the vertices and the d\n value of the edges, when merging two components, we simply merge the two segment trees.",
    "name": "E. LuoTianyi and Cartridge",
    "statement": "LuoTianyi is watching the anime . She finds that making a Cartridge is\r\ninteresting. To describe the process of making a Cartridge more clearly,\r\nshe abstracts the original problem and gives you the following\r\nproblem.You are given a tree T consisting of n vertices. Each vertex has\r\nvalues a_i and b_i and each edge has values c_j and d_j.Now you are aim\r\nto build a T’ as follows: First, select p vertices from T (p is a number\r\nchosen by yourself) as the vertex set S’ of T’. Next, select p-1 edges\r\nfrom T one by one (you cannot select one edge more than once). May you\r\nhave chosen the j-th edge connects vertices x_j and y_j with values\r\n(c_j,d_j), then you can choose two vertices u and v in S’ that satisfy\r\nthe edge (x_j,y_j) is contained in the simple path from u to v in T, and\r\nlink u and v in T’ by the edge with values (c_j,d_j) (u and v shouldn’t\r\nbe contained in one connected component before in T’). Let A be the\r\nminimum of values a_i in T’ and C be the minimum of values c_i in T’.\r\nLet B be the sum of b_i in T’ and D be the sum of values d_i in T’. Let\r\nmin(A, C)\r\ncdot (B + D) be the of T’. You need to find the maximum possible cost of\r\nT’.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;struct HLD {    int n;    std::vector<int> siz, top, dep, parent, in, out, seq;    std::vector<std::vector<int>> adj;    int cur;        HLD() {}    HLD(int n) {        init(n);    }    void init(int n) {        this->n = n;        siz.resize(n);        top.resize(n);        dep.resize(n);        parent.resize(n);        in.resize(n);        out.resize(n);        seq.resize(n);        cur = 0;        adj.assign(n, {});    }    void addEdge(int u, int v) {        adj[u].push_back(v);        adj[v].push_back(u);    }    void work(int root = 0) {        top[root] = root;        dep[root] = 0;        parent[root] = -1;        dfs1(root);        dfs2(root);    }    void dfs1(int u) {        if (parent[u] != -1) {            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), parent[u]));        }                siz[u] = 1;        for (auto &v : adj[u]) {            parent[v] = u;            dep[v] = dep[u] + 1;            dfs1(v);            siz[u] += siz[v];            if (siz[v] > siz[adj[u][0]]) {                std::swap(v, adj[u][0]);            }        }    }    void dfs2(int u) {        in[u] = cur++;        seq[in[u]] = u;        for (auto v : adj[u]) {            top[v] = v == adj[u][0] ? top[u] : v;            dfs2(v);        }        out[u] = cur;    }    int lca(int u, int v) {        while (top[u] != top[v]) {            if (dep[top[u]] > dep[top[v]]) {                u = parent[top[u]];            } else {                v = parent[top[v]];            }        }        return dep[u] < dep[v] ? u : v;    }        int dist(int u, int v) {        return dep[u] + dep[v] - 2 * dep[lca(u, v)];    }        int jump(int u, int k) {        if (dep[u] < k) {            return -1;        }                int d = dep[u] - k;                while (dep[top[u]] > d) {            u = parent[top[u]];        }                return seq[in[u] - dep[u] + d];    }        bool isAncester(int u, int v) {        return in[u] <= in[v] && in[v] < out[u];    }        int rootedParent(int u, int v) {        std::swap(u, v);        if (u == v) {            return u;        }        if (!isAncester(u, v)) {            return parent[u];        }        auto it = std::upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y) {            return in[x] < in[y];        }) - 1;        return *it;    }        int rootedSize(int u, int v) {        if (u == v) {            return n;        }        if (!isAncester(v, u)) {            return siz[v];        }        return n - siz[rootedParent(u, v)];    }        int rootedLca(int a, int b, int c) {        return lca(a, b) ^ lca(b, c) ^ lca(c, a);    }};struct DSU {    std::vector<int> f, siz;        DSU() {}    DSU(int n) {        init(n);    }        void init(int n) {        f.resize(n);        std::iota(f.begin(), f.end(), 0);        siz.assign(n, 1);    }        int find(int x) {        while (x != f[x]) {            x = f[x] = f[f[x]];        }        return x;    }        bool same(int x, int y) {        return find(x) == find(y);    }        bool merge(int x, int y) {        x = find(x);        y = find(y);        if (x == y) {            return false;        }        siz[x] += siz[y];        f[y] = x;        return true;    }        int size(int x) {        return siz[find(x)];    }}; template<class Info>struct SegmentTree {    int n;    std::vector<Info> info;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template<class T>    SegmentTree(std::vector<T> init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template<class T>    void init(std::vector<T> init_) {        n = init_.size();        info.assign(4 << std::__lg(n), Info());        std::function<void(int, int, int)> build = [&](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void modify(int p, int l, int r, int x, const Info &v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        if (x < m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l >= y || r <= x) {            return Info();        }        if (l >= x && r <= y) {            return info[p];        }        int m = (l + r) / 2;        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    template<class F>    int findFirst(int p, int l, int r, int x, int y, F pred) {        if (l >= y || r <= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template<class F>    int findFirst(int l, int r, F pred) {        return findFirst(1, 0, n, l, r, pred);    }    template<class F>    int findLast(int p, int l, int r, int x, int y, F pred) {        if (l >= y || r <= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template<class F>    int findLast(int l, int r, F pred) {        return findLast(1, 0, n, l, r, pred);    }}; constexpr int inf = 1E9;struct Min {    int x = inf;}; Min operator+(Min a, Min b) {    return {std::min(a.x, b.x)};}template <typename T>struct Fenwick {    int n;    std::vector<T> a;        Fenwick(int n = 0) {        init(n);    }        void init(int n) {        this->n = n;        a.assign(n, T());    }        void add(int x, T v) {        for (int i = x + 1; i <= n; i += i & -i) {            a[i - 1] += v;        }    }        T sum(int x) {        auto ans = T();        for (int i = x; i > 0; i -= i & -i) {            ans += a[i - 1];        }        return ans;    }        T rangeSum(int l, int r) {        return sum(r) - sum(l);    }        int kth(T k) {        int x = 0;        for (int i = 1 << std::__lg(n); i; i /= 2) {            if (x + i <= n && k >= a[x + i - 1]) {                x += i;                k -= a[x - 1];            }        }        return x;    }}; int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n;    std::cin >> n;        std::vector<int> a(2 * n - 1), b(2 * n - 1);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }    for (int i = 0; i < n; i++) {        std::cin >> b[i];    }        HLD t(n);    std::vector<int> x(n - 1), y(n - 1);    for (int i = 0; i < n - 1; i++) {        std::cin >> x[i] >> y[i] >> a[n + i] >> b[n + i];        x[i]--, y[i]--;                t.addEdge(x[i], y[i]);    }    t.work();        auto vb = b;    std::sort(vb.begin(), vb.end(), std::greater());    for (int i = 0; i < 2 * n - 1; i++) {        b[i] = std::lower_bound(vb.begin(), vb.end(), b[i], std::greater()) - vb.begin();    }        auto cmp = [&](int x, int y) {        return t.in[x] < t.in[y];    };    std::set<int, decltype(cmp)> s(cmp);    std::vector<int> c(n), d(n);    for (int i = 0; i < n - 1; i++) {        if (t.parent[x[i]] != y[i]) {            std::swap(x[i], y[i]);        }        c[x[i]] = a[n + i];        d[x[i]] = b[n + i];    }        std::vector<int> ord(2 * n - 1);    std::iota(ord.begin(), ord.end(), 0);    std::sort(ord.begin(), ord.end(), [&](int i, int j) {        return a[i] > a[j];    });        SegmentTree<Min> seg(n);        int top = -1;        Fenwick<int> fc(2 * n - 1), fce(2 * n - 1);    Fenwick<i64> fs(2 * n - 1), fse(2 * n - 1);    i64 sumb = 0;    auto add = [&](int x, int t = 1) {        fc.add(x, t);        fs.add(x, vb[x] * t);    };        std::set<int, decltype(cmp)> sdown(cmp);    i64 sumv = 0;    auto addv = [&](int x) {        // std::cerr << \"addvertex \" << x + 1 << \"\\n\";                sumv += vb[b[x]];        add(b[x]);                auto it = sdown.upper_bound(x);        int u = -1;        if (it != sdown.begin() && t.in[x] < t.out[*std::prev(it)]) {            u = *std::prev(it);        }                if (u != -1) {            auto v = seg.rangeQuery(t.in[u], t.out[u]).x;            if (v != inf) {                add(v);                sumb -= vb[v];            }        }        seg.modify(t.in[x], {b[x]});        if (u != -1) {            auto v = seg.rangeQuery(t.in[u], t.out[u]).x;            if (v != inf) {                add(v, -1);                sumb += vb[v];            }        }    };        int L = n, R = 0;        int cnte = 0;    auto adde = [&](int x) {        // std::cerr << \"addedge (\" << x + 1 << \", \" << t.parent[x] + 1 << \")\\n\";        cnte++;        sumb += vb[d[x]];        fce.add(d[x], 1);        fse.add(d[x], vb[d[x]]);        L = std::min(L, t.in[x]);        R = std::max(R, t.out[x]);                if (top == -1 || t.dep[x] < t.dep[top]) {            top = x;        }                auto it = sdown.upper_bound(x);        if (it != sdown.begin() && t.in[x] < t.out[*std::prev(it)]) {            int u = *std::prev(it);            auto v = seg.rangeQuery(t.in[u], t.out[u]).x;            if (v != inf) {                add(v);                sumb -= vb[v];            }            sdown.erase(u);        }        it = sdown.lower_bound(x);        if (it != sdown.end() && t.in[*it] < t.out[x]) {            return;        }        sdown.insert(x);        auto v = seg.rangeQuery(t.in[x], t.out[x]).x;        if (v != inf) {            add(v, -1);            sumb += vb[v];        }    };        auto query = [&]() {        if (cnte >= s.size() - 1) {            int res = s.size() - 1;            i64 sum = sumv;            int t = fce.kth(res);            sum += fse.sum(t);            res -= fce.sum(t);            if (res) {                sum += 1LL * res * vb[t];            }            return sum;        }        int res = cnte + 1 - sdown.size();        i64 sum = sumb;        if (top != -1) {            if (t.in[top] > L || t.out[top] < R) {                top = -1;            }        }        int v = -1;        if (top != -1) {            res--;            v = (seg.rangeQuery(0, t.in[top]) + seg.rangeQuery(t.out[top], n)).x;            add(v, -1);            sum += vb[v];        }        int t = fc.kth(res);        sum += fs.sum(t);        res -= fc.sum(t);        if (res) {            sum += 1LL * res * vb[t];        }        if (v != -1) {            add(v);        }        // std::cerr << \"p : \" << cnte + 1 << \"\\n\";        // std::cerr << \"sumb : \" << sumb << \"\\n\";        // std::cerr << \"sum : \" << sum << \"\\n\";        // std::cerr << \"-----\\n\";        return sum;    };        std::vector<bool> vis(n);    i64 ans = 0;    for (int i = 0; i < n; i++) {        ans = std::max(ans, 1LL * a[i] * vb[b[i]]);    }    DSU dsu(n);    for (auto i : ord) {        i64 min = a[i];        if (i < n) {            auto it = s.insert(i).first;            int lst = it == s.begin() ? *s.rbegin() : *std::prev(it);            int nxt = std::next(it) == s.end() ? *s.begin() : *std::next(it);            for (auto x : {lst, nxt}) {                int y = i;                x = dsu.find(x);                y = dsu.find(y);                while (x != y) {                    if (t.dep[x] < t.dep[y]) {                        std::swap(x, y);                    }                    if (vis[x]) {                        adde(x);                    }                    vis[x] = true;                    dsu.merge(t.parent[x], x);                    x = dsu.find(x);                }            }            addv(i);        } else {            i -= n;            if (vis[x[i]]) {                adde(x[i]);            }            vis[x[i]] = true;        }        if (!s.empty()) {            // std::cerr << \"min : \" << min << \"\\n\";            ans = std::max(ans, min * query());        }    }        std::cout << ans << \"\\n\";        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. LuoTianyi and Cartridge.json",
    "hint": []
}