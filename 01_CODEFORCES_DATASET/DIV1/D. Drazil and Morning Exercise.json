{"link": "https://codeforces.com//contest/516/problem/D", "problemId": "22480", "problem_idx": "D", "shortId": "516D", "contest_number": "516", "problem_submissions": {"D": [9897778, 9901317, 9902316, 9902257, 9902926, 9899362, 9901747, 9900577, 9901753, 9900598, 9902022, 9902250, 9908234, 9907894, 9901637, 10134694], "C": [9894077, 9894988, 9894528, 9894592, 9890787, 9892570, 9894045, 9897863, 9902115, 9893633, 9897304, 9906453, 9890308, 9915358, 9897994, 9896924, 9895656, 9894595, 9895218], "A": [9891009, 9888069, 9891404, 9888532, 9886301, 9886680, 9886736, 9887016, 9887312, 9885451, 9885346, 9886088, 9885688, 9885877, 9886467], "B": [9888215, 9890996, 9889129, 9891841, 9894454, 9896886, 9901312, 9890721, 9898664, 9916236, 9895068, 9891776, 9889048, 9930005, 9890589, 9889796, 9891061, 9898651], "E": [9897098, 9919136]}, "name": "D. Drazil and Morning Exercise", "statement": "Drazil and Varda are the earthworm couple. They want to find a good\r\nplace to bring up their children. They found a good ground containing\r\nnature hole. The hole contains many rooms, some pairs of rooms are\r\nconnected by small tunnels such that earthworm can move between\r\nthem.Let\u2019s consider rooms and small tunnels as the vertices and edges in\r\na graph. This graph is a . In the other words, any pair of vertices has\r\nan unique path between them.Each room that is in the graph is connected\r\nwith a ground by a vertical tunnel. Here, is a vertex that has only one\r\noutgoing edge in the graph.Each room is large enough only to fit one\r\nearthworm living in it. Earthworm can\u2019t live in a tunnel.Drazil and\r\nVarda have a plan to educate their children. They want all their\r\nchildren to do morning exercises immediately after getting up!When the\r\nmorning is coming, all earthworm children get up in the same time, then\r\neach of them chooses the path to the ground for gathering with others\r\n(these children are lazy, so they all want to do exercises as late as\r\npossible).Drazil and Varda want the difference between the time first\r\nearthworm child arrives outside and the time the last earthworm child\r\narrives outside to be not larger than (otherwise children will spread\r\naround the ground and it will be hard to keep them exercising\r\ntogether).Also, The rooms that are occupied by their children should\r\nform a set. In the other words, for any two rooms that are occupied with\r\nearthworm children, all rooms that lie on the path between them should\r\nbe occupied with earthworm children too.How many children Drazil and\r\nVarda may have at most in order to satisfy all conditions above? Drazil\r\nand Varda want to know the answer for many different choices of .(Drazil\r\nand Varda don\u2019t live in the hole with their children)\r\n", "solutions": ["#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MAX = 100005;\nvector<pair<int, int> > adj[MAX];\nlong long d1[MAX], d2[MAX];\nlong long st[MAX], fi[MAX], cnt;\nlong long seg[20][MAX], val[MAX];\nint n;\nvoid build(int d = 0, int s = 0, int e = n)\n{\n\tif (e - s < 2)\n\t{\n\t\tseg[d][s] = val[s];\n\t\treturn;\n\t}\n\tint mid = (s + e) / 2;\n\tbuild(d + 1, s, mid);\n\tbuild(d + 1, mid, e);\n\tmerge(seg[d + 1] + s, seg[d + 1] + mid, seg[d + 1] + mid, seg[d + 1] + e, seg[d] + s);\n}\nlong long get(int l, int r, long long val, int d = 0, int s = 0, int e = n)\n{\n\tif (l <= s && e <= r)\n\t\treturn lower_bound(seg[d] + s, seg[d] + e, val) - (seg[d] + s);\n\tif (e <= l || r <= s)\n\t\treturn 0;\n\tint mid = (s + e) / 2;\n\treturn get(l, r, val, d + 1, s, mid) + get(l, r, val, d + 1, mid, e);\n}\nvoid init()\n{\n\tfor (int i = 0; i < MAX; i++)\n\t{\n\t\td2[i] = d1[i];\n\t\td1[i] = 0;\n\t}\n}\nvoid dfs(int p, int v)\n{\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint u = adj[v][i].first, w = adj[v][i].second;\n\t\tif (u != p)\n\t\t{\n\t\t\td1[u] = d1[v] + w;\n\t\t\tdfs(v, u);\n\t\t}\n\t}\n}\nvoid go(int p, int v)\n{\n\tst[v] = cnt++;\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint u = adj[v][i].first;\n\t\tif (u != p)\n\t\t\tgo(v, u);\n\t}\n\tfi[v] = cnt;\n\tval[st[v]] = max(d1[v], d2[v]);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tu--;\n\t\tv--;\n\t\tadj[u].push_back(make_pair(v, w));\n\t\tadj[v].push_back(make_pair(u, w));\n\t}\n\tdfs(-1, 0);\n\tint v = 0;\n\tfor (int i = 1; i < n; i++)\n\t\tif (d1[v] < d1[i])\n\t\t\tv = i;\n\tinit();\n\tdfs(-1, v);\n\tint u = 0;\n\tfor (int i = 1; i < n; i++)\n\t\tif (d1[u] < d1[i])\n\t\t\tu = i;\n\tinit();\n\tdfs(-1, u);\n\tint root = 0;\n\tfor (int i = 1; i < n; i++)\n\t\tif (max(d1[root], d2[root]) > max(d1[i], d2[i]))\n\t\t\troot = i;\n\tgo(-1, root);\n\tbuild();\n\tint q;\n\tcin >> q;\n\twhile (q--)\n\t{\n\t\tlong long l;\n\t\tcin >> l;\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans = max(ans, get(st[i], fi[i], max(d1[i], d2[i]) + l + 1));\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "dsu", "trees", "two pointers"], "dificulty": "2800", "interactive": false}