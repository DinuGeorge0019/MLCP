{
    "link": "https://codeforces.com//contest/1168/problem/D",
    "problemId": "349591",
    "problem_idx": "D",
    "shortId": "1168D",
    "contest_number": "1168",
    "problem_submissions": {
        "D": [
            54689933,
            54709717,
            54687414,
            54689247,
            54692817,
            54690951,
            54687623,
            54690825,
            54690084,
            54693991,
            54691003,
            54691066,
            54691626,
            54692507,
            54689961,
            54693988,
            54752028,
            54747584,
            54782050,
            54716017,
            54694558
        ],
        "B": [
            54688206,
            54684470,
            54672670,
            54675422,
            54672484,
            54674963,
            54674803,
            54682027,
            54675650,
            54680245,
            54677508,
            54680443,
            54678955,
            54683400,
            54673481,
            54675324,
            54675597,
            54675910,
            54676117
        ],
        "A": [
            54679849,
            54670251,
            54678124,
            54670773,
            54670009,
            54671023,
            54672077,
            54670763,
            54669908,
            54672903,
            54670896,
            54674583,
            54671922,
            54670734,
            54670514,
            54670263,
            54670924,
            54670411,
            54671870
        ],
        "C": [
            54678044,
            54685816,
            54846089,
            54676677,
            54679735,
            54675366,
            54680183,
            54677459,
            54678103,
            54681414,
            54678145,
            54682238,
            54682671,
            54681429,
            54681732,
            54676972,
            54678213,
            54678234,
            54678543,
            54679007
        ],
        "E": [
            54672350,
            54679530,
            156967221,
            54891863,
            54891597
        ]
    },
    "name": "D. Anagram Paths",
    "statement": "Toad Ilya has a rooted binary tree with vertex 1 being the root. A tree\r\nis a connected graph without cycles. A tree is rooted if one vertex is\r\nselected and called the root. A vertex u is a child of a vertex v if u\r\nand v are connected by an edge and v is closer to the root than u. A\r\nleaf is a non-root vertex that has no children.In the tree Ilya has each\r\nvertex has children, and each edge has some character written on it. The\r\ncharacter can be a lowercase English letter or the question mark ”.Ilya\r\nwill q times update the tree a bit. Each update will replace exactly one\r\ncharacter on some edge. After each update Ilya needs to find if the tree\r\nis and if yes, find its for each letter. Well, that’s difficult to\r\nexplain, but we’ll try.To start with, a string a is an of a string b if\r\nit is possible to rearrange letters in a (without changing the letters\r\nitself) so that it becomes b. For example, the string \"\" is an anagram\r\nof the string \"\", but the string \"\" is not an anagram of the string\r\n\"\".Consider a path from the root of the tree to a leaf. The characters\r\non the edges on this path form a string, we say that this string is\r\nassociated with this leaf. The tree is if and only if it is possible to\r\nreplace each question mark with a lowercase English letter so that for\r\nall pair of leaves the associated strings for these leaves are anagrams\r\nof each other.If the tree is , then its for the letter c is the maximum\r\npossible number of letters c in a string associated with some leaf in a\r\nvalid replacement of all question marks.Please after each update find if\r\nthe tree is and if yes, find the\r\nsum{f(c)\r\ncdot ind(c)} for all letters c, where f(c) is the for the letter c, and\r\nind(x) is the index of this letter in the alphabet (ind(\"\") = 1, ind(\"\")\r\n= 2, ..., ind(\"\") = 26).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\n#define maxN 223456\n\n\nvector<int> son[maxN], scomp[maxN];\nint dp[maxN][30], cnt[maxN][30];\nint id[maxN], idpar[maxN], par[maxN], depc[maxN], sumd[maxN], invalid[maxN];\nint n, q, dep, idx, cnts;\nchar t[maxN], s[30];\n\nvoid dfs(int u, int d) {\n\tif (son[u].empty()) {\n\t\tif (dep == -1) {\n\t\t\tdep = d;\n\t\t}\n\t\tif (d != dep) {\n\t\t\tfor (int i = 0; i < q; i++)\n\t\t\t\tprintf(\"Fou\\n\");\n\t\t\texit(0);\n\t\t}\n\t}\n\tdepc[id[u]] = max(depc[id[u]], d);\n\tfor (auto v : son[u]) {\n\t\tif (u == 1 || (int)son[u].size() >= 2) {\n\t\t\tid[v] = ++idx;\n\t\t\tidpar[idx] = id[u];\n\t\t\tscomp[id[u]].push_back(idx);\n\t\t} else {\n\t\t\tid[v] = id[u];\n\t\t}\n\t\tdfs(v, d + 1);\n\t}\n}\n\nvoid modify(int u, int c, int delta) {\n\tif (c < 0) return;\n\tu = id[u];\n\tcnt[u][c] += delta;\n\twhile (true) {\n\t\tsumd[u] -= dp[u][c];\n\t\tcnts -= invalid[u];\n\t\tdp[u][c] = 0;\n\t\tfor (auto v : scomp[u]) {\n\t\t\tdp[u][c] = max(dp[u][c], dp[v][c] + cnt[v][c]);\n\t\t}\n\t\tsumd[u] += dp[u][c];\n\t\tinvalid[u] = sumd[u] > dep - depc[u];\n\t\tcnts += invalid[u];\n\t\tif (u == 0)\n\t\t\tbreak;\n\t\tu = idpar[u];\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%d%s\", &par[i], s);\n\t\tt[i] = s[0];\n\t\tson[par[i]].push_back(i);\n\t}\n\tdep = -1;\n\tdfs(1, 0);\n\tfor (int i = 2; i <= n; i++) {\n\t\tmodify(i, t[i] - 'a', 1);\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tint u;\n\t\tscanf(\"%d%s\", &u, s);\n\t\tmodify(u, t[u] - 'a', -1);\n\t\tt[u] = s[0];\n\t\tmodify(u, t[u] - 'a', 1);\n\t\tif (cnts) {\n\t\t\tprintf(\"Fou\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\ti64 ans = 0;\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tans += (i + 1) * (dep - (sumd[0] - dp[0][i]));\n\t\t}\n\t\tprintf(\"Shi %lld\\n\", ans);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Anagram Paths.json",
    "editorial_link": "https://codeforces.com//blog/entry/67241",
    "editorial": "Ok, letâs make some useless (ha-ha, in fact not) observation at first,\r\nobviously, all leaves must have the same depth.Now, I will define the\r\ncriterion for the tree to be good.Let be the largest number of\r\ncharacters that contained on edges of some path from vertex to the leaf,\r\nand be the length of a path from to the leaf.Lemma: tree is good iff for\r\neach vertex .Obviously, if the tree is good for each vertex because else\r\nyou just donât have enough \"space\" in the subtree of the vertex to\r\ncontain all required characters.Why is it criterion? If for each vertex\r\nit is satisfied, from the root you can find some suitable characters on\r\nthe edges from it, and then it is easy to see that you can restore the\r\nchildren by induction.Ok, with this knowledge how to solve the problem?\r\nMaybe some spooky tree data structures will help us?... Yup, you can do\r\nit with the \"Dynamic tree DP technique\" with HLD, and you will get the\r\nsolution in even for not a binary tree.But it is not very easy to\r\nrealize it :)Letâs remember that all leaves must have the same depth, so\r\nI will give you another Lemma!Lemma: if you will \"compress\" all vertices\r\nwith one son in the tree, where all leaves have an equal depth, then the\r\ndepth of this tree will be .Why? let be the number of vertices on the\r\ndepth , then for each as each vertex at the depth should have at least\r\none son, and you have , so there are distinct values among them, so\r\nalmost all (without some values) has (which means that all vertices at\r\nthe depth has exactly one son).So with this knowledge, you can\r\n\"compress\" the tree as I described, and after each query just go up from\r\nthe end of the changed edge and recalculate the DP. Of course, each edge\r\nnow will have several characters on it, so you should maintain a counter\r\nin each edge, but it is more a realization aspect.Finally, here is the\r\nsolution\r\n",
    "hint": []
}