{
    "link": "https://codeforces.com//contest/623/problem/E",
    "problemId": "47315",
    "problem_idx": "E",
    "shortId": "623E",
    "contest_number": "623",
    "problem_submissions": {
        "C": [
            15809186,
            15807923,
            15810181,
            15806671,
            15808652,
            15818870,
            15811297,
            15824389,
            15801567
        ],
        "D": [
            15802822,
            15804610,
            15804063,
            15810065,
            15809969,
            15800847,
            15801410,
            15804877,
            15805201,
            15809200,
            15805279,
            15805265,
            15803978,
            15806446,
            15804093,
            15805984,
            15809435,
            15808164
        ],
        "B": [
            15799385,
            15799937,
            15800370,
            15800033,
            15797877,
            15808021,
            15799907,
            15800024,
            15802615,
            15799613,
            15799768,
            15806416,
            15803166,
            15800459,
            15801892,
            15800003,
            15806962,
            15802319
        ],
        "A": [
            15794295,
            15794155,
            15793520,
            15793524,
            15802472,
            15806700,
            15794661,
            15793789,
            15793952,
            15802327,
            15793050,
            15794635,
            15796862,
            15810492,
            15795834,
            15794597,
            15792903,
            15798814
        ],
        "E": [
            15807539,
            15822584
        ]
    },
    "name": "E. Transforming Sequence",
    "statement": "Let’s define the transformation of a sequence of integers as , where for\r\nall , where is the bitwise OR operation.Vasya consequently applies the\r\ntransformation to all sequences of length consisting of integers from to\r\ninclusive. He wants to know how many of these sequences have such\r\nproperty that their transformation is a sequence. Help him to calculate\r\nthis number modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=301000;\nll ret[N],coef[N],tmp[N],fnv[N],n;\nint k,K;\nvoid mult(ll *x,ll y) {\n\tll c=1;\n\trep(i,0,K+1) {\n\t\tx[i]=x[i]*c%mod;\n\t\tc=c*y%mod;\n\t}\n}\nvoid multt(ll *x,ll y) {\n\trep(i,0,K+1) x[i]=x[i]*y%mod;\n}\n\nll buffer[N],buffer_pos,size=32768;\n\nvoid multiply(int size,ll a[],ll b[],ll r[]) {\n\tif (size<=16) {\n\t\tfor (int i=0;i<size+size;i++) r[i]=0;\n\t\tfor (int i=0;i<size;i++) if (a[i]) for (int j=0;j<size;j++) {\n\t\t\tr[i+j]+=a[i]*b[j];\n\t\t\tif (r[i+j]>=8000000000000000000ll) r[i+j]%=mod;\n\t\t}\n\t\tfor (int i=0;i<size+size;i++) r[i]%=mod;\n\t\treturn;\n\t}\n\tint s=size/2;\n\tmultiply(s,a,b,r);\n\tmultiply(s,a+s,b+s,r+size);\n\tll *a2=buffer+buffer_pos; buffer_pos+=s;\n\tll *b2=buffer+buffer_pos; buffer_pos+=s;\n\tll *r2=buffer+buffer_pos; buffer_pos+=size;\n\tfor (int i=0;i<s;i++) { a2[i]=a[i]+a[i+s]; if (a2[i]>=mod) a2[i]-=mod; }\n\tfor (int i=0;i<s;i++) { b2[i]=b[i]+b[i+s]; if (b2[i]>=mod) b2[i]-=mod; }\n\tmultiply(s,a2,b2,r2);\n\tfor (int i=0;i<size;i++) r2[i]-=r[i]+r[i+size];\n\tfor (int i=0;i<size;i++) { r[i+s]+=r2[i]; r[i+s]%=mod; if (r[i+s]<0) r[i+s]+=mod; }\n\tbuffer_pos-=(s+s+size);\n}\nvoid mul(ll *a,ll *b) {\n\tll *r=buffer+buffer_pos;\n\tbuffer_pos+=size+size;\n\tmultiply(size,a,b,r);\n\tfor (int i=0;i<size;i++) a[i]=r[i];\n\tbuffer_pos-=size+size;\t\n}\nvoid poww(int n) {\n\tif (n==1) {\n\t\trep(i,0,K+1) ret[i]=coef[i];\n\t} else if (n%2==1) {\n\t\tpoww(n-1);\n\t\tmult(ret,2);\n\t\tmultt(ret,powmod(2,n-1));\n\t\tmul(ret,coef);\n\t} else {\n\t\tpoww(n/2);\n\t\trep(i,0,K+1) tmp[i]=ret[i];\n\t\tmult(tmp,powmod(2,n/2));\n\t\tmultt(tmp,powmod(2,(n/2)*(n/2)));\n\t\tmul(ret,tmp);\n\t}\n}\nint main() {\n\tscanf(\"%I64d%d\",&n,&k);\n\tif (n>k) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tfnv[0]=1;\n\tK=k-n;\n\twhile (size/2>K+1) size/=2;\n\trep(i,1,k+1) fnv[i]=fnv[i-1]*powmod(i,mod-2)%mod;\n\trep(i,0,K+1) coef[i]=fnv[i+1];\n\tret[0]=1;\n\tpoww(n);\n\tll ans=0;\n\trep(i,n,k+1) {\n\t\tans=(ans+ret[i-n]*fnv[k-i])%mod;\n\t}\n\trep(i,1,k+1) ans=ans*i%mod;\n\tprintf(\"%I64d\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Transforming Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/23278",
    "editorial": "First observation is that if the sequence of prefix xors is strictly\r\nincreasing, than on each step has at least one new bit comparing to the\r\nprevious elements. So, since there are overall bits, the length of the\r\nsequence canât be more than . So, if , the answer is 0. Letâs firstly\r\nsolve the task with complexity. We calculate the number of sequences of\r\nlength such that has bits. The transition is to add a number with new\r\nbits, and choose those bits which are already in the prefix xor\r\narbitrarily. So, is increased by . The last binomial coefficient\r\ncomplies with the choice these very bits from which will be present in .\r\nNote now that the transition doesnât depend on , so letâs try to use the\r\nidea of the binary exponentiation. Suppose we want to merge two dynamics\r\n, where is the number of bits present in and correspondingly. Now we\r\nwant to obtain for arrays of size . The formula is: Here corresponds to\r\nthe bits present in the xor of the left part, and for each number of the\r\nright part we can choose these bits arbitrarily. Rewrite the formula in\r\nthe following way: So, we can compute for all having multiplied two\r\npolynomials and . We can obtain the coefficients of the first polynomial\r\nfrom the coefficients of the second in . So, we can compute this dynamic\r\nprogramming for all lengths powers of two, in , using the fast Fourier\r\ntransform. In fact, it is more convenient to compute using the same\r\nequation. After that, we can use the same merge strategy to compute the\r\nanswer for the given , using dynamics for the powers of two. Overall\r\ncomplexity is . We decided to ask the answer modulo to not let the\r\nparticipants easily guess that these problem requires FFT :) So, in\r\norder to get accepted you had to implement one of the methods to deal\r\nwith the large modulo in polynomial multiplication using FFT. Another\r\napproach was to apply Karatsuba algorithm, our realisation timed out on\r\nour tests, but qdai0815 somehow made it pass :)\r\n",
    "hint": []
}