{
    "link": "https://codeforces.com//contest/2089/problem/C2",
    "problemId": "3285045",
    "problem_idx": "C2",
    "shortId": "2089C2",
    "contest_number": "2089",
    "problem_submissions": {
        "E": [
            312117803,
            312117703,
            312026130,
            312177107,
            312173295,
            312027793,
            312310993,
            313591454
        ],
        "D": [
            312005425,
            312035983,
            312012646,
            312019023,
            312056542,
            312030790,
            312054855,
            312180193,
            312030778
        ],
        "B1": [
            311991638,
            311974074,
            311977257,
            311972783,
            311983703,
            311976653,
            311974663,
            311979567,
            311977867,
            311972876,
            311991596,
            311992114,
            311995537,
            312002724,
            311975692,
            311984582
        ],
        "B2": [
            311991504,
            311976057,
            311977008,
            311974724,
            311983600,
            311985419,
            311992609,
            311979419,
            311994591,
            311992227,
            311991999,
            311996351,
            312002610,
            311983804
        ],
        "C2": [
            311986572,
            311996842,
            311993140,
            311998124,
            312010341,
            312018999,
            312025560,
            312024295,
            312015915,
            312001206,
            312022380,
            312015982,
            312024268,
            312015714,
            312022629
        ],
        "C1": [
            311971941,
            311984058,
            311983107,
            311982200,
            311999669,
            311989579,
            311981776,
            311986834,
            312000911,
            311982471,
            311996193,
            312013435,
            312002171,
            311994068,
            311985200,
            311999126
        ],
        "A": [
            311962756,
            311967378,
            311963536,
            311963013,
            311973819,
            311962523,
            311964171,
            311965578,
            311966948,
            311963646,
            311964125,
            311965567,
            311963107,
            311964180,
            311964607,
            311967685
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141053",
    "editorial": "SolutionBackgroundThis problem is inspired by a minigame from a recently\r\nreleased party video game, but the story was modified to comply with the\r\ntitle. We tried to isolate the artistic part and the theoretical part,\r\nand I apologize if you still feel like working on reading comprehension\r\nexercises.SolutionNoticing that each member’s strategy is not maximizing\r\nthe total outcome (which is the expected number of successful matches\r\nbetween keys and locks), but only maximizing the outcome in her current\r\nturn, and equally likely to adopt each of optimal (pure) strategies, it\r\nwill be ideal if there is some simple form of the strategy that only\r\ndepends on and .Analyzing the StrategyAt the very beginning, when there\r\nis no information about the relationship between keys and locks, the\r\nfirst member in her first turn must randomly choose a key and a\r\nlock.What about the second member, if the first one is not lucky enough?\r\nSince she will not choose the same pair of keys and locks, there are\r\nthree different types of (pure) strategies: Choose a different key to\r\nopen the same lock; Choose the same key to open a different lock; Choose\r\na different key and a different lock. For the first type of strategy,\r\nsince there are keys remaining (after the very first attempt), and among\r\nthem is only one correct key, the probability of opening the same lock\r\nis .For the second type, it can be proven that the probability is also .\r\nAnother way to think of this is, add imaginary locks and match each of\r\nthem with a counterfeit key. Then, it is apparent that a new lock\r\nmatches the selected key with the given probability. The Straightforward\r\nComputation of the ProbabilityThe key selected by the first member can\r\neither be a real key or a counterfeit one. Denote the event of the key\r\nbeing authentic as , and that of it failing to open the lock at the\r\nfirst turn as . Then, according to the Bayes’ theorem along with the law\r\nof total probability,Thus, the probability that the same key selected by\r\nthe first member can open another lock randomly chosen by the second\r\nmember (denoted as ) isFor the third type of strategy, its probability\r\ncan be computed from either the first type or the second type, as\r\ndifferent outcomes are equally likely to happen:In conclusion, the\r\nsecond member will either choose the same key or the same lock. Because\r\nthere are pairs of the same key and other locks, and pairs of other keys\r\nand the same lock, the second member will use the same key with\r\nprobability , or check the same lock with probability .As for all the\r\nfollowing attempts, a similar Proof shows that, everyone will imitate\r\nthe strategy adopted by the second member. That is to say, if the second\r\nmember decides to continue with the same key, everyone will keep using\r\nthis same key, until a lock is opened or all the locks are checked; if\r\nthe second member picks a different key for the same lock, everyone will\r\nchallenge this same lock, until it is eventually settled (and obviously\r\nit will). Furthermore, whenever a key is identified as counterfeit, or a\r\nlock is opened, the information ’collapses’, which turns the original\r\nproblem into a subproblem with either one less counterfeit key\r\n(corresponding to ), or both one less valid key and one less lock (),\r\nrespectively.To sum up, the process of the game is: Whenever a lock is\r\nopened, the original problem is reduced to a subproblem with ; Whenever\r\na key is proven counterfeit, the original problem is reduced to a\r\nsubproblem where ; -The first member randomly chooses a key and a lock\r\nto check if they match; If the first member fails, the second member\r\nadopts the same key with probability , or investigates the same lock\r\nwith probability ; If the second member fails as well, all the following\r\nattempts will replicate the choice of whether to employ the same key or\r\nthe same lock. Design the Algorithm with Strategies SolvedKnowing the\r\nconcrete strategies, the task now becomes how to compute the expected\r\nvalues efficiently. As you might have imagined, it can be achieved using\r\ndynamic programming due to the existence of overlapping subproblems. But\r\nlet’s examine another approach which might be easier to understand:\r\ncompute , the total probability that the -th member begins a subproblem\r\nwith locks and counterfeit keys, and accumulate ’s during the\r\ncomputation.Transitions for itself include (and those from to will be\r\nsimilar to): The first member manages to open the lock without any prior\r\ninformation; The second member makes a successful guess; Any of the\r\nsucceeding attempts succeeds; Everyone uses the same key but it fails on\r\nall the locks. For each , all the transition can be easily processed in\r\ntime, except the third one. A verbatim implementation requires time per\r\nstate, which is apparently not efficient enough. Since , a possible\r\nwork-around is to compute the transition coefficient for each member,\r\ninstead of each attempt. Intuitively, all attempts should share the same\r\nprobability of success, regardless of the order. A simplified model is\r\nto draw all balls sequentially without replacement from a box of red\r\nball and white balls, in which the red ball appears at the -th attempt\r\nwith an equal probability of . Of course, the observation for our\r\nproblem can also be proven mathematically, but let’s omit it for\r\nsimplicity.This important observation reduces the time complexity of the\r\nthird type of transition to , as we can first compute the maximum number\r\nof attempts for each member, and then multiply it with the common\r\nprobability of a single attempt. However, this is still not enough for\r\npassing the problem (and we adjusted the constraints to prevent so).The\r\nfinal trick to pass all testcases requires revisiting the transition\r\ncoefficients we just computed. Notice that, if all the members have\r\nattempts in total (but for the third type of transition only, which\r\nexcludes the first two), then: If is a multiple of , then every member\r\ncan have at most attempts; Otherwise, the first members (right after the\r\nsecond member, who decides to advance with the same key or the same\r\nlock) can have at most attempts, while all the others can have at most\r\nattempts. This implies that the transition coefficients consists of at\r\nmost maximal contiguous subsequences of the same coefficients (in fact,\r\nif the coefficients are treated as a circular sequence, then there will\r\nbe exactly or for the two cases respectively). Using techniques such as\r\nprefix sums helps further decrease the complexity of the computation to\r\nper state.The total time complexity is .\r\n",
    "name": "C2. Key of Like  Hard Version ",
    "statement": "A toy box is a refrigerator filled with childhood delight. Like\r\nweakness, struggle, hope ... When such a sleeper is reawakened, what\r\nkind of surprises will be waiting?M received her toy box as a birthday\r\npresent from her mother. A jewellery designer would definitely spare no\r\neffort in decorating yet another priceless masterpiece as a starry\r\nfirmament with exquisitely shaped gemstones. In addition, l distinct\r\nlocks secure the tiny universe of her lovely daughter: a hair clip\r\nfeaturing a flower design, a weathered feather pen, a balloon shaped\r\nlike the letter M ... each piece obscures a precious moment.A few days\r\nago, M rediscovered her toy box when she was reorganizing her bedroom,\r\nalong with a ring of keys uniquely designed for the toy box. Attached to\r\nthe key ring are (l + k) keys, of which l keys are able to open one of\r\nthe l locks correspondingly, while the other k keys are nothing but\r\ncounterfeits to discourage brute-force attack. To remind the\r\ncorrespondence, M’s mother adorned each key with a gemstone of a\r\ndifferent type. However, passing days have faded M’s memory away.\"... So\r\nI have to turn to you all,\" M said while laying that ring of keys on the\r\ntable.K picked up the keys and examined them carefully. \"The appearance\r\nof these keys unveils nothing fruitful. Thus, I am afraid that we shall\r\ninspect them sequentially.\"Although everyone is willing to help M,\r\nnobody has a plan. Observing others’ reactions, T suggested, \"Let’s play\r\na game. Everyone tries a key in turn, and who opens the most locks is\r\n.\"n members, including M herself, take turns to unlock the toy box\r\nrecursively in the same order until all the l locks are unlocked. At\r\neach turn, the current member only selects a single key and tests it on\r\nexactly one of the locks. To open the toy box as soon as possible, every\r\nmember chooses the key and the lock that maximize the probability of\r\nbeing a successful match. If there are multiple such pairs, a member\r\nwill randomly choose one of such pairs with equal probability.\r\nApparently, if a lock has been matched with a key, then neither the lock\r\nnor the key will be chosen again in following attempts.Assume that at\r\nthe very beginning, the probability that a lock can be opened by any key\r\nis equal. If everyone always tries the optimal pairs of keys and locks\r\nbased on all the historical trials, what will the expected number of\r\nsuccessful matches be for each member?\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C2. Key of Like  Hard Version .json",
    "hint": []
}