{
    "link": "https://codeforces.com//contest/687/problem/C",
    "problemId": "63912",
    "problem_idx": "C",
    "shortId": "687C",
    "contest_number": "687",
    "problem_submissions": {
        "E": [
            18802309,
            18806260,
            18805246,
            18803372,
            18799334,
            18807280,
            18805272,
            18806337,
            18807252,
            18806390,
            18807620,
            18803706,
            18810595,
            18816088,
            18805681
        ],
        "D": [
            18793799,
            18802718,
            18796900,
            18797754,
            18807683,
            18798362,
            18797604,
            18800141,
            18800702,
            18803058,
            18801619,
            18800190,
            18801266,
            18807597,
            18797518,
            18800453,
            18798281
        ],
        "A": [
            18790806,
            18786960,
            18787408,
            18787163,
            18787741,
            18788893,
            18788129,
            18787797,
            18786842,
            18788168,
            18789518,
            18787023,
            18787148,
            18787130,
            18787967,
            18788569,
            18787232,
            18787389
        ],
        "C": [
            18788685,
            18790045,
            18790813,
            18791514,
            18792644,
            18791092,
            18793279,
            18795089,
            18793603,
            18792159,
            18795767,
            18790356,
            18792828,
            18792310,
            18792853,
            18794074,
            18789915,
            18792958
        ],
        "B": [
            18786970,
            18788540,
            18789247,
            18789185,
            18796167,
            18786909,
            18790772,
            18789737,
            20295221,
            20295216,
            20295180,
            20295158,
            20295119,
            20295105,
            18790246,
            18790367,
            18793463,
            18789273,
            20295043,
            20295033,
            20295023,
            20295001,
            20294990,
            20292826,
            18789797,
            18790852,
            18792280,
            18796842,
            18789369
        ]
    },
    "name": "C. The Values You Can Make",
    "statement": "Pari wants to buy an expensive chocolate from Arya. She has coins, the\r\nvalue of the -th coin is . The price of the chocolate is , so Pari will\r\ntake a subset of her coins with sum equal to and give it to Arya.Looking\r\nat her coins, a question came to her mind: after giving the coins to\r\nArya, what values does Arya can make with them? She is jealous and she\r\ndoesn\u2019t want Arya to make a lot of values. So she wants to know all the\r\nvalues , such that Arya will be able to make using some subset of coins\r\nwith the sum .Formally, Pari wants to know the values such that there\r\nexists a subset of coins with the sum such that some subset of this\r\nsubset has the sum , i.e. there is exists some way to pay for the\r\nchocolate, such that Arya will be able to make the sum using these\r\ncoins.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,m,x;\nbool dp[510][510],pd[510][510];\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tdp[0][0]=1;\n\trep(i,0,n) {\n\t\tscanf(\"%d\",&x);\n\t\trep(j,0,m+1) rep(k,0,m+1) pd[j][k]=dp[j][k],dp[j][k]=0;\n\t\trep(j,0,m+1) rep(k,0,m+1) {\n\t\t\tdp[j][k]|=pd[j][k];\n\t\t\tif (j+x<=m) dp[j+x][k]|=pd[j][k];\n\t\t\tif (k+x<=m) dp[j][k+x]|=pd[j][k];\n\t\t}\n\t}\n\tVI ret;\n\trep(j,0,m+1) if (dp[j][m-j]) ret.pb(j);\n\tprintf(\"%d\\n\",SZ(ret));\n\tfor (auto p: ret) {\n\t\tprintf(\"%d \",p);\n\t}\n\tputs(\"\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. The Values You Can Make.json",
    "editorial_link": "https://codeforces.com//blog/entry/45770",
    "editorial": "Hint\nUse dynamic programming.\n\nSolution\nLet dpi,?j,?k be true if and only if there exists a subset of the first i coins with sum j, that has a subset with sum k. There are 3 cases to handle:\n\nThe i-th coin is not used in the subsets.\nThe i-th coin is used in the subset to make j, but it's not used in the subset of this subset.\nThe i-th coin is used in both subsets.\nSo dpi,?j,?k is equal to dpi?-?1,?j,?k OR dpi?-?1,?j?-?ci,?k OR dpi?-?1,?j?-?ci,?k?-?ci."
}