{"link": "https://codeforces.com//contest/529/problem/D", "problemId": "25013", "problem_idx": "D", "shortId": "529D", "contest_number": "529", "problem_submissions": {"A": [10386870, 10387083, 10387317, 10387235, 10387134, 10386419, 10387369, 10386078, 10389580, 10388216, 10387712, 10386357, 10387632, 10386965, 10387734, 10385828], "C": [10386311, 10385455, 10386427, 10385364, 10406538, 10385834, 10386051, 10386918, 10386327, 10386510, 10385417, 10385724, 10386116, 10409781, 10386107, 10386201, 10386650, 10404350, 10386786, 10387225], "D": [10385805, 10386369, 10385736, 10386160, 10387079, 10385785, 10386933, 10385679, 10386619, 10386454, 10386390, 10387127, 10386675, 10386195, 10385799, 10388002], "E": [10385000, 10384871, 10384905, 10385848, 10385056, 10385201, 10385198, 10387352, 10385145, 10385184, 10385731, 10384843, 10385458, 10387221, 10385405, 10384991, 10385094], "B": [10384855, 10385831, 10385265, 10386319, 10385276, 10385001, 10385225, 10386328, 10385038, 10384881, 10385688, 10386077, 10385299, 10385149, 10385037, 10385267, 10384933, 10388225]}, "name": "D. Social Network", "statement": "Polycarpus got an internship in one well-known social network. His test\r\ntask is to count the number of unique users who have visited a social\r\nnetwork during the day. Polycarpus was provided with information on all\r\nuser requests for this time period. For each query, we know its time...\r\nand nothing else, because Polycarpus has already accidentally removed\r\nthe user IDs corresponding to the requests from the database. Thus, it\r\nis now impossible to determine whether any two requests are made by the\r\nsame person or by different people.But wait, something is still known,\r\nbecause that day a record was achieved simultaneous users online! In\r\naddition, Polycarpus believes that if a user made a request at second ,\r\nthen he was online for seconds after that, that is, at seconds , , ,\r\n..., . So, the user\u2019s time online can be calculated as the union of time\r\nintervals of the form over all times of requests from him.Guided by\r\nthese thoughts, Polycarpus wants to assign a user ID to each request so\r\nthat: the number of different users online did not exceed at any moment,\r\nat some second the number of distinct users online reached value , the\r\ntotal number of users (the number of distinct identifiers) was as much\r\nas possible. Help Polycarpus cope with the test.\r\n", "solutions": ["#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAXT = 24*60*60;\nconst int MAXN = 20020;\n\nset<int> st[MAXT+10], en[MAXT+10];\n\nvector<int> E[MAXN];\nint a[MAXN];\nint l[MAXN], r[MAXN];\nint dad[MAXN];\nint ans[MAXN];\n\nstruct cmp {\n  bool operator () (const int &a, const int &b) {\n    if (r[a] != r[b]) return r[a] > r[b];\n    return a < b;\n  }\n};\n\nset<int, cmp> S;\n\nvoid dfs(int x, int a) {\n  ans[x] = a;\n  for (int y: E[x])\n    dfs(y, a);\n}\n\nint main(void) {\n  int n, m, T;\n  scanf(\"%d %d %d\", &n, &m, &T);\n  REP(i, n) {\n    int h, m, s;\n    scanf(\"%d:%d:%d\", &h, &m, &s);\n    a[i] = (h*60 + m)*60 + s;\n    st[a[i]].insert(i);\n    en[a[i]+T].insert(i);\n    l[i] = a[i], r[i] = a[i] + T;\n    dad[i] = i;\n  }\n\n  bool ok = false;\n  REP(i, MAXT) {\n    for (int j: st[i]) S.insert(j);\n    for (int j: en[i]) if (r[j] == i) S.erase(j);\n    \n    while ((int)S.size() > m) {\n      int x = *S.begin(); S.erase(S.begin());\n      int y = *S.begin(); S.erase(S.begin());\n      \n      en[r[x]].erase(x);\n      en[r[y]].erase(y);\n\n      E[x].push_back(y);\n      dad[y] = x;\n      r[x] = max(r[x], r[y]);\n      en[r[x]].insert(x);\n      S.insert(x);\n    }\n\n    ok |= (int)S.size() == m;\n  }\n\n  if (!ok) {\n    puts(\"No solution\");\n    return 0;\n  }\n\n  int R = 0;\n  REP(i, n)\n    if (dad[i] == i) {\n      dfs(i, R);\n      R++;\n    }\n\n  printf(\"%d\\n\", R);\n  REP(i, n) printf(\"%d\\n\", ans[i]+1);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "2100", "interactive": false}