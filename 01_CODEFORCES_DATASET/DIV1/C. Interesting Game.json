{
    "link": "https://codeforces.com//contest/87/problem/C",
    "problemId": "459",
    "problem_idx": "C",
    "shortId": "87C",
    "contest_number": "87",
    "problem_submissions": {
        "E": [
            480522,
            480373,
            480563,
            481052,
            487220,
            487031,
            486475,
            483729,
            480251,
            482514,
            479707,
            481257
        ],
        "D": [
            479023,
            478767,
            478527,
            480005,
            478079,
            479874,
            481953,
            479744,
            478788,
            480461,
            479633,
            479612,
            480061,
            1186292,
            480377
        ],
        "C": [
            477696,
            477515,
            477634,
            477346,
            478564,
            477717,
            482287,
            482259,
            482254,
            482249,
            478031,
            477748,
            478549,
            478513,
            478021,
            477556,
            477965,
            477701,
            478643,
            478646
        ],
        "B": [
            477395,
            477959,
            480915,
            478219,
            479510,
            478272,
            478602,
            479590,
            477948,
            477912,
            477626,
            478345,
            478853,
            480591,
            477860,
            478043
        ],
        "A": [
            477178,
            477245,
            477382,
            477797,
            478932,
            477255,
            477225,
            477234,
            477375,
            477368,
            477236,
            477191,
            477429,
            479893,
            477216,
            477325
        ]
    },
    "name": "C. Interesting Game",
    "statement": "Two best friends Serozha and Gena play a game.Initially there is one\r\npile consisting of stones on the table. During one move one pile should\r\nbe taken and divided into an arbitrary number of piles consisting of\r\nstones. The piles should meet the condition . Naturally, the number of\r\npiles should be no less than two.The friends play in turns. The player\r\nwho cannot make a move loses. Serozha makes the first move. Who will win\r\nif both players play in the optimal way?\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <bitset>\n#include <cmath>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#define mp make_pair\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef long long int64;\ntypedef vector<int> vi;\n\ntemplate<class T> T abs(T x) {return x > 0 ? x : (-x); }\ntemplate<class T> T sqr(T x) {return x * x; }\n\nint main()\n{\n    int n;\n    cin >> n;\n    vi d(n + 1, 0);\n    vi u(n + 2, 0);\n    for (int i = 2; i <= n; ++i) {\n        int k = 2;\n        while (1) {\n            int x = i - (k * (k - 1)) / 2;\n            if (x < 0) break;\n            if (x % k == 0) {\n                x /= k;\n                int t = 0;\n                for (int j = 0; j < k; ++j)\n                    t ^= d[x + j];\n                u[t] = i;\n            }\n            ++k;\n        }\n        int r = 0;\n        while (u[r] == i) ++r;\n        d[i] = r;\n    }\n    if (!d[n]) printf(\"-1\\n\");\n    else {\n        int k = 2;\n        while (1) {\n            int x = n - (k * (k - 1)) / 2;\n            if (x % k == 0) {\n                x /= k;\n                int t = 0;\n                for (int i = 0; i < k; ++i)\n                    t ^= d[x + i];\n                if (!t) break;\n            }\n            ++k;\n        }\n        printf(\"%d\\n\", k);\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Interesting Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/2121",
    "editorial": "In this task you should analyze the game. However, due to the fact that with every move the game is divided into several independent ones, the analysis can be performed using the Grundy's function (you can read about it here, or here). Now all we have to do is to construct edges for each position. We can build the edges separately for each vertex by solving  simple linear equations for each number of piles after splitting. We can construct all the divisions in advance, simply taking one by one the smallest pile and the number or piles and terminating when the sum exceeds n. The second way is better because it works for the O(m?+? n), where m stands for the number of edges, and the first one works for , which is larger.\n\nWe should evaluate m in the maximal test. The edges are no more than . However, in practice they are much less - about 520 thousand. Which is why there's enough time to build the edges within the time limit of O(nk).\n\nYou can try to find a Grundy's function by the definition if we xor all the required values for each position. But this may not work: it has too many long partitions (solutions with lazy countings or other ideas was working, though).\nLet's learn how to quickly count a Grundy's xor function for a long partition. Let's use a standard method for counting functions on the interval - xor[l,?r]?=?xor[0,?r]\\^xor[0,?l?-?1]. In the course of the algorithm we will keep a xor on a prefix of xor[i] up to i. Then the xor on the interval can also be calculated as O(1). The solution was strictly successful due to the number of edges, which is not very large.",
    "hint": []
}