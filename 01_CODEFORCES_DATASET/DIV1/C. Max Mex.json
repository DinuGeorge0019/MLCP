{"link": "https://codeforces.com//contest/1083/problem/C", "problemId": "268423", "problem_idx": "C", "shortId": "1083C", "contest_number": "1083", "problem_submissions": {"F": [46915087, 46876311, 46868384, 46877366, 46879128, 46934792, 46934770, 46934758, 46934487, 46934473, 46934346, 46934338, 46934202, 46933927, 46928101, 46927984, 46927894, 46927871, 46927855, 46927824, 46927737, 46927669, 46927614, 46881270], "E": [46869370, 46871694, 46869499, 46863810, 46865492, 46873246, 46870302, 46870225, 46877380, 73537754, 46882329, 46878807, 46866936, 46868963, 46871231, 46872499, 46871547, 46871489, 46871036, 46871727, 46869495, 50322936, 50315966, 49844673, 49844653, 46872514], "C": [46867095, 46877292, 47334658, 46890375, 46870788, 46950972, 46950940, 46950838, 46877308, 46877619, 46875434, 46987974, 46883043, 46874242, 46882744, 46942133], "B": [46861840, 46872617, 46861528, 46859342, 46860406, 46863456, 46865386, 46864693, 46865545, 46861409, 46863762, 46864513, 46863287, 46861669, 46861388, 46863642, 46862875, 46865443, 46861004, 46867808], "A": [46860516, 46860277, 46860154, 46866668, 46859314, 46876109, 46860042, 46861931, 46860073, 46859289, 46859440, 46860646, 46859325, 46859654, 46859377, 46861868, 46860315, 46863438, 46865470, 46859724], "D": [46882403, 46994123]}, "name": "C. Max Mex", "statement": "Once Grisha found a tree (connected graph without cycles) with a root in\r\nnode 1.But this tree was not just a tree. A permutation p of integers\r\nfrom 0 to n - 1 is written in nodes, a number p_i is written in node\r\ni.As Grisha likes to invent some strange and interesting problems for\r\nhimself, but not always can solve them, you need to help him deal with\r\ntwo types of queries on this tree.Let\u2019s define a function MEX(S), where\r\nS is a set of non-negative integers, as a smallest non-negative integer\r\nthat is not included in this set.Let l be a simple path in this tree. So\r\nlet\u2019s define indices of nodes which lie on l as u_1, u_2,\r\nldots, u_k. Define V(l) as a set {p_{u_1}, p_{u_2},\r\nldots , p_{u_k}}. Then queries are: For two nodes i and j, swap p_i and\r\np_j. Find the maximum value of MEX(V(l)) in all possible l.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1200*1007;\nconst int n1=(1<<18);\n\nint n;\nint tab[nax];\nint gdz[nax];\n\nvector <int> drz[nax];\nint roz[nax], jump[nax], pre[nax], post[nax], fad[nax];\nint odl[nax];\nint l;\n\nvoid dfs_roz(int v)\n{\n\troz[v]=1;\n\tfor (int &i : drz[v])\n\t{\n\t\tfad[i]=v;\n\t\todl[i]=odl[v]+1;\n\t\tdfs_roz(i);\n\t\troz[v]+=roz[i];\n\t\tif (roz[i]>roz[drz[v][0]])\n\t\t\tswap(i, drz[v][0]);\n\t}\n}\n\nvoid dfs_pre(int v)\n{\n\tif (!jump[v])\n\t\tjump[v]=v;\n\tl++;\n\tpre[v]=l;\n\tif (!drz[v].empty())\n\t\tjump[drz[v][0]]=jump[v];\n\tfor (int i : drz[v])\n\t\tdfs_pre(i);\n\tpost[v]=l;\n}\n\nint lca(int v, int u)\n{\n\twhile(jump[v]!=jump[u])\n\t{\n\t\tif (pre[v]<pre[u])\n\t\t\tswap(v, u);\n\t\tv=fad[jump[v]];\n\t}\n\treturn (pre[v]<pre[u] ? v : u);\n}\n\nvector < pair <int,int> > path_up(int v, int u)\n{\n\tvector < pair <int,int> > ret;\n\twhile(jump[v]!=jump[u])\n\t{\n\t\tret.push_back({pre[jump[v]], pre[v]});\n\t\tv=fad[jump[v]];\n\t}\n\tret.push_back({pre[u], pre[v]});\n\treturn ret;\n}\n\nvector < pair <int,int> > get_path(int v, int u)\n{\n\tint w=lca(v, u);\n\tauto ret=path_up(v, w);\n\tauto pom=path_up(u, w);\n\tfor (auto &i : ret)\n\t\tswap(i.first, i.second);\n\twhile(!pom.empty())\n\t{\n\t\tret.push_back(pom.back());\n\t\tpom.pop_back();\n\t}\n\treturn ret;\n}\n\nint liczodl(int a, int b)\n{\n\treturn odl[a]+odl[b]-2*odl[lca(a, b)];\n}\n\npii prze[nax];\n\nint mac[4][4];\n\npii lacz(pii a, pii b)\n{\n\tif (a.first==0)\n\t\treturn b;\n\tif (a.first==-1)\n\t\treturn a;\n\tif (b.first==-1)\n\t\treturn b;\n\tvi wek{a.first, a.second, b.first, b.second};\n\tpii naj={0, 0};\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tfor (int j=0; j<i; j++)\n\t\t{\n\t\t\tmac[i][j]=mac[j][i]=liczodl(wek[i], wek[j]);\n\t\t\tif (mac[i][j]>mac[naj.first][naj.second])\n\t\t\t\tnaj={i, j};\n\t\t}\n\t}\n\tfor (int i=0; i<4; i++)\n\t\tif (mac[naj.first][i]+mac[naj.second][i]!=mac[naj.first][naj.second])\n\t\t\treturn {-1, -1};\n\treturn {wek[naj.first], wek[naj.second]};\n}\n\nvoid upd(int v)\n{\n\tprze[v+n1-1]={gdz[v], gdz[v]};\n\tv+=n1-1;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tprze[v]=lacz(prze[v*2], prze[v*2+1]);\n\t\tv>>=1;\n\t}\n}\n\nvoid zamien(int a, int b)\n{\n\tint x=tab[a];\n\tint y=tab[b];\n\tswap(tab[a], tab[b]);\n\tswap(gdz[x], gdz[y]);\n\tupd(x);\n\tupd(y);\n}\n\nint wyn;\npii juz;\n\nint lis;\n\nvoid szuk(int v, int a, int b)\n{\n\tif (a==b)\n\t\treturn;\n\tint s=(a+b)>>1;\n\tif (s>n)\n\t{\n\t\tszuk(v<<1, a, (a+b)>>1);\n\t\treturn;\n\t}\n\tpii wez=lacz(juz, prze[v*2]);\n\tif (wez.first!=-1)\n\t{\n\t\tjuz=wez;\n\t\twyn+=s-a+1;\n\t\tszuk((v<<1)^1, (a+b+2)>>1, b);\n\t}\n\telse\n\t{\n\t\tszuk(v<<1, a, (a+b)>>1);\n\t}\n}\n\nvoid query()\n{\n\tint typ;\n\tscanf(\"%d\", &typ);\n\tif (typ==1)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tzamien(a, b);\n\t}\n\telse\n\t{\n\t\tif (lis==2)\n\t\t{\n\t\t\tprintf(\"%d\\n\", n);\n\t\t\treturn;\n\t\t}\n\t\tjuz={0, 0};\n\t\twyn=0;\n\t\tszuk(1, 1, n1);\n\t\tprintf(\"%d\\n\", wyn);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &tab[i]);\n\t\ttab[i]++;\n\t\tgdz[tab[i]]=i;\n\t}\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tdrz[x].push_back(i);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint sto=((i>1)+(!drz[i].empty()));\n\t\tlis+=(sto==1);\n\t}\n\todl[1]=1;\n\tdfs_roz(1);\n\tdfs_pre(1);\n\tfor (int i=1; i<=n; i++)\n\t\tprze[i+n1-1]={gdz[i], gdz[i]};\n\tfor (int i=n1-1; i; i--)\n\t\tprze[i]=lacz(prze[i*2], prze[i*2+1]);\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile(q--)\n\t\tquery();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "trees"], "dificulty": "2900", "interactive": false}