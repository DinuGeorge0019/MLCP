{
    "link": "https://codeforces.com//contest/607/problem/B",
    "problemId": "43759",
    "problem_idx": "B",
    "shortId": "607B",
    "contest_number": "607",
    "problem_submissions": {
        "E": [
            14958443,
            14961849,
            14961838,
            14961831,
            16737326
        ],
        "D": [
            14951724,
            14952244,
            14950470,
            14950039,
            14952208,
            14949972,
            14952659,
            14968005,
            14967954,
            14967922,
            14967912,
            14967907,
            14967903,
            14967896,
            14967707,
            14967669,
            14956925,
            14956428,
            14958812,
            14957599,
            14953577,
            14952372,
            14951711,
            14957330,
            14954653,
            14952137,
            14951821,
            14954577,
            14952711
        ],
        "C": [
            14947368,
            14953869,
            14954714,
            14954225,
            14954959,
            14954407,
            14957641,
            14951200,
            14952263,
            14949536,
            14956671,
            14955594,
            14955895,
            14951583,
            14957050
        ],
        "B": [
            14944943,
            14943843,
            14943439,
            14944195,
            14944079,
            14951944,
            14944759,
            14945484,
            14944543,
            14945215,
            14944778,
            14945950,
            14944649,
            14947158,
            14943778,
            14944962,
            14948034,
            14943374,
            14945989
        ],
        "A": [
            14941938,
            14942696,
            14942042,
            14943122,
            14941989,
            14950953,
            14942232,
            14942613,
            14942728,
            14942057,
            14942385,
            14946665,
            14948612,
            14942429,
            14941952,
            14943906,
            14943291,
            15059376,
            14942040,
            14942093
        ]
    },
    "name": "B. Zuma",
    "statement": "Genos recently installed the game Zuma on his phone. In Zuma there\r\nexists a line of gemstones, the -th of which has color . The goal of the\r\ngame is to destroy all the gemstones in the line as quickly as\r\npossible.In one second, Genos is able to choose exactly one continuous\r\nsubstring of colored gemstones that is a palindrome and remove it from\r\nthe line. After the substring is removed, the remaining gemstones shift\r\nto form a solid line again. What is the minimum number of seconds needed\r\nto destroy the entire line?Let us remind, that the string (or substring)\r\nis called , if it reads same backwards or forward. In our case this\r\nmeans the color of the first gemstone is equal to the color of the last\r\none, the color of the second gemstone is equal to the color of the next\r\nto last and so on.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 500;\n\nint n;\nint a[maxn + 5];\nint dp[maxn + 5][maxn + 5];\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d\", &n);\n\tREP(i, 0, n) scanf(\"%d\", a + i);\n\tREP(i, 0, n + 1) dp[i][i] = 0;\n\tREP(l, 1, n + 1)\n\t\tREP(i, 0, n - l + 1)\n\t\t{\n\t\t\tint j = i + l;\n\t\t\tdp[i][j] = oo;\n\t\t\tif (a[i] == a[j - 1]) dp[i][j] = dp[i + 1][j - 1];\n\t\t\tREP(k, i, j - 1)\n\t\t\t\tif (a[i] == a[k]) chkmin(dp[i][j], dp[i + 1][k] + dp[k + 1][j] + 1);\n\t\t}\n\tprintf(\"%d\\n\", dp[0][n] + 1);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Zuma.json",
    "editorial_link": "https://codeforces.com//blog/entry/22256",
    "editorial": "We use dp on contiguous ranges to calculate the answer. Let D[i][j] denote the number of seconds it takes to collapse some range [i,?j]. Let us work out a transition for this definition. Consider the left-most gemstone. This gemstone will either be destroyed individually or as part of a non-singular range. In the first case, we destroy the left-most gemstone and reduce to the subproblem [i?+?1,?j]. In the second case, notice that the left-most gemstone will match up with some gemstone to its right. We can iterate through every gemstone with the same color as the left-most (let k be the index of this matching gemstone) and reduce to two subproblems [i?+?1,?k?-?1] and [k?+?1,?j]. We can reduce to the subproblem [i?+?1,?k?-?1] because we can just remove gemstones i and k with the last removal of [i?+?1,?k?-?1]. We must also make a special case for when the first two elements in a range are equal and consider the subproblem [i?+?2,?j]."
}