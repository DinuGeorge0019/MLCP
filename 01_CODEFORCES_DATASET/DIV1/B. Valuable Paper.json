{"link": "https://codeforces.com//contest/1423/problem/B", "problemId": "749082", "problem_idx": "B", "shortId": "1423B", "contest_number": "1423", "problem_submissions": {"J": [95462948, 95462931, 95462795, 95462776, 95462759, 95462752, 95462749, 95445856, 95445842, 95445741, 95445735, 95445720, 95436077, 95435983, 94779119, 94773285, 94770663, 94778562], "C": [94789081], "I": [94786050], "F": [94784528, 94776365, 94779778, 94781062], "H": [94781814, 94783650, 94777878, 94784871], "L": [94780014, 94780685, 94786643, 94773659], "B": [94771096, 94770153, 94772426, 94771466], "K": [94770723, 94771588, 94773427, 94774938], "A": []}, "name": "B. Valuable Paper", "statement": "The pandemic is upon us, and the world is in shortage of the most\r\nimportant resource: toilet paper. As one of the best prepared nations\r\nfor this crisis, BubbleLand promised to help all other world nations\r\nwith this valuable resource. To do that, the country will send airplanes\r\nto other countries carrying toilet paper.In BubbleLand, there are N\r\ntoilet paper factories, and N airports. Because of how much it takes to\r\nbuild a road, and of course legal issues, every factory must send paper\r\nto only one airport, and every airport can only take toilet paper from\r\none factory.Also, a road can\u2019t be built between all airport-factory\r\npairs, again because of legal issues. Every possible road has number d\r\ngiven, number of days it takes to build that road.Your job is to choose\r\nN factory-airport pairs, such that if the country starts building all\r\nroads at the same time, it takes the least amount of days to complete\r\nthem.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 05.10.2020 16:08:00       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass matching {\n public:\n  vector<vector<int>> g;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was = vector<int>(n, 0);\n    g.resize(n);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    was[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      iter++;\n      int add = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(m);\n  vector<int> b(m);\n  vector<int> c(m);\n  for (int i = 0; i < m; i++) {\n    cin >> a[i] >> b[i] >> c[i];\n    --a[i]; --b[i];\n  }\n  vector<int> order(m);\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&](int i, int j) {\n    return c[i] < c[j];\n  });\n  int low = n, high = m + 1;\n  while (low < high) {\n    int mid = (low + high) >> 1;\n    matching mat(n, n);\n    for (int i = 0; i < m; i++) {\n      if (c[i] <= c[order[mid - 1]]) {\n        mat.add(a[i], b[i]);\n      }\n    }\n    if (mat.solve() == n) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n  cout << (low <= m ? c[order[low - 1]] : -1) << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "flows", "graph matchings", "graphs"], "dificulty": "1900", "interactive": false}