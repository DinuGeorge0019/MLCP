{"link": "https://codeforces.com//contest/238/problem/B", "problemId": "2112", "problem_idx": "B", "shortId": "238B", "contest_number": "238", "problem_submissions": {"E": [2504243, 2503858, 2509891, 2694210, 2552413], "B": [2501797, 2504771, 2501096, 2501711, 2501715, 2500046, 2500118, 2500703, 2501297, 2500963, 2500837, 2501321, 2500477, 2500698, 2502278, 2501139, 2500966, 2501060, 2501238], "C": [2500671, 2502160, 2502349, 2502372, 2500466, 2501719, 2501950, 2502275, 2502065, 2502329, 2502087, 2502235, 2501641, 2502453, 2501221, 2502604, 2502443, 2502751, 2503154], "A": [2498142, 2498095, 2498716, 2498060, 2498106, 2498185, 2498628, 2498741, 2498627, 2498605, 2499081, 2498586, 2498140, 2501538, 2498125, 2498688, 2499407, 2498390], "D": [2556123, 2505008]}, "name": "B. Boring Partition", "statement": "This problem is the most boring one you\u2019ve ever seen. Given a sequence\r\nof integers and a non-negative integer , our goal is to partition the\r\nsequence into two subsequences (not necessarily consist of continuous\r\nelements). Each element of the original sequence should be contained in\r\nexactly one of the result subsequences. Note, that one of the result\r\nsubsequences can be empty.Let\u2019s define function on pairs of distinct\r\nelements (that is ) in the original sequence. If and are in the same\r\nsubsequence in the current partition then otherwise . Consider all\r\npossible values of the function for some partition. We\u2019ll call the of\r\nthis partiotion the difference between the maximum value of function and\r\nthe minimum value of function .Your task is to find a partition of the\r\ngiven sequence that have the minimal possible goodness among all\r\npossible partitions.\r\n", "solutions": ["#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int N = 444444;\n\npair <int, int> a[N];\nint b[N], ans[N];\nint n, h, i, k;\n\nint main() {\n//  freopen(\"in\", \"r\", stdin);\n//  freopen(\"out\", \"w\", stdout);\n  scanf(\"%d %d\", &n, &h);\n  for (i=0;i<n;i++) {\n    int foo;\n    scanf(\"%d\", &foo);\n    a[i] = make_pair(foo, i+1);\n  }\n  sort(a, a+n);\n  for (i=0;i<n;i++) b[i] = a[i].first;\n  int diff = (b[n-1]+b[n-2]) - (b[0]+b[1]);\n  int km = 0;\n  for (k=1;k<n;k++) {\n    int other;\n\n    int small = (int)1e9;\n    if (k >= 2) {\n      other = b[1]+b[2];\n      if (other < small) small = other;\n    }\n    other = b[0]+b[1]+h;\n    if (other < small) small = other;\n    if (k < n-1) {\n      other = b[0]+b[k+1];\n      if (other < small) small = other;\n    }\n\n    int big = b[n-1]+h;\n    if (k == n-1) big += b[0];\n    else big += b[k];\n    other = b[n-1]+b[n-2];\n    if (other > big) big = other;\n\n    if (big-small < diff) {\n      diff = big-small;\n      km = k;\n    }\n  }\n  printf(\"%d\\n\", diff);\n  for (i=1;i<=n;i++) ans[i] = 1;\n  for (i=1;i<=km;i++) ans[a[i].second] = 2;\n  for (i=1;i<n;i++) printf(\"%d \", ans[i]);\n  printf(\"%d\\n\", ans[n]);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "1800", "interactive": false}