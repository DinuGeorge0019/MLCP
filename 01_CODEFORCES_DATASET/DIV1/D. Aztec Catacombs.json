{"link": "https://codeforces.com//contest/966/problem/D", "problemId": "179478", "problem_idx": "D", "shortId": "966D", "contest_number": "966", "problem_submissions": {"E": [37728467, 37721887, 37727395, 37722353, 46428064, 37735854, 37726097, 37728168, 37731395, 37731373], "D": [37722933, 37721182, 37720577, 37745366, 37727547, 37724656, 37720856, 37720615, 37721601, 37723190, 37720741, 37720916, 37854456, 37723453, 37723867, 37723823, 37723640, 37725199], "C": [37716531, 37723619, 37716233, 37716062, 37721394, 37719905, 37724974, 37710146, 37715347, 37715961, 37715642, 37715427, 37717480, 37715886, 37716616, 37716460, 37712823, 37718703, 37718856], "B": [37712342, 37710216, 37712076, 37714505, 37717238, 37717093, 37713464, 37712937, 37711956, 37712143, 37712153, 37712830, 37714037, 37717527, 37712504, 37714456, 37719214, 37710052, 37715647], "A": [37709493, 37711125, 37709073, 37709222, 37711428, 37711424, 37710230, 37723341, 37715473, 37709490, 37710976, 37717218, 37726403, 37716138, 37716852, 37710495, 37715732, 37712927, 37711795], "F": [37856043]}, "name": "D. Aztec Catacombs", "statement": "Indiana Jones found ancient Aztec catacombs containing a golden idol.\r\nThe catacombs consists of n caves. Each pair of caves is connected with\r\na two-way corridor that can be opened or closed. The entrance to the\r\ncatacombs is in the cave 1, the idol and the exit are in the cave n.When\r\nIndiana goes from a cave x to a cave y using an open corridor, all\r\ncorridors connected to the cave x change their state: all open corridors\r\nbecome closed, all closed corridors become open. Indiana wants to go\r\nfrom cave 1 to cave n going through as small number of corridors as\r\npossible. Help him find the optimal path, or determine that it is\r\nimpossible to get out of catacombs.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\nusing namespace std;\nint n,m,f[300010],g[300010],h[300010],p;\nvector<int> a[300010],w;\nmap<L,int> u;\ninline int bfs(int s,int p)\n{\n    int i,k=0;\n    f[s]=1;\n    g[1]=s;\n    k=1;\n    for(i=1;i<=k;i++)\n      for(auto j:a[g[i]])\n        if(j!=p && !f[j])\n          {\n           f[j]=f[g[i]]+1;\n           h[j]=g[i];\n           g[++k]=j;\n          }\n    return k;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k,l;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++)\n\t  {\n       scanf(\"%d%d\",&j,&k);\n       a[j].pb(k);\n       a[k].pb(j);\n       u[(L)j*n+k]=u[(L)k*n+j]=1;\n      }\n    bfs(1,0);\n    if(f[n])\n      {\n       p=f[n]-1;\n       for(i=n;i;i=h[i])\n         w.pb(i);\n      }\n    else\n      p=100000000;\n    for(i=1;i<=n && p>4;i++)\n      if(f[i]==3)\n          {\n           p=4;\n           w.clear();\n           w.pb(n);\n           w.pb(1);\n           w.pb(i);\n           w.pb(h[i]);\n           w.pb(1);\n          }\n    if(p>5)\n      {\n       for(i=1;i<=n;i++)\n         f[i]=0;\n       for(auto i:a[1])\n         if(!f[i])\n           {\n            if(p<=5)\n              break;\n            k=bfs(i,1);\n            for(j=1;j<=k && p>5;j++)\n              if(f[g[j]]==3)\n                {\n                 p=5;\n                 w.clear();\n                 w.pb(n);\n                 w.pb(i);\n                 w.pb(g[j]);\n                 w.pb(h[g[j]]);\n                 w.pb(i);\n                 w.pb(1);\n                }\n            for(j=2;j<k && p>5;j++)\n              for(l=j+1;l<=k && p>5;l++)\n                if(!u[(L)g[j]*n+g[l]])\n                  {\n                   p=5;\n                   w.clear();\n                   w.pb(n);\n                   w.pb(g[j]);\n                   w.pb(g[l]);\n                   w.pb(g[1]);\n                   w.pb(g[j]);\n                   w.pb(1);\n                  }\n           }\n      }\n    if(p==100000000)\n      printf(\"-1\\n\");\n    else\n      {\n       printf(\"%d\\n\",p);\n       for(i=p;i>=0;i--)\n         printf(\"%d \",w[i]);\n       printf(\"\\n\");\n      }\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs"], "dificulty": "2600", "interactive": false}