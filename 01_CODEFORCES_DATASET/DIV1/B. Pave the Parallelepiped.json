{"link": "https://codeforces.com//contest/1007/problem/B", "problemId": "197247", "problem_idx": "B", "shortId": "1007B", "contest_number": "1007", "problem_submissions": {"C": [40289014, 40311007, 40303376, 40289853, 40282836, 40298460, 40292416, 40291392, 40315809, 40295182, 43029830], "B": [40273384, 40274250, 40291551, 40287008, 40280350, 40301243, 40277597, 40277856, 40278440, 40276236, 40280080, 40280290, 40278003, 40280632, 40280737, 40278002], "A": [40264928, 40264790, 40264714, 40264612, 40266456, 40265453, 40267936, 40264621, 40264617, 40264727, 40264905, 40264738, 40265555, 40264686, 40264608, 40264865, 40264835, 40265293], "D": [40284510, 40287759, 40291268, 62534541, 40294556, 40301360], "E": [54819990, 54819956, 47314793]}, "name": "B. Pave the Parallelepiped", "statement": "You are given a rectangular parallelepiped with sides of positive\r\ninteger lengths A, B and C. Find the number of different groups of three\r\nintegers (a, b, c) such that 1\r\nleq a\r\nleq b\r\nleq c and parallelepiped A\r\ntimes B\r\ntimes C can be paved with parallelepipeds a\r\ntimes b\r\ntimes c. Note, that all small parallelepipeds .For example,\r\nparallelepiped 1\r\ntimes 5\r\ntimes 6 can be divided into parallelepipeds 1\r\ntimes 3\r\ntimes 5, but can not be divided into parallelepipeds 1\r\ntimes 2\r\ntimes 3.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<class T> ostream& operator<<(ostream& os, const V<T> &v) {\n    cout << \"[\";\n    for (auto p: v) cout << p << \", \";\n    cout << \"]\";\n    return os;\n}\n\nconst int MN = 100100;\nV<int> fac[MN];\n\nvoid first() {\n    for (int i = 1; i < MN; i++) {\n        for (int j = i; j < MN; j += i) {\n            fac[j].push_back(i);\n        }\n    }\n}\n\nvoid calc() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    V<int> res_ab, res;\n    merge(begin(fac[a]), end(fac[a]), begin(fac[b]), end(fac[b]), back_inserter(res_ab));\n    merge(begin(res_ab), end(res_ab), begin(fac[c]), end(fac[c]), back_inserter(res));\n    res.erase(unique(begin(res), end(res)), end(res));\n\n    ll cnt[8] = {};\n    for (int d: res) {\n        int f = 0;\n        if (a % d == 0) f += 1;\n        if (b % d == 0) f += 2;\n        if (c % d == 0) f += 4;\n        assert(f);\n        cnt[f]++;\n    }\n    ll ans = 0;\n    for (int i = 1; i <= 7; i++) {\n        for (int j = i; j <= 7; j++) {\n            for (int k = j; k <= 7; k++) {\n                if ((i | j | k) != 7) continue;\n                if ((i == j || j == k) && (j == 1 || j == 2 || j == 4)) continue;\n\n                ll z = cnt[j];\n                if (i == j && j == k) {\n                    ans += z * (z+1) * (z+2) / 6;\n                    continue;\n                }\n                if (i == j) {\n                    ans += z * (z+1) * cnt[k] / 2;\n                    continue;\n                }\n                if (j == k) {\n                    ans += z * (z+1) * cnt[i] / 2;\n                    continue;                    \n                }\n                ans += cnt[i] * cnt[j] * cnt[k];\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    first();\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n        calc();\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "combinatorics", "math", "number theory"], "dificulty": "2400", "interactive": false}