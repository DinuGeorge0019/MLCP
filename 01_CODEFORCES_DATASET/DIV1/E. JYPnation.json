{
    "link": "https://codeforces.com//contest/1338/problem/E",
    "problemId": "590535",
    "problem_idx": "E",
    "shortId": "1338E",
    "contest_number": "1338",
    "problem_submissions": {
        "E": [
            76397300,
            76619327,
            76403815,
            76434529,
            76434479,
            76434133,
            76434078,
            76433920,
            76433813,
            76433749,
            76433522,
            76432895,
            76432405,
            76433003,
            76432715,
            76492191,
            76458850,
            77714923,
            76416304,
            78374239,
            105958584
        ],
        "D": [
            76383105,
            76378423,
            76373799,
            76372283,
            76380290,
            76721483,
            76721183,
            76718097,
            76716953,
            76379002,
            76377538,
            76378427,
            76454507,
            76377531,
            76381613,
            76384929,
            76380304,
            76384800,
            76387623,
            76383511,
            76383924,
            76389002,
            76385003,
            76379777,
            76361072
        ],
        "C": [
            76355433,
            76365439,
            76355356,
            76357185,
            76342857,
            77464916,
            77464536,
            76797866,
            76793425,
            76363706,
            76354913,
            76352467,
            76454469,
            76364453,
            76361606,
            76365484,
            76367936,
            76362206,
            76361479,
            76370442,
            76369319,
            76368001,
            76372720,
            76355615,
            76385066
        ],
        "B": [
            76346805,
            76342391,
            76342822,
            76343816,
            76355163,
            77465740,
            76793469,
            76348894,
            76346501,
            76359563,
            76454438,
            76345410,
            76341218,
            76346125,
            76349446,
            76346871,
            76343626,
            76346043,
            76350035,
            76345138,
            76349598,
            76348838,
            76367005
        ],
        "A": [
            76334223,
            76335060,
            76334379,
            76334482,
            76348815,
            76334952,
            76364133,
            76339027,
            76454272,
            76334304,
            76334154,
            76336649,
            76334438,
            76334441,
            76334773,
            76334264,
            76337258,
            76335486,
            76337735,
            76341537,
            76369906
        ]
    },
    "name": "E. JYPnation",
    "statement": "The new nation consists of n cities and some roads between them. JYP has\r\ngiven some restrictions: To guarantee efficiency while avoiding chaos, .\r\nThe logo of rivaling companies should not appear in the plan, that is, 4\r\nA,B,C,D JYP has given criteria for your diagram. For two cities A,B, let\r\ndis(A,B) be the smallest number of roads you have to go through to get\r\nfrom A to B. If it is not possible to walk from A to B, dis(A,B) = 614n.\r\nThen, the efficiency value is defined to be the sum of dis(A,B) for all\r\nordered pairs of distinct cities (A,B)..You have drawn a design diagram\r\nthat satisfies JYP’s restrictions. Find the sum of dis(A,B) over all\r\nordered pairs of cities (A,B) with A\r\nneq B.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 12.04.2020 18:40:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<bool>> g(n, vector<bool>(n, false));\n  vector<int> din(n, 0);\n  vector<int> dout(n, 0);\n  for (int i = 0; i < n; i++) {\n    string foo;\n    cin >> foo;\n    for (int j = 0; j < (n >> 2); j++) {\n      char c = foo[j];\n      int d = (c <= '9' ? (int) (c - '0') : (int) (c - 'A' + 10));\n      for (int k = 0; k < 4; k++) {\n        if (d & (1 << (3 - k))) {\n          int x = (j << 2) | k;\n          g[i][x] = true;\n          dout[i] += 1;\n          din[x] += 1;\n        }\n      }\n    }\n  }\n  const long long none = 614LL * n;\n  long long ans = 0;\n  vector<bool> alive(n, true);\n  for (int rm = n; rm >= 1; rm--) {\n    bool found = false;\n    for (int i = 0; i < n; i++) {\n      if (alive[i] && dout[i] == rm - 1) {\n        alive[i] = false;\n        ans += (1 + none) * (rm - 1);\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      vector<int> all;\n      for (int i = 0; i < n; i++) {\n        if (alive[i]) {\n          all.push_back(i);\n        }\n      }\n      debug(all);\n      assert((int) all.size() == rm);\n      vector<int> used(n, 0);\n      vector<int> seq(1, all[0]);\n      used[seq[0]] += 1;\n      vector<int> add;\n      vector<bool> in_seq(n, false);\n      in_seq[seq[0]] = true;\n      for (int it = 0; it < rm; it++) {\n        assert(it < (int) seq.size());\n        int v = seq[it];\n        in_seq[v] = false;\n        add.clear();\n        for (int j = 0; j < n; j++) {\n          if (v != j && !in_seq[j] && alive[j] && !g[v][j]) {\n            assert(used[j] < 2);\n            used[j] += 1;\n            add.push_back(j);\n          }\n        }\n        sort(add.begin(), add.end(), [&](int i, int j) {\n          return g[j][i];\n        });\n        for (int u : add) {\n          seq.push_back(u);\n          in_seq[u] = true;\n        }\n      }\n      seq.resize(rm);\n      reverse(seq.begin(), seq.end());\n      for (int i = 0; i < rm; i++) {\n        int cc = 0;\n        while (cc < rm - 1) {\n          ans += rm - 1 - cc;\n          cc += dout[seq[(i + cc) % rm]];\n        }\n      }\n      break;\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. JYPnation.json",
    "editorial_link": "https://codeforces.com//blog/entry/75913",
    "editorial": "The solution contains several tricky observations, but its not hard to\r\nprove each of them seperately, so I will mention only the key points of\r\nthe solution and proof.Firstly, we should repeatedly remove points that\r\nhave no in-degree. We can calculate their contribution easily.For a node\r\n, define to be the set of nodes that exists. has no cycles for any node\r\n.Letâs pick to be the node with maximum in-degree.Let = , and let = ,\r\nwhere is the set of all vertices. There exist nodes ,, such that\r\nexists.Let = , and let = For all nodes ,, exists. has no cycles, has no\r\ncycles. has no cycles, has no cycles. That means we have partitioned the\r\ngraph into two sets of nodes, where each set is completely ordered.Lets\r\nlabel the nodes in by where is an integer from to , such that for two\r\nnodes and , exists iff .Label nodes in by in similar manner. Define to\r\nbe the set of nodes that exists. Define to be the set of nodes that\r\nexists. If then . If then . iff iff and iff and iff iff and iff and\r\nFinally, we can count the answer in by the above observations.\r\n",
    "hint": []
}