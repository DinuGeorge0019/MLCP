{
    "link": "https://codeforces.com//contest/986/problem/A",
    "problemId": "186081",
    "problem_idx": "A",
    "shortId": "986A",
    "contest_number": "986",
    "problem_submissions": {
        "D": [
            42104811,
            42104792,
            42104740,
            42104337,
            42103931,
            42103877,
            42103819,
            42103728,
            42103430,
            42103363,
            42090622,
            42090614,
            42090469,
            42090439,
            42090421,
            42090403,
            42090387,
            38733857,
            38748243,
            38741625,
            38744949,
            38732535,
            38776124,
            38775923,
            73829906,
            48935186,
            46682125,
            38947315,
            38947302,
            38947285,
            38946968,
            38946777,
            38946767,
            38946516,
            38946375,
            38946181,
            38944862,
            38944853,
            38944843,
            38944833,
            38944826,
            38944784,
            38944707,
            38944667,
            38944627,
            38903696,
            38903692,
            38903690,
            38903603,
            38903544,
            38903533,
            38903435,
            38903221,
            38903111,
            38903010,
            38902730,
            38902722,
            38902698,
            38868689,
            38868687,
            38868625,
            38868606,
            38868604,
            38868564,
            38868475,
            38868474,
            38868436,
            38868410,
            38868378,
            38868342,
            38868314,
            38868268,
            38868265,
            38868261,
            38868236,
            38868233,
            38868218,
            38868215,
            38868193,
            38868187,
            38868182,
            38868177,
            38868174,
            38868170,
            38868106,
            38868104,
            38868091,
            38868070,
            38868066,
            38868064,
            38868060,
            38868052,
            38868048,
            38868019,
            38868012,
            38868008,
            38868002,
            38783809,
            38783797,
            38783781,
            38783746,
            38783741,
            38783462,
            38783445,
            38780380,
            38776796,
            38776020,
            38776009,
            38775996,
            38775983,
            38775959,
            38774927,
            38774159,
            38774142,
            38774133,
            38774083,
            38772484,
            38772455,
            38772446,
            38772398,
            38772056,
            38771982,
            38771852,
            38771749,
            38771473,
            38770302,
            38770261,
            38758325,
            38743969,
            38775097,
            38775073,
            38775025,
            38774686,
            38769151
        ],
        "E": [
            38747055,
            38738177,
            38746661,
            38745236,
            38748676,
            38751753,
            38745180,
            38747262,
            38746823,
            38745830,
            38751939,
            38740507,
            38750013,
            38749870,
            38752411,
            38979399,
            38747190,
            38753936,
            38746328,
            42589039,
            38781799,
            38781783,
            38752251,
            38750400,
            38738811,
            38743630
        ],
        "F": [
            38743952,
            38741619,
            38749997,
            38752035,
            38759153,
            38766951,
            38747287,
            38803173,
            38802767
        ],
        "C": [
            38736843,
            38745069,
            38732331,
            38733537,
            38731636,
            38741009,
            38735527,
            38733610,
            38737347,
            38735879,
            38747912,
            38735093,
            38731137,
            38747956,
            38732967,
            38749305,
            38742224,
            38742550,
            38745758,
            38746063
        ],
        "B": [
            38727078,
            38726856,
            38726789,
            38729993,
            38726090,
            38734230,
            38728365,
            38728016,
            38727081,
            38728548,
            38726100,
            38728328,
            38735514,
            38726544,
            38737280,
            38727906,
            38727500,
            38748980,
            38769342
        ],
        "A": [
            38722963,
            38723690,
            38723235,
            38724127,
            38723622,
            38736390,
            38723609,
            38724267,
            38724018,
            38725327,
            38724685,
            38725264,
            38723597,
            38724159,
            38722907,
            38723625,
            38725178,
            38724347,
            38741266,
            38724867
        ]
    },
    "name": "A. Fair",
    "statement": "Some company is going to hold a fair in Byteland. There are n towns in\r\nByteland and m two-way roads between towns. Of course, you can reach any\r\ntown from any other town using roads.There are k types of goods produced\r\nin Byteland and every town produces only one type. To hold a fair you\r\nhave to bring at least s different types of goods. It costs d(u,v) coins\r\nto bring goods from town u to town v where d(u,v) is the length of the\r\nshortest path from u to v. Length of a path is the number of roads in\r\nthis path.The organizers will cover all travel expenses but they can\r\nchoose the towns to bring goods from. Now they want to calculate minimum\r\nexpenses to hold a fair in each of n towns.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 29.05.2018 18:34:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k, s;\n  cin >> n >> m >> k >> s;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n  }\n  vector<vector<int>> g(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<vector<int>> dist(k, vector<int>(n, -1));\n  for (int type = 0; type < k; type++) {\n    vector<int> que;\n    for (int i = 0; i < n; i++) {\n      if (a[i] == type) {\n        dist[type][i] = 0;\n        que.push_back(i);\n      }\n    }\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int u : g[que[b]]) {\n        if (dist[type][u] == -1) {\n          dist[type][u] = dist[type][que[b]] + 1;\n          que.push_back(u);\n        }\n      }\n    }\n  }\n  vector<int> d(k);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < k; j++) {\n      d[j] = dist[j][i];\n    }\n    sort(d.begin(), d.end());\n    long long sum = 0;\n    for (int j = 0; j < s; j++) {\n      sum += d[j];\n    }\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << sum;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy",
        "number theory",
        "shortest paths"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Fair.json",
    "editorial_link": "https://codeforces.com//blog/entry/59758",
    "editorial": "Let\u00e2\u0080\u0099s find a cost to bring a good in each town. To do this we will run\r\nBFS from all towns producing good at once. Just add all that towns in\r\nqueue and run usual BFS. Complexity of BFS is , so total complexity of\r\nBFSs will be .Now for each town we should choose cheapest goods. We can\r\nsort them in , but we can use nth_element instead. It will put the -th\r\nelement in sorted order on place , and all elements smaller will be to\r\nthe left. Since we are interested only in their sum, we can just sum up\r\nfirst elements after calling nth_element.Another way to achieve\r\ncomplexity is to run all BFSs simultaneously, then for each town first\r\ngoods to reach it are the cheapest.Bonus: solve the problem in time.\r\n"
}