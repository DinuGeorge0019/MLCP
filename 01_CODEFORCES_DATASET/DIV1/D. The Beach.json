{
    "link": "https://codeforces.com//contest/1753/problem/D",
    "problemId": "1601079",
    "problem_idx": "D",
    "shortId": "1753D",
    "contest_number": "1753",
    "problem_submissions": {
        "F": [
            177651080,
            177647555,
            177657470,
            188911747,
            188911656,
            188911570,
            188911428,
            188910549,
            188910073,
            188909646,
            188909166,
            188907827,
            188904326,
            188904190,
            188903731,
            177833531,
            177833492
        ],
        "E": [
            177581778,
            177583727,
            177589838,
            177589285,
            177593827,
            177594409,
            177597830,
            177594087,
            177592707,
            177585112,
            177601527,
            177590220,
            177673253,
            177974155,
            177974124,
            177973591,
            177724036
        ],
        "D": [
            177563465,
            177565205,
            177564757,
            177573155,
            177575242,
            177580076,
            177576436,
            177570973,
            177566523,
            177596897,
            177580588,
            177604329,
            177563352,
            177570046,
            177566269,
            177573602,
            177755461,
            177576614,
            177574911
        ],
        "C": [
            177552151,
            177550933,
            177551820,
            177553154,
            177551866,
            177564888,
            177563099,
            177563169,
            177574479,
            177556455,
            177565810,
            177544648,
            177550098,
            177548226,
            177548338,
            177556464,
            177755441,
            177552144,
            177557310
        ],
        "B": [
            177547853,
            177542169,
            177543741,
            177547659,
            177545799,
            177543102,
            177548449,
            177558513,
            177542410,
            177547120,
            177556897,
            177532887,
            177540969,
            177543956,
            177543358,
            177547075,
            177755409,
            177545453,
            177551061
        ],
        "A2": [
            177545216,
            177538464,
            177539211,
            177543167,
            177542984,
            177539535,
            177544288,
            177553832,
            177538606,
            177548841,
            177551155,
            177550293,
            177537648,
            177536071,
            177539594,
            177543961,
            177755345,
            177539530,
            177545423
        ],
        "A1": [
            177533578,
            177538639,
            177539788,
            177537288,
            177537340,
            177539306,
            177543813,
            177553991,
            177538938,
            177533253,
            177550897,
            177550032,
            177537887,
            177533119,
            177533588,
            177544324,
            177755312,
            177540035,
            177546684
        ]
    },
    "name": "D. The Beach",
    "statement": "Andrew loves the sea. That’s why, at the height of the summer season, he\r\ndecided to go to the beach, taking a sunbed with him to sunbathe.The\r\nbeach is a rectangular field with n rows and m columns. Some cells of\r\nthe beach are free, some have roads, stones, shops and other non-movable\r\nobjects. Some of two adjacent along the side cells can have sunbeds\r\nlocated either horizontally or vertically.Andrew hopes to put his sunbed\r\nsomewhere, but that’s a bad luck, there may no longer be free places for\r\nhim! That’s why Andrew asked you to help him to find a free place for\r\nhis sunbed. Andrew’s sunbed also should be places on two adjacent cells.\r\nIf there are no two adjacent free cells, then in order to free some\r\nplace for a sunbed, you will have to disturb other tourists. You can do\r\nthe following actions: Come to some sunbed and, after causing p units of\r\ndiscomfort to its owner, lift the sunbed by one of its sides and rotate\r\nit by 90 degrees. One half of the sunbed must remain in the same cell\r\nand another half of the sunbed must move to the free cell. At the same\r\ntime, anything could be on the way of a sunbed during the rotation .\r\nCome to some sunbed and, after causing q units of discomfort to its\r\nowner, shift the sunbed along its long side by one cell. One half of the\r\nsunbed must move to the place of another, and another to the free cell.\r\nIn any moment each sunbed occupies two adjacent free cells. You cannot\r\nmove more than one sunbed at a time.Help Andrew to free a space for his\r\nsunbed, causing the minimum possible number of units of discomfort to\r\nother tourists, or detect that it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nconstexpr i64 inf = 1E18;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m, p, q;\n    std::cin >> n >> m >> p >> q;\n    \n    std::vector<std::string> s(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> s[i];\n    }\n    \n    const int N = n * m;\n    std::vector<int> match(N, -1);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (s[i][j] == 'L') {\n                match[i * m + j] = i * m + j + 1;\n                match[i * m + j + 1] = i * m + j;\n            } else if (s[i][j] == 'U') {\n                match[i * m + j] = (i + 1) * m + j;\n                match[(i + 1) * m + j] = i * m + j;\n            }\n        }\n    }\n    \n    auto bfs = [&](int t) {\n        std::vector<i64> dis(N, inf);\n        std::queue<std::pair<int, i64>> q1, q2;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if ((i + j) % 2 == t && s[i][j] == '.') {\n                    q1.emplace(i * m + j, 0);\n                }\n            }\n        }\n        \n        while (!q1.empty() || !q2.empty()) {\n            int u;\n            i64 d;\n            \n            if (!q1.empty() && (q2.empty() || q1.front().second < q2.front().second)) {\n                std::tie(u, d) = q1.front();\n                q1.pop();\n            } else {\n                std::tie(u, d) = q2.front();\n                q2.pop();\n            }\n            \n            if (dis[u] != inf) {\n                continue;\n            }\n            \n            dis[u] = d;\n            int x = u / m, y = u % m;\n            \n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                \n                if (nx < 0 || nx >= n || ny < 0 || ny >= m || match[nx * m + ny] == -1) {\n                    continue;\n                }\n                \n                int mx = nx + dx[i];\n                int my = ny + dy[i];\n                \n                if (mx < 0 || mx >= n || my < 0 || my >= m || match[nx * m + ny] != mx * m + my) {\n                    q1.emplace(match[nx * m + ny], d + p);\n                } else {\n                    q2.emplace(match[nx * m + ny], d + q);\n                }\n            }\n        }\n        \n        return dis;\n    };\n    \n    auto f0 = bfs(0);\n    auto f1 = bfs(1);\n    \n    i64 ans = inf;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                i64 v = f0[i * m + j];\n                if (i) {\n                    ans = std::min(ans, v + f1[(i - 1) * m + j]);\n                }\n                if (i + 1 < n) {\n                    ans = std::min(ans, v + f1[(i + 1) * m + j]);\n                }\n                if (j) {\n                    ans = std::min(ans, v + f1[i * m + j - 1]);\n                }\n                if (j + 1 < m) {\n                    ans = std::min(ans, v + f1[i * m + j + 1]);\n                }\n            }\n        }\n    }\n    if (ans == inf) {\n        ans = -1;\n    }\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. The Beach.json",
    "editorial_link": "https://codeforces.com//blog/entry/108336",
    "editorial": "Letâs paint our field in a chess coloring. Now letâs consider our\r\noperations not as the movement of sunbeds, but as the movement of free\r\ncells. Then, a free cell adjacent to the long side of the sunbed can\r\nmove to a cell of the sunbed that is not adjacent to this one, for units\r\nof discomfort. A free cell adjacent to the short side of the sunbed can\r\nmove to a cell of the sunbed that is not adjacent to this one, for units\r\nof discomfort. Note that in this cases, the free cell does not change\r\nits color (in chess coloring).Since each sunbed should occupy one black\r\nand one white cell, then some two free cells of different colors should\r\nmove to neighboring ones using operations.It can be shown that in the\r\noptimal answer we use no more than one operation with each sunbed.Then,\r\nfor each position, looking at the adjacent sunbeds, we will determine\r\nwhere the free cell can move if it turns out to be in this position.\r\nLetâs construct a weighted oriented graph on the cells of the field.\r\nEdge of weight (equal to or ) will mean that there is a sunbed such that\r\nby moving it with an operation that brings discomfort, we will free the\r\ncell and block the cell . Note that the graphs on the black and white\r\ncells are not connected. Letâs run Dijkstraâs algorithm from all free\r\ncells at once. Then, for each cell - the minimum distance in this graph\r\nfrom a free cell is equal to the minimum amount of discomfort that must\r\nbe used to free this cell. The answer to the problem is the minimum for\r\nall pairs , neighboring cells, . Or if there is no pair of adjacent\r\ncells, both of which are reachable from the free ones.Asymptotics of the\r\nsolution:\r\n",
    "hint": []
}