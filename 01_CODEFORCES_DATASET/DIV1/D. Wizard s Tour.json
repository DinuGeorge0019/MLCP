{
    "link": "https://codeforces.com//contest/860/problem/D",
    "problemId": "122867",
    "problem_idx": "D",
    "shortId": "860D",
    "contest_number": "860",
    "problem_submissions": {
        "E": [
            30442338,
            30439610,
            30443019,
            30443046,
            30440508,
            30432483,
            30439294,
            30445411,
            30436063,
            30437142,
            30437221,
            30481068,
            30480696,
            30454225,
            30453851,
            30453830,
            30453714,
            30453688,
            30451950,
            30438289,
            30430653,
            30450525
        ],
        "C": [
            30436281,
            30442840,
            30434064,
            30433549,
            30444395,
            30448672,
            30433775,
            30432045,
            30440377,
            30451948,
            30455922,
            30438248,
            30440061,
            30440352,
            30434684,
            30440440,
            30440439,
            30441823
        ],
        "D": [
            30433124,
            30431343,
            30438212,
            30436898,
            30431927,
            30428404,
            30445018,
            30435042,
            30427155,
            30430494,
            30439252,
            30433856,
            31966531,
            30430878,
            30431992,
            30442376,
            30442582,
            30437824,
            30433265,
            30433563,
            30431407
        ],
        "B": [
            30425955,
            30423718,
            30424479,
            30425464,
            30424782,
            30426033,
            30423375,
            30424915,
            30427560,
            30426303,
            30423664,
            30424888,
            30426149,
            30428815,
            30436103,
            30426185,
            30427070,
            30426587,
            30424713
        ],
        "A": [
            30423599,
            30422216,
            30422379,
            30422507,
            30422342,
            30423247,
            30422321,
            30422663,
            30422437,
            30424719,
            30423379,
            30422275,
            30422538,
            30422660,
            30423270,
            30433600,
            30422460,
            30423290,
            30423757,
            30422708
        ]
    },
    "name": "D. Wizard s Tour",
    "statement": "All Berland residents are waiting for an unprecedented tour of wizard in\r\nhis Blue Helicopter over the cities of Berland!It is well-known that\r\nthere are cities in Berland, some pairs of which are connected by\r\nbidirectional roads. Each pair of cities is connected by no more than\r\none road. It is not guaranteed that the road network is , i.e. it is\r\npossible that you can’t reach some city from some other.The tour will\r\ncontain several episodes. In each of the episodes: the wizard will\r\ndisembark at some city from the Helicopter; he will give a performance\r\nand show a movie for free at the city ; he will drive to some\r\nneighboring city using a road; he will give a performance and show a\r\nmovie for free at the city ; he will drive to some neighboring to city ;\r\nhe will give a performance and show a movie for free at the city ; he\r\nwill embark the Helicopter and fly away from the city . It is known that\r\nthe wizard doesn’t like to use roads, so he agrees to use each road at\r\nmost once (regardless of direction). In other words, for road between\r\nand he only can drive once from to , or drive once from to , or do not\r\nuse this road at all.The wizards wants to plan as many episodes as\r\npossible without violation the above rules. Help the wizard!Please note\r\nthat the wizard can visit the same city multiple times, the restriction\r\nis on roads only.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nvector<int> E[202020];\nmap<pair<int,int>,int> EE;\nint vis[202020];\nint vise[202020];\nvector<vector<int>> R;\n\nint dfs(int cur,int pre) {\n\tint m=-1;\n\tif(vis[cur]) return cur;\n\tvis[cur]=1;\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tif(vise[EE[{cur,e}]]) continue;\n\t\tvise[EE[{cur,e}]]=1;\n\t\tint tar=dfs(e,cur);\n\t\tif(tar!=-1) {\n\t\t\tif(m==-1) {\n\t\t\t\tm=tar;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR.push_back({m,cur,tar});\n\t\t\t\tm=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(m==-1) {\n\t\treturn cur;\n\t}\n\telse {\n\t\tif(pre!=-1) R.push_back({m,cur,pre});\n\t\treturn -1;\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,M) {\n\t\tcin>>x>>y;\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t\tEE[{x,y}]=EE[{y,x}]=i;\n\t}\n\tFOR(i,N) if(vis[i+1]==0) dfs(i+1,-1);\n\t\n\t_P(\"%d\\n\",R.size());\n\tFORR(r,R) _P(\"%d %d %d\\n\",r[0],r[1],r[2]);\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Wizard s Tour.json",
    "editorial_link": "https://codeforces.com//blog/entry/54604",
    "editorial": "Obviously the task can be solved independently for each component.\n\nHere is the algorithm that allows you to reach exactly  tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.\n\nThis algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal.",
    "hint": []
}