{
    "link": "https://codeforces.com//contest/2006/problem/D",
    "problemId": "2845533",
    "problem_idx": "D",
    "shortId": "2006D",
    "contest_number": "2006",
    "problem_submissions": {
        "F": [
            278838627,
            278834885,
            278839605,
            278842896,
            283040284,
            278849665,
            279479840,
            279030892,
            278872889
        ],
        "E": [
            278816205,
            278815039,
            278825195,
            278819088,
            278823646,
            278824405,
            278834146,
            278833851,
            278836845,
            278834660,
            278831348,
            278835070,
            278824284,
            278835798,
            278834079,
            278836349,
            278834150,
            278840676,
            278837721,
            278840281
        ],
        "D": [
            278802409,
            278805803,
            278813224,
            278825476,
            278809587,
            278813203,
            278814738,
            278815896,
            278817434,
            278818422,
            278823248,
            278822269,
            278830412,
            278825693,
            278818908,
            278819966,
            278823289,
            278817077,
            278823950,
            278818832
        ],
        "C": [
            278788793,
            278798461,
            278801097,
            278797423,
            278800136,
            278800438,
            278797097,
            278802996,
            278798370,
            278802119,
            278807042,
            278803250,
            278809464,
            278800483,
            278808112,
            278808529,
            278813687,
            278799260,
            278808716,
            278807375
        ],
        "B": [
            278783201,
            278791628,
            278792112,
            278787764,
            278787151,
            278789090,
            278788997,
            278795304,
            278790397,
            278793228,
            278796651,
            278795483,
            278796854,
            278787538,
            278797112,
            278796560,
            278796305,
            278792796,
            278798821,
            278792242
        ],
        "A": [
            278774854,
            278780780,
            278783421,
            278777635,
            278777703,
            278778768,
            278777654,
            278780623,
            278781426,
            278784680,
            278779860,
            278783271,
            278779619,
            278776511,
            278786116,
            278783656,
            278783630,
            278778742,
            278777793,
            278783717
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133382",
    "editorial": "Read the hints. Let\u00e2\u0080\u0099s consider how to reorder the array. Let the sorted\r\narray be . We can prove that it is optimal to reorder it like this: .\r\nYou can find the proof at the end of the tutorial.From the proof or\r\nanything we can discover the restriction is: for all that , .Let denote\r\nthe number of elements with values in range . We can rewrite the\r\nrestrictions into: for each that , it must satisfy that . This means\r\nthat the number of that cannot fit must not be greater than the number\r\nof , and only numbers should be considered. Note that there\u00e2\u0080\u0099re only\r\nrange sums on the value range to consider, which is acceptable. Consider\r\na modify operation, we obviously change the maximum value into . This\r\nincreases every by and decreases every non-zero by , so the answer is\r\neasy to calculate. Just notice the situation when is too small and the\r\nlength of the interval is too short.How to maintain for all\r\nsubintervals? You can consider simply prefix sums, but its time constant\r\nfactor seems too large for a 2-dimensional array. So we lowered the\r\nmemory limit to reduce such issues. An easy way to handle is: solve the\r\nproblem offline, and for each we calculate the prefix sum for and , and\r\nthen answer all the queries. In this way the time constant factor\r\nbecomes much smaller and the memory becomes .Another way to solve is to\r\nuse Mo\u00e2\u0080\u0099s algorithm. It uses memory and time.The time complexity is\r\n.Proof for the optimal way to reorder:If , it\u00e2\u0080\u0099s correct.First, it is\r\noptimal to put at the first position. Suppose there\u00e2\u0080\u0099s a way to reorder\r\nthat is not at the first position: , we can always reverse the prefix so\r\nthat it still satisfies the condition but is at the first position.Then,\r\nit is optimal to put at the second position. Suppose there\u00e2\u0080\u0099s a way to\r\nreorder that is at the first position and at the second position, as and\r\nboth can fit , we can consider them the same(any number can be put\r\nbeside them), so it\u00e2\u0080\u0099s possible to swap and .If , then the array isn\u00e2\u0080\u0099t\r\ngood. Otherwise, any number can be put beside , so the method of\r\nreordering can be reduced to the same problem of . So the conclusion is\r\nproved.\r\n",
    "name": "D. Iris and Adjacent Products",
    "statement": "Iris has just learned multiplication in her Maths lessons. However,\r\nsince her brain is unable to withstand too complex calculations, she\r\ncould not multiply two integers with the product greater than k\r\ntogether. Otherwise, her brain may explode!Her teacher sets a difficult\r\ntask every day as her daily summer holiday homework. Now she is given an\r\narray a consisting of n elements, and she needs to calculate the product\r\nof each two adjacent elements (that is, a_1\r\ncdot a_2, a_2\r\ncdot a_3, and so on). Iris wants her brain to work safely, and in order\r\nto do that, she would like to modify the array a in such a way that a_i\r\ncdot a_{i + 1}\r\nleq k holds for every 1\r\nleq i < n. There are two types of operations she can perform: She can\r\nrearrange the elements of the array a in an arbitrary way. She can\r\nselect an arbitrary element of the array a and change its value to an\r\narbitrary integer from 1 to k. Iris wants to minimize the number of\r\noperations of that she uses.However, that\u2019s completely not the end of\r\nthe summer holiday! Summer holiday lasts for q days, and on the i-th\r\nday, Iris is asked to solve the Math homework for the subarray b_{l_i},\r\nb_{l_i + 1},\r\nldots, b_{r_i}. Help Iris and tell her the minimum number of type 2\r\noperations she needs to perform for each day. Note that the operations\r\nare for each day, i.e. the array b is not changed.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 30.08.2024 08:02:16**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int n, q, k;    cin >> n >> q >> k;    vector<int> b(n);    for (int i = 0; i < n; i++) {      cin >> b[i];    }    vector<int> ql(q), qr(q);    for (int i = 0; i < q; i++) {      cin >> ql[i] >> qr[i];      --ql[i];    }    for (int i = 0; i < n; i++) {      int x = k / b[i];      b[i] = k / x;    }    auto bs = b;    sort(bs.begin(), bs.end());    bs.resize(unique(bs.begin(), bs.end()) - bs.begin());    int sz = int(bs.size());    for (int i = 0; i < n; i++) {      b[i] = int(lower_bound(bs.begin(), bs.end(), b[i]) - bs.begin());    }    const int B = max(1, int(sqrt(n)));    vector<pair<int, int>> by(q);    for (int i = 0; i < q; i++) {      by[i] = {ql[i] / B, qr[i]};    }    vector<int> order(q);    iota(order.begin(), order.end(), 0);    sort(order.begin(), order.end(), [&](int i, int j) {      return by[i] < by[j];    });    vector<int> res(q);    vector<int> cnt(sz);    auto Add = [&](int i) {      cnt[b[i]] += 1;    };    auto Remove = [&](int i) {      cnt[b[i]] -= 1;    };    int l = 0, r = 0;    for (int it : order) {      while (r < qr[it]) {        Add(r++);      }      while (l > ql[it]) {        Add(--l);      }      while (r > qr[it]) {        Remove(--r);      }      while (l < ql[it]) {        Remove(l++);      }      int len = qr[it] - ql[it];      int min_sum = 2 * len;      int si = 0, sj = len;      int j = sz;      for (int i = 0; i < sz; i++) {        if (cnt[i] == 0) {          continue;        }        while (j > i && int64_t(bs[i]) * bs[j - 1] > k) {          j -= 1;          sj -= cnt[j];        }        if (i > j) {          break;        }        min_sum = min(min_sum, si + max(si + 1, sj));        si += cnt[i];      }      int new_len = min(len, min_sum);      res[it] = (len - new_len + 1) / 2;    }    for (int i = 0; i < q; i++) {      cout << res[i] << \" \\n\"[i == q - 1];    }  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Iris and Adjacent Products.json"
}