{
    "link": "https://codeforces.com//contest/1336/problem/F",
    "problemId": "594572",
    "problem_idx": "F",
    "shortId": "1336F",
    "contest_number": "1336",
    "problem_submissions": {
        "D": [
            76886677,
            76883955,
            76872368,
            76882178,
            76894871,
            76894177,
            76885532,
            76907882,
            77033594,
            77091883,
            76900082,
            76884934,
            76874617
        ],
        "A": [
            76864054,
            76808839,
            76828187,
            76809546,
            76814169,
            76823336,
            76827670,
            76836840,
            76814633,
            76809091,
            76816264,
            76813939,
            76811729,
            76811390,
            76834705,
            76826600,
            76815368,
            76837049,
            76817310
        ],
        "B": [
            76860488,
            76819320,
            76814288,
            76825429,
            76828812,
            76838781,
            76838525,
            76843572,
            76826054,
            76817907,
            76825620,
            76826257,
            76821471,
            76823111,
            76831291,
            76821337,
            76838685,
            76839113,
            76827505
        ],
        "C": [
            76854725,
            76829511,
            76835542,
            76846764,
            76855809,
            76854630,
            76858132,
            76850152,
            76839221,
            76831744,
            76838549,
            76834558,
            76833263,
            76835970,
            76841416,
            76837215,
            76859411,
            76818388,
            76844588
        ],
        "E1": [
            76850288,
            76855475,
            76852735,
            76883081,
            76892755,
            76881482,
            76888504,
            76867895,
            76895876,
            76859814,
            76851085,
            76862051,
            77146034,
            76864099,
            76864337,
            76853452,
            150818764,
            150818693,
            76914981,
            76914599,
            76858346,
            76859234
        ],
        "E2": [
            76849352,
            85264213,
            76894287,
            77317433,
            76903834,
            77032081,
            227735667,
            77145907
        ],
        "F": [
            76895069,
            142907140,
            92908333,
            92907865,
            76904132,
            77029817,
            77028666,
            77028475,
            76902682,
            76902541
        ]
    },
    "name": "F. Journey",
    "statement": "In the wilds far beyond lies the Land of Sacredness, which can be viewed\r\nas a tree connected undirected graph consisting of n nodes and n-1\r\nedges. The nodes are numbered from 1 to n. There are m travelers\r\nattracted by its prosperity and beauty. Thereupon, they set off their\r\njourney on this land. The i-th traveler will travel along the shortest\r\npath from s_i to t_i. In doing so, they will all edges in the shortest\r\npath from s_i to t_i, which is unique in the tree.During their journey,\r\nthe travelers will acquaint themselves with the others. Some may even\r\nbecome friends. To be specific, the i-th traveler and the j-th traveler\r\nwill become friends if and only if there are k edges that both the i-th\r\ntraveler and the j-th traveler will . Your task is to find out the\r\nnumber of pairs of travelers (i, j) satisfying the following conditions:\r\n1\r\nleq i < j\r\nleq m. the i-th traveler and the j-th traveler will become friends.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\n//Lyft Level 5 Challenge 2018 - Final F\ntemplate<class E>\nstruct doubling{\n\tconst vvc<E>&g;\n\tconst int n,h;\n\tint cnt;\n\tvvc<int> par;\n\tvi dep,in,out;\n\tvoid dfs(int v,int p,int d){\n\t\tpar[0][v]=p;\n\t\tdep[v]=d;\n\t\tin[v]=cnt++;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,d+1);\n\t\tout[v]=cnt;\n\t}\n\tdoubling(const vvc<E>&gg,int r):g(gg),n(g.size()),h(__lg(n)+1),\n\t\tcnt(0),par(h,vi(n,-1)),dep(n),in(n),out(n){\n\t\tdfs(r,-1,0);\n\t\trng(i,1,h){\n\t\t\trep(j,n)\n\t\t\t\tif(par[i-1][j]!=-1)\n\t\t\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint lca(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tint w=dep[b]-dep[a];\n\t\trep(i,h)if(w&1<<i)\n\t\t\tb=par[i][b];\n\t\tif(a==b)return a;\n\t\tper(i,h){\n\t\t\tint x=par[i][a],y=par[i][b];\n\t\t\tif(x!=y)tie(a,b)=pi(x,y);\n\t\t}\n\t\treturn par[0][a];\n\t}\n\tint len(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tint jump(int a,int b,int d){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tint c=lca(a,b);\n\t\tint w=dep[a]+dep[b]-dep[c]*2;\n\t\tassert(0<=d&&d<=w);\n\t\tif(d<=dep[a]-dep[c]){\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\ta=par[i][a];\n\t\t\treturn a;\n\t\t}else{\n\t\t\td=w-d;\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\tb=par[i][b];\n\t\t\treturn b;\n\t\t}\n\t}\n\tint getpar(int v,int len)const{\n\t\trep(i,h)if(len&1<<i)v=par[i][v];\n\t\treturn v;\n\t}\n};\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.assign(s=n,0);}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\n//offline\n//ROI2018 day2 D\nstruct point2d{\n\tstruct query{\n\t\tint x,i,l,r;\n\t\tbool operator<(const query&rhs)const{\n\t\t\treturn pi(x,-i)<pi(rhs.x,-rhs.i);\n\t\t}\n\t};\n\tvi ys,ans;\n\tvc<query> qs;\n\tpoint2d(const vc<pi>&ps){\n\t\tfor(auto p:ps)\n\t\t\tys.pb(p.b);\n\t\tmkuni(ys);\n\t\tfor(auto p:ps)\n\t\t\tqs.pb({p.a,-1,lwb(ys,p.b),-1});\n\t}\n\tvoid aq(int x1,int x2,int y1,int y2){\n\t\tint i=si(ans);\n\t\tans.pb(0);\n\t\ty1=lwb(ys,y1);\n\t\ty2=lwb(ys,y2);\n\t\tqs.pb({x1,i*2,y1,y2});\n\t\tqs.pb({x2,i*2+1,y1,y2});\n\t}\n\tvi calc(){\n\t\tsort(all(qs));\n\t\tBIT<int> bit(si(ys));\n\t\tfor(auto q:qs){\n\t\t\tif(q.i==-1){\n\t\t\t\tbit.add(q.l,1);\n\t\t\t}else{\n\t\t\t\tint w=bit.sum(q.l,q.r);\n\t\t\t\tif(q.i%2==0)ans[q.i/2]-=w;\n\t\t\t\telse ans[q.i/2]+=w;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n//\u5185\u90e8\u3067\u30b0\u30e9\u30d5\u3092\u3044\u3058\u308b\u304b\u3089 in,out \u3092\u4f7f\u3046\u3068\u304d\u306f\u6ce8\u610f\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tg[v].erase(remove(all(g[v]),p),g[v].ed);\n\t\tfor(auto&e:g[v]){\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\tint k;\n\tvvc<pi> pt;\n\tstruct Query{\n\t\tint i,x1,x2,y1,y2,w;\n\t\tbool has(int x,int y){\n\t\t\treturn x1<=x&&x<x2&&y1<=y&&y<y2;\n\t\t}\n\t};\n\tvc<Query> qs;\n\tmap<int,int> dfs(int v,const doubling<int>&d){\n\t\tmap<int,int> res;\n\t\tint l=0,r=0;\n\t\tif(si(g[v])){\n\t\t\tres=dfs(g[v][0],d);\n\t\t\tl=in[g[v][0]];\n\t\t\tr=out[g[v][0]];\n\t\t}\n\t\tauto add=[&](int i,int to){\n\t\t\tauto itr=res.find(i);\n\t\t\tif(itr==res.ed)res[i]=to;\n\t\t\telse res.erase(itr);\n\t\t};\n\t\tbool curvert=false;\n\t\tauto waf=[&](int i,int to){\n\t\t\tif(!asde(v,to)){\n\t\t\t\tint c=lca(v,to);\n\t\t\t\tint uplen=dep[v]-dep[c];\n\t\t\t\tint downlen=dep[to]-dep[c];\n\t\t\t\tif(uplen+downlen>=k){\n\t\t\t\t\tif(uplen>=k){\n\t\t\t\t\t\tint z=d.getpar(v,k-1);\n\t\t\t\t\t\tif(l<r){\n\t\t\t\t\t\t\tqs.pb({i,0,in[z],l,r,2});\n\t\t\t\t\t\t\tqs.pb({i,l,r,out[z],n,2});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(curvert){\n\t\t\t\t\t\t\tqs.pb({i,0,in[z],in[v],in[v]+1,1});\n\t\t\t\t\t\t\tqs.pb({i,in[v],in[v]+1,out[z],n,1});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(in[to]>in[v]&&downlen){\n\t\t\t\t\t\t\tint w=d.getpar(to,downlen-1);\n\t\t\t\t\t\t\tif(l<r)qs.pb({i,l,r,in[w],out[w],-2});\n\t\t\t\t\t\t\tif(curvert)qs.pb({i,in[v],in[v]+1,in[w],out[w],-1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(in[to]<in[v]){\n\t\t\t\t\t\t\tint z=d.getpar(to,(uplen+downlen-k));\n\t\t\t\t\t\t\tif(l<r)qs.pb({i,in[z],out[z],l,r,2});\n\t\t\t\t\t\t\tif(curvert)qs.pb({i,in[z],out[z],in[v],in[v]+1,1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(i,to);\n\t\t};\n\t\trng(tmpi,1,si(g[v])){\n\t\t\tmap<int,int> z=dfs(g[v][tmpi],d);\n\t\t\tfor(auto kv:z){\n\t\t\t\twaf(kv.a,kv.b);\n\t\t\t}\n\t\t\tr=out[g[v][tmpi]];\n\t\t}\n\t\tcurvert=1;\n\t\tfor(auto kv:pt[v]){\n\t\t\twaf(kv.a,kv.b);\n\t\t}\n\t\treturn move(res);\n\t}\n\tvoid slv(int kk,int m){\n\t\tk=kk;\n\t\tpt.resize(n);\n\t\tvc<pi> xy;\n\t\tll res=0;\n\t\trep(i,m){\n\t\t\tint a,b;cin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tpt[a].eb(i,b);\n\t\t\tpt[b].eb(i,a);\n\t\t\txy.pb(minmax(in[a],in[b]));\n\t\t\tif(len(a,b)<k)res++;\n\t\t}\n\t\tdoubling<int> d(g,0);\n\t\tdfs(0,d);\n\t\t\n\t\tvi ans(m);\n\t\t\n\t\tpoint2d ysp(xy);\n\t\tfor(auto z:qs)ysp.aq(z.x1,z.x2,z.y1,z.y2);\n\t\tauto mrt=ysp.calc();\n\t\trep(i,si(qs)){\n\t\t\tres+=qs[i].w*mrt[i];\n\t\t}\n\t\t\n\t\tdmp(ans);\n\t\tres-=m;\n\t\tprint(res/2);\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,m;cin>>n>>m;\n\tint k;cin>>k;\n\t\n\tvvc<int> t(n);\n\trep(_,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tt[a].pb(b);\n\t\tt[b].pb(a);\n\t}\n\t\n\tHLD<int> h(t,0);\n\th.slv(k,m);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "graphs",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Journey.json",
    "editorial_link": "https://codeforces.com//blog/entry/76099",
    "editorial": "TutorialFirst, let\u00e2\u0080\u0099s choose an arbitrary root for the tree. Then for all\r\npairs of paths, their LCA (lowest common ancestor) can be either\r\ndifferent or the same.Then, let\u00e2\u0080\u0099s calculate the answer of pairs with\r\ndifferent LCAs. In this case, if the intersection is not empty, it will\r\nbe a vertical path as in the graph below.Here path and path intersects\r\nat path .We can process all paths in decreasing order of the depth of\r\ntheir LCA. When processing a path we calculate the number of paths ,\r\nwhere is processed before , and the edge-intersection of and is at least\r\n. To do this we can plus one to the subtree of the nodes on the path\r\nedges away from the LCA (node and for path in the graph above), then we\r\ncan query the value at the endpoints of the path (node and for path ).\r\nWe can maintain this easily with BIT (binary indexed tree, or Fenwick\r\ntree).Next, we calculate pairs with the same LCA. This case is\r\nharder.For each node we calculate the number of pairs with the LCA . For\r\na pair of path and , there are still two cases we need to handle.Let be\r\nthe index of in the DFS order. For a path we assume that (otherwise you\r\ncan just swap them)In the first case ( the right one in the graph above,\r\nwhere ), the intersection of and is the path that goes from to (path )In\r\nthis case the intersection may cross over node .For all paths with the\r\nLCA . We can build a virtual-tree over all of the paths, and on node we\r\nstore the value of . Let\u00e2\u0080\u0099s do a dfs on the virtual-tree. On each node we\r\ncalculate pairs , that . For , let\u00e2\u0080\u0099s go from to for edges, assume the\r\nnode we reached is , all legal should be in the subtree of .We can use a\r\nsegment tree on the DFS-order to maintain all s in the subtree and merge\r\nthem with the small-to-large trick, meanwhile, iterate over all in the\r\nsmaller segment tree, count the valid \u00e2\u0080\u0099s in the larger segment tree.In\r\nfact, you can use HLD (heavy-light decomposition) instead of\r\nvirtual-tree, which seems to be easier to implement.Now note that the\r\nsolution above is based on the fact that the intersection of and is the\r\npath that goes from to . But it is not always true, so here we have\r\nanother case to handle.In this case, (the left one in the graph above),\r\nthe intersection is definitely a vertical path that goes from to . This\r\ncan be solved similarly to the case of different LCAs.The overall\r\ncomplexity of this solution is .\r\n"
}