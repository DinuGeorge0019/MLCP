{
    "link": "https://codeforces.com//contest/1470/problem/D",
    "problemId": "855305",
    "problem_idx": "D",
    "shortId": "1470D",
    "contest_number": "1470",
    "problem_submissions": {
        "E": [
            103440669,
            103450045,
            103444324,
            103446807,
            103456209,
            103459429,
            103458872,
            103449311,
            103444803,
            103455366,
            103427287,
            103523513,
            103512117,
            107007766,
            103497278
        ],
        "C": [
            103424863,
            103419731,
            103412394,
            103420749,
            103473095,
            103443608,
            103423946,
            103436573,
            103483233,
            103668985,
            103426627,
            103424859,
            103478420,
            103478404,
            103478387,
            103478371,
            103478354,
            103478316,
            103478307,
            103478286,
            103478261,
            103478250,
            103415351,
            103438274,
            103450179,
            103434430,
            103429394,
            103442814,
            103435400
        ],
        "D": [
            103415926,
            103427083,
            103428552,
            103423208,
            103420751,
            103429115,
            103425438,
            103418855,
            103424458,
            103422509,
            103452603,
            103410374,
            103430035,
            103428165,
            103418606,
            103410543,
            103439473,
            103434901,
            103425306,
            103416679
        ],
        "B": [
            103406584,
            103402617,
            103400867,
            103408140,
            103415671,
            103407933,
            103428755,
            103407002,
            103406514,
            103413492,
            103439686,
            103403315,
            103398826,
            103407557,
            103405634,
            103400232,
            103409460,
            103410649,
            103414139,
            103409541
        ],
        "A": [
            103395440,
            103396207,
            103392457,
            120480996,
            103397804,
            103473156,
            103473127,
            103399272,
            103396942,
            103393409,
            103401022,
            103396664,
            103398098,
            103431488,
            103391970,
            103392128,
            103393954,
            103394467,
            103391951,
            103398410,
            103401147,
            103400351,
            103410763
        ],
        "F": [
            128458334,
            128458191,
            105649646,
            105647576
        ]
    },
    "name": "D. Strange Housing",
    "statement": "Students of Winter Informatics School are going to live in a set of\r\nhouses connected by underground passages. Teachers are also going to\r\nlive in some of these houses, but they can not be accommodated randomly.\r\nFor safety reasons, the following must hold: All passages between two\r\nhouses will be closed, if there are no teachers in both of them. All\r\nother passages will stay open. It should be possible to travel between\r\nany two houses using the underground passages that are . Teachers should\r\nnot live in houses, directly connected by a passage. Please help the\r\norganizers to choose the houses where teachers will live to satisfy the\r\nsafety requirements or determine that it is impossible.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 05.01.2021 18:05:09       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    vector<int> res(n, -1);\n    res[0] = 1;\n    vector<int> que;\n    for (int x : g[0]) {\n      que.push_back(x);\n      res[x] = 0;\n    }\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int v : g[que[b]]) {\n        if (res[v] == -1) {\n          res[v] = 1;\n          for (int x : g[v]) {\n            if (res[x] == -1) {\n              res[x] = 0;\n              que.push_back(x);\n            }\n          }\n        }\n      }\n    }\n    if (*min_element(res.begin(), res.end()) == -1) {\n      cout << \"NO\" << '\\n';\n      continue;\n    }\n    cout << \"YES\" << '\\n';\n    vector<int> ret;\n    for (int i = 0; i < n; i++) {\n      if (res[i] == 1) {\n        ret.push_back(i);\n      }\n    }\n    cout << ret.size() << '\\n';\n    for (int i = 0; i < (int) ret.size(); i++) {\n      if (i > 0) {\n        cout << \" \";\n      }\n      cout << ret[i] + 1;\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graph matchings",
        "graphs",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Strange Housing.json",
    "editorial_link": "https://codeforces.com//blog/entry/86464",
    "editorial": "One can prove that the answer always exists if the graph is connected,\r\nand the algorithm proves it.Let us paint all vertices with black and\r\nwhite colors. Let us pick any vertex and paint it black, and let us\r\npaint all its neighbours with white. Then let\u00e2\u0080\u0099s pick any uncoloured\r\nvertex that is connected to a white one, paint it black, and paint all\r\nits neighbours white. We continue this process until there are no\r\nuncoloured vertices left. We claim that the set of black vertices is the\r\nanswer.We are never painting two adjacent vertices black, since we\r\ncolour all their neighbours with white. It is also true that the set of\r\nalready coloured vertices is always connected if we keep only the edges\r\nadjacent to black vertices: it is true initially, and whenever we paint\r\na vertex white, it is connected to a black one directly, and when we\r\npaint a vertex black, one of its edges goes to a white one coloured on\r\nthe previous steps (that is how we pick the vertex to paint it white).\r\n"
}