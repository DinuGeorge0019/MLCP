{
    "link": "https://codeforces.com//contest/1876/problem/B",
    "problemId": "2251946",
    "problem_idx": "B",
    "shortId": "1876B",
    "contest_number": "1876",
    "problem_submissions": {
        "F": [
            227177806,
            227207094,
            227205539,
            227205151
        ],
        "E": [
            227157151,
            227151734,
            227168660,
            227172380,
            227183052,
            227309041,
            227308704,
            227174767,
            227180790,
            227181408,
            227180728,
            227180621,
            227182335,
            227260713,
            227259829,
            227186766,
            227170474,
            227321208,
            227261014
        ],
        "D": [
            227143743,
            227138577,
            227308847,
            227146942,
            227140586,
            227141511,
            227160448,
            227153072,
            227151615,
            227160275,
            227166901,
            227141697,
            227262091,
            227163246,
            227151371,
            227141424,
            227141434,
            227152662,
            227155489,
            227148839,
            227151040,
            227154461
        ],
        "C": [
            227128643,
            227130062,
            227133604,
            227130971,
            227129714,
            227144982,
            227139072,
            227133756,
            227145578,
            227141605,
            227156976,
            227263099,
            227135346,
            227132471,
            227128506,
            227133146,
            227135885,
            227135604,
            227140440,
            227137265
        ],
        "B": [
            227120010,
            227119885,
            227123059,
            227119488,
            227120157,
            227125041,
            227123945,
            227122604,
            227124586,
            227123169,
            227160403,
            227263121,
            227124143,
            227123043,
            227120364,
            227120185,
            227120687,
            227125676,
            227123006,
            227129980,
            227122132
        ],
        "A": [
            227117267,
            227116977,
            227118151,
            227116487,
            227116831,
            227118490,
            227120408,
            227118388,
            227121296,
            227117209,
            227162962,
            227263136,
            227118862,
            227118193,
            227117199,
            227115769,
            227117422,
            227121537,
            227118512,
            227124495,
            227116510
        ],
        "G": [
            227270487,
            229852864,
            229527555
        ]
    },
    "name": "B. Effects of Anti Pimples",
    "statement": "Chaneka has an array [a_1,a_2,\r\nldots,a_n]. Initially, all elements are white. Chaneka will choose one\r\nor more different indices and colour the elements at those chosen\r\nindices black. Then, she will choose all white elements whose indices\r\nare multiples of the index of black element and colour those elements\r\ngreen. After that, her score is the value of a_i out of all black and\r\ngreen elements.There are 2^n-1 ways for Chaneka to choose the black\r\nindices. Find the sum of scores for all possible ways Chaneka can choose\r\nthe black indices. Since the answer can be very big, print the answer\r\nmodulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\n\nint n;\nll tab[nax];\n\nll wyn;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i; j<=n; j+=i)\n\t\t\ttab[i]=max(tab[i], tab[j]);\n\tsort(tab+1, tab+1+n);\n\tll pot=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twyn=(wyn+tab[i]*pot)%mod;\n\t\tpot=(pot*2)%mod;\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "number theory",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Effects of Anti Pimples.json",
    "editorial_link": "https://codeforces.com//blog/entry/121200",
    "editorial": "For some value , let be the number of different ways to choose the black\r\nindices such that the score is exactly and let be the number of\r\ndifferent ways to choose the black indices such that the score is . Then\r\n.Let\u00e2\u0080\u0099s try to calculate . First, group the elements in into two groups,\r\nwith group 1 containing elements with values greater than and group 2\r\ncontaining elements with values not greater than . Notice that the only\r\nrequirement we must satisfy is to not make any group 1 element black or\r\ngreen and we can do anything to the group 2 elements. In order to make\r\nsure that no group 1 element is black or green, we must make sure that\r\nno black index we choose is a factor of at least one group 1 index. This\r\nmeans, we just need calculate some value that represents the number of\r\ndifferent indices that is a factor at least one group 1 index, then the\r\nvalue of is .The answer to the original problem is the sum of for all\r\npossible values . However, we just care about the values such that ,\r\nwhich only happens if is equal to the value of some element of .In order\r\nto calculate for all desired values of , we need to iterate the elements\r\nof from the biggest value to the smallest value. Each element we\r\niterate, we iterate every index that is a factor of the index of the\r\ncurrent element and mark those indices as group 1 while we keep track of\r\nthe value of .The total number of iterations is the total number of\r\nfactors for every index, which is .Time Complexity:\r\n"
}