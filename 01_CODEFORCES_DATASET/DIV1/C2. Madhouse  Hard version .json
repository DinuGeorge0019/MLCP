{
    "link": "https://codeforces.com//contest/1286/problem/C2",
    "problemId": "509642",
    "problem_idx": "C2",
    "shortId": "1286C2",
    "contest_number": "1286",
    "problem_submissions": {
        "E": [
            68277312,
            68282070,
            68274194,
            68303699,
            68303260,
            68305269,
            68280891,
            68275520,
            68485018,
            68484885,
            68281607,
            68589901,
            71865785,
            101133015,
            68300396
        ],
        "C2": [
            68266879,
            68290041,
            68261617,
            68262301,
            68264579,
            68294367,
            68270650,
            68281404,
            68295029,
            68426335,
            68286377,
            68264588,
            68267031
        ],
        "D": [
            68263572,
            68264108,
            68884999,
            68884847,
            68884788,
            68283246,
            68268908,
            68270542,
            68266913,
            68271305,
            68294377,
            68276847,
            68262972,
            68265436,
            68273176,
            68274949,
            68277188,
            68266253,
            68271981,
            68278589,
            68338459,
            68281162,
            68264815
        ],
        "C1": [
            68253495,
            68254635,
            68259019,
            68259783,
            68260037,
            68294288,
            68263649,
            68253659,
            68276644,
            68259313,
            68260800,
            68257683,
            68278462,
            68275645,
            68260838,
            68264488,
            68260121
        ],
        "B": [
            68249656,
            68250720,
            68252206,
            68250842,
            68249851,
            68249360,
            68294267,
            68254854,
            68250823,
            68250630,
            68252322,
            68250475,
            68253134,
            68252948,
            68253877,
            68249986,
            68255559,
            68256077,
            68252468,
            68253101,
            68252113
        ],
        "A": [
            68245108,
            68248019,
            68248101,
            68248225,
            68245837,
            68246154,
            68294224,
            68250492,
            68248558,
            68247246,
            68248005,
            68247110,
            68249600,
            68246667,
            68250822,
            68253310,
            68252365,
            68251609,
            68247685,
            68248520,
            68246550
        ],
        "F": [
            68288717,
            68426651,
            68284858,
            68284592,
            68283300,
            68321599,
            68593980,
            68272947,
            68281697,
            68274721,
            75028012
        ]
    },
    "name": "C2. Madhouse  Hard version ",
    "statement": "Venya joined a tour to the madhouse, in which orderlies play with\r\npatients the following game. Orderlies pick a string s of length n,\r\nconsisting only of lowercase English letters. The player can ask two\r\ntypes of queries: ask to list all substrings of s[l..r]. Substrings will\r\nbe returned in random order, and in every substring, all characters will\r\nbe randomly shuffled. guess the string picked by the orderlies. This\r\nquery can be asked exactly once, after that the game will finish. If the\r\nstring is guessed correctly, the player wins, otherwise he loses. The\r\nplayer can ask of the first type.To make it easier for the orderlies,\r\nthere is an additional limitation: the total number of returned\r\nsubstrings in all queries of the first type must not exceed\r\nleft\r\nlceil 0.777(n+1)^2\r\nright\r\nrceil (\r\nlceil x\r\nrceil is x rounded up).Venya asked you to write a program, which will\r\nguess the string by interacting with the orderlies\u2019 program and acting\r\nby the game\u2019s rules.Your program should immediately terminate after\r\nguessing the string using a query of the second type. In case your\r\nprogram guessed the string incorrectly, or it violated the game rules,\r\nit will receive verdict .Note that in every test case the string is\r\nfixed beforehand and will not change during the game, which means that\r\nthe interactor is not adaptive.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nchar p[120], A[10100][120], B[10100][120], res[120];\nint SA[110], SB[110], Z[110], Pre[110];\nint SS[110], Suf[110];\nvoid Do(int n) {\n\tint i, j;\n\tprintf(\"? %d %d\\n\", 1, n);\n\tfflush(stdout);\n\tfor (i = 0; i < n*(n + 1) / 2; i++) {\n\t\tscanf(\"%s\", A[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; A[i][j]; j++)c += A[i][j] - 'a';\n\t\tint L = j;\n\t\tSA[L] += c;\n\t}\n\tprintf(\"? %d %d\\n\", 1, n - 1);\n\tfflush(stdout);\n\n\tfor (i = 0; i < n*(n - 1) / 2; i++) {\n\t\tscanf(\"%s\", B[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; B[i][j]; j++)c += B[i][j] - 'a';\n\t\tint L = j;\n\t\tSB[L] += c;\n\t}\n\n\tfor (i = 1; i <= n; i++) {\n\t\tZ[i] = SA[i] - SB[i];\n\t\tres[n - i] = Z[i] - Z[i - 1] + 'a';\n\t}\n\n}\nint main() {\n\tint i, j, k;\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tif (n == 1) {\n\t\tprintf(\"? %d %d\\n\", 1, n);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", p);\n\t\tprintf(\"! %s\\n\", p);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\tif (n == 2) {\n\n\t\tprintf(\"? %d %d\\n\", 1, 1);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", p);\n\t\tres[0] = p[0];\n\t\tprintf(\"? %d %d\\n\", 2, 2);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", p);\n\t\tres[1] = p[0];\n\t\tres[2] = 0;\n\t\tprintf(\"! %s\\n\", res);\n\t\treturn 0;\n\t}\n\n\tDo((n + 1) / 2);\n\n\tprintf(\"? %d %d\\n\", 1, n);\n\tfflush(stdout);\n\n\tfor (i = 0; i < (n + 1) / 2; i++) {\n\t\tPre[i + 1] = Pre[i] + res[i] - 'a';\n\t}\n\n\tfor (i = 0; i < n*(n + 1) / 2; i++) {\n\t\tscanf(\"%s\", A[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; A[i][j]; j++)c += A[i][j] - 'a';\n\t\tint L = j;\n\t\tSS[L] += c;\n\t}\n\tint tot = SS[n];\n\n\tfor (i = 1; i <= n / 2; i++) {\n\t\tint z = SS[n-i];\n\t\tfor (j = 1; j < i; j++) {\n\t\t\tint s = 0;\n\t\t\tfor (k = 0; k < i - j; k++) {\n\t\t\t\ts += res[n - k - 1] - 'a';\n\t\t\t}\n\t\t\tz -= tot - (s + Pre[j]);\n\t\t}\n\n\t\tz -= (tot - Pre[i]);\n\t\tSuf[i] = tot - z;\n\t\tres[n - i] = Suf[i] - Suf[i - 1] + 'a';\n\t}\n\tprintf(\"! %s\\n\", res);\n\tfflush(stdout);\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "hashing",
        "interactive",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C2. Madhouse  Hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/72867",
    "editorial": "Let\u00e2\u0080\u0099s consider the solution that uses queries with the lengths and (it\r\nasks about too many substrings, so it will not pass all the tests, but\r\nit will help us further). Let\u00e2\u0080\u0099s ask about substrings and . For\r\nconvenience, rearrange the letters in all strings in alphabetical order.\r\nThen note that all the suffixes of correspond to those strings that we\r\nget in the first case, and do not get in the second. Having found all\r\nsuch strings, we can easily find all suffixes of by looking at them from\r\nsmaller ones to bigger.For a complete solution we should first find the\r\nfirst characters of the string by the solution described above. Then ask\r\nabout the whole string. Let be the number of times that the symbol\r\noccurs in total in all substrings of length in the last query. Note that\r\nthe symbol at position is counted in exactly times. Then for all from to\r\n, the value - is equal to the number of times that occurs on positions\r\nwith indices from to . Knowing these quantities, it is possible to find\r\nout how many times the element x occurs on positions and in sum for each\r\nfrom to . Since we already know the first half of the string, it is not\r\ndifficult to restore the character at the position , and therefore the\r\nentire string.In total, we asked about the substrings , and , the total\r\nnumber of substrings received is , and that the limitations of the\r\nproblem.\r\n"
}