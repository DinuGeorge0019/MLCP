{"link": "https://codeforces.com//contest/1924/problem/C", "problemId": "2447859", "problem_idx": "C", "shortId": "1924C", "contest_number": "1924", "problem_submissions": {"E": [243630255, 243625417, 243831471, 243819146, 243638029, 243635094, 243635575, 243643653, 243641448, 243654047, 243642725, 243655474, 243640193, 243642282, 243738773, 243738280, 243737868, 243737472, 243736583, 243647040, 243643392, 243656506, 243623598, 243647525, 243642926], "D": [243610539, 243613703, 243615017, 243615468, 243616484, 243609433, 243612607, 243604919, 243590030, 243626983, 243620249, 243611671, 243630742, 243627184, 243647496, 243637086, 243615081], "C": [243600996, 243608465, 243605004, 243605423, 243609031, 243624334, 243598851, 243618516, 243614897, 243607146, 243609954, 243605925, 243615697, 243614877, 243629728, 243619721, 243625857], "B": [243576284, 243596345, 243574522, 243584076, 243591802, 243608792, 243595388, 243582812, 243591583, 243581060, 243590774, 243588502, 243614602, 243593249, 243586709, 243594966, 243581169, 243586114], "A": [243557786, 243557461, 243557951, 243558389, 243559700, 243571068, 243569238, 243556739, 243561136, 243559764, 243556383, 243563507, 243559787, 243566206, 243566244, 243561059, 243558400, 243589028], "F": [243674865, 243667546, 243888054, 243737554, 246427685]}, "name": "C. Fractal Origami", "statement": "You have a square piece of paper with a side length equal to 1 unit. In\r\none operation, you fold each corner of the square to the center of the\r\npaper, thus forming another square with a side length equal to\r\ndfrac{1}{\r\nsqrt{2}} units. By taking this square as a new square, you do the\r\noperation again and repeat this process a total of N times. After\r\nperforming the set of operations, you open the paper with the same side\r\nup you started with and see some crease lines on it. Every crease line\r\nis one of two types: a mountain or a valley. A mountain is when the\r\npaper folds outward, and a valley is when the paper folds inward.You\r\ncalculate the sum of the length of all mountain crease lines on the\r\npaper and call it M. Similarly, you calculate for valley crease lines\r\nand call it V. You want to find the value of\r\ndfrac{M}{V}.It can be proved that this value can be represented in the\r\nform of A + B\r\nsqrt{2}, where A and B are rational numbers. Let this B be represented\r\nas an irreducible fraction\r\ndfrac{p}{q}, your task is to print p*inv(q) modulo 999\r\n,999\r\n,893 , where inv(q) is the modular inverse of q.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 999999893;\nusing Z = MInt<P>;\n\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    Z a = 0, b = 0;\n    a = power(Z(2), (n + 1) / 2);\n    b = power(Z(2), n / 2) - 1;\n    \n    Z c = a * a - b * b * 2;\n    Z ans = 2 * b / c;\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["geometry", "math", "matrices"], "dificulty": "2400", "interactive": false}