{"link": "https://codeforces.com//contest/1394/problem/A", "problemId": "697384", "problem_idx": "A", "shortId": "1394A", "contest_number": "1394", "problem_submissions": {"E": [89738268, 89751614, 89751306, 89748113, 92138216, 90294852], "C": [89732445, 89683758, 89696028, 89683626, 89694594, 89712053, 89693715, 89701612, 89697873, 89702287, 89692727, 89701355, 89703625, 90289383, 89700363, 89706177, 89705251, 89703716, 89721405, 89690071, 89703493, 89708013], "D": [89693191, 89704513, 89710792, 89709417, 89804436, 89704286, 89710073, 89710943, 89707637, 89713733, 89713912, 89711885, 89714265, 90289402, 89722481, 89717905, 89719820, 89719453, 89709166, 89707845, 89725892, 89720000], "B": [89670028, 89681474, 89694856, 89677267, 89803448, 89803280, 89758188, 89757972, 89693039, 89682124, 89685684, 89674007, 89686030, 89674213, 89680671, 89691474, 90289363, 89685315, 89684531, 89683358, 89689040, 89677823, 89676540, 89686855, 89686732], "A": [89662871, 89663327, 89661651, 89662462, 89662370, 89664124, 89666251, 89712037, 89661542, 89665502, 89668072, 89669720, 90289341, 89661258, 89665118, 89665097, 89669384, 89661494, 89728914, 89662580, 89663285]}, "name": "A. Boboniu Chats with Du", "statement": "Have you ever used the chat application QQ? Well, in a chat group of QQ,\r\nadministrators can muzzle a user for days.In Boboniu\u2019s chat group,\r\nthere\u2019s a person called Du Yi who likes to make fun of Boboniu every\r\nday.Du will chat in the group for n days. On the i-th day: If Du can\r\nspeak, he\u2019ll make fun of Boboniu with fun factor a_i. But after that, he\r\nmay be muzzled depending on Boboniu\u2019s mood. Otherwise, Du won\u2019t do\r\nanything. Boboniu\u2019s mood is a constant m. On the i-th day: If Du can\r\nspeak and a_i>m, then Boboniu will be angry and muzzle him for d days,\r\nwhich means that Du won\u2019t be able to speak on the i+1, i+2,\r\ncdots,\r\nmin(i+d,n)-th days. Otherwise, Boboniu won\u2019t do anything. The total fun\r\nfactor is the sum of the fun factors on the days when Du can speak.Du\r\nasked you to find the maximum total fun factor among all possible\r\npermutations of a.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<bool> vb; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nll n,d,m;\nvi a;\nvl cum;\n\nint main() {\n\tsetIO(); re(n,d,m); d ++;\n\ta.rsz(n); re(a); sort(rall(a));\n\tvi x, y;\n\ttrav(t,a) {\n\t\tif (t > m) x.pb(t);\n\t\telse y.pb(t);\n\t}\n\tcum.rsz(sz(y)+1);\n\tF0R(i,sz(y)) cum[i+1] = cum[i]+y[i];\n\tll sum = 0, ans = 0;\n\tif (!sz(x)) {\n\t\tps(cum[sz(y)]);\n\t\texit(0);\n\t}\n\tFOR(i,1,sz(x)+1) {\n\t\tsum += x[i-1];\n\t\tll lo = d*(i-1)+1, hi = d*i;\n\t\tckmin(hi,n);\n\t\ttie(lo,hi) = mp(n-hi,n-lo);\n\t\tif (lo > sz(y) || hi < 0) continue;\n\t\tckmax(ans,sum+cum[min((int)hi,sz(y))]);\n\t}\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"], "input": "", "output": "", "tags": ["dp", "greedy", "sortings", "two pointers"], "dificulty": "1800", "interactive": false}