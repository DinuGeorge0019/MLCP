{
    "link": "https://codeforces.com//contest/1190/problem/E",
    "problemId": "371227",
    "problem_idx": "E",
    "shortId": "1190E",
    "contest_number": "1190",
    "problem_submissions": {
        "F": [
            56941738,
            56942014,
            56928138,
            56942516,
            56950887,
            58195417,
            58195396
        ],
        "E": [
            56917008,
            56916854,
            56935244,
            57349641,
            56979679,
            56978421,
            56932359,
            56972779,
            56934145,
            56955262,
            56955204,
            56941608,
            56941586,
            56935542,
            56933188,
            57068903,
            57330846,
            57330794,
            56942010
        ],
        "D": [
            56905170,
            56903117,
            56915954,
            56905847,
            56909818,
            56908766,
            56917699,
            56902041,
            56905886,
            56904524,
            56906795,
            56906965,
            56900483,
            56909139,
            56909403,
            56908905,
            56906330,
            56905643,
            56915882,
            56909382
        ],
        "C": [
            56900650,
            56922677,
            56907961,
            56915160,
            56918774,
            56933389,
            56914144,
            56911238,
            56911841,
            56914833,
            56915809,
            56917468,
            56907600,
            56903345,
            56902197,
            56904463,
            56924310,
            56918439,
            56903054,
            56913026
        ],
        "B": [
            56894838,
            56897380,
            56899896,
            56900500,
            56902295,
            56898363,
            56894711,
            56934531,
            56896361,
            56900397,
            56898856,
            56894889,
            56895625,
            56895683,
            56897433,
            56894846,
            56898447,
            56897871,
            56896691,
            56899788
        ],
        "A": [
            56890891,
            56891248,
            56896475,
            56892165,
            56893900,
            56891144,
            56890604,
            56893098,
            56892007,
            56891978,
            56894387,
            56896707,
            56892771,
            56890233,
            56891624,
            56891412,
            56893655,
            56892212,
            56892634,
            56891452
        ]
    },
    "name": "E. Tokitsukaze and Explosion",
    "statement": "Tokitsukaze and her friends are trying to infiltrate a secret base built\r\nby Claris. However, Claris has been aware of that and set a bomb which\r\nis going to explode in a minute. Although they try to escape, they have\r\nno place to go after they find that the door has been locked.At this\r\nvery moment, CJB, Father of Tokitsukaze comes. With his magical power\r\ngiven by Ereshkigal, the goddess of the underworld, CJB is able to set m\r\nbarriers to protect them from the explosion. Formally, let’s build a\r\nCartesian coordinate system on the plane and assume the bomb is at O(0,\r\n0). There are n persons in Tokitsukaze’s crew, the i-th one of whom is\r\nat P_i(X_i, Y_i). Every barrier can be considered as a line with\r\ninfinity length and they can intersect each other. For every person from\r\nTokitsukaze’s crew, there must be at least one barrier separating the\r\nbomb and him, which means the line between the bomb and him intersects\r\nwith at least one barrier. In this definition, if there exists a person\r\nstanding at the position of the bomb, any line through O(0, 0) will\r\nsatisfy the requirement.Although CJB is very powerful, he still wants\r\nhis barriers to be as far from the bomb as possible, in order to\r\nconserve his energy. Please help him calculate the maximum distance\r\nbetween the bomb and the closest barrier while all of Tokitsukaze’s crew\r\nare safe.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst double PI = 4 * atan(1);\n\nconst int IT = 80;\nconst int N = 400200;\nint n;\npdd a[N];\npdd b[N];\npdd c[N];\nint g[N];\n\n/*\nstruct Event {\n\t\n};\n*/\n\nint calcAns(int m, int s) {\n\tint res = 0;\n\tint v = s;\n\twhile(v < s + m) {\n\t\tres++;\n\t\tv = g[v];\n\t}\n\treturn res;\n}\nint solve(double d) {\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble ang = acos(d / a[i].second);\n\t\tb[i] = mp(a[i].first - ang, a[i].first + ang);\n\t}\n//\tfor (int i = 0; i < n; i++)\n//\t\teprintf(\"(%.5lf %.5lf)\\n\", b[i].first, b[i].second);\n//\teprintf(\"--------\\n\");\n\tfor (int i = 0; i < n; i++) {\n\t\twhile(b[i].first < 0) {\n\t\t\tb[i].first += 2 * PI;\n\t\t\tb[i].second += 2 * PI;\n\t\t}\n\t\tb[n + i].first = b[i].first + 2 * PI;\n\t\tb[n + i].second = b[i].second + 2 * PI;\n\t}\n\tsort(b, b + 2 * n);\n\tdouble r = b[2 * n - 1].second;\n\tint m = 0;\n\tfor (int i = 2 * n - 2; i >= 0; i--) {\n\t\tif (b[i].second < r) {\n\t\t\tr = b[i].second;\n\t\t\tif (b[i].first < 2 * PI)\n\t\t\t\tc[m++] = b[i];\n\t\t}\n\t}\n\treverse(c, c + m);\n//\tfor (int i = 0; i < m; i++)\n//\t\teprintf(\"(%.5lf %.5lf)\\n\", c[i].first, c[i].second);\n//\teprintf(\"---------\\n\");\n\tfor (int i = 0; i < m; i++) {\n\t\tc[m + i].first = c[i].first + 2 * PI;\n\t\tc[m + i].second = c[i].second + 2 * PI;\n\t}\n\tint pos = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\twhile(c[pos].first <= c[i].second) pos++;\n\t\tg[i] = pos;\n\t}\n\tfor (int i = 0; i < 2 * m; i++)\n\t\tg[m + i] = g[i] + m;\n\tint T = 0;\n\tint v = 0;\n\tint L = 0, R = m;\n\twhile(v < m) {\n\t\tint u = g[v];\n\t\tif (u - v < R - L) {\n\t\t\tL = v;\n\t\t\tR = u;\n\t\t}\n\t\tv = u;\n\t\tT++;\n\t}\n\tfor (int i = L; i <= R; i++)\n\t\tT = min(T, calcAns(m, i));\n\treturn T;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\ta[i] = mp(atan2(y, x), sqrt(x * x + y * y));\n\t}\n\tsort(a, a + n);\n\t\n//\tsolve(0.5);\n//\treturn 0;\n\t\n\tdouble r = a[0].second;\n\tfor (int i = 0; i < n; i++)\n\t\tr = min(r, a[i].second);\n\tdouble l = 0;\n\tfor (int it = 0; it < IT; it++) {\n\t\tdouble x = (l + r) / 2;\n\t\tif (solve(x) <= m)\n\t\t\tl = x;\n\t\telse\n\t\t\tr = x;\n\t}\n\tprintf(\"%.13lf\\n\", l);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Tokitsukaze and Explosion.json",
    "editorial_link": "https://codeforces.com/blog/entry/68314",
    "editorial": "TutorialIt is obvious that we can binary search the answer because we\r\ncan pull any line closer to and the situation wonât change. Applying a\r\nbinary search, we focus on if it is possible to set barriers with the\r\nsame distance to and meet the requirement. By doing so, we can draw a\r\ncircle whose center is such that the closest point to on each barrier is\r\non the circumference. Then it becomes a classic problem for each barrier\r\nwe can get the angle range of its closest point on the circle, and we\r\nhave to choose at most points on the circle to ensure that there is at\r\nleast one point within each range.This kind of greedy trick is very\r\nsimple on a sequence. As to ranges on a sequence, you only have to sort\r\nall ranges in increasing order of left endpoint and take every necessary\r\nright endpoint. As to ranges on a circle, you can enumerate a position\r\nto break the circle into a sequence. But if you enumerate as the same\r\nway on the sequence, the time complexity will be which is not\r\nenough.Instead, we can double and extend these ranges into ranges and\r\nthen regard them as on a sequence. We can do some precalculation, such\r\nas if we want to choose a point to cover the -th sorted range and other\r\nranges in its right as many as possible, what is the next range that we\r\ncannot cover. Letâs denote that as , and then we can calculate the next\r\nrange after repeated steps from the -th range as , which can be obtained\r\nfrom . After preparation, we can enumerate the beginning position and\r\nuse binary lifting method, each time in complexity , to know that\r\nwhether we can use steps to cover all the ranges.Therefore, the total\r\ntime complexity can be , where is the precision requirement.\r\n",
    "hint": []
}