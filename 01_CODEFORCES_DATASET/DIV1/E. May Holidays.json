{
    "link": "https://codeforces.com//contest/966/problem/E",
    "problemId": "179479",
    "problem_idx": "E",
    "shortId": "966E",
    "contest_number": "966",
    "problem_submissions": {
        "E": [
            37728467,
            37721887,
            37727395,
            37722353,
            46428064,
            37735854,
            37726097,
            37728168,
            37731395,
            37731373
        ],
        "D": [
            37722933,
            37721182,
            37720577,
            37745366,
            37727547,
            37724656,
            37720856,
            37720615,
            37721601,
            37723190,
            37720741,
            37720916,
            37854456,
            37723453,
            37723867,
            37723823,
            37723640,
            37725199
        ],
        "C": [
            37716531,
            37723619,
            37716233,
            37716062,
            37721394,
            37719905,
            37724974,
            37710146,
            37715347,
            37715961,
            37715642,
            37715427,
            37717480,
            37715886,
            37716616,
            37716460,
            37712823,
            37718703,
            37718856
        ],
        "B": [
            37712342,
            37710216,
            37712076,
            37714505,
            37717238,
            37717093,
            37713464,
            37712937,
            37711956,
            37712143,
            37712153,
            37712830,
            37714037,
            37717527,
            37712504,
            37714456,
            37719214,
            37710052,
            37715647
        ],
        "A": [
            37709493,
            37711125,
            37709073,
            37709222,
            37711428,
            37711424,
            37710230,
            37723341,
            37715473,
            37709490,
            37710976,
            37717218,
            37726403,
            37716138,
            37716852,
            37710495,
            37715732,
            37712927,
            37711795
        ],
        "F": [
            37856043
        ]
    },
    "name": "E. May Holidays",
    "statement": "It’s May in Flatland, and there are m days in this month. Despite the\r\nfact that May Holidays are canceled long time ago, employees of some\r\nsoftware company still have a habit of taking short or long vacations in\r\nMay.Of course, not all managers of the company like this. There are n\r\nemployees in the company that form a tree-like structure of\r\nsubordination: each employee has a unique integer id i between 1 and n,\r\nand each employee with id i (except the head manager whose id is 1) has\r\nexactly one direct manager with id p_i. The structure of subordination\r\nis not cyclic, i.e. if we start moving from any employee to his direct\r\nmanager, then we will eventually reach the head manager. We define that\r\nan employee u is a subordinate of an employee v, if v is a direct\r\nmanager of u, or the direct manager of u is a subordinate of v. Let s_i\r\nbe the number of subordinates the i-th employee has (for example, s_1 =\r\nn - 1, because all employees except himself are subordinates of the head\r\nmanager).Each employee i has a bearing limit of t_i, which is an integer\r\nbetween 0 and s_i. It denotes the maximum number of the subordinates of\r\nthe i-th employee being on vacation at the same moment that he can bear.\r\nIf at some moment strictly more than t_i subordinates of the i-th\r\nemployee are on vacation, and the i-th employee himself is not on a\r\nvacation, he becomes .In each of the m days of May exactly one event of\r\nthe following two types happens: either one employee leaves on a\r\nvacation at the beginning of the day, or one employee returns from a\r\nvacation in the beginning of the day. You know the sequence of events in\r\nthe following m days. Your task is to compute for each of the m days the\r\nnumber of displeased employees on that day.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\nconst int M=400,inf=1000000000;\nusing namespace std;\nint n,m,w[100010],ww[100010],f[255][200010],g[255];\nvector<int> a[100010];\nint x[100010],y[100010],p,v[100010],fa[100010],ff[100010],q;\ninline void dp(int i,int j)\n{\n    v[i]=1;\n    for(auto k:a[i])\n      if(k!=j)\n        {\n         fa[k]=i;\n         dp(k,i);\n         v[i]+=v[k];\n        }\n}\ninline void lp(int i,int j,int k)\n{\n    ff[i]=k;\n    x[++p]=i;\n    y[i]=p;\n    int u=0;\n    for(auto l:a[i])\n      if(l!=j && v[l]>v[u])\n        u=l;\n    if(u)\n      lp(u,i,k);\n    for(auto l:a[i])\n      if(l!=j && l!=u)\n        lp(l,i,l);\n}\ninline void add1(int i)\n{\n    g[i]--;\n    q-=f[i][g[i]];\n}\ninline void del1(int i)\n{\n    q+=f[i][g[i]];\n    g[i]++;\n}\ninline void add2(int i,int k)\n{\n    if(w[k]>1e8)\n      {\n       w[k]++;\n       return;\n      }\n    f[i][w[k]]--;\n    w[k]++;\n    f[i][w[k]]++;\n    if(w[k]==g[i])\n      q--;\n}\ninline void del2(int i,int k)\n{\n    if(w[k]>1e8)\n      {\n       w[k]--;\n       return;\n      }\n    f[i][w[k]]--;\n    w[k]--;\n    f[i][w[k]]++;\n    if(w[k]==g[i]-1)\n      q++;\n}\ninline void orz1(int k)\n{\n    int i=k/M;\n    if(w[k]<g[i])\n      q--;\n    f[i][w[k]]--;\n    w[k]+=inf;\n}\ninline void orz2(int k)\n{\n    int i=k/M;\n    w[k]-=inf;\n    f[i][w[k]]++;\n    if(w[k]<g[i])\n      q++;\n}\ninline void add(int l,int r)\n{\n    int i=l/M,j=r/M,k;\n    if(i==j)\n      {\n       for(k=l;k<=r;k++)\n         add2(i,k);\n       return;\n      }\n    for(k=i+1;k<j;k++)\n      add1(k);\n    for(k=l;k<(i+1)*M && k<=n;k++)\n      add2(i,k);\n    for(k=j*M;k<=r && k<=n;k++)\n      add2(j,k);\n}\ninline void del(int l,int r)\n{\n    int i=l/M,j=r/M,k;\n    if(i==j)\n      {\n       for(k=l;k<=r;k++)\n         del2(i,k);\n       return;\n      }\n    for(k=i+1;k<j;k++)\n      del1(k);\n    for(k=l;k<(i+1)*M && k<=n;k++)\n      del2(i,k);\n    for(k=j*M;k<=r && k<=n;k++)\n      del2(j,k);\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=2;i<=n;i++)\n\t  {\n       scanf(\"%d\",&j);\n       a[j].pb(i);\n      }\n    for(i=1;i<=n;i++)\n      {\n       scanf(\"%d\",&ww[i]);\n      }\n    dp(1,0);\n    lp(1,0,1);\n    for(i=1;i<=n;i++)\n      {\n       w[i]=ww[x[i]];\n       w[i]+=n;\n       f[i/M][w[i]]++;\n      }\n    for(i=0;i<=n/M;i++)\n      g[i]=n;\n    //for(i=1;i<=n;i++)\n      //cout<<i<<\" \"<<fa[i]<<\" \"<<ff[i]<<\"\\n\";\n    while(m--)\n      {\n       scanf(\"%d\",&i);\n       if(i>0)\n         k=0;\n       else\n         i=-i,k=1;\n       if(k)\n         orz2(y[i]);\n       else\n         orz1(y[i]);\n       for(;i>0;i=fa[j])\n         {\n          j=ff[i];\n          //cout<<i<<\" \"<<j<<\"\\n\";\n          if(k)\n            add(y[j],y[i]);\n          else\n            del(y[j],y[i]);\n         }\n       printf(\"%d \",q);\n      }\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. May Holidays.json",
    "editorial_link": "https://codeforces.com//blog/entry/59173",
    "editorial": "In terms of trees we have a rooted tree whose vertices may be activated and deactivated, and each vertex has a limit for the number of deactivated vertices among its descendants. We are required to switch the state of some vertex, and after each query we report the number of activated vertices unsatisfied vertices. Let the balance of a vertex be equal to the difference between its limit of deactivated descendants and the actual number of deactivated vertices among its descendants. In such terms we are interested in the number of activated vertices with the negative balance.\n\nLet's utilize the idea of sqrt-optimization. Consider a block of k\n consecutive queries, let us answer all of them. Suppose this query affects the state of vertices v1,v2,,vl\n (l?k\n), let us call such vertices interesting. Then, during the current query block, the balance will change only for the vertices that have at least one interesting vertex in its subtree.\n\nLet's perform a classical trick of building the condensed tree containing the given interesting vertices. Namely, sort all the interesting vertices in order of their visit when doing DFS, and add all vertices of form lca(vi,vi+1)\n for all 1?i<l\n to the set of interesting vertices. After such procedure all vertices whose balance may change may be splitted into O(k)\n vertical paths each of which ends in an interesting vertex.\n\nNow we are going to consider separately the interesting vertices and the interior vertices of all paths between interesting vertices. In each of the paths the balance of all vertices is changed simultaneously, thus we may sort all the vertices in each path by balance and then group all vertices having the same balance together. Introduce a pointer that initially stands at the first satisfied group (with non-negative balance). When the balance of all groups is changed by 1, instead of actually changing the value of balance we may just shift the pointer by at most one position to the left or to the right (artificially changing the origin) and accounting at most one group the pointer has passed in the answer.\n\nOn each query we have to perform such an operation with every path and interesting vertex that is located above the queried vertex. Since each vertex and each path is processed in O(1)\n, processing a single query takes O(k)\n time and processing all queries inside a block takes O(k2)\n time. It is possible to build all paths and groups in running time of a single DFS plus sort time (std::sort or counting sort) for grouping vertices of equal balance. This part of solution takes O(n)\n per each query block or O(nlogn)\n depending on used sorting algorithm.\n\nIf we use count sort, the resulting complexity will be O(mk(k2+n))\n, finally we can take k=?(n???)\n and get O(mn???)\n running time.",
    "hint": []
}