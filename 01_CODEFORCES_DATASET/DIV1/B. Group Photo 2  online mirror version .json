{
    "link": "https://codeforces.com//contest/529/problem/B",
    "problemId": "25011",
    "problem_idx": "B",
    "shortId": "529B",
    "contest_number": "529",
    "problem_submissions": {
        "A": [
            10386870,
            10387083,
            10387317,
            10387235,
            10387134,
            10386419,
            10387369,
            10386078,
            10389580,
            10388216,
            10387712,
            10386357,
            10387632,
            10386965,
            10387734,
            10385828
        ],
        "C": [
            10386311,
            10385455,
            10386427,
            10385364,
            10406538,
            10385834,
            10386051,
            10386918,
            10386327,
            10386510,
            10385417,
            10385724,
            10386116,
            10409781,
            10386107,
            10386201,
            10386650,
            10404350,
            10386786,
            10387225
        ],
        "D": [
            10385805,
            10386369,
            10385736,
            10386160,
            10387079,
            10385785,
            10386933,
            10385679,
            10386619,
            10386454,
            10386390,
            10387127,
            10386675,
            10386195,
            10385799,
            10388002
        ],
        "E": [
            10385000,
            10384871,
            10384905,
            10385848,
            10385056,
            10385201,
            10385198,
            10387352,
            10385145,
            10385184,
            10385731,
            10384843,
            10385458,
            10387221,
            10385405,
            10384991,
            10385094
        ],
        "B": [
            10384855,
            10385831,
            10385265,
            10386319,
            10385276,
            10385001,
            10385225,
            10386328,
            10385038,
            10384881,
            10385688,
            10386077,
            10385299,
            10385149,
            10385037,
            10385267,
            10384933,
            10388225
        ]
    },
    "name": "B. Group Photo 2  online mirror version ",
    "statement": "Many years have passed, and friends met at a party again. Technologies\r\nhave leaped forward since the last meeting, cameras with timer appeared\r\nand now it is not obligatory for one of the friends to stand with a\r\ncamera, and, thus, being absent on the photo.Simply speaking, the\r\nprocess of photographing can be described as follows. Each friend\r\noccupies a rectangle of pixels on the photo: the -th of them in a\r\nstanding state occupies a pixels wide and a pixels high rectangle. But\r\nalso, each person can lie down for the photo, and then he will occupy a\r\npixels wide and a pixels high rectangle.The total photo will have size ,\r\nwhere is the total width of all the people rectangles, and is the\r\nmaximum of the heights. The friends want to determine what minimum area\r\nthe group photo can they obtain if no more than of them can lie on the\r\nground (it would be strange if more than gentlemen lie on the ground\r\ntogether, isn’t it?..)Help them to achieve this goal.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAXN = 1010;\n\nint w[MAXN], h[MAXN];\n\nint main(void) {\n  int n;\n  scanf(\"%d\", &n);\n  REP(i, n) scanf(\"%d %d\", w+i, h+i);\n  \n  int sumw = accumulate(w, w + n, 0);\n  int maxh = *max_element(h, h + n);\n  int ans = sumw * maxh;\n  \n  for (int H = 1; H <= 1000; ++H) {\n    int cnt = 0;\n    static vector<int> v; v.clear();\n\n    int sumw = 0;\n    REP(i, n)\n      if (h[i] > H) {\n        if (w[i] > H) { cnt = n; break; }\n        cnt++;\n        sumw += h[i];\n      } else {\n        sumw += w[i];\n        if (w[i] <= H) v.push_back(w[i] - h[i]);\n      }\n    \n    if (cnt*2 > n) continue;\n\n    sort(v.begin(), v.end());\n    while ((cnt+1)*2 <= n && (int)v.size() && v.back() > 0) {\n      sumw -= v.back();\n      v.pop_back();\n      cnt++;\n    }\n\n    ans = min(ans, sumw * H);\n  }\n  \n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Group Photo 2  online mirror version .json",
    "editorial_link": "https://codeforces.com//blog/entry/17065",
    "editorial": "In an online mirror version the problem was slightly harder. Letâs call\r\npeople with\r\ntextit{high}, and remaining people\r\ntextit{wide}. Letâs fix photo height . Letâs consider several following\r\ncases: Now we have several people that have to lie on the ground (from\r\nsecond case) and if there are too many of them (more than ) then such\r\nvalue of is impossible. After we put down people from second case there\r\ncan still be some vacant ground positions, we distribute them to the\r\npeople from fourth case with highest values of . Then we calculate the\r\ntotal area of the photo and relax the answer. Intended solution has the\r\ncomplexity or . For each possible value that we can get write a pair\r\nwhere is number of bills to achieve this value. Sort this array in\r\nascending order of and leave only the best possible number of bills for\r\neach value of . Then to answer a query we should iterate over the first\r\nsummand in resulting sum and look for the remainder using binary search.\r\nThe alternate way is the method of two pointers for looking in an array\r\nfor a pair of numbers with a given sum that works in amortized time.\r\nCheck that we used no more than bills totally and relax the answer if\r\nneeded. Letâs follow greedily in following way. Iterate over all\r\nrequests in a chronological order. Letâs try to associate each query to\r\nthe new person. Of course we canât always do that: when there are\r\nalready active users on a site, we should associate this request with\r\nsome existing person. Now we need to choose, who it will be. Letâs show\r\nthat the best way is to associate a request with the most recently\r\nactive person. Indeed, such \"critical\" state can be represented as a\r\nvector consisting of numbers that are times since the last request for\r\neach of the active people in descending order. If we are currently in\r\nthe state , then we can move to the one of the new states , , ,\r\ndepending on who we will associate the new request with. We can see that\r\nthe first vector is component-wise larger then other ones, so it is\r\nbetter than other states (since the largest number in some component of\r\nvector means that this person will probably disappear earlier giving us\r\nmore freedom in further operations). So, all we have to do is to\r\nsimulate the process keeping all active people in some data structure\r\nwith times of their last activity. As a such structure one can use\r\nanything implementing the priority queue interface (priority_queue, set,\r\nsegment tree or anything else). Complexity of such solution is . Letâs\r\nunderstand what does it mean that some cell isnât attacked by any rook.\r\nIt means that there exists row and column of the rectangle without rooks\r\non them. Itâs hard to check this condition, so it is a good idea to\r\ncheck the opposite for it. We just shown that the rectangle is good if\r\non of the two conditions holds: there should be a rook in each row of it\r\nor there should be a rook in each column. We can check those conditions\r\nseparately. How can we check that for a set of rectangles there is a\r\npoint in each row? This can be done by sweeping vertical line from left\r\nto right. Suppose we are standing in the right side of a rectangle\r\nlocated in rows from to with the left side in a column . Then if you\r\ndenote as the position of the last rook appeared in a row number , the\r\ncriteria for a rectangle looks like . That means that we can keep the\r\nvalues in a segment tree and answer for all rectangles in\r\nlogarithmic-time. Similarly for columns. This solution answers all\r\nqueries in off-line in time . The main idea is that the bracket sequence\r\ncan be seen as a sequence of prefix balances, i. e sequence such that .\r\nCalculate the number of opening brackets and closing brackets in\r\noriginal string. It is true that if then the string can be fixed by\r\nadding closing brackets at the end and shifting the resulting string to\r\nthe point of balance minimum, and if , then the string can be similarly\r\nfixed by adding opening brackets to the beginning and then properly\r\nshifting the whole string. Itâs obvious that it is impossible to fix the\r\nstring by using the less number of brackets. So we know the value of the\r\nanswer, now we need to figure out how it looks like. Suppose that we\r\nfirst circularly shift and only then add brackets. Suppose that we add\r\nclosing brackets. Consider the following two facts: Each of those\r\nstatements is easy to prove. They give us the fact that in the optimal\r\nanswer we put closing brackets at the end of the string (after rotating\r\nthe initial string). So we have to consider the set of the original\r\nstring circular shifts such that they transform to the correct bracket\r\nsequence by adding closing brackets to the end and choose the\r\nlexicographically least among them. Comparing circular shifts of the\r\nstring is the problem that can be solved by a suffix array. The other\r\nway is to find lexicographical minimum among them by using hashing and\r\nbinary search to compare two circular shifts. The case when is similar\r\nexcept that opening brackets should be put into the beginning of the\r\nstring. So, overall complexity is .\r\n",
    "hint": []
}