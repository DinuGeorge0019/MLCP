{
    "link": "https://codeforces.com//contest/1416/problem/A",
    "problemId": "740365",
    "problem_idx": "A",
    "shortId": "1416A",
    "contest_number": "1416",
    "problem_submissions": {
        "F": [
            94006266,
            94013395,
            94017337,
            94007333,
            94012350,
            94016693,
            94144598,
            94144345,
            94143862,
            94143815,
            94143507,
            94143372,
            94134107,
            94022751,
            94013371,
            94123054,
            93993751,
            93995209,
            94206946,
            94047832
        ],
        "D": [
            93996097,
            94002143,
            93994280,
            93996848,
            94000279,
            93995262,
            93992025,
            94030965,
            93988840,
            94001509,
            93996287,
            94006105,
            94007577,
            94017080,
            93995866,
            93997659,
            93998139,
            93997214,
            93995418,
            94000331,
            93999706
        ],
        "E": [
            93989598,
            93993245,
            94005344,
            94008684,
            94029993,
            94019586,
            94015916,
            94018911,
            94274661,
            94428216,
            94428140,
            94046134
        ],
        "B": [
            93977851,
            93981480,
            93977205,
            93989726,
            93978642,
            93985288,
            93976209,
            93981357,
            93985099,
            93999768,
            93994963,
            94270201,
            93976947,
            93987758,
            93986950,
            93981437,
            93979361,
            93987047,
            93979513
        ],
        "C": [
            93974213,
            93978374,
            93983878,
            93979532,
            94282160,
            93989242,
            93980978,
            93980593,
            93976201,
            93990186,
            93986370,
            93974300,
            93996660,
            94001007,
            93983516,
            93980305,
            93980649,
            93977960,
            93984553,
            93980471,
            93985644
        ],
        "A": [
            93970422,
            93970885,
            93970919,
            93970033,
            93971425,
            93971578,
            93970140,
            93970220,
            93970538,
            93970561,
            93981050,
            94269181,
            94002877,
            93970437,
            93972131,
            93974465,
            93974988,
            93972065,
            93971571,
            93970260
        ]
    },
    "name": "A. k-Amazing Numbers",
    "statement": "You are given an array a consisting of n integers numbered from 1 to\r\nn.Let\u2019s define the k-amazing number of the array as the minimum number\r\nthat occurs in all of the subsegments of the array having length k\r\n(recall that a subsegment of a of length k is a contiguous part of a\r\ncontaining exactly k elements). If there is no integer occuring in all\r\nsubsegments of length k for some value of k, then the k-amazing number\r\nis -1.For each k from 1 to n calculate the k-amazing number of the array\r\na.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 27.09.2020 18:03:25       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      --a[i];\n    }\n    vector<vector<int>> pos(n);\n    for (int i = 0; i < n; i++) {\n      pos[a[i]].push_back(i);\n    }\n    const int inf = (int) 1e9;\n    vector<int> ans(n + 1, inf);\n    for (int i = 0; i < n; i++) {\n      if (pos[i].empty()) {\n        continue;\n      }\n      int mx = pos[i][0];\n      for (int j = 0; j < (int) pos[i].size() - 1; j++) {\n        mx = max(mx, pos[i][j + 1] - pos[i][j] - 1);\n      }\n      mx = max(mx, n - 1 - pos[i].back());\n      ans[mx + 1] = min(ans[mx + 1], i + 1);\n    }\n    for (int i = 1; i < n; i++) {\n      ans[i + 1] = min(ans[i + 1], ans[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n      if (i > 1) {\n        cout << \" \";\n      }\n      cout << (ans[i] == inf ? -1 : ans[i]);\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. k-Amazing Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/83036",
    "editorial": "Let\u00e2\u0080\u0099s fix some arbitrary number and calculate the minimum value of such\r\nthat occurs in all segments of length . Let be the indices of entries of\r\nin the array. Then, for each it is clear that should be at least the\r\nvalue of . Also, and . It is enough to just take the maximum of those\r\nvalues. Let\u00e2\u0080\u0099s call this derived value of as .Now, we can just go in\r\nincreasing order of from to and try update the suffix with . This can be\r\ndone straightforwardly, just iterating over the range . If we arrive at\r\na cell for which the value of is already calculated, we immediately\r\nterminate our loop and continue our algorithm from . Time complexity:\r\n.Space complexity: .\r\n"
}