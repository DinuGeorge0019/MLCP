{
    "link": "https://codeforces.com//contest/949/problem/D",
    "problemId": "163631",
    "problem_idx": "D",
    "shortId": "949D",
    "contest_number": "949",
    "problem_submissions": {
        "E": [
            36105597,
            36104729,
            36107882,
            36106052,
            36109939,
            36109078,
            36111836,
            36112039,
            36111175,
            36106962,
            36109964,
            36110554,
            36111413,
            36109601,
            36111115,
            36110022,
            36110942,
            94270940,
            36111425,
            36106250,
            36109832
        ],
        "D": [
            36101360,
            36106649,
            36105542,
            36109215,
            36106017,
            36106726,
            36102230,
            36101449,
            36103104,
            36110228,
            36103260,
            36105066,
            36107080,
            36106355,
            36107442,
            36106210,
            36107773,
            36109010,
            36109232,
            36112599
        ],
        "C": [
            36097297,
            36099409,
            36097097,
            36099338,
            36100026,
            36100955,
            36098934,
            36097758,
            36099260,
            36100420,
            36101363,
            36101312,
            36100998,
            36103414,
            36103747,
            36102556,
            36101236,
            36102526,
            50661562,
            36100630,
            36101932
        ],
        "B": [
            36095300,
            36092787,
            36094621,
            36097341,
            36096959,
            36097302,
            36093518,
            36094892,
            36097014,
            36095796,
            36096835,
            36098669,
            36097021,
            36100952,
            36098276,
            36097313,
            36097889,
            36098939,
            36095872,
            36098787
        ],
        "A": [
            36093067,
            36095425,
            36093246,
            36094348,
            36092357,
            36093156,
            36095248,
            36092415,
            36092267,
            36097893,
            36093322,
            36092795,
            36093362,
            36093672,
            36096228,
            36095964,
            36093387,
            36095876,
            36127878,
            36094011
        ]
    },
    "name": "D. Curfew",
    "statement": "Instructors of Some Informatics School make students go to bed.The house\r\ncontains rooms, in each room exactly students were supposed to sleep.\r\nHowever, at the time of curfew it happened that many students are not\r\nlocated in their assigned rooms. The rooms are arranged in a row and\r\nnumbered from to . Initially, in -th room there are students. All\r\nstudents are currently somewhere in the house, therefore . Also\r\ninstructors live in this house.The process of curfew enforcement is the\r\nfollowing. One instructor starts near room and moves toward room , while\r\nthe second instructor starts near room and moves toward room . After\r\nprocessing current room, each instructor moves on to the next one. Both\r\ninstructors enter rooms and move simultaneously, if is odd, then only\r\nthe first instructor processes the middle room. When all rooms are\r\nprocessed, the process ends.When an instructor processes a room, she\r\ncounts the number of students in the room, then turns off the light, and\r\nlocks the room. Also, if the number of students inside the processed\r\nroom is not equal to , the instructor writes down the number of this\r\nroom into her notebook (and turns off the light, and locks the room).\r\nInstructors are in a hurry (to prepare the study plan for the next day),\r\nso they don’t care about who is in the room, but only about the number\r\nof students.While instructors are inside the rooms, students can run\r\nbetween rooms that are not locked and not being processed. A student can\r\nrun by at most rooms, that is she can move to a room with number that\r\ndiffers my at most . Also, after (or instead of) running each student\r\ncan hide under a bed in a room she is in. In this case the instructor\r\nwill not count her during the processing. In each room any number of\r\nstudents can hide simultaneously.Formally, here is what’s happening: A\r\ncurfew is announced, at this point in room there are students. Each\r\nstudent can run to another room but not further than rooms away from her\r\ninitial room, or stay in place. After that each student can optionally\r\nhide under a bed. Instructors enter room and room , they count students\r\nthere and lock the room (after it no one can enter or leave this room).\r\nEach student from rooms with numbers from to can run to another room but\r\nnot further than rooms away from her room, or stay in place. Each\r\nstudent can optionally hide under a bed. Instructors move from room to\r\nroom and from room to room . This process continues until all rooms are\r\nprocessed. Let denote the number of rooms in which the first instructor\r\ncounted the number of non-hidden students different from , and be the\r\nsame number for the second instructor. Students know that the principal\r\nwill only listen to one complaint, therefore they want to minimize the\r\nmaximum of numbers . Help them find this value if they use the optimal\r\nstrategy.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define Se second\n#define Fi first\n\nll in[100050];\nll uin[100050];\nvector <pll> Vl;\nint main() {\n\tint N, D, B, i, j;\n\tscanf(\"%d %d %d\", &N, &D, &B);\n\tfor (i = 1; i <= N; i++) scanf(\"%lld\", &in[i]);\n\n\tint st = 0, en = N / 2 - 1 , mi, rv = N / 2;\n\twhile (st <= en) {\n\t\tmi = (st + en) / 2;\n\n\t\tint s1 = mi + 1, e1 = N / 2 - 1;\n\t\tint s2 = (N + 4) / 2, e2 = N - mi;\n\t\tif (N % 2 == 0) {\n\t\t\te1 = N / 2 - 1;\n\t\t\ts2 = N / 2 + 2;\n\t\t}\n\t\telse {\n\t\t\te1 = N / 2;\n\t\t\ts2 = N / 2 + 2;\n\t\t}\n\n\t\tfor (i = 1; i <= N; i++) uin[i] = in[i];\n\n\t\tint pst = 1, pen = N;\n\t\tfor (i = s1; i <= e1; i++) {\n\t\t\tll tl = (ll)i*D;\n\n\t\t\tll v = B;\n\t\t\tint sp = INF, ep = -INF;\n\t\t\twhile (v) {\n\t\t\t\tif (uin[pst] == 0) {\n\t\t\t\t\tpst++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsp = min(sp, pst);\n\t\t\t\tep = max(ep, pst);\n\t\t\t\tif (uin[pst] > v) {\n\t\t\t\t\tuin[pst] -= v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv -= uin[pst];\n\t\t\t\t\tuin[pst] = 0;\n\t\t\t\t\tpst++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (abs(sp - i) > tl) break;\n\t\t\tif (abs(ep - i) > tl) break;\n\t\t}\n\t\tif (i <= e1) {\n\t\t\tst = mi + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = e2; i >= s2; i--) {\n\t\t\tll tl = (ll)(N+1-i)*D;\n\n\t\t\tll v = B;\n\t\t\tint sp = INF, ep = -INF;\n\t\t\twhile (v) {\n\t\t\t\tif (uin[pen] == 0) {\n\t\t\t\t\tpen--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsp = min(sp, pen);\n\t\t\t\tep = max(ep, pen);\n\t\t\t\tif (uin[pen] > v) {\n\t\t\t\t\tuin[pen] -= v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv -= uin[pen];\n\t\t\t\t\tuin[pen] = 0;\n\t\t\t\t\tpen--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (abs(sp - i) > tl) break;\n\t\t\tif (abs(ep - i) > tl) break;\n\t\t}\n\t\tif (i >= s2) {\n\t\t\tst = mi + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint p1 = N / 2, p2 = p1 + 1;\n\t\tif (N % 2 == 1) p1 = p2;\n\t\tll cnt[3] = { 0,0,0 };\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tll tl = (ll)((N + 1) / 2) * D;\n\t\t\tll st = i - tl, en = i + tl;\n\t\t\t\n\t\t\tbool c1 = false, c2 = false;\n\t\t\tif (st <= p1 && p1 <= en) c1 = true;\n\t\t\tif (st <= p2 && p2 <= en) c2 = true;\n\n\t\t\tif (c1 || c2) cnt[2] += uin[i];\n\t\t\tif (c1) cnt[0] += uin[i];\n\t\t\tif (c2) cnt[1] += uin[i];\n\t\t}\n\n\t\tbool chk = false;\n\t\tif (N % 2 == 1) chk = (cnt[0] >= B);\n\t\telse chk = (cnt[0] >= B && cnt[1] >= B && cnt[2] >= 2 * B);\n\t\tif (chk) {\n\t\t\trv = mi;\n\t\t\ten = mi - 1;\n\t\t}\n\t\telse st = mi + 1;\n\t}\n\treturn !printf(\"%d\\n\", rv);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Curfew.json",
    "editorial_link": "https://codeforces.com//blog/entry/58291",
    "editorial": "Letâs solve the problem in case when there is only one instructor (which\r\nmoves from left to right and the only goal is to minimize number of bad\r\nrooms)I claim, that the following greedy works: Move through rooms from\r\nleft to right If there are too many students inside room, send the\r\nexcess students to the next room If there are not enough students, but\r\nit is possible to fulfill this room from rooms on the right (the sum is\r\nat least ), then do it. If itâs not possible, then send all students to\r\nthe following room. If it is the last room, say that those students are\r\nhiding in it. This greedy can be implemented in time: calculate the\r\nprefix sums on the , this way you can check if it is possible to move\r\nstudents from following rooms here fast.To handle the removal students\r\nfrom following rooms you can maintain the current \"debt\" of students.\r\nWhen you first consider room you can repay the debt as much as you can\r\nand then check one of the cases above. Since the both left and right\r\nborders of segments are moving monotonously the debt will be \"inherited\"\r\ncorrectly.Notice, that you can only consider \"paths of different\r\nstudents never cross\", that means if first student was initially in room\r\nand moved to , while the second student was in and moved to , then if\r\nthan . Because otherwise you can swap students and nothing will change.\r\n(you can possibly skip it).Suppose there is a better answer, which\r\ncompletes the rooms , , , while the greedy solutions completes rooms , ,\r\n, .We will assume that in optimal solution paths of students donât\r\nintersect, that all \"excessive\" students are hiding in last room and\r\nthat all rooms in optimal answer are either full () or empty ().\r\nOtherwise itâs possible to change the \"correct answer in such way, that\r\nnumber of good rooms will not decrease.Letâs is smallest index when .\r\nThen , because greedy solution would always fulfill the room if it would\r\nbe possible (actually, greedy solution builts the lexmin solution).But\r\nif we can \"patch\" the supposed optimal solution and move all students\r\nwhich were sent to room to (we know it is possible by the greedy\r\nsolutionâs answer).This way we can increase the common prefix with any\r\npossible \"best\" answer hence contradiction.Back to the problem with .\r\nRecall, that \"paths of different students donât cross\", hence there\r\nexists a \"border\", the number from to , where the first students are\r\ngoing to the first instructor and all others to second.One could have\r\nbruteforced that border and solved the both halfs of the array by the\r\nmethod above, but then the complexity will be which is too much. We need\r\nto search for the border more efficiently.Let will be the answer for\r\nfirst instructor, when he is given first students and is the answer for\r\nsecond instructor when he is given all students except first ones.It is\r\neasy to see, that in decreasing, while is increasing (both times it is\r\nnot strict monotonicity). Indeed, the more students are given to\r\ninstructor, than more opportunities he has (all excessive students can\r\nalways hide, so it is not a problem).We are searching for where is\r\nsmallest possible.Letâs introduce function increasing (but still not\r\nstrict).Letâs call the smallest index, such that . One can see, that a\r\nis the final answer. Indeed, if one will try greater âs than , than the\r\nwill be dominating in max, and hence is more optimal. Otherwise, if ,\r\nthen is better. Solve this problem in time. Students became fat and\r\ncanât hide under the bed! Can you solve it now?\r\n",
    "hint": []
}