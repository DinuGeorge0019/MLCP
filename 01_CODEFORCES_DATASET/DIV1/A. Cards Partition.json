{
    "link": "https://codeforces.com//contest/2018/problem/A",
    "problemId": "2905183",
    "problem_idx": "A",
    "shortId": "2018A",
    "contest_number": "2018",
    "problem_submissions": {
        "F1": [
            283240998,
            283223838,
            283219415,
            283236306,
            283222916,
            283217600,
            283233290,
            283231886,
            283231256,
            283232151,
            283229995,
            283237003,
            283235478,
            283237574,
            283236444,
            283230142,
            283243735,
            283243123,
            283242008,
            283243508
        ],
        "F2": [
            283240981,
            283223708,
            283219380,
            283241370,
            283223162,
            283225122,
            283233500,
            283231817,
            283231569,
            283232589,
            283230224,
            283236870,
            283235839,
            283237529,
            283238353,
            283243847,
            283243386,
            283242191,
            283243811
        ],
        "F3": [
            283240882,
            283223675,
            283219246,
            283271588,
            283270237,
            283224933,
            283229369,
            283236884,
            283231408,
            283234186,
            283238623,
            283246555,
            283236714,
            283242719,
            283237265,
            283240426,
            283246144,
            283243432,
            283242213,
            283244419
        ],
        "E2": [
            283228724,
            283271415,
            283952156,
            285367980,
            285366320,
            284023567,
            283309295
        ],
        "E1": [
            283228436,
            283232974,
            283271394,
            283269080,
            283266646,
            283248084,
            283226474,
            285366140,
            284023512,
            283309260,
            283237845
        ],
        "D": [
            283195973,
            283206733,
            283203886,
            283202562,
            283199647,
            283202135,
            283203009,
            283209326,
            283212471,
            283208248,
            283213153,
            283210604,
            283213401,
            283215308,
            283215785,
            283193803,
            283212467,
            283216433,
            283217858,
            283213030
        ],
        "C": [
            283191019,
            283190311,
            283188296,
            283196136,
            283191568,
            283193617,
            283197810,
            283200878,
            283205239,
            283197789,
            283193479,
            283202635,
            283205964,
            283204336,
            283202253,
            283186865,
            283201070,
            283203016,
            283201349,
            283204359
        ],
        "B": [
            283187765,
            283200401,
            283192789,
            283188636,
            283190321,
            283192212,
            283195063,
            283200019,
            283195292,
            283189706,
            283199364,
            283199549,
            283199094,
            283197971,
            283197559,
            283195753,
            283198921,
            283194967,
            283197864
        ],
        "A": [
            283182907,
            283184407,
            283187228,
            283181621,
            283185198,
            283186414,
            283185582,
            283191793,
            283185688,
            283183522,
            283193549,
            283187676,
            283189523,
            283193094,
            283182769,
            283189185,
            283185401,
            283198807,
            283189030
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "Note that there are types of cards, so the subsets have size at\nmost , and the answer is at most .If , you can make subsets of size if\nand only if the following conditions are true: the number of cards () is\na multiple of ; the maximum number of cards of some type () is . Proof:\nis the number of decks times . The number of decks is . Each deck can\ncontain at most card of each type, so there are at most cards of each\ntype in total. If the two conditions above hold, you can make a deck\ncontaining the types of cards with maximum frequency. You can show with\nsome calculations that the conditions still hold after removing these\ncards. So you can prove by induction that the two conditions are\nsufficient to make decks of size . The same idea is used in problems\nlike 1954D - Colored Balls and abc227_d - Project Planning.For a generic\n, the answer is if you can make the number of cards of type equal.\nOtherwise, for any choice of number of cards to buy, you can buy them\nwithout changing . It means that you need cards in total: if you have\nless than cards, you have to check if you can reach cards by buying at\nmost new cards; if you already have or more cards at the beginning, you\nhave to check if you can make a multiple of . Complexity:\n",
    "name": "A. Cards Partition",
    "statement": "You have some cards. An integer between 1 and n is written on each card:\r\nspecifically, for each i from 1 to n, you have a_i cards which have the\r\nnumber i written on them.There is also a shop which contains unlimited\r\ncards of each type. You have k coins, so you can buy k new cards in\r\ntotal, and the cards you buy can contain any integer , inclusive.After\r\nbuying the new cards, you must partition your cards into decks,\r\naccording to the following rules: all the decks must have the same size;\r\nthere are no pairs of cards with the same value in the same deck. Find\r\nthe maximum possible size of a deck after buying cards and partitioning\r\nthem optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;\u00a0void solve() {    int n;    i64 k;    std::cin >> n >> k;        std::vector<i64> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }    std::sort(a.begin(), a.end());        i64 sum = std::accumulate(a.begin(), a.end(), 0LL);    i64 mx = a[n - 1];        for (int i = n; i >= 1; i--) {        i64 need = mx * i;        need = std::max(need, sum + (i - sum % i) % i);        if (need - sum <= k) {            std::cout << i << \"\\n\";            return;        }    }}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "brute force",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Cards Partition.json"
}