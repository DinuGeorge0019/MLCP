{"link": "https://codeforces.com//contest/1383/problem/D", "problemId": "681330", "problem_idx": "D", "shortId": "1383D", "contest_number": "1383", "problem_submissions": {"F": [87911622, 87901413, 87908295, 87909079, 87912863, 87912844, 87913228, 87920937], "C": [87903412, 87908609, 87920945, 87921225, 87936073, 87936017, 87923661, 87919633, 87920208, 87928476, 88561363, 87907584], "D": [87893217, 87920512, 87917720, 87900472, 88564499, 87905800, 87942673, 87934937, 87934603, 87934354, 87926585, 87907511, 87916069, 87908438, 87914997, 87918050, 87919666, 87904890, 87912187, 87897729, 87922544, 87918917], "E": [87883167, 87893057, 87896267, 87890928, 88564562, 87897262, 87898365, 87901088, 87901845, 87906849, 87898532, 87900480, 87902921, 87905469, 87912176, 87897358, 87922285, 87909673, 87899729, 87921664], "B": [87873092, 87873731, 87878338, 87871770, 88564467, 87883802, 87879305, 87891950, 87885163, 87888568, 87878119, 87882001, 87878631, 87875818, 87883310, 87903746, 87887725, 87881741, 87892008, 87886946], "A": [87871300, 87878540, 87872599, 87873455, 88564441, 87872862, 87887205, 87872116, 87872818, 87877345, 87871429, 87873700, 87872797, 87871844, 87872683, 87874942, 87874295, 87872122, 87878303, 87875696]}, "name": "D. Rearrange", "statement": "Koa the Koala has a matrix A of n rows and m columns. Elements of this\r\nmatrix are distinct integers from 1 to n\r\ncdot m (each number from 1 to n\r\ncdot m appears exactly once in the matrix).For any matrix M of n rows\r\nand m columns let\u2019s define the following: The i-th row of M is defined\r\nas R_i(M) = [ M_{i1}, M_{i2},\r\nldots, M_{im} ] for all i (1\r\nle i\r\nle n). The j-th column of M is defined as C_j(M) = [ M_{1j}, M_{2j},\r\nldots, M_{nj} ] for all j (1\r\nle j\r\nle m). Koa defines S(A) = (X, Y) as the spectrum of A, where X is the\r\nset of the maximum values in rows of A and Y is the set of the maximum\r\nvalues in columns of A.More formally: X =\r\n{\r\nmax(R_1(A)),\r\nmax(R_2(A)),\r\nldots,\r\nmax(R_n(A))\r\n} Y =\r\n{\r\nmax(C_1(A)),\r\nmax(C_2(A)),\r\nldots,\r\nmax(C_m(A))\r\n}Koa asks you to find some matrix A\u2019 of n rows and m columns, such that\r\neach number from 1 to n\r\ncdot m appears exactly once in the matrix, and the following conditions\r\nhold: S(A\u2019) = S(A) R_i(A\u2019) is bitonic for all i (1\r\nle i\r\nle n) C_j(A\u2019) is bitonic for all j (1\r\nle j\r\nle m) An array t (t_1, t_2,\r\nldots, t_k) is called bitonic if it first increases and then decreases.\r\nMore formally: t is bitonic if there exists some position p (1\r\nle p\r\nle k) such that: t_1 < t_2 <\r\nldots < t_p > t_{p+1} >\r\nldots > t_k.Help Koa to find such matrix or to determine that it doesn\u2019t\r\nexist.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 24.07.2020 18:10:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int h, w;\n  cin >> h >> w;\n  vector<vector<int>> a(h, vector<int>(w));\n  vector<pair<int, int>> pos(h * w);\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cin >> a[i][j];\n      --a[i][j];\n      pos[a[i][j]] = make_pair(i, j);\n    }\n  }\n  vector<vector<int>> b(h, vector<int>(w, -1));\n  int pi = -1;\n  int pj = -1;\n  vector<pair<int, int>> cells;\n  int ptr = 0;\n  for (int val = h * w - 1; val >= 0; val--) {\n    for (int i = 0; i < h; i++) debug(b[i]);\n    debug(pi, pj, cells);\n    auto& at = pos[val];\n    int vi = at.first;\n    int vj = at.second;\n    bool row_max = true;\n    for (int j = 0; j < w; j++) {\n      row_max &= (a[vi][j] <= val);\n    }\n    bool col_max = true;\n    for (int i = 0; i < h; i++) {\n      col_max &= (a[i][vj] <= val);\n    }\n    debug(val, vi, vj, row_max, col_max);\n    if (row_max && col_max) {\n      b[++pi][++pj] = val;\n      for (int j = pj - 1; j >= 0; j--) {\n        if (b[pi][j] == -1) {\n          cells.emplace_back(pi, j);\n        }\n      }\n      for (int i = pi - 1; i >= 0; i--) {\n        if (b[i][pj] == -1) {\n          cells.emplace_back(i, pj);\n        }\n      }\n      continue;\n    }\n    if (row_max) {\n      b[++pi][pj] = val;\n      for (int j = pj - 1; j >= 0; j--) {\n        if (b[pi][j] == -1) {\n          cells.emplace_back(pi, j);\n        }\n      }\n      continue;\n    }\n    if (col_max) {\n      b[pi][++pj] = val;\n      for (int i = pi - 1; i >= 0; i--) {\n        if (b[i][pj] == -1) {\n          cells.emplace_back(i, pj);\n        }\n      }\n      continue;\n    }\n    assert(ptr < (int) cells.size());\n    b[cells[ptr].first][cells[ptr].second] = val;\n    ++ptr;\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (j > 0) {\n        cout << \" \";\n      }\n      cout << b[i][j] + 1;\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "graphs", "greedy", "sortings"], "dificulty": "2800", "interactive": false}