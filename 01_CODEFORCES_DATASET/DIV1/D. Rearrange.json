{
    "link": "https://codeforces.com//contest/1383/problem/D",
    "problemId": "681330",
    "problem_idx": "D",
    "shortId": "1383D",
    "contest_number": "1383",
    "problem_submissions": {
        "F": [
            87911622,
            87901413,
            87908295,
            87909079,
            87912863,
            87912844,
            87913228,
            87920937
        ],
        "C": [
            87903412,
            87908609,
            87920945,
            87921225,
            87936073,
            87936017,
            87923661,
            87919633,
            87920208,
            87928476,
            88561363,
            87907584
        ],
        "D": [
            87893217,
            87920512,
            87917720,
            87900472,
            88564499,
            87905800,
            87942673,
            87934937,
            87934603,
            87934354,
            87926585,
            87907511,
            87916069,
            87908438,
            87914997,
            87918050,
            87919666,
            87904890,
            87912187,
            87897729,
            87922544,
            87918917
        ],
        "E": [
            87883167,
            87893057,
            87896267,
            87890928,
            88564562,
            87897262,
            87898365,
            87901088,
            87901845,
            87906849,
            87898532,
            87900480,
            87902921,
            87905469,
            87912176,
            87897358,
            87922285,
            87909673,
            87899729,
            87921664
        ],
        "B": [
            87873092,
            87873731,
            87878338,
            87871770,
            88564467,
            87883802,
            87879305,
            87891950,
            87885163,
            87888568,
            87878119,
            87882001,
            87878631,
            87875818,
            87883310,
            87903746,
            87887725,
            87881741,
            87892008,
            87886946
        ],
        "A": [
            87871300,
            87878540,
            87872599,
            87873455,
            88564441,
            87872862,
            87887205,
            87872116,
            87872818,
            87877345,
            87871429,
            87873700,
            87872797,
            87871844,
            87872683,
            87874942,
            87874295,
            87872122,
            87878303,
            87875696
        ]
    },
    "name": "D. Rearrange",
    "statement": "Koa the Koala has a matrix A of n rows and m columns. Elements of this\r\nmatrix are distinct integers from 1 to n\r\ncdot m (each number from 1 to n\r\ncdot m appears exactly once in the matrix).For any matrix M of n rows\r\nand m columns let\u2019s define the following: The i-th row of M is defined\r\nas R_i(M) = [ M_{i1}, M_{i2},\r\nldots, M_{im} ] for all i (1\r\nle i\r\nle n). The j-th column of M is defined as C_j(M) = [ M_{1j}, M_{2j},\r\nldots, M_{nj} ] for all j (1\r\nle j\r\nle m). Koa defines S(A) = (X, Y) as the spectrum of A, where X is the\r\nset of the maximum values in rows of A and Y is the set of the maximum\r\nvalues in columns of A.More formally: X =\r\n{\r\nmax(R_1(A)),\r\nmax(R_2(A)),\r\nldots,\r\nmax(R_n(A))\r\n} Y =\r\n{\r\nmax(C_1(A)),\r\nmax(C_2(A)),\r\nldots,\r\nmax(C_m(A))\r\n}Koa asks you to find some matrix A\u2019 of n rows and m columns, such that\r\neach number from 1 to n\r\ncdot m appears exactly once in the matrix, and the following conditions\r\nhold: S(A\u2019) = S(A) R_i(A\u2019) is bitonic for all i (1\r\nle i\r\nle n) C_j(A\u2019) is bitonic for all j (1\r\nle j\r\nle m) An array t (t_1, t_2,\r\nldots, t_k) is called bitonic if it first increases and then decreases.\r\nMore formally: t is bitonic if there exists some position p (1\r\nle p\r\nle k) such that: t_1 < t_2 <\r\nldots < t_p > t_{p+1} >\r\nldots > t_k.Help Koa to find such matrix or to determine that it doesn\u2019t\r\nexist.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 24.07.2020 18:10:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int h, w;\n  cin >> h >> w;\n  vector<vector<int>> a(h, vector<int>(w));\n  vector<pair<int, int>> pos(h * w);\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cin >> a[i][j];\n      --a[i][j];\n      pos[a[i][j]] = make_pair(i, j);\n    }\n  }\n  vector<vector<int>> b(h, vector<int>(w, -1));\n  int pi = -1;\n  int pj = -1;\n  vector<pair<int, int>> cells;\n  int ptr = 0;\n  for (int val = h * w - 1; val >= 0; val--) {\n    for (int i = 0; i < h; i++) debug(b[i]);\n    debug(pi, pj, cells);\n    auto& at = pos[val];\n    int vi = at.first;\n    int vj = at.second;\n    bool row_max = true;\n    for (int j = 0; j < w; j++) {\n      row_max &= (a[vi][j] <= val);\n    }\n    bool col_max = true;\n    for (int i = 0; i < h; i++) {\n      col_max &= (a[i][vj] <= val);\n    }\n    debug(val, vi, vj, row_max, col_max);\n    if (row_max && col_max) {\n      b[++pi][++pj] = val;\n      for (int j = pj - 1; j >= 0; j--) {\n        if (b[pi][j] == -1) {\n          cells.emplace_back(pi, j);\n        }\n      }\n      for (int i = pi - 1; i >= 0; i--) {\n        if (b[i][pj] == -1) {\n          cells.emplace_back(i, pj);\n        }\n      }\n      continue;\n    }\n    if (row_max) {\n      b[++pi][pj] = val;\n      for (int j = pj - 1; j >= 0; j--) {\n        if (b[pi][j] == -1) {\n          cells.emplace_back(pi, j);\n        }\n      }\n      continue;\n    }\n    if (col_max) {\n      b[pi][++pj] = val;\n      for (int i = pi - 1; i >= 0; i--) {\n        if (b[i][pj] == -1) {\n          cells.emplace_back(i, pj);\n        }\n      }\n      continue;\n    }\n    assert(ptr < (int) cells.size());\n    b[cells[ptr].first][cells[ptr].second] = val;\n    ++ptr;\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (j > 0) {\n        cout << \" \";\n      }\n      cout << b[i][j] + 1;\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "graphs",
        "greedy",
        "sortings"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Rearrange.json",
    "editorial_link": "https://codeforces.com//blog/entry/80562",
    "editorial": "Let be a matrix of size that is formed by a permutation of elements from\r\nto . Find the maximum element on each row and column (i.e. the\r\nspectrum)Now we are going to build the answer adding numbers one by one\r\nin decreasing order. We start with an empty 2 dimensional matrix (both\r\ndimensions have length 0) and at the end of each iteration the following\r\ninvariants will be maintained on the matrix: All elements processed are\r\ninside of the matrix. Each row and column is bitonic. The\r\nhorizontal/vertical spectrum of this matrix is a subset of the expected\r\nhorizontal/vertical spectrum. In addition we are keeping a queue with\r\nall positions in the matrix that doesn\u00e2\u0080\u0099t contain any element yet. At the\r\nend of each iteration the following invariants will be maintained on the\r\nqueue: Let be a position on the queue and a position that contains a\r\nvalue that belongs to the horizontal spectrum in the matrix such that\r\nand are in the same row, then all positions between and have already an\r\nelement in the matrix or occur in the queue before . Let be a position\r\non the queue and a position that contains a value that belongs to the\r\nvertical spectrum in the matrix such that and are in the same column,\r\nthen all positions between and have already an element in the matrix or\r\noccur in the queue before . M := int[0][0]Queue := new Queue()// sides\r\nof the matrixx, y = 0, 0 for num in n * m .. 1 if num belongs to the\r\nhorizontal spectrum // Add one row full of 0 in the bottom of the matrix\r\nX += 1 if num belongs to the vertical spectrum // Add one column full of\r\n0 in the right of the matrix Y += 1 if num belongs either to the\r\nhorizontal or to the vertical spectrum: // Put num in the bottom\r\nrightmost position of the matrix. M[x][y] = num else: ax, ay = pop\r\nelement from Queue M[ax][ay] = num if num belongs to the horizontal\r\nspectrum // Add all positions in the last row (but the last one) to the\r\nQueue from right to left for py in y - 1 .. 1 Queue.add(x, py) if num\r\nbelongs to the vertical spectrum: // Add all positions in the last\r\ncolumn (but the last one) to the Queue from bottom to top. for px in X -\r\n1 .. 1 Queue.add(px, y)In the end, invariants on the matrix guarantee\r\nthat all elements are placed, each row and column consist in a bitonic\r\nsequence as required and the spectrums are equal to the expected\r\nspectrums.Let\u00e2\u0080\u0099s prove each invariant on the matrix is kept: Clearly on\r\neach step a different element is placed on the matrix on an empty\r\nposition, we should only show that the operation doesn\u00e2\u0080\u0099t fail with Queue\r\nempty. Say the current element is , so the matrix is filled with\r\nelements larger than . Now we know that in original matrix there were at\r\nleast rows with maximums less than t and at least m-y columns with\r\nmaximums less than , so there could be at most elements greater or equal\r\nthan t but there are already. On each row and column the first element\r\nadded is the maximum and then elements are added in each direction\r\nstarting from it toward each edge, since elements are processed from\r\nlargest to smallest then each row and column is bitonic. The first\r\nelement added on each row and column is the maximum, and we only add it\r\nif it is part of the expected spectrum. Time complexity:\r\n"
}