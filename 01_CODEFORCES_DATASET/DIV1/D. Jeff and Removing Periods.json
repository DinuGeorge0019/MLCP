{
    "link": "https://codeforces.com//contest/351/problem/D",
    "problemId": "3595",
    "problem_idx": "D",
    "shortId": "351D",
    "contest_number": "351",
    "problem_submissions": {
        "D": [
            4670145,
            4670249,
            4674550,
            4670754,
            4674929,
            4684601,
            4669199,
            4669889,
            4672385,
            4680204
        ],
        "C": [
            4665748,
            4664661,
            4663479,
            4665815,
            4667455,
            4687038,
            4686935,
            4686917,
            4668439,
            4666789,
            4670720,
            4671735,
            4670649,
            4671154,
            4668837,
            4669283
        ],
        "B": [
            4661574,
            4660489,
            4662188,
            4663391,
            4665392,
            4662692,
            4661437,
            4662916,
            4663186,
            4668058,
            4662366,
            4666797,
            4662458,
            4659236,
            4659832,
            4665176,
            4659225
        ],
        "A": [
            4661298,
            4659082,
            4658665,
            4661628,
            4664159,
            4659520,
            4666420,
            4665346,
            4659838,
            4662463,
            4658356,
            4660908,
            4660765
        ],
        "E": [
            4658359,
            4666363,
            4665274,
            4666984,
            4664316,
            4666715,
            4668432,
            4666380,
            4665428,
            4663383,
            4671601,
            4671635,
            4660529,
            4661696,
            4664447,
            4673681,
            4671913,
            4664654
        ]
    },
    "name": "D. Jeff and Removing Periods",
    "statement": "Cosider a sequence, consisting of integers: , , , . Jeff can perform the\r\nfollowing operation on sequence : take three integers , , , such that =\r\n, = , , = ; remove elements , , , from the sequence , the remaining\r\nelements should be reindexed . permute in some order the remaining\r\nelements of sequence . A beauty of a sequence is the minimum number of\r\noperations that is needed to delete all elements from sequence .Jeffâ€™s\r\nwritten down a sequence of integers , , , . Now he wants to ask\r\nquestions. Each question can be described with two integers . The answer\r\nto the question is the beauty of sequence , , , . You are given the\r\nsequence and all questions. Help Jeff, answer all his questions.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define T (1<<17)\nint tree[T];\n\nvoid add(int pos, int val){\n    for(int i=pos;i<T;i=((i)|(i+1))) tree[i] += val;\n}\n\nint sum(int pos){\n    int ans = 0;\n    for(int i=pos;i>0;i=((i)&(i-1))) ans += tree[i-1];\n    return ans;\n}\n\nint tree2[T];\n\nvoid add2(int pos, int val){\n    for(int i=pos;i<T;i=((i)|(i+1))) tree2[i] += val;\n}\n\nint sum2(int pos){\n    int ans = 0;\n    for(int i=pos;i>0;i=((i)&(i-1))) ans += tree2[i-1];\n    return ans;\n}\n\nint N;\nint a[100010],index[100010];\nint next[100010];\nvector <pair <int, int> > query[100010]; // l -> r, id\nint ans[100010];\n\nint bound[100010];\n\nvoid pre(void){\n    int i;\n    \n    for(i=N-1;i>=0;i--){\n        if(next[i] == N){\n            bound[i] = N;\n        } else {\n            int x = i, y = next[i], z = next[y];\n            if(z == N || z - y == y - x){\n                bound[x] = bound[y];\n            } else {\n                bound[x] = z;\n            }\n        }\n    }\n}\n\nbool old[100010];\n\nvoid main2(void){\n    int i,j;\n    \n    for(i=N-1;i>=0;i--){\n        add(i, 1);\n        if(next[i] != N) add(next[i], -1);\n        \n        REP(j,query[i].size()){\n            int L = i, R = query[i][j].first, id = query[i][j].second;\n            ans[id] = sum(R) - sum(L);\n        }\n        \n        // add 1 to i+1 .. bound[i]\n        add2(i+1, 1);\n        add2(bound[i]+1, -1);\n        if(next[i] != N){\n            j = next[i];\n            add2(j+1, -1);\n            add2(bound[j]+1, 1);\n        }\n        \n        REP(j,query[i].size()){\n            int L = i, R = query[i][j].first, id = query[i][j].second;\n            if(sum2(R+1) == 0) ans[id]++;\n        }\n    }\n}\n\nint main(void){\n    int Q,i;\n    \n    cin >> N;\n    REP(i,N) scanf(\"%d\", &a[i]);\n    \n    REP(i,100010) index[i] = N;\n    for(i=N-1;i>=0;i--){\n        next[i] = index[a[i]];\n        index[a[i]] = i;\n    }\n    \n//  REP(i,N) cout << next[i] << ' ';\n//  cout << endl;\n    \n    pre();\n    \n    cin >> Q;\n    REP(i,Q){\n        int l,r;\n        scanf(\"%d%d\", &l, &r);\n        l--;\n        query[l].push_back(make_pair(r, i));\n    }\n    \n    main2();\n    \n    REP(i,Q) printf(\"%d\\n\", ans[i]);\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Jeff and Removing Periods.json",
    "editorial_link": "https://codeforces.com//blog/entry/9070",
    "editorial": "After the first request we can sort the numbers and for further moves\r\nwill be able to remove all occurrences of a certain number. So the\r\nanswer is the number of different numbers + 1 if there is no number,\r\noccurrence of which form an arithmetic progression. Number of different\r\nnumbers on a segment standart problem, can be done with offline\r\nalgorithm. The problem about finding the right number will be solved in\r\na similar algorithm:1. lets sort queries like pairs , we use integer\r\ndividing2. learn how to move from the interval to intervals , , , with\r\ncomplexcity 3. by means of such an operation will move from one segment\r\nto the next, in the amount of the operation algorithm will works It\r\nremains to learn how to make the change on the interval by element. Such\r\na problem can be solved quite simply:1. we craete for all value of\r\nnumbers in array2. depending on changes in the segment will add / remove\r\nitems to the start / end of the respective 3. check whether the\r\nresulting is arithmetic progression. it will be homework.\r\n",
    "hint": []
}