{"link": "https://codeforces.com//contest/351/problem/D", "problemId": "3595", "problem_idx": "D", "shortId": "351D", "contest_number": "351", "problem_submissions": {"D": [4670145, 4670249, 4674550, 4670754, 4674929, 4684601, 4669199, 4669889, 4672385, 4680204], "C": [4665748, 4664661, 4663479, 4665815, 4667455, 4687038, 4686935, 4686917, 4668439, 4666789, 4670720, 4671735, 4670649, 4671154, 4668837, 4669283], "B": [4661574, 4660489, 4662188, 4663391, 4665392, 4662692, 4661437, 4662916, 4663186, 4668058, 4662366, 4666797, 4662458, 4659236, 4659832, 4665176, 4659225], "A": [4661298, 4659082, 4658665, 4661628, 4664159, 4659520, 4666420, 4665346, 4659838, 4662463, 4658356, 4660908, 4660765], "E": [4658359, 4666363, 4665274, 4666984, 4664316, 4666715, 4668432, 4666380, 4665428, 4663383, 4671601, 4671635, 4660529, 4661696, 4664447, 4673681, 4671913, 4664654]}, "name": "D. Jeff and Removing Periods", "statement": "Cosider a sequence, consisting of integers: , , , . Jeff can perform the\r\nfollowing operation on sequence : take three integers , , , such that =\r\n, = , , = ; remove elements , , , from the sequence , the remaining\r\nelements should be reindexed . permute in some order the remaining\r\nelements of sequence . A beauty of a sequence is the minimum number of\r\noperations that is needed to delete all elements from sequence .Jeff\u2019s\r\nwritten down a sequence of integers , , , . Now he wants to ask\r\nquestions. Each question can be described with two integers . The answer\r\nto the question is the beauty of sequence , , , . You are given the\r\nsequence and all questions. Help Jeff, answer all his questions.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define T (1<<17)\nint tree[T];\n\nvoid add(int pos, int val){\n    for(int i=pos;i<T;i=((i)|(i+1))) tree[i] += val;\n}\n\nint sum(int pos){\n    int ans = 0;\n    for(int i=pos;i>0;i=((i)&(i-1))) ans += tree[i-1];\n    return ans;\n}\n\nint tree2[T];\n\nvoid add2(int pos, int val){\n    for(int i=pos;i<T;i=((i)|(i+1))) tree2[i] += val;\n}\n\nint sum2(int pos){\n    int ans = 0;\n    for(int i=pos;i>0;i=((i)&(i-1))) ans += tree2[i-1];\n    return ans;\n}\n\nint N;\nint a[100010],index[100010];\nint next[100010];\nvector <pair <int, int> > query[100010]; // l -> r, id\nint ans[100010];\n\nint bound[100010];\n\nvoid pre(void){\n    int i;\n    \n    for(i=N-1;i>=0;i--){\n        if(next[i] == N){\n            bound[i] = N;\n        } else {\n            int x = i, y = next[i], z = next[y];\n            if(z == N || z - y == y - x){\n                bound[x] = bound[y];\n            } else {\n                bound[x] = z;\n            }\n        }\n    }\n}\n\nbool old[100010];\n\nvoid main2(void){\n    int i,j;\n    \n    for(i=N-1;i>=0;i--){\n        add(i, 1);\n        if(next[i] != N) add(next[i], -1);\n        \n        REP(j,query[i].size()){\n            int L = i, R = query[i][j].first, id = query[i][j].second;\n            ans[id] = sum(R) - sum(L);\n        }\n        \n        // add 1 to i+1 .. bound[i]\n        add2(i+1, 1);\n        add2(bound[i]+1, -1);\n        if(next[i] != N){\n            j = next[i];\n            add2(j+1, -1);\n            add2(bound[j]+1, 1);\n        }\n        \n        REP(j,query[i].size()){\n            int L = i, R = query[i][j].first, id = query[i][j].second;\n            if(sum2(R+1) == 0) ans[id]++;\n        }\n    }\n}\n\nint main(void){\n    int Q,i;\n    \n    cin >> N;\n    REP(i,N) scanf(\"%d\", &a[i]);\n    \n    REP(i,100010) index[i] = N;\n    for(i=N-1;i>=0;i--){\n        next[i] = index[a[i]];\n        index[a[i]] = i;\n    }\n    \n//  REP(i,N) cout << next[i] << ' ';\n//  cout << endl;\n    \n    pre();\n    \n    cin >> Q;\n    REP(i,Q){\n        int l,r;\n        scanf(\"%d%d\", &l, &r);\n        l--;\n        query[l].push_back(make_pair(r, i));\n    }\n    \n    main2();\n    \n    REP(i,Q) printf(\"%d\\n\", ans[i]);\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2700", "interactive": false}