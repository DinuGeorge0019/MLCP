{
    "link": "https://codeforces.com//contest/264/problem/A",
    "problemId": "2526",
    "problem_idx": "A",
    "shortId": "264A",
    "contest_number": "264",
    "problem_submissions": {
        "D": [
            2970633,
            2970188,
            2969616,
            2972161,
            2970655,
            2972191,
            2971577,
            2970650,
            2971498,
            2971572,
            2972055,
            2972383,
            2971674,
            2972692,
            2971818,
            2972335
        ],
        "C": [
            2968127,
            2967219,
            2967855,
            2968130,
            2966487,
            2966588,
            2967563,
            2967148,
            2967835,
            2968495,
            2969405,
            2968262,
            2968182,
            2968431,
            2970284,
            2968742,
            2969164,
            2966742
        ],
        "B": [
            2965253,
            2965388,
            2965967,
            2964982,
            2964487,
            2965047,
            2964632,
            2965554,
            2964885,
            2965097,
            2966188,
            2965309,
            2965972,
            2965497,
            2965546,
            2967550,
            2966171
        ],
        "A": [
            2963692,
            2963886,
            2964531,
            2963631,
            2963360,
            2963339,
            2963656,
            2963270,
            2995453,
            2963462,
            2963614,
            2963459,
            2963970,
            2964239,
            2963708,
            2963681,
            2964333,
            2963722
        ],
        "E": [
            2971453,
            3192402,
            2977035,
            2974561,
            2972662
        ]
    },
    "name": "A. Escape from Stones",
    "statement": "Squirrel Liss lived in a forest peacefully, but unexpected trouble\r\nhappens. Stones fall from a mountain. Initially Squirrel Liss occupies\r\nan interval . Next, stones will fall and Liss will escape from the\r\nstones. The stones are numbered from 1 to in order.The stones always\r\nfall to the center of Liss\u2019s interval. When Liss occupies the interval\r\nand a stone falls to , she will escape to the left or to the right. If\r\nshe escapes to the left, her new interval will be . If she escapes to\r\nthe right, her new interval will be .You are given a string of length .\r\nIf the -th character of is \"\" or \"\", when the -th stone falls Liss will\r\nescape to the left or to the right, respectively. Find the sequence of\r\nstones\u2019 numbers from left to right after all the stones falls.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n//#define _MY_OPT_MODE_\n#define _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <list>\n\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long double ldb;\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef pair <double, double> pdd;\n\n#define y0 wwwwwww\n#define y1 qqqqqqq\n#define next NEXT\n#define prev PREV\n#define forn(i, n) for (int i = 0; i < (int) n; i++)\n#define ford(i, n) for (int i = (int) n - 1; i >= 0; i--)\n#define seta(a, b) memset(a, b, sizeof(a))\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n#define last(a) a[a.size() - 1]\n#define mp make_pair\n#define fs first\n#define sc second\n\ntemplate <class T> T sqr(T x) { return x * x; }\n\ndouble const pi = 3.1415926535897932384626433832795;\nint const inf = (int) 1e9;\nint64 const inf64 = (int64) 4e18;\nconst string name = \"a\";\n\nint n, ans[1000100];\nchar s[1000100];\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen((name + \".in\").data(), \"r\", stdin);\n\tfreopen((name + \".out\").data(), \"w\", stdout);\n#endif\n\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tint y1 = 0, y2 = n - 1;\n\tforn(i, n)\n\t\tif (s[i] == 'l') ans[y2--] = i + 1;\n\t\telse ans[y1++] = i + 1;\n\tforn(i, n)\n\t\tprintf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Escape from Stones.json",
    "editorial_link": "https://codeforces.com/blog/entry/6478",
    "editorial": "You can visualize the problem as a binary tree. Each node is responsable\r\nfor a interval [a, b]. Starting from the root, responsable for [0, 1],\r\nif you go left then root will have a left child responsable for interval\r\n[0, 1 / 2]. Since you\u00e2\u0080\u0099re a left child, last time the stone fell on\r\nposition 1 / 2, the end point of the interval. Note that from that\r\nchild, it doesn\u00e2\u0080\u0099t matter if you go left or right: the stone will never\r\nfall on a position bigger than 1 / 2 (the end point). The ideia is:\r\nsince a stone always fall on the midpoint (a + b) / 2 of the lower and\r\nend points, it can never fall after the endpoint. In fact, the stone\r\nmust fall infinitely many times to the right to reach that endpoint. So,\r\nwe were on a node [0, 1], the stone fell and we jumped to the left,\r\ncreating a left child [0, 1 / 2] and we now know that there is no way\r\nthe stone will every fall to a position > 1 / 2. This means that in the\r\nfinal solution, the current node [0, 1 / 2] will come AFTER all nodes\r\n(descendents) that come after this one. If we jumped to the right\r\ninstead, creating a right child responsable for interval [1 / 2, 1] we\r\ncan show the same way that the stone will never fall before the starting\r\npoint 1 / 2. This means that the current node will com BEFORE all nodes\r\n(descendents) that come after this one, since we know that the stone\r\ncan\u00e2\u0080\u0099t fall on a postion < 1 / 2 from now on. This is an algorithm: if in\r\nthe i\u00e2\u0080\u0099th stone we jumped to the left, we now that stone i will become\r\nAFTER all next stones. If we jumped right, stone i will become BEFORE\r\nall next stones. Code: 23071895\r\n"
}