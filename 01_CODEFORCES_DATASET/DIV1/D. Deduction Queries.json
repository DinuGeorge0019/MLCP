{"link": "https://codeforces.com//contest/1074/problem/D", "problemId": "249089", "problem_idx": "D", "shortId": "1074D", "contest_number": "1074", "problem_submissions": {"E": [45303620, 45300249, 45344571, 45304718, 45304862, 45306309, 45306510, 45315681, 45302002, 45303642], "F": [45297925, 45302412, 45298748, 45300083, 45299480, 45298818, 45299827, 45300561, 45300985, 45300910, 45302087, 45302359, 45302549, 45302342, 45306149, 45302208, 45303449, 45304102, 45303226], "D": [45294973, 45293128, 45295261, 45296109, 45292313, 45291734, 45297119, 45297694, 45297259, 45298710, 45297635, 45297369, 45298399, 45297846, 45294290, 45297091, 45296770, 45296596, 45297365, 45299859], "C": [45293553, 45291475, 45293844, 45294044, 45293914, 45294012, 45293608, 45295772, 45294886, 45297284, 45296110, 45294396, 45293720, 45296080, 45292596, 45294430, 45294994, 45295210, 45294620, 45296058], "B": [45292377, 45294890, 45292284, 45297195, 45296274, 45295787, 45291944, 45293450, 45293244, 45294291, 45295233, 45293263, 45291573, 45294870, 45303353, 45293540, 45298407, 45293034, 45292582, 45292571], "A": [45289520, 45289825, 45289616, 45289578, 45294985, 45294783, 45289998, 45290374, 45289949, 45291060, 45291837, 45290090, 45295330, 45290627, 45290102, 45291029, 45290582, 45297889, 45289941, 45289786]}, "name": "D. Deduction Queries", "statement": "There is an array a of 2^{30} integers, indexed from 0 to 2^{30}-1.\r\nInitially, you know that 0\r\nleq a_i < 2^{30} (0\r\nleq i < 2^{30}), but you do not know any of the values. Your task is to\r\nprocess queries of two types: : You are informed that the of the\r\nsubarray [l, r] (ends inclusive) is equal to x. That is, a_l\r\noplus a_{l+1}\r\noplus\r\nldots\r\noplus a_{r-1}\r\noplus a_r = x, where\r\noplus is the bitwise xor operator. In some cases, the received update\r\ncontradicts past updates. In this case, you should the contradicting\r\nupdate (the current update). : You are asked to output the bitwise xor\r\nof the subarray [l, r] (ends inclusive). If it is still impossible to\r\nknow this value, considering all past updates, then output .Note that\r\nthe queries are . That is, you need to write an solution.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\n\nint oj[nax];\nint xo[nax];\n\nunordered_map <int,int> mapa;\n\nint dajnum(int v)\n{\n\tif (!mapa.count(v))\n\t{\n\t\tn++;\n\t\tmapa[v]=n;\n\t\toj[n]=n;\n\t}\n\treturn mapa[v];\n}\n\nint fin(int v)\n{\n\tif (v==oj[v])\n\t\treturn v;\n\tint p=fin(oj[v]);\n\txo[v]^=xo[oj[v]];\n\toj[v]=p;\n\treturn p;\n}\n\nvoid uni(int a, int b, int w)\n{\n\tif (fin(a)==fin(b))\n\t\treturn;\n\tw^=xo[a];\n\tw^=xo[b];\n\ta=fin(a);\n\tb=fin(b);\n\toj[a]=b;\n\txo[a]=w;\n}\n\npii tlu(pii v)\n{\n\tint a=dajnum(v.first);\n\tint b=dajnum(v.second+1);\n\treturn {a, b};\n}\n\nint main()\n{\n\tscanf(\"%d\", &q);\n\tint zero=dajnum(0);\n\tint last=0;\n\twhile(q--)\n\t{\n\t\tint typ;\n\t\tscanf(\"%d\", &typ);\n\t\tif (typ==1)\n\t\t{\n\t\t\tint l, r, x;\n\t\t\tscanf(\"%d%d%d\", &l, &r, &x);\n\t\t\tl^=last;\n\t\t\tr^=last;\n\t\t\tx^=last;\n\t\t\tif (l>r)\n\t\t\t\tswap(l, r);\n\t\t\t//~ debug() << l << \" \" << r << \" \" << x;\n\t\t\tpii v=tlu({l, r});\n\t\t\tuni(v.first, v.second, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint l, r;\n\t\t\tscanf(\"%d%d\", &l, &r);\n\t\t\tl^=last;\n\t\t\tr^=last;\n\t\t\tif (l>r)\n\t\t\t\tswap(l, r);\n\t\t\tpii v=tlu({l, r});\n\t\t\t//~ debug() << l << \" \" << r;\n\t\t\tint ans=-1;\n\t\t\tif (fin(v.first)==fin(v.second))\n\t\t\t\tans=xo[v.first]^xo[v.second];\n\t\t\tlast=abs(ans);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dsu", "hashing"], "dificulty": "2400", "interactive": false}