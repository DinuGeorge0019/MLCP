{
    "link": "https://codeforces.com//contest/1074/problem/D",
    "problemId": "249089",
    "problem_idx": "D",
    "shortId": "1074D",
    "contest_number": "1074",
    "problem_submissions": {
        "E": [
            45303620,
            45300249,
            45344571,
            45304718,
            45304862,
            45306309,
            45306510,
            45315681,
            45302002,
            45303642
        ],
        "F": [
            45297925,
            45302412,
            45298748,
            45300083,
            45299480,
            45298818,
            45299827,
            45300561,
            45300985,
            45300910,
            45302087,
            45302359,
            45302549,
            45302342,
            45306149,
            45302208,
            45303449,
            45304102,
            45303226
        ],
        "D": [
            45294973,
            45293128,
            45295261,
            45296109,
            45292313,
            45291734,
            45297119,
            45297694,
            45297259,
            45298710,
            45297635,
            45297369,
            45298399,
            45297846,
            45294290,
            45297091,
            45296770,
            45296596,
            45297365,
            45299859
        ],
        "C": [
            45293553,
            45291475,
            45293844,
            45294044,
            45293914,
            45294012,
            45293608,
            45295772,
            45294886,
            45297284,
            45296110,
            45294396,
            45293720,
            45296080,
            45292596,
            45294430,
            45294994,
            45295210,
            45294620,
            45296058
        ],
        "B": [
            45292377,
            45294890,
            45292284,
            45297195,
            45296274,
            45295787,
            45291944,
            45293450,
            45293244,
            45294291,
            45295233,
            45293263,
            45291573,
            45294870,
            45303353,
            45293540,
            45298407,
            45293034,
            45292582,
            45292571
        ],
        "A": [
            45289520,
            45289825,
            45289616,
            45289578,
            45294985,
            45294783,
            45289998,
            45290374,
            45289949,
            45291060,
            45291837,
            45290090,
            45295330,
            45290627,
            45290102,
            45291029,
            45290582,
            45297889,
            45289941,
            45289786
        ]
    },
    "name": "D. Deduction Queries",
    "statement": "There is an array a of 2^{30} integers, indexed from 0 to 2^{30}-1.\r\nInitially, you know that 0\r\nleq a_i < 2^{30} (0\r\nleq i < 2^{30}), but you do not know any of the values. Your task is to\r\nprocess queries of two types: : You are informed that the of the\r\nsubarray [l, r] (ends inclusive) is equal to x. That is, a_l\r\noplus a_{l+1}\r\noplus\r\nldots\r\noplus a_{r-1}\r\noplus a_r = x, where\r\noplus is the bitwise xor operator. In some cases, the received update\r\ncontradicts past updates. In this case, you should the contradicting\r\nupdate (the current update). : You are asked to output the bitwise xor\r\nof the subarray [l, r] (ends inclusive). If it is still impossible to\r\nknow this value, considering all past updates, then output .Note that\r\nthe queries are . That is, you need to write an solution.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\n\nint oj[nax];\nint xo[nax];\n\nunordered_map <int,int> mapa;\n\nint dajnum(int v)\n{\n\tif (!mapa.count(v))\n\t{\n\t\tn++;\n\t\tmapa[v]=n;\n\t\toj[n]=n;\n\t}\n\treturn mapa[v];\n}\n\nint fin(int v)\n{\n\tif (v==oj[v])\n\t\treturn v;\n\tint p=fin(oj[v]);\n\txo[v]^=xo[oj[v]];\n\toj[v]=p;\n\treturn p;\n}\n\nvoid uni(int a, int b, int w)\n{\n\tif (fin(a)==fin(b))\n\t\treturn;\n\tw^=xo[a];\n\tw^=xo[b];\n\ta=fin(a);\n\tb=fin(b);\n\toj[a]=b;\n\txo[a]=w;\n}\n\npii tlu(pii v)\n{\n\tint a=dajnum(v.first);\n\tint b=dajnum(v.second+1);\n\treturn {a, b};\n}\n\nint main()\n{\n\tscanf(\"%d\", &q);\n\tint zero=dajnum(0);\n\tint last=0;\n\twhile(q--)\n\t{\n\t\tint typ;\n\t\tscanf(\"%d\", &typ);\n\t\tif (typ==1)\n\t\t{\n\t\t\tint l, r, x;\n\t\t\tscanf(\"%d%d%d\", &l, &r, &x);\n\t\t\tl^=last;\n\t\t\tr^=last;\n\t\t\tx^=last;\n\t\t\tif (l>r)\n\t\t\t\tswap(l, r);\n\t\t\t//~ debug() << l << \" \" << r << \" \" << x;\n\t\t\tpii v=tlu({l, r});\n\t\t\tuni(v.first, v.second, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint l, r;\n\t\t\tscanf(\"%d%d\", &l, &r);\n\t\t\tl^=last;\n\t\t\tr^=last;\n\t\t\tif (l>r)\n\t\t\t\tswap(l, r);\n\t\t\tpii v=tlu({l, r});\n\t\t\t//~ debug() << l << \" \" << r;\n\t\t\tint ans=-1;\n\t\t\tif (fin(v.first)==fin(v.second))\n\t\t\t\tans=xo[v.first]^xo[v.second];\n\t\t\tlast=abs(ans);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "hashing"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Deduction Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/62985",
    "editorial": "First, letâs learn how to handle information we have not recieved in\r\nupdates. Let the function be equal to the xor of the subarray . Also, we\r\ndefine .Assume 3 indicies . There are 2 rules: . (holds when ). These\r\nrules require a lot of conditions (and also plenty of 1). We can\r\nsimplify them greatly: Letâs index the borders between cells in our\r\narray (there are of them). Now, instead of defining a subarray by its 2\r\nendpoint , we will define a subarray by its 2 endpoint . Technically it\r\njust means, that we should increase by 1, and then we get the 2 end\r\nborders.From now I will assume that our input is given in such a way,\r\nthat subarrays are defined by their borders (So I will not mention the\r\naddition of 1 to ). Notice that the function is also affected by this.If\r\nwe take a look at our rules again, they boil down to just 1 rule: , for\r\n3 indicies ( doesnât need to hold now, for instance ). This\r\ntransformation also shows an observation; Assume every border is a\r\nvertex in a graph, and every update describes an undirected edge between\r\nthe vertices with weight . We let the distance between 2 nodes be the\r\nxor of edge weights on the path between them. Notice that this distance\r\nis equal to . In other words, an update adds an edge and a query asks\r\nfor some distance.Another observation is that, we do not care about all\r\nthe nodes, but only about the ones we recieved in queries and updates.\r\nMoreover, their order is irrelevant, so we can do an online mapping of\r\nnew nodes to the next free indicies. Thus, the number of nodes will be\r\nworstcase .Claim: We can know the answer to some query , if and only if\r\nthere exists a path between the nodes (they are in the same connected\r\ncomponent).//start spoiler of proofThere will be some subset of edges we\r\ntake, to form the xor between nodes and . Assume every vertex has 2\r\nstates, on/off. Initially all vertices are off, and our current answer\r\nis . When we take an edge we flip the state of its 2 ends, and xor our\r\nanswer by its weight. Suppose at some moment of time the nodes with \"on\"\r\nstate are {} (in sorted order). Observe that our current answer is equal\r\nto . This implies we want our subset of edges to end up having only the\r\nnodes {} activated. We look at the connected components. Observe that in\r\neach connected component, the number of nodes activated at any time is\r\neven. If the nodes and are in different component, then in our final\r\nresult we would want to have only 1 activated node in the component of ,\r\nand same with , but this is impossible.//end spoiler of proofFirst, we\r\nneed to know whether a query gives us 2 nodes that are in different\r\ncomponents (to know whether the answer is or not). For this we need to\r\nuse the Union-Find structure. Also notice, that our Union-Find structure\r\nwill only need to handle a forest of trees (if an update gives us an\r\nedge that creates a cycle, it means there is no contribution, so we\r\nignore it).Provided that an answer does exist, we need to also handle\r\nfinding a xor path between 2 nodes in a tree, to support merging of\r\ntrees. Generally to find a property over some path in a tree, it is\r\ncommon to use LCA or binary lifting. This turns out very difficult when\r\nwe also need to merge trees (unless you insist on implementing\r\nLink-Cut/ETT). Fortunately, we can still abuse the xor operator. In some\r\ntree, mark as the xor of edges on the path from to some arbitrary root\r\nin the tree. The xor path between nodes () turns out to be . So we would\r\nlike to maintain for each tree some arbitrary root and all those\r\nvalues.Notice that we can augment our Union-Find structure to support\r\nthis as well: For each node in the structure, we maintain as its parent\r\nin the structure, and as the xor on the path from to . Notice that can\r\nbe easily updated together with during the operation in the structure.To\r\nsummarize, when we are given in some update, we transform it to , and\r\nthen we add the edge between the parents.Finally, the complexity is ,\r\nbut this is only due to the online mapping if we use a regular map; You\r\ncan use a hash table and get a running time of , but I suggest being\r\ncareful with a hash table (you may want to read this:\r\nhttps://codeforces.com/blog/entry/62393).\r\n",
    "hint": []
}