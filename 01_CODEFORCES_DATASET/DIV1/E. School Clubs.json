{
    "link": "https://codeforces.com//contest/1479/problem/E",
    "problemId": "889630",
    "problem_idx": "E",
    "shortId": "1479E",
    "contest_number": "1479",
    "problem_submissions": {
        "D": [
            106806356,
            106798804,
            106791682,
            106791766,
            106783633,
            106814882,
            106806404,
            106823371,
            106808799,
            106822218,
            106817839,
            106848882,
            106812415,
            106835076,
            106827553,
            106802594,
            106816382,
            106815777,
            106820515,
            106838550,
            106850875,
            106833526
        ],
        "C": [
            106782305,
            106781616,
            106813281,
            106777792,
            106806652,
            106785851,
            106790598,
            106804329,
            106788311,
            106797179,
            106801693,
            106797158,
            106799023,
            106802871,
            106833768,
            106794280,
            106835769,
            106791359,
            106812286,
            106805528
        ],
        "B2": [
            106767251,
            106763833,
            106764524,
            106766365,
            106766872,
            106772583,
            106777899,
            106776623,
            106772714,
            106777329,
            106781346,
            106839134,
            106782598,
            106789550,
            106774779,
            106781374,
            106779953,
            106776541,
            106784819,
            106807842
        ],
        "B1": [
            106761871,
            106761547,
            106772762,
            106765327,
            106765110,
            106769139,
            106770176,
            106777978,
            106783437,
            106765790,
            106777195,
            106759777,
            106771397,
            106771604,
            106765950,
            106772183,
            106778477,
            106775679,
            106771753,
            106783453
        ],
        "A": [
            106755900,
            106753726,
            106756482,
            106751012,
            106869291,
            106756412,
            106753230,
            106749820,
            106752580,
            106752067,
            106756325,
            106758074,
            106749882,
            106753072,
            106759686,
            106753472,
            106830245,
            106764145,
            106862156,
            106753714,
            106755663
        ],
        "E": [
            106862710,
            106861209,
            106848127,
            128939200,
            106847859,
            106846880,
            112187125
        ]
    },
    "name": "E. School Clubs",
    "statement": "In Homer\u2019s school, there are n students who love clubs. Initially, there\r\nare m clubs, and each of the n students is in exactly one club. In other\r\nwords, there are a_i students in the i-th club for 1\r\nleq i\r\nleq m and a_1+a_2+\r\ndots+a_m = n.The n students are so unfriendly that every day one of them\r\n(chosen from all of the n students) gets angry. The student who gets\r\nangry will do one of the following things. With probability\r\nfrac 1 2, he leaves his current club, then creates a new club himself\r\nand joins it. There is only one student (himself) in the new club he\r\ncreates. With probability\r\nfrac 1 2, he does not create new clubs. In this case, he changes his\r\nclub to a new one (possibly the same club he is in currently) with\r\nprobability proportional to the number of students in it. Formally,\r\nsuppose there are k clubs and there are b_i students in the i-th club\r\nfor 1\r\nleq i\r\nleq k (before the student gets angry). He leaves his current club, and\r\nthen joins the i-th club with probability\r\nfrac {b_i} {n}. We note that when a club becomes empty, students will\r\nnever join it because any student who gets angry will join an empty club\r\nwith probability 0 according to the above statement.Homer wonders the\r\nexpected number of days until every student is in the same club for the\r\nfirst time.We can prove that the answer can be represented as a rational\r\nnumber\r\nfrac p q with\r\ngcd(p, q) = 1. Therefore, you are asked to find the value of pq^{-1}\r\nbmod 998\r\n,244\r\n,353. It can be shown that q\r\nbmod 998\r\n,244\r\n,353\r\nneq 0 under the given constraints of the problem.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(V<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(double& d) { str t; re(t); d = stod(t); }\nvoid re(long double& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(V<T>& x) { each(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { each(a,x) re(a); }\ntcT> void rv(int n, V<T>& x) { x.rsz(n); re(x); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t// #ifdef LOCAL\n\t// \treturn b ? \"true\" : \"false\"; \n\t// #else \n\treturn ts((int)b);\n\t// #endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(V<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << \", \";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\nvoid setPrec() { cout << fixed << setprecision(15); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid setIO(str s = \"\") {\n\tunsyncIO(); setPrec();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for USACO\n}\n\nvoid decrement() {}\ntcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n#define rvi(x,y) vi x(y); re(x);\n\n// https://codeforces.com/blog/entry/87598\n// P(x)=2N-x, Q(x)=N-x\n// evaluate Q(1...N-1) in blocks of B\n// evaluate P(1...N-1) in blocks of B\n// evaluate R(1...N-1) in blocks of B\n// \n\n// you want Q(1...N-1) + ... + P(1...a-1)*Q(a..N-1)\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = int((ll)v*m.v%MOD); return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: Basic poly ops including division. Can replace \\texttt{T} with double, complex.\n * Source: Own. Also see\n\t* https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/PolyInterpolate.h\n\t* https://github.com/ecnerwala/icpc-book/blob/master/content/numerical/fft.cpp\n * Verification: see FFT\n */\n\n// #include \"../../number-theory (11.1)/Modular Arithmetic/ModInt.h\"\n\nusing T = mi; using poly = vector<T>;\nvoid remz(poly& p) { while (sz(p)&&p.bk==T(0)) p.pop_back(); }\npoly REMZ(poly p) { remz(p); return p; }\npoly rev(poly p) { reverse(all(p)); return p; }\npoly shift(poly p, int x) { \n\tif (x >= 0) p.insert(begin(p),x,0); \n\telse assert(sz(p)+x >= 0), p.erase(begin(p),begin(p)-x);\n\treturn p; \n}\npoly RSZ(const poly& p, int x) { \n\tif (x <= sz(p)) return poly(begin(p),begin(p)+x);\n\tpoly q = p; q.rsz(x); return q;  }\nT eval(const poly& p, T x) { // evaluate at point x\n\tT res = 0; R0F(i,sz(p)) res = x*res+p[i]; \n\treturn res; }\npoly dif(const poly& p) { // differentiate\n\tpoly res; FOR(i,1,sz(p)) res.pb(T(i)*p[i]); \n\treturn res; }\npoly integ(const poly& p) { // integrate\n\tpoly res(sz(p)+1); F0R(i,sz(p)) res[i+1] = p[i]/T(i+1);\n\treturn res; }\n\npoly& operator+=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] += r[i]; \n\treturn l; }\npoly& operator-=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] -= r[i]; \n\treturn l; }\npoly& operator*=(poly& l, const T& r) { each(t,l) t *= r; \n\treturn l;\t }\npoly& operator/=(poly& l, const T& r) { each(t,l) t /= r; \n\treturn l; }\npoly operator+(poly l, const poly& r) { return l += r; }\npoly operator-(poly l, const poly& r) { return l -= r; }\npoly operator-(poly l) { each(t,l) t *= -1; return l; }\npoly operator*(poly l, const T& r) { return l *= r; }\npoly operator*(const T& r, const poly& l) { return l*r; }\npoly operator/(poly l, const T& r) { return l /= r;\t }\npoly operator*(const poly& l, const poly& r) {\n\tif (!min(sz(l),sz(r))) return {};\n\tpoly x(sz(l)+sz(r)-1); \n\tF0R(i,sz(l)) F0R(j,sz(r)) x[i+j] += l[i]*r[j];\n\treturn x;\n}\npoly& operator*=(poly& l, const poly& r) { return l = l*r; }\n\npair<poly,poly> quoRem(poly a, poly b) { \n\tremz(a); remz(b); assert(sz(b));\n\tT lst = b.bk, B = T(1)/lst; each(t,a) t *= B; \n\teach(t,b) t *= B;\n\tpoly q(max(sz(a)-sz(b)+1,0));\n\tfor (int dif; (dif=sz(a)-sz(b)) >= 0; remz(a)) {\n\t\tq[dif] = a.bk; F0R(i,sz(b)) a[i+dif] -= q[dif]*b[i]; }\n\teach(t,a) t *= lst;\n\treturn {q,a}; // quotient, remainder\n}\npoly operator/(const poly& a, const poly& b) { return quoRem(a,b).f; }\npoly operator%(const poly& a, const poly& b) { return quoRem(a,b).s; }\n/**poly a = {1,3,5,8,6,0,0,0,0}, b = {1,5,1};\nps(quoRem(a,b)); a = 2*a, b = 2*b; ps(quoRem(a,b));*/\npoly gcd(poly a, poly b) { return b == poly{} ? a : gcd(b,a%b); }\nT resultant(poly a, poly b) { // R(A,B)\n\t// =b_m^n*prod_{j=1}^mA(mu_j)\n\t// =b_m^na_m^n*prod_{i=1}^nprod_{j=1}^m(mu_j-lambda_i)\n\t// =(-1)^{mn}a_n^m*prod_{i=1}^nB(lambda_i)\n\t// =(-1)^{nm}R(B,A)\n\t// Also, R(A,B)=b_m^{deg(A)-deg(A-CB)}R(A-CB,B)\n\tint ad = sz(a)-1, bd = sz(b)-1; \n\tif (bd <= 0) return bd < 0 ? 0 : pow(b.bk,ad);\n\tint pw = ad; a = a%b; pw -= (ad = sz(a)-1);\n\treturn resultant(b,a)*pow(b.bk,pw)*T((bd&ad&1)?-1:1);\n}\n\n/**\n * Description: Multiply polynomials of ints for any modulus $<2^{31}$. \n \t* For XOR convolution ignore \\texttt{m} within \\texttt{fft}. \n * Time: O(N\\log N)\n * Source: \n \t* KACTL (https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/NumberTheoreticTransform.h)\n \t* https://cp-algorithms.com/algebra/fft.html\n \t* https://csacademy.com/blog/fast-fourier-transform-and-variations-of-it\n \t* maroonrk\n * Verification: \n\t* https://judge.yosupo.jp/problem/convolution_mod\n\t* SPOJ polymul, CSA manhattan, CF Perfect Encoding\n\t* http://codeforces.com/contest/632/problem/E\n */\n\n// #include \"ModInt.h\"\n// const int MOD = 998244353;\n\ntemplate<class T> void fft(V<T>& A, bool inv = 0) { // NTT\n\tint n = sz(A); assert((T::mod-1)%n == 0); V<T> B(n);\n\tfor(int b = n/2; b; b /= 2, swap(A,B)) {\n\t\tT w = pow(T::rt(),(T::mod-1)/n*b), m = 1;\n\t\tfor(int i = 0; i < n; i += b*2, m *= w) F0R(j,b) {\n\t\t\tT u = A[i+j], v = A[i+j+b]*m;\n\t\t\tB[i/2+j] = u+v; B[i/2+j+n/2] = u-v;\n\t\t}\n\t}\n\tif (inv) { reverse(1+all(A)); \n\t\tT z = T(1)/T(n); each(t,A) t *= z; }\n}\ntemplate<class T> V<T> mul(V<T> A, V<T> B) { // only special moduli for NTT\n\tif (!min(sz(A),sz(B))) return {};\n\tint s = sz(A)+sz(B)-1, n = 1; for (; n < s; n *= 2);\n\tbool eq = A == B; A.rsz(n), fft(A);\n\tif (eq) B = A; // squaring A, reuse result\n\telse B.rsz(n), fft(B);\n\tF0R(i,n) A[i] *= B[i];\n\tfft(A,1); A.rsz(s); return A;\n}\ntemplate<class M, class T> V<M> mulMod(V<T> x, V<T> y) {\n\tauto con = [](const V<T>& v) {\n\t\tV<M> w(sz(v)); F0R(i,sz(v)) w[i] = (int)v[i];\n\t\treturn w; };\n\treturn mul(con(x),con(y));\n}\ntemplate<class T> V<T> MUL(const V<T>& A, const V<T>& B) { // arbitrary moduli\n\tusing m0 = mint<(119<<23)+1,62>; auto c0 = mulMod<m0>(A,B);\n\tusing m1 = mint<(5<<25)+1,  62>; auto c1 = mulMod<m1>(A,B);\n\tusing m2 = mint<(7<<26)+1,  62>; auto c2 = mulMod<m2>(A,B);\n\tint n = sz(c0); V<T> res(n);\n\tm1 r01 = 1/m1(m0::mod); m2 r02 = 1/m2(m0::mod), r12 = 1/m2(m1::mod);\n\tF0R(i,n) { // a is remainder mod m0::mod, b fixes it mod m1::mod\n\t\tint a = c0[i].v, b = ((c1[i]-a)*r01).v, c = (((c2[i]-a)*r02-b)*r12).v;\n\t\tres[i] = (T(c)*m1::mod+b)*m0::mod+a; // c fixes it mod m2::mod\n\t}\n\treturn res;\n}\n\n\n/**\n * Description: Multiply small polys directly, otherwise use FFT.\n * Source: KACTL, https://cp-algorithms.com/algebra/fft.html\n */\n\n// #include \"Poly.h\"\n// #include \"FFT.h\"\n\nbool small(const poly& a, const poly& b) { // multiply directly\n\treturn (ll)sz(a)*sz(b) <= 10000; } \n// vmi smart(const vmi& a, const vmi& b) { return mul(a,b); }\n// vl smart(const vl& a, const vl& b) {\n// \tauto X = mul(vcd(all(a)),vcd(all(b)));\n// \tvl x(sz(X)); F0R(i,sz(X)) x[i] = round(X[i].real());\n// \treturn x; }\npoly conv(const poly& a, const poly& b) {\n\treturn small(a,b) ? a*b : mul(a,b); } \n\n/**\n * Description: computes $A^{-1}$ such that $AA^{-1}\\equiv 1\\pmod{x^n}$.\n \t* Newton's method: If you want $F(x)=0$ and $F(Q_k)\\equiv 0\\pmod{x^a}$\n \t* then $Q_{k+1}=Q_k-\\frac{F(Q_k)}{F'(Q_k)}\\pmod{x^{2a}}$ satisfies\n \t* $F(Q_{k+1})\\equiv 0 \\pmod{x^{2a}}$. Application: if $f(n),g(n)$ are the\n \t* \\#s of forests and trees on $n$ nodes then \n \t* $\\sum_{n=0}^{\\infty}f(n)x^n=\\exp\\left(\\sum_{n=1}^{\\infty}\\frac{g(n)}{n!}\\right)$.\n * Time: O(N\\log N)\n * Source: CF, http://people.csail.mit.edu/madhu/ST12/scribe/lect06.pdf\n \t* https://cp-algorithms.com/algebra/polynomial.html\n * Usage: vmi v={1,5,2,3,4}; ps(exp(2*log(v,9),9)); // squares v\n * Verification: https://codeforces.com/contest/438/problem/E\n \t* https://codeforces.com/gym/102028/submission/77687049\n \t* https://loj.ac/problem/6703 (MultipointEval)\n */\n\n// #include \"PolyConv.h\"\n\npoly inv(poly A, int n) { // Q-(1/Q-A)/(-Q^{-2})\n\tpoly B{1/A[0]};\n\tfor (int x = 2; x/2 < n; x *= 2)\n\t\tB = 2*B-RSZ(conv(RSZ(A,x),conv(B,B)),x);\n\treturn RSZ(B,n);\n}\npoly sqrt(const poly& A, int n) {  // Q-(Q^2-A)/(2Q)\n\tassert(A[0] == 1); poly B{1};\n\tfor (int x = 2; x/2 < n; x *= 2)\n\t\tB = T(1)/T(2)*RSZ(B+conv(RSZ(A,x),inv(B,x)),x);\n\treturn RSZ(B,n);\n}\npair<poly,poly> divi(const poly& f, const poly& g) { // return quotient and remainder\n\tif (sz(f) < sz(g)) return {{},f};\n\tpoly q = conv(inv(rev(g),sz(f)-sz(g)+1),rev(f));\n\tq = rev(RSZ(q,sz(f)-sz(g)+1));\n\tpoly r = RSZ(f-conv(q,g),sz(g)-1); return {q,r};\n}\npoly log(poly A, int n) { assert(A[0] == 1); // (ln A)' = A'/A\n\tA.rsz(n); return integ(RSZ(conv(dif(A),inv(A,n-1)),n-1)); }\npoly exp(poly A, int n) { assert(A[0] == 0);\n\tpoly B{1}, IB{1};\n\tfor (int x = 1; x < n; x *= 2) {\n\t\tIB = 2*IB-RSZ(conv(B,conv(IB,IB)),x); // inverse of B to x places\n\t\tpoly Q = dif(RSZ(A,x)); Q += RSZ(conv(IB,dif(B)-conv(B,Q)),2*x-1); \n\t\t// first x-1 terms of dif(B)-conv(B,Q) are zero\n\t\tB = B+RSZ(conv(B,RSZ(A,2*x)-integ(Q)),2*x); \n\t} // We know that Q=A' is B'/B to x-1 places, we want to find B'/B to 2x-1 places\n\treturn RSZ(B,n);\n}\n// poly expOld(poly A, int n) { // Q-(lnQ-A)/(1/Q)\n// \tassert(A[0] == 0); poly B = {1};\n// \twhile (sz(B) < n) { int x = 2*sz(B);\n// \t\tB = RSZ(B+conv(B,RSZ(A,x)-log(B,x)),x); }\n// \treturn RSZ(B,n);\n// }\n\nvoid segProd(vector<poly>& stor, poly& v, int ind, int l, int r) { // v -> places to evaluate at\n\tif (l == r) { stor[ind] = {-v[l],1}; return; }\n\tint m = (l+r)/2; segProd(stor,v,2*ind,l,m); segProd(stor,v,2*ind+1,m+1,r);\n\tstor[ind] = conv(stor[2*ind],stor[2*ind+1]);\n}\nvoid evalAll(vector<poly>& stor, poly& res, poly v, int ind = 1) {\n\tv = divi(v,stor[ind]).s;\n\tif (sz(stor[ind]) == 2) { res.pb(sz(v)?v[0]:0); return; }\n\tevalAll(stor,res,v,2*ind); evalAll(stor,res,v,2*ind+1);\n}\npoly multiEval(poly v, poly p) {\n\tvector<poly> stor(4*sz(p)); segProd(stor,p,1,0,sz(p)-1);\n\tpoly res; evalAll(stor,res,v); return res; }\n\npoly combAll(vector<poly>& stor, poly& dems, int ind, int l, int r) {\n\tif (l == r) return {dems[l]};\n\tint m = (l+r)/2;\n\tpoly a = combAll(stor,dems,2*ind,l,m), b = combAll(stor,dems,2*ind+1,m+1,r);\n\treturn conv(a,stor[2*ind+1])+conv(b,stor[2*ind]);\n}\npoly interpolate(vector<pair<T,T>> v) {\n\tint n = sz(v); poly x; each(t,v) x.pb(t.f);\n\tvector<poly> stor(4*n); segProd(stor,x,1,0,n-1);\n\tpoly dems; evalAll(stor,dems,dif(stor[1]));\n\tF0R(i,n) dems[i] = v[i].s/dems[i];\n\treturn combAll(stor,dems,1,0,n-1);\n}\n\nconst int B = 1<<15;\n\nint M, N = 0;\n\nmi get_p(int i) { return 2*N-i; }\n\nmi get_q(int i) { return N-i; }\n\n// poly divideAndMultiply(V<poly> v) {\n// \tif (sz(v) == 1) return v[0];\n// \tpoly a = divideAndMultiply(V<poly>(begin(v),begin(v)+sz(v)/2));\n// \tpoly b = divideAndMultiply(V<poly>(begin(v)+sz(v)/2,end(v)));\n// \trtn mul(a,b);\n// }\n\n// poly Bconsecutive(mi a, mi b) { // a*(x+i)+b\n// \tV<poly> v; FOR(i,1,B+1) v.pb({a*i+b,a});\n// \treturn divideAndMultiply(v);\n// }\n\nAR<poly,3> getR(int l, int r) { \n\t// product of p, product of q, desired\n\tif (l == r) {\n\t\tpoly tmp_p{2*N-l,-1};\n\t\tpoly tmp_q{N-l,-1};\n\t\treturn {tmp_p,tmp_q,tmp_q};\n\t}\n\tint m = (l+r)/2;\n\tauto ans_l = getR(l,m), ans_r = getR(m+1,r);\n\treturn {mul(ans_l[0],ans_r[0]),mul(ans_l[1],ans_r[1]),\n\t\tmul(ans_l[2],ans_r[1])+mul(ans_l[0],ans_r[2])};\n\t// p(x+l), q(x+l), q(x+l)\n\t// q(x+1) ...          q(x+B)\n\t// p(x+1) ... p(x+B-1) q(x+B)\n}\n\n// p(x+1)*...*p(x+B)\n// q(x+1)*...*q(x+B)\n\n\nmi tot_q_prod = 1;\n\nmi eval_dumb(int t) {\n\tmi sum = 0;\n\tFOR(i,1,t+1) {\n\t\tmi prod = 1;\n\t\tFOR(j,1,i) prod *= get_p(j);\n\t\tFOR(j,i,N) prod *= get_q(j);\n\t\tsum += prod;\n\t}\n\tsum /= tot_q_prod;\n\t// FOR(j,1,N) sum /= get_q(j);\n\treturn sum;\n}\n\npoly PP,QQ,RR;\npoly suf_prod;\n\nmi eval_smart(int a) { // 0 to a-1\n\tmi ans = 0;\n\tmi pref_prod = 1;\n\t// last term is P[1..a-1]\n\tfor (int i = 0; ; ++i) {\n\t\t// P[1..B*i] Q[B*i+1] onwards\n\t\t// over to\n\t\t// P[1..B*(i+1)-1] Q[B*i+B] onwards\n\t\tif (B*i+B-1 < a) {\n\t\t\tans += pref_prod*RR[i]*suf_prod[i+1]; // suf_prod[i] has B*i+1 onwards\n\t\t} else {\n\t\t\t// start with P[1..B*i] .. Q[B*i+1 onwards]\n\t\t\tmi cur_prod = pref_prod*suf_prod[i];\n\t\t\tFOR(j,B*i,a) {\n\t\t\t\tif (j > B*i) {\n\t\t\t\t\tcur_prod /= get_q(j);\n\t\t\t\t\tcur_prod *= get_p(j);\n\t\t\t\t}\n\t\t\t\tans += cur_prod;\n\t\t\t}\n\t\t\t// B*i to a-1\n\t\t\tbreak;\n\t\t}\n\t\tpref_prod *= PP[i];\n\t\t// PP[0]..PP[i-1]*RR[i]*QQ[i+1]*QQ[i+2]+...\n\t\t// B*i to B*i+B-1\n\t}\n\tdbg(\"DIVIDING\",tot_q_prod);\n\tans /= tot_q_prod;\n\treturn ans;\n}\n\nmi eval(int t) {\n\t// mi x = eval_dumb(t);\n\tmi y = eval_smart(t);\n\t// assert(x == y);\n\treturn y;\n}\n\nint main() {\n\tsetIO(); \n\tre(M); rvi(A,M);\n\teach(t,A) N += t;\n\n\tauto PQR = getR(1,B);\n\tpoly P = PQR[0];\n\tpoly Q = PQR[1];\n\tpoly R = PQR[2];\n\n\tpoly places; F0R(i,B) places.pb(B*i);\n\n\tPP = multiEval(P,places);\n\t// F0R(i,B) {\n\t// \tmi mul = 1;\n\t// \tFOR(j,1,B+1) mul *= get_p(B*i+j);\n\t// \tdbg(\"HUH\",i,PP[i],mul);\n\t// }\n\tQQ = multiEval(Q,places);\n\tRR = multiEval(R,places);\n\tfor (int i = 0; ; ++i) {\n\t\tif (B*i+B < N) {\n\t\t\ttot_q_prod *= QQ[i];\n\t\t} else {\n\t\t\tFOR(cur,B*i+1,N) tot_q_prod *= get_q(cur);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint ind = 0; while (B*ind < N) ++ind;\n\tsuf_prod = poly(ind+1);\n\tsuf_prod[ind] = suf_prod[ind-1] = 1;\n\tFOR(j,B*(ind-1)+1,N) suf_prod[ind-1] *= get_q(j);\n\tR0F(i,ind-1) {\n\t\tassert(i < sz(QQ));\n\t\tsuf_prod[i] = QQ[i]*suf_prod[i+1];\n\t\t// dbg(\"HA\",i,QQ[i],suf_prod[i]);\n\t}\n\tdbg(\"CALCED\",tot_q_prod);\n\t// dbg(\"HA\",suf_prod[0],suf_prod,tot_q_prod); exit(0);\n\t// mi test_prod = 1; FOR(i,1,N) test_prod *= i;\n\t// dbg(tot_prod,test_prod);\n\n\n\n\tmi ans = 0;\n\teach(t,A) ans += eval(t);\n\tans -= eval(N);\n\tps(-2*ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "fft",
        "math",
        "number theory",
        "probabilities"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. School Clubs.json",
    "editorial_link": "https://codeforces.com//blog/entry/87598",
    "editorial": "There may be several ways to deal with the expected value of stopping\r\ntime. Here, we decide to give an elegant way to derive the expected\r\nstopping time inspired by MiFaFaOvO\u00e2\u0080\u0099s comment. Here, we are going to\r\nintroduce the mathematical tool we will use in the following description\r\n(see here for a Chinese explanation.)Consider a random process , where\r\nis called the -th event of the process, or the event at time . Let\r\nrandom variable be its stopping time. That is, for every , It can be\r\ndecided whether as long as are given. If there is a function that maps\r\nan event to a real number such that for every , and depends on some\r\nproperties of the events and the stopping time, which is usually a\r\nconstant in practice. Let , then . That is, is a martingale of . By the\r\noptimal stopping theorem, under some ignorable conditions, we have that\r\n. Therefore, . Moreover, if is a constant, then We will use the above\r\nidentity to find the expected value of , the stopping time. Usually, is\r\ncalled the potential function.To begin our journey, we should first\r\ndescribe an event as something (a number, a tuple, a sequence, or a set)\r\nin our problem. We find it naturally to use a (multi-)set to describe\r\nit, where denotes the number of clubs, the -th of which contains\r\nstudents. We see that the explicit order of the clubs does not matter\r\nbut the number of students in each club. Furthermore, we notice that ,\r\nwhich implies us to define the potential function as the form where . It\r\nshould be noted that the sum of elements in is a constant, so we let We\r\nfirst consider the corner case for the value of . Since students will\r\nnever join an empty club, and denotes the events with the same property.\r\nTherefore, we need , which immediately yields .We now investigate how\r\nthe potential function behaves from the -th event to the -th event . We\r\nnote that the student who gets angry is in the -th club with probability\r\n. After that, the angry student will leave and create a new club with\r\nprobability . In this case, , and we have join the -th club () with\r\nprobability . In this case, , and we have stay still in the -th club\r\nwith probability . In this case, , and we have To sum it up, we get that\r\nLet , and then we obtain that Here, we need to find a function that\r\nsatisfies the above condition with the corner case .There are several\r\npossible ways to assign the value of . We choose the most simple one\r\nsuch that , which removes the constant term. Under this assignment, we\r\nhave . After this, we have to make that i.e. holds for every .We let for\r\n. Therefore, , and We find that where and . If we can compute in an\r\nefficient way, then the problem is solved. However, it seems not so\r\nstraightforward.For convenience, we denote where and are linear\r\nfunctions (polynomials of degree ). To compute , we use the trick\r\nmentioned in min_25\u00e2\u0080\u0099s blog. However, the trick we adopt here can deal\r\nwith more general cases.Let be a large enough positive integer. Then we\r\nhave We only have to compute the inner sum . We now use the SQRT trick\r\nhere. Let be the block size. Let Then we will see that It is more\r\nconvenient to let and , then the main summation in is written as Now, we\r\nhave three values needed, which are . We deal with first. We note that\r\nis a polynomial of degree and we want to compute for every . If we can\r\nobtain the values of , then by Lagrange interpolation, we can recover\r\nthe polynomial . And then, if we know the exact polynomial , then by\r\nmulti-point evaluation trick, we can compute the values of for every .\r\nThe total time complexity would be .We can compute in time. And then, we\r\nnote that Therefore, can be computed in time if we simultaneously\r\nmaintain the values of block product of and in the above identity.\r\nBonus: A \"log\" in the complexity may be eliminated by some trick similar\r\nto min_25\u00e2\u0080\u0099s blog? This subproblem is very similar to compute the\r\nfactorial-like product, which is originally mentioned in min_25\u00e2\u0080\u0099s blog.\r\nTo solve it, we define Then . What we need is to compute fast enough. We\r\nalso note that is a polynomial of degree . We can easily find the values\r\nof in time. Therefore, the values of can be obtained by Lagrange\r\ninterpolation and multi-point evaluation. In particular, we are able to\r\ncompute in this way, which is considered to be a general factorial. This\r\nsubproblem is more tricky if we are able to compute fast. Similarly, we\r\ndefine as what we did when computing . Let be the prefix block products\r\nof as an analog for and . It can be easily seen that Having computed all\r\nvalues we need in the previous several sections, we are able to compute\r\nthe value of a single in time. Therefore, the overall complexity is .\r\nMoreover, we can save in complexity with an improved interpolation\r\nmethod for shifting evaluation values. See the paper \"A. Bostan, P.\r\nGaudry, and E. Schost, Linear recurrences with polynomial coefficients\r\nand application to integer factorization and Cartier-Manin operator. ,\r\n36(6): 1777 1806. 2007\". Suppose given are a polynomial of degree by a\r\npoint-value representation and a shift . It is asked to compute an\r\nalternative point-value representation . A straightforward way to solve\r\nthis problem is to directly make use of Lagrange interpolation and\r\nmulti-point evaluation, which yields an arithmetic complexity algorithm.\r\nIn fact, we can do it better in time.Recall the formula of Lagrange\r\ninterpolation that given points where , then the unique polynomial of\r\ndegree is Rewrite this formula in our case that are given, then We\r\nassume that do not overlap with , then for , we have The summation can\r\nbe computed by FFT. Consider two polynomials: We have Therefore, can be\r\ncomputed in time. Now we consider a modified version: given a polynomial\r\nof degree by a point-value representation and a shift , compute . The\r\ntrick is to let , which is also a polynomial of degree . Then the\r\nproblem becomes: given and a shift , compute . Let\u00e2\u0080\u0099s consider how to\r\ncompute . For convenience, we denote that where indicates the number of\r\nelements in the product. We need to compute the values of To compute\r\nthese values recurrently, we should notice that We choose as an example.\r\nHere we need to compute There are values of that are needed, which are\r\nThe first line is our target and the rest three lines can be obtained by\r\nshifting the first line by , and , respectively. Let be the complexity\r\nwhere is the degree of our polynomials, then Hence, . In our case, ,\r\nthen the complexity is reduced to . We use the trick, SQRT\r\ndecomposition, to split summations into blocks, and then use Lagrange\r\ninterpolation and multi-point evaluation to compute the value in each\r\nblock. We obtain an algorithm with complexity . A more subtle trick to\r\nsave a is obtained by the shifting technique, which yields a faster\r\nalgorithm with complexity . The constant factor of Lagrange\r\ninterpolation and multi-point evaluation is very large, so this approach\r\nto save a brings a significant improvement. However, we allow suboptimal\r\nsolutions that directly use Lagrange interpolation and multi-point\r\nevaluation to get AC. Some related problems: Stopping time: 1349D, 850F,\r\n1025G. Generating function: SPOJ FACTMODP, CodeChef QPOLYSUM, 1349F2.\r\n"
}