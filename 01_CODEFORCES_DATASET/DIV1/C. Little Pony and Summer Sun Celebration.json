{"link": "https://codeforces.com//contest/453/problem/C", "problemId": "11935", "problem_idx": "C", "shortId": "453C", "contest_number": "453", "problem_submissions": {"D": [7318525, 7321381, 7319937, 7313076, 7316122, 11122936], "C": [7314789, 7312823, 7323051, 7318282, 7319034, 7312696, 7313901, 7313477, 7314695, 7314310, 7314103, 7314216, 7311079, 7314796, 7314374, 7314951, 7314159, 7314941], "B": [7311773, 7310412, 7316305, 7319850, 7314250, 7310826, 7311570, 7321252, 7320392, 7320316, 7312680, 7310934, 7311494, 7312013, 7315911, 7311404, 7312306, 7313238, 7312326, 7313318], "A": [7308671, 7308664, 7309073, 7318976, 7309345, 7308656, 7308757, 7321161, 7309462, 7308797, 7309148, 7308775, 7313516, 7309054, 7309188, 7308988, 7311729, 7309495], "E": [7318455, 7321485, 7325631, 7343757]}, "name": "C. Little Pony and Summer Sun Celebration", "statement": "Twilight Sparkle learnt that the evil Nightmare Moon would return during\r\nthe upcoming Summer Sun Celebration after one thousand years of\r\nimprisonment on the moon. She tried to warn her mentor Princess\r\nCelestia, but the princess ignored her and sent her to Ponyville to\r\ncheck on the preparations for the celebration. Twilight Sparkle wanted\r\nto track the path of Nightmare Moon. Unfortunately, she didn\u2019t know the\r\nexact path. What she knew is the parity of the number of times that each\r\nplace Nightmare Moon visited. Can you help Twilight Sparkle to restore\r\nany path that is consistent with this information?Ponyville can be\r\nrepresented as an undirected graph (vertices are places, edges are roads\r\nbetween places) without self-loops and multi-edges. The path can start\r\nand end at any place (also it can be empty). Each place can be visited\r\nmultiple times. The path must not visit more than places.\r\n", "solutions": ["#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\n// EVEN\n//   ENDS: Degree is 3 + 4k\n//   ELSE: Degree is 4k\n\n// ODD\n//   ENDS: Degree is 1 + 4k\n//   ELSE: Degree is 2 + 4k\n\n#define MAXN 100010\n\nint N;\nvector<int> E[MAXN];\nvector<int> R;\n\nint X[MAXN];\nbool vis[MAXN];\n\nbool dfs(int u) {\n  if(vis[u]) return false;\n  vis[u] = true;\n\n  bool res = X[u] == 1;\n  for(int i = 0; i < E[u].size(); i++) {\n    res |= dfs(E[u][i]);\n  }\n  return res;\n}\n\nvoid dfs2(int u, int p) {\n  vis[u] = true;\n\n  X[u] = 1 - X[u];\n  R.push_back(u);\n\n  for(int i = 0; i < E[u].size(); i++) {\n    int v = E[u][i];\n    if(vis[v]) continue;\n\n    dfs2(v, u);\n\n    X[u] = 1 - X[u];\n    R.push_back(u);\n  }\n\n  if(X[u]) {\n    if(p == -1) {\n      R.resize(R.size() - 1);\n    } else {\n      X[p] = 1 - X[p];\n      R.push_back(p);\n      X[u] = 1 - X[u];\n      R.push_back(u);\n    }\n  }\n}\n\nint main() {\n  int M;\n  cin >> N >> M;\n  for(int i = 0; i < M; i++) {\n    int u, v; cin >> u >> v; u--; v--;\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n  for(int i = 0; i < N; i++) {\n    cin >> X[i];\n  }\n\n  int xs = -1;\n  for(int i = 0; i < N; i++) {\n    if(vis[i]) continue;\n\n    if(dfs(i)) {\n      if(xs == -1) {\n        xs = i;\n      } else {\n        cout << \"-1\\n\";\n        return 0;\n      }\n    }\n  }\n  if(xs == -1) {\n    cout << \"0\\n\";\n  } else {\n    memset(vis, 0, sizeof(vis));\n    dfs2(xs, -1);\n\n    cout << R.size() << '\\n';\n    for(int i = 0; i < R.size(); i++) {\n      if(i) cout << ' ';\n      cout << R[i] + 1;\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs"], "dificulty": "2200", "interactive": false}