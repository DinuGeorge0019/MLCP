{
    "link": "https://codeforces.com//contest/650/problem/B",
    "problemId": "50876",
    "problem_idx": "B",
    "shortId": "650B",
    "contest_number": "650",
    "problem_submissions": {
        "E": [
            16578790,
            16577272,
            16578590,
            16579959,
            16637208,
            16582561,
            16619834,
            16591408,
            16757704
        ],
        "D": [
            16571229,
            16573705,
            16576122,
            16578304,
            16576176,
            16577509,
            16577016,
            16576771,
            16578407,
            16577295,
            16573405,
            16578398,
            16577971,
            16579415,
            16579518,
            16578322,
            16579977,
            16579420,
            16579068
        ],
        "B": [
            16567529,
            16566753,
            16570863,
            16566306,
            16567392,
            16570268,
            16568199,
            16568212,
            16566872,
            16566001,
            16578738,
            16567371,
            16573291,
            16569824,
            16567006,
            16572578,
            16570591,
            16567965,
            16566091
        ],
        "C": [
            16565085,
            16569140,
            16568520,
            16573461,
            16571216,
            16572854,
            16571058,
            16570678,
            16571485,
            16571831,
            16567202,
            16572160,
            16568367,
            16566170,
            16572982,
            16567681,
            16567338,
            16571921,
            16572363
        ],
        "A": [
            16562732,
            16562808,
            16562782,
            16562889,
            16563014,
            16563492,
            16563086,
            16563133,
            16562823,
            16562796,
            16575057,
            16563813,
            16563019,
            16567243,
            16562986,
            16569600,
            16562758,
            16562970,
            16562962
        ]
    },
    "name": "B. Image Preview",
    "statement": "Vasya\u2019s telephone contains photos. Photo number 1 is currently opened on\r\nthe phone. It is allowed to move left and right to the adjacent photo by\r\nswiping finger over the screen. If you swipe left from the first photo,\r\nyou reach photo . Similarly, by swiping right from the last photo you\r\nreach photo . It takes seconds to swipe from photo to adjacent.For each\r\nphoto it is known which orientation is intended for it horizontal or\r\nvertical. Phone is in the vertical orientation and be rotated. It takes\r\nsecond to change orientation of the photo.Vasya has seconds to watch\r\nphotos. He want to watch as many photos as possible. If Vasya opens the\r\nphoto for the first time, he spends second to notice all details in it.\r\nIf photo is in the wrong orientation, he spends seconds on rotating it\r\nbefore watching it. If Vasya has already opened the photo, he just skips\r\nit (so he doesn\u2019t spend any time for watching it or for changing its\r\norientation). It is not allowed to skip unseen photos.Help Vasya find\r\nthe maximum number of photos he is able to watch during seconds.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000010;\n\nint v[N];\nint sum[N];\nchar foo[N];\n\nint main() {\n  int n, A, B, T;\n  scanf(\"%d %d %d %d\", &n, &A, &B, &T);\n  scanf(\"%s\", foo);\n  for (int i = 0; i < n; i++) {\n    v[i] = 1 + (foo[i] == 'w' ? B : 0);\n  }\n  if (v[0] > T) {\n    printf(\"%d\\n\", 0);\n    return 0;\n  }\n  int ans = 0;\n  for (int rot = 0; rot < 2; rot++) {\n    sum[0] = 0;\n    for (int i = 1; i < n; i++) {\n      sum[i] = sum[i - 1] + v[i] + A;\n    }\n    v[n] = v[0];\n    int spent = 0;\n    int cur = 0;\n    for (int i = n; i >= 1; i--) {\n      spent += v[i];\n      cur++;\n      if (spent > T) {\n        break;\n      }\n      ans = max(ans, cur);\n      {\n        int back = (n - i) * A;\n        int have = T - (spent + back);\n        if (have >= 0) {\n          int low = 0, high = i - 1;\n          while (low < high) {\n            int mid = (low + high + 1) >> 1;\n            if (sum[mid] <= have) {\n              low = mid;\n            } else {\n              high = mid - 1;\n            }\n          }\n          ans = max(ans, cur + low);\n        }\n      }\n      spent += A;\n    }\n    for (int i = 1; i < n - i; i++) {\n      swap(v[i], v[n - i]);\n    }\n  }\n  ans = min(ans, n);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dp",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Image Preview.json",
    "editorial_link": "https://codeforces.com//blog/entry/43677",
    "editorial": "What photos we will\nsee in the end? Some number from the beginning of the gallery and some\nfrom the end. There are 4 cases: First two cases are straightforward, we\ncan just emulate them. Third and fourth cases can be done with the\nmethod of two pointers. Note that if we see one more picture to the\nright, we spend more time on the right side and the number of photos\nseen to the left will decrease. This solution will run in . Alternative\nsolution is to fix how many photos we\u00e2\u0080\u0099ve seen to the right and search\nhow many we can see to the left with binary search. For this method we\nwill need to precompute times of seeing pictures to the right and to the\nleft. But this is solution is , which is slightly worse then previous\none, but maybe it is easier for somebody.\n"
}