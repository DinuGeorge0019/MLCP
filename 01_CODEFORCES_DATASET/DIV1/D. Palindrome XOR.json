{
    "link": "https://codeforces.com//contest/1161/problem/D",
    "problemId": "339901",
    "problem_idx": "D",
    "shortId": "1161D",
    "contest_number": "1161",
    "problem_submissions": {
        "F": [
            53909371,
            114209812,
            53863200
        ],
        "E": [
            53757964,
            53756987,
            53756569,
            53759204,
            53758710,
            53758335,
            53759423,
            53759655,
            53759053,
            53758599,
            53760097,
            53761659,
            53757322,
            53759810
        ],
        "D": [
            53752102,
            53753035,
            53753793,
            53751800,
            53753429,
            53754722,
            87768256,
            53755219,
            53754639,
            53755997,
            53749499,
            53756338,
            53756778,
            53758722,
            53757091,
            53754786,
            53751937,
            53753965,
            53753805,
            53754929
        ],
        "C": [
            53750364,
            53751704,
            53751645,
            53749841,
            53749214,
            53750926,
            53751458,
            53755261,
            53754114,
            53751399,
            53756883,
            53754076,
            53759235,
            53760202,
            53749644,
            53749593,
            53751107,
            53750858
        ],
        "B": [
            53748059,
            53750584,
            53750568,
            53748260,
            53748334,
            53748600,
            53749151,
            53749091,
            53748293,
            53760218,
            53747945,
            53749635,
            53748265,
            53747869,
            53748914,
            53748572,
            53749307,
            53749491
        ],
        "A": [
            53746899,
            53747514,
            53747934,
            53746630,
            53746650,
            53747171,
            53747667,
            53746731,
            53746977,
            53759102,
            53746696,
            53748269,
            53748575,
            53751158,
            53747184,
            53746584,
            53747125,
            53747652
        ]
    },
    "name": "D. Palindrome XOR",
    "statement": "You are given a string s consisting of characters \"\", \"\", and \"\". The\r\nfirst character of s is guaranteed to be \"\". Let m be the number of\r\ncharacters in s.Count the number of ways we can choose a pair of\r\nintegers a, b that satisfies the following: 1\r\nleq a < b < 2^m When written without leading zeros, the base-2\r\nrepresentations of a and b are both palindromes. The base-2\r\nrepresentation of of a and b matches the pattern s. We say that t\r\nmatches s if the lengths of t and s are the same and for every i, the\r\ni-th character of t is equal to the i-th character of s, or the i-th\r\ncharacter of s is \"\". Compute this count modulo 998244353.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nstruct G {\n    vpi adj[2005];\n    int col[2005];\n    int nex = 1;\n    bool bad = 0;\n    G () {\n    }\n    void addEdge(int a, int b, int c) {\n        adj[a].pb({b,c}), adj[b].pb({a,c});\n    }\n    void dfs(int x, int y) {\n        if (col[x] != -1) {\n            if (col[x] != y) bad = 1;\n            return;\n        }\n        col[x] = y;\n        trav(t,adj[x]) dfs(t.f,col[x]^t.s);\n    }\n    mi count() {\n        int z = 0; F0R(i,nex) col[i] = -1;\n        F0R(i,nex) if (col[i] == -1) {\n            dfs(i,0);\n            z ++;\n        }\n        if (bad) return 0;\n        return exp(mi(2),z-1);\n    }\n};\n\nstring s;\nmi ans(0);\n\nvoid solve(int len) {\n    G g = G(); \n    vi a(sz(s));\n    F0R(j,sz(a)) {\n        if (j > sz(a)-1-j) a[j] = a[sz(a)-1-j];\n        else a[j] = g.nex++;\n    }\n    vi b(len);\n    F0R(j,sz(b)) {\n        if (j > sz(b)-1-j) b[j] = b[sz(b)-1-j];\n        else b[j] = g.nex++;\n    }\n    g.addEdge(0,a.back(),1);\n    g.addEdge(0,b.back(),1);\n    F0Rd(i,sz(s)) if (s[i] != '?') {\n        if (i >= sz(b)) {\n            g.addEdge(0,a[i],s[i]-'0');\n        } else {\n            g.addEdge(a[i],b[i],s[i]-'0');\n        }\n    }\n    ans += g.count();\n}\n\nint main() {\n    setIO(); re(s); reverse(all(s));\n    FOR(i,1,sz(s)) solve(i);\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Palindrome XOR.json",
    "editorial_link": "https://codeforces.com//blog/entry/66878",
    "editorial": "Since the leading character of s\n is a \"1\", then that means a<2m?1\n and 2m?1?b<2m\n. Let's fix the length of a\n as k\n. I'll describe a more general solution, so there might be simpler solutions that work for this specific problem.\n\nLet's make a graph with n+k+2\n nodes. The first n\n nodes represent the n\n bits of b\n, and the next k\n nodes represent the k\n bits of a\n. The last two nodes represent a 0\n node and 1\n node (which we will explain later). We want to find the number of ways to color the graph with two colors 0\n and 1\n such that they satisfy some conditions.\n\nLet's draw two different types of edges 0\n-edges and 1\n-edges. If two nodes are connected by a 0\n-edge, then that means they must be the same color. If two nodes are connected by a 1\n-edge, then that means they must be a different color.\n\nWe will draw some edges as follows:\n\nDraw a 1\n edge between the 0\n node and 1\n node to represent they must be different colors.\nDraw a 0\n edge between bi\n and bn?i?1\n to represent the palindrome conditions (similarly we can do this for a\n).\nFor the i\n-th bit, if si\n is \"1\", draw a 1\n edge between ai\n and bi\n (if i>k\n, we instead draw an edge from bi\n to 1\n). If si\n is \"0\", then draw a 0\n edge between ai\n and bi\n. If si\n is \"?\", then don't draw any edges, since there are no explicit constraints.\nNow, we want to count the number of valid colorings. We want to split the graph into a two colors, which is a bipartite graph. We want all edges that cross the bipartition to be 1\n edges and all edges within the same bipartition to be 0\n edges.\n\nTo count this, we first collapse all connected components of 0\n edges, then check if the remaining 1\n edges form a bipartite graph. If there is a non-bipartite graph, return 0\n immediately, since this means it's impossible to fulfill the conditions. Otherwise, let C\n be the number of connected components. We add 2C?1\n to our answer. The reason we subtract 1\n is that the component containing the 0\n and 1\n node is fixed to be colored 0\n, but for other components, we are free to color the components in either of two ways.\n\nThere are n\n different lengths to try, each of which take a linear amount of time to get the count, so the overall time complexity is O(n2)\n.",
    "hint": []
}