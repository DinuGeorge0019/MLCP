{
    "link": "https://codeforces.com//contest/1819/problem/C",
    "problemId": "1880620",
    "problem_idx": "C",
    "shortId": "1819C",
    "contest_number": "1819",
    "problem_submissions": {
        "E": [
            202225318,
            202223532,
            202223484,
            202225560,
            202308964,
            202224265,
            202225112,
            202221853,
            202253482,
            202237435,
            203635743,
            203096948,
            202225859,
            202369794
        ],
        "D": [
            202209352,
            202212141,
            202205538,
            202220831,
            202198559,
            202210822,
            202236119,
            202239190,
            202212242,
            202208889,
            202205391,
            202216800,
            203995136,
            202197649,
            202216978,
            202217768,
            202220492,
            202220964,
            202225376,
            202219172
        ],
        "C": [
            202201042,
            202203020,
            202193305,
            202202657,
            202190230,
            202199701,
            202199472,
            202200745,
            202199789,
            202199523,
            208251329,
            202218422,
            202204297,
            202216624,
            202204671,
            202205053,
            202201997,
            202201056,
            202198992
        ],
        "B": [
            202193365,
            202195322,
            202214813,
            202196120,
            202186520,
            202187817,
            202188682,
            202193750,
            202186708,
            202188527,
            202188957,
            202183110,
            202191595,
            202187157,
            202193385,
            202195604,
            202188109,
            202186084,
            202189411
        ],
        "A": [
            202182367,
            202180872,
            202181217,
            202181093,
            202180590,
            202180859,
            202181832,
            202181960,
            202180690,
            202180596,
            202180602,
            202180463,
            202182678,
            202180651,
            202182633,
            202181119,
            202181593,
            202180899,
            202180615
        ],
        "F": [
            202939012,
            206043011
        ]
    },
    "name": "C. The Fox and the Complete Tree Traversal",
    "statement": "The fox Yae climbed the of the Sacred Sakura. A tree is a connected\r\nundirected graph that does not contain cycles.The fox uses her magical\r\npowers to move around the tree. Yae can jump from vertex v to another\r\nvertex u if and only if the distance between these vertices does not\r\nexceed 2. In other words, in one jump Yae can jump from vertex v to\r\nvertex u if vertices v and u are connected by an edge, or if there\r\nexists such vertex w that vertices v and w are connected by an edge, and\r\nalso vertices u and w are connected by an edge.After Yae was able to get\r\nthe sakura petal, she wondered if there was a route in the tree v_1,\r\nv_2,\r\nldots, v_n such that: the fox can jump from vertex v_i to vertex v_{i +\r\n1}, the fox can jump from vertex v_n to vertex v_1, all v_i are pairwise\r\ndistinct. Help the fox determine if the required traversal exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n\n#define ll long long\n#define int ll\n#define ull unsigned ll\n#define ld long double\n#define rep(a) rep1(i,a)\n#define rep1(i,a) rep2(i,0,a)\n#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)\n#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)\n#define chkmin(a,b) (a=min(a,b))\n#define chkmax(a,b) (a=max(a,b))\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int>\n#define pb push_back\n#define eb emplace_back\n#define sort_unique(a) sort(all(a)),a.resize(unique(all(a))-a.begin())\n//#define inf 1010000000\n#define inf 4000000000000000000\n#define eps 1e-9\n#define sz(a) ((int)a.size())\n#define pow2(x) (1ll<<(x))\n#define ceiling(a,b) (((a)+(b)-1)/(b))\n#define print0(a) cout << (a) << ' '\n#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#ifdef i_am_noob\n#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)\ntemplate<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(T && x) {cerr << x << endl;}\ntemplate<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}\n#else\n#define bug(...) 777771449\n#endif\ntemplate<typename T> void print(T && x) {cout << x << \"\\n\";}\ntemplate<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\n\nconst int Mod=1000000007,Mod2=998244353;\nconst int MOD=Mod2;\ntemplate <int mod>\nstruct Modint{\n    int val;\n    Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}\n    Modint operator +(const Modint& o) const {\n        Modint res;\n        res.val=val+o.val;\n        if(res.val>=mod) res.val-=mod;\n        return res;\n    }\n    Modint operator +(const int& o) const {return Modint(val+o);}\n    Modint operator -() const {\n        Modint res;\n        res.val=-val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const Modint& o) const {\n        Modint res;\n        res.val=val-o.val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const int& o) const {return Modint(val-o);}\n    Modint operator *(const Modint& o) const {return Modint(val*o.val);}\n    Modint operator *(const int& o) const {return Modint(val*(o%mod));}\n    Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}\n    Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}\n    Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}\n    Modint Pow(int b) const {\n        Modint tmp(val),ret(1);\n        while(b){\n            if(b&1) ret*=tmp;\n            b>>=1;tmp*=tmp;\n        }\n        return ret;\n    }\n    Modint Pow(const Modint& a, int b) const {return a.Pow(b);}\n    inline Modint inv() const {return (*this).Pow(mod-2);}\n    Modint operator /(const Modint& o) const {return *this*o.inv();}\n    Modint operator /(const int& o) const {return *this*Modint(o).inv();}\n    bool operator ==(const Modint& o) const {return val==o.val;}\n};\ntemplate<int mod>\nostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}\ntemplate<int mod>\nModint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}\ntemplate<int mod>\nModint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}\ntemplate<int mod>\nModint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}\n#define modint Modint<MOD>\nvector<modint> inv,fac,invfac;\nvoid init_comb(int N){\n    inv.resize(N),fac.resize(N),invfac.resize(N);\n    inv[1]=1,fac[0]=1,invfac[0]=1;\n    rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);\n    rep2(i,1,N) fac[i]=fac[i-1]*i;\n    rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];\n}\ninline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}\ninline modint H(int n, int m){return C(n+m-1,n);}\n\nconst int maxn=200005,maxm=pow2(17),maxk=7777714;\n\n//i_am_noob\n//#define wiwihorz  \nvoid balbitorz(){}\nint n,dis[2][maxn],a[maxn];\nvector<int> adj[maxn],vec[maxn];\n\nvoid dfs(int u, int par, int t){\n    dis[t][u]=par==-1?0:dis[t][par]+1;\n    for(auto v: adj[u]) if(v!=par) dfs(v,u,t);\n}\n\nvoid orzck(){\n    cin >> n;\n    rep(n-1){\n        int u,v; cin >> u >> v; u--,v--;\n        adj[u].pb(v),adj[v].pb(u);\n    }\n    dfs(0,-1,0);\n    int p=max_element(dis[0],dis[0]+n)-dis[0];\n    dfs(p,-1,0);\n    int q=max_element(dis[0],dis[0]+n)-dis[0];\n    dfs(q,-1,1);\n    int d=dis[0][q];\n    rep(n){\n        assert(dis[0][i]+dis[1][i]-d>=0&&(dis[0][i]+dis[1][i]-d)%2==0);\n        if(dis[0][i]+dis[1][i]-d>2){\n            print(\"No\");\n            return;\n        }\n        if(dis[0][i]+dis[1][i]-d==0){\n            a[dis[0][i]]=i;\n            for(auto j: adj[i]) if(dis[0][j]+dis[1][j]-d==2) vec[i].pb(j);\n        }\n    }\n    vector<int> res;\n    for(int i=0; i<d; i+=2){\n        res.pb(a[i]);\n        for(auto j: vec[a[i+1]]) res.pb(j);\n    }\n    int dd=d;\n    if(d%2==0){\n        dd--;\n        res.pb(a[d]);\n    }\n    for(int i=dd; i>=1; i-=2){\n        res.pb(a[i]);\n        for(auto j: vec[a[i-1]]) res.pb(j);\n    }\n    assert(sz(res)==n);\n    print(\"Yes\");\n    for(auto i: res) print0(i+1);\n    cout << \"\\n\";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    // #ifdef i_am_noob\n    // freopen(\"input1.txt\",\"r\",stdin);\n    // freopen(\"output1.txt\",\"w\",stdout);\n    // freopen(\"output2.txt\",\"w\",stderr);\n    // #endif\n    cout << fixed << setprecision(15);\n    ld start=clock();\n    balbitorz();\n    int t;\n    #ifdef wiwihorz\n    cin >> t;\n    #else\n    t=1;\n    #endif\n    while(t--) orzck();\n    bug((clock()-start)/CLOCKS_PER_SEC);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. The Fox and the Complete Tree Traversal.json",
    "editorial_link": "https://codeforces.com//blog/entry/115133",
    "editorial": "Note that if the tree contains the subgraph shown below, then there is\r\nno answer. To prove this it is enough to consider all possible cases for\r\nhow a cyclic route can pass through the upper vertex and understand that\r\nit is impossible to construct such route. Let\u00e2\u0080\u0099s assume that the tree\r\ndoes not contain the subgraph shown. It is easy to see that in this\r\ncase, the tree can be represented as a path and vertices directly\r\nattached to it. To check that the tree can be represented in this way,\r\nwe will find the diameter of the tree and check that all other vertices\r\nare directly connected to it. Now we need to learn how to build a cyclic\r\nroute.Number the vertices of the diameter from to in the order of\r\ntraversal of the diameter from one end to the other. Now let\u00e2\u0080\u0099s build the\r\nroute as follows. Firstly, visit vertex , then visit all vertices not on\r\nthe diameter attached to vertex , then move to vertex , then to all\r\nvertices not on the diameter attached to vertex , and so on. When we\r\nreach the end of the diameter, we will visit all vertices of the\r\ndiameter with even numbers, as well as all vertices of the tree not on\r\nthe diameter attached to the vertices of the diameter with odd numbers.\r\nNow let\u00e2\u0080\u0099s make the same route in the opposite direction along the\r\ndiameter, but through vertices of a different parity, which reaches\r\nvertex .Time complexity: .\r\n"
}