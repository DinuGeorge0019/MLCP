{
    "link": "https://codeforces.com//contest/840/problem/C",
    "problemId": "118958",
    "problem_idx": "C",
    "shortId": "840C",
    "contest_number": "840",
    "problem_submissions": {
        "E": [
            29579983,
            29579804,
            29577664,
            29579379,
            30931404,
            29639075,
            29617435,
            29681440,
            29681407,
            29681392,
            29681366
        ],
        "D": [
            29572451,
            29573549,
            29574893,
            29644417,
            29644402,
            29595162,
            29575013,
            29575646,
            29572436,
            29576887,
            29575628,
            29572554,
            29567189,
            29575551,
            29574764,
            29578191,
            29654756,
            29591307,
            29590747,
            29590681,
            29590673,
            29590627,
            29571509,
            29577552,
            29578628,
            29580062
        ],
        "C": [
            29567872,
            29569558,
            29567683,
            29569063,
            29562508,
            29569694,
            29567877,
            29577113,
            29566790,
            29572424,
            29577847,
            29579952,
            29584687,
            29571506,
            29571448,
            29570686,
            29578919,
            29571629,
            29571512,
            29569311
        ],
        "B": [
            29561393,
            29563952,
            29561789,
            29563624,
            29569083,
            29562635,
            29573313,
            29563716,
            29576058,
            29565857,
            29562483,
            29571100,
            29573859,
            29577034,
            29563154,
            29568606,
            29568725,
            29563595,
            29562462
        ],
        "A": [
            29557063,
            29560856,
            29557654,
            29557167,
            29564205,
            29559452,
            29556856,
            29560188,
            29575932,
            29562655,
            29557325,
            29559317,
            29562250,
            29559768,
            29556972,
            29558958,
            29556622,
            29557880,
            29558266
        ]
    },
    "name": "C. On the Bench",
    "statement": "A year ago on the bench in public park Leha found an array of numbers.\r\nLeha believes that permutation is right if for all condition, that is\r\nnot perfect square, holds. Leha wants to find number of right\r\npermutations modulo .\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\n\ntemplate<int MOD>\nstruct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) { }\n\tModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n};\ntypedef ModInt<1000000007> mint;\n\nint main() {\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d\", &a[i]);\n\t\tmap<int, int> counts;\n\t\trep(i, n) {\n\t\t\tint x = a[i];\n\t\t\tfor (int j = 2; ; ++ j) {\n\t\t\t\tint jj = j * j;\n\t\t\t\tif (jj > x) break;\n\t\t\t\twhile (x % jj == 0)\n\t\t\t\t\tx /= jj;\n\t\t\t}\n\t\t\t++ counts[x];\n\t\t}\n\t\tvector<vector<mint>> C(n + 1, vector<mint>(n + 1));\n\t\tfor (int i = 0; i <= n; i ++) {\n\t\t\tC[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j ++)\n\t\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t\t}\n\t\tvector<mint> dp, ndp(n + 1);\n\t\tndp[0] = 1;\n\t\tint sum = 0;\n\t\tfor (auto pp : counts) {\n\t\t\tint w = pp.second;\n\t\t\tif (w == 0) continue;\n\t\t\tdp.swap(ndp);\n\t\t\tndp.assign(n + 1, mint());\n\t\t\trep(i, n + 1) {\n\t\t\t\tmint x = dp[i];\n\t\t\t\tif (x.x == 0) continue;\n\t\t\t\trer(j, 0, i) {\n\t\t\t\t\tfor (int k = 0; k <= sum + 1 - i && j + k <= w; ++ k) {\n\t\t\t\t\t\tif (j == 0 && k == 0) continue;\n\t\t\t\t\t\tint l = w - j - k;\n\t\t\t\t\t\tmint cnt = x;\n\t\t\t\t\t\tcnt *= C[i][j];\n\t\t\t\t\t\tcnt *= C[sum + 1 - i][k];\n\t\t\t\t\t\tcnt *= C[l + j + k - 1][j + k - 1];\n\t\t\t\t\t\tndp[i - j + l] += cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += w;\n\t\t}\n\t\tmint ans = ndp[0];\n\t\tfor (auto pp : counts) rep(i, pp.second)\n\t\t\tans *= i + 1;\n\t\tprintf(\"%d\\n\", ans.get());\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. On the Bench.json",
    "editorial_link": "https://codeforces.com//blog/entry/53943?locale=en",
    "editorial": "Let's divide all numbers into groups. Scan all numbers from left to right. Suppose that current position is i. If groupi is not calculated yet, i forms a new group. Assign unique number to groupi. Then for all j such that j?>?i and a[j]Â·a[i] is a perfect square, make groupj equal to groupi. Now we can use dynamic programming to calculate the answer.\nF(i,?j) will denote the number of ways to place first i groups having j \"bad\" pairs of neighbors.\nSuppose we want to make a transition from F(i,?j). Let's denote size of group i as size, and total count of numbers placed before as total.\nWe will iterate S from 1 to min(size,?total?+?1) and D from 0 to min(j,?S).\nS is the number of subsegments we will break the next group in, and D is the number of currently existing \"bad\" pairs we will eliminate.\nThis transition will add T to F(i?+?1,?j?-?D?+?size?-?S) (D \"pairs\" eliminated, size?-?S new pairs appeared after placing new group).\nT is the number of ways to place the new group according to S and D values.\nActually it's . Why? Because there are  ways to break group of size size into S subsegments.\n ways to select those D \"bad\" pairs out of existing j we will eliminate.\nAnd  ways to choose placements for S?-?D subsegment (other D are breaking some pairs so their positions are predefined).\nAfter all calculations, the answer is F(g,?0), where g is the total number of groups.",
    "hint": []
}