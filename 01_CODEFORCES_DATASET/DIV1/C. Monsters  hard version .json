{
    "link": "https://codeforces.com//contest/1785/problem/C",
    "problemId": "1767286",
    "problem_idx": "C",
    "shortId": "1785C",
    "contest_number": "1785",
    "problem_submissions": {
        "F": [
            192340988,
            192367706,
            192347284,
            192344077,
            192349198,
            192347771,
            192385993,
            192336126,
            192406311,
            192343375,
            192348787,
            192366544,
            192344262,
            192411258,
            192345259,
            192363821,
            192484658
        ],
        "E": [
            192334775,
            192378839,
            192330680,
            192327219,
            192332119,
            192339722,
            192385982,
            192341740,
            192412077,
            192337184,
            192336634,
            192325309,
            192324682,
            192330314,
            192339341,
            192328941,
            192342934,
            192342640,
            192343285,
            192338492,
            192348718
        ],
        "D": [
            192309677,
            192304720,
            192308363,
            192312353,
            192300737,
            192385972,
            192323435,
            192411822,
            192411698,
            192411631,
            192411452,
            192307092,
            192297940,
            192289422,
            192305735,
            192292206,
            192306351,
            192303021,
            192324811,
            192312541,
            192301962,
            192316529,
            192316093,
            192321567,
            192314574
        ],
        "C": [
            192301226,
            192367208,
            192300659,
            192294893,
            192304774,
            192305847,
            192385966,
            192316174,
            192318962,
            192301773,
            192292324,
            192299527,
            193510779,
            192315363,
            192293483,
            192308504,
            192291605,
            192310063,
            192307486,
            192299043,
            192314808,
            192308858
        ],
        "B": [
            192291042,
            192291589,
            192316742,
            192291514,
            192291590,
            192385951,
            192288659,
            192292597,
            192289761,
            192297426,
            192300042,
            192305089,
            192297247,
            192288814,
            192295447,
            192337551,
            192290254,
            192297732,
            192303838,
            192303907,
            192291091
        ],
        "A": [
            192284331,
            192283441,
            192283155,
            192282660,
            192283131,
            192385935,
            192282844,
            192284622,
            192283277,
            192290652,
            192292611,
            192296096,
            192286915,
            192282931,
            192283418,
            192285228,
            192283044,
            192283110,
            192282987,
            192288048,
            192282867
        ]
    },
    "name": "C. Monsters  hard version ",
    "statement": "In a computer game, you are fighting against n monsters. Monster number\r\ni has a_i health points, all a_i are integers. A monster is alive while\r\nit has at least 1 health point.You can cast spells of two types: Deal 1\r\ndamage to any single alive monster of your choice. Deal 1 damage to all\r\nalive monsters. If at least one monster dies (ends up with 0 health\r\npoints) as a result of this action, then repeat it (and keep repeating\r\nwhile at least one monster dies every time). Dealing 1 damage to a\r\nmonster reduces its health by 1.Spells of type 1 can be cast any number\r\nof times, while a spell of type 2 can be cast at most once during the\r\ngame.For every k = 1, 2,\r\nldots, n, answer the following question. Suppose that only the first k\r\nmonsters, with numbers 1, 2,\r\nldots, k, are present in the game. What is the smallest number of times\r\nyou need to cast spells of type 1 to kill all k monsters?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#include <bits/extc++.h> /** keep-include */\nusing namespace __gnu_pbds;\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nconstexpr int bsf_constexpr(unsigned int n) {\n    int x = 0;\n    while (!(n & (1 << x))) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\nusing ll = int64_t;\n\nusing S = ll;\nusing F = ll;\n\nS op(S x, S y) { return min(x, y); }\nS e(){ return ll(1e9); }\nS mapping(F f, S x) { return f + x; }\nF composition(F f, F g) { return f + g; }\nF id() { return 0; }\n\ntemplate<class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag,\n    tree_order_statistics_node_update>;\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<ll> A(N);\n\tfor(ll& x : A) cin >> x;\n\tvector<int> ord(N);\n\tfor(int i = 0; i < N; i++) ord[i] = i;\n\tsort(ord.begin(), ord.end(), [&](int x, int y) { return A[x] < A[y]; });\n\tvector<int> inv_ord(N);\n\tfor(int i = 0; i < N; i++) inv_ord[ord[i]] = i;\n\tatcoder::lazy_segtree<S, op, e, F, mapping, composition, id> seg(N);\n\tll cnt = 0;\n\tll in_seg_sum = 0;\n\n\tordered_set<int> in_set_idx;\n\tfor(int i = 0; i < N; i++){\n\t\tint loc = inv_ord[i];\n\n\t\tint nbefore = in_set_idx.order_of_key(loc);\n\t\tin_set_idx.insert(loc);\n\t\tseg.set(loc, A[i] - nbefore - 1);\n\t\tseg.apply(loc+1, N, -1);\n\t\tcnt += 1;\n\t\tin_seg_sum += A[i];\n\t\tint f = seg.max_right(0, [&](S x) -> bool {\n\t\t\treturn x >= 0;\n\t\t});\n\t\tif(f < N){\n\t\t\tassert(seg.get(f) < 0);\n\t\t\tseg.set(f, e());\n\t\t\tseg.apply(f+1, N, 1);\n\t\t\tin_set_idx.erase(f);\n\t\t\tcnt -= 1;\n\t\t\tin_seg_sum -= A[ord[f]];\n\t\t}\n\t\tll ans = in_seg_sum - ll(cnt) * ll(cnt + 1) / 2;\n\t\tcout << ans << \" \\n\"[i == N-1];\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Monsters  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/112875",
    "editorial": "Continuing on the solution to the easy version: now we have a set of\r\nintegers , we need to add elements into one by one and maintain the\r\nanswer to the problem.Recall that for every , either or . Note that can\r\nonly happen when . Let\u00e2\u0080\u0099s call such an element . If we remove a useless\r\nelement, the answer does not change.If there are no useless elements, we\r\nhave and for : that is, . Thus, the answer to the problem can be easily\r\ncalculated as , where is the current size of the set.We can formulate\r\nthe condition \"there are no useless elements\" as follows. For any , let\r\nbe the number of elements in not exceeding . Then, .On the other hand,\r\nsuppose that for some , we have . Let\u00e2\u0080\u0099s find the smallest such . Then,\r\nwe can see that contains a useless element equal to , and we can safely\r\nremove it.We can check this condition after adding each new element to\r\nusing a segment tree. In every cell of the array maintained by the\r\nsegment tree, we will store the difference . Initially, cell contains\r\nvalue . When a new element appears, we should subtract from all cells in\r\nrange . Then, if a cell with a negative value appears (that is, , which\r\nis equivalent to ), we should find the leftmost such cell and remove an\r\nelement equal to . In particular, we should add to all cells in range\r\n.Thus, we can use a segment tree with \"range add\" and \"global min\". At\r\nmost one useless element can appear every time we enlarge , and if that\r\nhappens, we can identify and remove it in , resulting in an time\r\ncomplexity.\r\n"
}