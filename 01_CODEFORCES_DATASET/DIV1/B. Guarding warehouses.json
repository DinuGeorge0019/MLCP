{"link": "https://codeforces.com//contest/1218/problem/B", "problemId": "412334", "problem_idx": "B", "shortId": "1218B", "contest_number": "1218", "problem_submissions": {"D": [60648151, 60643203, 60647260, 60645392, 60642748], "H": [60644806, 60638524], "E": [60642127, 60641056, 60641513, 60643564, 60648498], "I": [60640334, 60639607, 60640474, 60637390, 60638678], "F": [60638215, 60637531, 60635942, 60636552, 60636479], "C": [60637983, 60674902, 60648025], "B": [60648802], "A": [60645770]}, "name": "B. Guarding warehouses", "statement": "Bob Bubblestrong just got a new job as security guard. Bob is now\r\nresponsible for safety of a collection of warehouses, each containing\r\nthe most valuable Bubble Cup assets - the high-quality bubbles. His task\r\nis to detect thieves inside the warehouses and call the police.Looking\r\nfrom the sky, each warehouse has a shape of a convex polygon. Walls of\r\nno two warehouses intersect, and of course, none of the warehouses is\r\nbuilt inside of another warehouse.Little did the Bubble Cup bosses know\r\nhow lazy Bob is and that he enjoys watching soap operas (he heard they\r\nare full of bubbles) from the coziness of his office. Instead of going\r\nfrom one warehouse to another to check if warehouses are secured, the\r\nplan Bob has is to monitor all the warehouses from the comfort of his\r\noffice using the special X-ray goggles. The goggles have an infinite\r\nrange, so a thief in any of the warehouses could easily be\r\nspotted.However, the goggles promptly broke and the X-rays are now\r\nstrong only enough to let Bob see through a single wall. Now, Bob would\r\nreally appreciate if you could help him find out what is the total area\r\ninside of the warehouses monitored by the broken goggles, so that he\r\ncould know how much area of the warehouses he needs to monitor in\r\nperson.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T, class DUPA> ostream& operator<<(ostream& out, set<T, DUPA> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst LD kEps = 1e-9;\nconst LD kPi = 2 * acos(0);\nLD Sq(LD x) {\n  return x * x;\n}\nstruct Point {\n  LD x, y;\n  Point() {}\n  Point(LD a, LD b) : x(a), y(b) {}\n  Point(const Point& a) : x(a.x), y(a.y) {}\n  void operator=(const Point& a) { x = a.x; y = a.y; }\n  Point operator+(const Point& a) const { Point p(x + a.x, y + a.y); return p; }\n  Point operator-(const Point& a) const { Point p(x - a.x, y - a.y); return p; }\n  Point operator*(LD a) const { Point p(x * a, y * a); return p; }\n  Point operator/(LD a) const { assert(abs(a) > kEps); Point p(x / a, y / a); return p; }\n  Point& operator+=(const Point& a) { x += a.x; y += a.y; return *this; }\n  Point& operator-=(const Point& a) { x -= a.x; y -= a.y; return *this; }\n  Point& operator*=(LD a) { x *= a; y *= a; return *this;}\n  Point& operator/=(LD a) { assert(abs(a) > kEps); x /= a; y /= a; return *this; }\n  \n  bool IsZero() const {\n    return abs(x) < kEps && abs(y) < kEps;\n  }\n  bool operator==(const Point& a) const {\n    return (*this - a).IsZero();\n  }\n  LD CrossProd(const Point& a) const {\n    return x * a.y - y * a.x;\n  }\n  LD CrossProd(Point a, Point b) const {\n    a -= *this;\n    b -= *this;\n    return a.CrossProd(b);\n  }\n  LD DotProd(const Point& a) const {\n    return x * a.x + y * a.y;\n  }\n  LD Norm() const {\n    return sqrt(Sq(x) + Sq(y));\n  }\n  void NormalizeSelf() {\n    *this /= Norm();\n  }\n  Point Normalize() {\n    Point res(*this);\n    res.NormalizeSelf();\n    return res;\n  }\n  LD Dist(const Point& a) const {\n    return (*this - a).Norm();\n  }\n  LD Angle() const {\n    return atan2(y, x);\n  }\n  void RotateSelf(LD angle) {\n    LD c = cos(angle);\n    LD s = sin(angle);\n    LD nx = x * c - y * s;\n    LD ny = y * c + x * s;\n    y = ny;\n    x = nx;\n  }\n  Point Rotate(LD angle) const {\n    Point res(*this);\n    res.RotateSelf(angle);\n    return res;\n  }\n  static bool LexCmp(const Point& a, const Point& b) {\n    if (abs(a.x - b.x) > kEps) {\n      return a.x < b.x;\n    }\n    return a.y < b.y;\n  }\n  LD SqNorm() {\n    return x * x + y * y;\n  }\n  friend ostream& operator<<(ostream& out, Point m);\n};\n\nostream& operator<<(ostream& out, Point p) {\n  out << \"(\" << p.x << \", \" << p.y << \")\";\n  return out;\n}\n\nstruct Circle {\n  Point center;\n  LD r;\n  Circle(LD x, LD y, LD rad) {\n    center = Point(x, y);\n    r = rad;\n  }\n  Circle(const Point& a, LD rad) : center(a), r(rad) {}\n  LD Area() const {\n    return kPi * Sq(r);\n  }\n  LD Perimeter() const {\n    return 2 * kPi * r;\n  }\n  LD Diameter() const {\n    return 2 * r;\n  }\n  Point RotateRightMost(LD ang) const {\n    return center + Point{r * cos(ang), r * sin(ang)};\n  }\n  bool operator==(const Circle& c) const {\n    return center == c.center && abs(r - c.r) < kEps;\n  }\n};\n\nstruct Line {\n  Point p[2];\n  bool is_seg;\n  Line(Point a, Point b, bool is_seg_ = false) {\n    p[0] = a;\n    p[1] = b;\n    is_seg = is_seg_;\n  }\n  Line() {\n  }\n  Point& operator[](int a) {\n    return p[a];\n  }\n  Point NormalVector() {\n    Point perp = p[1] - p[0];\n    perp.RotateSelf(kPi / 2);\n    perp.NormalizeSelf();\n    return perp;\n  }\n  \n  // (A, B, C) such that A^2 + B^2 = 1, (A, B) > (0, 0)\n  vector<LD> LineEqNormLD() { // seems ok\n    LD A = p[1].y - p[0].y;\n    LD B = p[0].x - p[1].x;\n    LD C = -(A * p[0].x + B * p[0].y);\n    assert(abs(A * p[1].x + B * p[1].y + C) < kEps);\n    LD norm = sqrt(Sq(A) + Sq(B));\n    vector<LD> res{A, B, C};\n    for (auto& x : res) { x /= norm; }\n    if (A < -kEps || (abs(A) < kEps && B < -kEps)) {\n      for (auto& x : res) { x *= -1; }\n    }\n    return res;\n  }\n  \n  // assumes that coordinates are integers!\n  vector<int> LineEqNormInt() { // seems ok\n    int A = round(p[1].y - p[0].y);\n    int B = round(p[0].x - p[1].x);\n    int C = -(A * p[0].x + B * p[0].y);\n    int gcd = abs(__gcd(A, __gcd(B, C)));\n    vector<int> res{A, B, C};\n    for (auto& x : res) { x /= gcd; }\n    if (A < 0 || (A == 0 && B < 0)) {\n      for (auto& x : res) { x *= -1; }\n    }\n    return res;\n  }\n};\n\nstruct Utils {\n  // 0, 1, 2 or 3 pts. In case of 3 pts it means they are equal\n  static vector<Point> InterCircleCircle(Circle a, Circle b) {\n    if (a.r + kEps < b.r) {\n      swap(a, b);\n    }\n    if (a == b) {\n      return vector<Point>{a.RotateRightMost(0), a.RotateRightMost(2 * kPi / 3),\n        a.RotateRightMost(4 * kPi / 3)};\n    }\n    Point diff = b.center - a.center;\n    LD dis = diff.Norm();\n    LD ang = diff.Angle();\n    LD longest = max(max(a.r, b.r), dis);\n    LD per = a.r + b.r + dis;\n    if (2 * longest > per + kEps) {\n      return vector<Point>();\n    }\n    if (abs(2 * longest - per) < 2 * kEps) {\n      return vector<Point>{a.RotateRightMost(ang)};\n    }\n    LD ang_dev = acos((Sq(a.r) + Sq(dis) - Sq(b.r)) / (2 * a.r * dis));\n    return vector<Point>{a.RotateRightMost(ang - ang_dev), a.RotateRightMost(ang + ang_dev)};\n  }\n  \n  static vector<Point> InterLineLine(Line a, Line b) { // working fine\n    Point vec_a = a[1] - a[0];\n    Point vec_b1 = b[1] - a[0];\n    Point vec_b0 = b[0] - a[0]; \n    LD tr_area = vec_b1.CrossProd(vec_b0);\n    LD quad_area = vec_b1.CrossProd(vec_a) + vec_a.CrossProd(vec_b0);\n    if (abs(quad_area) < kEps) { // parallel or coinciding\n      if (PtBelongToLine(b, a[0])) {\n        return {a[0], a[1]};\n      } else {\n        return {};\n      }\n    }\n    return {a[0] + vec_a * (tr_area / quad_area)};\n  } \n  \n  static Point ProjPointToLine(Point p, Line l) { ///Tested\n    Point diff = l[1] - l[0];\n    return l[0] + diff * (diff.DotProd(p - l[0]) / diff.DotProd(diff));\n  }\n  \n  static Point ReflectPtWRTLine(Point p, Line l) {\n    Point proj = ProjPointToLine(p, l);\n    return proj * 2 - p;\n  }\n  \n  static vector<Point> InterCircleLine(Circle c, Line l) { /// Tested here: http://codeforces.com/gym/100554/submission/10197624\n    Point proj = ProjPointToLine(c.center, l);\n    LD dis_proj = c.center.Dist(proj);\n    if (dis_proj > c.r + kEps) { return vector<Point>(); }\n    LD a = sqrt(max((LD)0, Sq(c.r) - Sq(dis_proj)));\n    Point dir = l[1] - l[0];\n    LD dir_norm = dir.Norm();\n    vector<Point> cands{proj + dir * (a / dir_norm), proj - dir * (a / dir_norm)};\n    if (cands[0].Dist(cands[1]) < kEps) { return vector<Point>{proj}; }\n    return cands;\n  }\n  \n  static bool PtBelongToLine(Line l, Point p) {\n    return abs(l[0].CrossProd(l[1], p)) < kEps;\n  }\n  \n  static bool PtBelongToSeg(Line l, Point p) { // seems ok\n    return abs(p.Dist(l[0]) + p.Dist(l[1]) - l[0].Dist(l[1])) < kEps;\n  }\n  \n  static vector<Point> InterCircleSeg(Circle c, Line l) { //seems ok\n    vector<Point> from_line = InterCircleLine(c, l);\n    vector<Point> res;\n    for (auto p : from_line) {\n      if (PtBelongToSeg(l, p)) { res.PB(p); }\n    }\n    return res;\n  }\n  \n  static vector<Point> TangencyPtsToCircle(Circle c, Point p) { // seems ok\n    LD d = c.center.Dist(p);\n    if (d < c.r - kEps) { return {}; }\n    if (d < c.r + kEps) { return {p}; }\n    LD from_cent = (p - c.center).Angle();\n    LD ang_dev = acos(c.r / d);\n    return {c.RotateRightMost(from_cent - ang_dev), c.RotateRightMost(from_cent + ang_dev)};\n  }\n  \n  // outer and inner tangents tested only locally (however I believe that rigorously)\n  static vector<Line> OuterTangents(Circle c1, Circle c2) {\n    if (c1 == c2) { return {}; } // is it surely best choice?\n    if (c1.r < c2.r) { swap(c1, c2); }\n    if (c2.r + c1.center.Dist(c2.center) < c1.r - kEps) { return {}; }\n    if (abs(c1.r - c2.r) < kEps) {\n      Point diff = c2.center - c1.center;\n      Point R = diff.Rotate(kPi / 2) * (c1.r / diff.Norm()); \n      return {{c1.center + R, c2.center + R}, {c1.center - R, c2.center - R}};\n    }\n    Point I = c1.center + (c2.center - c1.center) * (c1.r / (c1.r - c2.r)); \n    if (c2.r + c1.center.Dist(c2.center) < c1.r + kEps) {\n      return {{I, I + (c2.center - c1.center).Rotate(kPi / 2)}};\n    }\n    vector<Point> to1 = TangencyPtsToCircle(c1, I);\n    vector<Point> to2 = TangencyPtsToCircle(c2, I);\n    vector<Line> res{{to1[0], to2[0]}, {to1[1], to2[1]}};\n    assert(Utils::PtBelongToLine(res[0], I));\n    assert(Utils::PtBelongToLine(res[1], I));\n    return res;\n  }\n  \n  // unfortunately big part of code is same as in previous function\n  // can be joined when putting appropriate signs in few places\n  // however those ifs differ a bit hence it may not be good idea\n  // to necessarily join them\n  static vector<Line> InnerTangents(Circle c1, Circle c2) {\n    if (c1 == c2) { return {}; } // this time surely best choice\n    if (c1.r < c2.r) { swap(c1, c2); }\n    LD d = c1.center.Dist(c2.center);\n    if (d < c1.r + c2.r - kEps) { return {}; }\n    Point I = c1.center + (c2.center - c1.center) * (c1.r / (c1.r + c2.r));\n    if (d < c1.r + c2.r + kEps) {\n      return {{I, I + (c2.center - c1.center).Rotate(kPi / 2)}};\n    }\n    vector<Point> to1 = TangencyPtsToCircle(c1, I);\n    vector<Point> to2 = TangencyPtsToCircle(c2, I);\n    vector<Line> res{{to1[0], to2[0]}, {to1[1], to2[1]}};\n    assert(Utils::PtBelongToLine(res[0], I));\n    assert(Utils::PtBelongToLine(res[1], I));\n    return res;\n  }\n  \n  static bool AreParallel(Line l1, Line l2) { // seems ok\n    return abs(l1[0].CrossProd(l2[0], l1[1]) - l1[0].CrossProd(l2[1], l1[1])) < kEps;\n  }\n  \n  // returns a vector of points such that their convex hull is intersection of those segments\n  // SZ(res) == 0 => empty intersection, SZ(res) == 1 => intersection is a point, SZ(res) == 2 => intersection is a segment\n  static vector<Point> InterSegs(Line l1, Line l2) { // seems ok\n    if (!Point::LexCmp(l1[0], l1[1])) { swap(l1[0], l1[1]); }\n    if (!Point::LexCmp(l2[0], l2[1])) { swap(l2[0], l2[1]); }\n    if (AreParallel(l1, l2)) {\n      if (!PtBelongToLine(l1, l2[0])) { return vector<Point>(); }\n      vector<Point> ends(2);\n      for (int tr = 0; tr < 2; tr++) {\n        if (Point::LexCmp(l1[tr], l2[tr]) ^ tr) {\n          ends[tr] = l2[tr];\n        } else {\n          ends[tr] = l1[tr];\n        }\n      }\n      if ((ends[1] - ends[0]).IsZero()) {\n        ends.pop_back();\n      }\n      if (SZ(ends) == 2 && Point::LexCmp(ends[1], ends[0])) { return vector<Point>(); }\n      return ends;\n    } else {\n      vector<Point> p = InterLineLine(l1, l2);\n      if (PtBelongToSeg(l1, p[0]) && PtBelongToSeg(l2, p[0])) { return p; }\n      return vector<Point>();\n    }\n  }\n  \n  static LD Angle(Point P, Point Q, Point R) { // angle PQR\n    LD ang2 = (P - Q).Angle();\n    LD ang1 = (R - Q).Angle();\n    LD ans = ang1 - ang2;\n    if (ans < kEps) {\n      ans += 2 * kPi;\n    }\n    return ans;\n  }\n  \n  // tested here: http://codeforces.com/contest/600/submission/14961583\n  // DON'T change anything as this will lead to precision errors\n  // don't know why, but this is the only version which works precisely even for very mean cases\n  static LD DiskInterArea(Circle c1, Circle c2) { // tested here: http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=006254 problem I\n    if (c1.r < c2.r) {\n      swap(c1, c2);\n    }\n    LD d = c1.center.Dist(c2.center);\n    if (c1.r + c2.r < d + kEps) {\n      return 0;\n    }\n    if (c1.r - c2.r > d - kEps) {\n      return kPi * Sq(c2.r);\n    }\n    LD alfa = acos((Sq(d) + Sq(c1.r) - Sq(c2.r)) / (2 * d * c1.r));\n    LD beta = acos((Sq(d) + Sq(c2.r) - Sq(c1.r)) / (2 * d * c2.r));\n    return alfa * Sq(c1.r) + beta * Sq(c2.r) - sin(2 * alfa) * Sq(c1.r) / 2 - sin(2 * beta) * Sq(c2.r) / 2;\n  }\n  \n  static Line RadAxis(Circle c1, Circle c2) {\n    LD d = c1.center.Dist(c2.center);\n    LD a = (Sq(c1.r) - Sq(c2.r) + Sq(d)) / (2 * d);\n    Point Q = c1.center + (c2.center - c1.center) * (a / d);\n    Point R = Q + (c2.center - c1.center).Rotate(kPi / 2);\n    return Line(Q, R);\n  }\n};\n\nstruct Polygon {\n  vector<Point> pts;\n  Polygon(vector<Point> pts_) : pts(pts_) {}\n  Polygon() : Polygon(vector<Point>()) {}\n  void Add(Point p) {\n    pts.push_back(p);\n  }\n  // positive for counterclockwise\n  double Area() {\n    double area = 0;\n    for (int i = 0; i < SZ(pts); i++) {\n      area += pts[i].CrossProd(pts[(i + 1) % SZ(pts)]);\n    }\n    area /= 2;\n    return area;\n  }\n  void OrientCounterclockwise() {\n    if (Area() < 0) {\n      reverse(pts.begin(), pts.end());\n    }\n  }\n  int next(int a) {\n    if (a + 1 < SZ(pts)) {\n      return a + 1;\n    }\n    return 0;\n  }\n  pair<int, int> FurthestPair() { // tested here: http://codeforces.com/contest/333/submission/11058065\n    MakeConvexHull();\n    OrientCounterclockwise();\n    int furth = 1;\n    pair<int, int> best_pair = make_pair(0, 0);\n    double best_dis = 0;\n    for (int i = 0; i < SZ(pts); i++) {\n      Point side = pts[next(i)] - pts[i];\n      while (side.CrossProd(pts[furth] - pts[i]) < side.CrossProd(pts[next(furth)] - pts[i])) {\n        furth = next(furth);\n      }\n      vector<int> vec{i, next(i)};\n      for (auto ind : vec) {\n        if (pts[ind].Dist(pts[furth]) > best_dis) {\n          best_pair = make_pair(ind, furth);\n          best_dis = pts[ind].Dist(pts[furth]);\n        }\n      }\n      cerr<<\"Furthest from: \"<<pts[i]<<\"-\"<<pts[next(i)]<<\" is \"<<pts[furth]<<endl;\n    }\n    return best_pair;\n  }\n  // for square 34 \n  //            12 holds one_way_hull = {{1,3,4},{1,2,4}}\n  // resulting polygon is counterclockwise {1, 2, 4, 3}\n  vector<vector<Point>> MakeConvexHull() { // tested everywhere http://codeforces.com/contest/333/submission/11058065\n    vector<vector<Point>> one_way_hull(2);\n    sort(pts.begin(), pts.end(), Point::LexCmp);\n    for (int dir = -1; dir <= 1; dir += 2) {\n      int hull_num = (dir + 1) / 2;\n      auto& H = one_way_hull[hull_num];\n      one_way_hull[hull_num].push_back(pts[0]);\n      if (SZ(pts) > 1) {\n        H.push_back(pts[1]);\n      }\n      for (int i = 2; i < SZ(pts); i++) {\n        while (SZ(H) >= 2 &&\n          dir * (pts[i] - H[SZ(H) - 2]).CrossProd(H.back() - H[SZ(H) - 2]) > -kEps) {\n          H.pop_back();\n          }\n          H.push_back(pts[i]);\n      }\n      if (SZ(H) > 1 && (H[0] - H.back()).IsZero()) { H.pop_back(); }\n    }\n    pts.clear();\n    for (auto p : one_way_hull[1]) {\n      pts.push_back(p);\n    }\n    for (int i = SZ(one_way_hull[0]) - 2; i >= 1; i--) {\n      pts.push_back(one_way_hull[0][i]);\n    }\n    return one_way_hull;\n  }\n  \n  // without sides\n  vector<vector<bool>> InsideDiagonalsMatrix() { // tested here: http://codeforces.com/contest/438/submission/11063385\n    int n = pts.size();\n    vector<vector<bool>> res(n, vector<bool>(n));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        Line diag(pts[i], pts[j]);\n        if (i == j || abs(i - j) == 1 || abs(i - j) == n - 1) { continue; }\n        res[i][j] = 1;\n        for (int k = 0; k < n; k++) {\n          int kk = next(k);\n          Line side(pts[k], pts[kk]);\n          if (k == i || k == j || kk == i || kk == j) { continue; }\n          vector<Point> inter = Utils::InterSegs(diag, side);\n          if (SZ(inter)) { res[i][j] = 0; }\n        }\n        int act = next(i);\n        LD areas[2] = {0, 0};\n        int passed_j = 0;\n        while (act != i) {\n          passed_j |= (act == j);\n          areas[passed_j] += pts[i].CrossProd(pts[act], pts[next(act)]);\n          act = next(act);\n        }\n        if (areas[0] * areas[1] < kEps) {\n          res[i][j] = 0;\n        }\n      }\n    }\n    return res;\n  }\n  \n  // P needs to be strictly outside polygon \n  // polygon needs to be STRICTLY convex and counterclockwise oriented (as MakeConvexHull does)\n  // returns {L, R} so that PL, PR are tangents and PL is on left\n  vector<Point> Tangents(Point p) { // tested here: https://icpc.kattis.com/problems/spin (1169964)\n    vector<Point> res;\n    REP (tr, 2) {\n      auto GrThan = [&](int fir, int sec) { // fir on sec's left\n        return p.CrossProd(pts[sec], pts[fir]) > kEps;\n      };\n      bool up = false;\n      int cr = 0;\n      if (SZ(pts) >= 2) { cr = p.CrossProd(pts[0], pts[1]); }\n      if (abs(cr) < kEps && SZ(pts) >= 3) { cr = p.CrossProd(pts[0], pts[2]); }\n      up = (cr > 0);\n      VI bd{1, SZ(pts) - 1};\n      int faj = 0;\n      while (bd[0] + 6 <= bd[1]) { // better don't replace with smaller constants\n        VI h(2);\n        REP (hh, 2) { h[hh] = (bd[0] + bd[1] + bd[hh]) / 3; }\n        if (!GrThan(h[up ^ tr], 0) ^ tr) { bd[up ^ tr] = h[up ^ tr]; }\n        else {\n          int gr = GrThan(h[0], h[1]);\n          bd[gr ^ tr] = h[gr ^ tr];\n        }\n      }\n      FOR (i, bd[0], bd[1]) {\n        if (GrThan(i, faj) ^ tr) {\n          faj = i;\n        }\n      }\n      res.PB(pts[faj]);\n    }\n    return res;\n  }\n};\n\nstruct ConvexPolHalves { // tested here: https://icpc.kattis.com/problems/spin (1169964)\n  vector<vector<Point>> chains; // initialized by MakeConvexHull\n  bool BelongTo(Point p) { // including borders\n    if (SZ(chains[0]) == 1) {\n      return (chains[0][0] - p).IsZero();\n    }\n    if (p.x  + kEps < chains[0][0].x || p.x - kEps > chains[0].back().x) { return false; }\n    REP (tr, 2) {\n      int kl = 0, kp = SZ(chains[tr]) - 2, faj = 0;\n      while (kl <= kp) {\n        int aktc = (kl + kp) / 2;\n        if (chains[tr][aktc].x < p.x + kEps) {\n          kl = aktc + 1;\n          faj = aktc;\n        } else {\n          kp = aktc - 1;\n        }\n      }\n      Point fir = chains[tr][faj], sec = chains[tr][faj + 1];\n      if (abs(fir.x - sec.x) < kEps) {\n        if (tr == 0) { if (sec.y + kEps < p.y) { return false; } }\n        else { if (fir.y - kEps > p.y) { return false; } }\n      } else {\n        LD cr = fir.CrossProd(sec, p);\n        if (abs(cr) < kEps) { return true; }\n        if ((cr > 0) ^ tr) { return false; }\n      }\n    }\n    return true;\n  }\n};\n\n// CLIP START\nbool InUpper(Point a) {\n  if (abs(a.y) > kEps) {\n    return a.y > 0;\n  }\n  return a.x > 0;\n}\n\nbool angle_cmp(const Point a, const Point b) {\n  bool u = InUpper(a);\n  bool v = InUpper(b);\n  return u!=v ? u : a.CrossProd(b)>0;\n}\n\n/**\n * @brief a+(b-a)*f \\in c+lin(d-c)\n * @returns f\n */\nLD cross(Point a, Point b, Point c, Point d) {\n  return (d - c).CrossProd(a - c) / (d - c).CrossProd(a - b);\n}\n\nstruct ClipLine { // valid side is on left\n  ClipLine(Point A, Point B) : al(A), bl(B), a(A), b(B) {};\n  Point al,bl; // original line points\n  mutable Point a,b; // actual intersection points\n  Point dir() const { return bl - al; }\n  bool operator<(const ClipLine& l) const { return angle_cmp(dir(),l.dir()); }\n  Point cross(const ClipLine& l) {\n    return al + (bl - al) * ::cross(al, bl, l.al, l.bl);\n  }\n  bool left(Point p) {\n    return (bl - al).CrossProd(p - al) > 0;\n  }\n};\n\n// FIXME WATCH OUT IT DOESN'T WORK IF YOU PUT THE SAME LINE TWICE!!!!\n// To deal with it set<vector<int>> of LineEqNormInt if your\n// points have integer coordinates and don't put line\n// with the same equation twice ot set<vector<LD>> with fancy comparator\n// that compares up to eps tolerance at every coordinate\n// and use LineEqNormLD\n\nstruct Clip {\n  Clip(LD r) : area(4*r*r) {\n    Point a{-r,-r}, b{r,-r}, c{r,r}, d{-r,r};\n    lines = {ClipLine(a,b), ClipLine(b,c), ClipLine(c,d), ClipLine(d,a)};\n  }\n  \n  void insert(Line l) { insert(ClipLine(l[0], l[1])); }\n  \n  void insert(ClipLine l) {\n    assert(abs(l.dir().SqNorm()) > kEps);\n    find(l);\n    while (size() && !l.left(it->a) && !l.left(it->b)) { erase(); }\n    if (size()) {\n      while (prev(), size() && !l.left(it->a) && !l.left(it->b)) { erase(); }\n    }\n    if (size() && (!l.left(it->a) || !l.left(it->b))) {\n      l.a = l.cross(*it);\n      area -= l.a.CrossProd(it->b)*.5; it->b = l.a; next();\n      l.b = l.cross(*it);\n      if ((l.a-l.b).SqNorm() < kEps) {\n        l.b = l.a;\n      }\n      area -= it->a.CrossProd(l.b) * .5;\n      it->a = l.b;\n      if (!(l.a - l.b).IsZero()) {\n        area += l.a.CrossProd(l.b)*.5;\n        lines.insert(l);\n      }\n    }\n    //assert(l.dir().SqNorm()>1e-13);\n  }\n  \n  void find(const ClipLine &l) {\n    it = lines.lower_bound(l);\n    if (it == lines.end()) { it = lines.begin(); }\n  }\n  \n  void recalculate() {\n    area = 0; for (const ClipLine &l : lines) area += l.a.CrossProd(l.b);\n    area *= .5;\n  }\n  \n  int size() { return lines.size(); }\n  void next() { if(++it==lines.end()) it = lines.begin(); }\n  void prev() { if(it==lines.begin()) it = lines.end(); --it; }\n  void erase() {\n    assert(it!=lines.end());\n    area -= it->a.CrossProd(it->b)*.5;\n    it = lines.erase(it);\n    if(it==lines.end()) it = lines.begin();\n  }\n  typename set<ClipLine>::iterator it;\n  set<ClipLine> lines;\n  LD area;\n};\n// CLIP ENDS\n\n// CENTERS BEGIN\nPoint Bary(Point A, Point B, Point C, LD a, LD b, LD c) {\n  return (A * a + B * b + C * c) / (a + b + c);\n}\n\nPoint Centroid(Point A, Point B, Point C) {\n  return Bary(A, B, C, 1, 1, 1);\n}\n\nPoint Circumcenter(Point A, Point B, Point C) {\n  LD a = (B - C).SqNorm(), b = (C - A).SqNorm(), c = (A - B).SqNorm();\n  return Bary(A, B, C, a * (b + c - a), b * (c + a - b), c * (a + b - c));\n}\n\nPoint Incenter(Point A, Point B, Point C) {\n  return Bary(A, B, C, (B - C).Norm(), (A - C).Norm(), (A - B).Norm());\n}\n\nPoint Orthocenter(Point A, Point B, Point C) {\n  LD a = (B - C).SqNorm(), b = (C - A).SqNorm(), c = (A - B).SqNorm();\n  return Bary(A, B, C, (a+b-c)*(c+a-b), (b+c-a)*(a+b-c), (c+a-b)*(b+c-a));\n}\n\nPoint Excenter(Point A, Point B, Point C) { // opposite to A\n  LD a = (B - C).Norm(), b = (A - C).Norm(), c = (A - B).Norm();\n  return Bary(A, B, C, -a, b, c);\n}\n\nconst int N = 1e5 + 5;\nint segs_ends[N][2];\nint is_in[N];\nPoint pts[N];\nbool Cmp(int a, int b) {\n  int ua = InUpper(pts[a]);\n  int ub = InUpper(pts[b]);\n  if (ua != ub) {\n    return ua > ub;\n  }\n  return pts[a].CrossProd(pts[b]) > 0;\n}\nPoint dir;\nPoint orig;\nLD GetDis(int a) {\n  debug(orig, dir, pts[segs_ends[a][0]], pts[segs_ends[a][1]]);\n  Point i1 = Utils::InterLineLine({orig, dir}, {pts[segs_ends[a][0]], pts[segs_ends[a][1]]})[0];\n  return i1.Norm();\n}\nstruct CmpSecik {\n  bool operator() (int a, int b) {\n    if (a == b) { return 0; }\n    LD d1 = GetDis(a);\n    LD d2 = GetDis(b);\n    if (abs(d1 - d2) > kEps) {\n      return d1 < d2;\n    }\n    Point i1 = Utils::InterLineLine({orig, dir}, {pts[segs_ends[a][0]], pts[segs_ends[a][1]]})[0];\n    Point oth_a = pts[segs_ends[a][0]] + pts[segs_ends[a][1]] - i1 * 2;\n    Point oth_b = pts[segs_ends[b][0]] + pts[segs_ends[b][1]] - i1 * 2;\n    if (i1.CrossProd(oth_a) > 0) {\n      return oth_a.CrossProd(oth_b) < 0;\n    } else {\n      return oth_a.CrossProd(oth_b) > 0;\n    }\n  }\n};\nint coll[N];\nLD Area(Point d1, Point d2, int a) {\n  \n  Point i1 = Utils::InterLineLine({orig, d1}, {pts[segs_ends[a][0]], pts[segs_ends[a][1]]})[0];\n  Point i2 = Utils::InterLineLine({orig, d2}, {pts[segs_ends[a][0]], pts[segs_ends[a][1]]})[0];\n  return i1.CrossProd(i2);\n}\nVI wh_segs_adj[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(4);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int ware;\n  cin>>ware;\n  int cur = 0;\n  RE (i, ware) {\n    int c;\n    cin>>c;\n    FOR (j, cur + 1, cur + c - 1) {\n      segs_ends[j][0] = j;\n      segs_ends[j][1] = j + 1;\n    }\n    segs_ends[cur + c][0] = cur + c;\n    segs_ends[cur + c][1] = cur + 1;\n    RE (j, c) {\n      cur++;\n      int x, y;\n      cin>>x>>y;\n      pts[cur] = {(LD)x, (LD)y};\n    }\n  }\n  RE (i, cur) {\n    REP (j, 2) {\n      wh_segs_adj[segs_ends[i][j]].PB(i);\n    }\n  }\n  pts[cur + 1] = {1, 0};\n  VI ord(cur);\n  iota(ALL(ord), 1);\n  sort(ALL(ord), Cmp);\n  VI wh(cur + 2);\n  REP (i, SZ(ord)) {\n    wh[ord[i]] = i;\n  }\n  ord.PB(cur + 1);\n  set<int, CmpSecik> miotelka;\n  dir = {1, 0};\n  RE (i, cur) {\n    int i1 = segs_ends[i][0];\n    int i2 = segs_ends[i][1];\n    LD cr = pts[i1].CrossProd(pts[i2]);\n    if (abs(cr) < kEps) {\n      coll[i] = 1;\n      continue;\n    } else if (cr < 0) {\n      swap(segs_ends[i][0], segs_ends[i][1]);\n    }\n    if (!InUpper(pts[segs_ends[i][0]]) && InUpper(pts[segs_ends[i][1]])) {\n      miotelka.insert(i);\n      is_in[i] = 1;\n    }\n  }\n  debug(miotelka);\n  LD res = 0;\n  for (auto next_dir_ind : ord) {\n    Point next_dir = pts[next_dir_ind];\n    debug(next_dir_ind, next_dir, miotelka);\n    if (abs(dir.CrossProd(next_dir)) > kEps) {\n      assert(SZ(miotelka) % 2 == 0);\n      if (SZ(miotelka) >= 2) {\n        auto it = miotelka.begin();\n        res -= Area(dir, next_dir, *it);\n        res += Area(dir, next_dir, *(next(it)));\n      }\n    }\n    dir = dir + next_dir;\n    VI to_rem, to_ins;\n    for (auto seg : wh_segs_adj[next_dir_ind]) {\n      if (coll[seg]) { continue; }\n      if (is_in[seg]) {\n        to_rem.PB(seg);\n      } else {\n        to_ins.PB(seg);\n      }\n      is_in[seg] ^= 1;\n    }\n    debug(wh_segs_adj[next_dir_ind], to_rem, to_ins);\n    for (auto rem : to_rem) {\n      miotelka.erase(rem);\n    }\n    dir = next_dir;\n    for (auto ins : to_ins) {\n      miotelka.insert(ins);\n    }\n  }\n  cout<<res/2<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "geometry"], "dificulty": "3000", "interactive": false}