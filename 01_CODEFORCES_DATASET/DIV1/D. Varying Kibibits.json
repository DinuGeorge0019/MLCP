{"link": "https://codeforces.com//contest/800/problem/D", "problemId": "103098", "problem_idx": "D", "shortId": "800D", "contest_number": "800", "problem_submissions": {"A": [26437824, 26437413, 26424399, 26417348, 26417549, 26416882, 26417345, 26417672, 26417220, 26417679, 26421663, 26417804, 26418603, 26418392, 26418074, 26417524, 26460923, 26420581, 26435242, 26677047, 26429059], "E": [26433415, 26477309, 26437062, 26436411], "D": [26430216, 26421580, 26427879, 26424854, 26429250, 26431239, 26427030, 26429935, 26430978, 26427918, 26431811, 26431775, 26432322, 26483339, 26483333, 26483260, 26429237, 26433768, 26460903, 26434200, 26431466, 26431322, 26427768], "C": [26426299, 26426474, 26424315, 26429087, 26424916, 26425781, 26430517, 26426280, 26425889, 26430194, 26427437, 26427899, 26428225, 26431339, 26426820, 26427120, 26426356, 26426998, 26421900], "B": [26421783, 26423033, 26420771, 26420198, 26421833, 26421342, 26421711, 26421555, 26422110, 26423813, 26422982, 26422079, 26421473, 26421858, 26421532, 26422706, 26418487, 26420698, 26435223, 26435196, 26435077]}, "name": "D. Varying Kibibits", "statement": "You are given integers . Denote this list of integers as .Let be a\r\nfunction that takes in a non-empty list of integers .The function will\r\noutput another integer as follows: First, all integers in are padded\r\nwith leading zeros so they are all the same length as the maximum length\r\nnumber in . We will construct a string where the -th character is the\r\nminimum of the -th character in padded input numbers. The output is the\r\nnumber representing the string interpreted in base 10. For example , ,\r\n.Define the function Here, denotes a subsequence.In other words, is the\r\nsum of squares of sum of elements of nonempty subsequences of that\r\nevaluate to when plugged into modulo , then multiplied by . The last\r\nmultiplication is not modded. You would like to compute . To reduce the\r\noutput size, print the value , where denotes the bitwise XOR operator.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 1000000;\nconst int M = 6;\n\nconst ll mod = 1000000007;\n\nstruct Input {\n\tint n;\n\tint a[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tll ans;\n\t\n\tvoid write () {\n\t\tcout << ans << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\tint pw[M + 1];\n\t\tll pw2[N + 1];\n\t\tll cnt[N], sum[N], sum2[N];\n\t\tll val[N];\n\t\t\n\t\tvoid solve () {\n\t\t\tpw[0] = 1;\n\t\t\tforn (i, M)  {\n\t\t\t\tpw[i + 1] = pw[i] * 10;\n\t\t\t}\n\t\t\tpw2[0] = 1;\n\t\t\tforn (i, N) {\n\t\t\t\tpw2[i + 1] = pw2[i] * 2 % mod;\n\t\t\t}\n\t\t\tforn (i, n) {\n\t\t\t\t(cnt[a[i]] += 1) %= mod;\n\t\t\t\t(sum[a[i]] += a[i]) %= mod;\n\t\t\t\t(sum2[a[i]] += a[i] * 1ll * a[i]) %= mod;\n\t\t\t}\n\t\t\tforn (i, M) {\n\t\t\t\tford (j, N) {\n\t\t\t\t\tif (j / pw[i] % 10 != 0) {\n\t\t\t\t\t\t(cnt[j - pw[i]] += cnt[j]) %= mod;\n\t\t\t\t\t\t(sum[j - pw[i]] += sum[j]) %= mod;\n\t\t\t\t\t\t(sum2[j - pw[i]] += sum2[j]) %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tforn (i, N) {\n\t\t\t\tif (cnt[i] == 0) {\n\t\t\t\t\tval[i] = 0;\n\t\t\t\t} else if (cnt[i] == 1) {\n\t\t\t\t\tval[i] = sum2[i];\n\t\t\t\t} else {\n\t\t\t\t\tval[i] = (sum[i] * sum[i] + sum2[i]) % mod * pw2[cnt[i] - 2] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(val[N - 1]);\n\t\t\tforn (i, M) {\n\t\t\t\tforn (j, N) {\n\t\t\t\t\tif (j / pw[i] % 10 != 0) {\n\t\t\t\t\t\t(val[j - pw[i]] += mod - val[j]) %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tforn (i, N) {\n\t\t\t\tans ^= val[i] * i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2700", "interactive": false}