{"link": "https://codeforces.com//contest/249/problem/D", "problemId": "2273", "problem_idx": "D", "shortId": "249D", "contest_number": "249", "problem_submissions": {"B": [2649094, 2645222, 2648325, 2645133, 2741637, 2647160, 2646906, 2647140, 2647297, 2647803, 2649557, 2647782, 2649225, 2647984], "C": [2648016, 2646272, 2649752, 2649594, 2648682, 2650241, 2650113], "D": [2646289, 2646128, 2648091, 2747311, 2647914, 2649873, 2686963, 3563620], "A": [2645128, 2644427, 2643471, 2646603, 2643981, 2650080, 2644186, 2645243, 2644193, 2644672, 2644232, 2644059, 2650955, 2650931, 2645477, 2644588, 2644531], "E": [2649181, 2648187, 2749553, 2893989]}, "name": "D. Donkey and Stars", "statement": "In the evenings Donkey would join Shrek to look at the stars. They would\r\nsit on a log, sipping tea and they would watch the starry sky. The sky\r\nhung above the roof, right behind the chimney. Shrek\u2019s stars were to the\r\nright of the chimney and the Donkey\u2019s stars were to the left. Most days\r\nthe Donkey would just count the stars, so he knew that they are exactly\r\n. This time he wanted a challenge. He imagined a coordinate system: he\r\nput the origin of the coordinates at the intersection of the roof and\r\nthe chimney, directed the axis to the left along the roof and the axis\r\nup along the chimney (see figure). The Donkey imagined two rays\r\nemanating from he origin of axes at angles and to the axis. Now he\r\nchooses any star that lies strictly between these rays. After that he\r\nimagines more rays that emanate from this star at the same angles and to\r\nthe axis and chooses another star that lies strictly between the new\r\nrays. He repeats the operation as long as there still are stars he can\r\nchoose between the rays that emanate from a star. As a result, the\r\nDonkey gets a chain of stars. He can consecutively get to each star if\r\nhe acts by the given rules.Your task is to find the maximum number of\r\nstars that the Donkey\u2019s chain can contain.Note that the chain must\r\nnecessarily start in the point of the origin of the axes, that isn\u2019t\r\ntaken into consideration while counting the number of stars in the\r\nchain.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nclass fenv_tree {\n  static int f(int x) { return x & -x; }\n  vi tr;\n  public:\n  fenv_tree(int n) : tr(n + 1, 0) {}\n  int get(int x) {\n    int res = 0;\n    for (x++; x > 0; x -= f(x)) res = max(res, tr[x]);\n    return res;\n  }\n  void update(int x, int val) {\n    for (x++; x < sz(tr); x += f(x)) tr[x] = max(tr[x], val);\n  }\n};\n\nint main() {\n  #ifdef DEBUG\n  freopen(\"std.in\", \"r\", stdin);\n  freopen(\"std.out\", \"w\", stdout);\n  #endif\n\n  int n;\n  int va, vb, vc, vd;\n  while (scanf(\"%d%d/%d%d/%d\", &n, &va, &vb, &vc, &vd) >= 1) {\n    vector<pair<ll, ll> > pts(n);\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      pts[i].first = ll(x) * vc + ll(y) * -vd;\n      pts[i].second = ll(x) * -va + ll(y) * vb;\n    }\n\n    vll ys(n);\n    for (int i = 0; i < n; i++) ys[i] = pts[i].second;\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    for (int i = 0; i < n; i++)\n      pts[i].second = -(lower_bound(ys.begin(), ys.end(), pts[i].second) - ys.begin());\n    sort(pts.begin(), pts.end());\n    for (int i = 0; i < n; i++)\n      pts[i].second = -pts[i].second;\n\n    fenv_tree tr(sz(ys));\n    int ans = 0;\n    for (int i = 0; i < sz(pts); i++) if (pts[i].first > 0 && ys[pts[i].second] > 0) {\n      int cdyn = 1 + tr.get(pts[i].second - 1);\n      ans = max(ans, cdyn);\n      tr.update(pts[i].second, cdyn);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "geometry", "math", "sortings"], "dificulty": "2700", "interactive": false}