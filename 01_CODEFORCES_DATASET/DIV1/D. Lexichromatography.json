{"link": "https://codeforces.com//contest/1876/problem/D", "problemId": "2251948", "problem_idx": "D", "shortId": "1876D", "contest_number": "1876", "problem_submissions": {"F": [227177806, 227207094, 227205539, 227205151], "E": [227157151, 227151734, 227168660, 227172380, 227183052, 227309041, 227308704, 227174767, 227180790, 227181408, 227180728, 227180621, 227182335, 227260713, 227259829, 227186766, 227170474, 227321208, 227261014], "D": [227143743, 227138577, 227308847, 227146942, 227140586, 227141511, 227160448, 227153072, 227151615, 227160275, 227166901, 227141697, 227262091, 227163246, 227151371, 227141424, 227141434, 227152662, 227155489, 227148839, 227151040, 227154461], "C": [227128643, 227130062, 227133604, 227130971, 227129714, 227144982, 227139072, 227133756, 227145578, 227141605, 227156976, 227263099, 227135346, 227132471, 227128506, 227133146, 227135885, 227135604, 227140440, 227137265], "B": [227120010, 227119885, 227123059, 227119488, 227120157, 227125041, 227123945, 227122604, 227124586, 227123169, 227160403, 227263121, 227124143, 227123043, 227120364, 227120185, 227120687, 227125676, 227123006, 227129980, 227122132], "A": [227117267, 227116977, 227118151, 227116487, 227116831, 227118490, 227120408, 227118388, 227121296, 227117209, 227162962, 227263136, 227118862, 227118193, 227117199, 227115769, 227117422, 227121537, 227118512, 227124495, 227116510], "G": [227270487, 229852864, 229527555]}, "name": "D. Lexichromatography", "statement": "Pak Chanek loves his faculty, the Faculty of Computer Science,\r\nUniversity of Indonesia (Fasilkom). He wants to play with the colours of\r\nthe faculty\u2019s logo, blue and red.There is an array a consisting of n\r\nelements, element i has a value of a_i. Pak Chanek wants to colour each\r\nelement in the array blue or red such that these following conditions\r\nare satisfied: If all blue elements are formed into a subsequence^\r\ndagger and so are all the red elements, the blue subsequence is strictly\r\nless than the red subsequence lexicographically^\r\nddagger. Array a does not have that is imbalanced. A subarray is\r\nimbalanced if and only if there is a value k such that the absolute\r\ndifference between the number of blue elements with value k and the\r\nnumber of red elements with value k in this subarray is 2 or more. Note\r\nthat it is possible to colour every element of the array the same\r\ncolour. How many different colourings satisfy all those conditions?\r\nSince the answer can be very big, print the answer modulo 998\r\n,244\r\n,353. Two colourings are different if and only if there is at least one\r\nelement that is blue in one colouring, but red in the other.^\r\ndagger A subsequence of an array is a sequence that can be obtained from\r\nthe array by deleting some elements (possibly none), without changing\r\nthe order of the remaining elements.^\r\nddagger Let p and q be two different sequences. Sequence p is said to be\r\nlexicographically less than sequence q if and only if p is a prefix of q\r\nor there is an index i such that p_j=q_j holds for every 1\r\nleq j<i, and p_i<q_i. In particular, an empty sequence is always\r\nlexicographically less than any non-empty sequence.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst ll o2=(mod+1)/2;\n\nint n;\nint tab[nax];\n\nvi wys[nax];\n\nint ojf[nax];\n\nint fin(int v)\n{\n\tif (v!=ojf[v])\n\t\tojf[v]=fin(ojf[v]);\n\treturn ojf[v];\n}\n\nvoid uni(int a, int b)\n{\n\tojf[fin(a)]=fin(b);\n}\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll losuj()\n{\n\tll ret=0;\n\tfor (int i=0; i<6; i++)\n\t\tret=(ret*1000+(rng()%1000));\n\treturn ret;\n}\n\nll pref[nax];\n\nvoid izi()\n{\n\tll res=o2;\n\tfor (int i=1; i<nax; i++)\n\t\tif (!wys[i].empty())\n\t\t\tres=(res*2)%mod;\n\tprintf(\"%lld\\n\", res);\n\texit(0);\n}\n\nint wlew[nax];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &tab[i]);\n\t\twys[tab[i]].push_back(i);\n\t}\n\tint sameparz=1;\n\tfor (int i=1; i<nax; i++)\n\t\tif (wys[i].size()&1)\n\t\t\tsameparz=0;\n\tif (!sameparz)\n\t\tizi();\n\t\n\tfor (int i=1; i<=n+1; i++)\n\t\twlew[i]=n+1;\n\tfor (int i=1; i<nax; i++)\n\t{\n\t\tif (wys[i].empty())\n\t\t\tcontinue;\n\t\tint r=wys[i].size();\n\t\tfor (int j=0; j<r; j+=2)\n\t\t\twlew[wys[i][j+1]]=wys[i][j];\n\t}\n\tfor (int i=n-1; i; i--)\n\t\twlew[i]=min(wlew[i], wlew[i+1]);\n\tfor (int i=1; i<nax; i++)\n\t{\n\t\tif (wys[i].empty())\n\t\t\tcontinue;\n\t\tint r=wys[i].size();\n\t\tfor (int j=0; j<r; j+=2)\n\t\t\tif (wlew[wys[i][j+1]+1]<wys[i][j])\n\t\t\t\tizi();\n\t}\n\t\n\tfor (int i=1; i<nax; i++)\n\t\tojf[i]=i;\n\tfor (int i=1; i<nax; i++)\n\t{\n\t\tif (wys[i].empty())\n\t\t\tcontinue;\n\t\tint r=wys[i].size();\n\t\tfor (int j=0; j<r; j+=2)\n\t\t{\n\t\t\tll x=losuj();\n\t\t\tpref[wys[i][j]]^=x;\n\t\t\tpref[wys[i][j+1]]^=x;\n\t\t}\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tpref[i+1]^=pref[i];\n\t\tif (pref[i])\n\t\t\tuni(tab[i], tab[i+1]);\n\t}\n\tint ile=0;\n\tfor (int i=1; i<nax; i++)\n\t\tif (!wys[i].empty() && ojf[i]==i)\n\t\t\tile++;\n\tll res=1;\n\tfor (int i=1; i<nax; i++)\n\t\tif (!wys[i].empty())\n\t\t\tres=(res*2)%mod;\n\tll dwa=1;\n\tfor (int i=1; i<=ile; i++)\n\t\tdwa=(dwa*2)%mod;\n\tres-=dwa;\n\tres+=mod;\n\tres%=mod;\n\tres*=o2;\n\tres%=mod;\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dfs and similar", "dsu", "graphs", "two pointers"], "dificulty": "2500", "interactive": false}