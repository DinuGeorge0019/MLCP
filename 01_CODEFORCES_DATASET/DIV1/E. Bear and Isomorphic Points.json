{"link": "https://codeforces.com//contest/790/problem/E", "problemId": "98953", "problem_idx": "E", "shortId": "790E", "contest_number": "790", "problem_submissions": {"D": [25675131, 25621791, 25620770, 25622633, 25623312, 25623816, 25680670, 25648868], "E": [25623895, 26123540, 26123499, 26123493, 26123456, 26123432, 26123251, 25617517], "C": [25613244, 25614979, 25616936, 25615762, 25617856, 25618954, 25661266, 25614888, 25615074, 25614005, 25609588, 25614426, 25615773, 25615586, 25615794, 25615992, 25615935, 25616033], "B": [25609297, 25610960, 25614995, 25612479, 25611945, 25614279, 25608753, 25610247, 25611326, 25609739, 25611787, 25609929, 25612272, 25613816, 25610322, 25610272, 25611239, 25970156, 25970140, 25970114, 25970098, 25969741, 25969717, 25967914, 25967797, 25967715, 25967642, 25967579, 25967531, 25967441, 25967437, 25967418, 25967341, 25628594, 25611848], "A": [25606141, 25607710, 25610915, 25606934, 25606698, 25609653, 25606498, 25607278, 25607609, 25607400, 25613182, 25606914, 25607776, 25606578, 25607601, 25607434, 25608027, 25628141, 25608400]}, "name": "E. Bear and Isomorphic Points", "statement": "Bearland is a big square on the plane. It contains all points with\r\ncoordinates not exceeding by the absolute value.There are houses in\r\nBearland. The -th of them is located at the point . The points are\r\ndistinct, but some subsets of them may be collinear.Bear Limak lives in\r\nthe first house. He wants to destroy his house and build a new one\r\nsomewhere in Bearland.Bears don\u2019t like big changes. For every three\r\npoints (houses) , and , the sign of their cross product should be the\r\nsame before and after the relocation. If it was negative/positive/zero,\r\nit should still be negative/positive/zero respectively. This condition\r\nshould be satisfied for all triples of indices , possibly equal to each\r\nother or different than . Additionally, Limak isn\u2019t allowed to build the\r\nhouse at the point where some other house already exists (but it can be\r\nthe point where his old house was).In the formula above, we define the\r\ndifference and the cross product of points and as: Consider a set of\r\npossible new placements of Limak\u2019s house. Your task is to find the area\r\nof that set of points.Formally, let\u2019s say that Limak chooses the new\r\nplacement randomly (each coordinate is chosen independently uniformly at\r\nrandom from the interval ). Let denote the probability of getting the\r\nallowed placement of new house. Let denote the area of Bearland (). Your\r\ntask is to find .\r\n", "solutions": ["#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-13;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\nstruct point {\n  ld x, y;\n\n  int read() {\n    double x_, y_;\n    if (scanf(\"%lf%lf\", &x_, &y_) < 2) {\n      return 0;\n    }\n    x = x_, y = y_;\n    return 1;\n  }\n\n  point(): x(), y() {}\n  point(ld x, ld y): x(x), y(y) {}\n\n  point operator -(const point & p) const {\n    return point(x - p.x, y - p.y);\n  }\n\n  point operator +(const point & p) const {\n    return point(x + p.x, y + p.y);\n  }\n\n  ld operator *(const point & p) const {\n    return x * p.x + y * p.y;\n  }\n\n  ld operator ^(const point & p) const {\n    return x * p.y - y * p.x;\n  }\n\n  point operator *(const ld & m) const {\n    return point(x * m, y * m);\n  }\n  \n  ld slen() const {\n    return x * x + y * y;\n  }\n\n  ld len() const {\n    return sqrt(slen());\n  }\n\n  point norm() const {\n    ld l = len();\n    assert(l > eps);\n    return point(x / l, y / l);\n  }\n\n  point rot() const {\n    return point(-y, x);\n  }\n\n  bool operator <(const point & p) const {\n    if (abs(x - p.x) > eps) {\n      return x < p.x;\n    }\n    if (abs(y - p.y) > eps) {\n      return y < p.y;\n    }\n    return false;\n  }\n\n  bool operator ==(const point & p) const {\n    return abs(x - p.x) < eps && abs(y - p.y) < eps;\n  }\n\n  int type() const {\n    return y > eps || (y >= -eps && x > eps);\n  }\n};\n\nstruct pointComp {\n  bool operator ()(const point & a, const point & b) {\n    int at = a.type(), bt = b.type();\n    if (at != bt) {\n      return at < bt;\n    }\n    ld prod = a ^ b;\n    if (abs(prod) > eps) {\n      return prod > eps;\n    }\n    return a.slen() < b.slen() - eps;\n  }\n};\n\nstruct line {\n  point o, v;\n\n  line(): o(), v() {}\n  line(const point & a, const point & b) {\n    o = a;\n    v = (b - a).norm();\n  }\n\n  ld dist(const point & p) const {\n    return v ^ (p - o);\n  }\n\n  bool operator <(const line & l) const {\n    if (!(v == l.v)) {\n      return pointComp()(v, l.v);\n    }\n    ld d = dist(l.o);\n    return d < -eps;\n  }\n};\n\n//intersect two lines, assume they do not coincide\nbool intersect(const line & a, const line & b, point & res) { \n  ld coeff = (a.v ^ b.v);\n  if (abs(coeff) < eps) {\n    return false;\n  }\n  ld ka = (b.o ^ b.v) / coeff;\n  ld kb = (a.v ^ a.o) / coeff;\n  res = a.v * ka + b.v * kb;\n\n#ifdef DEBUG\n  assert(abs(a.dist(res)) < eps && abs(b.dist(res)) < eps);\n#endif\n  return true;\n}\n\n\n//a, b, c are on the same line, check if c is in [a,b]\nbool inside(point a, point b, point c) {\n  if (b < a) {\n    swap(a, b);\n  }\n  return !(c < a || b < c);\n}\n\n//intersect [a,b] and [c,d]\n//assume they are not on the same line and have positive length\nbool intersect(point a, point b, point c, point d, point & res) {\n  if (!intersect(line(a, b), line(c, d), res)) {\n    return false;\n  }\n  return inside(a, b, res) && inside(c, d, res);\n}\n\n//intersect line and circle\nbool intersect(line l, point o, ld r, point res[2]) {\n  point n = l.v.rot();\n  ld d = (l.o - o) * n;\n  if (abs(d) > r + eps) {\n    return false;\n  }\n\n  ld x = sqrt(max((ld) 0, r * r - d * d));\n\n  for (int it = 0; it < 2; ++it) {\n    res[it] = o + n * d + l.v * (it ? -x : x);\n  }\n  return true;\n}\n\n//intersect two circles\nbool intersect(point o1, ld r1, point o2, ld r2, point res[2]) {\n  if (r1 < r2 - eps) {\n    swap(o1, o2);\n    swap(r1, r2);\n  }\n  ld d = (o2 - o1).len();\n  if (r1 + r2 < d - eps || r1 - r2 > d + eps) {\n    return false;\n  }\n\n  ld cosa = (r1 * r1 + d * d - r2 * r2) / ((ld) 2 * r1 * d);\n  ld sina = sqrt(max((ld) 0, (ld) 1 - cosa * cosa));\n  point v1 = (o2 - o1).norm() * r1;\n  point v2 = v1.rot();\n\n  for (int it = 0; it < 2; ++it) {\n    res[it] = o1 + v1 * cosa + v2 * (it ? -sina : sina); \n  }\n  return true;\n}\n\nint commonTangents(point o1, ld r1, point o2, ld r2, point *res) {\n  ld d = (o1 - o2).len();\n  if (d < eps) {\n    return 0;\n  }\n  int cnt = 0;\n  for (int i = 0; i < 2; ++i) {\n    ld cosa = (r1 + (i ? -r2 : r2)) / d;\n    if (abs(cosa) < (ld) 1 + eps) {\n      ld sina = sqrt(max((ld) 0, (ld) 1 - cosa * cosa));\n      point v1 = (o2 - o1).norm() * r1;\n      point v2 = v1.rot();\n      for (int it = 0; it < 2; ++it) {\n        res[cnt++] = o1 + v1 * cosa + v2 * (it ? -sina : sina);\n      }\n    }\n  }\n  return cnt;\n}\n\nnamespace Halfplane {\n  const static int maxn = (int) 8e5 + 10;\n  line h[maxn];\n  point p[maxn];\n\n  int intersect(int n, line *_h, point *res) {\n    for (int i = 0; i < n; ++i) {\n      h[i] = _h[i];\n    }\n    static point box[4] = {\n      point(1e6, -1e6),\n      point(1e6, 1e6),\n      point(-1e6, 1e6),\n      point(-1e6, -1e6)\n    };\n    for (int i = 0; i < 4; ++i) {\n      h[n++] = line(box[i], box[(i + 1) % 4]);\n    }\n    sort(h, h + n);\n\n    {\n      int m = 0;\n      for (int i = 0; i < n; ++i) {\n        if (i == 0 || !(h[i].v == h[i - 1].v)) {\n          h[m++] = h[i];\n        }\n      }\n      n = m;\n    }\n\n    int m = 0;\n    int del = 0;\n    for (int i = 1; i < n; ++i) {\n      while (m > del && h[i].dist(p[m - 1]) <= eps) {\n        --m;\n      }\n      while (m > del && h[i].dist(p[del]) <= eps) {\n        ++del;\n      }\n      if (del == m && (h[m].v ^ h[i].v) < eps) {\n        return 0;\n      }\n      point np;\n      assert(intersect(h[i], h[m], np));\n      if (h[del].dist(np) >= -eps) {\n        p[m++] = np;\n        h[m] = h[i];\n      }\n    }\n    rotate(p, p + del, p + m);\n    rotate(h, h + del, h + m + 1);\n    m -= del;\n    if (m == 0) {\n      return 0;\n    }\n\n    point np;\n    assert(intersect(h[0], h[m], np));\n    p[m++] = np;\n    for (int i = 0; i < m; ++i) {\n      res[i] = p[i];\n    }\n    return m;\n  }\n};\n//END ALGO\n\n\nconst int maxn = (int) 2e5 + 10;\npoint ps[maxn];\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    assert(ps[i].read());\n  }\n  return 1;\n}\n\nline ls[maxn * 4];\n\npoint ans[4 * maxn];\n\npoint qs[maxn];\n\nvoid solve() {\n  point p0 = ps[0];\n  for (int i = 0; i < n; ++i) {\n    qs[i] = ps[i] - p0;\n    if (qs[i].type() == 1) {\n      qs[i] = qs[i] * -1;\n    }\n  }\n\n  sort(qs + 1, qs + n, pointComp());\n\n  for (int i = 1; i < n - 1; ++i) {\n    if (qs[i].type() == qs[i + 1].type() && abs(qs[i] ^ qs[i + 1]) <= eps) {\n      printf(\"0\\n\");\n      return;\n    }\n  }\n  for (int i = 1; i < n; ++i) {\n    qs[i - 1] = ps[i] - p0;\n  }\n  --n;\n  sort(qs, qs + n, pointComp());\n\n\n  int cntl = 0;\n  for (int i = 0, j = 0; i < n; ++i) {\n    point p = qs[i];\n\n    if (j == i) {\n      j = (j + 1) % n;\n    }\n\n    while (i != j) {\n      if ((p ^ qs[j]) < 0) {\n        break;\n      }\n      j = (j + 1) % n;\n    }\n\n    for (int it = 0; it < 2; ++it) {\n      int cj = (j + n - it) % n;\n      if (cj == i) {\n        continue;\n      }\n\n      ls[cntl] = line(qs[i] + p0, qs[cj] + p0);\n      if (ls[cntl].dist(p0) < 0) {\n        ls[cntl].v = ls[cntl].v * -1;\n      }\n      ++cntl;\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    ls[cntl] = line(qs[i] + p0, qs[(i + 1) % n] + p0);\n    if (ls[cntl].dist(p0) < 0) {\n      ls[cntl].v = ls[cntl].v * -1;\n    }\n    ++cntl;\n  }\n\n  int got = Halfplane::intersect(cntl, ls, ans);\n  ans[got] = ans[0];\n\n  ld S = 0;\n  for (int i = 0; i < got; ++i) {\n    S += (ans[i] ^ ans[i + 1]);\n  }\n  S /= 2;\n  printf(\"%.18f\\n\", (double) S);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  int t;\n  scanf(\"%d\", &t);\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["geometry"], "dificulty": "3300", "interactive": false}