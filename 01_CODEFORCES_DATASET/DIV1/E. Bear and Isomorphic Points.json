{
    "link": "https://codeforces.com//contest/790/problem/E",
    "problemId": "98953",
    "problem_idx": "E",
    "shortId": "790E",
    "contest_number": "790",
    "problem_submissions": {
        "D": [
            25675131,
            25621791,
            25620770,
            25622633,
            25623312,
            25623816,
            25680670,
            25648868
        ],
        "E": [
            25623895,
            26123540,
            26123499,
            26123493,
            26123456,
            26123432,
            26123251,
            25617517
        ],
        "C": [
            25613244,
            25614979,
            25616936,
            25615762,
            25617856,
            25618954,
            25661266,
            25614888,
            25615074,
            25614005,
            25609588,
            25614426,
            25615773,
            25615586,
            25615794,
            25615992,
            25615935,
            25616033
        ],
        "B": [
            25609297,
            25610960,
            25614995,
            25612479,
            25611945,
            25614279,
            25608753,
            25610247,
            25611326,
            25609739,
            25611787,
            25609929,
            25612272,
            25613816,
            25610322,
            25610272,
            25611239,
            25970156,
            25970140,
            25970114,
            25970098,
            25969741,
            25969717,
            25967914,
            25967797,
            25967715,
            25967642,
            25967579,
            25967531,
            25967441,
            25967437,
            25967418,
            25967341,
            25628594,
            25611848
        ],
        "A": [
            25606141,
            25607710,
            25610915,
            25606934,
            25606698,
            25609653,
            25606498,
            25607278,
            25607609,
            25607400,
            25613182,
            25606914,
            25607776,
            25606578,
            25607601,
            25607434,
            25608027,
            25628141,
            25608400
        ]
    },
    "name": "E. Bear and Isomorphic Points",
    "statement": "Bearland is a big square on the plane. It contains all points with\r\ncoordinates not exceeding by the absolute value.There are houses in\r\nBearland. The -th of them is located at the point . The points are\r\ndistinct, but some subsets of them may be collinear.Bear Limak lives in\r\nthe first house. He wants to destroy his house and build a new one\r\nsomewhere in Bearland.Bears don\u2019t like big changes. For every three\r\npoints (houses) , and , the sign of their cross product should be the\r\nsame before and after the relocation. If it was negative/positive/zero,\r\nit should still be negative/positive/zero respectively. This condition\r\nshould be satisfied for all triples of indices , possibly equal to each\r\nother or different than . Additionally, Limak isn\u2019t allowed to build the\r\nhouse at the point where some other house already exists (but it can be\r\nthe point where his old house was).In the formula above, we define the\r\ndifference and the cross product of points and as: Consider a set of\r\npossible new placements of Limak\u2019s house. Your task is to find the area\r\nof that set of points.Formally, let\u2019s say that Limak chooses the new\r\nplacement randomly (each coordinate is chosen independently uniformly at\r\nrandom from the interval ). Let denote the probability of getting the\r\nallowed placement of new house. Let denote the area of Bearland (). Your\r\ntask is to find .\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-13;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\nstruct point {\n  ld x, y;\n\n  int read() {\n    double x_, y_;\n    if (scanf(\"%lf%lf\", &x_, &y_) < 2) {\n      return 0;\n    }\n    x = x_, y = y_;\n    return 1;\n  }\n\n  point(): x(), y() {}\n  point(ld x, ld y): x(x), y(y) {}\n\n  point operator -(const point & p) const {\n    return point(x - p.x, y - p.y);\n  }\n\n  point operator +(const point & p) const {\n    return point(x + p.x, y + p.y);\n  }\n\n  ld operator *(const point & p) const {\n    return x * p.x + y * p.y;\n  }\n\n  ld operator ^(const point & p) const {\n    return x * p.y - y * p.x;\n  }\n\n  point operator *(const ld & m) const {\n    return point(x * m, y * m);\n  }\n  \n  ld slen() const {\n    return x * x + y * y;\n  }\n\n  ld len() const {\n    return sqrt(slen());\n  }\n\n  point norm() const {\n    ld l = len();\n    assert(l > eps);\n    return point(x / l, y / l);\n  }\n\n  point rot() const {\n    return point(-y, x);\n  }\n\n  bool operator <(const point & p) const {\n    if (abs(x - p.x) > eps) {\n      return x < p.x;\n    }\n    if (abs(y - p.y) > eps) {\n      return y < p.y;\n    }\n    return false;\n  }\n\n  bool operator ==(const point & p) const {\n    return abs(x - p.x) < eps && abs(y - p.y) < eps;\n  }\n\n  int type() const {\n    return y > eps || (y >= -eps && x > eps);\n  }\n};\n\nstruct pointComp {\n  bool operator ()(const point & a, const point & b) {\n    int at = a.type(), bt = b.type();\n    if (at != bt) {\n      return at < bt;\n    }\n    ld prod = a ^ b;\n    if (abs(prod) > eps) {\n      return prod > eps;\n    }\n    return a.slen() < b.slen() - eps;\n  }\n};\n\nstruct line {\n  point o, v;\n\n  line(): o(), v() {}\n  line(const point & a, const point & b) {\n    o = a;\n    v = (b - a).norm();\n  }\n\n  ld dist(const point & p) const {\n    return v ^ (p - o);\n  }\n\n  bool operator <(const line & l) const {\n    if (!(v == l.v)) {\n      return pointComp()(v, l.v);\n    }\n    ld d = dist(l.o);\n    return d < -eps;\n  }\n};\n\n//intersect two lines, assume they do not coincide\nbool intersect(const line & a, const line & b, point & res) { \n  ld coeff = (a.v ^ b.v);\n  if (abs(coeff) < eps) {\n    return false;\n  }\n  ld ka = (b.o ^ b.v) / coeff;\n  ld kb = (a.v ^ a.o) / coeff;\n  res = a.v * ka + b.v * kb;\n\n#ifdef DEBUG\n  assert(abs(a.dist(res)) < eps && abs(b.dist(res)) < eps);\n#endif\n  return true;\n}\n\n\n//a, b, c are on the same line, check if c is in [a,b]\nbool inside(point a, point b, point c) {\n  if (b < a) {\n    swap(a, b);\n  }\n  return !(c < a || b < c);\n}\n\n//intersect [a,b] and [c,d]\n//assume they are not on the same line and have positive length\nbool intersect(point a, point b, point c, point d, point & res) {\n  if (!intersect(line(a, b), line(c, d), res)) {\n    return false;\n  }\n  return inside(a, b, res) && inside(c, d, res);\n}\n\n//intersect line and circle\nbool intersect(line l, point o, ld r, point res[2]) {\n  point n = l.v.rot();\n  ld d = (l.o - o) * n;\n  if (abs(d) > r + eps) {\n    return false;\n  }\n\n  ld x = sqrt(max((ld) 0, r * r - d * d));\n\n  for (int it = 0; it < 2; ++it) {\n    res[it] = o + n * d + l.v * (it ? -x : x);\n  }\n  return true;\n}\n\n//intersect two circles\nbool intersect(point o1, ld r1, point o2, ld r2, point res[2]) {\n  if (r1 < r2 - eps) {\n    swap(o1, o2);\n    swap(r1, r2);\n  }\n  ld d = (o2 - o1).len();\n  if (r1 + r2 < d - eps || r1 - r2 > d + eps) {\n    return false;\n  }\n\n  ld cosa = (r1 * r1 + d * d - r2 * r2) / ((ld) 2 * r1 * d);\n  ld sina = sqrt(max((ld) 0, (ld) 1 - cosa * cosa));\n  point v1 = (o2 - o1).norm() * r1;\n  point v2 = v1.rot();\n\n  for (int it = 0; it < 2; ++it) {\n    res[it] = o1 + v1 * cosa + v2 * (it ? -sina : sina); \n  }\n  return true;\n}\n\nint commonTangents(point o1, ld r1, point o2, ld r2, point *res) {\n  ld d = (o1 - o2).len();\n  if (d < eps) {\n    return 0;\n  }\n  int cnt = 0;\n  for (int i = 0; i < 2; ++i) {\n    ld cosa = (r1 + (i ? -r2 : r2)) / d;\n    if (abs(cosa) < (ld) 1 + eps) {\n      ld sina = sqrt(max((ld) 0, (ld) 1 - cosa * cosa));\n      point v1 = (o2 - o1).norm() * r1;\n      point v2 = v1.rot();\n      for (int it = 0; it < 2; ++it) {\n        res[cnt++] = o1 + v1 * cosa + v2 * (it ? -sina : sina);\n      }\n    }\n  }\n  return cnt;\n}\n\nnamespace Halfplane {\n  const static int maxn = (int) 8e5 + 10;\n  line h[maxn];\n  point p[maxn];\n\n  int intersect(int n, line *_h, point *res) {\n    for (int i = 0; i < n; ++i) {\n      h[i] = _h[i];\n    }\n    static point box[4] = {\n      point(1e6, -1e6),\n      point(1e6, 1e6),\n      point(-1e6, 1e6),\n      point(-1e6, -1e6)\n    };\n    for (int i = 0; i < 4; ++i) {\n      h[n++] = line(box[i], box[(i + 1) % 4]);\n    }\n    sort(h, h + n);\n\n    {\n      int m = 0;\n      for (int i = 0; i < n; ++i) {\n        if (i == 0 || !(h[i].v == h[i - 1].v)) {\n          h[m++] = h[i];\n        }\n      }\n      n = m;\n    }\n\n    int m = 0;\n    int del = 0;\n    for (int i = 1; i < n; ++i) {\n      while (m > del && h[i].dist(p[m - 1]) <= eps) {\n        --m;\n      }\n      while (m > del && h[i].dist(p[del]) <= eps) {\n        ++del;\n      }\n      if (del == m && (h[m].v ^ h[i].v) < eps) {\n        return 0;\n      }\n      point np;\n      assert(intersect(h[i], h[m], np));\n      if (h[del].dist(np) >= -eps) {\n        p[m++] = np;\n        h[m] = h[i];\n      }\n    }\n    rotate(p, p + del, p + m);\n    rotate(h, h + del, h + m + 1);\n    m -= del;\n    if (m == 0) {\n      return 0;\n    }\n\n    point np;\n    assert(intersect(h[0], h[m], np));\n    p[m++] = np;\n    for (int i = 0; i < m; ++i) {\n      res[i] = p[i];\n    }\n    return m;\n  }\n};\n//END ALGO\n\n\nconst int maxn = (int) 2e5 + 10;\npoint ps[maxn];\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    assert(ps[i].read());\n  }\n  return 1;\n}\n\nline ls[maxn * 4];\n\npoint ans[4 * maxn];\n\npoint qs[maxn];\n\nvoid solve() {\n  point p0 = ps[0];\n  for (int i = 0; i < n; ++i) {\n    qs[i] = ps[i] - p0;\n    if (qs[i].type() == 1) {\n      qs[i] = qs[i] * -1;\n    }\n  }\n\n  sort(qs + 1, qs + n, pointComp());\n\n  for (int i = 1; i < n - 1; ++i) {\n    if (qs[i].type() == qs[i + 1].type() && abs(qs[i] ^ qs[i + 1]) <= eps) {\n      printf(\"0\\n\");\n      return;\n    }\n  }\n  for (int i = 1; i < n; ++i) {\n    qs[i - 1] = ps[i] - p0;\n  }\n  --n;\n  sort(qs, qs + n, pointComp());\n\n\n  int cntl = 0;\n  for (int i = 0, j = 0; i < n; ++i) {\n    point p = qs[i];\n\n    if (j == i) {\n      j = (j + 1) % n;\n    }\n\n    while (i != j) {\n      if ((p ^ qs[j]) < 0) {\n        break;\n      }\n      j = (j + 1) % n;\n    }\n\n    for (int it = 0; it < 2; ++it) {\n      int cj = (j + n - it) % n;\n      if (cj == i) {\n        continue;\n      }\n\n      ls[cntl] = line(qs[i] + p0, qs[cj] + p0);\n      if (ls[cntl].dist(p0) < 0) {\n        ls[cntl].v = ls[cntl].v * -1;\n      }\n      ++cntl;\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    ls[cntl] = line(qs[i] + p0, qs[(i + 1) % n] + p0);\n    if (ls[cntl].dist(p0) < 0) {\n      ls[cntl].v = ls[cntl].v * -1;\n    }\n    ++cntl;\n  }\n\n  int got = Halfplane::intersect(cntl, ls, ans);\n  ans[got] = ans[0];\n\n  ld S = 0;\n  for (int i = 0; i < got; ++i) {\n    S += (ans[i] ^ ans[i + 1]);\n  }\n  S /= 2;\n  printf(\"%.18f\\n\", (double) S);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  int t;\n  scanf(\"%d\", &t);\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Bear and Isomorphic Points.json",
    "editorial_link": "https://codeforces.com//blog/entry/51068",
    "editorial": "If p1 is collinear with some two other points, we should print 0. Now let's assume that no two points are collinear with p1.\n\nThe naive solution is to iterate over O(n2) pairs of points. For each pair of points there is a line going through them both, and we know that the new placement of p1 should be on the same side (e.g. on the left) from the line - otherwise the sign of the cross product will change. In other words, the new placement must belong to some halfplane. What we're looking for is the intersection of those O(n2) halfplanes, what can be found in . We should also remember that the new placement must be inside the big square, what can be achieved by adding four halfplanes (each for one side of the square).\n\nIt turns out that it's quite easy to improve the complexity of the naive solution. Let's first sort other n?-?1 points by angle. One way to approach the problem is to think \"we are interested in those new placements that don't affect the sorting of those n?-?1 points\" - this is almost enough to get the intended solution. If sorted (in the clockwise order) points are p2,?p3,?...,?pn, taking into account a halfplane that goes through points pi and pi?+?1 ensures that pi?+?1 is further in the clockwise order than pi (i.e. it is more \"on the right\" if we look from p1). Usually, pi?+?2 is also more \"on the right\" than pi, and so on, till some point pj that is no longer \"on the left\" from pi (if we look from p1). For each i, let's find the first j that pj is \"on the left\" from pi (move indices i and j with two pointers) and then consider a halfplane that goes through pi and pj. To sum up, we consider n halfplanes determined by pairs (pi,?pi?+?1) and n halfplanes determined by pairs (pi,?pj) where pi and pj are almost opposite to each other, with respect to p1. It turns out that this is already a working solution - no other halfplanes are needed. The answer is the intersection of found O(n) halfplanes. Let's prove the correctness.\n\nLet's assume that one of halfplanes (going through some pa and pb) wasn't considered, while it should be because it would affect the answer. And let's say that pb is more \"on the right\" than pa, and a?<?b. If |a?-?b|?=?1, we surely considered that halfplane. Otherwise, if there is some other point with index  such that it is on the proper side of the line (pa,?pb), i.e. on the same side as p1, halfplanes determined by pairs (a,?m) and (m,?b) completely cover that (a,?b) halfplane. Here we must use induction: if each halfplane determined by a pair (a,?b) for smaller value of b?-?a is either taken or covered by some other taken halfplanes, then also halfplanes with greater differences b?-?a will be considered (remember that we assumed that there is some other points with index  such that ...).\n\nThe case analysed above is shown on the drawing below. Let R denote the red point. If halfplanes (pa,?R) and (R,?pb) are considered (or from induction they are covered by something else), we don't need considering (pa,?pb).\n\n\nWhat remains is the case when a?+?1???b and each point with index in [a?+?1,?b?-?1] is on the line (pa,?pb) or on the wrong side (not the same as p1). It quite easily implies that our line is already covered everywhere except for the segment (pa,?pb), see the drawing:\n\n\nNow we should take a look at points pb?+?1,?pb?+?2,?.... If one of them pk is on the wrong side of the line (pa,?pb) (i.e. on the side different than p1), the halfplane (pk?-?1,?pk) covers our segment (pa,?pb) and we are done. Otherwise, all those points are on the proper side (the same as p1). Eventually one of them will be the last one that is \"on the right\" from pa and let's remember that we consider halfplanes determined by such pairs (earlier denoted as pi and pj). Since that point is on the proper side of the line (pa,?pb), the segment is covered:"
}