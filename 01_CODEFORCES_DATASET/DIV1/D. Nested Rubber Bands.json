{"link": "https://codeforces.com//contest/1338/problem/D", "problemId": "590534", "problem_idx": "D", "shortId": "1338D", "contest_number": "1338", "problem_submissions": {"E": [76397300, 76619327, 76403815, 76434529, 76434479, 76434133, 76434078, 76433920, 76433813, 76433749, 76433522, 76432895, 76432405, 76433003, 76432715, 76492191, 76458850, 77714923, 76416304, 78374239, 105958584], "D": [76383105, 76378423, 76373799, 76372283, 76380290, 76721483, 76721183, 76718097, 76716953, 76379002, 76377538, 76378427, 76454507, 76377531, 76381613, 76384929, 76380304, 76384800, 76387623, 76383511, 76383924, 76389002, 76385003, 76379777, 76361072], "C": [76355433, 76365439, 76355356, 76357185, 76342857, 77464916, 77464536, 76797866, 76793425, 76363706, 76354913, 76352467, 76454469, 76364453, 76361606, 76365484, 76367936, 76362206, 76361479, 76370442, 76369319, 76368001, 76372720, 76355615, 76385066], "B": [76346805, 76342391, 76342822, 76343816, 76355163, 77465740, 76793469, 76348894, 76346501, 76359563, 76454438, 76345410, 76341218, 76346125, 76349446, 76346871, 76343626, 76346043, 76350035, 76345138, 76349598, 76348838, 76367005], "A": [76334223, 76335060, 76334379, 76334482, 76348815, 76334952, 76364133, 76339027, 76454272, 76334304, 76334154, 76336649, 76334438, 76334441, 76334773, 76334264, 76337258, 76335486, 76337735, 76341537, 76369906]}, "name": "D. Nested Rubber Bands", "statement": "You have a tree of n vertices. You are going to convert this tree into n\r\nrubber bands on infinitely large plane. Conversion rule follows: For\r\nevery pair of vertices a and b, rubber bands a and b should intersect if\r\nand only if there is an edge exists between a and b in the tree. Shape\r\nof rubber bands must be a simple loop. In other words, rubber band is a\r\nloop which doesn\u2019t self-intersect. Now let\u2019s define following things:\r\nRubber band a rubber band b, if and only if rubber band b is in rubber\r\nband a\u2019s area, and they don\u2019t intersect each other. Sequence of rubber\r\nbands a_{1}, a_{2},\r\nldots, a_{k} (k\r\nge 2) are , if and only if for all i (2\r\nle i\r\nle k), a_{i-1} includes a_{i}. This is an example of conversion. Note\r\nthat rubber bands 5 and 6 are nested. It can be proved that is it\r\npossible to make a conversion and sequence of nested rubber bands under\r\ngiven constraints.What is the maximum length of sequence of nested\r\nrubber bands can be obtained from given tree? Find and print it.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 12.04.2020 18:15:51       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> take(n);\n  vector<int> nope(n);\n  int ans = 0;\n  function<void(int, int)> Dfs = [&](int v, int pr) {\n    vector<int> children;\n    for (int u : g[v]) {\n      if (u == pr) {\n        continue;\n      }\n      Dfs(u, v);\n      children.push_back(u);\n    }\n    {\n      take[v] = 0;\n      for (int u : children) {\n        take[v] = max(take[v], nope[u]);\n      }\n      take[v] += 1;\n    }\n    {\n      nope[v] = 0;\n      for (int u : children) {\n        nope[v] = max(nope[v], max(nope[u], take[u]));\n      }\n      nope[v] += (int) g[v].size() - 2;\n    }\n    {\n      int m1 = 0, m2 = 0;\n      for (int u : children) {\n        if (nope[u] > m1) {\n          m2 = m1;\n          m1 = nope[u];\n        } else {\n          m2 = max(m2, nope[u]);\n        }\n      }\n      ans = max(ans, m1 + m2 + 1);\n    }\n    {\n      int m1 = 0, m2 = 0;\n      for (int u : children) {\n        int cur = max(nope[u], take[u]);\n        if (cur > m1) {\n          m2 = m1;\n          m1 = cur;\n        } else {\n          m2 = max(m2, cur);\n        }\n      }\n      ans = max(ans, m1 + m2 + (int) g[v].size() - 2);\n    }\n  };\n  Dfs(0, -1);\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "dp", "math", "trees"], "dificulty": "2700", "interactive": false}