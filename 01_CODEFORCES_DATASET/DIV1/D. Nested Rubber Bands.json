{
    "link": "https://codeforces.com//contest/1338/problem/D",
    "problemId": "590534",
    "problem_idx": "D",
    "shortId": "1338D",
    "contest_number": "1338",
    "problem_submissions": {
        "E": [
            76397300,
            76619327,
            76403815,
            76434529,
            76434479,
            76434133,
            76434078,
            76433920,
            76433813,
            76433749,
            76433522,
            76432895,
            76432405,
            76433003,
            76432715,
            76492191,
            76458850,
            77714923,
            76416304,
            78374239,
            105958584
        ],
        "D": [
            76383105,
            76378423,
            76373799,
            76372283,
            76380290,
            76721483,
            76721183,
            76718097,
            76716953,
            76379002,
            76377538,
            76378427,
            76454507,
            76377531,
            76381613,
            76384929,
            76380304,
            76384800,
            76387623,
            76383511,
            76383924,
            76389002,
            76385003,
            76379777,
            76361072
        ],
        "C": [
            76355433,
            76365439,
            76355356,
            76357185,
            76342857,
            77464916,
            77464536,
            76797866,
            76793425,
            76363706,
            76354913,
            76352467,
            76454469,
            76364453,
            76361606,
            76365484,
            76367936,
            76362206,
            76361479,
            76370442,
            76369319,
            76368001,
            76372720,
            76355615,
            76385066
        ],
        "B": [
            76346805,
            76342391,
            76342822,
            76343816,
            76355163,
            77465740,
            76793469,
            76348894,
            76346501,
            76359563,
            76454438,
            76345410,
            76341218,
            76346125,
            76349446,
            76346871,
            76343626,
            76346043,
            76350035,
            76345138,
            76349598,
            76348838,
            76367005
        ],
        "A": [
            76334223,
            76335060,
            76334379,
            76334482,
            76348815,
            76334952,
            76364133,
            76339027,
            76454272,
            76334304,
            76334154,
            76336649,
            76334438,
            76334441,
            76334773,
            76334264,
            76337258,
            76335486,
            76337735,
            76341537,
            76369906
        ]
    },
    "name": "D. Nested Rubber Bands",
    "statement": "You have a tree of n vertices. You are going to convert this tree into n\r\nrubber bands on infinitely large plane. Conversion rule follows: For\r\nevery pair of vertices a and b, rubber bands a and b should intersect if\r\nand only if there is an edge exists between a and b in the tree. Shape\r\nof rubber bands must be a simple loop. In other words, rubber band is a\r\nloop which doesn\u2019t self-intersect. Now let\u2019s define following things:\r\nRubber band a rubber band b, if and only if rubber band b is in rubber\r\nband a\u2019s area, and they don\u2019t intersect each other. Sequence of rubber\r\nbands a_{1}, a_{2},\r\nldots, a_{k} (k\r\nge 2) are , if and only if for all i (2\r\nle i\r\nle k), a_{i-1} includes a_{i}. This is an example of conversion. Note\r\nthat rubber bands 5 and 6 are nested. It can be proved that is it\r\npossible to make a conversion and sequence of nested rubber bands under\r\ngiven constraints.What is the maximum length of sequence of nested\r\nrubber bands can be obtained from given tree? Find and print it.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 12.04.2020 18:15:51       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> take(n);\n  vector<int> nope(n);\n  int ans = 0;\n  function<void(int, int)> Dfs = [&](int v, int pr) {\n    vector<int> children;\n    for (int u : g[v]) {\n      if (u == pr) {\n        continue;\n      }\n      Dfs(u, v);\n      children.push_back(u);\n    }\n    {\n      take[v] = 0;\n      for (int u : children) {\n        take[v] = max(take[v], nope[u]);\n      }\n      take[v] += 1;\n    }\n    {\n      nope[v] = 0;\n      for (int u : children) {\n        nope[v] = max(nope[v], max(nope[u], take[u]));\n      }\n      nope[v] += (int) g[v].size() - 2;\n    }\n    {\n      int m1 = 0, m2 = 0;\n      for (int u : children) {\n        if (nope[u] > m1) {\n          m2 = m1;\n          m1 = nope[u];\n        } else {\n          m2 = max(m2, nope[u]);\n        }\n      }\n      ans = max(ans, m1 + m2 + 1);\n    }\n    {\n      int m1 = 0, m2 = 0;\n      for (int u : children) {\n        int cur = max(nope[u], take[u]);\n        if (cur > m1) {\n          m2 = m1;\n          m1 = cur;\n        } else {\n          m2 = max(m2, cur);\n        }\n      }\n      ans = max(ans, m1 + m2 + (int) g[v].size() - 2);\n    }\n  };\n  Dfs(0, -1);\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "math",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Nested Rubber Bands.json",
    "editorial_link": "https://codeforces.com//blog/entry/75913",
    "editorial": ". You have to generate optimal sequence which is subsequence of path\r\nbetween some two vertices. Neighbors of vertices in optimal sequence\r\nwill be used as nested rubber bands. This is an example of conversion.\r\nRed vertices are picked sequence, and blue vertices are neighbor of red\r\nvertices which are used as nested rubber bands. The reason why black\r\nvertices can\u00e2\u0080\u0099t be used as nested rubber bands is, basically you have to\r\nmake a tunnel between any two blue lines, but it\u00e2\u0080\u0099s impossible, because\r\nin each tunnel there is at least one red vertex which blocks complete\r\nconnection on tunnel.Also, this can be described as finding maximum\r\nindependent set on subtree, which consists of vertices which has at most\r\ndistance from the optimal path connection of red vertices. Now your goal\r\nis to maximize number of blue vertices.. The distances between two\r\nadjacent red vertices are at most . Adjacent in this sentence means\r\nadjacent elements in generated optimal sequence. Because if there is\r\nsome unused It is always optimal to take more red vertices than\r\nabandoning black vertices. Note that if there are two black vertices\r\nbetween two red vertices, then we cannot use both of them as blue\r\nvertices.From those two observations, construct tree DP and run for it.\r\nTime complexity is .\r\n"
}