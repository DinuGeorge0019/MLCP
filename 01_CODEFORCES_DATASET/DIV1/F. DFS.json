{
    "link": "https://codeforces.com//contest/1074/problem/F",
    "problemId": "249091",
    "problem_idx": "F",
    "shortId": "1074F",
    "contest_number": "1074",
    "problem_submissions": {
        "E": [
            45303620,
            45300249,
            45344571,
            45304718,
            45304862,
            45306309,
            45306510,
            45315681,
            45302002,
            45303642
        ],
        "F": [
            45297925,
            45302412,
            45298748,
            45300083,
            45299480,
            45298818,
            45299827,
            45300561,
            45300985,
            45300910,
            45302087,
            45302359,
            45302549,
            45302342,
            45306149,
            45302208,
            45303449,
            45304102,
            45303226
        ],
        "D": [
            45294973,
            45293128,
            45295261,
            45296109,
            45292313,
            45291734,
            45297119,
            45297694,
            45297259,
            45298710,
            45297635,
            45297369,
            45298399,
            45297846,
            45294290,
            45297091,
            45296770,
            45296596,
            45297365,
            45299859
        ],
        "C": [
            45293553,
            45291475,
            45293844,
            45294044,
            45293914,
            45294012,
            45293608,
            45295772,
            45294886,
            45297284,
            45296110,
            45294396,
            45293720,
            45296080,
            45292596,
            45294430,
            45294994,
            45295210,
            45294620,
            45296058
        ],
        "B": [
            45292377,
            45294890,
            45292284,
            45297195,
            45296274,
            45295787,
            45291944,
            45293450,
            45293244,
            45294291,
            45295233,
            45293263,
            45291573,
            45294870,
            45303353,
            45293540,
            45298407,
            45293034,
            45292582,
            45292571
        ],
        "A": [
            45289520,
            45289825,
            45289616,
            45289578,
            45294985,
            45294783,
            45289998,
            45290374,
            45289949,
            45291060,
            45291837,
            45290090,
            45295330,
            45290627,
            45290102,
            45291029,
            45290582,
            45297889,
            45289941,
            45289786
        ]
    },
    "name": "F. DFS",
    "statement": "Let T be a tree on n vertices. Consider a graph G_0, initially equal to\r\nT. You are given a sequence of q updates, where the i-th update is given\r\nas a pair of two distinct integers u_i and v_i. For every i from 1 to q,\r\nwe define the graph G_i as follows: If G_{i-1} contains an edge\r\n{u_i, v_i\r\n}, then remove this edge to form G_i. Otherwise, add this edge to\r\nG_{i-1} to form G_i. Formally, G_i := G_{i-1}\r\ntriangle\r\n{\r\n{u_i, v_i\r\n}\r\n} where\r\ntriangle denotes the set symmetric difference. Furthermore, it is\r\nguaranteed that T is always a subgraph of G_i. In other words, an update\r\nnever removes an edge of T.Consider a connected graph H and run a\r\ndepth-first search on it. One can see that the tree edges (i.e. the\r\nedges leading to a not yet visited vertex at the time of traversal) form\r\na spanning tree of the graph H. This spanning tree is not generally\r\nfixed for a particular graph it depends on the starting vertex, and on\r\nthe order in which the neighbors of each vertex are traversed. We call\r\nvertex w if one can order the neighbors of each vertex in such a way\r\nthat the depth-first search started from w produces T as the spanning\r\ntree. For every i from 1 to q, find and report the number of good\r\nvertices.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1100*1007;\nconst int n1=(1<<18);\n\nint n, q;\nvi graf[nax];\n\nvector <int> drz[nax];\nint roz[nax], jump[nax], pre[nax], post[nax], fad[nax];\nint l;\n\nvoid dfs_roz(int v)\n{\n\troz[v]=1;\n\tfor (int &i : drz[v])\n\t{\n\t\tfad[i]=v;\n\t\tdfs_roz(i);\n\t\troz[v]+=roz[i];\n\t\tif (roz[i]>roz[drz[v][0]])\n\t\t\tswap(i, drz[v][0]);\n\t}\n}\n\nvoid dfs_pre(int v)\n{\n\tif (!jump[v])\n\t\tjump[v]=v;\n\tl++;\n\tpre[v]=l;\n\tif (!drz[v].empty())\n\t\tjump[drz[v][0]]=jump[v];\n\tfor (int i : drz[v])\n\t\tdfs_pre(i);\n\tpost[v]=l;\n}\n\nint lca(int v, int u)\n{\n\twhile(jump[v]!=jump[u])\n\t{\n\t\tif (pre[v]<pre[u])\n\t\t\tswap(v, u);\n\t\tv=fad[jump[v]];\n\t}\n\treturn (pre[v]<pre[u] ? v : u);\n}\n\nvector < pair <int,int> > path_up(int v, int u)\n{\n\tvector < pair <int,int> > ret;\n\twhile(jump[v]!=jump[u])\n\t{\n\t\tret.push_back({pre[jump[v]], pre[v]});\n\t\tv=fad[jump[v]];\n\t}\n\tret.push_back({pre[u], pre[v]});\n\treturn ret;\n}\n\nvector < pair <int,int> > get_path(int v, int u)\n{\n\tint w=lca(v, u);\n\tauto ret=path_up(v, w);\n\tauto pom=path_up(u, w);\n\tfor (auto &i : ret)\n\t\tswap(i.first, i.second);\n\twhile(!pom.empty())\n\t{\n\t\tret.push_back(pom.back());\n\t\tpom.pop_back();\n\t}\n\treturn ret;\n}\n\nint odl[nax];\nvi jumpp[nax];\n\nvoid dfs1(int v, int oj)\n{\n\tjumpp[v].push_back(oj);\n\twhile(jumpp[v].back())\n\t{\n\t\tint p1=jumpp[v].back();\n\t\tint p2=min(jumpp[v].size(), jumpp[p1].size())-1;\n\t\tjumpp[v].push_back(jumpp[p1][p2]);\n\t}\n\tfor (int i : graf[v])\n\t{\n\t\tif (i!=oj)\n\t\t{\n\t\t\todl[i]=odl[v]+1;\n\t\t\tdrz[v].push_back(i);\n\t\t\tdfs1(i, v);\n\t\t}\n\t}\n}\n\nint skocz(int v, int ile)\n{\n\tfor (int i=0; (1<<i)<=ile; i++)\n\t\tif (ile&(1<<i))\n\t\t\tv=jumpp[v][i];\n\treturn v;\n}\n\nint dod[nax];\npii maxi[nax];\n\npii lacz(pii a, pii b)\n{\n\tif (a.first==b.first)\n\t\treturn {a.first, a.second+b.second};\n\treturn max(a, b);\n}\n\npii daj(int v)\n{\n\treturn {dod[v]+maxi[v].first, maxi[v].second};\n}\n\nvoid upd(int v)\n{\n\tmaxi[v]=lacz(daj(v*2), daj(v*2+1));\n}\n\nvoid pisz(int v, int a, int b, int graa, int grab, int w)\n{\n\t//~ if (v==1)\n\t\t//~ debug() << \"pisze \" << graa << \" \" << grab << \"  \" << w;\n\tif (a>=graa && b<=grab)\n\t{\n\t\tdod[v]+=w;\n\t\treturn;\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn;\n\t}\n\tpisz((v<<1), a, (a+b)>>1, graa, grab, w);\n\tpisz((v<<1)^1, (a+b+2)>>1, b, graa, grab, w);\n\tupd(v);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\todl[1]=1;\n\tdfs1(1, 0);\n\tdfs_roz(1);\n\tdfs_pre(1);\n\tset <pii> jest;\n\tfor (int i=1; i<=n; i++)\n\t\tmaxi[i+n1-1]={0, 1};\n\tfor (int i=n1-1; i; i--)\n\t\tupd(i);\n\tpisz(1, 1, n1, n+1, n1, -1);\n\twhile(q--)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tif (a>b)\n\t\t\tswap(a, b);\n\t\tint w;\n\t\tif (jest.count({a, b}))\n\t\t{\n\t\t\tw=-1;\n\t\t\tjest.erase({a, b});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tw=1;\n\t\t\tjest.insert({a, b});\n\t\t}\n\t\tint l=lca(a, b);\n\t\t//~ debug() << a << \" \" << b << \" \" << l;\n\t\tif (a!=l && b!=l)\n\t\t{\n\t\t\tpisz(1, 1, n1, pre[a], post[a], w);\n\t\t\tpisz(1, 1, n1, pre[b], post[b], w);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (l==b)\n\t\t\t\tswap(a, b);\n\t\t\tpisz(1, 1, n1, 1, n, w);\n\t\t\tint p=skocz(b, odl[b]-odl[a]-1);\n\t\t\tpisz(1, 1, n1, pre[p], post[p], -w);\n\t\t\tpisz(1, 1, n1, pre[b], post[b], w);\n\t\t}\n\t\tpii v=daj(1);\n\t\tif (v.first!=(int)jest.size())\n\t\t\tv.second=0;\n\t\t//~ debug() << v;\n\t\tprintf(\"%d\\n\", v.second);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. DFS.json",
    "editorial_link": "https://codeforces.com//blog/entry/62985",
    "editorial": "Letâs consider an arbitrary run of DFS producing some tree. Letâs root\r\nthe tree at the starting vertex. It can be shown that on a directed\r\ngraph, there are only two types of edges. The first are the tree edges\r\n(those are the ones that are used to visit a new vertex). The second are\r\nedges which, upon being traversed, lead to a vertex that was already\r\nvisited. It can be shown that, in the rooted tree, those edges always\r\nconnect a vertex with one of its ancestors. In other words, all the\r\nedges that are dynamically added to the tree must connect a vertex with\r\none of their ancestors. This means that the staring vertex must not lie\r\non the path connecting the two endpoints of such edge, or any of the\r\nvertices in some of the subtrees. For instance, on the second sample,\r\nthe edge disallows the vertex from being the starting vertex, as it lies\r\non the path from to , and also vertex .Each edge thus forbids a certain\r\nset of vertices from being the starting point. This yields a\r\nstraightforward solution. To optimize it further, we can root the tree\r\narbitrarily and renumber the vertices using their DFS visit times. When\r\nwe do this, we notice that the set of a forbidden vertices for each edge\r\nis a union of at most three intervals of vertices. This lets us build an\r\nsolution using a segment tree. The operation is add a constant on\r\ninterval, and then find the minimum on interval and the number of\r\noccurrences of said minimum. We add to forbid a vertex because of an\r\nedge, subtract to revert that when the edge is subsequently removed. The\r\nanswer is the number of minimums on the whole tree if that minimum is ,\r\nand otherwise.\r\n",
    "hint": []
}