{
    "link": "https://codeforces.com//contest/453/problem/E",
    "problemId": "11937",
    "problem_idx": "E",
    "shortId": "453E",
    "contest_number": "453",
    "problem_submissions": {
        "D": [
            7318525,
            7321381,
            7319937,
            7313076,
            7316122,
            11122936
        ],
        "C": [
            7314789,
            7312823,
            7323051,
            7318282,
            7319034,
            7312696,
            7313901,
            7313477,
            7314695,
            7314310,
            7314103,
            7314216,
            7311079,
            7314796,
            7314374,
            7314951,
            7314159,
            7314941
        ],
        "B": [
            7311773,
            7310412,
            7316305,
            7319850,
            7314250,
            7310826,
            7311570,
            7321252,
            7320392,
            7320316,
            7312680,
            7310934,
            7311494,
            7312013,
            7315911,
            7311404,
            7312306,
            7313238,
            7312326,
            7313318
        ],
        "A": [
            7308671,
            7308664,
            7309073,
            7318976,
            7309345,
            7308656,
            7308757,
            7321161,
            7309462,
            7308797,
            7309148,
            7308775,
            7313516,
            7309054,
            7309188,
            7308988,
            7311729,
            7309495
        ],
        "E": [
            7318455,
            7321485,
            7325631,
            7343757
        ]
    },
    "name": "E. Little Pony and Lord Tirek",
    "statement": "Lord Tirek is a centaur and the main antagonist in the season four\r\nfinale episodes in the series \"My Little Pony: Friendship Is Magic\". In\r\n\"Twilight’s Kingdom\" (Part 1), Tirek escapes from Tartarus and drains\r\nmagic from ponies to grow stronger. The core skill of Tirek is called\r\nAbsorb Mana. It takes all mana from a magic creature and gives them to\r\nthe caster.Now to simplify the problem, assume you have ponies (numbered\r\nfrom 1 to ). Each pony has three attributes: : amount of mana that the\r\npony has at time 0; : maximum mana that the pony can have; : mana\r\nregeneration per unit time. Lord Tirek will do instructions, each of\r\nthem can be described with three integers: . The instruction means that\r\nat time , Tirek will use Absorb Mana on ponies with numbers from to\r\n(both borders inclusive). We’ll give you all the instructions in order,\r\ncount how much mana Tirek absorbs for each instruction.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nstruct inode {\n\tint lastUsed;\n};\n\nconst int BT = 131072;\n\ninode itree[BT*2];\n\nint s[100003],maxmana[100003],regen[100003];\n\nlong long ans[100003];\nint ansi;\n\nstruct adjust\n{\n\tint regen; // regen time\n\tint ansIndex;\n\tint l;\n\tint r;\n};\n\ninline bool sf(const adjust &a, const adjust &b) {\n\treturn a.regen < b.regen;\n}\n\nvector<adjust> events;\n\nvoid updateTree(int ind, int l, int r, int ql, int qr, int t, bool needUpdate = true) {\n\tif (r < ql || l > qr) return;\n\tint m = (l+r+1)>>1;\n\tif (ql <= l && r <= qr) {\n\t\tif (itree[ind].lastUsed < 0) {\n\t\t\tif (ind >= BT) {\n\t\t\t\tans[ansi] += min(s[ind-BT] + regen[ind-BT] * (long long)t, (long long)maxmana[ind-BT]);\n\t\t\t} else {\n\t\t\t\tupdateTree(ind<<1, l, m-1, ql, qr, t, false);\n\t\t\t\tupdateTree((ind<<1)+1, m, r, ql, qr, t, false);\n\t\t\t}\n\t\t} else {\n\t\t\tadjust adj;\n\t\t\tadj.regen = t - itree[ind].lastUsed;\n\t\t\tadj.ansIndex = ansi;\n\t\t\tadj.l = l;\n\t\t\tadj.r = r;\n\t\t\tevents.push_back(adj);\n\t\t}\n\t\tif (needUpdate) {\n\t\t\titree[ind].lastUsed = t;\n\t\t}\n\t\treturn;\n\t}\n\tif (itree[ind].lastUsed >= 0) {\n\t\titree[ind<<1].lastUsed = itree[ind].lastUsed;\n\t\titree[(ind<<1)+1].lastUsed = itree[ind].lastUsed;\n\t\titree[ind].lastUsed = -1;\n\t}\n\tupdateTree(ind<<1, l, m-1, ql, qr, t, needUpdate);\n\tupdateTree((ind<<1)+1, m, r, ql, qr, t, needUpdate);\n}\n\nstruct inode2 {\n\tlong long bcnt;\n\tlong long bsum;\n} itree2[BT*2];\n\nvoid update2(int p, long long regenrate, long long val) {\n\tp += BT;\n\twhile(p) {\n\t\titree2[p].bcnt -= regenrate;\n\t\titree2[p].bsum += val;\n\t\tp >>= 1;\n\t}\n}\n\npair<long long, long long> getBounded(int l, int r) {\n\tlong long cnt = 0;\n\tlong long sum = 0;\n\tl += BT;\n\tr += BT;\n\twhile(l <= r) {\n\t\tif (l&1){\n\t\t\tcnt += itree2[l].bcnt;\n\t\t\tsum += itree2[l].bsum;\n\t\t}\n\t\tif (!(r&1)){\n\t\t\tcnt += itree2[r].bcnt;\n\t\t\tsum += itree2[r].bsum;\n\t\t}\n\t\tl = (l+1)>>1;\n\t\tr = (r-1)>>1;\n\t}\n\treturn make_pair(cnt, sum);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d\",&s[i],&maxmana[i],&regen[i]);\n\t}\n\tfor(int i = 0; i < BT*2; i++) {\n\t\titree[i].lastUsed = -2;\n\t}\n\tint m;\n\tscanf(\"%d\",&m);\n\tfor(int i = 0; i < m; i++) {\n\t\tint t,l,r;\n\t\tscanf(\"%d%d%d\",&t,&l,&r);\n\t\tl--,r--;\n\t\tansi = i;\n\t\tupdateTree(1,0,BT-1,l,r,t);\n\t}\n\tsort(events.begin(),events.end(),sf);\n\tvector<pair<int,int>> ponyMaxReach;\n\tfor(int i = 0; i < n; i++) {\n\t\tif (regen[i] != 0) {\n\t\t\tponyMaxReach.emplace_back((maxmana[i]+regen[i]-1) / regen[i], i);\n\t\t}\n\t\titree2[i+BT].bcnt = regen[i];\n\t}\n\tfor(int i = BT-1; i >= 1; i--) {\n\t\titree2[i].bcnt = itree2[i<<1].bcnt + itree2[(i<<1)+1].bcnt;\n\t}\n\tsort(ponyMaxReach.begin(),ponyMaxReach.end());\n\tfor(int i = 0, j = 0; i < events.size(); i++) {\n\t\tfor(;j < ponyMaxReach.size() && ponyMaxReach[j].first <= events[i].regen;j++) {\n\t\t\tint ponyInd = ponyMaxReach[j].second;\n\t\t\tupdate2(ponyInd, regen[ponyInd], maxmana[ponyInd]);\n\t\t}\n\t\tauto res = getBounded(events[i].l, events[i].r);\n\t\tans[events[i].ansIndex] += res.first * events[i].regen + res.second;\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Little Pony and Lord Tirek.json",
    "editorial_link": "https://codeforces.com//blog/entry/13190",
    "editorial": "Brief description:\nn ponies (from 1 to n) in a line, each pony has:\n\nsi: the start mana.\nmi: the maximum mana.\nri: mana regeneration per unit time.\nAlso, you have m operations called Absorb Mana t l r. For each operations, at time t, count how many mana from l to r. After that, reset each pony's mana to 0.\n\nAnalysis:\nKey Observation\nThe income of a operation, is only relevant with the previous operation. In other words, what we focus on is the difference time between adjacent operations.\n\nWeaken the problem\nLet us assume si?=?0 and ri?=?1 at the beginning to avoid disrupting when we try to find the main direction of the algorithm. Also it will be much easier if the problem only ask the sum of all query. One of the accepted method is following:\n\nFirstly, for each operation (t, l, r), we split it into a insert event on l, and a delete event r?+?1. Secondly, we use scanning from left to right to accumulate the contributions of each pony.\n\nIn order to do that, you need a balanced tree to maintenance the difference time between adjacent operations, and a second balanced tree to maintenance some kind of prefixes sum according to those \"difference\".\n\nThe first balanced tree could been implemented by STL::SET. For each operation, you need only constant insert and delete operations on those balanced tree, thus the overall complexity is O(nlogn).\n\nGeneral solution\nInstead of scanning, now we use a balanced tree to maintenance the intervals which have same previous operation time and use a functional interval tree to maintenance those ponies. For each operation, we use binary search on the first balanced tree, and query on the second balanced tree. Thus the overall complexity is O(nlog2n).",
    "hint": []
}