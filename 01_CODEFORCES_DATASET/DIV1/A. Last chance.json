{"link": "https://codeforces.com//contest/1045/problem/A", "problemId": "223463", "problem_idx": "A", "shortId": "1045A", "contest_number": "1045", "problem_submissions": {"E": [43261410, 43577517], "J": [43258702, 43260133, 43575980, 43263093, 43266033], "A": [43255060, 43256216, 43263322, 43263783, 43258806, 43275613], "D": [43251490, 43264794, 43257475, 43253807, 43257410, 43253327, 43248880], "C": [43250229, 43244156, 43255852, 43252661, 43258515, 43251235, 43259397], "G": [43247867, 43248087, 43251069, 43250948, 43255077, 43249900, 43251360], "H": [43246289, 43252595, 43260022, 43258468, 43261064, 43264435, 43263084], "B": [43243648, 43248788, 43247063, 43264324, 43264189, 43246587, 43256450, 43248333, 43254638], "I": [43243009, 43244706, 43243112, 43242671, 43255452, 43243089, 43243594], "F": [43577952]}, "name": "A. Last chance", "statement": "It is the year 2969. 1000 years have passed from the moon landing.\r\nMeanwhile, the humanity colonized the Hyperspace and lived in\r\nharmony.Until we realized that we were not alone.Not too far away from\r\nthe Earth, the massive fleet of aliens\u2019 spaceships is preparing to\r\nattack the Earth. For the first time in a while, the humanity is in real\r\ndanger. Crisis and panic are everywhere. The scientists from all around\r\nthe solar system have met and discussed the possible solutions. However,\r\nno progress has been made.The Earth\u2019s last hope is YOU!Fortunately, the\r\nEarth is equipped with very powerful defense systems made by MDCS. There\r\nare N aliens\u2019 spaceships which form the line. The defense system\r\nconsists of three types of weapons: SQL rockets every SQL rocket can\r\ndestroy at most one spaceship in the given set. Cognition beams every\r\nCognition beam has an interval [l,r] and can destroy at most one\r\nspaceship in that interval. OMG bazooka every OMG bazooka has three\r\npossible targets, however, each bazooka can destroy either zero or\r\nexactly two spaceships. In addition, due to the smart targeting system,\r\nthe sets of the three possible targets of any two different OMG bazookas\r\nare disjoint (that means that every ship is targeted with at most one\r\nOMG bazooka). Your task is to make a plan of the attack which will\r\ndestroy the largest possible number of spaceships. Every destroyed\r\nspaceship should be destroyed with exactly one weapon.\r\n", "solutions": ["#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n\ntemplate<typename T>\nstruct Dinic {\n\tconst T INF = 1e9;\n\tconst int INF1 = 1e9;\n\tstruct edge {\n\t\tint a, b;\n\t\tT f, c;\n\t};\n\tint s, t;\n\tvector<edge> ed;\n\tint n;\n\tvector<vector<int> > eds;\n\tvector<T> dd;\n\tvector<int> pp;\n\tvector<int> inCut;\n\tDinic(int N, int S, int TT) {\n\t\tn = N, s = S, t = TT;\n\t\teds.clear();\n\t\tdd.clear();\n\t\tpp.clear();\n\t\ted.clear();\n\t\teds.resize(n);\n\t\tdd.resize(n);\n\t\tpp.resize(n);\n\t\tinCut.clear();\n\t}\n\tvoid add_edge(int a, int b, T c) {\n\t\tedge x;\n\t\tx.a = a;\n\t\tx.b = b;\n\t\tx.f = 0;\n\t\tx.c = c;\n\t\teds[a].push_back(ed.size());\n\t\teds[b].push_back(ed.size() + 1);\n\t\ted.push_back(x);\n\t\tx.c = 0;\n\t\tswap(x.a, x.b);\n\t\ted.push_back(x);\n\t}\n\tT dfs(int v, T fl) {\n\t\tif (v == t)\n\t\t\treturn fl;\n\t\tif (dd[v] == dd[t])\n\t\t\treturn 0;\n\t\tT sum = 0;\n\t\tfor (; pp[v] < (int)eds[v].size(); ++pp[v]) {\n\t\t\tint e = eds[v][pp[v]];\n\t\t\tint u = ed[e].b;\n\t\t\tT fr = ed[e].c - ed[e].f;\n\t\t\tif (fr == 0 || dd[u] != dd[v] + 1 || pp[u] == (int)eds[u].size())\n\t\t\t\tcontinue;\n\t\t\tfr = dfs(u, min(fl, fr));\n\t\t\ted[e].f += fr;\n\t\t\ted[e ^ 1].f -= fr;\n\t\t\tsum += fr;\n\t\t\tfl -= fr;\n\t\t\tif (fl == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn sum;\n\t}\n\tT flow() {\n\t\tT sum = 0;\n\t\tT lst = 0;\n\t\tdo {\n\t\t\tlst = 0;\n\t\t\tfill(dd.begin(), dd.end(), INF1);\n\t\t\tdd[s] = 0;\n\t\t\tqueue<int> qu;\n\t\t\tqu.push(s);\n\t\t\twhile (!qu.empty()) {\n\t\t\t\tint x = qu.front();\n\t\t\t\tqu.pop();\n\t\t\t\tfor (int i = 0; i < (int)eds[x].size(); ++i) {\n\t\t\t\t\tif (ed[eds[x][i]].f < ed[eds[x][i]].c) {\n\t\t\t\t\t\tint u = ed[eds[x][i]].b;\n\t\t\t\t\t\tif (dd[u] > dd[x] + 1)\n\t\t\t\t\t\t\tdd[u] = dd[x] + 1, qu.push(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dd[t] == INF)\n\t\t\t\tbreak;\n\t\t\tfill(pp.begin(), pp.end(), 0);\n\t\t\tlst = dfs(s, INF);\n\t\t\tsum += lst;\n\t\t} while (lst);\n\t\treturn sum;\n\t}\n\tvoid dfs1(int s) {\n\t\tpp[s] = 1;\n\t\tfor (int e: eds[s]) {\n\t\t\tif (ed[e].c != ed[e].f && !pp[ed[e].b])\n\t\t\t\tdfs1(ed[e].b);\n\t\t}\n\t}\n\tvoid markCut() {\n\t\tinCut.resize(ed.size());\n\t\tfill(pp.begin(), pp.end(), 0);\n\t\tdfs1(s);\n\t\tfor (int i = 0; i < ed.size(); ++i)\n\t\t\tif (pp[ed[i].a] && !pp[ed[i].b])\n\t\t\t\tinCut[i] = 1;\n\t\t\telse\n\t\t\t\tinCut[i] = 0;\n\t}\n\tvector<int> st;\n\tint dfs2(int v) {\n\t\tst.push_back(v);\n\t\tif (v == t)\n\t\t\treturn 1;\n\t\tfor (int e: eds[v]) {\n\t\t\tif (ed[e].f > 0) {\n\t\t\t\t--ed[e].f;\n\t\t\t\tdfs2(ed[e].b);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvector<vector<int>> dec() {\n\t\tvector<vector<int>> now;\n\t\twhile (true) {\n\t\t\tst.clear();\n\t\t\tif (dfs2(s)) {\n\t\t\t\tnow.push_back(st);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\treturn now;\n\t}\n};\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int MAXN = 5100;\n\nint n, m;\nvector<int> go[MAXN];\nint l[MAXN];\nint r[MAXN];\nint tp[MAXN];\nint cc;\nint gg[MAXN * 4];\n\nvoid build(int v, int tl, int tr) {\n\tif (tl + 1 == tr) {\n\t\tgg[v] = n + tl;\n\t\treturn;\n\t}\n\tint m = (tl + tr) >> 1;\n\tgg[v] = cc++;\n\tbuild(v * 2 + 1, tl, m);\n\tbuild(v * 2 + 2, m, tr);\n}\nint s, t;\n\nint fl[MAXN];\nvoid build2(int v, int tl, int tr, Dinic<int> &cur) {\n\tif (tl + 1 == tr) {\n\t\tif (!fl[tl]) {\n\t\t\tcur.add_edge(gg[v], t, 1);\n\t\t}\n\t\treturn;\n\t}\n\tint m = (tl + tr) >> 1;\n\tcur.add_edge(gg[v], gg[v * 2 + 1], MAXN);\n\tcur.add_edge(gg[v], gg[v * 2 + 2], MAXN);\n\tbuild2(v * 2 + 1, tl, m, cur);\n\tbuild2(v * 2 + 2, m, tr, cur);\n}\n\nvoid add(int v, int tl, int tr, int l, int r, int k, Dinic<int> &cur) {\n\tif (r <= tl || tr <= l)\n\t\treturn;\n\tif (l <= tl && tr <= r) {\n\t\tcur.add_edge(k, gg[v], 1);\n\t\treturn;\n\t}\n\tint m = (tl + tr) >> 1;\n\tadd(v * 2 + 1, tl, m, l, r, k, cur);\n\tadd(v * 2 + 2, m, tr, l, r, k, cur);\n}\nint kl[MAXN];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> m;\n\tcc = n + m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint t;\n\t\tcin >> t;\n\t\ttp[i] = t;\n\t\tif (t == 0) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\t--x;\n\t\t\t\tgo[i].push_back(x);\n\t\t\t}\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tcin >> l[i] >> r[i];\n\t\t\t--l[i];\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\t--x;\n\t\t\t\tgo[i].push_back(x);\n\t\t\t\tfl[x] = 1;\n\t\t\t}\n\t\t\t++cc;\n\t\t}\n\t}\n\tbuild(0, 0, m);\n\ts = cc;\n\tt = cc + 1;\n\tDinic<int> cur(cc + 2, s, t);\n\tbuild2(0, 0, m, cur);\n\tint nw = n + m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (tp[i] == 0) {\n\t\t\tcur.add_edge(s, i, 1);\n\t\t\tfor (int j: go[i])\n\t\t\t\tcur.add_edge(i, n + j, 1);\n\t\t}\n\t\telse if (tp[i] == 1) {\n\t\t\tcur.add_edge(s, i, 1);\n\t\t\tadd(0, 0, m, l[i], r[i], i, cur);\n\t\t}\n\t\telse {\n\t\t\tcur.add_edge(nw, t, 1);\n\t\t\tfor (int j = 0; j < 3; ++j)\n\t\t\t\tcur.add_edge(n + go[i][j], nw, 1);\n\t\t\t++nw;\n\t\t}\n\t}\n\tcur.flow();\n\tvector<vector<int>> tmp = cur.dec();\n\tvector<pair<int, int>> ans;\n\tfor (int i = 0; i < tmp.size(); ++i) {\n\t\tint x = tmp[i][1];\n\t\tint y = tmp[i][tmp[i].size() - 2] - n;\n\t\tif (y >= m)\n\t\t\ty = tmp[i][tmp[i].size() - 3] - n;\n\t\tans.emplace_back(x, y);\n\t\tkl[y] = 1;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (tp[i] == 2) {\n\t\t\tint fr = 2;\n\t\t\tfor (int j: go[i])\n\t\t\t\tif (!kl[j] && fr)\n\t\t\t\t\tans.emplace_back(i, j), --fr;\n\t\t}\n\t}\n\tcout << ans.size() << \"\\n\";\n\tfor (int i = 0; i < ans.size(); ++i)\n\t\tcout << ans[i].first + 1 << \" \" << ans[i].second + 1 << \"\\n\";\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["data structures", "flows", "graph matchings", "graphs", "trees"], "dificulty": "2500", "interactive": false}