{
    "link": "https://codeforces.com//contest/685/problem/E",
    "problemId": "63496",
    "problem_idx": "E",
    "shortId": "685E",
    "contest_number": "685",
    "problem_submissions": {
        "D": [
            18684968,
            18683037,
            18681924,
            18684130,
            18684858,
            18675255,
            18679526,
            18679808,
            18682052,
            18681014,
            18682178,
            18675901,
            18679039,
            18766980,
            18685989,
            18678764,
            18679061
        ],
        "E": [
            18680021,
            18684845,
            18678334,
            18685890,
            18682877,
            18680554,
            18681882,
            18681692,
            18684390,
            18678520,
            18684936,
            18720222,
            18691735,
            18673504,
            18680472,
            18683676
        ],
        "C": [
            18677291,
            18679523,
            18681119,
            18679602,
            18685346,
            19679131,
            18684317,
            18682713,
            18688360
        ],
        "B": [
            18672960,
            18674692,
            18671800,
            18672771,
            18680872,
            18678053,
            18673109,
            18673699,
            18678361,
            18684612,
            18675812,
            18678146,
            19679139,
            19641621,
            18676260,
            18675658,
            18675674,
            18671554,
            18673419,
            18674754,
            18676154
        ],
        "A": [
            18671402,
            18670567,
            18669065,
            18670159,
            18670329,
            18681950,
            18668946,
            18671121,
            18669783,
            18686475,
            18678918,
            18676980,
            19641683,
            18673416,
            18767003,
            18671711,
            18682810,
            18674563,
            18668359,
            18672213
        ]
    },
    "name": "E. Travelling Through the Snow Queen s Kingdom",
    "statement": "Gerda is travelling to the palace of the Snow Queen.The road network\r\nconsists of intersections and bidirectional roads. Roads are numbered\r\nfrom to . Snow Queen put a powerful spell on the roads to change the\r\nweather conditions there. Now, if Gerda steps on the road at the moment\r\nof time less or equal to , she will leave the road exactly at the moment\r\n. In case she steps on the road at the moment of time greater than , she\r\nstays there forever.Gerda starts at the moment of time at the\r\nintersection number and goes to the palace of the Snow Queen, located at\r\nthe intersection number . Moreover, she has to be there at the moment\r\n(or earlier), before the arrival of the Queen.Given the description of\r\nthe road network, determine for queries , , and if itâ€™s possible for\r\nGerda to get to the palace on time.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n    #define lld \"%I64d\"\n#else\n    #define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\nint n,m,q;\nint u[222222],v[222222];\nstruct quer{\n\tint l,r,s,t;\n\tint id;\n\tvoid read(){\n\t\tgn(l);gn(r);gn(s);gn(t);\n\t}\n}que[222222];\nint ans[222222];\nint cmp(const quer&a,const quer&b){\n\treturn a.l<b.l;\n}\nint f[1005][1005];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tfil(f,63);\n\tgn(n);gn(m);gn(q);\n\trep(i,1,m+1)gn(u[i]),gn(v[i]);\n\trep(i,1,q+1){\n\t\tque[i].read();\n\t\tque[i].id=i;\n\t}\n\tsort(que+1,que+1+q,cmp);\n\tint cur=q;\n\tfor (int i=m;i>=1;i--){\n\t\tint u=::u[i],v=::v[i];\n\t\tf[u][v]=f[v][u]=i;\n\t\tfor (int t=1;t<=n;t++)\n\t\t\tif(f[u][t]<f[v][t])f[v][t]=f[u][t];\n\t\t\telse f[u][t]=f[v][t];\n\t\twhile(cur>=1 && que[cur].l==i)ans[que[cur].id]=f[que[cur].s][que[cur].t]<=que[cur].r,cur--;\n\t}\n\trep(i,1,q+1)if(ans[i])printf(\"Yes\\n\");else printf(\"No\\n\");\n\n\t\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "divide and conquer",
        "graphs"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Travelling Through the Snow Queen s Kingdom.json",
    "editorial_link": "https://codeforces.com//blog/entry/45558",
    "editorial": "We propose following solution:\nLet's solve task with divide & conquer. At first let's lift l to the first index, where s was mentioned And lower the r to the last index, where t was mentioned. This will not affect answers, but will make implementation much more easy.\n\nLet's look on all queries. For each query consider it's location relative to centre of edges array. If it's stricly on the left half or on the right half, then solve recursively (You need to implement function like solve(requests,?l,?r)).\n\nHow to answer on query, if it contains the centre? Let's precalculate two dp's:\n\ndpr[i]?=? bitset of vertices you can from to the vi or ui with l?=?m and r?=?i.\n\ndpl[i]?=? bitset of vertices you can go to starting from vi or ui with l?=?i and r?=?m?-?1\n\nvi and ui are vertices of i'th edge.\n\nUsing this dp the answer is yes if and ony if dpl[l][u]?=?true and dpr[r][u]?=?true for some u.\n\nAll above can be implemented using bitwise operations.\nSo the time is ",
    "hint": []
}