{
    "link": "https://codeforces.com//contest/555/problem/B",
    "problemId": "30420",
    "problem_idx": "B",
    "shortId": "555B",
    "contest_number": "555",
    "problem_submissions": {
        "E": [
            11801002,
            11802846,
            11800102,
            11803583,
            11800123,
            11802210,
            11798298,
            11804601,
            11804794,
            11814374,
            11814369,
            11812993,
            11798643,
            11801381,
            11801970,
            11807078,
            11805652,
            11807059,
            11806770
        ],
        "D": [
            11798292,
            11797684,
            11802341,
            11798935,
            11804707,
            11798722,
            11803791,
            11799483,
            11805705,
            11790452,
            11894849,
            11797513,
            11795485,
            11794677,
            11798421
        ],
        "B": [
            11793605,
            11787993,
            11791939,
            11792335,
            11794935,
            17186416,
            11790076,
            11792803,
            11790163,
            11791786,
            11798665,
            11793439,
            11790680,
            11788414,
            11791421,
            11789757
        ],
        "A": [
            11791498,
            11789364,
            11789864,
            11794544,
            11805322,
            17186185,
            11803610,
            11791903,
            11786622,
            11787094,
            11786902,
            11800059,
            11789582,
            11786965,
            11790812,
            11786427,
            11786182
        ],
        "C": [
            11790530,
            11794079,
            11795417,
            11789940,
            11791044,
            11793448,
            11793773,
            11801897,
            11796749,
            11801939,
            11797130,
            11796059,
            11798373,
            11795041,
            11798751,
            11798577,
            11794820
        ]
    },
    "name": "B. Case of Fugitive",
    "statement": "Andrewid the Android is a galaxy-famous detective. He is now chasing a\r\ncriminal hiding on the planet Oxa-5, the planet almost fully covered\r\nwith water.The only dry land there is an archipelago of narrow islands\r\nlocated in a row. For more comfort let\u2019s represent them as\r\nnon-intersecting segments on a straight line: island has coordinates ,\r\nbesides, for .To reach the goal, Andrewid needs to place a bridge\r\nbetween each pair of islands. A bridge of length can be placed between\r\nthe -th and the -th islads, if there are such coordinates of and , that\r\n, and . The detective was supplied with bridges, each bridge can be used\r\nat most once. Help him determine whether the bridges he got are enough\r\nto connect each pair of adjacent islands.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\nconst int MAX = 200005;\npair<long long, long long> a[MAX], p[MAX];\npair<pair<long long, long long>, int> seg[MAX];\nbool cmp(pair<pair<long long, long long>, int> a, pair<pair<long long, long long>, int> b)\n{\n\tif (a.first.second != b.first.second)\n\t\treturn (a.first.second < b.first.second);\n\tif (a.first.first != b.first.first)\n\t\treturn (a.first.first < b.first.first);\n\treturn (a.second < b.second);\n}\nint ans[MAX];\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i].first >> a[i].second;\n\tn--;\n\tfor (int i = 0; i < n; i++)\n\t\tseg[i] = make_pair(make_pair(a[i + 1].first - a[i].second, a[i + 1].second - a[i].first), i);\n\tsort(seg, seg + n, cmp);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> p[i].first;\n\t\tp[i].second = i;\n\t}\n\tsort(p, p + m);\n\tset<pair<long long, int> > s;\n\tint ptr = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\twhile (ptr < m && p[ptr].first <= seg[i].first.second)\n\t\t\ts.insert(p[ptr++]);\n\t\tset<pair<long long, int> >::iterator it = s.lower_bound(make_pair(seg[i].first.first, -1));\n\t\tif (it == s.end())\n\t\t{\n\t\t\tcout << \"No\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tans[seg[i].second] = it->second;\n\t\ts.erase(it);\n\t}\n\tcout << \"Yes\\n\";\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] + 1 << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Case of Fugitive.json",
    "editorial_link": "https://codeforces.com//blog/entry/18919",
    "editorial": "We can put a bridge between bridges and if its length lies in the\r\nsegment . Now we have a well-known problem: there are segments and\r\npoints on a plane, for every segment we need to assign a point which\r\nlies in it to this segment and every point can be assigned only once.\r\nLet\u00e2\u0080\u0099s call a segment open if no point is assigned to it. Let\u00e2\u0080\u0099s go\r\nthrough all points from left to right and at every moment keep all open\r\nsegments that contain current point in a BST (std::set). When processing\r\na point it should be assigned to the segment (from our set) that has the\r\nleftmost right end. This algorithm will find the answer if there is one.\r\nSuppose this solution is wrong and suppose there is a solution in which\r\npoint is assigned to another open segment (there\u00e2\u0080\u0099s no sense in skipping\r\nthis point). Then some point is assigned to the segment which was\r\nassigned to. is to the right of so we can swap them and come to our\r\nanswer again. Time: ; solution.\r\n"
}