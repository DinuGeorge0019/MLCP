{
    "link": "https://codeforces.com//contest/1801/problem/F",
    "problemId": "1817549",
    "problem_idx": "F",
    "shortId": "1801F",
    "contest_number": "1801",
    "problem_submissions": {
        "G": [
            203657914,
            201155712,
            196755049,
            196760812,
            203134482
        ],
        "E": [
            196675152,
            196635209,
            196644302,
            196640748,
            196641519,
            196635379,
            196630013,
            196657513,
            196650893,
            196653405,
            196644576,
            196654360,
            196640172,
            196683603,
            196680417,
            196653431,
            196644218,
            196626389,
            199502352,
            199501873,
            199501660,
            199501455,
            199501378,
            199501277,
            199501214,
            199501173,
            199500937,
            199500810,
            196645808,
            196668272,
            196658312,
            196656102,
            196652330
        ],
        "F": [
            196622978,
            196623206,
            196631833,
            196626066,
            196642170,
            196635485,
            196619644,
            196630879,
            196631678,
            196626069,
            196641735,
            196624132,
            196623158,
            196622410,
            196637181,
            196627815,
            196619025,
            196627461,
            196633301,
            196628988
        ],
        "D": [
            196614757,
            196616104,
            196610930,
            196615603,
            196617463,
            196615380,
            196614983,
            196615414,
            196624090,
            196611332,
            196624396,
            196619261,
            196612951,
            196616838,
            196613243,
            196620716,
            196612736,
            196620435,
            196615283,
            196621604
        ],
        "C": [
            196609472,
            196608959,
            196606372,
            196605050,
            196609433,
            196606282,
            196610970,
            196610779,
            196613465,
            196606986,
            196612839,
            196609050,
            196607813,
            196663784,
            196670930,
            196612044,
            196605520,
            196611174,
            196610757,
            196615745
        ],
        "B": [
            196607492,
            196604951,
            196602514,
            196611006,
            196605854,
            196603175,
            196607224,
            196607805,
            196609864,
            196732242,
            196608899,
            196725334,
            196673072,
            196604282,
            196604121,
            196602391,
            196666183
        ],
        "A": [
            196601824,
            196601543,
            196601334,
            196601281,
            196602802,
            196601554,
            196623981,
            196603178,
            196605892,
            196601290,
            196604431,
            196602393,
            196602511,
            196601410,
            196601549,
            196603512,
            196601416,
            196607954,
            196604235,
            196602401
        ]
    },
    "name": "F. Another n-dimensional chocolate bar",
    "statement": "Mom bought the boy Vasya a n-dimensional chocolate bar, which is a\r\nn-dimensional cube with the length of each side equal to 1. The\r\nchocolate is planned to be divided into slices. According to the ith\r\ndimension, it can be divided by hyperplanes into a_i equal parts. Thus,\r\nthe chocolate is divided in total into a_1\r\ncdot a_2\r\ncdot a_3\r\ncdot\r\nldots\r\ncdot a_n slices, each slice has a length of i-th dimension equal to\r\nfrac{1}{a_i}, respectively, the volume of each slice is\r\nfrac{1}{a_1 a_2\r\ncdots a_n}.Vasya and his friends want to cut a chocolate bar to get at\r\nleast k pieces, while Vasya wants to maximize the volume of the smallest\r\nof them. It is possible to cut the chocolate bar only at the junction of\r\nthe lobules, and each incision must pass through the entire chocolate\r\nbar along some hyperplane involved in the formation of lobules. Only\r\nafter making all the cuts, Vasya disassembles the chocolate into\r\npieces.More formally, Vasya wants to choose the numbers b_1, b_2,\r\ndots, b_n (1\r\nle b_i\r\nle a_i) the number of parts into which Vasya will cut the chocolate bar\r\nalong each dimension. The condition b_1\r\ncdot b_2\r\ncdot\r\nldots\r\ncdot b_n\r\nge k must be met to get at least k pieces after all cuts. It can be\r\nnoted that with optimal cutting with such parameters, the minimum piece\r\nwill contain\r\nlfloor\r\nfrac{a_1}{b_1}\r\nrfloor\r\ndotsm\r\nlfloor\r\nfrac{a_n}{b_n}\r\nrfloor slices, and its volume will be equal to\r\nlfloor\r\nfrac{a_1}{b_1}\r\nrfloor\r\ndotsm\r\nlfloor\r\nfrac{a_n}{b_n}\r\nrfloor\r\ncdot\r\nfrac{1}{a_1 a_2\r\ncdots a_n}.Vasya wants to get the maximum possible value of the volume\r\nof the minimum piece multiplied by k, that is, he wants to maximize the\r\nnumber of\r\nlfloor\r\nfrac{a_1}{b_1}\r\nrfloor\r\ndotsm\r\nlfloor\r\nfrac{a_n}{b_n}\r\nrfloor\r\ncdot\r\nfrac{1}{a_1 a_2\r\ncdots a_n}\r\ncdot k. Help him with this.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT \u3067\u6570\u5217\u3092\u7ba1\u7406\u3059\u308b\u3068\u304d\u306b\u4f7f\u3046 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify \u3057\u3066\u306a\u3044\u3084\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//\u30bd\u30fc\u30c8\u3057\u3066 i \u756a\u76ee\u304c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//\u4f8b\u3048\u3070 sortidx \u3067\u5f97\u305f idx \u3092\u4f7f\u3048\u3070\u5358\u306b\u30bd\u30fc\u30c8\u5217\u306b\u306a\u3063\u3066\u8fd4\u3063\u3066\u304f\u308b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\nstruct N{\n\tvi vs;\n\tint n,n2,s;\n\tN(int n_):n(n_),n2(sqrtl(n)){\n\t\t{\n\t\t\tint v=n;\n\t\t\twhile(1){\n\t\t\t\tvs.pb(v);\n\t\t\t\tif(v==1)break;\n\t\t\t\tint w=(n+v-2)/(v-1);\n\t\t\t\tv=(n+w-1)/w;\n\t\t\t}\n\t\t}\n\t\ts=vs.size();\n\t}\n\tint getidx(int a){\n\t\treturn a<=n2?s-a:(n+a-1)/a-1;\n\t}\n};\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tN z(k);\n\tint s=z.s;\n\tdmp(z.vs);\n\tvvc<pi> g(s);\n\trep(i,s){\n\t\tint w=z.vs[i];\n\t\tint d=1;\n\t\twhile(1){\n\t\t\tint v=(w+d-1)/d;\n\t\t\tg[i].eb(z.getidx(v),d);\n\t\t\t\n\t\t\tif(v==1)break;\n\t\t\td=(w+v-2)/(v-1);\n\t\t}\n\t}\n\tdmp(g);\n\tusing ld=long double;\n\tvc<ld> dp(s,0);\n\tdp[0]=k;\n\tauto nx=dp;\n\trep(_,n){\n\t\tint a;cin>>a;\n\t\tfill(all(nx),0);\n\t\trep(i,s)for(auto [j,d]:g[i]){\n\t\t\tdmp2(i,j,dp[i],(a/d),a);\n\t\t\tchmax(nx[j],dp[i]*(a/d)/a);\n\t\t}\n\t\tswap(nx,dp);\n\t\tdmp(dp);\n\t}\n\tcout<<dp[s-1]<<endl;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "meet-in-the-middle",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Another n-dimensional chocolate bar.json",
    "editorial_link": "https://codeforces.com//blog/entry/113857",
    "editorial": "For we denote the maximum value\nof To begin with, let\u00e2\u0080\u0099s solve the problem for using dynamic\nprogramming.Let\u00e2\u0080\u0099s put the maximum possible volume of the smallest piece,\nif by the first measurements we divided the chocolate into parts. If we\nhave divided into more than parts, we will also put the result in . In\nterms of calculation, we need to decide how many hours to divide the\nchocolate bar along the next dimension. Let\u00e2\u0080\u0099s look at several ways to do\nthis. It is possible for to sort out the state to which we are moving,\nand from this calculate how many parts you need to divide the chocolate\nbar along the next dimension. We get It is possible for to sort out how\nmany parts we divide the chocolate bar along the next dimension. Being\nin the state of , you can iterate over into how many parts to divide the\nchocolate until . It can be shown that such a solution will work for The\nkey idea suppose we need to divide a chocolate bar into parts, and along\nthe first measurements we have already divided it into parts, or parts,\nor or parts. All these states are not distinguishable for us, because in\nall these cases we need to divide the chocolate bar into at least parts.\nIt remains to understand how many such <> states there are and learn how\nto store them. There are several approaches for this, let\u00e2\u0080\u0099s analyze one\nof them: we are interested in all the values of for this is how many\nparts the chocolate bar may still need to be divided into. Among them,\nonly different, since either , or the value of itself. If we make all\nthese numbers states, and recalculate, iterating over the state to which\nto go, we get this is still not enough to solve the hollow problem. Last\nobservationIf we are in the state of where for some , we will apply the\nsame idea to it. From it, we are interested in transitions to the states\nfor . What kind of asymptotics will be obtained if we iterate over only\ninteresting transitions? it can be shown that this is which solves the\nproblem\n"
}