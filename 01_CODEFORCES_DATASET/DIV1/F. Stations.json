{
    "link": "https://codeforces.com//contest/1572/problem/F",
    "problemId": "1113068",
    "problem_idx": "F",
    "shortId": "1572F",
    "contest_number": "1572",
    "problem_submissions": {
        "E": [
            129206504,
            129205064,
            129206146,
            129186931,
            129254910,
            129870976,
            129204851
        ],
        "B": [
            129200222,
            129195364,
            129193573,
            129181375,
            129193456,
            129190984,
            129205791,
            129198794,
            129201998,
            129193078,
            129214920,
            129184305,
            129194122,
            129185643,
            129187972,
            129190794,
            129186099,
            129191410,
            129188216
        ],
        "C": [
            129195835,
            129191513,
            129199311,
            129193150,
            129195181,
            129198867,
            129196979,
            129259448,
            129179785,
            129722486,
            129198454,
            129198079,
            129197696,
            129199887,
            129197773,
            129211811,
            129200276
        ],
        "D": [
            129192769,
            129199613,
            129201627,
            129206390,
            129205002,
            129205082,
            129227304,
            129328372,
            129201185,
            129870962,
            129870944,
            129203066,
            129316237,
            129316188,
            136814393,
            129429191
        ],
        "A": [
            129167164,
            129167977,
            129198411,
            129169285,
            129180189,
            129173821,
            129177103,
            129171630,
            129176985,
            129172424,
            129196280,
            129167530,
            129169791,
            129170025,
            129173030,
            129174006,
            129171850,
            129174559,
            129177053
        ],
        "F": [
            129209583,
            129209541,
            129208785,
            129202453,
            129198897,
            129722539,
            129216893,
            129216152,
            129193790,
            129338264
        ]
    },
    "name": "F. Stations",
    "statement": "There are n cities in a row numbered from 1 to n.The cities will be\r\nbuilding broadcasting stations. The station in the i-th city has height\r\nh_i and range w_i. It can broadcast information to city j if the\r\nfollowing constraints are met: i\r\nle j\r\nle w_i, and for each k such that i < k\r\nle j, the following condition holds: h_k < h_i. In other words, the\r\nstation in city i can broadcast information to city j if j\r\nge i, j is in the range of i-th station, and i is strictly highest on\r\nthe range from i to j (including city j).At the beginning, for every\r\ncity i, h_i = 0 and w_i = i.Then q events will take place. During i-th\r\nevent one of the following will happen: City c_i will rebuild its\r\nstation so that its height will be strictly highest among all stations\r\nand w_{c_i} will be set to g_i. Let b_j be the number of stations that\r\ncan broadcast information to city j. Print the sum of b_j over all j\r\nsatisfying l_i\r\nle j\r\nle r_i. Your task is to react to all events and print answers to all\r\nqueries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 1<<18;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << \"\\n\"; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\n/**\n * Description: range sum queries and point updates for $D$ dimensions\n * Source: https://codeforces.com/blog/entry/64914\n * Verification: SPOJ matsum\n * Usage: \\texttt{BIT<int,10,10>} gives 2D BIT\n * Time: O((\\log N)^D)\n */\n\ntemplate <class T, int ...Ns> struct BIT {\n\tT val = 0; void upd(T v) { val += v; }\n\tT query() { return val; }\n};\ntemplate <class T, int N, int... Ns> struct BIT<T, N, Ns...> {\n\tBIT<T,Ns...> bit[N+1];\n\ttemplate<typename... Args> void upd(int pos, Args... args) { assert(pos > 0);\n\t\tfor (; pos<=N; pos+=pos&-pos) bit[pos].upd(args...); }\n\ttemplate<typename... Args> T sum(int r, Args... args) {\n\t\tT res=0; for (;r;r-=r&-r) res += bit[r].query(args...); \n\t\treturn res; }\n\ttemplate<typename... Args> T query(int l, int r, Args... \n\t\targs) { return sum(r,args...)-sum(l-1,args...); }\n}; \ntemplate<class T, int N> int get_kth(const BIT<T,N>& bit, T des) { \n\tassert(des > 0);\n\tint ind = 0;\n\tfor (int i = 1<<bits(N); i; i /= 2)\n\t\tif (ind+i <= N && bit.bit[ind+i].val < des)\n\t\t\tdes -= bit.bit[ind += i].val;\n\tassert(ind < N); return ind+1;\n}\n\nBIT<ll,MX> B0, B1;\nint N,Q;\npair<pi,int> seg[2*MX]; // max, max cnt, second min\nint lazy[2*MX];\n\npair<pi,int> operator+(pair<pi,int> a, pair<pi,int> b) {\n\tif (a < b) swap(a,b);\n\tif (a.f.f == b.f.f) {\n\t\treturn {{a.f.f,a.f.s+b.f.s},max(a.s,b.s)};\n\t} else {\n\t\treturn {a.f,max(a.s,b.f.f)};\n\t}\n}\n\nvoid pull(int ind) {\n\tseg[ind] = seg[2*ind]+seg[2*ind+1];\n}\n\nvoid build(int ind, int L, int R) {\n\tlazy[ind] = MOD;\n\tif (L == R) {\n\t\tseg[ind] = {{L,1},-MOD};\n\t\treturn;\n\t}\n\tint M = (L+R)/2;\n\tbuild(2*ind,L,M); build(2*ind+1,M+1,R);\n\tpull(ind);\n}\n\nvoid push(int ind, int L, int R) {\n\tassert(lazy[ind] > seg[ind].s);\n\tckmin(seg[ind].f.f,lazy[ind]);\n\tif (L != R) {\n\t\tckmin(lazy[2*ind],lazy[ind]);\n\t\tckmin(lazy[2*ind+1],lazy[ind]);\n\t}\n\tlazy[ind] = MOD;\n}\n\nvoid upd(int index, ll dif) {\n\t// dbg(\"UPD\",index,dif);\n\tB1.upd(1,dif);\n\tB1.upd(index+1,-dif);\n\tB0.upd(index+1,dif*index);\n}\n\nvoid set_equal(int c, int g, int ind, int L, int R) {\n\tpush(ind,L,R);\n\tif (R < c || c < L) return;\n\tif (L == R) {\n\t\t// dbg(\"EQUAL BASE CASE\");\n\t\tupd(seg[ind].f.f,-seg[ind].f.s);\n\t\tupd(g,seg[ind].f.s);\n\t\tseg[ind].f.f = g;\n\t\treturn;\n\t}\n\tint M = (L+R)/2;\n\tset_equal(c,g,2*ind,L,M);\n\tset_equal(c,g,2*ind+1,M+1,R);\n\tpull(ind);\n}\n\n\nvoid make_min(int lo, int hi, int v, int ind, int L, int R) {\n\tpush(ind,L,R);\n\tif (v >= seg[ind].f.f || R < lo || hi < L) return;\n\tif (lo <= L && R <= hi && v > seg[ind].s) {\n\t\tupd(seg[ind].f.f,-seg[ind].f.s);\n\t\tupd(v,seg[ind].f.s);\n\t\tlazy[ind] = v;\n\t\tpush(ind,L,R);\n\t\treturn;\n\t}\n\tint M = (L+R)/2;\n\tmake_min(lo,hi,v,2*ind,L,M);\n\tmake_min(lo,hi,v,2*ind+1,M+1,R);\n\tpull(ind);\n}\n\nll get_sum(int r) {\n\treturn B1.sum(r)*r+B0.sum(r);\n}\n\nvoid add_range(int l, int r) {\n\tupd(l-1,-1);\n\tupd(r,1);\n}\n\nint main() {\n\tsetIO();\n\tre(N,Q);\n\tupd(N,1);\n\tbuild(1,1,N);\n\trep(Q) {\n\t\tints(p);\n\t\tif (p == 1) {\n\t\t\tints(c,g);\n\t\t\tset_equal(c,g,1,1,N);\n\t\t\tmake_min(1,c-1,c-1,1,1,N);\n\t\t} else {\n\t\t\tints(l,r);\n\t\t\tps(get_sum(r)-get_sum(l-1));\n\t\t}\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Stations.json",
    "editorial_link": "https://codeforces.com//blog/entry/95086",
    "editorial": "We will maintain the array on a range add/sum segment tree. Queries are\r\ndone then in per query.Now lets focus on the station rebuilds. Lets\r\nmaintain an array , which means how far a station can broadcast\r\ninformation including the fact that some stations might block the\r\nsignal. When a station is rebuild in city we need to perform a operation\r\non interval with value . Next we have to set to . These are all changes\r\nto array that happen during a single rebuild.Now we want to keep array\r\nup to date. We need to know what has been changed and a list of changes\r\nto array is all we need. When setting to we can add on interval . This\r\nis fast enough to do with a single operation on array , since we do this\r\nonce for every rebuild. Lets say that was decreased as a result of the\r\noperation. To update array accordingly we should subtract 1 on interval\r\n.Sadly, performing a subtraction on for every value in array that has\r\nchanged during the operation one by one is too slow and we can\u00e2\u0080\u0099t afford\r\nit. Thankfully, we can speed this up. First, we will think how to keep\r\narray updated. We can use segment tree beats to perform the operation.\r\nRecall that during the operation we get to know what elements and how\r\nmany times have changed. This is traditionally used to update the sum\r\nover interval information. Now we are going to use it in a different\r\nway. Lets say that value was decreased times in a node where we perform\r\na tag. To keep array updated we only need subrtact from interval .Lets\r\nthink about the complexity now. Segment tree beats with and operations\r\nrun in amortized meaning that we will perform at most this many changes\r\non array . This leads us to our total time complexity of .\r\n"
}