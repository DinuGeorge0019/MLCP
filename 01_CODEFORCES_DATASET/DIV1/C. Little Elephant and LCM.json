{
    "link": "https://codeforces.com//contest/258/problem/C",
    "problemId": "2444",
    "problem_idx": "C",
    "shortId": "258C",
    "contest_number": "258",
    "problem_submissions": {
        "D": [
            2814736,
            2812430,
            2814871,
            2814961,
            2812733,
            2815597,
            2815735,
            3321861,
            2817362,
            2813664,
            2817783,
            2816087,
            2814924
        ],
        "E": [
            2813546,
            2815005,
            2813362,
            2813842,
            2813877,
            2813261,
            2811449,
            2814046,
            2814079,
            2814422,
            2814320,
            2814528,
            2814704,
            2817438,
            2817366,
            2817363,
            2817357,
            2817344,
            2817287,
            2817270,
            2814834
        ],
        "C": [
            2811749,
            2809654,
            2812462,
            2812301,
            2814561,
            2810964,
            2812259,
            2812879,
            2811632,
            2812613,
            2812711,
            2812609,
            2811716,
            2810788,
            2813202,
            2812348,
            2813127
        ],
        "B": [
            2809756,
            2813180,
            2810688,
            2811171,
            2811678,
            2809679,
            2814549,
            2809883,
            2810504,
            2810872,
            2811182,
            2813077,
            2812214,
            2811807,
            2810280,
            2810608
        ],
        "A": [
            2807475,
            2810109,
            2807417,
            2807993,
            2807422,
            2807498,
            2807514,
            2808316,
            2807507,
            2807423,
            2807995,
            2807416,
            2807421,
            2807426,
            2807559
        ]
    },
    "name": "C. Little Elephant and LCM",
    "statement": "The Little Elephant loves the LCM (least common multiple) operation of a\r\nnon-empty set of positive integers. The result of the LCM operation of\r\npositive integers is the minimum positive integer that is divisible by\r\neach of numbers .Let’s assume that there is a sequence of integers .\r\nLet’s denote their LCMs as and the maximum of them as . The Little\r\nElephant considers a sequence , if .The Little Elephant has a sequence\r\nof integers . Help him find the number of good sequences of integers ,\r\nsuch that for all the following condition fulfills: . As the answer can\r\nbe rather large, print the remainder from dividing it by .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing std::vector;\nusing std::lower_bound;\n\nconst int N = 100000;\nconst int INF = 1000000000;\nconst int MOD = 1000000000 + 7;\n\nint n, a[N];\nvector <int> divisors[N + 1];\n\nint pow(int a, int n) {\n    int ret = 1;\n    while (n) {\n        if (n & 1) {\n            ret = (long long)ret * a % MOD;\n        }\n        n >>= 1;\n        a = (long long)a * a % MOD;\n    }\n    return ret;\n}\n\nint inverse(int a) {\n    return a == 1 ? 1 : (long long)(MOD - MOD / a) * inverse(MOD % a) % MOD;\n}\n\nint main() {\n    for (int d = 1; d <= N; ++ d) {\n        for (int i = d; i <= N; i += d) {\n            divisors[i].push_back(d);\n        }\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d\", a + i);\n    }\n    std::sort(a, a + n);\n    int answer = 0;\n    for (int lcm = 1; lcm <= N; ++ lcm) {\n        vector <int> &divisor = divisors[lcm];\n        int m = divisor.size();\n        int way = 1;\n        for (int j = 0; j + 1 < m; ++ j) {\n            int size = lower_bound(a, a + n, divisor[j + 1]) - lower_bound(a, a + n, divisor[j]);\n            way = (long long)way * pow(j + 1, size) % MOD;\n        }\n        int size = a + n - lower_bound(a, a + n, lcm);\n        if (size) {\n            way = (long long)way * (pow(m, size) + MOD - pow(m - 1, size)) % MOD;\n            (answer += way) %= MOD;\n        }\n    }\n    printf(\"%d\\n\", answer);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Little Elephant and LCM.json",
    "editorial_link": "https://codeforces.com//blog/entry/6213",
    "editorial": "The complexity of the possible solution is . You can see that statement\r\nis equal to statement \"All the numbers must divide \". You can iterate\r\nthat , let it be equal to . Find all divisors of and sort them . For\r\neach between 1 and you can find (using simple DP) the number of numbers\r\nthat (if than ), denote it as . Then the reuslt is equal to , because\r\nfor each of the numbers there is way to assign, for each of numbers\r\nthere is ways of assignments, and so on. But you should notice that if\r\ndoing this problem in such way, you need to garantee that there is some\r\nsuch . Hance you need from the last multiplier subtract all the ways\r\nthat there is no number equal to .\r\n",
    "hint": []
}