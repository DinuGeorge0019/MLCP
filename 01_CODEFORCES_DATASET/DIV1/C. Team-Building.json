{
    "link": "https://codeforces.com//contest/1444/problem/C",
    "problemId": "781576",
    "problem_idx": "C",
    "shortId": "1444C",
    "contest_number": "1444",
    "problem_submissions": {
        "E": [
            177060864,
            97660118,
            97359218,
            97528673,
            105295397,
            97391457,
            107899094
        ],
        "D": [
            97340003,
            97340266,
            97342285,
            97342896,
            97337709,
            97340895,
            97341601,
            97345333,
            97349700,
            97373326,
            97348927,
            97326702,
            97346935,
            97347842,
            97348566,
            97344354,
            97348921,
            97341198,
            97348249,
            97341495,
            97349542
        ],
        "C": [
            97320701,
            97319171,
            97319507,
            97327690,
            97320892,
            97327102,
            97328013,
            97321796,
            97328337,
            97336256,
            97330742,
            97325357,
            97336388,
            97333742,
            97327914,
            97322996,
            97331358,
            99653258,
            97349832,
            97328361
        ],
        "B": [
            97309345,
            97307941,
            97312731,
            97313742,
            97309124,
            97318228,
            97312056,
            97312423,
            97316008,
            97338138,
            97314968,
            97311029,
            97312318,
            97313371,
            97314101,
            97346837,
            97315650,
            97314655,
            97317415
        ],
        "A": [
            97303759,
            97308441,
            97306115,
            97307464,
            97305751,
            97307808,
            97306079,
            97306446,
            97310249,
            97339306,
            97309724,
            97306667,
            97305992,
            97307462,
            97306550,
            97306839,
            97306977,
            97308612,
            97308951
        ]
    },
    "name": "C. Team-Building",
    "statement": "The new academic year has started, and Berland\u2019s university has n\r\nfirst-year students. They are divided into k academic groups, however,\r\nsome of the groups might be empty. Among the students, there are m pairs\r\nof acquaintances, and each acquaintance pair might be both in a common\r\ngroup or be in two different groups.Alice is the curator of the first\r\nyears, she wants to host an entertaining game to make everyone know each\r\nother. To do that, she will select two different academic groups and\r\nthen divide the students of those groups into two teams. The game\r\nrequires that there are no acquaintance pairs inside each of the\r\nteams.Alice wonders how many pairs of groups she can select, such that\r\nit\u2019ll be possible to play a game after that. All students of the two\r\nselected groups must take part in the game.Please note, that the teams\r\nAlice will form for the game don\u2019t need to coincide with groups the\r\nstudents learn in. Moreover, teams may have different sizes (or even be\r\nempty).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn't exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << \", \";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nvi C;\nvb bad;\n\nbool BAD = 0;\n\n/**\n * Description: Disjoint Set Union with path compression\n \t* and union by size. Add edges and test connectivity. \n \t* Use for Kruskal's or Boruvka's minimum spanning tree.\n * Time: O(\\alpha(N))\n * Source: CSAcademy, KACTL\n * Verification: *\n */\n\ntemplate<bool mode> struct DSU {\n\tvi e, par_edge; \n\tvoid init(int N) { \n\t\te = par_edge = vi(N,-1); \n\t\tF0R(i,N) e[i] = i;\n\t}\n\tpi get(int x) { \n\t\tif (e[x] == x) return {x,0};\n\t\tpi q = get(e[x]);\n\t\te[x] = q.f; par_edge[x] ^= q.s;\n\t\treturn {e[x],par_edge[x]};\n\t}\n\t// bool sameSet(int a, int b) { return get(a) == get(b); }\n\t// int size(int x) { return -e[get(x)]; }\n\tbool unite(int x, int y, int z) { // union by size\n\t\tpi a = get(x);\n\t\tpi b = get(y); \n\t\tif (a.f == b.f) {\n\t\t\tif (a.s^b.s^z) {\n\t\t\t\tif (mode == 0) bad[C[a.f]] = 1;\n\t\t\t\telse BAD = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\te[a.f] = b.f; par_edge[a.f] = a.s^b.s^z;\n\t\treturn 1;\n\t}\n};\n\nDSU<false> D;\nDSU<true> DD;\n\n/**template<class T> T kruskal(int N, vector<pair<T,pi>> ed) {\n\tsort(all(ed));\n\tT ans = 0; DSU D; D.init(N); // edges that unite are in MST\n\ttrav(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f; \n\treturn ans;\n}*/\n\nvi verts;\n\nvoid ad(pi p) {\n\tpi a = D.get(p.f);\n\tpi b = D.get(p.s);\n\t// dbg(p,a,b);\n\tDD.unite(a.f,b.f,a.s^b.s^1);\n\tverts.pb(a.f), verts.pb(b.f);\n\t// dbg(\"AD\",p,a,b,DD.get(a.f),DD.get(b.f));\n}\n\nvoid clr() {\n\ttrav(t,verts) {\n\t\tDD.par_edge[t] = -1;\n\t\tDD.e[t] = t;\n\t}\n\tverts.clear();\n}\n\nint N,M,K;\n\nint main() {\n\tsetIO(); re(N,M,K); bad.rsz(K+1);\n\tC.rsz(N); re(C);\n\tV<pair<pi,pi>> todo;\n\tD.init(N); DD.init(N);\n\tF0R(i,M) {\n\t\tint a,b; re(a,b); --a,--b;\n\t\tif (C[a] == C[b]) {\n\t\t\tD.unite(a,b,1);\n\t\t} else {\n\t\t\tpi p = {C[a],C[b]}; if (p.f > p.s) swap(p.f,p.s);\n\t\t\ttodo.pb({p,{a,b}});\t\n\t\t}\n\t}\n\tll ok = 0;\n\tFOR(i,1,K+1) if (!bad[i]) ok ++;\n\tll ans = ok*(ok-1)/2;\n\tsort(all(todo));\n\t// dbg(\"HA\",ans,todo,ok);\n\tfor (int i = 0; i < sz(todo); ) {\n\t\tint I = i;\n\t\tBAD = 0;\n\t\tclr();\n\t\twhile (i < sz(todo) && todo[i].f == todo[I].f) {\n\t\t\tad(todo[i].s);\n\t\t\ti ++;\n\t\t}\n\t\t// dbg(\"DONE\",todo[I],(int)bad[todo[I].f.f],(int)bad[todo[I].f.s]);\n\t\tif (!bad[todo[I].f.f] && !bad[todo[I].f.s]) ans -= BAD;\n\t}\n\tps(ans);\n\t// how man\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Team-Building.json",
    "editorial_link": "https://codeforces.com//blog/entry/84248",
    "editorial": "You\u00e2\u0080\u0099re given an undirected graph without loops and multiple edges, each\r\nvertex has some color from to . Count the number of pairs of colors such\r\nthat graph induced by vertices of these two colors will be\r\nbipartite.Let\u00e2\u0080\u0099s check for each color whether the graph induced by it is\r\nbipartite (for example, using depth-first search). This can be done in .\r\nWe will not use non-bipartite colors further since they can\u00e2\u0080\u0099t be in any\r\npairs.Now let\u00e2\u0080\u0099s construct a slow solution that we will make faster\r\nlater.Consider some color . There\u00e2\u0080\u0099re edges from vertices of this color\r\nto vertices of colors . Let\u00e2\u0080\u0099s check whether the graphs induced by pairs\r\nare bipartite (also using depth-first search), thereby finding out which\r\ncolors cannot be in pair with . The others can. After doing this for\r\neach color , we can find the asnwer.How fast does this work? Notice that\r\nany edge between different colors we will use in DFS only two times. The\r\nproblem are edges between vertices of the same color, we can use them up\r\nto times, and there can be a lot of them.Let\u00e2\u0080\u0099s solve this problem and\r\nconstruct a faster solution.A graph is bipartite if and only if it\r\ndoesn\u00e2\u0080\u0099t contains odd cycles. Consider some connected bipartite component\r\ninduced by color . If a cycle goes through this component, it doesn\u00e2\u0080\u0099t\r\nmatter how exactly it does it. If the path of the cycle in this\r\ncomponent ends in the same side where it has started, then it has even\r\nlength, and odd otherwise. This fact lets us compress this component to\r\ntwo vertices (one for each side) connected by one edge. For each color\r\nthis way we compress all components formed by it.Now we have the\r\ncompressed graph, where all connected components are either one vertex\r\nor two vertices connected by one edge. Let\u00e2\u0080\u0099s do the same process we did\r\nin slow solution and check every connected pair of colors whether the\r\ngraph induced by it is bipartite. To check the pair , for each edge\r\nbetween vertices of colors and in the original graph add a new edge to\r\nthe compressed graph between corresponding vertices. After that use DFS\r\nto check if graph is bipartite, rollback the changes and do the same for\r\nall other pairs. How long does this work for one pair ?Let\u00e2\u0080\u0099s start DFS\r\nonly from components that were connected by added edges, since the\r\nothers do not affect whether the graph is bipartite or not, but there\r\ncan be a lot of them. This way DFS will use only added edges and some\r\nedges between vertices of the same color or . However, there will be at\r\nmost two times more of the latter than the added, because each added\r\nedge connects at most two new components, and each new component has at\r\nmost one edge. So, we check one pair in the time proportional to amount\r\nof edges between its colors, and it sums up to for all pairs.So, the\r\nwhole solution works in or , depending on the implementation.\r\n"
}