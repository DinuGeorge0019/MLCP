{
    "link": "https://codeforces.com//contest/1852/problem/D",
    "problemId": "2099135",
    "problem_idx": "D",
    "shortId": "1852D",
    "contest_number": "1852",
    "problem_submissions": {
        "F": [
            215258181,
            215285692,
            217509901,
            217509714
        ],
        "E": [
            215240027,
            215239122,
            215243644,
            215243658,
            215248799,
            215245960,
            215237098,
            215240727,
            215296441,
            215327365,
            215336328,
            217901271,
            215247415
        ],
        "D": [
            215222100,
            215222081,
            215222261,
            215225730,
            215218775,
            215382147,
            215226776,
            215250750,
            215250174,
            215230611,
            215232642,
            215226731,
            215232589,
            215240152,
            215237043,
            215236182,
            215239579,
            215241752,
            215242725
        ],
        "C": [
            215209363,
            215208759,
            215214250,
            215220833,
            215208505,
            215217394,
            215219756,
            215218376,
            215205472,
            215208510,
            215213920,
            215221691,
            215216406,
            215223920,
            215226652,
            215216927,
            215221642,
            215210662,
            215212429
        ],
        "B": [
            215201282,
            215200579,
            215202726,
            215199335,
            215200474,
            215207713,
            215208166,
            215202505,
            215214027,
            215200003,
            215206319,
            215205331,
            215204344,
            215212727,
            215206313,
            215209315,
            215209426,
            215199777,
            215204560
        ],
        "A": [
            215201184,
            215192031,
            215194261,
            215194419,
            215219859,
            215194029,
            215260286,
            215197669,
            215196351,
            215192202,
            215192228,
            215192416,
            215194163,
            215196399,
            215195136,
            215198712,
            215191998,
            215201193,
            215192233,
            215195682
        ]
    },
    "name": "D. Miriany and Matchstick",
    "statement": "Miriany’s matchstick is a 2\r\ntimes n grid that needs to be filled with characters or . He has already\r\nfilled in the first row of the grid and would like you to fill in the\r\nsecond row. You must do so in a way such that the number of ^\r\ndagger is equal to k. If it is impossible, report so.^\r\ndagger An is a pair of cells (r_1, c_1) and (r_2, c_2) (1\r\nle r_1, r_2\r\nle 2, 1\r\nle c_1, c_2\r\nle n) such that |r_1 - r_2| + |c_1 - c_2| = 1 and the characters in\r\n(r_1, c_1) and (r_2, c_2) are different.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::string s;\n    std::cin >> s;\n    \n    for (int i = 1; i < n; i++) {\n        k -= (s[i] != s[i - 1]);\n    }\n    if (k < 0) {\n        std::cout << \"NO\\n\";\n        return;\n    }\n    \n    std::vector dp(2, std::vector<std::vector<std::pair<int, int>>>(n));\n    dp[0][0].emplace_back(s[0] != 'A', s[0] != 'A');\n    dp[1][0].emplace_back(s[0] != 'B', s[0] != 'B');\n    for (int i = 1; i < n; i++) {\n        for (int t = 0; t < 2; t++) {\n            for (auto [l, r] : dp[t][i - 1]) {\n                dp[t][i].emplace_back(l, r);\n                dp[!t][i].emplace_back(l + 1, r + 1);\n            }\n        }\n        for (int t = 0; t < 2; t++) {\n            std::vector<std::pair<int, int>> f;\n            std::sort(dp[t][i].begin(), dp[t][i].end());\n            int d = (s[i] != 'A' + t);\n            for (auto [l, r] : dp[t][i]) {\n                l += d;\n                r += d;\n                if (!f.empty() && l <= f.back().second + 1) {\n                    f.back().second = std::max(f.back().second, r);\n                } else {\n                    f.emplace_back(l, r);\n                }\n            }\n            dp[t][i] = f;\n        }\n    }\n    \n    auto get = [&](auto &f, int x) {\n        for (auto [l, r] : f) {\n            if (l <= x && x <= r) {\n                return true;\n            }\n        }\n        return false;\n    };\n    \n    for (int t = 0; t < 2; t++) {\n        if (get(dp[t][n - 1], k)) {\n            std::cout << \"YES\\n\";\n            auto ans = s;\n            for (int i = n - 1; i > 0; i--) {\n                k -= (s[i] != 'A' + t);\n                ans[i] = 'A' + t;\n                if (!get(dp[t][i - 1], k)) {\n                    t = !t;\n                    k--;\n                }\n            }\n            ans[0] = 'A' + t;\n            std::cout << ans << \"\\n\";\n            return;\n        }\n    }\n    std::cout << \"NO\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Miriany and Matchstick.json",
    "editorial_link": "https://codeforces.com//blog/entry/116940",
    "editorial": "Call the number of adjacent pairs of cells with different\ncharacters the cost.If we construct the second row from left to right,\nthe amount each character adds to the cost only depends on the previous\ncharacter. Thus, we can represent the problem with a DAG whose vertices\nrepresent choices for each character and whose edges represent the cost\nof choosing two adjacent characters. Our goal is to find a path starting\nfrom the far left and ending at the far right of cost . For example,\nbelow is the DAG for the third testcase in the sample. (For convenience,\nwe include the cost of cells in the top row with the corresponding cells\nin the bottom row.)A general way to find such a path is as follows: For\neach vertex, store all possible costs of a path starting from the far\nleft and ending at that vertex, which can be calculated with dynamic\nprogramming. Then we construct our path backwards from the right. For\neach candidate previous vertex, we check that the constructed pathâs\ncost plus the cost of the edge from this vertex plus some stored cost in\nthis vertex equals , in which case we know that some completion of the\npath from the far left to this vertex exists and we can choose this\nvertex.Naively calculating this DP would require time per operation.\nHowever, intuitively, each set of possible costs should contain almost\nall values between its minimum and maximum, and experiments suggest it\nalways consists of at most two intervals. We will first formalize the DP\nand then prove this observation.Let store the set of possible values of\nwhen the grid is truncated to the first columns and the last character\nin the second row is . Define similarly.Using the notation , , , we have\nthe recurrences with initial values and .Now either we hope that each\nset consists of intervals, or we have to prove that each set indeed\nconsists of at most two intervals: ProofWe will use induction to prove\nthat the following stronger property holds for all : and are overlapping\nintervals, except that possibly one (non-endpoint) value is missing from\none interval, but in that case either or is present in the other\ninterval. ( must be treated separately, but it can easily be\nchecked.)Base case. To prove this holds for , WLOG let so and . If ,\nthen which satisfies the property with . If , then which satisfies the\nproperty with .Induction step. Suppose the property holds for .Since the\nconditions of the property only depend on relative positions, for\nconvenience we shift the sets and left by to get If the property holds\nfor , then it holds for .First, we show that a missing value in or can\nonly come directly from a missing value in or and not from the union\noperation merging two non-adjacent intervals. This is true because and\noverlap, so even after is added to either, they are still at least\nadjacent.If a value is missing, WLOG let it be missing from . If , then\nmay be missing while does not miss any value. Also, since is adjacent to\nthe missing value (which isnât an endpoint), it is in , so either or is\nin . This also guarantees the intervals overlap, satisfying the property\nfor . The case for is very similar. may be missing either or , and since\n, is in . If no value is missing, let be a common value in both and .\nThen, and is a superset of either or , so the intervals overlap.To find\nthe union of two sets of intervals, sort them by left endpoint and merge\nadjacent overlapping intervals. After computing the DP, apply the\naforementioned backwards construction to obtain a valid second row.Below\nis a visualization of solving the third testcase in the sample. Generate\nyour own here!\n",
    "hint": [
        "Hint 1 Solve the samples for all values of .",
        "Hint 2 What does constructing a second row from left to right look like?",
        "Hint 3 How does knowing the possible for any first row help you construct a second row?",
        "Hint 4 Apply dynamic programming to calculate the possible , and use the information in the DP to construct a solution."
    ]
}