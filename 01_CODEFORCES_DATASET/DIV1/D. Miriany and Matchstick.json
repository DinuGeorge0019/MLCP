{"link": "https://codeforces.com//contest/1852/problem/D", "problemId": "2099135", "problem_idx": "D", "shortId": "1852D", "contest_number": "1852", "problem_submissions": {"F": [215258181, 215285692, 217509901, 217509714], "E": [215240027, 215239122, 215243644, 215243658, 215248799, 215245960, 215237098, 215240727, 215296441, 215327365, 215336328, 217901271, 215247415], "D": [215222100, 215222081, 215222261, 215225730, 215218775, 215382147, 215226776, 215250750, 215250174, 215230611, 215232642, 215226731, 215232589, 215240152, 215237043, 215236182, 215239579, 215241752, 215242725], "C": [215209363, 215208759, 215214250, 215220833, 215208505, 215217394, 215219756, 215218376, 215205472, 215208510, 215213920, 215221691, 215216406, 215223920, 215226652, 215216927, 215221642, 215210662, 215212429], "B": [215201282, 215200579, 215202726, 215199335, 215200474, 215207713, 215208166, 215202505, 215214027, 215200003, 215206319, 215205331, 215204344, 215212727, 215206313, 215209315, 215209426, 215199777, 215204560], "A": [215201184, 215192031, 215194261, 215194419, 215219859, 215194029, 215260286, 215197669, 215196351, 215192202, 215192228, 215192416, 215194163, 215196399, 215195136, 215198712, 215191998, 215201193, 215192233, 215195682]}, "name": "D. Miriany and Matchstick", "statement": "Miriany\u2019s matchstick is a 2\r\ntimes n grid that needs to be filled with characters or . He has already\r\nfilled in the first row of the grid and would like you to fill in the\r\nsecond row. You must do so in a way such that the number of ^\r\ndagger is equal to k. If it is impossible, report so.^\r\ndagger An is a pair of cells (r_1, c_1) and (r_2, c_2) (1\r\nle r_1, r_2\r\nle 2, 1\r\nle c_1, c_2\r\nle n) such that |r_1 - r_2| + |c_1 - c_2| = 1 and the characters in\r\n(r_1, c_1) and (r_2, c_2) are different.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::string s;\n    std::cin >> s;\n    \n    for (int i = 1; i < n; i++) {\n        k -= (s[i] != s[i - 1]);\n    }\n    if (k < 0) {\n        std::cout << \"NO\\n\";\n        return;\n    }\n    \n    std::vector dp(2, std::vector<std::vector<std::pair<int, int>>>(n));\n    dp[0][0].emplace_back(s[0] != 'A', s[0] != 'A');\n    dp[1][0].emplace_back(s[0] != 'B', s[0] != 'B');\n    for (int i = 1; i < n; i++) {\n        for (int t = 0; t < 2; t++) {\n            for (auto [l, r] : dp[t][i - 1]) {\n                dp[t][i].emplace_back(l, r);\n                dp[!t][i].emplace_back(l + 1, r + 1);\n            }\n        }\n        for (int t = 0; t < 2; t++) {\n            std::vector<std::pair<int, int>> f;\n            std::sort(dp[t][i].begin(), dp[t][i].end());\n            int d = (s[i] != 'A' + t);\n            for (auto [l, r] : dp[t][i]) {\n                l += d;\n                r += d;\n                if (!f.empty() && l <= f.back().second + 1) {\n                    f.back().second = std::max(f.back().second, r);\n                } else {\n                    f.emplace_back(l, r);\n                }\n            }\n            dp[t][i] = f;\n        }\n    }\n    \n    auto get = [&](auto &f, int x) {\n        for (auto [l, r] : f) {\n            if (l <= x && x <= r) {\n                return true;\n            }\n        }\n        return false;\n    };\n    \n    for (int t = 0; t < 2; t++) {\n        if (get(dp[t][n - 1], k)) {\n            std::cout << \"YES\\n\";\n            auto ans = s;\n            for (int i = n - 1; i > 0; i--) {\n                k -= (s[i] != 'A' + t);\n                ans[i] = 'A' + t;\n                if (!get(dp[t][i - 1], k)) {\n                    t = !t;\n                    k--;\n                }\n            }\n            ans[0] = 'A' + t;\n            std::cout << ans << \"\\n\";\n            return;\n        }\n    }\n    std::cout << \"NO\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "greedy"], "dificulty": "2800", "interactive": false}