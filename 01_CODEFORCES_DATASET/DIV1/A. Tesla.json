{"link": "https://codeforces.com//contest/995/problem/A", "problemId": "193033", "problem_idx": "A", "shortId": "995A", "contest_number": "995", "problem_submissions": {"A": [39622634, 39624778, 39611857, 39613075, 39612504, 39633809, 39730739, 39630464, 39614560, 39615127, 39615945, 39627850, 39644544], "D": [39620886, 39622276, 39624260, 39625402, 39620954, 39619269, 39625858, 39622750, 39648307, 39621953, 39623820, 39630198, 39624907, 39620407, 39624158, 40152305, 39628532], "B": [39618347, 39610962, 39613221, 39614545, 39609629, 39615815, 39611873, 39613569, 39613133, 39612138, 39610926, 39611393, 39611858, 39611928, 39613545, 39611754, 39609705, 53817193, 39610836], "C": [39617499, 39614510, 39626416, 39624999, 39616008, 39617835, 39618295, 39616280, 39624435, 39625816, 39622945, 39621745, 39619276, 39618758, 39619323, 40151840, 39622131], "F": [39615335, 39621081, 39625550, 39626823, 39628939, 39628609, 39627481, 39618994, 39618157, 39650537, 39650510, 39650502, 39650497, 39650286, 39626413, 39619718, 39628948, 39622378, 39621430, 39618390], "E": [39614170, 39617964, 39622775, 39619679, 39622645, 39623654, 39624609, 39619924, 39623004, 39785499, 39632072, 39631884, 39631853, 39631837, 39631822, 39620887, 39627781, 39618907, 39627618, 39627288, 39618749, 39642305]}, "name": "A. Tesla", "statement": "Allen dreams of one day owning a enormous fleet of electric cars, the\r\ncar of the future! He knows that this will give him a big status boost.\r\nAs Allen is planning out all of the different types of cars he will own\r\nand how he will arrange them, he realizes that he has a problem. Allen\u2019s\r\nfuture parking lot can be represented as a rectangle with 4 rows and n\r\n(n\r\nle 50) columns of rectangular spaces, each of which can contain at most\r\none car at any time. He imagines having k (k\r\nle 2n) cars in the grid, and all the cars are initially in the second\r\nand third rows. Each of the cars also has a different designated parking\r\nspace in the first or fourth row. Allen has to put the cars into\r\ncorresponding parking places. However, since Allen would never entrust\r\nhis cars to anyone else, only one car can be moved at a time. He can\r\ndrive a car from a space in any of the four cardinal directions to a\r\nneighboring empty space. Furthermore, Allen can only move one of his\r\ncars into a space on the first or fourth rows if it is the car\u2019s\r\ndesignated parking space. Allen knows he will be a very busy man, and\r\nwill only have time to move cars at most 20000 times before he realizes\r\nthat moving cars is not worth his time. Help Allen determine if he\r\nshould bother parking his cars or leave it to someone less important.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1010;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nPII q[N];\nint vis[5][N],car[5][N],n;\nPII pre[5][N];\nvector<VI> ret;\nvoid getpath(int x,int y) {\n\trep(i,0,4) rep(j,0,n) vis[i][j]=0,pre[i][j]=mp(-1,-1);\n\tint t=0;\n\tq[t++]=mp(x,y);\n\tvis[x][y]=1;\n\trep(i,0,t) {\n\t\tint px=q[i].fi,py=q[i].se;\n\t\tif (car[px][py]==0) {\n\t\t\twhile (1) {\n\t\t\t\tint qx=pre[px][py].fi,qy=pre[px][py].se;\n\t\t\t\tif (qx==-1&&qy==-1) break;\n\t\t\t\tassert(car[qx][qy]>0);\n\t\t\t\tret.pb(VI{car[qx][qy],px,py});\n\t\t\t\tcar[px][py]=car[qx][qy];\n\t\t\t\tcar[qx][qy]=0;\n\t\t\t\tpx=qx; py=qy;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\trep(k,0,4) {\n\t\t\tint qx=px+dx[k],qy=py+dy[k];\n\t\t\tif (qx>=1&&qx<=2&&qy>=0&&qy<n&&car[qx][qy]!=-1&&!vis[qx][qy]) {\n\t\t\t\tpre[qx][qy]=mp(px,py);\n\t\t\t\tvis[qx][qy]=1;\n\t\t\t\tq[t++]=mp(qx,qy);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid go(int x,int y,int c) {\n\tint posx=-1,posy=-1;\n\trep(i,1,3) rep(j,0,n) if (car[i][j]==c) {\n\t\tposx=i; posy=j;\n\t\tbreak;\n\t}\n\tint goalx=x^1,goaly=y;\n\twhile (posx!=goalx||posy!=goaly) {\n\t\tint nxtx=-1,nxty=-1;\n\t\trep(i,0,4) {\n\t\t\tint curx=posx+dx[i],cury=posy+dy[i];\n\t\t\tif (abs(curx-goalx)+abs(cury-goaly)<abs(posx-goalx)+abs(posy-goaly)) {\n\t\t\t\tnxtx=curx,nxty=cury;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcar[posx][posy]=-1;\n\t\tgetpath(nxtx,nxty);\n\t\tret.pb(VI{c,nxtx,nxty});\n\t\tcar[posx][posy]=0;\n\t\tcar[nxtx][nxty]=c;\n\t\tposx=nxtx; posy=nxty;\n\t}\n\tret.pb(VI{c,goalx^1,goaly});\n\tcar[goalx][goaly]=car[goalx^1][goaly]=0;\n}\nint main() {\n\tscanf(\"%d%*d\",&n);\n\trep(i,0,4) rep(j,0,n) scanf(\"%d\",&car[i][j]);\n\trep(j,0,n) {\n\t\tif (car[0][j]==car[1][j]&&car[0][j]!=0) {\n\t\t\tret.pb(VI{car[1][j],0,j});\n\t\t\tcar[0][j]=car[1][j]=0;\n\t\t}\n\t\tif (car[2][j]==car[3][j]&&car[2][j]!=0) {\n\t\t\tret.pb(VI{car[2][j],3,j});\n\t\t\tcar[2][j]=car[3][j]=0;\n\t\t}\n\t}\n\tbool empty=0;\n\trep(j,0,n) if (car[1][j]==0||car[2][j]==0) empty=1;\n\tif (!empty) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(j,0,n) {\n\t\tif (car[0][j]) go(0,j,car[0][j]);\n\t\tif (car[3][j]) go(3,j,car[3][j]);\n\t}\n\tprintf(\"%d\\n\",SZ(ret));\n\tfor (auto p:ret) {\n\t\tprintf(\"%d %d %d\\n\",p[0],p[1]+1,p[2]+1);\n\t}\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "implementation"], "dificulty": "2100", "interactive": false}