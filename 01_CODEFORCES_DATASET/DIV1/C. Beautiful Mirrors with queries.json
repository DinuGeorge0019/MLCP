{
    "link": "https://codeforces.com//contest/1264/problem/C",
    "problemId": "486703",
    "problem_idx": "C",
    "shortId": "1264C",
    "contest_number": "1264",
    "problem_submissions": {
        "B": [
            66341401,
            66322874,
            66336572,
            66329159,
            66325790,
            66330100,
            66345009,
            66330236,
            66376038,
            66331864,
            66336631,
            66328124,
            66347648,
            66329347,
            66322983,
            66344650,
            66327116,
            66327090,
            66332056
        ],
        "D2": [
            66339545,
            66335577,
            66343751,
            66352069,
            66344993,
            66344301,
            66348378,
            66362083,
            66352256,
            66376168,
            66345089,
            138527512,
            66378228,
            66393120,
            66349950,
            66338137,
            66353567,
            66351786
        ],
        "D1": [
            66334941,
            66334668,
            66343694,
            66345117,
            66344078,
            66344165,
            66344520,
            66350440,
            66349159,
            66376114,
            66339049,
            66358201,
            66357642,
            66351611,
            66357362,
            66352980,
            66346482,
            66338263,
            66345809,
            66347614
        ],
        "A": [
            66330725,
            66323882,
            66323064,
            66323750,
            66337390,
            66323088,
            66323240,
            66323608,
            66323803,
            66375789,
            66323639,
            66328235,
            66324332,
            66323365,
            66323990,
            66326030,
            66323496,
            66322830,
            66323987,
            66323760
        ],
        "C": [
            66326327,
            66330012,
            66334720,
            66339910,
            66341281,
            66334697,
            66340151,
            66333112,
            66337232,
            66376069,
            66331626,
            66349943,
            66341121,
            66340814,
            66329673,
            66346210,
            66334293,
            66333006,
            66337575,
            66339417,
            66355906
        ],
        "E": [
            66322750,
            66338115,
            66328737,
            66333356,
            66334932,
            66353827,
            66331679,
            66338428,
            66427601,
            66422500,
            66422400,
            66421563,
            66419015,
            66419013,
            66380135,
            66362673,
            66361972,
            66357957,
            66377834,
            66346874,
            66338003,
            66349170,
            66358017,
            66342846,
            66355768,
            66361241,
            66346679
        ],
        "F": [
            66498558,
            115183857
        ]
    },
    "name": "C. Beautiful Mirrors with queries",
    "statement": "Creatnx has n mirrors, numbered from 1 to n. Every day, Creatnx asks\r\nexactly one mirror \"Am I beautiful?\". The i-th mirror will tell Creatnx\r\nthat he is beautiful with probability\r\nfrac{p_i}{100} for all 1\r\nle i\r\nle n.. Initially, only the 1st mirror is a checkpoint. It remains a\r\ncheckpoint all the time.Creatnx asks the mirrors one by one, starting\r\nfrom the 1-st mirror. Every day, if he asks i-th mirror, there are two\r\npossibilities: The i-th mirror tells Creatnx that he is beautiful. In\r\nthis case, if i = n Creatnx will stop and become happy, otherwise he\r\nwill continue asking the i+1-th mirror next day; In the other case,\r\nCreatnx will feel upset. The next day, Creatnx will start asking . . You\r\nare given q queries, each query is represented by an integer u: If the\r\nu-th mirror isn\u2019t a checkpoint then we set it as a checkpoint.\r\nOtherwise, the u-th mirror is no longer a checkpoint.After each query,\r\nyou need to calculate the expected number of days until Creatnx becomes\r\nhappy.Each of this numbers should be found by modulo 998244353.\r\nFormally, let M = 998244353. It can be shown that the answer can be\r\nexpressed as an irreducible fraction\r\nfrac{p}{q}, where p and q are integers and q\r\nnot\r\nequiv 0\r\npmod{M}. Output the integer equal to p\r\ncdot q^{-1}\r\nbmod M. In other words, output such an integer x that 0\r\nle x < M and x\r\ncdot q\r\nequiv p\r\npmod{M}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353 ;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\n\nint n,q,p,u;\nset<int> hs;\nll f[N],mf[N],imf[N],smf[N],ans;\n\nll query(int l,int r) {\n\treturn (smf[l]-smf[r+1])*imf[r+1]%mod;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&q);\n\trep(i,1,n+1) {\n\t\tscanf(\"%d\",&p);\n\t\tf[i]=100*powmod(p,mod-2)%mod;\n\t}\n\tmf[n+1]=1;\n\timf[n+1]=1;\n\tper(i,1,n+1) {\n\t\tmf[i]=f[i]*mf[i+1]%mod;\n\t\timf[i]=powmod(mf[i],mod-2);\n\t\tsmf[i]=(smf[i+1]+mf[i])%mod;\n\t}\n\ths.insert(1);\n\ths.insert(n+1);\n\tans=query(1,n);\n\trep(i,0,q) {\n\t\tscanf(\"%d\",&u);\n\t\tif (hs.count(u)) {\n\t\t\tauto it=hs.find(u);\n\t\t\tauto pit=it,qit=it;\n\t\t\tpit--; qit++;\n\t\t\tans-=query(*pit,*it-1);\n\t\t\tans-=query(*it,*qit-1);\n\t\t\tans+=query(*pit,*qit-1);\n\t\t\ths.erase(u);\n\t\t} else {\n\t\t\ths.insert(u);\n\t\t\tauto it=hs.find(u);\n\t\t\tauto pit=it,qit=it;\n\t\t\tpit--; qit++;\n\t\t\tans+=query(*pit,*it-1);\n\t\t\tans+=query(*it,*qit-1);\n\t\t\tans-=query(*pit,*qit-1);\n\t\t}\n\t\tans%=mod;\n\t\tif (ans<0) ans+=mod;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "probabilities"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Beautiful Mirrors with queries.json",
    "editorial_link": "https://codeforces.com/blog/entry/71995",
    "editorial": "Assuming that currently there are checkpoints , the journey becoming\r\nhappy of Creatnx can be divided to stages where in -th stage Creatnx\r\n\"moving\" from mirror to mirror at position . Denote the -th stage as .\r\nThese stages are independent so the sum of expected number of days\r\nCreatnx spending in each stage will be the answer to this problem.When a\r\nnew checkpoint appear between 2 old checkpoints and , stage will be\r\nremoved from the set of stages and 2 new stages will be added, they are\r\nand . Similarly, when a checkpoint between 2 checkpoints and is no\r\nlonger a checkpoint, 2 stages and will be removed from the set of stages\r\nand new stage will be added. These removed/added stages can be fastly\r\nretrieved by storing all checkpoints in an ordered data structure such\r\nas in C++. For removed/added stages, we subtract/add its expected number\r\nof days from/to the current answer. We see that when a query occurs, the\r\nnumber of stages removed/added is small (just 3 in total). Therefore, if\r\nwe can calculate the expected number of days for an arbitrary stage fast\r\nenough, we can answer any query in a reasonable time.From the solution\r\nof problem Beautiful Mirror, we know that the expected number of days\r\nCreatnx spending in stage is: The denominator can be computed by using a\r\nprefix product array a common useful trick. We prepare an array where .\r\nAfter that, can be obtained by using 1 division: .For numerator , we\r\nalso use the same trick. An array will be prepare where . We have so .\r\n"
}