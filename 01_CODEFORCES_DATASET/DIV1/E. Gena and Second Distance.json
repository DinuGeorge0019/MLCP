{"link": "https://codeforces.com//contest/442/problem/E", "problemId": "10515", "problem_idx": "E", "shortId": "442E", "contest_number": "442", "problem_submissions": {"E": [6921847, 6938403], "C": [6919336, 6917056, 6920953, 6916705, 6918582, 6918908, 6921923, 6921586, 6918715, 6919667, 6919614, 6925095, 6918272, 6918805, 6919118], "D": [6917753, 6918850, 6915556, 6918817, 6920381, 6944679, 6921502, 6920210, 6921312, 6921510, 6918431, 6923717, 6920981, 6920504, 6918960], "B": [6916976, 6915574, 6916305, 6915680, 6916666, 6917064, 6917904, 6915565, 6916220, 6916648, 6916245, 6918094, 6915819, 6916307, 6917195, 6916646, 6916658, 6921189], "A": [6914458, 6914295, 6918545, 6915241, 6915516, 6914863, 6915569, 6914808, 6914997, 6914852, 6914659, 6915403, 6914675, 6915467, 6916072, 6920156, 6915628, 6915075]}, "name": "E. Gena and Second Distance", "statement": "Gena doesn\u2019t like geometry, so he asks you to solve this problem for\r\nhim.A rectangle with sides parallel to coordinate axes contains dots.\r\nLet\u2019s consider some point of the plane. Let\u2019s count the distances from\r\nthis point to the given points. Let\u2019s sort these numbers in the\r\nnon-decreasing order. We\u2019ll call the beauty of the point the second\r\nelement of this array. If there are two mimimum elements in this array,\r\nthe beaty will be equal to this minimum.Find the maximum beauty of a\r\npoint inside the given rectangle.\r\n", "solutions": ["#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 4010;\n\ninline double get_dist(double xa, double ya, double xb, double yb) {\n  return (xa - xb) * (xa - xb) + (ya - yb) * (ya - yb);\n}\n\nconst double eps = 1e-9;\n\ndouble x[N], y[N];\ndouble xx[N], yy[N];\n\nvoid cut(int &cnt, double aa, double bb, double cc) {\n  x[cnt] = x[0]; y[cnt] = y[0];\n  int ncnt = 0;\n  for (int i = 0; i < cnt; i++) {\n    double z = aa * x[i] + bb * y[i] + cc;\n    if (z < eps) {\n      xx[ncnt] = x[i];\n      yy[ncnt] = y[i];\n      ncnt++;\n    }\n    double zn = aa * x[i + 1] + bb * y[i + 1] + cc;\n    if ((z < -eps && zn > eps) || (z > eps && zn < -eps)) {\n      double a = y[i + 1] - y[i];\n      double b = x[i] - x[i + 1];\n      double c = -a * x[i] - b * y[i];\n      double d = a * bb - b * aa;\n      xx[ncnt] = (b * cc - c * bb) / d;\n      yy[ncnt] = (c * aa - a * cc) / d;\n      ncnt++;\n    }\n  }\n  cnt = ncnt;\n  for (int i = 0; i < cnt; i++) {\n    x[i] = xx[i];\n    y[i] = yy[i];\n  }\n}\n\npair <int, int> p[N];\nint weight[N];\n\ndouble ox[N], oy[N];\n\nint main() {\n  int w, h, n;\n  scanf(\"%d %d %d\", &w, &h, &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &p[i].first, &p[i].second);\n  }\n  sort(p, p + n);\n  int nn = 1;\n  weight[0] = 1;\n  for (int i = 1; i < n; i++) {\n    if (p[i] == p[nn - 1]) {\n      weight[nn - 1]++;\n    } else {\n      p[nn] = p[i];\n      weight[nn] = 1;\n      nn++;\n    }\n  }\n  n = nn;\n  double ans = 0.0;\n  for (int st = 0; st < n; st++) {\n    int cnt = 4;\n    x[0] = 0; y[0] = 0;\n    x[1] = w; y[1] = 0;\n    x[2] = w; y[2] = h;\n    x[3] = 0; y[3] = h;\n    for (int i = 0; i < n; i++) {\n      double aa = p[i].first - p[st].first;\n      double bb = p[i].second - p[st].second;\n      double cc = -aa * 0.5 * (p[i].first + p[st].first) - bb * 0.5 * (p[i].second + p[st].second);\n      cut(cnt, aa, bb, cc);\n    }\n    if (weight[st] >= 2) {\n      for (int i = 0; i < cnt; i++) {\n        double dist = get_dist(x[i], y[i], p[st].first, p[st].second);\n        if (dist > ans) {\n          ans = dist;\n        }\n      }\n      continue;\n    }\n    x[cnt] = x[0]; y[cnt] = y[0];\n    vector <int> pts;\n    for (int i = 0; i < cnt; i++) {\n      double xm = 0.5 * (x[i] + x[i + 1]);\n      double ym = 0.5 * (y[i] + y[i + 1]);\n      double mn = 1e20;\n      int km = -1;\n      for (int j = 0; j < n; j++) {\n        if (j == st) {\n          continue;\n        }\n        double cur = get_dist(xm, ym, p[j].first, p[j].second);\n        if (cur < mn) {\n          mn = cur;\n          km = j;\n        }\n      }\n      pts.push_back(km);\n    }\n    int ocnt = cnt;\n    for (int i = 0; i < cnt; i++) {\n      ox[i] = x[i];\n      oy[i] = y[i];\n    }\n    int sz = pts.size();\n    for (int jj = 0; jj < sz; jj++) {\n      int pt = pts[jj];\n      cnt = ocnt;\n      for (int i = 0; i < cnt; i++) {\n        x[i] = ox[i];\n        y[i] = oy[i];\n      }\n      for (int u = 0; u < sz; u++) {\n        if (u == jj) {\n          continue;\n        }\n        int i = pts[u];\n        double aa = p[i].first - p[pt].first;\n        double bb = p[i].second - p[pt].second;\n        double cc = -aa * 0.5 * (p[i].first + p[pt].first) - bb * 0.5 * (p[i].second + p[pt].second);\n        cut(cnt, aa, bb, cc);\n      }\n      for (int i = 0; i < cnt; i++) {\n        double dist = get_dist(x[i], y[i], p[pt].first, p[pt].second);\n        if (dist > ans) {\n          ans = dist;\n        }\n      }\n    }\n  }\n  printf(\"%.17lf\\n\", sqrt(ans));\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["geometry"], "dificulty": "3100", "interactive": false}