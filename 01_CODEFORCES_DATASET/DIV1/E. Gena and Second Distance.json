{
    "link": "https://codeforces.com//contest/442/problem/E",
    "problemId": "10515",
    "problem_idx": "E",
    "shortId": "442E",
    "contest_number": "442",
    "problem_submissions": {
        "E": [
            6921847,
            6938403
        ],
        "C": [
            6919336,
            6917056,
            6920953,
            6916705,
            6918582,
            6918908,
            6921923,
            6921586,
            6918715,
            6919667,
            6919614,
            6925095,
            6918272,
            6918805,
            6919118
        ],
        "D": [
            6917753,
            6918850,
            6915556,
            6918817,
            6920381,
            6944679,
            6921502,
            6920210,
            6921312,
            6921510,
            6918431,
            6923717,
            6920981,
            6920504,
            6918960
        ],
        "B": [
            6916976,
            6915574,
            6916305,
            6915680,
            6916666,
            6917064,
            6917904,
            6915565,
            6916220,
            6916648,
            6916245,
            6918094,
            6915819,
            6916307,
            6917195,
            6916646,
            6916658,
            6921189
        ],
        "A": [
            6914458,
            6914295,
            6918545,
            6915241,
            6915516,
            6914863,
            6915569,
            6914808,
            6914997,
            6914852,
            6914659,
            6915403,
            6914675,
            6915467,
            6916072,
            6920156,
            6915628,
            6915075
        ]
    },
    "name": "E. Gena and Second Distance",
    "statement": "Gena doesn’t like geometry, so he asks you to solve this problem for\r\nhim.A rectangle with sides parallel to coordinate axes contains dots.\r\nLet’s consider some point of the plane. Let’s count the distances from\r\nthis point to the given points. Let’s sort these numbers in the\r\nnon-decreasing order. We’ll call the beauty of the point the second\r\nelement of this array. If there are two mimimum elements in this array,\r\nthe beaty will be equal to this minimum.Find the maximum beauty of a\r\npoint inside the given rectangle.\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 4010;\n\ninline double get_dist(double xa, double ya, double xb, double yb) {\n  return (xa - xb) * (xa - xb) + (ya - yb) * (ya - yb);\n}\n\nconst double eps = 1e-9;\n\ndouble x[N], y[N];\ndouble xx[N], yy[N];\n\nvoid cut(int &cnt, double aa, double bb, double cc) {\n  x[cnt] = x[0]; y[cnt] = y[0];\n  int ncnt = 0;\n  for (int i = 0; i < cnt; i++) {\n    double z = aa * x[i] + bb * y[i] + cc;\n    if (z < eps) {\n      xx[ncnt] = x[i];\n      yy[ncnt] = y[i];\n      ncnt++;\n    }\n    double zn = aa * x[i + 1] + bb * y[i + 1] + cc;\n    if ((z < -eps && zn > eps) || (z > eps && zn < -eps)) {\n      double a = y[i + 1] - y[i];\n      double b = x[i] - x[i + 1];\n      double c = -a * x[i] - b * y[i];\n      double d = a * bb - b * aa;\n      xx[ncnt] = (b * cc - c * bb) / d;\n      yy[ncnt] = (c * aa - a * cc) / d;\n      ncnt++;\n    }\n  }\n  cnt = ncnt;\n  for (int i = 0; i < cnt; i++) {\n    x[i] = xx[i];\n    y[i] = yy[i];\n  }\n}\n\npair <int, int> p[N];\nint weight[N];\n\ndouble ox[N], oy[N];\n\nint main() {\n  int w, h, n;\n  scanf(\"%d %d %d\", &w, &h, &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &p[i].first, &p[i].second);\n  }\n  sort(p, p + n);\n  int nn = 1;\n  weight[0] = 1;\n  for (int i = 1; i < n; i++) {\n    if (p[i] == p[nn - 1]) {\n      weight[nn - 1]++;\n    } else {\n      p[nn] = p[i];\n      weight[nn] = 1;\n      nn++;\n    }\n  }\n  n = nn;\n  double ans = 0.0;\n  for (int st = 0; st < n; st++) {\n    int cnt = 4;\n    x[0] = 0; y[0] = 0;\n    x[1] = w; y[1] = 0;\n    x[2] = w; y[2] = h;\n    x[3] = 0; y[3] = h;\n    for (int i = 0; i < n; i++) {\n      double aa = p[i].first - p[st].first;\n      double bb = p[i].second - p[st].second;\n      double cc = -aa * 0.5 * (p[i].first + p[st].first) - bb * 0.5 * (p[i].second + p[st].second);\n      cut(cnt, aa, bb, cc);\n    }\n    if (weight[st] >= 2) {\n      for (int i = 0; i < cnt; i++) {\n        double dist = get_dist(x[i], y[i], p[st].first, p[st].second);\n        if (dist > ans) {\n          ans = dist;\n        }\n      }\n      continue;\n    }\n    x[cnt] = x[0]; y[cnt] = y[0];\n    vector <int> pts;\n    for (int i = 0; i < cnt; i++) {\n      double xm = 0.5 * (x[i] + x[i + 1]);\n      double ym = 0.5 * (y[i] + y[i + 1]);\n      double mn = 1e20;\n      int km = -1;\n      for (int j = 0; j < n; j++) {\n        if (j == st) {\n          continue;\n        }\n        double cur = get_dist(xm, ym, p[j].first, p[j].second);\n        if (cur < mn) {\n          mn = cur;\n          km = j;\n        }\n      }\n      pts.push_back(km);\n    }\n    int ocnt = cnt;\n    for (int i = 0; i < cnt; i++) {\n      ox[i] = x[i];\n      oy[i] = y[i];\n    }\n    int sz = pts.size();\n    for (int jj = 0; jj < sz; jj++) {\n      int pt = pts[jj];\n      cnt = ocnt;\n      for (int i = 0; i < cnt; i++) {\n        x[i] = ox[i];\n        y[i] = oy[i];\n      }\n      for (int u = 0; u < sz; u++) {\n        if (u == jj) {\n          continue;\n        }\n        int i = pts[u];\n        double aa = p[i].first - p[pt].first;\n        double bb = p[i].second - p[pt].second;\n        double cc = -aa * 0.5 * (p[i].first + p[pt].first) - bb * 0.5 * (p[i].second + p[pt].second);\n        cut(cnt, aa, bb, cc);\n      }\n      for (int i = 0; i < cnt; i++) {\n        double dist = get_dist(x[i], y[i], p[pt].first, p[pt].second);\n        if (dist > ans) {\n          ans = dist;\n        }\n      }\n    }\n  }\n  printf(\"%.17lf\\n\", sqrt(ans));\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Gena and Second Distance.json",
    "editorial_link": "https://codeforces.com//blog/entry/12739",
    "editorial": "To solve this problem we can use a binary search. How do we check that\r\nanswer if not less than ? It means that we can draw a circle with such\r\nradius which center locates in the rectangle and there are no more than\r\none point inside this circle. How could we check it? We always can shift\r\nthis circle in such a way that at least one point would be on its\r\nborder. We can try all points as one which is on border. Than we should\r\ndraw a circle with center in it and intersect it with circles built on\r\nother points. If there is a point on this circle which is covered with\r\nno more than one other circle, than answer is greater or equal . Finding\r\nsuch point is almost a typical problem which can be solved in where\r\nnumber of intersections points of circles. We described a solution which\r\nworks in . But we can make it faster. Letâs try all vertices as centers\r\nof circles and inside this loop make a binary search. We can make one\r\noptimize: if we canât find a point on circle with radius which is equal\r\nto the best now known than we shouldnât do a binary search in this point\r\n(because we canât increase the answer). It can be proved that this\r\nsolution in avarage case works in if we shuffle points. Itâs true\r\nbecause a binary search will be used in avarage only times. To prove\r\nthis fact letâs look at probability of binary search to be used in -th\r\nstep. If all values are different and shuffled it is . It is known that\r\nsum of first elements of this sirie is bounded by . In this task there\r\nare some technical issues you need to know about. For example, we would\r\ndo a binary search only times if we find a stricly incresing subseqence\r\nof answers. Thatâs why before using a binary search we should check that\r\nwe can obtain not current answer but current answer plus some small\r\nvalue. Also we need to understand what \"small value\" is (it should be\r\nsomething like , where , in another case you will probably have some\r\nproblems with accuracy). Also one interesting fact about this problem.\r\nIf you write a solution with time compexity equal to , it will work very\r\nfast on random tests becaue there are will be a very small number of\r\ncircle intersections.\r\n",
    "hint": []
}