{"link": "https://codeforces.com//contest/251/problem/D", "problemId": "2348", "problem_idx": "D", "shortId": "251D", "contest_number": "251", "problem_submissions": {"C": [2708116, 2703586, 2704109, 2703232, 2706506, 2702257, 2703703, 2703280, 2704115, 2703686, 2705486, 2704984, 2704534, 2705165, 2704884, 2705233], "D": [2706516, 2706940, 2707149, 2704789, 2714168, 2709244, 2963073], "B": [2702885, 2710707, 2702748, 2702944, 2703852, 2706610, 2702523, 2702863, 2704268, 2703034, 2702681, 2702420, 2702396, 2702786, 2702560], "A": [2700911, 2700969, 2701184, 2701021, 2701182, 2704236, 2701557, 2700957, 2701183, 2703855, 2701084, 2701446, 2701163, 2701237, 2701243, 2701186]}, "name": "D. Two Sets", "statement": "Little Petya likes numbers a lot. Recently his mother has presented him\r\na collection of non-negative integers. There\u2019s only one thing Petya\r\nlikes more than numbers: playing with little Masha. He immediately\r\ndecided to give a part of his new collection to her. To make the game\r\neven more interesting, Petya decided to give Masha such collection of\r\nnumbers for which the following conditions fulfill: Let\u2019s introduce to\r\ndenote the of all numbers Petya has got left; and let\u2019s introduce to\r\ndenote the of all numbers he gave to Masha. Value must be as large as\r\npossible. If there are multiple ways to divide the collection so that\r\nthe previous condition fulfilled, then Petya minimizes the value . The\r\noperation is a bitwise excluding \"\", that is denoted as \"\" in the Pascal\r\nlanguage and \"\" in C/C++/Java.Help Petya divide the collection as\r\ndescribed above. If there are multiple suitable ways to divide it, find\r\nany of them. Please note that after Petya gives a part of his numbers to\r\nMasha, he may have no numbers left. The reverse situation is also\r\npossible, when Petya gives nothing to Masha. In both cases we must\r\nassume that the of an empty set of numbers equals 0.\r\n", "solutions": ["#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nconst int N = 222222;\nconst int m = 62;\n\nlong long a[N], b[N], mask[N];\nint c[N], n, who[N];\nint need[N], used[N];\n\nbool can() {\n  int i, j, k;\n  for (i=0;i<n;i++) b[i] = a[i], mask[i] = 0, used[i] = 0;\n  for (j=m-1;j>=0;j--)\n    if (need[j] != -1) {\n      who[j] = -1;\n      for (i=0;i<n;i++)\n        if (!used[i] && (b[i] & (1LL << j))) {\n          used[i] = 1;\n          who[j] = i;\n          mask[i] |= (1LL << j);\n          for (k=0;k<n;k++)\n            if (i != k && (b[k] & (1LL << j))) {\n              b[k] ^= b[i];\n              mask[k] ^= mask[i];\n            }\n          break;\n        }\n    }\n  long long have = 0, ms = 0;\n  for (j=m-1;j>=0;j--)\n    if (need[j] != -1) {\n      if ((!!(have & (1LL << j))) != need[j]) {\n        if (who[j] == -1) return false;\n        have ^= b[who[j]];\n        ms ^= mask[who[j]];\n      }\n    }\n  for (i=0;i<n;i++) c[i] = 2;\n  for (j=0;j<m;j++)\n    if (ms & (1LL << j)) c[who[j]] = 1;\n  return true;\n}\n\nint main() {\n//  freopen(\"in\", \"r\", stdin);\n//  freopen(\"out\", \"w\", stdout);\n  int i, j;\n  scanf(\"%d\", &n);\n  for (i=0;i<n;i++) scanf(\"%I64d\", &a[i]);\n  long long X = 0;\n  for (i=0;i<n;i++) X ^= a[i];\n  for (j=0;j<m;j++) need[j] = -1;\n  for (j=m-1;j>=0;j--)\n    if (!(X & (1LL << j))) {\n      need[j] = 1;\n      if (!can()) need[j] = 0;\n    }\n  for (j=m-1;j>=0;j--)\n    if (X & (1LL << j)) {\n      need[j] = 0;\n      if (!can()) need[j] = 1;\n    }\n  can();\n  for (i=0;i<n-1;i++) printf(\"%d \", c[i]);\n  printf(\"%d\\n\", c[n-1]);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "math"], "dificulty": "2700", "interactive": false}