{
    "link": "https://codeforces.com//contest/1149/problem/E",
    "problemId": "337473",
    "problem_idx": "E",
    "shortId": "1149E",
    "contest_number": "1149",
    "problem_submissions": {
        "E": [
            53524396,
            53522321,
            53522530,
            61434525,
            53525980,
            53522711,
            53522606,
            53524594
        ],
        "D": [
            53521434,
            53526235,
            53529930,
            53518623,
            53524984,
            53524746,
            53526493,
            53518787,
            53526308,
            53526383,
            53526628,
            53531041,
            53521860,
            53522269,
            53523326,
            53523444
        ],
        "C": [
            53514328,
            53518841,
            53519044,
            53525230,
            53518371,
            53511307,
            53515929,
            53520465,
            53525523,
            53518004,
            53522574,
            53520365,
            53530616,
            53530825
        ],
        "B": [
            53508704,
            53508119,
            53512032,
            53509531,
            53508225,
            53520230,
            53523389,
            53511171,
            53521543,
            53521758,
            53512839,
            53514480,
            53510228,
            53510444,
            53509691,
            53512920,
            53514615,
            53513077,
            53514341
        ],
        "A": [
            53502075,
            53501727,
            53502902,
            53502745,
            53502146,
            53501598,
            53502759,
            53502876,
            53503703,
            53505214,
            53502973,
            53503023,
            53501694,
            53501955,
            53501687,
            53504126,
            53504632,
            53504664,
            53501821
        ]
    },
    "name": "E. Election Promises",
    "statement": "In Byteland, there are two political parties fighting for seats in the\r\nParliament in the upcoming elections: and . As they want to convince as\r\nmany citizens as possible to cast their votes on them, they keep\r\npromising lower and lower taxes.There are n cities in Byteland,\r\nconnected by m one-way roads. Interestingly enough, the road network has\r\nno cycles it\u2019s impossible to start in any city, follow a number of\r\nroads, and return to that city. Last year, citizens of the i-th city had\r\nto pay h_i bourles of tax.Parties will now alternately hold the election\r\nconventions in various cities. If a party holds a convention in city v,\r\nthe party needs to the taxes in this city to a non-negative integer\r\namount of bourles. However, at the same time they can arbitrarily modify\r\nthe taxes in each of the cities that can be reached from v using a\r\nsingle road. The only condition that must be fulfilled that the tax in\r\neach city has to remain a non-negative integer amount of bourles.The\r\nfirst party to hold the convention is . It\u2019s predicted that the party to\r\nhold the last convention will win the election. Can win regardless of \u2019s\r\nmoves?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nvector<int> g[N];\nint ord[N];\nint ordSz;\nbool used[N];\nint n, m;\nint a[N];\nint b[N];\nint c[N];\nbool mex[N];\n\nvoid dfs(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v]) {\n\t\tif (used[u]) continue;\n\t\tdfs(u);\n\t}\n\tord[ordSz++] = v;\n}\n\nvoid printAns(int v) {\n\ta[v] ^= c[b[v]];\n\tc[b[v]] = 0;\n\tfor (int u : g[v]) {\n\t\ta[u] ^= c[b[u]];\n\t\tc[b[u]] = 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", a[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\t\tdfs(i);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = ord[i];\n\t\tfor (int j = 0; j <= (int)g[v].size(); j++)\n\t\t\tmex[j] = 0;\n\t\tfor (int u : g[v])\n\t\t\tmex[b[u]] = 1;\n\t\tb[v] = 0;\n\t\twhile(mex[b[v]]) b[v]++;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tc[b[i]] ^= a[i];\n\tint mx = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (c[i] != 0)\n\t\t\tmx = i;\n\t}\n\tif (mx == -1) {\n\t\tprintf(\"LOSE\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"WIN\\n\");\n\tfor (int v = 0; v < n; v++) {\n\t\tif (b[v] != mx) continue;\n\t\tif ((a[v] ^ c[mx]) > a[v]) continue;\n\t\tprintAns(v);\n\t\treturn 0;\n\t}\n\tthrow;\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "graphs"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Election Promises.json",
    "editorial_link": "https://codeforces.com/blog/entry/66783",
    "editorial": "Let\u00e2\u0080\u0099s get straight to the main lemma: For any vertex , let\u00e2\u0080\u0099s define the\r\nof as where is the minimum-excluded function. Moreover, for any , let be\r\nthe xor-sum of the taxes in all cities fulfilling ; that is, . The\r\nstarting party loses if and only if for all \u00e2\u0080\u0099s; that is, if all xor-sums\r\nare equal to 0. Let\u00e2\u0080\u0099s consider any move from the position in which all\r\nxor-sums are zero. If we\u00e2\u0080\u0099re holding the convention in the city , then we\r\nthe amount of taxes in this city. Note however that there is no direct\r\nconnection from to any other city having the same level as , as is the\r\nsmallest integer the set . Therefore, there is exactly one tax value\r\nchanging at level , and thus the value must change. As it was zero\r\nbefore, it must become non-zero.Now consider any configuration where\r\nsome xor-sums are non-zero. Let be the highest level at which . We want\r\nto hold the election in a selected city at level . Which one? Notice\r\nthat no city at a single level is connected to each other, and therefore\r\nwe can only afford to pick one city and its tax. This is equivalent to\r\nthe game of Nim where each city corresponds to a single stack of stones.\r\nWe perform a single optimal move in this game: pick a city and decrease\r\nthe tax in the city by a non-zero amount of bourles, leading to the\r\nposition where the new xor-sum of the taxes at this level is equal to\r\nzero. We also need to take care of zeroing all \u00e2\u0080\u0099s for . This is however\r\nstraightforward: for each , pick a single city fulfilling at level\r\ndirectly reachable from (there must be one from the definition of ), and\r\nalter the value of tax in order to nullify .The proof above is actually\r\nconstructive and allows us to compute a single winning move in time.As a\r\nsmall bonus: if you\u00e2\u0080\u0099re into advanced game theory, you can come up with\r\nthe lemma above without much guesswork. One can compute the nimbers for\r\nthe state where there are no taxes anywhere except a single city where\r\nthe tax is equal to , and it turns out to be equal to where is the\r\nsmallest infinite ordinal number. Moreover, it\u00e2\u0080\u0099s not that hard to see\r\nthat the nimber for the state where there are more taxed cities is a\r\nnim-sum of the nimbers corresponding to the states with only one taxed\r\ncity. This all should quite naturally lead to the lemma above.\r\n"
}