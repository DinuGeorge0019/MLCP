{
    "link": "https://codeforces.com//contest/875/problem/E",
    "problemId": "128562",
    "problem_idx": "E",
    "shortId": "875E",
    "contest_number": "875",
    "problem_submissions": {
        "E": [
            31401553,
            31405129,
            31392967,
            31402730,
            31406263,
            31406095,
            31408958,
            31406910,
            31404200,
            32046810,
            31410002,
            31402646,
            31408382,
            31408030,
            31409057,
            31407519,
            31408444,
            31409422,
            31410812
        ],
        "F": [
            31398084,
            31399145,
            31396559,
            31395380,
            31403081,
            31400082,
            31403804,
            31406312,
            31396246,
            31399556,
            31401521,
            31404590,
            31400144,
            31400447,
            31405585,
            31400568,
            31400491
        ],
        "D": [
            31396611,
            31396495,
            31401963,
            31398464,
            31393353,
            31401930,
            31397316,
            31400838,
            31400178,
            31401960,
            31405520,
            31403500,
            31399600,
            31393212,
            31397813,
            31402582,
            31404085,
            31402819
        ],
        "C": [
            31393812,
            31393863,
            31406345,
            31407198,
            31398483,
            31396625,
            31396317,
            31397236,
            31394681,
            31407238,
            31393913,
            31402010,
            31410726,
            31409259,
            31398396,
            31400696,
            31397975
        ],
        "B": [
            31389883,
            31401063,
            31407394,
            31393529,
            31395934,
            31391146,
            31390806,
            31391837,
            31403535,
            31403703,
            31396960,
            31396617,
            31395546,
            31393934,
            31392682,
            31393141,
            31391081
        ],
        "A": [
            31388853,
            31388828,
            31407811,
            31389006,
            31389634,
            31389036,
            31388899,
            31388792,
            31388831,
            31388861,
            31388768,
            31390308,
            31389965,
            31388888,
            31389164,
            31388787,
            31388820
        ]
    },
    "name": "E. Delivery Club",
    "statement": "Petya and Vasya got employed as couriers. During the working day they\r\nare to deliver packages to different points on the line. According to\r\nthe companyâ€™s internal rules, the delivery of packages must be carried\r\nout strictly in a certain order. Initially, Petya is at the point with\r\nthe coordinate , Vasya is at the point with the coordinate , and the\r\nclients are at the points in the order of the required visit.The guys\r\nagree in advance who of them will deliver the package to which of the\r\ncustomers, and then they act as follows. When the package for the -th\r\nclient is delivered, the one who delivers the package to the -st client\r\nis sent to the path (it can be the same person who went to the point ,\r\nor the other). The friend who is not busy in delivering the current\r\npackage, is standing still.To communicate with each other, the guys have\r\ngot walkie-talkies. The walkie-talkies work rather poorly at great\r\ndistances, so Petya and Vasya want to distribute the orders so that the\r\nmaximum distance between them during the day is as low as possible. Help\r\nPetya and Vasya to minimize the maximum distance between them, observing\r\nall delivery rules.\r\n",
    "solutions": [
        "#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint n,x[100010],w[100010],f[100010][25],g[100010][25],u[100010],l,r;\ninline int minn(int l,int r)\n{\n\tint k=u[r-l+1];\n\treturn min(f[l][k],f[r-(1<<k)+1][k]);\n}\ninline int maxx(int l,int r)\n{\n\tint k=u[r-l+1];\n\treturn max(g[l][k],g[r-(1<<k)+1][k]);\n}\ninline bool check(int p)\n{\n\tint i,k,l,r,m,a,b;\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   for(l=i,r=n;l<r;)\n\t     {\n\t\t  m=(l+r+1>>1);\n\t\t  a=minn(i,m);\n\t\t  b=maxx(i,m);\n\t\t  if(a>=x[i]-p && b<=x[i]+p)\n\t\t    l=m;\n\t\t  else\n\t\t    r=m-1;\n\t\t }\n\t   w[i]=l;\n\t  }\n\tfor(i=3,k=max(w[1],w[2]);i<=k;i++)\n\t  k=max(k,w[i]);\n\treturn i>n;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tn+=2;\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tfor(i=n;i>0;i--)\n\t  {\n\t   f[i][0]=g[i][0]=x[i];\n\t   for(j=1;j<=20;j++)\n\t     {\n\t\t  f[i][j]=min(f[i][j-1],f[min(i+(1<<j-1),n)][j-1]);\n\t\t  g[i][j]=max(g[i][j-1],g[min(i+(1<<j-1),n)][j-1]);\n\t\t }\n\t  }\n\tfor(i=2;i<=n;i++)\n\t  u[i]=u[i>>1]+1;\n\tfor(l=abs(x[1]-x[2]),r=1000000000;l<r;)\n\t  if(check(l+r>>1))\n\t    r=(l+r>>1);\n\t  else\n\t    l=(l+r>>1)+1;\n\tprintf(\"%d\\n\",l);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Delivery Club.json",
    "editorial_link": "https://codeforces.com//blog/entry/55233",
    "editorial": "We will learn to check that the answer is no more . If we learn to do\r\nthis, we can make a binary search for the answer and get the answer.To\r\ncheck we calculate is it possible to process the first orders so that\r\nthe last order of one courier is , and the second order is . In this\r\ncase, the transition can be done immediately by several steps\r\nforward.Transition from to means that the first courier will execute the\r\norders , and the second the order with the number . The transition can\r\nbe made if and for all from to .It may be rewritten as , and so the\r\nmaximum for given can be found using segment tree or analogical\r\nstructure. After that you only set to all possible on the segment. It\r\ncan be done for example going along the massive and knowing maximum\r\nsegment of possible .The solution works in .\r\n",
    "hint": []
}