{"link": "https://codeforces.com//contest/506/problem/B", "problemId": "20821", "problem_idx": "B", "shortId": "506B", "contest_number": "506", "problem_submissions": {"C": [9464348, 9463979, 9557239, 9466208, 9514381], "D": [9461125, 9461876, 9460334, 9459573, 9458109, 9460700, 9459375, 9461634, 9460457, 9461910, 9458643, 9460232, 9462018, 9462258, 9460016, 9460009, 9459977, 9462409, 9460765], "B": [9459503, 9458315, 9457879, 9457557, 9459219, 9458249, 9461319, 9459208, 9457985, 9457950, 9462161, 9459453, 9458782, 9461373, 9462464, 9462819, 9459210, 9458536], "A": [9456602, 9456438, 9456462, 9456507, 9460135, 9456591, 9456641, 9456514, 9463082, 9456214, 9463955, 9457315, 9456528, 9457236, 9463962, 9457919, 9457204, 9456634, 9464389], "E": [9557214]}, "name": "B. Mr. Kitayuta s Technology", "statement": "Shuseki Kingdom is the world\u2019s leading nation for innovation and\r\ntechnology. There are cities in the kingdom, numbered from to .Thanks to\r\nMr. Kitayuta\u2019s research, it has finally become possible to construct\r\nteleportation pipes between two cities. A teleportation pipe will\r\nconnect two cities unidirectionally, that is, a teleportation pipe from\r\ncity to city cannot be used to travel from city to city . The\r\ntransportation within each city is extremely developed, therefore if a\r\npipe from city to city and a pipe from city to city are both\r\nconstructed, people will be able to travel from city to city\r\ninstantly.Mr. Kitayuta is also involved in national politics. He\r\nconsiders that the transportation between the pairs of city () is\r\nimportant. He is planning to construct teleportation pipes so that for\r\neach important pair , it will be possible to travel from city to city by\r\nusing one or more teleportation pipes (but not necessarily from city to\r\ncity ). Find the minimum number of teleportation pipes that need to be\r\nconstructed. So far, no teleportation pipe has been constructed, and\r\nthere is no other effective transportation between cities.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:33554432\")\n\n#include <cstdio>\n#include <map>\n#include <memory.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint n,m;\nvector<int> gnext[100003];\nvector<int> grev[100003];\nint v[100003];\nint color[100003], curcolor;\nint c2cycle[100003];\n\nvector<int> finishqueue;\nvoid dfs(int nod) {\n\tv[nod] = 1;\n\tfor (int i = 0; i < gnext[nod].size(); i++) {\n\t\tint next = gnext[nod][i];\n\t\tif (v[next]) continue;\n\t\tdfs(next);\n\t}\n\tfinishqueue.push_back(nod);\n}\n\nvector<int> newqueue;\nvoid dfs2(int nod) {\n\tv[nod] = 2;\n\tcolor[nod] = curcolor;\n\tfor (int i = 0; i < grev[nod].size(); i++) {\n\t\tint next = grev[nod][i];\n\t\tif (v[next] == 2) continue;\n\t\tdfs2(next);\n\t}\n\tnewqueue.push_back(nod);\n}\n\nint grp[100003];\nbool hascycle[100003];\nint getgrp(int nod) {\n\treturn nod == grp[nod] ? nod : (grp[nod] = getgrp(grp[nod]));\n}\nvoid mergegrp(int a, int b) {\n\tbool c = hascycle[getgrp(b)] || hascycle[getgrp(a)];\n\tgrp[getgrp(a)] = getgrp(b);\n\thascycle[getgrp(b)] = c;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i = 0; i < n; i++) grp[i] = i;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--,b--;\n\t\tgnext[a].push_back(b);\n\t\tgrev[b].push_back(a);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) if (v[i] == 0) dfs(i);\n\tfor (int i = n-1; i >= 0; i--) {\n\t\tint cur = finishqueue[i];\n\t\tif (v[cur] == 2) continue;\n\t\tnewqueue.clear();\n\t\tdfs2(cur);\n\t\tcurcolor++;\n\t\tfor (int j = 0; j < newqueue.size(); j++) {\n\t\t\tint p = newqueue[j];\n\t\t\tfor (int k = 0; k < grev[p].size(); k++) {\n\t\t\t\tmergegrp(color[grev[p][k]], color[p]);\n\t\t\t}\n\t\t}\n\t\tif (newqueue.size() >= 2) {\n\t\t\thascycle[color[newqueue[0]]] = true;\n\t\t}\n\t}\n\tans = n;\n\tfor (int i = 0; i < curcolor; i++) {\n\t\tif (grp[i] != i) continue;\n\t\tif (!hascycle[i]) ans--;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "graphs"], "dificulty": "2200", "interactive": false}