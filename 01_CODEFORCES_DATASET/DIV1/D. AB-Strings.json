{
    "link": "https://codeforces.com//contest/1012/problem/D",
    "problemId": "203194",
    "problem_idx": "D",
    "shortId": "1012D",
    "contest_number": "1012",
    "problem_submissions": {
        "D": [
            40965345,
            40960627,
            40962755,
            40958672,
            40960130,
            40960868,
            40957816,
            40962185,
            40977537,
            40977026,
            40958559,
            40961785,
            40963025,
            40963296,
            40964134,
            40968496,
            40964728
        ],
        "E": [
            40960617,
            40966609,
            40966430,
            40968315,
            40959955,
            40968344,
            41293524,
            40971324,
            40961945,
            40965219,
            40964178,
            40964935,
            40966686
        ],
        "C": [
            40946223,
            40950962,
            40949847,
            40947169,
            40948884,
            40951113,
            40948032,
            40950863,
            40949840,
            40948978,
            40950249,
            40944733,
            40947497,
            40951510,
            40946864,
            40950557,
            40948982,
            40953572,
            40952480,
            40955310
        ],
        "B": [
            40942792,
            40947068,
            40945179,
            40941414,
            40943485,
            40944363,
            40943466,
            40948512,
            40943709,
            40942617,
            40946516,
            40941822,
            40945156,
            40945233,
            40943297,
            40953601,
            40943064,
            40946807,
            40947838,
            40944988
        ],
        "A": [
            40940407,
            40940426,
            40944393,
            40940053,
            40941238,
            40941590,
            40941675,
            40939828,
            40941205,
            40939974,
            40940704,
            40939790,
            40943152,
            40941982,
            40942155,
            40942198,
            40952349,
            40943555,
            40944486,
            40941409
        ],
        "F": [
            41294072,
            40975225,
            40975082,
            48927133,
            48926928,
            48926890,
            48926661,
            48926482,
            48926274,
            48926240,
            48926110,
            48925986,
            48925954,
            48925448,
            48924606
        ]
    },
    "name": "D. AB-Strings",
    "statement": "There are two strings and , consisting only of letters and . You can\r\nmake the following operation several times: choose a prefix of , a\r\nprefix of and swap them. Prefixes , also a prefix can coincide with a\r\nwhole string. Your task is to find a sequence of operations after which\r\none of the strings consists only of letters and the other consists only\r\nof letters. The number of operations should be .\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 400400;\nbool REV = false;\nvector<pii> a, b;\nvector<pii> ans;\nchar s[N];\n\nvector<pii> read() {\n\tscanf(\"%s\", s);\n\tint L = strlen(s);\n\tchar cur = 'c';\n\tint len = 0;\n\tvector<pii> res;\n\tfor (int i = 0; i < L; i++) {\n\t\tif (cur == s[i]) {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len != 0) {\n\t\t\tres.push_back(mp((int)(cur - 'a'), len));\n\t\t}\n\t\tcur = s[i];\n\t\tlen = 1;\n\t}\n\tif (len != 0)\n\t\tres.push_back(mp((int)(cur - 'a'), len));\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n\nvoid makeMove(int X, int Y) {\n\tvector<pii> c, d;\n\tint sumX = 0, sumY = 0;\n\twhile(X--) {\n\t\tsumX += a.back().second;\n\t\tc.push_back(a.back());\n\t\ta.pop_back();\n\t}\n\twhile(Y--) {\n\t\tsumY += b.back().second;\n\t\td.push_back(b.back());\n\t\tb.pop_back();\n\t}\n\tif (REV) swap(sumX, sumY);\n\tans.push_back(mp(sumX, sumY));\n\twhile(!c.empty()) {\n\t\tpii t = c.back();\n\t\tc.pop_back();\n\t\tif (b.empty() || b.back().first != t.first)\n\t\t\tb.push_back(t);\n\t\telse\n\t\t\tb.back().second += t.second;\n\t}\n\twhile(!d.empty()) {\n\t\tpii t = d.back();\n\t\td.pop_back();\n\t\tif (a.empty() || a.back().first != t.first)\n\t\t\ta.push_back(t);\n\t\telse\n\t\t\ta.back().second += t.second;\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\ta = read();\n\tb = read();\n\n\tif ((int)a.size() > (int)b.size()) {\n\t\tREV = true;\n\t\tswap(a, b);\n\t}\n\n\tint X = a.back().first;\n\tfor (int i = 0; i < (int)a.size(); i++)\n\t\ta[i].first ^= X;\n\tfor (int i = 0; i < (int)b.size(); i++)\n\t\tb[i].first ^= X;\n\n\tif ((int)a.size() == 1) {\n\t\tif (b.back().first == 0) {\n\t\t\tmakeMove(0, ((int)b.size() / 4) * 2 + 1);\n\t\t} else {\n\t\t\tif ((int)b.size() > 1)\n\t\t\t\tmakeMove(1, ((int)b.size() / 4) * 2 + 1);\n\t\t}\n\t} else {\n\t\tif (b.back().first == 0) {\n\t\t\tif (((int)b.size() - (int)a.size()) % 4 == 3) {\n\t\t\t\tmakeMove(1, 2);\n\t\t\t}\n\t\t\tmakeMove(0, (((int)b.size() - (int)a.size()) / 4) * 2 + 1);\n\t\t} else {\n\t\t\tif (((int)b.size() - (int)a.size()) % 4 == 3) {\n\t\t\t\tmakeMove(1, (((int)b.size() - (int)a.size()) / 4) * 2 + 3);\n\t\t\t} else {\n\t\t\t\tmakeMove(1, (((int)b.size() - (int)a.size()) / 4) * 2 + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile((int)a.size() > 1 || (int)b.size() > 1)\n\t\tmakeMove(1, 1);\n\n\tprintf(\"%d\\n\", (int)ans.size());\n\tfor (pii t : ans)\n\t\tprintf(\"%d %d\\n\", t.first, t.second);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "strings"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. AB-Strings.json",
    "editorial_link": "https://codeforces.com/blog/entry/60920",
    "editorial": "The solution is basically like following:Note that we can compress equal\r\nadjacent letters.Now we can do a dynamic programming with params (first\r\nletter of , length of , first letter of , length of ).However, the\r\namount of transactions and even states is too large. But we can write a\r\nslow, but surely correct solution, and examine the transactions, which\r\nare made in dp.Basically, the most typical transaction is to just make a\r\nswap of first group in with first group in . However there special\r\ncases, like when the first letters are the same or when the lengths are\r\nvery small.Running a slow dynamic programming helps to get all the cases\r\nfor the solution.Formally, the correctness of this algorithm can be\r\nproven by induction and the large cases analyses, which we skip for\r\nclarity.Another approach is to consider different first operations, and\r\nthen go a greedy after it algorithm. See the second solution for the\r\ndetails. We don\u00e2\u0080\u0099t prove it.\r\n"
}