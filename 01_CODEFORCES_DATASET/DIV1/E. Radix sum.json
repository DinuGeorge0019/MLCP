{
    "link": "https://codeforces.com//contest/1103/problem/E",
    "problemId": "286157",
    "problem_idx": "E",
    "shortId": "1103E",
    "contest_number": "1103",
    "problem_submissions": {
        "E": [
            48753270,
            48771690,
            48772282
        ],
        "C": [
            48737996,
            48751833,
            48742130,
            48750924,
            48753455,
            48785591,
            48744586,
            48747377,
            48750469,
            48752184,
            48749897,
            48750575,
            48750490,
            48749685,
            48751441
        ],
        "B": [
            48729408,
            48731995,
            48733031,
            48738196,
            48732688,
            48735686,
            48732548,
            48745783,
            48738143,
            48736855,
            48734767,
            48731627,
            48740835,
            48746307,
            48736276,
            48737788,
            48737739,
            48735990,
            48736042
        ],
        "A": [
            48723784,
            48727790,
            48725191,
            48732437,
            48724396,
            48725785,
            48724635,
            48726318,
            48725482,
            48726526,
            48724739,
            48726676,
            48725374,
            48729843,
            48724696,
            48726116,
            48730660,
            48725296,
            48724384
        ],
        "D": [
            48745574,
            48759308,
            48758091,
            48757563,
            48785689,
            48755420,
            48758598,
            48759719,
            48935021,
            48790648,
            48790368,
            48790273,
            48768973,
            48768847,
            48768502,
            48768204,
            48768156,
            48759654,
            48763805,
            48758531
        ]
    },
    "name": "E. Radix sum",
    "statement": "Let’s define of number a consisting of digits a_1,\r\nldots ,a_k and number b consisting of digits b_1,\r\nldots ,b_k(we add leading zeroes to the shorter number to match longer\r\nlength) as number s(a,b) consisting of digits (a_1+b_1)\r\nmod 10,\r\nldots ,(a_k+b_k)\r\nmod 10. The of several integers is defined as follows: s(t_1,\r\nldots ,t_n)=s(t_1,s(t_2,\r\nldots ,t_n))You are given an array x_1,\r\nldots ,x_n. The task is to compute for each integer i (0\r\nle i < n) number of ways to consequently choose one of the integers from\r\nthe array n times, so that the of these integers is equal to i.\r\nCalculate these values modulo 2^{58}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int M = 10;\nusing ULL = uint64_t;\n\nstruct SumUnits {\n  array<ULL, M> value;\n\n  SumUnits() { value.fill(0); }\n\n  SumUnits(ULL x) {\n    value.fill(0);\n    value[0] = x;\n  }\n\n  SumUnits &operator+=(const SumUnits &other) {\n    for (int i = 0; i < M; ++i) {\n      value[i] += other.value[i];\n    }\n    return *this;\n  }\n\n  SumUnits &operator-=(const SumUnits &other) {\n    for (int i = 0; i < M; ++i) {\n      value[i] -= other.value[i];\n    }\n    return *this;\n  }\n\n  SumUnits operator*(const SumUnits &other) const {\n    SumUnits ans;\n    for (int i = 0; i < M; ++i) {\n      for (int j = 0; j < M; ++j) {\n        ans.value[(i + j) % M] += value[i] * other.value[j];\n      }\n    }\n    return ans;\n  }\n\n  SumUnits PowMod(int n) const {\n    SumUnits ans(1);\n    SumUnits val = *this;\n    //debug(ans, val, val*val);\n    while (n) {\n      if (n & 1) { ans = ans * val; }\n      n >>= 1;\n      val = val * val;\n    }\n    return ans;\n  }\n\n  SumUnits Shift(int x) const {\n    SumUnits ans;\n    for (int i = 0; i < M; ++i) {\n      ans.value[(i + x) % M] = value[i];\n    }\n    return ans;\n  }\n\n  friend ostream &operator<<(ostream &os, const SumUnits &su) {\n    os<<\"[\";\n    for (int i = 0; i < M; ++i) { os<<su.value[i]<<','; }\n    return os<<\"]\";\n  }\n\n  ULL GetInt() const {\n    SumUnits cpy = *this;\n    ULL v = cpy.value[1];\n    for (int i = 0; i < M; ++i) {\n      cpy.value[i] -= v;\n    }\n    v = cpy.value[2];\n    for (int i = 0; i < M; i += 2) {\n      cpy.value[i] -= v;\n    }\n    v = cpy.value[5];\n    for (int i = 0; i < M; i += 5) {\n      cpy.value[i] -= v;\n    }\n    for (int i = 1; i < M; ++i) {\n      assert(cpy.value[i] == 0);\n    }\n    return cpy.value[0];\n  }\n};\n\n#warning\nconst int MaxRange = 1e5;\n\nSumUnits values[MaxRange + 5];\n\nvoid DoDFT(int coef, bool invert) {\n  const int dir = invert ? M - 1 : 1;\n\n  for (int base = 0; base < MaxRange; ++base) {\n    if (base % (coef * 10) >= coef) { continue; }\n\n    int ids[M];\n    for (int i = 0; i < M; ++i) {\n      ids[i] = base + i * coef;\n    }\n\n    SumUnits su[M];\n    for (int i = 0; i < M; ++i) {\n      su[i] = SumUnits{};\n    }\n\n    for (int i = 0; i < M; ++i) {\n      //const int k = ids[i];\n      for (int j = 0; j < M; ++j) {\n        const int n = ids[j];\n        su[i] += values[n].Shift((i * j * dir) % M);\n      }\n    }\n\n    for (int i = 0; i < M; ++i) {\n      const int k = ids[i];\n      values[k] = su[i];\n    }\n  }\n\n#ifdef LOCAL\n  for (int i = 0; i < 10; ++i) {\n    cerr << values[i] << \",\";\n  }\n  cerr << \"\\n\";\n#endif\n}\n\nint N;\n\nconst ULL Inv5 = 57646075230342349ULL;\nconst ULL Mod = 1ULL << 58;\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  for (int i = 0; i < N; ++i) {\n    int v;\n    cin >> v;\n    ++values[v].value[0];\n  }\n\n  for (int coef = 1; coef < MaxRange; coef *= 10) {\n    DoDFT(coef, false);\n  }\n\n  //debug(values[0], values[1]);\n\n  for (int i = 0; i < MaxRange; ++i) {\n    values[i] = values[i].PowMod(N);\n  }\n\n#ifdef LOCAL\n  for (int i = 0; i < 10; ++i) {\n    cerr << values[i] << \",\";\n  }\n  cerr << \"\\n\";\n#endif\n\n\n  for (int coef = 1; coef < MaxRange; coef *= 10) {\n    DoDFT(coef, true);\n  }\n\n  //debug(values[0], values[1]);\n\n  vector<ULL> answers(N);\n  for (int i = 0; i < N; ++i) {\n    answers[i] = values[i].GetInt();\n  }\n\n  for (int coef = 1; coef < MaxRange; coef *= 10) {\n    for (ULL &x : answers) {\n      x /= 2;\n      x *= Inv5;\n    }\n  }\n\n  for (ULL x : answers) {\n    x %= Mod;\n    cout << x << \"\\n\";\n  }\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "fft",
        "math",
        "number theory"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Radix sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/64722",
    "editorial": "After reading the problem statement, it is pretty clear that you should\r\napply something like Hadamard transform, but inner transform should have\r\nsize ten instead of two. There is no -th root of one modulo (except -th\r\nand -th roots), so it is not possible to solve the problem just\r\ncalculating all values modulo . The main idea is that you should\r\ncalculate all values in a polynomial ring modulo (in this ring identity\r\nholds, so is the oneâs -th root).Now the problem is there is no modular\r\ninverse of , so we apply the trick. Letâs just use unsigned long long,\r\nand in the end we will divide the answer by (it is invertible, because\r\nit is relatively prime to 2), and then we simply divide the answer by\r\nwith integer division, it can be easily shown that the result will be\r\ncorrect. It is worth noting that after inverse transform you should\r\neliminate monomes larger than by applying the identity (modulo ). After\r\nthat only the coefficient with remains, and this will be the answer.\r\n",
    "hint": []
}