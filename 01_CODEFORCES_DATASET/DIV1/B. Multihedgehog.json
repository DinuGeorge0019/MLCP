{
    "link": "https://codeforces.com//contest/1067/problem/B",
    "problemId": "242828",
    "problem_idx": "B",
    "shortId": "1067B",
    "contest_number": "1067",
    "problem_submissions": {
        "E": [
            44797063,
            44801350,
            44801345,
            44800256,
            44807009,
            44795862,
            44802107,
            44801174,
            44802534,
            44808036,
            44807819,
            44808903,
            44813776,
            44808812,
            44823059,
            44822826
        ],
        "C": [
            44791919,
            44798705,
            44789846,
            45703244,
            44817690,
            44796737,
            44821755,
            44819508,
            44819482,
            44798809,
            44800641
        ],
        "B": [
            44785395,
            44790831,
            44786324,
            44787984,
            44813565,
            44800421,
            44789408,
            44792434,
            44795239,
            44792208,
            44793600,
            44795334,
            44790580,
            44792571,
            44793492,
            44790971,
            44785468,
            44794434
        ],
        "A": [
            44781795,
            44784467,
            44782825,
            44782486,
            44802955,
            44788563,
            44785068,
            44786748,
            44791948,
            44785790,
            44788019,
            44787518,
            44785264,
            44787093,
            44892470,
            44785358,
            44786648,
            44792812,
            44788577
        ],
        "D": [
            44810645,
            44811277,
            59968450,
            44830180,
            44927930,
            44819755,
            44819681,
            44819351,
            44807988,
            44804123
        ]
    },
    "name": "B. Multihedgehog",
    "statement": "Someone give a strange birthday present to Ivan. It is hedgehog\r\nconnected undirected graph in which one vertex has degree at least 3 (we\r\nwill call it center) and all other vertices has degree 1. Ivan thought\r\nthat hedgehog is too boring and decided to make himself\r\nk-multihedgehog.Let us define k-multihedgehog as follows:\r\n1-multihedgehog is hedgehog: it has one vertex of degree at least 3 and\r\nsome vertices of degree 1. For all k\r\nge 2, k-multihedgehog is (k-1)-multihedgehog in which the following\r\nchanges has been made for each vertex v with degree 1: let u be its only\r\nneighbor; remove vertex v, create a new hedgehog with center at vertex w\r\nand connect vertices u and w with an edge. New hedgehogs can differ from\r\neach other and the initial gift. Thereby k-multihedgehog is a tree. Ivan\r\nmade k-multihedgehog but he is not sure that he did not make any\r\nmistakes. That is why he asked you to check if his tree is indeed\r\nk-multihedgehog.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\n\nvi graf[nax];\n\nvoid nope()\n{\n\tprintf(\"No\\n\");\n\texit(0);\n}\n\nvoid tak()\n{\n\tprintf(\"Yes\\n\");\n\texit(0);\n}\n\nint korz=-1;\n\nvi stos;\n\nvoid dfs1(int v, int oj)\n{\n\tstos.push_back(v);\n\tif ((int)stos.size()==2*k+1)\n\t\tkorz=stos[k];\n\tfor (int i : graf[v])\n\t\tif (i!=oj)\n\t\t\tdfs1(i, v);\n\tstos.pop_back();\n}\n\nvoid dfs2(int v, int oj, int odl)\n{\n\tif ((int)graf[v].size()==1 && odl!=k)\n\t\tnope();\n\tfor (int i : graf[v])\n\t\tif (i!=oj)\n\t\t\tdfs2(i, v, odl+1);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tif (n<=3)\n\t\tnope();\n\tint lis=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif ((int)graf[i].size()==1)\n\t\t\tlis=i;\n\tdfs1(lis, 0);\n\tif (korz==-1)\n\t\tnope();\n\tif ((int)graf[korz].size()<3)\n\t\tnope();\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif ((int)graf[i].size()==1 || i==korz)\n\t\t\tcontinue;\n\t\tif ((int)graf[i].size()<4)\n\t\t\tnope();\n\t}\n\tdfs2(korz, 0, 0);\n\ttak();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Multihedgehog.json",
    "editorial_link": "https://codeforces.com/blog/entry/62688",
    "editorial": "Solution 1: Firstly let\u00e2\u0080\u0099s find all vertices with degree . Now we can\r\ndelete them and all, verticies which were incident to them must became\r\nverticies with degree . And also for each new veretice with degree we\r\nmust have already deleted not less then verticies. If initial graph was\r\n-multihedgehog, after deleting vertices with degree it would became\r\n-multihedgehog.It could be realised using bfs starting from all initial\r\nvertices with degree .Complexity is .Solution 2: First of all let\u00e2\u0080\u0099s find\r\ndiametr of the graph. After that we can find middle vertex in diameter\r\nand check if it is a center of -multihedgehog using simple\r\ndfs.Complexity is .\r\n"
}