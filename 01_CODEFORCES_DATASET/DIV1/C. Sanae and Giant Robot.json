{
    "link": "https://codeforces.com//contest/1687/problem/C",
    "problemId": "1419367",
    "problem_idx": "C",
    "shortId": "1687C",
    "contest_number": "1687",
    "problem_submissions": {
        "E": [
            159400142,
            159409445,
            159415903
        ],
        "D": [
            159385709,
            159382982,
            159386487,
            159387507,
            159397573,
            159399320,
            159391569,
            159397786,
            159396436,
            159395456,
            159398210,
            159399180,
            159407593,
            159403303,
            159404538,
            159409257,
            180746841,
            159402849,
            159401651,
            159407966,
            160388189,
            159436063,
            159436040,
            159435984,
            159419781,
            159403828
        ],
        "C": [
            159372815,
            159372262,
            159366644,
            159367127,
            159364840,
            159377203,
            159381172,
            159372251,
            159382727,
            159384371,
            159375023,
            159388232,
            159376434,
            159382167,
            159380993,
            159376872,
            159376695,
            159388502,
            159386180,
            159388678
        ],
        "B": [
            159359094,
            159359944,
            159359502,
            159356648,
            159356713,
            159358784,
            159359353,
            159359146,
            159369441,
            159357746,
            159365304,
            159359951,
            159364501,
            159359761,
            159371294,
            159365665,
            159363760,
            159364175,
            159366158,
            159367949
        ],
        "A": [
            159352673,
            159354526,
            159354098,
            159352807,
            159352456,
            159352554,
            159353893,
            159353089,
            159361438,
            159353196,
            159354069,
            159353562,
            159353431,
            159353777,
            159361194,
            159354902,
            159354475,
            159353974,
            159355709,
            159356539
        ]
    },
    "name": "C. Sanae and Giant Robot",
    "statement": "Is it really?! The robot only existing in my imagination?! The Colossal\r\nWalking Robot?!! Kochiya Sanae Sanae made a giant robot Hisoutensoku,\r\nbut something is wrong with it. To make matters worse, Sanae can not\r\nfigure out how to stop it, and she is forced to fix it on-the-fly.The\r\nstate of a robot can be represented by an array of integers of length n.\r\nInitially, the robot is at state a. She wishes to turn it into state b.\r\nAs a great programmer, Sanae knows the art of copy-and-paste. In one\r\noperation, she can choose some segment from given segments, copy the\r\nsegment from b and paste it into of the robot, replacing the original\r\nstate there. However, she has to ensure that the sum of a after each\r\ncopy operation in case the robot go haywire. Formally, Sanae can choose\r\nsegment [l,r] and assign a_i = b_i (l\r\nle i\r\nle r) if\r\nsum\r\nlimits_{i=1}^n a_i does not change after the operation.Determine whether\r\nit is possible for Sanae to successfully turn the robot from the initial\r\nstate a to the desired state b with any (possibly, zero) operations.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nvector<int> g[N];\nint n;\nll a[N], b[N];\nset<int> setik;\nint q[N];\nint topQ;\n\nvoid fixSegm(int l, int r) {\n\tif (l > r) swap(l, r);\n\twhile(true) {\n\t\tauto it = setik.lower_bound(l);\n\t\tif (it == setik.end()) break;\n\t\tif (*it > r) break;\n\t\tint x = *it;\n\t\tsetik.erase(it);\n\t\tq[topQ++] = x;\n\t}\n}\n\nbool solve() {\n\tint m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i <= n; i++)\n\t\tg[i].clear();\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &a[i + 1]);\n\t\ta[i + 1] += a[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &b[i + 1]);\n\t\tb[i + 1] += b[i];\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tl--;\n\t\tg[l].push_back(r);\n\t\tg[r].push_back(l);\n\t}\n\tif (a[n] != b[n]) return false;\n\ttopQ = 0;\n\tsetik.clear();\n\tfor (int i = 0; i <= n; i++) {\n\t\tif (a[i] == b[i])\n\t\t\tq[topQ++] = i;\n\t\telse\n\t\t\tsetik.insert(i);\n\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = q[i];\n\t\tfor (int u : g[v]) {\n\t\t\tif (setik.count(u)) continue;\n\t\t\tfixSegm(v, u);\n\t\t}\n\t}\n\treturn setik.empty();\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tif (solve()) {\n\t\t\tprintf(\"Yes\\n\");\n\t\t} else {\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dsu",
        "greedy",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Sanae and Giant Robot.json",
    "editorial_link": "https://codeforces.com//blog/entry/103493",
    "editorial": "Solution Let . The task can be described as: Given an array . For some\ngiven interval if , we can assign to (). The goal is to make\n().Obviously assigning non-zero value to is useless, while assigning to\ndoes no harm. Therefore, we can repeatedly choose any interval\nsatisfying , and assigning to all non-zero () until there is no such\ninterval. We can use set in C++ or disjoint set or segment tree to find\nsuch .As each element can be assigned to at most once, the time\ncomplexity is .\n",
    "hint": [
        "Hint1 Let Unable to parse markup [type=CF_MATHJAX] for convenience.",
        "Hint2 The interval selected satisfies Unable to parse markup [type=CF_MATHJAX] . What does range sum remind you of?"
    ]
}