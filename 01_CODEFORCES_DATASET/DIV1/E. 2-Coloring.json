{
    "link": "https://codeforces.com//contest/1503/problem/E",
    "problemId": "945473",
    "problem_idx": "E",
    "shortId": "1503E",
    "contest_number": "1503",
    "problem_submissions": {
        "F": [
            111939776,
            111936345,
            111953640,
            111949537,
            111942068,
            111944734,
            111944711,
            111948141,
            111947867,
            113984444
        ],
        "E": [
            111918055,
            111912666,
            111918864,
            111923939,
            111922990,
            111923269,
            111922053,
            111920801,
            111927922,
            111926604,
            111931364,
            111936374,
            111926173,
            111935792,
            111929517,
            111930613,
            111937713,
            111935328,
            111934244
        ],
        "D": [
            111903738,
            111902585,
            111898744,
            111893896,
            111901869,
            111902624,
            111880076,
            111902059,
            111906951,
            111905795,
            111910439,
            111899185,
            111916472,
            111904574,
            111913444,
            111910826,
            111914877,
            111924091,
            111906860
        ],
        "C": [
            111886477,
            111890876,
            111881938,
            111886094,
            111882409,
            111883959,
            111902446,
            111905834,
            111885208,
            111897171,
            111889963,
            111890061,
            111888926,
            111886850,
            111898651,
            111896248,
            111894668,
            111884135,
            111889304
        ],
        "B": [
            111876447,
            111888244,
            111877449,
            111876120,
            111878468,
            111878981,
            111893644,
            111877927,
            111878327,
            111877579,
            111878407,
            111882807,
            111900739,
            111880662,
            111889601,
            111886898,
            111883228,
            111878516,
            111916268
        ],
        "A": [
            111871860,
            111872029,
            111873354,
            111871912,
            111872701,
            111874636,
            111888931,
            111872574,
            111873406,
            111872331,
            111873739,
            111875192,
            111873092,
            111873513,
            111878839,
            111875591,
            111873509,
            111872858,
            111893066
        ]
    },
    "name": "E. 2-Coloring",
    "statement": "There is a grid with n rows and m columns. Every cell of the grid should\r\nbe colored either blue or yellow.A coloring of the grid is called stupid\r\nif every row has exactly one segment of blue cells and every column has\r\nexactly one segment of yellow cells.In other words, every row must have\r\nat least one blue cell, and all blue cells in a row must be consecutive.\r\nSimilarly, every column must have at least one yellow cell, and all\r\nyellow cells in a column must be consecutive. An example of a stupid\r\ncoloring. Examples of clever colorings. The first coloring is missing a\r\nblue cell in the second row, and the second coloring has two yellow\r\nsegments in the second column. How many stupid colorings of the grid are\r\nthere? Two colorings are considered different if there is some cell that\r\nis colored differently.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nnum ways(int a, int b){\n\treturn ncr(a+b, a);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint n, m;\n\tcin >> n >> m;\n\tif(n == 1 || m == 1){\n\t\tcout << 0 << '\\n';\n\t\treturn 0;\n\t}\n\tnum ans = 0;\n\tfor(int i = 0; i + 1 < n; i++){\n\t\tnum v = 0;\n\t\tfor(int j = m-2; j >= 0; j--){\n\t\t\tv += ways(i, j+1) * ways(i+1, m-j-2);\n\t\t\tans += v * ways(n-i-1, j) * ways(n-i-2, m-1-j);\n\t\t}\n\t}\n\tfor(int i = 0; i + 1 < m; i++){\n\t\tnum v = 0;\n\t\tfor(int j = n-2; j >= 0; j--){\n\t\t\tans += v * ways(m-i-1, j) * ways(m-i-2, n-1-j);\n\t\t\tv += ways(i, j+1) * ways(i+1, n-j-2);\n\t\t}\n\t}\n\tcout << (ans * 2) << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. 2-Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/89319",
    "editorial": "Before counting, we should understand the structure of a stupid\r\ncoloring.First, both of the following cannot hold: There exists a path\r\nof yellow cells from column to column . There exists a path of blue\r\ncells from row to row . In fact, if two such paths existed, they must\r\nhave a cell in common, and it would have to be blue and yellow at the\r\nsame time.Without loss of generality, suppose statement 1 is false.\r\nConsider a yellow cell in the grid. All blue cells in its row must be to\r\nits left or right because they lie in one segment. So, each yellow cell\r\neither belongs to the connected component of yellow cells touching the\r\nfirst column or the component touching the last column.There cannot be a\r\ncolumn with one cell in and another cell in , otherwise the segment\r\nwould connect the two components. And every column has at least one\r\nyellow cell, so there exists a number () such that occupies the first\r\ncolumns and occupies the last columns.Let be the segment of yellow cells\r\nin column and be the segment of yellow cells in column . Since the\r\nsegments do not overlap, we either have or . Without loss of generality,\r\nsuppose . The cells in create a monotonically increasing path from to ,\r\nthen make a monotonically decreasing path from to . A similar structure\r\nhappens for .The number of monotonic paths where we step right times and\r\nup times is counted by the binomial coefficient . Now, if we fix and ,\r\nwe can count the number of stupid colorings with the product of binomial\r\ncoefficients. To make this fast enough, we can fix only and use a prefix\r\nsum to find the number of ways over all .To generalize from the\r\nassumption that , we can multiply the answer by since it\u00e2\u0080\u0099s symmetric. To\r\ngeneralize from the assumption that statement is false, we can also\r\ncount the number of ways if and are swapped. But we should be careful\r\nabout double counting the case where both statements 1 and 2 are false.\r\nThis can be handled without too much trouble by simply requiring for one\r\nof the two cases.Complexity is .\r\n"
}