{
    "link": "https://codeforces.com//contest/1495/problem/F",
    "problemId": "920579",
    "problem_idx": "F",
    "shortId": "1495F",
    "contest_number": "1495",
    "problem_submissions": {
        "F": [
            109612449,
            109607835,
            109606482,
            109609150,
            109620903,
            109726650,
            109627363,
            109621999
        ],
        "E": [
            109601349,
            109614588,
            109615437,
            109622017,
            109595998,
            109609900,
            109608272,
            109611154,
            109618626,
            109616350,
            109613793,
            109616566,
            109663705,
            109745948
        ],
        "D": [
            109585527,
            109580228,
            109579316,
            109589541,
            109578458,
            109566916,
            109575841,
            109594019,
            109596254,
            109599839,
            109603208,
            109598498,
            109595100,
            109579185,
            109589312,
            109591284,
            109598520,
            109583665,
            109585365
        ],
        "C": [
            109580634,
            109591405,
            109587970,
            109577744,
            109586320,
            109593422,
            109611088,
            109582953,
            109580883,
            109580583,
            109587448,
            109605186,
            109581328,
            109584227,
            109579041,
            109577709,
            109589629,
            109602493
        ],
        "B": [
            109568471,
            109565101,
            109584053,
            109566115,
            109569156,
            109574304,
            109563074,
            109573615,
            109567542,
            109575207,
            109571021,
            109587658,
            109567505,
            109566798,
            109566339,
            109589966,
            109570284,
            109566248
        ],
        "A": [
            109557502,
            109557307,
            109557290,
            109557352,
            109558084,
            109569473,
            109557547,
            109559952,
            109558698,
            109558154,
            109557812,
            109558270,
            109557945,
            109558879,
            109557971,
            109558445,
            109560880,
            109558343,
            109559119
        ]
    },
    "name": "F. Squares",
    "statement": "There are n squares drawn from left to right on the floor. The i-th\r\nsquare has three integers p_i,a_i,b_i, written on it. The sequence\r\np_1,p_2,\r\ndots,p_n forms a permutation.Each round you will start from the leftmost\r\nsquare 1 and jump to the right. If you are now on the i-th square, you\r\ncan do one of the following two operations: Jump to the i+1-th square\r\nand pay the cost a_i. If i=n, then you can end the round and pay the\r\ncost a_i. Jump to the j-th square and pay the cost b_i, where j is the\r\nleftmost square that satisfies j > i, p_j > p_i. If there is no such j\r\nthen you can end the round and pay the cost b_i. There are q rounds in\r\nthe game. To make the game more difficult, you need to maintain a square\r\nset S (initially it is empty). You pass through these squares during the\r\nround (other squares can also be passed through). The square set S for\r\nthe i-th round is obtained by adding or removing a square from the\r\nsquare set for the (i-1)-th round. For each round find the minimum cost\r\nyou should pay to end it.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\n\nint per[nax];\n\nll ka[nax];\nll kb[nax];\n\nint gdz[nax];\n\nll fen[nax];\n\nvoid pisz(int a, int b, ll w)\n{\n\tfor (int i=a; i<nax; i+=(i&(-i)))\n\t\tfen[i]+=w;\n\tfor (int i=b+1; i<nax; i+=(i&(-i)))\n\t\tfen[i]-=w;\n}\n\nll czyt(int v)\n{\n\tll ret=0;\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tret+=fen[i];\n\treturn ret;\n}\n\nint zap[nax];\nset<int> setel;\n\nmap<pii,ll> ciek;\n\nvi oco[nax];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &per[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &ka[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &kb[i]);\n\t\n\tgdz[n]=n+1;\n\tfor (int i=n-1; i; i--)\n\t{\n\t\tgdz[i]=i+1;\n\t\twhile(gdz[i]<=n && per[gdz[i]]<per[i])\n\t\t\tgdz[i]=gdz[gdz[i]];\n\t}\n\t//~ debug() << range(gdz+1, gdz+1+n);\n\tfor (int i=1; i<=q; i++)\n\t{\n\t\tscanf(\"%d\", &zap[i]);\n\t}\n\tsetel.insert(1);\n\tsetel.insert(n+1);\n\tciek[{1, n+1}];\n\tfor (int i=1; i<=q; i++)\n\t{\n\t\tif (zap[i]==1)\n\t\t\tcontinue;\n\t\tif (setel.count(zap[i]))\n\t\t{\n\t\t\tauto it=setel.find(zap[i]);\n\t\t\tit--;\n\t\t\tint a=(*it);\n\t\t\tit++;\n\t\t\tit++;\n\t\t\tint b=(*it);\n\t\t\tciek[{a, b}];\n\t\t\tsetel.erase(zap[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsetel.insert(zap[i]);\n\t\t\tauto it=setel.find(zap[i]);\n\t\t\tit--;\n\t\t\tciek[{(*it), zap[i]}];\n\t\t\tit++;\n\t\t\tit++;\n\t\t\tciek[{zap[i], (*it)}];\n\t\t}\n\t}\n\tsetel.clear();\n\t//~ debug() << ciek;\n\tfor (auto i : ciek)\n\t{\n\t\tpii p=i.first;\n\t\toco[p.first].push_back(p.second);\n\t}\n\tfor (int i=n; i; i--)\n\t{\n\t\t//~ if (gdz[i]==i+1)\n\t\t//~ {\n\t\t\t//~ pisz(i+1, n+1, min(ka[i], kb[i]));\n\t\t//~ }\n\t\t//~ else\n\t\t//~ {\n\t\t\t\n\t\t//~ }\n\t\tll tam=czyt(gdz[i]);\n\t\tpisz(i+1, gdz[i]-1, ka[i]);\n\t\tpisz(gdz[i], n+1, -tam+min(ka[i]+tam, kb[i]));\n\t\t//~ vll wek;\n\t\t//~ for (int j=i+1; j<=n+1; j++)\n\t\t\t//~ wek.push_back(czyt(j));\n\t\t//~ debug() << i << \" \" << wek;\n\t\tfor (int j : oco[i])\n\t\t\tciek[{i, j}]=czyt(j);\n\t}\n\tsetel.insert(1);\n\tsetel.insert(n+1);\n\tll trz=ciek[{1, n+1}];\n\tfor (int i=1; i<=q; i++)\n\t{\n\t\tif (zap[i]!=1)\n\t\t{\n\t\t\tif (setel.count(zap[i]))\n\t\t\t{\n\t\t\t\tauto it=setel.find(zap[i]);\n\t\t\t\tit--;\n\t\t\t\tint a=(*it);\n\t\t\t\tit++;\n\t\t\t\tit++;\n\t\t\t\tint b=(*it);\n\t\t\t\tsetel.erase(zap[i]);\n\t\t\t\ttrz-=ciek[{a, zap[i]}];\n\t\t\t\ttrz-=ciek[{zap[i], b}];\n\t\t\t\ttrz+=ciek[{a, b}];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsetel.insert(zap[i]);\n\t\t\t\tauto it=setel.find(zap[i]);\n\t\t\t\tit--;\n\t\t\t\tint a=(*it);\n\t\t\t\tit++;\n\t\t\t\tit++;\n\t\t\t\tint b=(*it);\n\t\t\t\ttrz+=ciek[{a, zap[i]}];\n\t\t\t\ttrz+=ciek[{zap[i], b}];\n\t\t\t\ttrz-=ciek[{a, b}];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", trz);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Squares.json",
    "editorial_link": "https://codeforces.com//blog/entry/88533",
    "editorial": "If we let the parent of is the rightmost satisfying (if that doesn\u00e2\u0080\u0099t\r\nexist, the parent of is ), we can get a tree and we can dfs the tree\r\nwith the order . Let\u00e2\u0080\u0099s call the parent of is and the children set of is\r\n.Here is an example. and the permutation is . The graphs we build\r\nfollow. Let\u00e2\u0080\u0099s call the edges with the cost A-type and the edges with the\r\ncost B-type. Consider that now you are on the -th square. If you choose\r\na B-type edge(with the cost ), you will jump over all the squares in \u00e2\u0080\u0099s\r\nsubtree( is not included), that is to say, you will not pass through\r\nthem. If you choose an A-type edge, we can think you enter \u00e2\u0080\u0099s subtree\r\nand you must pass through all of the \u00e2\u0080\u0099s child.To simplify the problem,\r\nwe think you choose a node if and only if you pass through the A-type\r\nedge from the -th square. Let\u00e2\u0080\u0099s call the chosen set is . It is not hard\r\nto find out that the node can be chosen if and only if all the ancestors\r\nof in the tree are chosen(if not, you even don\u00e2\u0080\u0099t have the chance to pass\r\nthrough ). And that you pass through the -th square is equivalent to you\r\nchoosing the parent of .Then the problem is simplified. You purpose is\r\nto choose some nodes in the tree ( must be chosen as it is the root) and\r\nminimize your cost. Here your cost is . If we let , the cost can be\r\nconsidered as . It is very easy to solve it with binups.The time\r\ncomplexity is .\r\n"
}