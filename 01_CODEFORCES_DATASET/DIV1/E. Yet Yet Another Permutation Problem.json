{"link": "https://codeforces.com//contest/1936/problem/E", "problemId": "2503249", "problem_idx": "E", "shortId": "1936E", "contest_number": "1936", "problem_submissions": {"D": [249364690, 248943933, 248953790, 249029415, 248948695, 249384877, 248946718, 249691560, 248955075, 248956184, 248951174, 248957366, 248965278, 248962414, 248959804, 248956212, 248940582, 248972190, 248967537, 248935591, 248968777], "F": [248959624, 248956053, 249024905, 249024791, 249617325, 249616926, 249616449, 249616090], "C": [248923874, 248935905, 248936411, 248923821, 249389527, 249389485, 249389471, 248932096, 249960032, 249959905, 248928496, 248925527, 248927912, 248933135, 248931237, 248927110, 248920757, 248942173, 248944746, 248948052, 248945719, 248954792, 249702139, 249700847, 248946434, 248946276], "B": [248915925, 248925932, 248926756, 248909886, 248921270, 250626935, 248920462, 248915106, 248915547, 248917787, 248924541, 248919814, 248929862, 248928500, 248928933, 248958629, 248930625, 248933889, 248965009, 248934936], "A": [248907152, 248906597, 248909183, 248914647, 248906656, 250627352, 248907025, 248906362, 248923349, 248909550, 248908351, 248909231, 248911552, 248909761, 248918833, 248908591, 248914734, 248920857], "E": [248969738, 248981250, 249019529, 248981225, 248968880, 249091224, 249090696, 252634475, 249522528]}, "name": "E. Yet Yet Another Permutation Problem", "statement": "You are given a permutation p of length n.Please count the number of\r\npermutations q of length n which satisfy the following: for each 1\r\nle i < n,\r\nmax(q_1,\r\nldots,q_i)\r\nneq\r\nmax(p_1,\r\nldots,p_i).Since the answer may be large, output the answer modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int >\n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\n#define pb emplace_back\nusing namespace std;\nconst int mod = 998244353, _G = 3, N = (1 << 21), inv2 = (mod + 1) / 2;\n#define add(a, b) (a + b >= mod ? a + b - mod : a + b)\n#define dec(a, b) (a < b ? a - b + mod : a - b)\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N + 1], ifac[N + 1], inv[N + 1];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) inv[mod % i] * (mod - mod / i) % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n}\nint C(int x, int y) {\n\treturn y < 0 || x < y ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\ninline int sgn(int x) {\n\treturn (x & 1) ? mod - 1 : 1;\n}\nint rt[N], Lim;\nvoid Pinit(int x) {\n\tfor(Lim = 1; Lim <= x; Lim <<= 1) ;\n\tfor(int i = 1; i < Lim; i <<= 1) {\n\t\tint sG = qpow (_G, (mod - 1) / (i << 1));\n\t\trt[i] = 1;\n\t\tL(j, i + 1, i * 2 - 1) rt[j] = (ll) rt[j - 1] * sG % mod;\n\t}\n}\nstruct poly {\n\tvector<int> a;\n\tint size() { return sz(a); }\n\tint & operator [] (int x) { return a[x]; }\n\tint v(int x) { return x < 0 || x >= sz(a) ? 0 : a[x]; }\n\tvoid clear() { vector<int> ().swap(a); }\n\tvoid rs(int x = 0) { a.resize(x); }\n\tpoly (int n = 0) { rs(n); }\n\tpoly (vector<int> o) { a = o; }\n\tpoly (const poly &o) { a = o.a; }\n\tpoly Rs(int x = 0) { vi res = a; res.resize(x); return res; }\n\tinline void dif() {\n\t\tint n = sz(a);\n\t\tfor (int l = n >> 1; l >= 1; l >>= 1) \n\t\t\tfor(int j = 0; j < n; j += l << 1) \n\t\t\t\tfor(int k = 0, *w = rt + l; k < l; k++, w++) {\n\t\t\t\t\tint x = a[j + k], y = a[j + k + l];\n\t\t\t\t\ta[j + k] = add(x, y);\n\t\t\t\t\ta[j + k + l] = (ll) * w * dec(x, y) % mod;\n\t\t\t\t}\n\t}\n\tvoid dit () {\n\t\tint n = sz(a);\n\t\tfor(int i = 2; i <= n; i <<= 1) \n\t\t\tfor(int j = 0, l = (i >> 1); j < n; j += i) \n\t\t\t\tfor(int k = 0, *w = rt + l; k < l; k++, w++) {\n\t\t\t\t\tint pa = a[j + k], pb = (ll) a[j + k + l] * *w % mod;\n\t\t\t\t\ta[j + k] = add(pa, pb), a[j + k + l] = dec(pa, pb);\n\t\t\t\t}\n\t\treverse(a.begin() + 1, a.end());\n\t\tfor(int i = 0, iv = qpow(n); i < n; i++) a[i] = (ll) a[i] * iv % mod;\n\t} \n\tfriend poly operator * (poly aa, poly bb) {\n\t\tif(!sz(aa) || !sz(bb)) return {};\n\t\tint lim, all = sz(aa) + sz(bb) - 1;\n\t\tfor(lim = 1; lim < all; lim <<= 1);\n\t\taa.rs(lim), bb.rs(lim), aa.dif(), bb.dif();\n\t\tL(i, 0, lim - 1) aa[i] = (ll) aa[i] * bb[i] % mod;\n\t\taa.dit(), aa.a.resize(all);\n\t\treturn aa;\n\t}\n\tpoly Inv() {\n\t\tpoly res, f, g;\n\t\tres.rs(1), res[0] = qpow(a[0]);\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = m << 1, f = res, g.rs(pn), f.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (*this).v(i);\n\t\t\tf.dif(), g.dif();\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (ll) f[i] * g[i] % mod;\n\t\t\tg.dit();\n\t\t\tfor(int i = 0; i < m; i++) g[i] = 0;\n\t\t\tg.dif();\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (ll) f[i] * g[i] % mod;\n\t\t\tg.dit(), res.rs(pn);\n\t\t\tfor(int i = m; i < min(pn, sz(a)); i++) res[i] = (mod - g[i]) % mod;\n\t\t} \n\t\treturn res.rs(sz(a)), res;\n\t}\n\tpoly Shift (int x) {\n\t\tpoly zm (sz(a) + x);\n\t\tL(i, max(-x, 0), sz(a) - 1) zm[i + x] = a[i];\n\t\treturn zm; \n\t}\n\tfriend poly operator * (poly aa, int bb) {\n\t\tpoly res(sz(aa));\n\t\tL(i, 0, sz(aa) - 1) res[i] = (ll) aa[i] * bb % mod;\n\t\treturn res;\n\t}\n\tfriend poly operator + (poly aa, poly bb) {\n\t\tvector<int> res(max(sz(aa), sz(bb)));\n\t\tL(i, 0, sz(res) - 1) res[i] = add(aa.v(i), bb.v(i));\n\t\treturn poly(res);\n\t}\n\tfriend poly operator - (poly aa, poly bb) {\n\t\tvector<int> res(max(sz(aa), sz(bb)));\n\t\tL(i, 0, sz(res) - 1) res[i] = dec(aa.v(i), bb.v(i));\n\t\treturn poly(res);\n\t}\n\tpoly & operator += (poly o) {\n\t\trs(max(sz(a), sz(o)));\n\t\tL(i, 0, sz(a) - 1) (a[i] += o.v(i)) %= mod;\n\t\treturn (*this);\n\t}\n\tpoly & operator -= (poly o) {\n\t\trs(max(sz(a), sz(o)));\n\t\tL(i, 0, sz(a) - 1) (a[i] += mod - o.v(i)) %= mod;\n\t\treturn (*this);\n\t}\n\tpoly & operator *= (poly o) {\n\t\treturn (*this) = (*this) * o;\n\t}\n\tpoly Integ() {\n\t\tif(!sz(a)) return poly();\n\t\tpoly res(sz(a) + 1);\n\t\tL(i, 1, sz(a)) res[i] = (ll) a[i - 1] * inv[i] % mod;\n\t\treturn res;\n\t}\n\tpoly Deriv() {\n\t\tif(!sz(a)) return poly();\n\t\tpoly res(sz(a) - 1); \n\t\tL(i, 1, sz(a) - 1) res[i - 1] = (ll) a[i] * i % mod;\n\t\treturn res;\n\t}\n\tpoly Ln() {\n\t\tpoly g = ((*this).Inv() * (*this).Deriv()).Integ();\n\t\treturn g.rs(sz(a)), g;\n\t}\n\tpoly Exp() {\n\t\tpoly res(1), f; \n\t\tres[0] = 1;\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = min(m << 1, sz(a)), f.rs(pn), res.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) f[i] = (*this).v(i);\n\t\t\tf -= res.Ln(), (f[0] += 1) %= mod, res *= f, res.rs(pn); \n\t\t}\n\t\treturn res.rs(sz(a)), res;\n\t}\n\tpoly pow(int x, int rx = -1) { // x : the power % mod; rx : the power % (mod - 1)\n\t\tif(rx == -1) rx = x;\n\t\tint cnt = 0;\n\t\twhile (a[cnt] == 0 && cnt < sz(a)) cnt += 1;\n\t\t\n\t\tpoly res = (*this);\n\t\tL(i, cnt, sz(a) - 1) res[i - cnt] = res[i];\n\t\tL(i, sz(a) - cnt, sz(a) - 1) res[i] = 0;\n\t\tint c = res[0], w = qpow (res[0]);\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * w % mod;\n\t\tres = res.Ln();\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * x % mod;\n\t\tres = res.Exp();\n\t\tc = qpow (c, rx);\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * c % mod;\n\t\t\n\t\tif((ll) cnt * x > sz(a)) L(i, 0, sz(a) - 1) res[i] = 0;\n\t\telse if(cnt) {\n\t\t\tR(i, sz(a) - cnt * x - 1, 0) res[i + cnt * x] = res[i];\n\t\t\tL(i, 0, cnt * x - 1) res[i] = 0; \n\t\t}\n\t\treturn res;\n\t}\n\tpoly sqrt(int rt = 1) {\n\t\tpoly res(1), f; \n\t\tres[0] = rt;\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = min(m << 1, sz(a)), f.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) f[i] = (*this).v(i);\n\t\t\tf += res * res, f.rs(pn), res.rs(pn), res = f * res.Inv(), res.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) res[i] = (ll) res[i] * inv2 % mod;\n\t\t} \n\t\treturn res;\n\t}\n\tvoid Rev() {\n\t\treverse(a.begin(), a.end());\n\t}\n\tfriend pair < poly, poly > div (poly f, poly g) { /* f / g = first, f % g = second */\n\t\tf.rs(max(sz(f), sz(g))), f.Rev(), g.Rev();\n\t\tint n = sz(f), m = sz(g);\n\t\tpoly A = g.Rs(n - m + 1).Inv(), t;\n\t\tA *= f.Rs(n - m + 1), A.rs(n - m + 1), A.Rev(), g.Rev(), f.Rev(), t = f - A * g, t.rs(m - 1);\n\t\treturn make_pair(A, t);\n\t} \n} ;\n\nint n, p[N];\nint dp[N];\nint f[N];\ninline int A(int x, int y) {\n\treturn (ll)C(x, y) * fac[y] % mod;\n}\nint sums[N], r2[N], r3[N];\nvoid solve(int l, int r) {\n\tif(l == r) {\n\t\tint i = l;\n\t\tif(p[i] == p[i - 1]) {\n\t\t\t(dp[i] += (ll) sums[i - 1] * (p[i] - i + 1) % mod) %= mod;\n\t\t\t(dp[i] += (ll) r3[i - 1] % mod) %= mod;\n\t\t\t(dp[i] += (ll) r2[i - 1] * (mod - i) % mod) %= mod;\n\t\t} \n\t\tif(i < n) dp[i] = (mod - dp[i]) % mod;\n\t\tsums[i] = dp[i];\n\t\tr2[i] = dp[i], r3[i] = (ll) dp[i] * i % mod;\n\t\tif(p[i] == p[i - 1]) {\n\t\t\t(sums[i] += (ll)sums[i - 1] * (p[i] - i + 1) % mod) %= mod;\t\n\t\t\t(r2[i] += (ll)r2[i - 1] * (p[i] - i) % mod) %= mod;\t\n\t\t\t(r3[i] += (ll)r3[i - 1] * (p[i] - i) % mod) %= mod;\t\n\t\t} \n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tsolve(l, mid);\n\tL(cas, 0, 1) {\n\tint vl = p[mid + 1] - mid, vr = p[r] - l;\n\tpoly ls(mid - l + 1);\n\tpoly rs(vr - vl + 1);\n\tL(i, vl, vr) {\n\t\tint val = (i == 0 ? 0 : fac[i - 1]);\n\t\t(rs[i - vl] += val) %= mod;\n\t}\n\tL(i, l, mid)\n\t\tls[i - l] = cas ? (ll) dp[i] * i % mod : dp[i];\n\tls *= rs;\n\n\tif(cas == 0) {\n\tL(i, mid + 1, r)\n\t\t(dp[i] += (ll) i * ls[p[i] - l - vl] % mod * ifac[p[i] - i] % mod) %= mod;\n\t} else {\n\tL(i, mid + 1, r)\n\t\t(dp[i] += mod - (ll) ls[p[i] - l - vl] * ifac[p[i] - i] % mod) %= mod;\n\t}\n\t}\n\tsolve(mid + 1, r);\n}\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> p[i];\n\t\tp[i] = max(p[i], p[i - 1]);\n\t}\n\tL(i, 1, n) dp[i] = (ll) i * A(p[i] - 1, i - 1) % mod;\n\tL(i, 0, n) sums[i] = 0, r2[i] = 0, r3[i] = 0;\n\tsolve(1, n);\n\tcout << dp[n] << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tinit(1 << 20);\n\tPinit(1 << 20);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n} "], "input": "", "output": "", "tags": ["divide and conquer", "fft", "math"], "dificulty": "3400", "interactive": false}