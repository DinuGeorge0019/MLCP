{
    "link": "https://codeforces.com//contest/1936/problem/F",
    "problemId": "2503250",
    "problem_idx": "F",
    "shortId": "1936F",
    "contest_number": "1936",
    "problem_submissions": {
        "D": [
            249364690,
            248943933,
            248953790,
            249029415,
            248948695,
            249384877,
            248946718,
            249691560,
            248955075,
            248956184,
            248951174,
            248957366,
            248965278,
            248962414,
            248959804,
            248956212,
            248940582,
            248972190,
            248967537,
            248935591,
            248968777
        ],
        "F": [
            248959624,
            248956053,
            249024905,
            249024791,
            249617325,
            249616926,
            249616449,
            249616090
        ],
        "C": [
            248923874,
            248935905,
            248936411,
            248923821,
            249389527,
            249389485,
            249389471,
            248932096,
            249960032,
            249959905,
            248928496,
            248925527,
            248927912,
            248933135,
            248931237,
            248927110,
            248920757,
            248942173,
            248944746,
            248948052,
            248945719,
            248954792,
            249702139,
            249700847,
            248946434,
            248946276
        ],
        "B": [
            248915925,
            248925932,
            248926756,
            248909886,
            248921270,
            250626935,
            248920462,
            248915106,
            248915547,
            248917787,
            248924541,
            248919814,
            248929862,
            248928500,
            248928933,
            248958629,
            248930625,
            248933889,
            248965009,
            248934936
        ],
        "A": [
            248907152,
            248906597,
            248909183,
            248914647,
            248906656,
            250627352,
            248907025,
            248906362,
            248923349,
            248909550,
            248908351,
            248909231,
            248911552,
            248909761,
            248918833,
            248908591,
            248914734,
            248920857
        ],
        "E": [
            248969738,
            248981250,
            249019529,
            248981225,
            248968880,
            249091224,
            249090696,
            252634475,
            249522528
        ]
    },
    "name": "F. Grand Finale  Circles",
    "statement": "You are given n circles on the plane. The i-th of these circles is given\r\nby a tuple of integers (x_i, y_i, r_i), where (x_i, y_i) are the\r\ncoordinates of its center, and r_i is the radius of the circle.Please\r\nfind a circle C which meets the following conditions: C is contained\r\ninside all n circles given in the input. Among all circles C that meet\r\nthe first condition, the radius of the circle is maximum. Let the\r\nlargest suitable circle have the radius of a.Your output C, described as\r\n(x,y,r), will be accepted if it meets the following conditions: For each\r\ni,\r\nsqrt{(x_i-x)^2+(y_i-y)^2}+ r\r\nle r_i+\r\nmax(a,1)\r\ncdot 10^{-7}. The absolute or relative error of r does not exceed\r\n10^{-7}. Formally, your answer is accepted if and only if\r\nfrac{\r\nleft|r - a\r\nright|}{\r\nmax(1, a)}\r\nle 10^{-7}.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\nusing ld=double;\nconst ld inf=1e18;\nconst int lim=1e6;\nconst int magic=65;\nconst ld phi=(1+sqrt(5))/2;\n\n//~ mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 rng(69);\n\nint n;\n//~ pll sr[nax];\n//~ ll rad[nax];\n\npair<pll,ll> tab[nax];\n\nld f(pair<ld,ld> v)\n{\n\tld ret=inf;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tld x=tab[i].first.first-v.first;\n\t\tld y=tab[i].first.second-v.second;\n\t\tret=min(ret, tab[i].second-sqrt(x*x+y*y));\n\t\t//~ ld kwa=x*x+y*y;\n\t\t//~ if (ret>tab[i].second || kwa>(tab[i].second-ret)*(tab[i].second-ret))\n\t\t\t//~ ret=min(ret, tab[i].second-sqrt(kwa));\n\t}\n\treturn ret;\n}\n\npair<ld,ld> licz(ld x)\n{\n\tld tsa=-lim;\n\tld tsb=lim;\n\tint mamlew=0;\n\tint mampra=0;\n\tld lew=0;\n\tld pra=0;\n\t\n\tfor (int h=0; h<magic; h++)\n\t{\n\t\tld ts1=(phi*tsa+1*tsb)/(1+phi);\n\t\tld ts2=(1*tsa+phi*tsb)/(1+phi);\n\t\tif (!mamlew)\n\t\t\tlew=f({x, ts1});\n\t\tif (!mampra)\n\t\t\tpra=f({x, ts2});\n\t\tmamlew=mampra=0;\n\t\tif (lew>pra)\n\t\t{\n\t\t\ttsb=ts2;\n\t\t\tmampra=1;\n\t\t\tpra=lew;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttsa=ts1;\n\t\t\tmamlew=1;\n\t\t\tlew=pra;\n\t\t}\n\t}\n\tld y=(tsa+tsb)/2;\n\treturn {f({x, y}), y};\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t//~ for (int i=1; i<=n; i++)\n\t//~ {\n\t\t//~ tab[i].first.first=rng()%(2*lim+1)-lim;\n\t\t//~ tab[i].first.second=rng()%(2*lim+1)-lim;\n\t\t//~ tab[i].second=2*lim;\n\t//~ }\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld%lld%lld\", &tab[i].first.first, &tab[i].first.second, &tab[i].second);\n\tshuffle(tab+1, tab+1+n, rng);\n\tld tsa=-lim;\n\tld tsb=lim;\n\t\n\tint mamlew=0;\n\tint mampra=0;\n\tld lew=0;\n\tld pra=0;\n\t\n\tfor (int h=0; h<magic; h++)\n\t{\n\t\tld ts1=(phi*tsa+1*tsb)/(1+phi);\n\t\tld ts2=(1*tsa+phi*tsb)/(1+phi);\n\t\tif (!mamlew)\n\t\t\tlew=licz(ts1).first;\n\t\tif (!mampra)\n\t\t\tpra=licz(ts2).first;\n\t\tmamlew=mampra=0;\n\t\tif (lew>pra)\n\t\t{\n\t\t\ttsb=ts2;\n\t\t\tmampra=1;\n\t\t\tpra=lew;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttsa=ts1;\n\t\t\tmamlew=1;\n\t\t\tlew=pra;\n\t\t}\n\t}\n\tld x=(tsa+tsb)/2;\n\tld y=licz(x).second;\n\tprintf(\"%.9lf %.9lf %.9lf\\n\", (double)x, (double)y, (double)f({x, y}));\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "geometry"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Grand Finale  Circles.json",
    "editorial_link": "https://codeforces.com//blog/entry/126513",
    "editorial": "TutorialFor a given center coordinate , we can model the objective\r\nfunction to maximize as follows. Formally, this can be modeled as\r\nfollows: This is a second order cone program. Generally, this is not as\r\nsimple to solve as linear or quadratic programs. There are multiple\r\nsolvers out there, but all of them are either commercial or simply unfit\r\nfor use on Codeforces. And even if we use general approaches to second\r\norder cone programming, their time complexity is at least , so they\r\ncannot work. Almost all general approaches to convex programming do not\r\nhelp very much for this task also, because of the following reasons.\r\nGradient Descent cannot work in this task. The objective function is not\r\nsmooth. Coordinate Descent also cannot work in this task for the same\r\nreason, and it is not hard to find a countercase. Subgradient methods\r\ncan solve this task, but they take iterations to converge. This is a\r\nvery big dependency on the precision, so they take too much time. We do\r\nnot expect anyone to write Adaptive Coordinate Descent during contest\r\ntime, but we still tested the PRAXIS algorithm and checked that it does\r\nnot pass. Using nested ternary searches does not help very much. The\r\ntime complexity will be , but the constants are large due to multiple\r\nfunction calls and floating point operations. Heuristics such as the\r\nNelder-Mead method are not proven to converge. In many cases we found it\r\nnot converging successfully. In the editorial, we will explain a\r\nsolution of expected time complexity, with constants depending on the\r\nnumber of dimensions (which is in our case).First, we observe that any\r\nanswer can be described as a \"basis\" of at most selected circles. For ,\r\nthe basis is as follows. Case 1: This is the case of no circles, which\r\ncan be regarded as an \"identity element\" of bases. Some very huge circle\r\nthat will enclose any given circle, for example the circle with as\r\nradius and as center, can represent this case. Case 2: This is the case\r\nof a single circle. The circle that represents this case is the one\r\nselected circle. Case 3: This is the case of two circles, for which the\r\nbasis is the largest circle in the intersection of two circles. We can\r\nfind this by choosing the center as the midpoint of the two points and ,\r\nwhere and are the points where the line segment between circle centers\r\nand the circle itself intersect. Case 4: This is the case of three\r\ncircles, and the most tricky of all four cases. It can be found as one\r\nsolution to the following system of quadratic equations: This can be\r\nsolved algebraically. If you are used to solving geometry problems in\r\nOlympiads, you may know the \u00e2\u0080\u009dProblem of Apollonius\u00e2\u0080\u009d. This is one special\r\ncase of the problem, which is not very often mentioned because often the\r\nthree circles do not intersect with each other (thus most of the time\r\none solution for must be negative). Or if one does not know the problem,\r\nthey can find that the locus of the circle center that meets with two\r\ncircle edges (as in Case 3) is a conic section, precisely one side of a\r\npair of hyperbola. By finding the intersections of two hyperbola, one\r\ncan find the center of this circle. Thus, this circle can be found in\r\ntime, with constants based on number of dimensions.By the system of\r\nquadratic equations stated above, we see that there are at most\r\nsolutions. It is sufficient to take the one that happens to be inside\r\nthe intersection. (If there are two such solutions, take the larger one.\r\nFor the current version of the data this check is not necessary, but it\r\ndoes not hurt to try.) Thus, for some , the bases can be represented\r\nwith some circles.Do note that, already, we have an solution based on\r\nthis. We enumerate all possible bases, and find the smallest one out of\r\nthem (since that one will be the one that satisfies the conditions).\r\nNow, for some basis circle , we can check whether some given circle is\r\n\"violated\" by this basis (i.e. this basis is not inside this circle) in\r\nby comparing the distance. We take an incremental approach. We add\r\ncircles to the basis one by one, up to circles. We choose to change the\r\nbasis if only the next added circle is violated by the current basis. Of\r\ncourse, still this takes time, and sorting the circles based on any\r\nargument will not help anyways.However, adding the circles in random\r\norder will make it only take expected time. This can be analyzed by the\r\nprobability that a new basis will be added. The precise analysis for the\r\ntime complexity is left as a practice for the reader.If you have seen\r\nthe minimum enclosing circle problem, the Welzl\u00e2\u0080\u0099s algorithm to solve\r\nthat precise problem will seem very similar to this. In fact, the\r\nsuggested algorithm itself is not very different from Welzl\u00e2\u0080\u0099s algorithm.\r\nIf you want, though, you may take an iterative approach instead of\r\nmodifying Welzl\u00e2\u0080\u0099s algorithm. Using three nested loops will do.There is\r\nonly two issues left. The first is the issue of numerical instability.\r\nSometimes, due to numerical instability, the algorithm will return a NaN\r\nvalue. It is not that hard to solve, we can simply shuffle again and\r\nrerun the algorithm. The given time limit will be sufficient for doing\r\nthis unless the constant is too big. The second is more tricky, and it\r\nis about hacks.If you use a fixed seed for randomization (or time-based\r\nseeds to some extent), someone may hack you by adding an adversarial\r\ntest case which makes the time complexity explode back to . This is very\r\nbad. How do we solve this? To intervent this, we will make the algorithm\r\nhalt when the number of iterations exceed a certain limit. Formally, let\r\nus choose a constant , and the algorithm will halt and rerun when the\r\nnumber of iterations exceeds . Then, if the probability of the algorithm\r\nsuccessfully running in this number of iterations is , the expected\r\nnumber of reruns needed is , and hacking is much harder. The algorithm\r\nwill successfully find the solution in time. Of course, the probability\r\ndepends on , and you must tune the value as needed. Empirically runs\r\nvery well, almost always taking no longer than seconds under proper\r\noptimizations, and seconds without.\r\n"
}