{
    "link": "https://codeforces.com//contest/2101/problem/D",
    "problemId": "3379869",
    "problem_idx": "D",
    "shortId": "2101D",
    "contest_number": "2101",
    "problem_submissions": {
        "D": [
            319294804,
            319237348,
            319244062,
            319233111,
            319248438,
            319270934,
            319247114,
            319246074,
            319245749,
            319256088,
            319251191,
            319251037,
            319261866,
            319252875,
            319254950,
            319262267,
            319251514,
            319255297
        ],
        "F": [
            319280605,
            319281731,
            319296938,
            319296545,
            319307832,
            319307784,
            319294905,
            319285038,
            319280546,
            319439373,
            319610626,
            319290581,
            322062368,
            319622463
        ],
        "E": [
            319261457,
            319271887,
            319269195,
            319269179,
            319260221,
            319295559,
            319294878,
            319271978,
            319272872,
            319314013,
            319277656,
            319282084,
            319306454,
            319284113,
            319285106,
            319318396,
            319280504,
            319284828,
            319289037
        ],
        "C": [
            319227789,
            319248152,
            319242282,
            319237027,
            319228539,
            319229145,
            319235166,
            319232460,
            319242619,
            319234897,
            319234927,
            319241291,
            319239653,
            319237271,
            319245442,
            319240061,
            319236820
        ],
        "B": [
            319220410,
            319218858,
            319221247,
            319221700,
            319222744,
            319220314,
            319219692,
            319223217,
            319223401,
            319224243,
            319230362,
            319224392,
            319222585,
            319222454,
            319227561,
            319224092
        ],
        "A": [
            319215799,
            319216381,
            319216154,
            319217268,
            319216406,
            319216292,
            319216910,
            319216574,
            319215332,
            319218464,
            319222747,
            319217683,
            319216023,
            319216949,
            319220045,
            319216375
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142788",
    "editorial": "SolutionThe first observation is that a subarray is cute, iff there is\r\nan index , such that it is the one and only share of the LIS and LDS,\r\nand all other elements belong to either LIS or LDS. Proof: We know that\r\nthere cannot be two elements belonging to both LIS and LDS, and if there\r\nis none, the property won’t be held. Therefore, we conclude that there\r\nis exactly one element shared between the LIS and LDS.Diving deeper into\r\nthe shared element, we can see that the smaller elements before it must\r\nall be ascending, and the bigger elements after it must also all be\r\nascending (as this will make our LIS). Similarly, all the bigger\r\nelements before it and all the smaller elements after it should be\r\ndescending. This gives us a good pattern, and we can easily see that any\r\nsubarray included within a cute subarray is cute itself (call this\r\nmonotonic property).For counting the total number of cute subarrays, we\r\ncalculate the values of and for each index. Let be the biggest index\r\nbefore , such that the condition above is met. Similarly define as the\r\nindex after . If we can somehow calculate this values for all indices,\r\nthen we’ll end up with segments (for each ), and a subarray is cute iff\r\nit’s included in at least one segment. This is a very classic problem,\r\nso the solution won’t be discussed here.The only detail left is how to\r\ncalculate the values of and ? We’ll discuss the process of calculating\r\nthe here, but the follows a very similar pattern. We claim that . In\r\nhere is defined as follow: if : then is minimum index , such that . if :\r\nin this case is minimum such that . Proof: The fact that can easily be\r\nconcluded from the fact thay cuteness is a monotonic property. Also\r\ngoing back to the conditions described above, we can see that is\r\nbasically the first index that will ruin our condition, so based on the\r\ndefinition of , we can say that .The calculation of and can both be\r\nimplemented using a Segment Tree or a Monotonic Stack; both\r\nimplementations are included below. After we have those values, we count\r\nthe number of subarrays included in at least one segment, and that would\r\nbe our final answer.\r\n",
    "name": "D. Mani and Segments",
    "statement": "An array b of length |b| is if the sum of the length of its Longest\r\nIncreasing Subsequence (LIS) and the length of its Longest Decreasing\r\nSubsequence (LDS)^{\r\ntext{ }} is one more than the length of the array. More formally, the\r\narray b is cute if\r\noperatorname{LIS}(b) +\r\noperatorname{LDS}(b) = |b| + 1.You are given a permutation a of length\r\nn^{\r\ntext{ }}. Your task is to count the number of non-empty subarrays^{\r\ntext{ }} of permutation a that are cute.^{\r\ntext{ }}A sequence x is a subsequence of a sequence y if x can be\r\nobtained from y by the deletion of several (possibly, zero or all)\r\nelement from arbitrary positions. The longest increasing (decreasing)\r\nsubsequence of an array is the longest subsequence such that its\r\nelements are ordered in strictly increasing (decreasing) order.^{\r\ntext{ }}A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray). ^{\r\ntext{ }}An array x is a subarray of an array y if x can be obtained from\r\ny by the deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Mani and Segments.json",
    "hint": [
        "Hint 1 What are some characteristics of a cute subarray?",
        "Hint 2 Is cuteness a monotone property?",
        "Hint 3 How to find the maximal cute subarray for a fixed index ?"
    ]
}