{
    "link": "https://codeforces.com//contest/674/problem/E",
    "problemId": "59816",
    "problem_idx": "E",
    "shortId": "674E",
    "contest_number": "674",
    "problem_submissions": {
        "F": [
            17795703,
            17796640,
            17795248,
            17796731,
            17795284,
            17786875,
            17793312,
            17799447,
            17799059,
            17796927,
            17809648
        ],
        "E": [
            17791802,
            17792589,
            17793136,
            17792993,
            17792579,
            17790993,
            17797689,
            17793850,
            17793986,
            17790505,
            17793423,
            17807249,
            17795195,
            17795763,
            17827053,
            17796913
        ],
        "C": [
            17789698,
            17787708,
            17787067,
            17789946,
            17787511,
            17796571,
            17795757,
            17788550,
            17790663,
            17794959,
            17792670,
            17795899,
            17791267,
            17793511,
            17791551,
            17791808
        ],
        "B": [
            17783364,
            17783002,
            17794015,
            17783259,
            17783884,
            17783532,
            17788831,
            17784932,
            17787141,
            17784301,
            17785005,
            17785023,
            17784292,
            17783013,
            17783128,
            17786182,
            17784522
        ],
        "A": [
            17780055,
            17780264,
            17780741,
            17780847,
            17780248,
            17780121,
            17787726,
            17781230,
            17780294,
            17782551,
            17782250,
            17781088,
            17780155,
            17780065,
            17780569,
            17780629,
            17781843
        ],
        "D": [
            17798492,
            17808237
        ],
        "G": [
            17818293,
            17796240,
            17798313
        ]
    },
    "name": "E. Bear and Destroying Subtrees",
    "statement": "Limak is a little grizzly bear. He will once attack Deerland but now he\r\ncan only destroy trees in role-playing games. Limak starts with a tree\r\nwith one vertex. The only vertex has index and is a root of the\r\ntree.Sometimes, a game chooses a subtree and allows Limak to attack it.\r\nWhen a subtree is attacked then each of its edges is destroyed with\r\nprobability , independently of other edges. Then, Limak gets the penalty\r\nan integer equal to the height of the subtree after the attack. The\r\nheight is defined as the maximum number of edges on the path between the\r\nroot of the subtree and any vertex in the subtree.You must handle\r\nqueries of two types. denotes a query of the first type. A new vertex\r\nappears and its parent is . A new vertex has the next available index\r\n(so, new vertices will be numbered ). denotes a query of the second\r\ntype. For a moment let’s assume that the game allows Limak to attack a\r\nsubtree rooted in . Then, what would be the expected value of the\r\npenalty Limak gets after the attack? In a query of the second type,\r\nLimak doesn’t actually attack the subtree and thus the query doesn’t\r\naffect next queries.\r\n",
    "solutions": [
        "#include <iostream>\n#include <tuple>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 510000;\nconst ld eps = 1e-15;\nint p[maxn];\nvector<ld> pr[maxn];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int v = 1;\n    int Q;\n    cin >> Q;\n    pr[0].pb(1.0);\n    forn(i, Q) {\n        int t;\n        cin >> t;\n        if (t == 1) {\n            int u;\n            cin >> u;\n            --u;\n            int w = v;\n            p[v] = u;\n            pr[v].pb(0.0);\n            ld newp = 1.0;\n            int d = 0;\n            for (; v; v = p[v]) {\n                if (pr[p[v]].size() <= d + 1) pr[p[v]].resize(d + 2);\n                ld oldq = pr[p[v]][d + 1], oldp = pr[v][d];\n                pr[v][d] = newp;\n                ld q = 1.0 - oldq;\n                q /= 1.0 - 0.5 * oldp;\n                q *= 1.0 - 0.5 * newp;\n                q = 1.0 - q;\n//                pr[p[v]][d + 1] = 1.0 - q;\n                if (fabs(q - oldq) < eps) break;\n                newp = q;\n                ++d;\n            }\n            if (pr[v].size() <= d) pr[v].resize(d + 1);\n            pr[v][d] = newp;\n            v = ++w;\n        } else {\n            int u;\n            cin >> u;\n            --u;\n            cout << accumulate(all(pr[u]), (ld)0.0) - 1.0 << '\\n';\n        }\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Bear and Destroying Subtrees.json",
    "editorial_link": "https://codeforces.com//blog/entry/44754",
    "editorial": "Let denote the probability that subtree (if\nattacked now) would have height at most . The first observation is that\nwe donât care about big because itâs very unlikely that a path with e.g.\n100 edges will survive. Letâs later talk about choosing and now letâs\nsay that itâs enough to consider up to . When we should answer a query\nfor subtree then we should sum up to get the answer. The other query is\nharder. Letâs say that a new vertex is attached to vertex . Then, among\nonly changes (other values stay the same). Also, one value changes, and\nso does and so on. You should iterate over vertices (each time going to\nparent) and update the corresponding value. TODO puts here come formula\nfor updating value. The complexity is . You may think that is enough\nbecause is small enough. Unfortunately, there exist malicious tests.\nConsider a tree with paths from root, each with length . Now, we talk\nabout the probability of magnitude: which is more than for .\nhttp://www.wolframalpha.com/input/?i=1+-+(1-(1\n",
    "hint": []
}