{
    "link": "https://codeforces.com//contest/1340/problem/C",
    "problemId": "599367",
    "problem_idx": "C",
    "shortId": "1340C",
    "contest_number": "1340",
    "problem_submissions": {
        "F": [
            77861280,
            77852254,
            77849797,
            78528429,
            78527982,
            77845721,
            77870771,
            77870728,
            77870667,
            77809735,
            77844929,
            78038847,
            77865877,
            77864401,
            77864363,
            77862346,
            77862326
        ],
        "D": [
            77814886,
            77820644,
            77812632,
            77817969,
            78526970,
            77818222,
            77825103,
            77825677,
            77810183,
            77803432,
            77810910,
            77812394,
            77816455,
            77825551,
            77843873,
            77828804,
            77822663,
            77822063
        ],
        "C": [
            77795843,
            77812380,
            77824845,
            77823255,
            78526952,
            77799809,
            77811601,
            77834672,
            77830782,
            77811370,
            77793451,
            77808028,
            77797811,
            77795450,
            77802848,
            77796169,
            77858001,
            77810294,
            77809842
        ],
        "A": [
            77782251,
            77771158,
            77774810,
            77787508,
            78526918,
            78526910,
            77776379,
            77774309,
            77776029,
            77816613,
            77771928,
            77777830,
            77775868,
            77773607,
            77771508,
            77776009,
            77776621,
            77773349,
            77795835,
            77779579,
            77772710,
            77776861
        ],
        "B": [
            77777625,
            77796394,
            77787259,
            77781233,
            78526935,
            77868779,
            77790975,
            77793147,
            77821618,
            77789026,
            77773962,
            77770331,
            77782427,
            77780486,
            77790796,
            77783960,
            77786770,
            77783985,
            77790124,
            77791298,
            77788341
        ],
        "E": [
            77836196,
            77868575,
            77868568,
            77868546,
            77868525,
            77868496,
            77845628,
            77864964,
            77846936,
            77902183,
            77902167,
            77902121,
            77902068,
            77902045,
            77901978,
            77850099,
            77859253,
            77828316,
            77849841,
            77848435,
            77856908,
            77842257
        ]
    },
    "name": "C. Nastya and Unexpected Guest",
    "statement": "On the way from Denis’s house to the girl’s house is a road of n lines.\r\nThis road can’t be always crossed in one green light. Foreseeing this,\r\nthe good mayor decided to place safety islands in some parts of the\r\nroad. Each safety island is located after a line, as well as at the\r\nbeginning and at the end of the road. Pedestrians can relax on them,\r\ngain strength and wait for a green light.Denis came to the edge of the\r\nroad exactly at the moment when the green light turned on. The boy knows\r\nthat the traffic light first lights up g seconds green, and then r\r\nseconds red, then again g seconds green and so on.Formally, the road can\r\nbe represented as a segment [0, n]. Initially, Denis is at point 0. His\r\ntask is to get to point n in the shortest possible time.He knows many\r\ndifferent integers d_1, d_2,\r\nldots, d_m, where 0\r\nleq d_i\r\nleq n are the coordinates of points, in which the safety islands are\r\nlocated. Only at one of these points, the boy can be at a time when the\r\nred light is on.Unfortunately, Denis isn’t always able to control\r\nhimself because of the excitement, so some restrictions are imposed: He\r\nmust always move while the green light is on because it’s difficult to\r\nstand when so beautiful girl is waiting for you. Denis can change his\r\nposition by\r\npm 1 in 1 second. While doing so, he must always stay inside the segment\r\n[0, n]. He can change his direction only on the safety islands (because\r\nit is safe). This means that if in the previous second the boy changed\r\nhis position by +1 and he walked on a safety island, then he can change\r\nhis position by\r\npm 1. Otherwise, he can change his position only by +1. Similarly, if in\r\nthe previous second he changed his position by -1, on a safety island he\r\ncan change position by\r\npm 1, and at any other point by -1. At the moment when the red light is\r\non, the boy must be on one of the safety islands. He can continue moving\r\nin any direction when the green light is on. Denis has crossed the road\r\nas soon as his coordinate becomes equal to n.This task was not so\r\nsimple, because it’s possible that it is impossible to cross the road.\r\nSince Denis has all thoughts about his love, he couldn’t solve this\r\nproblem and asked us to help him. Find the minimal possible time for\r\nwhich he can cross the road according to these rules, or find that it is\r\nimpossible to do.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tint N, M; cin >> N >> M;\n\tvector<int> X(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> X[i];\n\t}\n\tsort(X.begin(), X.end());\n\tassert(X[0] == 0);\n\tassert(X[M-1] == N);\n\n\tint G, R; cin >> G >> R;\n\tvector<bool> vis(M * G);\n\tvis[0] = true;\n\n\tvector<int> islands; islands.reserve(M);\n\tislands.push_back(0);\n\n\tvector<int> q; q.reserve(M*G);\n\n\tint ans = -1;\n\tfor (int T = 0; !islands.empty(); T++) {\n\t\tq.clear();\n\t\tfor (int i : islands) {\n\t\t\tq.push_back(i*G);\n\t\t}\n\t\tislands.clear();\n\n\t\tfor (int z = 0; z < int(q.size()); z++) {\n\t\t\tint cur = q[z];\n\t\t\tint i = cur / G;\n\t\t\tint t = cur % G;\n\t\t\tfor (int j : {i-1, i+1}) {\n\t\t\t\tif (!(0 <= j && j < M)) continue;\n\t\t\t\tint nt = t + abs(X[i] - X[j]);\n\t\t\t\tif (nt > G) continue;\n\n\t\t\t\tif (j == M-1) {\n\t\t\t\t\tint cnd = T * (G+R) + nt;\n\t\t\t\t\tif (ans == -1 || cnd < ans) {\n\t\t\t\t\t\tans = cnd;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nt == G) {\n\t\t\t\t\tnt = 0;\n\t\t\t\t}\n\n\t\t\t\tif (vis[j*G + nt]) continue;\n\t\t\t\tvis[j*G+nt] = true;\n\n\t\t\t\tif (nt) {\n\t\t\t\t\tq.push_back(j*G+nt);\n\t\t\t\t} else {\n\t\t\t\t\tislands.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Nastya and Unexpected Guest.json",
    "editorial_link": "https://codeforces.com//blog/entry/76479",
    "editorial": "Notice the fact: if we somehow came to safety island and time imodg\n (mod\n - is a remainder after dividing i\n by g\n), we don't need anymore to come to this island at time j\n where i<j\n and imodg=jmodg\n, because this will form a cycle.\n\nSo that we can rephrase our task like this: we have some vertices, which are denoted as a pair (i,t)\n, i\n - is island index, t\n is a remainder after dividing the time we came to i\n by g\n. So it will be enough to use only edges between vertices (i,t)?(i+1,(t+a[i+1]?a[i])modg)\n and (i,t)?(i?1,(t+a[i]?a[i?1])modg)\n, because all remaining edges can be expressed through these ones. Now lets notice that edges, which make time t+a>g\n can't be used due to restriction of walking on red. But vertices with t+a=g\n are good for us. So we can say, that while green light is on, Denis can walk without restrictions, and when t+a=g\n we add g+r\n to time. So we can use 01\n-BFS to solve this task and at the end check find vertex and position from which we can go to our final destination.",
    "hint": []
}