{"link": "https://codeforces.com//contest/156/problem/E", "problemId": "963", "problem_idx": "E", "shortId": "156E", "contest_number": "156", "problem_submissions": {"E": [1251034, 1250912, 1253282, 1312001, 1252010, 1252212], "D": [1249184, 1247144, 1248677, 1244853, 1248432, 1249652, 1248827, 1249495, 1249499, 1249691, 1251015, 1250308, 1250503, 1250715, 1247775, 1249330, 1248752, 1249953], "C": [1246457, 1246202, 1245021, 1245780, 1246904, 1247167, 1247068, 1245810, 1248007, 1247482, 1246141, 1247596, 1248235, 1246808, 1249384, 1245140, 1248141, 1247379], "B": [1245938, 1245171, 1246054, 1247267, 1245759, 1246347, 1246009, 1246866, 1246408, 1246550, 1245203, 1246446, 1245623, 1245940, 1248731, 1247154, 1246738, 1246814], "A": [1244965, 1244119, 1244125, 1246346, 1244442, 1244222, 1247281, 1244463, 1247485, 1245043, 1244152, 1244905, 1244423, 1244550, 1252481, 1251048, 1252049]}, "name": "E. Mrs. Hudson s Pancakes", "statement": "Mrs. Hudson hasn\u2019t made her famous pancakes for quite a while and\r\nfinally she decided to make them again. She has learned new recipes\r\nrecently and she can\u2019t wait to try them. Those recipes are based on\r\nspecial spices. Mrs. Hudson has these spices in the kitchen lying in\r\njars with integers from to (each spice lies in an individual jar). Each\r\njar also has the of the corresponding spice inscribed some integer .We\r\nknow three values for the -th pancake recipe: , , . Here and are\r\nintegers, and is the of some integer written in the numeral system with\r\nradix . The pattern contains digits, Latin letters (to denote digits\r\nlarger than nine) and question marks. Number in the -base numeral system\r\n, if we can replace question marks in the pattern with digits and\r\nletters so that we obtain number (leading zeroes aren\u2019t taken into\r\nconsideration when performing the comparison). More formally: each\r\nquestion mark should be replaced by exactly one digit or exactly one\r\nletter. If after we replace all question marks we get a number with\r\nleading zeroes, we can delete these zeroes. For example, number in the\r\n-base numeral system matches the pattern \"\", and number does not.To make\r\nthe pancakes by the -th recipe, Mrs. Hudson should take all jars with\r\nwhose representation in the -base numeral system matches the pattern .\r\nThe of the recipe () is defined as the sum of number and the product of\r\nof all taken jars. More formally: (where is all such numbers whose\r\nrepresentation in the -base numeral system matches the pattern ).Mrs.\r\nHudson isn\u2019t as interested in the control numbers as she is in their\r\nminimum prime divisors. Your task is: for each recipe find the minimum\r\nprime divisor of number . If this divisor exceeds , then you do not have\r\nto find it, print -1.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nvoid add(int &a, int b, int p) {\n  a = (a + b) % p;\n}\nint mul(int a, int b, int p) {\n  return a * b % p;\n}\nint getid(char c) {\n  if (c >= '0' && c <= '9') return c - '0';\n  assert(c >= 'A' && c <= 'F');\n  return c - 'A' + 10;\n}\n\nconst int MAXD = 16;\nconst int MAXN = 1e4;\nconst int MSZ = 4;\nconst ll MMSK = (1 << MSZ) - 1;\n\nstruct Req {\n  int d;\n  ll msk, mval, c;\n  bool bad;\n};\n\nll ids[MAXD + 1][MAXN];\nint main() {\n  #ifdef DEBUG\n  freopen(\"std.in\", \"r\", stdin);\n  freopen(\"std.out\", \"w\", stdout);\n  #endif\n\n  vi ps;\n  for (int i = 2; i <= 100; i++) {\n    bool g = true;\n    for (int i2 = 2; i2 * i2 <= i; i2++)\n      if (i % i2 == 0) g = false;\n    if (!g) continue;\n    ps.pb(i);\n  }\n\n  for (int d = 2; d <= MAXD; d++) {\n    for (int i = 0; i < MAXN; i++) {\n      vi ds;\n      int x = i;\n      for (; x; x /= d) ds.pb(x % d);\n\n      ll &msk = ids[d][i] = 0;\n      for (int i2 = 0; i2 < sz(ds); i2++)\n        msk |= (ll)ds[i2] << (MSZ * i2);\n    }\n  }\n\n  int n, m;\n  while (scanf(\"%d\", &n) >= 1) {\n    vll as(n);\n    vvll asp(n);\n    for (int i = 0; i < n; i++) {\n      scanf(\"%I64d\", &as[i]);\n      for (int i2 = 0; i2 < sz(ps); i2++)\n        asp[i].pb(as[i] % ps[i2]);\n    }\n\n    scanf(\"%d\", &m);\n    vector<set<ll> > msks(MAXD + 1);\n    vector<Req> rqs(m);\n    for (int i = 0; i < m; i++) {\n      int &d = rqs[i].d;\n      char s[31];\n      scanf(\"%d%s%I64d\", &d, s, &rqs[i].c);\n\n      int i2 = 0;\n      int pos = strlen(s) - 1;\n      bool &bad = rqs[i].bad = false;\n      while (pos >= 14) {\n        if (s[i2] != '?' && s[i2] != '0') {\n          bad = true;\n          break;\n        }\n        i2++;\n        pos--;\n      }\n      if (bad)\n        continue;\n\n      ll &msk = rqs[i].msk, &mval = rqs[i].mval;\n      for (i2 = 0; s[i2]; i2++, pos--)\n        if (s[i2] != '?') {\n          msk |= MMSK << (MSZ * pos);\n          mval |= (ll)getid(s[i2]) << (MSZ * pos);\n        }\n      msks[d].insert(msk);\n    }\n    eprintf(\"read\\n\");\n\n    vector<map<ll, map<ll, vi> > > pcs(MAXD + 1);\n    for (int d = 2; d <= MAXD; d++) {\n      eprintf(\"d=%d %d\\n\", d, sz(msks[d]));\n      for (set<ll>::iterator it = msks[d].begin(); it != msks[d].end(); it++) {\n         ll msk = *it;\n\n         map<ll, vi> &cnts = pcs[d][msk];\n         for (int i = 0; i < n; i++) {\n           vi &ccnt = cnts[ids[d][i] & msk];\n           if (ccnt.empty())\n             ccnt = vi(sz(ps), 1);\n\n           for (int i2 = 0; i2 < sz(ccnt); i2++)\n             ccnt[i2] = mul(ccnt[i2], asp[i][i2], ps[i2]);\n         }\n      }\n    }\n\n    eprintf(\"go\\n\");\n    for (int i = 0; i < m; i++) {\n      vi cps(sz(ps));\n      for (int i2 = 0; i2 < sz(ps); i2++)\n        cps[i2] = rqs[i].c % ps[i2];\n\n      vi nps(sz(ps), 1);\n      if (!rqs[i].bad) {\n        map<ll, vi> &cnts = pcs[rqs[i].d][rqs[i].msk];\n        const vi &res = cnts[rqs[i].mval];\n        if (!res.empty()) nps = res;\n      }\n\n      for (int i2 = 0; i2 < sz(ps); i2++)\n        add(cps[i2], nps[i2], ps[i2]);\n      int ans = -1;\n      for (int i2 = 0; i2 < sz(ps); i2++)\n        if (!cps[i2]) { ans = ps[i2]; break; }\n      printf(\"%d\\n\", ans);\n    }\n    eprintf(\"end\\n\");\n  }\n  return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "dp"], "dificulty": "3000", "interactive": false}