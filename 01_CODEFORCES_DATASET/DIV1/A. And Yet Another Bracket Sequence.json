{
    "link": "https://codeforces.com//contest/529/problem/A",
    "problemId": "25010",
    "problem_idx": "A",
    "shortId": "529A",
    "contest_number": "529",
    "problem_submissions": {
        "A": [
            10386870,
            10387083,
            10387317,
            10387235,
            10387134,
            10386419,
            10387369,
            10386078,
            10389580,
            10388216,
            10387712,
            10386357,
            10387632,
            10386965,
            10387734,
            10385828
        ],
        "C": [
            10386311,
            10385455,
            10386427,
            10385364,
            10406538,
            10385834,
            10386051,
            10386918,
            10386327,
            10386510,
            10385417,
            10385724,
            10386116,
            10409781,
            10386107,
            10386201,
            10386650,
            10404350,
            10386786,
            10387225
        ],
        "D": [
            10385805,
            10386369,
            10385736,
            10386160,
            10387079,
            10385785,
            10386933,
            10385679,
            10386619,
            10386454,
            10386390,
            10387127,
            10386675,
            10386195,
            10385799,
            10388002
        ],
        "E": [
            10385000,
            10384871,
            10384905,
            10385848,
            10385056,
            10385201,
            10385198,
            10387352,
            10385145,
            10385184,
            10385731,
            10384843,
            10385458,
            10387221,
            10385405,
            10384991,
            10385094
        ],
        "B": [
            10384855,
            10385831,
            10385265,
            10386319,
            10385276,
            10385001,
            10385225,
            10386328,
            10385038,
            10384881,
            10385688,
            10386077,
            10385299,
            10385149,
            10385037,
            10385267,
            10384933,
            10388225
        ]
    },
    "name": "A. And Yet Another Bracket Sequence",
    "statement": "Polycarpus has a finite sequence of opening and closing brackets. In\r\norder not to fall asleep in a lecture, Polycarpus is having fun with his\r\nsequence. He is able to perform two operations: adding any bracket in\r\nany position (in the beginning, the end, or between any two existing\r\nbrackets); cyclic shift moving the last bracket from the end of the\r\nsequence to the beginning. Polycarpus can apply any number of operations\r\nto his sequence and adding a cyclic shift in any order. As a result, he\r\nwants to get the correct bracket sequence of the minimum possible\r\nlength. If there are several such sequences, Polycarpus is interested in\r\nthe lexicographically smallest one. Help him find such a sequence.A is a\r\nsequence of opening and closing brackets, from which you can get a\r\ncorrect arithmetic expression by adding characters \"1\" and \"+\" . Each\r\nopening bracket must correspond to a closed one. For example, the\r\nsequences \"(())()\", \"()\", \"(()(()))\" are correct and \")(\", \"(()\" and\r\n\"(()))(\" are not.The sequence is lexicographically smaller than sequence\r\n, if there is such number from to , that for and . Consider that \"(\"\r\n\")\".\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAXN = 2000200;\nconst int off = 1<<21;\nconst int mod = 1e9 + 9;\nconst int H = 9973;\n\ninline int add(int a, int b) {\n  return a+b >= mod ? a+b-mod : a+b;\n}\n\ninline int sub(int a, int b) {\n  return a >= b ? a-b : a-b+mod;\n}\n\ninline int mul(int a, int b) {\n  return llint(a)*b % mod;\n}\n\nint h[MAXN], pw[MAXN];\n\nstruct data {\n  int op, cl;\n} T[2*off];\n\ndata operator + (const data &a, const data &b) {\n  int m = min(a.op, b.cl);\n  return {a.op + b.op - m, a.cl + b.cl - m};\n}\ndata dummy = {0, 0};\n\ndata query(int i, int lo, int hi, int a, int b) {\n  if (lo >= b || hi <= a) return dummy;\n  if (lo >= a && hi <= b) return T[i];\n  return query(i*2, lo, (lo+hi)/2, a, b) + query(i*2+1, (lo+hi)/2, hi, a, b);\n}\n\nchar s[MAXN];\n\ninline int get_hash(int i, int len) {\n  return sub(h[i + len], mul(h[i], pw[len]));\n}\n\nbool cmp(int i, int j, int len) {\n  int lo = 0, hi = len;\n  while (lo < hi) {\n    int mid = (lo + hi + 1) / 2;\n    if (get_hash(i, mid) == get_hash(j, mid)) lo = mid; else\n      hi = mid - 1;\n  }\n\n  return s[i + lo] == '(';\n}\n\nint main(void) {\n  scanf(\"%s\", s);\n  int n = strlen(s);\n  REP(i, n) s[n+i] = s[i];\n  \n  pw[0] = 1;\n  h[0] = 0;\n  REP(i, 2*n) {\n    h[i+1] = add(mul(h[i], H), s[i]);\n    pw[i+1] = mul(pw[i], H);\n  }\n\n  FOR(i, off, 2*off)\n    if (i-off < 2*n) {\n      if (s[i-off] == '(') T[i] = {1, 0}; else\n        T[i] = {0, 1};\n    } else \n      T[i] = dummy;\n  \n  for (int i = off-1; i > 0; --i)\n    T[i] = T[i*2] + T[i*2+1];\n  \n  int best = 4*n;\n  int bestop = -1;\n  int bestcl = -1;\n  int ind = -1;\n  \n  REP(i, n) {\n    data a = query(1, 0, off, i, i + n);\n    int len = n + a.op + a.cl;\n    if (len < best || (len == best && cmp(i, ind, n))) {\n      best = len;\n      bestop = a.op;\n      bestcl = a.cl;\n      ind = i;\n    }\n  }\n  \n  REP(i, bestcl) putchar('(');\n  REP(i, n) putchar(s[ind + i]);\n  REP(i, bestop) putchar(')');\n  putchar('\\n');\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "hashing",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. And Yet Another Bracket Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/17065",
    "editorial": "The main idea is that the bracket sequence can be seen as a sequence of prefix balances, i. e sequence (ai) such that ai?+?1?=?ai?Â±?1.\n\nCalculate the number of opening brackets A and closing brackets B in original string. It is true that if A?>??=?B then the string can be fixed by adding A?-?B closing brackets at the end and shifting the resulting string to the point of balance minimum, and if A???B, then the string can be similarly fixed by adding B?-?A opening brackets to the beginning and then properly shifting the whole string. It's obvious that it is impossible to fix the string by using the less number of brackets. So we know the value of the answer, now we need to figure out how it looks like.\n\nSuppose that we first circularly shift and only then add brackets. Suppose that we add x closing brackets. Consider the following two facts:\n\nIf it is possible to fix a string by adding closing bracket to some x positions then it is possible to fix it by adding x closing brackets to the end of the string.\nFrom all strings obtained from a give one by adding closing brackets to x positions, the minimum is one that obtained by putting x closing brackets to the end.\nEach of those statements is easy to prove. They give us the fact that in the optimal answer we put closing brackets at the end of the string (after rotating the initial string). So we have to consider the set of the original string circular shifts such that they transform to the correct bracket sequence by adding x?=?A?-?B closing brackets to the end and choose the lexicographically least among them. Comparing circular shifts of the string is the problem that can be solved by a suffix array. The other way is to find lexicographical minimum among them by using hashing and binary search to compare two circular shifts.\n\nThe case when A???B is similar except that opening brackets should be put into the beginning of the string.\n\nSo, overall complexity is .",
    "hint": []
}