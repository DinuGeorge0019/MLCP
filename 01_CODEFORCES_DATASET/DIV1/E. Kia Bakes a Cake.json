{
    "link": "https://codeforces.com//contest/2101/problem/E",
    "problemId": "3379870",
    "problem_idx": "E",
    "shortId": "2101E",
    "contest_number": "2101",
    "problem_submissions": {
        "D": [
            319294804,
            319237348,
            319244062,
            319233111,
            319248438,
            319270934,
            319247114,
            319246074,
            319245749,
            319256088,
            319251191,
            319251037,
            319261866,
            319252875,
            319254950,
            319262267,
            319251514,
            319255297
        ],
        "F": [
            319280605,
            319281731,
            319296938,
            319296545,
            319307832,
            319307784,
            319294905,
            319285038,
            319280546,
            319439373,
            319610626,
            319290581,
            322062368,
            319622463
        ],
        "E": [
            319261457,
            319271887,
            319269195,
            319269179,
            319260221,
            319295559,
            319294878,
            319271978,
            319272872,
            319314013,
            319277656,
            319282084,
            319306454,
            319284113,
            319285106,
            319318396,
            319280504,
            319284828,
            319289037
        ],
        "C": [
            319227789,
            319248152,
            319242282,
            319237027,
            319228539,
            319229145,
            319235166,
            319232460,
            319242619,
            319234897,
            319234927,
            319241291,
            319239653,
            319237271,
            319245442,
            319240061,
            319236820
        ],
        "B": [
            319220410,
            319218858,
            319221247,
            319221700,
            319222744,
            319220314,
            319219692,
            319223217,
            319223401,
            319224243,
            319230362,
            319224392,
            319222585,
            319222454,
            319227561,
            319224092
        ],
        "A": [
            319215799,
            319216381,
            319216154,
            319217268,
            319216406,
            319216292,
            319216910,
            319216574,
            319215332,
            319218464,
            319222747,
            319217683,
            319216023,
            319216949,
            319220045,
            319216375
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142788",
    "editorial": "SolutionThe length of each two nodes in a tree is always less than the\r\nnumber of nodes, and therefore the maximum weight that we can see in our\r\nconstructed graph has an upper bound of . Because the weight of any nice\r\npath is doubled every time, the maximum length of any nice path won’t\r\nexceed . The next observation is that we cannot see any node twice in a\r\nnice path (in other words, there are no cycles).Proof: Let’s assume that\r\na cycle exists. We know that the weight of each edge is always greater\r\nthan the sum of all previous edges, so even without any waste, . This\r\ntells us no matter how far we get, because we’re taking more steps in\r\nthe last edge than the sum of all previous ones, we can never end up in\r\nthe first node. Therefore, every nice path is a simple path, and no\r\ncycles can be made.Now, let’s define as the maximum weight of any edge\r\nto start a simple path from vertex and take steps, and if not possible.\r\nThe idea here is to build the nicest path reversly, from the end to the\r\nbeginning. We can update this and build the paths backwards, and this\r\nwill give us an solution as .To optimize this, we use the suffix trick\r\non centroid decomposition and keep the maximum two suffixes every time,\r\nto update in increasing order of accordingly. This would result in a\r\nimplementation, which can be further optimized to using the fact that we\r\ncan use counting sort for sorting as we have an upper bound of . Both\r\nimplementations are included below.\r\n",
    "name": "E. Kia Bakes a Cake",
    "statement": "You are given a binary string s of length n and a tree T with n\r\nvertices. Let k be the number of s in s. We will construct a complete\r\nundirected weighted graph with k vertices as follows: For each 1\r\nle i\r\nle n with s_i =\r\nmathtt{1}, create a vertex labeled i. For any two vertices labeled u and\r\nv that are created in the above step, define the edge weight between\r\nthem w(u, v) as the distance^{\r\ntext{ }} between vertex u and vertex v in the tree T. A path^{\r\ntext{ }} that visits vertices labeled v_1, v_2,\r\nldots, v_m in this order is if for all 1\r\nle i\r\nle m - 2, the condition 2\r\ncdot w(v_i, v_{i + 1})\r\nle w(v_{i + 1}, v_{i + 2}) holds. In other words, the weight of each\r\nedge in the path must be at least twice the weight of the previous edge.\r\nNote that s_{v_i} =\r\nmathtt{1} has to be satisfied for all 1\r\nle i\r\nle m, as otherwise, there would be no vertex with the corresponding\r\nlabel.For each vertex labeled i (1\r\nle i\r\nle n and s_i =\r\nmathtt{1}) in the complete undirected weighted graph, determine the\r\nmaximum number of vertices in any nice simple path starting from the\r\nvertex labeled i.^{\r\ntext{ }}The distance between two vertices a and b in a tree is equal to\r\nthe number of edges on the unique simple path between vertex a and\r\nvertex b.^{\r\ntext{ }}A path is a sequence of vertices v_1, v_2,\r\nldots, v_m such that there is an edge between v_i and v_{i + 1} for all\r\n1\r\nle i\r\nle m - 1. A simple path is a path with no repeated vertices, i.e., v_i\r\nneq v_j for all 1\r\nle i < j\r\nle m.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Kia Bakes a Cake.json",
    "hint": [
        "Hint 1 Can we see any node twice in our walk?",
        "Hint 2 What is the upper bound on the length of the path?",
        "Hint 3 How do we approach this using dynamic programming?",
        "Hint 4 How to optimize the DP?"
    ]
}