{
    "link": "https://codeforces.com//contest/1827/problem/F",
    "problemId": "1922415",
    "problem_idx": "F",
    "shortId": "1827F",
    "contest_number": "1827",
    "problem_submissions": {
        "B1": [
            205909125,
            205871229,
            205860094,
            205853484,
            205858214,
            205884799,
            205855785,
            205857268,
            205859721,
            205854125,
            205853990,
            205854393,
            205857685,
            205856108,
            205871852,
            205864517,
            205849753,
            205856355,
            206036248,
            205883111,
            205857458,
            205852308
        ],
        "C": [
            205887704,
            205865086,
            205862189,
            205877784,
            205865401,
            205880693,
            205873972,
            205883370,
            205896807,
            205874900,
            205883582,
            205869590,
            205872529,
            205865317,
            205875560,
            205870203,
            205870915,
            206036332,
            205857923,
            205878002,
            205869836
        ],
        "E": [
            205882857,
            205890682,
            205893722,
            205893207,
            205891321,
            205895989,
            205901490,
            205897572,
            205894529,
            205889627,
            205900528,
            205921803,
            205921497,
            205921364,
            205921183,
            205920554,
            205920187,
            205928602,
            205907318,
            205907019,
            205906136,
            205905793,
            205905368,
            205905221,
            205903986
        ],
        "B2": [
            205871376,
            205860123,
            205854465,
            205857731,
            205884857,
            205854446,
            205857708,
            205859949,
            205855049,
            205892922,
            205864074,
            205856597,
            205855367,
            205871926,
            205864651,
            205863717,
            205856284,
            206036255,
            205889062,
            205869038,
            205876542
        ],
        "D": [
            205863885,
            205875931,
            205878262,
            205884073,
            205878863,
            205877520,
            205881913,
            205884050,
            205871773,
            205899731,
            205892557,
            205885814,
            205881313,
            205883473,
            205884864,
            205888365,
            205888201,
            206036361,
            205877449,
            205886393,
            205963414,
            205889611
        ],
        "A": [
            205845172,
            205844037,
            205843466,
            205843847,
            205844462,
            205843511,
            205844799,
            205845695,
            205844273,
            205843867,
            205845548,
            205843654,
            205843208,
            205846139,
            205845358,
            205843530,
            206036234,
            205846931,
            205848794,
            205843958
        ],
        "F": [
            207299235,
            207299224,
            207299166,
            207299023,
            207298779,
            207298502,
            207298128
        ]
    },
    "name": "F. Copium Permutation",
    "statement": "You are given a permutation a_1,a_2,\r\nldots,a_n of the first n positive integers. A subarray [l,r] is called\r\nif we can rearrange it so that it becomes a sequence of consecutive\r\nintegers, or more formally, if\r\nmax(a_l,a_{l+1},\r\nldots,a_r)-\r\nmin(a_l,a_{l+1},\r\nldots,a_r)=r-l For each k in the range [0,n], print out the number of\r\ncopium subarrays of a over all ways of rearranging the last n-k elements\r\nof a.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nint main() {\n\tusing std::cin;\n\tusing std::cout;\n\tusing std::cerr;\n\tstd::ios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; cin >> N;\n\t\tstd::vector<int> A(N);\n\t\tfor (auto& a : A) { cin >> a; a--; }\n\n\t\tstd::vector<int> nxt_earlier(N);\n\t\tstd::vector<int> prv_earlier(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnxt_earlier[i] = i+1;\n\t\t\tprv_earlier[i] = i-1;\n\t\t}\n\t\tfor (int i = N-1; i >= 0; i--) {\n\t\t\tint a = A[i];\n\t\t\tint p = prv_earlier[a];\n\t\t\tint n = nxt_earlier[a];\n\t\t\tif (p != -1) nxt_earlier[p] = n;\n\t\t\tif (n != N) prv_earlier[n] = p;\n\t\t}\n\n\t\tauto c2 = [](int a) -> int64_t {\n\t\t\tassert(a >= 0);\n\t\t\treturn int64_t(a) * int64_t(a-1) / 2;\n\t\t};\n\n\t\t// lo_ans is strictly before i, hi_ans is strictly after i\n\t\tint64_t lo_ans = 0;\n\t\tint64_t hi_ans = c2(N+1);\n\t\t// We store mid_ans (things using i) in the persistent stack\n\n\t\tenum class NodeType {\n\t\t\tLEAF,\n\t\t\tINCR,\n\t\t\tDECR,\n\t\t\tFULL,\n\t\t\tPARTIAL,\n\t\t};\n\t\tstruct cnd_t {\n\t\t\tint left;\n\t\t\tint lo;\n\t\t\tint lo_gap;\n\t\t\tint hi;\n\t\t\tint hi_gap;\n\t\t\tNodeType node_type;\n\t\t\tint node_sz;\n\n\t\t\tint64_t mid_ans = 0;\n\n\t\t\tint lo_best = 0;\n\t\t\tint64_t lo_cur = 0;\n\t\t\tint hi_best = 0;\n\t\t\tint64_t hi_cur = 0;\n\t\t};\n\n\t\tstd::vector<cnd_t> stk; stk.reserve(N);\n\n\t\tstd::vector<int64_t> res; res.reserve(N+1);\n\t\tres.push_back(lo_ans + 0 + hi_ans);\n\n\t\tauto update_back = [&]() -> void {\n\t\t\tint z = int(stk.size()) - 1;\n\t\t\tassert(z >= 0);\n\t\t\tstk[z].mid_ans = z == 0 ? 0 : stk[z-1].mid_ans;\n\t\t\tstk[z].mid_ans += std::max(stk[z].node_sz, 1);\n\t\t\t{\n\t\t\t\tint lo_gap_sz = stk[z].lo - stk[z].lo_gap;\n\t\t\t\tassert(lo_gap_sz >= 0);\n\t\t\t\tif (z > 0 && stk[z].lo_gap == stk[z-1].lo_gap) {\n\t\t\t\t\tstk[z].lo_best = std::max(stk[z-1].lo_best, stk[z-1].node_sz);\n\t\t\t\t\tstk[z].mid_ans -= stk[z-1].lo_cur;\n\t\t\t\t} else {\n\t\t\t\t\tstk[z].lo_best = 0;\n\t\t\t\t}\n\t\t\t\tstk[z].lo_cur = int64_t(lo_gap_sz) * int64_t(stk[z].lo_best + 1);\n\t\t\t\tstk[z].mid_ans += stk[z].lo_cur;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint hi_gap_sz = stk[z].hi_gap - stk[z].hi;\n\t\t\t\tassert(hi_gap_sz >= 0);\n\t\t\t\tif (z > 0 && stk[z].hi_gap == stk[z-1].hi_gap) {\n\t\t\t\t\tstk[z].hi_best = std::max(stk[z-1].hi_best, stk[z-1].node_sz);\n\t\t\t\t\tstk[z].mid_ans -= stk[z-1].hi_cur;\n\t\t\t\t} else {\n\t\t\t\t\tstk[z].hi_best = 0;\n\t\t\t\t}\n\t\t\t\tstk[z].hi_cur = int64_t(hi_gap_sz) * int64_t(stk[z].hi_best + 1);\n\t\t\t\tstk[z].mid_ans += stk[z].hi_cur;\n\t\t\t}\n\t\t};\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a = A[i];\n\n\t\t\twhile (!stk.empty() && (a < stk.back().lo_gap || a > stk.back().hi_gap)) {\n\t\t\t\tassert(stk.size() >= 2);\n\t\t\t\tif (stk.end()[-2].lo_gap == stk.end()[-1].lo_gap) {\n\t\t\t\t\tstk.end()[-2].lo = stk.end()[-1].lo;\n\t\t\t\t} else if (stk.end()[-2].hi_gap == stk.end()[-1].hi_gap) {\n\t\t\t\t\tstk.end()[-2].hi = stk.end()[-1].hi;\n\t\t\t\t}\n\n\t\t\t\tstk.pop_back();\n\n\t\t\t\tstk.back().node_type = NodeType::PARTIAL;\n\t\t\t\tstk.back().node_sz = 0;\n\t\t\t}\n\n\t\t\tif (!stk.empty()) {\n\t\t\t\tif (stk.back().node_type == NodeType::DECR) {\n\t\t\t\t\tassert(a < stk.back().lo || a > stk.back().hi);\n\t\t\t\t\tif (a > stk.back().hi) {\n\t\t\t\t\t\tstk.back().node_type = NodeType::FULL;\n\t\t\t\t\t\tstk.back().node_sz = 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (stk.back().node_type == NodeType::INCR) {\n\t\t\t\t\tassert(a < stk.back().lo || a > stk.back().hi);\n\t\t\t\t\tif (a < stk.back().lo) {\n\t\t\t\t\t\tstk.back().node_type = NodeType::FULL;\n\t\t\t\t\t\tstk.back().node_sz = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thi_ans -= int64_t(nxt_earlier[a] - a) * int64_t(a - prv_earlier[a]);\n\n\t\t\tif (!stk.empty()) {\n\t\t\t\t// Until this point, we were just merging/joining the single back node, so we don't need to call update in any other places\n\t\t\t\tupdate_back();\n\t\t\t}\n\t\t\tstk.push_back({i, a, prv_earlier[a]+1, a, nxt_earlier[a]-1, NodeType::PARTIAL, 0});\n\t\t\tupdate_back();\n\t\t\t//cerr << \"Run \" << i << ' ' << a << ' ' << lo_ans << ' ' << hi_ans << '\\n';\n\t\t\t//for (auto it : stk) { cerr << it.left << ' ' << it.lo_gap << '-' << it.lo << '-' << it.hi << '-' << it.hi_gap << ' ' << int(it.node_type) << ' ' << it.node_sz << '\\n'; }\n\n\t\t\tres.push_back(lo_ans + stk.back().mid_ans + hi_ans);\n\t\t\t//cerr << \"mid_ans \" << mid_ans << '\\n';\n\n\t\t\tstk.back().node_type = NodeType::LEAF;\n\t\t\tstk.back().node_sz = 1;\n\t\t\tlo_ans ++;\n\n\t\t\twhile (stk.size() >= 2 && std::max(stk.back().hi, stk.end()[-2].hi) - std::min(stk.back().lo, stk.end()[-2].lo) == i - stk.end()[-2].left) {\n\t\t\t\t// merge these two nodes into one\n\t\t\t\tNodeType node_type;\n\t\t\t\tint node_sz;\n\t\t\t\tif (stk.end()[-2].lo_gap == stk.end()[-1].lo_gap) {\n\t\t\t\t\tstk.end()[-2].lo = stk.end()[-1].lo;\n\t\t\t\t\tnode_type = NodeType::DECR;\n\t\t\t\t\tnode_sz = (stk.end()[-2].node_type == node_type ? stk.end()[-2].node_sz : 1) + 1;\n\t\t\t\t\tlo_ans += node_sz - 1;\n\t\t\t\t} else if (stk.end()[-2].hi_gap == stk.end()[-1].hi_gap) {\n\t\t\t\t\tstk.end()[-2].hi = stk.end()[-1].hi;\n\t\t\t\t\tnode_type = NodeType::INCR;\n\t\t\t\t\tnode_sz = (stk.end()[-2].node_type == node_type ? stk.end()[-2].node_sz : 1) + 1;\n\t\t\t\t\tlo_ans += node_sz - 1;\n\t\t\t\t} else {\n\t\t\t\t\tnode_type = NodeType::FULL;\n\t\t\t\t\tnode_sz = 1;\n\t\t\t\t\tlo_ans ++;\n\t\t\t\t}\n\n\t\t\t\tstk.pop_back();\n\t\t\t\tstk.back().node_type = node_type;\n\t\t\t\tstk.back().node_sz = node_sz;\n\t\t\t}\n\t\t}\n\t\tassert(int(res.size()) == N+1);\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tcout << res[i] << \" \\n\"[i==N];\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Copium Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/116109",
    "editorial": "SolutionSolve the problem for fixed Call the last elements as special\r\nnumbers.Observation: In optimal rearrangement, every maximal segment of\r\nspecial numbers will be placed on consecutive positions in either\r\nascending order or descending order. For simplicity, from now on we will\r\ncall maximal segment of special number as maximal segment.For example,\r\ntake a permutation and , the maximal segments are , and .We divide the\r\nset of copium subarrays into three parts, one for those lie entirely on\r\nprefix , one for those lie entirely on suffix , and one for the rest.\r\nThe number of subarrays in the first part can be calculated with the\r\nalgorithm used in 526F - Pudding Monsters. The number of subarrays in\r\nthe second part can be easily deduced from above observation.Define an\r\narray such that for each : and subarray contains consecutive nonspecial\r\nnumbers.For example, take a permutation and , then .We will process\r\narray from right to left while adding special numbers from left to\r\nright. Let us consider , first add all special numbers which are missing\r\nfrom subarray at the end of current permutation. If is not already\r\ncopium, we increase our answer by one. Denote and as the minimum and\r\nmaximum number in subarray . Loot at two maximal segments, one contains\r\nand one contains . We can place them here to increase the answer.For\r\nexample, let , , and the current permutation . The two maximal segments\r\nare and . We can place them like to increase the answer by 4.\r\nFurthermore, we can see that three good positions , and benefit from\r\nmaximal segment . In general, consider consecutive good positions\r\nsatisfying , all of them can benefit from the same maximal segment if\r\nfor all , subarray is copium .There is a similar condition when we\r\nconsider consecutive good positions having the same . So the algorithm\r\ngoes like this: For each value of and , find the longest segment of good\r\npositions satisfying condition , then multiply with the length of\r\ncorresponding maximal segment and add to the answer.Solve for each We\r\nwill calculate the answer for each from to in this order. We will store\r\nthe longest segment for each prefix of -equivalent and -equivalent\r\npositions. Note that when going from to , only a suffix of will no\r\nlonger be good, so we can manually delete them one by one from right to\r\nleft, then add . There will be at most good positions we need to\r\nconsider. The first one, of course, is . If or , let be the last\r\nposition satisfying or , the second one is the first good position after\r\nand it satisfies a property: It must be the last position in the\r\n-equivalent or -equivalent positions. The proof is left as an exercise.\r\nTherefore, updating this position will not affect the positions behind\r\nit. The overall complexity is .\r\n"
}