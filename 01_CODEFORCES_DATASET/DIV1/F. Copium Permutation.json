{"link": "https://codeforces.com//contest/1827/problem/F", "problemId": "1922415", "problem_idx": "F", "shortId": "1827F", "contest_number": "1827", "problem_submissions": {"B1": [205909125, 205871229, 205860094, 205853484, 205858214, 205884799, 205855785, 205857268, 205859721, 205854125, 205853990, 205854393, 205857685, 205856108, 205871852, 205864517, 205849753, 205856355, 206036248, 205883111, 205857458, 205852308], "C": [205887704, 205865086, 205862189, 205877784, 205865401, 205880693, 205873972, 205883370, 205896807, 205874900, 205883582, 205869590, 205872529, 205865317, 205875560, 205870203, 205870915, 206036332, 205857923, 205878002, 205869836], "E": [205882857, 205890682, 205893722, 205893207, 205891321, 205895989, 205901490, 205897572, 205894529, 205889627, 205900528, 205921803, 205921497, 205921364, 205921183, 205920554, 205920187, 205928602, 205907318, 205907019, 205906136, 205905793, 205905368, 205905221, 205903986], "B2": [205871376, 205860123, 205854465, 205857731, 205884857, 205854446, 205857708, 205859949, 205855049, 205892922, 205864074, 205856597, 205855367, 205871926, 205864651, 205863717, 205856284, 206036255, 205889062, 205869038, 205876542], "D": [205863885, 205875931, 205878262, 205884073, 205878863, 205877520, 205881913, 205884050, 205871773, 205899731, 205892557, 205885814, 205881313, 205883473, 205884864, 205888365, 205888201, 206036361, 205877449, 205886393, 205963414, 205889611], "A": [205845172, 205844037, 205843466, 205843847, 205844462, 205843511, 205844799, 205845695, 205844273, 205843867, 205845548, 205843654, 205843208, 205846139, 205845358, 205843530, 206036234, 205846931, 205848794, 205843958], "F": [207299235, 207299224, 207299166, 207299023, 207298779, 207298502, 207298128]}, "name": "F. Copium Permutation", "statement": "You are given a permutation a_1,a_2,\r\nldots,a_n of the first n positive integers. A subarray [l,r] is called\r\nif we can rearrange it so that it becomes a sequence of consecutive\r\nintegers, or more formally, if\r\nmax(a_l,a_{l+1},\r\nldots,a_r)-\r\nmin(a_l,a_{l+1},\r\nldots,a_r)=r-l For each k in the range [0,n], print out the number of\r\ncopium subarrays of a over all ways of rearranging the last n-k elements\r\nof a.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nint main() {\n\tusing std::cin;\n\tusing std::cout;\n\tusing std::cerr;\n\tstd::ios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; cin >> N;\n\t\tstd::vector<int> A(N);\n\t\tfor (auto& a : A) { cin >> a; a--; }\n\n\t\tstd::vector<int> nxt_earlier(N);\n\t\tstd::vector<int> prv_earlier(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnxt_earlier[i] = i+1;\n\t\t\tprv_earlier[i] = i-1;\n\t\t}\n\t\tfor (int i = N-1; i >= 0; i--) {\n\t\t\tint a = A[i];\n\t\t\tint p = prv_earlier[a];\n\t\t\tint n = nxt_earlier[a];\n\t\t\tif (p != -1) nxt_earlier[p] = n;\n\t\t\tif (n != N) prv_earlier[n] = p;\n\t\t}\n\n\t\tauto c2 = [](int a) -> int64_t {\n\t\t\tassert(a >= 0);\n\t\t\treturn int64_t(a) * int64_t(a-1) / 2;\n\t\t};\n\n\t\t// lo_ans is strictly before i, hi_ans is strictly after i\n\t\tint64_t lo_ans = 0;\n\t\tint64_t hi_ans = c2(N+1);\n\t\t// We store mid_ans (things using i) in the persistent stack\n\n\t\tenum class NodeType {\n\t\t\tLEAF,\n\t\t\tINCR,\n\t\t\tDECR,\n\t\t\tFULL,\n\t\t\tPARTIAL,\n\t\t};\n\t\tstruct cnd_t {\n\t\t\tint left;\n\t\t\tint lo;\n\t\t\tint lo_gap;\n\t\t\tint hi;\n\t\t\tint hi_gap;\n\t\t\tNodeType node_type;\n\t\t\tint node_sz;\n\n\t\t\tint64_t mid_ans = 0;\n\n\t\t\tint lo_best = 0;\n\t\t\tint64_t lo_cur = 0;\n\t\t\tint hi_best = 0;\n\t\t\tint64_t hi_cur = 0;\n\t\t};\n\n\t\tstd::vector<cnd_t> stk; stk.reserve(N);\n\n\t\tstd::vector<int64_t> res; res.reserve(N+1);\n\t\tres.push_back(lo_ans + 0 + hi_ans);\n\n\t\tauto update_back = [&]() -> void {\n\t\t\tint z = int(stk.size()) - 1;\n\t\t\tassert(z >= 0);\n\t\t\tstk[z].mid_ans = z == 0 ? 0 : stk[z-1].mid_ans;\n\t\t\tstk[z].mid_ans += std::max(stk[z].node_sz, 1);\n\t\t\t{\n\t\t\t\tint lo_gap_sz = stk[z].lo - stk[z].lo_gap;\n\t\t\t\tassert(lo_gap_sz >= 0);\n\t\t\t\tif (z > 0 && stk[z].lo_gap == stk[z-1].lo_gap) {\n\t\t\t\t\tstk[z].lo_best = std::max(stk[z-1].lo_best, stk[z-1].node_sz);\n\t\t\t\t\tstk[z].mid_ans -= stk[z-1].lo_cur;\n\t\t\t\t} else {\n\t\t\t\t\tstk[z].lo_best = 0;\n\t\t\t\t}\n\t\t\t\tstk[z].lo_cur = int64_t(lo_gap_sz) * int64_t(stk[z].lo_best + 1);\n\t\t\t\tstk[z].mid_ans += stk[z].lo_cur;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint hi_gap_sz = stk[z].hi_gap - stk[z].hi;\n\t\t\t\tassert(hi_gap_sz >= 0);\n\t\t\t\tif (z > 0 && stk[z].hi_gap == stk[z-1].hi_gap) {\n\t\t\t\t\tstk[z].hi_best = std::max(stk[z-1].hi_best, stk[z-1].node_sz);\n\t\t\t\t\tstk[z].mid_ans -= stk[z-1].hi_cur;\n\t\t\t\t} else {\n\t\t\t\t\tstk[z].hi_best = 0;\n\t\t\t\t}\n\t\t\t\tstk[z].hi_cur = int64_t(hi_gap_sz) * int64_t(stk[z].hi_best + 1);\n\t\t\t\tstk[z].mid_ans += stk[z].hi_cur;\n\t\t\t}\n\t\t};\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a = A[i];\n\n\t\t\twhile (!stk.empty() && (a < stk.back().lo_gap || a > stk.back().hi_gap)) {\n\t\t\t\tassert(stk.size() >= 2);\n\t\t\t\tif (stk.end()[-2].lo_gap == stk.end()[-1].lo_gap) {\n\t\t\t\t\tstk.end()[-2].lo = stk.end()[-1].lo;\n\t\t\t\t} else if (stk.end()[-2].hi_gap == stk.end()[-1].hi_gap) {\n\t\t\t\t\tstk.end()[-2].hi = stk.end()[-1].hi;\n\t\t\t\t}\n\n\t\t\t\tstk.pop_back();\n\n\t\t\t\tstk.back().node_type = NodeType::PARTIAL;\n\t\t\t\tstk.back().node_sz = 0;\n\t\t\t}\n\n\t\t\tif (!stk.empty()) {\n\t\t\t\tif (stk.back().node_type == NodeType::DECR) {\n\t\t\t\t\tassert(a < stk.back().lo || a > stk.back().hi);\n\t\t\t\t\tif (a > stk.back().hi) {\n\t\t\t\t\t\tstk.back().node_type = NodeType::FULL;\n\t\t\t\t\t\tstk.back().node_sz = 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (stk.back().node_type == NodeType::INCR) {\n\t\t\t\t\tassert(a < stk.back().lo || a > stk.back().hi);\n\t\t\t\t\tif (a < stk.back().lo) {\n\t\t\t\t\t\tstk.back().node_type = NodeType::FULL;\n\t\t\t\t\t\tstk.back().node_sz = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thi_ans -= int64_t(nxt_earlier[a] - a) * int64_t(a - prv_earlier[a]);\n\n\t\t\tif (!stk.empty()) {\n\t\t\t\t// Until this point, we were just merging/joining the single back node, so we don't need to call update in any other places\n\t\t\t\tupdate_back();\n\t\t\t}\n\t\t\tstk.push_back({i, a, prv_earlier[a]+1, a, nxt_earlier[a]-1, NodeType::PARTIAL, 0});\n\t\t\tupdate_back();\n\t\t\t//cerr << \"Run \" << i << ' ' << a << ' ' << lo_ans << ' ' << hi_ans << '\\n';\n\t\t\t//for (auto it : stk) { cerr << it.left << ' ' << it.lo_gap << '-' << it.lo << '-' << it.hi << '-' << it.hi_gap << ' ' << int(it.node_type) << ' ' << it.node_sz << '\\n'; }\n\n\t\t\tres.push_back(lo_ans + stk.back().mid_ans + hi_ans);\n\t\t\t//cerr << \"mid_ans \" << mid_ans << '\\n';\n\n\t\t\tstk.back().node_type = NodeType::LEAF;\n\t\t\tstk.back().node_sz = 1;\n\t\t\tlo_ans ++;\n\n\t\t\twhile (stk.size() >= 2 && std::max(stk.back().hi, stk.end()[-2].hi) - std::min(stk.back().lo, stk.end()[-2].lo) == i - stk.end()[-2].left) {\n\t\t\t\t// merge these two nodes into one\n\t\t\t\tNodeType node_type;\n\t\t\t\tint node_sz;\n\t\t\t\tif (stk.end()[-2].lo_gap == stk.end()[-1].lo_gap) {\n\t\t\t\t\tstk.end()[-2].lo = stk.end()[-1].lo;\n\t\t\t\t\tnode_type = NodeType::DECR;\n\t\t\t\t\tnode_sz = (stk.end()[-2].node_type == node_type ? stk.end()[-2].node_sz : 1) + 1;\n\t\t\t\t\tlo_ans += node_sz - 1;\n\t\t\t\t} else if (stk.end()[-2].hi_gap == stk.end()[-1].hi_gap) {\n\t\t\t\t\tstk.end()[-2].hi = stk.end()[-1].hi;\n\t\t\t\t\tnode_type = NodeType::INCR;\n\t\t\t\t\tnode_sz = (stk.end()[-2].node_type == node_type ? stk.end()[-2].node_sz : 1) + 1;\n\t\t\t\t\tlo_ans += node_sz - 1;\n\t\t\t\t} else {\n\t\t\t\t\tnode_type = NodeType::FULL;\n\t\t\t\t\tnode_sz = 1;\n\t\t\t\t\tlo_ans ++;\n\t\t\t\t}\n\n\t\t\t\tstk.pop_back();\n\t\t\t\tstk.back().node_type = node_type;\n\t\t\t\tstk.back().node_sz = node_sz;\n\t\t\t}\n\t\t}\n\t\tassert(int(res.size()) == N+1);\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tcout << res[i] << \" \\n\"[i==N];\n\t\t}\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "greedy"], "dificulty": "3500", "interactive": false}