{
    "link": "https://codeforces.com//contest/2066/problem/E",
    "problemId": "3199293",
    "problem_idx": "E",
    "shortId": "2066E",
    "contest_number": "2066",
    "problem_submissions": {
        "F": [
            305961929,
            305711209,
            305793569
        ],
        "E": [
            305671371,
            305674660,
            305665469,
            305684205,
            305683469,
            310345727,
            310345697,
            310345040,
            310344970,
            310344497,
            305694481,
            305692759,
            305693640,
            305681002,
            305696381,
            305695872,
            305686452,
            305675358,
            305680777,
            305683070,
            305690451,
            305694177,
            305728015,
            305696099
        ],
        "D2": [
            305648746,
            305651253,
            305683341,
            305658883,
            305667318,
            305671414,
            305677452,
            305675429,
            305693750,
            305670413,
            305682081,
            305674110,
            305707013,
            305819437,
            305673972,
            305704574
        ],
        "D1": [
            305641952,
            305650970,
            305646344,
            305645126,
            305659222,
            305663013,
            305661891,
            305665940,
            305665958,
            305662965,
            305663912,
            305674196,
            305649164,
            305650961,
            305657269,
            305647121,
            305660139,
            305661141,
            305667237
        ],
        "C": [
            305634452,
            305633837,
            305639878,
            305638169,
            305653394,
            305631789,
            305636828,
            305651476,
            305661411,
            305643169,
            305658240,
            305653292,
            305630480,
            305641469,
            305649547,
            305637115,
            305653856,
            305647798,
            305652374
        ],
        "B": [
            305627289,
            305635243,
            305623300,
            305628744,
            305647081,
            305643811,
            305641796,
            305631285,
            305634558,
            305631722,
            305638100,
            305660386,
            305639015,
            305628890,
            305637597,
            305626680,
            305646425,
            305631817,
            305639727
        ],
        "A": [
            305621144,
            305616029,
            305632571,
            305622624,
            305643284,
            305653176,
            305619400,
            305618136,
            305626320,
            305627945,
            305642775,
            305657405,
            305632785,
            305618364,
            305626420,
            305620045,
            305626552,
            305622482,
            305623998
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/139415?locale=en",
    "editorial": "If all values are distinct, we immediately lose (except for ).Suppose\r\ninitially there are two barrels of equal weight . Then we look at what\r\nthe scales indicate for the pair . If it shows \"greater\" or \"less\" we\r\nunderstand that the poisonous barrel is respectively or and we win\r\nimmediately. If it shows \"equal,\" then both barrels are definitely not\r\npoisonous. We will keep only the barrels whose mass appears exactly\r\nonce, and from all the other barrels, we can pour all the water into one\r\nof the barrels, and let the mass of this water be .We have water\r\navailable to pour into a safe barrel, and in the remaining barrels there\r\nis water.If water is currently available, we can either: Check any\r\nbarrel that has water. By pouring water from the safe barrel into it\r\nuntil the weights are equal, we then check the scales. If they show\r\nequality, we know for sure that this barrel is safe; otherwise, we know\r\nit is poisonous. Take any two barrels with a difference of no more than\r\n: , add water to the -th barrel to equalize the weights, and also\r\ncompare the barrels by checking both.We have no other methods; if with\r\nthe current both of these methods are inapplicable, but there are more\r\nthan one unverified barrels left we lose.If we consider that the first\r\nmethod is applied \"automatically\" as long as possible, it means that at\r\nany moment we possess some prefix of barrels , since if we have checked\r\nbarrel , we can also check .Therefore, we need to determine whether it\r\nis true that if we have of free water, we can perform some action to\r\ncheck one of the barrels for all from to . If this holds, we can\r\niteratively determine everything; if not, at some point we will hit a\r\nwall and will not be able to determine anything about the barrels . The\r\nupper limit is , not , because if we check all barrels except one, the\r\nremaining unverified barrel will be deemed poisonous by the process of\r\nelimination.Letâ€™s say that is a special index if . Note that we can\r\ncheck the condition from the previous paragraph not for all , but only\r\nfor special , and this will be equivalent. Since from a non-special\r\nindex, we can always check barrel .However, there are also no more than\r\nspecial indices, since with each special index, the prefix sum of the\r\narray increases at least twofold.Therefore, our further plan for solving\r\nthe problem is as follows: after each query, we find all special indices\r\nand explicitly check each of them, finding on the suffix and comparing\r\nit with . We will learn to find and check a special index in and obtain\r\na solution in .We can use a to support \"unique\" weights of barrels and\r\nthe amount of available water at the very beginning.Then,\r\nadding/removing unique barrels can be implemented using a large segment\r\ntree of size .Thus, finding the next \"special\" index and checking it can\r\nbe implemented by descending/querying in this segment tree.\r\n",
    "name": "E. Tropical Season",
    "statement": "You have n barrels of infinite capacity. The i-th barrel initially\r\ncontains a_i kilograms of water. In this problem, we assume that all\r\nbarrels weigh the same.You know that one of the barrels has a small\r\namount of tropical poison distributed on its surface, with a total\r\nweight of 0.179 kilograms. However, you do not know which barrel\r\ncontains the poison. Your task is to identify this barrel.All the\r\nbarrels are on scales. Unfortunately, the scales do not show the exact\r\nweight of each barrel. Instead, for each pair of barrels, they show the\r\nresult of a comparison between the weights of those barrels. Thus, for\r\nany two barrels, you can determine whether their weights are equal, and\r\nif not, which barrel is heavier. The poison and water are included in\r\nthe weight of the barrel.The scales are always turned on, and the\r\ninformation from them can be used an unlimited number of times.You also\r\nhave the ability to pour water. You can pour water from any barrel into\r\nany other barrel in any amounts.However, to pour water, you must\r\nphysically handle the barrel from which you are pouring, so if that\r\nhappens to be the poisonous barrel, you will die. This outcome must be\r\navoided.However, you can pour water into the poisonous barrel without\r\ntouching it.In other words, you can choose the numbers i, j, x (i\r\nneq j, 1\r\nleq i, j\r\nleq n, 0 < x\r\nleq a_i, the barrel numbered i is poisonous) and execute a_i := a_i - x,\r\na_j := a_j + x. Where x is not necessarily an integer.Is it possible to\r\nguarantee the identification of which barrel contains the poison and\r\nremain alive using pouring and the information from the scales? You know\r\nthat the poison is located on one of the barrels.Additionally, we ask\r\nyou to process q queries. In each query, either one of the existing\r\nbarrels is removed, or an additional barrel with a certain amount of\r\nwater is added. After each query, you need to answer whether it is\r\npossible to guarantee the identification of the poisonous barrel, given\r\nthat there is exactly one.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Tropical Season.json",
    "hint": []
}