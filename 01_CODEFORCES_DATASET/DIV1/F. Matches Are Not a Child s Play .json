{
    "link": "https://codeforces.com//contest/1137/problem/F",
    "problemId": "309122",
    "problem_idx": "F",
    "shortId": "1137F",
    "contest_number": "1137",
    "problem_submissions": {
        "C": [
            51278692,
            51013174,
            51012138,
            51014594,
            51060015,
            51011758,
            51015377,
            51058095,
            51060423,
            51013462,
            51011929,
            51013820,
            51016620,
            51021729,
            51016142,
            51022376,
            51017039,
            51022733
        ],
        "D": [
            51022280,
            51016149,
            51021902,
            51016444,
            51017886,
            51022110,
            51022575,
            51017121,
            51017510,
            51026190,
            51017887,
            51020056,
            51071936,
            51020439,
            51057402,
            51015057,
            51021542,
            51016650
        ],
        "F": [
            51021456,
            51151872,
            51044265,
            208399382,
            208399328,
            51370362,
            51370305,
            56076657,
            51062431,
            51062375,
            51201422,
            51152102
        ],
        "E": [
            51015510,
            51019659,
            51017815,
            51022086,
            51024208,
            51025483,
            51015317,
            51021155,
            51026207,
            51019242,
            51116875,
            51022655,
            51043942,
            51019234,
            51021992,
            51040600
        ],
        "B": [
            51007898,
            51008699,
            51007790,
            51010637,
            51008661,
            51008854,
            51009928,
            51010030,
            51008543,
            51011271,
            51008351,
            51008938,
            51007902,
            51007130,
            51009176,
            51009835,
            51007086,
            51008751,
            51007248
        ],
        "A": [
            51006589,
            51007409,
            51005936,
            51007585,
            51007232,
            51007035,
            51007494,
            51006878,
            51006201,
            51013385,
            51006659,
            51007366,
            51005796,
            51010835,
            51007279,
            51007757,
            51009144,
            51007439,
            51005946
        ]
    },
    "name": "F. Matches Are Not a Child s Play ",
    "statement": "Lena is playing with matches. The natural question arising in the head\r\nof any child playing with matches is whether it\u2019s possible to set a tree\r\non fire with a matches, or not.Let\u2019s say, that the tree is a connected\r\ngraph without cycles and the vertices are labeled with integers 1, 2,\r\nldots, n. Also every vertex v has some integer priority p_v associated\r\nwith it. All priorities are distinct.It turns out, that if you set a\r\ntree on fire, it will burn to nothing. However, this process doesn\u2019t\r\nhappen instantly. At the beginning, burns out the leaf (a vertex is\r\ncalled to be a if it has only one adjacent vertex) of the tree of the\r\nminimum priority. Then burns out the leaf of the minimal priority of the\r\nremaining tree, and so on. This way, the vertices turn into the leaves\r\nand burn out until only one vertex remains. Then this vertex burns out\r\nas well.Lena has prepared a tree of n vertices and every vertex in it\r\nhas a priority p_v = v. Lena is very curious about burning out this\r\ntree. However, she understands, that if she will burn the tree now, then\r\nit will disappear completely. Lena is a kind girl and she will feel bad\r\nfor the burned tree, so she wants to study the process of burning the\r\ntree only in her mind. Lena wants to process q queries, each of them is\r\none of three following types: \" v\", assign the vertex v priority 1 +\r\nmax\r\n{p_1, p_2,\r\nldots, p_n\r\n}; \" v\", find the step at which the vertex v will burn out, if the tree\r\nwould be set on fire now; \" v u\", find out which of the vertices v and u\r\nwill burn out first, if the tree would be set on fire now. Notice, that\r\nif all priorities would be distinct, then after the \"\" query they will\r\nstay distinct as well. Initially all priorities are distinct, hence\r\nduring any (purely hypothetical of course) burning of the tree, all\r\nleafs would have distinct priorities.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  void init(int v) {\n    fenw.resize(n = v);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= x + 1;\n    }\n  }\n\n  T query(int x) {\n    T res{};\n    while (x >= 0) {\n      res += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return res;\n  }\n};\n\nconst int N = 234567;\n\nint n, q, f[N], sz[N], tag[N], last[N], c[N][2];\nfenwick<int> fenw;\nvector<int> adj[N];\nbool rev[N];\n\nbool is_root(int x) {\n  return c[f[x]][0] != x && c[f[x]][1] != x;\n}\n\nvoid pull(int x) {\n  sz[x] = sz[c[x][0]] + sz[c[x][1]] + 1;\n}\n\nvoid rotate(int x) {\n  int y = f[x], z = f[y], k = c[y][1] == x;\n  if (!is_root(y)) {\n    c[z][c[z][1] == y] = x;\n  }\n  f[c[y][k] = c[x][!k]] = y;\n  f[f[c[x][!k] = y] = x] = z;\n  pull(y);\n  pull(x);\n}\n\nvoid push(int x) {\n  if (rev[x]) {\n    swap(c[x][0], c[x][1]);\n    rev[c[x][0]] ^= 1;\n    rev[c[x][1]] ^= 1;\n    rev[x] = false;\n  }\n  if (tag[x]) {\n    tag[c[x][0]] = last[c[x][0]] = tag[x];\n    tag[c[x][1]] = last[c[x][1]] = tag[x];\n    tag[x] = 0;\n  }\n}\n\nvoid splay(int x) {\n  static int st[N];\n  int top = 0;\n  st[++top] = x;\n  for (int i = x; !is_root(i); i = f[i]) {\n    st[++top] = f[i];\n  }\n  while (top) {\n    push(st[top--]);\n  }\n  for (int y = f[x], z = f[y]; !is_root(x); rotate(x), y = f[x], z = f[y]) {\n    if (!is_root(y)) {\n      rotate((c[y][1] == x) == (c[z][1] == y) ? y : x);\n    }\n  }\n}\n\nvoid access(int x, int tt) {\n  for (int t = 0; x; t = x, x = f[x]) {\n    splay(x);\n    c[x][1] = 0;\n    pull(x);\n    fenw.modify(last[x], -sz[x]);\n    last[x] = tag[x] = tt;\n    fenw.modify(last[x], sz[x]);\n    c[x][1] = t;\n    pull(x);\n  }\n}\n\nvoid dfs(int x) {\n  last[x] = x;\n  for (auto y : adj[x]) {\n    if (y != f[x]) {\n      f[y] = x;\n      dfs(y);\n      last[x] = max(last[x], last[y]);\n    }\n  }\n  for (auto y : adj[x]) {\n    if (y != f[x] && last[x] == last[y]) {\n      c[x][1] = y;\n      sz[x] = sz[y] + 1;\n    }\n  }\n  fenw.modify(last[x], 1);\n}\n\nint query(int x) {\n  splay(x);\n  push(x);\n  return fenw.query(last[x]) - sz[c[x][0]];\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> q;\n  fenw.init(n + q + 1);\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  for (int i = 1; i <= n; ++i) {\n    sz[i] = 1;\n  }\n  dfs(n);\n  int time = n;\n  while (q--) {\n    string type;\n    cin >> type;\n    if (type == \"up\") {\n      int x;\n      cin >> x;\n      access(x, time);\n      splay(x);\n      rev[x] ^= 1;\n      push(x);\n      fenw.modify(last[x], -1);\n      c[x][1] = 0;\n      tag[x] = last[x] = ++time;\n      sz[x] = 1;\n      fenw.modify(last[x], 1);\n    } else if (type == \"when\") {\n      int x;\n      cin >> x;\n      cout << query(x) << \"\\n\";\n    } else {\n      int x, y;\n      cin >> x >> y;\n      cout << (query(x) < query(y) ? x : y) << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Matches Are Not a Child s Play .json",
    "editorial_link": "https://codeforces.com/blog/entry/65825",
    "editorial": "First, let\u00e2\u0080\u0099s notice, that operation \"compare\" is redundant and can be\r\nimplemented as two \"when\" operations (we didn\u00e2\u0080\u0099t removed it from onsite\r\nolympiad\u00e2\u0080\u0099s version as a possible hint).Suppose we know the order of the\r\nburning vertices. How it will change after \"up\" operation? Actually,\r\nquite simply: let\u00e2\u0080\u0099s notice, that the part from previous maximum to the\r\nnew one will burn the last. Actually, everything except this path burns\r\nout in the same relative order as before, and then burns the path, in\r\norder from older maximum to the new one.Let\u00e2\u0080\u0099s say, that \"up\" paints it\u00e2\u0080\u0099s\r\npath in the color i (and i++). Then to calculate when[v], let\u00e2\u0080\u0099s first\r\nget the color of vertex v. And then when[v] equals to the number of\r\nvertices of smaller colors plus the number of vertices of the same\r\ncolor, but which will burn before this one. The latter is simply the\r\nnumber of vertices on the path from older maximum to the new one in the\r\ncorresponding up query. To implement coloring on the path, we can use\r\nHeavy-Light-Decomposition. Inside every path of HLD let\u00e2\u0080\u0099s store a set of\r\nsegments of vertices of the same color. Then operation to color some\r\npath works in , amortized. The number of vertices with smaller color can\r\nbe calculated with a fenwick tree (which stores for color the number of\r\nsuch vertices).There are also small technical details to handle: you\r\nneed to account the original order of burning out, before all up\u00e2\u0080\u0099s. But\r\nsince each vertex changes it\u00e2\u0080\u0099s color from zero to nonzero at most once,\r\nyou can do it in O(number such vertices).\r\n"
}