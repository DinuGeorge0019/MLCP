{
    "link": "https://codeforces.com//contest/1229/problem/B",
    "problemId": "419076",
    "problem_idx": "B",
    "shortId": "1229B",
    "contest_number": "1229",
    "problem_submissions": {
        "E2": [
            66535857,
            61153989,
            61162985,
            61167725,
            61164541,
            61175914,
            73169874,
            73169292,
            67251679,
            61176348,
            61171644,
            61168314,
            61282274
        ],
        "C": [
            61156990,
            61139280,
            61133462,
            61168973,
            61144252,
            61152507,
            61152114,
            61139574,
            61138824,
            61139511,
            61146010,
            61154268,
            61140423,
            61146503,
            61146999,
            61163280,
            61145517,
            61140699
        ],
        "E1": [
            61153988,
            61160360,
            61157052,
            61164602,
            61165567,
            61168930,
            61169365,
            61171555,
            61161774,
            61282244,
            91100857
        ],
        "D": [
            61143107,
            61152425,
            61148639,
            61156853,
            61153552,
            61162885,
            61162936,
            61151975,
            61157442,
            61157392,
            61156341,
            61210834,
            61160744,
            61159221,
            61160510,
            61155666,
            61165039,
            61163062
        ],
        "B": [
            61128405,
            61132933,
            61165615,
            61142364,
            61131741,
            61140527,
            61129638,
            61133794,
            61131083,
            61134616,
            61139186,
            61132543,
            61141781,
            61139438,
            61135873,
            61137164,
            61151652
        ],
        "A": [
            61122880,
            61126193,
            61123596,
            61131920,
            61125660,
            61128699,
            61125244,
            61171108,
            61124176,
            61136192,
            61128585,
            61129134,
            61124511,
            61133577,
            61132336,
            61124059,
            61130617,
            61131139
        ],
        "F": [
            61198842,
            61176125,
            61453900,
            61180269,
            61179508,
            61398042
        ]
    },
    "name": "B. Kamil and Making a Stream",
    "statement": "Kamil likes streaming the competitive programming videos. His MeTube\r\nchannel has recently reached 100 million subscribers. In order to\r\ncelebrate this, he posted a video with an interesting problem he\r\ncouldn\u2019t solve yet. Can you help him?You\u2019re given a tree a connected\r\nundirected graph consisting of n vertices connected by n - 1 edges. The\r\ntree is rooted at vertex 1. A vertex u is called an of v if it lies on\r\nthe shortest path between the root and v. In particular, a vertex is an\r\nancestor of itself.Each vertex v is assigned its x_v a non-negative\r\ninteger not larger than 10^{12}. This allows us to define the beauty of\r\na path. Let u be an ancestor of v. Then we define the beauty f(u, v) as\r\nthe greatest common divisor of the beauties of all vertices on the\r\nshortest path between u and v. Formally, if u=t_1, t_2, t_3,\r\ndots, t_k=v are the vertices on the shortest path between u and v, then\r\nf(u, v) =\r\ngcd(x_{t_1}, x_{t_2},\r\ndots, x_{t_k}). Here,\r\ngcd denotes the greatest common divisor of a set of numbers. In\r\nparticular, f(u, u) =\r\ngcd(x_u) = x_u.Your task is to find the sum\r\nsum_{u\r\ntext{ is an ancestor of }v} f(u, v). As the result might be too large,\r\nplease output it modulo 10^9 + 7.Note that for each y,\r\ngcd(0, y) =\r\ngcd(y, 0) = y. In particular,\r\ngcd(0, 0) = 0.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nconst int N = 100100;\nvector<int> g[N];\nvector<pli> a[N];\nint n;\nll x[N];\n\nvoid dfs(int v, int par) {\n\tif (par != -1) {\n\t\tfor (pli t : a[par]) {\n\t\t\tll y = gcd(t.first, x[v]);\n\t\t\tif (a[v].empty() || a[v].back().first != y) {\n\t\t\t\ta[v].push_back(mp(y, t.second));\n\t\t\t} else {\n\t\t\t\ta[v].back().second += t.second;\n\t\t\t}\n\t\t}\n\t}\n\tif (a[v].empty() || a[v].back().first != x[v]) {\n\t\ta[v].push_back(mp(x[v], 1));\n\t} else {\n\t\ta[v].back().second++;\n\t}\n\tfor (int u : g[v]) {\n\t\tif (u == par) continue;\n\t\tdfs(u, v);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &x[i]);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0, -1);\n\tll ans = 0;\n\tfor (int v = 0; v < n; v++)\n\t\tfor (pli t : a[v]) {\n\t\t\tans = (ans + t.first * t.second) % MOD;\n\t\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "dp",
        "graphs",
        "math",
        "number theory",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Kamil and Making a Stream.json",
    "editorial_link": "https://codeforces.com//blog/entry/70008",
    "editorial": "Let\u00e2\u0080\u0099s prove the following observation:To prove this observation,\r\nconsider the ancestors of in the order from the bottom-most to top-most:\r\n. Notice that . Therefore, each consecutive adds another value to the\r\ngcd of all numbers. If a gcd of all numbers changes, it must be a\r\ndivisor of the previous gcd. Therefore, it\u00e2\u0080\u0099s easy to see that it can\r\nchange at most times.We can now implement a depth-first search. If we\r\ninvoke a recursive call in vertex , we will receive the multiset of\r\nvalues . We add all these values to the result and run the recursive\r\ncalls in the children.This is currently or , but we can improve it by\r\nactually using a map from the distinct values in the multiset to the\r\nnumber of their occurrences. Then each map will have no more than\r\nelements. As we need to compute \u00e2\u0080\u0099s throughout the algorithm, this\r\nsolution allows us to solve the problem in time and in memory.It\u00e2\u0080\u0099s also\r\npossible to solve the problem using jump-pointers. Each jump-pointer\r\nwill additionally hold the greatest common divisor of all the numbers we\r\njump over when following the pointer.\r\n"
}