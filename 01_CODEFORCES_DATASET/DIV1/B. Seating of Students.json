{
    "link": "https://codeforces.com//contest/906/problem/B",
    "problemId": "140845",
    "problem_idx": "B",
    "shortId": "906B",
    "contest_number": "906",
    "problem_submissions": {
        "D": [
            149029866,
            33557818,
            33559276,
            33563941,
            33561236,
            33558964,
            33560338,
            33552737,
            33564592,
            33555169,
            33563596,
            33557368,
            33574046,
            33570274,
            33569097,
            33952208,
            33561210,
            33554741,
            33558804,
            33566104,
            33558203,
            33550675
        ],
        "E": [
            33563788,
            51774603,
            33570251,
            42678760,
            33642683,
            33642639,
            57252155,
            33595209
        ],
        "A": [
            33559632,
            33542429,
            33541419,
            33540284,
            33543709,
            33540394,
            33541815,
            33539940,
            33541391,
            33544813,
            33540734,
            33541098,
            33542736,
            33541277,
            33565456,
            33540685,
            33540110,
            33569386
        ],
        "C": [
            33554104,
            33555026,
            33556927,
            33558399,
            33566145,
            33563804,
            33559596,
            33558825,
            33566746,
            33569757,
            33570264,
            33560203,
            33561015,
            33582668,
            33568743,
            33550511,
            33571601,
            33568875,
            33565260
        ],
        "B": [
            33543854,
            33551699,
            33549379,
            33555394,
            33548541,
            33552331,
            33565116,
            33549927,
            33571875,
            33555675,
            33564877,
            33554448,
            33562774,
            33555252,
            33583579,
            33583372,
            33554912,
            33572090
        ]
    },
    "name": "B. Seating of Students",
    "statement": "Students went into a class to write a test and sat in some way. The\r\nteacher thought: \"Probably they sat in this order to copy works of each\r\nother. I need to rearrange them in such a way that students that were\r\nneighbors are not neighbors in a new seating.\"The class can be\r\nrepresented as a matrix with rows and columns with a student in each\r\ncell. Two students are neighbors if cells in which they sit have a\r\ncommon side.Let’s enumerate students from to in order of rows. So a\r\nstudent who initially sits in the cell in row and column has a number .\r\nYou have to find a matrix with rows and columns in which all numbers\r\nfrom to appear exactly once and adjacent numbers in the original matrix\r\nare not adjacent in it, or determine that there is no such matrix.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,m,p[N],px[N],py[N],q[N];\n\nbool adj(int u,int v) {\n\tif (u>v) swap(u,v);\n\tif (px[u]==px[v]&&py[u]+1==py[v]) return 1;\n\tif (py[u]==py[v]&&px[u]+1==px[v]) return 1;\n\treturn 0;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,n*m) px[i]=i/m,py[i]=i%m;\n\twhile (clock()<=1.9*CLOCKS_PER_SEC) {\n\t\trep(i,0,n*m) p[i]=i;\n\t\trandom_shuffle(p,p+n*m);\n\t\tset<PII> hs;\n\t\trep(i,0,n*m) hs.insert(mp(p[i],i));\n\t\tbool val=1;\n\t\trep(i,0,n*m) {\n\t\t\tint x=i/m,y=i%m;\n\t\t\tauto it=hs.begin();\n\t\t\tbool suc=0;\n\t\t\twhile (1) {\n\t\t\t\tsuc=1;\n\t\t\t\tq[i]=it->se;\n\t\t\t\tif (y&&adj(q[i],q[i-1])) { suc=0; }\n\t\t\t\tif (x&&adj(q[i],q[i-m])) { suc=0; }\n\t\t\t\tif (suc) { hs.erase(it); break; }\n\t\t\t\tit++;\n\t\t\t\tif (it==hs.end()) break;\n\t\t\t}\n\t\t\tif (suc==0) { val=0; break; }\n\t\t}\n\t\tif (val) {\n\t\t\tputs(\"YES\");\n\t\t\trep(i,0,n*m) {\n\t\t\t\tprintf(\"%d \",q[i]+1);\n\t\t\t\tif (i%m==m-1) puts(\"\");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"NO\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Seating of Students.json",
    "editorial_link": "https://codeforces.com//blog/entry/56601",
    "editorial": "The problem has many solutions, including random ones. Consider one of\r\ndeterministic solutions. Without loss of generality, assume that .There\r\nare a couple of corner cases: . In this case, good seating exists. . In\r\nthis case, seating does not exist (obviously). . In any seating, one of\r\nneighbours of student 2 will be one of his former neighbours, so correct\r\nseating does not exist. . Only student 4 can be a neighbour of student\r\n1, but there should be 2 neighbours for student 1; then, correct seating\r\ndoes not exist. . Both students 5 and 2 have 3 neighbours in the initial\r\nseating; then, in new seating, these students should be in\r\nnon-neighbouring corner cells. Moreover, these corner cells can not be\r\nin one row because in this case itâs impossible to find a student for\r\ncell between 2 and 5. So, without loss of generality, let 5 be in lower\r\nleft corner, and 2 in upper right corner. Then, only students 1 and 3\r\ncan seat on lower middle cell; but if sduent 1 seats in the cell, then\r\nstudent 4 is impossible to seat at any of the remaining cells, so do\r\nstudent 6 in case of student 3 seating at the cell. So, correct seating\r\ndoes not exist in this case too. . In this case, one of correct seatings\r\nis . . In this case, let students with odd numbers in increasing order\r\nwill be in first half of the row, and others in increasing order - in\r\nsecond half. For example, for the seating will be . . One of possible\r\ncorrect seatings is:; If , then shift each even row cyclically on two\r\nsymbols in the right, and then shift each even column cyclically on one\r\nsymbol upwards. If students are vertical neighbours in the initial\r\nseating, then in new seating, they will be in different columns on the\r\ndistance 2 (possibly through the edge of the table); but if students are\r\nhorizontal neighbours in the initial seating, then in new seating they\r\nwill be in neighbouring rows and neighbouring columns (possibly thorugh\r\nthe edges again). So, for case , we build a correct seating.\r\n",
    "hint": []
}