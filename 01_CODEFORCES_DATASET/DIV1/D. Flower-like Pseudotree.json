{
    "link": "https://codeforces.com//contest/1868/problem/D",
    "problemId": "2185409",
    "problem_idx": "D",
    "shortId": "1868D",
    "contest_number": "1868",
    "problem_submissions": {
        "E": [
            223228586,
            222815728,
            231588269
        ],
        "D": [
            223110671,
            222776638,
            222777162,
            222782980,
            222782523,
            223072795,
            222790549,
            222790677,
            222793420,
            222800103,
            222795470,
            222793980,
            222802561,
            222799384,
            222797784,
            222800727,
            222795823,
            222801192,
            223669050,
            222801040,
            222802199
        ],
        "F": [
            223085466,
            222790947,
            247646963,
            222898179
        ],
        "C": [
            222763067,
            222759154,
            222746616,
            222760340,
            222756156,
            222763622,
            222756124,
            222762393,
            222751686,
            222776556,
            222772834,
            222764583,
            222781677,
            222774228,
            222779099,
            222765233,
            222774182,
            222776098,
            222768907
        ],
        "B2": [
            222745832,
            222748527,
            222758458,
            222744648,
            222743313,
            223073100,
            222746136,
            222743413,
            222746166,
            222738003,
            222740242,
            222749443,
            222748125,
            222749951,
            222757155,
            222748050,
            222749211,
            222753148,
            222756646,
            222747692
        ],
        "B1": [
            222740122,
            222740465,
            222751668,
            222737311,
            222738981,
            222739684,
            222744732,
            222739960,
            222731387,
            222735455,
            222736795,
            222740857,
            222744073,
            222747258,
            222741914,
            222742503,
            222742541,
            222746683,
            222738741
        ],
        "A": [
            222734071,
            222731429,
            222729599,
            222732029,
            222733115,
            222733400,
            222731753,
            222727215,
            222726334,
            222729722,
            222729267,
            222729343,
            222736621,
            222732161,
            222735584,
            222730265,
            222732117,
            222730488,
            222728959
        ]
    },
    "name": "D. Flower-like Pseudotree",
    "statement": "A is a connected graph which has cycle and self-loops. Note that a\r\npseudotree . It can be shown that a pseudotree with n vertices always\r\ncontains n edges.After deleting all edges on the cycle in the\r\npseudotree, a forest^{\r\ndagger} will be formed. It can be shown that each tree in the forest\r\nwill contain exactly one vertex which is on cycle before removing the\r\nedges. If all trees in the forest have the same depth^{\r\nddagger} when picking the vertex on cycle as root, we call the original\r\npseudotree .Our friend sszcdjr, had a flower-like pseudotree with n\r\nvertices and n edges. However, he forgot all the edges in the\r\npseudotree. Fortunately, he still remembers the degrees of vertices.\r\nSpecifically, the degree of the i-th vertex is d_i.You have to help\r\nsszcdjr construct a possible flower-like pseudotree with n vertices,\r\nwhere the degree of the i-th vertex is d_i, or tell him that it is\r\nimpossible.^{\r\ndagger} A forest is a graph in which all connectivity components are\r\ntrees. A connected graph without cycles and self-loops is called a\r\ntree.^{\r\nddagger} The depth of a tree with a root is the maximum distance from\r\nthe root to the vertex of this tree.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT ã§æ°åãç®¡çããã¨ãã«ä½¿ã (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify ãã¦ãªãã\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ã½ã¼ããã¦ i çªç®ã idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//ä¾ãã° sortidx ã§å¾ã idx ãä½¿ãã°åã«ã½ã¼ãåã«ãªã£ã¦è¿ã£ã¦ãã\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS revv(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t>\nvoid pb(vc<t>&a,const vc<t>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t>\nvc<t> cat(vc<t> a,const vc<t>&b){\n\tpb(a,b);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;\n\tif(dbg){\n\t\tn=10;\n\t}else{\n\t\tcin>>n;\n\t}\n\tvi d;\n\tif(dbg){\n\t\td=vi(n,1);\n\t\trep(_,n){\n\t\t\td[rand_int(n)]++;\n\t\t}\n\t}else{\n\t\td=readvi(n);\n\t}\n\tif(SUM(d)!=2*n||MAX(d)>n)return No(0);\n\tvi idx=sortidx(d);\n\tif(count(all(d),2)==n){\n\t\tYes(0);\n\t\trep(i,n){\n\t\t\tprint(i+1,(i+1)%n+1);\n\t\t}\n\t}else{\n\t\tint leaves=count(all(d),1);\n\t\tint head=0;\n\t\tvi q;\n\t\trep(i,leaves)q.pb(0);\n\t\trng(cut,leaves,n-1){\n\t\t\tint inner=cut-leaves;\n\t\t\tint len=inner/(n-cut);\n\t\t\tif(d[idx[cut]]>=3&&q.back()<=len){\n\t\t\t\t//dmp(cut);\n\t\t\t\tvc<pi> ans;\n\t\t\t\tauto ae=[&](int i,int j){\n\t\t\t\t\t//dmp2(i,j);\n\t\t\t\t\tassert(d[i]>0);\n\t\t\t\t\tassert(d[j]>0);\n\t\t\t\t\tans.eb(i,j);\n\t\t\t\t\td[i]--;\n\t\t\t\t\td[j]--;\n\t\t\t\t};\n\t\t\t\trng(i,cut,n){\n\t\t\t\t\tint j=i+1;\n\t\t\t\t\tif(j==n)j=cut;\n\t\t\t\t\tae(idx[i],idx[j]);\n\t\t\t\t}\n\t\t\t\tint s=0;\n\t\t\t\thead=0;\n\t\t\t\tvi root(n,-1),dep(n,-1),tail(n,-1),mx(n,-1),avail;\n\t\t\t\trng(i,cut,n){\n\t\t\t\t\tint v=idx[i];\n\t\t\t\t\troot[v]=v;\n\t\t\t\t\tdep[v]=0;\n\t\t\t\t\ttail[v]=v;\n\t\t\t\t\tmx[v]=0;\n\t\t\t\t\trep(_,d[v])avail.eb(v);\n\t\t\t\t}\n\t\t\t\tgnr(i,leaves,cut+1){\n\t\t\t\t\tif(s+(i-leaves)==len*(n-cut)){\n\t\t\t\t\t\t//dmp(i);\n\t\t\t\t\t\t//dmp(d);\n\t\t\t\t\t\t//dmp(mx);\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint k=i;\n\t\t\t\t\t\t\trng(j,cut,n){\n\t\t\t\t\t\t\t\tint v=idx[j];\n\t\t\t\t\t\t\t\tint tar=len-mx[v];\n\t\t\t\t\t\t\t\tv=tail[v];\n\t\t\t\t\t\t\t\trep(_,tar){\n\t\t\t\t\t\t\t\t\tassert(d[v]>=1);\n\t\t\t\t\t\t\t\t\tint u=idx[--k];\n\t\t\t\t\t\t\t\t\tae(u,v);\n\t\t\t\t\t\t\t\t\tv=u;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tavail.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\trng(j,leaves,n){\n\t\t\t\t\t\t\tint v=idx[j];\n\t\t\t\t\t\t\trep(_,d[v])avail.pb(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(j,leaves){\n\t\t\t\t\t\t\tint v=idx[j];\n\t\t\t\t\t\t\tassert(si(avail));\n\t\t\t\t\t\t\tae(v,gpp(avail));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(avail.empty());\n\t\t\t\t\t\tassert(si(ans)==n);\n\t\t\t\t\t\tYes(0);\n\t\t\t\t\t\tfor(auto [a,b]:ans){\n\t\t\t\t\t\t\tprint(a+1,b+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tassert(i>leaves);\n\t\t\t\t\tint v=idx[i-1];\n\t\t\t\t\tint u=avail[head++];\n\t\t\t\t\tae(u,v);\n\t\t\t\t\troot[v]=root[u];\n\t\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\t\ttail[root[v]]=v;\n\t\t\t\t\tassert(inc(0,dep[v]-mx[root[v]],1));\n\t\t\t\t\tif(chmax(mx[root[v]],dep[v])){\n\t\t\t\t\t\ts++;\n\t\t\t\t\t}\n\t\t\t\t\trep(_,d[v])avail.pb(v);\n\t\t\t\t}\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tint v=d[idx[cut]]-1;\n\t\t\thead+=v;\n\t\t\tassert(head<=si(q));\n\t\t\tq.pb(q[head-1]+1);\n\t\t}\n\t\tNo(0);\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Flower-like Pseudotree.json",
    "editorial_link": "https://codeforces.com//blog/entry/116642",
    "editorial": "If , itâs obviously impossible to construct a flower-like psuedotree. So\r\nletâs just consider the situation when .Sort from largest to smallest.\r\nIf , we can simply construct a cycle. Otherwise , in which case there\r\nmust be at least two and the vertices on the cycle must satisfy . The\r\nfollowing pictures donât show vertices with and the edges with weight\r\nare two multi-edges.Let be the number of vertices with .If is even, we\r\ncan make a cycle using and , with two chains of equal length hanging\r\nfrom and . If is odd and , itâs easy to see that we can hang two\r\nvertices below to transform it to the situation where is even. However,\r\nwe need at least vertices to make the psuedotree flower-like, which\r\nmeans that must be satisfied. (In the picture, at least vertices are\r\nneeded.) If is odd, and , itâs impossible for us to simply build a cycle\r\nlength . Thus, we can try to put in one cycle and the condition is .If\r\nis odd and , itâs impossible for us to do the operation above, because\r\nwe canât hang two vertices under . Itâs easy to see that we canât\r\nbalance the two trees if . For , we can hang under , under and under to\r\nmake the psuedotree flower-like. However, we need at least vertices to\r\nmake it balanced, which means must be satisfied. If is odd, and , there\r\nare three cases: : It can be proven that there isnât such a psuedotree.\r\n: It can be proven that there isnât such a psuedotree. : We can simply\r\nbuild a cycle of length . If is odd, and , thereâs only one case: : We\r\ncan simply build a cycle of length . The total complexity depends on the\r\nsorting part, which is if you use or , and if you use bucket sorting.\r\n",
    "hint": [
        "Hint 1 In fact, vertices with degree are useless, let's first ignore them. It's easy to see that when , we can simply hang them under the vertices which haven't reached their degree limit.",
        "Hint 2 In most cases, we can simply put two vertices on the cycle.",
        "Hint 3 Sort from the largest to the smallest. Can we construct a flower-like psuedotree when ? Can we construct a flower-like psuedotree when and ?",
        "Hint 4 Can you find an easy way to construct the flower-like psuedotree when the number of is even?",
        "Hint 5 Try to extend the solution when the number of is even to the odd case. Note some corner cases."
    ]
}