{"link": "https://codeforces.com//contest/1218/problem/D", "problemId": "412336", "problem_idx": "D", "shortId": "1218D", "contest_number": "1218", "problem_submissions": {"D": [60648151, 60643203, 60647260, 60645392, 60642748], "H": [60644806, 60638524], "E": [60642127, 60641056, 60641513, 60643564, 60648498], "I": [60640334, 60639607, 60640474, 60637390, 60638678], "F": [60638215, 60637531, 60635942, 60636552, 60636479], "C": [60637983, 60674902, 60648025], "B": [60648802], "A": [60645770]}, "name": "D. Xor Spanning Tree", "statement": "In the galaxy far far away is the ancient interplanetary republic of\r\nBubbleland, consisting of N planets. Between them, there are M\r\nbidirectional wormholes, each connecting a pair of planets. Bubbleland\r\nis a very centralized republic, having a capital planet Whiteplanet,\r\nfrom which any another planet can be reached using these wormholes. It\r\nis also guaranteed that no wormhole connects planet to itself and that\r\nno two different wormholes connect same pair of planets. We call a path\r\nthat begins at one planet, visits other planets and each of them at most\r\nonce and returns to starting point a . Interplanetary Safety Regulations\r\nguarantee that each planet belongs to at most one and that there are at\r\nmost 42 .After many eons of usage, wormholes need to be repaired and\r\neach wormhole has the cost W_{i} which needs to be payed for reparation.\r\nUnfortunately, the Senate of Bubbleland is short on budget. Therefore,\r\nthey have decided only to fix as many wormholes as they need in order to\r\nhave all planets reachable from capital and to pay as little money as\r\nthey have to for this repair. However the way in which the Senate\r\ncalculates the cost is different. Cost of the set of reparations is\r\nbinary xor of costs of each individual reparation, that is if\r\nreparations to be made have costs A_{1},A_{2},...,A_{k}, the cost of\r\nentire set is A_{1}\r\noplus A_{2}\r\noplus ...\r\noplus A_{k}.Now the Senate would like to know how much money do they\r\nhave to pay and also the number of different ways to achieve that cost .\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n#define x first\n#define y second\n\nconst int N = 100005, SZ = 131072, L = 17;\nll M = ll(1e9) + 7, MM = 998244353, ISZ = 742744451, ISZZ = 998236737;\n\nint Rev(int x) {\n    int i, r = 0;\n    for (i = 0; i < L; i++) {\n        r = r << 1 | x & 1;\n        x >>= 1;\n    }\n    return r;\n}\n \nvoid FFT(ll *a, bool f, ll M, ll ISZ) {\n    int i, j, k, z;\n    for (i = 0; i < SZ; i++) {\n        j = Rev(i);\n        if (i < j) {\n            z = a[i];\n            a[i] = a[j];\n            a[j] = z;\n        }\n    }\n    for (i = 1; i < SZ; i <<= 1) for (j = 0; j < SZ; j += i << 1) for (k = 0; k < i; k++) {\n        z = a[i + j + k];\n        a[i + j + k] = (a[j + k] - z + M) % M;\n        (a[j + k] += z) %= M;\n    }\n    if (f) for (i = 0; i < SZ; i++) a[i] = a[i] * ISZ % M;\n}\n\nint n, m, p[N], tt;\nvector<pii> e[N];\nll a[SZ], b[SZ], aa[SZ], bb[SZ];\n\nint f(int x){\n    if(x == p[x]) return x;\n    return p[x] = f(p[x]);\n}\n\nint g(int x, int y, int z){\n    if(x == z) return 1;\n    for(pii &i : e[x]){\n        if(i.x == y) continue;\n        if(!g(i.x, x, z)) continue;\n        b[i.y]++;\n        return 1;\n    }\n    return 0;\n}\n\nvoid h(){\n    memcpy(bb, b, sizeof(b));\n    FFT(b, 0, M, ISZ);\n    FFT(bb, 0, MM, ISZZ);\n    for(int i = 0; i < SZ; i++) (a[i] *= b[i]) %= M;\n    for(int i = 0; i < SZ; i++) (aa[i] *= bb[i]) %= MM;\n}\n\nint main(){ ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    iota(p, p+n+1, 0);\n    a[0] = aa[0] = 1;\n    FFT(a, 0, M, ISZ);\n    FFT(aa, 0, MM, ISZZ);\n    for(int x, y, z; m--; ){\n        cin >> x >> y >> z;\n        tt ^= z;\n        if(f(x) != f(y)){\n            p[f(y)] = f(x);\n            e[x].emplace_back(y, z);\n            e[y].emplace_back(x, z);\n        }\n        else{\n            memset(b, 0, sizeof(b));\n            b[z]++;\n            g(x, 0, y);\n            h();\n        }\n    }\n    memset(b, 0, sizeof(b));\n    b[tt] = 1;\n    h();\n    FFT(a, 1, M, ISZ);\n    FFT(aa, 1, MM, ISZZ);\n    for(int i = 0; ; i++) if(a[i] || aa[i]){\n        cout << i << ' ' << a[i] << '\\n';\n        return 0;\n    }\n}"], "input": "", "output": "", "tags": ["divide and conquer", "fft", "graphs"], "dificulty": "2400", "interactive": false}