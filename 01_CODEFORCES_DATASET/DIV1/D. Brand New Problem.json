{
    "link": "https://codeforces.com//contest/201/problem/D",
    "problemId": "1458",
    "problem_idx": "D",
    "shortId": "201D",
    "contest_number": "201",
    "problem_submissions": {
        "D": [
            1842426,
            1845322,
            1848015,
            2017065,
            1845704,
            1843679,
            1843165,
            1843645,
            1843721,
            1842642,
            3962764,
            1843892
        ],
        "E": [
            1841059,
            1842295,
            1842570,
            1848002,
            1842412,
            1843333,
            1841361,
            1842083,
            1843064,
            1842151,
            1843347
        ],
        "A": [
            1840364,
            1839374,
            1839153,
            1847954,
            1840731,
            1839399,
            1844333,
            1839094,
            1839993,
            1841295,
            1840073,
            1839956,
            1838952,
            1839521,
            1838849,
            1839719,
            1839105,
            1839524
        ],
        "C": [
            1840066,
            1840781,
            1840491,
            1847992,
            1840261,
            1840947,
            1839278,
            1840815,
            1841258,
            1842024,
            1841894,
            1844043,
            1841094,
            1844134,
            1840094,
            1867350,
            1840802,
            1840979
        ],
        "B": [
            1839596,
            1838940,
            1839961,
            1847965,
            1841485,
            1840001,
            1840567,
            1839860,
            1841578,
            1839437,
            1840889,
            1840454,
            1839972,
            1839833,
            1841387,
            1839459,
            1840240,
            1840100,
            1840475
        ]
    },
    "name": "D. Brand New Problem",
    "statement": "A widely known among some people Belarusian sport programmer Lesha\r\ndecided to make some money to buy a one square meter larger flat. To do\r\nthis, he wants to make and carry out a Super Rated Match (SRM) on the\r\nsite Torcoder.com. But there’s a problem a severe torcoder coordinator\r\nIvan does not accept any Lesha’s problem, calling each of them an\r\noffensive word \"duped\" (that is, duplicated). And one day they nearely\r\nquarrelled over yet another problem Ivan wouldn’t accept.You are invited\r\nto act as a fair judge and determine whether the problem is indeed , or\r\nIvan is right and the problem bears some resemblance to those used in\r\nthe previous SRMs.You are given the descriptions of Lesha’s problem and\r\neach of Torcoder.com archive problems. The description of each problem\r\nis a sequence of words. Besides, it is guaranteed that Lesha’s problem\r\nhas no repeated words, while the description of an archive problem may\r\ncontain any number of repeated words.The \"similarity\" between Lesha’s\r\nproblem and some archive problem can be found as follows. Among all\r\npermutations of words in Lesha’s problem we choose the one that occurs\r\nin the archive problem as a subsequence. If there are multiple such\r\npermutations, we choose the one with the smallest number of inversions.\r\nThen the \"similarity\" of a problem can be written as , where is the\r\nnumber of words in Lesha’s problem and is the number of inversions in\r\nthe chosen permutation. Note that the \"similarity\" is always a positive\r\ninteger.The problem is called if there is not a single problem in Ivan’s\r\narchive which contains a permutation of words from Lesha’s problem as a\r\nsubsequence.Help the boys and determine whether the proposed problem is\r\nnew, or specify the problem from the archive which resembles Lesha’s\r\nproblem the most, otherwise.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint Q;\nint similarity[20];\n\nint A,B;\nstring a[20],b[500010];\nint first[20],next[20][500010];\n\nint cost[(1<<15)][20];\nint dp[(1<<15)][110];\n\nint func(void){\n    int i,j,mask;\n    \n    REP(i,A){\n        int x = B;\n        next[i][B] = B;\n        for(j=B-1;j>=0;j--){\n            next[i][j] = x;\n            if(a[i] == b[j]) x = j;\n        }\n        first[i] = x;\n    }\n    \n    int maxInv = A * (A-1) / 2;\n    REP(mask,(1<<A)) REP(i,maxInv+1) dp[mask][i] = B;\n    REP(i,A) dp[(1<<i)][0] = first[i];\n    \n    REP(mask,(1<<A)) REP(i,maxInv+1) if(dp[mask][i] < B){\n        REP(j,A) if(!(mask&(1<<j))){\n            int mask2 = (mask | (1<<j));\n            int tmp = next[j][dp[mask][i]];\n            int inv = i + cost[mask][j];\n            if(tmp < dp[mask2][inv]) dp[mask2][inv] = tmp;\n        }\n    }\n    \n    int ans = -1;\n    REP(i,maxInv+1) if(dp[(1<<A)-1][i] < B) ans = max(ans,maxInv-i+1);\n    return ans;\n}\n\nint main(void){\n    int i,j,mask;\n    \n    REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;\n    \n    cin >> A;\n    REP(i,A) cin >> a[i];\n    cin >> Q;\n    REP(i,Q){\n        cin >> B;\n        REP(j,B) cin >> b[j];\n        int ans = func();\n        similarity[i] = ans;\n    }\n    \n    int ans = -1;\n    REP(i,Q) if(similarity[i] != -1 && (ans == -1 || similarity[i] > similarity[ans])) ans = i;\n    \n    if(ans == -1){\n        cout << \"Brand new problem!\" << endl;\n    } else {\n        cout << ans + 1 << endl;\n        string anss = \"[:\";\n        REP(i,similarity[ans]) anss += \"|\";\n        anss += \":]\";\n        cout << anss << endl;\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Brand New Problem.json",
    "editorial_link": "https://codeforces.com/blog/entry/4808",
    "editorial": "The first solution coming to mind is dynamic programming f[i][j]?=? (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215?-?1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.\n\nLet's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)\n\nIt's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j]?=? (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0]?=?0, f[0][j]?=?? for j?>?0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word  that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p?=?f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j]?=? (the smallest position k?>?i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.\n\nThe total number of operations can be calculated as m·(k·n?+?2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.",
    "hint": []
}