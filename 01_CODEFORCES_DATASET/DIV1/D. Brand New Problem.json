{"link": "https://codeforces.com//contest/201/problem/D", "problemId": "1458", "problem_idx": "D", "shortId": "201D", "contest_number": "201", "problem_submissions": {"D": [1842426, 1845322, 1848015, 2017065, 1845704, 1843679, 1843165, 1843645, 1843721, 1842642, 3962764, 1843892], "E": [1841059, 1842295, 1842570, 1848002, 1842412, 1843333, 1841361, 1842083, 1843064, 1842151, 1843347], "A": [1840364, 1839374, 1839153, 1847954, 1840731, 1839399, 1844333, 1839094, 1839993, 1841295, 1840073, 1839956, 1838952, 1839521, 1838849, 1839719, 1839105, 1839524], "C": [1840066, 1840781, 1840491, 1847992, 1840261, 1840947, 1839278, 1840815, 1841258, 1842024, 1841894, 1844043, 1841094, 1844134, 1840094, 1867350, 1840802, 1840979], "B": [1839596, 1838940, 1839961, 1847965, 1841485, 1840001, 1840567, 1839860, 1841578, 1839437, 1840889, 1840454, 1839972, 1839833, 1841387, 1839459, 1840240, 1840100, 1840475]}, "name": "D. Brand New Problem", "statement": "A widely known among some people Belarusian sport programmer Lesha\r\ndecided to make some money to buy a one square meter larger flat. To do\r\nthis, he wants to make and carry out a Super Rated Match (SRM) on the\r\nsite Torcoder.com. But there\u2019s a problem a severe torcoder coordinator\r\nIvan does not accept any Lesha\u2019s problem, calling each of them an\r\noffensive word \"duped\" (that is, duplicated). And one day they nearely\r\nquarrelled over yet another problem Ivan wouldn\u2019t accept.You are invited\r\nto act as a fair judge and determine whether the problem is indeed , or\r\nIvan is right and the problem bears some resemblance to those used in\r\nthe previous SRMs.You are given the descriptions of Lesha\u2019s problem and\r\neach of Torcoder.com archive problems. The description of each problem\r\nis a sequence of words. Besides, it is guaranteed that Lesha\u2019s problem\r\nhas no repeated words, while the description of an archive problem may\r\ncontain any number of repeated words.The \"similarity\" between Lesha\u2019s\r\nproblem and some archive problem can be found as follows. Among all\r\npermutations of words in Lesha\u2019s problem we choose the one that occurs\r\nin the archive problem as a subsequence. If there are multiple such\r\npermutations, we choose the one with the smallest number of inversions.\r\nThen the \"similarity\" of a problem can be written as , where is the\r\nnumber of words in Lesha\u2019s problem and is the number of inversions in\r\nthe chosen permutation. Note that the \"similarity\" is always a positive\r\ninteger.The problem is called if there is not a single problem in Ivan\u2019s\r\narchive which contains a permutation of words from Lesha\u2019s problem as a\r\nsubsequence.Help the boys and determine whether the proposed problem is\r\nnew, or specify the problem from the archive which resembles Lesha\u2019s\r\nproblem the most, otherwise.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint Q;\nint similarity[20];\n\nint A,B;\nstring a[20],b[500010];\nint first[20],next[20][500010];\n\nint cost[(1<<15)][20];\nint dp[(1<<15)][110];\n\nint func(void){\n    int i,j,mask;\n    \n    REP(i,A){\n        int x = B;\n        next[i][B] = B;\n        for(j=B-1;j>=0;j--){\n            next[i][j] = x;\n            if(a[i] == b[j]) x = j;\n        }\n        first[i] = x;\n    }\n    \n    int maxInv = A * (A-1) / 2;\n    REP(mask,(1<<A)) REP(i,maxInv+1) dp[mask][i] = B;\n    REP(i,A) dp[(1<<i)][0] = first[i];\n    \n    REP(mask,(1<<A)) REP(i,maxInv+1) if(dp[mask][i] < B){\n        REP(j,A) if(!(mask&(1<<j))){\n            int mask2 = (mask | (1<<j));\n            int tmp = next[j][dp[mask][i]];\n            int inv = i + cost[mask][j];\n            if(tmp < dp[mask2][inv]) dp[mask2][inv] = tmp;\n        }\n    }\n    \n    int ans = -1;\n    REP(i,maxInv+1) if(dp[(1<<A)-1][i] < B) ans = max(ans,maxInv-i+1);\n    return ans;\n}\n\nint main(void){\n    int i,j,mask;\n    \n    REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;\n    \n    cin >> A;\n    REP(i,A) cin >> a[i];\n    cin >> Q;\n    REP(i,Q){\n        cin >> B;\n        REP(j,B) cin >> b[j];\n        int ans = func();\n        similarity[i] = ans;\n    }\n    \n    int ans = -1;\n    REP(i,Q) if(similarity[i] != -1 && (ans == -1 || similarity[i] > similarity[ans])) ans = i;\n    \n    if(ans == -1){\n        cout << \"Brand new problem!\" << endl;\n    } else {\n        cout << ans + 1 << endl;\n        string anss = \"[:\";\n        REP(i,similarity[ans]) anss += \"|\";\n        anss += \":]\";\n        cout << anss << endl;\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "dp"], "dificulty": "2600", "interactive": false}