{
    "link": "https://codeforces.com//contest/739/problem/E",
    "problemId": "81536",
    "problem_idx": "E",
    "shortId": "739E",
    "contest_number": "739",
    "problem_submissions": {
        "C": [
            22442698,
            22439403,
            22439035,
            22441010,
            22452684,
            22437700,
            22438882,
            22439230,
            22438925,
            22440648,
            22439930,
            22440447,
            22440445,
            22442265,
            22442505,
            22443020,
            22443464,
            22471543
        ],
        "A": [
            22439350,
            22427880,
            22428059,
            22427929,
            22427879,
            22427835,
            22427894,
            22569748,
            22427875,
            22427910,
            22428905,
            22428165,
            22427839,
            22428416,
            22427876,
            22427815,
            22428207,
            22427895,
            22461370,
            22461352,
            22428531
        ],
        "B": [
            22438821,
            22430420,
            22433537,
            22432542,
            22430611,
            22432279,
            22431221,
            22432719,
            22432020,
            22433235,
            22432524,
            22433360,
            22434177,
            22433963,
            22430137,
            22435255,
            22433707,
            22459456,
            22459424,
            22459398,
            22442832
        ],
        "E": [
            22435846,
            23367614,
            23367585,
            23236778,
            22443543,
            31723439,
            22934699,
            22934399,
            22516029,
            22515992,
            22463839,
            22463413,
            22443763,
            22446956,
            22453608,
            22445886,
            22461332,
            22692840,
            22455977,
            22471655,
            22471636,
            22461535,
            22447302
        ],
        "D": [
            22462793,
            22462750,
            22462690,
            22450389,
            22469047,
            22498066
        ]
    },
    "name": "E. Gosha is hunting",
    "statement": "Gosha is hunting. His goal is to catch as many Pokemons as possible.\r\nGosha has Poke Balls and Ultra Balls. There are Pokemons. They are\r\nnumbered through . Gosha knows that if he throws a Poke Ball at the -th\r\nPokemon he catches it with probability . If he throws an Ultra Ball at\r\nthe -th Pokemon he catches it with probability . He can throw at most\r\none Ball of each type at any Pokemon.The hunting proceeds as follows: at\r\nfirst, Gosha chooses no more than Pokemons at which he will throw Poke\r\nBalls and no more than Pokemons at which he will throw Ultra Balls.\r\nAfter that, he throws the chosen Balls at the chosen Pokemons. If he\r\nthrows both Ultra Ball and Poke Ball at some Pokemon, he is caught if\r\nand only if he is caught by any of these Balls. The outcome of a throw\r\ndoesn’t depend on the other throws.Gosha would like to know what is the\r\nexpected number of the Pokemons he catches if he acts in an optimal way.\r\nIn other words, he would like to know the maximum possible expected\r\nnumber of Pokemons can catch.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=2010;\nint n,a,b,cnt[N][N];\ndouble p[N],u[N],f[N],dp[N][N];\nint main() {\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\trep(i,0,n) scanf(\"%lf\",p+i);\n\trep(i,0,n) scanf(\"%lf\",u+i),f[i]=p[i]+u[i]-p[i]*u[i];\n\tdouble l=-5e4,r=5e4;\n\twhile (clock()<=4*CLOCKS_PER_SEC) {\n\t\tdouble md=(l+r)*0.5;\n\t\trep(i,0,n+1) rep(j,0,i+1) dp[i][j]=-1e10,cnt[i][j]=0;\n\t\tdp[0][0]=0;\n\t\trep(i,1,n+1) rep(j,0,i+1) {\n\t\t\tif (j<i&&dp[i-1][j]>dp[i][j]) dp[i][j]=dp[i-1][j],cnt[i][j]=cnt[i-1][j];\n\t\t\tif (j>0&&dp[i-1][j-1]+p[i-1]>dp[i][j]) dp[i][j]=dp[i-1][j-1]+p[i-1],cnt[i][j]=cnt[i-1][j-1];\n\t\t\tif (j<i&&dp[i-1][j]+u[i-1]+md>dp[i][j]) dp[i][j]=dp[i-1][j]+u[i-1]+md,cnt[i][j]=cnt[i-1][j]+1;\n\t\t\tif (j>0&&dp[i-1][j-1]+f[i-1]+md>dp[i][j]) dp[i][j]=dp[i-1][j-1]+f[i-1]+md,cnt[i][j]=cnt[i-1][j-1]+1;\n\t\t}\n\t\tif (cnt[n][a]<b) l=md; else r=md;\n\t}\n\tprintf(\"%.10f\\n\",dp[n][a]-b*0.5*(l+r));\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "flows",
        "math",
        "probabilities",
        "sortings"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Gosha is hunting.json",
    "editorial_link": "https://codeforces.com//blog/entry/48582",
    "editorial": "Letâs divide Pokemons into 4 types: and depending on Balls that we throw\r\nto them. Letâs sort them by in descending order. Letâs iterate over last\r\nPokemon in which we throw Ultra Ball (his type is or ). Let be the index\r\nof this Pokemon. It is not hard to prove that there are no Pokemons to\r\nthe left of that have type and all Pokemons to the right of have type or\r\n. Letâs sort all Pokemons to the left of by in descending order. Letâs\r\niterate last Pokemon of type . Let be his index. We can prove that to\r\nthe left of every Pokemon has type or (Letâs call this group of Pokemons\r\n). Between and every Pokemon has type or (will call them ). To the right\r\nof only and (will call them ). We know that we throw an Ultra Ball to\r\nevery Pokemon in . So letâs add to our answer sum of of all Pokemons in\r\n. Number of Pokemons in of type equals to the difference between (number\r\nof Ultra Balls) and size of . Therefore we know number of Pokemons in of\r\ntype and we know how many Poke Balls are left for and summarily. Not\r\nhard to prove that in group we should throw Poke Balls to Pokemons with\r\ngreatest . Now we have to understand in which Pokemons in and we should\r\nthrow Poke Balls. If we throw Poke Ball to Pokemon from , it adds to the\r\nanswer , from - adds . So we should throw Poke Balls to Pokemons with\r\ngreatest values. When we iterate over , each iteration one Pokemon moves\r\nfrom to . We can keep structure that can add and delete one element,\r\nfind minimum and keep sum of all elements in the structure. For example,\r\ntreap or map (in c++). Letâs keep 2 such structures: for calculating\r\nanswer for and for calculating answer for throwing Poke Balls to\r\nPokemons in and . The complexity - O().\r\n",
    "hint": []
}