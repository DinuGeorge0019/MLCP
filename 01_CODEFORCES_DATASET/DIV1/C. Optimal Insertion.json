{
    "link": "https://codeforces.com//contest/1601/problem/C",
    "problemId": "1157779",
    "problem_idx": "C",
    "shortId": "1601C",
    "contest_number": "1601",
    "problem_submissions": {
        "F": [
            133036741,
            133030850,
            133053471,
            133036776,
            136096402,
            133146246
        ],
        "E": [
            133012503,
            133009950,
            133010165,
            133012509,
            133023042,
            133010446,
            133029069,
            133020546,
            133026708,
            133026848,
            133096129,
            133096027,
            133009106,
            133031363,
            133005130,
            133031540,
            133037221,
            133324190,
            133128643,
            133007675,
            133037406
        ],
        "D": [
            133003986,
            133005946,
            133003145,
            133019481,
            133007804,
            133008410,
            133020273,
            133009176,
            133009157,
            133008849,
            133009299,
            133026582,
            133008809,
            133014147,
            133008199,
            133009583,
            133010326,
            133056419,
            133004546,
            133008768
        ],
        "C": [
            132999482,
            132998781,
            132997710,
            132998487,
            133003047,
            133002651,
            133001118,
            133000071,
            133003217,
            132998126,
            133000279,
            133000540,
            133004698,
            133023294,
            133006018,
            133000684,
            132998660,
            133001622,
            133009000,
            133004643
        ],
        "B": [
            132991406,
            132991376,
            132992870,
            132992842,
            132992304,
            132995590,
            132995226,
            132992037,
            132995055,
            132990916,
            132993158,
            132995079,
            132994798,
            132993699,
            132996347,
            133113107,
            132993962,
            132993893,
            132997201,
            132995373,
            132994895
        ],
        "A": [
            132984771,
            132984572,
            132985020,
            132988648,
            132985081,
            132985096,
            132984905,
            132984874,
            132986113,
            132984658,
            132986695,
            132985767,
            132986320,
            132985605,
            132985251,
            132987796,
            132985532,
            132985036,
            132986108,
            132986609
        ]
    },
    "name": "C. Optimal Insertion",
    "statement": "You are given two arrays of integers a_1, a_2,\r\nldots, a_n and b_1, b_2,\r\nldots, b_m.You need to insert all elements of b into a in an arbitrary\r\nway. As a result you will get an array c_1, c_2,\r\nldots, c_{n+m} of size n + m.Note that you are not allowed to change the\r\norder of elements in a, while you can insert elements of b at arbitrary\r\npositions. They can be inserted at the beginning, between any elements\r\nof a, or at the end. Moreover, elements of b can appear in the resulting\r\narray in any order.What is the minimum possible number of inversions in\r\nthe resulting array c? Recall that an inversion is a pair of indices (i,\r\nj) such that i < j and c_i > c_j.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, a[1000005], b[1000005];\nPII perm[1000005];\nstruct fwt\n{\n\tint dat[1000005];\n\tvoid clear()\n\t{\n\t\trep1(i, n) dat[i] = 0;\n\t}\n\tvoid add(int id, int val)\n\t{\n\t\tfor(id ++; id <= n; id += id & -id) dat[id] += val;\n\t}\n\tint query(int id)\n\t{\n\t\tint ret = 0;\n\t\tfor(id ++; id > 0; id -= id & -id) ret += dat[id];\n\t\treturn ret;\n\t}\n}tre;\n\nLL ans;\npriority_queue<int> que;\nvoid addnew(int x)\n{\n\tif(que.empty()) {\n\t\tque.push(x);\n\t} else if(x >= que.top()) que.push(x);\n\telse {\n\t\tans += que.top() - x;\n\t\tque.push(x); que.push(x); que.pop();\n\t}\n}\nvoid solve()\n{\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n) scanf(\"%d\", &a[i]);\n\trep(i, m) scanf(\"%d\", &b[i]);\n\tsort(b, b + m);\n\trep(i, n) perm[i] = MP(a[i], i);\n\tsort(perm, perm + n);\n\tans = 0;\n\ttre.clear();\n\trep(i, n) {\n\t\tans += 2 * (i - tre.query(perm[i].second));\n\t\ttre.add(perm[i].second, 1);\n\t}\n\twhile(!que.empty()) que.pop();\n\trep(i, n) {\n\t\tint r = upper_bound(b, b + m, a[i]) - b, l = lower_bound(b, b + m, a[i]) - b; \n\t\taddnew(r); addnew(l); ans -= r - l;\n\t}\n\tassert(ans % 2 == 0);\n\tprintf(\"%lld\\n\", ans / 2);\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile(T --) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Optimal Insertion.json",
    "editorial_link": "https://codeforces.com//blog/entry/95865",
    "editorial": "Letâs sort array .Letâs define as the index of the array , before which\r\nwe should insert . If should be inserted at the end of the array , letâs\r\nmake .Letâs note, that all inserted elements should go in the sorted\r\norder in the optimal answer. If it is false and there exists for , letâs\r\nswap and in the answer. The number of inversions will decrease, a\r\ncontradiction.So . If we will find their values we will be able to\r\nrestore an array after inserting elements.Letâs use \"Divide and conquer\"\r\nto find them. Letâs write a recursive function , that will find for all\r\n, if it is known, that for all such . To find all values of we should\r\ncall the function .Realization of : If , we shouldnât do anything. Let .\r\nLetâs find . The number of inversions with will be (the number of for\r\n) + (the number of for ). This sum differs by a constant from: (the\r\nnumber of for ) + (the number of for ). For this sum it is simple to\r\nfind the minimal optimal in . Letâs make two recursive calls of , , that\r\nwill find all remaining values of . The complexity of this function will\r\nbe , because there will be levels of recursion and we will make\r\noperations on each of them.In the end, using the values we will restore\r\nthe array and find the number of inversions in it.Total complexity:\r\n.Also, there exist other correct solutions with the same complexity,\r\nusing segment tree.\r\n",
    "hint": []
}