{
    "link": "https://codeforces.com//contest/1815/problem/E",
    "problemId": "1871723",
    "problem_idx": "E",
    "shortId": "1815E",
    "contest_number": "1815",
    "problem_submissions": {
        "F": [
            201555670,
            201558612,
            201561386,
            201567730,
            201566757,
            202046482,
            201726445,
            201935453,
            201585873
        ],
        "E": [
            201530172,
            201528832,
            201551207,
            201544435,
            201543833,
            201554402,
            201555894,
            201557703,
            201554929,
            201556101,
            201557247,
            201555003,
            201557950,
            201556139,
            201563294,
            201546853,
            201542261,
            201546492,
            201570815
        ],
        "D": [
            201513083,
            201506968,
            201521370,
            201517487,
            201522017,
            201533871,
            201533067,
            201531357,
            201527346,
            201537489,
            201539887,
            201539975,
            201543678,
            201546232,
            201566677,
            201568923,
            201534451
        ],
        "C": [
            201497483,
            201499771,
            201506268,
            201502220,
            201510933,
            201510356,
            201506402,
            201517502,
            201515562,
            201517401,
            201523915,
            201524806,
            201533994,
            201523878,
            201503778,
            201512320,
            201510486,
            201513744
        ],
        "B": [
            201489690,
            201490417,
            201495395,
            201494655,
            201496814,
            201493671,
            201494756,
            201502664,
            201501592,
            201503253,
            201515920,
            201510149,
            201510749,
            201492437,
            201503376,
            201496616,
            201500693
        ],
        "A": [
            201483243,
            201480897,
            201480866,
            201480768,
            201483195,
            201480859,
            201480836,
            201481081,
            201480782,
            201481965,
            201483607,
            201482857,
            201481459,
            201480707,
            201481969,
            201481110,
            201483462
        ]
    },
    "name": "E. Bosco and Particle",
    "statement": "Bosco is studying the behaviour of particles. He decided to investigate\r\non the peculiar behaviour of the so-called \"four-one-two\" particle. He\r\ndoes the following:There is a line of length n+1, where the topmost\r\npoint is position 0 and bottommost is position n+1. The particle is\r\ninitially (at time t=0) at position 0 and heading downwards. The\r\nparticle moves at the speed of 1 unit per second. There are n\r\noscillators at positions 1,2,\r\nldots,n.Each oscillator can be described by a binary string. The initial\r\nstate of each oscillator is the first character of its binary string.\r\nWhen the particle hits with an oscillator, the particle reverses its\r\ndirection if its current state is\r\ntexttt{1} and continues to move at the same direction if its current\r\nstate is\r\ntexttt{0}, and that oscillator moves on to the next state (the next\r\nstate of the last state is defined as the first state). Additionally,\r\nthe particle always reverses its direction when it is at position 0 or\r\nn+1 at time t > 0.Bosco would like to know the cycle length of the\r\nmovement of particle. The cycle length is defined as the minimum value\r\nof c such that for any time t\r\nge 0, the position of the particle at time t is same as the position of\r\nthe particle at time t+c. It can be proved that such value c always\r\nexists. As he realises the answer might be too large, he asks you to\r\noutput your answer modulo 998244353.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 09.04.2023 11:35:51       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nnamespace factorizer {\n\ntemplate <typename T>\nstruct FactorizerVarMod { static T value; };\ntemplate <typename T>\nT FactorizerVarMod<T>::value;\n\ntemplate <typename T>\nbool IsPrime(T n, const vector<T>& bases) {\n  if (n < 2) {\n    return false;\n  }\n  vector<T> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n  for (const T& x : small_primes) {\n    if (n % x == 0) {\n      return n == x;\n    }\n  }\n  if (n < 31 * 31) {\n    return true;\n  }\n  int s = 0;\n  T d = n - 1;\n  while ((d & 1) == 0) {\n    d >>= 1;\n    s++;\n  }\n  FactorizerVarMod<T>::value = n;\n  for (const T& a : bases) {\n    if (a % n == 0) {\n      continue;\n    }\n    Modular<FactorizerVarMod<T>> cur = a;\n    cur = power(cur, d);\n    if (cur == 1) {\n      continue;\n    }\n    bool witness = true;\n    for (int r = 0; r < s; r++) {\n      if (cur == n - 1) {\n        witness = false;\n        break;\n      }\n      cur *= cur;\n    }\n    if (witness) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool IsPrime(long long n) {\n  return IsPrime(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n}\n\nbool IsPrime(int32_t n) {\n  return IsPrime(n, {2, 7, 61});\n}\n\n// but if you really need ulong long version...\n/*\nbool IsPrime(ulong long n) {\n  if (n < 2) {\n    return false;\n  }\n  vector<uint32_t> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n  for (uint32_t x : small_primes) {\n    if (n == x) {\n      return true;\n    }\n    if (n % x == 0) {\n      return false;\n    }\n  }\n  if (n < 31 * 31) {\n    return true;\n  }\n  uint32_t s = __builtin_ctzll(n - 1);\n  ulong long d = (n - 1) >> s;\n  function<bool(ulong long)> witness = [&n, &s, &d](ulong long a) {\n    ulong long cur = 1, p = d;\n    while (p > 0) {\n      if (p & 1) {\n        cur = (__uint128_t) cur * a % n;\n      }\n      a = (__uint128_t) a * a % n;\n      p >>= 1;\n    }\n    if (cur == 1) {\n      return false;\n    }\n    for (uint32_t r = 0; r < s; r++) {\n      if (cur == n - 1) {\n        return false;\n      }\n      cur = (__uint128_t) cur * cur % n;\n    }\n    return true;\n  };\n  vector<ulong long> bases_64bit = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n  for (ulong long a : bases_64bit) {\n    if (a % n == 0) {\n      return true;\n    }\n    if (witness(a)) {\n      return false;\n    }\n  }\n  return true;\n}\n*/\n\nvector<int> least = {0, 1};\nvector<int> primes;\nint precalculated = 1;\n\nvoid RunLinearSieve(int n) {\n  n = max(n, 1);\n  least.assign(n + 1, 0);\n  primes.clear();\n  for (int i = 2; i <= n; i++) {\n    if (least[i] == 0) {\n      least[i] = i;\n      primes.push_back(i);\n    }\n    for (int x : primes) {\n      if (x > least[i] || i * x > n) {\n        break;\n      }\n      least[i * x] = x;\n    }\n  }\n  precalculated = n;\n}\n\nvoid RunSlowSieve(int n) {\n  n = max(n, 1);\n  least.assign(n + 1, 0);\n  for (int i = 2; i * i <= n; i++) {\n    if (least[i] == 0) {\n      for (int j = i * i; j <= n; j += i) {\n        if (least[j] == 0) {\n          least[j] = i;\n        }\n      }\n    }\n  }\n  primes.clear();\n  for (int i = 2; i <= n; i++) {\n    if (least[i] == 0) {\n      least[i] = i;\n      primes.push_back(i);\n    }\n  }\n  precalculated = n;\n}\n\nvoid RunSieve(int n) {\n  RunLinearSieve(n);\n}\n\ntemplate <typename T>\nvector<pair<T, int>> MergeFactors(const vector<pair<T, int>>& a, const vector<pair<T, int>>& b) {\n  vector<pair<T, int>> c;\n  int i = 0;\n  int j = 0;\n  while (i < (int) a.size() || j < (int) b.size()) {\n    if (i < (int) a.size() && j < (int) b.size() && a[i].first == b[j].first) {\n      c.emplace_back(a[i].first, a[i].second + b[j].second);\n      ++i;\n      ++j;\n      continue;\n    }\n    if (j == (int) b.size() || (i < (int) a.size() && a[i].first < b[j].first)) {\n      c.push_back(a[i++]);\n    } else {\n      c.push_back(b[j++]);\n    }\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<pair<T, int>> RhoC(const T& n, const T& c) {\n  if (n <= 1) {\n    return {};\n  }\n  if ((n & 1) == 0) {\n    return MergeFactors({{2, 1}}, RhoC(n / 2, c));\n  }\n  if (IsPrime(n)) {\n    return {{n, 1}};\n  }\n  FactorizerVarMod<T>::value = n;\n  Modular<FactorizerVarMod<T>> x = 2;\n  Modular<FactorizerVarMod<T>> saved = 2;\n  T power = 1;\n  T lam = 1;\n  while (true) {\n    x = x * x + c;\n    T g = __gcd((x - saved)(), n);\n    if (g != 1) {\n      return MergeFactors(RhoC(g, c + 1), RhoC(n / g, c + 1));\n    }\n    if (power == lam) {\n      saved = x;\n      power <<= 1;\n      lam = 0;\n    }\n    lam++;\n  }\n  return {};\n}\n\ntemplate <typename T>\nvector<pair<T, int>> Rho(const T& n) {\n  return RhoC(n, static_cast<T>(1));\n}\n\ntemplate <typename T>\nvector<pair<T, int>> Factorize(T x) {\n  if (x <= 1) {\n    return {};\n  }\n  if (x <= precalculated) {\n    vector<pair<T, int>> ret;\n    while (x > 1) {\n      if (!ret.empty() && ret.back().first == least[x]) {\n        ret.back().second++;\n      } else {\n        ret.emplace_back(least[x], 1);\n      }\n      x /= least[x];\n    }\n    return ret;\n  }\n  if (x <= static_cast<long long>(precalculated) * precalculated) {\n    vector<pair<T, int>> ret;\n    if (!IsPrime(x)) {\n      for (T i : primes) {\n        T t = x / i;\n        if (i > t) {\n          break;\n        }\n        if (x == t * i) {\n          int cnt = 0;\n          while (x % i == 0) {\n            x /= i;\n            cnt++;\n          }\n          ret.emplace_back(i, cnt);\n          if (IsPrime(x)) {\n            break;\n          }\n        }\n      }\n    }\n    if (x > 1) {\n      ret.emplace_back(x, 1);\n    }\n    return ret;\n  }\n  return Rho(x);\n}\n\ntemplate <typename T>\nvector<T> BuildDivisorsFromFactors(const vector<pair<T, int>>& factors) {\n  vector<T> divisors = {1};\n  for (auto& p : factors) {\n    int sz = (int) divisors.size();\n    for (int i = 0; i < sz; i++) {\n      T cur = divisors[i];\n      for (int j = 0; j < p.second; j++) {\n        cur *= p.first;\n        divisors.push_back(cur);\n      }\n    }\n  }\n  sort(divisors.begin(), divisors.end());\n  return divisors;\n}\n\n}  // namespace factorizer\n\ntemplate <typename T>\nvector<int> z_function(int n, const T &s) {\n  vector<int> z(n, n);\n  int l = 0, r = 0;\n  for (int i = 1; i < n; i++) {\n    z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n      z[i]++;\n    }\n    if (i + z[i] - 1 > r) {\n      l = i;\n      r = i + z[i] - 1;\n    }\n  }\n  return z;\n}\n\ntemplate <typename T>\nvector<int> z_function(const T &s) {\n  return z_function((int) s.size(), s);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  const int M = (int) 2e6 + 10;\n  factorizer::RunSieve(M);\n  vector<Mint> inv(M);\n  for (int i = 1; i < M; i++) {\n    inv[i] = 1 / Mint(i);\n  }\n  Mint per = 2;\n  Mint cnt = 1;\n  vector<int> a(M);\n  for (int id = 0; id < n; id++) {\n    string s;\n    cin >> s;\n    auto z = z_function(s);\n    int len = (int) s.size();\n    for (int i = 1; i < len; i++) {\n      if (z[i] == len - i && len % i == 0) {\n        s = s.substr(0, i);\n        len = i;\n        break;\n      }\n    }\n    int k0 = 0;\n    for (char c : s) {\n      if (c == '0') {\n        k0 += 1;\n      }\n    }\n    if (k0 % 2 == 1) {\n      s += s;\n      len += len;\n      k0 += k0;\n    }\n    int times = 0;\n    int met = 0;\n    int hit = 0;\n    for (char c : s) {\n      if (c == '0') {\n        if (met % 2 == 0) {\n          times += 1;\n          hit += 1;\n        }\n        met += 1;\n      } else {\n        if (met % 2 == 0) {\n          times += 1;\n        } else {\n          hit += 1;\n        }\n      }\n    }\n    auto f = factorizer::Factorize(times);\n    for (auto& p : f) {\n      while (a[p.first] < p.second) {\n        a[p.first] += 1;\n        per *= p.first;\n        cnt *= p.first;\n      }\n    }\n    for (auto& p : f) {\n      for (int i = 0; i < p.second; i++) {\n        a[p.first] -= 1;\n        cnt *= inv[p.first];\n      }\n    }\n    if (hit == 0) {\n      break;\n    }\n    cnt *= hit;\n    f = factorizer::Factorize(hit);\n    for (auto& p : f) {\n      a[p.first] += p.second;\n    }\n    per += 2 * cnt;\n  }\n  cout << per << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "number theory",
        "strings"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Bosco and Particle.json",
    "editorial_link": "https://codeforces.com//blog/entry/114899",
    "editorial": "Observation 1 Observe that whole process is periodic. Note that the\nprocess is reversible. If you are in some state , consisting of position\nof the particle and the current state position of each oscillator, you\ncan decide the next state and the previous state. This implies the state\ntransition graph is a permutation, so it decomposes into cycles.\n",
    "hint": [
        "Hint 1 If the oscillator string is periodic, what should we do?",
        "Hint 2 Use the case when to help you calculate the answer."
    ]
}