{
    "link": "https://codeforces.com//contest/1718/problem/E",
    "problemId": "1509968",
    "problem_idx": "E",
    "shortId": "1718E",
    "contest_number": "1718",
    "problem_submissions": {
        "F": [
            168597010,
            168624668,
            173812548,
            173812098,
            168599096
        ],
        "D": [
            168565469,
            168586026,
            168571061,
            168581216,
            168578771,
            168572736,
            168587794,
            168591318,
            168592506,
            168597359,
            168590948,
            168600506,
            168597231,
            168582453,
            168687986
        ],
        "C": [
            168541281,
            168543939,
            168544627,
            168545043,
            168549826,
            168553177,
            168540235,
            168546151,
            168543268,
            168562740,
            168541559,
            168562194,
            168567397,
            168609760,
            168609209,
            168608717,
            168567701,
            168606687,
            168620286,
            168547337,
            168546667,
            168553348,
            168556898,
            168552397
        ],
        "B": [
            168533942,
            168529866,
            168534830,
            168535200,
            168537223,
            168547085,
            168528202,
            168537852,
            168530917,
            168805783,
            168550097,
            168530349,
            168548672,
            168547336,
            168549427,
            168545357,
            168535673,
            168532763,
            168537259,
            168542957,
            168536570
        ],
        "A2": [
            168516853,
            168520403,
            168525192,
            168517279,
            168521825,
            168526171,
            168517695,
            168521659,
            168518863,
            168529215,
            168520755,
            168523804,
            168536216,
            168521669,
            168523926,
            168522044,
            168518219,
            168525244,
            168524582,
            168517935
        ],
        "A1": [
            168516745,
            168520669,
            168524305,
            168517111,
            168521468,
            168525366,
            168517892,
            168521859,
            168518553,
            168529389,
            168520943,
            168523566,
            168536034,
            168521371,
            168523798,
            168521699,
            168516764,
            168524985,
            168524317,
            168517770
        ],
        "E": [
            168650929,
            168598643,
            168610266,
            173790812
        ]
    },
    "name": "E. Impressionism",
    "statement": "Burenka has two pictures a and b, which are tables of the same size n\r\ntimes m. Each cell of each painting has a color a number from 0 to 2\r\ncdot 10^5, and there are no repeating colors in any row or column of\r\neach of the two paintings, except color 0.Burenka wants to get a picture\r\nb from the picture a. To achieve her goal, Burenka can perform one of 2\r\noperations: swap any two rows of a or any two of its columns. Tell\r\nBurenka if she can fulfill what she wants, and if so, tell her the\r\nsequence of actions.The rows are numbered from 1 to n from top to\r\nbottom, the columns are numbered from 1 to m from left to right.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\n//mint107 \u306f verify \u3057\u3066\u306d\u3048\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\nconst int vmax=2*ten(5)+10;\n\nusing A=array<mint,2>;\n\nA z[vmax];\nvoid init(){\n\trep(v,vmax)rep(k,2)z[v][k]=rand_int(1,mint::mod-1);\n}\n\nvc<A> gethash(int n,int m,vvc<int> rw){\n\tvc<A> a(n),b(m);\n\tconst int ITR=min(n,m)/2*2+4;\n\trep(_,ITR){\n\t\tif(_%2==0){\n\t\t\trep(j,m)rep(k,2)b[j][k]=0;\n\t\t\trep(i,n)rep(j,m){\n\t\t\t\trep(k,2){\n\t\t\t\t\tb[j][k]+=(a[i][k]+1)*z[rw[i][j]][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\trep(i,n)rep(k,2)a[i][k]=0;\n\t\t\trep(i,n)rep(j,m){\n\t\t\t\trep(k,2){\n\t\t\t\t\ta[i][k]+=(b[j][k]+1)*z[rw[i][j]][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn a;\n}\n\ntemplate<class T>\npair<bool,vc<pi>> mg(vc<T> a,vc<T> b){\n\tint n=si(a);assert(si(b)==n);\n\tvc<pair<T,int>> x(n),y(n);\n\trep(i,n)x[i]=mp(a[i],i);\n\trep(i,n)y[i]=mp(b[i],i);\n\tsort(all(x));\n\tsort(all(y));\n\trep(i,n)if(x[i].a!=y[i].a)return mp(false,vc<pi>{});\n\tvi p(n),q(n);\n\trep(i,n)p[x[i].b]=y[i].b;\n\trep(i,n)q[p[i]]=i;\n\tvc<pi> res;\n\trep(i,n)if(p[i]!=i){\n\t\tint j=q[i];\n\t\tswap(p[i],p[j]);\n\t\tswap(q[p[i]],q[p[j]]);\n\t\tres.eb(i,j);\n\t\tswap(a[i],a[j]);\n\t}\n\tassert(a==b);\n\treturn mp(true,res);\n}\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tvvc<int> rw1(n),rw2(n);\n\trep(i,n)rw1[i]=readvi(m);\n\trep(i,n)rw2[i]=readvi(m);\n\tdmp(rw1);\n\tdmp(rw2);\n\tauto a=gethash(n,m,rw1);\n\tauto c=gethash(n,m,rw2);\n\t\n\t\n\tauto [ok1,ij1]=mg(a,c);\n\tif(ok1){\n\t\tfor(auto [i,j]:ij1){\n\t\t\tswap(rw1[i],rw1[j]);\n\t\t}\n\t\tvvc<int> x(m,vi(n)),y(m,vi(n));\n\t\trep(i,n)rep(j,m)x[j][i]=rw1[i][j];\n\t\trep(i,n)rep(j,m)y[j][i]=rw2[i][j];\n\t\tauto [ok2,ij2]=mg(x,y);\n\t\t\n\t\tif(ok2){\n\t\t\tprint(si(ij1)+si(ij2));\n\t\t\tfor(auto [i,j]:ij1){\n\t\t\t\tcout<<\"1 \"<<i+1<<\" \"<<j+1<<\"\\n\";\n\t\t\t}\n\t\t\tfor(auto [i,j]:ij2){\n\t\t\t\tcout<<\"2 \"<<i+1<<\" \"<<j+1<<\"\\n\";\n\t\t\t}\n\t\t}else print(-1);\n\t}else print(-1);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinit();\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "implementation",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Impressionism.json",
    "editorial_link": "https://codeforces.com//blog/entry/106049",
    "editorial": "Let\u00e2\u0080\u0099s have two permutations: of length and of length .\nInitially, both permutations are identical. For operation , we will\nexecute , for operation we will execute . It is easy to see that after\nperforming all operations in the position will be .Now we need to find\npermutations of so that .Let\u00e2\u0080\u0099s look at a bipartite graph where the first\npart is rows and the second is columns. Let if , then from there is an\nundirected edge in of the color . if we construct the same graph for ,\nthen we need to check for isomorphism two bipartite graphs, each edge of\nwhich has a color, and as we remember, by the condition of the vertex, 2\nedges of the same color cannot be Incidence. Let\u00e2\u0080\u0099s call them graph and\ngraph .This problem is largely for implementation, therefore, starting\nfrom this moment, the actions that you can observe in the author\u00e2\u0080\u0099s\nsolution are described 168728958.Let otherwise let\u00e2\u0080\u0099s swap and in places.\nLet\u00e2\u0080\u0099s try to match the elements of the array to the elements of the\narray . Let\u00e2\u0080\u0099s go through the indices from to . Let\u00e2\u0080\u0099s now choose which\npair of to choose for the -th vertex of the first fraction of the graph\n. If we have already found a pair earlier, skip the step, otherwise\nlet\u00e2\u0080\u0099s sort out the appropriate option for the pair among all the\nvertices of the first component that do not yet have a pair, there are\nno more than , after the vertices are matched, the edges are also\nuniquely matched (because there are no 2 edges of different colors),\nlet\u00e2\u0080\u0099s then run the substitution recursively for edges (if we have mapped\nthe vertex to the vertex and from there is an edge of color in , and\nfrom there is an edge in , then it is easy to prove that in the answer\nwill be mapped to ), which means we will restore the entire component.\nLet the sum of the number of vertices and the number of edges in the\ncomponent be , then we will perform no more than actions to restore the\ncomponent.by permutations, getting a sequence of swaps is a matter of\ntechnique, I will not explain it, but this is a separate function in the\nauthor\u00e2\u0080\u0099s solution you will understand.in total, our solution works for\nor , where is the total number of vertices and edges in all\ncomponents.feel free to ask any questions\n"
}