{
    "link": "https://codeforces.com//contest/650/problem/E",
    "problemId": "50875",
    "problem_idx": "E",
    "shortId": "650E",
    "contest_number": "650",
    "problem_submissions": {
        "E": [
            16578790,
            16577272,
            16578590,
            16579959,
            16637208,
            16582561,
            16619834,
            16591408,
            16757704
        ],
        "D": [
            16571229,
            16573705,
            16576122,
            16578304,
            16576176,
            16577509,
            16577016,
            16576771,
            16578407,
            16577295,
            16573405,
            16578398,
            16577971,
            16579415,
            16579518,
            16578322,
            16579977,
            16579420,
            16579068
        ],
        "B": [
            16567529,
            16566753,
            16570863,
            16566306,
            16567392,
            16570268,
            16568199,
            16568212,
            16566872,
            16566001,
            16578738,
            16567371,
            16573291,
            16569824,
            16567006,
            16572578,
            16570591,
            16567965,
            16566091
        ],
        "C": [
            16565085,
            16569140,
            16568520,
            16573461,
            16571216,
            16572854,
            16571058,
            16570678,
            16571485,
            16571831,
            16567202,
            16572160,
            16568367,
            16566170,
            16572982,
            16567681,
            16567338,
            16571921,
            16572363
        ],
        "A": [
            16562732,
            16562808,
            16562782,
            16562889,
            16563014,
            16563492,
            16563086,
            16563133,
            16562823,
            16562796,
            16575057,
            16563813,
            16563019,
            16567243,
            16562986,
            16569600,
            16562758,
            16562970,
            16562962
        ]
    },
    "name": "E. Clockwork Bomb",
    "statement": "My name is James diGriz, Iâ€™m the most clever robber and treasure hunter\r\nin the whole galaxy. There are books written about my adventures and\r\nsongs about my operations, though you were able to catch me up in a\r\npretty awkward moment.I was able to hide from cameras, outsmart all the\r\nguards and pass numerous traps, but when I finally reached the treasure\r\nbox and opened it, I have accidentally started the clockwork bomb!\r\nLuckily, I have met such kind of bombs before and I know that the\r\nclockwork mechanism can be stopped by connecting contacts with wires on\r\nthe control panel of the bomb in a certain manner.I see contacts\r\nconnected by wires. Contacts are numbered with integers from to . Bomb\r\nhas a security mechanism that ensures the following condition: if there\r\nexist contacts forming a circuit, i. e. there exist wires between\r\ncontacts and , and , , and , then the bomb immediately explodes and my\r\nstory ends here. In particular, if two contacts are connected by more\r\nthan one wire they form a circuit of length . It is also prohibited to\r\nconnect a contact with itself.On the other hand, if I disconnect more\r\nthan one wire (i. e. at some moment there will be no more than wires in\r\nthe scheme) then the other security check fails and the bomb also\r\nexplodes. So, the only thing I can do is to unplug some wire and plug it\r\ninto a new place ensuring the fact that no circuits appear.I know how I\r\nshould put the wires in order to stop the clockwork. But my time is\r\nrunning out! Help me get out of this alive: find the sequence of\r\noperations each of which consists of unplugging some wire and putting it\r\ninto another place so that the bomb is defused.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 500010;\n\nint p[N];\n\ninline int find_set(int x) {\n  if (x != p[x]) {\n    p[x] = find_set(p[x]);\n  }\n  return p[x];\n}\n\nvector < pair <int, int> > edges[N];\n\ninline void unite(int x, int y) {\n  x = find_set(x);\n  y = find_set(y);\n  if (x == y) {\n    return;\n  }\n  p[x] = y;\n  if (edges[x].size() > edges[y].size()) {\n    swap(edges[x], edges[y]);\n  }\n  while (!edges[x].empty()) {\n    edges[y].push_back(edges[x].back());\n    edges[x].pop_back();\n  }\n}\n\nvector < pair <int, int> > g[N];\nbool rem[N], add[N];\nbool done[N];\nint bx[N], by[N];\n\ninline void dfs(int v, int pr) {\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (u == pr) {\n      continue;\n    }\n    dfs(u, v);\n    int id = g[v][j].second;\n    if (!rem[id]) {\n      unite(u, v);\n      continue;\n    }\n    pair <int, int> e = edges[u].back();\n    while (done[e.second]) {\n      edges[u].pop_back();\n      e = edges[u].back();\n    }\n    done[e.second] = true;\n    printf(\"%d %d %d %d\\n\", u + 1, v + 1, bx[e.second] + 1, by[e.second] + 1);\n    edges[u].pop_back();\n    unite(u, e.first);\n  }\n}\n\nint ax[N], ay[N];\npair < pair <int, int>, int > ev[2 * N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d %d\", ax + i, ay + i);\n    ax[i]--; ay[i]--;\n    if (ax[i] > ay[i]) {\n      swap(ax[i], ay[i]);\n    }\n    ev[i] = make_pair(make_pair(ax[i], ay[i]), i);\n    rem[i] = false;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d %d\", bx + i, by + i);\n    bx[i]--; by[i]--;\n    if (bx[i] > by[i]) {\n      swap(bx[i], by[i]);\n    }\n    ev[n - 1 + i] = make_pair(make_pair(bx[i], by[i]), ~i);\n    add[i] = false;\n  }\n  sort(ev, ev + n - 1 + n - 1);\n  int ans = 0;\n  for (int i = n - 1 + n - 1 - 1; i >= 0; i--) {\n    if (i > 0 && ev[i].first == ev[i - 1].first) {\n      i--;\n      continue;\n    }\n    int x = ev[i].second;\n    if (x >= 0) {\n      rem[x] = true;\n      ans++;\n    } else {\n      add[~x] = true;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    g[ax[i]].push_back(make_pair(ay[i], i));\n    g[ay[i]].push_back(make_pair(ax[i], i));\n  }\n  for (int i = 0; i < n; i++) {\n    edges[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    if (!add[i]) {\n      continue;\n    }\n    done[i] = false;\n    edges[bx[i]].push_back(make_pair(by[i], i));\n    edges[by[i]].push_back(make_pair(bx[i], i));\n  }\n  for (int i = 0; i < n; i++) {\n    p[i] = i;\n  }\n  printf(\"%d\\n\", ans);\n  dfs(0, -1);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "greedy",
        "trees"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Clockwork Bomb.json",
    "editorial_link": "https://codeforces.com//blog/entry/43677",
    "editorial": "First idea is that answer\nis always equals to the number of edges from the first tree, which are\nnot in the second one. This means that if we have an edge in both trees\nwe will never touch it. So if we have such edge we can remove this edge\nand merge its two vertices together, nothing will change. Second idea\nthat if we will take any edge from the first tree there always exists\nsome edge from the second tree, which we can swap (otherwise second\ngraph is not connected, but the tree is always connected). So the order\nof adding edges from the first tree can be arbitrary. Third idea is that\nif we will select leaf node in the first tree, then cut its only edge,\nthen we can add instead of it any edge going from this vertex in the\nsecond tree. Overall algorithm: we store linked lists of edges in\nvertices, when edge is in both trees we use disjoint-set union to merge\nvertices and join their lists. We can simply traverse first tree to get\nany order of edges in which the current edge will always contain leaf as\none of its vertices. Complexity is , which in practice is almost linear.\n",
    "hint": []
}