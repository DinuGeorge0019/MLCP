{
    "link": "https://codeforces.com//contest/1628/problem/B",
    "problemId": "1270543",
    "problem_idx": "B",
    "shortId": "1628B",
    "contest_number": "1628",
    "problem_submissions": {
        "F": [
            143704137,
            143703628,
            143702221,
            143703556,
            147001965
        ],
        "E": [
            143675713,
            143683767,
            143678064,
            143684015,
            143703839,
            143703586,
            143684851,
            143683465,
            143685498,
            143691038,
            143689260,
            143676465,
            143693250,
            143684297,
            143687706,
            143698977,
            143697149,
            143693737,
            143726859,
            143698932,
            143695817,
            143695968
        ],
        "D2": [
            143658634,
            143670285,
            143666637,
            143665499,
            143666995,
            143667409,
            143672399,
            143672413,
            143661151,
            143647661,
            143658816,
            143673791,
            143659789,
            143650476,
            143675004,
            143660718,
            143676678,
            143684084,
            143660907
        ],
        "D1": [
            143652051,
            143661015,
            143649637,
            143665355,
            143640835,
            143647447,
            143672291,
            143669534,
            143658393,
            143632054,
            143652557,
            143673638,
            143659662,
            143650805,
            143669620,
            143647751,
            143667415,
            143668369,
            143654580
        ],
        "C": [
            143648600,
            143653504,
            143662609,
            143671130,
            143659087,
            143671994,
            143662240,
            143665901,
            143679854,
            143654744,
            143666734,
            143658744,
            143650933,
            143640762,
            143660335,
            143673771,
            143662259,
            143663580,
            143684690
        ],
        "B": [
            143641041,
            143647996,
            143687560,
            143645776,
            143664691,
            143661275,
            143640613,
            143649322,
            143664737,
            143644329,
            143690738,
            143695054,
            143657006,
            143653454,
            143666253,
            143657114,
            143649062,
            143668019
        ],
        "A": [
            143633679,
            143636764,
            143632428,
            143638866,
            143635799,
            143637277,
            143632341,
            143633434,
            143635604,
            143658928,
            143634190,
            143633884,
            143633848,
            143634819,
            143640442,
            143650623,
            143643930,
            143639364,
            143636998
        ]
    },
    "name": "B. Peculiar Movie Preferences",
    "statement": "You are given a list s of n non-empty strings of length , representing\r\nthe scenes of Mihai\u2019s movie.A subsequence of s is called if it is\r\nnon-empty and the concatenation of the strings in the subsequence, in\r\norder, is a palindrome.Can you help Mihai check if there is at least one\r\nawesome subsequence of s?A palindrome is a string that reads the same\r\nbackward as forward, for example strings \"\", \"\", \"\", \"\" are palindromes,\r\nbut strings \"\", \"\", \"\" are not.A sequence a is a non-empty subsequence\r\nof a non-empty sequence b if a can be obtained from b by deletion of\r\nseveral (possibly zero, but not all) elements.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 22.01.2022 17:44:36       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<string> s(n);\n    for (int i = 0; i < n; i++) {\n      cin >> s[i];\n    }\n    bool ok = false;\n    for (int i = 0; i < n; i++) {\n      if (s[i] == string(s[i].rbegin(), s[i].rend())) {\n        ok = true;\n        break;\n      }\n    }\n    if (ok) {\n      cout << \"YES\" << '\\n';\n      continue;\n    }\n    set<string> p;\n    for (int i = 0; i < n; i++) {\n      string x(s[i].rbegin(), s[i].rend());\n      string y(s[i].rbegin(), prev(s[i].rend()));\n      if (p.find(x) != p.end() || p.find(y) != p.end()) {\n        ok = true;\n        break;\n      }\n      p.insert(s[i]);\n    }\n    if (!ok) {\n      p.clear();\n      for (int i = n - 1; i >= 0; i--) {\n        string x(next(s[i].rbegin()), s[i].rend());\n        if (p.find(x) != p.end()) {\n          ok = true;\n          break;\n        }\n        p.insert(s[i]);\n      }\n    }\n    cout << (ok ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Peculiar Movie Preferences.json",
    "editorial_link": "https://codeforces.com//blog/entry/99276",
    "editorial": "Because of the low constraints on the lengths of the strings, we can\r\nprove that it\u00e2\u0080\u0099s enough to pair at most strings to form a\r\npalindrome.<proof only checking pairs is enough>Let\u00e2\u0080\u0099s assume there is a\r\nawesome subsequence of the form xyz where x and z are single strings\r\nfrom s, and y is anything. If x and z are the same length, they clearly\r\nhave to be reverses of each other for xyz to be a palindrome, so y is\r\nnot needed to make it a palindrome. If they are not the same length, one\r\nof them is of length 3 and the other is of length 2. Assume x is the\r\nstring of length 3 and y is the string of length 2. The first two\r\ncharacters of x must be the reverse of z. If x and z are concatenated,\r\nthe third character of x is in the middle, so it doesn\u00e2\u0080\u0099t matter. So in\r\nthis case too, y is not needed. This proves that if any awesome\r\nsubsequence exists, there also exists an awesome subsequence of 1 or 2\r\nstrings.<proof ends>So, we first check if there exists a palindrome\r\nalready, if there is, we found a solution! If not, checking for each\r\npair would take too long, but we can do it much more efficiently. We can\r\nassume that all strings are of length or since if there was a string of\r\nlength it would be a palindrome and we would have found the solution\r\nearlier. For each string of length it\u00e2\u0080\u0099s enough to check if before it, we\r\nhave seen a string of the following forms: its reverse or its reverse\r\nwith a character appended to it (so a string of length ), since the last\r\ncharacter of a string of length would be the middle character of the\r\npalindrome obtained after concatenation.For each string of length it\u00e2\u0080\u0099s\r\nenough to check if before it, we have seen a string of the following\r\nforms: its reverse or the reverse of the string without considering the\r\nfirst character (so a string of length ), since the first character of a\r\nstring of length would be the middle character of the palindrome\r\nobtained after concatenation.All this can be checked using a frequency\r\nmatrix, map, set or other data structures.\r\n"
}