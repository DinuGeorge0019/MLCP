{"link": "https://codeforces.com//contest/542/problem/D", "problemId": "27152", "problem_idx": "D", "shortId": "542D", "contest_number": "542", "problem_submissions": {"E": [10988594, 10988662, 10988040, 10988519, 10989472, 10986646, 10986386, 10987525, 10987889, 10997446, 10987208, 10988323, 10987814], "A": [10988183, 10988073, 10988917, 10988039, 10988066, 10988030, 10988339, 10987042, 10988676, 10988761, 10989522, 10985841, 10987459, 10994455], "D": [10986695, 10987150, 10987152, 10986150, 10986231, 10986943, 10990837, 10988365, 10989849, 10993982, 11035792, 11035777, 11035767, 11035727, 10990386, 10992159, 10990340, 10990120, 10987703, 10987627], "F": [10986005, 10986369, 10987577, 10990309, 10986553, 10985927, 10987236, 10985531, 10987038, 10986965, 10986721, 10986640, 10986454, 10985938, 10985827, 10985838, 10986342, 10986368], "C": [10985518, 10985721, 10985435, 10985462, 10985406, 10986200, 10986782, 10986530, 10985521, 10986222, 10986134, 10985353, 10985405, 10985560, 10985649, 10985787], "B": [10996302, 11060742, 11054057]}, "name": "D. Superhero s Job", "statement": "It\u2019s tough to be a superhero. And it\u2019s twice as tough to resist the\r\nsupervillain who is cool at math. Suppose that you\u2019re an ordinary Batman\r\nin an ordinary city of Gotham. Your enemy Joker mined the building of\r\nthe city administration and you only have several minutes to neutralize\r\nthe charge. To do that you should enter the cancel code on the bomb\r\ncontrol panel.However, that mad man decided to give you a hint. This\r\nmorning the mayor found a playing card under his pillow. There was a\r\nline written on the card:The bomb has a note saying \"\", where is some\r\npositive integer. You suspect that the cancel code is some integer that\r\nmeets the equation . Now in order to decide whether you should\r\nneutralize the bomb or run for your life, you\u2019ve got to count how many\r\ndistinct positive integers meet this equation.\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1000100;\n\nll A;\nvector <ll> pfac;\nvector <int> pcnt;\nll fac[MAXN];\nll dp[MAXN];\nint nfac;\nmap <ll, int> dloc;\nbool prime[MAXN];\n\nbool cprime (ll x)\n{\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            return false;\n        }\n    return true;\n}\n\nvoid factorise()\n{\n    ll x = A;\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            int cnt = 0;\n            while (x % i == 0)\n            {\n                x /= i;\n                cnt++;\n            }\n            \n            pfac.push_back (i);\n            pcnt.push_back (cnt);\n        }\n    \n    if (x > 1)\n    {\n        pfac.push_back (x);\n        pcnt.push_back (1);\n    }\n    \n    nfac = 1;\n    for (int i = 0; i < pcnt.size(); i++)\n    {\n        //cout << pfac[i] << \" \" << pcnt[i] << \"\\n\";\n        nfac *= (pcnt[i] + 1);\n    }\n    \n    for (int i = 0; i < nfac; i++)\n    {\n        ll res = 1;\n        \n        int tval = i;\n        for (int j = 0; j < pcnt.size(); j++)\n        {\n            int c = tval % (pcnt[j] + 1);\n            tval /= pcnt[j] + 1;\n            \n            for (int k = 0; k < c; k++)\n                res *= pfac[j];\n        }\n        \n        fac[i] = res;\n        dloc[res] = i;\n    }\n}\n\nbool cpow (ll x)\n{\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            while (x % i == 0)\n                x /= i;\n            return x == 1;\n        }\n    return true;\n}\n\nvector <ll> cposs;\n\nvoid run() // run dp on cposs\n{\n    for (int i = 0; i < nfac; i++)\n    {\n        for (int j = 0; j < cposs.size(); j++)\n        {\n            ll cval = cposs[j];\n            if (fac[i] % cval == 0)\n            {\n                int nloc = dloc[fac[i] / cval];\n                dp[nloc] += dp[i];\n            }\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> A;\n    factorise();\n    \n    for (int i = 0; i < nfac; i++)\n        dp[i] = 0;\n    dp[nfac-1] = 1;\n    \n    for (int i = 0; i < MAXN; i++)\n        prime[i] = true;\n    prime[0] = prime[1] = false;\n    \n    for (int i = 2; i * i < MAXN; i++)\n    {\n        if (prime[i])\n            for (int j = i * i; j < MAXN; j += i)\n                prime[j] = false;\n    }\n    \n    //for (int i = 0; i < nfac; i++)\n    //    cout << fac[i] << \"\\n\";\n    \n    for (int i = 2; i < MAXN; i++)\n    {\n        if (prime[i])\n        {\n            ll cval = i;\n            \n            cposs.clear();\n            while (cval < A)\n            {\n                if (dloc.find(cval + 1) != dloc.end())\n                    cposs.push_back (cval + 1);\n                cval *= i;\n            }\n            \n            if (cposs.size() > 0)\n                run();\n        }\n    }\n    \n    for (int i = 0; i < nfac; i++)\n    {\n        if (fac[i] > MAXN && cprime (fac[i] - 1))\n        {\n            cposs.clear();\n            cposs.push_back (fac[i]);\n            run ();\n        }\n    }\n    \n    cout << dp[0] << \"\\n\";\n    return 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "hashing", "math", "number theory"], "dificulty": "2600", "interactive": false}