{
    "link": "https://codeforces.com//contest/1434/problem/A",
    "problemId": "773398",
    "problem_idx": "A",
    "shortId": "1434A",
    "contest_number": "1434",
    "problem_submissions": {
        "E": [
            96677024,
            96703305,
            96695061,
            105543081,
            96703526,
            96698372
        ],
        "C": [
            96660091,
            96659353,
            96663643,
            96664995,
            96666231,
            96665833,
            96660295,
            96665975,
            96667697,
            96663270,
            96667899,
            96671631,
            96669472,
            96667880,
            96663509,
            96656865,
            96675583,
            96671215,
            96671994,
            96665979
        ],
        "B": [
            96653756,
            96655206,
            96656896,
            96653660,
            96657305,
            96660070,
            96656102,
            96658196,
            96659133,
            96653643,
            96661876,
            96658486,
            96660839,
            96661406,
            96658185,
            96654001,
            96679983,
            96658727,
            96658564,
            96660622
        ],
        "A": [
            96649454,
            96650673,
            96653179,
            96660619,
            96651935,
            96654803,
            96651530,
            96652454,
            96653264,
            96657461,
            96658652,
            96653143,
            96656680,
            96654396,
            96655185,
            96650897,
            96672264,
            96652811,
            96654828,
            96652745
        ],
        "D": [
            96673411,
            96677110,
            96683665,
            96678842,
            96678338,
            96679519,
            96679771,
            96683979,
            96680244,
            96683615,
            96681902,
            96685151,
            96688093,
            96669235,
            96686214,
            96686134,
            96682142
        ]
    },
    "name": "A. Perform Easily",
    "statement": "After battling Shikamaru, Tayuya decided that her flute is too\r\npredictable, and replaced it with a guitar. The guitar has 6 strings and\r\nan infinite number of frets numbered from 1. Fretting the fret number j\r\non the i-th string produces the note a_{i} + j.Tayuya wants to play a\r\nmelody of n notes. Each note can be played on different string-fret\r\ncombination. The easiness of performance depends on the difference\r\nbetween the maximal and the minimal indices of used frets. The less this\r\ndifference is, the easier it is to perform the technique. Please\r\ndetermine the minimal possible difference.For example, if a = [1, 1, 2,\r\n2, 3, 3], and the sequence of notes is 4, 11, 11, 12, 12, 13, 13\r\n(corresponding to the second example), we can play the first note on the\r\nfirst string, and all the other notes on the sixth string. Then the\r\nmaximal fret will be 10, the minimal one will be 3, and the answer is\r\n10 - 3 = 7, as shown on the picture.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 25.10.2020 14:04:52       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n = 6;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  int m;\n  cin >> m;\n  vector<int> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  vector<vector<int>> x(m, vector<int>(n));\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      x[i][j] = b[i] - a[j];\n    }\n    sort(x[i].begin(), x[i].end());\n  }\n  vector<pair<int, int>> p;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      p.emplace_back(x[i][j], i);\n    }\n  }\n  sort(p.begin(), p.end());\n  multiset<int> s;\n  for (int i = 0; i < m; i++) {\n    s.insert(x[i][0]);\n  }\n  vector<int> ptr(m, 0);\n  int ans = (int) 2e9;\n  {\n    int mn = *s.begin();\n    int mx = *prev(s.end());\n    ans = min(ans, mx - mn);\n  }\n  for (auto& q : p) {\n    int i = q.second;\n    s.erase(s.find(x[i][ptr[i]]));\n    ++ptr[i];\n    if (ptr[i] == n) {\n      break;\n    }\n    s.insert(x[i][ptr[i]]);\n    int mn = *s.begin();\n    int mx = *prev(s.end());\n    ans = min(ans, mx - mn);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Perform Easily.json",
    "editorial_link": "https://codeforces.com//blog/entry/84056",
    "editorial": "Consider all possible frets we may need to use. To do this we sort all the pairs (bj?ai,j)\n lexicographically. Now we need to find a subsegment with the minimal range containing the first fields and also so that all numbers from 1\n to n\n occur among the second fields (so it will mean that for each note there is at least one string-fret combination).\n\nFor each l\n, denote the minimal right(l)\n so that [l,right(l)]\n is a valid subsegment. It's easy to see that right(l)?right(l+1)\n, because if [l+1,right(l+1)]\n contains all numbers from 1\n to n\n among the second fields, then so does [l,right(l+1)]\n. So to find all right(l)\n one can just use two pointers, maintaining the set of notes that occur on the segment.\n\nOnce we calculated it, we just print the minimal difference between the first fields of the endpoints of all possible segments [l,right(l)]\n. The final complexity is O(nmlog(nm))\n."
}