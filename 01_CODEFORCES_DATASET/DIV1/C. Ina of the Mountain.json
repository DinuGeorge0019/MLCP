{
    "link": "https://codeforces.com//contest/1852/problem/C",
    "problemId": "2099134",
    "problem_idx": "C",
    "shortId": "1852C",
    "contest_number": "1852",
    "problem_submissions": {
        "F": [
            215258181,
            215285692,
            217509901,
            217509714
        ],
        "E": [
            215240027,
            215239122,
            215243644,
            215243658,
            215248799,
            215245960,
            215237098,
            215240727,
            215296441,
            215327365,
            215336328,
            217901271,
            215247415
        ],
        "D": [
            215222100,
            215222081,
            215222261,
            215225730,
            215218775,
            215382147,
            215226776,
            215250750,
            215250174,
            215230611,
            215232642,
            215226731,
            215232589,
            215240152,
            215237043,
            215236182,
            215239579,
            215241752,
            215242725
        ],
        "C": [
            215209363,
            215208759,
            215214250,
            215220833,
            215208505,
            215217394,
            215219756,
            215218376,
            215205472,
            215208510,
            215213920,
            215221691,
            215216406,
            215223920,
            215226652,
            215216927,
            215221642,
            215210662,
            215212429
        ],
        "B": [
            215201282,
            215200579,
            215202726,
            215199335,
            215200474,
            215207713,
            215208166,
            215202505,
            215214027,
            215200003,
            215206319,
            215205331,
            215204344,
            215212727,
            215206313,
            215209315,
            215209426,
            215199777,
            215204560
        ],
        "A": [
            215201184,
            215192031,
            215194261,
            215194419,
            215219859,
            215194029,
            215260286,
            215197669,
            215196351,
            215192202,
            215192228,
            215192416,
            215194163,
            215196399,
            215195136,
            215198712,
            215191998,
            215201193,
            215192233,
            215195682
        ]
    },
    "name": "C. Ina of the Mountain",
    "statement": "There are n octopuses on a single-file trail on Ina’s mountain, numbered\r\n1, 2,\r\nldots, n. The i-th octopus has a certain initial health value a_i, where\r\n1\r\nleq a_i\r\nleq k.Each boulder crushes consecutive octopuses with indexes l, l+1,\r\nldots, r, where 1\r\nleq l\r\nleq r\r\nleq n. You can choose the numbers l and r arbitrarily for each\r\nboulder.For each boulder, the health value of each octopus the boulder\r\ncrushes is reduced by 1. However, as octopuses are immortal, once they\r\nreach a health value of 0, they will immediately regenerate to a health\r\nvalue of k. Given the octopuses’ initial health values, find the number\r\nof boulders that need to be thrown to make the health of all octopuses\r\nequal to k.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n + 2);\n    std::priority_queue<i64, std::vector<i64>, std::greater<i64>> q;\n    i64 add = 0;\n    for (int i = 1; i <= n; i++) {\n        std::cin >> a[i];\n        if (a[i] == k) {\n            a[i] = 0;\n        }\n    }\n    \n    i64 ans = 0;\n    int p = 0;\n    for (int i = 1; i <= n + 1; i++) {\n        if (a[i] >= a[i - 1]) {\n            q.push(a[i] - a[i - 1]);\n        } else {\n            q.push(0);\n            q.push(k + a[i] - a[i - 1]);\n        }\n        ans += q.top();\n        q.pop();\n    }\n    \n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Ina of the Mountain.json",
    "editorial_link": "https://codeforces.com//blog/entry/116940",
    "editorial": "Problem Credits: fast-fourier-transfem Analysis: fast-fourier-transfem,\r\nEmeraldBlock, GusterGoose27 SolutionTo make things easier, replace\r\nhealth values of with health values of , so the goal is to reach health.\r\nRegeneration is now from , which was formerly , to , instead of to ,\r\nwhich is now to . For clarity, create a new array such that .Now,\r\ninstead of letting health values wrap around, we can just initially give\r\neach octopus a multiple of more health. For example, if and an octopus\r\nwith initially health regenerates twice, we can pretend it initially had\r\nhealth.Create a new array storing these new healths. Since all healths\r\nwill reach , it also represents the number of boulders that will hit\r\neach octopus.To find the minimum number of boulder throws, represent the\r\nhealth values with a histogram, where the heights of blocks are equal to\r\nthe values of :Then, erase all vertical borders between blocks. The\r\nresulting segments each represent a boulder throw:Intuitively, this\r\nshould minimize the number of boulders, since any sequence of boulder\r\nthrows should be rearrangeable into horizontal segments covering this\r\nhistogram.We can easily calculate the number of boulders as the sum of\r\nall positive adjacent differences, treating the far left and far right\r\nas having health .Formally, pad with an extra to the left and right\r\n(i.e. ) and let the adjacent differences be . We claim the minimum\r\nnumber of boulder throws is . This many is necessary, since if is\r\npositive, octopus gets crushed more times than octopus , so at least\r\nbouldersâ ranges have left endpoint . This many is achievable, as\r\ndepicted above. Crush all octopuses with the highest health exactly once\r\n(crushing consecutive octopuses with the same boulder), then all\r\noctopuses with the new highest health, and so on. Each boulderâs rangeâs\r\nleft endpoint corresponds with part of a positive adjacent difference.\r\n",
    "hint": [
        "Hint 2 Can you figure out an solution? And can you improve on it?",
        "Hint 3 Suppose you already had the optimal solution for the subarray . How could you extend it to ?"
    ]
}