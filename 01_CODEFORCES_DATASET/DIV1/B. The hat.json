{
    "link": "https://codeforces.com//contest/1019/problem/B",
    "problemId": "207014",
    "problem_idx": "B",
    "shortId": "1019B",
    "contest_number": "1019",
    "problem_submissions": {
        "D": [
            41494541,
            41486235,
            41489624,
            41496428,
            41482324,
            41485058,
            41485821,
            41503084,
            41488961,
            41490515,
            41488550,
            41488663,
            41486677,
            41490916,
            41491659,
            41491114,
            41488916,
            41491612,
            41493392
        ],
        "C": [
            41485063,
            41566656,
            41496194,
            41491682,
            41552113,
            41499582,
            41487460,
            41530705,
            41652339,
            205457358
        ],
        "A": [
            41477821,
            41473071,
            41475477,
            41477205,
            41474279,
            41472040,
            41473278,
            41472687,
            41471212,
            41472351,
            41478347,
            41474071,
            41472848,
            41472443,
            41471416,
            41473130,
            41524142,
            41480834,
            41476724,
            41472604
        ],
        "B": [
            41472593,
            41477785,
            41479330,
            41486699,
            41478688,
            41476845,
            41477610,
            41476296,
            41475985,
            41478284,
            41482245,
            41489236,
            41477340,
            41477044,
            41480533,
            41484731,
            41486696,
            41478640
        ],
        "E": [
            41541275,
            41536720,
            41496541,
            41519405,
            41505368,
            41533475
        ]
    },
    "name": "B. The hat",
    "statement": "Imur Ishakov decided to organize a club for people who love to play the\r\nfamous game The hat . The club was visited by students, where is even.\r\nImur arranged them all in a circle and held a draw to break the students\r\nin pairs, but something went wrong. The participants are numbered so\r\nthat participant and participant () are adjacent, as well as participant\r\nand participant . Each student was given a piece of paper with a number\r\nin such a way, that for every two adjacent students, these numbers\r\ndiffer exactly by one. The plan was to form students with the same\r\nnumbers in a pair, but it turned out that not all numbers appeared\r\nexactly twice.As you know, the most convenient is to explain the words\r\nto the partner when he is sitting exactly across you. Students with\r\nnumbers and sit across each other. Imur is wondering if there are two\r\npeople sitting across each other with the same numbers given. Help him\r\nto find such pair of people if it exists.You can ask questions of form\r\nwhich number was received by student ? , and the goal is to determine\r\nwhether the desired pair exists in no more than questions.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint n;\nint ask(int x){\n  cout << \"? \" << x << endl;\n  cout << \"? \" << x + n / 2 << endl;\n  int a,b;\n  cin >> a >> b;\n  if(a == b){\n    cout << \"! \" << x << endl;\n    exit(0);\n  }\n  return a < b;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  if(n % 4 == 2){\n    cout << \"! -1\\n\";\n    return 0;\n  }\n  int po = 1;\n  int ko = 1 + n/2;\n  int jak = ask(1);\n  while(1){\n    int m = (po + ko) / 2;\n    if(ask(m) == jak){\n      po = m;\n    }else{\n      ko = m;\n    }\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "interactive"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. The hat.json",
    "editorial_link": "https://codeforces.com//blog/entry/61161",
    "editorial": "Let be a number given to the -th student. Letâs introduce function . As\r\nis even, is integer, and is defined correctly. Notice two facts: first,\r\n, and second, . The problem is to find an such that . Second note leads\r\nus to observation that all have the same oddity. So, letâs find , and if\r\nit is odd, then there is no answer, and we need to print all have the\r\nsame oddity (odd), and zero, as a number of different oddity, wonât\r\nappear in .Otherwise, suppose we know , and it is equal to (without loss\r\nof generality ). Notice that . As we remember from second observation\r\nthat all have the same oddity, and neighboring numbers differ by no more\r\nthan 2, we can use discrete continuity. Lemma: if you have two indices\r\nand with values and , then on segment between and there are all values\r\nwith the same oddity from to . Indeed, as neighboring differ by no more\r\nthan 2, we couldnât skip any number with the same oddity.Now we can use\r\na binary search. At the start , , and values and are even numbers with\r\nthe different signs. By lemma, on segment between and there is a zero\r\nthat we want to find. Letâs take . If , we found the answer. Otherwise,\r\nbased on sign of we can replace one of , in binary search to , and\r\nreduce the problem to the same with smaller size. There will be no more\r\nthan iterations, and as calculation of requires two queries, we solved\r\nthe problem in queries.\r\n",
    "hint": []
}