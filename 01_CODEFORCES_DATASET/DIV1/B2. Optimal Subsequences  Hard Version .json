{
    "link": "https://codeforces.com//contest/1261/problem/B2",
    "problemId": "479747",
    "problem_idx": "B2",
    "shortId": "1261B2",
    "contest_number": "1261",
    "problem_submissions": {
        "F": [
            65647116,
            65658053,
            65657980,
            65657931,
            65651526,
            65649568,
            65649392,
            65651843,
            65651789,
            65643329,
            65715623,
            65660068,
            66569502,
            66569457,
            66569446,
            66563643,
            66529592,
            66529450,
            66529001,
            66528877,
            66527265,
            66527166,
            202179447,
            65759590,
            65736891,
            65656177,
            65801900,
            65656900,
            65653812
        ],
        "E": [
            65640839,
            65636308,
            65639924,
            65632814,
            65644428,
            65645126,
            65649634,
            65644543,
            65648074,
            65645492,
            65646710,
            65643401,
            65649412,
            65647298,
            65649626,
            65646791,
            65647214,
            65650131,
            65673025
        ],
        "D2": [
            65637210,
            65632855,
            65635634,
            65636824,
            65639345,
            65639544,
            65635456,
            65639090,
            65637689,
            65685918,
            65636623,
            65641288,
            65630575,
            65640353,
            65641640,
            65638704,
            65642981,
            65642369,
            65636523,
            65640625
        ],
        "D1": [
            65637138,
            65632929,
            65635559,
            65636922,
            65639374,
            65639684,
            65633638,
            65639276,
            65637859,
            65636779,
            65641185,
            65630619,
            65640390,
            65641739,
            65638754,
            65643069,
            65642429,
            65636584,
            65639802
        ],
        "C": [
            65632448,
            65642046,
            65632919,
            65640324,
            65637319,
            65636062,
            65629189,
            65635829,
            65634638,
            65686469,
            65686406,
            65686240,
            65686235,
            65686196,
            65686121,
            65686065,
            65686054,
            65686032,
            65685983,
            65685973,
            65685956,
            65633182,
            65639316,
            65636734,
            65647142,
            65634479,
            65636999,
            65635515,
            65637442,
            65637462,
            65658341,
            65640232,
            65635038
        ],
        "B1": [
            65629099,
            65627296,
            65628841,
            65642477,
            65630053,
            65629451,
            65645427,
            65631701,
            65629375,
            65639182,
            65631034,
            65637262,
            65630223,
            65630435,
            65630786,
            65631879,
            65632451,
            65627736,
            65630111
        ],
        "B2": [
            65629029,
            65627239,
            65628722,
            65642378,
            65629995,
            65629248,
            65645596,
            65631497,
            65629280,
            65720078,
            65685862,
            65639011,
            65631167,
            65637207,
            65630166,
            65630277,
            65630671,
            65631817,
            65632276,
            65627619,
            65630224
        ],
        "A": [
            65626424,
            65626236,
            65626313,
            65643924,
            65627202,
            65627360,
            65650514,
            65628121,
            65627165,
            65626869,
            65627525,
            65634172,
            65626632,
            65626977,
            65627953,
            65628262,
            65627833,
            65631529,
            65627297
        ]
    },
    "name": "B2. Optimal Subsequences  Hard Version ",
    "statement": "You are given a sequence of integers a=[a_1,a_2,\r\ndots,a_n] of length n. Its is obtained by removing zero or more elements\r\nfrom the sequence a (they do not necessarily go consecutively). For\r\nexample, for the sequence a=[11,20,11,33,11,20,11]:\r\n[11,20,11,33,11,20,11], [11,20,11,33,11,20], [11,11,11,11], [20],\r\n[33,20] are subsequences (these are just some of the long list); [40],\r\n[33,33], [33,20,20], [20,20,11,11] are not subsequences. Suppose that an\r\nadditional non-negative integer k (1\r\nle k\r\nle n) is given, then the subsequence is called if: it has a length of k\r\nand the sum of its elements is the maximum possible among all\r\nsubsequences of length k; and among all subsequences of length k that\r\nsatisfy the previous item, it is minimal. Recall that the sequence\r\nb=[b_1, b_2,\r\ndots, b_k] is lexicographically smaller than the sequence c=[c_1, c_2,\r\ndots, c_k] if the first element (from the left) in which they differ\r\nless in the sequence b than in c. Formally: there exists t (1\r\nle t\r\nle k) such that b_1=c_1, b_2=c_2, ..., b_{t-1}=c_{t-1} and at the same\r\ntime b_t<c_t. For example: [10, 20, 20] lexicographically less than [10,\r\n21, 1], [7, 99, 99] is lexicographically less than [10, 21, 1], [10, 21,\r\n0] is lexicographically less than [10, 21, 1]. You are given a sequence\r\nof a=[a_1,a_2,\r\ndots,a_n] and m requests, each consisting of two numbers k_j and pos_j\r\n(1\r\nle k\r\nle n, 1\r\nle pos_j\r\nle k_j). For each query, print the value that is in the index pos_j of\r\nthe optimal subsequence of the given sequence a for k=k_j.For example,\r\nif n=4, a=[10,20,30,20], k_j=2, then the optimal subsequence is [20,30]\r\nit is the minimum lexicographically among all subsequences of length 2\r\nwith the maximum total sum of items. Thus, the answer to the request\r\nk_j=2, pos_j=1 is the number 20, and the answer to the request k_j=2,\r\npos_j=2 is the number 30.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass node {\n public:\n  int cnt = 0;\n  int val = 0;\n  \n  void apply(int l, int r, int v) {\n    cnt = 1;\n    val = v;\n  }\n};\n\nclass segtree {\n public:\n  vector<node> tree;\n  int n;\n\n  node unite(const node &l, const node &r) {\n    node res;\n    res.cnt = l.cnt + r.cnt;\n    return res;\n  }\n\n  segtree(int n): n(n) {\n    tree.resize(n * 2 - 1);\n  }\n\n  void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  void push(int x, int l, int r) {\n    int y = (l + r) >> 1, z = x + ((y - l + 1) << 1);\n    /*\n    if (tree[x].tag) {\n      tree[x + 1].apply(l, y, tree[x].tag);\n      tree[z].apply(y + 1, r, tree[x].tag);\n      tree[x].tag = 0;\n    }\n    */\n  }\n\n  void build(int x, int l, int r) {\n    if (l != r) {\n      int y = (l + r) >> 1, z = x + ((y - l + 1) << 1);\n      build(x + 1, l, y);\n      build(z, y + 1, r);\n      pull(x, z);\n    }\n  }\n\n  template<typename T>\n  void build(int x, int l, int r, const vector<T> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n    } else {\n      int y = (l + r) >> 1, z = x + ((y - l + 1) << 1);\n      build(x + 1, l, y, v);\n      build(z, y + 1, r, v);\n      pull(x, z);\n    }\n  }\n\n  template<typename... T>\n  void modify(int x, int l, int r, int ll, int rr, const T&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n    } else {\n      int y = (l + r) >> 1, z = x + ((y - l + 1) << 1);\n      push(x, l, r);\n      if (ll <= y) {\n        modify(x + 1, l, y, ll, rr, v...);\n      }\n      if (rr > y) {\n        modify(z, y + 1, r, ll, rr, v...);\n      }\n      pull(x, z);\n    }\n  }\n\n  int query(int x, int l, int r, int k) {\n    if (l == r) {\n      return tree[x].val;\n    } else {\n      int y = (l + r) >> 1, z = x + ((y - l + 1) << 1);\n      if (tree[x + 1].cnt >= k) {\n        return query(x + 1, l, y, k);\n      } else {\n        return query(z, y + 1, r, k - tree[x + 1].cnt);\n      }\n    }\n  }\n\n  void build() {\n    build(0, 0, n - 1);\n  }\n\n  template<typename T>\n  void build(const vector<T> &v) {\n    build(0, 0, n - 1, v);\n  }\n\n  template<typename... T>\n  void modify(int l, int r, const T&... v) {\n    modify(0, 0, n - 1, l, r, v...);\n  }\n\n  int query(int k) {\n    return query(0, 0, n - 1, k);\n  }\n};\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<pair<int, int>> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i].first;\n    a[i].first *= -1;\n    a[i].second = i;\n  }\n  sort(a.begin(), a.end());\n  int m;\n  cin >> m;\n  vector<vector<pair<int, int>>> queries(n);\n  vector<int> ans(m);\n  for (int i = 0; i < m; ++i) {\n    int foo, bar;\n    cin >> foo >> bar;\n    queries[foo - 1].emplace_back(bar, i);\n  }\n  segtree seg(n);\n  for (int i = 0; i < n; ++i) {\n    seg.modify(a[i].second, a[i].second, -a[i].first);\n    for (auto p : queries[i]) {\n      ans[p.second] = seg.query(p.first);\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    cout << ans[i] << \"\\n\";\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B2. Optimal Subsequences  Hard Version .json",
    "editorial_link": "https://codeforces.com/blog/entry/71740",
    "editorial": "Letâs first solve the simplified version (Easy Version) without paying\r\nattention to the efficiency of the algorithm.It is clear that the sum of\r\nthe elements of the optimal subsequence is equal to the sum of maximal\r\nelements of the sequence . Let the smallest (the -th) of maximal\r\nelements be . Obviously, all elements of that are greater than and\r\nseveral elements that are equal to will be included in the optimal\r\nsubsequence. Among all the elements that are equal to you need to choose\r\nthose that are located to the left. Thus, a simplified version solution\r\nmight look like this: in order to build an optimal subsequence of length\r\n, take an array and construct its copy sorted by non-increasing: ; let ;\r\nwe take the following subsequence from : all the elements and several\r\nleftmost occurrences of (you need to take such occurrences in order to\r\nget exactly elements in total). To solve the complicated version, we\r\nnote that the solution above is equivalent to sorting all elements of\r\nfirst of all by value (non-increasing), and secondly by position\r\n(ascending). The desired optimal subsequence is simply first elements of\r\nin this order.To quickly process requests, we will use the opportunity\r\nto read all requests in the program, sort them by and process them in\r\nthat order. Then, in order to answer the request , you need to take\r\nelements in this order and choose the -th from them (just in the order\r\nof indices). Thus, the problem is reduced to finding the -th element in\r\na set, where only elements are added. This can be solved using a wide\r\nrange of data structures (a tree of segments, a Fenwick tree, even\r\nsqrt-compositions), and using a non-standard tree built into g++ that\r\nsupports the operation \"quickly find the th element of a set\". Below is\r\nthe solution code:\r\n",
    "hint": []
}