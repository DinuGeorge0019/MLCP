{
    "link": "https://codeforces.com//contest/1819/problem/A",
    "problemId": "1880618",
    "problem_idx": "A",
    "shortId": "1819A",
    "contest_number": "1819",
    "problem_submissions": {
        "E": [
            202225318,
            202223532,
            202223484,
            202225560,
            202308964,
            202224265,
            202225112,
            202221853,
            202253482,
            202237435,
            203635743,
            203096948,
            202225859,
            202369794
        ],
        "D": [
            202209352,
            202212141,
            202205538,
            202220831,
            202198559,
            202210822,
            202236119,
            202239190,
            202212242,
            202208889,
            202205391,
            202216800,
            203995136,
            202197649,
            202216978,
            202217768,
            202220492,
            202220964,
            202225376,
            202219172
        ],
        "C": [
            202201042,
            202203020,
            202193305,
            202202657,
            202190230,
            202199701,
            202199472,
            202200745,
            202199789,
            202199523,
            208251329,
            202218422,
            202204297,
            202216624,
            202204671,
            202205053,
            202201997,
            202201056,
            202198992
        ],
        "B": [
            202193365,
            202195322,
            202214813,
            202196120,
            202186520,
            202187817,
            202188682,
            202193750,
            202186708,
            202188527,
            202188957,
            202183110,
            202191595,
            202187157,
            202193385,
            202195604,
            202188109,
            202186084,
            202189411
        ],
        "A": [
            202182367,
            202180872,
            202181217,
            202181093,
            202180590,
            202180859,
            202181832,
            202181960,
            202180690,
            202180596,
            202180602,
            202180463,
            202182678,
            202180651,
            202182633,
            202181119,
            202181593,
            202180899,
            202180615
        ],
        "F": [
            202939012,
            206043011
        ]
    },
    "name": "A. Constructive Problem",
    "statement": "As you know, any problem that does not require the use of complex data\r\nstructures is considered constructive. You are offered to solve one of\r\nsuch problems.You are given an array a of n non-negative integers. You\r\nare allowed to perform the following operation : choose some non-empty\r\nsubsegment a_l, a_{l+1},\r\nldots, a_r of the array a and a non-negative integer k, and assign value\r\nk to all elements of the array on the chosen subsegment.The task is to\r\nfind out whether\r\noperatorname{MEX}(a) can be increased by exactly one by performing such\r\nan operation. In other words, if before the operation\r\noperatorname{MEX}(a) = m held, then after the operation it must hold\r\nthat\r\noperatorname{MEX}(a) = m + 1.Recall that\r\noperatorname{MEX} of a set of integers c_1, c_2,\r\nldots, c_k is defined as the smallest non-negative integer x which does\r\nnot occur in the set c.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n\n#define ll long long\n#define int ll\n#define ull unsigned ll\n#define ld long double\n#define rep(a) rep1(i,a)\n#define rep1(i,a) rep2(i,0,a)\n#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)\n#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)\n#define chkmin(a,b) (a=min(a,b))\n#define chkmax(a,b) (a=max(a,b))\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int>\n#define pb push_back\n#define eb emplace_back\n#define sort_unique(a) sort(all(a)),a.resize(unique(all(a))-a.begin())\n//#define inf 1010000000\n#define inf 4000000000000000000\n#define eps 1e-9\n#define sz(a) ((int)a.size())\n#define pow2(x) (1ll<<(x))\n#define ceiling(a,b) (((a)+(b)-1)/(b))\n#define print0(a) cout << (a) << ' '\n#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#ifdef i_am_noob\n#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)\ntemplate<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(T && x) {cerr << x << endl;}\ntemplate<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}\n#else\n#define bug(...) 777771449\n#endif\ntemplate<typename T> void print(T && x) {cout << x << \"\\n\";}\ntemplate<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\n\nconst int Mod=1000000007,Mod2=998244353;\nconst int MOD=Mod2;\ntemplate <int mod>\nstruct Modint{\n    int val;\n    Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}\n    Modint operator +(const Modint& o) const {\n        Modint res;\n        res.val=val+o.val;\n        if(res.val>=mod) res.val-=mod;\n        return res;\n    }\n    Modint operator +(const int& o) const {return Modint(val+o);}\n    Modint operator -() const {\n        Modint res;\n        res.val=-val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const Modint& o) const {\n        Modint res;\n        res.val=val-o.val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const int& o) const {return Modint(val-o);}\n    Modint operator *(const Modint& o) const {return Modint(val*o.val);}\n    Modint operator *(const int& o) const {return Modint(val*(o%mod));}\n    Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}\n    Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}\n    Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}\n    Modint Pow(int b) const {\n        Modint tmp(val),ret(1);\n        while(b){\n            if(b&1) ret*=tmp;\n            b>>=1;tmp*=tmp;\n        }\n        return ret;\n    }\n    Modint Pow(const Modint& a, int b) const {return a.Pow(b);}\n    inline Modint inv() const {return (*this).Pow(mod-2);}\n    Modint operator /(const Modint& o) const {return *this*o.inv();}\n    Modint operator /(const int& o) const {return *this*Modint(o).inv();}\n    bool operator ==(const Modint& o) const {return val==o.val;}\n};\ntemplate<int mod>\nostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}\ntemplate<int mod>\nModint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}\ntemplate<int mod>\nModint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}\ntemplate<int mod>\nModint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}\n#define modint Modint<MOD>\nvector<modint> inv,fac,invfac;\nvoid init_comb(int N){\n    inv.resize(N),fac.resize(N),invfac.resize(N);\n    inv[1]=1,fac[0]=1,invfac[0]=1;\n    rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);\n    rep2(i,1,N) fac[i]=fac[i-1]*i;\n    rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];\n}\ninline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}\ninline modint H(int n, int m){return C(n+m-1,n);}\n\nconst int maxn=200005,maxm=pow2(17),maxk=7777714;\n\n//i_am_noob\n#define wiwihorz  \nvoid balbitorz(){}\nint n,a[maxn],b[maxn],mex;\nbool vis[maxn];\n\nvoid orzck(){\n    cin >> n;\n    rep(n) cin >> a[i],b[i]=a[i];\n    sort(b,b+n);\n    if(b[0]) mex=0;\n    else{\n        bool flag=0;\n        rep(n-1) if(b[i+1]-b[i]>=2){\n            mex=b[i]+1;\n            flag=1;\n            break;\n        }\n        if(!flag) mex=b[n-1]+1;\n    }\n    int l=n,r=-1;\n    rep(n) if(a[i]==mex+1) chkmin(l,i),chkmax(r,i);\n    rep(mex) vis[i]=0;\n    rep(n) if(i<l||i>r) if(a[i]<mex) vis[a[i]]=1;\n    if(mex==n){\n        print(\"No\");\n        return;\n    }\n    if(r<0){\n        print(\"Yes\");\n        return;\n    }\n    rep(mex) if(!vis[i]){\n        print(\"No\");\n        return;\n    }\n    print(\"Yes\");\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    // #ifdef i_am_noob\n    // freopen(\"input1.txt\",\"r\",stdin);\n    // freopen(\"output1.txt\",\"w\",stdout);\n    // freopen(\"output2.txt\",\"w\",stderr);\n    // #endif\n    cout << fixed << setprecision(15);\n    ld start=clock();\n    balbitorz();\n    int t;\n    #ifdef wiwihorz\n    cin >> t;\n    #else\n    t=1;\n    #endif\n    while(t--) orzck();\n    bug((clock()-start)/CLOCKS_PER_SEC);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Constructive Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/115133",
    "editorial": "Let the current value of mex equal to and the value of mex after\r\nperforming operation equals to . It\u00e2\u0080\u0099s easy to see that in the resulting\r\narray there should exist element equals to (if it doesn\u00e2\u0080\u0099t exist, the\r\nvalue of mex won\u00e2\u0080\u0099t be equal to ). Also notice that should be equal to\r\nbecause this value didn\u00e2\u0080\u0099t appear in the array before the operation and\r\nmust appear there after performing the operation. Consider the following\r\ncases. If there exists such that , let\u00e2\u0080\u0099s find the minimum value and the\r\nmaximum value such that . It\u00e2\u0080\u0099s easy to see that the performed operation\r\nshould cover these elements. We already know which value of to select.\r\nNow notice that there are no profits from using longer segments because\r\nis already not greater than (there are no elements equal to ) and longer\r\nsegments may make less. If there is no such that but there exists such\r\nthat , is already not greater than . Similarly with the previous case,\r\nwe can find any such that and replace with . In all other cases if there\r\nexist two indices such that , we can replace one of these elements with\r\n. In this case we will make equals to . If there are no such indices,\r\nequals to the length of the array and we cannot increment . The only\r\nthing we have to do after considering cases is to check if the performed\r\noperation leads to correct value of .Time complexity: .\r\n"
}