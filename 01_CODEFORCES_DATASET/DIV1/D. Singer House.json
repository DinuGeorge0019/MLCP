{
    "link": "https://codeforces.com//contest/830/problem/D",
    "problemId": "114245",
    "problem_idx": "D",
    "shortId": "830D",
    "contest_number": "830",
    "problem_submissions": {
        "D": [
            28594647,
            28515632,
            28517135,
            28522787,
            28518930,
            28520136,
            28522520,
            28522651,
            28522385,
            28521029,
            28522173,
            28931336,
            28518846,
            28520792,
            28518779,
            28524006,
            28523790,
            28523582,
            28514145,
            28518855
        ],
        "E": [
            28524957,
            28527227,
            28776493,
            28776475,
            31868930,
            28528205
        ],
        "C": [
            28513312,
            28514258,
            28526449,
            28512880,
            28515933,
            28516073,
            28513800,
            28513739,
            28515967,
            28518241,
            29799228,
            29796538,
            28519327,
            28516487,
            28931386,
            28515691,
            28524374,
            28513589,
            28518503,
            28515655,
            28517033,
            28528492,
            28534968
        ],
        "B": [
            28508342,
            28509379,
            28507817,
            28511318,
            28509260,
            28508546,
            28510695,
            28510689,
            30628707,
            30615033,
            30614998,
            28512995,
            28509425,
            28513558,
            28509785,
            28511054,
            28519867,
            28511755,
            28512387,
            28511965,
            28515860,
            28511432
        ],
        "A": [
            28506433,
            28506738,
            28506322,
            28516214,
            28513064,
            28506171,
            28506332,
            28506901,
            28509003,
            28511010,
            28512266,
            28526236,
            28507144,
            28507136,
            28519649,
            28517536,
            28508069
        ]
    },
    "name": "D. Singer House",
    "statement": "It is known that passages in Singer house are complex and intertwined.\r\nLet\u2019s define a Singer -house as a graph built by the following process:\r\ntake complete binary tree of height and add edges from each vertex to\r\nall its successors, if they are not yet present. Count the number of\r\nnon-empty paths in Singer -house which do not pass the same vertex\r\ntwice. Two paths are distinct if the sets or the orders of visited\r\nvertices are different. Since the answer can be large, output it modulo\r\n.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int mo=1e9+7;\nint f[500][500],C[500][500],I[500],nI[500];\nlong long A[500];\nint n;\nint quick(int k1,int k2){\n\tint k3=1;\n\twhile (k2){\n\t\tif (k2&1) k3=1ll*k3*k1%mo; k2>>=1; k1=1ll*k1*k1%mo;\n\t}\n\treturn k3;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tf[0][0]=1;\n\tfor (int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\tI[0]=1; for (int i=1;i<=n;i++) I[i]=1ll*I[i-1]*i%mo;\n\tfor (int i=0;i<=n;i++) nI[i]=quick(I[i],mo-2);\n\tfor (int i=1;i<=n;i++){\n\t\tf[i][0]=1; memset(A,0x00,sizeof A); A[0]=1;\n\t\tfor (int j=n;j;j--)\n\t\t\tfor (int k=0;k<=j;k++)\n\t\t\t\tif (A[j]<0) A[j]+=1ll*f[i-1][k]*f[i-1][j-k];\n\t\t\t\telse A[j]+=1ll*(f[i-1][k]-mo)*f[i-1][j-k]; \n\t\tfor (int j=1;j<=n;j++) A[j]=1ll*(A[j]%mo+mo)*I[j]%mo;\n\t\tfor (int j=n;j;j--)\n\t\t\tf[i][j]=(1ll*(2*j+1)*A[j]+1ll*j*A[j+1]+1ll*j*A[j-1])%mo*nI[j]%mo;\n\t}\n\tprintf(\"%d\\n\",f[n][1]);\n\treturn 0;\n}\n\t\t\t"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Singer House.json",
    "editorial_link": "https://codeforces.com//blog/entry/53302",
    "editorial": "Compute \"what is the number of sets of non-intersecting paths in\r\n-house?\" Yes, it works. The answer is . .For updating from for each Let\r\n:Take the root, and make itself a new path .Don\u00e2\u0080\u0099t take the root .Take\r\nthe root, and connect it to a path in the left child .Take the root, and\r\nconnect it to a path in the right child .Take the root, and it combines\r\ntwo paths .Now the important fact is because we need we only need first\r\nvalues of . So the complexity is .\r\n"
}