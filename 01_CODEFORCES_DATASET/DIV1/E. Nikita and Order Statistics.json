{"link": "https://codeforces.com//contest/993/problem/E", "problemId": "190657", "problem_idx": "E", "shortId": "993E", "contest_number": "993", "problem_submissions": {"F": [39315278, 39320695, 39316458, 39677099], "E": [39303954, 44679848, 44679803, 39298654, 39318832, 39301524, 39298924, 39298197, 39302275, 39302298, 39298229, 39298156, 39300839, 39300092, 39352453, 39352393, 39352354, 39303455, 39304019, 39307250, 39300445, 39304215, 39295908, 39310154], "D": [39301603, 39306272, 39305543, 39303758, 39301872, 39306720, 39307619, 39312577, 39306349, 39308036, 39310122, 39446648, 39311312, 39310199, 39311258, 39311908, 39309211, 39312503, 41629328, 39305033], "C": [39298935, 39297300, 39298508, 39300315, 39304660, 39297439, 39298052, 39296218, 39303022, 39303419, 39304668, 39300073, 39299818, 39298805, 39302281, 39300110, 39306526, 39299493], "B": [39297062, 39295065, 39295700, 39296902, 39295145, 39299299, 39296202, 39294546, 39301730, 39301559, 39302344, 39295884, 39296798, 39301508, 39306228, 39297394, 39303701, 39296320], "A": [39295010, 39292992, 39292988, 39294233, 39305393, 39293507, 39294073, 39292365, 39300142, 39294094, 39296117, 39292842, 39294818, 39295302, 39304183, 39295611, 39298852, 39293790]}, "name": "E. Nikita and Order Statistics", "statement": "Nikita likes tasks on order statistics, for example, he can easily find\r\nthe k-th number in increasing order on a segment of an array. But now\r\nNikita wonders how many segments of an array there are such that a given\r\nnumber x is the k-th number in increasing order on this segment. In\r\nother words, you should find the number of segments of a given array\r\nsuch that there are exactly k numbers of this segment which are less\r\nthan x.Nikita wants to get answer for this question for each k from 0 to\r\nn, where n is the size of the array.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst double PI = 4 * atan(1);\n\ntypedef complex<double> cd;\n\n//const int LOG = 6;\nconst int LOG = 19;\nconst int N = 1 << LOG;\nconst int NN = N + 5;\ncd w[NN];\nint rev[NN];\nint a[NN];\nint n, x;\n\ncd A[NN], B[NN];\n\nvoid initFFT() {\n\tfor (int i = 0; i < N; i++)\n\t\tw[i] = cd(cos(2 * PI * i / N), sin(2 * PI * i / N));\n\trev[0] = 0;\n\tfor (int mask = 1; mask < N; mask++) {\n\t\tint k = 0;\n\t\twhile(((mask >> k) & 1) == 0) k++;\n\t\trev[mask] = rev[mask ^ (1 << k)] ^ (1 << (LOG - 1 - k));\n\t}\n}\n\ncd F[2][NN];\nvoid FFT(cd* A) {\n\tfor (int i = 0; i < N; i++)\n\t\tF[0][rev[i]] = A[i];\n\tint t = 0, nt = 1;\n\tfor (int lvl = 0; lvl < LOG; lvl++) {\n\t\t//cerr << lvl << endl;\n\t\tint len = 1 << lvl;\n\t\tfor (int st = 0; st < N; st += (1 << (lvl + 1)))\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tcd ad = F[t][st + len + i] * w[i << (LOG - 1 - lvl)];\n\t\t\t\tF[nt][st + i] = F[t][st + i] + ad;\n\t\t\t\tF[nt][st + len + i] = F[t][st + i] - ad;\n\t\t\t}\n\t\tswap(t, nt);\n\t}\n\tfor (int i = 0; i < N; i++)\n\t\tA[i] = F[t][i];\n}\n\nll ans[NN];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tinitFFT();\n\n\tint x;\n\tscanf(\"%d%d\", &n, &x);\n\ta[0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint y;\n\t\tscanf(\"%d\", &y);\n\t\ta[i + 1] = a[i] + (int)(y < x);\n\t}\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tA[a[i]] += 1;\n\t\tB[n - a[i]] += 1;\n\t}\n//\tcerr << \"before FFT\" << endl;\n\tFFT(A);\n\tFFT(B);\n\tfor (int i = 0; i < N; i++)\n\t\tA[i] *= B[i];\n\tFFT(A);\n//\tcerr << \"all FFT\" << endl;\n\tfor (int i = 0; i < N; i++)\n\t\tans[i] = (ll)(A[i].real() / N + 0.5);\n\treverse(ans + 1, ans + N);\n\tfor (int i = 0; i <= n; i++)\n\t\tans[i] = ans[n + i];\n\tans[0] = 0;\n\tint L = 0;\n\twhile(L <= n) {\n\t\tint R = L;\n\t\twhile(R <= n && a[R] == a[L]) R++;\n\t\tans[0] += (ll)(R - L) * (R - L - 1) / 2;\n\t\tL = R;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tprintf(\"%lld \", ans[i]);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["chinese remainder theorem", "fft", "math"], "dificulty": "2300", "interactive": false}