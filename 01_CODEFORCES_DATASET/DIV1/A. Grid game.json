{
    "link": "https://codeforces.com//contest/1103/problem/A",
    "problemId": "286145",
    "problem_idx": "A",
    "shortId": "1103A",
    "contest_number": "1103",
    "problem_submissions": {
        "E": [
            48753270,
            48771690,
            48772282
        ],
        "C": [
            48737996,
            48751833,
            48742130,
            48750924,
            48753455,
            48785591,
            48744586,
            48747377,
            48750469,
            48752184,
            48749897,
            48750575,
            48750490,
            48749685,
            48751441
        ],
        "B": [
            48729408,
            48731995,
            48733031,
            48738196,
            48732688,
            48735686,
            48732548,
            48745783,
            48738143,
            48736855,
            48734767,
            48731627,
            48740835,
            48746307,
            48736276,
            48737788,
            48737739,
            48735990,
            48736042
        ],
        "A": [
            48723784,
            48727790,
            48725191,
            48732437,
            48724396,
            48725785,
            48724635,
            48726318,
            48725482,
            48726526,
            48724739,
            48726676,
            48725374,
            48729843,
            48724696,
            48726116,
            48730660,
            48725296,
            48724384
        ],
        "D": [
            48745574,
            48759308,
            48758091,
            48757563,
            48785689,
            48755420,
            48758598,
            48759719,
            48935021,
            48790648,
            48790368,
            48790273,
            48768973,
            48768847,
            48768502,
            48768204,
            48768156,
            48759654,
            48763805,
            48758531
        ]
    },
    "name": "A. Grid game",
    "statement": "You are given a 4x4 grid. You play a game there is a sequence of tiles,\r\neach of them is either 2x1 or 1x2. Your task is to consequently place\r\nall tiles from the given sequence in the grid. When tile is placed, each\r\ncell which is located in fully occupied row or column is deleted (cells\r\nare deleted at the same time independently). You can place tile in the\r\ngrid at any position, the only condition is that tiles (and tile parts)\r\nshould not overlap. Your goal is to proceed all given figures and avoid\r\ncrossing at any time.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  string s;\n  cin >> s;\n\n  int cur_0 = 1;\n  int cur_1 = 1;\n\n  for (char ch : s) {\n    if (ch == '0') {\n      cout << \"1 \" << cur_0 << \"\\n\";\n      if (cur_0 == 4) {\n        cur_0 = 1;\n      } else {\n        ++cur_0;\n      }\n    } else {\n      cout << \"3 \" << cur_1 << \"\\n\";\n      if (cur_1 == 3) {\n        cur_1 = 1;\n      } else {\n        cur_1 += 2;\n      }\n    }\n  }\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Grid game.json",
    "editorial_link": "https://codeforces.com//blog/entry/64722",
    "editorial": "One possible solution is to place vertical tiles into lower-left corner and place horizontal tiles into upper-right corner.If some tile comes, but there is already a tile of the same type, than we will place the new tile into upper-left corner. So both tiles will be cleared and only them."
}