{
    "link": "https://codeforces.com//contest/1693/problem/A",
    "problemId": "1430888",
    "problem_idx": "A",
    "shortId": "1693A",
    "contest_number": "1693",
    "problem_submissions": {
        "F": [
            160880007,
            160880972,
            160861674,
            160875588,
            160882783,
            160878948,
            160890167,
            160899913,
            161040863,
            160893311,
            160892940
        ],
        "E": [
            160864775,
            160851833,
            160876978,
            160893451,
            160863343,
            160869365,
            160873611,
            160876701,
            160883190,
            160881001,
            160869009,
            160890042,
            160889537,
            160889370,
            160888603,
            160888570,
            160884303
        ],
        "D": [
            160848374,
            160868923,
            160880702,
            160854200,
            160854032,
            160862911,
            160859336,
            160861278,
            160860933,
            160866823,
            160880935,
            160874455,
            160855846,
            160857826,
            160858928,
            160851586,
            160859103
        ],
        "C": [
            160833863,
            160838237,
            160831750,
            160839496,
            160831595,
            160847471,
            160845192,
            160845432,
            160842623,
            160834916,
            160845029,
            160853816,
            160836315,
            160837724,
            160840237,
            160837127,
            160842065,
            160837528
        ],
        "B": [
            160829995,
            160831749,
            160828393,
            160835792,
            160838408,
            160836721,
            160840343,
            160837858,
            160837790,
            160829673,
            160840637,
            160838527,
            160830551,
            160831811,
            160831387,
            160832406,
            160834629,
            160831231
        ],
        "A": [
            160824784,
            160824733,
            160824181,
            160826982,
            160842765,
            160829489,
            160836610,
            160834230,
            160827824,
            160825693,
            160827125,
            160830489,
            160824662,
            160825298,
            160825387,
            160826936,
            160829963,
            160825879
        ]
    },
    "name": "A. Directional Increase",
    "statement": "We have an array of length n. Initially, each element is equal to 0 and\r\nthere is a pointer located on the first element.We can do the following\r\ntwo kinds of operations any number of times (possibly zero) in any\r\norder: If the pointer is not on the last element, increase the element\r\nthe pointer is currently on by 1. Then move it to the next element. If\r\nthe pointer is not on the first element, decrease the element the\r\npointer is currently on by 1. Then move it to the previous element.But\r\nthere is one additional rule. You are given an array a. Determine\r\nwhether it\u2019s possible to obtain a after some operations or not.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nll tab[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(\"Yes\\n\");\n\telse\n\t\tprintf(\"No\\n\");\n}\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld\", &tab[i]);\n\t}\n\tll s=0;\n\tint bylo=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ts+=tab[i];\n\t\tif (s<0)\n\t\t{\n\t\t\tans(0);\n\t\t\treturn;\n\t\t}\n\t\tif (!s)\n\t\t{\n\t\t\tbylo=1;\n\t\t}\n\t\tif (bylo && s)\n\t\t{\n\t\t\tans(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (s)\n\t{\n\t\tans(0);\n\t\treturn;\n\t}\n\tans(1);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Directional Increase.json",
    "editorial_link": "https://codeforces.com//blog/entry/103952",
    "editorial": "First of all the sum of the elements has to be because the pointer has\r\nto end up on the first element.Denote the number of times you do the\r\nfirst operation while the pointer is on the -th element as . And the\r\nnumber of times you do the second operation while the pointer is on the\r\n-th element as . and because the pointer has to end up on the first\r\nelement.So and .Now that we have calculated , we need to determine\r\nwhether it\u00e2\u0080\u0099s possible to perform the operations like so.There are two\r\nconditions. (). If for each , , . Because the pointer couldn\u00e2\u0080\u0099t reach the\r\n-th element. You can always construct if these two conditions hold.Proof\r\nby induction. Perform the first operation and the second operation times\r\nin a row. Then perform the first operation. Construct the rest by\r\ninduction and then perform the second operation.Time complexity:\r\n"
}