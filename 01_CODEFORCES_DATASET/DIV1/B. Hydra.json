{
    "link": "https://codeforces.com//contest/243/problem/B",
    "problemId": "2197",
    "problem_idx": "B",
    "shortId": "243B",
    "contest_number": "243",
    "problem_submissions": {
        "C": [
            2572717,
            2570554,
            2571267,
            2570319,
            2570545,
            2570743,
            2570904,
            2572447,
            2569802,
            2571867,
            2571670,
            2571547,
            2572458,
            2572351,
            2572725,
            2572445,
            2571597
        ],
        "B": [
            2571032,
            2569391,
            2569867,
            2569039,
            2577625,
            2577586,
            2570199,
            2569750,
            2570050,
            2570000,
            2574723,
            2570092,
            2570360,
            2570412,
            2570400,
            2569098,
            2570322,
            2570512,
            2570546
        ],
        "A": [
            2567965,
            2567859,
            2571004,
            2567919,
            2568141,
            2568865,
            2568305,
            2568196,
            2567807,
            2568129,
            2568622,
            2567937,
            2568123,
            2567849,
            2568409,
            2569040,
            2568458
        ],
        "D": [
            2572629,
            2572978,
            2574124
        ]
    },
    "name": "B. Hydra",
    "statement": "One day Petya got a birthday present from his mom: a book called \"The\r\nLegends and Myths of Graph Theory\". From this book Petya learned about a\r\ngraph.A non-oriented graph is a , if it has a structure, shown on the\r\nfigure below. Namely, there are two nodes and connected by an edge, they\r\nare the hydra\u2019s and , correspondingly. The chest is connected with\r\nnodes, which are the hydra\u2019s . The stomach is connected with nodes,\r\nwhich are the hydra\u2019s . Note that the hydra is a tree, consisting of\r\nnodes. Also, Petya\u2019s got a non-directed graph , consisting of nodes and\r\nedges. Petya got this graph as a last year birthday present from his\r\nmom. Graph contains no self-loops or multiple edges.Now Petya wants to\r\nfind a hydra in graph . Or else, to make sure that the graph doesn\u2019t\r\nhave a hydra.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <sstream>\n#define zero(a) (abs(a)<eps)\n#define lowbit(a) ((a)&(-(a)))\n#define abs(a) ((a)>0?(a):(-(a)))\n#define dj(x1,y1,x2,y2) ((x1)*(x2)+(y1)*(y2))\n#define cj(x1,y1,x2,y2) ((x1)*(y2)-(x2)*(y1))\n#define dis(x1,y1,x2,y2) (((x2)-(x1))*((x2)-(x1))+((y2)-(y1))*((y2)-(y1)))\nconst double eps = 1e-9;\nconst double pi = acos(-1);\nconst int oo = 1000000000;\nconst int mod = 1000000009;\nconst double E = 2.7182818284590452353602874713527;\nusing namespace std;\n\nint head[100001],next[200001],e[200001],du[100001],hash[100001],d[3][100001];\nint totm=0;\n\nvoid add(int a,int b)\n{\n   e[++totm]=b;\n   next[totm]=head[a];\n   head[a]=totm;\n}\n\nint main()\n{\n   int n,m,h,t,flag=0;\n   cin>>n>>m>>h>>t;\n   for (int i=1;i<=m;i++)\n   {\n      int a,b;\n      scanf(\"%d%d\",&a,&b);\n      add(a,b);\n      add(b,a);\n      du[a]++;\n      du[b]++;\n   }\n   for (int i=1;i<=n;i++)\n      du[i]--;\n   for (int i=1;i<=totm;i+=2)\n   {\n      int x=e[i],y=e[i+1];\n      if (du[x]>du[y])\n         swap(x,y);\n      d[0][0]=d[1][0]=d[2][0]=0;\n      flag++;\n      if (min(du[x],du[y])>=min(h,t))\n      {\n         //int u,v;\n         for (int j=head[x];j;j=next[j])\n            if (e[j]!=y)\n               hash[e[j]]=flag;\n         for (int j=head[y];j;j=next[j])\n            if (e[j]!=x&&hash[e[j]]==flag)\n               d[2][++d[2][0]]=e[j];\n         flag++;\n         for (int j=1;j<=d[2][0];j++)\n            hash[d[2][j]]=flag;\n         if (max(min(h,t)-(du[x]-d[2][0]),0)+max(max(h,t)-(du[y]-d[2][0]),0)<=d[2][0])\n         {\n            for (int j=head[x];j&&d[0][0]<min(h,t);j=next[j])\n               if (e[j]!=y&&hash[e[j]]!=flag)\n                  d[0][++d[0][0]]=e[j];\n            while (d[0][0]<min(h,t))\n               d[0][++d[0][0]]=d[2][d[2][0]--];\n            for (int j=head[y];j&&d[1][0]<max(h,t);j=next[j])\n               if (e[j]!=x&&hash[e[j]]!=flag)\n                  d[1][++d[1][0]]=e[j];\n            while (d[1][0]<max(h,t))\n               d[1][++d[1][0]]=d[2][d[2][0]--];\n         }\n         else\n            continue;\n         /*if (du[x]<=du[y]&&h<=t||du[x]>=du[y]&&h>=t)\n         {\n            u=x;\n            v=y;\n            if (du[x]<=du[y])\n            {\n               for (int j=head[x];d[0][0]<h;j=next[j])\n                  if (e[j]!=y)\n                  {\n                     d[0][++d[0][0]]=e[j];\n                     hash[e[j]]=flag;\n                  }\n               for (int j=head[y];j&&d[1][0]<t;j=next[j])\n                  if (e[j]!=x&&hash[e[j]]!=flag)\n                     d[1][++d[1][0]]=e[j];\n            }\n            else\n            {\n               for (int j=head[y];d[1][0]<t;j=next[j])\n                  if (e[j]!=x)\n                  {\n                     d[1][++d[1][0]]=e[j];\n                     hash[e[j]]=flag;\n                  }\n               for (int j=head[x];j&&d[0][0]<h;j=next[j])\n                  if (e[j]!=y&&hash[e[j]]!=flag)\n                     d[0][++d[0][0]]=e[j];\n            }\n         }\n         else\n         {\n            u=y;\n            v=x;\n            if (du[x]<=du[y])\n            {\n               for (int j=head[x];d[1][0]<t;j=next[j])\n                  if (e[j]!=y)\n                  {\n                     d[1][++d[1][0]]=e[j];\n                     hash[e[j]]=flag;\n                  }\n               for (int j=head[y];j&&d[0][0]<h;j=next[j])\n                  if (e[j]!=x&&hash[e[j]]!=flag)\n                     d[0][++d[0][0]]=e[j];\n            }\n            else\n            {\n               for (int j=head[y];d[0][0]<h;j=next[j])\n                  if (e[j]!=x)\n                  {\n                     d[0][++d[0][0]]=e[j];\n                     hash[e[j]]=flag;\n                  }\n               for (int j=head[x];j&&d[1][0]<t;j=next[j])\n                  if (e[j]!=y&&hash[e[j]]!=flag)\n                     d[1][++d[1][0]]=e[j];\n            }\n         }*/\n         puts(\"YES\");\n         if (d[0][0]==h&&d[1][0]==t)\n         {\n         cout<<x<<' '<<y<<endl;\n         for (int j=1;j<=h;j++)\n            printf(\"%d%c\",d[0][j],(j==h)?'\\n':' ');\n         for (int j=1;j<=t;j++)\n            printf(\"%d%c\",d[1][j],(j==t)?'\\n':' ');\n         }\n         else\n         {\n         cout<<y<<' '<<x<<endl;\n         for (int j=1;j<=h;j++)\n            printf(\"%d%c\",d[1][j],(j==h)?'\\n':' ');\n         for (int j=1;j<=t;j++)\n            printf(\"%d%c\",d[0][j],(j==t)?'\\n':' ');\n         }\n         goto end;\n      }\n   }\n   puts(\"NO\");\n   end:\n   return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Hydra.json",
    "editorial_link": "https://codeforces.com//blog/entry/5895",
    "editorial": "You should check for every edge: this one can be body of hydra or not. Let's fix some edge (u,?v) (order of vertices is important, i.e. you should also check edge (v,?u)). Now you should chose some set of h vertices connected with u and some set of t vertices connected with v. These sets should not contain vertices u and v. Also, these two sets should have no common vertices.\n\nIf  and , there is no any hydra here.\n\nOrherwise, if  or , there is some hydra in any case. Even if all vertices connected with u and with v are common, number of them so big, that you always can split them into groups of size ???h and size ???t.\n\nThe last case is  and . Here you can find all common vertices in O(h?+?t), using array of flags. When you find the common subset, you can easy check existence of hydra."
}