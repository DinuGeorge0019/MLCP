{
    "link": "https://codeforces.com//contest/1168/problem/A",
    "problemId": "349588",
    "problem_idx": "A",
    "shortId": "1168A",
    "contest_number": "1168",
    "problem_submissions": {
        "D": [
            54689933,
            54709717,
            54687414,
            54689247,
            54692817,
            54690951,
            54687623,
            54690825,
            54690084,
            54693991,
            54691003,
            54691066,
            54691626,
            54692507,
            54689961,
            54693988,
            54752028,
            54747584,
            54782050,
            54716017,
            54694558
        ],
        "B": [
            54688206,
            54684470,
            54672670,
            54675422,
            54672484,
            54674963,
            54674803,
            54682027,
            54675650,
            54680245,
            54677508,
            54680443,
            54678955,
            54683400,
            54673481,
            54675324,
            54675597,
            54675910,
            54676117
        ],
        "A": [
            54679849,
            54670251,
            54678124,
            54670773,
            54670009,
            54671023,
            54672077,
            54670763,
            54669908,
            54672903,
            54670896,
            54674583,
            54671922,
            54670734,
            54670514,
            54670263,
            54670924,
            54670411,
            54671870
        ],
        "C": [
            54678044,
            54685816,
            54846089,
            54676677,
            54679735,
            54675366,
            54680183,
            54677459,
            54678103,
            54681414,
            54678145,
            54682238,
            54682671,
            54681429,
            54681732,
            54676972,
            54678213,
            54678234,
            54678543,
            54679007
        ],
        "E": [
            54672350,
            54679530,
            156967221,
            54891863,
            54891597
        ]
    },
    "name": "A. Increasing by Modulo",
    "statement": "Toad Zitz has an array of integers, each integer is between 0 and m-1\r\ninclusive. The integers are a_1, a_2,\r\nldots, a_n.In one operation Zitz can choose an integer k and k indices\r\ni_1, i_2,\r\nldots, i_k such that 1\r\nleq i_1 < i_2 <\r\nldots < i_k\r\nleq n. He should then change a_{i_j} to ((a_{i_j}+1)\r\nbmod m) for each chosen integer i_j. The integer m is fixed for all\r\noperations and indices.Here x\r\nbmod y denotes the remainder of the division of x by y.Zitz wants to\r\nmake his array non-decreasing with the minimum number of such\r\noperations. Find this minimum number of operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\n#define maxN 323456\nint n, m;\nint a[maxN];\n\nbool check(int c) {\n\tint premin = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] + c < m) {\n\t\t\tif (a[i] + c < premin) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tpremin = max(premin, a[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (a[i] + c - m < premin)\n\t\t\t\tpremin = max(premin, a[i]);\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tint l = -1, r = m;\n\twhile (l + 1 < r) {\n\t\tint c = (l + r) / 2;\n\t\tif (check(c))\n\t\t\tr = c;\n\t\telse\n\t\t\tl = c;\n\t}\n\tprintf(\"%d\\n\", r);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Increasing by Modulo.json",
    "editorial_link": "https://codeforces.com//blog/entry/67241",
    "editorial": "Let's check that the answer to the problem is ?x\n.\n\nThen, for each element, you have some interval (interval on the \"circle\" of remainders modulo m\n) of values, that it can be equal to.\n\nSo you need to check that you can pick in each interval some point, to make all these values non-decrease.\n\nYou can do it with greedy! Each time, let's take the smallest element from the interval, that is at least the previously chosen value.\n\nAnd after this, let's make the binary search on x\n.\n\nSo we have the solution in O(nlogm)\n."
}