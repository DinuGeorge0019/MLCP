{"link": "https://codeforces.com//contest/128/problem/D", "problemId": "675", "problem_idx": "D", "shortId": "128D", "contest_number": "128", "problem_submissions": {"B": [868631, 867052, 866131, 868093, 864920, 867712, 867635, 868241, 868954, 866973, 868225, 869082, 869329, 868786], "C": [867417, 865854, 866628, 866135, 867141, 866532, 866167, 866639, 866961, 867655, 868770, 866966, 867088, 867033], "D": [865898, 866482, 867528, 866945, 868692, 868382, 868718, 867247, 867493, 868514, 866507, 867640, 867746, 867494], "A": [865243, 865123, 865205, 865177, 867354, 866061, 865379, 868310, 865524, 866301, 865222, 865534, 865830, 866105]}, "name": "D. Numbers", "statement": "One day Anna got the following task at school: to arrange several\r\nnumbers in a circle so that any two neighboring numbers differs exactly\r\nby 1. Anna was given several numbers and arranged them in a circle to\r\nfulfill the task. Then she wanted to check if she had arranged the\r\nnumbers correctly, but at this point her younger sister Maria came and\r\nshuffled all numbers. Anna got sick with anger but what\u2019s done is done\r\nand the results of her work had been destroyed. But please tell Anna:\r\ncould she have hypothetically completed the task using all those given\r\nnumbers?\r\n", "solutions": ["#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long double real;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf (stderr, __VA_ARGS__)\n#else\n#define eprintf(...) assert (true)\n#endif\n\n#ifdef WIN32\n#define INT64 \"%I64d\"\n#else\n#define INT64 \"%lld\"\n#endif\n\nusing namespace std;\n\nconst int MaxN = 100005, NA = -1, MaxC = 0x3F3F3F3F;\n\nint a [MaxN];\nint n;\nmultiset <int, greater <int> > s;\ndeque <int> d;\n\nint main (void)\n{\n int i, v;\n multiset <int>::iterator it;\n\n while (scanf (\" %d\", &n) != EOF)\n {\n  for (i = 0; i < n; i++)\n   scanf (\" %d\", &a[i]);\n  s.clear ();\n  for (i = 0; i < n; i++)\n   s.insert (a[i]);\n  d.clear ();\n  it = s.begin ();\n  d.push_back (*it);\n  s.erase (it);\n\n  for (i = 1; i < n; i++)\n   if (d.front () > d.back ())\n   {\n    v = d.front ();\n    it = s.find (v + 1);\n    if (it != s.end ())\n    {\n     d.push_front (*it);\n     s.erase (it);\n    }\n    else\n    {\n     it = s.find (v - 1);\n     if (it != s.end ())\n     {\n      d.push_front (*it);\n      s.erase (it);\n     }\n     else\n      break;\n    }\n   }\n   else\n   {\n    v = d.back ();\n    it = s.find (v + 1);\n    if (it != s.end ())\n    {\n     d.push_back (*it);\n     s.erase (it);\n    }\n    else\n    {\n     it = s.find (v - 1);\n     if (it != s.end ())\n     {\n      d.push_back (*it);\n      s.erase (it);\n     }\n     else\n      break;\n    }\n   }\n\n  if ((int) d.size () == n && abs (d.front () - d.back ()) == 1)\n   printf (\"YES\\n\");\n  else\n   printf (\"NO\\n\");\n }\n return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "implementation"], "dificulty": "2000", "interactive": false}