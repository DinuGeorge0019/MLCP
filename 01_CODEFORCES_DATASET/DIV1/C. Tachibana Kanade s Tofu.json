{"link": "https://codeforces.com//contest/434/problem/C", "problemId": "9714", "problem_idx": "C", "shortId": "434C", "contest_number": "434", "problem_submissions": {"D": [6699538, 6706635, 6706622, 6706591, 6706589, 6795823, 6704699, 6708335, 6707919], "C": [6697907, 6699177, 6698487, 6699311, 6699392, 6797515, 6797483, 6718935, 6697269, 6700102, 6699851, 6696039, 6700493, 6700403, 6700591, 6698358, 6698258, 6700561, 6698389], "B": [6695587, 6696287, 6694622, 6695678, 6696514, 6695797, 6699364, 6695860, 6695864, 6699676, 6699377, 6696715, 6697097, 6695263, 6696899, 6700084, 6700621, 6697368, 6695731], "A": [6692446, 6694191, 6692438, 6693456, 6692853, 6692909, 6693769, 6692709, 6691931, 6694014, 6700765, 6693088, 6694404, 6692737, 6695761, 6695148, 6698289, 6693859, 6708768], "E": [6711897]}, "name": "C. Tachibana Kanade s Tofu", "statement": "Tachibana Kanade likes Mapo Tofu very much. One day, the canteen cooked\r\nall kinds of tofu to sell, but not all tofu is Mapo Tofu, only those\r\nspicy enough can be called Mapo Tofu.Each piece of tofu in the canteen\r\nis given a -based number, all numbers are in the range ( and being\r\n-based numbers), and for every -based integer in the range , there\r\nexists a piece of tofu with that number.To judge what tofu is Mapo Tofu,\r\nTachibana Kanade chose -based number strings, and assigned a value to\r\neach string. If a string appears in the number of a tofu, the value of\r\nthe string will be added to the value of that tofu. If a string appears\r\nmultiple times, then the value is also added that many times. Initially\r\nthe value of each tofu is zero.Tachibana Kanade considers tofu with\r\nvalues no more than to be Mapo Tofu. So now Tachibana Kanade wants to\r\nknow, how many pieces of tofu are Mapo Tofu?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 200 + 10;\nconst int MAX_M = 20 + 1;\nconst int MAX_K = 500 + 10;\nconst int MOD = 1000000007;\nint n, m, k;\n\nconst int CHARSET = 20;\nconst int MAX_N_NODES = int(3e5) + 10;\n\nint pointer;\nstruct Node {\n\tNode*ch[CHARSET], *fail, *par;\n\tNode*jump[CHARSET];\n\n\tint end;\n\tNode() {\n\t\tmemset(ch, 0, sizeof ch);\n\t\tfail = 0;\n\t\tend = 0;\n\t}\n\tNode*go(int w);\n}*root;\n\nNode nodePool[MAX_N_NODES], *cur;\nconst int MAX_ID = 400 + 10;\n\nint getId(Node*u) {\n\treturn u - nodePool;\n}\n\nNode*newNode() {\n\tNode*t = cur++;\n\tmemset(t->ch, 0, sizeof t->ch);\n\tt->fail = 0;\n\treturn t;\n}\n\nNode* Node::go(int w) {\n\tif (ch[w] == 0) {\n\t\tch[w] = newNode();\n\t\tch[w]->par = this;\n\t}\n\treturn ch[w];\n}\n\nvoid init() {\n\tcur = nodePool;\n\troot = newNode();\n\troot->par = 0;\n}\n\nvoid build() {\n\tstatic Node*que[MAX_N_NODES];\n\tint qh = 0, qt = 0;\n\tque[qt++] = root;\n\twhile (qh < qt) {\n\t\tNode*t = que[qh++];\n\t\tfor (int c = 0; c < CHARSET; ++c) {\n\t\t\tNode*v = t->ch[c];\n\t\t\tif (!v)\n\t\t\t\tcontinue;\n\t\t\tNode*f = t->fail;\n\t\t\twhile (f && f->ch[c] == 0)\n\t\t\t\tf = f->fail;\n\t\t\tif (f == 0)\n\t\t\t\tv->fail = root;\n\t\t\telse\n\t\t\t\tv->fail = f->ch[c];\n\t\t\tque[qt++] = v;\n\t\t}\n\t}\n\t//calculate JUMP\n\tfor (int j = 0; j < m; ++j) {\n\t\troot->jump[j] = root->ch[j] ? root->ch[j] : root;\n//\t\tif (root->jump[j] == 0)\n//\t\t\troot->jump[j] = root;\n\t}\n\n\tfor (int i = 1; i < qt; ++i) {\n\t\tNode*u = que[i];\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (u->ch[j])\n\t\t\t\tu->jump[j] = u->ch[j];\n\t\t\telse\n\t\t\t\tu->jump[j] = u->fail->jump[j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < qt; ++i) {\n\t\tNode*u = que[i];\n\t\tif (u->fail)\n\t\t\tu->end += u->fail->end;\n\t}\n}\n\nvector<int> L, R;\n\nvector<int> str[MAX_N];\nint v[MAX_N];\n\nvoid read(vector<int>&arr) {\n\tint n;\n\tcin >> n;\n\tarr.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> arr[i];\n\t}\n}\n\nint memo[202][410][501];\n\nint rec(int at, bool leadingZero, bool sameL, bool sameR, Node*u, int have) {\n\thave += u->end;\n\tif (have > k)\n\t\treturn 0;\n\n\tif (at == L.size()) {\n\t\treturn 1;\n\t}\n\n\tbool save = !(sameL || sameR);\n\tint ret = 0;\n\tif (save) {\n\t\tret = memo[at][getId(u)][have];\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t\tret = 0;\n\t}\n\n\tfor (int nxt = 0; nxt < m; ++nxt) { //nxt digit\n\t\tif (sameL && nxt < L[at])\n\t\t\tcontinue;\n\t\tif (sameR && nxt > R[at])\n\t\t\tcontinue;\n\t\tNode*nu = u;\n\t\tif (!leadingZero || nxt > 0)\n\t\t\tnu = u->jump[nxt];\n\n\t\tret += rec(at + 1, leadingZero && (nxt == 0), sameL && (nxt == L[at]),\n\t\t\t\tsameR && (nxt == R[at]), nu, have);\n\t\tif (ret >= MOD)\n\t\t\tret -= MOD;\n\t}\n\n\tif (save) {\n\t\tmemo[at][getId(u)][have] = ret;\n\t}\n\n\treturn ret;\n}\n\nint main() {\n//\tcout << sizeof(memo) / (1024 * 1024.0) << endl;\n\tcin >> n >> m >> k;\n\tread(L), read(R);\n\twhile (L.size() < R.size())\n\t\tL.insert(L.begin(), 0);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tread(str[i]);\n\t\tcin >> v[i];\n\t}\n\tinit();\n\tfor (int i = 0; i < n; ++i) {\n\t\tNode*u = root;\n\t\tfor (int j = 0; j < str[i].size(); ++j) {\n\t\t\tu = u->go(str[i][j]);\n\t\t}\n\t\tu->end += v[i];\n\t}\n\tbuild();\n\tmemset(memo, -1, sizeof memo);\n\tint ans = rec(0, true, true, true, root, 0);\n\tcout << ans << endl;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2500", "interactive": false}