{
    "link": "https://codeforces.com//contest/434/problem/C",
    "problemId": "9714",
    "problem_idx": "C",
    "shortId": "434C",
    "contest_number": "434",
    "problem_submissions": {
        "D": [
            6699538,
            6706635,
            6706622,
            6706591,
            6706589,
            6795823,
            6704699,
            6708335,
            6707919
        ],
        "C": [
            6697907,
            6699177,
            6698487,
            6699311,
            6699392,
            6797515,
            6797483,
            6718935,
            6697269,
            6700102,
            6699851,
            6696039,
            6700493,
            6700403,
            6700591,
            6698358,
            6698258,
            6700561,
            6698389
        ],
        "B": [
            6695587,
            6696287,
            6694622,
            6695678,
            6696514,
            6695797,
            6699364,
            6695860,
            6695864,
            6699676,
            6699377,
            6696715,
            6697097,
            6695263,
            6696899,
            6700084,
            6700621,
            6697368,
            6695731
        ],
        "A": [
            6692446,
            6694191,
            6692438,
            6693456,
            6692853,
            6692909,
            6693769,
            6692709,
            6691931,
            6694014,
            6700765,
            6693088,
            6694404,
            6692737,
            6695761,
            6695148,
            6698289,
            6693859,
            6708768
        ],
        "E": [
            6711897
        ]
    },
    "name": "C. Tachibana Kanade s Tofu",
    "statement": "Tachibana Kanade likes Mapo Tofu very much. One day, the canteen cooked\r\nall kinds of tofu to sell, but not all tofu is Mapo Tofu, only those\r\nspicy enough can be called Mapo Tofu.Each piece of tofu in the canteen\r\nis given a -based number, all numbers are in the range ( and being\r\n-based numbers), and for every -based integer in the range , there\r\nexists a piece of tofu with that number.To judge what tofu is Mapo Tofu,\r\nTachibana Kanade chose -based number strings, and assigned a value to\r\neach string. If a string appears in the number of a tofu, the value of\r\nthe string will be added to the value of that tofu. If a string appears\r\nmultiple times, then the value is also added that many times. Initially\r\nthe value of each tofu is zero.Tachibana Kanade considers tofu with\r\nvalues no more than to be Mapo Tofu. So now Tachibana Kanade wants to\r\nknow, how many pieces of tofu are Mapo Tofu?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 200 + 10;\nconst int MAX_M = 20 + 1;\nconst int MAX_K = 500 + 10;\nconst int MOD = 1000000007;\nint n, m, k;\n\nconst int CHARSET = 20;\nconst int MAX_N_NODES = int(3e5) + 10;\n\nint pointer;\nstruct Node {\n\tNode*ch[CHARSET], *fail, *par;\n\tNode*jump[CHARSET];\n\n\tint end;\n\tNode() {\n\t\tmemset(ch, 0, sizeof ch);\n\t\tfail = 0;\n\t\tend = 0;\n\t}\n\tNode*go(int w);\n}*root;\n\nNode nodePool[MAX_N_NODES], *cur;\nconst int MAX_ID = 400 + 10;\n\nint getId(Node*u) {\n\treturn u - nodePool;\n}\n\nNode*newNode() {\n\tNode*t = cur++;\n\tmemset(t->ch, 0, sizeof t->ch);\n\tt->fail = 0;\n\treturn t;\n}\n\nNode* Node::go(int w) {\n\tif (ch[w] == 0) {\n\t\tch[w] = newNode();\n\t\tch[w]->par = this;\n\t}\n\treturn ch[w];\n}\n\nvoid init() {\n\tcur = nodePool;\n\troot = newNode();\n\troot->par = 0;\n}\n\nvoid build() {\n\tstatic Node*que[MAX_N_NODES];\n\tint qh = 0, qt = 0;\n\tque[qt++] = root;\n\twhile (qh < qt) {\n\t\tNode*t = que[qh++];\n\t\tfor (int c = 0; c < CHARSET; ++c) {\n\t\t\tNode*v = t->ch[c];\n\t\t\tif (!v)\n\t\t\t\tcontinue;\n\t\t\tNode*f = t->fail;\n\t\t\twhile (f && f->ch[c] == 0)\n\t\t\t\tf = f->fail;\n\t\t\tif (f == 0)\n\t\t\t\tv->fail = root;\n\t\t\telse\n\t\t\t\tv->fail = f->ch[c];\n\t\t\tque[qt++] = v;\n\t\t}\n\t}\n\t//calculate JUMP\n\tfor (int j = 0; j < m; ++j) {\n\t\troot->jump[j] = root->ch[j] ? root->ch[j] : root;\n//\t\tif (root->jump[j] == 0)\n//\t\t\troot->jump[j] = root;\n\t}\n\n\tfor (int i = 1; i < qt; ++i) {\n\t\tNode*u = que[i];\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (u->ch[j])\n\t\t\t\tu->jump[j] = u->ch[j];\n\t\t\telse\n\t\t\t\tu->jump[j] = u->fail->jump[j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < qt; ++i) {\n\t\tNode*u = que[i];\n\t\tif (u->fail)\n\t\t\tu->end += u->fail->end;\n\t}\n}\n\nvector<int> L, R;\n\nvector<int> str[MAX_N];\nint v[MAX_N];\n\nvoid read(vector<int>&arr) {\n\tint n;\n\tcin >> n;\n\tarr.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> arr[i];\n\t}\n}\n\nint memo[202][410][501];\n\nint rec(int at, bool leadingZero, bool sameL, bool sameR, Node*u, int have) {\n\thave += u->end;\n\tif (have > k)\n\t\treturn 0;\n\n\tif (at == L.size()) {\n\t\treturn 1;\n\t}\n\n\tbool save = !(sameL || sameR);\n\tint ret = 0;\n\tif (save) {\n\t\tret = memo[at][getId(u)][have];\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t\tret = 0;\n\t}\n\n\tfor (int nxt = 0; nxt < m; ++nxt) { //nxt digit\n\t\tif (sameL && nxt < L[at])\n\t\t\tcontinue;\n\t\tif (sameR && nxt > R[at])\n\t\t\tcontinue;\n\t\tNode*nu = u;\n\t\tif (!leadingZero || nxt > 0)\n\t\t\tnu = u->jump[nxt];\n\n\t\tret += rec(at + 1, leadingZero && (nxt == 0), sameL && (nxt == L[at]),\n\t\t\t\tsameR && (nxt == R[at]), nu, have);\n\t\tif (ret >= MOD)\n\t\t\tret -= MOD;\n\t}\n\n\tif (save) {\n\t\tmemo[at][getId(u)][have] = ret;\n\t}\n\n\treturn ret;\n}\n\nint main() {\n//\tcout << sizeof(memo) / (1024 * 1024.0) << endl;\n\tcin >> n >> m >> k;\n\tread(L), read(R);\n\twhile (L.size() < R.size())\n\t\tL.insert(L.begin(), 0);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tread(str[i]);\n\t\tcin >> v[i];\n\t}\n\tinit();\n\tfor (int i = 0; i < n; ++i) {\n\t\tNode*u = root;\n\t\tfor (int j = 0; j < str[i].size(); ++j) {\n\t\t\tu = u->go(str[i][j]);\n\t\t}\n\t\tu->end += v[i];\n\t}\n\tbuild();\n\tmemset(memo, -1, sizeof memo);\n\tint ans = rec(0, true, true, true, root, 0);\n\tcout << ans << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Tachibana Kanade s Tofu.json",
    "editorial_link": "https://codeforces.com//blog/entry/12397",
    "editorial": "A straightforward brute-force idea would be to enumerate all numbers in\r\nthe interval , and count how many of them have a value greater than .\r\nThis approach is way too slow, but nevertheless let\u00e2\u0080\u0099s try optimizing it\r\nfirst. The enumeration part seems hard to optimize, so let\u00e2\u0080\u0099s consider\r\nwhat is the fastest way of calculating the value of a string. This is a\r\nclassic problem that can be solved using an Aho-Corasick automaton\r\n(abbr. ACA). Build an ACA with the given number strings, and simply\r\n\"walk\" in the automaton according to the string to be calculated.\r\nConsider a common method when dealing with digits split the interval\r\ninto two, minus . Then use DP to solve an interval, take for instance.\r\nConsider filling in the numbers one by one, we need to record in the\r\nstates of the DP the position in the string, and a flag denoting whether\r\nwe\u00e2\u0080\u0099re \"walking on the edge of the upper bound\", that is, whether the\r\nnumbers we\u00e2\u0080\u0099ve filled are the prefix of the upper-bound . How can we use\r\nthe approach above in this problem? Can we combine this approach with\r\nour ACA? The answer is yes, further record in the states of the DP the\r\nID of the node we\u00e2\u0080\u0099re currently \"standing on\" in the ACA. Consider the\r\ntransfer of this DP, enumerate which number we\u00e2\u0080\u0099re going to fill in, and\r\ncheck using our flag if the current number will be greater than the\r\nupper-bound. Appending a number to the end of our string would result in\r\na change of the ID of the node in our ACA, so \"walk\" along the\r\ntransferring edge in the ACA. What about the limit of values? Simply\r\nrecord the current value in our DP state, during transfer, add the value\r\nstored in the ACA\u00e2\u0080\u0099s node to the value stored in our state. The tricky\r\nbit is the leading zeros. Numbers can\u00e2\u0080\u0099t have leading zeros, but number\r\nstrings can. How can we distinguish leading zeros from zeros in the\r\nmiddle of the number? We keep another flag, denoting whether we\u00e2\u0080\u0099re still\r\ndealing with leading zeros. So finally our state looks like , where , ,\r\nand are current length of number, ID of current node in ACA, and current\r\nvalue of number respectively. Let be the total length of all number\r\nstring, and be the length of , the total complexity would be , since the\r\nnumber of states is and transfer takes time. Solution for the approach\r\nabove: 6712934 Solution for a different approach: 6713013\r\n"
}