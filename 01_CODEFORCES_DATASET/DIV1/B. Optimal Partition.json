{
    "link": "https://codeforces.com//contest/1667/problem/B",
    "problemId": "1373069",
    "problem_idx": "B",
    "shortId": "1667B",
    "contest_number": "1667",
    "problem_submissions": {
        "D": [
            154110050,
            154103852,
            154103937,
            154115479,
            154155764,
            154115906,
            154106152,
            154122484,
            154113686,
            154108338,
            154128689,
            154128856,
            154111430,
            154129489,
            154120823,
            154116376,
            154123174,
            154132994,
            154140447
        ],
        "E": [
            154098159,
            154112243,
            154113395,
            154103015,
            154110907,
            154132981,
            154119331,
            154111400,
            154101121,
            154121934,
            154125339,
            154115657,
            154116667,
            154129397,
            154116608,
            154116404,
            154106393,
            154102336,
            154119279,
            154115571,
            154118773
        ],
        "C": [
            154085084,
            154086351,
            154093926,
            154092233,
            154091477,
            154093338,
            154099548,
            154094249,
            154095983,
            154097356,
            154101589,
            154106382,
            154103698,
            154128503,
            154096518,
            154099179,
            154101629,
            154094236
        ],
        "B": [
            154081270,
            154079749,
            154080732,
            154084177,
            154082008,
            154087816,
            154084920,
            154081329,
            154079918,
            154089467,
            154085121,
            154087842,
            154083998,
            154085563,
            154088975,
            154094350,
            154109646,
            154150216,
            154080315,
            154083438
        ],
        "A": [
            154078911,
            154089336,
            154078854,
            154078866,
            154112501,
            154079024,
            154078951,
            154078873,
            154079568,
            154078977,
            154079611,
            154079048,
            154078916,
            154078899,
            154081306,
            154078922,
            154079058,
            154082401,
            154078903
        ]
    },
    "name": "B. Optimal Partition",
    "statement": "You are given an array a consisting of n integers. You should divide a\r\ninto continuous non-empty subarrays (there are 2^{n-1} ways to do\r\nthat).Let s=a_l+a_{l+1}+\r\nldots+a_r. The value of a subarray a_l, a_{l+1},\r\nldots, a_r is: (r-l+1) if s>0, 0 if s=0, -(r-l+1) if s<0. What is the\r\nmaximum sum of values you can get with a partition?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, dp[500005];\nLL a[500005];\nvector<LL> val;\nstruct fwt\n{\n\tint m, val[500005];\n\tvoid clear(int cm)\n\t{\n\t\tm = cm;\n\t\trep1(i, m) val[i] = -INF; \n\t}\n\tvoid ins(int id, int x)\n\t{\n\t\tfor(id ++; id <= m; id += id & -id) val[id] = max(val[id], x);\n\t}\n\tint query(int id)\n\t{\n\t\tint ret = -INF;\n\t\tfor(id ++; id > 0; id -= id & -id) ret = max(ret, val[id]);\n\t\treturn ret;\n\t}\n}t0, t1;\nvoid solve()\n{\n\tscanf(\"%d\", &n);\n\trep1(i, n) scanf(\"%lld\", &a[i]);\n\trep1(i, n) a[i] += a[i - 1];\n\tval.clear();\n\trep(i, n + 1) val.push_back(a[i]);\n\tsort(val.begin(), val.end());\n\tval.resize(unique(val.begin(), val.end()) - val.begin());\n\t\n\tt0.clear(n + 1);\n\tt1.clear(n + 1);\n\trep(i, n + 1) {\n\t\tint cur = lower_bound(val.begin(), val.end(), a[i]) - val.begin();\n\t\tif(i == 0) dp[i] = 0;\n\t\telse dp[i] = max(dp[i - 1] - 1, max(t0.query(cur), t1.query(cur) + i));\n\t\tt0.ins(cur, dp[i]);\n\t\tt1.ins(cur + 1, dp[i] - i);\n\t}\n\tprintf(\"%d\\n\", dp[n]);\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile(T --) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Optimal Partition.json",
    "editorial_link": "https://codeforces.com//blog/entry/102013",
    "editorial": "Let dpi\n be the answer for the first i\n elements, and v(i,j)\n the value of the subarray [i,j]\n. With prefix sums it is easy to calculate v(i,j)\n quickly. With this we can get a n2\n solution: dpi=max(dpj+v(j+1,i))\n for j<i\n.\n\nLets call a segment winning, drawing, or losing, if the value of it is positive, 0\n, or negative respectively. There is an optimal solution if the length of the drawing and losing segments are 1\n. (The task is solvable without this observation, but it is harder to implement.) Proof: For a losing segment in the worst case we can get two losing segments with the same total length (the same value).\n\nFor a drawing segment with length k\n if k\n is even than the answer is the same if we split it into two segments with length k/2\n. For odd k\n if the sum in the first (k?1)/2\n or last (k?1)/2\n elements is negative, than it is possible to increase the answer, otherwise one can split the segment into (k?1)/2\n, 1\n, and (k?1)/2\n long segments, and the answer for the new partition can't lessen.\n\nSo there is an optimal solution when only winning segments might be longer than 1\n. It is easy to handle the 1\n long segments. For each i\n (1?i?n\n) we have to find j\n, 0<=j<i\n, where v(j+1,i)>0\n, and dpj+v(j+1,i)\n is maximal (dp0=0\n).\n\nIf we store the prefix sums, and assign a permutation according to the prefix sums, than we can get all the positions 1?j<i\n, where v(j+1,i)>0\n.\n\nThan v(j+1,i)=i?j\n.\n\nSo when we calculate dpi\n, we should update with dpi?i\n. This way, finding the optimal j\n for each i\n is just a prefix maximum. One can solve the problem with Fenwick tree or segment tree.\n\nFinal complexity is O(n?log(n))\n.",
    "hint": []
}