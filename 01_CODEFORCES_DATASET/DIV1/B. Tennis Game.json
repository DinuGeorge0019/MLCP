{
    "link": "https://codeforces.com//contest/497/problem/B",
    "problemId": "19572",
    "problem_idx": "B",
    "shortId": "497B",
    "contest_number": "497",
    "problem_submissions": {
        "E": [
            9174487,
            9174196,
            9175010,
            9199333,
            9175252,
            9176527,
            9176653,
            9180194
        ],
        "D": [
            9170679,
            9173274,
            9174804,
            9174751,
            9171031,
            9176067,
            9175754
        ],
        "C": [
            9168733,
            9168537,
            9168027,
            43565108,
            9170031,
            9168979,
            9168260,
            9169684,
            9168763,
            9174362,
            9172330,
            9171998,
            9173920,
            9168319,
            9168825,
            9168629,
            43565576,
            9168203
        ],
        "B": [
            9166459,
            9166265,
            9166436,
            9199442,
            9167203,
            9166878,
            9166797,
            9166926,
            9170793,
            9172501,
            9170015,
            9168743,
            9169417,
            9166154,
            9166746,
            9166737,
            9165998
        ],
        "A": [
            9164122,
            9164273,
            9164359,
            9164060,
            9163922,
            9164065,
            9163958,
            9164600,
            9164390,
            9164526,
            9164902,
            9167522,
            9163923,
            9163921,
            9164484,
            9163952
        ]
    },
    "name": "B. Tennis Game",
    "statement": "Petya and Gena love playing table tennis. A single match is played\r\naccording to the following rules: a match consists of multiple sets,\r\neach set consists of multiple serves. Each serve is won by one of the\r\nplayers, this player scores one point. As soon as one of the players\r\nscores points, he wins the set; then the next set starts and scores of\r\nboth players are being set to 0. As soon as one of the players wins the\r\ntotal of sets, he wins the match and the match is over. Here and are\r\nsome positive integer numbers.To spice it up, Petya and Gena choose new\r\nnumbers and before every match. Besides, for the sake of history they\r\nkeep a record of each match: that is, for each serve they write down the\r\nwinner. Serve winners are recorded in the chronological order. In a\r\nrecord the set is over as soon as one of the players scores points and\r\nthe match is over as soon as one of the players wins sets.Petya and Gena\r\nhave found a record of an old match. Unfortunately, the sequence of\r\nserves in the record isn\u2019t divided into sets and numbers and for the\r\ngiven match are also lost. The players now wonder what values of and\r\nmight be. Can you determine all the possible options?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define ford(i,n) for (int i = int(n) - 1; i >= 0; --i)\n#define forv(i,v) for (auto i = v.begin(); i != v.end(); ++i)\n#define forr(i,v) for (auto i = v.end(); i != v.begin() && (--i, 1); )\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T> inline T abs (T x) {return x > T() ? x : -x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\nstruct Input {\n\tint n;\n\tint a[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t\t--a[i];\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tve<pii> ans;\n\t\n\tvoid write () {\n\t\tcout << sz(ans) << endl;\n\t\tforn (i, sz(ans)) {\n\t\t\tprintf(\"%d %d\\n\", ans[i].fs, ans[i].sc);\n\t\t}\n\t}\n\t\n\tvirtual void solve () {}\n\t\n\tvirtual void clear () {\n\t\t*this = Data();\n\t}\n};\n\nstruct Solution: Data {\n\tint s0[N + 1], s1[N + 1];\n\tint p0[N], p1[N];\n\tint cnt0, cnt1;\n\t\n\tvoid solve () {\n\t\tcnt0 = cnt1 = 0;\n\t\ts0[0] = s1[0] = 0;\n\t\tforn (i, n) {\n\t\t\ts0[i + 1] = s0[i] + (a[i] == 0);\n\t\t\ts1[i + 1] = s1[i] + (a[i] == 1);\n\t\t\tif (a[i] == 0) {\n\t\t\t\tp0[cnt0++] = i;\n\t\t\t} else {\n\t\t\t\tp1[cnt1++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (int k = 1; k <= n; ++k) {\n\t\t\tint t0 = 0, t1 = 0;\n\t\t\tint i = 0;\n\t\t\tbool ok = 1;\n\t\t\tint lst = 0;\n\t\t\twhile (i < n) {\n\t\t\t\tint j0 = (s0[i] + k > cnt0) ? n + 1 : p0[s0[i] + k - 1] + 1;\n\t\t\t\tint j1 = (s1[i] + k > cnt1) ? n + 1 : p1[s1[i] + k - 1] + 1;\n\t\t\t\tif (min(j0, j1) > n) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j0 < j1) {\n\t\t\t\t\ti = j0;\n\t\t\t\t\tt0++;\n\t\t\t\t\tlst = 0;\n\t\t\t\t} else {\n\t\t\t\t\ti = j1;\n\t\t\t\t\tt1++;\n\t\t\t\t\tlst = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t0 == t1 || ((t0 < t1) ^ lst)) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans.pb(mp(max(t0, t1), k));\n\t\t\t}\n\t\t}\n\t\tsort(all(ans));\n\t}\n\t\n\tvoid clear () {\n\t\t*this = Solution();\n\t}\n};\n\nSolution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\twhile (sol.read()) {\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n#else\n\tsol.read();\n\tsol.solve();\n\tsol.write();\n#endif\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Tennis Game.json",
    "editorial_link": "https://codeforces.com/blog/entry/15208",
    "editorial": "Choose some ; now emulate how the match will go, ensure that the record\r\nis valid for this and by the way find the corresponding value of . Print\r\nall valid options for and . This solution works in time, which is not\r\ngood enough, but we will try to optimize it. Suppose the current set if\r\nfinished and we have processed serves by now. Let us process the next\r\nset as follows: find -th and -th after position . If -th occurs earlier,\r\nthen the first player wins the set, and the set concludes right after\r\nthe -th ; the other case is handled symmetrically. If the match is not\r\nover yet, and in the rest of the record there are no ones nor twos, then\r\nthe record is clearly invalid. This way, every single set in the record\r\ncan be processed in time using binary search, or time using precomputed\r\narrays of positions for each player. Now observe that for any a match of\r\nserves can not contain more than sets, as each set contains at least\r\nserves. If we sum up the upper limits for the number of sets for each ,\r\nwe obtain the total upper limit for the number of sets we may need to\r\nprocess: (which is the famous harmonic sum). Using one of the approaches\r\ndiscussed above, one obtains a solution with complexity of or ; each of\r\nthese solutions fits the limit nicely. Obviously, for every there is no\r\nmore than one valid choice for ; however, maybe a bit unexpected, for a\r\ngiven there may exist more than one valid choice of . The first test\r\nwhere this takes place is pretest 12. The statement requires that the\r\npairs are printed lexicographically ordered; it is possible to make a\r\nmistake here and print the pairs with equal by descending (if we fill\r\nthe array by increasing and then simply reverse the array). Challenge:\r\nwhile preparing this problem I discovered that it\u00e2\u0080\u0099s quite hard to find a\r\ntest such that the number of pairs in the answer is large; in the actual\r\ntests the maximal number is 128, which is the number of divisors of the\r\nnumber 83160. Can you beat this record? If you have a test with that has\r\nlarger number of pairs in the answer, feel free to brag in the comments;\r\nalso don\u00e2\u0080\u0099t hesitate to share any insights on how one could bound the\r\nmaximal number analytically.\r\n"
}