{
    "link": "https://codeforces.com//contest/1286/problem/B",
    "problemId": "509640",
    "problem_idx": "B",
    "shortId": "1286B",
    "contest_number": "1286",
    "problem_submissions": {
        "E": [
            68277312,
            68282070,
            68274194,
            68303699,
            68303260,
            68305269,
            68280891,
            68275520,
            68485018,
            68484885,
            68281607,
            68589901,
            71865785,
            101133015,
            68300396
        ],
        "C2": [
            68266879,
            68290041,
            68261617,
            68262301,
            68264579,
            68294367,
            68270650,
            68281404,
            68295029,
            68426335,
            68286377,
            68264588,
            68267031
        ],
        "D": [
            68263572,
            68264108,
            68884999,
            68884847,
            68884788,
            68283246,
            68268908,
            68270542,
            68266913,
            68271305,
            68294377,
            68276847,
            68262972,
            68265436,
            68273176,
            68274949,
            68277188,
            68266253,
            68271981,
            68278589,
            68338459,
            68281162,
            68264815
        ],
        "C1": [
            68253495,
            68254635,
            68259019,
            68259783,
            68260037,
            68294288,
            68263649,
            68253659,
            68276644,
            68259313,
            68260800,
            68257683,
            68278462,
            68275645,
            68260838,
            68264488,
            68260121
        ],
        "B": [
            68249656,
            68250720,
            68252206,
            68250842,
            68249851,
            68249360,
            68294267,
            68254854,
            68250823,
            68250630,
            68252322,
            68250475,
            68253134,
            68252948,
            68253877,
            68249986,
            68255559,
            68256077,
            68252468,
            68253101,
            68252113
        ],
        "A": [
            68245108,
            68248019,
            68248101,
            68248225,
            68245837,
            68246154,
            68294224,
            68250492,
            68248558,
            68247246,
            68248005,
            68247110,
            68249600,
            68246667,
            68250822,
            68253310,
            68252365,
            68251609,
            68247685,
            68248520,
            68246550
        ],
        "F": [
            68288717,
            68426651,
            68284858,
            68284592,
            68283300,
            68321599,
            68593980,
            68272947,
            68281697,
            68274721,
            75028012
        ]
    },
    "name": "B. Numbers on Tree",
    "statement": "Evlampiy was gifted a rooted tree. The vertices of the tree are numbered\r\nfrom 1 to n. Each of its vertices also has an integer a_i written on it.\r\nFor each vertex i, Evlampiy calculated c_i the number of vertices j in\r\nthe subtree of vertex i, such that a_j < a_i. Illustration for the\r\nsecond example, the first integer is a_i and the integer in parentheses\r\nis c_iAfter the new year, Evlampiy could not remember what his gift was!\r\nHe remembers the tree and the values of c_i, but he completely forgot\r\nwhich integers a_i were written on the vertices.Help him to restore\r\ninitial integers!\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[2010];\nint w[2010], root, n, Num[2010], ord[2010], cnt, vis[2010], Res[2010], Rank[2010], Ed[2010], inp[2010];\nvoid DFS(int a, int pp) {\n\tNum[a] = ++cnt;\n\tord[cnt] = a;\n\tfor (auto &x : E[a]) {\n\t\tDFS(x, a);\n\t}\n\tEd[a] = cnt;\n}\nint main() {\n\tint i, a, j;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a) {\n\t\t\tE[a].push_back(i);\n\t\t}\n\t\telse {\n\t\t\troot = i;\n\t\t}\n\t\tscanf(\"%d\", &w[i]);\n\t\tinp[i] = w[i];\n\t}\n\tDFS(root, 0);\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (!vis[ord[j]] && !w[ord[j]])break;\n\t\t}\n\t\tif (j == n + 1) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tint x = ord[j];\n\t\tvis[x] = 1;\n\t\tRes[i] = x;\n\t\tRank[x] = i;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (Num[j] < Num[x] && Num[x] <= Ed[j] && !vis[j]) {\n\t\t\t\tw[j]--;\n\t\t\t\tif (w[j] < 0) {\n\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint c = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (Num[i] < Num[j] && Num[j] <= Ed[i]) {\n\t\t\t\tif (Rank[i] > Rank[j])c++;\n\t\t\t}\n\t\t}\n\t\tif (c != inp[i]) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\tfor (i = 1; i <= n; i++)printf(\"%d \", Rank[i]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Numbers on Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/72867",
    "editorial": "There are several approaches to this problem. We will tell one of them.\r\nNote that if for some vertex is greater than the number of vertices in\r\nits subtree, then there is no answer.Now we prove that we can always\r\nbuild the answer, so that all will be numbers from to . On those\r\nnumbers, letâs build some structure that supports deleting elements and\r\nsearching for k-th element. Letâs denote by the number of vertices in\r\nthe subtree of vertex . Now iterate over the subtree of in the order of\r\nthe depth first search. Then letâs set = -th element in our structure\r\n(and after that delete this element). Firstly, such an element will\r\nalways exist. This is true because when we examine the vertex , all\r\nvertices in the subtree of this vertex are not yet considered since in\r\nour structure there are at least elements. Secondly, the set of all\r\nvalues in the subtree will be a prefix of our structure. If this is\r\ntrue, then the condition that the subtree contains exactly elements\r\nsmaller than ours is guaranteed to be satisfied (because all elements\r\nfrom our structure that are smaller than ours are there, and we\r\nspecifically took the -th element). Let us prove this fact by induction\r\non the size of the tree. For a tree of size this is obvious (we always\r\ntake the first element). Now for size , we have the root on which the\r\nnumber is written. Then when we throw out , and then throw out all the\r\nvertices in the subtree, we will remove the prefix of at least vertices,\r\nwhich means that we will drop all the vertices up to , as well as some\r\nprefix of vertices after it, thus in total weâll throw out some prefix\r\nof vertices.Now, we have reduced the problem to dfs and searching for\r\nk-order statistics. This can be done in a variety of ways - segment\r\ntree, Fenwick tree, sqrt decomposition, Cartesian tree, or a built-in\r\nc++ tree.Code of the author solution with this tree.\r\n",
    "hint": []
}