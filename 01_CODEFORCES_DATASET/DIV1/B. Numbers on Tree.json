{"link": "https://codeforces.com//contest/1286/problem/B", "problemId": "509640", "problem_idx": "B", "shortId": "1286B", "contest_number": "1286", "problem_submissions": {"E": [68277312, 68282070, 68274194, 68303699, 68303260, 68305269, 68280891, 68275520, 68485018, 68484885, 68281607, 68589901, 71865785, 101133015, 68300396], "C2": [68266879, 68290041, 68261617, 68262301, 68264579, 68294367, 68270650, 68281404, 68295029, 68426335, 68286377, 68264588, 68267031], "D": [68263572, 68264108, 68884999, 68884847, 68884788, 68283246, 68268908, 68270542, 68266913, 68271305, 68294377, 68276847, 68262972, 68265436, 68273176, 68274949, 68277188, 68266253, 68271981, 68278589, 68338459, 68281162, 68264815], "C1": [68253495, 68254635, 68259019, 68259783, 68260037, 68294288, 68263649, 68253659, 68276644, 68259313, 68260800, 68257683, 68278462, 68275645, 68260838, 68264488, 68260121], "B": [68249656, 68250720, 68252206, 68250842, 68249851, 68249360, 68294267, 68254854, 68250823, 68250630, 68252322, 68250475, 68253134, 68252948, 68253877, 68249986, 68255559, 68256077, 68252468, 68253101, 68252113], "A": [68245108, 68248019, 68248101, 68248225, 68245837, 68246154, 68294224, 68250492, 68248558, 68247246, 68248005, 68247110, 68249600, 68246667, 68250822, 68253310, 68252365, 68251609, 68247685, 68248520, 68246550], "F": [68288717, 68426651, 68284858, 68284592, 68283300, 68321599, 68593980, 68272947, 68281697, 68274721, 75028012]}, "name": "B. Numbers on Tree", "statement": "Evlampiy was gifted a rooted tree. The vertices of the tree are numbered\r\nfrom 1 to n. Each of its vertices also has an integer a_i written on it.\r\nFor each vertex i, Evlampiy calculated c_i the number of vertices j in\r\nthe subtree of vertex i, such that a_j < a_i. Illustration for the\r\nsecond example, the first integer is a_i and the integer in parentheses\r\nis c_iAfter the new year, Evlampiy could not remember what his gift was!\r\nHe remembers the tree and the values of c_i, but he completely forgot\r\nwhich integers a_i were written on the vertices.Help him to restore\r\ninitial integers!\r\n", "solutions": ["#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[2010];\nint w[2010], root, n, Num[2010], ord[2010], cnt, vis[2010], Res[2010], Rank[2010], Ed[2010], inp[2010];\nvoid DFS(int a, int pp) {\n\tNum[a] = ++cnt;\n\tord[cnt] = a;\n\tfor (auto &x : E[a]) {\n\t\tDFS(x, a);\n\t}\n\tEd[a] = cnt;\n}\nint main() {\n\tint i, a, j;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a);\n\t\tif (a) {\n\t\t\tE[a].push_back(i);\n\t\t}\n\t\telse {\n\t\t\troot = i;\n\t\t}\n\t\tscanf(\"%d\", &w[i]);\n\t\tinp[i] = w[i];\n\t}\n\tDFS(root, 0);\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (!vis[ord[j]] && !w[ord[j]])break;\n\t\t}\n\t\tif (j == n + 1) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tint x = ord[j];\n\t\tvis[x] = 1;\n\t\tRes[i] = x;\n\t\tRank[x] = i;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (Num[j] < Num[x] && Num[x] <= Ed[j] && !vis[j]) {\n\t\t\t\tw[j]--;\n\t\t\t\tif (w[j] < 0) {\n\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint c = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (Num[i] < Num[j] && Num[j] <= Ed[i]) {\n\t\t\t\tif (Rank[i] > Rank[j])c++;\n\t\t\t}\n\t\t}\n\t\tif (c != inp[i]) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\tfor (i = 1; i <= n; i++)printf(\"%d \", Rank[i]);\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "dfs and similar", "graphs", "greedy", "trees"], "dificulty": "1800", "interactive": false}