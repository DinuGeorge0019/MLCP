{
    "link": "https://codeforces.com//contest/1078/problem/D",
    "problemId": "257669",
    "problem_idx": "D",
    "shortId": "1078D",
    "contest_number": "1078",
    "problem_submissions": {
        "D": [
            45940862,
            45933303,
            45935766,
            45933853,
            45930995,
            45936488,
            45940747,
            45943827,
            45939112,
            45949887,
            45939231,
            45940966,
            45940947,
            45958692,
            45958625,
            45928396,
            45942294,
            45942258,
            45942248,
            45942159,
            45942142,
            45942044,
            45941921,
            45940689
        ],
        "E": [
            45937493,
            45942033,
            45960731,
            45946630
        ],
        "B": [
            45928126,
            45925305,
            45926274,
            45926072,
            45923067,
            45926568,
            45940774,
            45920994,
            45922995,
            45940934,
            45949871,
            45927955,
            45922044,
            45923855,
            45923008,
            45958814,
            45932880,
            45923428,
            45938791,
            45941333,
            45925850,
            45924600,
            45924279
        ],
        "C": [
            45926441,
            45929882,
            45930167,
            45929211,
            45934188,
            45931921,
            45926885,
            45928260,
            45930909,
            45932518,
            45925565,
            45924426,
            45931751,
            45929018,
            45958808,
            45923916,
            45927809,
            45932834,
            45932060,
            45934408
        ],
        "A": [
            45921892,
            45921151,
            45920874,
            45923123,
            45920460,
            45920490,
            45920725,
            45923466,
            45934579,
            45920717,
            45924554,
            45958821,
            45927000,
            45931917,
            45930488,
            45922107,
            45922245,
            45921493
        ]
    },
    "name": "D. Chattering",
    "statement": "There are n parrots standing in a circle. Each parrot has a certain\r\nlevel of respect among other parrots, namely r_i. When a parrot with\r\nrespect level x starts chattering, x neighbours to the right and to the\r\nleft of it start repeating the same words in 1 second. Their neighbours\r\nthen start repeating as well, and so on, until all the birds begin to\r\nchatter.You are given the respect levels of all parrots. For each parrot\r\nanswer a question: if this certain parrot starts chattering, how many\r\nseconds will pass until all other birds will start repeating it?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nvector<int> l, r, x;\n\nvector<vector<int> > jl, jr;\n\nint largmin(int i, int j){\n\tif(l[i] < l[j]) return i;\n\treturn j;\n}\nint rargmax(int i, int j){\n\tif(r[i] > r[j]) return i;\n\treturn j;\n}\n\nint lmin(int a, int b){\n\tint z = 0;\n\twhile((1 << (z+1)) <= b-a+1) z += 1;\n\treturn largmin(jl[z][b], jl[z][a-1+(1 << z)]);\n}\nint rmax(int a, int b){\n\tint z = 0;\n\twhile((1 << (z+1)) <= b-a+1) z += 1;\n\treturn rargmax(jr[z][a], jr[z][b+1 - (1 << z)]);\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tx.resize(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x[i];\n\t}\n\tint N = 3*n;\n\tl.resize(N);\n\tr.resize(N);\n\tfor(int i = 0; i < N; i++){\n\t\tl[i] = max(i - x[i % n], 0);\n\t\tr[i] = min(i + x[i % n], N-1);\n\t}\n\tconst int MAXJ = 20;\n\tjl.resize(MAXJ, vector<int>(N));\n\tjr.resize(MAXJ, vector<int>(N));\n\tfor(int j = 0; j < MAXJ; j++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(j == 0){\n\t\t\t\tjl[j][i] = jr[j][i] = i;\n\t\t\t} else {\n\t\t\t\tjl[j][i] = largmin(jl[j-1][i], jl[j-1][max(i - (1 << (j-1)), 0)]);\n\t\t\t\tjr[j][i] = rargmax(jr[j-1][i], jr[j-1][min(i + (1 << (j-1)), N-1)]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > lexpo(MAXJ, vector<int>(N));\n\tvector<vector<int> > rexpo(MAXJ, vector<int>(N));\t\n\tfor(int j = 0; j < MAXJ; j++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(j == 0){\n\t\t\t\tlexpo[j][i] = lmin(l[i], i);\n\t\t\t\trexpo[j][i] = rmax(i, r[i]);\n\t\t\t} else {\n\t\t\t\tlexpo[j][i] = lexpo[j-1][lexpo[j-1][i]];\n\t\t\t\trexpo[j][i] = rexpo[j-1][rexpo[j-1][i]];\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ans(n);\n\tfor(int i = n; i < 2*n; i++){\n\t\tint curl = i;\n\t\tint curr = i;\n\t\tint nsteps = 0;\n\t\twhile(1){\n\t\t\tif(curr - curl + 1 >= n) break;\n\t\t\tfor(int j = MAXJ-1; j >= 0; j--){\n\t\t\t\tint newl = lmin(curl, curr);\n\t\t\t\tint newr = rmax(curl, curr);\n\t\t\t\tint xl = lexpo[j][newl];\n\t\t\t\tint xr = rexpo[j][newr];\n\t\t\t\tif(r[rmax(xl, curl)] > curr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(l[lmin(curr, xr)] < curl){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(r[xr] - l[xl] + 1 >= n) continue;\n\t\t\t\tcurl = l[xl];\n\t\t\t\tcurr = r[xr];\n\t\t\t\tnsteps += 1 + (1<<j);\n\t\t\t}\n\t\t\tif(curr - curl + 1 >= n) break;\n\t\t\tint newl = lmin(curl, curr);\n\t\t\tint newr = rmax(curl, curr);\n\t\t\tcurl = l[newl];\n\t\t\tcurr = r[newr];\n\t\t\tnsteps++;\n\t\t}\n\t\tans[i - n] = nsteps;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Chattering.json",
    "editorial_link": "https://codeforces.com//blog/entry/63324",
    "editorial": "Let us for a moment think that parrots stand in a line. We want to compute a series of values ri,k\n and li,k\n. li,k\n is the index of the leftmost parrot that will chatter in 2k\n seconds after the i\n-th parrot starts chattering. ri,k\n is defined similarly. Clearly, li,0=i?ai\n and ri,0=i+ai\n.\n\nWe calculate li,k\n using the values with lesser k\n. Precisely, li,k=minlt,k?1\n, where t\n goes in range [li,k?1,ri,k?1]\n. Explanation: the i\n-th parrot triggered some t\n-th parrot in 2k?1\n seconds, then the t\n-th parrot triggered some other parrot in next 2k?1\n seconds. Thus we want to find such t\n that the leftmost parrot triggered by t\n is minimum possible.\n\nWe use a segment tree or a sparse table on the values of the (k?1)\n-th level to compute the value of the DP on the k\n-th level.\n\nThe idea for the solution on a circle is essentially the same, but you must consider segments more carefully. One rather simple way to do it is to duplicate all the parrots, now numbering them \u0085,?2,?1,0,1,\u0085,n?1,n,n+1,\u0085\n such that the numbers with the same remainder modulo n\n denote the same parrot. Then we can bound the values for li,k\n and ri,k\n between ?n\n and 2n\n. Now a range query over a circle transforms to a constant number of range queries over a segment.\n\nTime complexity: O(nlog2n)\n."
}