{
    "link": "https://codeforces.com//contest/516/problem/E",
    "problemId": "22481",
    "problem_idx": "E",
    "shortId": "516E",
    "contest_number": "516",
    "problem_submissions": {
        "D": [
            9897778,
            9901317,
            9902316,
            9902257,
            9902926,
            9899362,
            9901747,
            9900577,
            9901753,
            9900598,
            9902022,
            9902250,
            9908234,
            9907894,
            9901637,
            10134694
        ],
        "C": [
            9894077,
            9894988,
            9894528,
            9894592,
            9890787,
            9892570,
            9894045,
            9897863,
            9902115,
            9893633,
            9897304,
            9906453,
            9890308,
            9915358,
            9897994,
            9896924,
            9895656,
            9894595,
            9895218
        ],
        "A": [
            9891009,
            9888069,
            9891404,
            9888532,
            9886301,
            9886680,
            9886736,
            9887016,
            9887312,
            9885451,
            9885346,
            9886088,
            9885688,
            9885877,
            9886467
        ],
        "B": [
            9888215,
            9890996,
            9889129,
            9891841,
            9894454,
            9896886,
            9901312,
            9890721,
            9898664,
            9916236,
            9895068,
            9891776,
            9889048,
            9930005,
            9890589,
            9889796,
            9891061,
            9898651
        ],
        "E": [
            9897098,
            9919136
        ]
    },
    "name": "E. Drazil and His Happy Friends",
    "statement": "Drazil has many friends. Some of them are happy and some of them are\r\nunhappy. Drazil wants to make all his friends become happy. So he\r\ninvented the following plan.There are boys and girls among his friends.\r\nLet’s number them from to and to separately. In -th day, Drazil invites\r\n-th boy and -th girl to have dinner together (as Drazil is programmer,\r\nstarts from ). If one of those two people is happy, the other one will\r\nalso become happy. Otherwise, those two people remain in their states.\r\nOnce a person becomes happy (or if it is happy originally), he stays\r\nhappy forever.Drazil wants to know on which day all his friends become\r\nhappy or to determine if they won’t become all happy at all.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<61)\n\nll func(ll cycle, ll cost, vector <pair <int, int> > init){\n    int i,j;\n    \n//  cout << cycle << ' ' << cost << endl;\n//  REP(i,init.size()) cout << init[i].first << ' ' << init[i].second << endl;\n//  cout << endl;\n    \n    sort(init.begin(),init.end());\n    \n    vector <pair <ll, ll> > v;\n    int sz = init.size();\n    i = 0;\n    while(i < sz){\n        ll best = INF;\n        for(j=i;j<sz;j++){\n            if(init[j].first != init[i].first) break;\n            best = min(best, (ll)init[j].second);\n        }\n        v.push_back(make_pair((ll)init[i].first, best));\n        i = j;\n    }\n    \n    ll ans = 0;\n    \n    sz = v.size();\n    REP(i,sz){\n        ll tmp;\n        if(i == sz-1){\n            tmp = v[0].first - v[sz-1].first + cycle;\n        } else {\n            tmp = v[i+1].first - v[i].first;\n        }\n        ans = max(ans, (tmp - 1) * cost + v[i].second);\n    }\n    \n    return ans;\n}\n\nint gcd(int x, int y){\n    return x ? gcd(y%x, x) : y;\n}\n\nll power(ll x, ll n, ll mod){\n    if(n == 0) return 1;\n    ll y = power(x, n/2, mod);\n    y = y * y % mod;\n    if(n%2 == 1) y = y * x % mod;\n    return y;\n}\n\nll phi(ll n){\n    ll ans = n;\n    ll x = n;\n    \n    for(ll p=2;p*p<=x;p++) if(x % p == 0){\n        while(x % p == 0) x /= p;\n        ans -= ans / p;\n    }\n    \n    if(x != 1) ans -= ans / x;\n    \n    return ans;\n}\n\nvector <pair <int, int> > v[200010];\n\nll func(int X, int Y, vector <int> vx, vector <int> vy){\n    int i;\n    \n    int g = gcd(X, Y);\n    if(g > 200005) return INF;\n    \n    ll r = Y / g;\n    ll mod = X / g;\n    ll yinv = 1;\n    if(mod != 1) yinv = power(r, phi(mod) - 1, mod);\n    \n    REP(i,g) v[i].clear();\n    \n    REP(i,vx.size()){\n        int x = vx[i];\n        int t = vx[i];\n        ll id = (x/g) * yinv % (X/g);\n        v[x%g].push_back(make_pair((int)id, t));\n    }\n    \n    REP(i,vy.size()){\n        int x = vy[i] % X;\n        int t = vy[i];\n        ll id = (x/g) * yinv % (X/g);\n        v[x%g].push_back(make_pair((int)id, t));\n    }\n    \n    REP(i,g) if(v[i].empty()) return INF;\n    \n    ll ans = 0;\n    REP(i,g){\n        ll tmp = func(X / g, Y, v[i]);\n        ans = max(ans, tmp);\n    }\n    \n    return ans;\n}\n\nint tx[1000010];\nint ty[1000010];\n\nvector <int> input(void){\n    int sz,x,i;\n    cin >> sz;\n    vector <int> v;\n    REP(i,sz){\n        scanf(\"%d\", &x);\n        v.push_back(x);\n    }\n    return v;\n}\n\nint main(void){\n    int X,Y,i;\n    \n    cin >> X >> Y;\n    vector <int> vx = input();\n    vector <int> vy = input();\n    \n    int M = 1000000;\n    \n    if(max(X, Y) <= M){\n        REP(i,X) tx[i] = (1<<29);\n        REP(i,Y) ty[i] = (1<<29);\n        REP(i,vx.size()) tx[vx[i]] = -1;\n        REP(i,vy.size()) ty[vy[i]] = -1;\n        \n        REP(i,M) if(tx[i%X] < i || ty[i%Y] < i){\n            tx[i%X] = min(tx[i%X], i);\n            ty[i%Y] = min(ty[i%Y], i);\n        }\n        \n        int ans = 0;\n        REP(i,X) ans = max(ans, tx[i]);\n        REP(i,Y) ans = max(ans, ty[i]);\n        \n    //  REP(i,X) cout << tx[i] << ' '; cout << endl;\n    //  REP(i,Y) cout << ty[i] << ' '; cout << endl;\n        \n        if(ans != (1<<29)){\n            cout << ans << endl;\n            return 0;\n        }\n    }\n    \n    ll ans1 = func(X, Y, vx, vy);\n    ll ans2 = func(Y, X, vy, vx);\n    ll ans = max(ans1, ans2);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    \n    // cout << ans1 << ' ' << ans2 << endl;\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Drazil and His Happy Friends.json",
    "editorial_link": "https://codeforces.com/blog/entry/16468",
    "editorial": "You may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n?*?m (because there are only n?*?m possible pairs of boys and girls).\n\nSo if no one changes from unhappy to happy in consecutive n?*?m days, there won't be any changes anymore since then.\n\nWe can simulate the process of having dinner until there are no status changes in consecutive n?*?m days.\n\nBecause there are only n+m people, it's easy to prove the simulation requires O((n?+?m)?*?n?*?m) days.\n\nBut in fact, the simulation takes only O(n?*?m) days.(More accurately, the bound is (min(n,?m)?+?1)?*?(max(n,?m)?-?1) )\n\nWhat happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)\n\nIn fact, this problem can be solved in O(n?+?m).\n\nLet g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying  will become happy some day because of this person.\n\nSo for each 0???i???g?-?1, we only need to check if there exists at least one person whose number mod g is i and is happy.\n\nIf it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.",
    "hint": []
}