{
    "link": "https://codeforces.com//contest/1039/problem/E",
    "problemId": "215704",
    "problem_idx": "E",
    "shortId": "1039E",
    "contest_number": "1039",
    "problem_submissions": {
        "D": [
            42513714,
            42511510,
            42520062,
            42506634,
            42517597,
            42520159,
            42521567,
            42523747,
            42518726,
            42517947,
            42522840,
            42517334,
            42557382,
            42552709,
            42522292,
            42521116,
            42593278,
            42593192,
            42592919,
            42592856,
            42529738,
            42525570,
            42594801,
            42594517,
            42530840
        ],
        "C": [
            42506498,
            42504177,
            42507968,
            42513002,
            42512024,
            42513641,
            42514946,
            42508788,
            42515591,
            42512122,
            42511727,
            42516665,
            42510178,
            42514370,
            42513831,
            42505887,
            42506202
        ],
        "A": [
            42503958,
            42503367,
            42516900,
            42503286,
            42504774,
            42503703,
            42517670,
            42510165,
            42507659,
            42503441,
            42509759,
            42530985,
            42509802,
            42525002,
            42513799,
            42511865
        ],
        "B": [
            42501109,
            42507268,
            42505627,
            42509001,
            42507388,
            42508900,
            42510540,
            42503816,
            42504282,
            42519348,
            42522856,
            42514032,
            42504233,
            42511724,
            42514814,
            42501808
        ],
        "E": [
            44360079,
            42649854,
            42649543,
            42648847,
            42648674,
            42648023,
            42621125,
            42617681,
            42617609,
            42617300
        ]
    },
    "name": "E. Summer Oenothera Exhibition",
    "statement": "While some people enjoy spending their time solving programming\r\ncontests, Dina prefers taking beautiful pictures. As soon as Byteland\r\nBotanical Garden announced Summer Oenothera Exhibition she decided to\r\ntest her new camera there.The exhibition consists of l = 10^{100}\r\nOenothera species arranged in a row and consecutively numbered with\r\nintegers from 0 to l - 1. Camera lens allows to take a photo of w\r\nspecies on it, i.e. Dina can take a photo containing flowers with\r\nindices from x to x + w - 1 for some integer x between 0 and l - w. We\r\nwill denote such photo with [x, x + w - 1].She has taken n photos, the\r\ni-th of which (in chronological order) is [x_i, x_i + w - 1] in our\r\nnotation. She decided to build a time-lapse video from these photos once\r\nshe discovered that Oenothera blossoms open in the evening. Dina takes\r\neach photo and truncates it, leaving its segment containing exactly k\r\nflowers, then she composes a video of these photos keeping their\r\noriginal order and voil , a beautiful artwork has been created!A scene\r\nis a contiguous sequence of photos such that the set of flowers on them\r\nis the same. The change between two scenes is called a . For example,\r\nconsider the first photo contains flowers [1, 5], the second photo\r\ncontains flowers [3, 7] and the third photo contains flowers [8, 12]. If\r\nk = 3, then Dina can truncate the first and the second photo into [3,\r\n5], and the third photo into [9, 11]. First two photos form a scene,\r\nthird photo also forms a scene and the transition between these two\r\nscenes which happens between the second and the third photos is a cut.\r\nIf k = 4, then each of the transitions between photos has to be a\r\ncut.Dina wants the number of cuts to be as small as possible. Please\r\nhelp her! Calculate the minimum possible number of cuts for different\r\nvalues of k.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n\n# include <iostream>\n# include <immintrin.h>\n# include <array>\n\nusing namespace std;\nint x[101010];\nint n, w, q;\narray<int, 4> foo(array<int, 4> kk) {\n    auto k = _mm_set_epi32(kk[3], kk[2], kk[1], kk[0]);\n    auto from = _mm_set1_epi32(-2e9);\n    auto to = _mm_set1_epi32(-2e9);\n    auto ans = _mm_set1_epi32(1);\n    for (int i = 0; i < n; ++i) {\n        auto val = _mm_set1_epi32(x[i]);\n        from = _mm_max_epi32(from, val);\n        to = _mm_min_epi32(to, val);\n        auto c = _mm_cmpgt_epi32(from, _mm_add_epi32(to, k));\n        ans = _mm_add_epi32(ans, c);\n        from = _mm_add_epi32(from, c & _mm_sub_epi32(val, from));\n        to = _mm_add_epi32(to, c & _mm_sub_epi32(val, to));\n    }\n    array<int, 4> res;\n    _mm_store_si128((__m128i*) &res[0], ans);\n    for (int i = 0; i < 4; ++i) { res[i] = -res[i]; }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> w >> q;\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i];\n    }\n    while (q > 0) {\n        array<int, 4> k;\n        for (int i = 0; i < 4; ++i) cin >> k[i];\n        for (int i = 0; i < 4; ++i) k[i] = w - k[i];\n        auto ans = foo(k);\n        for (int i = 0; i < min(q, 4); ++i) {\n            cout << ans[i] << '\\n';\n        }\n        q -= 4;\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Summer Oenothera Exhibition.json",
    "editorial_link": "https://codeforces.com/blog/entry/61668",
    "editorial": "Let\u00e2\u0080\u0099s reconsider this task in terms of segments: we need to split\r\nsequence of photos-segments into minimum number of contiguous groups\r\nsuch that there exists a subsegment in each group of length , which\r\ncontains inside of each segment of the group.It\u00e2\u0080\u0099s easy to see that if we\r\nmove right edge of each segment to the left by , it\u00e2\u0080\u0099s required to find a\r\nsingle point which is inside of each segments of the group. Let\u00e2\u0080\u0099s\r\nconsider as the length of each segment.Next, it\u00e2\u0080\u0099s always good to include\r\nin next group maximum number of segments until they have a on-empty\r\nintersection. Therefore, we have solution in let\u00e2\u0080\u0099s iterate through all\r\nsegments. If we can add current segment to last group, we add it, else\r\nwe create a new group with single current segment.Furthermore, to find\r\nnext group, we can use segment tree to perform it in . Let\u00e2\u0080\u0099s store\r\nminimum and maximum values of , then we descend the tree to find first\r\nsegment such that maximum left edge is on the right of minimum left\r\nedge.For each and let\u00e2\u0080\u0099s calculate minimum length of segments such that\r\ngroup that starts at element contains at least next segments. Let\u00e2\u0080\u0099s sort\r\nall requests in increasing order. We will answer requests in exactly\r\nthis order. Let\u00e2\u0080\u0099s maintain length of group for current , starting at\r\nelement (but ). There are events of changing this value at most.Let\u00e2\u0080\u0099s\r\nalso maintain values minimum number of groups (and last element of last\r\ngroup) required to jump to element or to jump to element such that .\r\nIt\u00e2\u0080\u0099s easy to see that when changes, only area of radius is changed for .\r\nTherefore may be recalculated in in total.Now we can simulate requests:\r\nwe jump using to the right at least on , therefore there will be jumps\r\nin total.The solution became for .Let\u00e2\u0080\u0099s speed up the solution to . Let\u00e2\u0080\u0099s\r\nchange the meaning of we allow the last group to be not maximal.\r\nTherefore we are now allowed not to recalculate where exactly last\r\nmaximal group ends. During simulation we need to perform request on\r\nsegment tree to understand where exactly last maximal group ends.Now\r\nlet\u00e2\u0080\u0099s do the following: after jump we iterate through next elements and\r\ntry to add it to last non-maximal group. If we already added more than ,\r\nlet\u00e2\u0080\u0099s perform a request on tree in .Therefore the solution performs in .\r\n"
}