{"link": "https://codeforces.com//contest/1083/problem/F", "problemId": "268426", "problem_idx": "F", "shortId": "1083F", "contest_number": "1083", "problem_submissions": {"F": [46915087, 46876311, 46868384, 46877366, 46879128, 46934792, 46934770, 46934758, 46934487, 46934473, 46934346, 46934338, 46934202, 46933927, 46928101, 46927984, 46927894, 46927871, 46927855, 46927824, 46927737, 46927669, 46927614, 46881270], "E": [46869370, 46871694, 46869499, 46863810, 46865492, 46873246, 46870302, 46870225, 46877380, 73537754, 46882329, 46878807, 46866936, 46868963, 46871231, 46872499, 46871547, 46871489, 46871036, 46871727, 46869495, 50322936, 50315966, 49844673, 49844653, 46872514], "C": [46867095, 46877292, 47334658, 46890375, 46870788, 46950972, 46950940, 46950838, 46877308, 46877619, 46875434, 46987974, 46883043, 46874242, 46882744, 46942133], "B": [46861840, 46872617, 46861528, 46859342, 46860406, 46863456, 46865386, 46864693, 46865545, 46861409, 46863762, 46864513, 46863287, 46861669, 46861388, 46863642, 46862875, 46865443, 46861004, 46867808], "A": [46860516, 46860277, 46860154, 46866668, 46859314, 46876109, 46860042, 46861931, 46860073, 46859289, 46859440, 46860646, 46859325, 46859654, 46859377, 46861868, 46860315, 46863438, 46865470, 46859724], "D": [46882403, 46994123]}, "name": "F. The Fair Nut and Amusing Xor", "statement": "The Fair Nut has two arrays a and b, consisting of n numbers. He found\r\nthem so long ago that no one knows when they came to him.The Fair Nut\r\noften changes numbers in his arrays. He also is interested in how\r\nsimilar a and b are after every modification.Let\u2019s denote similarity of\r\ntwo arrays as the minimum number of operations to apply to make arrays\r\nequal (every operation can be applied for both arrays). If it is\r\nimpossible, similarity will be equal -1.Per one operation you can choose\r\na subarray with length k (k is fixed), and change every element a_i,\r\nwhich belongs to the chosen subarray, to a_i\r\noplus x (x can be chosen), where\r\noplus denotes the bitwise XOR operation. Nut has already calculated the\r\nsimilarity of the arrays after every modification. Can you do it?Note\r\nthat you just need to calculate those values, that is you do not need to\r\napply any operations.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=200*1007;\nconst int d=1000;\nconst int vax=(1<<14);\n\nint wyn;\nint nanie;\n\nvoid ans()\n{\n\tif (nanie)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tprintf(\"%d\\n\", wyn);\n}\n\nstruct ogarniacz\n{\n\tbool brut=false;\n\t\n\tint r;\n\tvi wek;\n\tvi narz;\n\tvector <vi> bloczek;\n\t\n\tvoid init(int v)\n\t{\n\t\tif (v<=d)\n\t\t{\n\t\t\tbrut=true;\n\t\t\tr=v;\n\t\t\twek.resize(r);\n\t\t\treturn;\n\t\t}\n\t\tr=v/d+2;\n\t\twek.resize(r*d, 0);\n\t\tnarz.resize(r+1, 0);\n\t\tbloczek.resize(r, vi(vax, 0));\n\t\tfor (int i=0; i<r; i++)\n\t\t\tbloczek[i][0]=d;\n\t}\n\tvoid xoruj(int v, int x)\n\t{\n\t\tif (brut)\n\t\t{\n\t\t\tint wsz=0;\n\t\t\tfor (const int &i : wek)\n\t\t\t\twsz^=i;\n\t\t\tif (wsz)\n\t\t\t\tnanie--;\n\t\t\t\n\t\t\tint s=0;\n\t\t\tfor (const int &i : wek)\n\t\t\t{\n\t\t\t\ts^=i;\n\t\t\t\twyn-=(s>0);\n\t\t\t}\t\n\t\t\twek[v]^=x;\n\t\t\ts=0;\n\t\t\tfor (const int &i : wek)\n\t\t\t{\n\t\t\t\ts^=i;\n\t\t\t\twyn+=(s>0);\n\t\t\t}\t\n\t\t\t\n\t\t\twsz^=x;\n\t\t\tif (wsz)\n\t\t\t\tnanie++;\n\t\t\treturn;\n\t\t}\n\t\tif (narz[r])\n\t\t\tnanie--;\n\t\tfor (int i=0; i<r; i++)\n\t\t\twyn-=d-bloczek[i][narz[i]];\n\t\t\t\n\t\tint g=v/d;\n\t\tfor (int i=v; i<(g+1)*d; i++)\n\t\t{\n\t\t\tbloczek[g][wek[i]]--;\n\t\t\twek[i]^=x;\n\t\t\tbloczek[g][wek[i]]++;\n\t\t}\n\t\tfor (int i=g+1; i<=r; i++)\n\t\t\tnarz[i]^=x;\n\t\t\n\t\tfor (int i=0; i<r; i++)\n\t\t\twyn+=d-bloczek[i][narz[i]];\n\t\tif (narz[r])\n\t\t\tnanie++;\n\t}\n};\n\nint n, k, q;\nint tab[2][nax];\n\nint chce[nax];\n\nogarniacz data[nax];\n\nvoid myk(int v, int x)\n{\n\tdata[v%k].xoruj(v/k, x);\n}\n\nvoid ustaw(int v, int a, int b)\n{\n\tint zm=tab[v][a]^b;\n\ttab[v][a]=b;\n\tmyk(a-1, zm);\n\tmyk(a, zm);\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &k, &q);\n\tfor (int i=0; i<=n; i++)\n\t\tchce[i%k]++;\n\tfor (int i=0; i<k; i++)\n\t\tdata[i].init(chce[i]);\n\tfor (int h=0; h<2; h++)\n\t{\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tustaw(h, i, x);\n\t\t}\n\t}\n\tans();\n\twhile(q--)\n\t{\n\t\tchar a;\n\t\tint b, c;\n\t\tscanf(\" %c%d%d\", &a, &b, &c);\n\t\tustaw(a-'a', b, c);\n\t\tans();\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3300", "interactive": false}