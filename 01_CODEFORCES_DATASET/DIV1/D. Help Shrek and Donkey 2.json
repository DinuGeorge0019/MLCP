{"link": "https://codeforces.com//contest/142/problem/D", "problemId": "758", "problem_idx": "D", "shortId": "142D", "contest_number": "142", "problem_submissions": {"D": [1037429, 1033957, 1037084, 1113531, 1036315, 1036207, 1039046, 1039771, 1035511, 1039807], "C": [1036084, 1037803, 1040168, 1038580, 1038178, 1041260, 1038906, 1038902, 1038753, 1034775, 1040737, 1039056, 1038416, 1037153, 1034481], "B": [1032453, 1035023, 1033212, 1031763, 1032487, 1041275, 1033427, 1034500, 1033279, 1036000, 1032039, 1042729, 1042583, 1032611, 1033180, 1033834, 1032713, 1034068, 1032534], "A": [1031075, 1031753, 1031668, 1031166, 1031287, 1041290, 1031330, 1031886, 1032150, 1031269, 1033203, 1031404, 1031249, 1031261, 1031962, 1031577, 1031132], "E": [1356376, 1131959, 1131952, 1131947]}, "name": "D. Help Shrek and Donkey 2", "statement": "Having learned (not without some help from the Codeforces participants)\r\nto play the card game from the previous round optimally, Shrek and\r\nDonkey (as you may remember, they too live now in the Kingdom of Far Far\r\nAway) have decided to quit the boring card games and play with toy\r\nsoldiers.The rules of the game are as follows: there is a battlefield,\r\nits size equals squares, some squares contain the toy soldiers (the\r\ngreen ones belong to Shrek and the red ones belong to Donkey). Besides,\r\neach of the lines of the area contains not more than two soldiers.\r\nDuring a move a players should not less than and not more than soldiers\r\nbelonging to him and make them either or .An is moving all of the\r\nselected soldiers along the lines on which they stand an enemy soldier,\r\nif he is in this line. If this line doesn\u2019t have an enemy soldier, then\r\nthe selected soldier on this line can move in any direction during the\r\nplayer\u2019s move. Each selected soldier has to move at least by one cell.\r\nDifferent soldiers can move by a different number of cells. During the\r\nattack the soldiers are not allowed to cross the cells where other\r\nsoldiers stand (or stood immediately before the attack). It is also not\r\nallowed to go beyond the battlefield or finish the attack in the cells,\r\nwhere other soldiers stand (or stood immediately before attack).A is\r\nmoving all of the selected soldiers along the lines on which they stand\r\nan enemy soldier, if he is in this line. For example, let\u2019s suppose that\r\nthe original battlefield had the form (here symbols \"\" mark Shrek\u2019s\r\ngreen soldiers and symbols \"\" mark Donkey\u2019s red ones): Let\u2019s suppose\r\nthat and Shrek moves first. If he decides to , then after his move the\r\nbattlefield can look like that: If in the previous example Shrek decides\r\nto , then after his move the battlefield can look like that: On the\r\nother hand, the followings fields cannot result from Shrek\u2019s correct\r\nmove: Shrek starts the game. To make a move means to attack or to\r\nretreat by the rules. A player who cannot make a move loses and his\r\nopponent is the winner. Determine the winner of the given toy soldier\r\ngame if Shrek and Donkey continue to be under the yellow pills from the\r\nlast rounds\u2019 problem. Thus, they always play optimally (that is, they\r\ntry to win if it is possible, or finish the game in a draw, by ensuring\r\nthat it lasts forever, if they cannot win).\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <queue>\n#include <memory.h>\n#include <stack>\n#define mp make_pair\n#define pb push_back                     \n#define setval(a,v) memset(a,v,sizeof(a))\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nint sum[100];\nint n,m,k;\n\nvoid add(int a){\n   for (int i = 0; i < 10; i++)\n        if (a & (1<<i))\n            sum[i]++,sum[i] %= (k+1);\n\n}\n\nint main()\n{\n  #ifdef LOCAL\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n  #endif\n    scanf(\"%d %d %d\",&n,&m,&k);\n\n    bool d1,d2;\n    d1 = d2 = false;\n    for (int i = 0; i < n; i++){\n        int pos1,pos2;\n        int cnt1,cnt2;\n        cnt1 = cnt2 = 0;\n        pos1 = pos2 = -1;\n        for (int j = 0; j < m; j++){\n            char c;\n            scanf(\" %c \",&c);\n            if (c == 'G'){\n               pos1 = j; \n               cnt1++;\n            }\n            else if (c == 'R'){\n                pos2 = j;\n                cnt2++;\n            }\n        }\n       // cerr << pos1 <<\" \"<<pos2 << endl;\n        if (pos1 == -1 && pos2 == -1)\n            continue;\n        if (pos1 == -1 && cnt2 != m)\n            d2 = 1;\n        else if (pos2 == -1 && cnt1 != m)\n            d1 = 1;\n        else {\n            if (pos1 != -1 && pos2 != -1)\n                add(abs(pos1-pos2)-1);\n        }\n    }\n\n\n    if (d1 && !d2){\n        printf(\"First\\n\");\n        return 0;\n    }\n\n    if (d2 && !d1){\n        printf(\"Second\\n\");\n        return 0;\n    }\n    if (d1 && d2){\n        printf(\"Draw\\n\");\n        return 0;\n    }\n\n\n    for (int i = 0; i < 10; i++)\n        if (sum[i]){\n            printf(\"First\\n\");\n            return 0;\n        }\n    printf(\"Second\\n\");\n    return 0;\n}"], "input": "", "output": "", "tags": ["games"], "dificulty": "2600", "interactive": false}