{
    "link": "https://codeforces.com//contest/145/problem/A",
    "problemId": "835",
    "problem_idx": "A",
    "shortId": "145A",
    "contest_number": "145",
    "problem_submissions": {
        "E": [
            1105208,
            1105912,
            1104894,
            1102760,
            1106240,
            1105850,
            1107323,
            1106178,
            1106652,
            1107141,
            1106053,
            1106917,
            1110162,
            1106271,
            1108116,
            1106093,
            1106858,
            1105628,
            1106422
        ],
        "C": [
            1103754,
            1105077,
            1104008,
            1104728,
            1104390,
            1104502,
            1105076,
            1107490,
            1105685,
            1104716,
            1104727,
            1105594,
            1110098,
            1102678,
            1104471,
            1104980,
            1102716,
            1106604,
            1105209
        ],
        "B": [
            1102413,
            1103328,
            1106135,
            1106485,
            1102911,
            1103531,
            1103090,
            1103085,
            1103776,
            1103710,
            1107536,
            1102801,
            1110016,
            1106756,
            1108339
        ],
        "A": [
            1101171,
            1101193,
            1101307,
            1101588,
            1101358,
            1101247,
            1101150,
            1101748,
            1101315,
            1101364,
            1101363,
            1110038,
            1103077,
            1101351,
            1101685,
            1101209,
            1101163,
            1101232
        ],
        "D": [
            1131693,
            1131692,
            1124995,
            107142023,
            107141858,
            107141498,
            107140808,
            107137178
        ]
    },
    "name": "A. Lucky Conversion",
    "statement": "Petya has two strings and of the same length . The strings consist only\r\nof lucky digits. Petya can perform of two types: replace any one digit\r\nfrom string by its opposite (i.e., replace by and by ); swap any pair of\r\ndigits in string . Petya is interested in the minimum number of\r\noperations that are needed to make string equal to string . Help him\r\nwith the task.\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define REP(i,n) for (int i=0,_n=(n); i < _n; i++)\n#define REPD(i,n) for (int i=(n)-1; i >= 0; i--)\n#define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n\n#define CLEAR(x) memset(x,0,sizeof x);\n#define CLEARA(x) memset(&x,0,sizeof x);\n#define FILL(x,v) memset(x,v,sizeof x);\n#define FILLA(x,v) memset(&x,v,sizeof x);\n\n#define VAR(a,b) __typeof(b) a=(b)\n#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)\n\n#define REVERSE(c) reverse(ALL(c))\n#define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())\n#define INF 0x7fffffff\n#define X first\n#define Y second\n#define pb push_back\n#define SZ(c) (int)(c).size()\n#define MP make_pair\n#define eps 1.0e-11\nconst double pi = acos(-1.0);\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long LL;\n\nint n;\nchar a[1024000];\nchar b[1024000];\n\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tgets(a);\n\tgets(b);\n\tn=strlen(a);\n\tint x=0,y=0;\n\tREP(i,n) if (a[i]!=b[i])\n\t\tif (a[i]=='4')\n\t\t\t++x;\n\t\telse\n\t\t\t++y;\n\tprintf(\"%d\\n\",max(x,y));\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Lucky Conversion.json",
    "editorial_link": "https://codeforces.com//blog/entry/3746",
    "editorial": "You need to find two numbers: c47 (number of such positions i, that ai?=?4 and bi?=?7) and c74 (number of such positions that ai?=?7 and bi?=?4). After that the result will be max(c47,?c74) (because you need to obtain min(c47,?c74) swaps, the rest max(c47,?c74)?-?min(c47,?c74) are editings of digits)."
}