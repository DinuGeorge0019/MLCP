{
    "link": "https://codeforces.com//contest/461/problem/E",
    "problemId": "13284",
    "problem_idx": "E",
    "shortId": "461E",
    "contest_number": "461",
    "problem_submissions": {
        "E": [
            7595647,
            7593699,
            7595828,
            7594579,
            7595368,
            7600512,
            7595421,
            7661605,
            9294347,
            9294343,
            10452636
        ],
        "D": [
            7592651,
            7591771,
            7603387,
            7594572,
            7594433,
            7594196,
            7595170,
            7595635,
            7724393,
            7593683,
            7594245,
            7661058,
            8893908,
            10452336
        ],
        "C": [
            7587261,
            7587069,
            7586600,
            7586584,
            7590688,
            7588429,
            7587923,
            7590253,
            7588926,
            7591752,
            7589784,
            7592394,
            7587055,
            7589392,
            7587666,
            7587706,
            7588473
        ],
        "B": [
            7582196,
            7583106,
            209010830,
            7582794,
            7583033,
            7586901,
            7583221,
            7584128,
            7587075,
            7584566,
            7585023,
            7585807,
            7586879,
            7595401,
            7583774,
            7584143,
            7583861
        ],
        "A": [
            7580528,
            7580809,
            7580521,
            7581246,
            7587762,
            7581843,
            7580912,
            7581190,
            7581018,
            7581719,
            7581029,
            7581078,
            7581003,
            7584251,
            7580442,
            7580814,
            7580452
        ]
    },
    "name": "E. Appleman and a Game",
    "statement": "Appleman and Toastman like games. Today they play a game with strings\r\nwith the following rules. Firstly Toastman tells Appleman two strings\r\nand both consisting only of letters \u201d, \u201d, \u201d, \u201d. Then Appleman must build\r\nstring as quickly as possible. Initially he has empty string, and in one\r\nsecond he can append to end of the current string any contiguous\r\nsubstring of .Now, Toastman and Appleman are beginning to play the game.\r\nToastman has already told string to Appleman, but he hasn\u2019t come up with\r\nstring yet. Toastman only thinks, that he should choose string\r\nconsisting of characters. Of course, he wants to find the worst string\r\nfor Appleman (such string, that Appleman will spend as much time as\r\npossible during the game). Tell Toastman, how much time will Appleman\r\nspend during the game if Toastman finds the worst string for him. You\r\ncan assume that Appleman plays optimally, therefore he builds any string\r\nin minimal possible time.\r\n",
    "solutions": [
        "/*\n * cheat.cpp\n *\n *  Created on: 2012-5-25\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <string>\n#include <vector>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_LEN = int(1e5) + 10;\n\nstruct State {\n\tState*suf, *go[4];\n\tint val;\n\tState() :\n\t\t\tsuf(0), val(0) {\n\t\tmemset(go, 0, sizeof go);\n\t}\n}*root, *last;\nState statePool[MAX_LEN * 2], *cur = statePool;\n\nvoid init() {\n\troot = last = cur++;\n}\n\nvoid extend(int w) {\n\tState*p = last, *np = cur++;\n\tnp->val = p->val + 1;\n\twhile (p && !p->go[w])\n\t\tp->go[w] = np, p = p->suf;\n\tif (!p)\n\t\tnp->suf = root;\n\telse {\n\t\tState*q = p->go[w];\n\t\tif (p->val + 1 == q->val)\n\t\t\tnp->suf = q;\n\t\telse {\n\t\t\tState*nq = cur++;\n\t\t\tmemcpy(nq->go, q->go, sizeof q->go);\n\t\t\tnq->val = p->val + 1;\n\t\t\tnq->suf = q->suf;\n\t\t\tq->suf = nq;\n\t\t\tnp->suf = nq;\n\t\t\twhile (p && p->go[w] == q)\n\t\t\t\tp->go[w] = nq, p = p->suf;\n\t\t}\n\t}\n\tlast = np;\n}\n\nint buf[MAX_LEN];\n//int n, m;\ntypedef long long int64;\ntypedef vector<vector<int64> > mat;\n\nconst int64 INF = 1LL << 61;\n\nmat zero(int n) {\n\tmat a(n, vector<int64>(n, 0));\n\treturn a;\n}\n\nmat unit(int n) {\n\tmat c = zero(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tc[i][j] = (i == j) ? 0 : INF;\n\t\t}\n\t}\n\treturn c;\n}\n\nmat mul(mat a, mat b) {\n\tint n = a.size();\n\tmat c = zero(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tc[i][j] = INF;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tc[i][j] = min(c[i][j], a[i][k] + b[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nlong long N;\nint n;\n\nint64 COST[4][4];\nint main() {\n\tinit();\n\tcin >> N;\n\tstring t;\n\tcin >> t;\n\tn = t.size();\n\tstring ABCD = \"ABCD\";\n\tfor (int i = 0; i < t.size(); ++i) {\n\t\tint me = ABCD.find(t[i]);\n\t\tbuf[i] = me;\n\t\textend(me);\n\t}\n\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tCOST[i][j] = INF;\n\t\t}\n\t}\n\n\tfor (int forbid = 0; forbid < 4; ++forbid) {\n\t\tState*cur = root;\n\t\tint l = 0;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\twhile (i + l < n && cur->go[forbid])\n\t\t\t\tcur = cur->go[buf[i + l]], l++;\n\t\t\tif (!cur->go[forbid]) {\n//\t\t\t\tCOST[buf[i]][forbid] = l;\n\t\t\t\tCOST[buf[i]][forbid] = min(COST[buf[i]][forbid], 1LL * l);\n\t\t\t}\n\t\t\tif (l > 0) {\n\t\t\t\t--l;\n\t\t\t\tif (l <= cur->suf->val)\n\t\t\t\t\tcur = cur->suf;\n\t\t\t}\n\t\t}\n\t}\n\n//\tfor (int i = 0; i < 4; ++i) {\n//\t\tfor (int j = 0; j < 4; ++j) {\n//\t\t\tcout << COST[i][j] << \" \";\n//\t\t}\n//\t\tcout << endl;\n//\t}\n\n\tmat one = zero(4);\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tone[i][j] = COST[i][j];\n\t\t}\n\t}\n\n\tvector<mat> pw(70);\n\tpw[0] = one;\n\tfor (int i = 1; i < 70; ++i) {\n\t\tpw[i] = mul(pw[i - 1], pw[i - 1]);\n\t}\n\tmat cur = unit(4);\n\tlong long ans = 0;\n\tfor (int i = 70 - 1; i >= 0; --i) {\n\t\tmat ncur = mul(cur, pw[i]);\n\t\tint64 best = INF;\n\t\tfor (int a = 0; a < 4; ++a) {\n\t\t\tfor (int b = 0; b < 4; ++b) {\n\t\t\t\tbest = min(best, ncur[a][b]);\n\t\t\t}\n\t\t}\n\t\tif (best <= N) {\n\t\t\tcur = ncur;\n\t\t\tans += 1LL << i;\n\t\t}\n\t}\n\tint64 best = INF;\n\tfor (int a = 0; a < 4; ++a) {\n\t\tfor (int b = 0; b < 4; ++b) {\n\t\t\tbest = min(best, cur[a][b]);\n\t\t}\n\t}\n\tif (best < N)\n\t\t++ans;\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "shortest paths",
        "strings"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Appleman and a Game.json",
    "editorial_link": "https://codeforces.com/blog/entry/13568",
    "editorial": "Let C be the number of characters(here, C=4) Given string S, the way to\r\nachieve minimum steps is as follows: Append one of the longest substring\r\nof T that fits current position of string S. Appending a not-longest\r\nsubstring can be replaced by appending longest substring and shortening\r\nthe next substring appended. Let dp[K][c1][c2] be defined as : the\r\nminimum length of string that can be obtained by appending a string K\r\ntimes and that starts by character c1 and whose next character is c2.\r\nNote that next character is not counted in the length. dp[1] can be\r\ncalculated as follows: For every string of length L expressed by C\r\ncharacters, if the string is not included in T, update the dp table as\r\ndp[1][the string\u00e2\u0080\u0099s first character][its last character]=min(dp[1][its\r\nfirst character][its last character],L-1) For any (c1,c2), dp[1][c1][c2]\r\nis smaller than or equal to log_C(T+1)+2 (since the kind of strings of\r\nlength log_C(T+1)+2 that start by c1 and end by c2 is equals to T+1).\r\nTherefore for L=1...log(T+1)+2, try all the strings as described above.\r\nAlso we can use trie that contains all substrings of T of length\r\nlog_C(T+1)+2, and find what can\u00e2\u0080\u0099t be described as a substring of T by\r\none step. Since dp[k+1][c1][c2]=min(dp[k][c1][c3]+dp[1][c3][c2] |\r\nc3=1...C), we can use matrix multiplication to get dp[K]. For a integer\r\nK, if there is (c1,c2) such that dp[K][c1][c2]<|S|, the answer is\r\ngreater than K. Otherwise,the answer is smaller than or equal to K.\r\nSince answer is bigger or equal to 1 and smaller or equal to |S|, we can\r\nuse binary search to find the ansewr. O(T*((log T)^2+C^2)+C^3(log\r\n|S|)^2) BONUS: Is there any algorithm that solves in O(1) or\r\nO(C^foo)(that is, not depended on |S|) for each |S| with pre-calc? Some\r\nhints: Maximal value of dp[1][*][*] Minimal value of dp[1][*][*] <= 2\r\n(let\u00e2\u0080\u0099s call the maximal value dp[1][i][j]=L. Here, any C^(L-2) strings\r\nare contained in T as substring, so for any (c1,c2), dp[1][c1][c2]>=L-2)\r\nMaximal value of dp[1][k][*] minimal value of dp[1][k][*] <=1 ( k=1...C)\r\nMaximal value of dp[1][*][k] minimal value of dp[1][*][k] <=1 ( k=1...C)\r\nEven if we use these hints and make C=3, the implementation would be not\r\neasy. If you come up with smart way, please comment here :)\r\n"
}