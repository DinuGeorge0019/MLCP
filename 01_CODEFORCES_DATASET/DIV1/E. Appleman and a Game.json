{"link": "https://codeforces.com//contest/461/problem/E", "problemId": "13284", "problem_idx": "E", "shortId": "461E", "contest_number": "461", "problem_submissions": {"E": [7595647, 7593699, 7595828, 7594579, 7595368, 7600512, 7595421, 7661605, 9294347, 9294343, 10452636], "D": [7592651, 7591771, 7603387, 7594572, 7594433, 7594196, 7595170, 7595635, 7724393, 7593683, 7594245, 7661058, 8893908, 10452336], "C": [7587261, 7587069, 7586600, 7586584, 7590688, 7588429, 7587923, 7590253, 7588926, 7591752, 7589784, 7592394, 7587055, 7589392, 7587666, 7587706, 7588473], "B": [7582196, 7583106, 209010830, 7582794, 7583033, 7586901, 7583221, 7584128, 7587075, 7584566, 7585023, 7585807, 7586879, 7595401, 7583774, 7584143, 7583861], "A": [7580528, 7580809, 7580521, 7581246, 7587762, 7581843, 7580912, 7581190, 7581018, 7581719, 7581029, 7581078, 7581003, 7584251, 7580442, 7580814, 7580452]}, "name": "E. Appleman and a Game", "statement": "Appleman and Toastman like games. Today they play a game with strings\r\nwith the following rules. Firstly Toastman tells Appleman two strings\r\nand both consisting only of letters \u201d, \u201d, \u201d, \u201d. Then Appleman must build\r\nstring as quickly as possible. Initially he has empty string, and in one\r\nsecond he can append to end of the current string any contiguous\r\nsubstring of .Now, Toastman and Appleman are beginning to play the game.\r\nToastman has already told string to Appleman, but he hasn\u2019t come up with\r\nstring yet. Toastman only thinks, that he should choose string\r\nconsisting of characters. Of course, he wants to find the worst string\r\nfor Appleman (such string, that Appleman will spend as much time as\r\npossible during the game). Tell Toastman, how much time will Appleman\r\nspend during the game if Toastman finds the worst string for him. You\r\ncan assume that Appleman plays optimally, therefore he builds any string\r\nin minimal possible time.\r\n", "solutions": ["/*\n * cheat.cpp\n *\n *  Created on: 2012-5-25\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <string>\n#include <vector>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_LEN = int(1e5) + 10;\n\nstruct State {\n\tState*suf, *go[4];\n\tint val;\n\tState() :\n\t\t\tsuf(0), val(0) {\n\t\tmemset(go, 0, sizeof go);\n\t}\n}*root, *last;\nState statePool[MAX_LEN * 2], *cur = statePool;\n\nvoid init() {\n\troot = last = cur++;\n}\n\nvoid extend(int w) {\n\tState*p = last, *np = cur++;\n\tnp->val = p->val + 1;\n\twhile (p && !p->go[w])\n\t\tp->go[w] = np, p = p->suf;\n\tif (!p)\n\t\tnp->suf = root;\n\telse {\n\t\tState*q = p->go[w];\n\t\tif (p->val + 1 == q->val)\n\t\t\tnp->suf = q;\n\t\telse {\n\t\t\tState*nq = cur++;\n\t\t\tmemcpy(nq->go, q->go, sizeof q->go);\n\t\t\tnq->val = p->val + 1;\n\t\t\tnq->suf = q->suf;\n\t\t\tq->suf = nq;\n\t\t\tnp->suf = nq;\n\t\t\twhile (p && p->go[w] == q)\n\t\t\t\tp->go[w] = nq, p = p->suf;\n\t\t}\n\t}\n\tlast = np;\n}\n\nint buf[MAX_LEN];\n//int n, m;\ntypedef long long int64;\ntypedef vector<vector<int64> > mat;\n\nconst int64 INF = 1LL << 61;\n\nmat zero(int n) {\n\tmat a(n, vector<int64>(n, 0));\n\treturn a;\n}\n\nmat unit(int n) {\n\tmat c = zero(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tc[i][j] = (i == j) ? 0 : INF;\n\t\t}\n\t}\n\treturn c;\n}\n\nmat mul(mat a, mat b) {\n\tint n = a.size();\n\tmat c = zero(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tc[i][j] = INF;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tc[i][j] = min(c[i][j], a[i][k] + b[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nlong long N;\nint n;\n\nint64 COST[4][4];\nint main() {\n\tinit();\n\tcin >> N;\n\tstring t;\n\tcin >> t;\n\tn = t.size();\n\tstring ABCD = \"ABCD\";\n\tfor (int i = 0; i < t.size(); ++i) {\n\t\tint me = ABCD.find(t[i]);\n\t\tbuf[i] = me;\n\t\textend(me);\n\t}\n\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tCOST[i][j] = INF;\n\t\t}\n\t}\n\n\tfor (int forbid = 0; forbid < 4; ++forbid) {\n\t\tState*cur = root;\n\t\tint l = 0;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\twhile (i + l < n && cur->go[forbid])\n\t\t\t\tcur = cur->go[buf[i + l]], l++;\n\t\t\tif (!cur->go[forbid]) {\n//\t\t\t\tCOST[buf[i]][forbid] = l;\n\t\t\t\tCOST[buf[i]][forbid] = min(COST[buf[i]][forbid], 1LL * l);\n\t\t\t}\n\t\t\tif (l > 0) {\n\t\t\t\t--l;\n\t\t\t\tif (l <= cur->suf->val)\n\t\t\t\t\tcur = cur->suf;\n\t\t\t}\n\t\t}\n\t}\n\n//\tfor (int i = 0; i < 4; ++i) {\n//\t\tfor (int j = 0; j < 4; ++j) {\n//\t\t\tcout << COST[i][j] << \" \";\n//\t\t}\n//\t\tcout << endl;\n//\t}\n\n\tmat one = zero(4);\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tone[i][j] = COST[i][j];\n\t\t}\n\t}\n\n\tvector<mat> pw(70);\n\tpw[0] = one;\n\tfor (int i = 1; i < 70; ++i) {\n\t\tpw[i] = mul(pw[i - 1], pw[i - 1]);\n\t}\n\tmat cur = unit(4);\n\tlong long ans = 0;\n\tfor (int i = 70 - 1; i >= 0; --i) {\n\t\tmat ncur = mul(cur, pw[i]);\n\t\tint64 best = INF;\n\t\tfor (int a = 0; a < 4; ++a) {\n\t\t\tfor (int b = 0; b < 4; ++b) {\n\t\t\t\tbest = min(best, ncur[a][b]);\n\t\t\t}\n\t\t}\n\t\tif (best <= N) {\n\t\t\tcur = ncur;\n\t\t\tans += 1LL << i;\n\t\t}\n\t}\n\tint64 best = INF;\n\tfor (int a = 0; a < 4; ++a) {\n\t\tfor (int b = 0; b < 4; ++b) {\n\t\t\tbest = min(best, cur[a][b]);\n\t\t}\n\t}\n\tif (best < N)\n\t\t++ans;\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "shortest paths", "strings"], "dificulty": "3000", "interactive": false}