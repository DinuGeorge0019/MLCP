{"link": "https://codeforces.com//contest/1854/problem/D", "problemId": "2119350", "problem_idx": "D", "shortId": "1854D", "contest_number": "1854", "problem_submissions": {"F": [216373971, 217354172, 217397292], "D": [216310150, 216289199, 216321960, 216339370, 216308614, 216330486, 216327260, 216330943, 216339614, 216349670, 216345647, 216345106, 224815766, 216547574, 216366587], "E": [216288237, 216300028, 216302036, 216268441, 216334493, 216313354, 216348664, 216267007, 216336955, 216296297, 216300153, 216312130, 216307051, 216317337, 216275749, 216320776, 216324267, 216319909, 216313856], "C": [216273942, 216261365, 216266654, 216275371, 216264423, 216276518, 216281959, 216283401, 216256269, 216270575, 216274010, 216274561, 216269163, 216301579, 216282188, 216295268, 216271804, 216301995], "A2": [216264333, 216379126, 216379111, 216318393, 216275667, 216295850, 216251357, 216257398, 216276514, 216268588, 216307226, 216280080, 216286828, 216278270, 216337810, 216308708, 216280874, 216295056, 216275828], "A1": [216258579, 216252405, 216255683, 216241030, 216251535, 216248642, 216276758, 216268768, 216282006, 216259868, 216249337, 216287041, 216244661, 216249684, 216243548, 216258618, 216238489, 216275974], "B": [216248516, 216256912, 216241500, 216256089, 216258617, 216267337, 216293058, 216272552, 216268356, 216253180, 216258044, 216262545, 216263544, 216287092, 216255748, 216251265, 216280599, 216287965]}, "name": "D. Michael and Hotel", "statement": "Michael and Brian are stuck in a hotel with n rooms, numbered from 1 to\r\nn, and need to find each other. But this hotel\u2019s doors are all locked\r\nand the only way of getting around is by using the teleporters in each\r\nroom. Room i has a teleporter that will take you to room a_i (it might\r\nbe that a_i = i). But they don\u2019t know the values of a_1,a_2,\r\ndots, a_n.Instead, they can call up the front desk to ask queries. In\r\none query, they give a room u, a positive integer k, and a set of rooms\r\nS. The hotel concierge answers whether a person starting in room u, and\r\nusing the teleporters k times, ends up in a room in S.Brian is in\r\nroom 1. Michael wants to know the set A of rooms so that if he starts in\r\none of those rooms they can use the teleporters to meet up. He can ask\r\nat most 2000 queries.The values a_1, a_2,\r\ndots, a_n are fixed before the start of the interaction and do not\r\ndepend on your queries. In other words, the interactor is not adaptive.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\n\nint n;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint jeszcze=2000;\n\nint pyt(int v, int k, vi wek)\n{\n\tjeszcze--;\n\tif (jeszcze<0)\n\t\twhile(1);\n\tprintf(\"? %d %d %d\", v, k, (int)wek.size());\n\tfor (int i : wek)\n\t\tprintf(\" %d\", i);\n\tprintf(\"\\n\");\n\tff();\n\tint ret;\n\tscanf(\"%d\", &ret);\n\treturn ret;\n}\n\nvoid ans(vi wek)\n{\n\tprintf(\"! %d\", (int)wek.size());\n\tfor (int i : wek)\n\t\tprintf(\" %d\", i);\n\tprintf(\"\\n\");\n\tff();\n\texit(0);\n}\n\nvi przedzial(int a, int b)\n{\n\tvi ret;\n\tfor (int i=a; i<=b; i++)\n\t\tret.push_back(i);\n\treturn ret;\n}\n\nint dobre[nax];\n\nvi daj_dobre()\n{\n\tvi ret;\n\tfor (int i=1; i<=n; i++)\n\t\tif (dobre[i])\n\t\t\tret.push_back(i);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tint bsa=1;\n\tint bsb=n;\n\twhile(bsa<bsb)\n\t{\n\t\tint bss=(bsa+bsb)/2;\n\t\tvi tu=przedzial(bsa, bss);\n\t\tif (pyt(1, n, tu))\n\t\t\tbsb=bss;\n\t\telse\n\t\t\tbsa=bss+1;\n\t}\n\tint c=bsa;\n\tdobre[c]=1;\n\tint u=c;\n\tint urwane=0;\n\tfor (int h=1; h<=130; h++)\n\t{\n\t\tbsa=1;\n\t\tbsb=n;\n\t\twhile(bsa<bsb)\n\t\t{\n\t\t\tint bss=(bsa+bsb)/2;\n\t\t\tvi tu=przedzial(bsa, bss);\n\t\t\tif (pyt(u, 1, tu))\n\t\t\t\tbsb=bss;\n\t\t\telse\n\t\t\t\tbsa=bss+1;\n\t\t}\n\t\tdobre[bsa]=1;\n\t\tu=bsa;\n\t\t//~ debug() << imie(u);\n\t\tif (u==c)\n\t\t{\n\t\t\turwane=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tif (!dobre[i] && pyt(i, 128, daj_dobre()))\n\t\t\tdobre[i]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!dobre[i] && pyt(i, urwane ? n : 253, daj_dobre()))\n\t\t\tdobre[i]=1;\n\tans(daj_dobre());\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "interactive", "trees"], "dificulty": "3000", "interactive": false}