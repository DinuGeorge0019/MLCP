{
    "link": "https://codeforces.com//contest/866/problem/C",
    "problemId": "125342",
    "problem_idx": "C",
    "shortId": "866C",
    "contest_number": "866",
    "problem_submissions": {
        "G": [
            48042764,
            48042747,
            48042330,
            48042234,
            48042200,
            30882226,
            30888984,
            57250068
        ],
        "D": [
            31044799,
            30877994,
            30876120,
            30879768,
            30877841,
            30935417,
            30935391,
            30878366,
            82427005,
            30877626,
            30880014,
            30879034,
            30880919,
            30880306,
            30879681,
            30881205,
            30880292,
            30878146,
            30881085,
            30880894
        ],
        "F": [
            30883978,
            30915539,
            30915526,
            30915506,
            30915496,
            30915492,
            30915483,
            30915431,
            30915401,
            30915351,
            30915334,
            30888671,
            30882806,
            57257664
        ],
        "C": [
            30875892,
            30877179,
            30883361,
            30877278,
            30966883,
            30966734,
            30935175,
            30876872,
            30891743,
            30891736,
            30880301,
            30877644,
            30878514,
            30877044,
            30878539,
            30877470,
            30877525,
            30878653,
            30881355,
            30877891,
            31274174,
            30878115
        ],
        "B": [
            30874326,
            30883354,
            30901870,
            30876267,
            30875622,
            30878803,
            30876656,
            30875923,
            30874820,
            30876008,
            30875772,
            30876212,
            30875972,
            30876853,
            30876928,
            30876128,
            30876479
        ],
        "A": [
            30872518,
            30872539,
            30872760,
            30872739,
            30875884,
            30873740,
            30872744,
            30872982,
            30875680,
            30874617,
            30872755,
            30881297,
            30873075,
            30873379,
            30873703,
            30873164,
            30874384
        ],
        "E": [
            30957127,
            30884728,
            30888758,
            30909701
        ]
    },
    "name": "C. Gotta Go Fast",
    "statement": "You’re trying to set the record on your favorite video game. The game\r\nconsists of levels, which must be completed sequentially in order to\r\nbeat the game. You usually complete each level as fast as possible, but\r\nsometimes finish a level slower. Specifically, you will complete the -th\r\nlevel in either seconds or seconds, where , and there’s a percent chance\r\nof completing it in seconds. After completing a level, you may decide to\r\neither continue the game and play the next level, or reset the game and\r\nstart again from the first level. Both the decision and the action are\r\ninstant.Your goal is to complete all the levels sequentially in at most\r\ntotal seconds. You want to minimize the expected amount of time playing\r\nbefore achieving that goal. If you continue and reset optimally, how\r\nmuch total time can you expect to spend playing?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.09.2017 20:16:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 55;\nconst int MAX = 12345;\n\nint a[N], b[N], p[N], sum_b[N];\ndouble f[N][MAX];\n\nint main() {\n  int n, r;\n  scanf(\"%d %d\", &n, &r);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d %d\", a + i, b + i, p + i);\n  }\n  sum_b[0] = 0;\n  for (int i = 0; i < n; i++) {\n    sum_b[i + 1] = sum_b[i] + b[i];\n  }\n  double low = 0.0, high = 1e15;\n  for (int it = 0; it < 120; it++) {\n    double mid = (low + high) * 0.5;\n    for (int i = n; i >= 0; i--) {\n      for (int j = 0; j <= sum_b[i]; j++) {\n        if (i == n) {\n          f[i][j] = (j <= r ? 0.0 : mid);\n          continue;\n        }\n        f[i][j] = 0.01 * ((f[i + 1][j + a[i]] + a[i]) * p[i] + (f[i + 1][j + b[i]] + b[i]) * (100 - p[i]));\n        if (i > 0) {\n          f[i][j] = min(f[i][j], mid);\n        }\n      }\n    }\n    if (f[0][0] > mid) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n  double ans = 0.5 * (low + high);\n  printf(\"%.17f\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "probabilities"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Gotta Go Fast.json",
    "editorial_link": "https://codeforces.com//blog/entry/54888",
    "editorial": "Let's change the game by adding a deterministic variant, which takes exactly K seconds to complete. Initially, you play the original (random) game, but between levels (including before the first level), you're allowed to switch to the deterministic game (instead of restarting). You finish when you either complete the original game in at most R seconds, or complete the deterministic game.\n\nThis modified version is easier to analyze because there are no loops in the state graph. We can compute the optimal strategy by starting from the end and working backwards. For each level, and each amount of time it could have taken to reach this level, we can compute the expected time to completion for each of the 2 actions we can take, then perform whichever action is lower. Eventually we'll work our way back to the beginning of the game. If the optimal strategy is to immediately switch to the deterministic game, then the answer is greater than K. Otherwise it's less than K. This allows us to binary search the answer.",
    "hint": []
}