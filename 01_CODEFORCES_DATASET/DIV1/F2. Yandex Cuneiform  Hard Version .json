{
    "link": "https://codeforces.com//contest/2046/problem/F2",
    "problemId": "3064646",
    "problem_idx": "F2",
    "shortId": "2046F2",
    "contest_number": "2046",
    "problem_submissions": {
        "E2": [
            294584009,
            294914447,
            299392707
        ],
        "E1": [
            294583764,
            294575583,
            294575752,
            294582430,
            294565503,
            294626979,
            294869963,
            294674514,
            294674138,
            294611999,
            294672171,
            295181016,
            299301861,
            294579122,
            294609733
        ],
        "D": [
            294560152,
            294564191,
            294566638,
            294575690,
            294573167,
            294577461,
            294570961,
            294577018,
            294582440,
            294580055,
            294581279,
            294580878,
            294578858,
            294578559,
            294582493,
            294576385,
            294578827
        ],
        "C": [
            294540710,
            294545229,
            294545966,
            294548359,
            294558363,
            294545738,
            294550008,
            294552252,
            294555169,
            294551693,
            294558653,
            294550648,
            294551477,
            294560374,
            294559914,
            294555355,
            294557938,
            294552127,
            294543297,
            294557586
        ],
        "B": [
            294535038,
            294535101,
            294537375,
            294540562,
            294536849,
            294536519,
            294541688,
            294539018,
            294541654,
            294536164,
            294543153,
            294539414,
            294540802,
            294537409,
            294549010,
            294540274,
            294543427,
            294535624,
            294535094,
            294536775
        ],
        "A": [
            294532826,
            294532846,
            294539095,
            294533971,
            294533241,
            294533253,
            294534636,
            294533446,
            294534152,
            294532988,
            294537957,
            294533256,
            294533123,
            294534271,
            294537609,
            294533346,
            294537414,
            294532885,
            294532806,
            294533598
        ],
        "F2": [
            301103610,
            294606357
        ],
        "F1": [
            301085708,
            295825018,
            294574079
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136908",
    "editorial": "We will isolate substrings from the string that consist entirely of '?'. For each, we will denote its length as leni\n and the two neighboring symbols (standing to the left and right) as li\n, ri\n. (If the right and/or left symbol is absent, we will take it as '#', a symbol that does not match any of our interests).\n\nWe will write trivial constraints on the number of available symbols of each type on the segment. It is obvious that the number of symbols of each type cannot exceed leni+12\n: we will place one symbol for every other symbol. But if, for example, we had a symbol 'Y' on the left, the number of positions where we can place 'Y' decreases by 1\n. In total, we can place no more than len+1?(li=b)?(ri=b)2\n symbols of type b. We will write such constraints for each type of symbol and denote them as Y,D,X\n respectively.\n\nIt turns out that we can arrange y\n symbols 'Y', d\n symbols 'D' and x\n symbols 'X' if and only if y+d+x=leni\n and 0?y?Y,0?d?D,0?x?X\n. This can be proven by induction or checked with stress tests on small values. From this, we conclude that in order to be able to arrange x,d,y\n symbols of each type, the inequalities above must hold.\n\nFrom the equality y+d+x=leni\n, we express d=leni?(x+y)\n.\n\nThis results in three constraints: 0?x?X,0?y?Y,0?leni?(x+y)?D\n. The first two form a rectangle, and the third cuts off two corners at a 45\n degree angle. This is a convex polygon.\n\nThus, if for each segment of '?' we write a polygon and sum them using Minkowski sum, we will obtain constraints for the entire string.\n\nSince in the Minkowski sum (after merging collinear consecutive segments) there will be at most 6 points, we can write a greedy algorithm that sequentially tries to match the required symbol to each '?'.\n\nThe final asymptotic complexity is O(n)\n with some constant.",
    "name": "F2. Yandex Cuneiform  Hard Version ",
    "statement": "For a long time, no one could decipher Sumerian cuneiform. However, it\r\nhas finally succumbed to pressure! Today, you have the chance to\r\ndecipher Yandex cuneiform.Yandex cuneiform is defined by the following\r\nrules: An empty string is a Yandex cuneiform. If you insert exactly one\r\ncopy of each of the three letters \u201d, \u201d, and \u201d into a Yandex cuneiform in\r\nsuch a way that no two adjacent letters become equal after the\r\noperation, you obtain a Yandex cuneiform. If a string can\u2019t be obtained\r\nusing the above rules, it is not a Yandex cuneiform. You are given a\r\ntemplate. A template is a string consisting of the characters \u201d, \u201d, \u201d,\r\nand \u201d.You need to check whether there exists a way to replace each\r\nquestion mark with \u201d, \u201d, or \u201d to obtain a Yandex cuneiform, and if it\r\nexists, output any of the matching options, as well as a sequence of\r\ninsertion operations to obtain the resulting cuneiform.In this version\r\nof the problem, the number of question marks in the template can be\r\narbitrary.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;#define fwd(i, a, n) for (int i = (a); i < (n); i++)#define rep(i, n) fwd(i, 0, n)#define all(X) X.begin(), X.end()#define sz(X) int(size(X))#define pb push_back#define eb emplace_back#define st first#define nd secondusing pii = pair<int, int>; using vi = vector<int>;using ll = long long; using ld = long double;#ifdef LOCauto SS = signal(6, [](int) { *(int *)0 = 0; });#define DTP(x, y) auto operator << (auto &o, auto a) -> decltype(y, o) { o << \"(\"; x; return o << \")\"; }DTP(o << a.st << \", \" << a.nd, a.nd);DTP(for (auto i : a) o << i << \", \", all(a));#define deb(x...) cerr << setw(4) << __LINE__ << \":[\" #x \"]: \", [](auto... y) { (( cerr << y << \", \" ), ...) << '\\n'; }(x)#else#define deb(...) 0#endif\u00a0#include <bits/extc++.h>using namespace __gnu_pbds;template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\u00a0vi char_to_int;string int_to_char;\u00a0void sol(vi s) {    int n = sz(s);    array<int, 3> cnts{};    rep(i, n) ++cnts[s[i]];\u00a0    if (cnts[0] != cnts[1] || cnts[0] != cnts[2])        assert(false);\u00a0    rep(i, n-1) if (s[i] == s[i+1])        assert(false);\u00a0    set<int> active;    Tree<int> tree;    rep(i, n) active.insert(i), tree.insert(i);    array<array<set<int>, 3>, 3> where;\u00a0    auto nx = [&](int i) {        auto it = active.upper_bound(i);        return it == active.end() ? -1 : *it;    };    auto pr = [&](int i) {        auto it = active.lower_bound(i);        return it == active.begin() ? -1 : *--it;    };\u00a0    auto clear = [&](int i) {        if (i == -1) return;        rep(b, 3) where[s[i]][b].erase(i);    };\u00a0    auto re = [&](int i, int j) {        if (i == -1 || j == -1) return;        clear(i);        where[s[i]][s[j]].insert(i);    };\u00a0    rep(i, n - 1) re(i, i+1);\u00a0    auto remove = [&](int i) {        active.erase(active.find(i));        tree.erase(i);        clear(i);        int pi = pr(i), ni = nx(i);\u00a0        re(pi, ni);    };\u00a0    vector<pair<char, int>> anss;\u00a0    auto ans = [&](int i, int j, int k) {        set<int> st = {s[i], s[j], s[k]};        assert(sz(st) == 3);\u00a0        remove(i);        anss.eb(int_to_char[s[i]], tree.order_of_key(i));        remove(j);        anss.eb(int_to_char[s[j]], tree.order_of_key(j));        remove(k);        anss.eb(int_to_char[s[k]], tree.order_of_key(k));    };\u00a0    rep(_, n / 3) {        int S = nx(-1);        int ok = s[S];\u00a0        bool fi = false;        int a = (ok + 1) % 3, b = (ok + 2) % 3;\u00a0        rep(__, 2) {            if (fi) break;\u00a0            if (where[a][b].empty()) {                swap(a, b);                continue;            }            fi = true;\u00a0            int i = *where[a][b].begin();            int ni = nx(i);\u00a0            int pi = pr(i);            assert(pi != -1);            int nni = nx(ni);\u00a0            if (nni == -1) {                ans(i, ni, S);                continue;            }\u00a0            if (s[pi] == s[nni]) {                ans(i, ni, pi);                continue;            }            else {                ans(i, ni, S);                continue;            }        }\u00a0        assert(fi);    }\u00a0    reverse(all(anss));    for (auto [c, i] : anss)        cout << c << ' ' << i << '\\n';}\u00a0pair<array<array<int, 3>, 3>, bool> soleq(array<int, 3> cnts, array<int, 3> exadd, int minS, int maxS) {    deb(cnts, exadd, minS, maxS);\u00a0    rep(a, 3) rep(dir0, 2) {\u00a0        array<array<int, 3>, 3> r{};        r[a][(a + dir0 + 1) % 3] = exadd[a];\u00a0        auto ile = [&](int i) {            int x = cnts[i];            rep(j, 3) x += r[j][i];            return x;        };\u00a0        int b = (a + 1) % 3;        int c = (a + 2) % 3;        rep(leftb, exadd[b] + 1) {            r[b][c] = leftb;            r[b][a] = exadd[b] - leftb;\u00a0            fill(all(r[c]), 0);            int exc = exadd[c];\u00a0            int ileB = ile(b), ileA = ile(a);            int x = min(exc, abs(ileB - ileA));            exc -= x;            if (ileB < ileA)                r[c][b] += x;            else                r[c][a] += x;\u00a0            r[c][b] += exc / 2;            r[c][a] += (exc + 1) / 2;\u00a0            bool ok = true;            rep(i, 3) {                int x = ile(i);                ok &= minS <= x && x <= maxS;            }            if (ok)                return {r, true};        }\u00a0    }\u00a0    return {{}, false};}\u00a0void solve() {    string ss;    cin >> ss;    int n = sz(ss);    vi s(n);    rep(i, n) s[i] = char_to_int[ss[i]];\u00a0    rep(i, n-1) if (s[i] != -1 && s[i] == s[i+1]) {        cout << \"NO\\n\";        return;    }\u00a0    deb(s);\u00a0    if (*max_element(all(s)) == -1) rep(i, n)        s[i] = i % 3;\u00a0    vector<pii> ranges;    array<vi, 3> excepts;    int totLen = 0;\u00a0    rep(i, n) {        if (s[i] != -1) continue;        int r = i;        while (r+1 < n && s[r+1] == -1) ++r;        int l = i;        i = r;\u00a0        int pr = l ? s[l-1] : -1;        int nx = r+1 < n ? s[r+1] : -1;\u00a0        if ((r - l + 1) & 1) {            if (pr != -1 && nx != -1 && pr != nx) {                s[l++] = 3 - pr - nx;            }            else {                int ex = pr == -1 ? nx : pr;                excepts[ex].pb(l);                l++;            }        }        else {            if (pr != -1 && pr == nx) {                s[l++] = (pr + 1) % 3;                s[l++] = (pr + 2) % 3;            }        }        totLen += r - l + 1;\u00a0        ranges.eb(l, r);    }\u00a0    array<int, 3> cnts{}, excnts{};    rep(i, n) if (s[i] != -1) ++cnts[s[i]];    rep(i, 3) excnts[i] = sz(excepts[i]);\u00a0    deb(s);    deb(excepts);    deb(cnts);    deb(excnts);\u00a0    auto [sl, isok] = soleq(cnts, excnts, max(n/3 - totLen/2, 0), n/3);\u00a0    if (!isok) {        cout << \"NO\\n\";        return;    }\u00a0    rep(i, 3) deb(sl[i]);\u00a0    rep(i, 3) rep(j, 3) {        rep(_, sl[i][j]) {            int g = excepts[i].back();            excepts[i].pop_back();\u00a0            s[g] = j;        }    }\u00a0    deb(s);\u00a0    fill(all(cnts), 0);    rep(i, n) if (s[i] != -1) ++cnts[s[i]];\u00a0    for (auto [l, r] : ranges) {        assert((l + r) & 1);        while (l <= r) {            int skip = int(max_element(all(cnts)) - cnts.begin());\u00a0            int pr = l ? s[l-1] : -1;            int nx = r+1 < n ? s[r+1] : -1;            assert(pr != nx);            if (pr == -1) pr = (nx + 1) % 3;            if (nx == -1) nx = (pr + 1) % 3;\u00a0            if (pr != skip) {                s[l++] = 3 - pr - skip;                s[l++] = pr;            }            else if (nx != skip) {                s[r--] = 3 - nx - skip;                s[r--] = nx;            }            else                assert(false);\u00a0            rep(i, 3) cnts[i] += i != skip;        }    }\u00a0    rep(i, n) ss[i] = int_to_char[s[i]];    cout << \"YES\\n\" << ss << '\\n';    sol(s);}\u00a0int32_t main() {    cin.tie(0)->sync_with_stdio(0);    cout << fixed << setprecision(10);\u00a0    int_to_char = \"YDX\";    char_to_int.resize(256, -1);    rep(i, 3)        char_to_int[int_to_char[i]] = i;\u00a0    int z = 1;    cin >> z;    rep(_, z) solve();\u00a0    #ifdef LOCF    cout.flush(); cerr << \"- - - - - - - - -\\n\";    (void)!system(\"grep VmPeak /proc/$PPID/status | sed s/....kB/\\' MB\\'/1 >&2\"); // 4x.kB ....kB    #endif\u00a0    cout << flush;    _Exit(0);}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F2. Yandex Cuneiform  Hard Version .json"
}