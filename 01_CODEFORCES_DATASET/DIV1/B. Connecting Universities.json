{
    "link": "https://codeforces.com//contest/700/problem/B",
    "problemId": "66133",
    "problem_idx": "B",
    "shortId": "700B",
    "contest_number": "700",
    "problem_submissions": {
        "E": [
            24594748,
            158561725,
            158550290
        ],
        "C": [
            19345625,
            19382048,
            19338136,
            19340095,
            19340301,
            19337933,
            19340888,
            19340881,
            19340439,
            19343320,
            19342147,
            19343241,
            19336239,
            19344979,
            19337688,
            19345735,
            19344599
        ],
        "D": [
            19338795,
            19343784,
            19338575,
            19351010,
            19367015,
            19366989,
            19347563,
            19447172,
            19403026,
            19402917,
            19402596,
            19384510,
            157407262
        ],
        "B": [
            19331219,
            19332414,
            19339798,
            19330514,
            19333849,
            19334131,
            19329268,
            19335879,
            19332140,
            19330791,
            19333504,
            19333302,
            19336092,
            19330270,
            19335712,
            19342616,
            19337619,
            19335938
        ],
        "A": [
            19329325,
            19331230,
            19341005,
            19330573,
            19330510,
            19343948,
            19331088,
            19333400,
            19345881,
            19331775,
            19336434,
            19335266,
            19334161,
            19341301,
            19332102,
            19332761
        ]
    },
    "name": "B. Connecting Universities",
    "statement": "Treeland is a country in which there are towns connected by two-way road\r\nsuch that it’s possible to get from any town to any other town. In\r\nTreeland there are universities which are located in different towns.\r\nRecently, the president signed the decree to connect universities by\r\nhigh-speed network.The Ministry of Education understood the decree in\r\nits own way and decided that it was enough to connect each university\r\nwith another one by using a cable. Formally, the decree will be done! To\r\nhave the maximum sum in the budget, the Ministry decided to divide\r\nuniversities into pairs so that the total length of the required cable\r\nwill be maximum. In other words, the total distance between universities\r\nin pairs should be as large as possible. Help the Ministry to find the\r\nmaximum total distance. Of course, each university should be present in\r\nonly one pair. Consider that all roads have the same length which is\r\nequal to .\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[201000];\nint n, w[201000], Num[201000], ReNum[201000], cnt, par[201000][20], K, Dep[201000];\nlong long Res;\nvoid DFS(int a, int pp){\n    Num[a] = ++cnt;\n    ReNum[cnt] = a;\n    par[a][0] = pp;\n    int i;\n    for(i=0;i<E[a].size();i++){\n        if(E[a][i] ==pp)continue;\n        Dep[E[a][i]] = Dep[a] + 1;\n        DFS(E[a][i], a);\n    }\n}\nint LCA(int a, int b){\n    if(Dep[a] < Dep[b])return LCA(b,a);\n    int d = Dep[a]-Dep[b], i = 0;\n    while(d){\n        if(d&1)a = par[a][i];\n        i++;d>>=1;\n    }\n    for(i=17;i>=0;i--){\n        if(par[a][i]!=par[b][i])a=par[a][i],b=par[b][i];\n    }\n    if(a!=b)a=par[a][0];\n    return a;\n}\nint main(){\n    int i, a, b, j;\n    scanf(\"%d%d\",&n,&K);\n    for(i=1;i<=2*K;i++){\n        scanf(\"%d\",&w[i]);\n    }\n    for(i=1;i<n;i++){\n        scanf(\"%d%d\",&a,&b);\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n    DFS(1,0);\n    for(i=1;i<=2*K;i++)w[i] = Num[w[i]];\n    sort(w+1,w+2*K+1);\n    for(i=1;i<=2*K;i++){\n        w[i] = ReNum[w[i]];\n    }\n    for(i=0;i<17;i++){\n        for(j=1;j<=n;j++){\n            par[j][i+1] = par[par[j][i]][i];\n        }\n    }\n    for(i=1;i<=K;i++){\n        Res += Dep[w[i]] + Dep[w[K+i]] - 2*Dep[LCA(w[i],w[K+i])];\n    }\n    printf(\"%lld\\n\",Res);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Connecting Universities.json",
    "editorial_link": "https://codeforces.com//blog/entry/46283",
    "editorial": "Let's root a tree with vertex 1 by single DFS and by the way find two values for every vertex v:\n\nlv  length of the edge that leads from parent of v to vertex v;\nsv  the number of universities in the subtree of vertex v (including v itself).\nConsider any optimal solution, i.e. such solution that the total length is maximum. Look at some edge that leads from the parent of v to v. We claim that it should be used in min(sv,?2·k?-?sv) paths. It obviously cannot be used more time than this value, however, if it is used less number of times, that means there is at least one connected pair (let's say a and b) located in the subtree of v and at least one connected pair located outside (vertices c and d). By the properties of the tree, paths from a to c and from b to d cover all edges of the paths from a to b and from c to d plus some extra edges, meaning the current answer is not optimal. Thus, this edge will be used exactly min(sv,?2·k?-?sv) times.\n\nThe above means we can compute the answer value as . Note that the above method doesn't provide the optimal matching itself (though, not many modifications required).",
    "hint": []
}