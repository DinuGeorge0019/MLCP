{
    "link": "https://codeforces.com//contest/1198/problem/A",
    "problemId": "380935",
    "problem_idx": "A",
    "shortId": "1198A",
    "contest_number": "1198",
    "problem_submissions": {
        "F": [
            58070272,
            58050274,
            58050240,
            58050207,
            58050120,
            58050094,
            58050069,
            58050046,
            58050006,
            58049923,
            58049860,
            58049749,
            58019601,
            58020980,
            58023606,
            58025464,
            58030444,
            58024358,
            58026672,
            58028904,
            58162403,
            58161986,
            58161687,
            58161301,
            58039796,
            58039793,
            58039362,
            58039355,
            58039125,
            58039123,
            58038995,
            58038994,
            58038812,
            58038810,
            58038134,
            58038133,
            58037905,
            58037904,
            58037582,
            58037581,
            58037164,
            58036882,
            58036679,
            58032989,
            58029905,
            58028352,
            58028560,
            58031397,
            58032467,
            58052909,
            58052897,
            58051859,
            58036577,
            58036553
        ],
        "D": [
            58009170,
            58008663,
            58011717,
            58013706,
            58003645,
            58007012,
            58019265,
            58015153,
            58015508,
            58008652,
            58007749,
            58009878,
            58015548,
            58020689,
            58012149,
            58011680,
            58013790,
            58004635
        ],
        "E": [
            58005211,
            58006936,
            58007024,
            58005225,
            58009765,
            58014251,
            58015403,
            58012193,
            58011483,
            58014790,
            58013911,
            58010339,
            58023389,
            58007572,
            58008131,
            57999112,
            58014046
        ],
        "C": [
            58001259,
            57997749,
            58001059,
            58007271,
            58013728,
            58018717,
            58005961,
            58006629,
            58048331,
            58006607,
            57998153,
            58003794,
            58001508,
            58001992,
            58002563,
            58001272,
            58004043,
            57999919
        ],
        "B": [
            57998572,
            58004780,
            57994973,
            58001340,
            57998225,
            58001182,
            57997197,
            58002237,
            57998507,
            58005059,
            58000720,
            57998812,
            57999975,
            57997709,
            58009338,
            57997300
        ],
        "A": [
            57995047,
            57995575,
            57997676,
            57995156,
            57995500,
            57997301,
            57995357,
            57998877,
            57995263,
            58002849,
            58004383,
            58026838,
            57997108,
            57995572,
            58007187,
            57995267
        ]
    },
    "name": "A. MP3",
    "statement": "One common way of digitalizing sound is to record sound intensity at\r\nparticular time moments. For each time moment intensity is recorded as a\r\nnon-negative integer. Thus we can represent a sound file as an array of\r\nn non-negative integers.If there are exactly K distinct values in the\r\narray, then we need k =\r\nlceil\r\nlog_{2} K\r\nrceil bits to store each value. It then takes nk bits to store the whole\r\nfile.To reduce the memory consumption we need to apply some compression.\r\nOne common way is to reduce the number of possible intensity values. We\r\nchoose two integers l\r\nle r, and after that all intensity values are changed in the following\r\nway: if the intensity value is within the range [l;r], we don’t change\r\nit. If it is less than l, we change it to l; if it is greater than r, we\r\nchange it to r. You can see that we lose some low and some high\r\nintensities.Your task is to apply this compression in such a way that\r\nthe file fits onto a disk of size I bytes, and the number of changed\r\nelements in the array is minimal possible.We remind you that 1 byte\r\ncontains 8 bits.k =\r\nlceil log_{2} K\r\nrceil is the smallest integer such that K\r\nle 2^{k}. In particular, if K = 1, then k = 0.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\nint tab[nax];\n\nint wyn;\n\nint zm[nax];\n\nint roz(int a, int b)\n{\n\treturn zm[b]-zm[a]+1;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\twyn=n;\n\tk*=8;\n\tk/=n;\n\tk=min(k, 25);\n\tk=(1<<k);\n\tsort(tab+1, tab+1+n);\n\tfor (int i=2; i<=n; i++)\n\t\tzm[i]=(zm[i-1]+(tab[i]!=tab[i-1]));\n\tint w=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tw=max(w, i);\n\t\twhile(w<n && roz(i, w+1)<=k)\n\t\t\tw++;\n\t\twyn=min(wyn, n-(w-i+1));\n\t}\n\tprintf(\"%d\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "sortings",
        "two pointers"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. MP3.json",
    "editorial_link": "https://codeforces.com/blog/entry/68812",
    "editorial": "First letâs calculate how many different values we can have. Maximal is\r\n, maximal is . We have to be careful not to overflow, letâs use ( is\r\nbigger than any ).Letâs sort the array and compress equal values. Now we\r\nhave to choose no more than consecutive values in such a way that they\r\ncover as much elements as possible. If is bigger than number of\r\ndifferent values, then answer is 0. Otherwise we can precalculate prefix\r\nsums and try all the variants to choose consecutive values.Complexity is\r\n.\r\n",
    "hint": []
}