{
    "link": "https://codeforces.com//contest/1965/problem/E",
    "problemId": "2614999",
    "problem_idx": "E",
    "shortId": "1965E",
    "contest_number": "1965",
    "problem_submissions": {
        "F": [
            258465624,
            258627065,
            263837667,
            258481689
        ],
        "D": [
            258447727,
            258460812,
            258466117,
            258450218,
            258464835,
            258457510,
            258458513,
            258465971,
            259573719,
            258506961,
            258454027,
            258456282,
            258483429,
            258453210,
            258453791
        ],
        "C": [
            258425895,
            258434352,
            258433902,
            258442030,
            258433331,
            258429762,
            258434494,
            258427059,
            258424566,
            258435014,
            258430069,
            258434394,
            258430905,
            258434841,
            258457386,
            258428580,
            258429520,
            258434274
        ],
        "B": [
            258420424,
            258428605,
            258430303,
            258433453,
            258426877,
            258424079,
            258428403,
            258433720,
            259639909,
            258437552,
            258428917,
            258424298,
            258428062,
            258424086,
            258427169,
            258427222,
            258425398,
            258424422,
            258426595
        ],
        "A": [
            258418141,
            258418841,
            258425010,
            258419725,
            258419999,
            258418044,
            258419071,
            258418897,
            258418989,
            258419441,
            258418664,
            258419165,
            258419761,
            258418751,
            258419361,
            258418280,
            258427816,
            258420207
        ],
        "E": [
            258446500,
            258464809,
            258455602,
            258503208,
            258466942,
            258468402,
            258463371,
            258447373,
            258452406,
            258457290,
            258460561,
            258509487,
            258461569,
            302317911,
            258464177,
            258450702,
            258478527
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128914",
    "editorial": "We can show that a solution always exists. This example with , , will\r\ndemonstrate the construction we will use: First, extend each of the even\r\ncolumns up by spaces, keeping all cubes in a given vertical column the\r\nsame color: Then, for the odd columns, do something similar, except we\r\nuse the bottom rows to \"bend\" them around so the tops point out to the\r\nright: After that, extend each of these new \"bent\" rows (each of which\r\ncorresponds to an input cube in an odd column) to the right by : Now,\r\neach initial cube in the by grid corresponds to one of these extended\r\nrows or columns, each of which is a connected group. Fill in the\r\nremaining columns between the even columns with rows each. The -th of\r\nthese should be color . Now do the same for the odd columns: At this\r\npoint, each cell of a given color is connected to at least one of the\r\nrows/columns we added in the last two steps. Now, we want to connect all\r\nof those by color. Start by adding these rows: Followed by these rows:\r\nOnce again, at this point, each cube of a given color is connected to\r\none of the rows of that color we added in the last two steps. So the\r\nlast remaining step is to connect them: Now, all cubes of each color are\r\nconnected.This construction uses exactly additional cubes. Since , this\r\nis at most , which fits within the bounds of the problem.Complexity:\r\n",
    "name": "E. Connected Cubes",
    "statement": "There are n\r\ncdot m unit cubes currently in positions (1, 1, 1) through (n, m, 1).\r\nEach of these cubes is one of k colors. You want to add additional cubes\r\nat any integer coordinates such that the subset of cubes of each color\r\nis connected, where two cubes are considered connected if they share a\r\nface.In other words, for every pair of cubes of the same color c, it\r\nshould be possible to travel from one to the other, moving only through\r\ncubes of color c that share a face.The existing cubes are currently in\r\nthe corner of a room. There are colorless cubes completely filling the\r\nplanes x = 0, y = 0, and z = 0, preventing you from placing additional\r\ncubes there or at any negative coordinates. Find a solution that uses at\r\nmost 4\r\ncdot 10^5 additional cubes (not including the cubes that are currently\r\npresent), or determine that there is no solution. It can be shown that\r\nunder the given constraints, if there is a solution, there is one using\r\nat most 4\r\ncdot 10^5 additional cubes.\r\n",
    "solutions": [
        "//    \u82d4\u82b1\u5982\u7c73\u5c0f\uff0c\u4e5f\u5b66\u7261\u4e39\u5f00\u3002 //    Zhikun Wang (nocriz)//    2024\u5e744\u670827\u65e5\u00a0#include <bits/stdc++.h>using namespace std; using ll = long long; using db = long double; using str = string;using pi = pair<int,int>; using pl = pair<ll,ll>; using pd = pair<db,db>;using vi = vector<int>; using vb = vector<bool>; using vl = vector<ll>;using vd = vector<db>; using vs = vector<str>;using vpi = vector<pi>; using vpl = vector<pl>; using vpd = vector<pd>;\u00a0#define tcT template<class T#define tcTU tcT, class UtcT> using V = vector<T>;  tcT, size_t SZ> using AR = array<T,SZ>; tcT> using PR = pair<T,T>;\u00a0#define mp make_pair #define f first#define s second#define sz(x) int((x).size())#define bg(x) begin(x)#define all(x) bg(x), end(x)#define rall(x) x.rbegin(), x.rend() #define sor(x) sort(all(x)) #define rsz resize#define ins insert #define ft front()#define bk back()#define pb push_back#define eb emplace_back #define pf push_front#define lb lower_bound#define ub upper_bound\u00a0tcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\u00a0#define FOR(i,a,b) for (int i = (a); i < (b); ++i)#define F0R(i,a) FOR(i,0,a)#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)#define R0F(i,a) ROF(i,0,a)#define each(a,x) for (auto& a: x)\u00a0const int MOD = 1e9+7;const ll INF = 1e18; // not too close to LLONG_MAXconst db PI = acos((db)-1);const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); template<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\u00a0constexpr int pct(int x) { return __builtin_popcount(x); } // # of bits setconstexpr int bits(int x) { return x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) constexpr int p2(int x) { return 1<<x; }constexpr int msk2(int x) { return p2(x)-1; }ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded upll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded downtcT> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }tcT> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }tcTU> T fstTrue(T lo, T hi, U f) { hi ++; assert(lo <= hi); while (lo < hi) { T mid = lo+(hi-lo)/2; f(mid) ? hi = mid : lo = mid+1; } return lo; }tcTU> T lstTrue(T lo, T hi, U f) { lo --; assert(lo <= hi); while (lo < hi) { T mid = lo+(hi-lo+1)/2; f(mid) ? lo = mid : hi = mid-1; } return lo; }tcT> void remDup(vector<T>& v) { sort(all(v)); v.erase(unique(all(v)),end(v)); }tcTU> void erase(T& t, const U& u) { auto it = t.find(u); assert(it != end(t)); t.erase(it); } #define tcTUU tcT, class ...Uinline namespace Helpers { tcT, class = void> struct is_iterable : false_type {}; tcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>())) > > : true_type {}; tcT> constexpr bool is_iterable_v = is_iterable<T>::value; tcT, class = void> struct is_readable : false_type {}; tcT> struct is_readable<T, typename std::enable_if_t< is_same_v<decltype(cin >> declval<T&>()), istream&> > > : true_type {}; tcT> constexpr bool is_readable_v = is_readable<T>::value; tcT, class = void> struct is_printable : false_type {}; tcT> struct is_printable<T, typename std::enable_if_t< is_same_v<decltype(cout << declval<T>()), ostream&> > > : true_type {}; tcT> constexpr bool is_printable_v = is_printable<T>::value;}inline namespace Input { tcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>; tcTUU> void re(T& t, U&... u); tcTU> void re(pair<T,U>& p); tcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } tcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } tcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); tcTU> void re(pair<T,U>& p) { re(p.f,p.s); } tcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) { each(x,i) re(x); } tcTUU> void re(T& t, U&... u) { re(t); re(u...); }}inline namespace ToString {  tcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;  tcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {   stringstream ss; ss << fixed << setprecision(15) << v;   return ss.str(); }  tcT> str bit_vec(T t) {   str res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);   res += \"}\"; return res; }  str ts(V<bool> v) { return bit_vec(v); }  template<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); }   tcTU> str ts(pair<T,U> p);  tcT> typename enable_if<needs_output_v<T>,str>::type ts(T v);   tcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }  tcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {   bool fst = 1; str res = \"\";   for (const auto& x: v) {    if (!fst) res += sep;    fst = 0; res += ts(x);   }   return res;  }  tcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {   return \"{\"+ts_sep(v,\", \")+\"}\"; }  template<int, class T> typename enable_if<!needs_output_v<T>,vs>::type     ts_lev(const T& v) { return {ts(v)}; }  template<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type     ts_lev(const T& v) {   if (lev == 0 || !sz(v)) return {ts(v)};   vs res;   for (const auto& t: v) {    if (sz(res)) res.bk += \",\";    vs tmp = ts_lev<lev-1>(t);    res.ins(end(res),all(tmp));   }   F0R(i,sz(res)) {    str bef = \" \"; if (i == 0) bef = \"{\";    res[i] = bef+res[i];   }   res.bk += \"}\";   return res;  } }inline namespace Output { template<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); } template<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {pr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); } template<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } void ps() { cout << \"\\n\"; } template<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } template<class ...T> void dbg_out(const T&... t) { pr_sep(cerr,\" | \",t...); cerr << endl; }void loc_info(int line, str names) { cerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; } template<int lev, class T> void dbgl_out(const T& t) { cerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; } }#ifdef LOCAL\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)#else \t#define dbg(...) 0\t#define dbgl(lev,x) 0#endifvoid decrement() {} // subtract one from eachtcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\u00a0// re(a,b,c,...) reads vectors, arrays of pairs, complex, etc// pr(a,b,c,...) prints with no spaces. ps(a,b,c,...) prints with space and \\n.// All outputs uses ts() to generate string. vectors, bitsets, pairs, OK// dbg() debugs stuff. dbgl() debugs stuff with level.\u00a0int n, m, k;\u00a0int a[110][110];int main() {\tcin.tie(0)->sync_with_stdio(0);\tre(n, m, k);\tfor(int i=1;i<=n;i++) {\t\tfor(int j=1;j<=m;j++) {\t\t\tre(a[i][j]);\t\t}\t}\tint ct = 0;\tvi fi;\tvector<vi> ans;\tfor(int i= n;i>=1;i--) {\t\tct += 1;\t\tif((n-i)%2 == 0){\t\t\tfi.pb(ct);\t\t\tct += 1;\t\t}\t\tfor(int j=1;j<=m;j++) {\t\t\tint ci = i, ck = 1, cc = a[i][j];\t\t\twhile(ck < ct) {\t\t\t\tck += 1;\t\t\t\tans.pb({ci, j, ck, cc});\t\t\t}\t\t\twhile(ci < n + k) {\t\t\t\tci += 1;\t\t\t\tans.pb({ci, j, ck, cc});\t\t\t}\t\t}\u00a0\t}\t//ans.pb({0, 0, 0, 0});\tct += 1;\tfi.pb(ct);\tfor(int c=1;c<=k;c++) {\t\tfor(auto ck: fi) {\t\t\tfor(int j=1;j<=m;j++) {\t\t\t\tans.pb({c + n, j, ck, c});\t\t\t}\t\t}\t\tfor(int ck=1;ck<=fi.back();ck++) {\t\t\tans.pb({c + n, m+1, ck, c});\t\t}\u00a0\t//ans.pb({0, 0, 0, 0});\t}\tps(ans.size());\tfor(auto ct:ans){\t\tps(ct[0], ct[1], ct[2], ct[3]);\t}// END OF CODE\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Connected Cubes.json"
}