{
    "link": "https://codeforces.com//contest/103/problem/D",
    "problemId": "545",
    "problem_idx": "D",
    "shortId": "103D",
    "contest_number": "103",
    "problem_submissions": {
        "E": [
            594225,
            596662,
            39448090,
            39427579,
            39399437,
            595910,
            123375307,
            5405441
        ],
        "D": [
            592292,
            591569,
            591484,
            596181,
            596133,
            591648,
            592548,
            593008,
            592069,
            594057,
            593198,
            593774,
            593994,
            594003,
            593751,
            594358,
            594503,
            597893,
            597881,
            596124,
            595932,
            594188,
            592900,
            594112
        ],
        "C": [
            591729,
            592936,
            593120,
            596123,
            592928,
            591746,
            593864,
            593657,
            591747,
            592188,
            592501,
            592689,
            592235,
            591907,
            592739,
            592446,
            593652,
            592453
        ],
        "B": [
            589933,
            589502,
            590203,
            596103,
            590318,
            590585,
            590813,
            590526,
            590500,
            590943,
            590147,
            591873,
            590310,
            590700,
            590283,
            591089,
            590343,
            590573,
            591133
        ],
        "A": [
            589329,
            591835,
            589264,
            596085,
            589350,
            589466,
            589313,
            589253,
            593567,
            589432,
            589509,
            590045,
            589561,
            589677,
            589370,
            589409,
            590491
        ]
    },
    "name": "D. Time to Raid Cowavans",
    "statement": "As you know, the most intelligent beings on the Earth are, of course,\r\ncows. This conclusion was reached long ago by the Martian aliens, as\r\nwell as a number of other intelligent civilizations from outer space.\r\nSometimes cows gather into . This seems to be seasonal. But at this time\r\nthe cows become passive and react poorly to external stimuli. A cowavan\r\nis a perfect target for the Martian scientific saucer, it’s time for\r\nlarge-scale abductions, or, as the Martians say, raids. Simply put, a\r\ncowavan is a set of cows in a row. If we number all cows in the cowavan\r\nwith positive integers from to , then we can formalize the popular model\r\nof abduction, known as the : first they steal a cow number , then number\r\n, then number , and so on, until the number of an abducted cow exceeds .\r\nDuring one raid the cows are not renumbered. The aliens would be happy\r\nto place all the cows on board of their hospitable ship, but\r\nunfortunately, the amount of cargo space is very, very limited. The\r\nresearchers, knowing the mass of each cow in the cowavan, made scenarios\r\nof the -raid. Now they want to identify the following thing for each\r\nscenario individually: what total mass of pure beef will get on board of\r\nthe ship. All the scenarios are independent, in the process of\r\nperforming the calculations the cows are not being stolen.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n, m;\nint64 w[300300];\nint64 t[300300];\nvector < pair <pii, int> > Q;\nint64 ans[300300];\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n/*\tprintf (\"300000\\n\");\n\tforn (i, 300000)\n\t\tprintf (\"1000000000\\n\");\n\tprintf (\"300000\\n\");\n\tforn (i, 300000)\n\t\tprintf (\"1 %d\\n\", i+1);\n\treturn 0;*/\n\tseta (w, 0);\n\tscanf (\"%d\", &n);\n\tforn (i, n) {\n\t\tint x;\n\t\tscanf (\"%d\", &x);\n\t\tw[i] = x;\n\t}\n\tscanf (\"%d\", &m);\n\tQ.resize (m);\n\tforn (i, m) {\n\t\tint a, b;\n\t\tscanf (\"%d%d\", &a, &b);\n\t\ta --;\n\t\tQ[i] = mp (mp (b, a), i);\n\t}\n\tsort (all (Q));\n\tint cur = 0;\n\tforn (i, Q.size()) {\n\t\tint a = Q[i].fs.sc;\n\t\tint b = Q[i].fs.fs;\n\t\tint num = Q[i].sc;\n\t\tif (b > 1000) {\n\t\t\tans[num] = 0;\n\t\t\twhile (a < n) {\n\t\t\t\tans[num] += w[a];\n\t\t\t\ta += b;\n\t\t\t}\n\t\t} else {\n\t\t\tif (b > cur) {\n\t\t\t\tcur = b;\n\t\t\t\tseta (t, 0);\n\t\t\t\tfor (int i = n-1; i >= 0; i --) {\n\t\t\t\t\tt[i] = w[i];\n\t\t\t\t\tif (i + cur < n)\n\t\t\t\t\t\tt[i] += t[i+cur];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a < n)\n\t\t\t\tans[num] = t[a];\n\t\t\telse\n\t\t\t\tans[num] = 0;\n\t\t}\n\t}\n\n\tforn (i, m) \n\t\tprintf (\"%I64d\\n\", ans[i]);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Time to Raid Cowavans.json",
    "editorial_link": "https://codeforces.com/blog/entry/2426?locale=en",
    "editorial": "Letâs solve this problem by offline. Read all queries and sort them by\r\nincreasing . After that there are many effective solutions but I tell\r\nyou a most simple of them. Look at two following algorithms: 1. For each\r\n-query calculate the answer by the simple way: 2. Fix the value of and\r\ncalculate DP for all possible values of : Obvioulsy, the 1st algorithm\r\nis non-effective with little values of and the 2nd algorithm is\r\nnon-effecitve with very different values of . Behold that itâs\r\nimpossible to generate the situation where all âs are so little and\r\ndifferent simultaniously. There is a simple idea: we may solve the\r\nproblem by 1st algo if values of are so large (if they are greater than\r\n) and solve by 2nd algo if values of are so small (if they are less of\r\nequal to ). We need to sort our queries because of no reason to\r\ncalculate DP of any more than once. If we choose equal to that we will\r\nget a complexity.\r\n",
    "hint": []
}