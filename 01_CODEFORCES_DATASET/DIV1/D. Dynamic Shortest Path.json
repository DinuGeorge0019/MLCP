{
    "link": "https://codeforces.com//contest/843/problem/D",
    "problemId": "119864",
    "problem_idx": "D",
    "shortId": "843D",
    "contest_number": "843",
    "problem_submissions": {
        "D": [
            86210957,
            86210473,
            29756854,
            34937670,
            29781848,
            29781833,
            29781501,
            29855864,
            30128230,
            42158478,
            42158439,
            30022222,
            29772717
        ],
        "C": [
            29753044,
            29759187,
            29746479,
            29758195,
            29749173,
            29747919,
            29747700,
            29750057,
            29750292,
            29751827,
            29751575,
            29754184,
            29754916,
            29751833,
            29755015,
            29755103,
            29756089,
            29752710
        ],
        "E": [
            29748360,
            29749250,
            29756319,
            29752227,
            29761679,
            29956114,
            29762394,
            35205556,
            29781472,
            29754090,
            29761229,
            29762324,
            42187009
        ],
        "A": [
            29740862,
            29750546,
            29737212,
            29736679,
            29736752,
            29736447,
            29736902,
            29737823,
            29737375,
            29738506,
            29737473,
            29738082,
            29739251,
            29737566,
            29736802,
            29738724,
            29737891,
            29739246,
            29738315
        ],
        "B": [
            29755133,
            29757158,
            29758427,
            29740669,
            29739815,
            29741358,
            29743424,
            29741532,
            29745306,
            29741855,
            29742825,
            29744139,
            29742831,
            29742430,
            29744161,
            29746567,
            29746080,
            29746122
        ]
    },
    "name": "D. Dynamic Shortest Path",
    "statement": "You are given a weighted directed graph, consisting of vertices and\r\nedges. You should answer queries of two types: find the length of\r\nshortest path from vertex to vertex . add to weights of edges with\r\nindices .\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nstruct rng {\n    struct A {\n        int n;\n        const bool operator!=(A r) { return n != r.n; }\n        A& operator++() { n++; return *this; }\n        int operator*() { return n; }\n    };\n    int l, r;\n    rng(int r) : l(0), r(r) {}\n    rng(int l, int r) : l(l), r(r) {}\n    A begin() { return A{l}; }\n    A end() { return A{r}; }\n};\n\ntemplate<class D, D INF>\nstruct Dijkstra {\n    V<D> res; //res[i] = s\u304b\u3089i\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\n    \n    template<class E>\n    Dijkstra(const VV<E> &g, int s) {\n        int n = (int)g.size();\n        res = V<D>(n, INF);\n        \n        using P = pair<D, int>;\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push(P(0, s));\n        res[s] = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            if (res[p.second] < p.first) continue;\n            for (E e: g[p.second]) {\n                if (p.first+e.dist < res[e.to]) {\n                    res[e.to] = p.first+e.dist;\n                    q.push(P(res[e.to], e.to));\n                }\n            }\n        }\n    }\n};\n\nstruct E {\n    int to;\n    int dist;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n, m, q;\n    cin >> n >> m >> q;\n    VV<E> g(n);\n    using P = pair<int, int>;\n    V<P> ed(m);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c; a--; b--;\n        ed[i] = P(a, int(g[a].size()));\n        g[a].push_back(E{b, c});\n    }\n    \n    V<ll> sm = Dijkstra<ll, TEN(18)>(g, 0).res;\n    V<int> pos(n);\n    V<bool> cant(n);\n    for (int i = 0; i < n; i++) cant[i] = (sm[i] == TEN(18));\n\n    for (int i = 0; i < n; i++) {\n        if (cant[i]) continue;\n        for (auto &e: g[i]) {\n            int j = e.to;\n            e.dist -= sm[j] - sm[i];\n        }\n    }\n\n    auto ref = [&]() {\n        for (int i = 0; i < n; i++) {\n            if (cant[i]) continue;\n            for (auto &e: g[i]) {\n                int j = e.to;\n                e.dist -= pos[j] - pos[i];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (cant[i]) continue;\n            sm[i] += pos[i];\n            pos[i] = 0;\n        }\n    };\n\n    int c = 0;\n    V<bool> vis(n);\n    for (int ph = 0; ph < q; ph++) {\n        int ty;\n        cin >> ty;\n        if (ty == 1) {\n            if (c) {\n                fill(begin(pos), end(pos), TEN(9));\n                fill(begin(vis), end(vis), false);\n    \n                VV<int> que(c+1);\n                que[0].push_back(0);\n                pos[0] = 0;\n                for (int di = 0; di <= c; di++) {\n                    while (que[di].size()) {\n                        int p = que[di].back(); que[di].pop_back();\n                        if (vis[p]) continue;\n                        vis[p] = true;\n                        for (auto e: g[p]) {\n                            if (c < di + e.dist) continue;\n                            if (pos[e.to] <= di + e.dist) continue;\n                            pos[e.to] = di + e.dist;\n                            que[di + e.dist].push_back(e.to);\n                        }\n                    }\n                }\n                ref();\n                c = 0;                    \n            }\n            int v;\n            cin >> v; v--;\n            cout << (cant[v] ? -1 : sm[v]) << endl;\n        } else {\n            int x;\n            cin >> x;\n            for (int i = 0; i < x; i++) {\n                int l;\n                cin >> l; l--;\n                g[ed[l].first][ed[l].second].dist++;\n            }\n            c += x;            \n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "shortest paths"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Dynamic Shortest Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/54029",
    "editorial": "Firstly, let\u00e2\u0080\u0099s run an usual Dijkstra from , find distances and make them\r\na potentials of vertices. Then for each request let\u00e2\u0080\u0099s recalculate all\r\ndistances and make the potentials equal to these distances. To quickly\r\nrecalculate the distance between requests, we can use the fact that in a\r\ngraph with potentials, all distances are 0. When we increased the weight\r\nof some edges by 1, in the graph with potentials, all distances do not\r\nexceed the number of changed edges so we can run a Dijkstra on a vector\r\nper .\r\n"
}