{
    "link": "https://codeforces.com//contest/1010/problem/D",
    "problemId": "201805",
    "problem_idx": "D",
    "shortId": "1010D",
    "contest_number": "1010",
    "problem_submissions": {
        "B": [
            40799404,
            40801993,
            40788669,
            40787652,
            40789673,
            40789686,
            40789983,
            40785033,
            40792839,
            40805864,
            40788811,
            40787383,
            40789849,
            40789369,
            40787726,
            40805158,
            40792120,
            40788528
        ],
        "E": [
            40798849,
            40800058,
            40798099,
            40803219,
            40808162,
            40803215,
            40805435,
            40803779,
            40802990,
            40802895,
            40802904,
            40807344,
            40809272,
            40807596,
            40809118,
            40796705,
            40826253,
            40825565,
            40825440,
            40825326,
            40820969,
            40809148,
            40810854
        ],
        "D": [
            40790648,
            40792110,
            40793613,
            40792349,
            40794914,
            40795576,
            40794812,
            40796573,
            40795996,
            40791327,
            40795441,
            40794120,
            40793973,
            40796503,
            40791721,
            40802197,
            40794990,
            40796187
        ],
        "C": [
            40786265,
            40787662,
            40789931,
            40785223,
            40786749,
            40786331,
            40785962,
            40786363,
            40790435,
            40784715,
            40788036,
            40789805,
            40785906,
            40791178,
            40784561,
            40799332,
            40788152,
            40791287
        ],
        "A": [
            40783437,
            40783575,
            40783713,
            40784110,
            40784394,
            40784590,
            40783557,
            40784035,
            40783594,
            40783743,
            40791154,
            40783813,
            40784202,
            40785469,
            40783661,
            40798279,
            40784877,
            40785930
        ],
        "F": [
            40820195,
            40821625,
            40821278,
            40814070,
            40812966,
            47670616
        ]
    },
    "name": "D. Mars rover",
    "statement": "Natasha travels around Mars in the Mars rover. But suddenly it broke\r\ndown, namely the logical scheme inside it. The scheme is an undirected\r\ntree (connected acyclic graph) with a root in the vertex 1, in which\r\nevery leaf (excluding root) is an input, and all other vertices are\r\nlogical elements, including the root, which is output. One bit is fed to\r\neach input. One bit is returned at the output.There are four types of\r\nlogical elements: AND (2 inputs), OR (2 inputs), XOR (2 inputs), NOT (1\r\ninput). Logical elements take values from their direct descendants\r\n(inputs) and return the result of the function they perform. Natasha\r\nknows the logical scheme of the Mars rover, as well as the fact that\r\nonly one input is broken. In order to fix the Mars rover, she needs to\r\nchange the value on this input.For each input, determine what the output\r\nwill be if Natasha changes this input.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/CLionProjects/ACM/input.txt\", \"r\", stdin);\n//freopen(\"/home/alexandero/CLionProjects/ACM/output.txt\", \"w\", stdout);\n//freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n//cin \u00bb t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\nsolve(false);\n}\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n//const li mod = 1000000007;\n\n//using ull = unsigned long long;\n\nenum Type {\n  AND,\n  OR,\n  XOR,\n  NOT,\n  IN\n};\n\nvector<Type> types;\nvector<vector<int>> g;\nvector<int> val;\nvector<int> val_changed;\nvector<int> parent;\n\nint dfs(int v, int p) {\n  parent[v] = p;\n  if (types[v] == IN) {\n    return val[v];\n  }\n  if (types[v] == NOT) {\n    return val[v] = !dfs(g[v][0], v);\n  }\n  if (types[v] == AND) {\n    return val[v] = dfs(g[v][0], v) & dfs(g[v][1], v);\n  }\n  if (types[v] == OR) {\n    return val[v] = dfs(g[v][0], v) | dfs(g[v][1], v);\n  }\n  if (types[v] == XOR) {\n    return val[v] = dfs(g[v][0], v) ^ dfs(g[v][1], v);\n  }\n}\n\nvoid dfs_ans(int v) {\n  if (v == 0) {\n    val_changed[v] = val[v] ^ 1;\n  } else {\n    int p = parent[v];\n    int new_val = (val[v] ^ 1);\n    if (types[p] == NOT) {\n      val_changed[v] = val_changed[p];\n    } else {\n      int diff_val = ((g[p][0] == v) ? val[g[p][1]] : val[g[p][0]]);\n      int parent_val = val[p];\n      if (types[p] == AND) {\n        parent_val = diff_val & new_val;\n      }\n      if (types[p] == OR) {\n        parent_val = diff_val | new_val;\n      }\n      if (types[p] == XOR) {\n        parent_val = diff_val ^ new_val;\n      }\n      if (parent_val != val[p]) {\n        val_changed[v] = val_changed[p];\n      } else {\n        val_changed[v] = val[0];\n      }\n    }\n  }\n  for (int to : g[v]) {\n    dfs_ans(to);\n  }\n}\n\nvoid solve(bool read) {\n  int n;\n  cin >> n;\n  types.resize(n);\n  g.clear();\n  g.resize(n);\n  val.resize(n);\n  for (int i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    if (s == \"IN\") {\n      types[i] = IN;\n      cin >> val[i];\n    } else if (s == \"NOT\") {\n      types[i] = NOT;\n      int cur;\n      cin >> cur;\n      --cur;\n      g[i].push_back(cur);\n    } else {\n      switch(s[0]) {\n        case 'A':\n          types[i] = AND;\n          break;\n        case 'O':\n          types[i] = OR;\n          break;\n        case 'X':\n          types[i] = XOR;\n          break;\n        default:\n          assert(false);\n      }\n      g[i].resize(2);\n      for (int j = 0; j < 2; ++j) {\n        cin >> g[i][j];\n        --g[i][j];\n      }\n    }\n  }\n  parent.resize(n);\n  dfs(0, 0);\n  val_changed.resize(n);\n  dfs_ans(0);\n\n  for (int i = 0; i < n; ++i) {\n    if (types[i] == IN) {\n      cout << val_changed[i];\n    }\n  }\n  cout << \"\\n\";\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "implementation",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Mars rover.json",
    "editorial_link": "https://codeforces.com/blog/entry/60851",
    "editorial": "Let\u00e2\u0080\u0099s count the bit at each vertex. This can be done using depth-first\r\nsearch on this tree. Now for each vertex, let\u00e2\u0080\u0099s check: whether the bit\r\non the output of the scheme will change if the bit in the current vertex\r\nis changed. If all the vertices on the path from this vertex to the\r\noutput of the scheme. If at least one of them does not change, then the\r\noutput of the scheme does not change, and vice versa: if the output of\r\nthe scheme is changed, then each vertex on the path under consideration\r\nwill change. Now the solution can be implemented as follows. For each\r\nvertex, let\u00e2\u0080\u0099s make a note: whether the bit on the output of the scheme\r\nwill be changed if the bit on the current vertex is changed. For output\r\nof the scheme, this note is . Now let\u00e2\u0080\u0099s do the depth-first search on\r\nthis tree. If note at the current vertex is equal to , then at the\r\ninputs to it we make the note equal , otherwise, for each input to this\r\nvertex, we do the following. Let\u00e2\u0080\u0099s see if the current vertex is changed\r\nif the current input is changed. If it is changed, then at this input we\r\nwill make the note equal , otherwise .Complexity: .\r\n"
}