{
    "link": "https://codeforces.com//contest/482/problem/D",
    "problemId": "15991",
    "problem_idx": "D",
    "shortId": "482D",
    "contest_number": "482",
    "problem_submissions": {
        "E": [
            8395492,
            8395487,
            8395485,
            8395484,
            8395481
        ],
        "D": [
            8386071,
            8389539,
            8389292,
            8390634,
            8390063,
            8388875,
            8388934,
            8389261,
            8389687,
            8445804,
            8390689,
            8390772,
            9364523,
            8390299,
            8389829
        ],
        "C": [
            8384458,
            8395228,
            8386818,
            8387122,
            8391988,
            8393481,
            8394742,
            8391508,
            8393489,
            8387159,
            8387776
        ],
        "B": [
            8382609,
            8381668,
            8382625,
            8383076,
            8381676,
            8382713,
            8382593,
            8383732,
            8383882,
            8385352,
            8383031,
            8383352,
            8382682,
            8381439,
            8383046,
            8382782
        ],
        "A": [
            8380309,
            8380134,
            8380145,
            8380792,
            8380181,
            8383494,
            8380551,
            8380832,
            8382370,
            8381220,
            8380876,
            8380679,
            8381208,
            8382400,
            8381109,
            8380183
        ]
    },
    "name": "D. Random Function and Tree",
    "statement": "You have a rooted tree consisting of vertices. Let\u2019s number them with\r\nintegers from to inclusive. The root of the tree is the vertex . For\r\neach direct parent of the vertex is . We say that vertex is child for\r\nits direct parent .You have initially painted all the vertices with red\r\ncolor. You like to repaint some vertices of the tree. To perform\r\npainting you use the function that you call with the root of the tree as\r\nan argument. Here is the pseudocode of this function:count = 0 // global\r\ninteger variable rnd() { // this function is used in paint code return 0\r\nor 1 equiprobably}paint(s) { if (count is even) then paint s with white\r\ncolor else paint s with black color count = count + 1 if rnd() = 1 then\r\nchildren = [array of vertex s children in ascending order of their\r\nnumbers] else children = [array of vertex s children in descending order\r\nof their numbers] for child in children { // iterating over children\r\narray if rnd() = 1 then paint(child) // calling paint recursively }}As a\r\nresult of this function, some vertices may change their colors to white\r\nor black and some of them may remain red.Your task is to determine the\r\nnumber of distinct possible colorings of the vertices of the tree. We\r\nwill assume that the coloring is possible if there is a nonzero\r\nprobability to get this coloring with a single call of . We assume that\r\nthe colorings are different if there is a pair of vertices that are\r\npainted with different colors in these colorings. Since the required\r\nnumber may be very large, find its remainder of division by ().\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long)a * b % md;\n}\n\nconst int N = 200010;\n\nvector <int> g[N];\nint f[N][2];\nint aux[7][7], new_aux[7][7];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    g[i].clear();\n  }\n  for (int i = 2; i <= n; i++) {\n    int foo;\n    scanf(\"%d\", &foo);\n    g[foo].push_back(i);\n  }\n  for (int i = n; i >= 1; i--) {\n    for (int tot = 0; tot < 2; tot++) {\n      for (int all = 0; all < 4; all++) {\n        aux[tot][all] = 0;\n      }\n    }\n    aux[0][0] = 1;\n    int sz = g[i].size();\n    for (int j = 0; j < sz; j++) {\n      int u = g[i][j];\n      for (int tot = 0; tot < 2; tot++) {\n        for (int all = 0; all < 4; all++) {\n          new_aux[tot][all] = aux[tot][all];\n        }\n      }\n      for (int tot = 0; tot < 2; tot++) {\n        for (int all = 0; all < 4; all++) {\n          for (int cur = 0; cur < 2; cur++) {\n            add(new_aux[tot ^ cur][all | (1 << cur)], mul(aux[tot][all], f[u][cur]));\n          }\n        }\n      }\n      for (int tot = 0; tot < 2; tot++) {\n        for (int all = 0; all < 4; all++) {\n          aux[tot][all] = new_aux[tot][all];\n        }\n      }\n    }\n    f[i][0] = f[i][1] = 0;\n    for (int tot = 0; tot < 2; tot++) {\n      for (int all = 0; all < 4; all++) {\n        add(f[i][tot ^ 1], aux[tot][all]);\n        if (all == 3 || (all == 2 && tot == 0)) {\n          add(f[i][tot ^ 1], aux[tot][all]);\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", (f[1][0] + f[1][1]) % md);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Random Function and Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/14417",
    "editorial": "Let\u00e2\u0080\u0099s calculate dynamics the answer for vertex with\nsize of parity . At first step to calculate this dynamic for vertex we\nshould count all different paintings of a subtree visiting all children\nin increasing order of their numbers. By multiplying this number by 2 we\nwill get paintings visiting children in decreasing order. Now some\npaintings may count twice. To fix that, let\u00e2\u0080\u0099s have a look on a some\nsubtree of a vertex . Consider all the parities of children subtrees\nvisited by our function (0 or 1). First thing to note is that among\nthese parities exist two different values, the subtree will have\ndifferent paintings with different ordering (you can prove it yourself).\nOtherwise, all our children sizes have the same parity. If all sizes are\neven, this subtree will be counted twice. Otherwise, if sizes are odd,\nwe are interested only in odd count of visited subtrees. This way, we\nmust subtract from our dynamic the number of ways to paint any number of\nchildren with even subtree sizes and odd number of children with odd\nsubtree sizes. Jury\u00e2\u0080\u0099s solution: 8394936\n"
}