{
    "link": "https://codeforces.com//contest/634/problem/E",
    "problemId": "49952",
    "problem_idx": "E",
    "shortId": "634E",
    "contest_number": "634",
    "problem_submissions": {
        "E": [
            16414340,
            16416138,
            16413706,
            16414973,
            16415599,
            16414780,
            16415591,
            16416199,
            16416181,
            16416348,
            16415632,
            16415457,
            16416072,
            16413745,
            16466856,
            16413386
        ],
        "D": [
            16411007,
            16410815,
            16412075,
            16411999,
            16412771,
            16413214,
            16412917,
            16413088,
            16413557,
            16414243,
            16411968,
            16413070,
            16413608,
            16410814,
            16411583,
            16411708,
            16418042,
            16411828
        ],
        "C": [
            16409750,
            16409051,
            16410811,
            16409734,
            16410839,
            16411665,
            16411917,
            16411834,
            16411108,
            16413312,
            16410161,
            16411194,
            16417790,
            16416407,
            16409322,
            16410089,
            16410459,
            16409945,
            16409746,
            16410147
        ],
        "B": [
            16408395,
            16409662,
            16410216,
            16408841,
            16409386,
            16409860,
            16410585,
            16409660,
            16410064,
            16408757,
            16417413,
            16417828,
            16409703,
            16408566,
            16409147,
            16409169,
            16409287,
            16410817,
            16408754
        ],
        "A": [
            16407814,
            16407800,
            16408726,
            16407801,
            16408251,
            16407972,
            16407935,
            16408112,
            16408492,
            16407803,
            16407794,
            16408196,
            16407918,
            16407735,
            16407903,
            16407915,
            16407851,
            16408302,
            16407766
        ],
        "F": [
            16417401,
            17066904
        ]
    },
    "name": "E. Preorder Test",
    "statement": "For his computer science class, Jacob builds a model tree with sticks\r\nand balls containing nodes in the shape of a tree. Jacob has spent\r\nminutes building the -th ball in the tree.Jacobâ€™s teacher will evaluate\r\nhis model and grade Jacob based on the effort he has put in. However,\r\nshe does not have enough time to search his whole tree to determine\r\nthis; Jacob knows that she will examine the first nodes in a DFS-order\r\ntraversal of the tree. She will then assign Jacob a grade equal to the\r\nminimum she finds among those nodes.Though Jacob does not have enough\r\ntime to rebuild his model, he can choose the root node that his teacher\r\nstarts from. Furthermore, he can rearrange the list of neighbors of in\r\nany order he likes. Help Jacob find the best grade he can get on this\r\nassignment.A DFS-order traversal is an ordering of the nodes of a rooted\r\ntree, built by a recursive DFS-procedure initially called on the root of\r\nthe tree. When called on a given node , the procedure does the\r\nfollowing: Print . Traverse the list of neighbors of the node in order\r\nand iteratively call DFS-procedure on each one. Do not call\r\nDFS-procedure on node if you came to node directly from .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(\"%lf\", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c=='-') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>='0') && (c<='9'))\n\t\t\tx=x*10+c-'0',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nconst int MX = 2.1e5;\n\nint N, K;\nint ai[MX];\nVI E[MX];\nVI child[MX];\nbool light[MX];\nll dp[MX][5];\n/*\n0 -> root\n1 -> unknown, but parent is dark\n2 -> in the light set, on the path\n3 -> in the light set, NOT on the path, no path available\n4 -> in the light set, NOT on the path, path available\n*/\n\nconst int NINF = -1e9;\n\nvoid solve(int x)\n{\n\tforeach(o, child[x])\n\t\tsolve(o);\n\tll useNow = NINF;\n\t{\n\t\tll& ans = dp[x][4];\n\t\tans = NINF;\n\t\tif (light[x])\n\t\t{\n\t\t\t{\n\t\t\t\t// SAVE THE PATH FOR LATER\n\t\t\t\tll sum = 1;\n\t\t\t\tll bestDelta = 0;\n\t\t\t\tforeach(o, child[x])\n\t\t\t\t{\n\t\t\t\t\tsum += dp[o][3];\n\t\t\t\t\tbestDelta = max(bestDelta, dp[o][4] - dp[o][3]);\n\t\t\t\t}\n\t\t\t\tsum += bestDelta;\n\t\t\t\tans = max(ans, sum);\n\t\t\t}\n\t\t\t{\n\t\t\t\t// USE IT NOW\n\t\t\t\tll sum = 1;\n\t\t\t\tll bestA = 0;\n\t\t\t\tll bestB = 0;\n\t\t\t\tforeach(o, child[x])\n\t\t\t\t{\n\t\t\t\t\tll v1 = max(0LL, dp[o][3]);\n\t\t\t\t\tll v2 = dp[o][2];\n\t\t\t\t\tsum += v1;\n\t\t\t\t\tll delta = v2 - v1;\n\t\t\t\t\tif (delta > bestA)\n\t\t\t\t\t{\n\t\t\t\t\t\tbestB = bestA;\n\t\t\t\t\t\tbestA = delta;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbestB = max(bestB, delta);\n\t\t\t\t}\n\t\t\t\tuseNow = sum + bestA + bestB;\n\t\t\t\tans = max(ans, useNow);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tll& ans = dp[x][3];\n\t\tans = NINF;\n\t\tif (light[x])\n\t\t{\n\t\t\tll sum = 1;\n\t\t\tforeach(o, child[x])\n\t\t\t\tsum += dp[o][3];\n\t\t\tans = max(ans, sum);\n\t\t}\n\t}\n\t{\n\t\tll& ans = dp[x][2];\n\t\tans = NINF;\n\t\tif (light[x])\n\t\t{\n\t\t\tll sum = 1;\n\t\t\tll bestDelta = 0;\n\t\t\tforeach(o, child[x])\n\t\t\t{\n\t\t\t\tll v1 = max(0LL, dp[o][3]);\n\t\t\t\tll v2 = dp[o][2];\n\t\t\t\tsum += v1;\n\t\t\t\tbestDelta = max(bestDelta, v2 - v1);\n\t\t\t}\n\t\t\tsum += bestDelta;\n\t\t\tans = max(ans, sum);\n\t\t}\n\t}\n\t{\n\t\tll& ans = dp[x][1];\n\t\tans = useNow;\n\t\tforeach(o, child[x])\n\t\t\tans = max(ans, dp[o][1]);\n\t}\n\t// printf(\"%d [%s] -> %lld %lld %lld %lld\\n\", x, light[x] ? \"light\" : \"dark\", dp[x][1], dp[x][2], dp[x][3], dp[x][4]);\n}\n\nint ROOT = 0;\n\nbool ok(int threshold)\n{\n\t// printf(\"Testing OK with threshold %d\\n\", threshold);\n\tji(N) light[i] = ai[i] >= threshold;\n\tif (light[ROOT])\n\t\treturn true;\n\tsolve(ROOT);\n\treturn dp[ROOT][1] >= K;\n}\n\nvoid init(int x, int par)\n{\n\tforeach(o, E[x]) if (o != par)\n\t{\n\t\tchild[x].pb(o);\n\t\tinit(o, x);\n\t}\n\t// printf(\"%d:\", x);\n\t// foreach(o, child[x]) printf(\" %d\", o);\n\t// printf(\"\\n\");\n}\n\nint main()\n{\n\trint(N);\n\trint(K);\n\tji(N) rint(ai[i]);\n\tjk(N-1)\n\t{\n\t\tint u, v;\n\t\trint(u); rint(v);\n\t\t--u, --v;\n\t\tE[u].pb(v);\n\t\tE[v].pb(u);\n\t}\n\tji(N) if (ai[i] < ai[ROOT])\n\t\tROOT = i;\n\tinit(ROOT, -1);\n\tVI vals(N);\n\tji(N) vals[i] = ai[i];\n\tsort(vals.begin(), vals.end());\n\treverse(vals.begin(), vals.end());\n\tint lo = K-1;\n\tint hi = N-1;\n\twhile (lo != hi)\n\t{\n\t\t// printf(\"[%d %d]\\n\", vals[lo], vals[hi]);\n\t\tint mid = (lo + hi) / 2;\n\t\tif (ok(vals[mid]))\n\t\t\thi = mid;\n\t\telse\n\t\t\tlo = mid+1;\n\t}\n\tprintf(\"%d\\n\", vals[lo]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "graphs",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Preorder Test.json",
    "editorial_link": "https://codeforces.com//blog/entry/43467",
    "editorial": "We binary search on the answer, so we need to answer queries of the following form: is the a depth-first search traversal such that the first k vertices all have value at least v? We can answer this with a greedy tree-DP: for each subtree, we compute whether or not all its vertices have value at least v, and if not, the longest possible prefix with all values at least v. Then, our transition function can be greedy: the maximum possible prefix with all values at least v is the sum of the sizes of all child subtrees which are all at least v plus the largest prefix of all child subtrees.",
    "hint": []
}