{
    "link": "https://codeforces.com//contest/853/problem/E",
    "problemId": "121092",
    "problem_idx": "E",
    "shortId": "853E",
    "contest_number": "853",
    "problem_submissions": {
        "D": [
            30147648,
            30145874,
            30152169,
            30145670,
            30147401,
            30148548,
            30157869,
            30157814,
            30157512,
            30150989,
            30149728,
            30151353,
            30151549,
            30150847,
            30147708,
            30168803,
            30167984,
            30151241,
            30151140,
            30151931,
            30151709,
            30155800,
            30154094,
            30151955
        ],
        "C": [
            30142518,
            30148496,
            30147073,
            30143792,
            30144399,
            30146037,
            30145612,
            30146271,
            30147784,
            30146395,
            30148182,
            30151583,
            30168390,
            30147533,
            30148448,
            30148036,
            30147775,
            30144847,
            30147101,
            30148563
        ],
        "B": [
            30137358,
            30139471,
            30141499,
            30138298,
            30137334,
            30139875,
            30139930,
            30139800,
            30141449,
            30137864,
            30144203,
            30143376,
            30142744,
            30143145,
            30140773,
            30144005,
            30140202,
            30140453,
            30142525
        ],
        "A": [
            30133427,
            30134359,
            30136395,
            30133742,
            30132639,
            30132563,
            30134311,
            30135028,
            30134993,
            30133338,
            30136720,
            30135878,
            30134302,
            30137681,
            30134274,
            30133388,
            30133609,
            30133814,
            30134640
        ],
        "E": [
            30179221,
            30179071,
            31229560,
            30173059
        ]
    },
    "name": "E. Lada Malina",
    "statement": "After long-term research and lots of experiments leading Megapolian\r\nautomobile manufacturer AutoVoz released a brand new car model named\r\nLada Malina . One of the most impressive features of Lada Malina is its\r\nhighly efficient environment-friendly engines.Consider car as a point in\r\nplane. Car is equipped with engines numbered from to . Each engine is\r\ndefined by its velocity vector whose coordinates are measured in\r\ndistance units per day. An engine may be turned on at any level , that\r\nis a real number between and (inclusive) that result in a term of in the\r\nfinal car velocity. Namely, the final car velocity is equal to Formally,\r\nif car moves with constant values of during the whole day then its\r\n-coordinate will change by the first component of an expression above,\r\nand its -coordinate will change by the second component of an expression\r\nabove. For example, if all are equal to zero, the car won’t move, and if\r\nall are equal to zero except , then car will move with the velocity of\r\nthe first engine.There are factories in Megapolia, -th of them is\r\nlocated in . On the -th factory there are cars Lada Malina that are\r\nready for operation.As an attempt to increase sales of a new car,\r\nAutoVoz is going to hold an international exposition of cars. There are\r\noptions of exposition location and time, in the -th of them exposition\r\nwill happen in a point with coordinates in days. Of course, at the\r\nAutoVoz is going to bring as much new cars from factories as possible to\r\nthe place of exposition. Cars are going to be moved by enabling their\r\nengines on some certain levels, such that at the beginning of an\r\nexposition car gets exactly to the exposition location. However, for\r\nsome of the options it may be impossible to bring cars from some of the\r\nfactories to the exposition location by the moment of an exposition.\r\nYour task is to determine for each of the options of exposition location\r\nand time how many cars will be able to get there by the beginning of an\r\nexposition.\r\n",
    "solutions": [
        "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<map>\n#define MN 200000\n#define N 262144\n#define INF 2000000000\n#define eps 1e-7\n#define pa pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ndouble L[MN+5];map<pa,long long> num;\nint K,n,m,totx=0,toty=0,fx[MN+5],fy[MN+5],A[MN+5];\nlong long Ans[MN+5],T[N*2+5];\nstruct vec{int x,y;double slop;}s[25];\nbool cmps(const vec&a,const vec&b){return a.slop<b.slop;}\nstruct ques{int kind,x;double y;int id,ad,t;};\nvector<ques> v[11];\ninline double GetSlop(int y,int x){if(!x)return INF;else return (double)y/x;}\nbool cmp(const ques&a,const ques&b){return a.x==b.x?a.kind>b.kind:a.x<b.x;}\nvoid Renew(int x,int y){for(T[x+=N]+=y,x>>=1;x;x>>=1) T[x]=T[x<<1]+T[x<<1|1];}\nlong long Query(int l,int r)\n{\n\tlong long sum=0;\n\tfor(l+=N-1,r+=N+1;l^r^1;l>>=1,r>>=1)\n\t{\n\t\tif(~l&1) sum+=T[l+1];\n\t\tif( r&1) sum+=T[r-1];\n\t}\n\treturn sum;\n}\n\nint Find(int r,double y)\n{\n\tint l=1,res=r+1,mid;\n\twhile(l<=r)\n\t{\n\t\tmid=l+r>>1;\t\n\t\tif(L[mid]>y) res=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn res-1;\n}\n\nvoid Solve(vector<ques> q,int ky,int kx)\n{\n//\tcout<<\"Solve\"<<k<<endl;\n\tint cnt=0;memset(T,0,sizeof(T));\n\tfor(int i=1;i<=n;++i) \n\t\tif(!kx) q.push_back((ques){1,fx[i],fy[i],A[i],0,0}),L[++cnt]=fy[i];\n\t\telse \n\t\t{\n\t\t\tdouble c=(double)fy[i]-(double)fx[i]*ky/kx;L[++cnt]=c;\n\t\t\tq.push_back((ques){1,fx[i],c,A[i],0,0});\n\t\t}\n\tsort(q.begin(),q.end(),cmp);\n//\tfor(int i=0;i<q.size();++i) printf(\"%d %.8lf %.8lf %d %d\\n\",q[i].kind,q[i].x,q[i].y,q[i].id,q[i].ad);\n\tsort(L+1,L+cnt+1);\n\tfor(int i=0;i<q.size();++i)\n\t\tif(q[i].kind)\n\t\t{\n\t\t\tint p=lower_bound(L+1,L+cnt+1,q[i].y)-L;\n\t\t\tRenew(p,q[i].id);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tint p=upper_bound(L+1,L+cnt+1,q[i].y)-L-1;\n\t\t\twhile(p>0&&q[i].t&&q[i].y==L[p]) --p;\n\t\t\tif(p>0) Ans[q[i].id]+=q[i].ad*Query(1,p); \n\t\t}\n}\n\nint main()\n{\n\tK=read();n=read();m=read();\n\tfor(int i=1;i<=K;++i) \n\t{\n\t\ts[i].x=read(),s[i].y=read();\n\t\tif(s[i].x<0) s[i].x=-s[i].x,s[i].y=-s[i].y;\n\t\tif(s[i].x==0&&s[i].y<0) s[i].y=-s[i].y;\n\t\ttotx+=s[i].x,toty+=s[i].y,s[i].x<<=1,s[i].y<<=1;\n\t}\n\tfor(int i=1;i<=K;++i) s[i].slop=atan2(s[i].y,s[i].x);\n\tsort(s+1,s+K+1,cmps);\n\tfor(int i=1;i<=K;++i) s[i+K].x=-s[i].x,s[i+K].y=-s[i].y;K<<=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfx[i]=read(),fy[i]=read(),A[i]=read(),num[make_pair(fx[i],fy[i])]+=A[i];\n\tfor(int i=1;i<=m;++i) \n\t{\n\t\tint x=read(),y=read(),t=read(),id;\n\t\tx-=t*totx;y-=t*toty;Ans[i]+=num[make_pair(x,y)];\n\t\tfor(int j=1,id=1;j<=K;x+=s[j].x*t,y+=s[j].y*t,++j,id=(j-1)%(K>>1)+1) \n\t\tif(!s[j].x)\n\t\t{\n\t\t\tif(s[j].y<0)\n\t\t\t{\n\t\t\t\tv[id].push_back((ques){0,x,y,i,1,0});\n\t\t\t\tv[id].push_back((ques){0,x,y+s[j].y*t,i,-1,0});\n\t\t\t\tv[id].push_back((ques){0,x-1,y,i,-1,0});\n\t\t\t\tv[id].push_back((ques){0,x-1,y+s[j].y*t,i,1,0});\n\t\t\t}\n\t\t}\n\t\telse if(s[j].x<0)\n\t\t{\n\t\t\tdouble c=y-(double)x*s[j].y/s[j].x;\n\t\t\tv[id].push_back((ques){0,x,c,i,1,0});\n\t\t\tv[id].push_back((ques){0,x+s[j].x*t,c,i,-1,0});\n\t\t}\n\t\telse \n\t\t{\n\t\t\tdouble c=y-(double)x*s[j].y/s[j].x;\n\t\t\tv[id].push_back((ques){0,x+s[j].x*t,c,i,-1,1});\n\t\t\tv[id].push_back((ques){0,x,c,i,1,1});\n\t\t}\n\t}\n\tfor(int i=1;i<=K>>1;++i) Solve(v[i],s[i].y,s[i].x);\n\tfor(int i=1;i<=m;++i) printf(\"%lld\\n\",Ans[i]); \n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "geometry"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Lada Malina.json",
    "editorial_link": "https://codeforces.com//blog/entry/54368",
    "editorial": "In the original contest there were subtasks for this problem and itâs\r\nmore convinient to understand the editorial going through these\r\nsubtasks, so we will leave them here.The key part of a solution is to\r\nunderstand what are the locations that may be accessed from the origin\r\nin seconds. First observation is that we should investigate it only in\r\ncase when because is simply a scale factor. Let s denote this set for as\r\n.. For the first group it s easy to see that P is a square with vertices\r\nin points . So, the first group may be solved with a straightforward\r\napproach: we iterate through all the factories and check if itâs\r\npossible to get for cars from -th factories to the car exposition. We\r\ncan rotate the plane by degrees (this may be done by the transformation\r\n), after this each query region looks like a square. Therefore, itâs\r\nnecessary to check if point lies inside a square:. In the second group\r\npropeller velocities are two arbitrary vectors. It can be shown that\r\nwill always be a parallelogram centered in the origin, built on vectors\r\nand as sides. Thus, this group is a matter of the same approach with a\r\nbit more complicated predicate: one should be able to check that an\r\ninteger point belongs to an integer parallelogram. The key observation\r\nis that we may find an appropriate transformation of a plane that\r\ntransforms this set into a rectangle. Indeed, there always exists an\r\naffine transformation performing what we want. As an additional\r\nrequirement, we want to transform coordinates in such way that they are\r\nstill integral and not much larger than the original coordinates. The\r\ntransformation looks like following:The first expression is a signed\r\ndistance to the line parallel to the vector , and the second one is the\r\nsigned distance from the line parallel to the vector . Easy to see that\r\nbelonging to some query parallelogram can be formulated in terms of and\r\nindependendly belonging to some ranges. . Second group should be a hint\r\nfor the third group. One can find that the set is always a\r\ncentral-symmetric polygon with the center in the origin. Actually, this\r\nPolygon is a Minkowski sum of segments . Minkowski sum of sets is by\r\ndefinition the following set: . It can be built in time, although in\r\nthis problem is very small, so one may use any inefficient approach that\r\ncomes into his head, like building a convex hull of all points .After we\r\nfound out a form of , it s possible to solve the third group of tests in\r\nby checking if each possible factory location belongs into a query\r\npolygon in time.Following groups are exactly the same, but the\r\nconstraints are higher, they require using some geometric data structure\r\nto deal with range queries.. Fourth group and fifth group are very\r\nsimilar to first and second group correspondingly, but we need to\r\nprocess the requests faster. After the transformation of the plane, the\r\nrequest can be reformulated as \"find sum of all factories inside a\r\nsquare\", so any 2d data structure may be applied, like a segment tree of\r\nsegment trees. Another approach is to use a sweeping line algorithm with\r\na segment tree or an appropriate binary search tree, achieving a time\r\ncomplexity or .. To solve the sixth group we need to use a trapezoidal\r\npolygon area calculation algorithm applied to our problem. Calculate the\r\nsum of points in each of trapezoid areas below each of the sides of a\r\npolygon, and then take them with appropriate signs to achieve a result.\r\nSuch trapezoid area can be seen as a set of points satisfying the\r\ninequalities and . Under transformation , this area becomes a rectangle,\r\nleading us to an time solution.\r\n",
    "hint": []
}