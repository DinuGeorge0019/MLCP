{
    "link": "https://codeforces.com//contest/1801/problem/E",
    "problemId": "1817548",
    "problem_idx": "E",
    "shortId": "1801E",
    "contest_number": "1801",
    "problem_submissions": {
        "G": [
            203657914,
            201155712,
            196755049,
            196760812,
            203134482
        ],
        "E": [
            196675152,
            196635209,
            196644302,
            196640748,
            196641519,
            196635379,
            196630013,
            196657513,
            196650893,
            196653405,
            196644576,
            196654360,
            196640172,
            196683603,
            196680417,
            196653431,
            196644218,
            196626389,
            199502352,
            199501873,
            199501660,
            199501455,
            199501378,
            199501277,
            199501214,
            199501173,
            199500937,
            199500810,
            196645808,
            196668272,
            196658312,
            196656102,
            196652330
        ],
        "F": [
            196622978,
            196623206,
            196631833,
            196626066,
            196642170,
            196635485,
            196619644,
            196630879,
            196631678,
            196626069,
            196641735,
            196624132,
            196623158,
            196622410,
            196637181,
            196627815,
            196619025,
            196627461,
            196633301,
            196628988
        ],
        "D": [
            196614757,
            196616104,
            196610930,
            196615603,
            196617463,
            196615380,
            196614983,
            196615414,
            196624090,
            196611332,
            196624396,
            196619261,
            196612951,
            196616838,
            196613243,
            196620716,
            196612736,
            196620435,
            196615283,
            196621604
        ],
        "C": [
            196609472,
            196608959,
            196606372,
            196605050,
            196609433,
            196606282,
            196610970,
            196610779,
            196613465,
            196606986,
            196612839,
            196609050,
            196607813,
            196663784,
            196670930,
            196612044,
            196605520,
            196611174,
            196610757,
            196615745
        ],
        "B": [
            196607492,
            196604951,
            196602514,
            196611006,
            196605854,
            196603175,
            196607224,
            196607805,
            196609864,
            196732242,
            196608899,
            196725334,
            196673072,
            196604282,
            196604121,
            196602391,
            196666183
        ],
        "A": [
            196601824,
            196601543,
            196601334,
            196601281,
            196602802,
            196601554,
            196623981,
            196603178,
            196605892,
            196601290,
            196604431,
            196602393,
            196602511,
            196601410,
            196601549,
            196603512,
            196601416,
            196607954,
            196604235,
            196602401
        ]
    },
    "name": "E. Gasoline prices",
    "statement": "Berland is a huge country consisting of n cities. The road network of\r\nBerland can be represented as a root tree, that is, there is only n - 1\r\nroad in the country, and you can get from any city to any other exactly\r\none way, if you do not visit any city twice. For the convenience of\r\nrepresenting the country, for each city i, the city p_i is fixed, equal\r\nto the first city to which you need to go from the city i to get to the\r\ncity 1. In other words, the city p_i is equal to the ancestor of the\r\ncity i if the tree is hung for the city 1.There is one gas station in\r\neach city of Berland. Gas stations have special pricing, and for each\r\ngas station there is a fixed range of prices for which they are ready to\r\nsell gasoline. A gas station in the city with the number i is ready to\r\nsell gasoline at any price from l_i to r_i inclusive.The King of Berland\r\nis an exemplary family man, and for m years, two sons were born to him\r\nevery year. The king’s children have been involved in public affairs\r\nsince early childhood, and at the end of each year they check the\r\nhonesty of gasoline prices. From birth, the king’s children, who are\r\nborn in the year i, are responsible for checking gasoline prices on the\r\nways from the city of a_i to the city of b_i and from the city of c_i to\r\nthe city of d_i, respectively.The check is as follows: both children\r\nsimultaneously start their journey from the cities a_i and c_i,\r\nrespectively. The first son of the king, born in the year i, moves along\r\nthe path from the city a_i to the city b_i, and the second from the city\r\nc_i to the city d_i. Children check that the price of gasoline in the\r\ncity of a_i coincides with the price of gasoline in the city of c_i.\r\nNext, they check that the price of gasoline in the second city on the\r\nway from a_i to b_i coincides with the price in the second city on the\r\nway from c_i to d_i. Then they repeat the same thing for a couple of\r\nthird cities on their paths and so on. At the end, they check that the\r\nprice of gasoline in the city of b_i coincides with the price of\r\ngasoline in the city of d_i. It is guaranteed that the length of the\r\npath from the city a_i to the city b_i coincides with the length of the\r\npath from the city c_i to the city d_i.Gas stations must strictly obey\r\nthe laws, and therefore all checks of gasoline prices should not reveal\r\nviolations. Help Berland gas stations find out how many ways they can\r\nset gasoline prices for m years. In other words, for each i from 1 to m,\r\ncalculate how many ways you can set gasoline prices at all gas stations\r\nso that after the birth of the first i pairs of the king’s children, all\r\ntheir checks did not reveal violations, and at any gas station the price\r\nwas in the acceptable price range. Since the number of such methods can\r\nbe large, calculate the answer modulo 10^9 + 7.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tvoid clear(){\n\t\tfill(all(p),-1);\n\t\tfill(all(s),1);\n\t\tc=si(p);\n\t}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\n//Lyft Level 5 Challenge 2018 - Final F\n//CF635F\ntemplate<class E>\nstruct doubling{\n\tconst vvc<E>&g;\n\tconst int n,h;\n\tint cnt;\n\tvvc<int> par;\n\tvi dep,in,out;\n\tvoid dfs(int v,int p,int d){\n\t\tpar[0][v]=p;\n\t\tdep[v]=d;\n\t\tin[v]=cnt++;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,d+1);\n\t\tout[v]=cnt;\n\t}\n\tdoubling(const vvc<E>&gg,int r):g(gg),n(g.size()),h(__lg(n+10)+1),\n\t\tcnt(0),par(h,vi(n,-1)),dep(n),in(n),out(n){\n\t\tdfs(r,-1,0);\n\t\trng(i,1,h){\n\t\t\trep(j,n)\n\t\t\t\tif(par[i-1][j]!=-1)\n\t\t\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint lca(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tint w=dep[b]-dep[a];\n\t\trep(i,h)if(w&1<<i)\n\t\t\tb=par[i][b];\n\t\tif(a==b)return a;\n\t\tper(i,h){\n\t\t\tint x=par[i][a],y=par[i][b];\n\t\t\tif(x!=y)tie(a,b)=pi(x,y);\n\t\t}\n\t\treturn par[0][a];\n\t}\n\tint len(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tint jump(int a,int b,int d){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tint c=lca(a,b);\n\t\tint w=dep[a]+dep[b]-dep[c]*2;\n\t\tassert(0<=d&&d<=w);\n\t\tif(d<=dep[a]-dep[c]){\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\ta=par[i][a];\n\t\t\treturn a;\n\t\t}else{\n\t\t\td=w-d;\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\tb=par[i][b];\n\t\t\treturn b;\n\t\t}\n\t}\n\tint getpar(int v,int len)const{\n\t\trep(i,h)if(len&1<<i)v=par[i][v];\n\t\treturn v;\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tvvc<int> t(n);\n\trng(i,1,n){\n\t\tint p;cin>>p;p--;\n\t\tt[p].pb(i);\n\t}\n\tbool bad=false;\n\tmint ans=1;\n\tvc<pi> lr(n);\n\trep(i,n){\n\t\tlr[i]=readpi();\n\t\tlr[i].b++;\n\t\tans*=lr[i].b-lr[i].a;\n\t}\n\tdoubling<int> z(t,0);\n\tunionfind uf(n);\n\tvc<unionfind> es(z.h,unionfind(2*n));\n\tauto mg=[&](auto self,int lv,int k,int a,int b)->void{\n\t\tbool x=es[lv].unite(a,k*n+b);\n\t\tbool y=es[lv].unite(n+a,(1-k)*n+b);\n\t\tif(x||y){\n\t\t\tif(lv==0){\n\t\t\t\ta=uf.find(a);\n\t\t\t\tb=uf.find(b);\n\t\t\t\tif(a!=b){\n\t\t\t\t\tans/=lr[a].b-lr[a].a;\n\t\t\t\t\tans/=lr[b].b-lr[b].a;\n\t\t\t\t\tchmax(lr[a].a,lr[b].a);\n\t\t\t\t\tchmin(lr[a].b,lr[b].b);\n\t\t\t\t\tif(lr[a].a>=lr[a].b)bad=true;\n\t\t\t\t\tans*=lr[a].b-lr[a].a;\n\t\t\t\t\tuf.unite(a,b);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(k==0){\n\t\t\t\t\tself(self,lv-1,0,a,b);\n\t\t\t\t\tself(self,lv-1,0,z.par[lv-1][a],z.par[lv-1][b]);\n\t\t\t\t}else{\n\t\t\t\t\tself(self,lv-1,1,a,z.par[lv-1][b]);\n\t\t\t\t\tself(self,lv-1,1,z.par[lv-1][a],b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tint m;cin>>m;\n\tvi x(z.h),y(z.h);\n\trep(_,m){\n\t\tint v[2][2];rep(i,2)rep(j,2){cin>>v[i][j];v[i][j]--;}\n\t\tint lca[2]{};\n\t\trep(k,2)lca[k]=z.lca(v[k][0],v[k][1]);\n\t\trep(j,2){\n\t\t\tint u=inf;\n\t\t\trep(i,2)chmin(u,z.dep[v[i][j]]-z.dep[lca[i]]);\n\t\t\tper(lv,z.h)if(u&1<<lv){\n\t\t\t\tmg(mg,lv,0,v[0][j],v[1][j]);\n\t\t\t\trep(i,2)v[i][j]=z.par[lv][v[i][j]];\n\t\t\t}\n\t\t}\n\t\tif(z.dep[v[0][0]]<z.dep[v[0][1]]){\n\t\t\trep(i,2)swap(v[i][0],v[i][1]);\n\t\t}\n\t\tassert(z.dep[v[0][0]]-z.dep[v[0][1]]==z.dep[v[1][1]]-z.dep[v[1][0]]);\n\t\tint u=z.dep[v[0][0]]-z.dep[v[0][1]]+1;\n\t\tfill(all(x),-1);\n\t\tfill(all(y),-1);\n\t\trep(lv,z.h)if(u&1<<lv){\n\t\t\tx[lv]=v[0][0];\n\t\t\tv[0][0]=z.par[lv][v[0][0]];\n\t\t}\n\t\tper(lv,z.h)if(u&1<<lv){\n\t\t\ty[lv]=v[1][1];\n\t\t\tv[1][1]=z.par[lv][v[1][1]];\n\t\t}\n\t\trep(lv,z.h)if(x[lv]!=-1){\n\t\t\tmg(mg,lv,1,x[lv],y[lv]);\n\t\t}\n\t\tif(bad)print(0);\n\t\telse print(ans);\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dsu",
        "hashing",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Gasoline prices.json",
    "editorial_link": "https://codeforces.com//blog/entry/113857",
    "editorial": "letâs\nunderstand what is required of us. A tree is given, in each vertex of\nwhich the price range for this vertex is recorded. A query is a pair of\npaths of equal length, the prices at the -th vertices along these paths\nshould be equal for all . We need to find the number of ways to place\nprices at the vertices for each prefix of restrictionsLetâs start with a\nslow solution of the problem. We will store the connectivity components\n(in each vertex prices should be equal). For each of them, we store an\nacceptable price range. The answer will be the product of the lengths of\nthe ranges over all components. We will go along the paths and combine 2\nvertices into one component using DSU. It is clear that to speed up this\nsolution, it is necessary to search faster for the moments when two\nvertices are combined into one component.First, letâs analyze the long\nsolution. Letâs make a heavy-light decomposition, with which we will\nhash the paths in the tree, taking the root number of its components as\na symbol for the vertex. Now, with the help of bin search, we will look\nfor the first moment when the hashes on the path prefixes differ, that\nis, two vertices are combined into one component. With the help of\ntransfusions, we will update the roots of their components for vertices\nand the tree of segments for hld. We will get unions, we will find each\none for using hld. There will also be updates in the segment tree due to\noverflows. For each request there will be from hld. The final asymptotic\nNow letâs give a beautiful solution to this problem. Letâs start with\nbamboo.Replace the equality of prices on a pair of paths with two pairs\nof paths with lengths equal to the maximum power of two, less than the\nlength of the original path (as in sparse table). Now the path lengths\nof all constraints have become powers of two. We will iterate over the\npowers of two in descending order , for each path of length we will get\na vertex in the graph, we will also get a vertex for each such path in\nreverse order. Now the constraints define edges in such a graph. Letâs\nspend them, select the spanning tree. For each edge from the backbone,\nwe divide the constraints into 2 constraints with path lengths half as\nlong and continue the process. On a layer with lengths 1, we will get\nthe spanning tree we need, which will be responsible for the first\nmoments when some pairs of vertices were combined into components. Note\nthat no more than edges will be added down from each layer, as well as\nno more than edges from queries. That is, each layer will work for ,\nwhere is the average operating time in DSU, the inverse of the Ackerman\nfunction. We got the solution in For a complete solution on the tree,\nfirst we divide a pair of paths into three pairs of corresponding\nvertical paths (take from the 4 end vertices of these paths the pair of\nvertices closest to the lca on its path, then we pair this path with a\nvertical path (part of another path), now we get one vertical path and\nan arbitrary path in the tree, letâs split the second path by lca and\nthe first by the corresponding lengths). Next, we will proceed similarly\nto bamboo, only the place of the vertex responsible for the segment, we\nwill get the vertex responsible for the binary ascent in the tree to a\nheight equal to the power of two.\n",
    "hint": []
}