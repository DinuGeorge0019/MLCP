{
    "link": "https://codeforces.com//contest/1479/problem/A",
    "problemId": "889625",
    "problem_idx": "A",
    "shortId": "1479A",
    "contest_number": "1479",
    "problem_submissions": {
        "D": [
            106806356,
            106798804,
            106791682,
            106791766,
            106783633,
            106814882,
            106806404,
            106823371,
            106808799,
            106822218,
            106817839,
            106848882,
            106812415,
            106835076,
            106827553,
            106802594,
            106816382,
            106815777,
            106820515,
            106838550,
            106850875,
            106833526
        ],
        "C": [
            106782305,
            106781616,
            106813281,
            106777792,
            106806652,
            106785851,
            106790598,
            106804329,
            106788311,
            106797179,
            106801693,
            106797158,
            106799023,
            106802871,
            106833768,
            106794280,
            106835769,
            106791359,
            106812286,
            106805528
        ],
        "B2": [
            106767251,
            106763833,
            106764524,
            106766365,
            106766872,
            106772583,
            106777899,
            106776623,
            106772714,
            106777329,
            106781346,
            106839134,
            106782598,
            106789550,
            106774779,
            106781374,
            106779953,
            106776541,
            106784819,
            106807842
        ],
        "B1": [
            106761871,
            106761547,
            106772762,
            106765327,
            106765110,
            106769139,
            106770176,
            106777978,
            106783437,
            106765790,
            106777195,
            106759777,
            106771397,
            106771604,
            106765950,
            106772183,
            106778477,
            106775679,
            106771753,
            106783453
        ],
        "A": [
            106755900,
            106753726,
            106756482,
            106751012,
            106869291,
            106756412,
            106753230,
            106749820,
            106752580,
            106752067,
            106756325,
            106758074,
            106749882,
            106753072,
            106759686,
            106753472,
            106830245,
            106764145,
            106862156,
            106753714,
            106755663
        ],
        "E": [
            106862710,
            106861209,
            106848127,
            128939200,
            106847859,
            106846880,
            112187125
        ]
    },
    "name": "A. Searching Local Minimum",
    "statement": ".Homer likes arrays a lot and he wants to play a game with you. Homer\r\nhas hidden from you a permutation a_1, a_2,\r\ndots, a_n of integers 1 to n. You are asked to find any index k (1\r\nleq k\r\nleq n) which is a local minimum. For an array a_1, a_2,\r\ndots, a_n, an index i (1\r\nleq i\r\nleq n) is said to be a if a_i <\r\nmin\r\n{a_{i-1},a_{i+1}\r\n}, where a_0 = a_{n+1} = +\r\ninfty. An array is said to be a permutation of integers 1 to n, if it\r\ncontains all integers from 1 to n exactly once.Initially, you are only\r\ngiven the value of n without any other information about this\r\npermutation.At each interactive step, you are allowed to choose any i (1\r\nleq i\r\nleq n) and make a query with it. As a response, you will be given the\r\nvalue of a_i. You are asked to find any index k which is a local minimum\r\n.\r\n",
    "solutions": [
        "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n// Actual solution is at the bottom\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef int64_t int64;\ntypedef pair<int, int> ii;\n\nclass ASearchingLocalMinimum {\n public:\n  void solveOne() {\n    int n;\n    cin >> n;\n    if (n == 1) {\n      cout << \"! 1\\n\";\n      cout.flush();\n      return;\n    }\n    cout << \"? 1\\n\";\n    cout.flush();\n    int a0;\n    cin >> a0;\n    cout << \"? 2\\n\";\n    cout.flush();\n    int a1;\n    cin >> a1;\n    if (a0 < a1) {\n      cout << \"! 1\\n\";\n      cout.flush();\n      return;\n    }\n    cout << \"? \" << (n - 1) << \"\\n\";\n    cout.flush();\n    int a2;\n    cin >> a2;\n    cout << \"? \" << n << \"\\n\";\n    cout.flush();\n    int a3;\n    cin >> a3;\n    if (a2 > a3) {\n      cout << \"! \" << n << \"\\n\";\n      cout.flush();\n      return;\n    }\n    int left = 1;\n    int right = n - 2;\n    while (true) {\n      if (left == right) {\n        cout << \"! \" << (left + 1) << \"\\n\";\n        cout.flush();\n        return;\n      }\n      int m1 = (left + right) / 2;\n      int m2 = m1 + 1;\n      cout << \"? \" << (m1 + 1) << \"\\n\";\n      cout.flush();\n      int b0;\n      cin >> b0;\n      cout << \"? \" << (m2 + 1) << \"\\n\";\n      cout.flush();\n      int b1;\n      cin >> b1;\n      if (b0 < b1) {\n        right = m1;\n      } else {\n        left = m2;\n      }\n    }\n  }\n\n  void solve() {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne();\n    }\n  }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ASearchingLocalMinimum solver;\n\n\n    solver.solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "interactive",
        "ternary search"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Searching Local Minimum.json",
    "editorial_link": "https://codeforces.com//blog/entry/87598",
    "editorial": "We maintain by binary search a range which has a local minimum.\r\nMoreover, we assume that and . Initially, .In each iteration, let be the\r\nmidpoint of and . . If , then the range becomes .. If , then the range\r\nbecomes .When , we have found a local minimum .The number of queries to\r\nis at most .\r\n"
}