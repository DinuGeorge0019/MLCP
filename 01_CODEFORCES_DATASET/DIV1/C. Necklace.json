{
    "link": "https://codeforces.com//contest/613/problem/C",
    "problemId": "45533",
    "problem_idx": "C",
    "shortId": "613C",
    "contest_number": "613",
    "problem_submissions": {
        "D": [
            15370174,
            15369060,
            15371636,
            15370471,
            15379384,
            15362600,
            15363979,
            15354167,
            15368389,
            15426084,
            15425641,
            15365392,
            15373098,
            18779257,
            15368296,
            15377483,
            15371351
        ],
        "C": [
            15363274,
            15363231,
            15359913,
            15359671,
            15371545,
            15371994,
            15368974,
            15427099,
            15373779,
            15500484,
            15359086,
            15366208,
            15362711,
            15361056,
            15365561,
            15365370
        ],
        "B": [
            15355133,
            15358358,
            15354489,
            15354211,
            15353308,
            15367695,
            15366228,
            15357588,
            15366815,
            15355551,
            15352746,
            15361105,
            15353369,
            15358156,
            15356015,
            15356798
        ],
        "A": [
            15349386,
            15350249,
            15349384,
            15362764,
            15355920,
            15349371,
            15350969,
            15352662,
            15350106,
            15372771,
            15354161,
            15348878,
            15349502,
            15352202,
            15349256,
            15352650
        ],
        "E": [
            15391423,
            16723541,
            16067912,
            16067870
        ]
    },
    "name": "C. Necklace",
    "statement": "Ivan wants to make a necklace as a present to his beloved girl. A is a\r\ncyclic sequence of beads of different colors. Ivan says that necklace is\r\nrelative to the cut point between two adjacent beads, if the chain of\r\nbeads remaining after this cut is a palindrome (reads the same forward\r\nand backward). Ivan has beads of colors. He wants to make a necklace,\r\nsuch that it\u2019s beautiful relative to as many cuts as possible. He\r\ncertainly wants to use all the beads. Help him to make the most\r\nbeautiful necklace.\r\n",
    "solutions": [
        "#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 26, L = 100005;\n\nint n;\n\nint cnt[N];\n\nint ans;\n\nchar s[L];\n\nint main() {\n    scanf(\"%d\", &n);\n    int odds = 0;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", cnt + i);\n        odds += cnt[i] & 1;\n    }\n    if (n == 1) {\n        ans = cnt[0];\n        for (int i = 0; i < cnt[0]; ++i) {\n            s[i] = 'a';\n        }\n    } else if (n > 1) {\n        if (odds >= 2) {\n            ans = 0;\n            int top = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < cnt[i]; ++j) {\n                    s[top++] = 'a' + i;\n                }\n            }\n        } else if (odds == 1) {\n            int mid = -1, l = 0;\n            for (int i = 0; i < n; ++i) {\n                l += cnt[i];\n                if (cnt[i] & 1) {\n                    mid = i;\n                }\n            }\n            int g = 0;\n            for (int i = 0; i < n; ++i) {\n                if (~cnt[i] & 1) {\n                    g = g ? cnt[i] : __gcd(g, cnt[i]);\n                }\n            }\n            g /= 2;\n            g = __gcd(g, cnt[mid]);\n            ans = g;\n            int top = 0;\n            for (int i = 0; i < g; ++i) {\n                for (int j = 0; j < cnt[mid] / g; ++j) {\n                    s[top++] = 'a' + mid;\n                }\n                for (int j = 0; j < n; ++j) {\n                    if (j != mid) {\n                        for (int k = 0; k < cnt[j] / g / 2; ++k) {\n                            s[top++] = 'a' + j;\n                        }\n                    }\n                }\n                for (int j = n - 1; j >= 0; --j) {\n                    if (j != mid) {\n                        for (int k = 0; k < cnt[j] / g / 2; ++k) {\n                            s[top++] = 'a' + j;\n                        }\n                    }\n                }\n            }\n        } else if (odds == 0) {\n            int g = cnt[0];\n            for (int i = 0; i < n; ++i) {\n                g = __gcd(g, cnt[i]);\n            }\n            ans = g;\n            int top = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < cnt[i] / g; ++j) {\n                    s[top++] = 'a' + i;\n                }\n            }\n            int p = top;\n            for (int i = 0; i + 1 < g; ++i) {\n                int cur = top;\n                for (int j = 0; j < p; ++j) {\n                    s[top++] = s[cur - 1 - j];\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    puts(s);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Necklace.json",
    "editorial_link": "https://codeforces.com//blog/entry/22832",
    "editorial": "Surprisingly, the nice cuts can't be put randomly. Let's take a look on the first picture above (red lines represent nice cut points). But since the necklace is symmetrical relative to nice cuts, the cut points are also symmetrical relative to nice cuts, so there is one more cut (see picture two). Repeating this process, we will split the whole necklace into parts of the same size (picture three).\n\n     \n\nIf the number of parts is even, then each part can be taken arbitrarily, but the neighbouring parts must be reverses of each other (e.g. \"abc\" and \"cba\"). This is an implication of the cuts being nice.\n\nIf the number of parts is odd, then each part is equal to each other and is a palindrome, this is an implication of the cuts being nice too.\n\nAnyway, the number of characters in each part is equal, so amount of parts can't be greater than . Actually, it may be zero,  or its divisor.\n\nIf the number of odd-sized colors is zero, then the sum is even and gcd is even, this way we can construct a building block containing exactly  beads of i-th color, (gcd being gcd of all counts), then build beads of gcd parts, where each part equal to building block, with neighbouring parts being reverses. Since gcd is even, everything is ok.\n\nIf the number of odd-sized colors is one, then the sum is odd and gcd is odd. Building block have to be built as a palindrome containing  beads of i-th color, exactly n?-?1 of colors will be even and one odd, put the odd one in center, others on sides (aabcbaa). Everything is ok.\n\nIf num of odd counts is geq2. Gcd is odd, all its divisors too, so our building block has to be palindrome. Let k denote the number of parts. A building block will contain  beads of color i, at least two of these numbers are odd, it is impossible to build such a palindrome. The answer is zero.\n\nComplexity: O(sum), just to output answer.\n\nBonus. How to solve problem, if you are allowed to discard any subset of beads before constructing necklace?\n\nBonus. Given a necklace scheme (like one you were asked to output), how to determine number of nice cuts, O(sum), no suffix structures or hashes?"
}