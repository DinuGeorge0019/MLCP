{"link": "https://codeforces.com//contest/573/problem/C", "problemId": "34312", "problem_idx": "C", "shortId": "573C", "contest_number": "573", "problem_submissions": {"E": [12759251, 12766903, 12766685, 12854212], "C": [12753961, 12751834, 12752631, 12751871, 12753878, 12754621, 12753383, 12752808, 12753460, 12750581, 12750687, 12754051, 12757263, 12753734, 12752897, 12751281, 12753745, 12753332], "B": [12746992, 12747515, 12746798, 12748316, 12747498, 12747954, 12747704, 12747330, 12747866, 12747572, 12747495, 12748230, 12747423, 12748530, 12748216, 12747086, 12747056, 12748571], "A": [12746189, 12746077, 12746084, 12746660, 12746402, 12746165, 12746157, 12746206, 12746195, 12746103, 12746141, 12746264, 12746158, 12746252, 12746081, 12746225, 12746120, 12746512], "D": [12760293, 12767357, 12767345, 12767321, 12767302, 12767261, 12766285, 12766274, 12759069, 12759185, 12761792, 12787796, 12787738, 12787732, 12762112, 12766448, 12762456, 12761429, 12791178, 12769647, 12769635]}, "name": "C. Bear and Drawing", "statement": "Limak is a little bear who learns to draw. People usually start with\r\nhouses, fences and flowers but why would bears do it? Limak lives in the\r\nforest and he decides to draw a tree.Recall that is a connected graph\r\nconsisting of vertices and edges.Limak chose a tree with vertices. He\r\nhas infinite strip of paper with two parallel rows of dots. Little bear\r\nwants to assign vertices of a tree to some distinct dots on a paper so\r\nthat edges would intersect only at their endpoints drawn tree must be\r\nplanar. Below you can see one of correct drawings for the first sample\r\ntest. Is it possible for Limak to draw chosen tree?\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100010\nint n;\nvector<int> d[MAX],d2[MAX];\nbool cz[MAX],cz2[MAX];\nint ile[MAX];\nvoid dfs(int nr,int o){\n  if(SZ(d[nr]) <= 2){\n    cz[nr] = 1;\n    R(i,d[nr].size()){\n      if(d[nr][i] != o)\n        dfs(d[nr][i],nr);\n    }\n  }else{\n    ile[nr]++;\n  }\n}\nvoid tnij(){\n  R(i,n){\n    if(SZ(d[i]) == 1){\n      dfs(i,-1);\n    }\n  }\n}\nvoid tnij2(){\n  R(i,n){\n    if(ile[i] == 2 && SZ(d[i]) == 3)\n      cz[i] = 1;\n  }\n}\nvoid spr3(){\n  R(i,n){\n    if(cz[i] == 0){\n      int deg = 0;\n      R(j,SZ(d[i])){\n        if(cz[d[i][j]] == 0)\n          deg++;\n      }\n      if(deg > 2){\n        puts(\"No\");\n        exit(0);\n      }\n    }\n  }\n}\nmain(){\n  make(n);\n  R(i,n-1){\n    int a,b;\n    make2(a,b);\n    a--;b--;\n    d[a].PB(b);\n    d[b].PB(a);\n  }\n  tnij();\n  tnij2();\n  spr3();\n  puts(\"Yes\");\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "trees"], "dificulty": "2300", "interactive": false}