{
    "link": "https://codeforces.com//contest/258/problem/B",
    "problemId": "2443",
    "problem_idx": "B",
    "shortId": "258B",
    "contest_number": "258",
    "problem_submissions": {
        "D": [
            2814736,
            2812430,
            2814871,
            2814961,
            2812733,
            2815597,
            2815735,
            3321861,
            2817362,
            2813664,
            2817783,
            2816087,
            2814924
        ],
        "E": [
            2813546,
            2815005,
            2813362,
            2813842,
            2813877,
            2813261,
            2811449,
            2814046,
            2814079,
            2814422,
            2814320,
            2814528,
            2814704,
            2817438,
            2817366,
            2817363,
            2817357,
            2817344,
            2817287,
            2817270,
            2814834
        ],
        "C": [
            2811749,
            2809654,
            2812462,
            2812301,
            2814561,
            2810964,
            2812259,
            2812879,
            2811632,
            2812613,
            2812711,
            2812609,
            2811716,
            2810788,
            2813202,
            2812348,
            2813127
        ],
        "B": [
            2809756,
            2813180,
            2810688,
            2811171,
            2811678,
            2809679,
            2814549,
            2809883,
            2810504,
            2810872,
            2811182,
            2813077,
            2812214,
            2811807,
            2810280,
            2810608
        ],
        "A": [
            2807475,
            2810109,
            2807417,
            2807993,
            2807422,
            2807498,
            2807514,
            2808316,
            2807507,
            2807423,
            2807995,
            2807416,
            2807421,
            2807426,
            2807559
        ]
    },
    "name": "B. Little Elephant and Elections",
    "statement": "There have recently been elections in the zoo. Overall there were main\r\npolitical parties: one of them is the Little Elephant Political Party,\r\nother parties have less catchy names.Political parties find their number\r\nin the ballot highly important. Overall there are possible numbers: .\r\nEach of these parties is going to be assigned in some way to exactly one\r\nnumber, at that, two distinct parties cannot receive the same number.The\r\nLittle Elephant Political Party members believe in the lucky digits and\r\n. They want to evaluate their chances in the elections. For that, they\r\nneed to find out, how many correct assignments are there, such that the\r\nnumber of lucky digits in the Little Elephant Political Party ballot\r\nnumber is strictly larger than the total number of lucky digits in the\r\nballot numbers of 6 other parties. Help the Little Elephant Political\r\nParty, calculate this number. As the answer can be rather large, print\r\nthe remainder from dividing it by .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n\n\nint m, length;\nint digit[11];\n\nint memory[2][11][11];\n\nint count(bool first, bool less, int length, int size) {\n    if (length == 0) {\n        return less && !size;\n    }\n    if (less && memory[first][length][size] != -1) {\n        return memory[first][length][size];\n    }\n    int ret = 0;\n    for (int i = 0; i < 10; ++ i) {\n        if (first && !i) {\n            continue;\n        }\n        if (!less && digit[length - 1] < i) {\n            continue;\n        }\n        ret += count(false, less || i < digit[length - 1], length - 1, size - (i == 4 || i == 7));\n    }\n    if (less) {\n        memory[first][length][size] = ret;\n    }\n    return ret;\n}\n\nint size[11];\n\nconst int MOD = 1000000000 + 7;\n\nint answer;\nint ways[7];\n\nvoid dfs(int i, int way) {\n    if (i < 7) {\n        for (int k = 0; k <= 10; ++ k) {\n            if (size[k] > 0) {\n                ways[i] = k;\n                dfs(i + 1, (long long)way * (size[k] --) % MOD);\n                size[k] ++;\n            }\n        }\n    } else {\n        int sum = 0;\n        for (int i = 0; i < 6; ++ i) {\n            sum += ways[i];\n        }\n        sum -= ways[6];\n        if (sum < 0) {\n            answer += way;\n            answer %= MOD;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &m);\n    m ++;\n    length = 0;\n    while (m) {\n        digit[length ++] = m % 10;\n        m /= 10;\n    }\n    memset(memory, -1, sizeof(memory));\n    for (int k = 0; k <= 10; ++ k) {\n        for (int i = 1; i <= length; ++ i) {\n            size[k] += count(true, i < length, i, k);\n        }\n    }\n    //for (int i = 0; i <= 10; ++ i) {\n    //    printf(\"%d\\n\", size[i]);\n    //}\n    answer = 0;\n    dfs(0, 1);\n    printf(\"%d\\n\", answer);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Little Elephant and Elections.json",
    "editorial_link": "https://codeforces.com//blog/entry/6213",
    "editorial": "First of all, lets think about the problem of finding array the number\r\nof integers from 1 to such, that the number of lucky digits is equal to\r\n. It\u00e2\u0080\u0099s pretty standart dynamic programminc problem, which can be solved\r\nwith state [position][less][count]. It can be solved directly using DP,\r\nbut to simplify a bit you can use brute force (recursion) to brute all\r\npossible assignments of numbers of lucky digits in for all paries (up to\r\n9 digits). Now you can divide all parties in several indepentent groups,\r\neach of which should contain the same number of lucky digits. Consider\r\nthat the party of Litte Elephant is with number 1. Than assignment for\r\nthe first position should have more digits than the sum of the rest\r\n(because of the statement). Since all groups are indepented (because\r\nthere is no number that can have different number of lucky digits,\r\nobviously) you can find the number of resulting assignments for each\r\ngroup and find the final result by multiplying these all numbers and\r\ntaking modulo . Consider that you have group of size , each number of\r\nwhich should contain lucky digits. That it\u00e2\u0080\u0099s pretty easy to understand\r\nthat the number of assignment is equal to .\r\n"
}