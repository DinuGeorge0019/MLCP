{"link": "https://codeforces.com//contest/87/problem/D", "problemId": "460", "problem_idx": "D", "shortId": "87D", "contest_number": "87", "problem_submissions": {"E": [480522, 480373, 480563, 481052, 487220, 487031, 486475, 483729, 480251, 482514, 479707, 481257], "D": [479023, 478767, 478527, 480005, 478079, 479874, 481953, 479744, 478788, 480461, 479633, 479612, 480061, 1186292, 480377], "C": [477696, 477515, 477634, 477346, 478564, 477717, 482287, 482259, 482254, 482249, 478031, 477748, 478549, 478513, 478021, 477556, 477965, 477701, 478643, 478646], "B": [477395, 477959, 480915, 478219, 479510, 478272, 478602, 479590, 477948, 477912, 477626, 478345, 478853, 480591, 477860, 478043], "A": [477178, 477245, 477382, 477797, 478932, 477255, 477225, 477234, 477375, 477368, 477236, 477191, 477429, 479893, 477216, 477325]}, "name": "D. Beautiful Road", "statement": "A long time ago in some country in Asia were civil wars.Each of cities\r\nwanted to seize power. That\u2019s why sometimes one city gathered an army\r\nand sent it to campaign against another city.Road making was difficult,\r\nso the country had few roads, exactly . Also you could reach any city\r\nfrom any other city going on those roads.Even during the war the\r\nOriental people remain spiritually rich and appreciate the beauty of\r\nnature. And to keep the memory of this great crusade for the centuries\r\nto come, they planted one beautiful tree by the road on which the army\r\nspent most time. The Oriental people love nature, that\u2019s why if there\r\nwere several such roads, then one tree was planted by each of\r\nthem.Recently, when the records of the war were found, it became clear\r\nthat each city attacked each other one exactly once. There were exactly\r\nattacks in total. Everyone has been wondering what road after those wars\r\nbecame the most beautiful, that is, by which road they planted the\r\nlargest number of beautiful trees.\r\n", "solutions": ["#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <bitset>\n#include <cmath>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#define mp make_pair\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef long long int64;\ntypedef vector<int> vi;\n\ntemplate<class T> T abs(T x) {return x > 0 ? x : (-x); }\ntemplate<class T> T sqr(T x) {return x * x; }\n\nconst int maxn = 218 * 1000;\n\n\nvector<ii> g[maxn];\nvi gind[maxn];\n\nvi v;\n\nint64 opt = -1;\nvi cnt;\n\nvi G[maxn];\nvi Gind[maxn];\nint val[maxn];\n\nint u[maxn];\nint uc[maxn];\n\nint get(int x) {\n    if (x == u[x]) return x;\n    return u[x] = get(u[x]);\n}\n\nvoid uni(int x, int y) {\n    if (rand() % 2)\n        swap(x, y);\n    x = get(x), y = get(y);\n    if (x == y) return;\n    uc[y] += uc[x];\n    u[x] = y;\n}\n\nint64 sum = 0;\n\nbool us[maxn];\n\nvoid dfs0(int x, int p = -1) {\n    us[x] = true;\n    sum += val[x];\n    for (int i = 0; i < sz(G[x]); ++i) {\n        if (G[x][i] == p) continue;\n        dfs0(G[x][i], x);\n    }\n}\n\nint64 dfs(int x, int p = -1) {\n    int64 res = val[x];\n    for (int i = 0; i < sz(G[x]); ++i) {\n        if (G[x][i] == p) continue;\n        int64 t = dfs(G[x][i], x);\n        int64 cur = t * (sum - t);\n        if (cur > opt) {\n            opt = cur;\n            cnt.clear();\n            cnt.pb(Gind[x][i]);\n        }\n        else if (cur == opt) \n            cnt.pb(Gind[x][i]);\n        res += t;\n    }\n    return res;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n        u[i] = i, uc[i] = 1;\n    vector<pair<ii, ii> > e;\n    for (int i = 0; i < n - 1; ++i) {\n        int x, y, z;\n        scanf(\"%d%d%d\", &x, &y, &z);\n        --x, --y;\n        g[x].pb(ii(y, z));\n        g[y].pb(ii(x, z));\n        gind[x].pb(i);\n        gind[y].pb(i);\n        v.pb(z);\n        e.pb(mp(ii(z, i), ii(x, y)));\n    }\n    sort(all(v));\n    v.erase(unique(all(v)), v.end());\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < sz(g[i]); ++j) {\n            int l = g[i][j].second;\n            l = lower_bound(all(v), l) - v.begin();\n            g[i][j].second = l;\n        }\n\n    sort(all(e));\n    int cur = 0;\n    while (cur < sz(e)) {\n        int next = cur;\n        vi w;\n        while (next < sz(e) && e[next].first.first == e[cur].first.first) {\n            w.pb(get(e[next].second.first));\n            w.pb(get(e[next].second.second));\n            ++next;\n        }\n        sort(all(w));\n        w.erase(unique(all(w)), w.end());\n        int m = sz(w);\n        sum = 0;\n        for (int i = 0; i < m; ++i) {\n            G[i].clear();\n            Gind[i].clear();\n            val[i] = uc[w[i]];\n            sum += val[i];\n            us[i] = false;\n        }\n        for (int i = cur; i < next; ++i) {\n            int x = lower_bound(all(w), get(e[i].second.first)) - w.begin();\n            int y = lower_bound(all(w), get(e[i].second.second)) - w.begin();\n            G[x].pb(y);\n            G[y].pb(x);\n            Gind[x].pb(e[i].first.second);\n            Gind[y].pb(e[i].first.second);\n        }\n        for (int i = 0; i < m; ++i) {\n            if (us[i]) continue;\n            sum = 0;\n            dfs0(i);\n            dfs(i);\n        }\n        for (int i = cur; i < next; ++i) {\n            uni(e[i].second.first, e[i].second.second);\n        }\n        cur = next;\n    }\n\n    sort(all(cnt));\n    cout << (2LL * opt) << \" \" << sz(cnt) << \"\\n\";\n    for (int i = 0; i < sz(cnt); ++i)\n        printf(\"%d \", cnt[i] + 1);\n    printf(\"\\n\");\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "dsu", "graphs", "implementation", "sortings", "trees"], "dificulty": "2300", "interactive": false}