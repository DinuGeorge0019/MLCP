{
    "link": "https://codeforces.com//contest/713/problem/C",
    "problemId": "71347",
    "problem_idx": "C",
    "shortId": "713C",
    "contest_number": "713",
    "problem_submissions": {
        "C": [
            26460974,
            20575910,
            20583094,
            20581559,
            20581733,
            20583408,
            20579455,
            20582507,
            20580790,
            20585663,
            37183524,
            20586646,
            20578141,
            20587141,
            20583393,
            20576023,
            20577632,
            20581746,
            20588485,
            80008205,
            79474335,
            20583081,
            20586247,
            20589607
        ],
        "D": [
            20589016,
            20588044,
            20589791,
            20590045,
            20590281,
            20591597,
            20591896,
            20601734,
            20601720,
            20594132,
            20593560,
            20593079,
            20596440,
            20593442,
            20596199,
            20584415,
            20594603,
            20595698,
            20593723,
            20595881,
            24960690,
            20593574
        ],
        "B": [
            20583151,
            20580004,
            20578178,
            20578836,
            20578366,
            20585770,
            20579555,
            20576646,
            20583230,
            20581847,
            20589836,
            20583553,
            20579782,
            20588723,
            20589144,
            20578568,
            20589488,
            20583796,
            20583317
        ],
        "A": [
            20572754,
            20572042,
            20571909,
            20572204,
            20571875,
            20571504,
            20584123,
            20571416,
            20574058,
            20587954,
            20571916,
            20573302,
            20574693,
            20573904,
            20589571,
            20575437,
            20571888,
            20573337,
            20572118,
            20572133
        ],
        "E": [
            20940861,
            20595260
        ]
    },
    "name": "C. Sonya and Problem Wihtout a Legend",
    "statement": "Sonya was unable to think of a story for this problem, so here comes the\r\nformal description.You are given the array containing positive integers.\r\nAt one turn you can pick any element and increase or decrease it by .\r\nThe goal is the make the array strictly increasing by making the minimum\r\npossible number of operations. You are allowed to change elements in any\r\nway, they can become negative or equal to .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nlong long ans;\nmultiset < int > S;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n{\n    int ai;\n    scanf (\"%d\", &ai), ai -= i;\n//    printf (\"%d%c\", ai, \" \\n\"[i==N]);\n    if (S.empty () || (*S.rbegin ()) <= ai) S.insert (ai);\n    else\n    {\n        auto it = S.end (); it --;\n        ans += (*it) - ai, S.erase (it), S.insert (ai), S.insert (ai);\n    }\n}\nprintf (\"%I64d\\n\", ans);\n\nreturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Sonya and Problem Wihtout a Legend.json",
    "editorial_link": "https://codeforces.com//blog/entry/47094",
    "editorial": "Lets first solve easier problem. Given an array of number what it is\r\nminimal amount of operations ( to element, to element) to make all\r\nnumbers in array equal? We need to solve this problem for each prefix.\r\nOptimal solution would be making all numbers equal to median value of\r\nthe prefix (middle element in sorted list). For this problem we can\r\nsimply use two heaps and insert element in right one (removing elements\r\nfrom inserted if need) to keep heaps equal and fit the constraint\r\nmax_value(Heap1) min_value(Heap2). Now lets solve harder problem. What\r\nis minimal amount of operations ( to element, to element) to make array\r\nbe arithmetics progression with step ? We can just reduce number in\r\narray by value and will receive previous problem. Finally we have\r\noriginal problem. answer for prefix ending in , i.e. number of\r\noperations to make prefix of first elements in increasing order. Also\r\nfor each will remember minimal last number in resulting sequence. For\r\neach will bruteforce value () and calculate answer for if [, ] if\r\narithmetics progression with step . Also we need to assume if median\r\nvalue in [, ] is lower than minimal value at i than we cannot update\r\nanswer for by answer for .\r\n"
}