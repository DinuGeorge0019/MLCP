{
    "link": "https://codeforces.com//contest/1630/problem/C",
    "problemId": "1275998",
    "problem_idx": "C",
    "shortId": "1630C",
    "contest_number": "1630",
    "problem_submissions": {
        "E": [
            144224769,
            144215907,
            144221628,
            144228274,
            144219804,
            144218158,
            144225764,
            144238591,
            144210990,
            144217838,
            144226182,
            144224358,
            144225778,
            144221770,
            144226514,
            144222722,
            144227026,
            144226268,
            144232930
        ],
        "F": [
            144210863,
            144246407,
            144239829,
            144237561,
            144242088,
            144244711,
            144244456,
            144246802,
            144259720,
            144255927,
            144333444,
            144255940,
            144608342,
            148502898,
            148434493,
            148432956
        ],
        "D": [
            144197307,
            144203996,
            144209276,
            144205176,
            144207016,
            144204010,
            144211325,
            144216890,
            144199054,
            144199808,
            144201432,
            144206931,
            144201023,
            144209262,
            144204729,
            144211122,
            144210123,
            144205407,
            144205842
        ],
        "C": [
            144191312,
            144195772,
            144199628,
            144200731,
            144196919,
            144198723,
            144205328,
            144206861,
            144191587,
            144193957,
            144195705,
            144198126,
            144190461,
            144203715,
            144198045,
            144205577,
            144200182,
            144197491,
            144198438
        ],
        "B": [
            144182123,
            144182453,
            144193080,
            144189508,
            144185231,
            144186871,
            144189030,
            144188822,
            144178499,
            144179435,
            144183325,
            144180542,
            144180237,
            144181268,
            144190041,
            144176578,
            144186138,
            144190693,
            144189698
        ],
        "A": [
            144175474,
            144175629,
            144182481,
            144180498,
            144176716,
            144180161,
            144180336,
            144179468,
            144172483,
            144171609,
            144171918,
            144172250,
            144173608,
            144173794,
            144181834,
            144190017,
            144177869,
            144180828,
            144177686
        ]
    },
    "name": "C. Paint the Middle",
    "statement": "You are given n elements numbered from 1 to n, the element i has value\r\na_i and color c_i, initially, c_i = 0 for all i.The following operation\r\ncan be applied: Select three elements i, j and k (1\r\nleq i < j < k\r\nleq n), such that c_i, c_j and c_k are all equal to 0 and a_i = a_k,\r\nthen set c_j = 1. Find the maximum value of\r\nsum\r\nlimits_{i=1}^n{c_i} that can be obtained after applying the given\r\noperation any number of times.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[N];\nint b[N][2];\nint ans;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i <= n; i++)\n\t\tb[i][0] = b[i][1] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tif (b[a[i]][0] == -1) b[a[i]][0] = i;\n\t\tb[a[i]][1] = i;\n\t}\n\tans = n;\n\tint l = 0, r = -1;\n\twhile(l < n) {\n\t\teprintf(\"[%d %d]\\n\", l, r);\n\t\tif (r == -1) {\n\t\t\tint p = b[a[l]][1];\n\t\t\tif (p > l) {\n\t\t\t\tans--;\n\t\t\t\tl++;\n\t\t\t\tr = p;\n\t\t\t} else {\n\t\t\t\tl++;\n\t\t\t\tans--;\n\t\t\t}\n\t\t} else {\n\t\t\tint mx = r;\n\t\t\twhile(l < r) {\n\t\t\t\tmx = max(mx, b[a[l]][1]);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (mx == r) {\n\t\t\t\tans--;\n\t\t\t\tl = r + 1;\n\t\t\t\tr = -1;\n\t\t\t} else {\n\t\t\t\tans--;\n\t\t\t\tl = r + 1;\n\t\t\t\tr = mx;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Paint the Middle.json",
    "editorial_link": "https://codeforces.com//blog/entry/99384",
    "editorial": "Solution For each such that all the elements are different from it is\nimpossible to apply an operation with some indices from the first part,\nand some other from the second one.Then it is possible to split the\narray in subarrays for each such that the previous condition holds, and\nsum the answers from all of them.Let\u00e2\u0080\u0099s solve the problem independently\nfor one of those subarrays, let\u00e2\u0080\u0099s denote its length as , the values of\nits elements as and their colors as :For every tuple such that and it is\npossible to apply an operation with indices and . Then only the first\nand last occurrences of each element are important.For all pairs such\nthat , , is the first occurrence and the last occurrence of that value,\na segment will be created.Let\u00e2\u0080\u0099s denote the left border of a segment as\nand the right border as .Let\u00e2\u0080\u0099s say that a set of segments is connected\nif the union of its segments is the segment .Instead of maximizing , it\nis possible to focus on minimizing .Lemma 1: If we have a connected set\n, it is possible to apply some operations to its induced array to end up\nwith at most elements with . ProofFor each segment in if there exists a\nsegment such that , it is possible to apply the operation with indices\nand with . Otherwise, add this segment to a set .Then is possible to\nrepeatedly select the leftmost segment of that have not been selected\nyet, and set the color of its right border to , this will be always\npossible until we select the rightmost segment since is connected.In the\nend, all the left borders of the segments of will have , the same holds\nfor the right border of the rightmost segment of , which leads to a\ntotal of elements with , and .Let be a subarray that can be obtained by\napplying the given operation to the initial subarray any number of\ntimes.Let be the set of segments that includes all segments such that or\n(or both), where is the color of the -th segment of the subarray .Lemma\n2: There is always an optimal solution in which is connected.\nProofSuppose is not connected, if there are only two components of\nsegments and , there will always be a segment from to due to the way the\nsubarray was formed.If or have some segment such that there exists a\nsegment such that you can erase it by applying the operation with\nindices and with . Then we can assume that and similarly for .The\nsolution to before merging is , the solution to is , if we merge and\nwith a segment we get a component of size , and its answer will be\n(using\nbf{lemma 1}), the case with more than two components is similar, then we\ncan always merge the components without making the answer worse.Finally,\nthe problem in each subarray can be reduced to find the smallest set (in\nnumber of segments), such that the union of its segments is the whole\nsubarray. This can be computed with dp or sweep line. DP solutionLet be\nthe minimum size of a set such that the union of its segments is the\nsegment .To compute , process all the segments in increasing order of ,\nand compute the value of .Then the solution to the subarray is , this\ncan be computed in with segment tree.It is possible to compute a similar\nto solve the problem for the whole array without splitting the array,\nthe time complexity is . Code Sweep line solutionIt is possible to\ncreate an event where a segment starts and an event where a segment\nends. Then process the events in order and each time a segment ends, if\nit is the rightmost segment added, add to the solution the segment with\nmaximum among the segments that is already processed.It is possible to\nmodify the sweep line to solve the problem for the whole array without\nsplitting the array, the time complexity is or depending on the\nimplementation.\n"
}