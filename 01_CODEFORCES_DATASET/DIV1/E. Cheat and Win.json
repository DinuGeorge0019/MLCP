{
    "link": "https://codeforces.com//contest/1439/problem/E",
    "problemId": "798719",
    "problem_idx": "E",
    "shortId": "1439E",
    "contest_number": "1439",
    "problem_submissions": {
        "E": [
            98736027,
            98740513,
            98743267,
            98751627,
            98746552,
            98793931,
            99104638
        ],
        "D": [
            98723891,
            98705229,
            98723612,
            98827591,
            98816648,
            98814032,
            98725036,
            98724071,
            98728933,
            98730831,
            98730544,
            98736469,
            98737101,
            98739698,
            98716903,
            98721633,
            98735777,
            98741204,
            98725990,
            98732940,
            98719637,
            98741795
        ],
        "C": [
            98717653,
            98714961,
            98717583,
            98709251,
            98712683,
            98710256,
            98709014,
            98716952,
            98723694,
            98722478,
            98723203,
            98711303,
            98733440,
            98725610,
            98728037,
            98706473,
            98717733,
            98731377,
            98715466,
            98722420
        ],
        "B": [
            98704771,
            98722470,
            98701689,
            98703648,
            98704924,
            98788376,
            98780895,
            98705172,
            98721750,
            98849262,
            98707321,
            98708231,
            98709710,
            98796719,
            98765489,
            98765480,
            98765433,
            98765408,
            98765370,
            98750864,
            98750749,
            98747376,
            98713010,
            98736680,
            98709620,
            98716637,
            98748644,
            114352814,
            99699811,
            98846560,
            98754739,
            98754712,
            98711616
        ],
        "A2": [
            98692587,
            98708717,
            98890116,
            98695391,
            98695058,
            98694605,
            98697338,
            98695371,
            98698896,
            98697020,
            98700533,
            98695246,
            98692759,
            98703206,
            98695281,
            98699389,
            98696575,
            98695659,
            98722036,
            98693365,
            98696174
        ],
        "A1": [
            98692484,
            98708569,
            98695320,
            98695174,
            98694699,
            98697254,
            98695563,
            98698871,
            98696932,
            98700473,
            98695187,
            98692661,
            98703311,
            98695126,
            98699325,
            98696645,
            98695725,
            98722109,
            98693254,
            98696254
        ]
    },
    "name": "E. Cheat and Win",
    "statement": "Let’s consider a (10^9+1)\r\ntimes (10^9+1) field. The rows are numbered with integers from 0 to 10^9\r\nand the columns are numbered with integers from 0 to 10^9. Let’s define\r\nas (x, y) the cell located in the x-th row and y-th column.Let’s call a\r\ncell (x, y) good if x\r\n& y = 0, there\r\n& is the bitwise and operation.Let’s build a graph where vertices will\r\nbe all good cells of the field and we will make an edge between all\r\npairs of adjacent by side good cells. It can be proved that this graph\r\nwill be a tree connected graph without cycles. Let’s hang this tree on\r\nvertex (0, 0), so we will have a rooted tree with root (0, 0).Two\r\nplayers will play the game. Initially, some good cells are black and\r\nothers are white. Each player on his turn chooses a black good cell and\r\na subset of its ancestors (possibly empty) and inverts their colors\r\n(from white to black and vice versa). The player who can’t move (because\r\nall good cells are white) loses. It can be proved that the game is\r\nalways finite.Initially, all cells are white. You are given m pairs of\r\ncells. For each pair color all cells in a simple path between them as\r\nblack. Note that we do not invert their colors, we paint them\r\nblack.Sohrab and Mashtali are going to play this game. Sohrab is the\r\nfirst player and Mashtali is the second.Mashtali wants to win and\r\ndecided to cheat. He can make the following operation multiple times\r\nbefore the game starts: choose a cell and invert colors of all vertices\r\non the path between it and the root of the tree.Mammad who was watching\r\nthem wondered: \"what is the minimum number of operations Mashtali should\r\ndo to have a winning strategy?\".Find the answer to this question for the\r\ninitial painting of the tree. It can be proved that at least one\r\npossible way to cheat always exists.\r\n",
    "solutions": [
        "#include <bits/extc++.h>\n\nstruct splitmix64_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\t\t// http://xorshift.di.unimi.it/splitmix64.c\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\n\tsize_t operator()(uint64_t x) const {\n\t\tstatic const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n};\n\ntemplate <typename K, typename V, typename Hash = splitmix64_hash>\nusing hash_map = __gnu_pbds::gp_hash_table<K, V, Hash>;\n\ntemplate <typename K, typename Hash = splitmix64_hash>\nusing hash_set = hash_map<K, __gnu_pbds::null_type, Hash>;\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tbool has_root = false;\n\thash_map<int, vector<pair<int, int>>> mp;\n\n\tauto get_jmp = [&](array<int, 2> p) -> pair<bool, array<int, 2>> {\n\t\tassert(!(p[0] & p[1]));\n\t\tif (p[0] == 0 && p[1] == 0) {\n\t\t\treturn {false, {-1,0}};\n\t\t}\n\t\tif (!((p[0]-1) & p[1])) {\n\t\t\t// decrease 0\n\t\t\treturn {false, {p[0] & ~(p[1]-1), p[1]}};\n\t\t} else {\n\t\t\treturn {true, {p[0], p[1] & ~(p[0]-1)}};\n\t\t}\n\t};\n\tauto dep = [&](array<int, 2> p) { return p[0] + p[1]; };\n\n\tint M; cin >> M;\n\twhile (M--) {\n\t\tarray<int, 2> v1, v2; cin >> v1[0] >> v1[1] >> v2[0] >> v2[1];\n\t\twhile (true) {\n\t\t\tif (dep(v1) == 0 && dep(v2) == 0) {\n\t\t\t\thas_root = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tauto [d1, n1] = get_jmp(v1);\n\t\t\tauto [d2, n2] = get_jmp(v2);\n\t\t\tassert(n1[!d1] == v1[!d1]);\n\t\t\tassert(n2[!d2] == v2[!d2]);\n\n\t\t\tif (d1 == d2 && n1 == n2) {\n\t\t\t\t// get the deeper of the two\n\t\t\t\tint x1 = dep(v1), x2 = dep(v2);\n\t\t\t\tif (x1 > x2) swap(x1, x2);\n\t\t\t\tassert(x1 <= x2);\n\t\t\t\tmp[n1[!d1] * 2 + d1].push_back({x1-1, x2});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dep(n1) > dep(n2)) { swap(n1, n2), swap(d1, d2), swap(v1, v2); }\n\t\t\tassert(dep(n1) <= dep(n2));\n\n\t\t\tmp[n2[!d2] * 2 + d2].push_back({dep(n2), dep(v2)});\n\t\t\tv2 = n2;\n\t\t}\n\t}\n\n\thash_map<int, bool> tot_flip;\n\n\tif (has_root) tot_flip[0] ^= 1;\n\tfor (auto& [_, vec] : mp) {\n\t\tsort(vec.begin(), vec.end());\n\t\tint cur_hi = -1;\n\t\tfor (auto it : vec) {\n\t\t\tif (it.first > cur_hi) {\n\t\t\t\tif (cur_hi >= 0) tot_flip[cur_hi] ^= 1;\n\t\t\t\ttot_flip[it.first] ^= 1;\n\t\t\t}\n\t\t\tcur_hi = max(cur_hi, it.second);\n\t\t}\n\t\tif (cur_hi >= 0) {\n\t\t\ttot_flip[cur_hi] ^= 1;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (auto it : tot_flip) {\n\t\tif (it.second) {\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "games",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Cheat and Win.json",
    "editorial_link": "https://codeforces.com//blog/entry/84731",
    "editorial": "First letâs solve the problem on arbitrary trees. Consider the following\r\ngame: on some vertices of the tree we have some tokens. At each step you\r\nremove a token from some vertex and put a token in any subset of its\r\nancestors. The first game can be transformed to this one by putting a\r\ntoken in each black vertex. So now weâll solve the new game.Obviously\r\nthe game is independent for different tokens, so we can use Grundy\r\nnumbers. After working around some examples you can find that the Grundy\r\nnumber for a vertex at height is . it can be easily proved by induction\r\nsince any number less than it can be built by exactly one subset of itâs\r\nancestors.Consider the binary representation of the grundy for the\r\ngame(let it be S). Each cheating move means reversing the bits of a\r\nprefix of S. So the minimum number of operations needed can be shown as\r\nSince each operation decreases this expression at most once, we will\r\nneed at least operations, and there is an obvious way to make equal zero\r\nwith that number of operations.Now to solve the original problem, we\r\nneed to find a compressed tree of the marked vertices and then represent\r\nthe black vertices as union of paths from the root. After this we can\r\nfinally calculate the compressed form of the total Grundy number and\r\nfind the answer. For compressing the tree we need to do some operations,\r\nlike sorting the vertices by starting time(dfs order), finding the LCA\r\nof 2 vertices, etc. in time, where .How to do these? Well they can be\r\ndone with the following observation (the details are left for the reader\r\nbut they can be found in the model solution):For some , consider the\r\ntree on these 3 set of cells: One can see (and can prove) that these 3\r\ntrees are similar; so this gives us some recursive approach.Time\r\ncomplexity: , where .\r\n",
    "hint": []
}