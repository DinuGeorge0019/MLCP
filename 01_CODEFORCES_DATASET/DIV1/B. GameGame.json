{
    "link": "https://codeforces.com//contest/1383/problem/B",
    "problemId": "681328",
    "problem_idx": "B",
    "shortId": "1383B",
    "contest_number": "1383",
    "problem_submissions": {
        "F": [
            87911622,
            87901413,
            87908295,
            87909079,
            87912863,
            87912844,
            87913228,
            87920937
        ],
        "C": [
            87903412,
            87908609,
            87920945,
            87921225,
            87936073,
            87936017,
            87923661,
            87919633,
            87920208,
            87928476,
            88561363,
            87907584
        ],
        "D": [
            87893217,
            87920512,
            87917720,
            87900472,
            88564499,
            87905800,
            87942673,
            87934937,
            87934603,
            87934354,
            87926585,
            87907511,
            87916069,
            87908438,
            87914997,
            87918050,
            87919666,
            87904890,
            87912187,
            87897729,
            87922544,
            87918917
        ],
        "E": [
            87883167,
            87893057,
            87896267,
            87890928,
            88564562,
            87897262,
            87898365,
            87901088,
            87901845,
            87906849,
            87898532,
            87900480,
            87902921,
            87905469,
            87912176,
            87897358,
            87922285,
            87909673,
            87899729,
            87921664
        ],
        "B": [
            87873092,
            87873731,
            87878338,
            87871770,
            88564467,
            87883802,
            87879305,
            87891950,
            87885163,
            87888568,
            87878119,
            87882001,
            87878631,
            87875818,
            87883310,
            87903746,
            87887725,
            87881741,
            87892008,
            87886946
        ],
        "A": [
            87871300,
            87878540,
            87872599,
            87873455,
            88564441,
            87872862,
            87887205,
            87872116,
            87872818,
            87877345,
            87871429,
            87873700,
            87872797,
            87871844,
            87872683,
            87874942,
            87874295,
            87872122,
            87878303,
            87875696
        ]
    },
    "name": "B. GameGame",
    "statement": "Koa the Koala and her best friend want to play a game.The game starts\r\nwith an array a of length n consisting of non-negative integers. Koa and\r\nher best friend move in turns and each have initially a score equal to\r\n0. Koa starts.Let\u2019s describe a move in the game: During his move, a\r\nplayer chooses any element of the array and removes it from this array,\r\nxor-ing it with the current score of the player. More formally: if the\r\ncurrent score of the player is x and the chosen element is y, his new\r\nscore will be x\r\noplus y. Here\r\noplus denotes bitwise XOR operation. Note that after a move element y is\r\nremoved from a. The game ends when the array is empty. At the end of the\r\ngame the winner is the player with the maximum score. If both players\r\nhave the same score then it\u2019s a draw.If both players play optimally find\r\nout whether Koa will win, lose or draw the game.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 24.07.2020 17:42:08       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    int x = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      x ^= a[i];\n    }\n    if (x == 0) {\n      cout << \"DRAW\" << '\\n';\n      continue;\n    }\n    int bit = 30;\n    while (!(x & (1 << bit))) {\n      --bit;\n    }\n    int k0 = 0, k1 = 0;\n    for (int y : a) {\n      if (y & (1 << bit)) {\n        k1 += 1;\n      } else {\n        k0 += 1;\n      }\n    }\n    assert(k1 % 2 == 1);\n    if (k0 % 2 == 0 && k1 % 4 == 3) {\n      cout << \"LOSE\" << '\\n';\n    } else {\n      cout << \"WIN\" << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "games",
        "greedy",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. GameGame.json",
    "editorial_link": "https://codeforces.com//blog/entry/80562",
    "editorial": "Let be the number of ones and be the numbers of zeros in the most\r\nsignificant bit of the numbers: if is even, whatever decision players\r\ntake, both will end with the same score in that bit, so go to the next\r\nbit (if it doesn\u00e2\u0080\u0099t exist the game ends in a draw). Indeed, the parity of\r\nthe result of both players will be the same, since is even. if is odd,\r\none of the players ends with in this bit and the other with , the player\r\nwith in this bit wins the game because the well know inequality for , so\r\nthe game is equivalent to play on an array of ones and zeros. Lemma: The\r\nsecond player wins iff and otherwise the first player wins. Proof: We\r\nknow that so can be or if the first player can choose one and the\r\nremaining number of is a multiple of , if the first player always\r\nrepeats the last move of the second player (if and the second player\r\ntakes the last both players start taking all the remaining ones), then\r\nboth ends with the same number of ones which divided by is even and\r\ntherefore the first player wins. if if the second player can repeat the\r\nlast move of the first player always so the first ends with a even\r\nnumbers of and therefore the second player wins. if the first player\r\ntakes one and the game now is exactly the previous case with the first\r\nplayer as the second player. Time complexity: per testcase\r\n"
}