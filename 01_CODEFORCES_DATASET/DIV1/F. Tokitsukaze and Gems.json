{
    "link": "https://codeforces.com//contest/1677/problem/F",
    "problemId": "1392749",
    "problem_idx": "F",
    "shortId": "1677F",
    "contest_number": "1677",
    "problem_submissions": {
        "F": [
            156410211,
            156340426,
            162899316,
            156353702,
            156350954
        ],
        "E": [
            156331815,
            156318644,
            156328561,
            156331386,
            156331002,
            156328868,
            156325230,
            156336008,
            156334099,
            156333516,
            156333464,
            156335361,
            156328640,
            156340153,
            158284059,
            156378160,
            156338101,
            156328125,
            156340956,
            156337665,
            156338196,
            156339034
        ],
        "D": [
            156316835,
            156323238,
            156317161,
            156315911,
            156316022,
            156316672,
            156329661,
            156318133,
            156323976,
            156324745,
            156322030,
            156324914,
            156333446,
            156322961,
            158284040,
            156321654,
            156336035,
            156319782,
            156328313,
            156324515,
            156324891
        ],
        "C": [
            156310492,
            156302984,
            156308123,
            156302398,
            156308505,
            156310990,
            156308842,
            156308240,
            156309247,
            156311925,
            156314980,
            156306934,
            156313634,
            156303102,
            158284033,
            156312769,
            156312306,
            156311466,
            156313895,
            156319948,
            156317818
        ],
        "B": [
            156306242,
            156299817,
            156302654,
            156307122,
            156303982,
            156308030,
            156305072,
            156302974,
            156301220,
            156307457,
            156305188,
            156303760,
            156307405,
            156307846,
            158284021,
            156307024,
            156302217,
            156306717,
            156309806,
            156308440,
            156312263
        ],
        "A": [
            156296375,
            156295896,
            156296011,
            156296172,
            156296391,
            156299927,
            156298060,
            156296590,
            157632647,
            156296271,
            156296400,
            156299458,
            156296757,
            156297768,
            156296676,
            158284002,
            156297493,
            156296069,
            156297899,
            156296595,
            156298804,
            156300116
        ]
    },
    "name": "F. Tokitsukaze and Gems",
    "statement": "Tokitsukaze has a sequence with length of n. She likes gems very much.\r\nThere are n kinds of gems. The gems of the i-th kind are on the i-th\r\nposition, and there are a_i gems of the same kind on that position.\r\nDefine G(l,r) as the multiset containing all gems on the segment [l,r]\r\n(inclusive).A multiset of gems can be represented as S=[s_1,s_2,\r\nldots,s_n], which is a non-negative integer sequence of length n and\r\nmeans that S contains s_i gems of the i-th kind in the multiset. A\r\nmultiset T=[t_1,t_2,\r\nldots,t_n] is a multisubset of S=[s_1,s_2,\r\nldots,s_n] if and only if t_i\r\nle s_i for any i satisfying 1\r\nle i\r\nle n.Now, given two positive integers k and p, you need to calculate the\r\nresult of\r\nsum_{l=1}^n\r\nsum_{r=l}^n\r\nsum\r\nlimits_{[t_1,t_2,\r\ncdots,t_n]\r\nsubseteq G(l,r)}\r\nleft(\r\nleft(\r\nsum_{i=1}^n p^{t_i}t_i^k\r\nright)\r\nleft(\r\nsum_{i=1}^n[t_i>0]\r\nright)\r\nright),where [t_i>0]=1 if t_i>0 and [t_i>0]=0 if t_i=0.Since the answer\r\ncan be quite large, print it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#define USE_GOOD_MOD\n\n//size of input must be a power of 2\n//output of forward fmt is bit-reversed\n//output elements are in the range [0,mod*4)\n//input of inverse fmt should be bit-reversed\ntemplate<class mint>\nvoid inplace_fmt(const int n,mint*const f,bool inv){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic constexpr int L=30;\n\tstatic mint g[L],ig[L],p2[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tmint w=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\tg[i]=w;\n\t\t\tig[i]=w.inv();\n\t\t\tp2[i]=mint(1<<i).inv();\n\t\t}\n\t}\n\tif(!inv){\n\t\tint b=n;\n\t\tif(b>>=1){//input:[0,mod)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*2)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\twhile(b){\n\t\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tint b=1;\n\t\tif(b<n/2){//input:[0,mod)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t\tb<<=1;\n\t\t}\n\t\tfor(;b<n/2;b<<=1){\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b/2){//input:[0,mod*2)\n\t\t\t\t\tull x=f[j].v+mod2-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j].v=(f[j].v)<mod2?f[j].v:f[j].v-mod2;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\trng(j,i+b/2,i+b){//input:[0,mod)\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b<n){//input:[0,mod*2)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod2-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tmint z=p2[__lg(n)];\n\t\trep(i,n)f[i]*=z;\n\t}\n}\n\ntemplate<class mint>\nvoid inplace_fmt(vector<mint>&f,bool inv){\n\tinplace_fmt(si(f),f.data(),inv);\n}\n\n//size of input must be a power of 2\n//output elements are in the range [0,mod*4)\ntemplate<class mint>\nvoid half_fmt(const int n,mint*const f){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],h[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tg[i]=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\th[i]=mint::root().pow((mod-1)>>(i+2));\n\t\t}\n\t}\n\tint b=n;\n\tint lv=0;\n\tif(b>>=1){//input:[0,mod)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\tif(b>>=1){//input:[0,mod*2)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\twhile(b){\n\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<class mint>\nvoid half_fmt(vector<mint>&f){\n\thalf_fmt(si(f),f.data());\n}\n\n#ifdef USE_GOOD_MOD\n\ntemplate<class mint>\nvc<mint> multiply(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint n=si(x)+si(y)-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tvc<mint> z(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\ntemplate<class mint>\nvc<mint> multiply_givenlength(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint s=si(x);\n\tassert(ispow2(s));\n\tassert(si(y));\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tvc<mint> z(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);\n\treturn x;\n}\n\n#else\n\n//59501818244292734739283969-1=5.95*10^25 までの値を正しく計算\n//最終的な列の大きさが 2^24 までなら動く\n//最終的な列の大きさが 2^20 以下のときは，下の 3 つの素数を使ったほうが速い（は？）\n//VERIFY: yosupo\n//Yukicoder No980 (same=true)\nnamespace arbitrary_convolution{\n\tconstexpr modinfo base0{167772161,3};//2^25 * 5 + 1\n\tconstexpr modinfo base1{469762049,3};//2^26 * 7 + 1\n\tconstexpr modinfo base2{754974721,11};//2^24 * 45 + 1\n\t//extern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\t//extern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\t//extern constexpr modinfo base2{1053818881,7};//2^20 * 1005 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\tusing mint2=modular<base2>;\n\ttemplate<class t,class mint>\n\tvc<t> sub(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tauto d2=sub<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tvc<mint> res(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tres[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn res;\n\t}\n\ttemplate<class t,class mint>\n\tvc<t> sub_givenlength(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint s=si(x);\n\t\tassert(ispow2(s));\n\t\tassert(si(y)==s);\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply_givenlength(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tauto d0=sub_givenlength<mint0>(x,y,same);\n\t\tauto d1=sub_givenlength<mint1>(x,y,same);\n\t\tauto d2=sub_givenlength<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tvc<mint> res(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tres[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn res;\n\t}\n}\nusing arbitrary_convolution::multiply;\nusing arbitrary_convolution::multiply_givenlength;\n\n#endif\n\n//UTPC2021 C\nnamespace integer_convolution{\n\textern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\textern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\ttemplate<class t>\n\tvc<t> sub(const vi&x,const vi&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i];\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i];\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\tvi multiply(const vi&x,const vi&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tconst mint1 r=mint1(mint0::mod).inv();\n\t\tconst ll v=ll(mint0::mod)*mint1::mod;\n\t\tint n=si(d0);\n\t\tvi res(n);\n\t\trep(i,n){\n\t\t\tres[i]=d0[i].v+(r*(d1[i]-d0[i].v)).v*(ull)mint0::mod;\n\t\t\tif(res[i]>v/2)res[i]-=v;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n//Poly というのは常にサイズ 1 以上であることにしよう\n//low のあたりをかならずサイズ s のものを返すようにいじった\n//その影響で何かが起きているかも知れないし，起きていないかも知れない\ntemplate<class mint>\nstruct Poly:public vc<mint>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<mint>(args...){}\n\tPoly(initializer_list<mint>init):vc<mint>(all(init)){}\n\tint size()const{\n\t\treturn vc<mint>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\tassert(s);\n\t\tPoly res(s);\n\t\trep(i,min(s,size()))res[i]=(*this)[i];\n\t\treturn res;\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly operator>>(int x)const{\n\t\tassert(x<size());\n\t\tPoly res(size()-x);\n\t\trep(i,size()-x)res[i]=(*this)[i+x];\n\t\treturn res;\n\t}\n\tPoly operator<<(int x)const{\n\t\tPoly res(size()+x);\n\t\trep(i,size())res[i+x]=(*this)[i];\n\t\treturn res;\n\t}\n\tmint freq(int i)const{\n\t\treturn i<size()?(*this)[i]:0;\n\t}\n\tPoly operator-()const{\n\t\tPoly res=*this;\n\t\tfor(auto&v:res)v=-v;\n\t\treturn res;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator+=(T t){\n\t\t(*this)[0]+=t;\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator-=(T t){\n\t\t(*this)[0]-=t;\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_GOOD_MOD\n\tPoly inv(int s)const{\n\t\tPoly r{mint(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\tr.resize(s);\n\t\treturn r;\n\t}\n\t#else\n\t//source: Section 4 of \"Removing redundancy from high-precision Newton iteration\"\n\t// 5/3\n\tPoly inv(int s)const{\n\t\tPoly r(s);\n\t\tr[0]=mint(1)/(*this)[0];\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tvc<mint> f=low(2*n);\n\t\t\tf.resize(2*n);\n\t\t\tinplace_fmt(f,false);\n\t\t\tvc<mint> g=r.low(2*n);\n\t\t\tg.resize(2*n);\n\t\t\tinplace_fmt(g,false);\n\t\t\trep(i,2*n)f[i]*=g[i];\n\t\t\tinplace_fmt(f,true);\n\t\t\trep(i,n)f[i]=0;\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,2*n)f[i]*=g[i];\n\t\t\tinplace_fmt(f,true);\n\t\t\trng(i,n,min(2*n,s))r[i]=-f[i];\n\t\t}\n\t\treturn r;\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=mint(1)/mint(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1].v);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\ttemplate<class T>\n\tPoly operator+(T t)const{return Poly(*this)+=t;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator-(T t)const{return Poly(*this)-=t;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tassert(size());\n\t\tif(size()==1){\n\t\t\treturn {0};\n\t\t}else{\n\t\t\tPoly r(size()-1);\n\t\t\trep(i,r.size())\n\t\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\t\treturn r;\n\t\t}\n\t}\n\tPoly inte(const mint invs[])const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//VERIFY: yosupo\n\t//opencupXIII GP of Peterhof H\n\tPoly log(int s,const mint invs[])const{\n\t\tassert((*this)[0]==1);\n\t\tif(s==1)return {0};\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte(invs);\n\t}\n\t//Petrozavodsk 2019w mintay1 G\n\t//yosupo judge\n\t//UOJ Round23 C\n\tPoly exp(int s,const mint invs[])const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g.square()*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte(invs))).low(2*n);\n\t\t}\n\t\treturn f.low(s);\n\t}\n\t//exp(x),exp(-x) のペアを返す\n\t//UOJ Round23 C\n\tpair<Poly,Poly> exp2(int s,const mint invs[])const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\t//if(n>=s)break;\n\t\t\tg=g*2-(g.square()*f).low(n);\n\t\t\tif(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte(invs))).low(2*n);\n\t\t}\n\t\treturn make_pair(f.low(s),g.low(s));\n\t}\n\t#ifndef USE_GOOD_MOD\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tstatic const mint half=mint(1)/mint(2);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*half;\n\t\treturn r.low(s);\n\t}\n\t#else\n\t//11/6\n\t//VERIFY: yosupo\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tstatic const mint half=mint(1)/mint(2);\n\t\tvc<mint> f{1},g{1},z{1};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\trep(i,n)z[i]*=z[i];\n\t\t\tinplace_fmt(z,true);\n\t\t\t\n\t\t\tvc<mint> delta(2*n);\n\t\t\trep(i,n)delta[n+i]=z[i]-freq(i)-freq(n+i);\n\t\t\tinplace_fmt(delta,false);\n\t\t\t\n\t\t\tvc<mint> gbuf(2*n);\n\t\t\trep(i,n)gbuf[i]=g[i];\n\t\t\tinplace_fmt(gbuf,false);\n\t\t\t\n\t\t\trep(i,2*n)delta[i]*=gbuf[i];\n\t\t\tinplace_fmt(delta,true);\n\t\t\tf.resize(2*n);\n\t\t\trng(i,n,2*n)f[i]=-half*delta[i];\n\t\t\t\n\t\t\tif(2*n>=s)break;\n\t\t\t\n\t\t\tz=f;\n\t\t\tinplace_fmt(z,false);\n\t\t\t\n\t\t\tvc<mint> eps=gbuf;\n\t\t\trep(i,2*n)eps[i]*=z[i];\n\t\t\tinplace_fmt(eps,true);\n\t\t\t\n\t\t\trep(i,n)eps[i]=0;\n\t\t\tinplace_fmt(eps,false);\n\t\t\t\n\t\t\trep(i,2*n)eps[i]*=gbuf[i];\n\t\t\tinplace_fmt(eps,true);\n\t\t\tg.resize(2*n);\n\t\t\trng(i,n,2*n)g[i]=-eps[i];\n\t\t}\n\t\tf.resize(s);\n\t\treturn f;\n\t}\n\t#endif\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn make_pair(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tint lowzero()const{\n\t\trep(i,size())if((*this)[i]!=0)return i;\n\t\treturn size();\n\t}\n\t//VERIFY: yosupo\n\t//UOJ Round23 C (z=0,p<0)\n\tPoly pow(int s,int p,const mint invs[])const{\n\t\tassert(s>0);\n\t\tint n=size(),z=0;\n\t\tfor(;z<n&&(*this)[z]==0;z++);\n\t\tassert(z==0||p>0);\n\t\tif(z*p>=s)return Poly(s,0);\n\t\tmint c=(*this)[z],cinv=c.inv();\n\t\tmint d=c.pow(p);\n\t\tint t=s-z*p;\n\t\tPoly x(t);\n\t\trng(i,z,min(z+t,n))x[i-z]=(*this)[i]*cinv;\n\t\tx=x.log(t,invs);\n\t\trep(i,t)x[i]*=p;\n\t\tx=x.exp(t,invs);\n\t\trep(i,t)x[i]*=d;\n\t\tPoly y(s);\n\t\trep(i,t)y[z*p+i]=x[i];\n\t\treturn y;\n\t}\n\tmint eval(mint x)const{\n\t\tmint r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n//CF641 F2\n//f*x^(-a)\ntemplate<class mint>\nstruct Laurent{\n\tPoly<mint> f;\n\tint a;\n\tLaurent(const Poly<mint>&num,const Poly<mint>&den,int s){\n\t\ta=den.lowzero();\n\t\tassert(a<si(den));\n\t\tf=(num*(den>>a).inv(s)).low(s);\n\t}\n\tLaurent(const Poly<mint>&ff,int aa):f(ff),a(aa){}\n\tLaurent dif()const{\n\t\treturn Laurent(f*(-a)+(f.dif()<<1),a+1);\n\t}\n\tmint&operator[](int i){\n\t\tassert(inc(0,i+a,si(f)-1));\n\t\treturn f[i+a];\n\t}\n};\n\ntemplate<class mint>\nll m2l(mint a){\n\treturn a.v<mint::mod/2?a.v:ll(a.v)-ll(mint::mod);\n}\n\ntemplate<class mint>\nvoid showpoly(const Poly<mint>&a){\n\tvi tmp(si(a));\n\trep(i,si(a)){\n\t\ttmp[i]=m2l(a[i]);\n\t}\n\tcerr<<tmp<<endl;\n}\n\n//最大で 1<<mx のサイズの fft が登場！\ntemplate<class mint>\nvc<mint> large_convolution(const vc<mint>&a,const vc<mint>&b,int mx){\n\tint n=si(a),m=si(b);\n\tvc<mint> c(n+m-1);\n\tint len=1<<(mx-1);\n\tfor(int i=0;i<n;i+=len){\n\t\tfor(int j=0;j<n;j+=len){\n\t\t\tint x=min(len,n-i),y=min(len,m-j);\n\t\t\tauto d=multiply(vc<mint>(a.bg+i,a.bg+i+x),vc<mint>(b.bg+j,b.bg+j+y));\n\t\t\trep(k,si(d))\n\t\t\t\tc[i+j+k]+=d[k];\n\t\t}\n\t}\n\treturn c;\n}\n\n//source: Tellegen’s Principle into Practice\n\n//Yukicoder No.1145\n//top には，(x-a[i]) の積が入っている(a がサイズ s に拡張されていることに注意)\n//なので例えば (1-a[i]x) の積が欲しい場合は，\n//\tPoly<mint> f=s.top;\n//\tPoly<mint> g(n+1);\n//\trep(i,n+1)g[i]=f[si(f)-1-i];\ntemplate<class mint>\nstruct subproduct_tree{\n\tusing poly=Poly<mint>;\n\tint raws,s,h;\n\tmint*buf;\n\tvc<mint*>f;\n\tvi len;\n\tpoly top;\n\tvoid inner_product(const int n,const mint*a,const mint*b,mint*c){\n\t\trep(i,n)c[i]=a[i]*b[i];\n\t}\n\t//first n elements are fft-ed\n\t//last n elements are raw data mod x^n-1\n\t//the coefficient of x^n is v\n\t//convert the whole array into size-2n fft-ed array\n\tvoid doubling_fmt(const int n,mint*a,const mint v){\n\t\ta[n]-=v*2;\n\t\thalf_fmt(n,a+n);\n\t}\n\tsubproduct_tree(const vc<mint>&a){\n\t\traws=si(a);\n\t\ts=1;while(s<si(a))s*=2;\n\t\th=__lg(s)+1;\n\t\tbuf=new mint[s*h*2];\n\t\tf.resize(s*2);\n\t\tlen.resize(s*2);\n\t\t{\n\t\t\tmint*head=buf;\n\t\t\trng(i,1,s*2){\n\t\t\t\tlen[i]=s>>__lg(i);\n\t\t\t\tf[i]=head;\n\t\t\t\thead+=len[i]*2;\n\t\t\t}\n\t\t}\n\t\trep(i,s){\n\t\t\tmint w=i<si(a)?a[i]:0;\n\t\t\tf[s+i][0]=-w+1;\n\t\t\tf[s+i][1]=-w-1;\n\t\t}\n\t\tif(s==1)f[1][1]=f[1][0];\n\t\tgnr(i,1,s){\n\t\t\tinner_product(len[i],f[i*2],f[i*2+1],f[i]);\n\t\t\tcopy(f[i],f[i]+len[i],f[i]+len[i]);\n\t\t\tinplace_fmt(len[i],f[i]+len[i],true);\n\t\t\tif(i>1)doubling_fmt(len[i],f[i],1);\n\t\t}\n\t\ttop.resize(s+1);\n\t\trep(i,s)top[i]=f[1][s+i];\n\t\ttop[0]-=1;\n\t\ttop[s]=1;\n\t}\n\t~subproduct_tree(){\n\t\tdelete[] buf;\n\t}\n\t//VERIFY: yosupo\n\tvc<mint> multieval(const poly&b){\n\t\tmint*buf2=new mint[s*2];\n\t\tvc<mint*> c(s*2);\n\t\t{\n\t\t\tmint*head=buf2;\n\t\t\trng(i,1,s*2){\n\t\t\t\tif((i&(i-1))==0&&__lg(i)%2==0)head=buf2;\n\t\t\t\tc[i]=head;\n\t\t\t\thead+=len[i];\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tpoly tmp=top.rev().inv(si(b)).rev()*b;\n\t\t\trep(i,s)c[1][i]=i<si(b)?tmp[si(b)-1+i]:0;\n\t\t}\n\t\tvc<mint> tmp(s);\n\t\trng(i,1,s){\n\t\t\tinplace_fmt(len[i],c[i],false);\n\t\t\trep(k,2){\n\t\t\t\ttmp.resize(len[i]);\n\t\t\t\trep(j,len[i])tmp[j]=f[i*2+(k^1)][j]*c[i][j];\n\t\t\t\tinplace_fmt(tmp,true);\n\t\t\t\trep(j,len[i]/2)c[i*2+k][j]=tmp[len[i]/2+j];\n\t\t\t}\n\t\t}\n\t\tvc<mint> ans(raws);\n\t\trep(i,raws)ans[i]=c[s+i][0];\n\t\tdelete[] buf2;\n\t\treturn ans;\n\t}\n\tpoly interpolate(const vc<mint>&val){\n\t\tmint*buf2=new mint[s*2*2];\n\t\tvc<mint*> c(s*2);\n\t\t{\n\t\t\tmint*head=buf2;\n\t\t\trng(i,1,s*2){\n\t\t\t\tif((i&(i-1))==0&&__lg(i)%2==0)head=buf2;\n\t\t\t\tc[i]=head;\n\t\t\t\thead+=len[i]*2;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvc<mint> z=multieval(poly(top.bg+(s-si(val)),top.ed).dif());\n\t\t\trep(i,s){\n\t\t\t\tmint w=i<si(val)?val[i]/z[i]:0;\n\t\t\t\tc[s+i][0]=c[s+i][1]=w;\n\t\t\t}\n\t\t}\n\t\tgnr(i,1,s){\n\t\t\trep(j,len[i])\n\t\t\t\tc[i][j]=c[i*2][j]*f[i*2+1][j]+c[i*2+1][j]*f[i*2][j];\n\t\t\tcopy(c[i],c[i]+len[i],c[i]+len[i]);\n\t\t\tinplace_fmt(len[i],c[i]+len[i],true);\n\t\t\tif(i>1)doubling_fmt(len[i],c[i],0);\n\t\t}\n\t\tpoly res(c[1]+s+(s-si(val)),c[1]+s*2);\n\t\tdelete[] buf2;\n\t\treturn res;\n\t}\n};\n\ntemplate<class mint>\nvc<mint> multieval(const Poly<mint>&f,const vc<mint>&x){\n\treturn subproduct_tree<mint>(x).multieval(f);\n}\n\ntemplate<class mint>\nPoly<mint> interpolate(const vc<mint>&x,const vc<mint>&y){\n\tassert(si(x)==si(y));\n\tif(si(x)==1)return {y[0]};\n\tsubproduct_tree<mint> tree(x);\n\treturn tree.interpolate(y);\n}\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\n#ifdef LOCAL\nconst int vmax=1010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\nmint p2[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n}\n\n//initfact\nmint interpolate(const vc<mint>&a,mint x){\n\tint n=si(a);\n\tif(inc(0,x.v,n-1))return a[x.v];\n\tvc<mint> z(n+1);\n\tz[n]=1;\n\tper(i,n)z[i]=z[i+1]*(x-i);\n\tmint res,w=1;\n\trep(i,n){\n\t\tres+=w*z[i+1]*a[i]*finv[i]*finv[n-1-i]*((n-1-i)%2?-1:1);\n\t\tw*=x-i;\n\t}\n\treturn res;\n}\n\n//VERIFTY:yosupo\n// f は k 次多項式を 0 から k で評価した値が入る\n//sum {0<=i<=n-1} a^i f[i]\n//O(N)\nmint exp_poly_sum(const mint a,const vc<mint>&f,const int n){\n\tif(n==0)return 0;\n\tint k=si(f)-1;\n\tif(a==0){\n\t\treturn f[0];\n\t}else if(a==1){\n\t\tvc<mint> g(k+2);\n\t\trep(i,k+1)g[i+1]=g[i]+f[i];\n\t\treturn interpolate(g,n);\n\t}else{\n\t\tvc<mint> g(k+1);\n\t\t{\n\t\t\tmint r=1;\n\t\t\trep(i,k+1){\n\t\t\t\tg[i]=f[i]*r;\n\t\t\t\tr*=a;\n\t\t\t}\n\t\t}\n\t\tmint c;\n\t\t{\n\t\t\tmint w,r=1;\n\t\t\trep(i,k+1){\n\t\t\t\tw+=choose(k+1,i)*r;\n\t\t\t\tr*=-a;\n\t\t\t\tc+=g[k-i]*w;\n\t\t\t}\n\t\t\tc/=mint(1-a).pow(k+1);\n\t\t}\n\t\trep(i,k)g[i+1]+=g[i];\n\t\tmint ainv=a.inv(),w=1;\n\t\trep(i,k+1){\n\t\t\tg[i]=(g[i]-c)*w;\n\t\t\tw*=ainv;\n\t\t}\n\t\treturn interpolate(g,n-1)*a.pow(n-1)+c;\n\t}\n}\n\n//CF 789 F\n// f は k 次多項式を 0 から k で評価した値が入る\n//sum {0<=i<=n-1} a^i f[i]\n//for all n in xs\n//O(K log^2 K + N log^2 N)\nvc<mint> exp_poly_sum_many(const mint a,const vc<mint>&f,vi xs){\n\tint k=si(f)-1;\n\tif(a==0){\n\t\tassert(false);\n\t}else if(a==1){\n\t\tassert(false);\n\t}else{\n\t\tvc<mint> g(k+1);\n\t\t{\n\t\t\tmint r=1;\n\t\t\trep(i,k+1){\n\t\t\t\tg[i]=f[i]*r;\n\t\t\t\tr*=a;\n\t\t\t}\n\t\t}\n\t\tmint c;\n\t\t{\n\t\t\tmint w,r=1;\n\t\t\trep(i,k+1){\n\t\t\t\tw+=choose(k+1,i)*r;\n\t\t\t\tr*=-a;\n\t\t\t\tc+=g[k-i]*w;\n\t\t\t}\n\t\t\tc/=mint(1-a).pow(k+1);\n\t\t}\n\t\trep(i,k)g[i+1]+=g[i];\n\t\tmint ainv=a.inv(),w=1;\n\t\trep(i,k+1){\n\t\t\tg[i]=(g[i]-c)*w;\n\t\t\tw*=ainv;\n\t\t}\n\t\tvc<mint> tmp(k+1);\n\t\trep(i,k+1)tmp[i]=i;\n\t\tPoly z=interpolate(tmp,g);\n\t\tvc<mint> use(si(xs));\n\t\trep(i,si(xs))use[i]=xs[i]-1;\n\t\tvc<mint> res=multieval(z,use);\n\t\trep(i,si(xs)){\n\t\t\tres[i]=res[i]*a.pow(xs[i]-1)+c;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n//https://codeforces.com/blog/entry/102631?#comment-910422\n//CF 789 F\n// f は k 次多項式の係数列\n//sum {0<=i<=n-1} a^i f(i)\n//for all n in xs\n//O(K log K + N log^2 N)\nvc<mint> exp_poly_sum_many_faster(const mint a,const vc<mint>&f,vi xs){\n\tint k=si(f)-1;\n\tif(a==0){\n\t\tassert(false);\n\t}else if(a==1){\n\t\tassert(false);\n\t}else{\n\t\tPoly<mint> num(k+1);\n\t\trep(i,k+1)num[i]=fact[k-i]*f[k-i];\n\t\tPoly<mint> den(k+1);\n\t\tden[0]=-1;\n\t\trep(i,k+1)den[i]+=finv[i]*a;\n\t\tPoly<mint> w=(num*den.inv(k+1)).low(k+1);\n\t\treverse(all(w));\n\t\trep(i,k+1)w[i]*=finv[i];\n\t\tPoly<mint> res=multieval(w,vc<mint>(all(xs)));\n\t\trep(i,si(res))res[i]=res[i]*a.pow(xs[i])-w[0];\n\t\treturn res;\n\t}\n}\n\nvoid slv(){\n\tint n,k,p;cin>>n>>k>>p;\n\t//vc<mint> f(k+1);\n\t//rep(i,k+1)f[i]=mint(i).pow(k);\n\tvc<mint> f(k+1);f[k]=1;\n\tvi mx=readvi(n);\n\tvi evp(n);\n\trep(i,n)evp[i]=mx[i]+1;\n\t//auto sum=exp_poly_sum_many(p,f,evp);\n\tauto sum=exp_poly_sum_many_faster(p,f,evp);\n\t\n\tmint ans;\n\tmint dp[2][2];\n\t\n\trep(i,n){\n\t\tdp[0][0]+=1;\n\t\tmint nx[2][2];\n\t\t{//add nothing\n\t\t\trep(j,2)rep(q,2)nx[j][q]+=dp[j][q]*(mx[i]+1);\n\t\t}\n\t\t{//add only a\n\t\t\tnx[1][0]+=dp[0][0]*sum[i];\n\t\t\tnx[1][1]+=dp[0][1]*sum[i];\n\t\t}\n\t\t{//add only b\n\t\t\tnx[0][1]+=dp[0][0]*mx[i];\n\t\t\tnx[1][1]+=dp[1][0]*mx[i];\n\t\t}\n\t\t{//add both a and b\n\t\t\tnx[1][1]+=dp[0][0]*sum[i];\n\t\t}\n\t\tswap(dp,nx);\n\t\tans+=dp[1][1];\n\t}\n\t\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Tokitsukaze and Gems.json",
    "editorial_link": "https://codeforces.com//blog/entry/102631",
    "editorial": "TutorialFirst, consider how to calculate the contribution of a legal\r\npath. It can be found that the contribution of a legal path is\r\nequivalent to the following formula, where indicates the number of the\r\n-th gems on the path. This formula seems impossible to calculate, but it\r\ncan be observed that there is a chain structure behind it. Consider\r\ndynamic programming, try to calculate the -th gems’ answer by only\r\nconsidering the -th gems’ answer. Consider maintenance these:It can be\r\nobserved that if we enumerate how many the -th gem are selected, this\r\ncan actually be transferred, for example:Then spread.Now it can be\r\ntransferred. The main problem is how to calculate quickly, ensuring that\r\n.Let represent .Calculate the sum according to the proportional\r\nsequence, . Finally we get According to this recurrence formula, we can\r\nget When is constant, there exist a -degree polynomial about , making .\r\nThis conclusion can be proved by mathematical induction.Consider how to\r\nuse interpolation to get this polynomial, we only need to find .Consider\r\ndifference method, .So . But we still can’t get . There is a conclusion:\r\nthe -th difference of the -degree polynomial is . That is to say, .So we\r\ncan get , then use polynomial fast interpolation, and then polynomial\r\nmultipoint evaluation to get the value of every point we need.It can be\r\nobserved that the DP transfer can be replaced by matrix, so there are\r\nmatrices each position, the problem is equivalent to get the sum of the\r\nmatrix products of all intervals. It’s easy to solve. You can solve it\r\nin the way you like.Overall complexity: .\r\n",
    "hint": []
}