{"link": "https://codeforces.com//contest/1887/problem/C", "problemId": "2278999", "problem_idx": "C", "shortId": "1887C", "contest_number": "1887", "problem_submissions": {"F": [229268085, 229284035, 229267071, 229288213, 229337643, 229337387, 229279061, 229293399, 229278730, 229369273], "E": [229253684, 229249394, 229294341, 229258494, 229338891, 229258700, 229275116, 229278155, 229250811, 229297774, 229297309, 229282242, 229283031, 229282090, 229282378, 229286467, 229267304, 229286116, 229271763, 229270583, 229329580, 229283920], "D": [229234655, 229233555, 229233641, 229232712, 229245990, 229235831, 229244954, 229260058, 229227922, 229264964, 229263601, 229262619, 229264376, 229257713, 229260427, 229286289, 229259421, 229255789, 229242200], "C": [229225852, 229226994, 229224941, 229350172, 229237731, 229225395, 229233603, 229237191, 229279756, 229270695, 229241111, 229246450, 229246617, 229251201, 229242629, 229237936, 229246963, 229224946, 229244776, 229494537, 229293735], "B": [229219341, 229218026, 229215277, 229224722, 229339363, 229339262, 229339141, 229221501, 229217084, 229218884, 229227598, 229211736, 229227850, 229229211, 229230972, 229210296, 229231115, 229228032, 229227594, 229234703, 229369549, 229231109, 229226253], "A2": [229211901, 229206611, 229205624, 229212250, 229211246, 229243386, 229208241, 229214123, 229256240, 229230513, 229220464, 229213039, 229223811, 229217374, 229212405, 229212960, 229215200, 229212576, 229215764, 229211258], "A1": [229207683, 229206848, 229205786, 229207920, 229207504, 229243262, 229206160, 229214648, 229256343, 229206102, 229220609, 229213336, 229217825, 229217804, 229210022, 229205186, 229215529, 229207309, 229215990, 229206166]}, "name": "C. Minimum Array", "statement": "Given an array a of length n consisting of integers. Then the following\r\noperation is sequentially applied to it q times: Choose indices l and r\r\n(1\r\nle l\r\nle r\r\nle n) and an integer x; Add x to all elements of the array a in the\r\nsegment [l, r]. More formally, assign a_i := a_i + x for all l\r\nle i\r\nle r.Let b_j be the array a obtained after applying the first j\r\noperations (0\r\nle j\r\nle q). Note that b_0 is the array a before applying any operations.You\r\nneed to find the lexicographically minimum^{\r\ndagger} array among all arrays b_j.^{\r\ndagger}An array x is lexicographically smaller than array y if there is\r\nan index i such that x_i < y_i, and x_j = y_j for all j < i. In other\r\nwords, for the first index i where the arrays differ, x_i < y_i.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n    int n;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree() : n(0) {}\n    LazySegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    LazySegmentTree(std::vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(std::vector(n_, v_));\n    }\n    template<class T>\n    void init(std::vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << std::__lg(n), Info());\n        tag.assign(4 << std::__lg(n), Tag());\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return;\n        }\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m, r, x, y, v);\n        pull(p);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n    template<class F>\n    int findFirst(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        int res = findFirst(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = findFirst(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findFirst(int l, int r, F pred) {\n        return findFirst(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int findLast(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        int res = findLast(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = findLast(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findLast(int l, int r, F pred) {\n        return findLast(1, 0, n, l, r, pred);\n    }\n};\n\nconstexpr i64 inf = 1E18;\nstruct Tag {\n    i64 add = 0;\n    void apply(const Tag &t) {\n        add += t.add;\n    }\n};\nstruct Info {\n    i64 min = inf;\n    i64 max = -inf;\n    void apply(const Tag &t) {\n        min += t.add;\n        max += t.add;\n    }\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    return {std::min(a.min, b.min), std::max(a.max, b.max)};\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int q;\n    std::cin >> q;\n    \n    std::vector<std::vector<std::pair<int, int>>> add(n);\n    for (int i = 1; i <= q; i++) {\n        int l, r, x;\n        std::cin >> l >> r >> x;\n        l--;\n        add[l].emplace_back(i, x);\n        if (r < n) {\n            add[r].emplace_back(i, -x);\n        }\n    }\n    \n    LazySegmentTree<Info, Tag> seg(q + 1, Info{0, 0});\n    for (int i = 0; i < n; i++) {\n        for (auto [l, x] : add[i]) {\n            seg.rangeApply(l, q + 1, {x});\n        }\n        i64 v = seg.rangeQuery(0, q + 1).min;\n        std::cout << v + a[i] << \" \\n\"[i == n - 1];\n        while (true) {\n            int j = seg.findFirst(0, q + 1,\n                [&](const Info &info) {\n                    return info.max > v;\n                });\n            if (j == -1) {\n                break;\n            }\n            seg.modify(j, {});\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "constructive algorithms", "data structures", "greedy", "hashing", "two pointers"], "dificulty": "2400", "interactive": false}