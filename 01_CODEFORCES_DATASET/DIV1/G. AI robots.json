{"link": "https://codeforces.com//contest/1045/problem/G", "problemId": "223469", "problem_idx": "G", "shortId": "1045G", "contest_number": "1045", "problem_submissions": {"E": [43261410, 43577517], "J": [43258702, 43260133, 43575980, 43263093, 43266033], "A": [43255060, 43256216, 43263322, 43263783, 43258806, 43275613], "D": [43251490, 43264794, 43257475, 43253807, 43257410, 43253327, 43248880], "C": [43250229, 43244156, 43255852, 43252661, 43258515, 43251235, 43259397], "G": [43247867, 43248087, 43251069, 43250948, 43255077, 43249900, 43251360], "H": [43246289, 43252595, 43260022, 43258468, 43261064, 43264435, 43263084], "B": [43243648, 43248788, 43247063, 43264324, 43264189, 43246587, 43256450, 43248333, 43254638], "I": [43243009, 43244706, 43243112, 43242671, 43255452, 43243089, 43243594], "F": [43577952]}, "name": "G. AI robots", "statement": "In the last mission, MDCS has successfully shipped N AI robots to Mars.\r\nBefore they start exploring, system initialization is required so they\r\nare arranged in a line. Every robot can be described with three numbers:\r\nposition (x_i), radius of sight (r_i) and IQ (q_i).Since they are\r\nintelligent robots, some of them will talk if they see each other.\r\nRadius of sight is inclusive, so robot can see other all robots in range\r\n[x_i - r_i, x_i + r_i]. But they don\u2019t walk to talk with anybody, but\r\nonly with robots who have similar IQ. By similar IQ we mean that their\r\nabsolute difference isn\u2019t more than K. Help us and calculate how many\r\npairs of robots are going to talk with each other, so we can timely\r\nupdate their software and avoid any potential quarrel.\r\n", "solutions": ["#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<pair<int, int>,\n\t\tnull_type,\n\t\tless<>,\n\t\trb_tree_tag,\n\t\ttree_order_statistics_node_update>\n\t\tmset;\n\n//find_by_order(k);\n//order_of_key(x);\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nint n, k;\n\nvector<tuple<ll, ll, ll>> vv;\n\nmap<int, mset> mm;\nvector<int> dl[120000];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; ++i) {\n\t\tll x, r, q;\n\t\tcin >> x >> r >> q;\n\t\tvv.emplace_back(x, r, q);\n\t}\n\tsort(vv.begin(), vv.end());\n\tll ans = 0;\n\tfor (int i = 0; i < vv.size(); ++i) {\n\t\tint x, r, q;\n\t\ttie(x, r, q) = vv[i];\n\t\tfor (int a: dl[i]) {\n\t\t\tint x, r, q;\n\t\t\ttie(x, r, q) = vv[a];\n\t\t\tmm[q].erase({x, a});\n\t\t}\n\t\tint go = lower_bound(ALL(vv), make_tuple(x + r + 1, 0, 0)) - vv.begin();\n\t\tdl[go].push_back(i);\n\t\tauto it = mm.lower_bound(q - k);\n\t\twhile (it != mm.end() && it->first <= q + k) {\n\t\t\tauto it2 = it->second.lower_bound(make_pair(x - r, 0));\n\t\t\tif (it2 != it->second.end())\n\t\t\t\tans += it->second.size() - it->second.order_of_key(*it2);\n\t\t\t++it;\n\t\t}\n\t\tmm[q].insert({x, i});\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2200", "interactive": false}