{"link": "https://codeforces.com//contest/739/problem/B", "problemId": "81533", "problem_idx": "B", "shortId": "739B", "contest_number": "739", "problem_submissions": {"C": [22442698, 22439403, 22439035, 22441010, 22452684, 22437700, 22438882, 22439230, 22438925, 22440648, 22439930, 22440447, 22440445, 22442265, 22442505, 22443020, 22443464, 22471543], "A": [22439350, 22427880, 22428059, 22427929, 22427879, 22427835, 22427894, 22569748, 22427875, 22427910, 22428905, 22428165, 22427839, 22428416, 22427876, 22427815, 22428207, 22427895, 22461370, 22461352, 22428531], "B": [22438821, 22430420, 22433537, 22432542, 22430611, 22432279, 22431221, 22432719, 22432020, 22433235, 22432524, 22433360, 22434177, 22433963, 22430137, 22435255, 22433707, 22459456, 22459424, 22459398, 22442832], "E": [22435846, 23367614, 23367585, 23236778, 22443543, 31723439, 22934699, 22934399, 22516029, 22515992, 22463839, 22463413, 22443763, 22446956, 22453608, 22445886, 22461332, 22692840, 22455977, 22471655, 22471636, 22461535, 22447302], "D": [22462793, 22462750, 22462690, 22450389, 22469047, 22498066]}, "name": "B. Alyona and a tree", "statement": "Alyona has a tree with vertices. The root of the tree is the vertex . In\r\neach vertex Alyona wrote an positive integer, in the vertex she wrote .\r\nMoreover, the girl wrote a positive integer to every edge of the tree\r\n(possibly, different integers on different edges).Let\u2019s define as the\r\nsum of the integers written on the edges of the simple path from to .The\r\nvertex controls the vertex () if and only if is in the subtree of and\r\n.Alyona wants to settle in some vertex. In order to do this, she wants\r\nto know for each vertex what is the number of vertices such that\r\ncontrols .\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=201000;\nint n,a[N],p,w,sta[N],fg[N];\nvector<PII> s[N];\nll dis[N];\nvoid dfs(int u,ll d,int f) {\n\tsta[f]=u; dis[f]=d;\n\tint l=lower_bound(dis,dis+f+1,d-a[u])-dis-1;\n\tfg[sta[l]]--; fg[u]++;\n\tfor (auto v:s[u]) {\n\t\tdfs(v.fi,d+v.se,f+1);\n\t\tfg[u]+=fg[v.fi];\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",a+i);\n\trep(i,2,n+1) {\n\t\tscanf(\"%d%d\",&p,&w);\n\t\ts[p].pb(mp(i,w));\n\t}\n\tdis[0]=-1ll<<60;\n\tdfs(1,0,1);\n\trep(i,1,n+1) printf(\"%d \",fg[i]-1);\n\tputs(\"\");\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "dfs and similar", "graphs", "trees"], "dificulty": "1900", "interactive": false}