{
    "link": "https://codeforces.com//contest/1628/problem/D2",
    "problemId": "1270546",
    "problem_idx": "D2",
    "shortId": "1628D2",
    "contest_number": "1628",
    "problem_submissions": {
        "F": [
            143704137,
            143703628,
            143702221,
            143703556,
            147001965
        ],
        "E": [
            143675713,
            143683767,
            143678064,
            143684015,
            143703839,
            143703586,
            143684851,
            143683465,
            143685498,
            143691038,
            143689260,
            143676465,
            143693250,
            143684297,
            143687706,
            143698977,
            143697149,
            143693737,
            143726859,
            143698932,
            143695817,
            143695968
        ],
        "D2": [
            143658634,
            143670285,
            143666637,
            143665499,
            143666995,
            143667409,
            143672399,
            143672413,
            143661151,
            143647661,
            143658816,
            143673791,
            143659789,
            143650476,
            143675004,
            143660718,
            143676678,
            143684084,
            143660907
        ],
        "D1": [
            143652051,
            143661015,
            143649637,
            143665355,
            143640835,
            143647447,
            143672291,
            143669534,
            143658393,
            143632054,
            143652557,
            143673638,
            143659662,
            143650805,
            143669620,
            143647751,
            143667415,
            143668369,
            143654580
        ],
        "C": [
            143648600,
            143653504,
            143662609,
            143671130,
            143659087,
            143671994,
            143662240,
            143665901,
            143679854,
            143654744,
            143666734,
            143658744,
            143650933,
            143640762,
            143660335,
            143673771,
            143662259,
            143663580,
            143684690
        ],
        "B": [
            143641041,
            143647996,
            143687560,
            143645776,
            143664691,
            143661275,
            143640613,
            143649322,
            143664737,
            143644329,
            143690738,
            143695054,
            143657006,
            143653454,
            143666253,
            143657114,
            143649062,
            143668019
        ],
        "A": [
            143633679,
            143636764,
            143632428,
            143638866,
            143635799,
            143637277,
            143632341,
            143633434,
            143635604,
            143658928,
            143634190,
            143633884,
            143633848,
            143634819,
            143640442,
            143650623,
            143643930,
            143639364,
            143636998
        ]
    },
    "name": "D2. Game on Sum  Hard Version ",
    "statement": "Alice and Bob are given the numbers n, m and k, and play a game as\r\nfollows:The game has a score that Alice tries to maximize, and Bob tries\r\nto minimize. The score is initially 0. The game consists of n turns.\r\nEach turn, Alice picks a number from 0 to k (inclusive) which Bob either\r\nadds to or subtracts from the score of the game. But throughout the\r\ngame, Bob has to choose to add at least m out of the n turns.Bob gets to\r\nknow which number Alice picked before deciding whether to add or\r\nsubtract the number from the score, and Alice gets to know whether Bob\r\nadded or subtracted the number for the previous turn before picking the\r\nnumber for the current turn (except on the first turn since there was no\r\nprevious turn).If Alice and Bob play optimally, what will the final\r\nscore of the game be?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 22.01.2022 17:58:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    Mint k;\n    cin >> n >> m >> k;\n    if (m == 0) {\n      cout << 0 << '\\n';\n      continue;\n    }\n    m -= 1;\n    Mint ans = C(n, m) * 2;\n    for (int i = 1; i <= m; i++) {\n      ans += (i + 3) * power(Mint(2), i - 1) * C(n - i, m - i);\n    }\n    cout << ans / power(Mint(2), n) * k << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "games",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D2. Game on Sum  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/99276",
    "editorial": "We have base cases And transition Check the explanation for the easy\r\nversion to see why.This can be optimized by looking at contributions\r\nfrom the base cases.If we draw the states on a grid and ignore the\r\ndivision by in the transition, we can see that the number of times\r\nstates contributes to state is the number of paths from to in the grid\r\nsuch that at each step, both and increase, or only increases, except we\r\nhave to exclude paths that go through other base cases. The number of\r\nsuch paths is . Since the number of steps in all of these paths is the\r\nsame, we can account for the division by in each transition by dividing\r\nby in the end.To find the value of we sum the contribution form every\r\nbase case for .\r\n",
    "hint": []
}