{"link": "https://codeforces.com//contest/1827/problem/D", "problemId": "1922413", "problem_idx": "D", "shortId": "1827D", "contest_number": "1827", "problem_submissions": {"B1": [205909125, 205871229, 205860094, 205853484, 205858214, 205884799, 205855785, 205857268, 205859721, 205854125, 205853990, 205854393, 205857685, 205856108, 205871852, 205864517, 205849753, 205856355, 206036248, 205883111, 205857458, 205852308], "C": [205887704, 205865086, 205862189, 205877784, 205865401, 205880693, 205873972, 205883370, 205896807, 205874900, 205883582, 205869590, 205872529, 205865317, 205875560, 205870203, 205870915, 206036332, 205857923, 205878002, 205869836], "E": [205882857, 205890682, 205893722, 205893207, 205891321, 205895989, 205901490, 205897572, 205894529, 205889627, 205900528, 205921803, 205921497, 205921364, 205921183, 205920554, 205920187, 205928602, 205907318, 205907019, 205906136, 205905793, 205905368, 205905221, 205903986], "B2": [205871376, 205860123, 205854465, 205857731, 205884857, 205854446, 205857708, 205859949, 205855049, 205892922, 205864074, 205856597, 205855367, 205871926, 205864651, 205863717, 205856284, 206036255, 205889062, 205869038, 205876542], "D": [205863885, 205875931, 205878262, 205884073, 205878863, 205877520, 205881913, 205884050, 205871773, 205899731, 205892557, 205885814, 205881313, 205883473, 205884864, 205888365, 205888201, 206036361, 205877449, 205886393, 205963414, 205889611], "A": [205845172, 205844037, 205843466, 205843847, 205844462, 205843511, 205844799, 205845695, 205844273, 205843867, 205845548, 205843654, 205843208, 205846139, 205845358, 205843530, 206036234, 205846931, 205848794, 205843958], "F": [207299235, 207299224, 207299166, 207299023, 207298779, 207298502, 207298128]}, "name": "D. Two Centroids", "statement": "You are given a tree (an undirected connected acyclic graph) which\r\ninitially only contains vertex 1. There will be several queries to the\r\ngiven tree. In the i-th query, vertex i + 1 will appear and be connected\r\nto vertex p_i (1\r\nle p_i\r\nle i). After each query, please find out the least number of operations\r\nrequired to make the current tree has centroids. In one operation, you\r\ncan add vertex and edge to the tree such that it remains a tree.A vertex\r\nis called a centroid if its removal splits the tree into subtrees with\r\nat most\r\nlfloor\r\nfrac{n}{2}\r\nrfloor vertices each, with n as the number of vertices of the tree. For\r\nexample, the centroid of the following tree is 3 because the biggest\r\nsubtree after removing the centroid has 2 vertices. In the next tree,\r\nvertex 1 and 2 are both centroids.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nconstexpr int bsf_constexpr(unsigned int n) {\n    int x = 0;\n    while (!(n & (1 << x))) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) const {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) const {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() const { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) const {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) const {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) const {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) const {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nnamespace ecnerwala {\n\nusing std::swap;\n\nstruct level_ancestor {\n\tint N;\n\tstd::vector<int> preorder;\n\tstd::vector<int> idx;\n\tstd::vector<std::pair<int, int>> heavyPar; // heavy parent, distance\n\tlevel_ancestor() : N(0) {}\n\n\tlevel_ancestor(const std::vector<int>& par) : N(int(par.size())), preorder(N), idx(N), heavyPar(N) {\n\t\tstd::vector<std::vector<int>> ch(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (par[i] != -1) ch[par[i]].push_back(i);\n\t\t}\n\t\tstd::vector<int> sz(N);\n\t\tint nxt_idx = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (par[i] == -1) {\n\t\t\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\t\t\tsz[cur] = 1;\n\t\t\t\t\tfor (int nxt : ch[cur]) {\n\t\t\t\t\t\tself(nxt);\n\t\t\t\t\t\tsz[cur] += sz[nxt];\n\t\t\t\t\t}\n\t\t\t\t\tif (!ch[cur].empty()) {\n\t\t\t\t\t\tauto mit = max_element(ch[cur].begin(), ch[cur].end(), [&](int a, int b) { return sz[a] < sz[b]; });\n\t\t\t\t\t\tswap(*ch[cur].begin(), *mit);\n\t\t\t\t\t}\n\t\t\t\t})(i);\n\t\t\t\tstd::y_combinator([&](auto self, int cur, int isRoot = true) -> void {\n\t\t\t\t\tpreorder[idx[cur] = nxt_idx++] = cur;\n\t\t\t\t\tif (isRoot) {\n\t\t\t\t\t\theavyPar[idx[cur]] = {par[cur] == -1 ? -1 : idx[par[cur]], 1};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(idx[par[cur]] == idx[cur]-1);\n\t\t\t\t\t\theavyPar[idx[cur]] = heavyPar[idx[cur]-1];\n\t\t\t\t\t\theavyPar[idx[cur]].second++;\n\t\t\t\t\t}\n\t\t\t\t\tbool chRoot = false;\n\t\t\t\t\tfor (int nxt : ch[cur]) {\n\t\t\t\t\t\tself(nxt, chRoot);\n\t\t\t\t\t\tchRoot = true;\n\t\t\t\t\t}\n\t\t\t\t})(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint get_ancestor(int a, int k) const {\n\t\tassert(k >= 0);\n\t\ta = idx[a];\n\t\twhile (a != -1 && k) {\n\t\t\tif (k >= heavyPar[a].second) {\n\t\t\t\tk -= heavyPar[a].second;\n\t\t\t\tassert(heavyPar[a].first <= a - heavyPar[a].second);\n\t\t\t\ta = heavyPar[a].first;\n\t\t\t} else {\n\t\t\t\ta -= k;\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t\tif (a == -1) return -1;\n\t\telse return preorder[a];\n\t}\n\n\tint lca(int a, int b) const {\n\t\ta = idx[a], b = idx[b];\n\t\twhile (true) {\n\t\t\tif (a > b) swap(a, b);\n\t\t\tassert(a <= b);\n\t\t\tif (a > b - heavyPar[b].second) {\n\t\t\t\treturn preorder[a];\n\t\t\t}\n\t\t\tb = heavyPar[b].first;\n\t\t\tif (b == -1) return -1;\n\t\t}\n\t}\n\n\tint dist(int a, int b) const {\n\t\ta = idx[a], b = idx[b];\n\t\tint res = 0;\n\t\twhile (true) {\n\t\t\tif (a > b) swap(a, b);\n\t\t\tassert(a <= b);\n\t\t\tif (a > b - heavyPar[b].second) {\n\t\t\t\tres += b - a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres += heavyPar[b].second;\n\t\t\tb = heavyPar[b].first;\n\t\t\tif (b == -1) return -1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n} // namespace ecnerwala\n\nint op(int a, int b){\n\treturn a + b;\n}\nint e(){\n\treturn 0;\n}\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<int> p(N);\n\tvector<vector<int> > ch(N);\n\tfor(int i = 1; i < N; i++){\n\t\tcin >> p[i];\n\t\tp[i]--;\n\t\tch[p[i]].push_back(i);\n\t}\n\tp[0] = -1;\n\tauto la = ecnerwala::level_ancestor(p);\t\n\tvector<int> st(N), en(N);\n\tint T = 0;\n\ty_combinator(\n\t\t[&](auto self, int v) -> void {\n\t\t\tst[v] = T;\n\t\t\tT++;\n\t\t\tfor(int w : ch[v]) self(w);\n\t\t\ten[v] = T;\n\t\t}\n\t)(0);\n\tatcoder::segtree<int, op, e> seg(N);\n\tint cur = 1;\n\tauto score = [&](int v, int sz) -> int {\n\t\tint d = seg.prod(st[v], en[v]);\n\t\treturn abs(d - (sz - d));\n\t};\n\tfor(int i = 1; i < N; i++){\n\t\tint x = i;\n\t\tseg.set(st[i], seg.get(st[i]) + 1);\n\t\twhile(true){\n\t\t\tint L = la.lca(cur, x);\n\t\t\tint cand = cur;\n\t\t\tif(L == cur && cur != x){\n\t\t\t\tcand = la.get_ancestor(x, la.dist(cur, x) - 1);\n\t\t\t} else if(L == p[cur] && x != p[cur]){\n\t\t\t\tcand = la.get_ancestor(x, la.dist(p[cur], x) - 1);\n\t\t\t} else {\n\t\t\t\tcand = p[cur];\n\t\t\t}\n\t\t\tif(score(cand, i + 1) < score(cur, i + 1)){\n\t\t\t\tcur = cand;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans = score(cur, i + 1);\n\t\tcout << ans << \" \\n\"[i == N-1];\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "greedy", "trees"], "dificulty": "2800", "interactive": false}