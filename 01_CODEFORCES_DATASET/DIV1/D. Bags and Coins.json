{"link": "https://codeforces.com//contest/356/problem/D", "problemId": "3679", "problem_idx": "D", "shortId": "356D", "contest_number": "356", "problem_submissions": {"D": [4794974, 4796940, 4801750, 4797879, 4794633, 4794914, 4800192, 4799081, 4798608, 4796033, 4796373, 5586844, 4848850, 4848737], "C": [4792387, 4791833, 4794313, 4794230, 4792849, 4796109, 4790890, 4794074, 4792572, 4798707, 4793084, 4793173, 4792457, 4794510, 4793687, 4793583], "A": [4790471, 4798737, 4789838, 4789461, 4789429, 4789788, 4789491, 4792712, 4789440, 4789650, 4790200, 4790207, 4789553, 4789481, 4790643, 4790114, 4791900, 4790345], "B": [4789769, 4790832, 4793129, 4799391, 4791122, 4791172, 4791264, 4792100, 4790127, 4791066, 4791524, 4791678, 4791801, 4791270, 4793238, 4792003, 4791083, 4792077], "E": [4808374, 4805352]}, "name": "D. Bags and Coins", "statement": "When you were a child you must have been told a puzzle of bags and\r\ncoins. Anyway, here\u2019s one of its versions: The answer is quite simple.\r\nThe third bag contains a coin and two other bags. This problem is a\r\ngeneralization of the childhood puzzle. You have bags. You know that the\r\nfirst bag contains coins, the second bag contains coins, ..., the -th\r\nbag contains coins. In total, there are coins. Find the way to arrange\r\nthe bags and coins so that they match the described scenario or else\r\nstate that it is impossible to do.\r\n", "solutions": ["#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 4 * 77777;\n\nunsigned int one = 1;\nunsigned int f[N], nf[N];\npair <int, int> a[N];\nint last[N], inside[N], A[N];\nbool used[N];\n\nint main() {\n  int n, s;\n  scanf(\"%d %d\", &n, &s);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i].first);\n    A[i] = a[i].first;\n    a[i].second = i;\n  }\n  sort(a, a + n);\n  reverse(a, a + n);\n  if (a[0].first > s) {\n    printf(\"%d\\n\", -1);\n    return 0;\n  }\n  s -= a[0].first;\n  int nn = (s >> 5) + 1;\n  for (int i = 0; i < nn; i++) f[i] = 0;\n  for (int i = 0; i <= s; i++) last[i] = -1;\n  last[0] = 0;\n  f[0] |= (one << 0);\n  for (int q = 1; q < n; q++) {\n    int w = a[q].first;\n    for (int i = 0; i < nn; i++) nf[i] = 0;\n    int els = (w >> 5);\n    int shift = (w & 31);\n    for (int i = 0; i < nn; i++) {\n      int j = i + els;\n      if (j < nn) {\n        nf[j] |= (f[i] << shift);\n        if (j + 1 < nn && shift != 0) {\n          nf[j + 1] |= (f[i] >> (32 - shift));\n        }\n      }\n      else break;\n    }\n    for (int i = 0; i < nn; i++)\n      if ((f[i] | nf[i]) != f[i]) {\n        for (int j = 0; j < 32; j++)\n          if (nf[i] & (one << j)) {\n            if (!(f[i] & (one << j))) {\n              int id = (i << 5) + j;\n              last[id] = q;\n            }\n          }\n        f[i] |= nf[i];\n      }\n  }\n  if (last[s] == -1) {\n    printf(\"%d\\n\", -1);\n    return 0;\n  }\n  for (int i = 1; i < n; i++) used[i] = false;\n  while (s > 0) {\n    used[last[s]] = true;\n    s -= a[last[s]].first;\n  }\n  for (int i = 0; i < n; i++) inside[i] = -1;\n  int prev = 0;\n  for (int i = 1; i < n; i++) {\n    if (!used[i]) {\n      inside[a[prev].second] = a[i].second;\n      prev = i;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (inside[i] == -1) {\n      printf(\"%d 0\\n\", A[i]);\n    } else {\n      printf(\"%d 1 %d\\n\", A[i] - A[inside[i]], inside[i] + 1);\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "dp", "greedy"], "dificulty": "2700", "interactive": false}