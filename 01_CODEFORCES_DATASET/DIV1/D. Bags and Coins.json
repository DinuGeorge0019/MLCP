{
    "link": "https://codeforces.com//contest/356/problem/D",
    "problemId": "3679",
    "problem_idx": "D",
    "shortId": "356D",
    "contest_number": "356",
    "problem_submissions": {
        "D": [
            4794974,
            4796940,
            4801750,
            4797879,
            4794633,
            4794914,
            4800192,
            4799081,
            4798608,
            4796033,
            4796373,
            5586844,
            4848850,
            4848737
        ],
        "C": [
            4792387,
            4791833,
            4794313,
            4794230,
            4792849,
            4796109,
            4790890,
            4794074,
            4792572,
            4798707,
            4793084,
            4793173,
            4792457,
            4794510,
            4793687,
            4793583
        ],
        "A": [
            4790471,
            4798737,
            4789838,
            4789461,
            4789429,
            4789788,
            4789491,
            4792712,
            4789440,
            4789650,
            4790200,
            4790207,
            4789553,
            4789481,
            4790643,
            4790114,
            4791900,
            4790345
        ],
        "B": [
            4789769,
            4790832,
            4793129,
            4799391,
            4791122,
            4791172,
            4791264,
            4792100,
            4790127,
            4791066,
            4791524,
            4791678,
            4791801,
            4791270,
            4793238,
            4792003,
            4791083,
            4792077
        ],
        "E": [
            4808374,
            4805352
        ]
    },
    "name": "D. Bags and Coins",
    "statement": "When you were a child you must have been told a puzzle of bags and\r\ncoins. Anyway, here\u2019s one of its versions: The answer is quite simple.\r\nThe third bag contains a coin and two other bags. This problem is a\r\ngeneralization of the childhood puzzle. You have bags. You know that the\r\nfirst bag contains coins, the second bag contains coins, ..., the -th\r\nbag contains coins. In total, there are coins. Find the way to arrange\r\nthe bags and coins so that they match the described scenario or else\r\nstate that it is impossible to do.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 4 * 77777;\n\nunsigned int one = 1;\nunsigned int f[N], nf[N];\npair <int, int> a[N];\nint last[N], inside[N], A[N];\nbool used[N];\n\nint main() {\n  int n, s;\n  scanf(\"%d %d\", &n, &s);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i].first);\n    A[i] = a[i].first;\n    a[i].second = i;\n  }\n  sort(a, a + n);\n  reverse(a, a + n);\n  if (a[0].first > s) {\n    printf(\"%d\\n\", -1);\n    return 0;\n  }\n  s -= a[0].first;\n  int nn = (s >> 5) + 1;\n  for (int i = 0; i < nn; i++) f[i] = 0;\n  for (int i = 0; i <= s; i++) last[i] = -1;\n  last[0] = 0;\n  f[0] |= (one << 0);\n  for (int q = 1; q < n; q++) {\n    int w = a[q].first;\n    for (int i = 0; i < nn; i++) nf[i] = 0;\n    int els = (w >> 5);\n    int shift = (w & 31);\n    for (int i = 0; i < nn; i++) {\n      int j = i + els;\n      if (j < nn) {\n        nf[j] |= (f[i] << shift);\n        if (j + 1 < nn && shift != 0) {\n          nf[j + 1] |= (f[i] >> (32 - shift));\n        }\n      }\n      else break;\n    }\n    for (int i = 0; i < nn; i++)\n      if ((f[i] | nf[i]) != f[i]) {\n        for (int j = 0; j < 32; j++)\n          if (nf[i] & (one << j)) {\n            if (!(f[i] & (one << j))) {\n              int id = (i << 5) + j;\n              last[id] = q;\n            }\n          }\n        f[i] |= nf[i];\n      }\n  }\n  if (last[s] == -1) {\n    printf(\"%d\\n\", -1);\n    return 0;\n  }\n  for (int i = 1; i < n; i++) used[i] = false;\n  while (s > 0) {\n    used[last[s]] = true;\n    s -= a[last[s]].first;\n  }\n  for (int i = 0; i < n; i++) inside[i] = -1;\n  int prev = 0;\n  for (int i = 1; i < n; i++) {\n    if (!used[i]) {\n      inside[a[prev].second] = a[i].second;\n      prev = i;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (inside[i] == -1) {\n      printf(\"%d 0\\n\", A[i]);\n    } else {\n      printf(\"%d 1 %d\\n\", A[i] - A[inside[i]], inside[i] + 1);\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Bags and Coins.json",
    "editorial_link": "https://codeforces.com/blog/entry/9210",
    "editorial": "It\u00e2\u0080\u0099s easy to see that bags and their relations \"lies directly in\" should\r\nform directed forest. Each vertex should be given value the number of\r\ncoins in the corresponding bag. Let\u00e2\u0080\u0099s denote the sum of values in the\r\nsubtree of vertex as . The following conditions should be met: It\u00e2\u0080\u0099s\r\nclear that one of the bags with largest must be the root of some tree.\r\nIt\u00e2\u0080\u0099s quite easy to see that the solution exists if and only if there\r\nexists a subset such that and this subset contains at least one bag with\r\nthe largest . It\u00e2\u0080\u0099s obvious that it is necessary condition, the\r\nsufficiency is also easy to see: let\u00e2\u0080\u0099s suppose we have such subset. Then\r\nall bags from the subset, except one of the largest, will be roots of\r\nthe signle-vertex trees (i.e. for them). All bags that are not in the\r\nsubset we will consequentially put into the largest bag, forming the\r\n\"russian doll\" (this tree will be directed chain). So, we reduced the\r\ntask to the well-known subset-sum problem: from the items find the\r\nsubset with the given sum . This problem is NP-Complete, and with these\r\nconstraints is solved in a following way: let if it is possible to\r\nobtain sum using some of the first items, and otherwise. Then . The -th\r\nrow of this table depends only on the previous row, so we don\u00e2\u0080\u0099t have to\r\nstore the whole table in memory. Also we should use the fact that the\r\nvalues of the table are zeroes and ones, and we can use bit compression\r\nand store each row in an array of int\u00e2\u0080\u0099s of size . To get the -th row, we\r\nshould calculate the bitwise OR of the previous row and the previous row\r\nshifted to the left by positions. That is, we can find out whether it\r\npossible to obtain the sum in approximately operations. To find the\r\nactual way to obtain , we need to use the following trick: for every\r\npossible sum we will remember the value the number of such item that\r\nafter considering this item it became possible to obtain . This allows\r\nus to restore the solution.\r\n"
}