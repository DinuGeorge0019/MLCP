{"link": "https://codeforces.com//contest/1314/problem/F", "problemId": "547041", "problem_idx": "F", "shortId": "1314F", "contest_number": "1314", "problem_submissions": {"F": [71726158, 71718843, 74749593, 74749152, 72292726, 72292697, 72292343, 72291510, 71844196, 71723876, 71715422], "B": [71718479, 71829904, 71711385, 71709524, 71707913, 71711558, 71720310, 71713846, 71720222, 71715032, 71716531, 71717545, 71717755, 71716805, 71725696, 71868147], "D": [71714124, 71712892, 71733906, 71707801, 71745171, 71710988, 71712453, 71713369, 71709321, 71710231, 71720852, 71726797, 71713255, 71704334, 71710718, 71710921, 71711996, 71765821, 71712181, 71712148, 71712872, 71716965, 71711644], "C": [71711319, 71864827, 71714264, 71722928, 71716523, 71714295, 71721162, 71720891, 71720482, 71720726, 71723585, 71724431, 71726919, 71725565, 71714331], "A": [71703192, 71704610, 71703253, 71706188, 71703791, 71704145, 71707166, 71705278, 71704520, 71703175, 71715214, 71703215, 71703413, 71707725, 71704018, 71704745, 71703715, 71704666, 71704097], "E": [71722513, 71724911, 71718902, 71725474, 71727007, 71717687, 71725550, 71726599, 71726820, 71859582, 71935297, 71720287, 71723370]}, "name": "F. Bad Cryptography", "statement": "In modern cryptography much is tied to the algorithmic complexity of\r\nsolving several problems. One of such problems is a discrete logarithm\r\nproblem. It is formulated as follows: Let\u2019s fix a finite field and two\r\nit\u2019s elements a and b. One need to fun such x that a^x = b or detect\r\nthere is no such x. It is most likely that modern mankind cannot solve\r\nthe problem of discrete logarithm for a sufficiently large field size.\r\nFor example, for a field of residues modulo prime number, primes of 1024\r\nor 2048 bits are considered to be safe. However, calculations with such\r\nlarge numbers can place a significant load on servers that perform\r\ncryptographic operations. For this reason, instead of a simple module\r\nresidue field, more complex fields are often used. For such field no\r\nfast algorithms that use a field structure are known, smaller fields can\r\nbe used and operations can be properly optimized. Developer Nikolai does\r\nnot trust the generally accepted methods, so he wants to invent his own.\r\nRecently, he read about a very strange field nimbers, and thinks it\u2019s a\r\ngreat fit for the purpose. The field of nimbers is defined on a set of\r\nintegers from 0 to 2^{2^k} - 1 for some positive integer k . Bitwise\r\nexclusive or (\r\noplus) operation is used as addition. One of ways to define\r\nmultiplication operation (\r\nodot) is following properties: 0\r\nodot a = a\r\nodot 0 = 0 1\r\nodot a = a\r\nodot 1 = a a\r\nodot b = b\r\nodot a a\r\nodot (b\r\nodot c)= (a\r\nodot b)\r\nodot c a\r\nodot (b\r\noplus c) = (a\r\nodot b)\r\noplus (a\r\nodot c) If a = 2^{2^n} for some integer n > 0, and b < a, then a\r\nodot b = a\r\ncdot b. If a = 2^{2^n} for some integer n > 0, then a\r\nodot a =\r\nfrac{3}{2}\r\ncdot a. For example: 4\r\nodot 4 = 6 8\r\nodot 8 = 4\r\nodot 2\r\nodot 4\r\nodot 2 = 4\r\nodot 4\r\nodot 2\r\nodot 2 = 6\r\nodot 3 = (4\r\noplus 2)\r\nodot 3 = (4\r\nodot 3)\r\noplus (2\r\nodot (2\r\noplus 1)) = (4\r\nodot 3)\r\noplus (2\r\nodot 2)\r\noplus (2\r\nodot 1) = 12\r\noplus 3\r\noplus 2 = 13. 32\r\nodot 64 = (16\r\nodot 2)\r\nodot (16\r\nodot 4) = (16\r\nodot 16)\r\nodot (2\r\nodot 4) = 24\r\nodot 8 = (16\r\noplus 8)\r\nodot 8 = (16\r\nodot 8)\r\noplus (8\r\nodot 8) = 128\r\noplus 13 = 141 5\r\nodot 6 = (4\r\noplus 1)\r\nodot (4\r\noplus 2) = (4\r\nodot 4)\r\noplus (4\r\nodot 2)\r\noplus (4\r\nodot 1)\r\noplus (1\r\nodot 2) = 6\r\noplus 8\r\noplus 4\r\noplus 2 = 8 Formally, this algorithm can be described by following\r\npseudo-code. multiply(a, b) { ans = 0 for p1 in bits(a) // numbers of\r\nbits of a equal to one for p2 in bits(b) // numbers of bits of b equal\r\nto one ans = ans xor multiply_powers_of_2(1 << p1, 1 << p2) return\r\nans;}multiply_powers_of_2(a, b) { if (a == 1 or b == 1) return a * b n =\r\nmaximal value, such 2^{2^{n}} <= max(a, b) power = 2^{2^{n}}; if (a >=\r\npower and b >= power) { return multiply(power * 3 / 2,\r\nmultiply_powers_of_2(a / power, b / power)) } else if (a >= power) {\r\nreturn multiply_powers_of_2(a / power, b) * power } else { return\r\nmultiply_powers_of_2(a, b / power) * power }}It can be shown, that this\r\noperations really forms a field. Moreover, than can make sense as game\r\ntheory operations, but that\u2019s not related to problem much. With the help\r\nof appropriate caching and grouping of operations, it is possible to\r\ncalculate the product quickly enough, which is important to improve\r\nspeed of the cryptoalgorithm. More formal definitions as well as\r\nadditional properties can be clarified in the wikipedia article at link.\r\nThe authors of the task hope that the properties listed in the statement\r\nshould be enough for the solution. Powering for such muliplication is\r\ndefined in same way, formally a^{\r\nodot k} =\r\nunderbrace{a\r\nodot a\r\nodot\r\ncdots\r\nodot a}_{k\u00a0\r\ntexttt{times}}.You need to analyze the proposed scheme strength. For\r\npairs of numbers a and b you need to find such x, that a^{\r\nodot x} = b, or determine that it doesn\u2019t exist.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int base = 1000000000;\nconst int base_digits = 9;\n\nstruct bigint {\n  vector<int> z;\n  int sign;\n\n  bigint() : sign(1) {}\n\n  bigint(long long v) {\n    *this = v;\n  }\n\n  bigint(const string &s) {\n    read(s);\n  }\n\n  void operator=(const bigint &v) {\n    sign = v.sign;\n    z = v.z;\n  }\n\n  void operator=(long long v) {\n    sign = 1;\n    if (v < 0) {\n      sign = -1, v = -v;\n    }\n    z.clear();\n    for (; v > 0; v = v / base) {\n      z.push_back(v % base);\n    }\n  }\n\n  bigint operator+(const bigint &v) const {\n    if (sign == v.sign) {\n      bigint res = v;\n      for (int i = 0, carry = 0; i < (int) max(z.size(), v.z.size()) || carry; ++i) {\n        if (i == (int) res.z.size()) {\n          res.z.push_back(0);\n        }\n        res.z[i] += carry + (i < (int) z.size() ? z[i] : 0);\n        carry = res.z[i] >= base;\n        if (carry) {\n          res.z[i] -= base;\n        }\n      }\n      return res;\n    } else {\n      return *this - (-v);\n    }\n  }\n\n  bigint operator-(const bigint &v) const {\n    if (sign == v.sign) {\n      if (abs() >= v.abs()) {\n        bigint res = *this;\n        for (int i = 0, carry = 0; i < (int) v.z.size() || carry; ++i) {\n          res.z[i] -= carry + (i < (int) v.z.size() ? v.z[i] : 0);\n          carry = res.z[i] < 0;\n          if (carry) {\n            res.z[i] += base;\n          }\n        }\n        res.trim();\n        return res;\n      } else {\n        return -(v - *this);\n      }\n    } else {\n      return *this + (-v);\n    }\n  }\n\n  void operator*=(int v) {\n    if (v < 0) {\n      sign = -sign, v = -v;\n    }\n    for (int i = 0, carry = 0; i < (int) z.size() || carry; ++i) {\n      if (i == (int) z.size()) {\n        z.push_back(0);\n      }\n      long long cur = (long long) z[i] * v + carry;\n      carry = cur / base;\n      z[i] = cur % base;\n      // asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));\n    }\n    trim();\n  }\n\n  bigint operator*(int v) const {\n    bigint res = *this;\n    res *= v;\n    return res;\n  }\n\n  friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {\n    int norm = base / (b1.z.back() + 1);\n    bigint a = a1.abs() * norm;\n    bigint b = b1.abs() * norm;\n    bigint q, r;\n    q.z.resize(a.z.size());\n    for (int i = a.z.size() - 1; i >= 0; i--) {\n      r *= base;\n      r += a.z[i];\n      int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;\n      int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;\n      int d = ((long long) s1 * base + s2) / b.z.back();\n      r -= b * d;\n      while (r < 0) {\n        r += b, --d;\n      }\n      q.z[i] = d;\n    }\n    q.sign = a1.sign * b1.sign;\n    r.sign = a1.sign;\n    q.trim();\n    r.trim();\n    return make_pair(q, r / norm);\n  }\n\n  friend bigint sqrt(const bigint &a1) {\n    bigint a = a1;\n    while (a.z.empty() || (int) a.z.size() % 2 == 1) {\n      a.z.push_back(0);\n    }\n    int n = a.z.size();\n    int firstDigit = sqrt((long long) a.z[n - 1] * base + a.z[n - 2]);\n    int norm = base / (firstDigit + 1);\n    a *= norm;\n    a *= norm;\n    while (a.z.empty() || (int) a.z.size() % 2 == 1) {\n      a.z.push_back(0);\n    }\n    bigint r = (long long) a.z[n - 1] * base + a.z[n - 2];\n    firstDigit = sqrt((long long) a.z[n - 1] * base + a.z[n - 2]);\n    int q = firstDigit;\n    bigint res;\n    for (int j = n / 2 - 1; j >= 0; j--) {\n      for (;; --q) {\n        bigint r1 =\n          (r - (res * 2 * base + q) * q) * base * base +\n          (j > 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);\n        if (r1 >= 0) {\n          r = r1;\n          break;\n        }\n      }\n      res *= base;\n      res += q;\n      if (j > 0) {\n        int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;\n        int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;\n        int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;\n        q = ((long long) d1 * base * base + (long long) d2 * base + d3) /\n            (firstDigit * 2);\n      }\n    }\n    res.trim();\n    return res / norm;\n  }\n\n  bigint operator/(const bigint &v) const {\n    return divmod(*this, v).first;\n  }\n\n  bigint operator%(const bigint &v) const {\n    return divmod(*this, v).second;\n  }\n\n  void operator/=(int v) {\n    if (v < 0) {\n      sign = -sign, v = -v;\n    }\n    for (int i = z.size() - 1, rem = 0; i >= 0; --i) {\n      long long cur = z[i] + (long long) rem * base;\n      z[i] = cur / v;\n      rem = cur % v;\n    }\n    trim();\n  }\n\n  bigint operator/(int v) const {\n    bigint res = *this;\n    res /= v;\n    return res;\n  }\n\n  int operator%(int v) const {\n    if (v < 0) {\n      v = -v;\n    }\n    int m = 0;\n    for (int i = z.size() - 1; i >= 0; --i) {\n      m = ((long long) m * base + z[i]) % v;\n    }\n    return m * sign;\n  }\n\n  void operator+=(const bigint &v) {\n    *this = *this + v;\n  }\n  void operator-=(const bigint &v) {\n    *this = *this - v;\n  }\n  void operator*=(const bigint &v) {\n    *this = *this * v;\n  }\n  void operator/=(const bigint &v) {\n    *this = *this / v;\n  }\n\n  bool operator<(const bigint &v) const {\n    if (sign != v.sign) {\n      return sign < v.sign;\n    }\n    if (z.size() != v.z.size()) {\n      return z.size() * sign < v.z.size() * v.sign;\n    }\n    for (int i = z.size() - 1; i >= 0; i--) {\n      if (z[i] != v.z[i]) {\n        return z[i] * sign < v.z[i] * sign;\n      }\n    }\n    return false;\n  }\n\n  bool operator>(const bigint &v) const {\n    return v < *this;\n  }\n  bool operator<=(const bigint &v) const {\n    return !(v < *this);\n  }\n  bool operator>=(const bigint &v) const {\n    return !(*this < v);\n  }\n  bool operator==(const bigint &v) const {\n    return !(*this < v) && !(v < *this);\n  }\n  bool operator!=(const bigint &v) const {\n    return *this < v || v < *this;\n  }\n\n  void trim() {\n    while (!z.empty() && z.back() == 0) {\n      z.pop_back();\n    }\n    if (z.empty()) {\n      sign = 1;\n    }\n  }\n\n  bool isZero() const {\n    return z.empty() || ((int) z.size() == 1 && !z[0]);\n  }\n\n  bigint operator-() const {\n    bigint res = *this;\n    res.sign = -sign;\n    return res;\n  }\n\n  bigint abs() const {\n    bigint res = *this;\n    res.sign *= res.sign;\n    return res;\n  }\n\n  long long longValue() const {\n    long long res = 0;\n    for (int i = z.size() - 1; i >= 0; i--) {\n      res = res * base + z[i];\n    }\n    return res * sign;\n  }\n\n  friend bigint gcd(const bigint &a, const bigint &b) {\n    return b.isZero() ? a : gcd(b, a % b);\n  }\n  friend bigint lcm(const bigint &a, const bigint &b) {\n    return a / gcd(a, b) * b;\n  }\n\n  void read(const string &s) {\n    sign = 1;\n    z.clear();\n    int pos = 0;\n    while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {\n      if (s[pos] == '-') {\n        sign = -sign;\n      }\n      ++pos;\n    }\n    for (int i = s.size() - 1; i >= pos; i -= base_digits) {\n      int x = 0;\n      for (int j = max(pos, i - base_digits + 1); j <= i; j++) {\n        x = x * 10 + s[j] - '0';\n      }\n      z.push_back(x);\n    }\n    trim();\n  }\n\n  friend istream &operator>>(istream &stream, bigint &v) {\n    string s;\n    stream >> s;\n    v.read(s);\n    return stream;\n  }\n\n  friend ostream &operator<<(ostream &stream, const bigint &v) {\n    if (v.sign == -1) {\n      stream << '-';\n    }\n    stream << (v.z.empty() ? 0 : v.z.back());\n    for (int i = v.z.size() - 2; i >= 0; --i) {\n      stream << setw(base_digits) << setfill('0') << v.z[i];\n    }\n    return stream;\n  }\n\n  static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\n    vector<long long> p(max(old_digits, new_digits) + 1);\n    p[0] = 1;\n    for (int i = 1; i < (int) p.size(); i++) {\n      p[i] = p[i - 1] * 10;\n    }\n    vector<int> res;\n    long long cur = 0;\n    int cur_digits = 0;\n    for (int i = 0; i < (int) a.size(); i++) {\n      cur += a[i] * p[cur_digits];\n      cur_digits += old_digits;\n      while (cur_digits >= new_digits) {\n        res.push_back(cur % p[new_digits]);\n        cur /= p[new_digits];\n        cur_digits -= new_digits;\n      }\n    }\n    res.push_back(cur);\n    while (!res.empty() && res.back() == 0) {\n      res.pop_back();\n    }\n    return res;\n  }\n\n  typedef vector<long long> vll;\n\n  static vll karatsubaMultiply(const vll &a, const vll &b) {\n    int n = a.size();\n    vll res(n + n);\n    if (n <= 32) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          res[i + j] += a[i] * b[j];\n        }\n      }\n      return res;\n    }\n    int k = n >> 1;\n    vll a1(a.begin(), a.begin() + k);\n    vll a2(a.begin() + k, a.end());\n    vll b1(b.begin(), b.begin() + k);\n    vll b2(b.begin() + k, b.end());\n    vll a1b1 = karatsubaMultiply(a1, b1);\n    vll a2b2 = karatsubaMultiply(a2, b2);\n    for (int i = 0; i < k; i++) {\n      a2[i] += a1[i];\n    }\n    for (int i = 0; i < k; i++) {\n      b2[i] += b1[i];\n    }\n    vll r = karatsubaMultiply(a2, b2);\n    for (int i = 0; i < (int) a1b1.size(); i++) {\n      r[i] -= a1b1[i];\n    }\n    for (int i = 0; i < (int) a2b2.size(); i++) {\n      r[i] -= a2b2[i];\n    }\n    for (int i = 0; i < (int) r.size(); i++) {\n      res[i + k] += r[i];\n    }\n    for (int i = 0; i < (int) a1b1.size(); i++) {\n      res[i] += a1b1[i];\n    }\n    for (int i = 0; i < (int) a2b2.size(); i++) {\n      res[i + n] += a2b2[i];\n    }\n    return res;\n  }\n\n  bigint operator*(const bigint &v) const {\n    vector<int> a6 = convert_base(this->z, base_digits, 6);\n    vector<int> b6 = convert_base(v.z, base_digits, 6);\n    vll a(a6.begin(), a6.end());\n    vll b(b6.begin(), b6.end());\n    while (a.size() < b.size()) {\n      a.push_back(0);\n    }\n    while (b.size() < a.size()) {\n      b.push_back(0);\n    }\n    while (a.size() & (a.size() - 1)) {\n      a.push_back(0);\n      b.push_back(0);\n    }\n    vll c = karatsubaMultiply(a, b);\n    bigint res;\n    res.sign = sign * v.sign;\n    for (int i = 0, carry = 0; i < (int) c.size(); i++) {\n      long long cur = c[i] + carry;\n      res.z.push_back(cur % 1000000);\n      carry = cur / 1000000;\n    }\n    res.z = convert_base(res.z, 6, base_digits);\n    res.trim();\n    return res;\n  }\n};\n\ntemplate <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  a = a % m;\n  if (a < 0) {\n    a += m;\n  }\n  T b = m, u = 0, v = 1;\n  while (a != 0) {\n    T t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\n\ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  modnum() : v(0) {\n  }\n\n  modnum(long long _v) {\n    v = _v % P;\n    if (v < 0) {\n      v += P;\n    }\n  }\n\n  explicit operator int() const {\n    return v;\n  }\n\n  bool operator==(const modnum& o) const {\n    return v == o.v;\n  }\n\n  bool operator!=(const modnum& o) const {\n    return v != o.v;\n  }\n\n  modnum inverse() const {\n    return modnum(::inverse(v, P));\n  }\n\n  modnum operator-() const {\n    return modnum(v ? P - v : 0);\n  }\n  \n  modnum operator+() const {\n    return *this;\n  }\n\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  \n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  \n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n\n  modnum operator+(const modnum& o) const {\n    return modnum(*this) += o;\n  }\n\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n\n  modnum operator-(const modnum& o) const {\n    return modnum(*this) -= o;\n  }\n\n  modnum& operator*=(const modnum& o) {\n    v = (int) ((long long) v * o.v % P);\n    return *this;\n  }\n\n  modnum operator*(const modnum& o) const {\n    return modnum(*this) *= o;\n  }\n  \n  modnum& operator/=(const modnum& o) {\n    return *this *= o.inverse();\n  }\n\n  modnum operator/(const modnum& o) const {\n    return modnum(*this) /= o;\n  }\n};\n\ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\n\ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\n\ntypedef unsigned long long ull;\n\ntemplate <typename T>\nT power(T a, ull b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n\nnamespace nimber_initializer {\nconst int D = 8;\nconst int S = 1 << D | 1;\n\null table[S][S];\n}\n\null nimber_multiply(ull x, ull y, int d = 32) {\n  using namespace nimber_initializer;\n  if (x > y) {\n    swap(x, y);\n  }\n  if (!x) {\n    return 0;\n  }\n  if (x == 1) {\n    return y;\n  }\n  if (y < 1 << D && table[x][y]) {\n    return table[x][y];\n  }\n  while (y < 1ull << d) {\n    d >>= 1;\n  }\n  ull m = (1ull << d) - 1;\n  ull x0 = x & m, x1 = x >> d;\n  ull y0 = y & m, y1 = y >> d;\n  ull z0 = nimber_multiply(x0, y0, d >> 1);\n  ull z1 = nimber_multiply(x0 ^ x1, y0 ^ y1, d >> 1);\n  ull z2 = nimber_multiply(nimber_multiply(x1, y1, d >> 1), 1ull << (d - 1), d >> 1);\n  ull r = (z0 ^ z1) << d | (z0 ^ z2);\n  if (y < 1 << D) {\n    table[x][y] = r;\n  }\n  return r;\n}\n\nstruct nimber {\n private:\n  ull v;\n\n public:\n  nimber(ull v = 0) : v(v) {\n  }\n\n  explicit operator ull() const {\n    return v;\n  }\n\n  nimber& operator+=(const nimber& o) {\n    v ^= o.v;\n    return *this;\n  }\n\n  nimber& operator-=(const nimber& o) {\n    v ^= o.v;\n    return *this;\n  }\n\n  nimber& operator*=(const nimber& o) {\n    v = nimber_multiply(v, o.v);\n    return *this;\n  }\n\n  nimber& operator/=(const nimber& o) {\n    return *this *= o.inverse();\n  }\n\n  nimber operator+(const nimber& o) const {\n    return nimber(*this) += o;\n  }\n\n  nimber operator-(const nimber& o) const {\n    return nimber(*this) -= o;\n  }\n\n  nimber operator*(const nimber& o) const {\n    return nimber(*this) *= o;\n  }\n\n  nimber operator/(const nimber& o) const {\n    return nimber(*this) /= o;\n  }\n\n  nimber inverse() const {\n    if (v <= 1) {\n      return *this;\n    }\n    int d = 64;\n    while (v < 1ull << (d >> 1)) {\n      d >>= 1;\n    }\n    nimber r = 1;\n    nimber x = *this;\n    for (int i = 1; i < d; ++i) {\n      x *= x;\n      r *= x;\n    }\n    return r;\n  }\n};\n\nostream& operator<<(ostream& out, const nimber& n) {\n  return out << ull(n);\n}\n\nistream& operator>>(istream& in, nimber& n) {\n  ull _v;\n  in >> _v;\n  n = nimber(_v);\n  return in;\n}\n\nconst int p[7] = {3, 5, 17, 257, 641, 65537, 6700417};\nconst ull n = 18446744073709551615;\nconst nimber g = 1250686655986219608;\nconst int sq = 40000;\n\nunordered_map<ull, int> mp[7];\nnimber step[7];\n\nint get(nimber h, int who) {\n  nimber x = 1;\n  for (int i = 0; ; ++i) {\n    ull z = (ull) (h / x);\n    if (mp[who].count(z)) {\n      return (i * sq + mp[who][z]) % p[who];\n    }\n    x *= step[who];\n  }\n}\n\ntemplate <class T> pair<T, T> excrt(T m1, T a1, T m2, T a2) {\n  T g = __gcd(m1, m2); m1 /= g, m2 /= g;\n  if ((a2 - a1) % g != 0) return {-1, -1};\n\tif (m2 > m1) swap(m1, m2), swap(a1, a2);\n  T m = m1 * m2 * g, a = inverse(m1, m2) * ((a2 - a1) / g % m2 + m2) % m2 * m1 * g + a1;\n  return {m, a};\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  for (int i = 0; i < 7; ++i) {\n    nimber x = power(g, n / p[i]);\n    nimber y = 1;\n    for (int j = 0; j < sq; ++j) {\n      mp[i][(ull) y] = j;\n      y *= x;\n    }\n    step[i] = y;\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    nimber a, b;\n    cin >> a >> b;\n    vector<int> aa(7);\n    vector<int> bb(7);\n    for (int i = 0; i < 7; ++i) {\n      aa[i] = get(power(a, n / p[i]), i);\n      bb[i] = get(power(b, n / p[i]), i);\n    }\n    bool valid = true;\n    for (int i = 0; i < 7; ++i) {\n      if (!aa[i] && bb[i]) {\n        valid = false;\n        break;\n      }\n    }\n    if (valid) {\n      bigint m = 1, a = 0;\n      for (int i = 0; i < 7; ++i) {\n        if (aa[i]) {\n          bigint m0 = p[i];\n          bigint a0 = (long long) bb[i] * inverse(aa[i], p[i]) % p[i];\n          tie(m, a) = excrt(m, a, m0, a0);\n        }\n      }\n      cout << a << \"\\n\";\n    } else {\n      cout << -1 << \"\\n\";\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["math", "number theory"], "dificulty": "3400", "interactive": false}