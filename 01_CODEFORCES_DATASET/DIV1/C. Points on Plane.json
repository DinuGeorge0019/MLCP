{"link": "https://codeforces.com//contest/576/problem/C", "problemId": "34885", "problem_idx": "C", "shortId": "576C", "contest_number": "576", "problem_submissions": {"D": [12948640, 12948506, 12948354, 12937171, 12937633, 12940817, 12940388, 12940233, 12940092, 12939430, 12939063, 12935207, 12942962, 12940891, 12941506, 12939643, 12933648, 12943594], "C": [12932865, 12929775, 12930204, 12934079, 12931097, 12934157, 12932646, 12938006, 12960885, 12936499, 12932088, 12931162, 12933248, 12943319, 12926742, 12932751, 12928085, 12932873, 12935950], "B": [12930813, 12932445, 12933792, 12931978, 12932789, 12930228, 12930366, 12941663, 12931673, 12935038, 12935800, 12940912, 12931636, 12948000, 12937985, 12933306, 12935930, 12933037], "A": [12926373, 12925995, 12926783, 12926169, 12926245, 12926309, 12926740, 12939248, 12926537, 12926100, 12927525, 12926051, 12926418, 12928170, 12926649, 12926146, 12926053, 12936482], "E": [12958478, 12974224, 12948989, 13216883, 12944220]}, "name": "C. Points on Plane", "statement": "On a plane are points (, ) with integer coordinates between and . The\r\ndistance between the two points with numbers and is said to be the\r\nfollowing value: (the distance calculated by such formula is called ).We\r\ncall a hamiltonian path to be some permutation of numbers from to . We\r\nsay that the length of this path is value .Find some hamiltonian path\r\nwith a length of no more than . Note that you do not have to minimize\r\nthe path length.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 1000010\nint n;\nint x[MAX],y[MAX];\nvector<int> t[1001][1001];\nvoid dod(int a,int b){\n  R(i,SZ(t[a][b])){\n    printf(\"%d \",t[a][b][i]+1);\n  }\n}\nmain(){\n  make(n);\n  R(i,n){\n    int x,y;\n    make(x);if(!x)x++;\n    make(y);if(!y)y++;\n    t[(x-1)/1000][(y-1)/1000].PB(i);\n  }\n  R(i,1000){\n    if(i&1){\n      R(j,1000)\n        dod(i,j);\n    }else{\n      FD(j,1000)\n        dod(i,j);\n    }\n  }\n  puts(\"\");\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "divide and conquer", "geometry", "greedy", "sortings"], "dificulty": "2100", "interactive": false}