{"link": "https://codeforces.com//contest/718/problem/D", "problemId": "72543", "problem_idx": "D", "shortId": "718D", "contest_number": "718", "problem_submissions": {"C": [22302962, 22302941, 22302889, 22302852, 22302731, 22302692, 20846565, 20849386, 20847435, 20859089, 20848615, 20840892, 20856665, 20846554, 20847508, 20848199, 20847949, 20848925, 20849628, 20854862, 20850773, 20851572, 20861188, 20850610], "D": [20853333, 20864854, 20856011, 20861286, 21246935, 21246860, 20864386], "A": [20842439, 20877357, 20843102, 20840207, 20845729, 20843895, 20841441, 20841738, 20840153, 20842838, 20841757, 20842345, 20848915, 20842908, 20843212, 20840112, 20842542, 20845574], "E": [20878493, 21383093, 33904537]}, "name": "D. Andrew and Chemistry", "statement": "Formally, you are given a tree consisting of vertices, such that the\r\ndegree of each vertex doesn\u2019t exceed . You have to count the number of\r\ndistinct non-isomorphic trees that can be obtained by adding to this\r\ntree one new vertex and one new edge, such that the graph is still the\r\ntree and the degree of each vertex doesn\u2019t exceed .Two trees are\r\nisomorphic if there exists a bijection such that vertices and are\r\nconnected by an edge if and only if vertices and are connected by an\r\nedge.\r\n", "solutions": ["/**\n *    author:  [itmo] enot.1.10\n *    created: 23.09.2016 16:35:06       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = 1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\nconst int N = 2e5 + 10;\n\n#define next sdfklj\n#define hash sdflkjj\nint head[N], next[N], to[N], ec = 1;\n\ninline void add(int x, int y)\n{\n    ec++;\n    to[ec] = y;\n    next[ec] = head[x];\n    head[x] = ec;\n}\n             \nconst int mod1 = 1e9 + 7;\nconst int mod2 = 1e9 + 9;\nconst int P = 239;\n\nstruct hash\n{\n    int cnt;\n    int h1;\n    int h2;\n    hash()\n    {\n        cnt = 0;\n        h1 = 0;\n        h2 = 0;\n    }\n    void upd(int x)\n    {\n        cnt++;\n        h1 = (h1 * (ll)P + x) % mod1;\n        h2 = (h2 * (ll)P + x) % mod2;\n    }\n};\n\ninline bool operator < (hash a, hash b)\n{\n    if (a.cnt != b.cnt) return a.cnt < b.cnt;\n    if (a.h1 != b.h1) return a.h1 < b.h1;\n    return a.h2 < b.h2;\n}\n\nint pn1[N];\nint pn2[N];\n\ninline hash Merge(hash a, hash b)\n{\n    hash res;\n    res.cnt = a.cnt + b.cnt;\n    res.h1 = (a.h1 * (ll)pn1[b.cnt] + b.h1) % mod1;\n    res.h2 = (a.h2 * (ll)pn2[b.cnt] + b.h2) % mod2;\n    return res;\n}\n\nhash mem[N];\n\nhash go(int e)\n{\n    if (mem[e].cnt != -1) return mem[e];\n    mem[e] = hash();\n    int x = to[e];\n\n    vector<hash> v;\n    for (int ee = head[x]; ee; ee = next[ee]) if ((e ^ ee) != 1)\n    {\n        //eprintf(\"for calc %d->%d use calc %d->%d\\n\", to[e ^ 1], to[e], to[ee ^ 1], to[ee]);\n        v.pb(go(ee));\n    }\n    mem[e].upd(1);\n    sort(all(v));\n    forn(i, sz(v)) mem[e] = Merge(mem[e], v[i]);\n    mem[e].upd(2);\n    //eprintf(\"edge %d --> %d ::: %d %d %d\\n\", to[e ^ 1] , to[e], mem[e].cnt, mem[e].h1, mem[e].h2);\n    return mem[e];\n}\n\nhash calc(int x)\n{\n    vector<hash> v;\n    for (int ee = head[x]; ee; ee = next[ee])\n    {\n        v.pb(go(ee));\n    }\n    hash res;\n    res.upd(1);\n    sort(all(v));\n    forn(i, sz(v)) res = Merge(res, v[i]);\n    res.upd(2);\n    //eprintf(\"x = %d --> %d %d %d\\n\", x, res.cnt, res.h1, res.h2);\n    return res;\n}\n\n        \n    \n\nhash H[N];\nint deg[N];\n\n\nint main()\n{\n    #ifdef home\n        assert(freopen(\"1.in\", \"r\", stdin));\n        assert(freopen(\"1.out\", \"w\", stdout));\n    #endif\n    forn(i, N) mem[i].cnt = -1;\n\n    pn1[0] = pn2[0] = 1;\n    for (int i = 1; i < N; ++i)\n    {\n        pn1[i] = (pn1[i - 1] * (ll)P) % mod1;\n        pn2[i] = (pn2[i - 1] * (ll)P) % mod2;\n    }\n\n    int n;\n    scanf(\"%d\", &n);\n    forn(i, n - 1)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        --x, --y;\n        add(x, y);\n        add(y, x);\n        deg[x]++;\n        deg[y]++;\n    }\n\n    forn(i, n) H[i] = calc(i);\n\n    map<pi, int> M;\n    forn(i, n) if (deg[i] <= 3) M[{H[i].h1, H[i].h2}]++;\n    printf(\"%d\\n\", sz(M));\n\n    \n    #ifdef home\n        eprintf(\"time = %d ms\\n\", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "hashing", "trees"], "dificulty": "2900", "interactive": false}