{
    "link": "https://codeforces.com//contest/866/problem/G",
    "problemId": "125346",
    "problem_idx": "G",
    "shortId": "866G",
    "contest_number": "866",
    "problem_submissions": {
        "G": [
            48042764,
            48042747,
            48042330,
            48042234,
            48042200,
            30882226,
            30888984,
            57250068
        ],
        "D": [
            31044799,
            30877994,
            30876120,
            30879768,
            30877841,
            30935417,
            30935391,
            30878366,
            82427005,
            30877626,
            30880014,
            30879034,
            30880919,
            30880306,
            30879681,
            30881205,
            30880292,
            30878146,
            30881085,
            30880894
        ],
        "F": [
            30883978,
            30915539,
            30915526,
            30915506,
            30915496,
            30915492,
            30915483,
            30915431,
            30915401,
            30915351,
            30915334,
            30888671,
            30882806,
            57257664
        ],
        "C": [
            30875892,
            30877179,
            30883361,
            30877278,
            30966883,
            30966734,
            30935175,
            30876872,
            30891743,
            30891736,
            30880301,
            30877644,
            30878514,
            30877044,
            30878539,
            30877470,
            30877525,
            30878653,
            30881355,
            30877891,
            31274174,
            30878115
        ],
        "B": [
            30874326,
            30883354,
            30901870,
            30876267,
            30875622,
            30878803,
            30876656,
            30875923,
            30874820,
            30876008,
            30875772,
            30876212,
            30875972,
            30876853,
            30876928,
            30876128,
            30876479
        ],
        "A": [
            30872518,
            30872539,
            30872760,
            30872739,
            30875884,
            30873740,
            30872744,
            30872982,
            30875680,
            30874617,
            30872755,
            30881297,
            30873075,
            30873379,
            30873703,
            30873164,
            30874384
        ],
        "E": [
            30957127,
            30884728,
            30888758,
            30909701
        ]
    },
    "name": "G. Flowers and Chocolate",
    "statement": "It’s Piegirl’s birthday soon, and Pieguy has decided to buy her a\r\nbouquet of flowers and a basket of chocolates.The flower shop has\r\ndifferent types of flowers available. The -th type of flower always has\r\nexactly petals. Pieguy has decided to buy a bouquet consisting of\r\nexactly flowers. He may buy the same type of flower multiple times. The\r\nflowers are then arranged into a bouquet. The position of the flowers\r\nwithin a bouquet matters. You can think of a bouquet as an ordered list\r\nof flower types.The chocolate shop sells chocolates in boxes. There are\r\ndifferent types of boxes available. The -th type of box contains pieces\r\nof chocolate. Pieguy can buy any number of boxes, and can buy the same\r\ntype of box multiple times. He will then place these boxes into a\r\nbasket. The position of the boxes within the basket matters. You can\r\nthink of the basket as an ordered list of box types.Pieguy knows that\r\nPiegirl likes to pluck a petal from a flower before eating each piece of\r\nchocolate. He would like to ensure that she eats the last piece of\r\nchocolate from the last box just after plucking the last petal from the\r\nlast flower. That is, the total number of petals on all the flowers in\r\nthe bouquet should equal the total number of pieces of chocolate in all\r\nthe boxes in the basket.How many different bouquet+basket combinations\r\ncan Pieguy buy? The answer may be very large, so compute it modulo .\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 06.01.2019 23:15:40       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular inverse() const {\n    Type a = value, b = mod(), u = 0, v = 1;\n    while (a != 0) {\n      Type t = b / a;\n      b -= t * a; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    assert(b == 1);\n    return Modular(u);\n  }\n  Modular& operator/=(const Modular& other) { return *this *= other.inverse(); }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  stream >> number.value;\n  number.value = Modular<T>::normalize(number.value);\n  return stream;\n}\n\nstruct VarMod { static int value; };\nint VarMod::value;\n\n//using Mint = Modular<VarMod>;\nusing Mint = Modular<std::integral_constant<int, (int) 1e9 + 7>>;\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    a.clear();\n  } else {\n    vector<T> c = a;\n    a.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) c.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        a[i + j] += c[i] * b[j];\n      }\n    }\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c *= b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> x = b * b * vector<T>(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T> {1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n\nnamespace fft {\n\ntypedef double dbl;\n\nstruct num {\n  dbl x, y;\n  num() { x = y = 0; }\n  num(dbl x_, dbl y_) : x(x_), y(y_) {}\n};\n\ninline num operator+(num a, num b) { return num(a.x + b.x, a.y + b.y); }\ninline num operator-(num a, num b) { return num(a.x - b.x, a.y - b.y); }\ninline num operator*(num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\ninline num conj(num a) { return num(a.x, -a.y); }\n\nint base = 1;\nvector<num> roots = {{0, 0}, {1, 0}};\nvector<int> rev = {0, 1};\n\nconst dbl PI = static_cast<dbl>(acosl(-1.0));\n\nvoid ensure_base(int nbase) {\n  if (nbase <= base) {\n    return;\n  }\n  rev.resize(1 << nbase);\n  for (int i = 0; i < (1 << nbase); i++) {\n    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n  }\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    dbl angle = 2 * PI / (1 << (base + 1));\n//      num z(cos(angle), sin(angle));\n    for (int i = 1 << (base - 1); i < (1 << base); i++) {\n      roots[i << 1] = roots[i];\n//        roots[(i << 1) + 1] = roots[i] * z;\n      dbl angle_i = angle * (2 * i + 1 - (1 << base));\n      roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));\n    }\n    base++;\n  }\n}\n\nvoid fft(vector<num> &a, int n = -1) {\n  if (n == -1) {\n    n = (int) a.size();\n  }\n  assert((n & (n - 1)) == 0);\n  int zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; i++) {\n    if (i < (rev[i] >> shift)) {\n      swap(a[i], a[rev[i] >> shift]);\n    }\n  }\n  for (int k = 1; k < n; k <<= 1) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        num z = a[i + j + k] * roots[j + k];\n        a[i + j + k] = a[i + j] - z;\n        a[i + j] = a[i + j] + z;\n      }\n    }\n  }\n}\n\nvector<num> fa, fb;\n\nvector<int64_t> square(const vector<int>& a) {\n  if (a.empty()) {\n    return {};\n  }\n  int need = (int) a.size() + (int) a.size() - 1;\n  int nbase = 1;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if ((sz >> 1) > (int) fa.size()) {\n    fa.resize(sz >> 1);\n  }\n  for (int i = 0; i < (sz >> 1); i++) {\n    int x = (2 * i < (int) a.size() ? a[2 * i] : 0);\n    int y = (2 * i + 1 < (int) a.size() ? a[2 * i + 1] : 0);\n    fa[i] = num(x, y);\n  }\n  fft(fa, sz >> 1);\n  num r(1.0 / (sz >> 1), 0.0);\n  for (int i = 0; i <= (sz >> 2); i++) {\n    int j = ((sz >> 1) - i) & ((sz >> 1) - 1);\n    num fe = (fa[i] + conj(fa[j])) * num(0.5, 0);\n    num fo = (fa[i] - conj(fa[j])) * num(0, -0.5);\n    num aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];\n    num tmp = fe * fo;\n    fa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));\n    fa[j] = r * (aux + num(0, 2) * tmp);\n  }\n  fft(fa, sz >> 1);\n  vector<int64_t> res(need);\n  for (int i = 0; i < need; i++) {\n    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n  }\n  return res;\n}\n\nvector<int64_t> multiply(const vector<int>& a, const vector<int>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (a.size() == b.size() && a == b) {\n    return square(a);\n  }\n  int need = (int) a.size() + (int) b.size() - 1;\n  int nbase = 1;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if (sz > (int) fa.size()) {\n    fa.resize(sz);\n  }\n  for (int i = 0; i < sz; i++) {\n    int x = (i < (int) a.size() ? a[i] : 0);\n    int y = (i < (int) b.size() ? b[i] : 0);\n    fa[i] = num(x, y);\n  }\n  fft(fa, sz);\n  num r(0, -0.25 / (sz >> 1));\n  for (int i = 0; i <= (sz >> 1); i++) {\n    int j = (sz - i) & (sz - 1);\n    num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;\n    fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;\n    fa[i] = z;\n  }\n  for (int i = 0; i < (sz >> 1); i++) {\n    num A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);\n    num A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];\n    fa[i] = A0 + A1 * num(0, 1);\n  }\n  fft(fa, sz >> 1);\n  vector<int64_t> res(need);\n  for (int i = 0; i < need; i++) {\n    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n  }\n  return res;\n}\n\nvector<int> multiply_mod(const vector<int>& a, const vector<int>& b, int m) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  int eq = (a.size() == b.size() && a == b);\n  int need = (int) a.size() + (int) b.size() - 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if (sz > (int) fa.size()) {\n    fa.resize(sz);\n  }\n  for (int i = 0; i < (int) a.size(); i++) {\n    int x = (a[i] % m + m) % m;\n    fa[i] = num(x & ((1 << 15) - 1), x >> 15);\n  }\n  fill(fa.begin() + a.size(), fa.begin() + sz, num {0, 0});\n  fft(fa, sz);\n  if (sz > (int) fb.size()) {\n    fb.resize(sz);\n  }\n  if (eq) {\n    copy(fa.begin(), fa.begin() + sz, fb.begin());\n  } else {\n    for (int i = 0; i < (int) b.size(); i++) {\n      int x = (b[i] % m + m) % m;\n      fb[i] = num(x & ((1 << 15) - 1), x >> 15);\n    }\n    fill(fb.begin() + b.size(), fb.begin() + sz, num {0, 0});\n    fft(fb, sz);\n  }\n  dbl ratio = 0.25 / sz;\n  num r2(0, -1);\n  num r3(ratio, 0);\n  num r4(0, -ratio);\n  num r5(0, 1);\n  for (int i = 0; i <= (sz >> 1); i++) {\n    int j = (sz - i) & (sz - 1);\n    num a1 = (fa[i] + conj(fa[j]));\n    num a2 = (fa[i] - conj(fa[j])) * r2;\n    num b1 = (fb[i] + conj(fb[j])) * r3;\n    num b2 = (fb[i] - conj(fb[j])) * r4;\n    if (i != j) {\n      num c1 = (fa[j] + conj(fa[i]));\n      num c2 = (fa[j] - conj(fa[i])) * r2;\n      num d1 = (fb[j] + conj(fb[i])) * r3;\n      num d2 = (fb[j] - conj(fb[i])) * r4;\n      fa[i] = c1 * d1 + c2 * d2 * r5;\n      fb[i] = c1 * d2 + c2 * d1;\n    }\n    fa[j] = a1 * b1 + a2 * b2 * r5;\n    fb[j] = a1 * b2 + a2 * b1;\n  }\n  fft(fa, sz);\n  fft(fb, sz);\n  vector<int> res(need);\n  for (int i = 0; i < need; i++) {\n    int64_t aa = llround(fa[i].x);\n    int64_t bb = llround(fb[i].x);\n    int64_t cc = llround(fa[i].y);\n    res[i] = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);\n  }\n  return res;\n}\n\n}  // namespace fft\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type& operator*=(\n    vector<Modular<T>>& a,\n    const vector<Modular<T>>& b) {\n  vector<int> A(a.size());\n  for (int i = 0; i < (int) A.size(); i++) {\n    A[i] = static_cast<int>(a[i]);\n  }\n  vector<int> B(b.size());\n  for (int i = 0; i < (int) B.size(); i++) {\n    B[i] = static_cast<int>(b[i]);\n  }\n  vector<int> C = fft::multiply_mod(A, B, T::value);\n  a.resize(C.size());\n  for (int i = 0; i < (int) C.size(); i++) {\n    a[i] = C[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type operator*(\n    const vector<Modular<T>>& a,\n    const vector<Modular<T>>& b) {\n  vector<Modular<T>> c = a;\n  return c *= b;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int f, b;\n  long long n;\n  cin >> f >> b >> n;\n  vector<int> p(f);\n  for (int i = 0; i < f; i++) {\n    cin >> p[i];\n  }\n  vector<int> c(b);\n  for (int i = 0; i < b; i++) {\n    cin >> c[i];\n  }\n  int mx = *max_element(c.begin(), c.end());\n  vector<Mint> md(mx + 1);\n  md[mx]++;\n  for (int i = 0; i < b; i++) {\n    md[mx - c[i]]--;\n  }\n  vector<Mint> sum;\n  for (int i = 0; i < f; i++) {\n    sum += power({0, 1}, p[i], md);\n  }\n  vector<Mint> res = power(sum, n, md);\n  vector<Mint> final(mx);\n  final[mx - 1] = 1;\n  res = res * final % md;\n  debug(res);\n  cout << ((int) res.size() <= mx - 1 ? Mint(0) : res[mx - 1]) << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\G. Flowers and Chocolate.json",
    "editorial_link": "https://codeforces.com//blog/entry/54888",
    "editorial": "Let's first consider how to compute the number of ways to make a bouquet with exactly K petals. Define a polynomial . Then if we compute P(x)N, the coefficient of xK gives the number of ways to make a bouquet with exactly K petals. This is because each possible bouquet produces a term with an exponent equal to its number of petals.\n\nNow lets consider how to compute the number of ways to make a basket with exactly K chocolates. Define a polynomial . Then if we compute , the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates. This can be derived from a Generating Function, but we will provide an alternate derivation. Now let's define a polynomial . Initially, W(x)?=?1. Lines 3 through 5 add a multiple of Q(x) to W(x), and line 6 divides W(x) by x. It follows that the resulting polynomial is congruent to x?-?K modulo Q(x).\nThe final answer is the sum, over all values of K, of the number of bouquets with K petals times the number of baskets with K chocolates. The number of bouquets is given by the xK coefficient of P(x)N, or equivalently, the x?-?K coefficient of P(x?-?1)N, and the number of baskets is given by the coefficient of x0 of . It follows that the answer is simply the coefficient of x0 of . This can be computed using  polynomial multiplications, each of which takes O(max(ci)2) time, using naive multiplication, for a total runtime of .",
    "hint": []
}