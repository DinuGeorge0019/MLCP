{
    "link": "https://codeforces.com//contest/1261/problem/D1",
    "problemId": "479749",
    "problem_idx": "D1",
    "shortId": "1261D1",
    "contest_number": "1261",
    "problem_submissions": {
        "F": [
            65647116,
            65658053,
            65657980,
            65657931,
            65651526,
            65649568,
            65649392,
            65651843,
            65651789,
            65643329,
            65715623,
            65660068,
            66569502,
            66569457,
            66569446,
            66563643,
            66529592,
            66529450,
            66529001,
            66528877,
            66527265,
            66527166,
            202179447,
            65759590,
            65736891,
            65656177,
            65801900,
            65656900,
            65653812
        ],
        "E": [
            65640839,
            65636308,
            65639924,
            65632814,
            65644428,
            65645126,
            65649634,
            65644543,
            65648074,
            65645492,
            65646710,
            65643401,
            65649412,
            65647298,
            65649626,
            65646791,
            65647214,
            65650131,
            65673025
        ],
        "D2": [
            65637210,
            65632855,
            65635634,
            65636824,
            65639345,
            65639544,
            65635456,
            65639090,
            65637689,
            65685918,
            65636623,
            65641288,
            65630575,
            65640353,
            65641640,
            65638704,
            65642981,
            65642369,
            65636523,
            65640625
        ],
        "D1": [
            65637138,
            65632929,
            65635559,
            65636922,
            65639374,
            65639684,
            65633638,
            65639276,
            65637859,
            65636779,
            65641185,
            65630619,
            65640390,
            65641739,
            65638754,
            65643069,
            65642429,
            65636584,
            65639802
        ],
        "C": [
            65632448,
            65642046,
            65632919,
            65640324,
            65637319,
            65636062,
            65629189,
            65635829,
            65634638,
            65686469,
            65686406,
            65686240,
            65686235,
            65686196,
            65686121,
            65686065,
            65686054,
            65686032,
            65685983,
            65685973,
            65685956,
            65633182,
            65639316,
            65636734,
            65647142,
            65634479,
            65636999,
            65635515,
            65637442,
            65637462,
            65658341,
            65640232,
            65635038
        ],
        "B1": [
            65629099,
            65627296,
            65628841,
            65642477,
            65630053,
            65629451,
            65645427,
            65631701,
            65629375,
            65639182,
            65631034,
            65637262,
            65630223,
            65630435,
            65630786,
            65631879,
            65632451,
            65627736,
            65630111
        ],
        "B2": [
            65629029,
            65627239,
            65628722,
            65642378,
            65629995,
            65629248,
            65645596,
            65631497,
            65629280,
            65720078,
            65685862,
            65639011,
            65631167,
            65637207,
            65630166,
            65630277,
            65630671,
            65631817,
            65632276,
            65627619,
            65630224
        ],
        "A": [
            65626424,
            65626236,
            65626313,
            65643924,
            65627202,
            65627360,
            65650514,
            65628121,
            65627165,
            65626869,
            65627525,
            65634172,
            65626632,
            65626977,
            65627953,
            65628262,
            65627833,
            65631529,
            65627297
        ]
    },
    "name": "D1. Wrong Answer on test 233  Easy Version ",
    "statement": "Your program fails again. This time it gets \"\".The problem is about a\r\ntest containing n one-choice-questions. Each of the questions contains k\r\noptions, and only one of them is correct. The answer to the i-th\r\nquestion is h_{i}, and if your answer of the question i is h_{i}, you\r\nearn 1 point, otherwise, you earn 0 points for this question. The values\r\nh_1, h_2,\r\ndots, h_n are known to you in this problem.However, you have a mistake\r\nin your program. It moves the answer clockwise! Consider all the n\r\nanswers are written in a circle. Due to the mistake in your program,\r\nthey are shifted by one cyclically.Formally, the mistake moves the\r\nanswer for the question i to the question i\r\nbmod n + 1. So it moves the answer for the question 1 to question 2, the\r\nanswer for the question 2 to the question 3, ..., the answer for the\r\nquestion n to the question 1.We call all the n answers together an .\r\nThere are k^n possible answer suits in total.You’re wondering, how many\r\nanswer suits satisfy the following condition: . You need to find the\r\nanswer modulo 998\r\n,244\r\n,353.For example, if n = 5, and your answer suit is a=[1,2,3,4,5], it\r\nwill submitted as a’=[5,1,2,3,4] because of a mistake. If the correct\r\nanswer suit is h=[5,2,2,3,4], the answer suit a earns 1 point and the\r\nanswer suite a’ earns 4 points. Since 4 > 1, the answer suit\r\na=[1,2,3,4,5] should be counted.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n\nint inverse(int a, int m) {\n  a %= m;\n  if (a < 0) {\n    a += m;\n  }\n  int b = m, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\n\ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  modnum() : v(0) {\n  }\n\n  modnum(long long _v) {\n    v = _v % P;\n    if (v < 0) {\n      v += P;\n    }\n  }\n\n  explicit operator int() const {\n    return v;\n  }\n\n  bool operator==(const modnum& o) const {\n    return v == o.v;\n  }\n\n  bool operator!=(const modnum& o) const {\n    return v != o.v;\n  }\n\n  modnum inverse() const {\n    return modnum(::inverse(v, P));\n  }\n\n  modnum operator-() const {\n    return modnum(v ? P - v : 0);\n  }\n  \n  modnum operator+() const {\n    return *this;\n  }\n\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  \n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  \n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n\n  modnum operator+(const modnum& o) const {\n    return modnum(*this) += o;\n  }\n\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n\n  modnum operator-(const modnum& o) const {\n    return modnum(*this) -= o;\n  }\n\n  modnum& operator*=(const modnum& o) {\n    v = (int) ((long long) v * o.v % P);\n    return *this;\n  }\n\n  modnum operator*(const modnum& o) const {\n    return modnum(*this) *= o;\n  }\n  \n  modnum& operator/=(const modnum& o) {\n    return *this *= o.inverse();\n  }\n\n  modnum operator/(const modnum& o) const {\n    return modnum(*this) /= o;\n  }\n};\n\ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\n\ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\n\nusing num = modnum<998244353>;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  num m;\n  cin >> n >> m;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  a.push_back(a[0]);\n  int eq = 0;\n  int neq = 0;\n  for (int i = 0; i < n; ++i) {\n    if (a[i] == a[i + 1]) {\n      eq++;\n    } else {\n      neq++;\n    }\n  }\n  vector<num> fact(n + 1), inv_fact(n + 1);\n  fact[0] = inv_fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = fact[i - 1] * i;\n    inv_fact[i] = inv_fact[i - 1] / i;\n  }\n  auto binom = [&](int x, int y) {\n    return fact[x] * inv_fact[y] * inv_fact[x - y];\n  };\n  num cur = 0;\n  for (int i = 0; i <= neq / 2; ++i) {\n    cur += binom(neq, i);\n  }\n  num ans = 0;\n  for (int i = 0, j = neq; i < neq; ++i, --j) {\n    ans += power(m - 2, i) * (power(num(2), j) - cur) * binom(neq, i);\n    if (j % 2 == 0) {\n      cur -= binom(j, j / 2);\n    }\n    cur += binom(j - 1, (j - 1) / 2);\n    cur /= 2;\n  }\n  cout << ans * power(m, eq) << \"\\n\";\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D1. Wrong Answer on test 233  Easy Version .json",
    "editorial_link": "https://codeforces.com/blog/entry/71740",
    "editorial": "First of all, special judge for , where the answer is zero.Let be the\r\ndifference between the points for latest answer suit and the previous\r\none. An valid answer suit means . For positions satisfying , the answer\r\nfor this position will not affect . Assume thereâs positions which .For\r\na fixed position which , let your answer for this position is . If ,\r\nthen the value will decrease by 1. We call this kind of position as a .\r\nIf , then the value increase by 1. We call this kind of position as a .\r\nOtherwise value will not be affected, we call this kind of position\r\n.Obviously the number of increasing position should be exact larger then\r\nthe decreasing position. So letâs enumerate the number of zero\r\npositions. We can find the answer is equal to . represent the number of\r\nzero positions and represent the number of increasing positions.The only\r\nproblem is how to calculate quickly. Due to , we can tell that when is\r\nodd, . Otherwise it is equal to .\r\n",
    "hint": []
}