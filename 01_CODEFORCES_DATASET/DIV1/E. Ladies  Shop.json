{"link": "https://codeforces.com//contest/286/problem/E", "problemId": "2769", "problem_idx": "E", "shortId": "286E", "contest_number": "286", "problem_submissions": {"E": [3390546, 3391792, 3395790, 3391048, 3391288, 3390752, 3393756, 3405899, 3968761, 3584732, 3395321, 3395288, 3395060, 17994831, 3469466, 3469320], "D": [3389279, 3388966, 3389901, 3389906, 3391845, 3389722, 3392796, 3388857, 3395013, 3392782, 3391848, 3410751], "C": [3387722, 3387213, 3387005, 3386396, 3389739, 3391778, 3386453, 3386344, 3393851, 3387073, 3388380, 3388932, 3386042, 3389551, 3388553, 3389696, 3389128], "B": [3386275, 3386079, 3392121, 3386991, 3387709, 3390895, 3385630, 3385043, 3386200, 3386745, 3386272, 3387033, 3387460, 3387793, 3388156], "A": [3385050, 3384757, 3384907, 3384734, 3386122, 3385898, 3384517, 3384557, 3387291, 3384991, 3385549, 3387419, 3387088, 3385205, 3386011, 3386619, 3386427]}, "name": "E. Ladies  Shop", "statement": "A ladies\u2019 shop has recently opened in the city of Ultima Thule. To get\r\nready for the opening, the shop bought bags. Each bag is characterised\r\nby the total weight of the items you can put there. The weird thing is,\r\nyou use these bags to put a set of items with the total weight strictly\r\nless than . However the weights of the items that will be sold in the\r\nshop haven\u2019t yet been defined. That\u2019s what you should determine right\r\nnow.Your task is to find the set of the items\u2019 weights , such that: Any\r\nbag will be used. That is, for any there will be such set of items that\r\ntheir total weight will equal . We assume that there is the infinite\r\nnumber of items of any weight. You can put multiple items of the same\r\nweight in one bag. For any set of items that have total weight less than\r\nor equal to , there is a bag into which you can put this set. Similarly,\r\na set of items can contain multiple items of the same weight. Of all\r\nsets of the items\u2019 weights that satisfy points 1 and 2, find the set\r\nwith the minimum number of weights. In other words, value should be as\r\nsmall as possible. Find and print the required set.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nstruct base{\n\tdouble a,b;\n\tbase(){}\n\tbase(double a,double b):a(a),b(b){}\n\tbase operator+(const base &x)const{\n\t\treturn base(a+x.a,b+x.b);\n\t}\n\tbase operator-(const base &x)const{\n\t\treturn base(a-x.a,b-x.b);\n\t}\n\tbase operator*(const base &x)const{\n\t\treturn base(a*x.a-b*x.b,a*x.b+b*x.a);\n\t}\n\tbase operator/(double d)const{\n\t\treturn base(a/d,b/d);\n\t}\n};\n\nconst int lim=1<<21;\nint src[lim + 100];\nbase ar[lim + 100];\n\nvoid fft (bool invert) {\n\tint n = lim;\n\t\n\tfor (int i=1, j=0; i<n; ++i) {\n\t\tint bit = n >> 1;\n\t\tfor (; j>=bit; bit>>=1)\n\t\t\tj -= bit;\n\t\tj += bit;\n\t\tif (i < j)\n\t\t\tswap (ar[i], ar[j]);\n\t}\n\t\n\tfor (int len=2; len<=n; len<<=1) {\n\t\tdouble ang = 2*PI/len * (invert ? -1 : 1);\n\t\tbase wlen (cos(ang), sin(ang));\n\t\tfor (int i=0; i<n; i+=len) {\n\t\t\tbase w (1, 0);\n\t\t\tfor (int j=0; j<len/2; ++j) {\n\t\t\t\tbase u = ar[i+j],  v = ar[i+j+len/2] * w;\n\t\t\t\tar[i+j] = u + v;\n\t\t\t\tar[i+j+len/2] = u - v;\n\t\t\t\tw = w * wlen;\n\t\t\t}\n\t\t}\n\t}\n\tif (invert)\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tar[i] = ar[i] / n;\n}\n\nvoid square(){\n\tfft(false);\n\tforn(i,lim){\n\t\tar[i] = ar[i] * ar[i];\n\t}\n\tfft(true);\n}\n\nint main() {\n#ifdef __ASD__\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n,m;\n\tcin>>n>>m;\n\tforn(i,n){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tsrc[a]=1;\n\t\tar[a].a=1;\n\t}\n\tforn(a,m+1){\n\t\tif(!src[a])\n\t\t\tcontinue;\n\t\tfor(int b=a+a;b<=m;b+=a){\n\t\t\tif(!src[b]){\n\t\t\t\tcout<<\"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tsquare();\n\tvector<int> res;\n\tforn(a,m+1){\n\t\t//cout<<ar[a].a<<' '<<ar[a].b<<endl;\n\t\tbool t=fabs(ar[a].a)>.5;\n\t\tif(t){\n\t\t\tif(!src[a]){\n\t\t\t\tcout<<\"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(src[a])\n\t\t\t\tres.pb(a);\n\t\t}\n\t}\n\t\n\tcout<<\"YES\\n\"<<sz(res)<<'\\n';\n\tforv(i,res){\n\t\tprintf(\"%d \",res[i]);\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "fft", "math"], "dificulty": "2800", "interactive": false}