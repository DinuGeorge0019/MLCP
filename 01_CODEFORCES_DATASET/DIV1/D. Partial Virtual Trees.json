{"link": "https://codeforces.com//contest/1707/problem/D", "problemId": "1465656", "problem_idx": "D", "shortId": "1707D", "contest_number": "1707", "problem_submissions": {"E": [164603668, 164525375, 164669454, 185901683, 185901618, 185901333, 164563417], "D": [164511528, 164496478, 164493571, 164495095, 164501925, 164506638, 166069487, 164497571, 164507609, 166120309, 166120066, 164509308, 164956360, 164507471, 164489918, 164511025, 164904470, 164514319, 164514325, 164497954, 164519148, 164515594, 164518158, 164516720, 164511294], "B": [164484745, 164460975, 164467918, 164471533, 164466867, 164467580, 164475668, 164466783, 166120253, 166119986, 164469792, 164956306, 164468045, 164461021, 164475290, 164475116, 164472236, 164466401, 164463086, 164472164, 164472283, 164465112, 164479683], "C": [164479539, 164485229, 164482780, 164482216, 164481698, 164485751, 164487589, 164482127, 166120011, 164486694, 164956347, 164484482, 164472573, 164487921, 164484938, 164484181, 164511081, 164483634, 164483996, 164493834, 164499762, 164491460], "A": [164463335, 164470733, 164464634, 164464640, 164458756, 164460631, 164457208, 164456721, 166119954, 164458999, 164956326, 164457788, 164466493, 164459761, 164467279, 164469592, 164460485, 164464829, 164460707, 164471416, 164466775], "F": [164529829, 164530227, 165361670, 165361592, 165360981, 165360617, 164565887, 164565715]}, "name": "D. Partial Virtual Trees", "statement": "Kawashiro Nitori is a girl who loves competitive programming. One day\r\nshe found a rooted tree consisting of n vertices. The root is vertex 1.\r\nAs an advanced problem setter, she quickly thought of a\r\nproblem.Kawashiro Nitori has a vertex set U=\r\n{1,2,\r\nldots,n\r\n}. She\u2019s going to play a game with the tree and the set. In each\r\noperation, she will choose a vertex set T, where T is a of U, and change\r\nU into T.A vertex set S_1 is a partial virtual tree of a vertex set S_2,\r\nif S_1 is a subset of S_2, S_1\r\nneq S_2, and for all pairs of vertices i and j in S_1,\r\noperatorname{LCA}(i,j) is in S_1, where\r\noperatorname{LCA}(x,y) denotes the lowest common ancestor of vertices x\r\nand y on the tree. Note that a vertex set can have many different\r\npartial virtual trees.Kawashiro Nitori wants to know for each possible\r\nk, if she performs the operation k times, in how many ways she can make\r\nU=\r\n{1\r\n} in the end? Two ways are considered different if there exists an\r\ninteger z (1\r\nle z\r\nle k) such that after z operations the sets U are different.Since the\r\nanswer could be very large, you need to find it modulo p. It\u2019s\r\nguaranteed that p is a prime number.\r\n", "solutions": ["#include <cstdio>\n\nint n;\nint P=998244353;\ninline int mul(const int &a,const int &b){return 1ll*a*b%P;}\ninline int sub(int a,const int &b){a-=b;return (a<0)?a+P:a;}\ninline int add(int a,const int &b){a+=b;return(a>=P)?a-P:a;}\nint qsm(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint head[100001],nxt[200001],b[200001],k;\nvoid push(int s,int t){\n\tnxt[++k]=head[s];\n\thead[s]=k;\n\tb[k]=t;\n}\nint f[2010][2010],g[2010][2010];\nint tem[2010][2010],zero[2010][2010];\nvoid dfs(int x,int F){\n\tfor(int i=1;i<=n-1;++i)tem[x][i]=1,zero[x][i]=0;\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(b[i]!=F){\n\t\t\tdfs(b[i],x);\n\t\t\tfor(int j=1,sum=0;j<=n-1;++j){\n\t\t\t\tsum=add(f[b[i]][j],sum);\n\t\t\t\tif(!sum)++zero[x][j];\n\t\t\t\telse tem[x][j]=mul(tem[x][j],sum);\n\t\t\t}\n\t\t}\n\tif(x==1){\n\t\tfor(int i=1;i<=n-1;++i)f[x][i]=(zero[x][i]?0:tem[x][i]);\n\t\treturn;\n\t}\n\tfor(int i=1;i<=n-1;++i)f[x][i]=(zero[x][i]?0:tem[x][i]);\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(b[i]!=F){\n\t\t\tfor(int j=1,sum=0,all=0;j<=n-1;++j){\n\t\t\t\tsum=add(f[b[i]][j],sum);\n\t\t\t\tf[x][j]=add(f[x][j],mul(all,f[b[i]][j]));\n\t\t\t\tall=add(all,((sum!=0)?(zero[x][j]?0:mul(tem[x][j],qsm(sum,P-2))):(zero[x][j]==1?tem[x][j]:0)));\n\t\t\t}\n\t\t}\n\t// printf(\"dfs %d: \",x);\n\t// for(int i=1;i<n;++i)printf(\"%d \",f[x][i]);putchar('\\n');\n}\nint C[2010][2010];\nint main(){\n\tscanf(\"%d%d\",&n,&P);\n\tfor(int i=0;i<=n;++i){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;++j)\n\t\t\tC[i][j]=add(C[i-1][j],C[i-1][j-1]);\n\t}\n\tfor(int i=1,u,v;i<n;++i)scanf(\"%d%d\",&u,&v),push(u,v),push(v,u);\n\tdfs(1,0);\n\tfor(int i=1;i<=n-1;++i){\n\t\tfor(int j=1;j<i;++j)\n\t\t\tf[1][i]=sub(f[1][i],mul(f[1][j],C[i][j]));\n\t\tprintf(\"%d \",f[1][i]);\n\t}\n}"], "input": "", "output": "", "tags": ["combinatorics", "dfs and similar", "dp", "math", "trees"], "dificulty": "3000", "interactive": false}