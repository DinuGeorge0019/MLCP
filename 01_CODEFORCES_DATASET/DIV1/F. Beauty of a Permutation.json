{"link": "https://codeforces.com//contest/1205/problem/F", "problemId": "390602", "problem_idx": "F", "shortId": "1205F", "contest_number": "1205", "problem_submissions": {"B": [59042855, 59008277, 59009392, 59009099, 59017750, 59011582, 59017246, 59016172, 59010044, 59012507, 59016410, 59014372, 59018459, 59016311, 59014609, 59017774, 59016256, 59018790, 59017251, 59019103], "F": [59040509, 83365787, 73837920, 59054768, 59706336, 59497174, 59084173, 59131512], "E": [59035128, 59036458, 59034704, 59041033, 59039150, 59045402, 59080765, 59062429], "D": [59016188, 59026535, 59028832, 59032222, 59023841, 59032667, 59050800, 59047976, 59037746, 59038899, 59036700, 59037946, 59034393, 59042000, 59040164, 59037017, 59039734, 59041481, 59041292, 59040370, 59040328], "A": [59004226, 59002142, 59002328, 59003907, 59002592, 59003675, 59003063, 59008409, 59005394, 59004820, 59012388, 59002589, 59006476, 59006648, 59014700, 59002817, 59005001, 59008957, 59004360, 59003394], "C": [59022089, 59020944, 59025032, 59033727, 59026494, 59026517, 59028041, 59025931, 59027756, 59033147, 59024700, 59031289, 59032853, 59030231, 59031302, 59030790, 59030100, 59029442, 59031718]}, "name": "F. Beauty of a Permutation", "statement": "Define the beauty of a permutation of numbers from 1 to n (p_1, p_2,\r\ndots, p_n) as number of pairs (L, R) such that 1\r\nle L\r\nle R\r\nle n and numbers p_L, p_{L+1},\r\ndots, p_R are consecutive R-L+1 numbers in some order. For example, the\r\nbeauty of the permutation (1, 2, 5, 3, 4) equals 9, and segments,\r\ncorresponding to pairs, are [1], [2], [5], [4], [3], [1, 2], [3, 4], [5,\r\n3, 4], [1, 2, 5, 3, 4].Answer q independent queries. In each query, you\r\nwill be given integers n and k. Determine if there exists a permutation\r\nof numbers from 1 to n with beauty equal to k, and if there exists,\r\noutput one of them.\r\n", "solutions": ["#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\npii h[105][105*107/2];\nint q,N[SZ],K[SZ];\nvector<int> aa[SZ];\nvector<int> qry[105][105*107/2];\nvector<int> ch[SZ];\nint an=0,ty[SZ];\nvector<int> op;\nvoid dfs(int w,int d=0)\n{\n//\tcerr<<w<<\"!\"<<ty[w]<<\":\";\n//\tfor(auto c:ch[w]) cout<<c<<\",\";\n//\tcout<<\"\\n\";\n\tif(!ch[w].size())\n\t{\n\t\top.pb(w);\n\t\treturn;\n\t}\n\tif(ty[w]==1)\n\t{\n\t\tvector<int> sb;\n\t\tint s=ch[w].size();\n\t\tfor(int t=1;t<s;t+=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tsb.pb(ch[w][0]);\n\t\tfor(int t=(s-1)-((s-1)&1);t>0;t-=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n\telse\n\t{\n\t\tvector<int> sb;\n\t\tfor(auto r:ch[w]) sb.pb(r);\n\t\tif(d) reverse(sb.begin(),sb.end());\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n}\nvector<int> cons(int n,int p)\n{\n//\tcerr<<n<<\",\"<<p<<\"\\n\";\n\tan=n;\n\tvector<int> st;\n\tfor(int i=1;i<=n;++i) ty[i]=0,ch[i].clear(),st.pb(i);\n\tint X=1,Y=p;\n\twhile(X!=n)\n\t{\n\t\tpii g=h[X][Y];\n\t\tassert(g.fi!=-1);\n\t\tint y=g.se%2; g.se/=2;\n\t\tint c=g.fi-X+1;\n\t\ttie(X,Y)=g;\n\t\t++an; ty[an]=y; ch[an].clear();\n\t\tfor(int j=1;j<=c;++j)\n\t\t\tch[an].pb(st.back()),st.pop_back();\n\t\treverse(ch[an].begin(),ch[an].end());\n\t\tst.pb(an);\n\t}\n\tassert(Y==n&&st.size()==1);\n\top.clear();\n\tdfs(an);\n\t#ifdef LOCAL\n\t#warning \"LOCAL ON\"\n\tassert(op.size()==n);\n\tint sb=0;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tvector<int> g;\n\t\tfor(int j=i;j<n;++j)\n\t\t{\n\t\t\tg.pb(op[j]);\n\t\t\tsort(g.begin(),g.end());\n\t\t\tbool ok=1;\n\t\t\tfor(int w=0;w<g.size();++w)\n\t\t\t\tok&=g[w]==g[0]+w;\n\t\t\tif(ok) ++sb;\n\t\t}\n\t}\n//\tcerr<<sb<<\"?\\n\";\n\tassert(sb==p);\n\t#endif\n\treturn op;\n}\nint main()\n{\n\tscanf(\"%d\",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(\"%d%d\",N+i,K+i),\n\t\tqry[N[i]][K[i]].pb(i);\n\tfor(int n=1;n<=100;++n)\n\t{\n\tmemset(h,-1,sizeof h);\n\th[n][n]=pii(0,0);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tfor(int j=n*(n+1)/2;j>=0;--j) if(~h[i][j].fi)\n\t\t{\n\t\t\tfor(int c=2;c<=i;++c)\n\t\t\t{\n\t\t\t\th[i-c+1][j+c*(c-1)/2]=pii(i,j*2);\n\t\t\t\tif(c>=4) h[i-c+1][j+1]=pii(i,j*2+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=n*(n+1)/2;j>=0;--j)\n\t\tif(h[1][j].fi!=-1&&qry[n][j].size())\n\t\t{\n\t\t\tauto u=cons(n,j);\n\t\t\tfor(auto r:qry[n][j]) aa[r]=u;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i)\n\t\tif(aa[i].size())\n\t\t{\n\t\t\tputs(\"YES\");\n\t\t\tfor(auto x:aa[i])\n\t\t\t\tprintf(\"%d \",x);\n\t\t\tputs(\"\");\n\t\t}\n\t\telse\n\t\t\tputs(\"NO\");\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "3400", "interactive": false}