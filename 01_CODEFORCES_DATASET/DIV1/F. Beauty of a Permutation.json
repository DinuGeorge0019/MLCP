{
    "link": "https://codeforces.com//contest/1205/problem/F",
    "problemId": "390602",
    "problem_idx": "F",
    "shortId": "1205F",
    "contest_number": "1205",
    "problem_submissions": {
        "B": [
            59042855,
            59008277,
            59009392,
            59009099,
            59017750,
            59011582,
            59017246,
            59016172,
            59010044,
            59012507,
            59016410,
            59014372,
            59018459,
            59016311,
            59014609,
            59017774,
            59016256,
            59018790,
            59017251,
            59019103
        ],
        "F": [
            59040509,
            83365787,
            73837920,
            59054768,
            59706336,
            59497174,
            59084173,
            59131512
        ],
        "E": [
            59035128,
            59036458,
            59034704,
            59041033,
            59039150,
            59045402,
            59080765,
            59062429
        ],
        "D": [
            59016188,
            59026535,
            59028832,
            59032222,
            59023841,
            59032667,
            59050800,
            59047976,
            59037746,
            59038899,
            59036700,
            59037946,
            59034393,
            59042000,
            59040164,
            59037017,
            59039734,
            59041481,
            59041292,
            59040370,
            59040328
        ],
        "A": [
            59004226,
            59002142,
            59002328,
            59003907,
            59002592,
            59003675,
            59003063,
            59008409,
            59005394,
            59004820,
            59012388,
            59002589,
            59006476,
            59006648,
            59014700,
            59002817,
            59005001,
            59008957,
            59004360,
            59003394
        ],
        "C": [
            59022089,
            59020944,
            59025032,
            59033727,
            59026494,
            59026517,
            59028041,
            59025931,
            59027756,
            59033147,
            59024700,
            59031289,
            59032853,
            59030231,
            59031302,
            59030790,
            59030100,
            59029442,
            59031718
        ]
    },
    "name": "F. Beauty of a Permutation",
    "statement": "Define the beauty of a permutation of numbers from 1 to n (p_1, p_2,\r\ndots, p_n) as number of pairs (L, R) such that 1\r\nle L\r\nle R\r\nle n and numbers p_L, p_{L+1},\r\ndots, p_R are consecutive R-L+1 numbers in some order. For example, the\r\nbeauty of the permutation (1, 2, 5, 3, 4) equals 9, and segments,\r\ncorresponding to pairs, are [1], [2], [5], [4], [3], [1, 2], [3, 4], [5,\r\n3, 4], [1, 2, 5, 3, 4].Answer q independent queries. In each query, you\r\nwill be given integers n and k. Determine if there exists a permutation\r\nof numbers from 1 to n with beauty equal to k, and if there exists,\r\noutput one of them.\r\n",
    "solutions": [
        "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\npii h[105][105*107/2];\nint q,N[SZ],K[SZ];\nvector<int> aa[SZ];\nvector<int> qry[105][105*107/2];\nvector<int> ch[SZ];\nint an=0,ty[SZ];\nvector<int> op;\nvoid dfs(int w,int d=0)\n{\n//\tcerr<<w<<\"!\"<<ty[w]<<\":\";\n//\tfor(auto c:ch[w]) cout<<c<<\",\";\n//\tcout<<\"\\n\";\n\tif(!ch[w].size())\n\t{\n\t\top.pb(w);\n\t\treturn;\n\t}\n\tif(ty[w]==1)\n\t{\n\t\tvector<int> sb;\n\t\tint s=ch[w].size();\n\t\tfor(int t=1;t<s;t+=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tsb.pb(ch[w][0]);\n\t\tfor(int t=(s-1)-((s-1)&1);t>0;t-=2)\n\t\t\tsb.pb(ch[w][t]);\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n\telse\n\t{\n\t\tvector<int> sb;\n\t\tfor(auto r:ch[w]) sb.pb(r);\n\t\tif(d) reverse(sb.begin(),sb.end());\n\t\tfor(auto r:sb) dfs(r,d^1);\n\t}\n}\nvector<int> cons(int n,int p)\n{\n//\tcerr<<n<<\",\"<<p<<\"\\n\";\n\tan=n;\n\tvector<int> st;\n\tfor(int i=1;i<=n;++i) ty[i]=0,ch[i].clear(),st.pb(i);\n\tint X=1,Y=p;\n\twhile(X!=n)\n\t{\n\t\tpii g=h[X][Y];\n\t\tassert(g.fi!=-1);\n\t\tint y=g.se%2; g.se/=2;\n\t\tint c=g.fi-X+1;\n\t\ttie(X,Y)=g;\n\t\t++an; ty[an]=y; ch[an].clear();\n\t\tfor(int j=1;j<=c;++j)\n\t\t\tch[an].pb(st.back()),st.pop_back();\n\t\treverse(ch[an].begin(),ch[an].end());\n\t\tst.pb(an);\n\t}\n\tassert(Y==n&&st.size()==1);\n\top.clear();\n\tdfs(an);\n\t#ifdef LOCAL\n\t#warning \"LOCAL ON\"\n\tassert(op.size()==n);\n\tint sb=0;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tvector<int> g;\n\t\tfor(int j=i;j<n;++j)\n\t\t{\n\t\t\tg.pb(op[j]);\n\t\t\tsort(g.begin(),g.end());\n\t\t\tbool ok=1;\n\t\t\tfor(int w=0;w<g.size();++w)\n\t\t\t\tok&=g[w]==g[0]+w;\n\t\t\tif(ok) ++sb;\n\t\t}\n\t}\n//\tcerr<<sb<<\"?\\n\";\n\tassert(sb==p);\n\t#endif\n\treturn op;\n}\nint main()\n{\n\tscanf(\"%d\",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(\"%d%d\",N+i,K+i),\n\t\tqry[N[i]][K[i]].pb(i);\n\tfor(int n=1;n<=100;++n)\n\t{\n\tmemset(h,-1,sizeof h);\n\th[n][n]=pii(0,0);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tfor(int j=n*(n+1)/2;j>=0;--j) if(~h[i][j].fi)\n\t\t{\n\t\t\tfor(int c=2;c<=i;++c)\n\t\t\t{\n\t\t\t\th[i-c+1][j+c*(c-1)/2]=pii(i,j*2);\n\t\t\t\tif(c>=4) h[i-c+1][j+1]=pii(i,j*2+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=n*(n+1)/2;j>=0;--j)\n\t\tif(h[1][j].fi!=-1&&qry[n][j].size())\n\t\t{\n\t\t\tauto u=cons(n,j);\n\t\t\tfor(auto r:qry[n][j]) aa[r]=u;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i)\n\t\tif(aa[i].size())\n\t\t{\n\t\t\tputs(\"YES\");\n\t\t\tfor(auto x:aa[i])\n\t\t\t\tprintf(\"%d \",x);\n\t\t\tputs(\"\");\n\t\t}\n\t\telse\n\t\t\tputs(\"NO\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Beauty of a Permutation.json",
    "editorial_link": "https://codeforces.com/blog/entry/69158",
    "editorial": "We will denote if there exists a permutation of length with beauty equal\r\nto . To begin with, it is obvious that the beauty of a permutation of\r\nlength is at least for : indeed, you can take each element individually\r\nand the entire permutation completely.** Statement 1 **: if and , then\r\n.Let be a permutation of length , whose beauty is , and be a permutation\r\nof length , whose beauty is equal to . Let us build from them a\r\npermutation of length , whose beauty is . We \"expand\" in the permutation\r\nto , and to the rest of the elements , greater than , add . We got a\r\npermutation of length . Denote it by . If is not between , then we\r\nreverse the first elements, and this will be done in a new permutation.\r\nNow let be between , . Then what good pairs do we have in ? There are\r\ngood pairs among the first elements, there are good pairs if you count\r\nthe first elements in one, and we counted the interval from the first\r\nelements twice, so we counted pairs At the same time, this is all pairs,\r\nbecause if some good segment contains and , then it must contain as\r\nwell. Thus, this statement is proved.** Statement 2 **: if , then either\r\n, or , or exist , such that , and .Show it. We will call subsegments\r\nconsisting of several consecutive numbers in some order . Consider some\r\nkind of permutation of length of beauty . Suppose that .We want to show\r\nthat in the permutation there is some good subsegment of length not\r\nequal to or , with the following property: for any other good subsegment\r\nif and intersect, then one of them contains the second. In this case, by\r\nanalogy with the proof of Proposition 1, we can \"squeeze\" the segment\r\ninto one element, obtaining some kind of permutation . Then the number\r\nof good segments in the entire permutation will be equal to the number\r\nof good sub-segments on the segment the number of good segments in\r\n(since we counted the segment twice). We will call such a segment .\r\nThus, if in each permutation there is , then the statement is\r\ntrue.Suppose that , then in the permutation there is a good segment of\r\nlength not equal to or . Let\u00e2\u0080\u0099s say he\u00e2\u0080\u0099s not very good. Then there is\r\nanother. We denote if there exists a permutation of length with beauty\r\nequal to . To begin with, it is obvious that the beauty of a permutation\r\nof length is at least for : indeed, you can take each element\r\nindividually and the entire permutation completely.** Statement 1 **: if\r\nand , then .Let & mdash; a permutation of length , whose beauty is , and\r\n& mdash; a permutation of length , whose beauty is equal to . Let us\r\nbuild from them a permutation of length , whose beauty is . We \"expand\"\r\nin the permutation to , and to the rest of the elements , greater than ,\r\nadd . We got a permutation of length . Denote it by . If is not between\r\n, then we reverse the first elements, and this will be done in a new\r\npermutation. Now let be between , . Then what good pairs do we have in ?\r\nThere are good pairs among the first elements, there are good pairs if\r\nyou count the first elements in one, and we counted the interval from\r\nthe first elements twice, so we counted pairs At the same time, this is\r\nall pairs, because if some good segment contains and , then it must\r\ncontain as well. Thus, this statement is proved.** Statement 2 **: if ,\r\nthen either , or , or , such that , and .Show it. We will call\r\nsubsegments consisting of several consecutive numbers in some order .\r\nConsider some kind of permutation of length of beauty . Suppose that .We\r\nwant to show that in the permutation there is some good subsegment of\r\nlength not equal to or , with the following property: for any other good\r\nsubsegment if and intersect, then one of them contains the second. In\r\nthis case, by analogy with the proof of Proposition 1, we can \"squeeze\"\r\nthe segment into one element, obtaining some kind of permutation . Then\r\nthe number of good segments in the entire permutation will be equal to\r\nthe number of good sub-segments on the segment the number of good\r\nsegments in (since we counted the segment twice). We will call such a\r\nsegment . Thus, if in each permutation there is , then the statement is\r\ntrue.Let be a good segment that is not very good. Then there is a good\r\nsegment , which intersects with , but does not contain and is not\r\ncontained in it. The segments and form together segment . It is easy to\r\nshow that each of them is good, and the numbers in the segments go\r\nmonotonously. Let us demonstrate this with an example: , the first\r\nsegment is , the second is . Then together they will give the union of\r\nthree segments: . As we can see, each of these segments is good, and\r\nalso all numbers in the second segment are larger than all numbers in\r\nthe first, all numbers in the third segment are larger than all numbers\r\nin the second.Let at the moment we have lined up a chain of good\r\nsegments (going consecutively) , where the union of any several\r\nconsecutive ones is a good segment, as well as all the numbers in more\r\nthan all the numbers in (or vice versa). As long as is not equal to the\r\nwhole segment, we will do this: since is very good, there is a segment\r\nthat intersects with it but is not contained in it does not contain. It\r\nis easy to see that, thanks to the segment , our chain of good segments\r\nis extended.Now suppose that is the whole segment. While there is a\r\nsegment of length greater than among the segments, we will do the same:\r\nif , then we will find the necessary for it, then will be split into two\r\nsmaller good segments .At the end of the process, we get good segments\r\nof length each, and the numbers are sorted monotonously. Hence, the\r\nnumbers in the permutation were initially sorted monotonously, whence\r\nthe number of good segments is . The statement is proved.Now the left is\r\neasy: for each from to , we calculate what beauty values can be in a\r\npermutation of length using statement , storing the corresponding values\r\n. After that, it is easy to answer the request by building a permutation\r\nof the desired beauty according to the algorithm with the approval of\r\n.Asymptotics of (With an incredibly small constant, up to on this works\r\nfor 300 ms).Challenge: improve the asymptotics to (works in less than 30\r\nms).\r\n"
}