{
    "link": "https://codeforces.com//contest/89/problem/C",
    "problemId": "471",
    "problem_idx": "C",
    "shortId": "89C",
    "contest_number": "89",
    "problem_submissions": {
        "D": [
            492261,
            492054,
            491644,
            492548,
            491919,
            491966,
            492524,
            492023,
            492270,
            493211
        ],
        "C": [
            491274,
            491590,
            494170,
            491155,
            494716,
            494714,
            493157,
            493915,
            493856,
            491944,
            492125,
            491378,
            493230,
            494090,
            494024,
            492438
        ],
        "B": [
            490604,
            490688,
            493051,
            493381,
            493248,
            493828,
            491678,
            490992,
            493466,
            493681,
            491186,
            492876,
            492435,
            494470,
            494439,
            493776
        ],
        "A": [
            489185,
            489155,
            490046,
            490404,
            490021,
            489082,
            490779,
            489569,
            490295,
            489887,
            489342,
            493955,
            489473,
            496907
        ]
    },
    "name": "C. Chip Play",
    "statement": "Let\u2019s consider the following game. We have a rectangular field in size.\r\nSome squares of the field contain chips.Each chip has an arrow painted\r\non it. Thus, each chip on the field points in one of the following\r\ndirections: up, down, left or right.The player may choose a chip and\r\nmake a move with it.The move is the following sequence of actions. The\r\nchosen chip is marked as the current one. After that the player checks\r\nwhether there are more chips in the same row (or in the same column)\r\nwith the current one that are pointed by the arrow on the current chip.\r\nIf there is at least one chip then the closest of them is marked as the\r\nnew current chip and the former current chip is removed from the field.\r\nAfter that the check is repeated. This process can be repeated several\r\ntimes. If a new chip is not found, then the current chip is removed from\r\nthe field and the player\u2019s move ends.By the end of a move the player\r\nreceives several points equal to the number of the deleted chips.By the\r\ngiven initial chip arrangement determine the maximum number of points\r\nthat a player can receive during one move. Also determine the number of\r\nsuch moves.\r\n",
    "solutions": [
        "#include<stdio.h>\nchar in[5010][5010];\nshort xp[5010][5010],xn[5010][5010];\nshort yp[5010][5010],yn[5010][5010];\ninline void del(int x,int y){\n    xn[xp[x][y]][y]=xn[x][y];\n    xp[xn[x][y]][y]=xp[x][y];\n    yn[x][yp[x][y]]=yn[x][y];\n    yp[x][yn[x][y]]=yp[x][y];\n}\ninline void add(int x,int y){\n    xn[xp[x][y]][y]=x;\n    xp[xn[x][y]][y]=x;\n    yn[x][yp[x][y]]=y;\n    yp[x][yn[x][y]]=y;\n}\nint n,m;\ninline int go(int x,int y){\n    if(x==0||y==0||x==n+1||y==m+1)return 0;\n    del(x,y);\n    int d;\n    if(in[x][y]=='D')d=go(xn[x][y],y);\n    else if(in[x][y]=='U')d=go(xp[x][y],y);\n    else if(in[x][y]=='R')d=go(x,yn[x][y]);\n    else if(in[x][y]=='L')d=go(x,yp[x][y]);\n    add(x,y);\n    return d+1;\n}\nint main(){\n    int i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=n;i++)scanf(\"%s\",in[i]+1);\n    for(i=1;i<=n;i++){\n\tint p=0;\n\tfor(j=1;j<=m+1;j++){\n\t    if(in[i][j]!='.'){\n\t\tyn[i][p]=j;\n\t\typ[i][j]=p;\n\t\tp=j;\n\t    }\n\t}\n    }\n    for(j=1;j<=m;j++){\n\tint p=0;\n\tfor(i=1;i<=n+1;i++){\n\t    if(in[i][j]!='.'){\n\t\txn[p][j]=i;\n\t\txp[i][j]=p;\n\t\tp=i;\n\t    }\n\t}\n    }\n    int ans=0,ac=0;\n    for(i=1;i<=n;i++){\n\tfor(j=1;j<=m;j++){\n\t    if(in[i][j]!='.'){\n\t\tint d=go(i,j);\n\t\tif(d>ans){\n\t\t    ans=d;ac=1;\n\t\t}else if(d==ans)ac++;\n\t    }\n\t}\n    }\n    printf(\"%d %d\\n\",ans,ac);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Chip Play.json",
    "editorial_link": "https://codeforces.com//blog/entry/2162",
    "editorial": "This problem can be solved by simulation. You can just iterate over all chips and for every of them calculate number of points. But srupid simulate can give O(k3) time solution, where k is total number of chips. It doesn't fit into time limits. For example, try test like\n\n1 5000\nRRRR...[2500 times]LLLL...[2500 times]\n\nYou can simulate process in  time by using some data structures like std::set, but it doesn't fit into limits too.\n\nSimilating in O(k2) time is given by following data structure.\n\nFor every chip you can save links to chips that is placed up, doun, left and right from the considered chip. Net of links can be built in O(nm). Now, when you simulate process, you can remove chips this way:\n\nChip->L->R = Chip->R\nChip->R->L = Chip->L\nChip->U->D = Chip->D\nChip->D->U = Chip->U\n\nSo, jump from some chip to the next chip in a move can be done in O(1). Now you can simulate every move in O(k).\n\nRemove operation is reversible because every removed chip stores links to all of its neighbours. Therefore you can save links to all removed chips in current move and after restore net of links using following operetions for all removed chips in reversed order\n\nChip->L->R = Chip\nChip->R->L = Chip\nChip->U->D = Chip\nChip->D->U = Chip\n\nAlso you can just build net of links anew for every move."
}