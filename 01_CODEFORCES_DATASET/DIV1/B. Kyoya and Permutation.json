{
    "link": "https://codeforces.com//contest/553/problem/B",
    "problemId": "30214",
    "problem_idx": "B",
    "shortId": "553B",
    "contest_number": "553",
    "problem_submissions": {
        "D": [
            11744562,
            11744498,
            11745257,
            11745223,
            11745470,
            11745572,
            11744919,
            11745032,
            11745427,
            11746100,
            11746456,
            11746392,
            11746335,
            11745162,
            11746455,
            11746854,
            11746886,
            11745082
        ],
        "C": [
            11742306,
            11742552,
            11743239,
            11743506,
            11742528,
            11742781,
            11742831,
            11741480,
            11743177,
            11743672,
            11744065,
            11743860,
            11743962,
            11742856,
            11745114,
            11744324,
            11744734,
            11743321
        ],
        "B": [
            11740294,
            11741146,
            11741320,
            11741933,
            11744161,
            11741212,
            11741622,
            11743234,
            11743626,
            11740923,
            11740570,
            11741924,
            11742141,
            11741812,
            11743960,
            11742897,
            11743061,
            11741732
        ],
        "A": [
            11739123,
            11739635,
            11739748,
            11739276,
            11740077,
            11739044,
            11739303,
            11739327,
            11739192,
            11744185,
            11739212,
            11740023,
            11739776,
            11740185,
            11741127,
            11739503,
            11739666
        ],
        "E": [
            11751187,
            11762331
        ]
    },
    "name": "B. Kyoya and Permutation",
    "statement": "Let\u2019s define the permutation of length as an array consisting of\r\ndistinct integers from range from to . We say that this permutation maps\r\nvalue into the value , value into the value and so on.Kyota Ootori has\r\njust learned about of a permutation. A is a sequence of numbers such\r\nthat each element of this sequence is being mapped into the next element\r\nof this sequence (and the last element of the cycle is being mapped into\r\nthe first element of the cycle). The is a representation of as a\r\ncollection of cycles forming . For example, permutation has a that looks\r\nlike because 1 is replaced by 4, 4 is replaced by 2, 2 is replaced by 1,\r\n3 and 6 are swapped, and 5 remains in place. Permutation may have\r\nseveral cyclic representations, so Kyoya defines the of a permutation as\r\nfollows. First, reorder the elements within each cycle so the largest\r\nelement is first. Then, reorder all of the cycles so they are sorted by\r\ntheir first element. For our example above, the of is .Now, Kyoya\r\nnotices that if we drop the parenthesis in the standard cyclic\r\nrepresentation, we get another permutation! For instance, will become\r\n.Kyoya notices that some permutations don\u2019t change after applying\r\noperation described above at all. He wrote all permutations of length\r\nthat do not change in a list in lexicographic order. Unfortunately, his\r\nfriend Tamaki Suoh lost this list. Kyoya wishes to reproduce the list\r\nand he needs your help. Given the integers and , print the permutation\r\nthat was -th on Kyoya\u2019s list.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[2000];\n\nint main() {\n\tdp[0] = 1;\n\tdp[1] = 1;\n\tint N; cin >> N;\n\tfor(int i = 2; i <= N + 2; i++) {\n\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t}\n\n\tll K; cin >> K;\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tif(K > dp[N - i]) {\n\t\t\tK -= dp[N - i];\n\t\t\tcout << i + 1 << ' ' << i << ' ';\n\t\t\ti++;\n\t\t} else {\n\t\t\tcout << i << ' ';\n\t\t}\n\t}\n\n\tassert(K == 1);\n\n\tcout << '\\n';\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Kyoya and Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/18842",
    "editorial": "Solving this requires making the observation that only swaps between\r\nadjacent elements are allowed, and all of these swaps must be disjoint.\r\nThis can be discovered by writing a brute force program, or just\r\nnoticing the pattern for small . Here\u00e2\u0080\u0099s a proof for why this is.\r\nConsider the cycle that contains . Since is the largest number, it must\r\nbe the last cycle in the sequence, and it\u00e2\u0080\u0099s the first element of the\r\nsequence. If this cycle is length 1, then we\u00e2\u0080\u0099re obviously ok (we can\r\nalways append to the end). If the cycle is of length 2, we need to be\r\ninvolved in a cycle with . Lastly, if the cycle is of length 3 or more,\r\nwe will see we run into a problem. We\u00e2\u0080\u0099ll only show this for a cycle of\r\nlength 3 (though this argument does generalize to cycles of larger\r\nlength). Let be the cycle. So that means, is replaced by , is replaced\r\nby and is replaced by . So, in other words, the original permutation\r\ninvolving this cycle must look like However, we need it to look like so\r\nthis case is impossible. So, once we know that is a in a cycle of length\r\nor , we can ignore the last 1 or 2 elements of the permutation and\r\nrepeat our reasoning. Thus, the only valid cases are when we swap\r\nadjacent elements, and all swaps are disjoint. After making this\r\nobservation, we can see the number of valid permutations of length n is\r\nfib(n+1). (to see this, write try writing a recurrence). To reconstruct\r\nthe kth permutation in the list, we can do this recursively as follows:\r\nIf k is less than fib(n), then must be the very first element, and\r\nappend the th permutation on {1,...,n-1} with 1 added everywhere.\r\nOtherwise, add to the very front and append the k-fib(n)th permutation\r\non {1,...,n-2} with 2 added everywhere. Example code:\r\nhttp://codeforces.com/contest/553/submission/11767583\r\n"
}