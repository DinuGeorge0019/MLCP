{
    "link": "https://codeforces.com//contest/891/problem/D",
    "problemId": "134543",
    "problem_idx": "D",
    "shortId": "891D",
    "contest_number": "891",
    "problem_submissions": {
        "D": [
            32405811,
            32403732,
            32402138,
            32430714,
            32405646
        ],
        "B": [
            32397173,
            32384884,
            32383268,
            32389067,
            32402095,
            32392144,
            32390145,
            32392706,
            32386797,
            32391950,
            32394619,
            32391275,
            32387784,
            32402908,
            32394168,
            32390852,
            32393424,
            32402498,
            32390071,
            32396268
        ],
        "C": [
            32396218,
            32388086,
            32389360,
            32395431,
            32392168,
            32396723,
            32397239,
            32390965,
            32393675,
            32398647,
            32398521,
            32396975,
            32390007,
            32404522,
            32396953,
            32387277,
            32386884,
            32403069
        ],
        "A": [
            32391368,
            32389450,
            32385263,
            32382597,
            32388551,
            32393309,
            32385252,
            32391318,
            32384125,
            32393321,
            32386822,
            32382673,
            32385160,
            32385074,
            32382459,
            32389480,
            32400282,
            32382452,
            32383065
        ],
        "E": [
            32389900,
            32397841,
            32401538,
            32399718,
            32400691,
            32399515,
            32401892,
            32401660,
            32405427,
            32400764,
            32394075,
            32405328,
            32405995,
            32402118,
            32511522,
            32397327
        ]
    },
    "name": "D. Sloth",
    "statement": "Sloth is bad, mkay? So we decided to prepare a problem to punish lazy\r\nguys.You are given a tree, you should count the number of ways to remove\r\nan edge from it and then add an edge to it such that the final graph is\r\na tree and has a perfect matching. Two ways of this operation are\r\nconsidered different if their removed edges or their added edges aren\u2019t\r\nthe same. The removed edge and the added edge can be equal.A perfect\r\nmatching is a subset of edges such that each vertex is an endpoint of\r\nexactly one of these edges.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=501000;\n////// fuck\nint n,u,v,par[N],ev[N],sz[N],ret[N];\nPII dp[N],pd[N],fp[N],fs[N];\nll ans;\nVI e[N];\nPII gao(PII a,PII b) {\n\tif (a.fi>b.fi) return a;\n\telse if (a.fi<b.fi) return b;\n\telse return mp(a.fi,a.se+b.se);\n}\nvoid dfs(int u,int f) {\n\tpar[u]=1;\n\tsz[u]=1;\n\tev[u]=0;\n\tdp[u]=mp(0,1);\n\tfor (auto v:e[u]) if (v!=f) {\n\t\tdfs(v,u);\n\t\tpar[u]^=par[v];\n\t\tsz[u]+=sz[v];\n\t\tev[u]+=ev[v];\n\t\tif (par[v]==0) {\n\t\t\t// even\n\t\t\tev[u]++;\n\t\t\tdp[u]=gao(dp[u],mp(dp[v].fi-1,dp[v].se));\n\t\t} else {\n\t\t\tdp[u]=gao(dp[u],mp(dp[v].fi+1,dp[v].se));\n\t\t}\n\t}\n\tif (par[u]==1) {\n\t\tassert(ev[u]+dp[u].fi<=sz[u]/2);\n\t\tif (ev[u]+dp[u].fi!=sz[u]/2) ret[u]=0;\n\t\telse ret[u]=dp[u].se;\n\t}\n}\nvoid dfs2(int u,int f) {\n\tVI s; s.pb(u);\n\tfor (auto v:e[u]) if (v!=f) {\n\t\ts.pb(v);\n\t}\n\tint m=SZ(s);\n\tfp[0]=gao(pd[u],mp(0,1));\n\trep(i,1,m) {\n\t\tint v=s[i];\n\t\tif (par[v]==0) fp[i]=gao(fp[i-1],mp(dp[v].fi-1,dp[v].se));\n\t\telse fp[i]=gao(fp[i-1],mp(dp[v].fi+1,dp[v].se));\n\t}\n\tfs[m]=mp(-(1<<30),0);\n\tper(i,1,m) {\n\t\tint v=s[i];\n\t\tif (par[v]==0) fs[i]=gao(fs[i+1],mp(dp[v].fi-1,dp[v].se));\n\t\telse fs[i]=gao(fs[i+1],mp(dp[v].fi+1,dp[v].se));\n\t}\n\trep(i,1,m) {\n\t\tint v=s[i];\n\t\tpd[v]=gao(fp[i-1],fs[i+1]);\n//\t\tprintf(\"gg %d %d %d\\n\",v,pd[v].fi,pd[v].se);\n\t\tif (par[v]==1) {\n\t\t\tassert(ev[1]-ev[v]+pd[v].fi<=(n-sz[v])/2);\n\t\t\tif (ev[1]-ev[v]+pd[v].fi==(n-sz[v])/2) {\n\t\t\t\tans+=(ll)pd[v].se*ret[v];\n\t\t\t}\n\t\t}\n\t\tif (par[v]==0) pd[v].fi--; else pd[v].fi++;\n\t}\n\trep(i,1,m) {\n\t\tint v=s[i];\n\t\tdfs2(v,u);\n\t}\n\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tif (n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tdfs(1,0);\n\tif (ev[1]==n/2-1) {\n\t\trep(i,2,n+1) if (par[i]==0) ans=ans+(ll)sz[i]*(n-sz[i]);\n\t}\n\tdfs2(1,0);\n\tprintf(\"%lld\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graph matchings",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Sloth.json",
    "editorial_link": "https://codeforces.com//blog/entry/55841",
    "editorial": "If graph had odd number of vertices the answer is . Otherwise let\u00e2\u0080\u0099s call\r\nedges that by removing them the remaining graph would have two even\r\ncomponents good, and all the other edges are bad.If you remove a good\r\nedge and put another edge somewhere such that the final graph is a tree,\r\nthen it would have prefect matching if and only if the input tree had\r\nprefect matching.If no two bad edges share a vertex, after removing a\r\nbad edge (lets call it ) we should chose the end points of the edge we\r\nwant to add (lets call them ,) such that the path between and in the\r\ninput tree has alternately bad and good edges, the first and the last\r\nedges in the path are bad and is in this path too. So for any path in\r\nthe tree that has alternately bad and good edges and the first and final\r\nedges in it are bad we should add the to the answer. This can be done\r\nusing dp.If there are bad edges that share vertices, we know that each\r\nvertex has odd number of bad edges to its neighbors, and if this number\r\nis greater than 3 then the answer is 0. So each vertex has 1 or 3 odd\r\nedges to its neighbors. The path between end points of added edge should\r\ncontain all the vertices with 3 bad edges and also two of their bad\r\nedges should be in the path. So if the vertices with 3 bad edges aren\u00e2\u0080\u0099t\r\nin a path with this condition then the answer is 0 and otherwise we can\r\ncalculate the answer by checking some conditions in their path and\r\ncounting the number of paths with some condition at the end points of\r\ntheir path.\r\n"
}