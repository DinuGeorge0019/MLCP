{"link": "https://codeforces.com//contest/1470/problem/E", "problemId": "855306", "problem_idx": "E", "shortId": "1470E", "contest_number": "1470", "problem_submissions": {"E": [103440669, 103450045, 103444324, 103446807, 103456209, 103459429, 103458872, 103449311, 103444803, 103455366, 103427287, 103523513, 103512117, 107007766, 103497278], "C": [103424863, 103419731, 103412394, 103420749, 103473095, 103443608, 103423946, 103436573, 103483233, 103668985, 103426627, 103424859, 103478420, 103478404, 103478387, 103478371, 103478354, 103478316, 103478307, 103478286, 103478261, 103478250, 103415351, 103438274, 103450179, 103434430, 103429394, 103442814, 103435400], "D": [103415926, 103427083, 103428552, 103423208, 103420751, 103429115, 103425438, 103418855, 103424458, 103422509, 103452603, 103410374, 103430035, 103428165, 103418606, 103410543, 103439473, 103434901, 103425306, 103416679], "B": [103406584, 103402617, 103400867, 103408140, 103415671, 103407933, 103428755, 103407002, 103406514, 103413492, 103439686, 103403315, 103398826, 103407557, 103405634, 103400232, 103409460, 103410649, 103414139, 103409541], "A": [103395440, 103396207, 103392457, 120480996, 103397804, 103473156, 103473127, 103399272, 103396942, 103393409, 103401022, 103396664, 103398098, 103431488, 103391970, 103392128, 103393954, 103394467, 103391951, 103398410, 103401147, 103400351, 103410763], "F": [128458334, 128458191, 105649646, 105647576]}, "name": "E. Strange Permutation", "statement": "Alice had a permutation p_1, p_2,\r\nldots, p_n. Unfortunately, the permutation looked very boring, so she\r\ndecided to change it and choose some subranges of this permutation and\r\nreverse them. The cost of reversing a single subrange [l, r] (elements\r\nfrom position l to position r, inclusive) is equal to r - l, and the\r\ncost of the operation is the sum of costs of reversing individual\r\nsubranges. Alice had an integer c in mind, so she only considered\r\noperations that cost no more than c.Then she got bored, and decided to\r\nwrite down all the permutations that she could possibly obtain by\r\nperforming exactly one operation on the initial permutation. Of course,\r\nAlice is very smart, so she wrote down each obtainable permutation\r\nexactly once (no matter in how many ways it can be obtained), and of\r\ncourse the list was sorted lexicographically.Now Bob would like to ask\r\nAlice some questions about her list. Each question is in the following\r\nform: what is the i-th number in the j-th permutation that Alice wrote\r\ndown? Since Alice is too bored to answer these questions, she asked you\r\nto help her out.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 05.01.2021 18:25:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, c, q;\n    cin >> n >> c >> q;\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n      cin >> p[i];\n      --p[i];\n    }\n    vector<vector<long long>> ways(n + 1, vector<long long>(c + 1));\n    for (int j = 0; j <= c; j++) {\n      ways[n][j] = 1;\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      for (int j = 0; j <= c; j++) {\n        ways[i][j] = ways[i + 1][j];\n        for (int k = 1; k <= j; k++) {\n          if (i + k < n) {\n            ways[i][j] += ways[i + k + 1][j - k];\n          }\n        }\n      }\n    }\n    vector<vector<long long>> sumL(c + 1, vector<long long>(n + 1));\n    vector<vector<long long>> sumR(c + 1, vector<long long>(n + 1));\n    for (int rm = 0; rm <= c; rm++) {\n      for (int i = 0; i < n; i++) {\n        sumL[rm][i + 1] = sumL[rm][i];\n        sumR[rm][i + 1] = sumR[rm][i];\n        for (int k = 1; k <= rm; k++) {\n          if (i + k < n) {\n            if (p[i] < p[i + k]) {\n              sumR[rm][i + 1] += ways[i + k + 1][rm - k];\n            } else {\n              sumL[rm][i + 1] += ways[i + k + 1][rm - k];\n            }\n          }\n        }\n      }\n    }\n    vector<int> order;\n    while (q--) {\n      int pos;\n      long long id;\n      cin >> pos >> id;\n      --pos; --id;\n      if (id >= ways[0][c]) {\n        cout << -1 << '\\n';\n        continue;\n      }\n      int ans = -1;\n      int i = 0;\n      int rm = c;\n      while (i < n) {\n        assert(id < ways[i][rm]);\n        int low = i, high = n;\n        while (low < high) {\n          int mid = (low + high + 1) >> 1;\n          if (sumL[rm][mid] - sumL[rm][i] > id || sumR[rm][mid] - sumR[rm][i] > ways[i][rm] - 1 - id) {\n            high = mid - 1;\n          } else {\n            low = mid;\n          }\n        }\n        if (pos < low) {\n          ans = p[pos];\n          break;\n        }\n        id -= sumL[rm][low] - sumL[rm][i];\n        assert(id >= 0 && id < ways[low][rm]);\n        i = low;\n        order.clear();\n        for (int k = 0; k <= rm; k++) {\n          if (i + k < n) {\n            order.push_back(k);\n          }\n        }\n        sort(order.begin(), order.end(), [&](int x, int y) {\n          return p[i + x] < p[i + y];\n        });\n        int shift = -1;\n        for (int v : order) {\n          long long cur = ways[i + v + 1][rm - v];\n          if (id < cur) {\n            shift = v;\n            break;\n          }\n          id -= cur;\n        }\n        assert(shift != -1);\n        assert(shift != 0);\n        if (pos <= i + shift) {\n          ans = p[i + (i + shift) - pos];\n          break;\n        }\n        i += shift + 1;\n        rm -= shift;\n      }\n      assert(ans != -1);\n      cout << ans + 1 << '\\n';\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "combinatorics", "data structures", "dp", "graphs", "implementation", "two pointers"], "dificulty": "3200", "interactive": false}