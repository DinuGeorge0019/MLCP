{
    "link": "https://codeforces.com//contest/1470/problem/E",
    "problemId": "855306",
    "problem_idx": "E",
    "shortId": "1470E",
    "contest_number": "1470",
    "problem_submissions": {
        "E": [
            103440669,
            103450045,
            103444324,
            103446807,
            103456209,
            103459429,
            103458872,
            103449311,
            103444803,
            103455366,
            103427287,
            103523513,
            103512117,
            107007766,
            103497278
        ],
        "C": [
            103424863,
            103419731,
            103412394,
            103420749,
            103473095,
            103443608,
            103423946,
            103436573,
            103483233,
            103668985,
            103426627,
            103424859,
            103478420,
            103478404,
            103478387,
            103478371,
            103478354,
            103478316,
            103478307,
            103478286,
            103478261,
            103478250,
            103415351,
            103438274,
            103450179,
            103434430,
            103429394,
            103442814,
            103435400
        ],
        "D": [
            103415926,
            103427083,
            103428552,
            103423208,
            103420751,
            103429115,
            103425438,
            103418855,
            103424458,
            103422509,
            103452603,
            103410374,
            103430035,
            103428165,
            103418606,
            103410543,
            103439473,
            103434901,
            103425306,
            103416679
        ],
        "B": [
            103406584,
            103402617,
            103400867,
            103408140,
            103415671,
            103407933,
            103428755,
            103407002,
            103406514,
            103413492,
            103439686,
            103403315,
            103398826,
            103407557,
            103405634,
            103400232,
            103409460,
            103410649,
            103414139,
            103409541
        ],
        "A": [
            103395440,
            103396207,
            103392457,
            120480996,
            103397804,
            103473156,
            103473127,
            103399272,
            103396942,
            103393409,
            103401022,
            103396664,
            103398098,
            103431488,
            103391970,
            103392128,
            103393954,
            103394467,
            103391951,
            103398410,
            103401147,
            103400351,
            103410763
        ],
        "F": [
            128458334,
            128458191,
            105649646,
            105647576
        ]
    },
    "name": "E. Strange Permutation",
    "statement": "Alice had a permutation p_1, p_2,\r\nldots, p_n. Unfortunately, the permutation looked very boring, so she\r\ndecided to change it and choose some subranges of this permutation and\r\nreverse them. The cost of reversing a single subrange [l, r] (elements\r\nfrom position l to position r, inclusive) is equal to r - l, and the\r\ncost of the operation is the sum of costs of reversing individual\r\nsubranges. Alice had an integer c in mind, so she only considered\r\noperations that cost no more than c.Then she got bored, and decided to\r\nwrite down all the permutations that she could possibly obtain by\r\nperforming exactly one operation on the initial permutation. Of course,\r\nAlice is very smart, so she wrote down each obtainable permutation\r\nexactly once (no matter in how many ways it can be obtained), and of\r\ncourse the list was sorted lexicographically.Now Bob would like to ask\r\nAlice some questions about her list. Each question is in the following\r\nform: what is the i-th number in the j-th permutation that Alice wrote\r\ndown? Since Alice is too bored to answer these questions, she asked you\r\nto help her out.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 05.01.2021 18:25:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, c, q;\n    cin >> n >> c >> q;\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n      cin >> p[i];\n      --p[i];\n    }\n    vector<vector<long long>> ways(n + 1, vector<long long>(c + 1));\n    for (int j = 0; j <= c; j++) {\n      ways[n][j] = 1;\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      for (int j = 0; j <= c; j++) {\n        ways[i][j] = ways[i + 1][j];\n        for (int k = 1; k <= j; k++) {\n          if (i + k < n) {\n            ways[i][j] += ways[i + k + 1][j - k];\n          }\n        }\n      }\n    }\n    vector<vector<long long>> sumL(c + 1, vector<long long>(n + 1));\n    vector<vector<long long>> sumR(c + 1, vector<long long>(n + 1));\n    for (int rm = 0; rm <= c; rm++) {\n      for (int i = 0; i < n; i++) {\n        sumL[rm][i + 1] = sumL[rm][i];\n        sumR[rm][i + 1] = sumR[rm][i];\n        for (int k = 1; k <= rm; k++) {\n          if (i + k < n) {\n            if (p[i] < p[i + k]) {\n              sumR[rm][i + 1] += ways[i + k + 1][rm - k];\n            } else {\n              sumL[rm][i + 1] += ways[i + k + 1][rm - k];\n            }\n          }\n        }\n      }\n    }\n    vector<int> order;\n    while (q--) {\n      int pos;\n      long long id;\n      cin >> pos >> id;\n      --pos; --id;\n      if (id >= ways[0][c]) {\n        cout << -1 << '\\n';\n        continue;\n      }\n      int ans = -1;\n      int i = 0;\n      int rm = c;\n      while (i < n) {\n        assert(id < ways[i][rm]);\n        int low = i, high = n;\n        while (low < high) {\n          int mid = (low + high + 1) >> 1;\n          if (sumL[rm][mid] - sumL[rm][i] > id || sumR[rm][mid] - sumR[rm][i] > ways[i][rm] - 1 - id) {\n            high = mid - 1;\n          } else {\n            low = mid;\n          }\n        }\n        if (pos < low) {\n          ans = p[pos];\n          break;\n        }\n        id -= sumL[rm][low] - sumL[rm][i];\n        assert(id >= 0 && id < ways[low][rm]);\n        i = low;\n        order.clear();\n        for (int k = 0; k <= rm; k++) {\n          if (i + k < n) {\n            order.push_back(k);\n          }\n        }\n        sort(order.begin(), order.end(), [&](int x, int y) {\n          return p[i + x] < p[i + y];\n        });\n        int shift = -1;\n        for (int v : order) {\n          long long cur = ways[i + v + 1][rm - v];\n          if (id < cur) {\n            shift = v;\n            break;\n          }\n          id -= cur;\n        }\n        assert(shift != -1);\n        assert(shift != 0);\n        if (pos <= i + shift) {\n          ans = p[i + (i + shift) - pos];\n          break;\n        }\n        i += shift + 1;\n        rm -= shift;\n      }\n      assert(ans != -1);\n      cout << ans + 1 << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "data structures",
        "dp",
        "graphs",
        "implementation",
        "two pointers"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Strange Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/86464",
    "editorial": "Let call the cost of rotation of segment value coins.Let\u00e2\u0080\u0099s calculate how\r\nmany ways can we apply to the array of length with total cost less or\r\nequal to . We can fix bars between neighbouring elements of array. There\r\nis a bijection between ways to select of them and ways to apply some not\r\noverlapping rotations with total cost equals . We can see, that the\r\nnumber of ways is equals . Now we can check if the answer to the query\r\nis .It is easy to see, that the answer on query depends only on\r\nconstruction of -th permutation from . This construction can be\r\nrepresented as set of rotations of size not larger than . And the number\r\nof possible rotations in this set doesn\u00e2\u0080\u0099t exceed . If we can answer this\r\nquery for each suffix of , we can determine -th permutation: What is the\r\nleftmost rotation on the suffix of length , if we have coins and we want\r\nto get -th permutation of this suffix. Let\u00e2\u0080\u0099s fix any suffix . We can\r\nbuild a long array consisting of the leftmost rotations in construction\r\nof each permutation of this suffix using not more than coins. It is easy\r\nto see that each rotation will appear on some segment of this array. We\r\ncan determine the length of this segment: if it was the rotation , than\r\nthe length of this segment is . Exactly once happends that there is no\r\nleftmost rotation.For (suffix ) relative order of this segments won\u00e2\u0080\u0099t\r\nchange because we will add to the beginning of each permutation. Only\r\nsegments will appear (rotations ).We can show that new segment will\r\nappear only in the beginning and in the end (because only their first\r\nelement isn\u00e2\u0080\u0099t equal ).We can show that query is equivalent to query\r\nbecause of the structure of this array.In we can build this array using\r\ndeque. We should do this for each .Let\u00e2\u0080\u0099s answer the queries offline\r\nusing the following algorithm: Iterate in order of decreasing (let\u00e2\u0080\u0099s\r\ncall a level set of queries with the same ). Sort queries in order of\r\nincreasing . Using two pointers approach we can move all queries to\r\nanother level and change them to type . If we will remove queries from\r\neach level after answering them, memory will be reduced from to .Total\r\nwork time: . It can be optimized to using another sort algorithms. Also\r\nthere is a solution in and memory with binary search and slower\r\nsolutions with different data structures.\r\n"
}