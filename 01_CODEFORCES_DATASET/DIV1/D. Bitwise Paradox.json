{"link": "https://codeforces.com//contest/1936/problem/D", "problemId": "2503248", "problem_idx": "D", "shortId": "1936D", "contest_number": "1936", "problem_submissions": {"D": [249364690, 248943933, 248953790, 249029415, 248948695, 249384877, 248946718, 249691560, 248955075, 248956184, 248951174, 248957366, 248965278, 248962414, 248959804, 248956212, 248940582, 248972190, 248967537, 248935591, 248968777], "F": [248959624, 248956053, 249024905, 249024791, 249617325, 249616926, 249616449, 249616090], "C": [248923874, 248935905, 248936411, 248923821, 249389527, 249389485, 249389471, 248932096, 249960032, 249959905, 248928496, 248925527, 248927912, 248933135, 248931237, 248927110, 248920757, 248942173, 248944746, 248948052, 248945719, 248954792, 249702139, 249700847, 248946434, 248946276], "B": [248915925, 248925932, 248926756, 248909886, 248921270, 250626935, 248920462, 248915106, 248915547, 248917787, 248924541, 248919814, 248929862, 248928500, 248928933, 248958629, 248930625, 248933889, 248965009, 248934936], "A": [248907152, 248906597, 248909183, 248914647, 248906656, 250627352, 248907025, 248906362, 248923349, 248909550, 248908351, 248909231, 248911552, 248909761, 248918833, 248908591, 248914734, 248920857], "E": [248969738, 248981250, 249019529, 248981225, 248968880, 249091224, 249090696, 252634475, 249522528]}, "name": "D. Bitwise Paradox", "statement": "You are given two arrays a and b of size n along with a fixed integer\r\nv.An interval [l, r] is called a interval if (b_l\r\nmid b_{l+1}\r\nmid\r\nldots\r\nmid b_r)\r\nge v, where | denotes the bitwise OR operation. The of a good interval\r\nis defined as\r\nmax(a_l, a_{l+1},\r\nldots, a_r).You are given q queries of two types: \"\": assign b_i := x;\r\n\"\": find the beauty among all intervals [l_0,r_0] satisfying l\r\nle l_0\r\nle r_0\r\nle r. If there is no suitable good interval, output -1 instead. Please\r\nprocess all queries.\r\n", "solutions": ["// Not my code: https://codeforces.com/contest/1936/submission/248948695\n/**\n *    author:  tourist\n *    created: 29.02.2024 10:23:04\n**/\n#include <bits/stdc++.h>\n \nusing namespace std;\n\nvector<vector<int>> TLE(40000, vector<int>(7));\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n \nconst int inf = int(2e9);\nconst int M = 30;\n \narray<pair<int, int>, M> init;\nint v;\n \nclass segtree {\n public:\n  struct node {\n    array<pair<int, int>, M> pref = init;\n    array<pair<int, int>, M> suf = init;\n    int npref = 1;\n    int nsuf = 1;\n    int mx = 0;\n    int best = inf;\n \n    void apply(int l, int r, pair<int, int> p) {\n      auto [a, b] = p;\n      pref[0] = {b, a};\n      suf[0] = {b, a};\n      npref = nsuf = 1;\n      mx = a;\n      best = (b >= v ? a : inf);\n    }\n  };\n \n  node unite(const node &a, const node &b) const {\n    node res;\n    res.best = min(a.best, b.best);\n    res.mx = max(a.mx, b.mx);\n    int i = 0, j = b.npref - 1;\n    while (i < a.nsuf && j >= 0) {\n      if ((a.suf[i].first | b.pref[j].first) >= v) {\n        res.best = min(res.best, max(a.suf[i].second, b.pref[j].second));\n        j -= 1;\n      } else {\n        i += 1;\n      }\n    }\n    res.pref = a.pref;\n    res.npref = a.npref;\n    for (int j = 0; j < b.npref; j++) {\n      auto [last, c0] = res.pref[res.npref - 1];\n      auto [now, c1] = b.pref[j];\n      if ((last | now) > last) {\n        res.pref[res.npref++] = {last | now, max(a.mx, max(c0, c1))};\n      }\n    }\n    res.suf = b.suf;\n    res.nsuf = b.nsuf;\n    for (int j = 0; j < a.nsuf; j++) {\n      auto [last, c0] = res.suf[res.nsuf - 1];\n      auto [now, c1] = a.suf[j];\n      if ((last | now) > last) {\n        res.suf[res.nsuf++] = {last | now, max(b.mx, max(c0, c1))};\n      }\n    }\n    return res;\n  }\n \n  inline void push(int x, int l, int r) {\n  }\n \n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n \n  int n;\n  vector<node> tree;\n \n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n \n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n \n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n \n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n \n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n \n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n \n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n \n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n \n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n \n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n \n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n \n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n \n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n \n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n \n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n \n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  for (int i = 0; i < M; i++) {\n    init[i] = {-1, -1};\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n >> v;\n    vector<pair<int, int>> p(n);\n    for (int i = 0; i < n; i++) {\n      cin >> p[i].first;\n    }\n    for (int i = 0; i < n; i++) {\n      cin >> p[i].second;\n    }\n    segtree st(p);\n    int q;\n    cin >> q;\n    while (q--) {\n      int op;\n      cin >> op;\n      if (op == 1) {\n        int i, x;\n        cin >> i >> x;\n        --i;\n        p[i].second = x;\n        st.modify(i, i, p[i]);\n      } else {\n        int l, r;\n        cin >> l >> r;\n        --l; --r;\n        auto nd = st.get(l, r);\n        cout << (nd.best == inf ? -1 : nd.best) << '\\n';\n      }\n    }\n  }\n  return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "bitmasks", "data structures", "greedy", "two pointers"], "dificulty": "3100", "interactive": false}