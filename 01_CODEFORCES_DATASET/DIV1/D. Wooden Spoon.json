{"link": "https://codeforces.com//contest/1785/problem/D", "problemId": "1767287", "problem_idx": "D", "shortId": "1785D", "contest_number": "1785", "problem_submissions": {"F": [192340988, 192367706, 192347284, 192344077, 192349198, 192347771, 192385993, 192336126, 192406311, 192343375, 192348787, 192366544, 192344262, 192411258, 192345259, 192363821, 192484658], "E": [192334775, 192378839, 192330680, 192327219, 192332119, 192339722, 192385982, 192341740, 192412077, 192337184, 192336634, 192325309, 192324682, 192330314, 192339341, 192328941, 192342934, 192342640, 192343285, 192338492, 192348718], "D": [192309677, 192304720, 192308363, 192312353, 192300737, 192385972, 192323435, 192411822, 192411698, 192411631, 192411452, 192307092, 192297940, 192289422, 192305735, 192292206, 192306351, 192303021, 192324811, 192312541, 192301962, 192316529, 192316093, 192321567, 192314574], "C": [192301226, 192367208, 192300659, 192294893, 192304774, 192305847, 192385966, 192316174, 192318962, 192301773, 192292324, 192299527, 193510779, 192315363, 192293483, 192308504, 192291605, 192310063, 192307486, 192299043, 192314808, 192308858], "B": [192291042, 192291589, 192316742, 192291514, 192291590, 192385951, 192288659, 192292597, 192289761, 192297426, 192300042, 192305089, 192297247, 192288814, 192295447, 192337551, 192290254, 192297732, 192303838, 192303907, 192291091], "A": [192284331, 192283441, 192283155, 192282660, 192283131, 192385935, 192282844, 192284622, 192283277, 192290652, 192292611, 192296096, 192286915, 192282931, 192283418, 192285228, 192283044, 192283110, 192282987, 192288048, 192282867]}, "name": "D. Wooden Spoon", "statement": "2^n people, numbered with distinct integers from 1 to 2^n, are playing\r\nin a single elimination tournament. The bracket of the tournament is a\r\nfull binary tree of height n with 2^n leaves.When two players meet each\r\nother in a match, a player with the number always wins. The winner of\r\nthe tournament is the player who wins all n their matches.A virtual\r\nconsolation prize \"Wooden Spoon\" is awarded to a player who satisfies\r\nthe following n conditions: they lost their first match; the player who\r\nbeat them lost their second match; the player who beat that player lost\r\ntheir third match;\r\nldots; the player who beat the player from the previous condition lost\r\nthe final match of the tournament. It can be shown that there is always\r\nexactly one player who satisfies these conditions.Consider all possible\r\n(2^n)! arrangements of players into the tournament bracket. For each\r\nplayer, find the number of these arrangements in which they will be\r\nawarded the \"Wooden Spoon\", and print these numbers modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#define M_PI 0\n\ntemplate <typename T> T mod_inv_in_range(T a, T m) {\n\t// assert(0 <= a && a < m);\n\tT x = a, y = m;\n\tT vx = 1, vy = 0;\n\twhile (x) {\n\t\tT k = y / x;\n\t\ty %= x;\n\t\tvy -= k * vx;\n\t\tstd::swap(x, y);\n\t\tstd::swap(vx, vy);\n\t}\n\tassert(y == 1);\n\treturn vy < 0 ? m + vy : vy;\n}\n\ntemplate <typename T> T mod_inv(T a, T m) {\n\ta %= m;\n\ta = a < 0 ? a + m : a;\n\treturn mod_inv_in_range(a, m);\n}\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = mod_inv_in_range(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv -= MOD-o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\n\n/**\n * Author: Andrew He\n * Source: http://neerc.ifmo.ru/trains/toulouse/2017/fft2.pdf\n * Papers about accuracy: http://www.daemonology.net/papers/fft.pdf, http://www.cs.berkeley.edu/~fateman/papers/fftvsothers.pdf\n * For integers rounding works if $(|a| + |b|)\\max(a, b) < \\mathtt{\\sim} 10^9$, or in theory maybe $10^6$.\n */\n\nnamespace ecnerwala {\nnamespace fft {\n\nusing std::swap;\nusing std::vector;\nusing std::min;\nusing std::max;\n\ntemplate<class T> int sz(T&& arg) { using std::size; return int(size(std::forward<T>(arg))); }\ninline int nextPow2(int s) { return 1 << (s > 1 ? 32 - __builtin_clz(s-1) : 0); }\n\n// Complex\ntemplate <typename dbl> struct cplx { /// start-hash\n\tdbl x, y;\n\tcplx(dbl x_ = 0, dbl y_ = 0) : x(x_), y(y_) { }\n\tfriend cplx operator+(cplx a, cplx b) { return cplx(a.x + b.x, a.y + b.y); }\n\tfriend cplx operator-(cplx a, cplx b) { return cplx(a.x - b.x, a.y - b.y); }\n\tfriend cplx operator*(cplx a, cplx b) { return cplx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n\tfriend cplx conj(cplx a) { return cplx(a.x, -a.y); }\n\tfriend cplx inv(cplx a) { dbl n = (a.x*a.x+a.y*a.y); return cplx(a.x/n,-a.y/n); }\n};\n\n// getRoot implementations\ntemplate <typename num> struct getRoot {\n\tstatic num f(int k) = delete;\n};\ntemplate <typename dbl> struct getRoot<cplx<dbl>> {\n\tstatic cplx<dbl> f(int k) {\n\t\tdbl a=2*M_PI/k;\n\t\treturn cplx<dbl>(cos(a),sin(a));\n\t}\n};\ntemplate <int MOD> struct primitive_root {\n\tstatic const int value;\n};\ntemplate <> struct primitive_root<998244353> {\n\tstatic const int value = 3;\n};\ntemplate <int MOD> struct getRoot<modnum<MOD>> {\n\tstatic modnum<MOD> f(int k) {\n\t\tassert((MOD-1)%k == 0);\n\t\treturn pow(modnum<MOD>(primitive_root<MOD>::value), (MOD-1)/k);\n\t}\n};\n\ntemplate <typename num> class fft {\n\tstatic vector<int> rev;\n\tstatic vector<num> rt;\n\npublic:\n\tstatic void init(int n);\n\ttemplate <typename Iterator> static void go(Iterator begin, int n);\n\n\tstatic vector<num> scratch_a;\n\tstatic vector<num> scratch_b;\n};\n\ntemplate <typename num> vector<int> fft<num>::rev({0,1});\ntemplate <typename num> vector<num> fft<num>::rt(2, num(1));\ntemplate <typename num> vector<num> fft<num>::scratch_a;\ntemplate <typename num> vector<num> fft<num>::scratch_b;\n\ntemplate <typename num> void fft<num>::init(int n) {\n\tif (n <= sz(rt)) return;\n\trev.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\trev[i] = (rev[i>>1] | ((i&1)*n)) >> 1;\n\t}\n\trt.reserve(n);\n\tfor (int k = sz(rt); k < n; k *= 2) {\n\t\trt.resize(2*k);\n\t\tnum z = getRoot<num>::f(2*k);\n\t\tfor (int i = k/2; i < k; i++) {\n\t\t\trt[2*i] = rt[i], rt[2*i+1] = rt[i]*z;\n\t\t}\n\t}\n}\n\ntemplate <typename num> template <typename Iterator> void fft<num>::go(Iterator begin, int n) {\n\tinit(n);\n\tint s = __builtin_ctz(sz(rev)/n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i < (rev[i]>>s)) {\n\t\t\tswap(*(begin+i), *(begin+(rev[i]>>s)));\n\t\t}\n\t}\n\tfor (int k = 1; k < n; k *= 2) {\n\t\tfor (int i = 0; i < n; i += 2 * k) {\n\t\t\tIterator it1 = begin + i, it2 = it1 + k;\n\t\t\tfor (int j = 0; j < k; j++, ++it1, ++it2) {\n\t\t\t\tnum t = rt[j+k] * *it2;\n\t\t\t\t*it2 = *it1 - t;\n\t\t\t\t*it1 = *it1 + t;\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate <typename num> struct fft_multiplier {\n\ttemplate <typename IterA, typename IterB, typename IterOut>\n\tstatic void multiply(IterA ia, int sza, IterB ib, int szb, IterOut io) {\n\t\tvector<num>& fa = fft<num>::scratch_a;\n\t\tvector<num>& fb = fft<num>::scratch_b;\n\n\t\tif (sza == 0 || szb == 0) return;\n\t\tint s = sza + szb - 1;\n\t\tint n = nextPow2(s);\n\t\tfft<num>::init(n);\n\t\tif (sz(fa) < n) fa.resize(n);\n\t\tif (sz(fb) < n) fb.resize(n);\n\t\tcopy(ia, ia+sza, fa.begin());\n\t\tfill(fa.begin()+sza, fa.begin()+n, num(0));\n\t\tcopy(ib, ib+szb, fb.begin());\n\t\tfill(fb.begin()+szb, fb.begin()+n, num(0));\n\t\tfft<num>::go(fa.begin(), n);\n\t\tfft<num>::go(fb.begin(), n);\n\t\tnum d = inv(num(n));\n\t\tfor (int i = 0; i < n; i++) fa[i] = fa[i] * fb[i] * d;\n\t\treverse(fa.begin()+1, fa.begin()+n);\n\t\tfft<num>::go(fa.begin(), n);\n\t\tcopy(fa.begin(), fa.begin()+s, io);\n\t}\n};\n\ntemplate <typename num>\nstruct fft_inverser {\n\ttemplate <typename IterA, typename IterOut>\n\tstatic void inverse(IterA ia, int sza, IterOut io) {\n\t\tvector<num>& fa = fft<num>::scratch_a;\n\t\tvector<num>& fb = fft<num>::scratch_b;\n\n\t\tif (sza == 0) return;\n\t\tint s = nextPow2(sza) * 2;\n\t\tfft<num>::init(s);\n\t\tif (sz(fa) < s) fa.resize(s);\n\t\tif (sz(fb) < s) fb.resize(s);\n\t\tfb[0] = inv(*ia);\n\t\tfor (int n = 1; n < sza; ) {\n\t\t\tfill(fb.begin() + n, fb.begin() + 4 * n, num(0));\n\t\t\tn *= 2;\n\t\t\tcopy(ia, ia+min(n,sza), fa.begin());\n\t\t\tfill(fa.begin()+min(n,sza), fa.begin()+2*n, 0);\n\t\t\tfft<num>::go(fb.begin(), 2*n);\n\t\t\tfft<num>::go(fa.begin(), 2*n);\n\t\t\tnum d = inv(num(2*n));\n\t\t\tfor (int i = 0; i < 2*n; i++) fb[i] = fb[i] * (2 - fa[i] * fb[i]) * d;\n\t\t\treverse(fb.begin()+1, fb.begin()+2*n);\n\t\t\tfft<num>::go(fb.begin(), 2*n);\n\t\t}\n\t\tcopy(fb.begin(), fb.begin()+sza, io);\n\t}\n};\n\ntemplate <typename dbl>\nstruct fft_double_multiplier {\n\ttemplate <typename IterA, typename IterB, typename IterOut>\n\tstatic void multiply(IterA ia, int sza, IterB ib, int szb, IterOut io) {\n\t\tvector<cplx<dbl>>& fa = fft<cplx<dbl>>::scratch_a;\n\t\tvector<cplx<dbl>>& fb = fft<cplx<dbl>>::scratch_b;\n\n\t\tif (sza == 0 || szb == 0) return;\n\t\tint s = sza + szb - 1;\n\t\tint n = nextPow2(s);\n\t\tfft<cplx<dbl>>::init(n);\n\t\tif (sz(fa) < n) fa.resize(n);\n\t\tif (sz(fb) < n) fb.resize(n);\n\n\t\tfill(fa.begin(), fa.begin() + n, 0);\n\t\t{ auto it = ia; for (int i = 0; i < sza; ++i, ++it) fa[i].x = *it; }\n\t\t{ auto it = ib; for (int i = 0; i < szb; ++i, ++it) fa[i].y = *it; }\n\t\tfft<cplx<dbl>>::go(fa.begin(), n);\n\t\tfor (auto& x : fa) x = x * x;\n\t\tfor (int i = 0; i < n; ++i) fb[i] = fa[(n-i)&(n-1)] - conj(fa[i]);\n\t\tfft<cplx<dbl>>::go(fb.begin(), n);\n\t\t{ auto it = io; for (int i = 0; i < s; ++i, ++it) *it = fb[i].y / (4*n); }\n\t}\n};\n\ntemplate <typename mnum>\nstruct fft_mod_multiplier {\n\ttemplate <typename IterA, typename IterB, typename IterOut>\n\tstatic void multiply(IterA ia, int sza, IterB ib, int szb, IterOut io) {\n\t\tusing cnum = cplx<double>;\n\t\tvector<cnum>& fa = fft<cnum>::scratch_a;\n\t\tvector<cnum>& fb = fft<cnum>::scratch_b;\n\n\t\tif (sza == 0 || szb == 0) return;\n\t\tint s = sza + szb - 1;\n\t\tint n = nextPow2(s);\n\t\tfft<cnum>::init(n);\n\t\tif (sz(fa) < n) fa.resize(n);\n\t\tif (sz(fb) < n) fb.resize(n);\n\n\t\t{ auto it = ia; for (int i = 0; i < sza; ++i, ++it) fa[i] = cnum(int(*it) & ((1<<15)-1), int(*it) >> 15); }\n\t\tfill(fa.begin()+sza, fa.begin() + n, 0);\n\t\t{ auto it = ib; for (int i = 0; i < szb; ++i, ++it) fb[i] = cnum(int(*it) & ((1<<15)-1), int(*it) >> 15); }\n\t\tfill(fb.begin()+szb, fb.begin() + n, 0);\n\n\t\tfft<cnum>::go(fa.begin(), n);\n\t\tfft<cnum>::go(fb.begin(), n);\n\t\tdouble r0 = 0.5 / n; // 1/2n\n\t\tfor (int i = 0; i <= n/2; i++) {\n\t\t\tint j = (n-i)&(n-1);\n\t\t\tcnum g0 = (fb[i] + conj(fb[j])) * r0;\n\t\t\tcnum g1 = (fb[i] - conj(fb[j])) * r0;\n\t\t\tswap(g1.x, g1.y); g1.y *= -1;\n\t\t\tif (j != i) {\n\t\t\t\tswap(fa[j], fa[i]);\n\t\t\t\tfb[j] = fa[j] * g1;\n\t\t\t\tfa[j] = fa[j] * g0;\n\t\t\t}\n\t\t\tfb[i] = fa[i] * conj(g1);\n\t\t\tfa[i] = fa[i] * conj(g0);\n\t\t}\n\t\tfft<cnum>::go(fa.begin(), n);\n\t\tfft<cnum>::go(fb.begin(), n);\n\t\tusing ll = long long;\n\t\tconst ll m = mnum::MOD;\n\t\tauto it = io;\n\t\tfor (int i = 0; i < s; ++i, ++it) {\n\t\t\t*it = mnum((ll(fa[i].x+0.5)\n\t\t\t\t\t\t+ (ll(fa[i].y+0.5) % m << 15)\n\t\t\t\t\t\t+ (ll(fb[i].x+0.5) % m << 15)\n\t\t\t\t\t\t+ (ll(fb[i].y+0.5) % m << 30)) % m);\n\t\t}\n\t}\n};\n\ntemplate <class multiplier, typename num>\nstruct multiply_inverser {\n\ttemplate <typename IterA, typename IterOut>\n\tstatic void inverse(IterA ia, int sza, IterOut io) {\n\t\tif (sza == 0) return;\n\t\tint s = nextPow2(sza);\n\t\tvector<num> b(s,num(0));\n\t\tvector<num> tmp(2*s);\n\t\tb[0] = inv(*ia);\n\t\tfor (int n = 1; n < sza; ) {\n\t\t\t// TODO: could be square instead of multiply\n\t\t\tmultiplier::multiply(b.begin(),n,b.begin(),n,tmp.begin());\n\t\t\tint nn = min(sza,2*n);\n\t\t\tmultiplier::multiply(tmp.begin(),nn,ia,nn,tmp.begin());\n\t\t\tfor (int i = n; i < nn; i++) b[i] = -tmp[i];\n\t\t\tn = nn;\n\t\t}\n\t\tcopy(b.begin(), b.begin()+sza, io);\n\t}\n};\n\ntemplate <class multiplier, typename T> vector<T> multiply(const vector<T>& a, const vector<T>& b) {\n\tif (sz(a) == 0 || sz(b) == 0) return {};\n\tvector<T> r(max(0, sz(a) + sz(b) - 1));\n\tmultiplier::multiply(begin(a), sz(a), begin(b), sz(b), begin(r));\n\treturn r;\n}\n\ntemplate <typename T> vector<T> fft_multiply(const vector<T>& a, const vector<T>& b) {\n\treturn multiply<fft_multiplier<T>, T>(a, b);\n}\ntemplate <typename T> vector<T> fft_double_multiply(const vector<T>& a, const vector<T>& b) {\n\treturn multiply<fft_double_multiplier<T>, T>(a, b);\n}\ntemplate <typename T> vector<T> fft_mod_multiply(const vector<T>& a, const vector<T>& b) {\n\treturn multiply<fft_mod_multiplier<T>, T>(a, b);\n}\n\ntemplate <class inverser, typename T> vector<T> inverse(const vector<T>& a) {\n\tvector<T> r(sz(a));\n\tinverser::inverse(begin(a), sz(a), begin(r));\n\treturn r;\n}\ntemplate <typename T> vector<T> fft_inverse(const vector<T>& a) {\n\treturn inverse<fft_inverser<T>, T>(a);\n}\ntemplate <typename T> vector<T> fft_double_inverse(const vector<T>& a) {\n\treturn inverse<multiply_inverser<fft_double_multiplier<T>, T>, T>(a);\n}\ntemplate <typename T> vector<T> fft_mod_inverse(const vector<T>& a) {\n\treturn inverse<multiply_inverser<fft_mod_multiplier<T>, T>, T>(a);\n}\n\n}} // namespace ecnerwala::fft\n\nusing num = modnum<998244353>;\n\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint N;\n\tcin >> N;\n\tvector<num> x = {1};\n\tfor(int n = 1; n <= N; n++){\n\t\tvector<num> cx(1 << (n-1), 0);\n\t\tfor(int i = 0; i < x.size(); i++){\n\t\t\tx[i] *= ifact[i] * ifact[(1 << (n-1)) - 1 - i];\n\t\t}\n\t\tfor(int i = 0; i < cx.size(); i++){\n\t\t\tcx[i] = ifact[i] * ifact[(1 << (n-1)) - 1 - i];\n\t\t}\n\t\tvector<num> y((1 << n) - 1, 0);\n\t\tvector<num> cc = ecnerwala::fft::fft_multiply(x, cx);\n\t\tfor(int a = 0; a < y.size(); a++){\n\t\t\ty[a] = cc[a] * fact[a] * fact[(1 << n) - 2 - a];\n\t\t}\n\t\t// for(int a = 0; a < y.size(); a++){\n\t\t// \tfor(int i = 0; i <= a; i++){\n\t\t// \t\ty[a] += x[i] * ncr(a, i) * ncr((1 << n) - 2 - a, (1 << (n-1)) - 1 - i);\n\t\t// \t}\n\t\t// }\n\t\ty.push_back(0);\n\t\tfor(num& z : y) z *= fact[(1 << (n-1))] * 2;\n\t\tx = y;\n\t}\n\treverse(x.begin(), x.end());\n\tfor(num a : x) cout << a << '\\n';\n}"], "input": "", "output": "", "tags": ["combinatorics", "dp", "fft", "math"], "dificulty": "2400", "interactive": false}