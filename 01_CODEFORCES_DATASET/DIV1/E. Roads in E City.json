{"link": "https://codeforces.com//contest/1819/problem/E", "problemId": "1880631", "problem_idx": "E", "shortId": "1819E", "contest_number": "1819", "problem_submissions": {"E": [202225318, 202223532, 202223484, 202225560, 202308964, 202224265, 202225112, 202221853, 202253482, 202237435, 203635743, 203096948, 202225859, 202369794], "D": [202209352, 202212141, 202205538, 202220831, 202198559, 202210822, 202236119, 202239190, 202212242, 202208889, 202205391, 202216800, 203995136, 202197649, 202216978, 202217768, 202220492, 202220964, 202225376, 202219172], "C": [202201042, 202203020, 202193305, 202202657, 202190230, 202199701, 202199472, 202200745, 202199789, 202199523, 208251329, 202218422, 202204297, 202216624, 202204671, 202205053, 202201997, 202201056, 202198992], "B": [202193365, 202195322, 202214813, 202196120, 202186520, 202187817, 202188682, 202193750, 202186708, 202188527, 202188957, 202183110, 202191595, 202187157, 202193385, 202195604, 202188109, 202186084, 202189411], "A": [202182367, 202180872, 202181217, 202181093, 202180590, 202180859, 202181832, 202181960, 202180690, 202180596, 202180602, 202180463, 202182678, 202180651, 202182633, 202181119, 202181593, 202180899, 202180615], "F": [202939012, 206043011]}, "name": "E. Roads in E City", "statement": "As is well known, the city \"E\" has never had its roads repaired in its a\r\nthousand and a half years old history. And only recently the city\r\nadministration repaired some of them.It is known that in total in the\r\ncity \"E\" there are n intersections and m roads, which can be used in\r\nboth directions, numbered with integers from 1 to m. The i-th road\r\nconnects intersections with numbers a_i and b_i.Among all m roads, some\r\nsubset of the roads has been repaired, but you do not know which one.\r\nThe only information you could get from the city\u2019s road services is that\r\nyou can get from any intersection to any other intersection by driving\r\nonly on the roads that have been repaired.You are a young entrepreneur,\r\nand decided to organize a delivery service of fresh raw meat in the city\r\n\"E\" (in this city such meat is called \"steaks\", it is very popular among\r\nthe locals). You have already recruited a staff of couriers, but the\r\ncouriers are willing to travel only on repaired roads. Now you have to\r\nfind out which roads have already been repaired.The city administration\r\nhas given you the city for a period of time, so you can make different\r\nqueries of one of three types: Block the road with the number x. In this\r\ncase, movement on the road for couriers will be forbidden. . Unblock the\r\nroad with the number x. In this case, couriers will be able to move on\r\nthe road x if it is repaired. Try to deliver the order to the\r\nintersection with the number y. In this case, one of your couriers will\r\nstart moving from intersection with number s you don\u2019t know and deliver\r\nthe order to intersection with number y if there is a path on unblocked\r\nrepaired roads from intersection s to intersection y. It is guaranteed\r\nthat intersection s . Unfortunately, the city is placed at your complete\r\ndisposal for a short period of time, so you can make no more than 100\r\ncdot m requests.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n\n#define ll long long\n#define int ll\n#define ull unsigned ll\n#define ld long double\n#define rep(a) rep1(i,a)\n#define rep1(i,a) rep2(i,0,a)\n#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)\n#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)\n#define chkmin(a,b) (a=min(a,b))\n#define chkmax(a,b) (a=max(a,b))\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int>\n#define pb push_back\n#define eb emplace_back\n#define sort_unique(a) sort(all(a)),a.resize(unique(all(a))-a.begin())\n//#define inf 1010000000\n#define inf 4000000000000000000\n#define eps 1e-9\n#define sz(a) ((int)a.size())\n#define pow2(x) (1ll<<(x))\n#define ceiling(a,b) (((a)+(b)-1)/(b))\n#define print0(a) cout << (a) << ' '\n#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#ifdef i_am_noob\n#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)\ntemplate<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(T && x) {cerr << x << endl;}\ntemplate<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}\n#else\n#define bug(...) 777771449\n#endif\ntemplate<typename T> void print(T && x) {cout << x << \"\\n\";}\ntemplate<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\n\nconst int Mod=1000000007,Mod2=998244353;\nconst int MOD=Mod2;\ntemplate <int mod>\nstruct Modint{\n    int val;\n    Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}\n    Modint operator +(const Modint& o) const {\n        Modint res;\n        res.val=val+o.val;\n        if(res.val>=mod) res.val-=mod;\n        return res;\n    }\n    Modint operator +(const int& o) const {return Modint(val+o);}\n    Modint operator -() const {\n        Modint res;\n        res.val=-val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const Modint& o) const {\n        Modint res;\n        res.val=val-o.val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const int& o) const {return Modint(val-o);}\n    Modint operator *(const Modint& o) const {return Modint(val*o.val);}\n    Modint operator *(const int& o) const {return Modint(val*(o%mod));}\n    Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}\n    Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}\n    Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}\n    Modint Pow(int b) const {\n        Modint tmp(val),ret(1);\n        while(b){\n            if(b&1) ret*=tmp;\n            b>>=1;tmp*=tmp;\n        }\n        return ret;\n    }\n    Modint Pow(const Modint& a, int b) const {return a.Pow(b);}\n    inline Modint inv() const {return (*this).Pow(mod-2);}\n    Modint operator /(const Modint& o) const {return *this*o.inv();}\n    Modint operator /(const int& o) const {return *this*Modint(o).inv();}\n    bool operator ==(const Modint& o) const {return val==o.val;}\n};\ntemplate<int mod>\nostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}\ntemplate<int mod>\nModint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}\ntemplate<int mod>\nModint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}\ntemplate<int mod>\nModint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}\n#define modint Modint<MOD>\nvector<modint> inv,fac,invfac;\nvoid init_comb(int N){\n    inv.resize(N),fac.resize(N),invfac.resize(N);\n    inv[1]=1,fac[0]=1,invfac[0]=1;\n    rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);\n    rep2(i,1,N) fac[i]=fac[i-1]*i;\n    rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];\n}\ninline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}\ninline modint H(int n, int m){return C(n+m-1,n);}\n\nconst int maxn=2005,maxm=pow2(17),maxk=7777714;\n\n//i_am_noob\n#define wiwihorz  \nvoid balbitorz(){}\nint n,m,e[maxn][2],dep[maxn],par[maxn],id[maxn];\nbool can[maxn],tree[maxn],good[maxn];\nvector<pii> adj[maxn];\nykh;\n\nvoid toggle(int i){\n    if(can[i]) cout << \"- \" << i+1 << endl;\n    else cout << \"+ \" << i+1 << endl;\n    can[i]^=1;\n}\n\nbool check(int u, int v){\n    rep1(_,46){\n        int de;\n        if(rng()&1) de=u;\n        else de=v;\n        cout << \"? \" << de+1 << endl;\n        int res; cin >> res;\n        if(res==0) return 0;\n    }\n    return 1;\n}\n\nvoid dfs(int u, int fa, int de){\n    dep[u]=fa==-1?0:dep[fa]+1,par[u]=fa;\n    id[u]=de;\n    for(auto [v,i]: adj[u]) if(v!=fa) dfs(v,u,i);\n}\n\nvoid orzck(){\n    cin >> n >> m;\n    rep(m) can[i]=1,tree[i]=0,good[i]=0;\n    rep(m) cin >> e[i][0] >> e[i][1],e[i][0]--,e[i][1]--;\n    rep(n) adj[i].clear();\n    rep(m){\n        toggle(i);\n        if(!check(e[i][0],e[i][1])) toggle(i),good[i]=1,tree[i]=1;\n    }\n    int tot=0;\n    rep(m) if(tree[i]) tot++;\n    assert(tot==n-1);\n    rep(m) if(tree[i]) adj[e[i][0]].pb({e[i][1],i}),adj[e[i][1]].pb({e[i][0],i});\n    dfs(0,-1,-1);\n    rep(m) if(!tree[i]){\n        int u=e[i][0],v=e[i][1];\n        if(dep[u]>dep[v]) swap(u,v);\n        int x=id[v];\n        toggle(x);\n        toggle(i);\n        if(check(v,par[v])) good[i]=1;\n        toggle(x);\n        toggle(i);\n    }\n    print0(\"!\");\n    rep(m) print0(good[i]);\n    cout << endl;\n    int _; cin >> _;\n    if(_==0){\n        exit(0);\n    }\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    // #ifdef i_am_noob\n    // freopen(\"input1.txt\",\"r\",stdin);\n    // freopen(\"output1.txt\",\"w\",stdout);\n    // freopen(\"output2.txt\",\"w\",stderr);\n    // #endif\n    cout << fixed << setprecision(15);\n    ld start=clock();\n    balbitorz();\n    int t;\n    #ifdef wiwihorz\n    cin >> t;\n    #else\n    t=1;\n    #endif\n    while(t--) orzck();\n    bug((clock()-start)/CLOCKS_PER_SEC);\n    return 0;\n}"], "input": "", "output": "", "tags": ["interactive", "math", "probabilities", "trees"], "dificulty": "3200", "interactive": false}