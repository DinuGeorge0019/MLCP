{
    "link": "https://codeforces.com//contest/461/problem/D",
    "problemId": "13283",
    "problem_idx": "D",
    "shortId": "461D",
    "contest_number": "461",
    "problem_submissions": {
        "E": [
            7595647,
            7593699,
            7595828,
            7594579,
            7595368,
            7600512,
            7595421,
            7661605,
            9294347,
            9294343,
            10452636
        ],
        "D": [
            7592651,
            7591771,
            7603387,
            7594572,
            7594433,
            7594196,
            7595170,
            7595635,
            7724393,
            7593683,
            7594245,
            7661058,
            8893908,
            10452336
        ],
        "C": [
            7587261,
            7587069,
            7586600,
            7586584,
            7590688,
            7588429,
            7587923,
            7590253,
            7588926,
            7591752,
            7589784,
            7592394,
            7587055,
            7589392,
            7587666,
            7587706,
            7588473
        ],
        "B": [
            7582196,
            7583106,
            209010830,
            7582794,
            7583033,
            7586901,
            7583221,
            7584128,
            7587075,
            7584566,
            7585023,
            7585807,
            7586879,
            7595401,
            7583774,
            7584143,
            7583861
        ],
        "A": [
            7580528,
            7580809,
            7580521,
            7581246,
            7587762,
            7581843,
            7580912,
            7581190,
            7581018,
            7581719,
            7581029,
            7581078,
            7581003,
            7584251,
            7580442,
            7580814,
            7580452
        ]
    },
    "name": "D. Appleman and Complicated Task",
    "statement": "Toastman came up with a very complicated task. He gives it to Appleman,\r\nbut Appleman doesn’t know how to solve it. Can you help him?Given a\r\ncheckerboard. Each cell of the board has either character ”, or\r\ncharacter ”, or nothing. How many ways to fill all the empty cells with\r\n” or ” (each cell must contain only one character in the end) are there,\r\nsuch that for each cell the number of adjacent cells with ” will be\r\neven? Find the number of ways modulo . Two cells of the board are\r\nadjacent if they share a side.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <cassert>\nusing namespace std;\n\nconst int MAX_N = int(1e5) + 10;\nconst int MOD = int(1e9) + 7;\n\nstruct Edge {\n\tint t, c;\n\tEdge(int t, int c) :\n\t\t\tt(t), c(c) {\n\t}\n};\n\nvector<Edge> E[MAX_N];\nint n, k;\n\nvoid addEdge(int u, int v, int c) {\n\tE[u].push_back(Edge(v, c));\n\tE[v].push_back(Edge(u, c));\n}\n\nbool bad;\n//\t\tconstraint(r, 0, 0);\n//\t\tconstraint(r, n + 1, 0);\n//\t}\n//\tfor (int c = 0; c <= n + 1; ++c) {\n//\t\tconstraint(n + 1, c, 0);\n//\t}\nint col[MAX_N];\n\nvoid dfs(int u, int what) {\n\tif (bad)\n\t\treturn;\n\tif (col[u] != -1) {\n\t\tif (col[u] != what) {\n\t\t\tbad = true;\n\t\t}\n\t\treturn;\n\t}\n\tcol[u] = what;\n\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tdfs(e->t, what ^ e->c);\n\t}\n}\n\nvoid constraint(int r, int c, int v) {\n\tint d = min(r - 1, c - 1);\n\td = min(d, n - r);\n\td = min(d, n - c);\n\tint cc = abs(r - c) + d + 1;\n\tint L = cc - d, R = cc + d;\n\tL -= 2;\n\tif (L < 0)\n\t\tL = 0;\n\tif (R > n)\n\t\tR = n;\n\taddEdge(L, R, v);\n}\n\n//bitset<200> my[60][60];\n\nint main() {\n\n\t//50 50;\n//\tint N = 11;\n//\tfor (int i = 0; i < N; ++i) {\n//\t\tmy[0][i][i] = true;\n//\t}\n//\tfor (int r = 1; r < N; ++r) {\n//\t\tfor (int c = 0; c < N; ++c) {\n//\t\t\tif (r - 2 >= 0)\n//\t\t\t\tmy[r][c] ^= my[r - 2][c];\n//\t\t\tif (c - 1 >= 0)\n//\t\t\t\tmy[r][c] ^= my[r - 1][c - 1];\n//\t\t\tif (c + 1 < N)\n//\t\t\t\tmy[r][c] ^= my[r - 1][c + 1];\n//\t\t}\n//\t}\n//\n//\tfor (int r = 0; r < N; ++r) {\n//\t\tfor (int c = 0; c < N; ++c) {\n//\t\t\tint a = -1, b;\n//\t\t\tfor (int k = 0; k < N; ++k) {\n//\t\t\t\tif (my[r][c][k]) {\n//\t\t\t\t\tif (a == -1)\n//\t\t\t\t\t\ta = k;\n//\t\t\t\t\tb = k;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tprintf(\"%02d,%02d \", a, b);\n////\t\t\tprintf(\"%02d \", (b - a) / 2);\n//\t\t\tint d = r;\n//\t\t\td = min(d, c);\n//\t\t\td = min(d, N - 1 - c);\n//\t\t\td = min(d, N - 1 - r);\n//\t\t\tint cc = abs(r - c) + d;\n//\t\t\tassert(a == cc - d && b == cc + d);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n\n\tcin >> n >> k;\n\t//1...n\n\twhile (k--) {\n\t\tint r, c, v;\n\t\tscanf(\"%d%d\", &r, &c);\n\t\tchar ch;\n\t\tscanf(\" \");\n\t\tscanf(\"%c\", &ch);\n\t\tif (ch == 'o')\n\t\t\tv = 1;\n\t\telse\n\t\t\tv = 0;\n\t\tconstraint(r, c, v);\n\t}\n//\tfor (int r = 1; r <= n; ++r) {\n//\t\tconstraint(r, 0, 0);\n//\t\tconstraint(r, n + 1, 0);\n//\t}\n//\tfor (int c = 0; c <= n + 1; ++c) {\n//\t\tconstraint(n + 1, c, 0);\n//\t}\n\tmemset(col, -1, sizeof col);\n\tint cnt = 0;\n\tbad = false;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tif (bad)\n\t\t\tbreak;\n\t\tif (col[i] == -1) {\n\t\t\tdfs(i, 0);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tif (bad) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint ans = 1;\n\t--cnt;\n\twhile (cnt--)\n\t\tans = (ans + ans) % MOD;\n\tcout << ans << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Appleman and Complicated Task.json",
    "editorial_link": "https://codeforces.com/blog/entry/13568",
    "editorial": "First, we ignore the already drawn cell and dependence of cells. If we\r\ndecide the first row, then the entire board can decided uniquely. We\r\ncall âoâ is 1, and âxâ is 0. Then, a[i][j] = a[i-2][j] xor a[i-1][j-1]\r\nxor a[i-1][j+1] For example, Iâll explain n=5 case. Each column of first\r\nrow is a, b, c, d, and e. \"ac\" means a xor c. Each character affects the\r\nfollowing cells (denoted âoâ). Generally we can prove the dependence\r\nthat a[0][k] affects a[i][j] if k<=i+j<=2(n-1)-k and |i-j|<=k and k\r\n",
    "hint": []
}