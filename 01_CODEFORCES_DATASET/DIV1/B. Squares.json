{
    "link": "https://codeforces.com//contest/123/problem/B",
    "problemId": "653",
    "problem_idx": "B",
    "shortId": "123B",
    "contest_number": "123",
    "problem_submissions": {
        "E": [
            830840,
            831942,
            831247,
            1154341
        ],
        "C": [
            830171,
            829602,
            829696,
            830545,
            830265,
            830647,
            831072,
            830094,
            829962,
            833283,
            832903,
            833096
        ],
        "D": [
            829496,
            830812,
            1447203,
            829637,
            831873,
            1185562,
            836113,
            832570,
            831822,
            839081,
            831840,
            834715,
            834693,
            831236,
            831444,
            830484,
            833338,
            833314,
            833310,
            830603,
            830534,
            831043,
            833652,
            831461,
            831555,
            831382,
            831934
        ],
        "B": [
            828403,
            828703,
            828120,
            829057,
            828829,
            829690,
            829686,
            832376,
            828694,
            829613,
            829313,
            828996,
            829196,
            828023,
            828574,
            829940,
            829279
        ],
        "A": [
            827847,
            827523,
            827572,
            827701,
            827834,
            828726,
            828164,
            828031,
            832616,
            827887,
            828344,
            829843,
            828296,
            829771,
            827580,
            829074,
            828185
        ]
    },
    "name": "B. Squares",
    "statement": "You are given an infinite checkered field. You should get from a square\r\n(; ) to a square (; ). Using the shortest path is not necessary. You can\r\nmove on the field squares in four directions. That is, when you are\r\npositioned in any square, you can move to any other side-neighboring\r\none. A square (; ) is considered bad, if at least one of the two\r\nconditions is fulfilled: , . Your task is to find the minimum number of\r\nbad cells one will have to visit on the way from (; ) to (; ).\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef vector<string> vstr;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void pvp(T a, T b) { for (T i = a; i != b; ++i) cout << \"(\" << i->first << \", \" << i->second << \") \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in_c() { int c; for (; (c = getchar()) <= ' '; ) { if (!~c) throw ~0; } return c; }\nint in() { int x = 0, c; for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -in(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10); return x; }\nInt In() { Int x = 0, c; for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -In(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10); return x; }\n\nInt Abs(Int x) { return (x < 0) ? -x : x; }\nInt myFloor(Int a, Int b) {\n    return (a < 0) ? (a / b - 1) : (a / b);\n}\nInt solve(Int a, Int p, Int q) {\n//cout<<a<<\" \"<<p<<\" \"<<q<<endl;\n    return Abs(myFloor(p, a) - myFloor(q, a));\n}\n\nInt A, B, X0, Y0, X1, Y1;\n\nint main() {\n    \n    \n    for (; cin >> A >> B >> X0 >> Y0 >> X1 >> Y1; ) {\n        Int e = solve(A * 2, X0 + Y0, X1 + Y1);\n        Int f = solve(B * 2, X0 - Y0, X1 - Y1);\n        cout << max(e, f) << endl;\n    }\n    \n    return 0;\n}\n        "
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Squares.json",
    "editorial_link": "https://codeforces.com//blog/entry/3047",
    "editorial": "Let's turn the field on 45o transforming cells coordinates (x,?y) in (x?+?y,?x?-?y). Then the cell (x,?y) will be bad if one of the conditions occurs x???0 (mod 2a) or y???0 (mod 2b). So good cells will be divided into sectors by vertical and horizontal lines. For each sector, it is possible to determine the coordinates of a pair of numbers, the first number that will rise during the transition to the next right sector, and the second pair number will increase during the transition to the next upper sector. From the sector with coordinates (x,?y) can go to any nearby on the side of the sector, visiting at least one bad cell, ie in (x?-?1,?y), (x?+?1,?y), (x,?y?-?1) and (x,?y?+?1). Since the numbers 2a and 2b have the same parity, then from the sector (x,?y) can also go to the sector on the diagonal, and visiting a bad cell, ie in (x?-?1,?y?+?1), (x?+?1,?y?-?1), (x?-?1,?y?-?1) and (x?+?1,?y?+?1). Then it turns out that the minimum number of bad cells, which should be visited on the way out of from the sector (x1,?y1) to sector of (x2,?y2) equals max(|x1?-?x2|,?|y1?-?y2|).\nLet's transform the coordinates of the initial and final cells as described rule above. Then find sectors which contain our cells and calculate answer with formula above."
}