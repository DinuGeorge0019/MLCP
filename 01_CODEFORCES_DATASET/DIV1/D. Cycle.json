{"link": "https://codeforces.com//contest/135/problem/D", "problemId": "719", "problem_idx": "D", "shortId": "135D", "contest_number": "135", "problem_submissions": {"C": [944684, 941895, 941745, 941532, 944650, 945527, 942928, 943119, 942454, 943300, 943389, 941561, 941623, 940913, 942350, 941874, 942533], "D": [941660, 943291, 945020, 944509, 943932, 944955, 945060, 946515, 946811, 946183, 947267, 1202616, 943338, 947399, 947531, 948318], "B": [938992, 939256, 939578, 939872, 939430, 940532, 941115, 940491, 940317, 940731, 941548, 939927, 939245, 939945, 939103, 940367, 940260, 939461], "A": [937548, 938377, 938253, 937895, 937980, 938055, 938264, 938797, 937811, 937813, 938237, 937770, 937935, 938511, 937731, 937759, 937846, 937880], "E": [949929, 947660, 945720, 950498, 947878, 947674]}, "name": "D. Cycle", "statement": "Little Petya very much likes rectangular tables that consist of\r\ncharacters \"0\" and \"1\". Recently he has received one such table as a\r\ngift from his mother. The table contained rows and columns. The rows are\r\nnumbered from top to bottom from to , the columns are numbered from the\r\nleft to the right from to . Petya immediately decided to find the\r\nlongest cool cycle whatever it takes.A cycle is a sequence of pairwise\r\ndistinct cells where each two consecutive cells have a common side;\r\nbesides, the first cell has a common side with the last cell. A cycle is\r\ncalled cool if it fulfills all the following conditions simultaneously:\r\nThe cycle entirely consists of the cells that contain \"1\". Each cell\r\nthat belongs to the cycle, has a common side with exactly two other\r\ncells that belong to the cycle. Each cell of the table that contains \"1\"\r\neither belongs to the cycle or is positioned outside of it (see\r\ndefinition below). To define the notion of \"outside\" formally, let\u2019s\r\ndraw a cycle on a plane. Let each cell of the cycle ( is the row number,\r\nis the column number) correspond to the point on the coordinate plane.\r\nLet a straight line segment join each pair of points that correspond to\r\nthe cells belonging to the cycle and sharing a side. Thus, we will get a\r\nclosed polyline that has no self-intersections and self-touches. The\r\npolyline divides the plane into two connected parts: the part of an\r\ninfinite area and the part of a finite area. It is considered that cell\r\nlies outside of the cycle if it does not belong to the cycle and the\r\ncorresponding point on the plane with coordinates lies in the part with\r\nthe infinite area.Help Petya to find the length of the longest cool\r\ncycle in the table. The cycle length is defined as the number of cells\r\nthat belong to the cycle.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <memory.h>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define forn( i,n ) for ( int i=0; i<(int)(n); i++ )\n#define foreach( it, a ) for ( __typeof((a).begin()) it = (a).begin(); it != (a).end(); it++ )\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n\nconst int di[] = { -1, 0, 1, 0, -1, -1, 1, 1 };\nconst int dj[] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nint n, m;\nbool a[1010][1010];\nchar s[1010];\nbool u[1010][1010];\nint u1[1010][1010], it;\nint u2[1010][1010];\nvector<pii> v1;\npii q[1010*1010];\nint qb, qf;\n\nint go( int i, int j ) {\n  u2[i][j] = it;\n  int res = 1;\n  forn( q, 4 ) {\n    int ni = i + di[q];\n    int nj = j + dj[q];\n    if ( ni >= 0 && ni < n && nj >= 0 && nj < m )\n      if ( a[ni][nj] == 1 && u1[ni][nj] == it && u2[ni][nj] != it )\n        res += go( ni, nj );\n  }\n  return res;\n}\n\nint check( int si, int sj ) {\n  qb = qf = 0;\n  q[qf++] = pii( si, sj );\n  u[si][sj] = 1;\n  v1.clear();\n  bool side = false;\n\n  it++;\n  pii cur;\n  while ( qb < qf ) {\n    cur = q[qb++];\n    si = cur.first;\n    sj = cur.second;\n\n    forn( w, 8 ) {\n      int ni = si + di[w];\n      int nj = sj + dj[w];\n\n      if ( ni < 0 || ni >= n || nj < 0 || nj >= m ) {\n        side = true;\n        break;\n      }\n      else\n        if ( a[ni][nj] == 1 ) {\n          if ( u1[ni][nj] != it ) {\n            u1[ni][nj] = it;\n            v1.pb( pii( ni, nj ) );\n          }\n        }\n        else\n          if ( !u[ni][nj] ) {\n            u[ni][nj] = 1;\n            q[qf++] = pii( ni, nj );\n          }\n    }\n  }\n\n  if ( side ) return 0;\n\n  forn( i, v1.size() ) {\n    int cnt = 0;\n    forn( j, 4 ) {\n      int ti = v1[i].first + di[j];\n      int tj = v1[i].second + dj[j];\n      if ( ti >= 0 && ti < n && tj >= 0 && tj < m && a[ti][tj] == 1 && u1[ti][tj] == it )\n        cnt++;\n    }\n    if ( cnt != 2 ) return 0;\n  }\n\n  if ( v1.size() )\n    if ( go( v1[0].first, v1[0].second ) == (int)v1.size() ) return v1.size();\n\n  return 0;\n}\n\nint main()\n{\n  scanf( \"%d %d\", &n, &m );\n  forn( i, n ) {\n    scanf( \"%s\", s );\n    forn( j, m )\n      a[i][j] = s[j] == '1';\n  }\n\n  int ans = 0;\n  forn( i, n-1 )\n    forn( j, m-1 )\n      if ( a[i][j] && a[i+1][j] && a[i+1][j+1] && a[i][j+1] )\n        ans = 4;\n\n  forn( i, n )\n    forn( j, m )\n      if ( a[i][j] == 0 && !u[i][j] ) {\n        int z = check( i, j );\n        if ( z > ans ) ans = z;\n      }\n\n  printf( \"%d\\n\", ans );\n  return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "dfs and similar", "implementation"], "dificulty": "2500", "interactive": false}