{
    "link": "https://codeforces.com//contest/243/problem/D",
    "problemId": "2199",
    "problem_idx": "D",
    "shortId": "243D",
    "contest_number": "243",
    "problem_submissions": {
        "C": [
            2572717,
            2570554,
            2571267,
            2570319,
            2570545,
            2570743,
            2570904,
            2572447,
            2569802,
            2571867,
            2571670,
            2571547,
            2572458,
            2572351,
            2572725,
            2572445,
            2571597
        ],
        "B": [
            2571032,
            2569391,
            2569867,
            2569039,
            2577625,
            2577586,
            2570199,
            2569750,
            2570050,
            2570000,
            2574723,
            2570092,
            2570360,
            2570412,
            2570400,
            2569098,
            2570322,
            2570512,
            2570546
        ],
        "A": [
            2567965,
            2567859,
            2571004,
            2567919,
            2568141,
            2568865,
            2568305,
            2568196,
            2567807,
            2568129,
            2568622,
            2567937,
            2568123,
            2567849,
            2568409,
            2569040,
            2568458
        ],
        "D": [
            2572629,
            2572978,
            2574124
        ]
    },
    "name": "D. Cubes",
    "statement": "One day Petya got a set of wooden cubes as a present from his mom. Petya\r\nimmediately built a whole city from these cubes.The base of the city is\r\nan square, divided into unit squares. The square\u2019s sides are parallel to\r\nthe coordinate axes, the square\u2019s opposite corners have coordinates and\r\n. On each of the unit squares Petya built a tower of wooden cubes. The\r\nside of a wooden cube also has a unit length.After that Petya went an\r\ninfinitely large distance away from his masterpiece and looked at it in\r\nthe direction of vector . Petya wonders, how many distinct cubes are\r\nvisible from this position. Help him, find this number.Each cube\r\nincludes the border. We think that a cube is visible if there is a ray\r\nemanating from some point , belonging to the cube, in the direction of\r\nvector , that doesn\u2019t contain any points, belonging to other cubes.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n#include <deque>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(abs(x))\n#define y0 y3487465\n#define y1 y8687969\n#define fill(x,y) memset(x,y,sizeof(x))\n                         \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double D;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) { re x > 0 ? x : -x; }\n\nint n;\nint m;\nint vx, vy;\nint tree[(1 << 22) + 1];\nint add[(1 << 22) + 1];\nvector<pair<int, ii> > u;\nvector<pair<ii, ii> > w;\nint g[1000][1000];\nint p[1000][1000];\nint q[1000][1000];\n\nint get (int x, int l, int r, int lc, int rc) {\n    if (r < lc || l > rc) re 2e9;\n    if (l >= lc && r <= rc) re max (tree[x], add[x]);\n    int s = (l + r) / 2;\n    re max (min (get (x * 2 + 1, l, s, lc, rc), get (x * 2 + 2, s + 1, r, lc, rc)), add[x]);\n}\n\nint upd (int x, int l, int r, int lc, int rc, int z) {\n    if (r < lc || l > rc) re max (tree[x], add[x]);\n    if (l >= lc && r <= rc) {\n        add[x] = max (add[x], z);\n        re max (tree[x], add[x]);\n    }\n    int s = (l + r) / 2;\n    tree[x] = min (upd (x * 2 + 1, l, s, lc, rc, z), upd (x * 2 + 2, s + 1, r, lc, rc, z));\n    re max (tree[x], add[x]);\n}\n\nint main () {\n    scanf (\"%d%d%d\", &n, &vx, &vy);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            scanf (\"%d\", &g[i][j]);\n    if (vy < 0) {\n        vy = -vy;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; 2 * j < n; j++)\n                swap (g[i][j], g[i][n - j - 1]);\n    }\n    if (vx < 0) {\n        vx = -vx;\n        for (int i = 0; 2 * i < n; i++)\n            for (int j = 0; j < n; j++)\n                swap (g[i][j], g[n - i - 1][j]);\n    }\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            int a = vx * i + vy * j;\n            int b = -vy * (i + 1) + vx * j;\n            int c = -vy * i + vx * (j + 1) - 1;\n            u.pb (mp (a, mp (i, j)));\n            w.pb (mp (mp (b, 0), mp (i, j)));\n            w.pb (mp (mp (c, 1), mp (i, j)));\n        }\n    sort (all (u));\n    sort (all (w));\n    int r = 0;\n    for (int i = 0; i < sz (w); i++) {\n        if (i == 0 || w[i - 1].fi.fi != w[i].fi.fi) r++;\n        if (w[i].fi.se == 0) p[w[i].se.fi][w[i].se.se] = r - 1; else q[w[i].se.fi][w[i].se.se] = r - 1;\n    }\n    memset (tree, 0, sizeof (tree));\n    memset (add, 0, sizeof (add));\n    ll ans = 0;\n    for (int k = 0; k < sz (u); k++) {\n        int i = u[k].se.fi;\n        int j = u[k].se.se;\n        int a = g[i][j];\n        int b = p[i][j];\n        int c = q[i][j];\n        int d = get (0, 0, r - 1, b, c);\n        if (d < a) {\n            ans += a - d;\n            upd (0, 0, r - 1, b, c, a);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "geometry",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Cubes.json",
    "editorial_link": "https://codeforces.com//blog/entry/5895",
    "editorial": "You need for every column find the lowermost cube that you can see. You will see all cubes above this cube.\n\nConsider the city from above. You will see drid of size n?\u00d7?n. Now you should draw the line through every node of the grid parallel to vector v. We need know only that happens in every strip between two neighbour lines. Every column cover segment of O(n) adjacent strips.\n\nNow you should create an array a; every element of a corresponding to one strip. This array will store maximal height of considered columns.\n\nThen you should sort all columns in order if increasing distance from observer. In that order you should do following queries of 2 types:\n\nMinimum on segment. This query is needed when you want find the lowermost visible cube.\n\nReplace ai???max(ai,?h) on segment. You need this query for \"drawing\" column in the array.\n\nThat is all solution. You just need choose some data structure that can fast do queries. You can select from: block decomposition (length of every block should be ; because length of every query about O(n), total complexity of solution will be O(n5?/?2)), segment tree (), stupid array (it's O(n3), cache optimized implementaton fits in the time limit)."
}