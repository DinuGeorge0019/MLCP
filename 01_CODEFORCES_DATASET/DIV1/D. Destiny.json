{
    "link": "https://codeforces.com//contest/840/problem/D",
    "problemId": "118959",
    "problem_idx": "D",
    "shortId": "840D",
    "contest_number": "840",
    "problem_submissions": {
        "E": [
            29579983,
            29579804,
            29577664,
            29579379,
            30931404,
            29639075,
            29617435,
            29681440,
            29681407,
            29681392,
            29681366
        ],
        "D": [
            29572451,
            29573549,
            29574893,
            29644417,
            29644402,
            29595162,
            29575013,
            29575646,
            29572436,
            29576887,
            29575628,
            29572554,
            29567189,
            29575551,
            29574764,
            29578191,
            29654756,
            29591307,
            29590747,
            29590681,
            29590673,
            29590627,
            29571509,
            29577552,
            29578628,
            29580062
        ],
        "C": [
            29567872,
            29569558,
            29567683,
            29569063,
            29562508,
            29569694,
            29567877,
            29577113,
            29566790,
            29572424,
            29577847,
            29579952,
            29584687,
            29571506,
            29571448,
            29570686,
            29578919,
            29571629,
            29571512,
            29569311
        ],
        "B": [
            29561393,
            29563952,
            29561789,
            29563624,
            29569083,
            29562635,
            29573313,
            29563716,
            29576058,
            29565857,
            29562483,
            29571100,
            29573859,
            29577034,
            29563154,
            29568606,
            29568725,
            29563595,
            29562462
        ],
        "A": [
            29557063,
            29560856,
            29557654,
            29557167,
            29564205,
            29559452,
            29556856,
            29560188,
            29575932,
            29562655,
            29557325,
            29559317,
            29562250,
            29559768,
            29556972,
            29558958,
            29556622,
            29557880,
            29558266
        ]
    },
    "name": "D. Destiny",
    "statement": "Once, Leha found in the left pocket an array consisting of integers, and\r\nin the right pocket queries of the form . If there are queries, then\r\nthey must be answered. Answer for the query is minimal such that occurs\r\nin the interval strictly more than times or if there is no such number.\r\nHelp Leha with such a difficult task.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nstruct KMajority {\n\tstatic const int K = 5;\n\tint d = 0;\n\tarray<pair<int, int>, K> b;\n\tvoid add(int x, int cnt) {\n\t\tassert(cnt > 0);\n\t\trep(i, d) if (b[i].first == x) {\n\t\t\tb[i].second += cnt;\n\t\t\treturn;\n\t\t}\n\t\tb[d ++] = { x, cnt };\n\t\tif (d == K) {\n\t\t\tint mincnt = cnt;\n\t\t\trep(i, d - 1)\n\t\t\t\tamin(mincnt, b[i].second);\n\t\t\tfor(int i = 0; i < d; ) {\n\t\t\t\tif ((b[i].second -= mincnt) == 0)\n\t\t\t\t\tswap(b[i], b[-- d]);\n\t\t\t\telse\n\t\t\t\t\t++ i;\n\t\t\t}\n\t\t\tassert(d < K);\n\t\t}\n\t}\n\tvoid merge(const KMajority &that) {\n\t\trep(j, that.d)\n\t\t\tadd(that.b[j].first, that.b[j].second);\n\t}\n};\n\nint main() {\n\tint n; int q;\n\twhile (~scanf(\"%d%d\", &n, &q)) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d\", &a[i]);\n\t\tint nNodes = 1;\n\t\twhile (nNodes < n) nNodes *= 2;\n\t\tvector<KMajority> nodes(nNodes * 2);\n\t\trep(i, n)\n\t\t\tnodes[nNodes + i].add(a[i], 1);\n\t\tfor (int i = nNodes - 1; i > 0; -- i) {\n\t\t\tnodes[i] = nodes[i * 2];\n\t\t\tnodes[i].merge(nodes[i * 2 + 1]);\n\t\t}\n\t\tvector<vi> indices(*max_element(a.begin(), a.end()) + 1);\n\t\trep(i, n)\n\t\t\tindices[a[i]].push_back(i);\n\t\tll sum = 0;\n\t\trep(ii, q) {\n\t\t\tint L; int R; int K;\n\t\t\tscanf(\"%d%d%d\", &L, &R, &K), -- L;\n\t\t\tKMajority km;\n\t\t\tfor (int l = L + nNodes, r = R + nNodes; l < r; l >>= 1, r >>= 1) {\n\t\t\t\tif (l & 1) km.merge(nodes[l ++]);\n\t\t\t\tif (r & 1) km.merge(nodes[-- r]);\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\trep(j, km.d) {\n\t\t\t\tint x = km.b[j].first;\n\t\t\t\tconst auto &v = indices[x];\n\t\t\t\tint cnt = (int)(lower_bound(v.begin(), v.end(), R) - lower_bound(v.begin(), v.end(), L));\n\t\t\t\tif (cnt * K > R - L)\n\t\t\t\t\tamin(ans, x);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "probabilities"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Destiny.json",
    "editorial_link": "https://codeforces.com//blog/entry/53943?locale=en",
    "editorial": "We will use classical divide and conquer approach to answer each query.\nSuppose current query is at subsegment [L;R]. Divide the original array into two parts: [1;mid] and [mid?+?1;N], where . If our whole query belongs to the first or the second part only, discard the other part and repeat the process of division. Otherwise, L???mid???R. We claim that if we form a set of K most frequent values on [L;mid] and K most frequent values on [mid?+?1;R], one of the values from this set will be the answer, or there is no suitable value.\n\nK most frequent values thing can be precalculated. Run recursive function build(node,?L,?R). First, like in a segment tree, we'll run this function from left and right son of node.\nThen we need K most frequent values to be precalculated for all subsegments [L1;R1], such that L???L1???R1???R and at least one of L1 and R1 is equal to .\n\n\nWe will consider segments such that their left border is mid in the following order: [mid;mid],?[mid;mid?+?1],?...[mid;R]. If we already have K most frequent values and their counts for [mid,?i], it's rather easy to calculate them for [mid,?i?+?1]. We update the count of ai?+?1 and see if anything should be updated for the new list of most frequent values.\n\nExactly the same process happens to the left side of mid: we are working with the subsegments in order [mid;mid],?[mid?-?1;mid],?...,?[L;mid].\n\n\nNow, having all this data precalculated, we can easily run divide and conquer and get the candidates for being the solution at any [L;R] segment. Checking a candidate is not a problem as well: we can save all occurrences in the array for each number and then, using binary search, easily answer the following questions: \"How many times x appears from L to R?\".",
    "hint": []
}