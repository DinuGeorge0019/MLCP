{"link": "https://codeforces.com//contest/1599/problem/F", "problemId": "1136885", "problem_idx": "F", "shortId": "1599F", "contest_number": "1599", "problem_submissions": {"J": [131341071], "I": [131324833], "F": [131321008], "H": [131309947], "C": [131304492], "A": [131303141], "B": [], "D": [], "E": []}, "name": "F. Mars", "statement": "In the year 2420 humans have finally built a colony on Mars thanks to\r\nthe work of Elon Tusk. There are 10^9+7 cities arranged in a circle in\r\nthis colony and none of them are connected yet. Elon Tusk wants to\r\nconnect some of those cities using only roads of the same size in order\r\nto lower the production cost of those roads. Because of that he gave a\r\nlist on N cites where some cites can appear more than once and Q queries\r\nthat you need to answer. For the query you need to determine if it is\r\npossible to connect all the cities from L_{i} to R_{i} on that list\r\nusing only roads of length D_{i}.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define L(i, j, k) for (int i = (j); i <= (k); ++i) \n#define R(i, j, k) for (int i = (j); i >= (k); --i)  \n#define ll long long\n#define vi vector < int > \n#define sz(a) ((int) (a).size())\nusing namespace std;\nconst int N = 2e5 + 7, mod = 1e9 + 7, inv6 = (mod + 1) / 6, W = 2;\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint sum1 (int x) {\n\treturn (ll) x * (x + 1) / 2 % mod;\n}\nint sum2 (int x) {\n\treturn (ll) x * (x + 1) % mod * (2 * x + 1) % mod * inv6 % mod;\n}\nbool vis[N];\nint n, m, a[N];\nstruct fenwk {\n\tint sz[N];\n\tvoid add (int x, int w) {\n\t\tfor (; x; x -= x & -x) \n\t\t\t(sz[x] += w) %= mod;\n\t}\n\tint query (int x) {\n\t\tint ret = 0;\n\t\tfor (; x <= n; x += x & -x) \n\t\t\t(ret += sz[x]) %= mod;\n\t\treturn ret;\n\t} \n} fw[W + 1];\nint L[N], R[N], D[N];\nvi q[N];\nbool ns[N];\n\nmap < int, int > mp;\n\nvoid Add (int w, int k) {\n\tint ret = 1;\n\tL(i, 0, W) fw[i].add(w, (ll) ret * k % mod), ret = (ll) ret * a[w] % mod; \n}\nint main () {\n\tios::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0); \n\tcin >> n >> m;\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tL(i, 1, m) {\n\t\tcin >> L[i] >> R[i] >> D[i], q[R[i]].push_back(i);\n\t}\n\tL(i, 1, n) {\n\t\tint z = mp[a[i]];\n\t\tmp[a[i]] = i;\n\t\tif(z) Add(z, mod - 1);\n\t\tAdd (i, 1);\n\t\t\n\t\tfor (const int &t : q[i]) {\n\t\t\tint a = fw[0].query(L[t]), b = fw[1].query(L[t]), fir = (b + mod - (ll) \n\t\t\ta * (a - 1) / 2 % mod * D[t] % mod) * qpow (a) % mod;\n\t\t\tif(mp[fir] < L[t]) ns[t] = false;\n\t\t\telse {\n\t\t\t\tint s0 = a, s1 = sum1(a - 1), s2 = sum2 (a - 1);\n\t\t\t\tint ret = 0;\n\t\t\t\t(ret += (ll) fir * fir % mod * s0 % mod) %= mod;\n\t\t\t\t(ret += (ll) 2 * fir * D[t] % mod * s1 % mod) %= mod;\n\t\t\t\t(ret += (ll) D[t] * D[t] % mod * s2 % mod) %= mod;\n\t\t\t\tns[t] = ret == fw[2].query(L[t]);\n\t\t\t}\n\t\t}\n\t}\n\tL(i, 1, m) {\n\t\tif(ns[i]) cout << \"Yes\\n\";\n\t\telse cout << \"No\\n\";\n\t}\n\t\n\treturn 0;\n} "], "input": "", "output": "", "tags": ["hashing"], "dificulty": "2700", "interactive": false}