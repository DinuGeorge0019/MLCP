{"link": "https://codeforces.com//contest/506/problem/D", "problemId": "20823", "problem_idx": "D", "shortId": "506D", "contest_number": "506", "problem_submissions": {"C": [9464348, 9463979, 9557239, 9466208, 9514381], "D": [9461125, 9461876, 9460334, 9459573, 9458109, 9460700, 9459375, 9461634, 9460457, 9461910, 9458643, 9460232, 9462018, 9462258, 9460016, 9460009, 9459977, 9462409, 9460765], "B": [9459503, 9458315, 9457879, 9457557, 9459219, 9458249, 9461319, 9459208, 9457985, 9457950, 9462161, 9459453, 9458782, 9461373, 9462464, 9462819, 9459210, 9458536], "A": [9456602, 9456438, 9456462, 9456507, 9460135, 9456591, 9456641, 9456514, 9463082, 9456214, 9463955, 9457315, 9456528, 9457236, 9463962, 9457919, 9457204, 9456634, 9464389], "E": [9557214]}, "name": "D. Mr. Kitayuta s Colorful Graph", "statement": "Mr. Kitayuta has just bought an undirected graph with vertices and\r\nedges. The vertices of the graph are numbered from 1 to . Each edge,\r\nnamely edge , has a color , connecting vertex and .Mr. Kitayuta wants\r\nyou to process the following queries.In the -th query, he gives you two\r\nintegers - and .Find the number of the colors that satisfy the following\r\ncondition: the edges of that color connect vertex and vertex directly or\r\nindirectly.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:33554432\")\n\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint grp[100003];\n\nint getgrp(int nod) {\n\treturn nod == grp[nod] ? nod : (grp[nod] = getgrp(grp[nod]));\n}\nvoid mergegrp(int a, int b) {\n\tgrp[getgrp(a)] = getgrp(b);\n}\n\nint n,m;\nmap<int, int> vertex_color_to_edge[100003];\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i = 0; i < m; i++) grp[i] = i;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--,b--;\n\t\tint e1 = -1, e2 = -1;\n\t\tif (vertex_color_to_edge[a].count(c)) e1 = vertex_color_to_edge[a][c];\n\t\tif (vertex_color_to_edge[b].count(c)) e2 = vertex_color_to_edge[b][c];\n\t\tvertex_color_to_edge[a][c] = i;\n\t\tvertex_color_to_edge[b][c] = i;\n\t\tif (e1 >= 0) mergegrp(i, e1);\n\t\tif (e2 >= 0) mergegrp(i, e2);\n\t}\n\tint Q;\n\tscanf(\"%d\",&Q);\n\tmap<pair<int,int>, int> caches;\n\twhile(Q-->0){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--,b--;\n\n\t\tint ans = 0;\n\t\tif (caches.count(make_pair(a,b))) {\n\t\t\tprintf(\"%d\\n\", caches[make_pair(a,b)]);\n\t\t\tcontinue;\n\t\t}\n\t\tint sa = vertex_color_to_edge[a].size(), sb = vertex_color_to_edge[b].size();\n\t\tif (sa > sb) {\n\t\t\tswap(sa,sb);\n\t\t\tswap(a,b);\n\t\t}\n\t\tauto &other = vertex_color_to_edge[b];\n\t\tfor (auto I = vertex_color_to_edge[a].begin(), IEnd = vertex_color_to_edge[a].end(); I != IEnd; ++I) {\n\t\t\tauto J = other.find(I->first);\n\t\t\tif (J == other.end()) continue;\n\t\t\tif (getgrp(I->second) == getgrp(J->second)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcaches[make_pair(a,b)] = caches[make_pair(b,a)] = ans;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["brute force", "dfs and similar", "dsu", "graphs"], "dificulty": "2400", "interactive": false}