{
    "link": "https://codeforces.com//contest/506/problem/D",
    "problemId": "20823",
    "problem_idx": "D",
    "shortId": "506D",
    "contest_number": "506",
    "problem_submissions": {
        "C": [
            9464348,
            9463979,
            9557239,
            9466208,
            9514381
        ],
        "D": [
            9461125,
            9461876,
            9460334,
            9459573,
            9458109,
            9460700,
            9459375,
            9461634,
            9460457,
            9461910,
            9458643,
            9460232,
            9462018,
            9462258,
            9460016,
            9460009,
            9459977,
            9462409,
            9460765
        ],
        "B": [
            9459503,
            9458315,
            9457879,
            9457557,
            9459219,
            9458249,
            9461319,
            9459208,
            9457985,
            9457950,
            9462161,
            9459453,
            9458782,
            9461373,
            9462464,
            9462819,
            9459210,
            9458536
        ],
        "A": [
            9456602,
            9456438,
            9456462,
            9456507,
            9460135,
            9456591,
            9456641,
            9456514,
            9463082,
            9456214,
            9463955,
            9457315,
            9456528,
            9457236,
            9463962,
            9457919,
            9457204,
            9456634,
            9464389
        ],
        "E": [
            9557214
        ]
    },
    "name": "D. Mr. Kitayuta s Colorful Graph",
    "statement": "Mr. Kitayuta has just bought an undirected graph with vertices and\r\nedges. The vertices of the graph are numbered from 1 to . Each edge,\r\nnamely edge , has a color , connecting vertex and .Mr. Kitayuta wants\r\nyou to process the following queries.In the -th query, he gives you two\r\nintegers - and .Find the number of the colors that satisfy the following\r\ncondition: the edges of that color connect vertex and vertex directly or\r\nindirectly.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:33554432\")\n\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint grp[100003];\n\nint getgrp(int nod) {\n\treturn nod == grp[nod] ? nod : (grp[nod] = getgrp(grp[nod]));\n}\nvoid mergegrp(int a, int b) {\n\tgrp[getgrp(a)] = getgrp(b);\n}\n\nint n,m;\nmap<int, int> vertex_color_to_edge[100003];\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i = 0; i < m; i++) grp[i] = i;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--,b--;\n\t\tint e1 = -1, e2 = -1;\n\t\tif (vertex_color_to_edge[a].count(c)) e1 = vertex_color_to_edge[a][c];\n\t\tif (vertex_color_to_edge[b].count(c)) e2 = vertex_color_to_edge[b][c];\n\t\tvertex_color_to_edge[a][c] = i;\n\t\tvertex_color_to_edge[b][c] = i;\n\t\tif (e1 >= 0) mergegrp(i, e1);\n\t\tif (e2 >= 0) mergegrp(i, e2);\n\t}\n\tint Q;\n\tscanf(\"%d\",&Q);\n\tmap<pair<int,int>, int> caches;\n\twhile(Q-->0){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--,b--;\n\n\t\tint ans = 0;\n\t\tif (caches.count(make_pair(a,b))) {\n\t\t\tprintf(\"%d\\n\", caches[make_pair(a,b)]);\n\t\t\tcontinue;\n\t\t}\n\t\tint sa = vertex_color_to_edge[a].size(), sb = vertex_color_to_edge[b].size();\n\t\tif (sa > sb) {\n\t\t\tswap(sa,sb);\n\t\t\tswap(a,b);\n\t\t}\n\t\tauto &other = vertex_color_to_edge[b];\n\t\tfor (auto I = vertex_color_to_edge[a].begin(), IEnd = vertex_color_to_edge[a].end(); I != IEnd; ++I) {\n\t\t\tauto J = other.find(I->first);\n\t\t\tif (J == other.end()) continue;\n\t\t\tif (getgrp(I->second) == getgrp(J->second)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcaches[make_pair(a,b)] = caches[make_pair(b,a)] = ans;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Mr. Kitayuta s Colorful Graph.json",
    "editorial_link": "https://codeforces.com/blog/entry/15889",
    "editorial": "[Problem] Given an undirected graph whose edges are painted in colors,\r\nprocess the queries of the following form: Note: this is the exact same\r\nproblem as Div.2 B except the constraints, which are instead of .\r\n(Problem from hogloid) Below is the explanation from hogloid. [From\r\nhere] For each color, make a new graph that consists of the edges of the\r\ncolor and vertices connected by the edges. Make UnionFind for each\r\ngraph, and you can check whether a color connects vertex and , using it.\r\nFor each query, find a vertex which has smaller degree(let this vertex ,\r\nand the other vertex ) For each colors such that a edge of the color\r\nconnects to , check whether and is connected by the color. After\r\nanswering the query, memorize its tuple . If the same query is\r\nrequested, answer using this information. This will lead to solution.\r\nFor each query, the complexity is (For each color connects , find a\r\nvertex of of the color & check whether they are connected) The queries\r\nthat require longest computing time are, to ask every pair among\r\nvertices which have largest degrees. Let the indices of the vertices be\r\n, and degrees of the vertices be . Now, let\u00e2\u0080\u0099s fix vertex as . The total\r\ncomputing time of the queries such that is vertex is . Vertex can vary\r\nfrom to . Hence, the total complexity is at most . This complexity is at\r\nmost . By the way, in C++, using unordered_map, total complexity would\r\nbe . [End] There will be many other solutions. I will briefly explain\r\none of them which I think is typical. Let be the number of colors of the\r\nedges incident to vertex . The sum of all does not exceed since each\r\nedge increases this sum by at most 2. Thus, there will be at most values\r\nof such that (let ). We will call these vertices large, and the\r\nremaining ones small. Using time and memory, we can precalculate and\r\nstore the answer for all the possible queries where at least one of and\r\nis large, then we can immediately answer these queries. For the\r\nremaining queries, both and will be small, therefore it is enough to\r\ndirectly count the color that connects vertices and in time. The total\r\ntime required will be . If we choose , we can solve the problem in time.\r\nThe writer\u00e2\u0080\u0099s code (the first solution, C++)The tester\u00e2\u0080\u0099s code (the second\r\nsolution, C++): 9501240\r\n"
}