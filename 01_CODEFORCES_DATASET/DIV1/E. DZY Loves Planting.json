{
    "link": "https://codeforces.com//contest/444/problem/E",
    "problemId": "11254",
    "problem_idx": "E",
    "shortId": "444E",
    "contest_number": "444",
    "problem_submissions": {
        "B": [
            7031130,
            7030965,
            7024958,
            7024676,
            7030446,
            7027559,
            7026989,
            7029436,
            7032613,
            7026604,
            7041433,
            7024980
        ],
        "C": [
            7029407,
            7026783,
            7028625,
            7029070,
            7027854,
            7035787,
            7035783,
            7031351,
            7029689,
            7028909,
            7032738,
            7033609,
            7027863,
            7030366,
            7026206,
            7047158,
            7029026,
            7027864
        ],
        "A": [
            7026572,
            7023113,
            7022682,
            7021917,
            7022193,
            7021891,
            7023277,
            7021994,
            7023490,
            7022290,
            7021818,
            7029841,
            7024232,
            7028150,
            7022608,
            7022804
        ],
        "E": [
            7025382,
            7029973,
            7031979,
            7031957,
            7039984,
            7039647,
            7030433,
            7029905,
            7030939,
            7032469,
            7032562,
            7035736,
            7041366,
            7041365,
            7041358,
            7041326,
            7036608
        ],
        "D": [
            7030340,
            7032449,
            7029379,
            7031920,
            7032235,
            7032726,
            7027353,
            7024739,
            7032806,
            7032764,
            7032749,
            7032739,
            7032700,
            7031354,
            7029340,
            7031710,
            7032104
        ]
    },
    "name": "E. DZY Loves Planting",
    "statement": "DZY has a weighted tree (connected undirected graph without cycles)\r\ncontaining nodes (they are numbered from to ). He defines the function\r\nas the longest edge in the shortest path between nodes and . Specially\r\nfor every .For every integer sequence , DZY defines as . DZY wants to\r\nfind such a sequence that has maximum possible value. But there is one\r\nmore restriction: the element can appear in at most times.Please, find\r\nthe maximum possible under the described restrictions.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define M 1000000007\n#define N 211111\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n;\npair<int, pt> q[3333];\nint p[3333], sz[3333], kol[3333];\nint maxsz, sum = 0, bad = 0;\n\nint get(int x) {\n\tif (p[x] == x) return x;\n\treturn p[x] = get(p[x]);\n}\n\nvoid unite(int x, int y) {\n\tx = get(x);\n\ty = get(y);\n\tmaxsz = max(maxsz, sz[x] + sz[y]);\n\tsz[x] += sz[y];\n\tkol[x] += kol[y];\n\tif (kol[x] > sum - sz[x]) bad = 1;\n\n\n\tp[y] = x;\n}\n\nint main(){\n//\tfreopen(\"1.in\",\"r\",stdin);\t\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tscanf(\"%d%d%d\", &q[i].S.F, &q[i].S.S, &q[i].F);\n\t\tq[i].S.F--;\n\t\tq[i].S.S--;\n\t}\n\tsort(q, q + n - 1);\n\tint ans = 0;\n\tbad = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tp[i] = i;\n\t\tscanf(\"%d\", &sz[i]);\n\t\tkol[i] = 1;\n\t\tsum += sz[i];\n\t}\n\tfor (int i = 0; i < n; i++) if (kol[i] > sum - sz[i]) bad = 1;\n\tif (bad == 0 && n > 1) ans = q[0].F;\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint j = i;\n\t\twhile (j < n && q[j].F == q[i].F) {\n\t\t\tunite(q[j].S.F, q[j].S.S);\n\t\t\tj++;\n\t\t}\t\t\n\t\ti = j;\n\t\tif (bad == 0 && i < n) ans = q[i].F;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dsu",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. DZY Loves Planting.json",
    "editorial_link": "https://codeforces.com//blog/entry/12959",
    "editorial": "Firstly, use binary search. We need to determine whether the answer can\r\nbe bigger than . Then, every pair must contain at least one edge which\r\nlength is bigger than . Itâs a problem like bipartite graph matching,\r\nand we can use maxflow algorithm to solve it. We create nodes for every\r\nnode of the original tree. We call one of the nodes , and the other .\r\nAnd we need a source and a terminal . Link to every with upper bound ,\r\nand link to with upper bound . Then if the path between node and node\r\ncontains an edge with value larger than , link and with upper bound .\r\nThis means they can match. Every time we build such graph, we must check\r\npairs of nodes, so number of edges of the network is . We can make it\r\nbetter. Consider the process of\r\ntexttt{Divide and Conquer} of a tree, This algorithm can either based on\r\nnode or edge. And The one based on edge is simpler in this problem. Now,\r\nthere are two subtrees , on two sides, we record the maximum edge from\r\nevery node to the current edge we split, we call it . Suppose is in and\r\nis in (it is almost the same in contrast). We create two new nodes , in\r\nthe network to represent the two subtrees. Add edges ( is in ) and edges\r\n( is in ). If is in and , we add an edge . If is in and , we add an edge\r\n. Then use maxflow algorithm. The number of nodes in the network is and\r\nthe number of edges in the network is . So the total complexity is with\r\nreally small constant. Check the C++ code here. This is what I supposed\r\nDIV1-E will be. And thank subscriber for coming up with a really good\r\nalgorithm with time complexity 7025382. And maybe others have the same\r\nidea. This is my mistake, and I feel sorry for not noticing that, Iâm\r\ntoo naive, and not good at solving problems. Please forgive me.\r\n",
    "hint": []
}