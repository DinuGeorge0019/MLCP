{"link": "https://codeforces.com//contest/444/problem/E", "problemId": "11254", "problem_idx": "E", "shortId": "444E", "contest_number": "444", "problem_submissions": {"B": [7031130, 7030965, 7024958, 7024676, 7030446, 7027559, 7026989, 7029436, 7032613, 7026604, 7041433, 7024980], "C": [7029407, 7026783, 7028625, 7029070, 7027854, 7035787, 7035783, 7031351, 7029689, 7028909, 7032738, 7033609, 7027863, 7030366, 7026206, 7047158, 7029026, 7027864], "A": [7026572, 7023113, 7022682, 7021917, 7022193, 7021891, 7023277, 7021994, 7023490, 7022290, 7021818, 7029841, 7024232, 7028150, 7022608, 7022804], "E": [7025382, 7029973, 7031979, 7031957, 7039984, 7039647, 7030433, 7029905, 7030939, 7032469, 7032562, 7035736, 7041366, 7041365, 7041358, 7041326, 7036608], "D": [7030340, 7032449, 7029379, 7031920, 7032235, 7032726, 7027353, 7024739, 7032806, 7032764, 7032749, 7032739, 7032700, 7031354, 7029340, 7031710, 7032104]}, "name": "E. DZY Loves Planting", "statement": "DZY has a weighted tree (connected undirected graph without cycles)\r\ncontaining nodes (they are numbered from to ). He defines the function\r\nas the longest edge in the shortest path between nodes and . Specially\r\nfor every .For every integer sequence , DZY defines as . DZY wants to\r\nfind such a sequence that has maximum possible value. But there is one\r\nmore restriction: the element can appear in at most times.Please, find\r\nthe maximum possible under the described restrictions.\r\n", "solutions": ["#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define M 1000000007\n#define N 211111\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n;\npair<int, pt> q[3333];\nint p[3333], sz[3333], kol[3333];\nint maxsz, sum = 0, bad = 0;\n\nint get(int x) {\n\tif (p[x] == x) return x;\n\treturn p[x] = get(p[x]);\n}\n\nvoid unite(int x, int y) {\n\tx = get(x);\n\ty = get(y);\n\tmaxsz = max(maxsz, sz[x] + sz[y]);\n\tsz[x] += sz[y];\n\tkol[x] += kol[y];\n\tif (kol[x] > sum - sz[x]) bad = 1;\n\n\n\tp[y] = x;\n}\n\nint main(){\n//\tfreopen(\"1.in\",\"r\",stdin);\t\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tscanf(\"%d%d%d\", &q[i].S.F, &q[i].S.S, &q[i].F);\n\t\tq[i].S.F--;\n\t\tq[i].S.S--;\n\t}\n\tsort(q, q + n - 1);\n\tint ans = 0;\n\tbad = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tp[i] = i;\n\t\tscanf(\"%d\", &sz[i]);\n\t\tkol[i] = 1;\n\t\tsum += sz[i];\n\t}\n\tfor (int i = 0; i < n; i++) if (kol[i] > sum - sz[i]) bad = 1;\n\tif (bad == 0 && n > 1) ans = q[0].F;\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint j = i;\n\t\twhile (j < n && q[j].F == q[i].F) {\n\t\t\tunite(q[j].S.F, q[j].S.S);\n\t\t\tj++;\n\t\t}\t\t\n\t\ti = j;\n\t\tif (bad == 0 && i < n) ans = q[i].F;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["binary search", "dsu", "trees"], "dificulty": "2700", "interactive": false}