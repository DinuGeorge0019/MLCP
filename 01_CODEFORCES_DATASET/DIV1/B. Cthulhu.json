{
    "link": "https://codeforces.com//contest/103/problem/B",
    "problemId": "543",
    "problem_idx": "B",
    "shortId": "103B",
    "contest_number": "103",
    "problem_submissions": {
        "E": [
            594225,
            596662,
            39448090,
            39427579,
            39399437,
            595910,
            123375307,
            5405441
        ],
        "D": [
            592292,
            591569,
            591484,
            596181,
            596133,
            591648,
            592548,
            593008,
            592069,
            594057,
            593198,
            593774,
            593994,
            594003,
            593751,
            594358,
            594503,
            597893,
            597881,
            596124,
            595932,
            594188,
            592900,
            594112
        ],
        "C": [
            591729,
            592936,
            593120,
            596123,
            592928,
            591746,
            593864,
            593657,
            591747,
            592188,
            592501,
            592689,
            592235,
            591907,
            592739,
            592446,
            593652,
            592453
        ],
        "B": [
            589933,
            589502,
            590203,
            596103,
            590318,
            590585,
            590813,
            590526,
            590500,
            590943,
            590147,
            591873,
            590310,
            590700,
            590283,
            591089,
            590343,
            590573,
            591133
        ],
        "A": [
            589329,
            591835,
            589264,
            596085,
            589350,
            589466,
            589313,
            589253,
            593567,
            589432,
            589509,
            590045,
            589561,
            589677,
            589370,
            589409,
            590491
        ]
    },
    "name": "B. Cthulhu",
    "statement": "...Once upon a time a man came to the sea. The sea was stormy and dark.\r\nThe man started to call for the little mermaid to appear but alas, he\r\nonly woke up Cthulhu...Whereas on the other end of the world Pentagon is\r\nactively collecting information trying to predict the monster’s behavior\r\nand preparing the secret super weapon. Due to high seismic activity and\r\npoor weather conditions the satellites haven’t yet been able to make\r\nclear shots of the monster. The analysis of the first shot resulted in\r\nan undirected graph with vertices and edges. Now the world’s best minds\r\nare about to determine whether this graph can be regarded as Cthulhu or\r\nnot.To add simplicity, let’s suppose that Cthulhu looks from the space\r\nlike some spherical body with tentacles attached to it. Formally, we\r\nshall regard as Cthulhu such an undirected graph that can be represented\r\nas a set of three or more rooted trees, whose roots are connected by a\r\nsimple cycle.It is guaranteed that the graph contains no multiple edges\r\nand self-loops.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint l[100];\nint n, m;\n\nint leader (int v) {\n\tif (l[v] != v)\n\t\tl[v] = leader (l[v]);\n\treturn l[v];\n}\n\nvoid unite (int v1, int v2) {\n\tv1 = leader (v1);\n\tv2 = leader (v2);\n\tl[v1] = v2;\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tscanf (\"%d%d\", &n, &m);\n\tif (m != n) {\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\tforn (i, n)\n\t\tl[i] = i;\n\tforn (i, n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx --;\n\t\ty --;\n\t\tunite (x, y);\n\t}\n\tforn (i, n-1)\n\t\tif (leader (i) != leader (i+1)) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tcout << \"FHTAGN!\" << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Cthulhu.json",
    "editorial_link": "https://codeforces.com/blog/entry/2426?locale=en",
    "editorial": "Look at the formal part of statement. Cthulhu is a simple cycle with\r\nlength of 3 or more and every vertix of the cycle should be a root of\r\nsome tree. Notice this two important facts: a) Cthulhu is a connected\r\ngraph b) Cthulhu is a graph with only cycle If we add only one edge to\r\ntree (not a multiedge nor loop) then we will get a graph that a) and b)\r\nproperties. There is a simple solution: letâs check graph for\r\nconnectivity (we can do it by one DFS only) and check restriction. If\r\nall are ok then graph is Cthulhu.\r\n",
    "hint": []
}