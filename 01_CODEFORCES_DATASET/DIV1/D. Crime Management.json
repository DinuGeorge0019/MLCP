{"link": "https://codeforces.com//contest/107/problem/D", "problemId": "565", "problem_idx": "D", "shortId": "107D", "contest_number": "107", "problem_submissions": {"D": [631074, 632228, 633629, 632921, 633464, 632054, 631978, 632641, 632457, 632305, 633703, 632778, 632827], "C": [629632, 632720, 632094, 632639, 634261, 630830, 636165, 633949], "B": [628278, 628879, 628954, 627989, 629002, 630226, 628861, 629530, 628650, 628939, 628920, 629402, 628525, 629206, 629445, 629058, 629408], "A": [627482, 627526, 628267, 627433, 628167, 627658, 627777, 628413, 627577, 628188, 628306, 630891, 627548, 627550, 629729, 627698, 627546], "E": [633956]}, "name": "D. Crime Management", "statement": "Zeyad wants to commit crimes in Egypt and not be punished at the end.\r\nThere are several types of crimes. For example, bribery is a crime but\r\nis not considered such when repeated twice. Therefore, bribery is not\r\nconsidered a crime when repeated an even number of times. Speeding is a\r\ncrime, but is not considered such when repeated a number of times which\r\nis a multiple of five.More specifically, conditions on crime repetitions\r\nare known. Each condition describes the crime type and its multiplicity\r\n. If the number of times Zeyad committed the crime is a multiple of ,\r\nZeyad will not be punished for crime . Some crimes may be listed more\r\nthan once. In this case fulfilling at least one condition for this crime\r\nis enough to not be punished for it. Of course, if for certain crime the\r\nnumber of times Zeyad committed it is zero, he is innocent with respect\r\nto this crime.Now Zeyad is interested in a number of ways he can commit\r\nexactly crimes without any punishment.The order of commiting the crimes\r\nmatters. More formally, two ways, sequences and , of committing crimes\r\nare equal if , for all .\r\n", "solutions": ["/*\n * d.cpp\n *\n *  Created on: 2011-8-23\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\ntypedef vector<vector<int> > mat;\nconst int MOD = 12345;\nint N;\n\nmat zero() {\n\treturn mat(N, vector<int>(N, 0));\n}\n\nmat unit() {\n\tmat a = zero();\n\tfor (int i = 0; i < N; ++i) {\n\t\ta[i][i] = 1;\n\t}\n\treturn a;\n}\n\nmat operator*(mat a, mat b) {\n\tmat c = zero();\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tint tmp = 0;\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\ttmp += a[i][k] * b[k][j];\n\t\t\t\tif (k % 10 == 0)\n\t\t\t\t\ttmp %= MOD;\n\t\t\t}\n\t\t\tc[i][j] = tmp % MOD;\n\t\t}\n\t}\n\treturn c;\n}\n\ntypedef long long int64;\n\nmat matPow(mat a, int64 e) {\n\tif (!e)\n\t\treturn unit();\n\treturn e & 1 ? matPow(a, e - 1) * a : matPow(a * a, e >> 1);\n}\nint64 n;\nint c;\n\nint w[1000], mod[1000];\nbool has[26] = { };\n\nint main() {\n\tcin >> n >> c;\n\tN = 1;\n\tfor (int i = 0; i < c; ++i) {\n\t\tchar a;\n\t\tscanf(\" \");\n\t\tcin >> a;\n\t\tw[i] = a - 'A';\n\t\thas[w[i]] = true;\n\t\tcin >> mod[i];\n\t\tN *= mod[i];\n\t}\n\tmat m = zero();\n\tfor (int i = 0; i < N; ++i) {\n\t\tstatic int cur[1000];\n\t\tint x = i;\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tcur[j] = x % mod[j];\n\t\t\tx /= mod[j];\n\t\t}\n\t\tfor (int nxt = 0; nxt < 26; ++nxt)\n\t\t\tif (has[nxt]) {\n\t\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\t\tif (w[j] == nxt) {\n\t\t\t\t\t\t++cur[j];\n\t\t\t\t\t\tif (cur[j] >= mod[j])\n\t\t\t\t\t\t\tcur[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ni = 0;\n\t\t\t\tfor (int j = c - 1; j >= 0; --j) {\n\t\t\t\t\tni = ni * mod[j] + cur[j];\n\t\t\t\t}\n\t\t\t\tm[i][ni]++;\n\t\t\t\tif (m[i][ni] >= MOD)\n\t\t\t\t\tm[i][ni] -= MOD;\n\t\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\t\tif (w[j] == nxt) {\n\t\t\t\t\t\t--cur[j];\n\t\t\t\t\t\tif (cur[j] < 0)\n\t\t\t\t\t\t\tcur[j] += mod[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\tmat r = matPow(m, n);\n\tint ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x = i;\n\t\tbool ok[26] = { };\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tint cur = x % mod[j];\n\t\t\tx /= mod[j];\n\t\t\tif (cur == 0) {\n\t\t\t\tok[w[j]] = true;\n\t\t\t}\n\t\t}\n\t\tbool check = true;\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (has[i] && !ok[i]) {\n\t\t\t\tcheck = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (check) {\n\t\t\t(ans += r[0][i]) %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "graphs", "matrices"], "dificulty": "2400", "interactive": false}