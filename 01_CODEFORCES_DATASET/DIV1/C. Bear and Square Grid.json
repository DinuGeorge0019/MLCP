{
    "link": "https://codeforces.com//contest/679/problem/C",
    "problemId": "61896",
    "problem_idx": "C",
    "shortId": "679C",
    "contest_number": "679",
    "problem_submissions": {
        "D": [
            18322762,
            18323626,
            18322971,
            18323450,
            18324701,
            18327443,
            18345837,
            18345768,
            18345680,
            18345642,
            18327111,
            18328820,
            18327048,
            18328042,
            18328483,
            18329243,
            18329178,
            18324869,
            18324693
        ],
        "B": [
            18314677,
            18309080,
            18312175,
            18311888,
            18312358,
            18312942,
            18316455,
            18317342,
            18309354,
            18307663,
            18316385,
            18308970,
            18308226,
            18309465,
            18308416,
            18312030,
            18314147
        ],
        "C": [
            18310021,
            18317790,
            18318340,
            18317148,
            18319639,
            18318992,
            18320837,
            18322274,
            18315941,
            18322904,
            18316017,
            18318363,
            18318389,
            18317725,
            18315473,
            18314694
        ],
        "A": [
            18303717,
            18304196,
            18305388,
            18304702,
            18306194,
            18307513,
            18307982,
            18303929,
            18304410,
            18304102,
            18305596,
            18304174,
            18305099,
            18303722,
            18303574,
            18304076,
            18305438,
            18304649
        ],
        "E": [
            200103409,
            18853172,
            18325979,
            18447386,
            188767815
        ]
    },
    "name": "C. Bear and Square Grid",
    "statement": "You have a grid with rows and columns. Each cell is either empty\r\n(denoted by \u201d) or blocked (denoted by \u201d).Two empty cells are if they\r\nshare a side. Two cells (located in the row and column ) and are if\r\nthere exists a sequence of empty cells that starts with , finishes with\r\n, and any two consecutive cells in this sequence are directly connected.\r\nA is a set of empty cells such that any two cells in the component are\r\nconnected, and there is no cell in this set that is connected to some\r\ncell not in this set.Your friend Limak is a big grizzly bear. He is able\r\nto destroy any obstacles in some range. More precisely, you can choose a\r\nsquare of size in the grid and Limak will transform all blocked cells\r\nthere to empty ones. However, you can ask Limak to help only once.The\r\nchosen square must be completely inside the grid. It\u2019s possible that\r\nLimak won\u2019t change anything because all cells are empty anyway.You like\r\nbig connected components. After Limak helps you, what is the maximum\r\npossible size of the biggest connected component in the grid?\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint S[510][510], Num[510][510], C[250100], SS, CC[250100], Res;\nchar p[510][510];\nint n, K, cnt;\nvoid DFS(int x, int y){\n    Num[x][y]=cnt;\n    CC[cnt]++;\n    if(!Num[x+1][y] && p[x+1][y] == '.')DFS(x+1,y);\n    if(!Num[x-1][y] && p[x-1][y] == '.')DFS(x-1,y);\n    if(!Num[x][y+1] && p[x][y+1] == '.')DFS(x,y+1);\n    if(!Num[x][y-1] && p[x][y-1] == '.')DFS(x,y-1);\n}\nvoid Ins(int x, int y){\n    int t = Num[x][y];\n    if(!t)return;\n    if(!C[t])SS += CC[t];\n    C[t]++;\n}\nvoid Del(int x, int y){\n    int t = Num[x][y];\n    if(!t)return;\n    C[t]--;\n    if(!C[t])SS -= CC[t];\n}\nint Calc(int x, int y){\n    return S[x+K-1][y+K-1] - S[x-1][y+K-1] - S[x+K-1][y-1] + S[x-1][y-1];\n}\nint main(){\n    int i,j,k;\n    scanf(\"%d%d\",&n,&K);\n    for(i=1;i<=n;i++){\n        scanf(\"%s\",p[i]+1);\n        for(j=1;j<=n;j++){\n            S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1];\n            if(p[i][j]=='.')S[i][j]++;\n        }\n    }\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            if(!Num[i][j] && p[i][j]=='.'){\n                cnt++;\n                DFS(i,j);\n            }\n        }\n    }\n    for(i=1;i<=n-K+1;i++){\n        SS = 0;\n        for(j=1;j<=cnt;j++)C[j]=0;\n        for(j=i-1;j<=i+K;j++){\n            for(k=1;k<=K;k++){\n                Ins(j,k);\n            }\n        }\n        for(j=i;j<i+K;j++){\n            Ins(j,K+1);\n        }\n        Res = max(Res,SS + K*K - Calc(i,1));\n        for(j=2;j<=n-K+1;j++){\n            for(k=i;k<i+K;k++){\n                Del(k,j-2);\n                Ins(k,j+K);\n            }\n            Del(i-1,j-1);\n            Del(i+K,j-1);\n            Ins(i-1,j+K-1);\n            Ins(i+K,j+K-1);\n            Res = max(Res,SS + K*K - Calc(i,j));\n        }\n    }\n    printf(\"%d\\n\",Res);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Bear and Square Grid.json",
    "editorial_link": "https://codeforces.com//blog/entry/45310",
    "editorial": "Let\u00e2\u0080\u0099s first find CC\u00e2\u0080\u0099s (connected components) in the given grid, using\r\nDFS\u00e2\u0080\u0099s. We will consider every possible placement of a square. When the\r\nplacement is fixed then the answer is equal to the sum of the the sum of\r\nsizes of CC\u00e2\u0080\u0099s touching borders of the square (touching from outside),\r\nbut for those CC\u00e2\u0080\u0099s we should only count their cells that are outside of\r\nthe square not to count something twice. We will move a square, and at\r\nthe same time for each CC we will keep the number of its cells outside\r\nthe square. We will used a sliding-window technique. Let\u00e2\u0080\u0099s fix row of\r\nthe grid the upper row of the square. Then, we will first place the\r\nsquare on the left, and then we will slowly move a square to the right.\r\nAs we move a square, we should iterate over cells that stop or start to\r\nbelong to the square. For each such empty cell we should add or subtract\r\nfrom the size of its CC (ids and sizes of CC\u00e2\u0080\u0099s were found at the\r\nbeginning). And for each placement we consider, we should iterate over\r\noutside borders of the square ( cells left, up, right and down side) and\r\nsum up sizes of CC\u00e2\u0080\u0099s touching our square. Be careful to not count some\r\nCC twice you can e.g. keep an array of booleans and mark visited CC\u00e2\u0080\u0099s.\r\nAfter checking all cells you should clear an array, but you can\u00e2\u0080\u0099t do it\r\nin O(number_of_all_components) because it would be too slow. You can\r\ne.g. also add visited CC\u00e2\u0080\u0099s to some vector, and later in the boolean\r\narray clear only CC\u00e2\u0080\u0099s from the vector (and then clear vector). The\r\ncomplexity is . code1\r\n"
}