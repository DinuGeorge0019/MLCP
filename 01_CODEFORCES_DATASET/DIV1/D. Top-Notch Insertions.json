{"link": "https://codeforces.com//contest/1558/problem/D", "problemId": "1088952", "problem_idx": "D", "shortId": "1558D", "contest_number": "1558", "problem_submissions": {"F": [126899482, 126888055, 126902100, 126890640, 126888389, 126894123, 126904590, 126900041, 126902212, 126902942, 127549735, 127006693], "E": [126883583, 126896785, 126884151, 126898148, 126905418, 126902611, 126899238, 126907028, 126907352, 126891363, 126891974, 126891356, 126892061, 126902546, 126900088, 126903655, 126904227, 126900317, 126902700], "D": [126869704, 126870708, 126871179, 126874038, 126874151, 126876731, 126871810, 126867588, 126872511, 126871952, 126882884, 126882215, 126882465, 126878861, 126876122, 126890668, 126874784, 126883630, 126892178, 126890480], "B": [126858181, 126855670, 126854102, 126855872, 126858058, 126860085, 126854841, 126852806, 126853901, 126856718, 126855353, 126856232, 126858032, 126857658, 126854131, 126863721, 126854756, 126864821, 126867061, 126863501], "A": [126854362, 126850555, 126848635, 126848815, 126849088, 126855964, 126848126, 126847884, 126848457, 126849581, 126847772, 126849333, 126852232, 126849014, 126848809, 126853376, 126847687, 126859049, 126849750, 126850402], "C": [126850882, 126858888, 126859482, 126861350, 126866099, 126867225, 126859442, 126858664, 126862495, 126861859, 126865577, 126860578, 126863128, 126865366, 126858535, 126873768, 126863562, 126873408, 126874458, 126871983]}, "name": "D. Top-Notch Insertions", "statement": "Consider the insertion sort algorithm used to sort an integer sequence\r\n[a_1, a_2,\r\nldots, a_n] of length n in non-decreasing order.For each i in order from\r\n2 to n, do the following. If a_i\r\nge a_{i-1}, do nothing and move on to the next value of i. Otherwise,\r\nfind the smallest j such that a_i < a_j, shift the elements on positions\r\nfrom j to i-1 by one position to the right, and write down the initial\r\nvalue of a_i to position j. In this case we\u2019ll say that we performed an\r\nof an element from position i to position j.It can be noticed that after\r\nprocessing any i, the prefix of the sequence [a_1, a_2,\r\nldots, a_i] is sorted in non-decreasing order, therefore, the algorithm\r\nindeed sorts any sequence.For example, sorting [4, 5, 3, 1, 3] proceeds\r\nas follows: i = 2: a_2\r\nge a_1, do nothing; i = 3: j = 1, insert from position 3 to position 1:\r\n[3, 4, 5, 1, 3]; i = 4: j = 1, insert from position 4 to position 1: [1,\r\n3, 4, 5, 3]; i = 5: j = 3, insert from position 5 to position 3: [1, 3,\r\n3, 4, 5]. You are given an integer n and a list of m integer pairs (x_i,\r\ny_i). We are interested in sequences such that if you sort them using\r\nthe above algorithm, exactly m insertions will be performed: first from\r\nposition x_1 to position y_1, then from position x_2 to position y_2,\r\n..., finally, from position x_m to position y_m.How many sequences of\r\nlength n consisting of (not necessarily distinct) integers between 1 and\r\nn, inclusive, satisfy the above condition? Print this number modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#include <bits/extc++.h> /** keep-include */\nusing namespace __gnu_pbds;\n \ntemplate<class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag,\n    tree_order_statistics_node_update>;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nordered_set<int> work;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> x(m), y(m);\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\n\t}\n\tvector<pair<int,int> > constraints;\n\tfor(int i = m-1; i >= 0; i--){\n\t\tauto it = work.find_by_order(y[i]);\n\t\tconstraints.push_back({*it, *next(it)});\n\t\twork.erase(it);\n\t}\n\tint ns = 0;\n\tfor(auto [a, b] : constraints){\n\t\tif(a+1 == b) ns++;\n\t}\n\tnum ans = ncr(n + n-1 - ns, n);\n\tcout << ans << '\\n';\n\tfor(auto [a, b] : constraints){\n\t\twork.insert(a);\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tconst int MAXN = 200100;\n\tfor(int i = 0; i < MAXN; i++) work.insert(i);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"], "input": "", "output": "", "tags": ["combinatorics", "data structures"], "dificulty": "2600", "interactive": false}