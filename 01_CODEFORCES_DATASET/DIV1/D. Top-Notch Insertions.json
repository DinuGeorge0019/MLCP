{
    "link": "https://codeforces.com//contest/1558/problem/D",
    "problemId": "1088952",
    "problem_idx": "D",
    "shortId": "1558D",
    "contest_number": "1558",
    "problem_submissions": {
        "F": [
            126899482,
            126888055,
            126902100,
            126890640,
            126888389,
            126894123,
            126904590,
            126900041,
            126902212,
            126902942,
            127549735,
            127006693
        ],
        "E": [
            126883583,
            126896785,
            126884151,
            126898148,
            126905418,
            126902611,
            126899238,
            126907028,
            126907352,
            126891363,
            126891974,
            126891356,
            126892061,
            126902546,
            126900088,
            126903655,
            126904227,
            126900317,
            126902700
        ],
        "D": [
            126869704,
            126870708,
            126871179,
            126874038,
            126874151,
            126876731,
            126871810,
            126867588,
            126872511,
            126871952,
            126882884,
            126882215,
            126882465,
            126878861,
            126876122,
            126890668,
            126874784,
            126883630,
            126892178,
            126890480
        ],
        "B": [
            126858181,
            126855670,
            126854102,
            126855872,
            126858058,
            126860085,
            126854841,
            126852806,
            126853901,
            126856718,
            126855353,
            126856232,
            126858032,
            126857658,
            126854131,
            126863721,
            126854756,
            126864821,
            126867061,
            126863501
        ],
        "A": [
            126854362,
            126850555,
            126848635,
            126848815,
            126849088,
            126855964,
            126848126,
            126847884,
            126848457,
            126849581,
            126847772,
            126849333,
            126852232,
            126849014,
            126848809,
            126853376,
            126847687,
            126859049,
            126849750,
            126850402
        ],
        "C": [
            126850882,
            126858888,
            126859482,
            126861350,
            126866099,
            126867225,
            126859442,
            126858664,
            126862495,
            126861859,
            126865577,
            126860578,
            126863128,
            126865366,
            126858535,
            126873768,
            126863562,
            126873408,
            126874458,
            126871983
        ]
    },
    "name": "D. Top-Notch Insertions",
    "statement": "Consider the insertion sort algorithm used to sort an integer sequence\r\n[a_1, a_2,\r\nldots, a_n] of length n in non-decreasing order.For each i in order from\r\n2 to n, do the following. If a_i\r\nge a_{i-1}, do nothing and move on to the next value of i. Otherwise,\r\nfind the smallest j such that a_i < a_j, shift the elements on positions\r\nfrom j to i-1 by one position to the right, and write down the initial\r\nvalue of a_i to position j. In this case we\u2019ll say that we performed an\r\nof an element from position i to position j.It can be noticed that after\r\nprocessing any i, the prefix of the sequence [a_1, a_2,\r\nldots, a_i] is sorted in non-decreasing order, therefore, the algorithm\r\nindeed sorts any sequence.For example, sorting [4, 5, 3, 1, 3] proceeds\r\nas follows: i = 2: a_2\r\nge a_1, do nothing; i = 3: j = 1, insert from position 3 to position 1:\r\n[3, 4, 5, 1, 3]; i = 4: j = 1, insert from position 4 to position 1: [1,\r\n3, 4, 5, 3]; i = 5: j = 3, insert from position 5 to position 3: [1, 3,\r\n3, 4, 5]. You are given an integer n and a list of m integer pairs (x_i,\r\ny_i). We are interested in sequences such that if you sort them using\r\nthe above algorithm, exactly m insertions will be performed: first from\r\nposition x_1 to position y_1, then from position x_2 to position y_2,\r\n..., finally, from position x_m to position y_m.How many sequences of\r\nlength n consisting of (not necessarily distinct) integers between 1 and\r\nn, inclusive, satisfy the above condition? Print this number modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#include <bits/extc++.h> /** keep-include */\nusing namespace __gnu_pbds;\n \ntemplate<class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag,\n    tree_order_statistics_node_update>;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nordered_set<int> work;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> x(m), y(m);\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\n\t}\n\tvector<pair<int,int> > constraints;\n\tfor(int i = m-1; i >= 0; i--){\n\t\tauto it = work.find_by_order(y[i]);\n\t\tconstraints.push_back({*it, *next(it)});\n\t\twork.erase(it);\n\t}\n\tint ns = 0;\n\tfor(auto [a, b] : constraints){\n\t\tif(a+1 == b) ns++;\n\t}\n\tnum ans = ncr(n + n-1 - ns, n);\n\tcout << ans << '\\n';\n\tfor(auto [a, b] : constraints){\n\t\twork.insert(a);\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tconst int MAXN = 200100;\n\tfor(int i = 0; i < MAXN; i++) work.insert(i);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Top-Notch Insertions.json",
    "editorial_link": "https://codeforces.com//blog/entry/94216",
    "editorial": "First of all, note that the sequence of insertions uniquely determines\r\nwhere each element goes. For example, for and a sequence of insertions ,\r\nthe initial sequence is always transformed into , no matter what are.\r\nThus, instead of counting the initial sequences, we might count the\r\nfinal sequences instead.Let the final sequence be . From its sortedness,\r\nwe know that for every .Consider a single iteration of the sorting\r\nalgorithm. If , no insertion occurs. This actually doesn\u00e2\u0080\u0099t give us any\r\nextra information: we know that is placed later than in the final\r\nsequence anyway.What happens though if is inserted into position ?We\r\nknow that and also, since is the smallest index with such property, .\r\nAgain, a non-strict inequality doesn\u00e2\u0080\u0099t give us anything. However,\r\nknowing that is actually important.It turns out that we are interested\r\nin elements such that we have ever inserted an element during sorting.\r\nFor every such element, we know that the previous element in the sorted\r\norder is strictly smaller. All other pairs of neighboring elements can\r\neither be equal, or the earlier one can be smaller.All in all, let be\r\nthe number of indices such that (for all the other values of , ). How\r\nmany different sequences with integers from to satisfy this? This number\r\ncan be shown to be equal to .(The proof can go as follows: for each such\r\nthat , increase each of by . Now for every we have , and the maximum\r\npossible value of an element increased to . Thus, we have built a\r\nbijection from the sequences we are searching for to the sequences of\r\nnumbers between and . The number of the latter sequences is clearly\r\n.)How to find ? It can be done by going through the insertions and\r\nmaintaining a balanced binary search tree of your choice. However,\r\nimplementation becomes simpler if we process the insertions in reverse\r\norder.Let\u00e2\u0080\u0099s maintain a set of positions in the final sorted order that\r\nare not yet filled in. Initially, the set contains all integers from to\r\n. For each insertion (in reverse order), let be the -th smallest element\r\nof , and let be the -th smallest element of . Since we insert before ,\r\nmark position as \"a position such that we have ever inserted an element\r\nright before it\" (which is important for calculating ). Then, erase from\r\nthe set.As a data structure that can handle finding the -th smallest\r\nelement, we can use a balanced binary search tree, a segment tree, or\r\nbinary search over Fenwick tree (in C++ we can also use a built-in\r\npolicy-based data structure).Finally, to solve each test case in and not\r\n, we can have a single data structure instance for solving all test\r\ncases, and roll back any changes we apply while solving each test case.\r\n"
}