{
    "link": "https://codeforces.com//contest/521/problem/D",
    "problemId": "23441",
    "problem_idx": "D",
    "shortId": "521D",
    "contest_number": "521",
    "problem_submissions": {
        "D": [
            10114323,
            10113689,
            10119859,
            10119855,
            10119796,
            10113492,
            10113596,
            10116089,
            10113726,
            10114226,
            10114023,
            10114948,
            10114997,
            10118008,
            10116808,
            10115969,
            10115919,
            115640381
        ],
        "B": [
            10109892,
            10107901,
            10108581,
            10107819,
            10114473,
            10108104,
            10108433,
            10109077,
            10107764,
            10108790,
            10107608,
            10107745,
            10107578,
            10110313,
            10108219,
            10110179,
            10111006
        ],
        "C": [
            10109219,
            10110415,
            10110107,
            10111080,
            10109986,
            10110836,
            10111159,
            10109138,
            10106797,
            10109327,
            10109438,
            10109146,
            10106442,
            10110202,
            10108389,
            10108555
        ],
        "A": [
            10105003,
            10105742,
            10105267,
            10111233,
            10104462,
            10105194,
            10105511,
            10104861,
            10104854,
            10104826,
            10105033,
            10104516,
            10107256,
            10104819,
            10105232,
            10104822
        ],
        "E": [
            10113230,
            10117526,
            249300397
        ]
    },
    "name": "D. Shop",
    "statement": "Vasya plays one very well-known and extremely popular MMORPG game. His\r\ngame character has skill; currently the -th of them equals to . Also\r\nthis game has a common rating table in which the participants are ranked\r\naccording to the of all the skills of a hero in the descending\r\norder.Vasya decided to ’upgrade’ his character via the game store. This\r\nstore offers possible ways to improve the hero’s skills; Each of these\r\nways belongs to one of three types: assign the -th skill to ; add to the\r\n-th skill; multiply the -th skill by . Unfortunately, a) every\r\nimprovement can only be used once; b) the money on Vasya’s card is\r\nenough only to purchase not more than of the improvements. Help Vasya to\r\nreach the highest ranking in the game. To do this tell Vasya which of\r\nimprovements he has to purchase and in what order he should use them to\r\nmake his rating become as high as possible. If there are several ways to\r\nachieve it, print any of them.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <cstdint>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define mp make_pair\n\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate <typename T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <typename T> void chmax(T &t, const T &f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct Rat {\n\tInt p, q;\n\tRat() {}\n\tRat(Int p, Int q = 1) : p(p), q(q) { reduce(); }\n\tvoid reduce() { Int g = __gcd(p, q); p /= g; q /= g; if (q < 0 || (q == 0 && p < 0)) { p = -p; q = -q; } }\n\tRat operator+(const Rat &a) const { return Rat(p * a.q + q * a.p, q * a.q); }\n\tRat operator-(const Rat &a) const { return Rat(p * a.q - q * a.p, q * a.q); }\n\tRat operator*(const Rat &a) const { return Rat(p * a.p, q * a.q); }\n\tRat operator/(const Rat &a) const { return Rat(p * a.q, q * a.p); }\n\tRat &operator+=(const Rat &a) { return *this = *this + a; }\n\tRat &operator-=(const Rat &a) { return *this = *this - a; }\n\tRat &operator*=(const Rat &a) { return *this = *this * a; }\n\tRat &operator/=(const Rat &a) { return *this = *this / a; }\n\tRat operator+() const { return *this; }\n\tRat operator-() const { return Rat(-p, q); }\n\tbool operator< (const Rat &a) const { return (p * a.q <  q * a.p); }\n\tbool operator<=(const Rat &a) const { return (p * a.q <= q * a.p); }\n\tbool operator> (const Rat &a) const { return (p * a.q >  q * a.p); }\n\tbool operator>=(const Rat &a) const { return (p * a.q >= q * a.p); }\n\tbool operator==(const Rat &a) const { return  (p == a.p && q == a.q); }\n\tbool operator!=(const Rat &a) const { return !(p == a.p && q == a.q); }\n\texplicit operator double() const { return (double)p / (double)q; }\n\texplicit operator long double() const { return (long double)p / (long double)q; }\n\tfriend ostream &operator<<(ostream &os, const Rat &a) { os << a.p << \"/\" << a.q; return os; }\n};\n\nint K, N, M;\nInt A[100010];\nint T[100010], I[100010];\nInt B[100010];\n\nInt as[100010];\npair<Int, int> b1[100010];\nvector<pair<Int, int>> b2[100010];\nvector<pair<Int, int>> b3;\n\nmultiset<pair<Rat, int>> q;\n\nvoid addThem(int k) {\n\t/*\n\tif (b1[k].second != -1) {\n\t\tq.emplace(Rat(b1[k].first, as[k]), b1[k].second);\n\t}\n\t*/\n\tif (b2[k].back().second != -1) {\n\t\tq.emplace(Rat(as[k] + b2[k].back().first, as[k]), b2[k].back().second);\n\t}\n}\nvoid removeThem(int k) {\n\t/*\n\t{\n\t\tauto it = q.find(mp(Rat(b1[k].first, as[k]), b1[k].second));\n\t\tif (it != q.end()) {\n\t\t\tq.erase(it);\n\t\t}\n\t}\n\t*/\n\t{\n\t\tauto it = q.find(mp(Rat(as[k] + b2[k].back().first, as[k]), b2[k].back().second));\n\t\tif (it != q.end()) {\n\t\t\tq.erase(it);\n\t\t}\n\t}\n}\n\nint ansLen;\nint ans[100010];\nint ans1Len;\nint ans1[100010];\n\nint main() {\n\t\n\t\n\tfor (; ~scanf(\"%d%d%d\", &K, &N, &M); ) {\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tA[k] = in();\n\t\t}\n\t\tfor (int n = 0; n < N; ++n) {\n\t\t\tT[n] = in();\n\t\t\tI[n] = in() - 1;\n\t\t\tB[n] = in();\n\t\t}\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tas[k] = A[k];\n\t\t\tb1[k] = mp(0, -1);\n\t\t\tb2[k] = { mp(0, -1) };\n\t\t}\n\t\tb3.clear();\n\t\tfor (int n = 0; n < N; ++n) {\n\t\t\tconst int k = I[n];\n\t\t\tswitch (T[n]) {\n\t\t\t\tcase 1: {\n\t\t\t\t\tchmax(b1[k], mp(B[n], n));\n\t\t\t\t} break;\n\t\t\t\tcase 2: {\n\t\t\t\t\tb2[k].emplace_back(B[n], n);\n\t\t\t\t} break;\n\t\t\t\tcase 3: {\n\t\t\t\t\tb3.emplace_back(B[n], n);\n\t\t\t\t} break;\n\t\t\t\tdefault: assert(false);\n\t\t\t}\n\t\t}\n\t\tfor (; (int)b3.size() < N + 1; ) {\n\t\t\tb3.emplace_back(1, -1);\n\t\t}\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tif (b1[k].first > A[k]) {\n\t\t\t\tb2[k].emplace_back(b1[k].first - A[k], b1[k].second);\n\t\t\t}\n\t\t\tsort(b2[k].begin(), b2[k].end());\n\t\t}\n\t\tsort(b3.begin(), b3.end());\n/*\nfor(int k=0;k<K;++k){\n cout<<\"b1[\"<<k<<\"] = \"<<b1[k]<<endl;\n cout<<\"b2[\"<<k<<\"] : \";pv(b2[k].begin(),b2[k].end());\n}\ncout<<\"b3 : \";pv(b3.begin(),b3.end());\n*/\n\t\tq = { mp(1, -1) };\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\taddThem(k);\n\t\t}\n\t\tansLen = 0;\n\t\tfor (int m = 0; m < M; ++m) {\n// cout<<\"q : \";pv(q.begin(),q.end());\n\t\t\tauto best = --q.end();\n// cout<<\"  \"<<*best<<\" vs \"<<b3[(int)b3.size() - (M - m)]<<endl;\n\t\t\tif (best->first > b3[(int)b3.size() - (M - m)].first) {\n\t\t\t\tconst int n = best->second;\n\t\t\t\tassert(n != -1);\n\t\t\t\tq.erase(best);\n\t\t\t\tans[ansLen++] = n;\n\t\t\t\tconst int k = I[n];\n\t\t\t\tremoveThem(k);\n\t\t\t\t/*\n\t\t\t\tswitch (T[n]) {\n\t\t\t\t\tcase 1: {\n\t\t\t\t\t\tassert(b1[k].second == n);\n\t\t\t\t\t\tb1[k] = mp(0, -1);\n\t\t\t\t\t\tas[k] = B[k];\n\t\t\t\t\t} break;\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tassert(b2[k].back().second == n);\n\t\t\t\t\t\tb2[k].pop_back();\n\t\t\t\t\t\tas[k] += B[k];\n\t\t\t\t\t} break;\n\t\t\t\t\tdefault: assert(false);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tassert(b2[k].back().second == n);\n\t\t\t\tas[k] += b2[k].back().first;\n\t\t\t\tb2[k].pop_back();\n\t\t\t\t\n\t\t\t\taddThem(k);\n\t\t\t} else {\n\t\t\t\tfor (; m < M; ++m) {\n\t\t\t\t\tconst int n = b3.back().second;\n\t\t\t\t\tif (n == -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tb3.pop_back();\n\t\t\t\t\tans[ansLen++] = n;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans1Len = 0;\n\t\tfor (int i = 0; i < ansLen; ++i) {\n\t\t\tif (T[ans[i]] == 1) {\n\t\t\t\tans1[ans1Len++] = ans[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ansLen; ++i) {\n\t\t\tif (T[ans[i]] != 1) {\n\t\t\t\tans1[ans1Len++] = ans[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans1Len);\n\t\tfor (int i = 0; i < ans1Len; ++i) {\n\t\t\tif (i > 0) printf(\" \");\n\t\t\tprintf(\"%d\", ans1[i] + 1);\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Shop.json",
    "editorial_link": "https://codeforces.com//blog/entry/16736",
    "editorial": "Suppose the only type of upgrades we have is multiplication. It doesn't even matter for the answer which particular skill we are going to multiply, so we just choose several upgrades with greatest values of bi.\n\nNow we have additions as well; set multiplications aside for a moment. It is clear that for every skill we should choose several largest additions (maybe none). Let us sort the additions for every skill by non-increasing; now we should choose several first upgrades for each type. Now, for some skill the (non-increasing) sorted row of b's is b1, ..., bl, and the initial value of the skill is a. Now, as we have decided to take some prefix of b's, we know that if we take the upgrade bi, the value changes from a?+?b1?+?...?+?bi?-?1 to a?+?b1?+?...?+?bi?-?1?+?bi. That is, the ratio by which the value (and the whole product of values) is going to be multiplied by is the fraction . Now, with that ratio determined unambigiously for each addition upgrade, every addition has actually become a multiplication. =) So we have to compute the ratios for all additions (that is, we sort b's for each skill separately and find the fractions), and then sort the multiplications and additions altogether by the ratio they affect the whole product with. Clearly, all multiplications should be used after all the additions are done; that is, to choose which upgrades we use we should do the ratio sorting, but the order of actual using of upgrades is: first do all the additions, then do all the multiplications.\n\nFinally, let's deal with the assignment upgrades. Clearly, for each skill at most one assignment upgrade should be used, and if it used, it should the assignment upgrade with the largest b among all assignments for this skill. Also, if the assignment is used, it should be used before all the additions and multiplications for this skill. So, for each skill we should simply determine whether we use the largest assignment for this skill or not. However, if we use the assignment, the ratios for the additions of current skill become invalid as the starting value of a is altered.\n\nTo deal with this problem, imagine that we have first chosen some addition upgrades, and now we have to choose whether we use the assignment upgrade or not. If we do, the value of the skill changes from a?+?b1?+?...?+?bk to b?+?b1?+?...?+?bk. That is, the assignment here behaves pretty much the same way as the addition of b?-?a. The only difference is that once we have chosen to use the assignment, we should put it before all the additions.\n\nThat is, all largest assigments for each skill should be made into additions of b?-?a and processed along with all the other additions, which are, as we already know, going to become multiplications in the end. =)\n\nFinally, the problem is reduced to sorting the ratios for all upgrades. Let us estimate the numbers in the fractions. The ratio for a multiplication is an integer up to 106; the ratio for an addition is a fraction of general form . As k can be up to 105, and bi is up to 106, the numerator and denominator of such fraction can go up to 1011. To compare fractions  and  we should compare the products ad and bc, which can go up to 1022 by our estimates. That, unfortunately, overflows built-in integer types in most languages. However, this problem can be solved by subtracting 1 from all ratios (which clearly does not change the order of ratios), so that the additions' ratios will look like . Now, the numerator is up to 106, the products in the comparison are up to 1017, which fits in 64-bit integer type in any language.",
    "hint": []
}