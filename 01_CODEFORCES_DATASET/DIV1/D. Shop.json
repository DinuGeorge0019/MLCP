{"link": "https://codeforces.com//contest/521/problem/D", "problemId": "23441", "problem_idx": "D", "shortId": "521D", "contest_number": "521", "problem_submissions": {"D": [10114323, 10113689, 10119859, 10119855, 10119796, 10113492, 10113596, 10116089, 10113726, 10114226, 10114023, 10114948, 10114997, 10118008, 10116808, 10115969, 10115919, 115640381], "B": [10109892, 10107901, 10108581, 10107819, 10114473, 10108104, 10108433, 10109077, 10107764, 10108790, 10107608, 10107745, 10107578, 10110313, 10108219, 10110179, 10111006], "C": [10109219, 10110415, 10110107, 10111080, 10109986, 10110836, 10111159, 10109138, 10106797, 10109327, 10109438, 10109146, 10106442, 10110202, 10108389, 10108555], "A": [10105003, 10105742, 10105267, 10111233, 10104462, 10105194, 10105511, 10104861, 10104854, 10104826, 10105033, 10104516, 10107256, 10104819, 10105232, 10104822], "E": [10113230, 10117526, 249300397]}, "name": "D. Shop", "statement": "Vasya plays one very well-known and extremely popular MMORPG game. His\r\ngame character has skill; currently the -th of them equals to . Also\r\nthis game has a common rating table in which the participants are ranked\r\naccording to the of all the skills of a hero in the descending\r\norder.Vasya decided to \u2019upgrade\u2019 his character via the game store. This\r\nstore offers possible ways to improve the hero\u2019s skills; Each of these\r\nways belongs to one of three types: assign the -th skill to ; add to the\r\n-th skill; multiply the -th skill by . Unfortunately, a) every\r\nimprovement can only be used once; b) the money on Vasya\u2019s card is\r\nenough only to purchase not more than of the improvements. Help Vasya to\r\nreach the highest ranking in the game. To do this tell Vasya which of\r\nimprovements he has to purchase and in what order he should use them to\r\nmake his rating become as high as possible. If there are several ways to\r\nachieve it, print any of them.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <cstdint>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define mp make_pair\n\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate <typename T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <typename T> void chmax(T &t, const T &f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct Rat {\n\tInt p, q;\n\tRat() {}\n\tRat(Int p, Int q = 1) : p(p), q(q) { reduce(); }\n\tvoid reduce() { Int g = __gcd(p, q); p /= g; q /= g; if (q < 0 || (q == 0 && p < 0)) { p = -p; q = -q; } }\n\tRat operator+(const Rat &a) const { return Rat(p * a.q + q * a.p, q * a.q); }\n\tRat operator-(const Rat &a) const { return Rat(p * a.q - q * a.p, q * a.q); }\n\tRat operator*(const Rat &a) const { return Rat(p * a.p, q * a.q); }\n\tRat operator/(const Rat &a) const { return Rat(p * a.q, q * a.p); }\n\tRat &operator+=(const Rat &a) { return *this = *this + a; }\n\tRat &operator-=(const Rat &a) { return *this = *this - a; }\n\tRat &operator*=(const Rat &a) { return *this = *this * a; }\n\tRat &operator/=(const Rat &a) { return *this = *this / a; }\n\tRat operator+() const { return *this; }\n\tRat operator-() const { return Rat(-p, q); }\n\tbool operator< (const Rat &a) const { return (p * a.q <  q * a.p); }\n\tbool operator<=(const Rat &a) const { return (p * a.q <= q * a.p); }\n\tbool operator> (const Rat &a) const { return (p * a.q >  q * a.p); }\n\tbool operator>=(const Rat &a) const { return (p * a.q >= q * a.p); }\n\tbool operator==(const Rat &a) const { return  (p == a.p && q == a.q); }\n\tbool operator!=(const Rat &a) const { return !(p == a.p && q == a.q); }\n\texplicit operator double() const { return (double)p / (double)q; }\n\texplicit operator long double() const { return (long double)p / (long double)q; }\n\tfriend ostream &operator<<(ostream &os, const Rat &a) { os << a.p << \"/\" << a.q; return os; }\n};\n\nint K, N, M;\nInt A[100010];\nint T[100010], I[100010];\nInt B[100010];\n\nInt as[100010];\npair<Int, int> b1[100010];\nvector<pair<Int, int>> b2[100010];\nvector<pair<Int, int>> b3;\n\nmultiset<pair<Rat, int>> q;\n\nvoid addThem(int k) {\n\t/*\n\tif (b1[k].second != -1) {\n\t\tq.emplace(Rat(b1[k].first, as[k]), b1[k].second);\n\t}\n\t*/\n\tif (b2[k].back().second != -1) {\n\t\tq.emplace(Rat(as[k] + b2[k].back().first, as[k]), b2[k].back().second);\n\t}\n}\nvoid removeThem(int k) {\n\t/*\n\t{\n\t\tauto it = q.find(mp(Rat(b1[k].first, as[k]), b1[k].second));\n\t\tif (it != q.end()) {\n\t\t\tq.erase(it);\n\t\t}\n\t}\n\t*/\n\t{\n\t\tauto it = q.find(mp(Rat(as[k] + b2[k].back().first, as[k]), b2[k].back().second));\n\t\tif (it != q.end()) {\n\t\t\tq.erase(it);\n\t\t}\n\t}\n}\n\nint ansLen;\nint ans[100010];\nint ans1Len;\nint ans1[100010];\n\nint main() {\n\t\n\t\n\tfor (; ~scanf(\"%d%d%d\", &K, &N, &M); ) {\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tA[k] = in();\n\t\t}\n\t\tfor (int n = 0; n < N; ++n) {\n\t\t\tT[n] = in();\n\t\t\tI[n] = in() - 1;\n\t\t\tB[n] = in();\n\t\t}\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tas[k] = A[k];\n\t\t\tb1[k] = mp(0, -1);\n\t\t\tb2[k] = { mp(0, -1) };\n\t\t}\n\t\tb3.clear();\n\t\tfor (int n = 0; n < N; ++n) {\n\t\t\tconst int k = I[n];\n\t\t\tswitch (T[n]) {\n\t\t\t\tcase 1: {\n\t\t\t\t\tchmax(b1[k], mp(B[n], n));\n\t\t\t\t} break;\n\t\t\t\tcase 2: {\n\t\t\t\t\tb2[k].emplace_back(B[n], n);\n\t\t\t\t} break;\n\t\t\t\tcase 3: {\n\t\t\t\t\tb3.emplace_back(B[n], n);\n\t\t\t\t} break;\n\t\t\t\tdefault: assert(false);\n\t\t\t}\n\t\t}\n\t\tfor (; (int)b3.size() < N + 1; ) {\n\t\t\tb3.emplace_back(1, -1);\n\t\t}\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tif (b1[k].first > A[k]) {\n\t\t\t\tb2[k].emplace_back(b1[k].first - A[k], b1[k].second);\n\t\t\t}\n\t\t\tsort(b2[k].begin(), b2[k].end());\n\t\t}\n\t\tsort(b3.begin(), b3.end());\n/*\nfor(int k=0;k<K;++k){\n cout<<\"b1[\"<<k<<\"] = \"<<b1[k]<<endl;\n cout<<\"b2[\"<<k<<\"] : \";pv(b2[k].begin(),b2[k].end());\n}\ncout<<\"b3 : \";pv(b3.begin(),b3.end());\n*/\n\t\tq = { mp(1, -1) };\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\taddThem(k);\n\t\t}\n\t\tansLen = 0;\n\t\tfor (int m = 0; m < M; ++m) {\n// cout<<\"q : \";pv(q.begin(),q.end());\n\t\t\tauto best = --q.end();\n// cout<<\"  \"<<*best<<\" vs \"<<b3[(int)b3.size() - (M - m)]<<endl;\n\t\t\tif (best->first > b3[(int)b3.size() - (M - m)].first) {\n\t\t\t\tconst int n = best->second;\n\t\t\t\tassert(n != -1);\n\t\t\t\tq.erase(best);\n\t\t\t\tans[ansLen++] = n;\n\t\t\t\tconst int k = I[n];\n\t\t\t\tremoveThem(k);\n\t\t\t\t/*\n\t\t\t\tswitch (T[n]) {\n\t\t\t\t\tcase 1: {\n\t\t\t\t\t\tassert(b1[k].second == n);\n\t\t\t\t\t\tb1[k] = mp(0, -1);\n\t\t\t\t\t\tas[k] = B[k];\n\t\t\t\t\t} break;\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tassert(b2[k].back().second == n);\n\t\t\t\t\t\tb2[k].pop_back();\n\t\t\t\t\t\tas[k] += B[k];\n\t\t\t\t\t} break;\n\t\t\t\t\tdefault: assert(false);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tassert(b2[k].back().second == n);\n\t\t\t\tas[k] += b2[k].back().first;\n\t\t\t\tb2[k].pop_back();\n\t\t\t\t\n\t\t\t\taddThem(k);\n\t\t\t} else {\n\t\t\t\tfor (; m < M; ++m) {\n\t\t\t\t\tconst int n = b3.back().second;\n\t\t\t\t\tif (n == -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tb3.pop_back();\n\t\t\t\t\tans[ansLen++] = n;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans1Len = 0;\n\t\tfor (int i = 0; i < ansLen; ++i) {\n\t\t\tif (T[ans[i]] == 1) {\n\t\t\t\tans1[ans1Len++] = ans[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ansLen; ++i) {\n\t\t\tif (T[ans[i]] != 1) {\n\t\t\t\tans1[ans1Len++] = ans[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans1Len);\n\t\tfor (int i = 0; i < ans1Len; ++i) {\n\t\t\tif (i > 0) printf(\" \");\n\t\t\tprintf(\"%d\", ans1[i] + 1);\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["greedy"], "dificulty": "2800", "interactive": false}