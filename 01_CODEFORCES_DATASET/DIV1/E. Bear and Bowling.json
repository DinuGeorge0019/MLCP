{
    "link": "https://codeforces.com//contest/573/problem/E",
    "problemId": "34314",
    "problem_idx": "E",
    "shortId": "573E",
    "contest_number": "573",
    "problem_submissions": {
        "E": [
            12759251,
            12766903,
            12766685,
            12854212
        ],
        "C": [
            12753961,
            12751834,
            12752631,
            12751871,
            12753878,
            12754621,
            12753383,
            12752808,
            12753460,
            12750581,
            12750687,
            12754051,
            12757263,
            12753734,
            12752897,
            12751281,
            12753745,
            12753332
        ],
        "B": [
            12746992,
            12747515,
            12746798,
            12748316,
            12747498,
            12747954,
            12747704,
            12747330,
            12747866,
            12747572,
            12747495,
            12748230,
            12747423,
            12748530,
            12748216,
            12747086,
            12747056,
            12748571
        ],
        "A": [
            12746189,
            12746077,
            12746084,
            12746660,
            12746402,
            12746165,
            12746157,
            12746206,
            12746195,
            12746103,
            12746141,
            12746264,
            12746158,
            12746252,
            12746081,
            12746225,
            12746120,
            12746512
        ],
        "D": [
            12760293,
            12767357,
            12767345,
            12767321,
            12767302,
            12767261,
            12766285,
            12766274,
            12759069,
            12759185,
            12761792,
            12787796,
            12787738,
            12787732,
            12762112,
            12766448,
            12762456,
            12761429,
            12791178,
            12769647,
            12769635
        ]
    },
    "name": "E. Bear and Bowling",
    "statement": "Limak is an old brown bear. He often goes bowling with his friends.\r\nToday he feels really good and tries to beat his own record!For rolling\r\na ball one gets a score an integer (maybe negative) number of points.\r\nScore for -th roll is multiplied by and scores are summed up. So, for\r\nrolls with scores , total score is . Total score is if there were no\r\nrolls.Limak made rolls and got score for -th of them. He wants to\r\nmaximize his total score and he came up with an interesting idea. He\r\nwill cancel some rolls, saying that something distracted him or there\r\nwas a strong wind.Limak is able to cancel any number of rolls, maybe\r\neven all or none of them. Total score is calculated as if there were\r\nonly non-canceled rolls. Look at the sample tests for clarification.\r\nWhat maximum total score can Limak get?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100010\nint n;\nbool cz[MAX];\nLL wyn = 0;\nLL t[MAX];\nbool us(){\n  LL sum = 0;\n  int il = 0;\n  bool res = 0;\n  R(i,n)if(cz[i])sum+=t[i];\n  R(i,n){\n    if(cz[i]){\n      il++;\n      sum -= t[i];\n      if(t[i] * il + sum < 0){\n        wyn -= t[i] * il + sum;\n        il--;\n        cz[i] = 0;\n        res = 1;\n      }\n    }\n  }\n  return res;\n}\nbool dod(){\n  int il = 0;\n  LL sum = 0;\n  bool res = 0;\n  R(i,n)if(cz[i])il++;\n  FD(i,n){\n    if(!cz[i]){\n      if(t[i] * (il+1) + sum > 0){\n        wyn += t[i] * (il+1) + sum;\n        il++;\n        cz[i] = 1;\n        res = 1;\n      }\n    }\n    if(cz[i]){\n      il--;\n      sum += t[i];\n    }\n  }\n  return res;\n}\nmain(){\n  make(n);\n  R(i,n){\n    cz[i] = 1;\n    scanf(\"%lld\",&t[i]);\n    wyn += t[i]*(i+1);\n  }\n  bool x = 1;\n  while(x){\n    x=0;\n    if(us())x=1;\n    if(dod())x=1;\n  }\n  printf(\"%lld\\n\",wyn);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Bear and Bowling.json",
    "editorial_link": "https://codeforces.com//blog/entry/20040",
    "editorial": "FIRST PART greedy works We will add (take) elements to a subsequence one\r\nby one. Adding number , when we have taken numbers on the left,\r\nincreases result by where is sum of taken numbers on the right. Letâs\r\ncall this added value as the Quality of element . We will prove\r\ncorrectness of the following greedy algorithm. We take element with the\r\nbiggest Quality till there are no elements left. For every size of a\r\nsubsequence (number of taken elements) we will get optimal score.\r\n(lemma) If and , we wonât take first. Proof. Letâs consider a moment\r\nwhen we donât fulfill the lemma for the first time. If there are no\r\ntaken numbers between and , we have so is a better choice. For taken\r\nnumbers between and each number changes by and by . Weâll see that so\r\nwill remain greater than . If , the lemma (fulfilled till now) says that\r\nwasnât taken before it canât be true because is taken and is not. So\r\nindeed . Letâs assume that our greedy strategy is not correct. Letâs\r\nconsider first moment when we take some element and for some we canât\r\nget optimal subsequence with size by taking more elements (using any\r\nstrategy). Let denote a set of elements taken before. So there is no way\r\nto add some more elements to set and achieve optimal score with size .\r\nBut it was possible just before taking so there is a subset of remaining\r\nelements that and set is the best among sets with size . Note that canât\r\nbe empty. (case 1 contains at least one element on the left from ) Let\r\ndenote last element from that (here \"last\" means \"with the biggest \").\r\nOur strategy wanted before elements from so we know from lemma that . It\r\nwill turn out that replacing with (in set ) doesnât decrease the score\r\nso taking is acceptable. Note that replacing an element with another one\r\ndoesnât change size of a set/subsequence. In moment of choosing it had\r\nthe biggest quality so then . Now in there are new elements, those in .\r\nLetâs imagine adding them to (without and ). Each new element on the\r\nright change both and by . Elements on the left change by and by (note\r\nthat ). And there are no elements between and . Now, taking would give\r\nus set but remains not less than so we can take instead. (case 2\r\ncontains only elements on the right from ) Similarly, we can replace\r\nwith closest from set . As before, elements on the right change and by\r\nthe same value. SECOND PART how to implement it First, letâs understand\r\nsolution. We divide a sequence into Parts. When choosing the best\r\ncandidate in a Part, we want to forget about other Parts. Itâs enough to\r\nremember only and number of taken elements on the left (in previous\r\nParts) and sum of elements on the right (in next Parts). affects\r\nchoosing the best element in a Part, doesnât (but we need this constant\r\nto add it to result for best candidate). For a Part we want to have hull\r\nwith linear functions of form . With binary search we can find the best\r\nelement in and then construct new hull for this Part in . We can remove\r\nfrom complexity. First, binary search can be replaced with pointers for\r\neach Part initially we set a pointer at the beginning of Part. To find\r\nbest candidate in Part, we slowly move pointer to the right (by one).\r\nComplexity is amortized . And we can sort linear functions by angle only\r\nonce because value doesnât change then constructing a hull is only .\r\nNote that when rebuilding a hull, we must set pointer to the beginning\r\nof Part. So we have . Code. There are other two correct lemmas to speed\r\nyour solution up. We can take all positive numbers first (itâs not so\r\neasy to prove). And we can stop when taken number doesnât increase score\r\nnext taken numbers wonât increase score neither.\r\n",
    "hint": []
}