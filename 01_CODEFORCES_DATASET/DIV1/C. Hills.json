{
    "link": "https://codeforces.com//contest/1012/problem/C",
    "problemId": "203193",
    "problem_idx": "C",
    "shortId": "1012C",
    "contest_number": "1012",
    "problem_submissions": {
        "D": [
            40965345,
            40960627,
            40962755,
            40958672,
            40960130,
            40960868,
            40957816,
            40962185,
            40977537,
            40977026,
            40958559,
            40961785,
            40963025,
            40963296,
            40964134,
            40968496,
            40964728
        ],
        "E": [
            40960617,
            40966609,
            40966430,
            40968315,
            40959955,
            40968344,
            41293524,
            40971324,
            40961945,
            40965219,
            40964178,
            40964935,
            40966686
        ],
        "C": [
            40946223,
            40950962,
            40949847,
            40947169,
            40948884,
            40951113,
            40948032,
            40950863,
            40949840,
            40948978,
            40950249,
            40944733,
            40947497,
            40951510,
            40946864,
            40950557,
            40948982,
            40953572,
            40952480,
            40955310
        ],
        "B": [
            40942792,
            40947068,
            40945179,
            40941414,
            40943485,
            40944363,
            40943466,
            40948512,
            40943709,
            40942617,
            40946516,
            40941822,
            40945156,
            40945233,
            40943297,
            40953601,
            40943064,
            40946807,
            40947838,
            40944988
        ],
        "A": [
            40940407,
            40940426,
            40944393,
            40940053,
            40941238,
            40941590,
            40941675,
            40939828,
            40941205,
            40939974,
            40940704,
            40939790,
            40943152,
            40941982,
            40942155,
            40942198,
            40952349,
            40943555,
            40944486,
            40941409
        ],
        "F": [
            41294072,
            40975225,
            40975082,
            48927133,
            48926928,
            48926890,
            48926661,
            48926482,
            48926274,
            48926240,
            48926110,
            48925986,
            48925954,
            48925448,
            48924606
        ]
    },
    "name": "C. Hills",
    "statement": "Welcome to Innopolis city. Throughout the whole year, Innopolis citizens\r\nsuffer from everlasting city construction. From the window in your room,\r\nyou see the sequence of hills, where -th of them has height . The\r\nInnopolis administration wants to build some houses on the hills.\r\nHowever, for the sake of city appearance, a house can be only built on\r\nthe hill, which is strictly higher than neighbouring hills (if they are\r\npresent). For example, if the sequence of heights is , then houses could\r\nbe built on hills with heights and only.The Innopolis administration has\r\nan excavator, that can decrease the height of an arbitrary hill by one\r\nin one hour. The excavator can only work on one hill at a time. It is\r\nallowed to decrease hills up to zero height, or even to negative values.\r\nIncreasing height of any hill is impossible. The city administration\r\nwants to build houses, so there must be at least hills that satisfy the\r\ncondition above. What is the minimum time required to adjust the hills\r\nto achieve the administration\u2019s plan?However, the exact value of is not\r\nyet determined, so could you please calculate answers for all in range ?\r\nHere denotes divided by two, rounded up.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int INF = (int)1e9 + 7;\nconst int N = 5050;\nconst int M = N / 2;\nint a[N];\nint dp[N][M][3];\nint n;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < i / 2 + 5; j++)\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t\tdp[i][j][k] = INF;\n\tdp[0][0][1] = 0;\n\tdp[0][1][0] = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tint m = i / 2 + 3;\n\t\tfor (int x = 0; x <= m; x++) {\n\t\t\tif (dp[i - 1][x][0] < INF) {\n\t\t\t\tif (a[i] < a[i - 1]) {\n\t\t\t\t\tdp[i][x][1] = min(dp[i][x][1], dp[i - 1][x][0]);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][x][2] = min(dp[i][x][2], dp[i - 1][x][0] + (a[i] - a[i - 1] + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp[i - 1][x][1] < INF) {\n\t\t\t\tint p = a[i - 1];\n\t\t\t\tint w = dp[i - 1][x][1];\n\t\t\t\tif (a[i] > p) {\n\t\t\t\t\tdp[i][x + 1][0] = min(dp[i][x + 1][0], w);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][x + 1][0] = min(dp[i][x + 1][0], w + (p - a[i] + 1));\n\t\t\t\t}\n\t\t\t\tdp[i][x][1] = min(dp[i][x][1], w);\n\t\t\t}\n\t\t\tif (dp[i - 1][x][2] < INF) {\n\t\t\t\tint p = a[i - 2] - 1;\n\t\t\t\tint w = dp[i - 1][x][2];\n\t\t\t\tif (a[i] > p) {\n\t\t\t\t\tdp[i][x + 1][0] = min(dp[i][x + 1][0], w);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][x + 1][0] = min(dp[i][x + 1][0], w + (p - a[i] + 1));\n\t\t\t\t}\n\t\t\t\tdp[i][x][1] = min(dp[i][x][1], w);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= (n + 1) / 2; i++) {\n\t\tint res = INF;\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tres = min(res, dp[n - 1][i][j]);\n\t\tprintf(\"%d \", res);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Hills.json",
    "editorial_link": "https://codeforces.com/blog/entry/60920",
    "editorial": "The problem\u00e2\u0080\u0099s short statement is: \"we allowed to decrease any element\r\nand should create at least local maximums, count the minimum number of\r\noperations for all \".Notice, that any set of positions, where no\r\npositions are adjacent could be made to be local maximums we just need\r\nto decrease the neighbouring hills to some value.Let\u00e2\u0080\u0099s introduce the\r\nfollowing dynamic programming:dp[prefix][local_maxs] the minimum cost if\r\nwe analyze only given prefix, have the specified number of local\r\nmaximums (\"good hills to build on\") and we make a local maximum in the\r\nlast hill of this prefix.Th dumb implementation of this leads to states\r\nand time in each state we can brute force the previous position of local\r\nmaximum () and then calculate the cost of patching the segment from\r\nprevious local maximum to current one.A more attentive look says that it\r\nis, in fact solution on the segment only first and last elements need to\r\nbe decreased (possibly first and last elements are same).To get the full\r\nsolution full solution in we need to optimize dp a little bit. As we\r\nnoticed in the previous paragraph, there is one extreme situation, when\r\nthe first and elements are same, let\u00e2\u0080\u0099s handle this transition by hand in\r\nfor each state.Otherwise, funny fact, the cost of the segment strictly\r\nbetween local maximums is the cost of it\u00e2\u0080\u0099s left part plus it\u00e2\u0080\u0099cost of\r\nit\u00e2\u0080\u0099s right part. Seems like something we can decompose, right?Since our\r\ngoal is to update state now the right part is fixed constant for all\r\nsuch transitions. And we need to select minimum value of where .This can\r\nbe done by calculating a supplementary dp during the primarily dp\r\ncalculation for example we can calculate f[pref][j] = min dp[i][j] +\r\ncost(i, i + 1) for .\r\n"
}