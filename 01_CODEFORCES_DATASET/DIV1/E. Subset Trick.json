{
    "link": "https://codeforces.com//contest/1500/problem/E",
    "problemId": "922996",
    "problem_idx": "E",
    "shortId": "1500E",
    "contest_number": "1500",
    "problem_submissions": {
        "F": [
            109882523,
            156894272,
            156888570,
            109926929,
            109926191,
            109893056,
            109892507,
            110407942
        ],
        "E": [
            109869658,
            109880186,
            109882627,
            109869772,
            109883572,
            110177251,
            112227681,
            112227008,
            112226855
        ],
        "C": [
            109851937,
            109858563,
            109855424,
            109847448,
            109897897,
            109858583,
            109868120,
            109862817,
            109862820,
            109847704,
            109864051,
            109866901,
            109862545,
            109862473,
            109864278,
            109866655,
            109866161,
            109873497,
            109866235,
            109876064
        ],
        "A": [
            109847522,
            109845877,
            109846878,
            109889115,
            109845620,
            109845386,
            109845664,
            109845260,
            109853758,
            109847140,
            109849368,
            109845237,
            109845429,
            109846259,
            109846562,
            109868273,
            109864425,
            109846842,
            109854328
        ],
        "B": [
            109845439,
            109853012,
            109858233,
            109878921,
            109849145,
            109848615,
            109856685,
            109852114,
            109880910,
            109854120,
            109859099,
            109849597,
            109849728,
            109854205,
            109854819,
            109853965,
            109859327,
            109857020,
            109863440
        ],
        "D": [
            109866969,
            109867253,
            109854472,
            109863287,
            109861346,
            109868138,
            109875304,
            109871552,
            109879597,
            109878283,
            109877726,
            109880816,
            109873581,
            109879840,
            109875506,
            109884990,
            109881921,
            109883609
        ]
    },
    "name": "E. Subset Trick",
    "statement": "Vanya invented an interesting trick with a set of integers.Let an\r\nillusionist have a set of positive integers S. He names a positive\r\ninteger x. Then an audience volunteer must choose some subset (possibly,\r\nempty) of S without disclosing it to the illusionist. The volunteer\r\ntells the illusionist the size of the chosen subset. And here comes the\r\ntrick: the illusionist guesses whether the sum of the subset elements\r\ndoes not exceed x. The sum of elements of an empty subset is considered\r\nto be 0.Vanya wants to prepare the trick for a public performance. He\r\nprepared some set of positive integers S. Vasya wants the trick to be\r\nsuccessful. He calls a positive number x , if he can\u2019t be sure that the\r\ntrick would be successful for every subset a viewer can choose.Vanya\r\nwants to count the number of unsuitable integers for the chosen set\r\nS.Vanya plans to try different sets S. He wants you to write a program\r\nthat finds the number of unsuitable integers for the initial set S, and\r\nafter each change to the set S. Vanya will make q changes to the set,\r\nand each change is one of the following two types: add a new integer a\r\nto the set S, or remove some integer a from the set S.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 13.03.2021 13:07:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// https://github.com/kth-competitive-programming/kactl/blob/master/content/data-structures/FenwickTree.h\n\n/**\n * Author: Lukas Polacek\n * Date: 2009-10-30\n * License: CC0\n * Source: folklore/TopCoder\n * Description: Computes partial sums a[0] + a[1] + ... + a[pos - 1], and updates single elements a[i],\n * taking the difference between the old and new value.\n * Time: Both operations are $O(\\log N)$.\n * Status: Stress-tested\n */\n\ntypedef long long ll;\n\nstruct FT {\n\tvector<ll> s;\n\tFT(int n) : s(n) {}\n\tvoid update(int pos, ll dif) { // a[pos] += dif\n\t\tfor (; pos < (int) s.size(); pos |= pos + 1) s[pos] += dif;\n\t}\n\tll query(int pos) { // sum of values in [0, pos)\n\t\tll res = 0;\n\t\tfor (; pos > 0; pos &= pos - 1) res += s[pos-1];\n\t\treturn res;\n\t}\n\tint lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum\n\t\t// Returns n if no sum is >= sum, or -1 if empty sum is.\n\t\tif (sum <= 0) return -1;\n\t\tint pos = 0;\n\t\tfor (int pw = 1 << 25; pw; pw >>= 1) {\n\t\t\tif (pos + pw <= (int) s.size() && s[pos + pw-1] < sum)\n\t\t\t\tpos += pw, sum -= s[pos-1];\n\t\t}\n\t\treturn pos;\n\t}\n};\n\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n\nclass node {\n public:\n  int id;\n  node* l;\n  node* r;\n  node* p;\n  bool rev;\n  int sz;\n  // declare extra variables:\n  int P;\n  long long val;\n  long long sum;\n  long long sum_i; // sum (i * a[i])\n\n  node(int _id, long long _val) {\n    id = _id;\n    l = r = p = nullptr;\n    rev = false;\n    sz = 1;\n    // init extra variables:\n    P = rng();\n    val = _val;\n    sum = val;\n    sum_i = 0;\n  }\n\n  void unsafe_reverse() {\n    rev ^= 1;\n    swap(l, r);\n    pull();\n  }\n\n  // apply changes:\n  void unsafe_apply() {\n    \n  }\n\n  void push() {\n    if (rev) {\n      if (l != nullptr) {\n        l->unsafe_reverse();\n      }\n      if (r != nullptr) {\n        r->unsafe_reverse();\n      }\n      rev = 0;\n    }\n    // now push everything else:\n\n  }\n\n  void pull() {\n    sz = 1;\n    // now init from self:\n    sum = val;\n    sum_i = 0;\n    if (l != nullptr) {\n      l->p = this;\n      // now pull from l:\n      sum_i = l->sum_i + l->sz * sum + sum_i;\n      sum += l->sum;\n      sz += l->sz;\n    }\n    if (r != nullptr) {\n      r->p = this;\n      // now pull from r:\n      sum_i = sum_i + sz * r->sum + r->sum_i;\n      sum += r->sum;\n      sz += r->sz;\n    }\n  }\n};\n\nvoid debug_node(node* v, string pref = \"\") {\n  #ifdef LOCAL\n    if (v != nullptr) {\n      debug_node(v->r, pref + \" \");\n      cerr << pref << \"-\" << \" \" << v->id << '\\n';\n      debug_node(v->l, pref + \" \");\n    } else {\n      cerr << pref << \"-\" << \" \" << \"nullptr\" << '\\n';\n    }\n  #endif\n}\n\nnamespace treap {\n\npair<node*, int> find(node* v, const function<int(node*)> &go_to) {\n  // go_to returns: 0 -- found; -1 -- go left; 1 -- go right\n  // find returns the last vertex on the descent and its go_to\n  if (v == nullptr) {\n    return {nullptr, 0};\n  }\n  int dir;\n  while (true) {\n    v->push();\n    dir = go_to(v);\n    if (dir == 0) {\n      break;\n    }\n    node* u = (dir == -1 ? v->l : v->r);\n    if (u == nullptr) {\n      break;\n    }\n    v = u;\n  }\n  return {v, dir};\n}\n\nnode* get_leftmost(node* v) {\n  return find(v, [&](node*) { return -1; }).first;\n}\n\nnode* get_rightmost(node* v) {\n  return find(v, [&](node*) { return 1; }).first;\n}\n\nnode* get_kth(node* v, int k) { // 0-indexed\n  pair<node*, int> p = find(v, [&](node* u) {\n    if (u->l != nullptr) {\n      if (u->l->sz > k) {\n        return -1;\n      }\n      k -= u->l->sz;\n    }\n    if (k == 0) {\n      return 0;\n    }\n    k--;\n    return 1;\n  });\n  return (p.second == 0 ? p.first : nullptr);\n}\n\nint get_position(node* v) { // 0-indexed\n  int k = (v->l != nullptr ? v->l->sz : 0);\n  while (v->p != nullptr) {\n    if (v == v->p->r) {\n      k++;\n      if (v->p->l != nullptr) {\n        k += v->p->l->sz;\n      }\n    }\n    v = v->p;\n  }\n  return k;\n}\n\nnode* get_bst_root(node* v) {\n  while (v->p != nullptr) {\n    v = v->p;\n  }\n  return v;\n}\n\npair<node*, node*> split(node* v, const function<bool(node*)> &is_right) {\n  if (v == nullptr) {\n    return {nullptr, nullptr};\n  }\n  v->push();\n  if (is_right(v)) {\n    pair<node*, node*> p = split(v->l, is_right);\n    if (p.first != nullptr) {\n      p.first->p = nullptr;\n    }\n    v->l = p.second;\n    v->pull();\n    return {p.first, v};\n  } else {\n    pair<node*, node*> p = split(v->r, is_right);\n    v->r = p.first;\n    if (p.second != nullptr) {\n      p.second->p = nullptr;\n    }\n    v->pull();\n    return {v, p.second};\n  }\n}\n\npair<node*, node*> split_leftmost_k(node* v, int k) {\n  return split(v, [&](node* u) {\n    int left_and_me = (u->l != nullptr ? u->l->sz : 0) + 1;\n    if (k >= left_and_me) {\n      k -= left_and_me;\n      return false;\n    }\n    return true;\n  });\n}\n\nnode* merge(node* v, node* u) {\n  if (v == nullptr) {\n    return u;\n  }\n  if (u == nullptr) {\n    return v;\n  }\n  if (v->P > u->P) {\n//    if (rng() % (v->sz + u->sz) < (unsigned int) v->sz) {\n    v->push();\n    v->r = merge(v->r, u);\n    v->pull();\n    return v;\n  } else {\n    u->push();\n    u->l = merge(v, u->l);\n    u->pull();\n    return u;\n  }\n}\n\nint count_left(node* v, const function<bool(node*)> &is_right) {\n  if (v == nullptr) {\n    return 0;\n  }\n  v->push();\n  if (is_right(v)) {\n    return count_left(v->l, is_right);\n  }\n  return (v->l != nullptr ? v->l->sz : 0) + 1 + count_left(v->r, is_right);\n}\n\nnode* add(node* r, node* v, const function<bool(node*)> &go_left) {\n  pair<node*, node*> p = split(r, go_left);\n  return merge(p.first, merge(v, p.second));\n}\n\nnode* remove(node* v) { // returns the new root\n  v->push();\n  node* x = v->l;\n  node* y = v->r;\n  node* p = v->p;\n  v->l = v->r = v->p = nullptr;\n  v->push();\n  v->pull(); // now v might be reusable...\n  node* z = merge(x, y);\n  if (p == nullptr) {\n    if (z != nullptr) {\n      z->p = nullptr;\n    }\n    return z;\n  }\n  if (p->l == v) {\n    p->l = z;\n  }\n  if (p->r == v) {\n    p->r = z;\n  }\n  while (true) {\n    p->push();\n    p->pull();\n    if (p->p == nullptr) {\n      break;\n    }\n    p = p->p;\n  }\n  return p;\n}\n\nnode* next(node* v) {\n  if (v->r == nullptr) {\n    while (v->p != nullptr && v->p->r == v) {\n      v = v->p;\n    }\n    return v->p;\n  }\n  v->push();\n  v = v->r;\n  while (v->l != nullptr) {\n    v->push();\n    v = v->l;\n  }\n  return v;\n}\n\nnode* prev(node* v) {\n  if (v->l == nullptr) {\n    while (v->p != nullptr && v->p->l == v) {\n      v = v->p;\n    }\n    return v->p;\n  }\n  v->push();\n  v = v->l;\n  while (v->r != nullptr) {\n    v->push();\n    v = v->r;\n  }\n  return v;\n}\n\nint get_size(node* v) {\n  return (v != nullptr ? v->sz : 0);\n}\n\ntemplate<typename... T>\nvoid apply(node* v, T... args) {\n  v->unsafe_apply(args...);\n}\n\nvoid reverse(node* v) {\n  v->unsafe_reverse();\n}\n\n}  // namespace treap\n\nusing namespace treap;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  vector<long long> _s(n);\n  for (int i = 0; i < n; i++) {\n    cin >> _s[i];\n  }\n  vector<int> t(q);\n  vector<long long> _a(q);\n  for (int i = 0; i < q; i++) {\n    cin >> t[i] >> _a[i];\n  }\n  vector<long long> all(n + q);\n  for (int i = 0; i < n; i++) {\n    all[i] = _s[i];\n  }\n  for (int i = 0; i < q; i++) {\n    all[n + i] = _a[i];\n  }\n  sort(all.begin(), all.end());\n  all.resize(unique(all.begin(), all.end()) - all.begin());\n  int sz = (int) all.size();\n\n  FT has(sz);\n  FT val(sz);\n  int cnt = 0;\n  vector<node*> nodes(sz);\n  for (int i = 0; i < sz; i++) {\n    nodes[i] = new node(i, all[i]);\n  }\n  node* r = nullptr;\n\n  auto Add = [&](int i) {\n    has.update(i, +1);\n    val.update(i, +all[i]);\n    r = add(r, nodes[i], [&](node* nd) {\n      return all[i] < nd->val;\n    });\n    ++cnt;\n  };\n  auto Remove = [&](int i) {\n    has.update(i, -1);\n    val.update(i, -all[i]);\n    r = remove(nodes[i]);\n    --cnt;\n  };\n  auto Calc = [&]() -> long long {\n    if (cnt <= 1) {\n      return 0LL;\n    }\n    int low = 1;\n    int high = (cnt + 1) / 2;\n    while (low < high) {\n      int mid = (low + high) >> 1;\n      int pos = has.lower_bound(mid + 1);\n      long long small = val.query(pos + 1);\n      pos = has.lower_bound(cnt - mid);\n      long long big = val.query(sz) - val.query(pos + 1);\n      if (big > small) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    if (low == (cnt + 1) / 2) {\n      long long ret = 2 * r->sum_i - r->sum * (cnt - 1);\n      return ret;\n    }\n    auto p = split_leftmost_k(r, low);\n    auto q = split_leftmost_k(p.second, cnt - 2 * low);\n    long long ret = 0;\n    ret += p.first->sum_i * 2 - p.first->sum * (2 * low - 1);\n    ret += q.first->sum;\n    ret += q.second->sum_i * 2 + q.second->sum;\n    r = merge(p.first, merge(q.first, q.second));\n    return ret;\n  };\n  \n  \n  vector<int> s(n);\n  for (int i = 0; i < n; i++) { \n    s[i] = (int) (lower_bound(all.begin(), all.end(), _s[i]) - all.begin());\n  }\n  vector<int> a(q);\n  for (int i = 0; i < q; i++) { \n    a[i] = (int) (lower_bound(all.begin(), all.end(), _a[i]) - all.begin());\n  }\n  for (int i = 0; i < n; i++) {\n    Add(s[i]);\n  }\n  for (int i = 0; i <= q; i++) {\n    cout << Calc() << '\\n';\n    if (i == q) {\n      break;\n    }\n    if (t[i] == 1) {\n      Add(a[i]);\n    } else {\n      Remove(a[i]);\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Subset Trick.json",
    "editorial_link": "https://codeforces.com//blog/entry/88591",
    "editorial": "Let , where .Let\u00e2\u0080\u0099s calculate the number of good numbers from to . To get\r\nthe answer to our problem we should subtract this value from .Let\u00e2\u0080\u0099s\r\nsuppose that is good. It is easy to see that it is equivalent to for\r\nsome .So to calculate the required number of good numbers we should find\r\nthe length of the union of intervals for all .We can note two things:\r\nsome of these intervals are empty all non-empty intervals does not\r\nintersect with each other So the number we want to find is just .Let\u00e2\u0080\u0099s\r\ncall . Let\u00e2\u0080\u0099s note two simply things: if Let\u00e2\u0080\u0099s use them. First of all\r\nlet\u00e2\u0080\u0099s find . We can simply calculate the sum we need from it because we\r\nshould just multiply this sum by and possibly subtract the number from\r\nthe middle (if is odd).Let\u00e2\u0080\u0099s note that in the sum some first summands\r\nare , others are equal to (because will be bigger in the maximum).Let\u00e2\u0080\u0099s\r\nfind the minimal , such that using binary search. After that we should\r\ncalculate .So what values we should be able to calculate to solve the\r\nproblem? The sum of numbers on prefix . Using two queries of this type\r\nwe can calculate . The sum of numbers multiplied by index on prefix . We\r\ncan calculate the final answer using this query. To answer these queries\r\neffectively let\u00e2\u0080\u0099s use the segment tree. Initially let\u00e2\u0080\u0099s find all numbers\r\nthat will be in in some moment (we can do it because we have the list of\r\nall queries). We will make a segment tree on this array, where we will\r\nwrite , if there is no such number currently in and , otherwise.For each\r\nsegment of these segment tree we will store values: the number of\r\nnumbers from this segment, that lie in the current the sum of numbers\r\nfrom this segment, that lie in the current the sum of numbers multiplied\r\nby index from this segment, that lie in the current These values can be\r\neasily recalculated when an update in the segment tree happens.To\r\ncalculate two sums required for us we need to make the descent in the\r\nsegment tree summing the segments on the prefix, where the number of\r\nnumbers that lie in the current is equal to .In total, we get the\r\nsolution, because we make the binary search and use queries to the\r\nsegment tree inside it.\r\n"
}