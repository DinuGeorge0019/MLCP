{"link": "https://codeforces.com//contest/536/problem/E", "problemId": "26046", "problem_idx": "E", "shortId": "536E", "contest_number": "536", "problem_submissions": {"A": [10719921, 10706737, 10707689, 10711529, 10709676, 10707375, 10709573, 10707885, 10708720, 10706564, 10708318, 10709355, 10713459, 10725217, 10725216, 10725186, 10708292, 10706905, 10741377, 10713738], "B": [10718101, 10710644, 10709758, 10712675, 10707296, 10709351, 10713281, 10710208, 10710709, 10710095, 10711429, 10711411, 10707838, 10710289, 10713790, 10709325, 10709558], "E": [10716637, 10733077, 10733033, 10731562, 10741189], "C": [10709726, 10713480, 10715583, 10715941, 10717945, 10721487, 10717235, 10716651, 10717759, 10716150, 10716761, 10720841, 10718866], "D": [10717797, 10717420, 10719832, 10715603, 10716972, 10718818, 10719396, 10719946, 10724775, 10717671]}, "name": "E. Tavas on the Path", "statement": "Tavas lives in Tavaspolis. Tavaspolis has cities numbered from to\r\nconnected by bidirectional roads. There exists a path between any two\r\ncities. Also each road has a length. Tavas\u2019 favorite strings are binary\r\nstrings (they contain only 0 and 1). For any binary string like , is its\r\n. can be calculated as follows:Consider there are exactly blocks of s in\r\nthis string (a block of s in is a maximal consecutive substring of that\r\nonly contains ) with lengths .Define where is a given sequence (if ,\r\nthen ).Tavas loves queries. He asks you to answer queries. In each query\r\nhe gives you numbers and you should print following number:Consider the\r\nroads on the path from city to city : .Build the binary string of length\r\nsuch that: if and only if where is the length of road .You should print\r\nfor this query.\r\n", "solutions": ["#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<queue>\n#include<map>\ntypedef long long ll;\n#define mo 1000000007\nvoid gn(int &x){\n    char c;while((c=getchar())<'0'||c>'9');x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n}\nusing namespace std;\nint n,m;\nint g[100005]={0};\nstruct edge{\n       int v,w,next;\n}e[200005];int etot=0;\nvoid ae(int u,int v,int w){\n     e[etot].v=v;e[etot].w=w;e[etot].next=g[u];g[u]=etot++;\n     e[etot].v=u;e[etot].w=w;e[etot].next=g[v];g[v]=etot++;\n}\nint sz[100005];\nint bfs[100005],p,q,fa[100005],son[100005]={0},up[100005],h[100005],id[100005],idtot=0;\nvoid build(){\n     p=q=0;\n     bfs[q++]=1;\n     fa[1]=0;h[1]=0;\n     int u,v,i;\n     while(p<q){\n               u=bfs[p++];\n               for ( i=g[u];~i;i=e[i].next)if((v=e[i].v)!=fa[u]){\n                   fa[v]=u;\n                   bfs[q++]=v;\n                   h[v]=h[u]+1;\n               }\n     }\n     for (i=1;i<=n;i++)sz[i]=1;\n     sz[0]=0;\n     for (i=n-1;i>=0;i--){\n         sz[fa[bfs[i]]]+=sz[bfs[i]];\n         if(sz[bfs[i]]>sz[son[fa[bfs[i]]]])son[fa[bfs[i]]]=bfs[i];\n     }\n     for (i=n-1;i>=0;i--)if(!son[v=bfs[i]]){         \n         while(v!=1 && son[fa[v]]==v)v=fa[v];\n         p=v;\n         while(v)up[v]=p,id[v]=++idtot,v=son[v];\n     }\n}\nint f[111111];\nstruct que{\n    int u,v,l,id;\n}Q[111111];\nstruct edg{\n    int u,v,w;\n}E[111111];\nint cmpe(const edg&a,const edg&b){\n    return a.w>b.w;\n}\nint cmpq(const que&a,const que&b){\n    return a.l>b.l;\n}\nint ans[111111];\n\nstruct data{\n    int l,su,r,len;\n};\ninline data rev(const data&a){\n    return (data){a.r,a.su,a.l,a.len};\n}\ninline int eval(const data&a){\n    if(a.l==a.len)return f[a.l];\n    else return f[a.l]+f[a.r]+a.su;\n}\ninline data operator+(const data&a,const data&b){\n    data ans;\n    ans.len=a.len+b.len;\n    if(a.l!=a.len && b.l!=b.len){\n        ans.l=a.l,ans.r=b.r,ans.su=a.su+b.su+f[a.r+b.l];\n    }else if(a.l==a.len && b.l==b.len){\n        ans.l=ans.r=ans.len;ans.su=0;\n    }else if(a.l==a.len){\n        ans.l=a.l+b.l,ans.r=b.r,ans.su=b.su;\n    }else ans.l=a.l,ans.r=b.r+a.r,ans.su=a.su;\n    return ans;\n}\n\ndata seg[444444];\nint I;\ndata v;\n\nvoid upd(int l,int r,int x){\n    if(l==r)seg[x]=v;\n    else{\n        int mid=l+r>>1;\n        if(I<=mid)upd(l,mid,x<<1);\n        else upd(mid+1,r,x<<1|1);\n        seg[x]=seg[x<<1]+seg[x<<1|1];\n    }\n}\nint l1,r1;\nvoid qr(int l,int r,int x){\n    if(l1<=l && r<=r1)v=v+seg[x];\n    else{\n        int mid=l+r>>1;\n        if(l1<=mid)qr(l,mid,x<<1);\n        if(r1>mid)qr(mid+1,r,x<<1|1);\n    }\n}\nint query(int x,int y){\n    data mex,mey;\n    mex=mey=(data){0,0,0,0};\n    while(up[x]!=up[y]){\n        if(h[up[x]]>h[up[y]])swap(x,y),swap(mex,mey);\n        l1=id[up[y]],r1=id[y];\n        v=(data){0,0,0,0};\n        qr(1,n,1);\n        mey=v+mey;\n        y=fa[up[y]];\n    }\n    if(h[x]>h[y])swap(x,y),swap(mex,mey);\n    l1=id[x]+1,r1=id[y];\n    v=(data){0,0,0,0};\n    if(l1<=r1)qr(1,n,1);\n    data ans=rev(mex)+v+mey;\n    return eval(ans);\n}\nvoid init(int l,int r,int x){\n    if(l==r){\n        seg[x]=(data){0,0,0,1};\n    }else{\n        int mid=l+r>>1;\n        init(l,mid,x<<1);\n        init(mid+1,r,x<<1|1);\n        seg[x]=seg[x<<1]+seg[x<<1|1];\n    }\n}\nint main()\n{\n    memset(g,-1,sizeof(g));\n    int q;\n    scanf(\"%d%d\",&n,&q);\n    f[0]=0;for (int i=1;i<=n-1;i++)scanf(\"%d\",&f[i]);\n    for (int i=1;i<=n-1;i++){\n        int u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n        ae(u,v,w);\n        E[i]=(edg){u,v,w};\n    }\n    for (int i=1;i<=q;i++){\n        scanf(\"%d%d%d\",&Q[i].u,&Q[i].v,&Q[i].l);\n        Q[i].id=i;\n    }\n    sort(Q+1,Q+1+q,cmpq);\n    sort(E+1,E+1+(n-1),cmpe);\n    init(1,n,1);\n    build();\n    for (int i=1;i<=n-1;i++)if(h[E[i].u]>h[E[i].v])swap(E[i].u,E[i].v);\n    for (int i=1,cur=1;i<=q;i++){\n        while(cur<=n-1 && E[cur].w>=Q[i].l){\n            I=id[E[cur].v];\n            v=(data){1,0,1,1};\n            upd(1,n,1);\n            cur++;\n        }\n        ans[Q[i].id]=query(Q[i].u,Q[i].v);\n    }\n    for (int i=1;i<=q;i++)printf(\"%d\\n\",ans[i]);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "trees"], "dificulty": "3100", "interactive": false}