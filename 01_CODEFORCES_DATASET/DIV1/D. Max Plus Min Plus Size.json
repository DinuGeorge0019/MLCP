{
    "link": "https://codeforces.com//contest/2018/problem/D",
    "problemId": "2905186",
    "problem_idx": "D",
    "shortId": "2018D",
    "contest_number": "2018",
    "problem_submissions": {
        "F1": [
            283240998,
            283223838,
            283219415,
            283236306,
            283222916,
            283217600,
            283233290,
            283231886,
            283231256,
            283232151,
            283229995,
            283237003,
            283235478,
            283237574,
            283236444,
            283230142,
            283243735,
            283243123,
            283242008,
            283243508
        ],
        "F2": [
            283240981,
            283223708,
            283219380,
            283241370,
            283223162,
            283225122,
            283233500,
            283231817,
            283231569,
            283232589,
            283230224,
            283236870,
            283235839,
            283237529,
            283238353,
            283243847,
            283243386,
            283242191,
            283243811
        ],
        "F3": [
            283240882,
            283223675,
            283219246,
            283271588,
            283270237,
            283224933,
            283229369,
            283236884,
            283231408,
            283234186,
            283238623,
            283246555,
            283236714,
            283242719,
            283237265,
            283240426,
            283246144,
            283243432,
            283242213,
            283244419
        ],
        "E2": [
            283228724,
            283271415,
            283952156,
            285367980,
            285366320,
            284023567,
            283309295
        ],
        "E1": [
            283228436,
            283232974,
            283271394,
            283269080,
            283266646,
            283248084,
            283226474,
            285366140,
            284023512,
            283309260,
            283237845
        ],
        "D": [
            283195973,
            283206733,
            283203886,
            283202562,
            283199647,
            283202135,
            283203009,
            283209326,
            283212471,
            283208248,
            283213153,
            283210604,
            283213401,
            283215308,
            283215785,
            283193803,
            283212467,
            283216433,
            283217858,
            283213030
        ],
        "C": [
            283191019,
            283190311,
            283188296,
            283196136,
            283191568,
            283193617,
            283197810,
            283200878,
            283205239,
            283197789,
            283193479,
            283202635,
            283205964,
            283204336,
            283202253,
            283186865,
            283201070,
            283203016,
            283201349,
            283204359
        ],
        "B": [
            283187765,
            283200401,
            283192789,
            283188636,
            283190321,
            283192212,
            283195063,
            283200019,
            283195292,
            283189706,
            283199364,
            283199549,
            283199094,
            283197971,
            283197559,
            283195753,
            283198921,
            283194967,
            283197864
        ],
        "A": [
            283182907,
            283184407,
            283187228,
            283181621,
            283185198,
            283186414,
            283185582,
            283191793,
            283185688,
            283183522,
            283193549,
            283187676,
            283189523,
            283193094,
            283182769,
            283189185,
            283185401,
            283198807,
            283189030
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "Solution The optimal subsequence must contain at least one occurrence of\nthe maximum () (suppose it doesnât; then you can just add one\noccurrence, at the cost of removing at most two elements, and this does\nnot make your score smaller).Now you can iterate over the minimum value\n(), in decreasing order. At any moment, you can pick elements with\nvalues . Then you have to support queries \"insert pick-able element\" and\n\"calculate score\".The pick-able elements make some \"connected\ncomponents\" of size , and you can pick elements. You can maintain the\ncomponents with a DSU.You also want to pick an element with value . For\neach component, check if it contains in a subsequence with maximum size.\nIf this does not happen for any component, your score decreases by . All\nthis information can be maintained by storing, for each component, if it\ncontains in even positions, and if it contains in odd\npositions.Complexity:\n",
    "name": "D. Max Plus Min Plus Size",
    "statement": "You are given an array a_1, a_2,\r\nldots, a_n of positive integers.You can color some elements of the array\r\nred, but there cannot be two adjacent red elements (i.e., for 1\r\nleq i\r\nleq n-1, at least one of a_i and a_{i+1} must not be red).Your score is\r\nthe maximum value of a red element, plus the minimum value of a red\r\nelement, plus the number of red elements. Find the maximum score you can\r\nget.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;template<class Info>struct SegmentTree {    int n;    std::vector<Info> info;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template<class T>    SegmentTree(std::vector<T> init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template<class T>    void init(std::vector<T> init_) {        n = init_.size();        info.assign(4 << std::__lg(n), Info());        std::function<void(int, int, int)> build = [&](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void modify(int p, int l, int r, int x, const Info &v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        if (x < m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l >= y || r <= x) {            return Info();        }        if (l >= x && r <= y) {            return info[p];        }        int m = (l + r) / 2;        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    template<class F>    int findFirst(int p, int l, int r, int x, int y, F &&pred) {        if (l >= y || r <= x) {            return -1;        }        if (l >= x && r <= y && !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template<class F>    int findFirst(int l, int r, F &&pred) {        return findFirst(1, 0, n, l, r, pred);    }    template<class F>    int findLast(int p, int l, int r, int x, int y, F &&pred) {        if (l >= y || r <= x) {            return -1;        }        if (l >= x && r <= y && !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template<class F>    int findLast(int l, int r, F &&pred) {        return findLast(1, 0, n, l, r, pred);    }}; constexpr i64 inf = 1E18;struct Matrix {    i64 a[4][4];    Matrix() {        for (int i = 0; i < 4; i++) {            for (int j = 0; j < 4; j++) {                a[i][j] = (i == j ? 0 : -inf);            }        }    }}; Matrix operator+(const Matrix &a, const Matrix &b) {    Matrix c;    for (int i = 0; i < 4; i++) {        for (int j = 0; j < 4; j++) {            c.a[i][j] = -inf;            for (int k = 0; k < 4; k++) {                c.a[i][j] = std::max(c.a[i][j], a.a[i][k] + b.a[k][j]);            }        }    }    return c;}void solve() {    int n;    std::cin >> n;        std::vector<int> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }        std::vector<int> ord(n);    std::iota(ord.begin(), ord.end(), 0);    std::sort(ord.begin(), ord.end(),        [&](int i, int j) {            return a[i] > a[j];        });        Matrix init;    for (int i = 0; i < 4; i++) {        for (int j = 0; j < 4; j++) {            init.a[i][j] = -inf;        }    }    init.a[0][0] = 0;    init.a[1][0] = 0;    init.a[2][2] = 0;    init.a[3][2] = 0;    SegmentTree<Matrix> seg(std::vector(n, init));    i64 ans = 0;    for (auto i : ord) {        Matrix m = init;        m.a[0][1] = 1;        m.a[0][3] = a[i] + 1;        m.a[2][3] = 1;        seg.modify(i, m);        auto res = seg.rangeQuery(0, n);        ans = std::max({ans, res.a[0][2] + a[i], res.a[0][3] + a[i]});    }        std::cout << ans << \"\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "dsu",
        "greedy",
        "implementation",
        "matrices",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Max Plus Min Plus Size.json",
    "hint": [
        "Hint 1 The optimal subsequence must contain at least one occurrence of the maximum.",
        "Hint 2 Iterate over the minimum, in decreasing order.",
        "Hint 3 You have some \"connected components\". How many elements can you pick from each component? How to make sure you have picked at least one occurrence of the maximum?"
    ]
}