{
    "link": "https://codeforces.com//contest/375/problem/E",
    "problemId": "4239",
    "problem_idx": "E",
    "shortId": "375E",
    "contest_number": "375",
    "problem_submissions": {
        "E": [
            5516578,
            5543517,
            7404743,
            7404550
        ],
        "D": [
            5508327,
            5506241,
            5508178,
            5506936,
            5508210,
            5509728,
            5509565,
            5509786,
            5510266,
            5509657,
            5507662,
            5512033,
            5510626,
            5507997,
            5508460,
            5508656,
            5508269,
            5508332,
            5508891
        ],
        "C": [
            5505383,
            5509032,
            5505557,
            5508883,
            5509512,
            5507599,
            5508675,
            5508564,
            5508334,
            5508031,
            5521682,
            5507298,
            5515252
        ],
        "B": [
            5503331,
            5504049,
            5503218,
            5504342,
            5504635,
            5505593,
            5504545,
            5506014,
            5505956,
            5506155,
            5504757,
            5503899,
            5502860,
            5504310,
            5504273,
            5505401,
            5504620,
            5504706
        ],
        "A": [
            5502699,
            5502984,
            5506272,
            5503668,
            5503511,
            5502852,
            5503508,
            5504680,
            5504651,
            5505085,
            5503979,
            5502926,
            5504511,
            5503159,
            5503448,
            5504768,
            5503302,
            5503553
        ]
    },
    "name": "E. Red and Black Tree",
    "statement": "You have a weighted tree, consisting of vertices. Each vertex is either\r\npainted black or is painted red. A red and black tree is called , if for\r\nany its vertex we can find a black vertex at distance at most .The\r\ndistance between two nodes is the shortest path between them.You have a\r\nred and black tree. Your task is to make it beautiful in the minimum\r\nnumber of color swap operations. In one color swap operation, you can\r\nchoose two vertices of different colors and paint each of them the other\r\ncolor. In other words, if you choose a red vertex and a black vertex ,\r\nthen in one operation you are allowed to paint black and paint red.Print\r\nthe minimum number of required actions.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <numeric>\nusing namespace std;\n\nconst int MAX_N = 500 + 1, INF = 10000;\nint dist[MAX_N][MAX_N];\n\nstruct Edge {\n\tint t, c;\n\tEdge(int t, int c) :\n\t\t\tt(t), c(c) {\n\t}\n};\n\nvector<Edge> E[MAX_N];\nint n, x;\n\n//B->B\n//|G->B| is minimum and |B->B|+|G->B|<=|B|\n\nshort dp[MAX_N][MAX_N][MAX_N]; //i,B,w :min G->B\nint best[MAX_N][MAX_N]; //i,B :min G->B\nint size[MAX_N];\nint color[MAX_N];\n\nvoid dfs2(int u, int par, int rt, int d) {\n\td = min(d, x + 1);\n\tdist[rt][u] = d;\n\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e)\n\t\tif (e->t != par) {\n\t\t\tdfs2(e->t, u, rt, d + e->c);\n\t\t}\n}\n\nvoid dfs(int u, int par) {\n//\tsize[u] = 1;\n\tsize[u] = 1;\n\n\tint ch[MAX_N], nCh = 0;\n\tstatic int dp2[MAX_N][MAX_N]; //iter,B\n\n\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e)\n\t\tif (e->t != par) {\n\t\t\tch[nCh++] = e->t;\n\t\t\tdfs(e->t, u);\n\t\t\tsize[u] += size[e->t];\n\t\t}\n\n\tfor (int w = 0; w < n; ++w) {\n\t\tif (dist[u][w] > x) {\n\t\t\tfor (int a = 0; a <= n; ++a) {\n\t\t\t\tdp[u][a][w] = INF;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tint tot = 1;\n\t\tdp2[0][0] = 0;\n\n\t\tfor (int i = 0; i < nCh; ++i) {\n\t\t\tint c = ch[i];\n\t\t\tint nxt = tot + size[c];\n\n\t\t\tfor (int j = 0; j < nxt; ++j) {\n\t\t\t\tdp2[i + 1][j] = INF;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < tot; ++j) {\n\t\t\t\tfor (int k = 0; k <= size[c]; ++k) {\n\t\t\t\t\t//same as w\n\t\t\t\t\tif (k < size[c])\n\t\t\t\t\t\tdp2[i + 1][j + k] = min(dp2[i + 1][j + k],\n\t\t\t\t\t\t\t\tdp2[i][j] + dp[c][k][w]);\n\t\t\t\t\t//use best\n\t\t\t\t\tdp2[i + 1][j + k] = min(dp2[i + 1][j + k],\n\t\t\t\t\t\t\tdp2[i][j] + best[c][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot = nxt;\n\t\t}\n\n\t\tfor (int j = 0; j < tot; ++j) {\n\t\t\tdp[u][j][w] = dp2[nCh][j];\n\t\t}\n\t}\n\n\t//calc best\n\tfor (int j = 0; j <= size[u]; ++j) {\n\t\tbest[u][j] = INF;\n\t}\n\tfor (int j = 0; j < size[u]; ++j) {\n\t\tfor (int w = 0; w < n; ++w) {\n\t\t\tbest[u][j + 1] = min(best[u][j + 1], dp[u][j][w] + (color[w] == 0));\n\t\t}\n\t}\n}\n\nvoid genRandomTree(int n) {\n//\tsrand(234324);\n\t::n = n, x = rand();\n//\tcout << x << endl;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcolor[i] = (rand() % 5 == 0);\n\t\tE[i].clear();\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tint a = i, b = rand() % i, c = (rand() % x) / 2.2;\n\t\tE[a].push_back(Edge(b, c));\n\t\tE[b].push_back(Edge(a, c));\n\t}\n}\n\nint bruteForce() {\n\tint ans = INF;\n\tint bcnt = accumulate(color, color + n, 0);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdfs2(i, -1, i, 0);\n\t}\n\tfor (int black = 0; black < (1 << n); ++black) {\n\t\tint cnt = 0, ret = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (black >> i & 1) {\n\t\t\t\t++cnt;\n\t\t\t\tif (color[i] == 0)\n\t\t\t\t\t++ret;\n\t\t\t}\n\t\tif (cnt > bcnt)\n\t\t\tcontinue;\n\t\tbool can = true;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tbool ok = false;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (dist[i][j] <= x && (black >> j & 1))\n\t\t\t\t\tok = true;\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tcan = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (can) {\n\t\t\tans = min(ans, ret);\n\t\t}\n\t}\n//\tcerr << ans << endl;\n\treturn ans;\n}\n\nint work() {\n\tint bcnt = accumulate(color, color + n, 0);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdfs2(i, -1, i, 0);\n\t}\n\n\tdfs(0, -1);\n\n\tint ans = INF;\n\tfor (int i = 0; i <= bcnt; ++i) {\n\t\tans = min(ans, best[0][i]);\n\t}\n\treturn ans;\n}\n\nint main() {\n//\tcout << sizeof(dp) / (1024 * 1024.0) << endl;\n\tcin >> n >> x;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", color + i);\n//\t\tbcnt += color[i];\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c), --a, --b;\n\t\tE[a].push_back(Edge(b, c));\n\t\tE[b].push_back(Edge(a, c));\n\t}\n\n\tint ans = work();\n\tif (ans == INF)\n\t\tans = -1;\n\tcout << ans << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Red and Black Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/10084",
    "editorial": "This problem can be solved by integer programming: As\nit is known, integer programming is NP-hard. Thus, this cannot be the\nsolution. But we can prove the following linear programing\u00e2\u0080\u0099s solution is\nsame as the integer programming\u00e2\u0080\u0099s. And the known fastest algorithm to\nsolve linear programming is O(n^3.5). But in fact due to the property of\nthis problem, using simplex algorithm to solve linear programming is\neven faster. I think it can be O(n^3), but I have no proof. So just use\nsimplex to solve the linear programming problem above. The tutorial is\nnot finished yet. More details will be added later. UPD Thanks to\nCodeforces users, a lot of details supposed to be added can be found in\ncomments. I am adding something that is not clearly explained in the\ncomments or something that I want to share with you. Div1C: There are\nfew questions about this one. So I am explaining it more clearly.\nState(i, j, ts, bs) means: 1. You are at cell (i, j) 2. If the i-th bit\nof ts is 0 i-th treasure cross even edges of current path, otherwise odd\nedges. 3. If the i-th bit of bs is 0 i-th boom cross even edges of\ncurrent path, otherwise odd edges. Let dis[i][j][ts][bs] = min step to\ngo to reach state (i, j, ts, bs). Then we can use bfs algorithm to\ncalculate dis. About the bfs algorithm: The answer will be max{value(ts)\ndis[Si][Sj][ts][0]} My submission: 5550863 Div1D: To our surprise, there\nseems to be many different solutions to Div1D, which is very good. In\nfact, we thought about changing this problem so that only online\nalgorithm will be accepted, but we didn\u00e2\u0080\u0099t have much time to change it. I\nguess if we only accept online algorithm, the problem will be less\ninteresting becasue we might not have so many different solutions. So,\nnot changing it is a good decision. However, it may(some solution is\nhard to change to solve the online-version, so I use \u00e2\u0080\u0099may\u00e2\u0080\u0099) be quite\nsimple to solve the online-version of this problem if you have solved\nthe offline-version. You just need to use persistent data structure when\nimplementing binary search trees. You can get more detail from wiki.\nDiv1E: The meaning of the integer programming: After changing it to\nlinear programming: My submission: 5523033 There is a nice DP solution\ntoo, check this submission 5516578 by Touma_Kazusa.\n"
}