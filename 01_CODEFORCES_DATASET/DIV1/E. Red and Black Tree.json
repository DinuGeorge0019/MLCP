{"link": "https://codeforces.com//contest/375/problem/E", "problemId": "4239", "problem_idx": "E", "shortId": "375E", "contest_number": "375", "problem_submissions": {"E": [5516578, 5543517, 7404743, 7404550], "D": [5508327, 5506241, 5508178, 5506936, 5508210, 5509728, 5509565, 5509786, 5510266, 5509657, 5507662, 5512033, 5510626, 5507997, 5508460, 5508656, 5508269, 5508332, 5508891], "C": [5505383, 5509032, 5505557, 5508883, 5509512, 5507599, 5508675, 5508564, 5508334, 5508031, 5521682, 5507298, 5515252], "B": [5503331, 5504049, 5503218, 5504342, 5504635, 5505593, 5504545, 5506014, 5505956, 5506155, 5504757, 5503899, 5502860, 5504310, 5504273, 5505401, 5504620, 5504706], "A": [5502699, 5502984, 5506272, 5503668, 5503511, 5502852, 5503508, 5504680, 5504651, 5505085, 5503979, 5502926, 5504511, 5503159, 5503448, 5504768, 5503302, 5503553]}, "name": "E. Red and Black Tree", "statement": "You have a weighted tree, consisting of vertices. Each vertex is either\r\npainted black or is painted red. A red and black tree is called , if for\r\nany its vertex we can find a black vertex at distance at most .The\r\ndistance between two nodes is the shortest path between them.You have a\r\nred and black tree. Your task is to make it beautiful in the minimum\r\nnumber of color swap operations. In one color swap operation, you can\r\nchoose two vertices of different colors and paint each of them the other\r\ncolor. In other words, if you choose a red vertex and a black vertex ,\r\nthen in one operation you are allowed to paint black and paint red.Print\r\nthe minimum number of required actions.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <numeric>\nusing namespace std;\n\nconst int MAX_N = 500 + 1, INF = 10000;\nint dist[MAX_N][MAX_N];\n\nstruct Edge {\n\tint t, c;\n\tEdge(int t, int c) :\n\t\t\tt(t), c(c) {\n\t}\n};\n\nvector<Edge> E[MAX_N];\nint n, x;\n\n//B->B\n//|G->B| is minimum and |B->B|+|G->B|<=|B|\n\nshort dp[MAX_N][MAX_N][MAX_N]; //i,B,w :min G->B\nint best[MAX_N][MAX_N]; //i,B :min G->B\nint size[MAX_N];\nint color[MAX_N];\n\nvoid dfs2(int u, int par, int rt, int d) {\n\td = min(d, x + 1);\n\tdist[rt][u] = d;\n\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e)\n\t\tif (e->t != par) {\n\t\t\tdfs2(e->t, u, rt, d + e->c);\n\t\t}\n}\n\nvoid dfs(int u, int par) {\n//\tsize[u] = 1;\n\tsize[u] = 1;\n\n\tint ch[MAX_N], nCh = 0;\n\tstatic int dp2[MAX_N][MAX_N]; //iter,B\n\n\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e)\n\t\tif (e->t != par) {\n\t\t\tch[nCh++] = e->t;\n\t\t\tdfs(e->t, u);\n\t\t\tsize[u] += size[e->t];\n\t\t}\n\n\tfor (int w = 0; w < n; ++w) {\n\t\tif (dist[u][w] > x) {\n\t\t\tfor (int a = 0; a <= n; ++a) {\n\t\t\t\tdp[u][a][w] = INF;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tint tot = 1;\n\t\tdp2[0][0] = 0;\n\n\t\tfor (int i = 0; i < nCh; ++i) {\n\t\t\tint c = ch[i];\n\t\t\tint nxt = tot + size[c];\n\n\t\t\tfor (int j = 0; j < nxt; ++j) {\n\t\t\t\tdp2[i + 1][j] = INF;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < tot; ++j) {\n\t\t\t\tfor (int k = 0; k <= size[c]; ++k) {\n\t\t\t\t\t//same as w\n\t\t\t\t\tif (k < size[c])\n\t\t\t\t\t\tdp2[i + 1][j + k] = min(dp2[i + 1][j + k],\n\t\t\t\t\t\t\t\tdp2[i][j] + dp[c][k][w]);\n\t\t\t\t\t//use best\n\t\t\t\t\tdp2[i + 1][j + k] = min(dp2[i + 1][j + k],\n\t\t\t\t\t\t\tdp2[i][j] + best[c][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot = nxt;\n\t\t}\n\n\t\tfor (int j = 0; j < tot; ++j) {\n\t\t\tdp[u][j][w] = dp2[nCh][j];\n\t\t}\n\t}\n\n\t//calc best\n\tfor (int j = 0; j <= size[u]; ++j) {\n\t\tbest[u][j] = INF;\n\t}\n\tfor (int j = 0; j < size[u]; ++j) {\n\t\tfor (int w = 0; w < n; ++w) {\n\t\t\tbest[u][j + 1] = min(best[u][j + 1], dp[u][j][w] + (color[w] == 0));\n\t\t}\n\t}\n}\n\nvoid genRandomTree(int n) {\n//\tsrand(234324);\n\t::n = n, x = rand();\n//\tcout << x << endl;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcolor[i] = (rand() % 5 == 0);\n\t\tE[i].clear();\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tint a = i, b = rand() % i, c = (rand() % x) / 2.2;\n\t\tE[a].push_back(Edge(b, c));\n\t\tE[b].push_back(Edge(a, c));\n\t}\n}\n\nint bruteForce() {\n\tint ans = INF;\n\tint bcnt = accumulate(color, color + n, 0);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdfs2(i, -1, i, 0);\n\t}\n\tfor (int black = 0; black < (1 << n); ++black) {\n\t\tint cnt = 0, ret = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (black >> i & 1) {\n\t\t\t\t++cnt;\n\t\t\t\tif (color[i] == 0)\n\t\t\t\t\t++ret;\n\t\t\t}\n\t\tif (cnt > bcnt)\n\t\t\tcontinue;\n\t\tbool can = true;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tbool ok = false;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (dist[i][j] <= x && (black >> j & 1))\n\t\t\t\t\tok = true;\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tcan = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (can) {\n\t\t\tans = min(ans, ret);\n\t\t}\n\t}\n//\tcerr << ans << endl;\n\treturn ans;\n}\n\nint work() {\n\tint bcnt = accumulate(color, color + n, 0);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdfs2(i, -1, i, 0);\n\t}\n\n\tdfs(0, -1);\n\n\tint ans = INF;\n\tfor (int i = 0; i <= bcnt; ++i) {\n\t\tans = min(ans, best[0][i]);\n\t}\n\treturn ans;\n}\n\nint main() {\n//\tcout << sizeof(dp) / (1024 * 1024.0) << endl;\n\tcin >> n >> x;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", color + i);\n//\t\tbcnt += color[i];\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c), --a, --b;\n\t\tE[a].push_back(Edge(b, c));\n\t\tE[b].push_back(Edge(a, c));\n\t}\n\n\tint ans = work();\n\tif (ans == INF)\n\t\tans = -1;\n\tcout << ans << endl;\n}\n"], "input": "", "output": "", "tags": ["dp", "implementation", "math"], "dificulty": "3000", "interactive": false}