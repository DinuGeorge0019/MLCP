{
    "link": "https://codeforces.com//contest/853/problem/A",
    "problemId": "121088",
    "problem_idx": "A",
    "shortId": "853A",
    "contest_number": "853",
    "problem_submissions": {
        "D": [
            30147648,
            30145874,
            30152169,
            30145670,
            30147401,
            30148548,
            30157869,
            30157814,
            30157512,
            30150989,
            30149728,
            30151353,
            30151549,
            30150847,
            30147708,
            30168803,
            30167984,
            30151241,
            30151140,
            30151931,
            30151709,
            30155800,
            30154094,
            30151955
        ],
        "C": [
            30142518,
            30148496,
            30147073,
            30143792,
            30144399,
            30146037,
            30145612,
            30146271,
            30147784,
            30146395,
            30148182,
            30151583,
            30168390,
            30147533,
            30148448,
            30148036,
            30147775,
            30144847,
            30147101,
            30148563
        ],
        "B": [
            30137358,
            30139471,
            30141499,
            30138298,
            30137334,
            30139875,
            30139930,
            30139800,
            30141449,
            30137864,
            30144203,
            30143376,
            30142744,
            30143145,
            30140773,
            30144005,
            30140202,
            30140453,
            30142525
        ],
        "A": [
            30133427,
            30134359,
            30136395,
            30133742,
            30132639,
            30132563,
            30134311,
            30135028,
            30134993,
            30133338,
            30136720,
            30135878,
            30134302,
            30137681,
            30134274,
            30133388,
            30133609,
            30133814,
            30134640
        ],
        "E": [
            30179221,
            30179071,
            31229560,
            30173059
        ]
    },
    "name": "A. Planning",
    "statement": "Helen works in Metropolis airport. She is responsible for creating a\r\ndeparture schedule. There are flights that must depart today, the -th of\r\nthem is planned to depart at the -th minute of the day.Metropolis\r\nairport is the main transport hub of Metropolia, so it is difficult to\r\nkeep the schedule intact. This is exactly the case today: because of\r\ntechnical issues, no flights were able to depart during the first\r\nminutes of the day, so now the new departure schedule must be\r\ncreated.All scheduled flights must now depart at different minutes\r\nbetween -th and -th, inclusive. However, it’s not mandatory for the\r\nflights to depart in the same order they were initially scheduled to do\r\nso their order in the new schedule can be different. There is only one\r\nrestriction: no flight is allowed to depart earlier than it was supposed\r\nto depart in the initial schedule.Helen knows that each minute of delay\r\nof the -th flight costs airport burles. Help her find the order for\r\nflights to depart in the new schedule that minimizes the total cost for\r\nthe airport.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n#define mp make_pair\n\nconst int N = 300300;\nll a[N];\nint ans[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tset<pli> setik;\n\tll sum = 0;\n\tll ANS = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tANS += (k - i) * a[i];\n\t\tsum += a[i];\n\t\tsetik.insert(mp(-a[i], i));\n\t}\n\tfor (int i = k; i < n; i++) {\n\t\tsum += a[i];\n\t\tsetik.insert(mp(-a[i], i));\n\t\tsum += setik.begin()->first;\n\t\tans[setik.begin()->second] = i;\n\t\tsetik.erase(setik.begin());\n\t\tANS += sum;\n\t}\n\tfor (int i = n; i < n + k; i++) {\n\t\tsum += setik.begin()->first;\n\t\tans[setik.begin()->second] = i;\n\t\tsetik.erase(setik.begin());\n\t\tANS += sum;\n\t}\n\tprintf(\"%lld\\n\", ANS);\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", ans[i] + 1);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Planning.json",
    "editorial_link": "https://codeforces.com//blog/entry/54368",
    "editorial": "We will show that following greedy is correct: letâs for each moment of\r\ntime use a plane, which can depart in this moment of time (and didnât\r\ndepart earlier, of course) with minimal cost of delay. Proof is quite\r\nsimple: itâs required to minimize . You can notice that is constant, so\r\nwe just need to minimize . Consider the optimal solution when plane\r\ndeparts at moment and solution by greedy algorithm in which plane\r\ndeparts at moment . Let be plane with minimal , such . At any moment\r\ngreedy algorithm takes avaliable plane with lowest , so . Let be a\r\nplane, such that . But , so and itâs possible to swap and in optimal\r\nsolution without loosing of optimality. By performing this operation\r\nmany times itâs possible to make for each and it means that greedy\r\nsolution is optimal.To make this solution work fast you need to use some\r\ndata structures to find optimal plane faster for each moment. This data\r\nstructure should be able to add number into set, give value of minimal\r\nelement in set and erase minimal number from set. For this purpose you\r\ncan use heap (or someting like std::set or std::priority_queue in C++).\r\n",
    "hint": []
}