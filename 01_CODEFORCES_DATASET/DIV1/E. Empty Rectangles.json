{
    "link": "https://codeforces.com//contest/364/problem/E",
    "problemId": "4045",
    "problem_idx": "E",
    "shortId": "364E",
    "contest_number": "364",
    "problem_submissions": {
        "E": [
            5182930,
            5182917,
            5182805,
            5182789,
            5182779,
            5163338,
            5192424,
            5192315,
            5285842
        ],
        "C": [
            5159826,
            5156914,
            5156913,
            5159036,
            5158199,
            5156857,
            5160288,
            5159437,
            5160554,
            5160938,
            5160044,
            5162865,
            5159797,
            5161370
        ],
        "B": [
            5155945,
            5152807,
            5153694,
            5154783,
            5155872,
            5158323,
            5155584,
            5154573,
            5157525,
            5158221,
            5171150,
            5155541,
            5157687,
            5162725,
            5157104
        ],
        "A": [
            5151035,
            5151153,
            5151193,
            5150604,
            5151593,
            5151967,
            5152019,
            5151677,
            5154003,
            5153612,
            5152606,
            5154441,
            5150915,
            5155034
        ],
        "D": [
            5159378,
            5164152,
            5164129,
            5165101,
            26468599,
            26468582,
            26468554,
            5164765,
            5178204,
            5178186,
            5165121,
            5171056,
            5929384,
            5343038
        ]
    },
    "name": "E. Empty Rectangles",
    "statement": "You’ve got an table ( rows and columns), each cell of the table contains\r\na \"0\" or a \"1\".Your task is to calculate the number of rectangles with\r\nthe sides that are parallel to the sides of the table and go along the\r\ncell borders, such that the number one occurs exactly times in the\r\nrectangle.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define REPC(I, C) for (int I = 0; !(C); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\nconst int SIZE = 2555;\nint N,M,K,dd[SIZE][SIZE];\nchar s[SIZE];\nint get(int x1,int y1,int x2,int y2){\n    x1--;y1--;\n    return dd[x2][y2]-dd[x2][y1]-dd[x1][y2]+dd[x1][y1];\n}\nlong long an;\nvoid divide(int x1,int y1,int x2,int y2){\n    if(x1==x2&&y1==y2){\n        if(get(x1,y1,x2,y2)==K)an++;\n        return;\n    }\n    int ty=1;\n    if(x2-x1>y2-y1)ty=0;\n    if(ty==0){\n        int mm=(x1+x2)>>1;\n        for(int i=y1;i<=y2;i++){\n            int cnt[2][7]={};\n            for(int j=y2;j>=i;j--){\n                for(int k=0;k<=K;k++)\n                    while(cnt[0][k]<=mm-x1&&get(mm-cnt[0][k],i,mm,j)<=k)cnt[0][k]++;\n                for(int k=0;k<=K;k++)\n                    while(cnt[1][k]<x2-mm&&get(mm+1,i,mm+cnt[1][k]+1,j)<=k)cnt[1][k]++;\n                for(int k=0;k<=K;k++)\n                    an+=(cnt[0][k]-(k?cnt[0][k-1]:0))*(cnt[1][K-k]-(K-k?cnt[1][K-k-1]:0));\n            }\n        }\n        divide(x1,y1,mm,y2);\n        divide(mm+1,y1,x2,y2);\n    }\n    else{\n        int mm=(y1+y2)>>1;\n        for(int i=x1;i<=x2;i++){\n            int cnt[2][7]={};\n            for(int j=x2;j>=i;j--){\n                for(int k=0;k<=K;k++)\n                    while(cnt[0][k]<=mm-y1&&get(i,mm-cnt[0][k],j,mm)<=k)cnt[0][k]++;\n                for(int k=0;k<=K;k++)\n                    while(cnt[1][k]<y2-mm&&get(i,mm+1,j,mm+cnt[1][k]+1)<=k)cnt[1][k]++;\n                for(int k=0;k<=K;k++)\n                    an+=(cnt[0][k]-(k?cnt[0][k-1]:0))*(cnt[1][K-k]-(K-k?cnt[1][K-k-1]:0));\n            }\n        }\n        divide(x1,y1,x2,mm);\n        divide(x1,mm+1,x2,y2);\n    }\n}\nint main(){\n    RIII(N,M,K);\n    for(int i=1;i<=N;i++){\n        RS(s+1);\n        for(int j=1;j<=M;j++)\n            dd[i][j]=dd[i][j-1]+dd[i-1][j]-dd[i-1][j-1]+s[j]-'0';\n    }\n    divide(1,1,N,M);\n    cout<<an<<endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "two pointers"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Empty Rectangles.json",
    "editorial_link": "https://codeforces.com//blog/entry/9657",
    "editorial": "Let's find number of rectangles whick consist k ones and intersect  in cartesian coordinate system.\nIt's possible to do it in n2·k. We need to find closest k ones on the top and on the bottom of the  and enumareate all segments [l,?r] such as 1???l???r???n and find closest k ones on the top and on the bottom of the segments merging results for rows.\nIf we have k closest ones on the top and on the bottom of the segment we will find number of rectangles consists k ones and cross  on [l,?r] in O(k).\nThen we should find number of rectangles, which don't cross . Let's rotate table by 90 degrees, solve similar problem for two halfs of the table and so on.\n for square-shaped tables.\n \n\nAt the picture 1 two closest ones on the top (black cells) lying on the 4'th and 2'nd horizontals. Closest ones on the bottom lying on the 5'th and 7'th. Then if k?=?2 there are zero correct rectangles with two \"ones\" on the tom. There are four rectangles which consist one \"one\" on the top and one \"one\" on the bottom. You can see how segment grows up at the pictures 2, 3 and 4. Every time you should merge closest k ones of the added row with closest k ones of the current segment.",
    "hint": []
}