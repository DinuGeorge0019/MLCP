{"link": "https://codeforces.com//contest/806/problem/D", "problemId": "105598", "problem_idx": "D", "shortId": "806D", "contest_number": "806", "problem_submissions": {"E": [26946399, 26946353, 26942942, 26940751, 26976136, 26943065, 26942598, 26942187, 26937843, 26947143, 27001343, 26946488, 26943631, 26951183, 26939699, 26944777], "D": [26938120, 26934427, 26936263, 26937600, 26934513, 26936339, 26937621, 26938327, 26939404, 26938853, 26942391, 26940455, 26938860, 26938974, 26941503, 26941670], "B": [26933193, 26932004, 26938489, 26932467, 26931704, 26932365, 26935492, 26932113, 26930780, 26942817, 26930285, 26932725, 26943302, 26937682, 26931932, 26932598], "C": [26931766, 26942392, 26933099, 26934784, 26933629, 26933365, 26933930, 26931141, 26934600, 26930447, 26934117, 26934951, 26929917, 26933809, 26935513, 26934671], "A": [26928049, 26926811, 26929039, 26927072, 26927004, 26926681, 26927002, 26927962, 26928737, 26927722, 26927311, 26932013, 26927300, 26928724, 26926850, 26927034, 26927665, 26929077]}, "name": "D. Perishable Roads", "statement": "In the country of Never, there are cities and a well-developed road\r\nsystem. There is exactly one bidirectional road between every pair of\r\ncities, thus, there are as many as roads! No two roads intersect, and no\r\nroad passes through intermediate cities. The art of building tunnels and\r\nbridges has been mastered by Neverians.An independent committee has\r\nevaluated each road of Never with a positive integer called the of the\r\nroad. The lower the road\u2019s perishability is, the more pleasant it is to\r\ndrive through this road.It\u2019s the year of transport in Never. It has been\r\ndecided to build a museum of transport in one of the cities, and to set\r\na single signpost directing to some city (not necessarily the one with\r\nthe museum) in each of the other cities. The signposts must satisfy the\r\nfollowing important condition: if any Neverian living in a city without\r\nthe museum starts travelling from that city following the directions of\r\nthe signposts, then this person will eventually arrive in the city with\r\nthe museum.Neverians are incredibly positive-minded. If a Neverian\r\ntravels by a route consisting of several roads, he considers the to be\r\nequal to the smallest perishability of all the roads in this route.The\r\ngovernment of Never has not yet decided where to build the museum, so\r\nthey consider all possible options. The most important is the sum of\r\nperishabilities of the routes to the museum city from all the other\r\ncities of Never, if the travelers strictly follow the directions of the\r\nsignposts. The government of Never cares about their citizens, so they\r\nwant to set the signposts in a way which minimizes this sum. Help them\r\ndetermine the minimum possible sum for all possible options of the city\r\nwhere the museum can be built.\r\n", "solutions": ["#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\n#define tm f__k\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\nconst int MN = 2020;\nint n;\nll g[MN][MN];\nll ans[MN];\n\nvoid calc(int r) {\n    ll dist[MN];\n    fill(dist, dist+MN, TEN(18));\n    dist[r] = 0;\n    for (int i = 0; i < n; i++) {\n        if (i == r) continue;\n        for (int j = 0; j < n; j++) {\n            if (j == r || i == j) continue;\n            dist[j] = min(dist[j], 2*g[i][j]);\n        }\n    }\n    bool used[MN] = {};\n    while (true) {\n        ll mi = TEN(18), midx = -1;\n        for (int i = 0; i < n; i++) {\n            if (used[i]) continue;\n            if (dist[i] < mi) {\n                mi = dist[i];\n                midx = i;\n            }\n        }\n        if (midx == -1) break;\n        int i = midx;\n        used[i] = true;\n        for (int j = 0; j < n; j++) {\n            dist[j] = min(dist[j], dist[i]+g[i][j]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        ans[i] = min(ans[i], dist[i]);\n    }\n/*    for (int i = 0; i < n; i++) {\n        cout << dist[i] << \", \";\n    }\n    cout << endl;*/\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        g[i][i] = 0;\n        for (int j = i+1; j < n; j++) {\n            ll x;\n            cin >> x;\n            g[i][j] = g[j][i] = x;\n        }\n    }\n\n    ll mi = TEN(18);\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            mi = min(mi, g[i][j]);\n        }\n    }\n\n    int a;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (g[i][j] == mi) {\n                a = i;\n            }\n            g[i][j] -= mi;\n            g[j][i] -= mi;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        ans[i] = TEN(18);\n    }\n    calc(a);\n\n    for (int i = 0; i < n; i++) {\n        cout << ans[i] + mi * (n-1) << endl;\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "shortest paths"], "dificulty": "2700", "interactive": false}