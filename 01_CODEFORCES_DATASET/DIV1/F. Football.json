{
    "link": "https://codeforces.com//contest/1240/problem/F",
    "problemId": "432411",
    "problem_idx": "F",
    "shortId": "1240F",
    "contest_number": "1240",
    "problem_submissions": {
        "E": [
            62021022,
            62035875,
            62035850,
            62028210,
            62027934,
            62027922,
            62020968,
            62019492,
            62018107,
            62027376,
            62027344,
            62027323,
            62027283,
            62027247,
            62024590,
            62019193,
            62026365,
            62033510,
            66614259
        ],
        "F": [
            62015871,
            62023134,
            62022377,
            62098107,
            62038718,
            62038624,
            62038494,
            62038407,
            62038292,
            74689890,
            62022214
        ],
        "C": [
            62011492,
            62004160,
            62005302,
            62005113,
            62008834,
            61997769,
            62007006,
            62008153,
            62005139,
            62004806,
            62004551,
            62010900,
            62006495,
            62006440,
            62005717,
            62009451,
            62008088,
            62007344,
            62007020,
            62010351
        ],
        "D": [
            62009147,
            62009402,
            62014575,
            62037666,
            62037540,
            62037485,
            62037237,
            62030534,
            62030405,
            62030387,
            62030368,
            62030266,
            62027938,
            62013459,
            62012657,
            62006383,
            62007439,
            62012558,
            62014620,
            62005092,
            62013564,
            62012342,
            62013093,
            62013916,
            62013931,
            62014362,
            62014894
        ],
        "B": [
            61999051,
            61998153,
            62000446,
            61993443,
            62005202,
            62003856,
            62003729,
            61994391,
            61998951,
            61998615,
            61999693,
            62002895,
            62001444,
            62001486,
            61999611,
            62004268,
            62001331,
            62002370,
            62000744,
            61994760
        ],
        "A": [
            61993335,
            61995494,
            62011119,
            61998900,
            61995613,
            62001949,
            61995342,
            62005037,
            61996323,
            61994369,
            61994535,
            62007707,
            61995405,
            61994877,
            61995746,
            61997040,
            61995992,
            61997766,
            61995459,
            62004034
        ]
    },
    "name": "F. Football",
    "statement": "There are n football teams in the world. The Main Football Organization\r\n(MFO) wants to host at most m games. MFO wants the i-th game to be\r\nplayed between the teams a_i and b_i in one of the k stadiums. Let\r\ns_{ij} be the numbers of games the i-th team played in the j-th stadium.\r\nMFO does not want a team to have much more games in one stadium than in\r\nthe others. Therefore, for each team i, the absolute difference between\r\nthe maximum and minimum among s_{i1}, s_{i2},\r\nldots, s_{ik} should not exceed 2.Each team has w_i the amount of money\r\nMFO will earn for game of the i-th team. If the i-th team plays l games,\r\nMFO will earn w_i\r\ncdot l.MFO needs to find what games in what stadiums they need to host\r\nin order to earn as much money as possible, not violating the rule they\r\nset.However, this problem is too complicated for MFO. Therefore, they\r\nare asking you to help them.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db long double\n#define pii pair<int,int>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define INF ((1<<30)-233)\n#define sqr(x) ((x)*(x))\n#define debug puts(\"wzpkking\")\nusing namespace std;\n \nconst int M=5555;\nconst int N=2222;\nint col[2][M][N];\nvoid dfs(int p,int x,int y,int c0,int c1){\n\tint t=col[p^1][y][c0];\n\tcol[p][x][c0]=y;\n\tcol[p^1][y][c0]=x;\n\tif (!t){\n\t\tcol[p^1][y][c1]=0;\n\t\treturn;\n\t}\n\tdfs(p^1,y,t,c1,c0);\n}\n \nint n,m,k,s;\nint sz[2][N],id[2][N];\nint Id[M][M],ans[M];\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&s);\n\tfor (int i=1;i<=n;i++) scanf(\"%*d\");\n\tm=n;\n\tif (s==1){\n\t\tFor(i,1,k) printf(\"1 \");\n\t\treturn 0;\n\t}\n\tint nd=0,mx=0;\n\tFor(i,1,n) sz[0][i]=s;\n\tFor(i,1,m) sz[1][i]=s;\n\tFor(i,1,k){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (sz[0][x]==s)\n\t\t\tsz[0][x]=0,id[0][x]=++nd;\n\t\tsz[0][x]++; x=id[0][x];\n\t\tif (sz[1][y]==s)\n\t\t\tsz[1][y]=0,id[1][y]=++nd;\n\t\tsz[1][y]++; y=id[1][y];\n\t\t\n\t\tId[x][y]=i;\n\t\t\n\t\tint c0=1,c1=1;\n\t\tfor (;col[0][x][c0];c0++);\n\t\tfor (;col[1][y][c1];c1++);\n\t\tmx=max(mx,max(c0,c1));\n\t\tif (c0==c1){\n\t\t\tcol[0][x][c0]=y;\n\t\t\tcol[1][y][c0]=x;\n\t\t}\n\t\telse dfs(0,x,y,c0,c1);\n\t}\n\t\n\tint mn=0;\n\tFor(i,1,n) mn+=(sz[0][i]!=s);\n\tFor(i,1,m) mn+=(sz[1][i]!=s);\n\t//printf(\"%d\\n\",mn);\n\t\n\tFor(i,1,nd) For(j,1,mx)\n\t\tif (col[0][i][j])\n\t\t\tans[Id[i][col[0][i][j]]]=j;\n\t\n\tFor(i,1,k) printf(\"%d \",ans[i]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Football.json",
    "editorial_link": "https://codeforces.com/blog/entry/70358",
    "editorial": "Letâs assume that .We can randomly assign colors to edges. If there is a\r\nvertex that does not satisfy the condition, then we can choose color\r\nwhich appears the smallest number of times and color which appears the\r\nbiggest number of times. We will \"recolor\" edges that have one of these\r\ntwo colors. Letâs consider this graph only with edges with colors and .\r\nLetâs add a \"fake\" vertex . This graph may have many components. If a\r\ncomponent has at least one vertex with odd degree, we connect each such\r\nvertex with . Otherwise, letâs choose any vertex from that component and\r\nadd edges to . Therefore, the graph will be connected and each vertex\r\nwill have an even degree. Thus, we will be able to find an Euler cycle.\r\nLetâs color the odd edges in the cycle in , and even edges in . As a\r\nresult, the difference between these two colors for each vertex will be\r\nat most .Letâs do this operation while there is a vertex which does not\r\nsatisfy the condition.If , letâs split the edges into two groups with\r\nthe equal sizes (that is, and ). If a group has not greater than edges,\r\nthen do the algorithm at the beginning of the tutorial. Otherwise, split\r\nit again.If you found the answers for two groups, you need to find the\r\nanswer for the combined graph. Let be the most popular color in the\r\nfirst group, the second most popular color, ..., the least popular color\r\nin the first group. Similarly, let be the most popular color in the\r\nsecond graph, etc. So, in the combined graph, should be equal to ,\r\nshould be equal to . In other words, we take the most popular color in\r\nthe first group and color the least popular color in the second group\r\nwith that color. If there is a vertex that does not satisfy the\r\ncondition, \"recolor\" the graph according to the algorithm explained in\r\nthe third paragraph.\r\n",
    "hint": []
}