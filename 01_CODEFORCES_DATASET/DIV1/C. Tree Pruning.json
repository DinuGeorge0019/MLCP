{
    "link": "https://codeforces.com//contest/2018/problem/C",
    "problemId": "2905185",
    "problem_idx": "C",
    "shortId": "2018C",
    "contest_number": "2018",
    "problem_submissions": {
        "F1": [
            283240998,
            283223838,
            283219415,
            283236306,
            283222916,
            283217600,
            283233290,
            283231886,
            283231256,
            283232151,
            283229995,
            283237003,
            283235478,
            283237574,
            283236444,
            283230142,
            283243735,
            283243123,
            283242008,
            283243508
        ],
        "F2": [
            283240981,
            283223708,
            283219380,
            283241370,
            283223162,
            283225122,
            283233500,
            283231817,
            283231569,
            283232589,
            283230224,
            283236870,
            283235839,
            283237529,
            283238353,
            283243847,
            283243386,
            283242191,
            283243811
        ],
        "F3": [
            283240882,
            283223675,
            283219246,
            283271588,
            283270237,
            283224933,
            283229369,
            283236884,
            283231408,
            283234186,
            283238623,
            283246555,
            283236714,
            283242719,
            283237265,
            283240426,
            283246144,
            283243432,
            283242213,
            283244419
        ],
        "E2": [
            283228724,
            283271415,
            283952156,
            285367980,
            285366320,
            284023567,
            283309295
        ],
        "E1": [
            283228436,
            283232974,
            283271394,
            283269080,
            283266646,
            283248084,
            283226474,
            285366140,
            284023512,
            283309260,
            283237845
        ],
        "D": [
            283195973,
            283206733,
            283203886,
            283202562,
            283199647,
            283202135,
            283203009,
            283209326,
            283212471,
            283208248,
            283213153,
            283210604,
            283213401,
            283215308,
            283215785,
            283193803,
            283212467,
            283216433,
            283217858,
            283213030
        ],
        "C": [
            283191019,
            283190311,
            283188296,
            283196136,
            283191568,
            283193617,
            283197810,
            283200878,
            283205239,
            283197789,
            283193479,
            283202635,
            283205964,
            283204336,
            283202253,
            283186865,
            283201070,
            283203016,
            283201349,
            283204359
        ],
        "B": [
            283187765,
            283200401,
            283192789,
            283188636,
            283190321,
            283192212,
            283195063,
            283200019,
            283195292,
            283189706,
            283199364,
            283199549,
            283199094,
            283197971,
            283197559,
            283195753,
            283198921,
            283194967,
            283197864
        ],
        "A": [
            283182907,
            283184407,
            283187228,
            283181621,
            283185198,
            283186414,
            283185582,
            283191793,
            283185688,
            283183522,
            283193549,
            283187676,
            283189523,
            283193094,
            283182769,
            283189185,
            283185401,
            283198807,
            283189030
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "Solution If the final depth of the leaves is , itâs optimal to keep in\nthe tree all the nodes at depth and all their ancestors. These nodes are\nthe only ones which satisfy the following two conditions: their depth ()\nis ; the maximum depth of a node in their subtree () is . So every node\nis alive in the interval of depths . The optimal is the one contained in\nthe maximum number of intervals.\n",
    "name": "C. Tree Pruning",
    "statement": "You are given a tree with n nodes, rooted at node 1. In this problem, a\r\nleaf is a non-root node with degree 1.In one operation, you can remove a\r\nleaf and the edge adjacent to it (possibly, new leaves appear). What is\r\nthe minimum number of operations that you have to perform to get a tree,\r\nalso rooted at node 1, where all the leaves are at the same distance\r\nfrom the root?\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned; void solve() {    int n;    std::cin >> n;        std::vector<std::vector<int>> adj(n);    for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--;        v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        std::vector<int> dep(n), mx(n);    std::vector<int> f(n);    auto dfs = [&](auto &self, int x, int p) -> void {        mx[x] = dep[x];        for (auto y : adj[x]) {            if (y == p) {                continue;            }            dep[y] = dep[x] + 1;            self(self, y, x);            mx[x] = std::max(mx[x], mx[y]);        }        f[0]++;        f[dep[x]]--;        if (mx[x] + 1 < n) {            f[mx[x] + 1]++;        }    };    dfs(dfs, 0, -1);        for (int i = 1; i < n; i++) {        f[i] += f[i - 1];    }    int ans = *std::min_element(f.begin(), f.end());    std::cout << ans << \"\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "greedy",
        "sortings",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Tree Pruning.json",
    "hint": [
        "Hint 1 Solve for a fixed final depth of the leaves.",
        "Hint 2 Which nodes are \"alive\" if all leaves are at depth at the end?"
    ]
}