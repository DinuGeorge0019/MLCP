{"link": "https://codeforces.com//contest/1158/problem/E", "problemId": "343490", "problem_idx": "E", "shortId": "1158E", "contest_number": "1158", "problem_submissions": {"E": [54043697, 54045364, 54049022], "D": [54034270, 54037737, 54037081, 54029996, 54039126, 54036378, 54039507, 54040185, 54038993, 54040201, 54038641, 54040565, 54035763, 54041644, 54031772, 54033510, 54035224], "C": [54032525, 54035029, 54036135, 54034332, 54036498, 54034178, 54037957, 54038859, 54034328, 54037431, 54037039, 54036368, 54038382, 54039919, 54034772, 54037883, 54036347, 54039155], "B": [54031111, 54032629, 54034184, 54032709, 54033881, 54040878, 54036260, 54033097, 54031744, 54033322, 54032381, 54039897, 54035074, 54040745, 54038527, 54041411, 68070838, 54045735, 54041323], "A": [54029723, 54029634, 54031071, 54030974, 54029203, 54030224, 54030247, 54030013, 54029682, 54030151, 54031232, 54030952, 54031158, 54031859, 54031283, 54032676, 54031617, 54030225], "F": [54045740, 54049931, 74200730, 74200612, 73657677, 73657539, 73657494, 73657445, 73007148, 68077713, 68077566, 68077199, 68077121, 68076937]}, "name": "E. Strange device", "statement": "Vasya enjoys solving quizzes. He found a strange device and wants to\r\nknow how it works.This device encrypted with the tree (connected\r\nundirected graph without cycles) with n vertices, numbered with integers\r\nfrom 1 to n. To solve this quiz you should guess this tree.Fortunately,\r\nthis device can make one operation, using which you should guess the\r\ncipher. You can give the device an array d_1, d_2,\r\nldots, d_n of non-negative integers. On the device, there are n lamps,\r\ni-th of them is connected with i-th vertex of the tree. For all i the\r\nlight will turn on the i-th lamp, if there exist such vertex of the tree\r\nwith number j\r\nneq i that dist(i, j)\r\nleq d_j. Let\u2019s define dist(i, j) as the distance between vertices i and\r\nj in tree or number of edges on the simple path between vertices i and\r\nj.Vasya wants to solve this quiz using\r\nleq 80 operations with the device and guess the tree. Help him!\r\n", "solutions": ["#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint N;\n\nmap<vector<int>, vector<bool>> memo;\n\nvector<bool> Ask(const vector<int> &dists) {\n  if (count(ALL(dists), 0) == N) { return vector<bool>(N); }\n  auto iter = memo.find(dists);\n  if (iter != memo.end()) { return iter->nd; }\n\n  cout << \"?\";\n  for (int d : dists) { cout << \" \" << min(d, N - 1); }\n  cout << endl;\n  string ans;\n  cin >> ans;\n\n  vector<bool> ret(N);\n  for (int i = 0; i < N; ++i) {\n    ret[i] = ans[i] == '1';\n  }\n  return memo[dists] = ret;\n}\n\nvoid Answer(const vector<PII> &adj) {\n  cout << \"!\" << endl;\n  for (auto [u, v] : adj) {\n    cout << u + 1 << \" \" << v + 1 << endl;\n  }\n}\n\nint GetMaxH() {\n  vector<int> query(N);\n  int minh = 0, maxh = N;\n  while (maxh - minh > 1) {\n    const int mid = (minh + maxh) / 2;\n    query[0] = mid;\n    auto ans = Ask(query);\n    if (count(ALL(ans), true) == N - 1) {\n      maxh = mid;\n    } else {\n      minh = mid;\n    }\n  }\n  return maxh;\n}\n\nint32_t main() {\n  cin >> N;\n\n  const int maxh = GetMaxH();\n  debug(maxh);\n\n  VI heights(N);\n\n  VI cur_ask{0};\n\n  int cur_span = 1;\n  while (cur_span * 2 <= maxh) { cur_span *= 2; }\n\n  while (cur_span >= 1) {\n    VI next_ask;\n    debug(cur_span, cur_ask);\n    for (bool odd : {false, true}) {\n      VI query(N);\n      VI which;\n      for (int x : cur_ask) {\n        if (!!(heights[x] & (cur_span * 2)) == odd) {\n          query[x] = cur_span;\n          which.PB(x);\n        }\n      }\n\n      auto fst_ans = Ask(query);\n      for (int x : which) {\n        query[x] = cur_span - 1;\n      }\n      auto snd_ans = Ask(query);\n      for (int x : which) { fst_ans[x] = snd_ans[x] = true; }\n\n      for (int i = 0; i < N; ++i) {\n        if (!!(heights[i] & (cur_span * 2)) == odd) {\n          if (!snd_ans[i]) { heights[i] += cur_span; }\n          if (fst_ans[i] && !snd_ans[i]) {\n            next_ask.PB(i);\n          }\n        }\n      }\n    }\n\n    cur_span /= 2;\n    for (int v : next_ask) { cur_ask.PB(v); }\n  }\n\n  debug(heights);\n\n  vector<PII> edges;\n\n  for (int rem = 0; rem < 3; ++rem) {\n    VI from, to;\n    for (int i = 0; i < N; ++i) {\n      if (heights[i] % 3 == rem) {\n        from.PB(i);\n      }\n      if (heights[i] % 3 == (rem + 1) % 3) {\n        to.PB(i);\n      }\n    }\n\n    const int S = SZ(from);\n    const int T = SZ(to);\n    vector<int> to_mapping(T);\n\n    debug(from, to);\n\n    for (int b = 1; b < S; b *= 2) {\n      debug(b);\n      vector<int> query(N);\n      for (int i = 0; i < S; ++i) {\n        if (i & b) { query[from[i]] = 1; }\n      }\n      auto ans = Ask(query);\n      for (int i = 0; i < T; ++i) {\n        if (ans[to[i]]) { to_mapping[i] += b; }\n      }\n    }\n\n    for (int i = 0; i < T; ++i) {\n      if (to[i] == 0) { continue; }\n      edges.emplace_back(from[to_mapping[i]], to[i]);\n    }\n  }\n\n  Answer(edges);\n\n}\n\n"], "input": "", "output": "", "tags": ["binary search", "interactive", "math", "trees"], "dificulty": "3400", "interactive": false}