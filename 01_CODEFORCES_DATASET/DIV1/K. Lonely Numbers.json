{"link": "https://codeforces.com//contest/1423/problem/K", "problemId": "749091", "problem_idx": "K", "shortId": "1423K", "contest_number": "1423", "problem_submissions": {"J": [95462948, 95462931, 95462795, 95462776, 95462759, 95462752, 95462749, 95445856, 95445842, 95445741, 95445735, 95445720, 95436077, 95435983, 94779119, 94773285, 94770663, 94778562], "C": [94789081], "I": [94786050], "F": [94784528, 94776365, 94779778, 94781062], "H": [94781814, 94783650, 94777878, 94784871], "L": [94780014, 94780685, 94786643, 94773659], "B": [94771096, 94770153, 94772426, 94771466], "K": [94770723, 94771588, 94773427, 94774938], "A": [], "D": [], "E": [], "G": []}, "name": "K. Lonely Numbers", "statement": "In number world, two different numbers are friends if they have a lot in\r\ncommon, but also each one has unique perks.More precisely, two different\r\nnumbers a and b are friends if gcd(a,b),\r\nfrac{a}{gcd(a,b)},\r\nfrac{b}{gcd(a,b)} can form sides of a triangle.Three numbers a, b and c\r\ncan form sides of a triangle if a + b > c, b + c > a and c + a > b.In a\r\ngroup of numbers, a number is lonely if it doesn\u2019t have any friends in\r\nthat group.Given a group of numbers containing all numbers from 1, 2, 3,\r\n..., n, how many numbers in that group are lonely?\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 05.10.2020 16:17:35       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 123;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nnamespace factorizer {\n\ntemplate <typename T>\nstruct FactorizerVarMod { static T value; };\ntemplate <typename T>\nT FactorizerVarMod<T>::value;\n\ntemplate <typename T>\nbool IsPrime(T n, const vector<T>& bases) {\n  if (n < 2) {\n    return false;\n  }\n  vector<T> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n  for (const T& x : small_primes) {\n    if (n % x == 0) {\n      return n == x;\n    }\n  }\n  if (n < 31 * 31) {\n    return true;\n  }\n  int s = 0;\n  T d = n - 1;\n  while ((d & 1) == 0) {\n    d >>= 1;\n    s++;\n  }\n  FactorizerVarMod<T>::value = n;\n  for (const T& a : bases) {\n    if (a % n == 0) {\n      continue;\n    }\n    Modular<FactorizerVarMod<T>> cur = a;\n    cur = power(cur, d);\n    if (cur == 1) {\n      continue;\n    }\n    bool witness = true;\n    for (int r = 0; r < s; r++) {\n      if (cur == n - 1) {\n        witness = false;\n        break;\n      }\n      cur *= cur;\n    }\n    if (witness) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool IsPrime(int64_t n) {\n  return IsPrime(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n}\n\nbool IsPrime(int32_t n) {\n  return IsPrime(n, {2, 7, 61});\n}\n\n// but if you really need uint64_t version...\n/*\nbool IsPrime(uint64_t n) {\n  if (n < 2) {\n    return false;\n  }\n  vector<uint32_t> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n  for (uint32_t x : small_primes) {\n    if (n == x) {\n      return true;\n    }\n    if (n % x == 0) {\n      return false;\n    }\n  }\n  if (n < 31 * 31) {\n    return true;\n  }\n  uint32_t s = __builtin_ctzll(n - 1);\n  uint64_t d = (n - 1) >> s;\n  function<bool(uint64_t)> witness = [&n, &s, &d](uint64_t a) {\n    uint64_t cur = 1, p = d;\n    while (p > 0) {\n      if (p & 1) {\n        cur = (__uint128_t) cur * a % n;\n      }\n      a = (__uint128_t) a * a % n;\n      p >>= 1;\n    }\n    if (cur == 1) {\n      return false;\n    }\n    for (uint32_t r = 0; r < s; r++) {\n      if (cur == n - 1) {\n        return false;\n      }\n      cur = (__uint128_t) cur * cur % n;\n    }\n    return true;\n  };\n  vector<uint64_t> bases_64bit = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n  for (uint64_t a : bases_64bit) {\n    if (a % n == 0) {\n      return true;\n    }\n    if (witness(a)) {\n      return false;\n    }\n  }\n  return true;\n}\n*/\n\nvector<int> least = {0, 1};\nvector<int> primes;\nint precalculated = 1;\n\nvoid RunLinearSieve(int n) {\n  n = max(n, 1);\n  least.assign(n + 1, 0);\n  primes.clear();\n  for (int i = 2; i <= n; i++) {\n    if (least[i] == 0) {\n      least[i] = i;\n      primes.push_back(i);\n    }\n    for (int x : primes) {\n      if (x > least[i] || i * x > n) {\n        break;\n      }\n      least[i * x] = x;\n    }\n  }\n  precalculated = n;\n}\n\nvoid RunSlowSieve(int n) {\n  n = max(n, 1);\n  least.assign(n + 1, 0);\n  for (int i = 2; i * i <= n; i++) {\n    if (least[i] == 0) {\n      for (int j = i * i; j <= n; j += i) {\n        if (least[j] == 0) {\n          least[j] = i;\n        }\n      }\n    }\n  }\n  primes.clear();\n  for (int i = 2; i <= n; i++) {\n    if (least[i] == 0) {\n      least[i] = i;\n      primes.push_back(i);\n    }\n  }\n  precalculated = n;\n}\n\nvoid RunSieve(int n) {\n  RunLinearSieve(n);\n}\n\ntemplate <typename T>\nvector<pair<T, int>> MergeFactors(const vector<pair<T, int>>& a, const vector<pair<T, int>>& b) {\n  vector<pair<T, int>> c;\n  int i = 0;\n  int j = 0;\n  while (i < (int) a.size() || j < (int) b.size()) {\n    if (i < (int) a.size() && j < (int) b.size() && a[i].first == b[j].first) {\n      c.emplace_back(a[i].first, a[i].second + b[j].second);\n      ++i;\n      ++j;\n      continue;\n    }\n    if (j == (int) b.size() || (i < (int) a.size() && a[i].first < b[j].first)) {\n      c.push_back(a[i++]);\n    } else {\n      c.push_back(b[j++]);\n    }\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<pair<T, int>> RhoC(const T& n, const T& c) {\n  if (n <= 1) {\n    return {};\n  }\n  if ((n & 1) == 0) {\n    return MergeFactors({{2, 1}}, RhoC(n / 2, c));\n  }\n  if (IsPrime(n)) {\n    return {{n, 1}};\n  }\n  FactorizerVarMod<T>::value = n;\n  Modular<FactorizerVarMod<T>> x = 2;\n  Modular<FactorizerVarMod<T>> saved = 2;\n  T power = 1;\n  T lam = 1;\n  while (true) {\n    x = x * x + c;\n    T g = __gcd((x - saved)(), n);\n    if (g != 1) {\n      return MergeFactors(RhoC(g, c + 1), RhoC(n / g, c + 1));\n    }\n    if (power == lam) {\n      saved = x;\n      power <<= 1;\n      lam = 0;\n    }\n    lam++;\n  }\n  return {};\n}\n\ntemplate <typename T>\nvector<pair<T, int>> Rho(const T& n) {\n  return RhoC(n, static_cast<T>(1));\n}\n\ntemplate <typename T>\nvector<pair<T, int>> Factorize(T x) {\n  if (x <= 1) {\n    return {};\n  }\n  if (x <= precalculated) {\n    vector<pair<T, int>> ret;\n    while (x > 1) {\n      if (!ret.empty() && ret.back().first == least[x]) {\n        ret.back().second++;\n      } else {\n        ret.emplace_back(least[x], 1);\n      }\n      x /= least[x];\n    }\n    return ret;\n  }\n  if (x <= static_cast<int64_t>(precalculated) * precalculated) {\n    vector<pair<T, int>> ret;\n    if (!IsPrime(x)) {\n      for (T i : primes) {\n        T t = x / i;\n        if (i > t) {\n          break;\n        }\n        if (x == t * i) {\n          int cnt = 0;\n          while (x % i == 0) {\n            x /= i;\n            cnt++;\n          }\n          ret.emplace_back(i, cnt);\n          if (IsPrime(x)) {\n            break;\n          }\n        }\n      }\n    }\n    if (x > 1) {\n      ret.emplace_back(x, 1);\n    }\n    return ret;\n  }\n  return Rho(x);\n}\n\ntemplate <typename T>\nvector<T> BuildDivisorsFromFactors(const vector<pair<T, int>>& factors) {\n  vector<T> divisors = {1};\n  for (auto& p : factors) {\n    int sz = (int) divisors.size();\n    for (int i = 0; i < sz; i++) {\n      T cur = divisors[i];\n      for (int j = 0; j < p.second; j++) {\n        cur *= p.first;\n        divisors.push_back(cur);\n      }\n    }\n  }\n  sort(divisors.begin(), divisors.end());\n  return divisors;\n}\n\n}  // namespace factorizer\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = 1000010;\n  factorizer::RunSieve(N);\n  vector<int> pref(N);\n  for (int i = 1; i < N; i++) {\n    pref[i] = pref[i - 1] + (factorizer::least[i] == i);\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    int x = (int) ceil(sqrt(n + 1));\n    int ans = pref[n] - pref[x - 1] + 1;\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "math", "number theory", "two pointers"], "dificulty": "1600", "interactive": false}