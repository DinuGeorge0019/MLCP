{
    "link": "https://codeforces.com//contest/1827/problem/C",
    "problemId": "1922412",
    "problem_idx": "C",
    "shortId": "1827C",
    "contest_number": "1827",
    "problem_submissions": {
        "B1": [
            205909125,
            205871229,
            205860094,
            205853484,
            205858214,
            205884799,
            205855785,
            205857268,
            205859721,
            205854125,
            205853990,
            205854393,
            205857685,
            205856108,
            205871852,
            205864517,
            205849753,
            205856355,
            206036248,
            205883111,
            205857458,
            205852308
        ],
        "C": [
            205887704,
            205865086,
            205862189,
            205877784,
            205865401,
            205880693,
            205873972,
            205883370,
            205896807,
            205874900,
            205883582,
            205869590,
            205872529,
            205865317,
            205875560,
            205870203,
            205870915,
            206036332,
            205857923,
            205878002,
            205869836
        ],
        "E": [
            205882857,
            205890682,
            205893722,
            205893207,
            205891321,
            205895989,
            205901490,
            205897572,
            205894529,
            205889627,
            205900528,
            205921803,
            205921497,
            205921364,
            205921183,
            205920554,
            205920187,
            205928602,
            205907318,
            205907019,
            205906136,
            205905793,
            205905368,
            205905221,
            205903986
        ],
        "B2": [
            205871376,
            205860123,
            205854465,
            205857731,
            205884857,
            205854446,
            205857708,
            205859949,
            205855049,
            205892922,
            205864074,
            205856597,
            205855367,
            205871926,
            205864651,
            205863717,
            205856284,
            206036255,
            205889062,
            205869038,
            205876542
        ],
        "D": [
            205863885,
            205875931,
            205878262,
            205884073,
            205878863,
            205877520,
            205881913,
            205884050,
            205871773,
            205899731,
            205892557,
            205885814,
            205881313,
            205883473,
            205884864,
            205888365,
            205888201,
            206036361,
            205877449,
            205886393,
            205963414,
            205889611
        ],
        "A": [
            205845172,
            205844037,
            205843466,
            205843847,
            205844462,
            205843511,
            205844799,
            205845695,
            205844273,
            205843867,
            205845548,
            205843654,
            205843208,
            205846139,
            205845358,
            205843530,
            206036234,
            205846931,
            205848794,
            205843958
        ],
        "F": [
            207299235,
            207299224,
            207299166,
            207299023,
            207298779,
            207298502,
            207298128
        ]
    },
    "name": "C. Palindrome Partition",
    "statement": "A is a continuous and non-empty segment of letters from a given string,\r\nwithout any reorders.An is a string that reads the same backward as\r\nforward and has an even length. For example, strings \"\", \"\", \"\" are even\r\npalindromes, but strings \"\", \"\", \"\", \"\" are not.A is an even palindrome\r\nor a string that can be partitioned into some smaller even\r\npalindromes.You are given a string s, consisting of n lowercase Latin\r\nletters. Count the number of of s.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\narray<vi, 2> manacher(const string& s) {\n\tint n = sz(s);\n\tarray<vi,2> p = {vi(n+1), vi(n)};\n\trep(z,0,2) for (int i=0,l=0,r=0; i < n; i++) {\n\t\tint t = r-i+!z;\n\t\tif (i<r) p[z][i] = min(t, p[z][l+t]);\n\t\tint L = i-p[z][i], R = i+p[z][i]-!z;\n\t\twhile (L>=1 && R+1<n && s[L-1] == s[R+1])\n\t\t\tp[z][i]++, L--, R++;\n\t\tif (R>r) l=L, r=R;\n\t}\n\treturn p;\n}\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tstring S;\n\tcin >> S;\n\tvector<ll> dp(N+1, 1);\n\tauto z = manacher(S)[0];\n\tvector<vector<int >> ins(N+1);\n\tvector<vector<int> > del(N+1);\n\tmultiset<int> cur;\n\tfor(int i = 0; i <= N; i++){\n\t\tif(z[i]){\n\t\t\tins[i+1].push_back(-i);\n\t\t\tdel[i+z[i]].push_back(-i);\n\t\t}\n\t}\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int x : ins[i]){\n\t\t\tcur.insert(x);\n\t\t}\n\t\tif(!cur.empty()){\n\t\t\tint l = i + *cur.begin();\n\t\t\tdp[i] += dp[i - 2 * l];\n\t\t}\n\t\tfor(int x : del[i]){\n\t\t\tcur.erase(cur.find(x));\n\t\t}\n\t}\n\tll ans = accumulate(dp.begin(), dp.end(), ll(0)) - (N+1);\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "hashing",
        "strings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Palindrome Partition.json",
    "editorial_link": "https://codeforces.com//blog/entry/116109",
    "editorial": "Solution For the simplicity of the solution, we will abbreviate even\npalindrome as evp.Lemma: Consider a beautiful string , we can find the\nunique maximal partition for it by greedily choosing the smallest\npossible evp in each step from the left. Here maximal means maximum\nnumber of parts.Proof: Suppose is smallest prefix which is an evp and is\nthe first part in the partition of , here mean substring . We consider\ntwo cases: : In this case, it is clear that , and are evps, so we can\nreplace with them. : In this case, due to the fact that and are evps, is\nalso an evp, which contradicts to above assumption that is the smallest.\nWe can use dynamic programming to solve this problem. Let be the number\nof beautiful substrings starting at . For all from to , if there are\nsuch satisfying is the smallest evp beginning at , then , otherwise .\nThe answer will be the sum of from to .To calculate the array, first, we\nuse Manacher algorithm or hashing to find the maximum satisfying is an\nevp for each . Then for all , where is smallest position such that and .\nThe time complexity is .\n",
    "hint": [
        "Hint1 Try to construct beautiful string greedily.",
        "Hint2 What happens when we have two even palindromes share one of their endpoints?"
    ]
}