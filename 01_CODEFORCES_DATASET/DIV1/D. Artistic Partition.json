{
    "link": "https://codeforces.com//contest/1603/problem/D",
    "problemId": "1163972",
    "problem_idx": "D",
    "shortId": "1603D",
    "contest_number": "1603",
    "problem_submissions": {
        "D": [
            133678384,
            133698397,
            133689761,
            133665373,
            133663811,
            133667904,
            133870635,
            133666377,
            133712181,
            133672518,
            133669513,
            133671913,
            133674123,
            133668504,
            133670450,
            134053883,
            133670044
        ],
        "E": [
            133654251,
            133698597,
            133670917,
            133670921,
            133674718,
            133678832,
            133691448,
            133677480,
            133745184,
            133682168,
            158346606
        ],
        "C": [
            133634336,
            133654076,
            133641887,
            133643661,
            133700965,
            133639890,
            133639559,
            133648557,
            133635180,
            133642566,
            133633281,
            133658219,
            133645221,
            133638128,
            133655485,
            133647398,
            133646553,
            133645458,
            133645891,
            133650269,
            134161088,
            133646180
        ],
        "B": [
            133625504,
            133622630,
            133627460,
            133627705,
            133633891,
            133623525,
            133628792,
            133627917,
            133622898,
            133644787,
            133630406,
            133626809,
            133635643,
            133632995,
            133629432,
            133625758,
            133629935,
            133631448,
            134161095,
            133621172
        ],
        "A": [
            133616996,
            133617371,
            133618050,
            133618145,
            133618661,
            133618290,
            133617671,
            133620309,
            133617150,
            133619091,
            133618690,
            133618619,
            133622033,
            133621990,
            133618626,
            133617653,
            133618140,
            133620543,
            134161100,
            133617177
        ],
        "F": [
            133669341,
            133700346,
            133679782,
            133709673,
            133694728,
            133720215,
            133975676,
            134484874,
            158277914
        ]
    },
    "name": "D. Artistic Partition",
    "statement": "For two positive integers l and r (l\r\nle r) let c(l, r) denote the number of integer pairs (i, j) such that l\r\nle i\r\nle j\r\nle r and\r\noperatorname{gcd}(i, j)\r\nge l. Here,\r\noperatorname{gcd}(i, j) is the greatest common divisor (GCD) of integers\r\ni and j.YouKn0wWho has two integers n and k where 1\r\nle k\r\nle n. Let f(n, k) denote the minimum of\r\nsum\r\nlimits_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1\r\nlt x_2\r\nlt\r\nldots\r\nlt x_{k}\r\nlt x_{k+1}=n.Help YouKn0wWho find f(n, k).\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.10.2021 18:42:22       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nstatic struct FastInput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t chars_read = 0;\n  size_t buf_pos = 0;\n  FILE *in = stdin;\n  char cur = 0;\n\n  inline char get_char() {\n    if (buf_pos >= chars_read) {\n      chars_read = fread(buf, 1, BUF_SIZE, in);\n      buf_pos = 0;\n      buf[0] = (chars_read == 0 ? -1 : buf[0]);\n    }\n    return cur = buf[buf_pos++];\n  }\n \n  inline void tie(int) {}\n\n  inline explicit operator bool() {\n    return cur != -1;\n  }\n\n  inline static bool is_blank(char c) {\n    return c <= ' ';\n  }\n\n  inline bool skip_blanks() {\n    while (is_blank(cur) && cur != -1) {\n      get_char();\n    }\n    return cur != -1;\n  }\n \n  inline FastInput& operator>>(char& c) {\n    skip_blanks();\n    c = cur;\n    return *this;\n  }\n  \n  inline FastInput& operator>>(string& s) {\n    if (skip_blanks()) {\n      s.clear();\n      do {\n        s += cur;\n      } while (!is_blank(get_char()));\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline FastInput& read_integer(T& n) {\n    // unsafe, doesn't check that characters are actually digits\n    n = 0;\n    if (skip_blanks()) {\n      int sign = +1;\n      if (cur == '-') {\n        sign = -1;\n        get_char();\n      }\n      do {\n        n += n + (n << 3) + cur - '0';\n      } while (!is_blank(get_char()));\n      n *= sign;\n    }\n    return *this;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {\n    return read_integer(n);\n  }\n  \n  #if !defined(_WIN32) || defined(_WIN64)\n  inline FastInput& operator>>(__int128& n) {\n    return read_integer(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {\n    // not sure if really fast, for compatibility only\n    n = 0;\n    if (skip_blanks()) {\n      string s;\n      (*this) >> s;\n      sscanf(s.c_str(), \"%lf\", &n);\n    }\n    return *this;\n  }\n} fast_input;\n\n#define cin fast_input\n\nstatic struct FastOutput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t buf_pos = 0;\n  static constexpr int TMP_SIZE = 1 << 20;\n  char tmp[TMP_SIZE];\n  FILE *out = stdout;\n\n  inline void put_char(char c) {\n    buf[buf_pos++] = c;\n    if (buf_pos == BUF_SIZE) {\n      fwrite(buf, 1, buf_pos, out);\n      buf_pos = 0;\n    }\n  }\n\n  ~FastOutput() {\n    fwrite(buf, 1, buf_pos, out);\n  }\n\n  inline FastOutput& operator<<(char c) {\n    put_char(c);\n    return *this;\n  }\n\n  inline FastOutput& operator<<(const char* s) {\n    while (*s) {\n      put_char(*s++);\n    }\n    return *this;\n  }\n \n  inline FastOutput& operator<<(const string& s) {\n    for (int i = 0; i < (int) s.size(); i++) {\n      put_char(s[i]);\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline char* integer_to_string(T n) {\n    // beware of TMP_SIZE\n    char* p = tmp + TMP_SIZE - 1;\n    if (n == 0) {\n      *--p = '0';\n    } else {\n      bool is_negative = false;\n      if (n < 0) {\n        is_negative = true;\n        n = -n;\n      }\n      while (n > 0) {\n        *--p = (char) ('0' + n % 10);\n        n /= 10;\n      }\n      if (is_negative) {\n        *--p = '-';\n      }\n    }\n    return p;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, char*>::type stringify(T n) {\n    return integer_to_string(n);\n  }\n\n  #if !defined(_WIN32) || defined(_WIN64)\n  inline char* stringify(__int128 n) {\n    return integer_to_string(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, char*>::type stringify(T n) {\n    sprintf(tmp, \"%.17f\", n);\n    return tmp;\n  }\n\n  template <typename T>\n  inline FastOutput& operator<<(const T& n) {\n    auto p = stringify(n);\n    for (; *p != 0; p++) {\n      put_char(*p);\n    }\n    return *this;\n  }\n} fast_output;\n\n#define cout fast_output\n\nconst long long inf = (long long) 1e12;\n\nclass segtree {\n public:\n  struct node {\n    long long mn = 0;\n    long long add = 0;\n\n    void apply(int l, int r, long long v) {\n      mn += v;\n      add += v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mn = min(a.mn, b.mn);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add);\n      tree[z].apply(y + 1, r, tree[x].add);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int N = (int) 1e5;\n  const int K = 16;\n  vector<int> phi(N + 1);\n  iota(phi.begin(), phi.end(), 0);\n  for (int i = 1; i <= N; i++) {\n    for (int j = i + i; j <= N; j += i) {\n      phi[j] -= phi[i];\n    }\n  }\n  vector<vector<int>> divs(N + 1);\n  for (int i = 1; i <= N; i++) {\n    for (int j = i; j <= N; j += i) {\n      divs[j].push_back(i);\n    }\n  }\n  vector<vector<long long>> res(K + 1, vector<long long>(N + 1, inf));\n  res[0][0] = 0;\n  for (int k = 1; k <= K; k++) {\n    segtree st(res[k - 1]);\n    for (int i = 1; i <= N; i++) {\n      for (int j : divs[i]) {\n        st.modify(0, j - 1, phi[i / j]);\n      }\n      res[k][i] = st.get(0, N).mn;\n    }\n  }\n  debug(clock());\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    if (k > K) {\n      cout << n << '\\n';\n    } else {\n      cout << res[k][n] << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "dp",
        "number theory"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Artistic Partition.json",
    "editorial_link": "https://codeforces.com//blog/entry/96460",
    "editorial": "For now, let denote the number of integer pairs such that (instead of )\r\nand . So we can add to in the end.We can construct a straightforward dp\r\nwhere . As a straightforward implementation of takes time, the total\r\ncomplexity of finding will be which is quite shameful.Let\u00e2\u0080\u0099s see how to\r\ndo better. . It\u00e2\u0080\u0099s easy to see why it holds. when . Let . Following the\r\ntiny observation, we can split the numbers as without spending a single\r\npenny.Now we can solve in which is still shameful.So we just have to\r\nfind for and .Let\u00e2\u0080\u0099s optimize the calculation for . Here, . We can\r\ncalculate for all in and calculate in . So currently we can solve our\r\nproblem in which is still not to be proud of.But notice that there can\r\nbe at most distinct values in the sequence . Check this for a proof. So\r\nwe can calculate in which improves our solution to .But notice that as\r\nwe can precalculate the suffix sums for each to over all distinct values\r\nof and then calculate in . This preprocessing will take time and memory.\r\nThat means we can solve our problem which is promising. satisfies\r\nquadrangle inequality, that is for . Let . Here, But clearly as . So\r\n.You can learn more about quadrangle inequality and how it is useful\r\nfrom here. because I won\u00e2\u0080\u0099t describe why it helps us here.This suggests\r\nthat we can solve this problem using Divide and Conquer DP or 1D1D DP\r\nwhich will optimize our part to .To solve for multiple queries we can\r\njust precalculate for and . Overall complexity: where .This problem can\r\nalso be solved using Divide and Conquer DP and by calculating in in each\r\nlevel which runs pretty fast in practice (for , it takes less than 3s)\r\nbut I don\u00e2\u0080\u0099t have a rigorous upper bound on the time complexity. Check\r\nout my solution for more clarity.\r\n"
}