{
    "link": "https://codeforces.com//contest/587/problem/F",
    "problemId": "38263",
    "problem_idx": "F",
    "shortId": "587F",
    "contest_number": "587",
    "problem_submissions": {
        "B": [
            13648546,
            13631319,
            13641731,
            13630364,
            13633855,
            13635275,
            13633091,
            13631092,
            13632489,
            13636118,
            13634961,
            13633410,
            13637437,
            13631295,
            13631061,
            13631176,
            13632360,
            13636955,
            13631513,
            13651693
        ],
        "F": [
            13647165,
            15306413,
            17349765,
            13654656
        ],
        "E": [
            13635518,
            13645026,
            13634711,
            13645375,
            13645998,
            13646627,
            13648041,
            13649025,
            13654642,
            13649552,
            13647771,
            13647562,
            13649838,
            13647318,
            13650802,
            13654796,
            13653392,
            13655928
        ],
        "A": [
            13627098,
            13626726,
            13642310,
            13627311,
            13628719,
            13627650,
            13627049,
            13626772,
            13626754,
            13627918,
            13626713,
            13628042,
            13629897,
            13626736,
            13627142,
            13626620,
            13626815,
            13629767,
            13626766,
            13627175
        ],
        "C": [
            13638605,
            13644702,
            13638823,
            13638488,
            13639824,
            13640040,
            13637207,
            13636153,
            13640829,
            13642556,
            13639860,
            13642332,
            13636367,
            13653829,
            13637091,
            13635819,
            13636868,
            13633329,
            13636406,
            13632991
        ],
        "D": [
            16774884,
            14175098,
            13654446,
            13648717
        ]
    },
    "name": "F. Duff is Mad",
    "statement": "Duff is mad at her friends. That\u2019s why she sometimes makes Malek to take\r\ncandy from one of her friends for no reason! She has friends. Her -th\r\nfriend\u2019s name is (their names are not necessarily unique). times, she\r\nasks Malek to take candy from her friends. She\u2019s angry, but also she\r\nacts with rules. When she wants to ask Malek to take candy from one of\r\nher friends, like , she chooses two numbers and and tells Malek to take\r\nexactly candies from him/her, where is the number of occurrences of\r\nstring in .Malek is not able to calculate how many candies to take in\r\neach request from Duff. That\u2019s why she asked for your help. Please tell\r\nhim how many candies to take in each request.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << \"=\" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int ,int> PII;\ntypedef pair< int , PII> pii;\n\nconst int INF = ~0U>>1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n    int ret = 1;\n    for (; x; x >>= 1, a = 1ll * a * a % Mod)\n        if (x & 1) ret = 1ll * ret * a % Mod;\n    return ret; \n}\n\nconst int N=201000;\n\nint tot,rk[N*4],sa[N];\npair<PII,int> pos[N];\nchar s[N];\nint p[N];\nvoid init() {\n\tfor (int i=1;i<=tot;i++) rk[i]=p[i];\n\tfor (int j=0;j<19;j++) {\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tpos[i]=mp(mp(rk[i],rk[i+two(j)]),i);\n\t\tsort(pos+1,pos+tot+1);\n\t\tint cnt=0;\n\t\tfor (int i=1;i<=tot;i++) {\n\t\t\trk[pos[i].se]=cnt;\n\t\t\tcnt+=(pos[i].fi!=pos[i+1].fi);\n\t\t}\n\t\tif (cnt==tot) break;\n\t}\n\tfor (int i=1;i<=tot;i++) rk[i]++;\n\tfor (int i=1;i<=tot;i++) sa[rk[i]]=i;\n}\nint query(int l,int r,int c,int len) {\n\t++r; --l;\n\twhile (l+1<r) {\n\t\tint md=(l+r)>>1;\n\t\tif (p[sa[md]+len-1]>=c) r=md; else l=md;\n\t}\n\treturn r;\n}\n\nint n,q,l[N],r[N],c[N],ocr[N],sl[N],sr[N];\nint bigv[N],bigid[N],bigcnt;\nll ret[N],ans[N];\nvector<PII> ql[N],qr[N];\nvector<pair<PII,int> > Qr[N];\n\nvoid modify(int x,int s) { for (;x<=tot;x+=x&-x) c[x]+=s;}\nint query(int x) { int s=0; for (;x;x-=x&-x) s+=c[x]; return s;}\n\nconst int R=200;\nint main() {\n//\tfreopen(\"in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&q);\n\trep(i,1,n+1) {\n\t\tscanf(\"%s\",s);\n\t\tint len=strlen(s);\n\t\tl[i]=tot+1;\n\t\trep(j,0,len)\n\t\t\tp[++tot]=s[j]-'a'+1;\n\t\tp[++tot]=29+i;\n\t\tr[i]=tot;\n\t\tif (len>R) {\n\t\t\tbigid[i]=++bigcnt;\n\t\t\tbigv[bigcnt]=i;\n\t\t}\n\t}\n\tinit();\n\trep(i,1,n+1) {\n\t\tint pl=1,pr=tot;\n\t\trep(j,l[i],r[i]) {\n\t\t\tint ql=query(pl,pr,p[j],j-l[i]+1);\n\t\t\tint qr=query(pl,pr,p[j]+1,j-l[i]+1)-1;\n\t\t\tpl=ql;\n\t\t\tpr=qr;\n\t\t}\n\t\tsl[i]=pl,sr[i]=pr;\n\t}\n\n\trep(i,1,q+1) {\n\t\tint l,r,k;\n\t\tscanf(\"%d%d%d\",&l,&r,&k);\n\t\tif (bigid[k]) {\n\t\t\tQr[k].pb(mp(mp(l,r),i));\n\t\t} else {\n\t\t\tqr[r].pb(mp(k,i));\n\t\t\tqr[l-1].pb(mp(k,-i));\n\t\t}\n\t}\n\trep(i,1,bigcnt+1) {\n\t\tint v=bigv[i];\n\t\tfor (int j=1;j<=tot;j++) ocr[j]=0;\n\t\tfor (int j=l[v];j<r[v];j++) {\n\t\t\tocr[rk[j]]++;\n\t\t}\n\t\tfor (int j=1;j<=tot;j++) ocr[j]+=ocr[j-1];\n\t\tfor (int j=1;j<=n;j++) {\n\t\t\tret[j]=ret[j-1]+ocr[sr[j]]-ocr[sl[j]-1];\n\t\t}\n\t\tfor (auto que:Qr[v]) {\n\t\t\tint l=que.fi.fi,r=que.fi.se,id=que.se;\n\t\t\tans[id]=ret[r]-ret[l-1];\n\t\t}\n\t}\n\trep(i,1,n+1) {\n\t\tmodify(sl[i],1);\n\t\tmodify(sr[i]+1,-1);\n\t\tfor (auto p:qr[i]) {\n\t\t\tint id=p.se,w=1,v=p.fi;\n\t\t\tif (id<0) w=-1,id*=-1;\n\t\t\trep(j,l[v],r[v]) {\n\t\t\t\tans[id]+=w*query(rk[j]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,q+1) printf(\"%lld\\n\",ans[i]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "strings"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Duff is Mad.json",
    "editorial_link": "https://codeforces.com//blog/entry/20971",
    "editorial": "Use Aho-Corasick. Assume first of all we build the trie of our strings (function t). If t(v,?c)????-?1 it means that there is an edge in the trie outgoing from vertex v written c on it.\n\nSo, for building Aho-Corasick, consider f(v) = the vertex we go into, in case of failure (t(v,?c)?=??-?1). i.e the deepest vertex (u), that v???u and the path from root to u is a suffix of path from root to v. No we can build an automaton (Aho-Corasick), function g. For each i, do this (in the automaton):\n\ncur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g\nAssume cnt(v,?i) is the number of occurrences of number i in q[v]. Also, denote .\n\nBuild another tree. In this tree, for each i that is not root of the trie, let par[i]?=?f(i) (the vertex we go in the trie, in case of failure) and call it C-Tree.\n\nSo now, problem is on a tree. Operations are : Each query gives numbers l,?r,?k and you have to find the number ."
}