{
    "link": "https://codeforces.com//contest/1338/problem/C",
    "problemId": "590533",
    "problem_idx": "C",
    "shortId": "1338C",
    "contest_number": "1338",
    "problem_submissions": {
        "E": [
            76397300,
            76619327,
            76403815,
            76434529,
            76434479,
            76434133,
            76434078,
            76433920,
            76433813,
            76433749,
            76433522,
            76432895,
            76432405,
            76433003,
            76432715,
            76492191,
            76458850,
            77714923,
            76416304,
            78374239,
            105958584
        ],
        "D": [
            76383105,
            76378423,
            76373799,
            76372283,
            76380290,
            76721483,
            76721183,
            76718097,
            76716953,
            76379002,
            76377538,
            76378427,
            76454507,
            76377531,
            76381613,
            76384929,
            76380304,
            76384800,
            76387623,
            76383511,
            76383924,
            76389002,
            76385003,
            76379777,
            76361072
        ],
        "C": [
            76355433,
            76365439,
            76355356,
            76357185,
            76342857,
            77464916,
            77464536,
            76797866,
            76793425,
            76363706,
            76354913,
            76352467,
            76454469,
            76364453,
            76361606,
            76365484,
            76367936,
            76362206,
            76361479,
            76370442,
            76369319,
            76368001,
            76372720,
            76355615,
            76385066
        ],
        "B": [
            76346805,
            76342391,
            76342822,
            76343816,
            76355163,
            77465740,
            76793469,
            76348894,
            76346501,
            76359563,
            76454438,
            76345410,
            76341218,
            76346125,
            76349446,
            76346871,
            76343626,
            76346043,
            76350035,
            76345138,
            76349598,
            76348838,
            76367005
        ],
        "A": [
            76334223,
            76335060,
            76334379,
            76334482,
            76348815,
            76334952,
            76364133,
            76339027,
            76454272,
            76334304,
            76334154,
            76336649,
            76334438,
            76334441,
            76334773,
            76334264,
            76337258,
            76335486,
            76337735,
            76341537,
            76369906
        ]
    },
    "name": "C. Perfect Triples",
    "statement": "Consider the infinite sequence s of positive integers, created by\r\nrepeating the following steps: Find the lexicographically smallest\r\ntriple of positive integers (a, b, c) such that a\r\noplus b\r\noplus c = 0, where\r\noplus denotes the bitwise XOR operation. a, b, c are not in s. Here\r\ntriple of integers (a_1, b_1, c_1) is considered to be lexicographically\r\nsmaller than triple (a_2, b_2, c_2) if sequence [a_1, b_1, c_1] is\r\nlexicographically smaller than sequence [a_2, b_2, c_2]. Append a, b, c\r\nto s in this order. Go back to the first step. You have integer n. Find\r\nthe n-th element of s.You have to answer t independent test cases.A\r\nsequence a is lexicographically smaller than a sequence b if in the\r\nfirst position where a and b differ, the sequence a has a smaller\r\nelement than the corresponding element in b.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 12.04.2020 17:26:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\npair<long long, long long> Get(int bit, long long idx) {\n  if (bit == 0) {\n    return make_pair(1, 2);\n  }\n  long long some = 1LL << (bit - 2);\n  auto q = Get(bit - 2, idx % some);\n  q.first ^= (1LL << (bit - 2));\n  q.second ^= (1LL << (bit - 1));\n  long long cs = idx / some;\n  if (cs == 1) {\n    q.first ^= (1LL << (bit - 2));\n    q.second ^= (1LL << (bit - 1));\n  }\n  if (cs == 2) {\n    q.first ^= (1LL << (bit - 1));\n    q.second ^= (1LL << (bit - 1)) ^ (1LL << (bit - 2));\n  }\n  if (cs == 3) {\n    q.first ^= (1LL << (bit - 1)) ^ (1LL << (bit - 2));\n    q.second ^= (1LL << (bit - 2));\n  }\n  q.first ^= 1LL << bit;\n  q.second ^= 1LL << (bit + 1);\n  return q;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long n;\n    cin >> n;\n    long long idx = (n - 1) / 3;\n    long long pos = (n - 1) % 3;\n    for (int bit = 0; ; bit += 2) {\n      long long here = 1LL << bit;\n      if (idx < here) {\n        auto p = Get(bit, idx);\n        cout << (pos == 0 ? p.first : (pos == 1 ? p.second : (p.first ^ p.second))) << '\\n';\n        break;\n      }\n      idx -= here;\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "divide and conquer",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Perfect Triples.json",
    "editorial_link": "https://codeforces.com//blog/entry/75913",
    "editorial": "Let\u00e2\u0080\u0099s try mathematical induction.First, suppose you have fully used\r\nnumbers only between and inclusive. Now we are going to use all numbers\r\nbetween and inclusive by following methods. Following picture is\r\ndescription of , and in bitwise manner; First row means we have already\r\nused all numbers until . Other rows mean , and . Keep in mind that , ,\r\nand are the lexicographically smallest triple, so and should be\r\nsatisfied at the same time.. , , , , . Otherwise, condition won\u00e2\u0080\u0099t be\r\nsatisfied, because top two digits of , , are either , , and .Then we\r\nhave more freedom in lower digits, because since the highest digits are\r\nall different, then we can fill lower digits of three numbers\r\nindependently. Now look at picture below; This table shows you how to\r\nfill each digits of , and . . For each digits, , and should have form\r\nlike this. Of course, you can use mathematical induction again here; Try\r\nto prove this in only digits at the first, then expand this lemma to\r\ndigits, digits, ..., digits.Now you know the pattern of digits of , ,\r\nand . Apply this pattern for each test case. Time complexity is .\r\n"
}