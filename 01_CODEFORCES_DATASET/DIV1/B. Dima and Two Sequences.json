{"link": "https://codeforces.com//contest/273/problem/B", "problemId": "2628", "problem_idx": "B", "shortId": "273B", "contest_number": "273", "problem_submissions": {"E": [3122057, 3120720, 3116725, 3122040, 3119368, 3121838, 3121574, 3121579, 3125606, 3120011], "D": [3119497, 3117520, 3123565, 3124849, 3121281, 3120768, 3117933, 3118228, 3123569, 3119311, 3122877, 3126278], "C": [3115563, 3119236, 3114688, 3117048, 3114860, 3116598, 3116734, 3117277, 3123467, 3122916, 3115814, 3123127, 3120446, 3126351], "B": [3113600, 3113886, 3112899, 3112808, 3114287, 3114846, 3113647, 3114818, 3114980, 3115379, 3114362, 3114126, 3114530, 3115262, 3115087, 3115234, 3115233], "A": [3112248, 3112373, 3112176, 3115660, 3112665, 3115057, 3112184, 3113078, 3122087, 3114179, 3112232, 3112611, 3112527, 3114570, 3113385, 3113821, 3112715]}, "name": "B. Dima and Two Sequences", "statement": "Little Dima has two sequences of points with integer coordinates:\r\nsequence and sequence .Now Dima wants to count the number of distinct\r\nsequences of points of length that can be assembled from these\r\nsequences, such that the -coordinates of points in the assembled\r\nsequence will . Help him with that. Note that each element of the\r\ninitial sequences should be used exactly once in the assembled\r\nsequence.Dima considers two assembled sequences and distinct, if there\r\nis such , that .As the answer can be rather large, print the remainder\r\nfrom dividing the answer by number .\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define SZ(c) ((int)(c).size())\n\nvector<pair<int, int> > a;\nint main(void) {\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=0;i<n;i++) {\n        int x; scanf(\"%d\", &x);\n        a.push_back(make_pair(x, i+1));\n    }\n    for(int i=0;i<n;i++) {\n        int x; scanf(\"%d\", &x);\n        a.push_back(make_pair(x, i+1));\n    }\n    int MOD;\n    scanf(\"%d\", &MOD);\n    sort(a.begin(), a.end());\n    int ans=1;\n    for(int i=0,j=0;i<n*2;i=j) {\n        while(j<n*2 && a[j].first == a[i].first) j++;\n        int v=0, m=j-i, q=1;\n        for(int k=i+1;k<j;k++) if(a[k].second == a[k-1].second) ++v;\n        for(int k=1;k<=m;k++) {\n            int s=k; while(v>0 && s%2==0) s/=2,v--;\n            q=q*1LL*s%MOD;\n        }\n        ans=ans*1LL*q%MOD;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics"], "dificulty": "1600", "interactive": false}