{"link": "https://codeforces.com//contest/840/problem/B", "problemId": "118957", "problem_idx": "B", "shortId": "840B", "contest_number": "840", "problem_submissions": {"E": [29579983, 29579804, 29577664, 29579379, 30931404, 29639075, 29617435, 29681440, 29681407, 29681392, 29681366], "D": [29572451, 29573549, 29574893, 29644417, 29644402, 29595162, 29575013, 29575646, 29572436, 29576887, 29575628, 29572554, 29567189, 29575551, 29574764, 29578191, 29654756, 29591307, 29590747, 29590681, 29590673, 29590627, 29571509, 29577552, 29578628, 29580062], "C": [29567872, 29569558, 29567683, 29569063, 29562508, 29569694, 29567877, 29577113, 29566790, 29572424, 29577847, 29579952, 29584687, 29571506, 29571448, 29570686, 29578919, 29571629, 29571512, 29569311], "B": [29561393, 29563952, 29561789, 29563624, 29569083, 29562635, 29573313, 29563716, 29576058, 29565857, 29562483, 29571100, 29573859, 29577034, 29563154, 29568606, 29568725, 29563595, 29562462], "A": [29557063, 29560856, 29557654, 29557167, 29564205, 29559452, 29556856, 29560188, 29575932, 29562655, 29557325, 29559317, 29562250, 29559768, 29556972, 29558958, 29556622, 29557880, 29558266]}, "name": "B. Leha and another game about graph", "statement": "Leha plays a computer game, where is on each level is given a connected\r\ngraph with vertices and edges. Graph can contain multiple edges, but can\r\nnot contain self loops. Each vertex has an integer , which can be equal\r\nto , or . To pass the level, he needs to find a good subset of edges of\r\nthe graph or say, that it doesn\u2019t exist. Subset is called good , if by\r\nby leaving only edges from this subset in the original graph, we obtain\r\nthe following: for every vertex i, = - 1 or it\u2019s degree modulo 2 is\r\nequal to . Leha wants to pass the game as soon as possible and ask you\r\nto help him. In case of multiple correct answers, print any of them.\r\n", "solutions": ["#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nstruct UnionFind {\n\tvector<int> data;\n\tvoid init(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n};\n\nvector<int> t_parent;\nvector<int> t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile (!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor (int j = (int)g[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = g[i][j];\n\t\t\tif (t_parent[c] == -1 && c != root) {\n\t\t\t\tt_parent[c] = i;\n\t\t\t\tstk.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n; int m;\n\twhile (~scanf(\"%d%d\", &n, &m)) {\n\t\tvector<int> d(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d\", &d[i]);\n\t\tvector<pair<int, int> > edges(m);\n\t\tmap<pii, int> eindex;\n\t\tfor (int i = 0; i < m; ++ i) {\n\t\t\tint u; int v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tedges[i] = { u,v };\n\t\t\teindex[minmax(u, v)] = i;\n\t\t}\n\t\tint arb = -1;\n\t\tvector<int> odd;\n\t\trep(i, n) {\n\t\t\tif (d[i] == -1 && arb == -1)\n\t\t\t\tarb = i;\n\t\t\tif (d[i] == 1)\n\t\t\t\todd.push_back(i);\n\t\t}\n\t\tif (odd.size() % 2 != 0) {\n\t\t\tif (arb == -1) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[arb] = 1;\n\t\t\todd.push_back(arb);\n\t\t}\n\t\tvector<vi> g(n);\n\t\tUnionFind uf; uf.init(n);\n\t\tfor (auto e : edges) if (uf.unionSet(e.first, e.second)) {\n\t\t\tg[e.first].push_back(e.second);\n\t\t\tg[e.second].push_back(e.first);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tvector<int> add(n);\n\t\trep(k, odd.size() / 2) {\n\t\t\tint a = odd[k * 2], b = odd[k * 2 + 1];\n\t\t\tadd[a] ^= 1;\n\t\t\tadd[b] ^= 1;\n\t\t}\n\t\tvector<int> sum(add.begin(), add.end());\n\t\tfor (int ix = (int)t_ord.size() - 1; ix > 0; -- ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tsum[p] ^= sum[i];\n\t\t}\n\t\tvi ans;\n\t\treu(i, 1, n) if (sum[i] % 2 != 0) {\n\t\t\tans.push_back(eindex[minmax(t_parent[i], i)]);\n\t\t}\n\t\tprintf(\"%d\\n\", (int)ans.size());\n\t\tfor (int i = 0; i < (int)ans.size(); ++ i) {\n\t\t\tif (i != 0) putchar(' ');\n\t\t\tprintf(\"%d\", ans[i] + 1);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "dfs and similar", "dp", "graphs"], "dificulty": "2100", "interactive": false}