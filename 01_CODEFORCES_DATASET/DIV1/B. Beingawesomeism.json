{
    "link": "https://codeforces.com//contest/1280/problem/B",
    "problemId": "495761",
    "problem_idx": "B",
    "shortId": "1280B",
    "contest_number": "1280",
    "problem_submissions": {
        "E": [
            66917544,
            66918710,
            66922267,
            66921342,
            66922263,
            66926965,
            66926660,
            66927067,
            66925334,
            66928850,
            66995264,
            66984642,
            66984352,
            66984306,
            66929552,
            66927288,
            66928819,
            66918756,
            67988551,
            66935139,
            67027185,
            66930594
        ],
        "D": [
            66910755,
            66913056,
            66911496,
            66913696,
            66913107,
            66913708,
            66913839,
            66916865,
            66916639,
            66915491,
            66986758,
            66986656,
            66986610,
            66986506,
            66986162,
            66985974,
            66985915,
            66985866,
            66985681,
            66985603,
            66985529,
            66917639,
            66918143,
            66919046,
            66912800,
            66915483,
            66915027,
            67988467,
            66920051,
            66917432,
            66918759,
            66917692
        ],
        "C": [
            66906002,
            66909093,
            66907333,
            66908961,
            66908129,
            66909339,
            66908240,
            66909052,
            66911854,
            66908829,
            66908393,
            66909027,
            66913164,
            66908797,
            66903678,
            66908260,
            67988454,
            66908965,
            66910137,
            66910802,
            66910959
        ],
        "B": [
            66904540,
            66906897,
            66902891,
            66906439,
            66906232,
            66906362,
            66905756,
            66906434,
            66909740,
            66905894,
            66905319,
            66906149,
            66910474,
            66930936,
            66909557,
            66906748,
            67988445,
            66907466,
            66906183,
            66908402,
            66907579
        ],
        "A": [
            66901496,
            66903238,
            66905004,
            66902693,
            66904062,
            66902839,
            66902110,
            66903240,
            66903755,
            66903072,
            66902272,
            66903347,
            66905647,
            66902258,
            66906539,
            66904016,
            67988407,
            66934409,
            66903855,
            66903188,
            66903009,
            66902847
        ],
        "F": [
            66936996,
            66936445,
            69949014,
            71271095,
            66930593,
            67311416
        ]
    },
    "name": "B. Beingawesomeism",
    "statement": "You are an all-powerful being and you have created a rectangular world.\r\nIn fact, your world is so bland that it could be represented by a r\r\ntimes c grid. Each cell on the grid represents a country. Each country\r\nhas a dominant religion. There are only two religions in your world. One\r\nof the religions is called Beingawesomeism, who do good for the sake of\r\nbeing good. The other religion is called Pushingittoofarism, who do\r\nmurders for the sake of being bad.Oh, and you are actually not really\r\nall-powerful. You just have one power, which you can use infinitely many\r\ntimes! Your power involves . When a missionary group of a certain\r\ncountry, say a, passes by another country b, they change the dominant\r\nreligion of country b to the dominant religion of country a.In\r\nparticular, a single use of your power is this: You choose a horizontal\r\n1\r\ntimes x subgrid or a vertical x\r\ntimes 1 subgrid. That value of x is up to you; You choose a direction d.\r\nIf you chose a horizontal subgrid, your choices will either be NORTH or\r\nSOUTH. If you choose a vertical subgrid, your choices will either be\r\nEAST or WEST; You choose the number s of steps; You command each country\r\nin the subgrid to send a missionary group that will travel s steps\r\ntowards direction d. In each step, they will visit (and in effect\r\nconvert the dominant religion of) all s countries they pass through, as\r\ndetailed above. The parameters x, d, s must be chosen in such a way that\r\nany of the missionary groups won\u2019t leave the grid. The following image\r\nillustrates one possible single usage of your power. Here, represents a\r\ncountry with dominant religion Beingawesomeism and represents a country\r\nwith dominant religion Pushingittoofarism. Here, we\u2019ve chosen a 1\r\ntimes 4 subgrid, the direction NORTH, and s = 2 steps. You are a being\r\nwhich believes in free will, for the most part. However, you just really\r\nwant to stop receiving murders that are attributed to your name. Hence,\r\nyou decide to use your powers and try to make Beingawesomeism the\r\ndominant religion in every country.What is the minimum number of usages\r\nof your power needed to convert everyone to Beingawesomeism?With god,\r\nnothing is impossible. But maybe you\u2019re not god? If it is impossible to\r\nmake Beingawesomeism the dominant religion in all countries, you must\r\nalso admit your mortality and say so.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> s(n);\n\tfor(int i = 0; i < n; i++) cin >> s[i];\n\tbool is0 = false;\n\tbool is1 = false;\n\tbool is2 = false;\n\tbool is3 = false;\n\tbool is4 = false;\n\tis0 = true;\n\n\tbool f1 = true, f2 = true, f3 = true, f4 = true;\n\tfor(int i = 0; i < n; i++){\n\t\tbool row_works = true;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == 'P') row_works = false;\n\t\t}\n\t\tif(row_works) is2 = true;\n\t}\n\tfor(int j = 0; j < m; j++){\n\t\tbool col_works = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(s[i][j] == 'P') col_works = false;\n\t\t}\n\t\tif(col_works) is2 = true;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == 'P'){\n\t\t\t\tis0 = false;\n\t\t\t\tif(i == 0) f1 = false;\n\t\t\t\tif(i == n-1) f2 = false;\n\t\t\t\tif(j == 0) f3 = false;\n\t\t\t\tif(j == m-1) f4 = false;\n\t\t\t} else {\n\t\t\t\tif((i == 0 || i == n-1) && (j == 0 || j == m-1)){\n\t\t\t\t\tis2 = true;\n\t\t\t\t}\n\t\t\t\tif((i == 0 || i == n-1) || (j == 0 || j == m-1)){\n\t\t\t\t\tis3 = true;\n\t\t\t\t}\n\t\t\t\tis4 = true;\n\t\t\t}\n\t\t}\n\t}\n\tis1 = f1 | f2 | f3 | f4;\n\tif(is0){\n\t\tcout << 0 << '\\n';\n\t} else if(is1){\n\t\tcout << 1 << '\\n';\n\t} else if(is2){\n\t\tcout << 2 << '\\n';\n\t} else if(is3){\n\t\tcout << 3 << '\\n';\n\t} else if(is4){\n\t\tcout << 4 << '\\n';\n\t} else {\n\t\tcout << \"MORTAL\" << '\\n';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Beingawesomeism.json",
    "editorial_link": "https://codeforces.com//blog/entry/72212",
    "editorial": "If everything is P, then it is clearly impossible (MORTAL). Otherwise, you can turn everything into A in at most 4\n moves, starting from any single A. Thus, the answer is between 0\n and 4\n. We can exhaust all possibilities:\n\nThe answer is 0\n if:\nEverything is an A.\nOtherwise, at least 1\n move is needed.\nThe answer is 1\n if:\nAt least one of the edge rows/columns is all As.\nOtherwise, it can be shown that at least 2\n moves are needed, because if every edge has at least one P, then no single move can simultaneously turn all four edges into A. To see this, note that our move must simultaneously touch all four edges. This forces us to select our initial row/column to be an entire edge row/column of the grid. But then, we are forced to have at least one P in our selection, and this P cannot be removed in this move.\nThe answer is 2\n if:\nThere is one corner that's an A because in a single move, we can turn an edge into all As.\nThere's a whole column or row of As, because again, in a single move, we can turn an edge into all As. (This case could be tricky to spot.)\nOtherwise, it can be shown that at least 3\n moves are needed. This is because, if we are only allowed 2\n moves, then our first move must take us to a configuration where only 1\n move is needed. In other words, in a single move, we must ensure that one edge has all As. Now, suppose we have decided which edge to turn into all As. Since all corners are Ps, our move must touch both corners of that edge, and so we are forced to copy an entire row/column up to that edge. But since every row/column has a P, this means that the edge will contain a P after the move, and hence, we have failed to turn that edge into all As. (We cannot also have accidentally turned another edge into all As since the other corners are still Ps.)\nThe answer is 3\n if:\nThere is at least one A in one of the edges, because in a single move, we can ensure that one corner becomes an A.\nOtherwise, it can be shown that at least 4\n moves are needed, because we can't turn any corner into A in a single move (because all edges are Ps, and only cells in edges get copied onto corners), and we also can't turn any row/column into all As in a single move (since that requires copying an entire row/column onto it, but again, note that the edges are all Ps).\nThe answer is 4\n if:\nIt is not one of the cases above, since 4\n moves are always enough."
}