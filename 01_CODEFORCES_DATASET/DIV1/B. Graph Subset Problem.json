{
    "link": "https://codeforces.com//contest/1439/problem/B",
    "problemId": "798716",
    "problem_idx": "B",
    "shortId": "1439B",
    "contest_number": "1439",
    "problem_submissions": {
        "E": [
            98736027,
            98740513,
            98743267,
            98751627,
            98746552,
            98793931,
            99104638
        ],
        "D": [
            98723891,
            98705229,
            98723612,
            98827591,
            98816648,
            98814032,
            98725036,
            98724071,
            98728933,
            98730831,
            98730544,
            98736469,
            98737101,
            98739698,
            98716903,
            98721633,
            98735777,
            98741204,
            98725990,
            98732940,
            98719637,
            98741795
        ],
        "C": [
            98717653,
            98714961,
            98717583,
            98709251,
            98712683,
            98710256,
            98709014,
            98716952,
            98723694,
            98722478,
            98723203,
            98711303,
            98733440,
            98725610,
            98728037,
            98706473,
            98717733,
            98731377,
            98715466,
            98722420
        ],
        "B": [
            98704771,
            98722470,
            98701689,
            98703648,
            98704924,
            98788376,
            98780895,
            98705172,
            98721750,
            98849262,
            98707321,
            98708231,
            98709710,
            98796719,
            98765489,
            98765480,
            98765433,
            98765408,
            98765370,
            98750864,
            98750749,
            98747376,
            98713010,
            98736680,
            98709620,
            98716637,
            98748644,
            114352814,
            99699811,
            98846560,
            98754739,
            98754712,
            98711616
        ],
        "A2": [
            98692587,
            98708717,
            98890116,
            98695391,
            98695058,
            98694605,
            98697338,
            98695371,
            98698896,
            98697020,
            98700533,
            98695246,
            98692759,
            98703206,
            98695281,
            98699389,
            98696575,
            98695659,
            98722036,
            98693365,
            98696174
        ],
        "A1": [
            98692484,
            98708569,
            98695320,
            98695174,
            98694699,
            98697254,
            98695563,
            98698871,
            98696932,
            98700473,
            98695187,
            98692661,
            98703311,
            98695126,
            98699325,
            98696645,
            98695725,
            98722109,
            98693254,
            98696254
        ]
    },
    "name": "B. Graph Subset Problem",
    "statement": "You are given an undirected graph with n vertices and m edges. Also, you\r\nare given an integer k.Find either a clique of size k or a non-empty\r\nsubset of vertices such that each vertex of this subset has at least k\r\nneighbors in the subset. If there are no such cliques and subsets report\r\nabout it.A subset of vertices is called a clique of size k if its size\r\nis k and there exists an edge between every two vertices from the\r\nsubset. A vertex is called a neighbor of the other vertex if there\r\nexists an edge between them.\r\n",
    "solutions": [
        "#include <bits/extc++.h>\n\nstruct splitmix64_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\t\t// http://xorshift.di.unimi.it/splitmix64.c\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\n\tsize_t operator()(uint64_t x) const {\n\t\tstatic const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n};\n\ntemplate <typename K, typename V, typename Hash = splitmix64_hash>\nusing hash_map = __gnu_pbds::gp_hash_table<K, V, Hash>;\n\ntemplate <typename K, typename Hash = splitmix64_hash>\nusing hash_set = hash_map<K, __gnu_pbds::null_type, Hash>;\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\t[]() {\n\t\t\tint N, M, K; cin >> N >> M >> K;\n\t\t\tvector<hash_set<int>> adj(N);\n\t\t\tfor (int e = 0; e < M; e++) {\n\t\t\t\tint u, v; cin >> u >> v; u--, v--;\n\t\t\t\tadj[u].insert(v);\n\t\t\t\tadj[v].insert(u);\n\t\t\t}\n\t\t\tvector<int> deg(N);\n\t\t\tfor (int i = 0; i < N; i++) deg[i] = int(adj[i].size());\n\n\t\t\tvector<bool> alive(N, true);\n\t\t\tvector<int> q; q.reserve(N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (deg[i] < K - 1) q.push_back(i);\n\t\t\t}\n\t\t\tfor (int z = 0; z < int(q.size()); z++) {\n\t\t\t\tint cur = q[z];\n\t\t\t\talive[cur] = false;\n\t\t\t\tfor (int nxt : adj[cur]) {\n\t\t\t\t\tif (deg[nxt] == K-1) q.push_back(nxt);\n\t\t\t\t\t--deg[nxt];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tq.clear();\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (!alive[i]) continue;\n\t\t\t\tif (deg[i] == K-1) q.push_back(i);\n\t\t\t}\n\n\t\t\tvector<int> cur_verts; cur_verts.reserve(K);\n\t\t\tfor (int z = 0; z < int(q.size()); z++) {\n\t\t\t\tint cur = q[z];\n\t\t\t\tassert(deg[cur] <= K-1);\n\t\t\t\talive[cur] = false;\n\t\t\t\tfor (int nxt : adj[cur]) {\n\t\t\t\t\tif (deg[nxt] == K) q.push_back(nxt);\n\t\t\t\t\t--deg[nxt];\n\t\t\t\t}\n\n\t\t\t\tif (deg[cur] < K-1) continue;\n\t\t\t\tassert(deg[cur] == K-1);\n\n\t\t\t\tcur_verts.clear();\n\t\t\t\tcur_verts.push_back(cur);\n\t\t\t\tfor (int nxt : adj[cur]) {\n\t\t\t\t\tif (alive[nxt]) {\n\t\t\t\t\t\tif (deg[nxt] < K-2) goto bad;\n\t\t\t\t\t\tcur_verts.push_back(nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(int(cur_verts.size()) == K);\n\t\t\t\tfor (int i = 1; i < K; i++) {\n\t\t\t\t\tint a = cur_verts[i];\n\t\t\t\t\tconst auto& mp = adj[a];\n\t\t\t\t\tfor (int j = i+1; j < K; j++) {\n\t\t\t\t\t\tif (mp.find(cur_verts[j]) == mp.end()) {\n\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tcout << 2 << '\\n';\n\t\t\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\t\t\tcout << cur_verts[i]+1 << \" \\n\"[i+1==K];\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\nbad:\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvector<int> still_alive; still_alive.reserve(N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (alive[i]) still_alive.push_back(i);\n\t\t\t}\n\t\t\tif (!still_alive.empty()) {\n\t\t\t\tcout << 1 << ' ' << still_alive.size() << '\\n';\n\t\t\t\tfor (int z = 0; z < int(still_alive.size()); z++) {\n\t\t\t\t\tcout << still_alive[z]+1 << \" \\n\"[z+1==int(still_alive.size())];\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcout << -1 << '\\n';\n\t\t}();\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "graphs"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Graph Subset Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/84731",
    "editorial": "div1 B :It is easy to see that if the answer is ; because if , no matter\r\nwhether we have a clique of size or a subset of the graph with , we will\r\nhave more than edges in total.Now, the main idea is to suppose is the\r\nvertex with minimum degree; if we should delete becuase can not be in\r\nclique or the subset of vertices such that each vertex of this subset\r\nhas at least neighbors in the subset; so we have to erase and all edges\r\nattached to it.If , remaining vertices will form a subset that every\r\nvertex have at least neighbors in the subset, so we\u00e2\u0080\u0099ll print this subset\r\nas answer.If , we consider and all neighbors of as candidate for clique\r\nof size . then we erase and all edges attached to it.If we erase all\r\nvertices and didn\u00e2\u0080\u0099t found any good subset, then we should check clique\r\ncandidates.for checking clique candidates fast, iterate over vertices\r\nand name current vertex . then for neighbors of set to and otherwise.\r\nfor each clique candidate that contains like , we check edge between and\r\nin using array . every time we find new clique candidate, we remove at\r\nleast edges, so number of clique candidates is at most . for every\r\ncandidate we check edges in overall. so time complexity is .\r\n"
}