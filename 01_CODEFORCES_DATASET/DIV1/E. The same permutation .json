{
    "link": "https://codeforces.com//contest/804/problem/E",
    "problemId": "105176",
    "problem_idx": "E",
    "shortId": "804E",
    "contest_number": "804",
    "problem_submissions": {
        "D": [
            26864569,
            26864084,
            26864065,
            26863844,
            26859532,
            26855737,
            26853547,
            26853205,
            26854566,
            26856630,
            26853214,
            26855855,
            26861591,
            26863648,
            26855151,
            26854613,
            26864015,
            26856289,
            26858468,
            26856391
        ],
        "C": [
            26847789,
            26844906,
            26857930,
            26847099,
            26856657,
            26848089,
            26857400,
            26856222,
            26845185,
            26848695,
            26846499,
            26847477,
            26843068,
            26846575,
            26859352,
            26846716,
            26860420,
            26846219,
            26852629
        ],
        "B": [
            26841209,
            26838692,
            26840551,
            26839159,
            26839206,
            26840437,
            26840273,
            26854727,
            26841332,
            26842906,
            26840147,
            26841623,
            26839518,
            26840190,
            26840304,
            26839516,
            26840017,
            26847973,
            26839966
        ],
        "A": [
            26838410,
            26837453,
            26837406,
            26837277,
            26841198,
            26837228,
            26837723,
            26837298,
            26837762,
            26837644,
            26837931,
            26837280,
            26837588,
            26838739,
            26837615,
            26837337,
            26846921,
            26837692
        ],
        "E": [
            26859757,
            26861113,
            26864419,
            26864227,
            26864109,
            26864035,
            26863863,
            26860566,
            26862404,
            26859605,
            26854745,
            26861397,
            26884422,
            26865231,
            26853306,
            26856744,
            26859172
        ]
    },
    "name": "E. The same permutation ",
    "statement": "Seyyed and MoJaK are friends of Sajjad. Sajjad likes a permutation.\r\nSeyyed wants to change the permutation in a way that Sajjad won’t like\r\nit. Seyyed thinks more swaps yield more probability to do that, so he\r\nmakes MoJaK to perform a swap between every pair of positions , where ,\r\nexactly once. MoJaK doesn’t like to upset Sajjad.Given the permutation,\r\ndetermine whether it is possible to swap all pairs of positions so that\r\nthe permutation stays the same. If it is possible find how to do that.\r\n",
    "solutions": [
        "#include <iostream>\n#include <tuple>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nvector<pii> ans4 = {{0, 1}, {0, 2}, {1, 3}, {0, 3}, {1, 2}, {2, 3}};\nvector<pii> ans5 = {{0, 1},\n{0, 2},\n{0, 3},\n{1, 2},\n{1, 4},\n{2, 4},\n{0, 4},\n{2, 3},\n{1, 3},\n{3, 4}};\nint sh44[] = {0, 3, 1, 2};\nvector<pii> ans44;\nvector<pii> ans45;\n\nvector<pii> ans;\n\nvoid sh(vi v, vector<pii> p) {\n    for (pii q: p) ans.pb({v[q.fi], v[q.se]});\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    forn(i, 4) forn(j, 4) ans44.pb({j, 4 + (j + sh44[i]) % 4});\n\n    int n;\n    cin >> n;\n    int m = n % 4;\n    if (m != 0 && m != 1) {\n        cout << \"NO\\n\";\n        return 0;\n    }\n    for (int i = 0; i < n - 1; i += 4) {\n        vi v;\n        forn(j, 4) v.pb(i + j);\n        if (n % 4) v.pb(n - 1);\n        sh(v, n % 4 ? ans5 : ans4);\n        for (int j = 0; j < i; j += 4) {\n            vi u;\n            forn(k, 4) u.pb(i + k);\n            forn(k, 4) u.pb(j + k);\n            sh(u, ans44);\n        }\n    }\n\n    cout << \"YES\\n\";\n    for (pii p: ans) {\n        if (p.fi > p.se) swap(p.fi, p.se);\n        cout << p.fi + 1 << ' ' << p.se + 1 << '\\n';\n    }\n\n/*    vi a(n);\n    forn(i, n) a[i] = i;\n    vi c = a;\n    for (pii p: ans) {\n        assert(p.fi != p.se);\n        swap(a[p.fi], a[p.se]);\n    }\n    assert(set<pii>(all(ans)).size() == n * (n - 1) / 2);\n    assert(a == c);*/\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. The same permutation .json",
    "editorial_link": "https://codeforces.com/blog/entry/51846",
    "editorial": "If then it is simply provable the answer is \"NO\".So we just need to\r\ncheck . There is a constructive solution to do that. Assume that .\r\nPartition numbers to classes, each class contains a consecutive\r\nnumbers.We can solve each class itself by these swaps to reach the same\r\npermutation:We can do swaps between two different classes as follows to\r\nreach the same permutation, assume that the first element of the first\r\nclass is and for the second class is : Now assume that . Do the swaps\r\nabove with first numbers with these changes in place of swaps in the\r\nclasses itself to satisfy the last number:\r\n",
    "hint": [
        "hint1 You can prove, we need even number of swaps to reach the same permutation. So and the answer for and is -1.",
        "hint2 The solution almost is constructive. Try to solve it for n = 4 And then solve by .",
        "hint3 Let's partition numbers to classes, each class contains a consecutive numbers. And when there is a class with consecutive numbers."
    ]
}