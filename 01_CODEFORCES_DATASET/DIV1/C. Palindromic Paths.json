{
    "link": "https://codeforces.com//contest/1205/problem/C",
    "problemId": "390599",
    "problem_idx": "C",
    "shortId": "1205C",
    "contest_number": "1205",
    "problem_submissions": {
        "B": [
            59042855,
            59008277,
            59009392,
            59009099,
            59017750,
            59011582,
            59017246,
            59016172,
            59010044,
            59012507,
            59016410,
            59014372,
            59018459,
            59016311,
            59014609,
            59017774,
            59016256,
            59018790,
            59017251,
            59019103
        ],
        "F": [
            59040509,
            83365787,
            73837920,
            59054768,
            59706336,
            59497174,
            59084173,
            59131512
        ],
        "E": [
            59035128,
            59036458,
            59034704,
            59041033,
            59039150,
            59045402,
            59080765,
            59062429
        ],
        "D": [
            59016188,
            59026535,
            59028832,
            59032222,
            59023841,
            59032667,
            59050800,
            59047976,
            59037746,
            59038899,
            59036700,
            59037946,
            59034393,
            59042000,
            59040164,
            59037017,
            59039734,
            59041481,
            59041292,
            59040370,
            59040328
        ],
        "A": [
            59004226,
            59002142,
            59002328,
            59003907,
            59002592,
            59003675,
            59003063,
            59008409,
            59005394,
            59004820,
            59012388,
            59002589,
            59006476,
            59006648,
            59014700,
            59002817,
            59005001,
            59008957,
            59004360,
            59003394
        ],
        "C": [
            59022089,
            59020944,
            59025032,
            59033727,
            59026494,
            59026517,
            59028041,
            59025931,
            59027756,
            59033147,
            59024700,
            59031289,
            59032853,
            59030231,
            59031302,
            59030790,
            59030100,
            59029442,
            59031718
        ]
    },
    "name": "C. Palindromic Paths",
    "statement": "You are given a grid n\r\ntimes n, where n is . Rows are enumerated from 1 to n from up to down,\r\ncolumns are enumerated from 1 to n from left to right. Cell, standing on\r\nthe intersection of row x and column y, is denoted by (x, y).Every cell\r\ncontains 0 or 1. It is known that the top-left cell contains 1, and the\r\nbottom-right cell contains 0.We want to know numbers in all cells of the\r\ngrid. To do so we can ask the following questions: \"\", where 1\r\nle x_1\r\nle x_2\r\nle n, 1\r\nle y_1\r\nle y_2\r\nle n, and x_1 + y_1 + 2\r\nle x_2 + y_2. In other words, we output two different cells (x_1, y_1),\r\n(x_2, y_2) of the grid such that we can get from the first to the second\r\nby moving only to the right and down, and they aren\u2019t adjacent.As a\r\nresponse to such question you will be told if there exists a path\r\nbetween (x_1, y_1) and (x_2, y_2), going only to the right or down,\r\nnumbers in cells of which form a palindrome.For example, paths, shown in\r\ngreen, are palindromic, so answer for \"\" and \"\" would be that there\r\nexists such path. However, there is no palindromic path between (1, 1)\r\nand (3, 1). Determine all cells of the grid by asking not more than n^2\r\nquestions. It can be shown that the answer always exists.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 101;\nint n;\nint a[N][N];\n\nint query(int x1, int y1, int x2, int y2) {\n\tprintf(\"? %d %d %d %d\\n\", x1 + 1, y1 + 1, x2 + 1, y2 + 1);\n\tfflush(stdout);\n\tscanf(\"%d\", &x1);\n\treturn x1;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\ta[0][0] = 1;\n\tfor (int x = 0; x < n; x++)\n\t\tfor (int y = 0; y < n; y++) {\n\t\t\tif (x == 0 && y == 0) continue;\n\t\t\tif (x == n - 1 && y == n - 1) continue;\n\t\t\tif (((x + y) & 1) && (x == 0)) continue;\n\t\t\tif (x == 1 && y == 0) continue;\n\t\t\tint x1, y1;\n\t\t\tif (y >= 2) {\n\t\t\t\tx1 = x;\n\t\t\t\ty1 = y - 2;\n\t\t\t} else if (x >= 1 && y >= 1) {\n\t\t\t\tx1 = x - 1;\n\t\t\t\ty1 = y - 1;\n\t\t\t} else if (x >= 2) {\n\t\t\t\tx1 = x - 2;\n\t\t\t\ty1 = y;\n\t\t\t} else throw;\n\t\t\ta[x][y] = 1 ^ a[x1][y1] ^ query(x1, y1, x, y);\n\t\t}\n\tfor (int y = 1; y < n; y += 2)\n\t\ta[0][y] = 1 ^ a[2][y] ^ query(0, y, 2, y);\n\tint p = 0;\n\twhile(a[p + 2][p + 2] == a[p][p]) p++;\n\tif ((a[p][p + 1] ^ a[p + 2][p + 2]) == (a[p + 1][p + 1] ^ a[p + 2][p + 1])) {\n\t\tint t = query(p, p + 1, p + 2, p + 2);\n\t\tif (1 ^ t ^ a[p][p + 1] ^ a[p + 2][p + 2]) {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif ((i + j) & 1)\n\t\t\t\t\t\ta[i][j] ^= 1;\n\t\t}\n\t} else {\n\t\tint t = query(p, p, p + 2, p + 1);\n\t\tif (1 ^ t ^ a[p][p] ^ a[p + 2][p + 1]) {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif ((i + j) & 1)\n\t\t\t\t\t\ta[i][j] ^= 1;\n\t\t}\n\t}\n\tprintf(\"!\\n\");\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tprintf(\"%d\", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\tfflush(stdout);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "interactive"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Palindromic Paths.json",
    "editorial_link": "https://codeforces.com/blog/entry/69158",
    "editorial": "Denote if there is a palindromic path between them, and otherwise. We\r\nalso denote by the number written in the cell .Firstly, make an\r\nobservation: if the Manhattan distance is 2, then . In fact, the path\r\nbetween the cells and has a length of , and therefore it is palindromic\r\nif and only if .Consider a chessboard coloring such that the upper left\r\nunit is painted white. Then, using the observation described above, we\r\ncan restore the numbers in all white cells. In a similar way, if we fix\r\na certain number in a black cell, then all other numbers in black cells\r\nwill be restored uniquely. Thus, we only have two options for arranging\r\nnumbers on the board, which differ in the fact that in the second\r\noption, the numbers in the black cells are opposite to those in the\r\nfirst option. In the figure below, green pairs of white cells are\r\nconnected, about which we can ask questions to find out all the values\r\nin them, and red - pairs of black cells. Now there are two approaches.\r\nFirst: for each option, calculate for each pair of suitable cells, find\r\nwhere they differ, and ask a question about these two cells. This way we\r\ncan uniquely identify the board option. It is possible to determine\r\nusing dynamic programming: the answer is only when and there is a path\r\n-palindrome between a pair of and .The second approach is a little more\r\ninteresting, and it also shows why there is such a pair of cells for\r\nwhich the two options give different answers. Consider any path with a\r\nlength of cells, denote the numbers in its cells as . Then two of the\r\ncells of the path are black, and two are white. We know the relation\r\nbetween , as well as between (by the relation we mean that we know are\r\nnumbers in them same, or different). Suppose that the relation between\r\nis the same as between . Then will make it possible to uniquely\r\ndetermine all the numbers! Indeed, if , then , and therefore the path\r\nwill be palindromic. Otherwise, no path between and will be palindromic.\r\nThus, we will be able to establish a relation between some white and\r\nsome black cell, which will be enough to solve the problem.Suppose that\r\nfor any path of four cells , the relation between is different from the\r\nrelation between . This is equivalent to . Suppose that for any path of\r\nfour cells of numbers in them is equal to . Then we consider any path\r\nfrom the cell to the cell of length . If the xor of each of neighboring\r\ncells in it is , then the line is periodic with a period of , but the\r\nnumbers in the first and last cell in it are different from the\r\ncondition! Thus, the algorithm is as follows: choose any path between\r\nand , find on it four cells with a xor of numbers equal to , and ask a\r\nquestion about it.Asymptotics .\r\n"
}