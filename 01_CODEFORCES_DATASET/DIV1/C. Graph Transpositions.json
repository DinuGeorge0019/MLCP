{
    "link": "https://codeforces.com//contest/1442/problem/C",
    "problemId": "782908",
    "problem_idx": "C",
    "shortId": "1442C",
    "contest_number": "1442",
    "problem_submissions": {
        "F": [
            97498578,
            135803098
        ],
        "E": [
            97475216,
            97479604,
            97479996,
            97476389,
            97475771,
            97482490,
            97482122,
            97486462,
            97481313,
            97514122,
            97491110,
            97570605,
            97570447,
            97483367,
            97482486,
            97530901,
            97530677,
            97490693,
            97491170,
            97483183,
            97744761,
            97465807,
            97518516,
            97525092
        ],
        "D": [
            97466130,
            97467957,
            97470622,
            97481203,
            97465568,
            97454688,
            97470507,
            97479495,
            97471531,
            97513997,
            97513923,
            97474497,
            97524422,
            97524418,
            97524414,
            97523769,
            97523651,
            97523580,
            97514880,
            97514861,
            97470422,
            97454149,
            97469561,
            97480908,
            97475630,
            97456546,
            97494847,
            97472947,
            97473292
        ],
        "C": [
            97461787,
            97460269,
            97457703,
            97453909,
            97462173,
            97474564,
            97455050,
            97455856,
            97466820,
            97514136,
            97458387,
            97515471,
            97514818,
            97514812,
            97514752,
            97514717,
            97462625,
            97478118,
            97463398,
            97456934,
            97468590,
            97472482,
            97456397,
            97465702,
            97461718
        ],
        "B": [
            97444657,
            97444364,
            97444049,
            97441804,
            97446454,
            97444215,
            97443077,
            97445131,
            97444667,
            97514148,
            97444728,
            97447073,
            97465519,
            97447003,
            97445633,
            97445150,
            97448727,
            97454658,
            97448347,
            97442585
        ],
        "A": [
            97436722,
            97436568,
            97436299,
            97438819,
            97440488,
            97436328,
            97437458,
            97436707,
            97440205,
            97514153,
            97437001,
            97448738,
            97444789,
            97436058,
            97438579,
            97436174,
            97437755,
            97436528,
            97438505,
            97439502
        ]
    },
    "name": "C. Graph Transpositions",
    "statement": "You are given a directed graph of n vertices and m edges. Vertices are\r\nnumbered from 1 to n. There is a token in vertex 1.The following actions\r\nare allowed: Token movement. To move the token from vertex u to vertex v\r\nif there is an edge u\r\nto v in the graph. This action takes 1 second. Graph transposition. To\r\ntranspose all the edges in the graph: replace each edge u\r\nto v by an edge v\r\nto u. This action takes increasingly more time: k-th transposition takes\r\n2^{k-1} seconds, i.e. the first transposition takes 1 second, the second\r\none takes 2 seconds, the third one takes 4 seconds, and so on. The goal\r\nis to move the token from vertex 1 to vertex n in the shortest possible\r\ntime. Print this time modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn't exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << \", \";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\nint N,M;\nint dp[MX][2][21];\npi mn[MX][2];\nvi adj[MX][2];\npi bes[MX];\n\nusing T = pair<pi,pi>; // {transpositions, dist} and {vertex, color} ??\n// priority_queue<T,V<T>,greater<T>> pq;\n\n// BFS minimizing dist for transpositions < 21\n// Dijkstra minimizing {transpositions,dist}\n\n// void ad(pi loc, pi dist) {\n// \tif (dist.f < 21) {\n\n// \t} else {\n// \t\tif ()\n// \t}\n// }\n\nvoid bfs() {\n\tFOR(i,1,N+1) F0R(j,2) F0R(k,21) dp[i][j][k] = MOD;\n\tdeque<T> todo;\n\tauto upd = [&](pi vertColor, pi info) { // OK\n\t\tif (dp[vertColor.f][vertColor.s][info.f] <= info.s) {\n\t\t\treturn 0;\n\t\t}\n\t\tdp[vertColor.f][vertColor.s][info.f] = info.s;\n\t\treturn 1;\n\t};\n\tauto ad_front = [&](pi vertColor, pi info) {\n\t\tif (!upd(vertColor,info)) return;\n\t\ttodo.push_front({info,vertColor});\n\t};\n\tauto ad_back = [&](pi vertColor, pi info) {\n\t\tif (!upd(vertColor,info)) return;\n\t\ttodo.pb({info,vertColor});\n\t};\n\tad_front({1,0},{0,0});\n\twhile (sz(todo)) { // {transpositions,dist}, {vert,color}\n\t\tT t = todo.ft; todo.pop_front();\n\t\tif (t.f.s > dp[t.s.f][t.s.s][t.f.f]) continue;\n\t\t// dbg(\"TRANSPOSITIONS\",\"DIST\",\"VERT\",\"COLOR\",t,adj[t.s.f][t.s.s]);\n\t\tif (t.f.f+1 < 21) ad_front({t.s.f,t.s.s^1},{t.f.f+1,t.f.s});\n\t\ttrav(e,adj[t.s.f][t.s.s]) ad_back({e,t.s.s},{t.f.f,t.f.s+1});\n\t}\n}\n\npi dist[MX][2];\n\nvoid dijk() {\n\tdbg(\"DIJK\");\n\tFOR(i,1,N+1) F0R(j,2) dist[i][j] = {MOD,MOD}; // transpositions dist\n\tpriority_queue<T,V<T>,greater<T>> todo;\n\tauto ad = [&](pi vertColor, pi info) {\n\t\tif (ckmin(dist[vertColor.f][vertColor.s],info)) {\n\t\t\ttodo.push({info,vertColor});\n\t\t}\n\t};\n\tad({1,0},{0,0});\n\twhile (sz(todo)) {\n\t\tauto t = todo.top(); todo.pop();\n\t\tif (t.f > dist[t.s.f][t.s.s]) continue;\n\t\tad({t.s.f,t.s.s^1},{t.f.f+1,t.f.s});\n\t\ttrav(e,adj[t.s.f][t.s.s]) ad({e,t.s.s},{t.f.f,t.f.s+1});\n\t}\n\tpi ans = min(dist[N][0],dist[N][1]);\n\tdbg(\"HA\",ans);\n\tps(pow(mi(2),ans.f)-1+ans.s);\n\texit(0);\n\t// pi p = {};\n}\n\nint main() {\n\tsetIO(); re(N,M);\n\tF0R(i,M) {\n\t\tint u,v; re(u,v);\n\t\t// dbg(\"ED\",u,v);\n\t\tadj[u][0].pb(v);\n\t\tadj[v][1].pb(u);\n\t}\n\tbfs();\n\tint ans = MOD;\n\tF0R(j,2) F0R(k,21) if (dp[N][j][k] != MOD) {\n\t\t// dbg(\"HA\",j,k,dp[N][j][k]);\n\t\tckmin(ans,(1<<k)-1+dp[N][j][k]);\n\t}\n\tif (ans != MOD) {\n\t\tps(ans);\n\t\texit(0);\n\t}\n\tdijk();\n\n\t// FOR(i,1,N+1) {\n\t// \tmn[i] = MOD;\n\t// \tbes[i] = {MOD,MOD};\n\t// \tF0R(j,2) F0R(k,21) dp[i][j][k] = MOD;\n\t// }\n\t// ad({1,0},{0,0});\n\t// F0R(i,21) {\n\n\t// }\n\t// while (1) {\n\t// \tT p = pq.top(); pq.pop();\n\t// \tif (mn[p.s] < p.f.f && p.f.f >= 21) continue;\n\t// \ttrav(t,adj[][]) {\n\n\t// \t}\n\t// }\n\t// FOR(i,1,N+1) F0R(j,21) dp[i][j] = MOD;\n\t// dp[1][0] = 1;\n\t// F0R(mov,21) {\n\n\t// }\n\t// first get min for each vert\n\t// if some are still not reached\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Graph Transpositions.json",
    "editorial_link": "https://codeforces.com//blog/entry/84298",
    "editorial": "Consider a sequence of actions that moves the token from vertex to\r\nvertex . Let us say it has token movements and graph transpositions.\r\nThis sequence takes seconds.Note that the optimal path does not visit\r\nany edge twice. That means we need to consider only paths with .\r\nConsider another sequence consisting of token movements and graph\r\ntranspositions. Let . Note the following. If then < . This is true\r\nbecause the difference between and does not exceed and . This gives us\r\nthe following: if there is any sequence of actions with that moves the\r\ntoken from vertex to vertex then optimal path\u00e2\u0080\u0099s is less than too. Let us\r\ncheck this with the following algorithm, and if it is so, find the\r\noptimal sequence of actions.We can now build a new graph that consists\r\nof copies of the original graph: Reverse all the edges in every even\r\ngraph copy. For every vertex add new edge between -th and -th copies of\r\nvertex with weight for . We can find optimal paths from the first copy\r\nof vertex to all the copies of vertex using Dijkstra algorithm. Shortest\r\nof these paths would correspond to the answer: movement along a copy of\r\noriginal edge denotes token movement; movement along a new edge denotes\r\ngraph transposition.If the algorithm found no paths, then the sequence\r\nof actions that moves the token to from vertex 1 to vertex consists of\r\nat least transpositions. Note that if then < . It means that all\r\nsequences of actions can be compared using ordered vector\r\nlexicographically.Let us build another graph consisting of copies of the\r\noriginal graph: Reverse all the edges in the second copy of the graph.\r\nAssign to weights of all of these edges. For every vertex add two new\r\nedges between copies of : from the first to the second copy and back.\r\nWeights of both edges is . Let us find optimal paths from the first copy\r\nof vertex to both copies of vertex using Dijkstra algorithm. Let be the\r\nlength of the shortest one. New graph allows us to restore the optimal\r\nsequence of actions that moves the token from vertex to vertex that will\r\ntake seconds.\r\n"
}