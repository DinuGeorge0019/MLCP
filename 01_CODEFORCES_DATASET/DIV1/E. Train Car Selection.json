{
    "link": "https://codeforces.com//contest/1137/problem/E",
    "problemId": "309121",
    "problem_idx": "E",
    "shortId": "1137E",
    "contest_number": "1137",
    "problem_submissions": {
        "C": [
            51278692,
            51013174,
            51012138,
            51014594,
            51060015,
            51011758,
            51015377,
            51058095,
            51060423,
            51013462,
            51011929,
            51013820,
            51016620,
            51021729,
            51016142,
            51022376,
            51017039,
            51022733
        ],
        "D": [
            51022280,
            51016149,
            51021902,
            51016444,
            51017886,
            51022110,
            51022575,
            51017121,
            51017510,
            51026190,
            51017887,
            51020056,
            51071936,
            51020439,
            51057402,
            51015057,
            51021542,
            51016650
        ],
        "F": [
            51021456,
            51151872,
            51044265,
            208399382,
            208399328,
            51370362,
            51370305,
            56076657,
            51062431,
            51062375,
            51201422,
            51152102
        ],
        "E": [
            51015510,
            51019659,
            51017815,
            51022086,
            51024208,
            51025483,
            51015317,
            51021155,
            51026207,
            51019242,
            51116875,
            51022655,
            51043942,
            51019234,
            51021992,
            51040600
        ],
        "B": [
            51007898,
            51008699,
            51007790,
            51010637,
            51008661,
            51008854,
            51009928,
            51010030,
            51008543,
            51011271,
            51008351,
            51008938,
            51007902,
            51007130,
            51009176,
            51009835,
            51007086,
            51008751,
            51007248
        ],
        "A": [
            51006589,
            51007409,
            51005936,
            51007585,
            51007232,
            51007035,
            51007494,
            51006878,
            51006201,
            51013385,
            51006659,
            51007366,
            51005796,
            51010835,
            51007279,
            51007757,
            51009144,
            51007439,
            51005946
        ]
    },
    "name": "E. Train Car Selection",
    "statement": "Vasya likes to travel by train, but doesn’t like when the car he travels\r\nin is located in the tail of the train.Vasya gets on the train at the\r\nstation. The train consists of n cars indexed from 1 to n counting from\r\nthe locomotive (head of the train). Three types of events occur while\r\nthe train is moving: Some number of cars are added to the head of the\r\ntrain; Some number of cars are added to the tail of the train; Vasya\r\nrecalculates the values of the convenience of the cars (read more about\r\nit below). At each moment of time we will index the cars from the head\r\nof the train, starting from 1. Note that when adding new cars to the\r\nhead of the train, the indexing of the old ones may shift.To choose\r\nwhich car to go in, Vasya will use the value A_i for each car (where i\r\nis a car index), which is calculated as follows: At the beginning of the\r\ntrip A_i=0, as well as for the new cars at the time of their addition.\r\nDuring the next recalculation Vasya chooses some integers b and s and\r\nadds to all A_i value b + (i - 1)\r\ncdot s. Vasya hasn’t decided yet where he will get on the train and\r\nwhere will get off the train, so after each event of one of the three\r\ntypes he wants to know the least index of the car, such that its value\r\nA_i is minimal. Since there is a lot of cars, Vasya asked you to write a\r\nprogram that answers his question.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n  long long x, y;\n\n  point(long long x = 0, long long y = 0): x(x), y(y) {\n  }\n\n  point operator - (const point &b) const {\n    return point(x - b.x, y - b.y);\n  }\n};\n\nbool check(point p, point q, point r) {\n  point pp = p - q, rr = r - q;\n  return (long double) pp.x * rr.y >= (long double) pp.y * rr.x;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n;\n  int m;\n  cin >> n >> m;\n  long long add = 0, slope = 0;\n  vector<point> hull(1, point(0, 0));\n  while (m--) {\n    int type;\n    cin >> type;\n    if (type == 1) {\n      int cnt;\n      cin >> cnt;\n      hull.clear();\n      hull.push_back(point(0, 0));\n      n += cnt;\n      add = slope = 0;\n    } else if (type == 2) {\n      int cnt;\n      cin >> cnt;\n      while (hull.size() > 1 && check(point(n, -(n * slope + add)), hull[hull.size() - 2], hull[hull.size() - 1])) {\n        hull.pop_back();\n      }\n      hull.push_back(point(n, -(n * slope + add)));\n      n += cnt;\n    } else {\n      int b, s;\n      cin >> b >> s;\n      add += b;\n      slope += s;\n    }\n    while (hull.size() > 1 && slope * hull.back().x + hull.back().y >= slope * hull[hull.size() - 2].x + hull[hull.size() - 2].y) {\n      hull.pop_back();\n    }\n    cout << hull.back().x + 1 << \" \" << slope * hull.back().x + hull.back().y + add << \"\\n\";\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Train Car Selection.json",
    "editorial_link": "https://codeforces.com/blog/entry/65825",
    "editorial": "There are many approaches to this problem, many of them having time, but\r\nwe will describe a purely linear solution.First, notice that for every\r\ngroup of cars added together, we need only to care about the first car\r\nin this group the remaining ones will never be the answer.Second, notice\r\nthat there are some cars appended to the head of the train, then all\r\nprevious cars will never be answer again, so we can simply replace them\r\nwith cars with .So now we only need to care about operations of adding\r\ncars to the tail, and about adding the progression.Suppose cars located\r\nat positions and have comfort .Then observe the lower-left convex hull\r\nof points . One can see, that the points not lying on this hull will\r\nnever be an answer.Also note, that we can handle all progressions\r\nimplicitly suppose the progressions are described with , . Then letâs\r\nsimply store current sums of and . Then the operation of adding\r\nprogression can be done by simply adding to those sums, also we donât\r\nhave to track the moment the cars are added, since we can simply\r\nsubtract from based on sums at the moment of .So when we add cars to the\r\nend we simply need to add point to the end and possibly drop some points\r\nfrom the end of the current convex hull. And when we add new\r\nprogression, we may also need to drop some elements from the hull, but\r\nsince itâs the convex hull, the line coefficients between neighboring\r\npoints are monotonous, so we need to drop only some points in the end of\r\nthe hull.\r\n",
    "hint": []
}