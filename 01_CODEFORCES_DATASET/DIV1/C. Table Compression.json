{
    "link": "https://codeforces.com//contest/650/problem/C",
    "problemId": "50873",
    "problem_idx": "C",
    "shortId": "650C",
    "contest_number": "650",
    "problem_submissions": {
        "E": [
            16578790,
            16577272,
            16578590,
            16579959,
            16637208,
            16582561,
            16619834,
            16591408,
            16757704
        ],
        "D": [
            16571229,
            16573705,
            16576122,
            16578304,
            16576176,
            16577509,
            16577016,
            16576771,
            16578407,
            16577295,
            16573405,
            16578398,
            16577971,
            16579415,
            16579518,
            16578322,
            16579977,
            16579420,
            16579068
        ],
        "B": [
            16567529,
            16566753,
            16570863,
            16566306,
            16567392,
            16570268,
            16568199,
            16568212,
            16566872,
            16566001,
            16578738,
            16567371,
            16573291,
            16569824,
            16567006,
            16572578,
            16570591,
            16567965,
            16566091
        ],
        "C": [
            16565085,
            16569140,
            16568520,
            16573461,
            16571216,
            16572854,
            16571058,
            16570678,
            16571485,
            16571831,
            16567202,
            16572160,
            16568367,
            16566170,
            16572982,
            16567681,
            16567338,
            16571921,
            16572363
        ],
        "A": [
            16562732,
            16562808,
            16562782,
            16562889,
            16563014,
            16563492,
            16563086,
            16563133,
            16562823,
            16562796,
            16575057,
            16563813,
            16563019,
            16567243,
            16562986,
            16569600,
            16562758,
            16562970,
            16562962
        ]
    },
    "name": "C. Table Compression",
    "statement": "Little Petya is now fond of data compression algorithms. He has already\r\nstudied , , algorithms and many others. Inspired by the new knowledge,\r\nPetya is now developing the new compression algorithm which he wants to\r\nname .Petya decided to compress tables. He is given a table consisting\r\nof rows and columns that is filled with positive integers. He wants to\r\nbuild the table consisting of positive integers such that the relative\r\norder of the elements in each row and each column remains the same. That\r\nis, if in some row of the initial table , then in the resulting table ,\r\nand if then . Similarly, if in some column of the initial table then in\r\ncompressed table and if then . Because large values require more space\r\nto store them, the maximum value in should be as small as possible.Petya\r\nis good in theory, however, he needs your help to implement the\r\nalgorithm.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000010;\n\nvector <int> eq[N], mr[N];\npair <int, int> b[N], c[N];\nint a[N];\nbool was[N];\nint x[N];\nint res[N];\n\nint main() {\n  int h, w;\n  scanf(\"%d %d\", &h, &w);\n  for (int i = 0; i < h * w; i++) {\n    scanf(\"%d\", a + i);\n    eq[i].clear();\n    mr[i].clear();\n  }\n  for (int row = 0; row < h; row++) {\n    for (int j = 0; j < w; j++) {\n      int id = row * w + j;\n      b[j] = make_pair(a[id], id);\n    }\n    sort(b, b + w);\n    for (int j = 1; j < w; j++) {\n      int x = b[j].second;\n      int y = b[j - 1].second;\n      if (b[j].first == b[j - 1].first) {\n        eq[x].push_back(y);\n        eq[y].push_back(x);\n      } else {\n        mr[x].push_back(y);\n      }\n    }\n  }\n  for (int col = 0; col < w; col++) {\n    for (int i = 0; i < h; i++) {\n      int id = i * w + col;\n      b[i] = make_pair(a[id], id);\n    }\n    sort(b, b + h);\n    for (int j = 1; j < h; j++) {\n      int x = b[j].second;\n      int y = b[j - 1].second;\n      if (b[j].first == b[j - 1].first) {\n        eq[x].push_back(y);\n        eq[y].push_back(x);\n      } else {\n        mr[x].push_back(y);\n      }\n    }\n  }\n  for (int i = 0; i < h * w; i++) {\n    was[i] = false;\n    c[i] = make_pair(a[i], i);\n  }\n  sort(c, c + h * w);\n  for (int id = 0; id < h * w; id++) {\n    int q = c[id].second;\n    if (was[q]) {\n      continue;\n    }\n    int b = 0, e = 0;\n    x[0] = q;\n    was[q] = true;\n    while (b <= e) {\n      int sz = eq[x[b]].size();\n      for (int j = 0; j < sz; j++) {\n        int u = eq[x[b]][j];\n        if (!was[u]) {\n          e++;\n          x[e] = u;\n          was[u] = true;\n        }\n      }\n      b++;\n    }\n    e++;\n    int put = 1;\n    for (int jj = 0; jj < e; jj++) {\n      int u = x[jj];\n      int sz = mr[u].size();\n      for (int j = 0; j < sz; j++) {\n        int v = mr[u][j];\n        put = max(put, res[v] + 1);\n      }\n    }\n    for (int jj = 0; jj < e; jj++) {\n      int u = x[jj];\n      res[u] = put;\n    }\n  }\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (j > 0) {\n        putchar(' ');\n      }\n      printf(\"%d\", res[i * w + j]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Table Compression.json",
    "editorial_link": "https://codeforces.com//blog/entry/43677",
    "editorial": "First we will solve our\nproblem when all values are different. We will construct a graph, where\nvertices are cells and there is an edge between two of them if we know\nthat one is strictly less then the other and this relation should be\npreserved. This graph obviously has no cycles, so we can calculate\nanswer as dynamic programming on the vertices: We can do this with\ntopological sort or with lazy computations. But if we will construct our\ngraph naively then it will contain edges. To reduce this number we will\nsort each row and column and add edges only between neighbours in the\nsorted order. Now we have edges and we compute them in time. But to\nsolve the problem completely in the beginning we need to compress all\nequal values which are in the same rows and columns. We can construct\nsecond graph with edges between equal cells in the same way as before\nand find all connected components in it. They will be our new vertices\nfor the first graph.\n",
    "hint": []
}