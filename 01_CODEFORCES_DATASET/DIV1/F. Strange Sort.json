{
    "link": "https://codeforces.com//contest/1558/problem/F",
    "problemId": "1088954",
    "problem_idx": "F",
    "shortId": "1558F",
    "contest_number": "1558",
    "problem_submissions": {
        "F": [
            126899482,
            126888055,
            126902100,
            126890640,
            126888389,
            126894123,
            126904590,
            126900041,
            126902212,
            126902942,
            127549735,
            127006693
        ],
        "E": [
            126883583,
            126896785,
            126884151,
            126898148,
            126905418,
            126902611,
            126899238,
            126907028,
            126907352,
            126891363,
            126891974,
            126891356,
            126892061,
            126902546,
            126900088,
            126903655,
            126904227,
            126900317,
            126902700
        ],
        "D": [
            126869704,
            126870708,
            126871179,
            126874038,
            126874151,
            126876731,
            126871810,
            126867588,
            126872511,
            126871952,
            126882884,
            126882215,
            126882465,
            126878861,
            126876122,
            126890668,
            126874784,
            126883630,
            126892178,
            126890480
        ],
        "B": [
            126858181,
            126855670,
            126854102,
            126855872,
            126858058,
            126860085,
            126854841,
            126852806,
            126853901,
            126856718,
            126855353,
            126856232,
            126858032,
            126857658,
            126854131,
            126863721,
            126854756,
            126864821,
            126867061,
            126863501
        ],
        "A": [
            126854362,
            126850555,
            126848635,
            126848815,
            126849088,
            126855964,
            126848126,
            126847884,
            126848457,
            126849581,
            126847772,
            126849333,
            126852232,
            126849014,
            126848809,
            126853376,
            126847687,
            126859049,
            126849750,
            126850402
        ],
        "C": [
            126850882,
            126858888,
            126859482,
            126861350,
            126866099,
            126867225,
            126859442,
            126858664,
            126862495,
            126861859,
            126865577,
            126860578,
            126863128,
            126865366,
            126858535,
            126873768,
            126863562,
            126873408,
            126874458,
            126871983
        ]
    },
    "name": "F. Strange Sort",
    "statement": "You have a permutation: an array a = [a_1, a_2,\r\nldots, a_n] of distinct integers from 1 to n. The length of the\r\npermutation n is odd.Consider the following algorithm of sorting the\r\npermutation in increasing order.A helper procedure of the algorithm,\r\nf(i), takes a single argument i (1\r\nle i\r\nle n-1) and does the following. If a_i > a_{i+1}, the values of a_i and\r\na_{i+1} are exchanged. Otherwise, the permutation doesn\u2019t change.The\r\nalgorithm consists of iterations, numbered with consecutive integers\r\nstarting with 1. On the i-th iteration, the algorithm does the\r\nfollowing: if i is odd, call f(1), f(3),\r\nldots, f(n - 2); if i is even, call f(2), f(4),\r\nldots, f(n - 1). It can be proven that after a finite number of\r\niterations the permutation will be sorted in increasing order.After how\r\nmany iterations will this happen for the first time?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = 1e9;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi, mset = inf, madd = 0, val = -inf;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tint query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -inf;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\nint solve(vector<int> a){\n\tint n = (int)a.size();\n\tbool sorted = true;\n\tfor(int i = 0; i < n; i++) if(a[i] != i) sorted = false;\n\tif(sorted){\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i+1 < n; i += 2){\n\t\tif(a[i] > a[i+1]) swap(a[i], a[i+1]);\n\t}\n\tvector<int> loc(n);\n\tfor(int i = 0; i < n; i++) loc[a[i]] = i;\n\tvector<int> r(n+1, 0);\n\tfor(int i = 0; i <= n; i++) r[i] = n-i;\n\tNode segtree(r, 0, n+2);\n\tint ans = 0;\n\tint min1 = n;\n\tint max0 = n-1;\n\tfor(int i = n-1; i > 0; i--){\n\t\tsegtree.add(loc[i]+1, n+2, 1);\n\t\tsegtree.add(0, loc[i]+1, -1);\n\t\tmin1 = min(min1, loc[i]);\n\t\twhile(a[max0] >= i) max0--;\n\t\tans = max(ans, segtree.query(min1, max0+1));\n\t}\n\treturn 1 + max(ans - 1, 0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor(int& x : a){\n\t\t\tcin >> x;\n\t\t\tx--;\n\t\t}\n\t\tint ans = solve(a);\n\t\tcout << ans << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "sortings"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Strange Sort.json",
    "editorial_link": "https://codeforces.com//blog/entry/94216",
    "editorial": "Let\u00e2\u0080\u0099s draw a wall of towers of cubes, with the -th tower having height .\r\nFor example, for the picture will look as follows ( stands for a cube):\r\nWhen two elements get swapped, their corresponding towers get swapped as\r\nwell.Note that applying to the permutation (swapping and if ) is\r\nequivalent to applying to each row of the above matrix independently\r\n(swapping cells and if the -th cell is and the -th cell is ). Also note\r\nthat in the final state, when the permutation is , each row of the\r\nmatrix is sorted in non-descending order too (\u00e2\u0080\u0099s go before \u00e2\u0080\u0099s), and vice\r\nversa if each row is sorted, the permutation is sorted as well.Thus,\r\nit\u00e2\u0080\u0099s enough to find the number of iterations required to sort each row\r\nof the matrix, and the maximum of these numbers is the answer for the\r\ngiven permutation.The rows of the matrix are for .How to solve the\r\nproblem for a sequence of \u00e2\u0080\u0099s and \u00e2\u0080\u0099s?We can assume that the instances of\r\n\u00e2\u0080\u0099s don\u00e2\u0080\u0099t change their relative order, and the same for \u00e2\u0080\u0099s. Let the\r\npositions of zeros in the initial sequence be . The -th zero from the\r\nleft is moving towards position in the sorted sequence.Let be the number\r\nof steps it takes the -th zero from the left to get to its final\r\nposition .If the -th zero is already in position , then .Otherwise, if ,\r\nnote that , because the -th zero can only get to position after the -th\r\nzero gets to position .Moreover, let there be ones to the left of the\r\n-th zero in the initial sequence. Then , because the has to swap with\r\nevery to the left of it, and also the first iteration is useless if is\r\nodd.It turns out that the -th zero either gets stuck into the -th zero\r\n(and then ), or consistently swaps with \u00e2\u0080\u0099s on each iteration except for\r\nmaybe the first (in which case ).We are interested in . Let the number\r\nof \u00e2\u0080\u0099s at the start of the initial sequence be . It can be seen that ,\r\nand this is exactly the number of iterations required.Recall that we\r\nneed to find the number of iterations for different binary sequences.\r\nHowever, these binary sequences are very similar to each other.Let\u00e2\u0080\u0099s\r\nmaintain the values of for all zeros in a segment tree (and, say, for\r\npositions containing ones). Start with the sequence for that is, a\r\nsequence of all ones. As we increase by one, a single in gets replaced\r\nwith . We can handle these changes using a segment tree with \"range add\"\r\nand \"range max\". The time complexity of the solution is .(Another\r\nequivalent formula is: . Here is the number of \u00e2\u0080\u0099s in ; is the smallest\r\nposition such that ; and is the largest position such that . This\r\nformula can also be proven using induction. In short, consider this\r\nformula applied to the number of iterations the difference is that\r\ninstead of , we sometimes have , depending on the parity of the current\r\niteration number. Consider all positions where the value is maximized.\r\nThen it can be shown that after one iteration the value for all such\r\npositions decreases by : if the parity is incorrect, after one iteration\r\nthe parity becomes correct; otherwise, observe that and , which get\r\nswapped in the next iteration. Moreover, the value for all other\r\npositions has the same parity, increases by at most , and thus doesn\u00e2\u0080\u0099t\r\nbecome too big either.)\r\n"
}