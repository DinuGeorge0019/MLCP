{"link": "https://codeforces.com//contest/1558/problem/F", "problemId": "1088954", "problem_idx": "F", "shortId": "1558F", "contest_number": "1558", "problem_submissions": {"F": [126899482, 126888055, 126902100, 126890640, 126888389, 126894123, 126904590, 126900041, 126902212, 126902942, 127549735, 127006693], "E": [126883583, 126896785, 126884151, 126898148, 126905418, 126902611, 126899238, 126907028, 126907352, 126891363, 126891974, 126891356, 126892061, 126902546, 126900088, 126903655, 126904227, 126900317, 126902700], "D": [126869704, 126870708, 126871179, 126874038, 126874151, 126876731, 126871810, 126867588, 126872511, 126871952, 126882884, 126882215, 126882465, 126878861, 126876122, 126890668, 126874784, 126883630, 126892178, 126890480], "B": [126858181, 126855670, 126854102, 126855872, 126858058, 126860085, 126854841, 126852806, 126853901, 126856718, 126855353, 126856232, 126858032, 126857658, 126854131, 126863721, 126854756, 126864821, 126867061, 126863501], "A": [126854362, 126850555, 126848635, 126848815, 126849088, 126855964, 126848126, 126847884, 126848457, 126849581, 126847772, 126849333, 126852232, 126849014, 126848809, 126853376, 126847687, 126859049, 126849750, 126850402], "C": [126850882, 126858888, 126859482, 126861350, 126866099, 126867225, 126859442, 126858664, 126862495, 126861859, 126865577, 126860578, 126863128, 126865366, 126858535, 126873768, 126863562, 126873408, 126874458, 126871983]}, "name": "F. Strange Sort", "statement": "You have a permutation: an array a = [a_1, a_2,\r\nldots, a_n] of distinct integers from 1 to n. The length of the\r\npermutation n is odd.Consider the following algorithm of sorting the\r\npermutation in increasing order.A helper procedure of the algorithm,\r\nf(i), takes a single argument i (1\r\nle i\r\nle n-1) and does the following. If a_i > a_{i+1}, the values of a_i and\r\na_{i+1} are exchanged. Otherwise, the permutation doesn\u2019t change.The\r\nalgorithm consists of iterations, numbered with consecutive integers\r\nstarting with 1. On the i-th iteration, the algorithm does the\r\nfollowing: if i is odd, call f(1), f(3),\r\nldots, f(n - 2); if i is even, call f(2), f(4),\r\nldots, f(n - 1). It can be proven that after a finite number of\r\niterations the permutation will be sorted in increasing order.After how\r\nmany iterations will this happen for the first time?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = 1e9;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi, mset = inf, madd = 0, val = -inf;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tint query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -inf;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\nint solve(vector<int> a){\n\tint n = (int)a.size();\n\tbool sorted = true;\n\tfor(int i = 0; i < n; i++) if(a[i] != i) sorted = false;\n\tif(sorted){\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i+1 < n; i += 2){\n\t\tif(a[i] > a[i+1]) swap(a[i], a[i+1]);\n\t}\n\tvector<int> loc(n);\n\tfor(int i = 0; i < n; i++) loc[a[i]] = i;\n\tvector<int> r(n+1, 0);\n\tfor(int i = 0; i <= n; i++) r[i] = n-i;\n\tNode segtree(r, 0, n+2);\n\tint ans = 0;\n\tint min1 = n;\n\tint max0 = n-1;\n\tfor(int i = n-1; i > 0; i--){\n\t\tsegtree.add(loc[i]+1, n+2, 1);\n\t\tsegtree.add(0, loc[i]+1, -1);\n\t\tmin1 = min(min1, loc[i]);\n\t\twhile(a[max0] >= i) max0--;\n\t\tans = max(ans, segtree.query(min1, max0+1));\n\t}\n\treturn 1 + max(ans - 1, 0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor(int& x : a){\n\t\t\tcin >> x;\n\t\t\tx--;\n\t\t}\n\t\tint ans = solve(a);\n\t\tcout << ans << '\\n';\n\t}\n}"], "input": "", "output": "", "tags": ["data structures", "sortings"], "dificulty": "3300", "interactive": false}