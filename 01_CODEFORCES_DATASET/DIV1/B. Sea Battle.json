{"link": "https://codeforces.com//contest/737/problem/B", "problemId": "81050", "problem_idx": "B", "shortId": "737B", "contest_number": "737", "problem_submissions": {"D": [22352998, 22361676, 22361660, 22352983, 22352295, 22352107, 22352670, 22355408, 22353859, 22355150, 22355124, 22355580, 22352603, 22354241, 22355135, 22367415, 22354851, 22353195, 22355191, 22354766, 22354567, 22355616, 22355720], "C": [22346894, 22348992, 22348428, 22346364, 22349019, 22347742, 22344273, 22349093, 22344153, 22348276, 22349914, 22349222, 22351285, 22350460, 22350277, 22351065, 22348263, 22347006, 22351260, 22349703], "B": [22345266, 22344047, 22346326, 22344623, 22347286, 22345951, 22346273, 22346654, 22345815, 22347161, 22347731, 22346343, 22348170, 22348193, 22348953, 22349108, 22345433, 22343951, 22343981, 22347679], "A": [22344335, 22346876, 22344812, 22348251, 22345241, 22344610, 22348244, 22344836, 22349514, 22345867, 22345524, 22349952, 22345718, 22346457, 22347708, 22346937, 22344148, 22348610, 22348383, 22345809], "F": [22363265, 22374526], "E": [22411333]}, "name": "B. Sea Battle", "statement": "Galya is playing one-dimensional Sea Battle on a grid. In this game\r\nships are placed on the grid. Each of the ships consists of consecutive\r\ncells. No cell can be part of two ships, however, the ships each\r\nother.Galya doesn\u2019t know the ships location. She can shoot to some cells\r\nand after each shot she is told if that cell was a part of some ship\r\n(this case is called \"hit\") or not (this case is called \"miss\").Galya\r\nhas already made shots, all of them were misses.Your task is to\r\ncalculate the minimum number of cells such that if Galya shoot at all of\r\nthem, she would hit at least one ship.It is guaranteed that there is at\r\nleast one valid ships placement.\r\n", "solutions": ["/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n#include <vector>\n\nusing namespace std;\n\nclass TaskB {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, cnt, len, k;\n\t\tin >> n >> cnt >> len >> k;\n\t\tstring s;\n\t\tin >> s;\n\t\tint cur = 0;\n\t\tint need = 0;\n\t\tvector<int> poses;\n\t\tfor (int i: range(n)) {\n\t\t\tif (s[i] == '1') {\n\t\t\t\tcur = 0;\n\t\t\t} else {\n\t\t\t\t++cur;\n\t\t\t}\n\n\t\t\tif (cur == len) {\n\t\t\t\t++need;\n\t\t\t\tcur = 0;\n\t\t\t\tposes.push_back(i + 1);\n\t\t\t}\n\t\t}\n\t\tout << need - cnt + 1 << \"\\n\";\n\t\tfor (int i: range(need - cnt + 1)) {\n\t\t\tout << poses[i] << \" \";\n\t\t}\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskB solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "implementation", "math"], "dificulty": "1700", "interactive": false}