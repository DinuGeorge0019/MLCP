{
    "link": "https://codeforces.com//contest/1965/problem/F",
    "problemId": "2615000",
    "problem_idx": "F",
    "shortId": "1965F",
    "contest_number": "1965",
    "problem_submissions": {
        "F": [
            258465624,
            258627065,
            263837667,
            258481689
        ],
        "D": [
            258447727,
            258460812,
            258466117,
            258450218,
            258464835,
            258457510,
            258458513,
            258465971,
            259573719,
            258506961,
            258454027,
            258456282,
            258483429,
            258453210,
            258453791
        ],
        "C": [
            258425895,
            258434352,
            258433902,
            258442030,
            258433331,
            258429762,
            258434494,
            258427059,
            258424566,
            258435014,
            258430069,
            258434394,
            258430905,
            258434841,
            258457386,
            258428580,
            258429520,
            258434274
        ],
        "B": [
            258420424,
            258428605,
            258430303,
            258433453,
            258426877,
            258424079,
            258428403,
            258433720,
            259639909,
            258437552,
            258428917,
            258424298,
            258428062,
            258424086,
            258427169,
            258427222,
            258425398,
            258424422,
            258426595
        ],
        "A": [
            258418141,
            258418841,
            258425010,
            258419725,
            258419999,
            258418044,
            258419071,
            258418897,
            258418989,
            258419441,
            258418664,
            258419165,
            258419761,
            258418751,
            258419361,
            258418280,
            258427816,
            258420207
        ],
        "E": [
            258446500,
            258464809,
            258455602,
            258503208,
            258466942,
            258468402,
            258463371,
            258447373,
            258452406,
            258457290,
            258460561,
            258509487,
            258461569,
            302317911,
            258464177,
            258450702,
            258478527
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128914",
    "editorial": "For a segment of days, how can we tell if there\u00e2\u0080\u0099s a way to assign a\r\nlecturer to each day of the segment? Consider a bipartite graph: the\r\nfirst part consists of the days in the segment, the second part consists\r\nof all lecturers, an edge between a day and a lecturer exists if that\r\nlecturer is available on that day. We need to check if the maximum\r\nmatching covers all vertices in the first part. If this is the case,\r\nwe\u00e2\u0080\u0099ll call the segment of days .A common way to check if a segment is\r\nvalid is to use Hall\u00e2\u0080\u0099s marriage theorem. In our case, we can formulate\r\nit as follows: If for each subset of days , the number of lecturers\r\navailable on at least one day of that subset is at least , then this\r\nsegment of days is valid. It might be tempting to only consider subsets\r\nwhich form contiguous subsegments. However, consider the following test\r\ncase: 31 32 22 2For a segment of days , the only subset that violates\r\nthe Hall\u00e2\u0080\u0099s marriage theorem condition is , which is not contiguous.Let\u00e2\u0080\u0099s\r\ntry to fix that.Suppose there are two lecturers with equal : let their\r\navailability segments be and , where . Then, if we replace with , the\r\nanswer does not change. This can be easily seen if you consider the set\r\nof all pairs of days that these two lecturers can cover, and notice that\r\nthis set stays the same after the transformation.(Note that when ,\r\nreplacing with is effectively equivalent to removing one of the\r\nlecturers: their segment becomes empty.)We can keep applying this\r\noperation until all are distinct (potentially removing some lecturers in\r\nthe process). This process can be simulated in time by going left to\r\nright using a priority queue.Why is this transformation useful? Consider\r\na subset of days that violates the Hall\u00e2\u0080\u0099s marriage theorem condition.\r\nSuppose it\u00e2\u0080\u0099s non-contiguous: say, days and () belong to , while none of\r\ndays belong to . Then, if we include days into , then will still violate\r\nthe condition! (proof left as an exercise)As a consequence, if we\r\ninclude all \"gaps\" in , we\u00e2\u0080\u0099ll still get a violating subset, but this\r\ntime, it will be contiguous.We have described a transformation that\r\nmakes all distinct. Similarly, we can apply it in the same way to make\r\nall distinct. After that, we\u00e2\u0080\u0099ll get another useful property:\r\nmonotonicity. Specifically, if is a violating subset, then and are\r\nviolating subsets as well.Now we can see that a segment of days is valid\r\niff it is not a violating subset itself (i.e. instead of checking all\r\nsubsets of the segment, it\u00e2\u0080\u0099s enough to just check the whole segment).To\r\nfinish the solution, we can use the two pointers technique to find all\r\nvalid segments in linear time.: solve the problem for .\r\n",
    "name": "F. Conference",
    "statement": "You have been asked to organize a very important art conference. The\r\nfirst step is to choose the dates.The conference must last for a certain\r\nnumber of consecutive days. Each day, one lecturer must perform, and the\r\nsame lecturer cannot perform more than once.You asked n potential\r\nlecturers if they could participate in the conference. Lecturer i\r\nindicated that they could perform on any day from l_i to r_i inclusive.A\r\ncertain segment of days can be chosen as the conference dates if there\r\nis a way to assign an available lecturer to each day of the segment,\r\nassigning each lecturer to no more than one day.For each k from 1 to n,\r\nfind how many ways there are to choose a segment of k consecutive days\r\nas the conference dates.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;struct DSU {    std::vector<int> f, siz;        DSU() {}    DSU(int n) {        init(n);    }        void init(int n) {        f.resize(n);        std::iota(f.begin(), f.end(), 0);        siz.assign(n, 1);    }        int find(int x) {        while (x != f[x]) {            x = f[x] = f[f[x]];        }        return x;    }        bool same(int x, int y) {        return find(x) == find(y);    }        bool merge(int x, int y) {        x = find(x);        y = find(y);        if (x == y) {            return false;        }        siz[x] += siz[y];        f[y] = x;        return true;    }        int size(int x) {        return siz[find(x)];    }};\u00a0template<class Info, class Tag>struct LazySegmentTree {    int n;    std::vector<Info> info;    std::vector<Tag> tag;    LazySegmentTree() : n(0) {}    LazySegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template<class T>    LazySegmentTree(std::vector<T> init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template<class T>    void init(std::vector<T> init_) {        n = init_.size();        info.assign(4 << std::__lg(n), Info());        tag.assign(4 << std::__lg(n), Tag());        std::function<void(int, int, int)> build = [&](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void apply(int p, const Tag &v) {        info[p].apply(v);        tag[p].apply(v);    }    void push(int p) {        apply(2 * p, tag[p]);        apply(2 * p + 1, tag[p]);        tag[p] = Tag();    }    void modify(int p, int l, int r, int x, const Info &v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        push(p);        if (x < m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l >= y || r <= x) {            return Info();        }        if (l >= x && r <= y) {            return info[p];        }        int m = (l + r) / 2;        push(p);        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {        if (l >= y || r <= x) {            return;        }        if (l >= x && r <= y) {            apply(p, v);            return;        }        int m = (l + r) / 2;        push(p);        rangeApply(2 * p, l, m, x, y, v);        rangeApply(2 * p + 1, m, r, x, y, v);        pull(p);    }    void rangeApply(int l, int r, const Tag &v) {        return rangeApply(1, 0, n, l, r, v);    }    template<class F>    int findFirst(int p, int l, int r, int x, int y, F &&pred) {        if (l >= y || r <= x) {            return -1;        }        if (l >= x && r <= y && !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        push(p);        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template<class F>    int findFirst(int l, int r, F &&pred) {        return findFirst(1, 0, n, l, r, pred);    }    template<class F>    int findLast(int p, int l, int r, int x, int y, F &&pred) {        if (l >= y || r <= x) {            return -1;        }        if (l >= x && r <= y && !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        push(p);        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template<class F>    int findLast(int l, int r, F &&pred) {        return findLast(1, 0, n, l, r, pred);    }};\u00a0struct Tag {    int add = 0;    void apply(Tag t) {        add += t.add;    }};\u00a0struct Info {    int min = 0;    void apply(Tag t) {        min += t.add;    }};\u00a0Info operator+(const Info &a, const Info &b) {    return {std::min(a.min, b.min)};}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n;    std::cin >> n;        int m = 0;    std::vector<int> l(n), r(n);    for (int i = 0; i < n; i++) {        std::cin >> l[i] >> r[i];        l[i]--;        m = std::max(m, r[i]);    }        std::vector<int> p(n);    std::iota(p.begin(), p.end(), 0);    std::sort(p.begin(), p.end(),        [&](int i, int j) {            return r[i] < r[j];        });        DSU dsu(m + 1);    std::vector<int> match(m, -1);    for (auto i : p) {        int x = dsu.find(l[i]);        if (x < r[i]) {            match[x] = r[i];            dsu.merge(x + 1, x);        }    }        std::vector<int> ans(n + 1);    LazySegmentTree<Info, Tag> seg(m);        std::multiset<int> mset;    for (int l = 0, r = 0; l < m; l++) {        if (r < l) {            r = l;        }        while (r < m && match[r] != -1) {            seg.rangeApply(match[r] - 1, m, {-1});            mset.insert(match[r] - 1);            seg.rangeApply(r, m, {1});            r++;        }        ans[std::min(r - l, n)]++;        if (r > l && r < m) {            seg.rangeApply(l, r, {-1});            if (seg.rangeQuery(0, m).min < 0) {                seg.rangeApply(r, m, {-1});                seg.rangeApply(*mset.begin(), m, {1});                mset.erase(mset.begin());            } else {                r++;            }        }    }        for (int i = n - 1; i >= 0; i--) {        ans[i] += ans[i + 1];    }    for (int i = 1; i <= n; i++) {        std::cout << ans[i] << \"\\n\";    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "flows"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Conference.json"
}