{"link": "https://codeforces.com//contest/585/problem/E", "problemId": "37968", "problem_idx": "E", "shortId": "585E", "contest_number": "585", "problem_submissions": {"E": [13568408, 13565539, 13570428, 13569433, 13562876, 13568414, 13569561, 13572183, 16851653, 13569075, 13575618, 14433103, 14433079, 13586801, 14994906], "D": [13563803, 13560460, 13565708, 13598452, 13575351, 13570446, 13565845, 13564574, 13569714, 13567701, 13566576, 13567580, 13566498, 13559261, 13566963, 13566457, 13569728, 13568576], "C": [13561640, 13569007, 13569377, 13560848, 13567147, 13570951, 13564734, 13564195, 13562727, 13563205, 13570079, 13563945, 13564180, 13570698, 13565134, 13564377], "B": [13558808, 13566721, 13560966, 13559388, 13575429, 13561963, 13558427, 13563703, 16850949, 13561366, 13561440, 13558802, 13567542, 13562248, 13560363, 13561318, 13562539], "A": [13556266, 13558452, 13556785, 13558546, 13586871, 13556142, 16850921, 13556990, 13562212, 13561943, 13585791, 13560017, 13556037, 13558619, 13558552], "F": [13587655, 13575255, 13575217, 16850828, 24552744, 14433355]}, "name": "E. Present for Vitalik the Philatelist ", "statement": "Vitalik the philatelist has a birthday today!As he is a regular customer\r\nin a stamp store called \u2019Robin Bobin\u2019, the store management decided to\r\nmake him a gift.Vitalik wants to buy one stamp and the store will give\r\nhim a non-empty set of the remaining stamps, such that the greatest\r\ncommon divisor (GCD) of the price of the stamps they give to him is more\r\nthan one. If the GCD of prices of the purchased stamp and prices of\r\npresent stamps set will be equal to , then Vitalik will leave the store\r\ncompletely happy.The store management asks you to count the number of\r\ndifferent situations in which Vitalik will leave the store completely\r\nhappy. Since the required number of situations can be very large, you\r\nneed to find the remainder of this number modulo . The situations are\r\ndifferent if the stamps purchased by Vitalik are different, or if one of\r\nthe present sets contains a stamp that the other present does not\r\ncontain.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = (ll)1e9 + 7;\nconst int N = (int)1e7 + 10;\nint a[N];\nint mu[N];\nll pow2[N];\n\nll add(ll x, ll y)\n{\n    x += y;\n    if (x >= MOD) return x - MOD;\n    return x;\n}\nll sub(ll x, ll y)\n{\n    x -= y;\n    if (x < 0) return x + MOD;\n    return x;\n}\nll mult(ll x, ll y)\n{\n    return (x * y) % MOD;\n}\n\nint main()\n{\n//  freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n\n    pow2[0] = 1;\n    for (int i = 1; i < N; i++)\n        pow2[i] = add(pow2[i - 1], pow2[i - 1]);\n    for (int i = 2; i < N; i++)\n    {\n        mu[i]++;\n        for (int j = 2 * i; j < N; j += i)\n            mu[j] -= mu[i];\n    }\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        a[x]++;\n    }\n    ll A = 0;\n    for (int d = 2; d < N; d++)\n    {\n        if (mu[d] == 0) continue;\n        int c = 0;\n        for (int i = d; i < N; i += d)\n            c += a[i];\n        if (c == 0) continue;\n        if (mu[d] == 1)\n            A = add(A, mult(n - c, sub(pow2[c], 1)));\n        else\n            A = sub(A, mult(n - c, sub(pow2[c], 1)));\n    }\n    printf(\"%lld\\n\", A);\n\n    return 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "math", "number theory"], "dificulty": "2900", "interactive": false}