{
    "link": "https://codeforces.com//contest/585/problem/E",
    "problemId": "37968",
    "problem_idx": "E",
    "shortId": "585E",
    "contest_number": "585",
    "problem_submissions": {
        "E": [
            13568408,
            13565539,
            13570428,
            13569433,
            13562876,
            13568414,
            13569561,
            13572183,
            16851653,
            13569075,
            13575618,
            14433103,
            14433079,
            13586801,
            14994906
        ],
        "D": [
            13563803,
            13560460,
            13565708,
            13598452,
            13575351,
            13570446,
            13565845,
            13564574,
            13569714,
            13567701,
            13566576,
            13567580,
            13566498,
            13559261,
            13566963,
            13566457,
            13569728,
            13568576
        ],
        "C": [
            13561640,
            13569007,
            13569377,
            13560848,
            13567147,
            13570951,
            13564734,
            13564195,
            13562727,
            13563205,
            13570079,
            13563945,
            13564180,
            13570698,
            13565134,
            13564377
        ],
        "B": [
            13558808,
            13566721,
            13560966,
            13559388,
            13575429,
            13561963,
            13558427,
            13563703,
            16850949,
            13561366,
            13561440,
            13558802,
            13567542,
            13562248,
            13560363,
            13561318,
            13562539
        ],
        "A": [
            13556266,
            13558452,
            13556785,
            13558546,
            13586871,
            13556142,
            16850921,
            13556990,
            13562212,
            13561943,
            13585791,
            13560017,
            13556037,
            13558619,
            13558552
        ],
        "F": [
            13587655,
            13575255,
            13575217,
            16850828,
            24552744,
            14433355
        ]
    },
    "name": "E. Present for Vitalik the Philatelist ",
    "statement": "Vitalik the philatelist has a birthday today!As he is a regular customer\r\nin a stamp store called \u2019Robin Bobin\u2019, the store management decided to\r\nmake him a gift.Vitalik wants to buy one stamp and the store will give\r\nhim a non-empty set of the remaining stamps, such that the greatest\r\ncommon divisor (GCD) of the price of the stamps they give to him is more\r\nthan one. If the GCD of prices of the purchased stamp and prices of\r\npresent stamps set will be equal to , then Vitalik will leave the store\r\ncompletely happy.The store management asks you to count the number of\r\ndifferent situations in which Vitalik will leave the store completely\r\nhappy. Since the required number of situations can be very large, you\r\nneed to find the remainder of this number modulo . The situations are\r\ndifferent if the stamps purchased by Vitalik are different, or if one of\r\nthe present sets contains a stamp that the other present does not\r\ncontain.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = (ll)1e9 + 7;\nconst int N = (int)1e7 + 10;\nint a[N];\nint mu[N];\nll pow2[N];\n\nll add(ll x, ll y)\n{\n    x += y;\n    if (x >= MOD) return x - MOD;\n    return x;\n}\nll sub(ll x, ll y)\n{\n    x -= y;\n    if (x < 0) return x + MOD;\n    return x;\n}\nll mult(ll x, ll y)\n{\n    return (x * y) % MOD;\n}\n\nint main()\n{\n//  freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n\n    pow2[0] = 1;\n    for (int i = 1; i < N; i++)\n        pow2[i] = add(pow2[i - 1], pow2[i - 1]);\n    for (int i = 2; i < N; i++)\n    {\n        mu[i]++;\n        for (int j = 2 * i; j < N; j += i)\n            mu[j] -= mu[i];\n    }\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        a[x]++;\n    }\n    ll A = 0;\n    for (int d = 2; d < N; d++)\n    {\n        if (mu[d] == 0) continue;\n        int c = 0;\n        for (int i = d; i < N; i += d)\n            c += a[i];\n        if (c == 0) continue;\n        if (mu[d] == 1)\n            A = add(A, mult(n - c, sub(pow2[c], 1)));\n        else\n            A = sub(A, mult(n - c, sub(pow2[c], 1)));\n    }\n    printf(\"%lld\\n\", A);\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "number theory"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Present for Vitalik the Philatelist .json",
    "editorial_link": "https://codeforces.com//blog/entry/20898",
    "editorial": "The problem has been prepared by gridnevvvit. Let\u00e2\u0080\u0099s calculate the number\r\nof subsets with gcd equal to value A. Let\u00e2\u0080\u0099s do that using principle of\r\ninclusions-exclusions: firstly we say that all subsets is good. The\r\ntotal number of subsets is equal to . Now let\u00e2\u0080\u0099s subtract subsets with\r\ngcd divisible by . The number of that subsets is equal to ( is the\r\nnumber of numbers that is divisable by ). Next we should subtract .\r\nSubsets with gcd divisible by we already counted with number two. Next\r\nwe should subtract . Now we should notice that subsets with gcd\r\ndivisible by we already processed twice: firstly with number , then with\r\n, so let\u00e2\u0080\u0099s add the number of these subsets . If we continue this process\r\nwe will get, that for all numbers we should add the value , where is\r\nequals to , if is divisible by square of some prime, , if the number of\r\nprimes in factorization of is even and in other case. So the numbers\r\nthat is divisible by square of some prime we can ignore, because they\r\nhave coefficient . To calculate values we should factorize all numbers\r\nand iterate over divisors with value . Now it\u00e2\u0080\u0099s easy to see, that the\r\nnumber of subsets with gcd greater than equals to . To solve the problem\r\nlet\u00e2\u0080\u0099s fix the stamp that Vitaliy will buy . Let\u00e2\u0080\u0099s recalculate the number\r\nfor array a without element . To do that we should only subtract those\r\nterms that was affected by number . We can do that in , where is the\r\nnumber of primes in factorization of the number . It\u00e2\u0080\u0099s easy to see that\r\nonly the subsets with gcd greater than , but not divisible by any\r\ndivisor of , should we counted in answer. To calculate number of those\r\nsubsets let\u00e2\u0080\u0099s again use the principle of inclusions-exclusions. For\r\nevery divisor of let\u00e2\u0080\u0099s subtract the value from . So now we got the\r\nnumber of subsets with gcd greater than , but coprime with . The answer\r\nto problem is the sum over all . The maximum number of primes in\r\nfactorization of number not greater than is equal to . We can factorize\r\nall numbers from to in linear time by algorithm for finding the smallest\r\ndivisors for all intergers from to , or by sieve of Eratosthenes in\r\ntime. Complexity: , where , is the largest number of primes in\r\nfactorization of .\r\n"
}