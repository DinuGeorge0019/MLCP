{"link": "https://codeforces.com//contest/1446/problem/B", "problemId": "797256", "problem_idx": "B", "shortId": "1446B", "contest_number": "1446", "problem_submissions": {"D2": [98488179, 98479602, 98464320, 98467493, 98464495, 98464291, 98477056, 98482171, 98496133, 98469225, 98470769, 98488185, 98481918, 98482926, 98479038], "F": [98482236, 98470414, 98500090, 98497700, 98476856, 98476210, 98484136, 98489678, 98481827, 98491554, 98484171, 98504348, 98502497, 98493379, 98482100, 98486768, 98492674, 98490163, 98501084], "E": [98475344, 98498258, 98500804, 98495217, 115705388, 106404746], "D1": [98457158, 98460382, 98456556, 98456978, 98464440, 98464426, 98466567, 98470196, 98464176, 98472990, 98478320, 98479479, 98482287, 98493368, 98460232, 98466662, 98460275, 98466691, 98472979, 98478998], "C": [98450996, 98452840, 98450218, 98453943, 98450946, 98452214, 98452223, 98455447, 98455497, 98455239, 98461758, 98461392, 98466665, 98466780, 98453580, 98454283, 98455611, 98457408, 98454698, 98458074], "B": [98446682, 98448334, 98447974, 98447142, 98452896, 98448193, 98448567, 98451491, 98449697, 98450934, 98454616, 98452183, 98446811, 98455267, 98447295, 98450250, 98449344, 98450158, 98450376, 98449480], "A": [98444992, 98445944, 98444925, 98445065, 98445347, 98445666, 98444771, 98446535, 98446420, 98447534, 98447441, 98445935, 98450208, 98461593, 98445099, 98445257, 98445487, 98446333, 98447509, 98445254]}, "name": "B. Catching Cheaters", "statement": "You are given two strings A and B representing essays of two students\r\nwho are suspected cheaters. For any two strings C, D we define their\r\nsimilarity score S(C,D) as 4\r\ncdot LCS(C,D) - |C| - |D|, where LCS(C,D) denotes the length of the\r\nLongest Common of strings C and D. You believe that only some part of\r\nthe essays could have been copied, therefore you\u2019re interested in their\r\n.Calculate the maximal similarity score over all pairs of substrings.\r\nMore formally, output maximal S(C, D) over all pairs (C, D), where C is\r\nsome substring of A, and D is some substring of B. If X is a string, |X|\r\ndenotes its length.A string a is a of a string b if a can be obtained\r\nfrom b by deletion of several (possibly, zero or all) characters from\r\nthe beginning and several (possibly, zero or all) characters from the\r\nend.A string a is a of a string b if a can be obtained from b by\r\ndeletion of several (possibly, zero or all) characters. Pay attention to\r\nthe difference between the and , as they both appear in the problem\r\nstatement. You may wish to read the Wikipedia page about the Longest\r\nCommon Subsequence problem.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 5050;\nint n, m;\nint dp[N][N];\nchar a[N], b[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s %s\", a, b);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j] - 1);\n\t\t\tdp[i][j + 1] = max(dp[i][j + 1], dp[i][j] - 1);\n\t\t\tif (a[i] == b[j])\n\t\t\t\tdp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + 2);\n\t\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= m; j++)\n\t\t\tans = max(ans, dp[i][j]);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "strings"], "dificulty": "1800", "interactive": false}