{"link": "https://codeforces.com//contest/848/problem/B", "problemId": "120617", "problem_idx": "B", "shortId": "848B", "contest_number": "848", "problem_submissions": {"D": [29984461, 29984526, 29990531, 29990452, 29983235, 29986841, 30011180, 30054712, 29986436, 29991292, 29988130, 30025667], "C": [29981953, 29979998, 29991414, 29985145, 29986831, 29981161, 30023429, 30739183, 30739016, 29983074, 29985177, 29986148, 29992066, 29984922, 29985048, 30004311, 29986150, 29985850, 29985839, 29985353, 29988848], "B": [29977726, 29987077, 29983009, 29978119, 29977288, 29977302, 29978411, 29979022, 29978648, 29977708, 29980992, 29981154, 29978110, 29977941, 29980264, 29977663, 29981248, 29982355, 29978027], "A": [29975110, 29976090, 29975270, 29974910, 29974992, 29974976, 29975582, 29975367, 29976038, 29974917, 29976913, 29976388, 29974989, 29978589, 29977088, 29975038, 29977707, 29977980, 29974970], "E": [31234259]}, "name": "B. Rooter s Song", "statement": "On a Cartesian coordinate plane lies a rectangular stage of size ,\r\nrepresented by a rectangle with corners , , and . It can be seen that no\r\ncollisions will happen before one enters the stage.On the sides of the\r\nstage stand dancers. The -th of them falls into one of the following\r\ngroups: : stands at , moves in positive direction (upwards); : stands at\r\n, moves in positive direction (rightwards). According to choreography,\r\nthe -th dancer should stand still for the first milliseconds, and then\r\nstart moving in the specified direction at unit per millisecond, until\r\nanother border is reached. It is guaranteed that no two dancers have the\r\nsame group, position and waiting time at the same time.When two dancers\r\ncollide (i.e. are on the same point at some time when both of them are\r\nmoving), they immediately exchange their moving directions and go on.\r\nDancers stop when a border of the stage is reached. Find out every\r\ndancer\u2019s stopping position.\r\n", "solutions": ["#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>\n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nmap <int, int> Mx;\nint ch(int x) {\n\tif (Mx.count(x)) return Mx[x];\n\tint t = Mx.size();\n\treturn Mx[x] = t + 1;\n}\n\nmap <pair<int, pii>, int> Mch;\nvector <pii> Vin[200050];\n\nint ans[200050][2];\nint main() {\n\tint N, W, H, i, j;\n\tscanf(\"%d %d %d\", &N, &W, &H);\n\tfor (i = 1; i <= N; i++) {\n\t\tint t1, t2, t3;\n\t\tscanf(\"%d %d %d\", &t1, &t2, &t3);\n\t\tint x = ch(t3 - t2);\n\t\tVin[x].emplace_back(t1, t2);\n\n\t\tMch[mp(x, pii(t1, t2))] = i;\n\t}\n\n\tfor (i = 1; i <= Mx.size(); i++) {\n\t\tsort(all(Vin[i]), [](pii a, pii b) {\n\t\t\tif (a.first != b.first) return a.first == 2;\n\t\t\telse if (a.first == 2) return a.second > b.second;\n\t\t\telse return a.second < b.second;\n\t\t});\n\t\t\n\t\tvector <pii> Va;\n\t\tfor (auto it : Vin[i]) if (it.first == 1) Va.emplace_back(it.second, H);\n\t\tfor (auto it : Vin[i]) if (it.first == 2) Va.emplace_back(W, it.second);\n\n\t\tfor (j = 0; j < Vin[i].size(); j++) {\n\t\t\tint x = Mch[mp(i, Vin[i][j])];\n\t\t\tans[x][0] = Va[j].first, ans[x][1] = Va[j].second;\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) printf(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "geometry", "implementation", "sortings", "two pointers"], "dificulty": "1900", "interactive": false}