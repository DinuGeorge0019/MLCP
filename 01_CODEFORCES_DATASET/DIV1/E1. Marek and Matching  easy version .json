{
    "link": "https://codeforces.com//contest/1229/problem/E1",
    "problemId": "419079",
    "problem_idx": "E1",
    "shortId": "1229E1",
    "contest_number": "1229",
    "problem_submissions": {
        "E2": [
            66535857,
            61153989,
            61162985,
            61167725,
            61164541,
            61175914,
            73169874,
            73169292,
            67251679,
            61176348,
            61171644,
            61168314,
            61282274
        ],
        "C": [
            61156990,
            61139280,
            61133462,
            61168973,
            61144252,
            61152507,
            61152114,
            61139574,
            61138824,
            61139511,
            61146010,
            61154268,
            61140423,
            61146503,
            61146999,
            61163280,
            61145517,
            61140699
        ],
        "E1": [
            61153988,
            61160360,
            61157052,
            61164602,
            61165567,
            61168930,
            61169365,
            61171555,
            61161774,
            61282244,
            91100857
        ],
        "D": [
            61143107,
            61152425,
            61148639,
            61156853,
            61153552,
            61162885,
            61162936,
            61151975,
            61157442,
            61157392,
            61156341,
            61210834,
            61160744,
            61159221,
            61160510,
            61155666,
            61165039,
            61163062
        ],
        "B": [
            61128405,
            61132933,
            61165615,
            61142364,
            61131741,
            61140527,
            61129638,
            61133794,
            61131083,
            61134616,
            61139186,
            61132543,
            61141781,
            61139438,
            61135873,
            61137164,
            61151652
        ],
        "A": [
            61122880,
            61126193,
            61123596,
            61131920,
            61125660,
            61128699,
            61125244,
            61171108,
            61124176,
            61136192,
            61128585,
            61129134,
            61124511,
            61133577,
            61132336,
            61124059,
            61130617,
            61131139
        ],
        "F": [
            61198842,
            61176125,
            61453900,
            61180269,
            61179508,
            61398042
        ]
    },
    "name": "E1. Marek and Matching  easy version ",
    "statement": "Marek is working hard on creating strong testcases to his new\r\nalgorithmic problem. You want to know what it is? Nah, we’re not telling\r\nyou. However, we can tell you how he generates the testcases.Marek\r\nchooses an integer n and n^2 integers p_{ij} (1\r\nle i\r\nle n, 1\r\nle j\r\nle n). He then generates a random bipartite graph with 2n vertices.\r\nThere are n vertices on the left side:\r\nell_1,\r\nell_2,\r\ndots,\r\nell_n, and n vertices on the right side: r_1, r_2,\r\ndots, r_n. For each i and j, he puts an edge between vertices\r\nell_i and r_j with probability p_{ij} percent.It turns out that the\r\ntests will be strong only if a perfect matching exists in the generated\r\ngraph. What is the probability that this will occur?It can be shown that\r\nthis value can be represented as\r\nfrac{P}{Q} where P and Q are coprime integers and Q\r\nnot\r\nequiv 0\r\npmod{10^9+7}. Let Q^{-1} be an integer for which Q\r\ncdot Q^{-1}\r\nequiv 1\r\npmod{10^9+7}. Print the value of P\r\ncdot Q^{-1} modulo 10^9+7.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = 7;\nconst int M = (1 << N) + 1;\nint ppc[M];\nint idInPpc[M];\nvector<int> maskForPpc[N + 1];\nll trans[N + 1][M][M];\nint n;\nunordered_map<ll, ll> dp[N + 1];\nll A[N][N];\n\nvoid precalc() {\n\tfor (int mask = 1; mask < (1 << n); mask++)\n\t\tppc[mask] = ppc[mask >> 1] + (mask & 1);\n\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\tint k = ppc[mask];\n\t\tidInPpc[mask] = (int)maskForPpc[k].size();\n\t\tmaskForPpc[k].push_back(mask);\n\t}\n\tfor (int k = 0; k <= n; k++)\n\t\tfor (int i = 0; i < (int)maskForPpc[k].size(); i++) {\n\t\t\tint inM = maskForPpc[k][i];\n\t\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\t\tll res = 0;\n\t\t\t\tif ((mask & inM) == mask) continue;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (((mask >> v) & 1) == 0) continue;\n\t\t\t\t\tif ((inM >> v) & 1) continue;\n\t\t\t\t\tint nmask = inM | (1 << v);\n\t\t\t\t\tres |= 1LL << idInPpc[nmask];\n\t\t\t\t}\n\t\t\t\ttrans[k][i][mask] = res;\n\t\t\t}\n\t\t}\n}\n\nvoid read() {\n/*\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tA[i][j] = rng() % 1000;\n\treturn;\n*/\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%lld\", &A[i][j]);\n\t\t\tA[i][j] = mult(A[i][j], rev(100));\n\t\t}\n\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tprecalc();\n\tread();\n\tdp[0][1] = 1;\n\tfor (int k = 0; k < n; k++)\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\tll W = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\tW = mult(W, A[k][i]);\n\t\t\t\telse\n\t\t\t\t\tW = mult(W, sub(1, A[k][i]));\n\t\t\t}\n\t\t\tfor (pll s : dp[k]) {\n\t\t\t\tll zmask = s.first, val = s.second;\n\t\t\t\tll nmask = 0;\n\t\t\t\tfor (int i = 0; i < (int)maskForPpc[k].size(); i++) {\n\t\t\t\t\tif ((zmask >> i) & 1)\n\t\t\t\t\t\tnmask |= trans[k][i][mask];\n\t\t\t\t}\n\t\t\t\tif (nmask == 0) continue;\n\t\t\t\tval = mult(val, W);\n\t\t\t\tdp[k + 1][nmask] = add(dp[k + 1][nmask], val);\n\t\t\t}\n\t\t}\n\tprintf(\"%lld\\n\", dp[n][1]);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "probabilities"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E1. Marek and Matching  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/70008",
    "editorial": "Letâs first discuss one of possible solutions for the easy subtask.Letâs\r\nassume that (all smaller âs can be easily reduced to this case). There\r\nare two layers of vertices: left and right . Letâs do meet-in-the-middle\r\non the right layer: and .Consider two parts of the graph: between and ,\r\nand between and . Each of them has edges, so we can try all subsets of\r\nedges in each of them separately. For each such subset: Compute the\r\nprobability that weâll generate exactly this subset of edges. Find all\r\n-element subsets of which can match perfectly with the currently\r\nconsidered half of . This can be done easily in time.Now, hereâs a trick\r\nthere are only three-element subsets of ! Therefore, for each -element\r\nmask , we can find: the probability that the set of three-element\r\nsubsets of matching perfectly with is exactly , the probability that the\r\nset of three-element subsets of whose match perfectly with is exactly .\r\nLetâs find the probability that there is no perfect matching in the\r\ngraph. We can see that itâs where and are -element masks. This can be\r\nsolved easily using SOS dynamic programming technique. If we let , then\r\nthe required sum is where .Therefore, this algorithm allows us to solve\r\nthe easy version of the problem in time.\r\n",
    "hint": []
}