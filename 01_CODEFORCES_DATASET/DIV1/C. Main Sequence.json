{"link": "https://codeforces.com//contest/286/problem/C", "problemId": "2767", "problem_idx": "C", "shortId": "286C", "contest_number": "286", "problem_submissions": {"E": [3390546, 3391792, 3395790, 3391048, 3391288, 3390752, 3393756, 3405899, 3968761, 3584732, 3395321, 3395288, 3395060, 17994831, 3469466, 3469320], "D": [3389279, 3388966, 3389901, 3389906, 3391845, 3389722, 3392796, 3388857, 3395013, 3392782, 3391848, 3410751], "C": [3387722, 3387213, 3387005, 3386396, 3389739, 3391778, 3386453, 3386344, 3393851, 3387073, 3388380, 3388932, 3386042, 3389551, 3388553, 3389696, 3389128], "B": [3386275, 3386079, 3392121, 3386991, 3387709, 3390895, 3385630, 3385043, 3386200, 3386745, 3386272, 3387033, 3387460, 3387793, 3388156], "A": [3385050, 3384757, 3384907, 3384734, 3386122, 3385898, 3384517, 3384557, 3387291, 3384991, 3385549, 3387419, 3387088, 3385205, 3386011, 3386619, 3386427]}, "name": "C. Main Sequence", "statement": "As you know, Vova has recently become a new shaman in the city of Ultima\r\nThule. So, he has received the shaman knowledge about the correct\r\nbracket sequences. The shamans of Ultima Thule have been using lots of\r\ndifferent types of brackets since prehistoric times. A bracket type is a\r\npositive integer. The shamans define a correct bracket sequence as\r\nfollows: An empty sequence is a correct bracket sequence. If and are\r\ncorrect bracket sequences, then sequence (their concatenation) also is a\r\ncorrect bracket sequence. If is a correct bracket sequence, then\r\nsequence also is a correct bracket sequence, where is an integer. For\r\nexample, sequences and are correct bracket sequences, and is\r\nnot.Moreover, after Vova became a shaman, he learned the correct bracket\r\nsequence , consisting of integers. As sequence is the most important,\r\nVova decided to encrypt it just in case.Encrypting consists of two\r\nsequences. The first sequence contains types of brackets, that is, ().\r\nThe second sequence contains integers (possibly, not all of them), which\r\nhad negative numbers in sequence .Unfortunately, Vova forgot the main\r\nsequence. But he was lucky enough to keep the encryption: sequences and\r\n. Help Vova restore sequence by the encryption. If there are multiple\r\nsequences that correspond to the encryption, restore any of them. If\r\nthere are no such sequences, you should tell so.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nint src[1100000];\nint res[1100000];\nint st[1100000];\n\nint main() {\n#ifdef __ASD__\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\twhile(cin>>n){\n\t\tforn(i,n){\n\t\t\tscanf(\"%d\",src+i);\n\t\t}\n\t\tint m;\n\t\tcin>>m;\n\t\tforn(i,m){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\t--a;\n\t\t\tsrc[a]*=-1;\n\t\t}\n\t\treverse(src,src+n);\n\t\tint p=0;\n\t\tbool ok=true;\n\t\tforn(i,n){\n\t\t\tint v=src[i];\n\t\t\tif(v>0 && (!p || st[p-1]!=v))\n\t\t\t\tv=-v;\n\t\t\tres[i]=v;\n\t\t\tif(v>0)\n\t\t\t\t--p;\n\t\t\telse\n\t\t\t\tst[p++]=-v;\n\t\t}\n\t\tif(p)\n\t\t\tok=false;\n\t\tif(!ok){\n\t\t\tcout<<\"NO\"<<'\\n';\n\t\t\tcontinue;\n\t\t}\n\t\treverse(res,res+n);\n\t\tcout<<\"YES\\n\";\n\t\tforn(i,n){\n\t\t\tprintf(\"%d \",res[i]);\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["greedy", "implementation"], "dificulty": "2100", "interactive": false}