{
    "link": "https://codeforces.com//contest/1067/problem/E",
    "problemId": "242831",
    "problem_idx": "E",
    "shortId": "1067E",
    "contest_number": "1067",
    "problem_submissions": {
        "E": [
            44797063,
            44801350,
            44801345,
            44800256,
            44807009,
            44795862,
            44802107,
            44801174,
            44802534,
            44808036,
            44807819,
            44808903,
            44813776,
            44808812,
            44823059,
            44822826
        ],
        "C": [
            44791919,
            44798705,
            44789846,
            45703244,
            44817690,
            44796737,
            44821755,
            44819508,
            44819482,
            44798809,
            44800641
        ],
        "B": [
            44785395,
            44790831,
            44786324,
            44787984,
            44813565,
            44800421,
            44789408,
            44792434,
            44795239,
            44792208,
            44793600,
            44795334,
            44790580,
            44792571,
            44793492,
            44790971,
            44785468,
            44794434
        ],
        "A": [
            44781795,
            44784467,
            44782825,
            44782486,
            44802955,
            44788563,
            44785068,
            44786748,
            44791948,
            44785790,
            44788019,
            44787518,
            44785264,
            44787093,
            44892470,
            44785358,
            44786648,
            44792812,
            44788577
        ],
        "D": [
            44810645,
            44811277,
            59968450,
            44830180,
            44927930,
            44819755,
            44819681,
            44819351,
            44807988,
            44804123
        ]
    },
    "name": "E. Random Forest Rank",
    "statement": "Let’s define rank of undirected graph as rank of its adjacency matrix in\r\nmathbb{R}^{n\r\ntimes n}.Given a tree. Each edge of this tree will be deleted with\r\nprobability 1/2, all these deletions are independent. Let E be the\r\nexpected rank of resulting forest. Find E\r\ncdot 2^{n-1} modulo 998244353 (it is easy to show that E\r\ncdot 2^{n-1} is an integer).\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=500*1007;\nconst ll mod=998244353;\n\nint n;\nvi graf[nax];\n\npll dp[nax][2];\npll pom[2];\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nvoid lacz(int v, int w)\n{\n\tfor (int i=0; i<2; i++)\n\t{\n\t\tpom[i]=dp[v][i];\n\t\tdp[v][i]=dp[0][0];\n\t}\n\tfor (int i=0; i<2; i++)\n\t{\n\t\tfor (int j=0; j<2; j++)\n\t\t{\n\t\t\tfor (int l=0; l<2; l++)\n\t\t\t{\n\t\t\t\tif (i || j || l)\n\t\t\t\t{\n\t\t\t\t\tdod(dp[v][i].first, pom[i].first*dp[w][j].first);\n\t\t\t\t\tdod(dp[v][i].second, pom[i].first*dp[w][j].second+dp[w][j].first*pom[i].second);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdod(dp[v][1].first, pom[i].first*dp[w][j].first);\n\t\t\t\t\tdod(dp[v][1].second, pom[i].first*dp[w][j].second+dp[w][j].first*pom[i].second+pom[i].first*dp[w][j].first*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int oj)\n{\n\tdp[v][0]={1, 0};\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t\tcontinue;\n\t\tdfs(i, v);\n\t\tlacz(v, i);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tprintf(\"%lld\\n\", (dp[1][0].second+dp[1][1].second)%mod);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graph matchings",
        "math",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Random Forest Rank.json",
    "editorial_link": "https://codeforces.com/blog/entry/62688",
    "editorial": "Iâll try to explain how to come up with this solution rather than just\r\nstate the fact. For those who are more interested in getting AC, here is\r\nyour fact: rank of a forest is twice the size of maximal matching.When\r\nwe see expected value, we usually want to somehow rewrite the thing\r\nunder the expected value, apply linearity of expectation and then\r\ncalculate some independent values. But thatâs not the case: rank behave\r\nstrangely and we cannot rewrite it as sum of something, at least I donât\r\nknow any such solutions (if you do, please write them in the comments).\r\nSo it looks like we are forced to what rank is.The rank of a matrix is a\r\nsize of its largest non-vanishing minor. But our matrix is symmetric,\r\nmaybe we can look only at symmetric minors (in a sense that we use the\r\nsame set of rows and columns)? This is actually true but it is just a\r\nfact from linear algebra (seems to be not very well known) and has\r\nlittle to do with our problem, so Iâll drop its proof and if someone is\r\ninterested, ask me in comments.Why do we like symmetric minors? Because\r\nthey correspond to induced subgraphs of our graph. And all induced\r\nsubgraphs of a forest are forests too! So letâs study when a forest has\r\nfull rank.To do it, letâs calculate determinant of its matrix. Matrix\r\nhas full rank iff its determinant is non-zero. Letâs write a determinant\r\nas a sum over all permutations.If then we have edge in our forest. Each\r\npermutation is a product of independent cycles. So to have non-zero\r\nproduct all the permutation cycles should be cycles in the forest. But\r\nforests have no cycles without repeating vertices! Well, actually they\r\ndo: each edge generate one cycle of length . And thatâs all, there are\r\nno other cycles in forest ( vertex is not a cycle, because we donât have\r\nself-loops). To have non-zero product all cycles of permutation must\r\nhave length and correspond to edges of forest. So we can divide all\r\nvertices in pairs, and in each pair there is an edge. Thatâs the\r\ndefinition of perfect matching. Why canât they still result in zero sum?\r\nBecause if there is a perfect matching in a forest then it is unique, so\r\nwe actually have no more than one non-zero summand.OK, forest has full\r\nrank is equivalent to forest has perfect matching. Suppose that is the\r\nsize of maximal matching of a forest. Then no its induced subgraph of\r\nsize strictly greater than can have perfect matching. And there is a\r\nsubgraph of size exactly which does have perfect matching: the ends of\r\nedges in maximal matching.Cool, we have proven the fact from the\r\nbeginning. . Now we have to calculate expected size of maximal matching.\r\nThat sound much easier: we already have a linear DP which calculates\r\nmaximal matching, and its values are exactly sizes of current maximal\r\nmatching. To remind: is a size of maximal matching in subtree rooted at\r\nwhere boolean flag means did we already cover vertex or is it still\r\nfree. All we have to do is to change the value stored in DP for expected\r\nvalue and also calculate probabilities to actually be in state with\r\ngiven flag .Complexity .\r\n",
    "hint": []
}