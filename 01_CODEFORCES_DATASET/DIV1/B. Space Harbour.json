{
    "link": "https://codeforces.com//contest/1924/problem/B",
    "problemId": "2447858",
    "problem_idx": "B",
    "shortId": "1924B",
    "contest_number": "1924",
    "problem_submissions": {
        "E": [
            243630255,
            243625417,
            243831471,
            243819146,
            243638029,
            243635094,
            243635575,
            243643653,
            243641448,
            243654047,
            243642725,
            243655474,
            243640193,
            243642282,
            243738773,
            243738280,
            243737868,
            243737472,
            243736583,
            243647040,
            243643392,
            243656506,
            243623598,
            243647525,
            243642926
        ],
        "D": [
            243610539,
            243613703,
            243615017,
            243615468,
            243616484,
            243609433,
            243612607,
            243604919,
            243590030,
            243626983,
            243620249,
            243611671,
            243630742,
            243627184,
            243647496,
            243637086,
            243615081
        ],
        "C": [
            243600996,
            243608465,
            243605004,
            243605423,
            243609031,
            243624334,
            243598851,
            243618516,
            243614897,
            243607146,
            243609954,
            243605925,
            243615697,
            243614877,
            243629728,
            243619721,
            243625857
        ],
        "B": [
            243576284,
            243596345,
            243574522,
            243584076,
            243591802,
            243608792,
            243595388,
            243582812,
            243591583,
            243581060,
            243590774,
            243588502,
            243614602,
            243593249,
            243586709,
            243594966,
            243581169,
            243586114
        ],
        "A": [
            243557786,
            243557461,
            243557951,
            243558389,
            243559700,
            243571068,
            243569238,
            243556739,
            243561136,
            243559764,
            243556383,
            243563507,
            243559787,
            243566206,
            243566244,
            243561059,
            243558400,
            243589028
        ],
        "F": [
            243674865,
            243667546,
            243888054,
            243737554,
            246427685
        ]
    },
    "name": "B. Space Harbour",
    "statement": "There are n points numbered 1 to n on a straight line. Initially, there\r\nare m harbours. The i-th harbour is at point X_i and has a value V_i.\r\nThere is exactly one ship on each of the n points. The cost of moving a\r\nship from its current location to the next harbour is the product of the\r\nvalue of the nearest harbour to its left and the distance from the\r\nnearest harbour to its right. Specifically, if a ship is already at a\r\nharbour, the cost of moving it to the next harbour is 0. Additionally,\r\nthere are q queries, each of which is either of the following 2 types: 1\r\nx v Add a harbour at point x with value v. It is guaranteed that before\r\nadding the harbour, there is no harbour at point x. 2 l r Print the sum\r\nof the cost of moving all ships at points from l to r to their next\r\nharbours.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n    int n;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree() : n(0) {}\n    LazySegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    LazySegmentTree(std::vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(std::vector(n_, v_));\n    }\n    template<class T>\n    void init(std::vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << std::__lg(n), Info());\n        tag.assign(4 << std::__lg(n), Tag());\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return;\n        }\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m, r, x, y, v);\n        pull(p);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n    template<class F>\n    int findFirst(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        int res = findFirst(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = findFirst(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findFirst(int l, int r, F pred) {\n        return findFirst(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int findLast(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        int res = findLast(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = findLast(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findLast(int l, int r, F pred) {\n        return findLast(1, 0, n, l, r, pred);\n    }\n};\n\nstruct Tag {\n    i64 k = 0;\n    i64 b = 0;\n    \n    void apply(const Tag &t) {\n        if (t.k < 0) {\n            k = t.k;\n            b = t.b;\n        }\n    }\n};\n\nstruct Info {\n    i64 cnt = 0;\n    i64 sid = 0;\n    i64 sum = 0;\n    \n    void apply(const Tag &t) {\n        if (t.k < 0) {\n            sum = sid * t.k + cnt * t.b;\n        }\n    }\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    return {a.cnt + b.cnt, a.sid + b.sid, a.sum + b.sum};\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m, q;\n    std::cin >> n >> m >> q;\n    \n    std::vector<int> X(m), V(m);\n    for (int i = 0; i < m; i++) {\n        std::cin >> X[i];\n        X[i]--;\n    }\n    for (int i = 0; i < m; i++) {\n        std::cin >> V[i];\n    }\n    \n    std::map<int, int> s;\n    for (int i = 0; i < m; i++) {\n        s[X[i]] = V[i];\n    }\n    \n    LazySegmentTree<Info, Tag> seg(n);\n    for (int i = 0; i < n; i++) {\n        seg.modify(i, {1, i, 0});\n    }\n    auto work = [&](auto it) {\n        auto nxt = std::next(it);\n        seg.rangeApply(it->first + 1, nxt->first + 1, {-it->second, 1LL * it->second * nxt->first});\n    };\n    for (auto it = s.begin(); it->first != n - 1; it++) {\n        work(it);\n    }\n    \n    while (q--) {\n        int t, x, y;\n        std::cin >> t >> x >> y;\n        \n        if (t == 1) {\n            x--;\n            s[x] = y;\n            auto it = s.find(x);\n            work(it);\n            work(std::prev(it));\n        } else {\n            x--;\n            i64 ans = seg.rangeQuery(x, y).sum;\n            std::cout << ans << \"\\n\";\n        }\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "math",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Space Harbour.json",
    "editorial_link": "https://codeforces.com//blog/entry/125137",
    "editorial": "Tutorial We can maintain a segment tree of size which initially stores\nthe cost of all the ships.Now there are 2 types of updates when we add\nan harbour: The ships to the left of the new harbour have their cost\ndecreased by a fixed amount. The ships to the right of the harbour have\ntheir cost changed by the value equivalent to product of distance from\nthe harbour on their right (which remains unchanged) and the difference\nin values of the previous and new harbour to their left. Example of\nupdatesLet and there be harbours on point and with values and\nrespectively.Now we add a harbour at point with value . Case 1: Cost for\nboth ships get decreased by Case 2: Cost for the ships get increased by\nrespectively. There are multiple ways to handle both the updates\nsimultaneously, a simple way would be to use a struct simulating an\narithmetic progression. It can contain two values Base: Simply a value\nwhich has to be added to all values belonging to the segment.\nDifference: For each node of the segment, will be added to the node,\nwhere is the distance of node from the end of the segment. Using\nsummation of arithmetic progression we can make sure that the updates on\nDifference can be applied to an entire segment lazily. You can see the\ncode for more details.\n"
}