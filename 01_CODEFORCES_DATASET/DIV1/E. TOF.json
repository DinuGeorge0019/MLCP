{"link": "https://codeforces.com//contest/687/problem/E", "problemId": "63914", "problem_idx": "E", "shortId": "687E", "contest_number": "687", "problem_submissions": {"E": [18802309, 18806260, 18805246, 18803372, 18799334, 18807280, 18805272, 18806337, 18807252, 18806390, 18807620, 18803706, 18810595, 18816088, 18805681], "D": [18793799, 18802718, 18796900, 18797754, 18807683, 18798362, 18797604, 18800141, 18800702, 18803058, 18801619, 18800190, 18801266, 18807597, 18797518, 18800453, 18798281], "A": [18790806, 18786960, 18787408, 18787163, 18787741, 18788893, 18788129, 18787797, 18786842, 18788168, 18789518, 18787023, 18787148, 18787130, 18787967, 18788569, 18787232, 18787389], "C": [18788685, 18790045, 18790813, 18791514, 18792644, 18791092, 18793279, 18795089, 18793603, 18792159, 18795767, 18790356, 18792828, 18792310, 18792853, 18794074, 18789915, 18792958], "B": [18786970, 18788540, 18789247, 18789185, 18796167, 18786909, 18790772, 18789737, 20295221, 20295216, 20295180, 20295158, 20295119, 20295105, 18790246, 18790367, 18793463, 18789273, 20295043, 20295033, 20295023, 20295001, 20294990, 20292826, 18789797, 18790852, 18792280, 18796842, 18789369]}, "name": "E. TOF", "statement": "Today Pari gave Arya a cool graph problem. Arya wrote a non-optimal\r\nsolution for it, because he believes in his ability to optimize\r\nnon-optimal solutions. In addition to being non-optimal, his code was\r\nbuggy and he tried a lot to optimize it, so the code also became dirty!\r\nHe keeps getting Time Limit Exceeds and he is disappointed. Suddenly a\r\nbright idea came to his mind!Here is how his dirty code looks\r\nlike:dfs(v){ set count[v] = count[v] + 1 if(count[v] < 1000) { foreach u\r\nin neighbors[v] { if(visited[u] is equal to false) { dfs(u) } break } }\r\nset visited[v] = true}main(){ input the digraph() TOF() foreach 1<=i<=n\r\n{ set count[i] = 0 , visited[i] = false } foreach 1 <= v <= n {\r\nif(visited[v] is equal to false) { dfs(v) } } ... // And do something\r\ncool and magical but we can\u2019t tell you what!}He asks you to write the\r\nfunction in order to optimize the running time of the code with\r\nminimizing the number of calls of the function. The input is a directed\r\ngraph and in the function you have to rearrange the edges of the graph\r\nin the list for each vertex. The number of calls of function depends on\r\nthe arrangement of of each vertex.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <queue>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=5010;\nint dfn[N],low[N],ins[N],st[N],bel[N],dis[N],vis[N];\nint ind,top,n,m,u,v,cnt,maxc;\nVI vec[N],e[N],f[N];\nqueue<int> q;\nvector<PII> E;\nvoid tarjan(int u) {\n\tdfn[u]=low[u]=++ind;\n\tins[u]=1;\n\tst[++top]=u;\n\trep(i,0,SZ(e[u])) {\n\t\tint v=e[u][i];\n\t\tif (!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);\n\t\telse if (ins[v]) low[u]=min(low[u],low[v]);\n\t} \n\tif (dfn[u]==low[u]) {\n\t\t++cnt;\n\t\twhile (1) {\n\t\t\tbel[st[top]]=cnt;\n\t\t\tvec[cnt].pb(st[top]);\n\t\t\tins[st[top]]=0;\n\t\t\tif (st[top--]==u) break;\n\t\t}\n\t}\n}\n\nvoid find(int u) {\n\trep(i,1,n+1) vis[i]=0,dis[i]=n+1;\n\tvis[u]=1; q.push(u); dis[u]=0;\n\twhile (!q.empty()) {\n\t\tint v=q.front(); q.pop();\n\t\tfor (auto w:e[v]) if (!vis[w]) {\n\t\t\tvis[w]=1; dis[w]=dis[v]+1;\n\t\t\tq.push(w);\n\t\t} \n\t}\n//\tprintf(\"%d\\n\",u);\n//\trep(i,1,n+1) printf(\"%d %d\\n\",i,dis[i]);\n\trep(i,1,n+1) for (auto v:e[i]) if (v==u) {\n\t\tmaxc=min(maxc,dis[i]+1);\n\t}\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v);\n\t\tE.pb(mp(u,v));\n\t}\n\trep(i,1,n+1) if (!dfn[i]) tarjan(i);\n\trep(i,0,m) {\n\t\tint u=E[i].fi,v=E[i].se;\n\t\tif (bel[u]!=bel[v]) {\n\t\t\tf[bel[u]].pb(bel[v]);\n\t\t}\n\t}\n\tint ret=n;\n\trep(i,1,cnt+1) if (SZ(f[i])==0) {\n\t\tif (SZ(vec[i])==1) continue;\n\t\tmaxc=n;\n\t\tfor (auto u:vec[i]) find(u);\n\t\tret+=998*maxc+1;\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs"], "dificulty": "2900", "interactive": false}