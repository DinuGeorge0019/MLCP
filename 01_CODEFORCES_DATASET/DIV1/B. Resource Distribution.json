{
    "link": "https://codeforces.com//contest/966/problem/B",
    "problemId": "179476",
    "problem_idx": "B",
    "shortId": "966B",
    "contest_number": "966",
    "problem_submissions": {
        "E": [
            37728467,
            37721887,
            37727395,
            37722353,
            46428064,
            37735854,
            37726097,
            37728168,
            37731395,
            37731373
        ],
        "D": [
            37722933,
            37721182,
            37720577,
            37745366,
            37727547,
            37724656,
            37720856,
            37720615,
            37721601,
            37723190,
            37720741,
            37720916,
            37854456,
            37723453,
            37723867,
            37723823,
            37723640,
            37725199
        ],
        "C": [
            37716531,
            37723619,
            37716233,
            37716062,
            37721394,
            37719905,
            37724974,
            37710146,
            37715347,
            37715961,
            37715642,
            37715427,
            37717480,
            37715886,
            37716616,
            37716460,
            37712823,
            37718703,
            37718856
        ],
        "B": [
            37712342,
            37710216,
            37712076,
            37714505,
            37717238,
            37717093,
            37713464,
            37712937,
            37711956,
            37712143,
            37712153,
            37712830,
            37714037,
            37717527,
            37712504,
            37714456,
            37719214,
            37710052,
            37715647
        ],
        "A": [
            37709493,
            37711125,
            37709073,
            37709222,
            37711428,
            37711424,
            37710230,
            37723341,
            37715473,
            37709490,
            37710976,
            37717218,
            37726403,
            37716138,
            37716852,
            37710495,
            37715732,
            37712927,
            37711795
        ],
        "F": [
            37856043
        ]
    },
    "name": "B. Resource Distribution",
    "statement": "One department of some software company has n servers of different\r\nspecifications. Servers are indexed with consecutive integers from 1 to\r\nn. Suppose that the specifications of the j-th server may be expressed\r\nwith a single integer number c_j of artificial resource units.In order\r\nfor production to work, it is needed to deploy two services S_1 and S_2\r\nto process incoming requests using the servers of the department.\r\nProcessing of incoming requests of service S_i takes x_i resource\r\nunits.The described situation happens in an advanced company, that is\r\nwhy each service may be deployed using not only one server, but several\r\nservers simultaneously. If service S_i is deployed using k_i servers,\r\nthen the load is divided equally between these servers and each server\r\nrequires only x_i / k_i (that may be a fractional number) resource\r\nunits.Each server may be left unused at all, or be used for deploying\r\nexactly one of the services (but not for two of them simultaneously).\r\nThe service should not use more resources than the server\r\nprovides.Determine if it is possible to deploy both services using the\r\ngiven servers, and if yes, determine which servers should be used for\r\ndeploying each of the services.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L long long\n#define aa first\n#define bb second\n#define pb push_back\nusing namespace std;\nint n,m1,m2;\npair<int,int> a[300010];\nvector<int> x,y;\ninline void print()\n{\n    int i;\n    printf(\"Yes\\n%d %d\\n\",(int)x.size(),(int)y.size());\n    for(i=0;i<x.size();i++)\n      printf(\"%d \",x[i]);\n    printf(\"\\n\");\n    for(i=0;i<y.size();i++)\n      printf(\"%d \",y[i]);\n    printf(\"\\n\");\n}\ninline bool chk()\n{\n    int i,j;\n    for(i=n;i>0;i--)\n      if((L)a[i].aa*(n-i+1)>=m1)\n        break;\n    if(i>0)\n      {\n       for(j=i-1;j>0;j--)\n         if((L)a[j].aa*(i-j)>=m2)\n           break;\n       if(j>0)\n         {\n          for(;j<i;j++)\n            y.pb(a[j].bb);\n          for(;i<=n;i++)\n            x.pb(a[i].bb);\n          return 1;\n         }\n       else\n         return 0;\n      }\n    else\n      return 0;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k1,k2;\n\tscanf(\"%d%d%d\",&n,&m1,&m2);\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   scanf(\"%d\",&a[i].aa);\n       a[i].bb=i;\n      }\n    sort(a+1,a+n+1);\n    if(chk())\n      print();\n    else\n      {\n       swap(m1,m2);\n       if(chk())\n         {\n          swap(x,y);\n          print();\n         }\n       else\n         printf(\"No\\n\");\n      }\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Resource Distribution.json",
    "editorial_link": "https://codeforces.com//blog/entry/59173",
    "editorial": "Suppose that the load of the first service was divided among k1\n servers and the load of the second service was divided among k2\n servers. In such case first service will be running on k1\n servers of resource at least p1=?x1/k1?\n and second service will be run on k2\n servers of resource at least p2=?x2/k2?\n.\n\nSuppose that p1?p2\n, the remaining case will be dealt in the similar way. Remove all servers that have less than p1\n resources, we are not going to use them. We may consider only assignments in which any server assigned to the first service has at most as many resources as any server assigned to the second service (otherwise we may swap them and the answer will still be correct). In such manner we may show that the first service may be assigned to the first k1\n servers having at least p1\n resource units and the second service may be assigned to the last k2\n servers in ascending order of available resources.\n\nFinally notice that if we fix k1\n, the optimal value of k2\n is minimum such that the last k2\n servers have at least p2\n resource units. Calculate the minimum possible k2\n in linear time, after that try each possible value of k1\n and check if the first k1\n servers having at least p1\n resource units do not intersect with the last k2\n servers (it may be checked in a single binary search).\n\nWe got a solution with running time of O(nlogn)\n."
}