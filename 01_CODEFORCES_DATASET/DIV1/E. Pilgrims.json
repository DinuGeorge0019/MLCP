{
    "link": "https://codeforces.com//contest/348/problem/E",
    "problemId": "3555",
    "problem_idx": "E",
    "shortId": "348E",
    "contest_number": "348",
    "problem_submissions": {
        "C": [
            4588342,
            4590159,
            4593135,
            4588912,
            4585853,
            4589632,
            4585524,
            4586580,
            4585883,
            4581239,
            4588365,
            4618235
        ],
        "B": [
            4580097,
            4582356,
            4579942,
            4582963,
            4589468,
            4587659,
            4577354,
            4585315,
            4580326,
            4582274,
            4579794,
            4606814,
            4580277,
            4584510,
            4582530,
            4581233,
            4588037,
            4582260,
            4589608
        ],
        "A": [
            4576873,
            4574641,
            4574230,
            4576431,
            4576985,
            4585961,
            4574860,
            4576105,
            4577005,
            4576961,
            4574398,
            4574642,
            4577358,
            4575644,
            4582569,
            4583556,
            4575731,
            4575526
        ],
        "D": [
            4576020,
            4578123,
            4580839,
            4584931,
            4582728,
            4580253,
            4592562,
            4587185,
            4588035,
            4587652,
            4587737,
            4590796,
            4582015
        ],
        "E": [
            4583454,
            4855776,
            4616595,
            4820950,
            4618329
        ]
    },
    "name": "E. Pilgrims",
    "statement": "A long time ago there was a land called Dudeland. Dudeland consisted of\r\ntowns connected with bidirectonal roads. The towns are indexed from to\r\nand one can reach any city from any other city if he moves along the\r\nroads of the country. There are monasteries in Dudeland located in\r\ndifferent towns. In each monastery lives a pilgrim.At the beginning of\r\nthe year, each pilgrim writes down which monastery is the farthest from\r\nthe monastery he is living in. If there is more than one farthest\r\nmonastery, he lists all of them. On the Big Lebowski day each pilgrim\r\npicks one town from his paper at random and starts walking to that town.\r\nWalter hates pilgrims and wants to make as many of them unhappy as\r\npossible by preventing them from finishing their journey. He plans to\r\ndestroy exactly one town that does not contain a monastery. A pilgrim\r\nbecomes unhappy if all monasteries in his list become unreachable from\r\nthe monastery he is living in. You need to find the maximum number of\r\npilgrims Walter can make unhappy. Also find the number of ways he can\r\nmake this maximal number of pilgrims unhappy: the number of possible\r\ntowns he can destroy.\r\n",
    "solutions": [
        "#include <cstdio>\n\nconst int N = 223456;\nconst int CO = 20;\nconst int INF = 1 << 30;\n\nint pv[N], de[N], he[N], ne[N], ss[N], ff[N], w[N], dp1[N], go1[N], lca[CO][N], cn[N], has[N];\n\nvoid dfs(int v, int pr, int d) {\n  pv[v] = pr;\n  de[v] = d;\n  int m1 = -INF;\n  int v1 = -1;\n  int m2 = -INF;\n//  int v2 = -1;\n  for (int e = he[v]; e >= 0; e = ne[e]) {\n    if (ff[e] == pr) continue;\n    dfs(ff[e], v, d + 1);\n    int cur = dp1[ff[e]] + w[e];\n    if (cur > m1) {\n      m2 = m1;\n//      v2 = v1;\n      m1 = cur;\n      v1 = go1[ff[e]];\n    } else if (cur > m2) {\n      m2 = cur;\n//      v2 = go1[ff[e]];\n    }\n  }\n  if (has[v]) {\n    int cur = 0;\n    if (cur > m1) {\n      m2 = m1;\n      m1 = 0;\n      v1 = v;\n    } else if (cur > m2) {\n      m2 = cur;\n    }\n  }\n//  printf(\"%d %d %d\\n\", v, m1, m2);\n  dp1[v] = m1;\n  go1[v] = v;\n  if (m1 != m2) {\n    go1[v] = go1[v1];\n  }\n}\n\nint glca(int v, int u) {\n  if (de[v] > de[u]) {\n    int t = v; v = u; u = t;\n  }\n  for (int i = CO - 1; i >= 0; i--) {\n    if (de[lca[i][u]] >= de[v]) u = lca[i][u];\n  }\n  if (v == u) return v;\n  for (int i = CO - 1; i >= 0; i--) {\n    if (lca[i][u] != lca[i][v]) {\n      u = lca[i][u];\n      v = lca[i][v];\n    }\n  }\n  return lca[0][v];\n}\n\nvoid addPath(int v, int u) {\n//  printf(\"add %d %d\\n\", v, u);\n  int z = glca(v, u);\n//  printf(\"lca %d %d %d\\n\", v, u, z);\n  cn[v]++;\n  cn[u]++;\n  cn[z]--;\n  if (lca[0][z] != z) cn[lca[0][z]]--;\n}\n\nvoid dfs2(int v, int m0, int v0) {\n  int m1 = m0;\n  int v1 = v0;\n  int m2 = -INF;\n  int v2 = -1;\n  int m3 = -INF;\n  int v3 = -1;\n  for (int e = he[v]; e >= 0; e = ne[e]) {\n    if (ff[e] == pv[v]) continue;\n    int cur = dp1[ff[e]] + w[e];\n    if (cur > m1) {\n      m3 = m2;\n      v3 = v2;\n      m2 = m1;\n      v2 = v1;\n      m1 = cur;\n      v1 = go1[ff[e]];\n    } else if (cur > m2) {\n      m3 = m2;\n      v3 = v2;\n      m2 = cur;\n      v2 = go1[ff[e]];\n    } else if (cur > m3) {\n      m3 = cur;\n      v3 = go1[ff[e]];\n    }\n  }  \n  if (has[v]) {\n    int cur = 0;\n    if (cur > m1) {\n      m3 = m2;\n      v3 = v2;\n      m2 = m1;\n      v2 = v1;\n      m1 = 0;\n      v1 = v;\n    } else if (cur > m2) {\n      m3 = m2;\n      v3 = v2;\n      m2 = cur;\n      v2 = v;\n    } else if (cur > m3) {\n      m3 = cur;\n      v3 = v;\n    }\n  }\n//  printf(\"type2 %d %d %d %d\\n\", v, m1, m2, v1);\n  if (has[v] && m1 != m2) {\n    addPath(v, v1);\n  }\n  for (int e = he[v]; e >= 0; e = ne[e]) {\n    if (ff[e] == pv[v]) continue;\n    if (v1 == go1[ff[e]]) dfs2(ff[e], m2 + w[e], m2 == m3 ? v : v2); else {\n      if (v2 == go1[ff[e]]) {\n        dfs2(ff[e], m1 + w[e], m1 == m3 ? v : v1);\n      } else {\n        dfs2(ff[e], m1 + w[e], m1 == m2 ? v : v1);\n      }\n    }\n  }\n}\n\nvoid dfs3(int v) {\n  for (int e = he[v]; e >= 0; e = ne[e]) {\n    if (ff[e] == pv[v]) continue;\n    dfs3(ff[e]);\n    cn[v] += cn[ff[e]];\n  }\n//  printf(\"          %d %d\\n\", v, cn[v]);\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    cn[i] = 0;\n    he[i] = -1;\n    has[i] = false;\n  }\n  for (int i = 0; i < m; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    has[x - 1] = true;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d%d%d\", ss + i, ff + i, w + i);\n    --ss[i];\n    --ff[i];\n    ss[i + n - 1] = ff[i];\n    ff[i + n - 1] = ss[i];\n    w[i + n - 1] = w[i];\n  }\n  for (int i = 0; i < n + n - 2; i++) {\n    ne[i] = he[ss[i]];\n    he[ss[i]] = i;\n  }\n  dfs(0, -1, 0);\n  for (int i = 0; i < n; i++) lca[0][i] = pv[i] >= 0 ? pv[i] : i;\n  for (int i = 1; i < CO; i++) {\n    for (int v = 0; v < n; v++) {\n      lca[i][v] = lca[i - 1][lca[i - 1][v]];\n    }\n  }\n  dfs2(0, -INF, -1);\n  dfs3(0);\n  int ma = -1;\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (has[i]) continue;\n    if (cn[i] > ma) {\n      ma = cn[i];\n      ans = 1;\n    } else if (cn[i] == ma) {\n      ++ans;\n    }\n//    printf(\"  %d %d\\n\", cn[i], i);\n  }\n  printf(\"%d %d\\n\", ma, ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Pilgrims.json",
    "editorial_link": "https://codeforces.com//blog/entry/9031",
    "editorial": "Let s build a simple solution at first and then we will try to improve\r\nit to solve problem more effectively given the constraints. For every\r\nvertex let s find the list of the farthest vertices. Let s find vertices\r\non the intersection of the paths between current vertex and each vertex\r\nfrom the list that don t contain monasteries. If we remove any of these\r\nvertices then every vertex from the list is unreachable from the current\r\nmonastery. For every vertex from the intersection increment the counter.\r\nThen the answer for the problem is the maximum among all counters and\r\nthe number of such maxima. Let s solve the problem more effectively\r\nusing the same idea. Let s make the tree with root. For every vertex we\r\nwill find the list of the farthest vertices only in the subtree. While\r\ntraversing the tree using depth first search we return the largest depth\r\nin the subtree and the number of the vertex where it was reached. Among\r\nall of the sons of the current vertex we choose the maximum of depths.\r\nIf maximum is reached one time then we return the same answer that was\r\nreturned from the son. If the answer was reached more than one time then\r\nwe return the number of the current vertex. Essentially, we find LCA of\r\nthe farthest vertices according to the current vertex. Before quitting\r\nthe vertex we increment the values on the segment between current vertex\r\nand found LCA. One can use Eulerian tour and segment tree for adding on\r\nthe segment. Finally, the last stage of solving the problem to solve it\r\nfor the case when the farthest vertex is not in the subtree of the\r\ncurrent vertex. For solving of that subproblem we use the same idea that\r\nwas used in the problem of the finding the maximal path in the tree. For\r\nevery vertex we keep 3 maximums 3 farthest vertices in the subtree. When\r\nwe go down to the subtree, we pass 2 remaining maximums too. In that\r\nway, when we re in any vertex, we can decide whether there s a path not\r\nin the subtree (it means, going up) of the same or larger length. If\r\nthere re 2 paths of the same length in the subtree and not in the\r\nsubtree, it means that for the pilgrim from the current monastery there\r\ns always a path no matter what town was destroyed. If one of the\r\nquantities is larger then we choose the segment in Eulerian tour and\r\nincrement the value on the segment. The case where there s several paths\r\n(at least 2) out of the subtree of the same maximal length, is the same\r\nwith the case in the subtree. LCA and segment tree can be solved\r\neffectively in time per query so the total memory and time is .\r\n"
}