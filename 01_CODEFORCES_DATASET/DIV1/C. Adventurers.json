{
    "link": "https://codeforces.com//contest/2046/problem/C",
    "problemId": "3064641",
    "problem_idx": "C",
    "shortId": "2046C",
    "contest_number": "2046",
    "problem_submissions": {
        "E2": [
            294584009,
            294914447,
            299392707
        ],
        "E1": [
            294583764,
            294575583,
            294575752,
            294582430,
            294565503,
            294626979,
            294869963,
            294674514,
            294674138,
            294611999,
            294672171,
            295181016,
            299301861,
            294579122,
            294609733
        ],
        "D": [
            294560152,
            294564191,
            294566638,
            294575690,
            294573167,
            294577461,
            294570961,
            294577018,
            294582440,
            294580055,
            294581279,
            294580878,
            294578858,
            294578559,
            294582493,
            294576385,
            294578827
        ],
        "C": [
            294540710,
            294545229,
            294545966,
            294548359,
            294558363,
            294545738,
            294550008,
            294552252,
            294555169,
            294551693,
            294558653,
            294550648,
            294551477,
            294560374,
            294559914,
            294555355,
            294557938,
            294552127,
            294543297,
            294557586
        ],
        "B": [
            294535038,
            294535101,
            294537375,
            294540562,
            294536849,
            294536519,
            294541688,
            294539018,
            294541654,
            294536164,
            294543153,
            294539414,
            294540802,
            294537409,
            294549010,
            294540274,
            294543427,
            294535624,
            294535094,
            294536775
        ],
        "A": [
            294532826,
            294532846,
            294539095,
            294533971,
            294533241,
            294533253,
            294534636,
            294533446,
            294534152,
            294532988,
            294537957,
            294533256,
            294533123,
            294534271,
            294537609,
            294533346,
            294537414,
            294532885,
            294532806,
            294533598
        ],
        "F2": [
            301103610,
            294606357
        ],
        "F1": [
            301085708,
            295825018,
            294574079
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136908",
    "editorial": "First, we will use the idea of binary search on the answer. Let's assume we are currently checking if we can achieve the answer k\n.\n\nWe will iterate over all the necessary coordinates of the vertical lines. To do this, we note that it makes sense to iterate only over those where the lines coincide in the Y-coordinate with at least one of the points. It is obvious that in this case, the necessary vertical lines will be on the order of O(n)\n.\n\nDuring the iteration over the vertical line, we will maintain two segment trees for the sum: one for the left half of the plane and the other for the right. ty\n in each of the segment trees will represent how many points have a Y-coordinate of y\n in the corresponding half of the plane. In each of the segment trees, we will check if it is possible to divide the half-plane into two parts by a line parallel to the x-axis, so that there are at least k\n points in both parts; and if this is possible, we will find the set of suitable lines \u0097 it will obviously be some segment [yl,yr]\n. If the intersection of the resulting segments in both segment trees is not empty, then we have found the answer. This can be done by descending the tree in O(logn)\n time.",
    "name": "C. Adventurers",
    "statement": "Once, four Roman merchants met in a Roman mansion to discuss their\r\ntrading plans. They faced the following problem: they traded the same\r\ntype of goods, and if they traded in the same city, they would\r\ninevitably incur losses. They decided to divide up the cities between\r\nthem where they would trade.The map of Rome can be represented in this\r\nproblem as a plane with certain points marked the cities of the Roman\r\nEmpire.The merchants decided to choose a certain (x_0, y_0). Then, in a\r\ncity with coordinates (x_i, y_i), the first merchant sells goods if x_0\r\nle x_i and y_0\r\nle y_i; the second merchant sells goods if x_0 > x_i and y_0\r\nle y_i; the third merchant sells goods if x_0\r\nle x_i and y_0 > y_i; the fourth merchant sells goods if x_0 > x_i and\r\ny_0 > y_i. The merchants want to choose (x_0, y_0) in such a way as to\r\nthat any of them gets (i. e., as fair as possible). Please find such a\r\npoint for them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;using u128 = unsigned __int128;template <typename T>struct Fenwick {    int n;    std::vector<T> a;        Fenwick(int n_ = 0) {        init(n_);    }        void init(int n_) {        n = n_;        a.assign(n, T{});    }        void add(int x, const T &v) {        for (int i = x + 1; i <= n; i += i & -i) {            a[i - 1] = a[i - 1] + v;        }    }        T sum(int x) {        T ans{};        for (int i = x; i > 0; i -= i & -i) {            ans = ans + a[i - 1];        }        return ans;    }        T rangeSum(int l, int r) {        return sum(r) - sum(l);    }        int select(const T &k) {        int x = 0;        T cur{};        for (int i = 1 << std::__lg(n); i; i /= 2) {            if (x + i <= n && cur + a[x + i - 1] <= k) {                x += i;                cur = cur + a[x - 1];            }        }        return x;    }};\u00a0void solve() {    int n;    std::cin >> n;        std::vector<int> x(n), y(n);    for (int i = 0; i < n; i++) {        std::cin >> x[i] >> y[i];    }        auto xs = x, ys = y;    std::sort(xs.begin(), xs.end());    std::sort(ys.begin(), ys.end());    xs.erase(std::unique(xs.begin(), xs.end()), xs.end());    ys.erase(std::unique(ys.begin(), ys.end()), ys.end());        for (int i = 0; i < n; i++) {        x[i] = std::lower_bound(xs.begin(), xs.end(), x[i]) - xs.begin();        y[i] = std::lower_bound(ys.begin(), ys.end(), y[i]) - ys.begin();    }        int k = 0;    int X0 = 0, Y0 = 0;        Fenwick<int> fl(n), fr(n);    for (int i = 0; i < n; i++) {        fr.add(y[i], 1);    }        std::vector<int> p(n);    std::iota(p.begin(), p.end(), 0);    std::sort(p.begin(), p.end(),        [&](int i, int j) {            return x[i] < x[j];        });        for (int j = 0; j < n; j++) {        int i = p[j];        fr.add(y[i], -1);        fl.add(y[i], 1);                if (j + 1 < n && x[p[j + 1]] == x[i]) {            continue;        }                while (true) {            if (j + 1 < 2 * (k + 1)) {                break;            }            if (n - j - 1 < 2 * (k + 1)) {                break;            }            int yl = std::max(fl.select(k), fr.select(k));            int yr = std::min(fl.select(j - k), fr.select(n - 1 - j - 1 - k));            if (yl >= yr) {                break;            }            k++;            X0 = xs[x[i]] + 1;            Y0 = ys[yr];        }    }        std::cout << k << \"\\n\";    std::cout << X0 << \" \" << Y0 << \"\\n\";}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "sortings",
        "ternary search",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Adventurers.json"
}