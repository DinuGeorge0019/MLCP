{
    "link": "https://codeforces.com//contest/1685/problem/B",
    "problemId": "1410453",
    "problem_idx": "B",
    "shortId": "1685B",
    "contest_number": "1685",
    "problem_submissions": {
        "E": [
            158459552,
            158470179,
            158498551,
            158474226,
            158469548,
            163064811,
            163064579,
            162972274,
            161995310
        ],
        "D1": [
            158446537,
            158446179,
            158436497,
            158441308,
            158450152,
            158437819,
            158438771,
            158444550,
            158444057,
            158444961,
            158450485,
            158456436,
            158455279,
            158451423,
            158456717,
            158456702,
            158458839,
            158450419,
            158454329
        ],
        "C": [
            158440149,
            158436682,
            158456408,
            158436985,
            158433630,
            158430630,
            158430086,
            158437803,
            158438284,
            158438857,
            158446162,
            158444048,
            158440132,
            158447129,
            158447895,
            158449525,
            158447760,
            158457006,
            158449988
        ],
        "B": [
            158430617,
            158426337,
            158489620,
            158427132,
            158430769,
            158427058,
            158419568,
            158419647,
            158422845,
            158428180,
            158427930,
            158426993,
            158428289,
            158433041,
            158438360,
            158432708,
            158432524,
            158429703,
            158431029,
            158439177
        ],
        "A": [
            158416845,
            158416623,
            158416445,
            158417978,
            158414637,
            158414483,
            158414377,
            158414577,
            158419066,
            158418105,
            158416435,
            158417522,
            158415887,
            158415929,
            158418032,
            158416211,
            158417132,
            158417328,
            158424448
        ],
        "D2": [
            158457366,
            158450783,
            158467580,
            158467275,
            158561732,
            166382774,
            166382436
        ]
    },
    "name": "B. Linguistics",
    "statement": "Alina has discovered a weird language, which contains only 4 words:\r\ntexttt{A},\r\ntexttt{B},\r\ntexttt{AB},\r\ntexttt{BA}. It also turned out that there are no spaces in this\r\nlanguage: a sentence is written by just concatenating its words into a\r\nsingle string.Alina has found one such sentence s and she is curious: is\r\nit possible that it consists of precisely a words\r\ntexttt{A}, b words\r\ntexttt{B}, c words\r\ntexttt{AB}, and d words\r\ntexttt{BA}?In other words, determine, if it\u2019s possible to concatenate\r\nthese a+b+c+d words in some order so that the resulting string is s.\r\nEach of the a+b+c+d words must be used exactly once in the\r\nconcatenation, but you can choose the order in which they are\r\nconcatenated.\r\n",
    "solutions": [
        "//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\n#define maxn 200005\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\n#define str string\nchar s[maxn];\nint ed[27];\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int x[2];\n        int u, v;\n        scanf(\"%d%d%d%d\", &u, &v, &x[0], &x[1]);\n        int cnt[2] = {u + x[0] + x[1], v + x[0] + x[1]};\n        scanf(\"%s\", s + 1);\n        int n = strlen(s + 1);\n        for (int i = 1; i <= n; i++) {\n            cnt[s[i] - 'A'] -= 1;\n        }\n        int flag = 1; \n        int sum = 0;\n        vector<pi> h;\n        if (cnt[0] != 0 || cnt[1] != 0) flag = 0;\n        else {\n            s[n + 1] = 'C';\n            for (int i = 1; i <= n; ) {\n                int j = i;\n                while (j < n && s[j] != s[j + 1]) j += 1;\n                int clen = j - i + 1;\n                if (clen % 2) sum += clen / 2;\n                else\n                    h.pb(mp(clen, s[i] - 'A'));\n                i = j + 1;\n            }\n            sort(h.begin(), h.end());\n           // cout << sum << endl;\n            for (auto w : h) {\n                pi v = mp(w.se, w.fi);\n                //cout << v.fi << ' ' << v.se << endl;\n                int tr = v.se / 2;\n                if (x[v.fi] >= tr) x[v.fi] -= tr;\n                else {\n                    int cur = min(x[v.fi], tr);\n                    x[v.fi] -= cur;\n                    tr -= cur; tr -= 1;\n                    x[v.fi ^ 1] -= min(x[v.fi ^ 1], tr);\n                }\n            }\n            if (x[0] + x[1] > sum) flag = 0;\n        }\n        if (flag) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return (0-0); //<3\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "sortings",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Linguistics.json",
    "editorial_link": "https://codeforces.com//blog/entry/103198",
    "editorial": "For the answer to be the frequency of the character in the words must\r\ncoincide with its frequency in the sentence , which is equivalent to the\r\ncondition . From now on we may assume that this is true.Notice that the\r\nanswer to the problem is if and only if it is possible to tile the\r\nstring with copies of and copies of so that all the substrings are\r\ndisjoint. Indeed one can simply fill the remaining characters of with\r\nthe copies of and the copies of (we are sure that the number of\r\ncharacters and is correct because of the initial check). Moreover, if ,\r\nthen clearly any tiling with and of cannot cover with a single tile both\r\nand ; therefore we can split the string between and and try to tile the\r\ntwo resulting substrings. By repeating this argument we will end up with\r\nmany alternating strings (a string is alternating if for all ). So, we\r\nhave reduced the problem to the following one:: You are given many\r\nalternating strings, can you find in these strings substrings equal to\r\nand subtrings equal to such that all the substrings are disjoint?In\r\norder to solve the problem let us analyze what happens when only one\r\nalternating string is present. Given an alternating string , we say that\r\nthe pair is valid if we can find in substrings equal to and substrings\r\nequal to so that the substrings are disjoint. Let us consider various\r\ncases: If , then is valid if and only if . Let . If and , then is valid\r\nif and only if or . Let . If and , then is valid if and only if or . Let\r\n. Loosely speaking, the alternating strings of type and have a bonus if\r\nthey are tiled only with one of the strings and .We will provide a proof\r\nfor the correcteness of the following greedy algorithm. Sort the strings\r\nof type by length and fill them, starting from the shortest, only with\r\n(i.e., find as many disjoint copies of as possible) until you reach or\r\nyou finish them (a string of length is filled with ). Do the same for\r\nthe strings of type for the word . At this point there are no more to\r\nuse and you can just fill the remaining strings with and in the only\r\nreasonable way. If in the end, if you have found strings and strings\r\nthen the answer is , otherwise it is .Let us provide a proof of the\r\ncorrectness of this algorithm. Let us remark that the proof of the\r\ncorrectness is in fact rather easy, but a bit cumbersome to write down.\r\nThe strategy of the proof is to start from a solution and to show that\r\nthe one constructed by the greedy algorithm is \"better\". Let be the\r\nmultisets of lengths of strings of the first, second and third type\r\nrespectively (according to the case division above). Then the problem is\r\nequivalent to understanding if Assume that the answer is and consider a\r\nsolution of the problem, i.e. a choice of a valid pair for each of the\r\nalternating strings. Let where corresponds to the lengths of the strings\r\nin where the valid pair of the solution is given by ( is the length of\r\nthe string). Partition analogously. Then we have Let us make a couple of\r\nobservations: For any it holds . If , then and also . Thanks to the\r\nsecond observation we know that we may assume (up to changing the\r\nsolution to a ) that contains the smaller elements of (i.e., for each ),\r\nand contains the smaller elements of . Then, applying the first\r\nobservation, we reduce the problem to understanding if there is prefix\r\nof (prefix in the sorted by length order) and a prefix of such that It\r\nremains to show that we may assume that is the largest prefix so that\r\n(and the analogous result for ) as this implies the correctness of the\r\ngreedy algorithm (i.e., if there is a valid solution then the one\r\nconstructed by the algorithm is a solution). Assume, by contradiction,\r\nthat there is such that . By we know where . Thus, we deduce which is\r\nequivalent to saying that () holds also if we replace with which is\r\nexactly what we wanted to prove\r\n"
}