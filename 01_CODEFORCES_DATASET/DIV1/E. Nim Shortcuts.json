{"link": "https://codeforces.com//contest/1458/problem/E", "problemId": "837946", "problem_idx": "E", "shortId": "1458E", "contest_number": "1458", "problem_submissions": {"C": [101749748, 101754548, 101742006, 101765508, 101760904, 101735121, 101758711, 101733697, 101742587, 101742771, 101744109, 101764706, 101753517, 101758458, 103876484, 101781534], "D": [101742255, 101733305, 101750551, 101754872, 101747447, 101747468, 101737535, 101761632, 101756331, 101755812, 102023685, 101761131, 101768544, 101764759, 103932701, 101747159], "E": [101737863, 101746540, 101766037, 101749099, 101757343, 101752859, 101763081, 101766464, 101774328, 101752190, 101746555, 101751393, 101757105], "B": [101728732, 101721253, 101733062, 101725510, 101763762, 101727209, 101722722, 101732397, 101727564, 101724112, 101730858, 101735965, 101740443, 101732340, 101727159, 101744347, 101723637, 101730363, 101730317], "A": [101720547, 101718495, 101723686, 101718493, 101718664, 101719145, 101718463, 101718584, 101718634, 101718787, 101720142, 101718675, 101719084, 101722215, 101718515, 101719224, 101718795, 101718781, 101721089], "F": [102925392, 102542392, 102542303, 103841307]}, "name": "E. Nim Shortcuts", "statement": "After your debut mobile game \"Nim\" blew up, you decided to make a sequel\r\ncalled \"Nim 2\". This game will expand on the trusted Nim game formula,\r\nadding the much awaited second heap! In the game, there are two heaps,\r\neach containing a non-negative number of stones. Two players make moves\r\nin turn. On their turn, a player can take any positive number of stones\r\nfrom either one of the heaps. A player who is unable to move loses the\r\ngame.To make the game easier to playtest, you\u2019ve introduced developer\r\nshortcuts. There are n shortcut positions (x_1, y_1),\r\nldots, (x_n, y_n). These change the game as follows: suppose that before\r\na player\u2019s turn the first and second heap contain x and y stones\r\nrespectively. If the pair (x, y) is equal to one of the pairs (x_i,\r\ny_i), then the player about to move loses instantly, otherwise they are\r\nable to make moves as normal. Note that in the above explanation the two\r\nheaps and all pairs are , that is, x must refer to the size of the first\r\nheap, and y must refer to the size of the second heap.The game release\r\nwas followed by too much celebration, and next thing you know is\r\ndeveloper shortcuts made their way to the next official update of the\r\ngame! Players now complain that the AI opponent has become unbeatable at\r\ncertain stages of the game. You now have to write a program to figure\r\nout which of the given initial positions can be won by the starting\r\nplayer, assuming both players act optimally.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 19.12.2020 13:02:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  const int M = (int) 1e9;\n  map<int, vector<int>> mp;\n  for (int i = 0; i < n; i++) {\n    mp[x[i]].push_back(y[i]);\n  }\n  mp[M + 1].push_back(-1);\n  set<pair<int, int>> s;\n  s.emplace(0, 2 * M);\n  vector<tuple<int, int, int>> res;\n  int last = -1;\n  for (auto& p : mp) {\n    sort(p.second.begin(), p.second.end());\n    int row = p.first;\n    int from = last + 1;\n    int to = row - 1;\n    while (from <= to) {\n      auto it = s.begin();\n      int it1 = it->first;\n      int it2 = it->second;\n      int len = it->second - it->first + 1;\n      if (len <= to - from + 1) {\n        res.emplace_back(from, from + len - 1, it->first);\n        from += len;\n        s.erase(it);\n        continue;\n      }\n      res.emplace_back(from, to, it->first);\n      s.erase(it);\n      s.emplace(it1 + (to - from + 1), it2);\n      break;\n    }\n    if (p.first > M) {\n      break;\n    }\n    for (int j : p.second) {\n      auto it = s.lower_bound(make_pair(j + 1, -1));\n      if (it != s.begin()) {\n        it = prev(it);\n        int L = it->first;\n        int R = it->second;\n        if (L <= j && j <= R) {\n          s.erase(it);\n          if (L < j) {\n            s.emplace(L, j - 1);\n          }\n          if (j < R) {\n            s.emplace(j + 1, R);\n          }\n        }\n      }\n    }\n    auto it = s.begin();\n    if (it->first < p.second[0]) {\n      int L = it->first;\n      int R = it->second;\n      p.second.insert(p.second.begin(), L);\n      s.erase(it);\n      if (L < R) {\n        s.emplace(L + 1, R);\n      }\n    }\n    last = row;\n  }\n  while (m--) {\n    int x, y;\n    cin >> x >> y;\n    auto it = mp.find(x);\n    if (it != mp.end()) {\n      auto ti = lower_bound(it->second.begin(), it->second.end(), y);\n      if (ti != it->second.end() && (*ti) == y) {\n        cout << \"LOSE\" << '\\n';\n      } else {\n        cout << \"WIN\" << '\\n';\n      }\n    } else {\n      auto ti = lower_bound(res.begin(), res.end(), make_tuple(x + 1, -1, -1));\n      assert(ti != res.begin());\n      ti = prev(ti);\n      assert(get<0>(*ti) <= x && x <= get<1>(*ti));\n      int val = get<2>(*ti) + (x - get<0>(*ti));\n      if (val == y) {\n        cout << \"LOSE\" << '\\n';\n      } else {\n        cout << \"WIN\" << '\\n';\n      }\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "games"], "dificulty": "3100", "interactive": false}