{
    "link": "https://codeforces.com//contest/1641/problem/E",
    "problemId": "1306248",
    "problem_idx": "E",
    "shortId": "1641E",
    "contest_number": "1641",
    "problem_submissions": {
        "D": [
            147518709,
            147518438,
            147518414,
            147427811,
            147454243,
            147448667,
            147443879,
            147448778,
            147461315,
            147449736,
            147438286,
            147472049,
            147446117,
            147443730,
            147449435,
            147452074,
            147451905,
            147452006,
            147454020,
            147456098,
            147454778,
            147430439
        ],
        "F": [
            147463572,
            147488364,
            147487709,
            147487635,
            147487566,
            147487511,
            147487448,
            147487273,
            147474513,
            147473910,
            147473584,
            147541615
        ],
        "E": [
            147445838,
            147446189,
            147454919,
            147456452,
            147460049,
            147450489,
            147462542,
            147543257,
            147542937,
            147453651,
            147456356,
            147459732,
            147462090,
            147455497,
            147527427,
            147590875
        ],
        "B": [
            147438181,
            147420165,
            147422523,
            147421140,
            147420036,
            147420813,
            147426049,
            147460937,
            147441628,
            147446219,
            147424792,
            147434886,
            147431843,
            147422293,
            147424883,
            147440401
        ],
        "C": [
            147435041,
            147431185,
            147429914,
            147434109,
            147426743,
            147452293,
            147436064,
            147458110,
            147432571,
            147432541,
            147431796,
            147432454,
            147435151,
            147433502,
            147424256,
            147417819,
            147434463,
            147437219,
            147451475
        ],
        "A": [
            147414901,
            147414810,
            147414544,
            147414530,
            147414675,
            147414742,
            147414833,
            147461626,
            147414843,
            147414962,
            147414590,
            147414549,
            147415904,
            147414474,
            147414750,
            147414483,
            147415173,
            147414668,
            147414647
        ]
    },
    "name": "E. Special Positions",
    "statement": "You are given an array a of length n. Also you are given m distinct\r\npositions p_1, p_2,\r\nldots, p_m (1\r\nleq p_i\r\nleq n).A subset of these positions T is randomly selected with equal\r\nprobability and the following value is calculated:\r\nsum_{i=1}^{n} (a_i\r\ncdot\r\nmin_{j\r\nin T}\r\nleft|i - j\r\nright|). In other word, for each index of the array, a_i and the\r\ndistance to the closest chosen position are multiplied, and then these\r\nvalues are summed up.Find the expected value of this sum.This value must\r\nbe found modulo 998\r\n,244\r\n,353. More formally, let M = 998\r\n,244\r\n,353. It can be shown that the answer can be represented as an\r\nirreducible fraction\r\nfrac{p}{q}, where p and q are integers and q\r\nneq 0 (mod M). Output the integer equal to p\r\ncdot q^{-1} (mod M). In other words, output such integer x that 0\r\nleq x < M and x\r\ncdot q = p (mod M).\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 23.02.2022 13:58:16       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n\n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n\n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n\n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n\n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n\n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<Mint> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> is_p(n);\n  for (int i = 0; i < m; i++) {\n    int x;\n    cin >> x;\n    --x;\n    is_p[x] = 1;\n  }\n  vector<int> pref(n + 1);\n  for (int i = 0; i < n; i++) {\n    pref[i + 1] = pref[i] + is_p[i];\n  }\n  vector<Mint> p2(m + 1);\n  p2[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    p2[i] = p2[i - 1] * 2;\n  }\n  Mint inv_2 = 1 / Mint(2);\n  vector<Mint> inv_p2(m + 1);\n  inv_p2[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    inv_p2[i] = inv_p2[i - 1] * inv_2;\n  }\n  vector<Mint> p2suf(n + 1);\n  for (int i = n - 1; i >= 0; i--) {\n    p2suf[i] = p2suf[i + 1] + (p2[m - pref[i]] - 1);\n  }\n  vector<Mint> p2pref(n + 1);\n  for (int i = 0; i < n; i++) {\n    p2pref[i + 1] = p2pref[i] + (p2[pref[i + 1]] - 1);\n  }\n  Mint ans = 0;\n  function<void(int, int)> Solve = [&](int L, int R) {\n    if (L == R) {\n      return;\n    }\n    int M = (L + R) >> 1;\n    vector<Mint> p(M - L + 1);\n    for (int i = L; i <= M; i++) {\n      p[i - L] = p2[pref[i]];\n    }\n    vector<Mint> q(R - M);\n    for (int i = M + 1; i <= R; i++) {\n      q[i - (M + 1)] = inv_p2[pref[i]];\n    }\n    auto r = p * q;\n    for (int i = 0; i < (int) r.size(); i++) {\n      int x = L + (M + 1) + i;\n      if (x % 2 == 1) {\n        ans += a[x / 2] * r[i];\n      }\n    }\n    Solve(L, M);\n    Solve(M + 1, R);\n  };\n  Solve(0, n);\n  ans *= p2[m];\n  for (int i = 0; i < n; i++) {\n    ans -= a[i] * min(i + 1, n - i);\n    if (2 * i + 1 < n) {\n      ans += a[i] * p2suf[2 * i + 2];\n    }\n    int x = 2 * i + 1 - n;\n    if (x > 0) {\n      ans += a[i] * p2pref[x - 1];\n    }\n  }\n  ans /= p2[m] - 1;\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "fft",
        "math"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Special Positions.json",
    "editorial_link": "https://codeforces.com//blog/entry/100249",
    "editorial": "First of all, calculate for each index the total sum of distances among\r\nall subsets if the closest selected position is to the left. Let , where\r\nthe number of cpecial positions at or to the right of (if then ).Let if\r\nposition is special, otherwise .It\u00e2\u0080\u0099s not hard to see, that the value for\r\nthe position in this case equals to .Then for each calculate two values:\r\nSince we can find first value using DNC (the second value we will find\r\nsimilary): we want to consider every . Then halve this segment: . Then\r\ncreate two polynomials: The polynomial of size , where . The polynomial\r\nof size , where . By multiplying this two polinomials we can recalculate\r\nthe values for positions from to and then solve two parts\r\nrecursively.Thus we can find for each index the total sum of distances\r\namong all subsets if the closest selected position is to the left. To\r\nfind for each index the total sum of distances among all subsets if the\r\nclosest selected positions is to the right we can do the same stuff but\r\nin inverse order.Note, that we need to consider the case where the\r\nclosest selected position to the left and the closest selected position\r\nare at the same distance from . It can be done by changing in one of the\r\ncases by the number of special positinos strickly to the right of .It\r\ncan be implemented in using FFT.\r\n"
}