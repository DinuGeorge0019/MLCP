{
    "link": "https://codeforces.com//contest/1261/problem/E",
    "problemId": "479752",
    "problem_idx": "E",
    "shortId": "1261E",
    "contest_number": "1261",
    "problem_submissions": {
        "F": [
            65647116,
            65658053,
            65657980,
            65657931,
            65651526,
            65649568,
            65649392,
            65651843,
            65651789,
            65643329,
            65715623,
            65660068,
            66569502,
            66569457,
            66569446,
            66563643,
            66529592,
            66529450,
            66529001,
            66528877,
            66527265,
            66527166,
            202179447,
            65759590,
            65736891,
            65656177,
            65801900,
            65656900,
            65653812
        ],
        "E": [
            65640839,
            65636308,
            65639924,
            65632814,
            65644428,
            65645126,
            65649634,
            65644543,
            65648074,
            65645492,
            65646710,
            65643401,
            65649412,
            65647298,
            65649626,
            65646791,
            65647214,
            65650131,
            65673025
        ],
        "D2": [
            65637210,
            65632855,
            65635634,
            65636824,
            65639345,
            65639544,
            65635456,
            65639090,
            65637689,
            65685918,
            65636623,
            65641288,
            65630575,
            65640353,
            65641640,
            65638704,
            65642981,
            65642369,
            65636523,
            65640625
        ],
        "D1": [
            65637138,
            65632929,
            65635559,
            65636922,
            65639374,
            65639684,
            65633638,
            65639276,
            65637859,
            65636779,
            65641185,
            65630619,
            65640390,
            65641739,
            65638754,
            65643069,
            65642429,
            65636584,
            65639802
        ],
        "C": [
            65632448,
            65642046,
            65632919,
            65640324,
            65637319,
            65636062,
            65629189,
            65635829,
            65634638,
            65686469,
            65686406,
            65686240,
            65686235,
            65686196,
            65686121,
            65686065,
            65686054,
            65686032,
            65685983,
            65685973,
            65685956,
            65633182,
            65639316,
            65636734,
            65647142,
            65634479,
            65636999,
            65635515,
            65637442,
            65637462,
            65658341,
            65640232,
            65635038
        ],
        "B1": [
            65629099,
            65627296,
            65628841,
            65642477,
            65630053,
            65629451,
            65645427,
            65631701,
            65629375,
            65639182,
            65631034,
            65637262,
            65630223,
            65630435,
            65630786,
            65631879,
            65632451,
            65627736,
            65630111
        ],
        "B2": [
            65629029,
            65627239,
            65628722,
            65642378,
            65629995,
            65629248,
            65645596,
            65631497,
            65629280,
            65720078,
            65685862,
            65639011,
            65631167,
            65637207,
            65630166,
            65630277,
            65630671,
            65631817,
            65632276,
            65627619,
            65630224
        ],
        "A": [
            65626424,
            65626236,
            65626313,
            65643924,
            65627202,
            65627360,
            65650514,
            65628121,
            65627165,
            65626869,
            65627525,
            65634172,
            65626632,
            65626977,
            65627953,
            65628262,
            65627833,
            65631529,
            65627297
        ]
    },
    "name": "E. Not Same",
    "statement": "You are given an integer array a_1, a_2,\r\ndots, a_n, where a_i represents the number of blocks at the i-th\r\nposition. It is guaranteed that 1\r\nle a_i\r\nle n. In one operation you can choose a subset of indices of the given\r\narray and remove one block in each of these indices. You can’t remove a\r\nblock from a position without blocks.All subsets that you choose should\r\nbe different (unique).You need to remove all blocks in the array using\r\nat most n+1 operations. It can be proved that the answer always exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> ans(n, vector<int>(n + 1, -1));\n  vector<vector<int>> groups(1);\n  for (int i = 0; i <= n; ++i) {\n    groups[0].push_back(i);\n  }\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    int y = min(x, n + 1 - x);\n    for (auto g : groups) {\n      if ((int) g.size() > 1) {\n        if (y) {\n          ans[i][g[0]] = 1;\n          ans[i][g[1]] = 0;\n          y--;\n          x--;\n        }\n      }\n    }\n    vector<vector<int>> new_groups;\n    for (auto g : groups) {\n      vector<int> zero;\n      vector<int> one;\n      for (int p : g) {\n        if (ans[i][p] == -1) {\n          if (x > 0) {\n            ans[i][p] = 1;\n            x--;\n          } else {\n            ans[i][p] = 0;\n          }\n        }\n        if (ans[i][p] == 1) {\n          one.push_back(p);\n        } else {\n          zero.push_back(p);\n        }\n      }\n      if (!zero.empty()) {\n        new_groups.push_back(zero);\n      }\n      if (!one.empty()) {\n        new_groups.push_back(one);\n      }\n    }\n    swap(groups, new_groups);\n  }\n  cout << n + 1 << \"\\n\";\n  for (int i = 0; i < n + 1; ++i) {\n    for (int j = 0; j < n; ++j) {\n      cout << ans[j][i];\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Not Same.json",
    "editorial_link": "https://codeforces.com/blog/entry/71740",
    "editorial": "The solution can be inspired by the output format :)First of all, sort\r\nall numbers in decreasing order. Let them be . We will construct the\r\nanswer column by column. Let us use a set of binary string to represent\r\na series of operations. For example represent operations for (invalid,\r\nhowever).Then we compress the same operations in a operation set as the\r\nnumber of this operation occurs. For example, can be compressed as as\r\nthereâs three and one . Note we do not care whether the operation is, we\r\nonly care how many times it occurs.Now, as we construct the answer\r\ncolumn by column, new numbers will be added. A new number can split some\r\nelements in the compress set. For example, we add a new in as it becomes\r\n. We can turn the operation set into , while the compress set turns from\r\n. In general, we can turn into uses a number . Special condition: can\r\nkeep same but use number .Special judge for , thus we use one operation\r\nto erase all numbers.Obviously the first compress set is , represent\r\noperation set .If , turn the second compress set as , otherwise turn it\r\nas .Then we maintain the compress set by keeping the sum of the elements\r\nsame but the number of the elements strictly increasing. For a current\r\ncompress set, let be the minimal element, and be the new number added.\r\nIf , split into . Otherwise split into , the left number can be randomly\r\nplaced.The left number can be randomly placed if and if only the sum of\r\nthe elements is larger then . Obviously the sum of the elements equals\r\nto or . If the sum of the elements equals to , then .After all split\r\noperations, the compress set must be , which means all operation differ\r\nfrom each other. We can construct the final answer now in .\r\n",
    "hint": []
}