{"link": "https://codeforces.com//contest/256/problem/A", "problemId": "2400", "problem_idx": "A", "shortId": "256A", "contest_number": "256", "problem_submissions": {"B": [2781429, 2776681, 2779641, 2777927, 2779004, 2777545, 2777829, 2778651, 2777720, 2778451, 2776552, 2782245, 2781330, 2777533], "D": [2779473, 2779904, 2777535, 2782686, 2789193, 2781305], "E": [2777253, 2781852, 2779020, 2775034, 2779843, 2779937, 2778999, 2781729, 2780947, 2779725, 2804945, 2804943, 2781663, 2781905, 2777856, 2780182, 2777426, 2780269], "C": [2776456, 2777569, 2783097, 2779210, 2776586, 2776922, 2776660, 2779042, 2777560, 2782221, 2778280, 2780113, 2780104, 2777296], "A": [2774012, 2782979, 2775596, 2779786, 2774535, 2774925, 2776089, 2773923, 2775590, 2774961, 2782829, 2781660, 2781773, 2774247]}, "name": "A. Almost Arithmetical Progression", "statement": "Gena loves sequences of numbers. Recently, he has discovered a new type\r\nof sequences which he called an almost arithmetical progression. A\r\nsequence is an , if its elements can be represented as: , where is some\r\ninteger; , where is some integer. Right now Gena has a piece of paper\r\nwith sequence , consisting of integers. Help Gena, find there the\r\nlongest subsequence of integers that is an almost arithmetical\r\nprogression.Sequence is a subsequence of sequence , if there is such\r\nincreasing sequence of indexes , that . In other words, sequence can be\r\nobtained from by crossing out some elements.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\nusing namespace std;\nint n;\nconst int MAX_N = 4000 + 10;\nint a[MAX_N];\n\ntemplate<class T>\nstruct Index: public vector<T> {\n\tusing vector<T>::erase;\n\tusing vector<T>::begin;\n\tusing vector<T>::end;\n\tvoid doit() {\n\t\tsort(begin(), end());\n\t\terase(unique(begin(), end()), end());\n\t}\n\tint get(T x) {\n\t\treturn lower_bound(begin(), end(), x) - begin();\n\t}\n};\nIndex<int> idx;\nint next[MAX_N][MAX_N];\nint dp[MAX_N][MAX_N];\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tidx.push_back(a[i]);\n\t}\n\tif (n <= 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tidx.doit();\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = idx.get(a[i]);\n\t}\n\tmemset(next[n], -1, sizeof next[n]);\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tmemcpy(next[i], next[i + 1], sizeof next[i]);\n\t\tnext[i][a[i]] = i;\n\t}\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tdp[i][j] = 2;\n\t\t\tint nxt = next[j + 1][a[i]];\n\t\t\tif (nxt != -1) {\n\t\t\t\tdp[i][j] = dp[j][nxt] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tans = max(ans, dp[i][j]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "dp", "two pointers"], "dificulty": "1500", "interactive": false}