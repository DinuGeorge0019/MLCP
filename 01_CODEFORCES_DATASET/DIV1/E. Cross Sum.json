{
    "link": "https://codeforces.com//contest/607/problem/E",
    "problemId": "43767",
    "problem_idx": "E",
    "shortId": "607E",
    "contest_number": "607",
    "problem_submissions": {
        "E": [
            14958443,
            14961849,
            14961838,
            14961831,
            16737326
        ],
        "D": [
            14951724,
            14952244,
            14950470,
            14950039,
            14952208,
            14949972,
            14952659,
            14968005,
            14967954,
            14967922,
            14967912,
            14967907,
            14967903,
            14967896,
            14967707,
            14967669,
            14956925,
            14956428,
            14958812,
            14957599,
            14953577,
            14952372,
            14951711,
            14957330,
            14954653,
            14952137,
            14951821,
            14954577,
            14952711
        ],
        "C": [
            14947368,
            14953869,
            14954714,
            14954225,
            14954959,
            14954407,
            14957641,
            14951200,
            14952263,
            14949536,
            14956671,
            14955594,
            14955895,
            14951583,
            14957050
        ],
        "B": [
            14944943,
            14943843,
            14943439,
            14944195,
            14944079,
            14951944,
            14944759,
            14945484,
            14944543,
            14945215,
            14944778,
            14945950,
            14944649,
            14947158,
            14943778,
            14944962,
            14948034,
            14943374,
            14945989
        ],
        "A": [
            14941938,
            14942696,
            14942042,
            14943122,
            14941989,
            14950953,
            14942232,
            14942613,
            14942728,
            14942057,
            14942385,
            14946665,
            14948612,
            14942429,
            14941952,
            14943906,
            14943291,
            15059376,
            14942040,
            14942093
        ]
    },
    "name": "E. Cross Sum",
    "statement": "Genos has been given distinct lines on the Cartesian plane. Let be a\r\nlist of intersection points of these lines. A single point might appear\r\nmultiple times in this list if it is the intersection of multiple pairs\r\nof lines. The order of the list does not matter.Given a query point ,\r\nlet be the corresponding list of distances of all points in to the query\r\npoint. Distance here refers to euclidean distance. As a refresher, the\r\neuclidean distance between two points and is .Genos is given a point and\r\na positive integer . He is asked to find the sum of the smallest\r\nelements in . Duplicate elements in are treated as separate elements.\r\nGenos is intimidated by Div1 E problems so he asked for your help.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\ninline int fpm(LL b, int e, int m)\n{\n\tb %= m;\n\tLL t = 1;\n\tfor ( ; e; e >>= 1, (b *= b) %= m)\n\t\tif (e & 1) (t *= b) %= m;\n\treturn t;\n}\n\nconst int Mod = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\n\nconst long double pi = acos(-1.0);\nconst long double eps = 1e-8;\n\ninline int dcmp(long double x) { return x < -eps ? -1 : x > eps; }\n\nstruct point\n{\n\tlong double x, y;\n\n\tpoint() { }\n\tpoint(const long double &_x, const long double &_y): x(_x), y(_y) { }\n\n\tfriend point operator+(const point &x, const point &y) { return point(x.x + y.x, x.y + y.y); }\n\tfriend point &operator+=(point &x, const point &y) { x.x += y.x, x.y += y.y; return x; }\n\tfriend point operator-(const point &x, const point &y) { return point(x.x - y.x, x.y - y.y); }\n\tfriend point &operator-=(point &x, const point &y) { x.x -= y.x, x.y -= y.y; return x; }\n\tfriend point operator*(const point &x, const long double &y) { return point(x.x * y, x.y * y); }\n\tfriend point operator/(const point &x, const long double &y) { return point(x.x / y, x.y / y); }\n\tfriend bool operator<(const point &x, const point &y) { if (!dcmp(x.x - y.x)) return dcmp(x.y - y.y) < 0; return x.x < y.x; }\n\tfriend long double operator*(const point &x, const point &y) { return x.x * y.x + x.y * y.y; }\n\tfriend long double operator^(const point &x, const point &y) { return x.x * y.y - x.y * y.x; }\n\n\tlong double angle() const{ return atan2(y, x); }\n\n};\n\nbool line_line(const point &P, const point &v, const point &Q, const point &w, long double &x)\n{\n\tpoint u = P - Q;\n\tif (!dcmp(v ^ w)) return 0;\n\tx = (w ^ u) / (v ^ w);\n\treturn 1;\n}\n\nbool line_cir(const point &u, const point &v, const point &O, const long double &r, long double &x, long double &y)\n{\n\tpoint w = u - O;\n\tlong double a = v * v, b = 2 * (v * w), c = w * w - r * r;\n\tlong double delta = b * b - 4 * (a * c);\n\tif (delta <= 0) return 0;\n\tdelta = sqrt(delta);\n\tx = (-b - delta) / (2 * a);\n\ty = (-b + delta) / (2 * a);\n\treturn 1;\n}\n\nconst int maxn = 50000;\nint n;\n\npoint O;\n\npoint s[maxn + 5], t[maxn + 5];\n\nvector<pair<pair<long double, long double>, int> > all;\nvector<long double> X;\nint c[maxn + 5];\n\ninline LL calc(long double mid)\n{\n\tall.clear();\n\tREP(j, 0, n)\n\t{\n\t\tlong double x, y;\n\t\tif (line_cir(s[j], t[j], O, mid, x, y)) \n\t\t{\n\t\t\tall.pb(mp(mp((s[j] + t[j] * x - O).angle(), (s[j] + t[j] * y - O).angle()), j));\n\t\t}\n\t}\n\tfor (auto &it : all) if (it.x.x > it.x.y) swap(it.x.x, it.x.y);\n\tX.clear();\n\tfor (auto it : all) X.pb(it.x.y);\n\tsort(ALL(X));\n\tsort(ALL(all));\n\tmemset(c, 0, sizeof c);\n\tLL cnt = 0;\n\tfor (auto it : all)\n\t{\n\t\tint tmp = lower_bound(ALL(X), it.x.y) - X.begin() + 1, tmp0 = lower_bound(ALL(X), it.x.x) - X.begin() + 1;\n\t\tfor (int i = tmp - 1; i > 0; i -= i & -i) cnt += c[i];\n\t\tfor (int i = tmp0 - 1; i > 0; i -= i & -i) cnt -= c[i];\n\t\tfor (int i = tmp; i <= n; i += i & -i) ++c[i];\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint m;\n\tscanf(\"%d\", &n);\n\tint x, y;\n\tscanf(\"%d%d%d\", &x, &y, &m);\n\tO = point(x / 1000.0, y / 1000.0);\n\tREP(i, 0, n)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ts[i] = point(0, b / 1000.0);\n\t\tt[i] = point(1, (a + b) / 1000.0);\n\t\tt[i] = t[i] - s[i];\n\t}\n\tlong double l = 0, r = 1e20; \n\tREP(i, 0, 120)\n\t{\n\t\tlong double mid = (l + r) / 2;\n\t\tif (calc(mid) >= m) r = mid;\n\t\telse l = mid;\n\t}\n\tdouble ans = 0;\n\tif (calc(l) > m) printf(\"0\\n\"); \n\telse\n\t{\n\t\tans += (m - calc(l)) * l;\n\t\tset<pair<int, int> > lyc;\n\t\tfor (auto it : all)\n\t\t{\n\t\t\tint tmp = lower_bound(ALL(X), it.x.y) - X.begin() + 1, tmp0 = lower_bound(ALL(X), it.x.x) - X.begin() + 1;\n\t\t\twhile (!lyc.empty() && lyc.begin()->x < tmp0) lyc.erase(lyc.begin());\n\t\t\tif (!lyc.empty())\n\t\t\t{\n\t\t\t\tfor (auto it0 : lyc)\n\t\t\t\t{\n\t\t\t\t\tif (it0.x >= tmp) break;\n\t\t\t\t\tlong double zzj;\n\t\t\t\t\tassert(line_line(s[it.y], t[it.y], s[it0.y], t[it0.y], zzj));\n\t\t\t\t\tpoint p = s[it.y] + t[it.y] * zzj;\n\t\t\t\t\tans += sqrt(max((long double)0, (p - O) * (p - O)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tlyc.insert(mp(tmp, it.y));\n\t\t}\n\t}\n\tprintf(\"%.15f\\n\", (double)ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "geometry"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Cross Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/22256",
    "editorial": "The problem boils down to summing the k closest intersections to a given query point.\n\nWe binary search on the distance d of kth farthest point. For a given distance d, the number of points within distance d of our query point is equivalent to the number of pairwise intersections that lie within a circle of radius d centered at our query point. To count the number of intersections, we can find the intersection points of the lines on the circle and sort them. Two lines which intersect will have overlapping intersection points on the circle (i.e. of the form ABAB where As and Bs are the intersection points of two lines). Counting the number of intersections can be done by DP.\n\nOnce we have d, we once again draw a circle of size d but this time we loop through all points in O(k) instead of counting the number of points.\n\nIt may happen that there are I?<?k intersections inside the circle of radius d but also I'?>?k inside a circle of radius d?+??. In this case, we should calculate the answer for d and add d(k?-?I).",
    "hint": []
}