{
    "link": "https://codeforces.com//contest/623/problem/D",
    "problemId": "47314",
    "problem_idx": "D",
    "shortId": "623D",
    "contest_number": "623",
    "problem_submissions": {
        "C": [
            15809186,
            15807923,
            15810181,
            15806671,
            15808652,
            15818870,
            15811297,
            15824389,
            15801567
        ],
        "D": [
            15802822,
            15804610,
            15804063,
            15810065,
            15809969,
            15800847,
            15801410,
            15804877,
            15805201,
            15809200,
            15805279,
            15805265,
            15803978,
            15806446,
            15804093,
            15805984,
            15809435,
            15808164
        ],
        "B": [
            15799385,
            15799937,
            15800370,
            15800033,
            15797877,
            15808021,
            15799907,
            15800024,
            15802615,
            15799613,
            15799768,
            15806416,
            15803166,
            15800459,
            15801892,
            15800003,
            15806962,
            15802319
        ],
        "A": [
            15794295,
            15794155,
            15793520,
            15793524,
            15802472,
            15806700,
            15794661,
            15793789,
            15793952,
            15802327,
            15793050,
            15794635,
            15796862,
            15810492,
            15795834,
            15794597,
            15792903,
            15798814
        ],
        "E": [
            15807539,
            15822584
        ]
    },
    "name": "D. Birthday",
    "statement": "A MIPT student named Misha has a birthday today, and he decided to\r\ncelebrate it in his country house in suburban Moscow. friends came by,\r\nand after a typical party they decided to play blind man’s buff.The\r\nbirthday boy gets blindfolded and the other players scatter around the\r\nhouse. The game is played in several rounds. In each round, Misha\r\ncatches exactly one of his friends and has to guess who it is. The\r\nprobability of catching the -th friend does not change between rounds\r\nand is equal to percent (as we know, it is directly proportional to the\r\namount of alcohol consumed by the -th friend) and holds. Misha has no\r\ninformation about who he caught. After Misha makes an attempt to guess\r\nthe caught person, the round ends. Even then, Misha isn’t told whether\r\nhe guessed correctly, and a new round begins.The game ends when Misha\r\nguesses every friend at least once, that is, there exists such set of\r\nrounds , that during round number Misha caught the -th friend and\r\nguessed him. Misha wants to minimize the expectation of the number of\r\nrounds of the game. Despite the fact that at any point in the game Misha\r\nhas no information about who he has already guessed, his friends are\r\nhonest, and if they see that the condition for the end of the game is\r\nfulfilled, the game ends immediately. Find the expectation of the number\r\nof rounds in the game if Misha plays optimally.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 101;\n\nint N;\nint rval[MAXN];\ndouble cprob[MAXN];\npriority_queue <pair <double, int> > pq;\n\nint main()\n{\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> rval[i];\n    \n    for (int i = 0; i < N; i++)\n    {\n        pq.push (make_pair (1e9, i));\n        cprob[i] = 0;\n    }\n    \n    double ans = 0, tot = 0;\n    for (int i = 1; i <= 3e6; i++)\n    {\n        pair <double, int> ptop = pq.top();\n        pq.pop();\n        \n        double rrate = ptop.first;\n        int rloc = ptop.second;\n        \n        cprob[rloc] += rval[rloc] / 100. * (1 - cprob[rloc]);\n        \n        if (rrate > 1e8)\n        {\n            tot = 1.;\n            for (int j = 0; j < N; j++)\n                tot *= cprob[j];\n            ans += tot * i;\n        }\n        else\n        {\n            ans += (rrate - 1) * tot * i;\n            tot *= rrate;\n        }\n        \n        double nadd = rval[rloc] / 100. * (1 - cprob[rloc]);\n        pq.push (make_pair (nadd / cprob[rloc] + 1, rloc));\n    }\n    \n    cout << fixed << setprecision(8);\n    cout << ans << \"\\n\";\n    //system (\"Pause\");\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "probabilities"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Birthday.json",
    "editorial_link": "https://codeforces.com//blog/entry/23278",
    "editorial": "Letâs denote . Main idea: first of all guess each friend once, then\r\nmaximize probability to end game on current step. Letâs simulate first\r\n300000 steps, and calculate . , where how many times we called -th\r\nfriend (). Expectation with some precision equals . So it is enough to\r\nprove that: 1) Greedy strategy gives maximum values for all . 2) On\r\n300000 step precision error will be less than . Proof: 1) Suppose, that\r\nfor some there exists set (), not equal to set produced by greedy\r\nalgorithm , gives the maximum value of . Letâs take some and , it is\r\neasy to prove tgat if we change to , to , then new set of gives bigger\r\nvalue of , contradiction. 2) . Letâs take set , it gives probability of\r\nend of the game not less than optimal. Then . Precision error does not\r\nexceed . It could be estimated as sum of geometric progression. If\r\nprecision error doesnât exceed .\r\n",
    "hint": []
}