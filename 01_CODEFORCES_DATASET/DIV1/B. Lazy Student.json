{"link": "https://codeforces.com//contest/605/problem/B", "problemId": "42718", "problem_idx": "B", "shortId": "605B", "contest_number": "605", "problem_submissions": {"C": [14733414, 14720384, 14720999, 14727321, 14722464, 14721634, 14727835, 14731363, 14731595, 14730092, 14726129, 14721720, 14724282, 14722284, 14722209, 14728049], "D": [14724788, 14728609, 14730065, 14729000, 14724493, 14732219, 14728421, 14723804, 14721730, 14724221, 14732566, 14780111, 14732774, 14732416, 14730015, 14724377], "A": [14722715, 14715950, 14715817, 14716990, 14715828, 14715926, 14717224, 14715773, 14715784, 14715907, 14716365, 14720150, 14715839, 14716429, 14716499, 14716967, 14715831, 14715776], "B": [14721948, 14718121, 14718105, 14718689, 14718666, 14718313, 14719575, 14717722, 14717902, 14718552, 14718421, 14718419, 14718059, 14719671, 14718443, 14719771, 14718528, 14719776], "E": [14718635, 14725044, 14723153, 14726864, 14729961, 14722181, 14723791, 14727330, 14729035, 14727305, 14723008, 14728473, 14728113, 14731024, 14729704, 14736246, 14736224]}, "name": "B. Lazy Student", "statement": "Student Vladislav came to his programming exam completely unprepared as\r\nusual. He got a question about some strange algorithm on a graph\r\nsomething that will definitely never be useful in real life. He asked a\r\ngirl sitting next to him to lend him some cheat papers for this\r\nquestions and found there the following definition: of graph is such a\r\ntree that it contains all the vertices of the original graph , and the\r\nsum of the weights of its edges is the minimum possible among all such\r\ntrees.Vladislav drew a graph with vertices and edges containing no loops\r\nand multiple edges. He found one of its minimum spanning trees and then\r\nwrote for each edge its weight and whether it is included in the found\r\ntree or not. Unfortunately, the piece of paper where the graph was\r\npainted is gone and the teacher is getting very angry and demands to see\r\nthe original graph. Help Vladislav come up with a graph so that the\r\ninformation about the minimum spanning tree remains correct.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,m;\npair<int,PII> p[N];\nPII e[N];\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d\",&p[i].fi,&p[i].se.fi);\n\t\tp[i].se.fi*=-1; p[i].se.se=i;\n\t}\n\tsort(p,p+m);\n\tint cnt=0; ll E=0; PII pre=mp(2,1);\n\trep(i,0,m) {\n\t\tint id=p[i].se.se;\n\t\tif (p[i].se.fi==-1) { cnt++; E+=cnt; e[id]=mp(0,cnt); }\n\t\telse {\n\t\t\tif (E==0) {\n\t\t\t\tputs(\"-1\"); return 0;\n\t\t\t} else {\n\t\t\t\te[id]=pre;\n\t\t\t\tpre.se++;\n\t\t\t\tif (pre.se==pre.fi) pre.fi++,pre.se=1;\n\t\t\t}\n\t\t}\n\t\t--E;\n\t}\n\trep(i,0,m) {\n\t\tprintf(\"%d %d\\n\",e[i].fi+1,e[i].se+1);\n\t}\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "graphs"], "dificulty": "1700", "interactive": false}