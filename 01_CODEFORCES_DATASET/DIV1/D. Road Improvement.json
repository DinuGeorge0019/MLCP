{
    "link": "https://codeforces.com//contest/543/problem/D",
    "problemId": "27506",
    "problem_idx": "D",
    "shortId": "543D",
    "contest_number": "543",
    "problem_submissions": {
        "C": [
            11031273,
            11032297,
            11028921,
            11027662,
            11035224,
            11032105,
            11026578,
            11030569,
            11027731,
            11030889,
            11031150,
            11032259,
            11039311,
            11029744,
            11031844,
            11033030,
            11027751,
            11027833,
            11030513
        ],
        "D": [
            11026961,
            11027152,
            11029036,
            11027586,
            11028656,
            11027275,
            11031263,
            11026257,
            11029360,
            11029505,
            11032424,
            11028940,
            11031163,
            11035849,
            11028432
        ],
        "B": [
            11024775,
            11024536,
            11030599,
            11035262,
            11024794,
            11024869,
            11025321,
            11028836,
            11028474,
            11031647,
            11025986,
            11024625,
            11027272,
            11029817,
            11024295,
            11024309
        ],
        "A": [
            11022855,
            11023048,
            11023174,
            11022792,
            11022796,
            11023075,
            11030178,
            11022790,
            11023930,
            11023772,
            11022768,
            11023607,
            11023159,
            11022742,
            11022813,
            11022885
        ]
    },
    "name": "D. Road Improvement",
    "statement": "The country has cities and bidirectional roads, it is possible to get\r\nfrom every city to any other one if you move only along the roads. The\r\ncities are numbered with integers from to inclusive.All the roads are\r\ninitially bad, but the government wants to improve the state of some\r\nroads. We will assume that the citizens are happy about road improvement\r\nif the path from the capital located in city to any other city contains\r\nat most one bad road.Your task is for every possible determine the\r\nnumber of ways of improving the quality of some roads in order to meet\r\nthe citizens\u2019 condition. As those values can be rather large, you need\r\nto print each value modulo ().\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n\n#ifdef _WIN32\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n\ntypedef long double ld;\n\nlong long rdtsc() {\n  long long tmp;\n  asm(\"rdtsc\" : \"=A\"(tmp));\n  return tmp;\n}\n\ninline int myrand() {\n  return abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n  return myrand() % x;\n}\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME \"text\"\n\nconst int INF = (int)1e9 + 1;\nconst ld EPS = 1e-9;\n\nvoid precalc() {\n}\n\nint n;\n\nconst int maxn = (int) 2e5 + 10;\nint pr[maxn];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  pr[0] = -1;\n  for (int i = 1; i < n; ++i) {\n    scanf(\"%d\", &pr[i]);\n    --pr[i];\n  }\n  return 1;\n}\n\nconst int MOD = (int) 1e9 + 7;\n\nint mult(int x, int y) {\n  return (long long) x * y % MOD;\n}\n\nvector<vector<int> > es;\n\nint f[maxn];\n\nvoid dfs(int v) {\n  int &res = f[v];\n  res = 1;\n  for (int it = 0; it < sz(es[v]); ++it) {\n    int u = es[v][it];\n    dfs(u);\n    res = mult(res, f[u] + 1);\n  }\n}\n\nint ans[maxn];\n\nvoid dfsLast(int v, int coef = 0) {\n  ++coef;\n  if (coef == MOD) {\n    coef = 0;\n  }\n  int &res = f[v];\n  res = 1;\n  int k  = sz(es[v]);\n  vector<int> pref(k + 1);\n  vector<int> suf(k + 1);\n  pref[0] = 1;\n  for (int i = 0; i < k; ++i) {\n    pref[i + 1] = mult(pref[i], f[es[v][i]] + 1);\n  }\n  suf[k] = 1;\n  for (int i = k - 1; i >= 0; --i) {\n    suf[i] = mult(suf[i + 1], f[es[v][i]] + 1);\n  }\n\n  ans[v] = mult(pref[k], coef);\n  for (int it = 0; it < k; ++it) {\n    int u = es[v][it];\n    dfsLast(u, mult(coef, mult(pref[it], suf[it + 1])));\n  }\n}\n\nvoid solve() {\n  es = vector<vector<int> >(n);\n  for (int i = 1; i < n; ++i) {\n    es[pr[i]].pb(i);\n  }\n\n  dfs(0);\n\n  dfsLast(0);\n  for (int i = 0; i < n; ++i) {\n    printf(\"%d%c\", ans[i], \" \\n\"[i == n - 1]);\n  }\n}\n\nint main() {\n  srand(rdtsc());\n#ifdef DEBUG\n  freopen(TASKNAME\".out\", \"w\", stdout);\n  assert(freopen(TASKNAME\".in\", \"r\", stdin));\n#endif\n\n  precalc();\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"%.18lf\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Road Improvement.json",
    "editorial_link": "https://codeforces.com//blog/entry/17773",
    "editorial": "Let\u00e2\u0080\u0099s suppose is a root of tree. Let\u00e2\u0080\u0099s calculate extra dynamic\r\nprogramming answer to the problem for sub-tree with root We can\r\nunderstand, that d[i] equals to the following value: where is a child of\r\nthe vertex . It\u00e2\u0080\u0099s nice. After that answer to problem for first vertex\r\nequal to . After that let\u00e2\u0080\u0099s study how to make child of current root as\r\nnew root of tree. We need to recalculate only two values and . First\r\nvalue we can recalculate using following formula : , where is the parent\r\nof vertex , (for vertex ), and array is the product of values , for all\r\nchilds of vertex and ( have same definition, but ). And after we can\r\ncalculate as . That is all, is root now, and answer to vertex equals to\r\ncurrent value The jury solution: 11035737\r\n"
}