{"link": "https://codeforces.com//contest/383/problem/C", "problemId": "5724", "problem_idx": "C", "shortId": "383C", "contest_number": "383", "problem_submissions": {"B": [5756409, 5751225, 5757744, 5753341, 5808519, 5808489, 5808447, 5758844, 5759238, 5752874, 5755308, 5752676, 5753907, 5753281, 5756832, 5755532], "E": [5754649, 5757705, 5753388, 5758136, 5808454, 5755553, 5754159, 5755881, 5756030, 5755626, 5754883, 5757327, 5758405, 5757943], "D": [5753594, 5752449, 5752307, 5754262, 5808453, 5751984, 5752563, 5753410, 5753070, 5753481, 5755159, 5755983, 5755452, 5753533, 5756037, 5756133, 5757148, 5756616, 5755389, 5756824], "C": [5750456, 5751886, 5754923, 5749119, 5751328, 5751146, 5750311, 5750868, 5752299, 5751003, 5750201, 5751936, 5751653, 5754669, 5750989, 5754841, 5751430, 5750434], "A": [5747280, 5747986, 5747387, 5747246, 5808450, 5747221, 5747445, 5747936, 5747254, 5748686, 5747361, 5747734, 5747935, 5748612, 5748223, 5747638, 5747622, 5749616, 5757219]}, "name": "C. Propagating tree", "statement": "Iahub likes trees very much. Recently he discovered an interesting tree\r\nnamed propagating tree. The tree consists of nodes numbered from to ,\r\neach node having an initial value . The root of the tree is node .This\r\ntree has a special property: when a value is added to a value of node ,\r\nthe value - is added to values of all the children of node . Note that\r\nwhen you add value - to a child of node , you also add -(-) to all\r\nchildren of the child of node and so on. Look an example explanation to\r\nunderstand better how it works.This tree supports two types of queries:\r\n\" \" is added to the value of node ; \" \" print the current value of node\r\n. In order to help Iahub understand the tree better, you must answer\r\nqueries of the preceding type.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nclass fenv_tree {\n  vi tr;\n  static int f(int x) { return x & -x; }\n\n  int _get(int x) {\n    int res = 0;\n    for (x++; x > 0; x -= f(x))\n      res += tr[x];\n    return res;\n  }\n  void _add(int x, int val) {\n    for (x++; x < sz(tr); x += f(x))\n      tr[x] += val;\n  }\n\n  public:\n  fenv_tree(int n) : tr(n + 1, 0) {}\n  int get(int x) {\n    return _get(x);\n  }\n  void add(int l, int r, int val) {\n    _add(l, val);\n    _add(r + 1, -val);\n  }\n};\n\nvvi es;\nvi seq, start, end;\nvi hs;\n\nvoid dfs(int v) {\n  if (start[v] >= 0) return;\n  start[v] = sz(seq);\n  seq.pb(v);\n  for (int i = 0; i < sz(es[v]); i++) {\n    int b = es[v][i];\n    hs[b] = hs[v] ^ 1;\n    dfs(b);\n  }\n  end[v] = sz(seq) - 1;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) >= 1) {\n    vi svals(n);\n    for (int i = 0; i < n; i++)\n      scanf(\"%d\", &svals[i]);\n\n    es = vvi(n);\n    for (int i = 0; i < n - 1; i++) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b), a--, b--;\n      es[a].pb(b);\n      es[b].pb(a);\n    }\n\n    seq = vi();\n    start = vi(n, -1);\n    end = vi(n, -1);\n    hs = vi(n, 0);\n    dfs(0);\n\n    assert(sz(seq) == n);\n    fenv_tree trs[2] = { fenv_tree(n), fenv_tree(n) };\n    for (int i = 0; i < n; i++) {\n      trs[hs[i]].add(start[i], start[i], svals[i]);\n    }\n\n//    for (int i = 0; i < n; i++)\n//      eprintf(\"%d%c\", seq[i] + 1, \"\\n \"[i + 1 < n]);\n\n    while (m --> 0) {\n      int ty, x;\n      scanf(\"%d%d\", &ty, &x), x--;\n      if (ty == 1) {\n        int val;\n        scanf(\"%d\", &val);\n\n        trs[hs[x]].add(start[x], end[x], val);\n        trs[!hs[x]].add(start[x], end[x], -val);\n      } else {\n        int res = 0;\n        res += trs[hs[x]].get(start[x]);\n        printf(\"%d\\n\", res);\n      }\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "trees"], "dificulty": "2000", "interactive": false}