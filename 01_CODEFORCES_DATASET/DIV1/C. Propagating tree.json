{
    "link": "https://codeforces.com//contest/383/problem/C",
    "problemId": "5724",
    "problem_idx": "C",
    "shortId": "383C",
    "contest_number": "383",
    "problem_submissions": {
        "B": [
            5756409,
            5751225,
            5757744,
            5753341,
            5808519,
            5808489,
            5808447,
            5758844,
            5759238,
            5752874,
            5755308,
            5752676,
            5753907,
            5753281,
            5756832,
            5755532
        ],
        "E": [
            5754649,
            5757705,
            5753388,
            5758136,
            5808454,
            5755553,
            5754159,
            5755881,
            5756030,
            5755626,
            5754883,
            5757327,
            5758405,
            5757943
        ],
        "D": [
            5753594,
            5752449,
            5752307,
            5754262,
            5808453,
            5751984,
            5752563,
            5753410,
            5753070,
            5753481,
            5755159,
            5755983,
            5755452,
            5753533,
            5756037,
            5756133,
            5757148,
            5756616,
            5755389,
            5756824
        ],
        "C": [
            5750456,
            5751886,
            5754923,
            5749119,
            5751328,
            5751146,
            5750311,
            5750868,
            5752299,
            5751003,
            5750201,
            5751936,
            5751653,
            5754669,
            5750989,
            5754841,
            5751430,
            5750434
        ],
        "A": [
            5747280,
            5747986,
            5747387,
            5747246,
            5808450,
            5747221,
            5747445,
            5747936,
            5747254,
            5748686,
            5747361,
            5747734,
            5747935,
            5748612,
            5748223,
            5747638,
            5747622,
            5749616,
            5757219
        ]
    },
    "name": "C. Propagating tree",
    "statement": "Iahub likes trees very much. Recently he discovered an interesting tree\r\nnamed propagating tree. The tree consists of nodes numbered from to ,\r\neach node having an initial value . The root of the tree is node .This\r\ntree has a special property: when a value is added to a value of node ,\r\nthe value - is added to values of all the children of node . Note that\r\nwhen you add value - to a child of node , you also add -(-) to all\r\nchildren of the child of node and so on. Look an example explanation to\r\nunderstand better how it works.This tree supports two types of queries:\r\n\" \" is added to the value of node ; \" \" print the current value of node\r\n. In order to help Iahub understand the tree better, you must answer\r\nqueries of the preceding type.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nclass fenv_tree {\n  vi tr;\n  static int f(int x) { return x & -x; }\n\n  int _get(int x) {\n    int res = 0;\n    for (x++; x > 0; x -= f(x))\n      res += tr[x];\n    return res;\n  }\n  void _add(int x, int val) {\n    for (x++; x < sz(tr); x += f(x))\n      tr[x] += val;\n  }\n\n  public:\n  fenv_tree(int n) : tr(n + 1, 0) {}\n  int get(int x) {\n    return _get(x);\n  }\n  void add(int l, int r, int val) {\n    _add(l, val);\n    _add(r + 1, -val);\n  }\n};\n\nvvi es;\nvi seq, start, end;\nvi hs;\n\nvoid dfs(int v) {\n  if (start[v] >= 0) return;\n  start[v] = sz(seq);\n  seq.pb(v);\n  for (int i = 0; i < sz(es[v]); i++) {\n    int b = es[v][i];\n    hs[b] = hs[v] ^ 1;\n    dfs(b);\n  }\n  end[v] = sz(seq) - 1;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) >= 1) {\n    vi svals(n);\n    for (int i = 0; i < n; i++)\n      scanf(\"%d\", &svals[i]);\n\n    es = vvi(n);\n    for (int i = 0; i < n - 1; i++) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b), a--, b--;\n      es[a].pb(b);\n      es[b].pb(a);\n    }\n\n    seq = vi();\n    start = vi(n, -1);\n    end = vi(n, -1);\n    hs = vi(n, 0);\n    dfs(0);\n\n    assert(sz(seq) == n);\n    fenv_tree trs[2] = { fenv_tree(n), fenv_tree(n) };\n    for (int i = 0; i < n; i++) {\n      trs[hs[i]].add(start[i], start[i], svals[i]);\n    }\n\n//    for (int i = 0; i < n; i++)\n//      eprintf(\"%d%c\", seq[i] + 1, \"\\n \"[i + 1 < n]);\n\n    while (m --> 0) {\n      int ty, x;\n      scanf(\"%d%d\", &ty, &x), x--;\n      if (ty == 1) {\n        int val;\n        scanf(\"%d\", &val);\n\n        trs[hs[x]].add(start[x], end[x], val);\n        trs[!hs[x]].add(start[x], end[x], -val);\n      } else {\n        int res = 0;\n        res += trs[hs[x]].get(start[x]);\n        printf(\"%d\\n\", res);\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Propagating tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/10476",
    "editorial": "This is kind of task that needs to be break into smaller subproblems that you can solve independently, then put them together and get solution.\n\nLets define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on.\n\nNow suppose you want to do an operation of type 1 to a node x. What nodes from subtree of x will be added +val (a positive value)? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will be added val. Sons of sons, located at level L + 2, will be added value +val again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be added a +val, and nodes located at levels L + 1, L + 3, L + 5 will be added a val. Lets take those values of L modulo 2. All nodes having remainder L modulo 2 will be added a +val, and nodes having reminder (L + 1) modulo 2 will be added val. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, +val will be added to y. Otherwise, -val will be added to y.\n\nFrom here we have the idea to split nodes of tree in 2 sets  those being located at even level and those being located at odd level. What still makes the problem hard to solve? The fact that we have a tree. If nodes from a subtree would be a contiguous sequence instead of some nodes from a tree, problem would be simpler: the problem would reduce to add / subtract values to all elements of a subarray and query about a current value of an element of array. So, how can we transform tree to an array, such as for a node x, all nodes from subtree of x to be a subarray of array?\n\nThe answer is yes. We can do this by properties of DFS search. Before reading on, make sure that you know what is discovery time and finish time in a DFS search. Lets build 3 arrays now  discover[], representing nodes in order of their discover times (a node is as before in discover as it has a small discover time), begin[] = for a node, in which time it was discovered and end[] = whats last time of a discovered node before this node finishes. For a subtree of x, all nodes in the subtree are nodes in discover from position begin[x] to end[x].\n\nExample: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3\n\nDiscover is {1, 5, 6, 7, 4, 2, 3}.\n\nbegin is {1, 6, 7, 5, 2, 3, 4}.\n\nend is {7, 6, 7, 7, 2, 7, 4}.\n\nWhats subtree of node 6? elements of discover from position begin[6] to end[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can see its correct and take more examples if you want :)\n\nNow, we reduced problem to: youre given an array A. you can perform 2 operations:\n\n1/ increase all elements from a range [x, y] to a value val (val can be negative, to treat subtractions)\n\n2/ whats current value of an element from position pos.\n\nThose who solved Iahub and Xors from my last round, CF 198, should probably say they saw something similar before. If you didnt solve problem before, I encourage you to do it after you solve this one, it uses a similar idea to what will follow now. Also, if you dont know Fenwick trees, please read them before moving on. An alternative would be for this task using segment trees with lazy update, but I see this one more complicated than needed.\n\nIll use now a not so common approach when dealing with data structures. Instead of keeping in a node the result, like you usually do, Ill keep just an auxiliary information. So what algorithm proposed does:\n\nLet A an array, initially with all elements 0.\n\nWhen you need to update range [x, y] with value val, you simply do A[x] += val and A[y + 1] -= val.\n\nWhen you need to answer a query about position pos, you output A[1] + A[2] + ... + A[pos].\n\nImplemented brute force, you get O(1) per update and O(N) per query. However, these both are operations supported by a Fenwick tree, so you can get O(logN) per operation.\n\nIt may not be very clear why this algorithm works. Lets take a closer look: an update needs to add value val only to range [x, y]. When you query a position pos, lets see if algorithm handles it correctly:\n\n1/ pos < x. In this case, result must not be affected by my update. Since pos < x and I only updated 2 values with indices >= x, when doing A[1] + A[2] + ... + A[pos] it wont matter at all I did that update  at least not for this query.\n\n2/ x <= pos <= y. Here, for a pos, I need to add value val only once. We add it only at A[x]  in this way it will be counted once, and it will be considered for each elements from range [x, y] (since an element at position p from range [x, y] has p >= x, in A[1] + A[2] + ... + A[p] Ill have to consider A[x]).\n\n3/ pos > y. Here I dont have to consider the query. But it would be considered when processing A[x]. But if I add to A[y + 1] value val Ill just cancel the value previously added.",
    "hint": []
}