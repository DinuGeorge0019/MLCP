{
    "link": "https://codeforces.com//contest/220/problem/C",
    "problemId": "1618",
    "problem_idx": "C",
    "shortId": "220C",
    "contest_number": "220",
    "problem_submissions": {
        "D": [
            2080540,
            2080418,
            2074895,
            2078075,
            2079217,
            2081403,
            2081824,
            2081006,
            2076381,
            2093601,
            2093590,
            3084971,
            2086233
        ],
        "E": [
            2078891,
            2078702,
            2081885,
            2081411,
            2081777,
            2080333,
            2079988,
            2077021,
            2081284,
            2080936,
            2080773,
            2080185,
            2080971,
            2082030,
            2080110,
            2081659,
            2081994,
            2086312,
            2082178
        ],
        "C": [
            2077244,
            2077402,
            2078300,
            2079325,
            2076073,
            2077207,
            2078341,
            2080109,
            2076476,
            2078366,
            2079100,
            2080050,
            2078605,
            2081663,
            2079424,
            2078933,
            2080721
        ],
        "B": [
            2074621,
            2083029,
            2082854,
            2073372,
            2075693,
            2075380,
            2073348,
            2074150,
            2075655,
            2074877,
            2074146,
            2076125,
            2083532,
            2074043,
            2074785,
            2086353,
            2077672,
            2098154,
            2098144,
            2076395,
            2075929,
            2074543
        ],
        "A": [
            2072304,
            2072260,
            2072332,
            2072289,
            2079727,
            2072355,
            2072380,
            2072450,
            2072425,
            2072416,
            2072763,
            2072261,
            2072442,
            2073395,
            2073046,
            2072395,
            2072278
        ]
    },
    "name": "C. Little Elephant and Shifts",
    "statement": "The Little Elephant has two permutations and of length , consisting of\r\nnumbers from 1 to , inclusive. Let\u2019s denote the -th element of the\r\npermutation as , the -th element of the permutation as .The between\r\npermutations and is the minimum absolute value of the difference between\r\nthe positions of the occurrences of some number in and in . More\r\nformally, it\u2019s such minimum , that .A number of permutation consisting\r\nfrom elements is a permutation . Overall a permutation has cyclic\r\nshifts.The Little Elephant wonders, for all cyclic shifts of permutation\r\n, what is the distance between the cyclic shift and permutation ?\r\n",
    "solutions": [
        "// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint to[101000];\nint dif[101000];\nint ans[101000];\ninline int ABS(int a){return a>0?a:-a;}\nint main(){\n    int n,i,j;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        int a;\n        scanf(\"%d\",&a);\n        to[a]=i;\n    }\n    for(i=1;i<=n;i++){\n        int a;\n        scanf(\"%d\",&a);\n        dif[i]=to[a]-i;\n        ans[i]=101000;\n    }\n    ans[0]=101000;\n    set<int> XD;\n    for(i=1;i<=n;i++){\n        XD.insert(dif[i]);\n        set<int>::iterator it=XD.lower_bound(n-i);\n        if(it!=XD.end()){\n            ans[i]=min(ans[i],ABS(*it-(n-i)));\n        }\n        if(it!=XD.begin()){\n            it--;\n            ans[i]=min(ans[i],ABS(*it-(n-i)));\n        }\n    }\n    XD.clear();\n    for(i=n;i>=1;i--){\n        XD.insert(dif[i]);\n        set<int>::iterator it=XD.lower_bound(-(i-1));\n        if(it!=XD.end()){\n            ans[i-1]=min(ans[i-1],ABS(*it+(i-1)));\n        }\n        if(it!=XD.begin()){\n            it--;\n            ans[i-1]=min(ans[i-1],ABS(*it+(i-1)));\n        }\n    }\n    ans[0]=min(ans[0],ans[n]);\n    for(i=0;i<n;i++)printf(\"%d\\n\",ans[i]);\n}\n// vim: fdm=marker:commentstring=\\ \\\"\\ %s:nowrap:autoread\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Little Elephant and Shifts.json",
    "editorial_link": "https://codeforces.com//blog/entry/5177",
    "editorial": "Each of the shifts can be divided into two parts the right (the one that\r\nstarts from occurrence 1) and the left (the rest of the elements). If we\r\ncould keep minimal distance for each part, the minimal of these numbers\r\nwill be the answers for the corresponding shift. Lets solve the problems\r\nof the right part, the left will be almost the same. Let we have some\r\nshift, for example and the permutation is and is , then shifted is . Let\r\nwe keep two sets ( and ). The first will keep all the distances from\r\nintegers in current left part to the corresponding positions in (for the\r\nexample above, it is\r\ntexttt{2, 4}). When you come to the next shift, all integers in should\r\nbe decreased by 1 (that is because all distances are also decreased by\r\n1). But now some integers in set may be negative, when any negative\r\ninteger occures (it always will be -1) you need to delete it from and\r\nput 1 to the . Also after shifting to the next shifts, all integers in\r\nmust be increase by 1. After that, for any shift, the answer will be\r\nminimum from the smallest numbers in and . It was very useful to use\r\nstandart \"set\" in C++.\r\n"
}