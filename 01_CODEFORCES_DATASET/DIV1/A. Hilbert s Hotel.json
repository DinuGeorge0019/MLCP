{
    "link": "https://codeforces.com//contest/1344/problem/A",
    "problemId": "600701",
    "problem_idx": "A",
    "shortId": "1344A",
    "contest_number": "1344",
    "problem_submissions": {
        "E": [
            79212522,
            79191531,
            80590953,
            79212872,
            79212690,
            79200320,
            79201434,
            79211282,
            79212433,
            79201854
        ],
        "F": [
            79198229,
            79194392,
            79201012,
            79200076,
            79187834,
            79207199,
            79809754,
            79207634,
            79321670,
            79237209
        ],
        "D": [
            79171968,
            79177519,
            79172745,
            79182190,
            79179127,
            79200953,
            79290388,
            79290327,
            79290278,
            79290202,
            79290106,
            79289995,
            79289887,
            79289860,
            79289837,
            79289762,
            79289686,
            79289607,
            79289576,
            79289521,
            79289422,
            79289347,
            79289280,
            79289191,
            79289098,
            79289025,
            79288951,
            79288889,
            79288802,
            79288740,
            79288714,
            79288657,
            79288619,
            79288562,
            79288537,
            79288505,
            79288461,
            79288426,
            79288386,
            79288343,
            79288285,
            79288204,
            79288164,
            79288116,
            79288088,
            79288039,
            79288012,
            79287980,
            79287919,
            79287860,
            79287808,
            79287736,
            79287668,
            79287637,
            79287604,
            79287566,
            79287547,
            79287511,
            79287459,
            79287434,
            79287397,
            79287350,
            79287296,
            79287262,
            79287211,
            79287167,
            79287127,
            79287079,
            79286996,
            79286949,
            79286890,
            79286845,
            79286781,
            79286728,
            79286696,
            79286656,
            79286614,
            79286579,
            79286534,
            79286474,
            79286420,
            79286389,
            79286352,
            79286300,
            79286206,
            79286092,
            79286033,
            79286000,
            79285960,
            79285920,
            79285841,
            79285783,
            79285724,
            79285687,
            79285642,
            79285596,
            79285548,
            79285495,
            79285449,
            79285406,
            79285333,
            79285275,
            79285210,
            79285148,
            79285111,
            79285080,
            79284856,
            79284810,
            79284730,
            79284667,
            79284608,
            79284558,
            79284511,
            79284467,
            79284408,
            79284359,
            79276900,
            79215004,
            79179390,
            79207200,
            79185960,
            79183492,
            79185743,
            79185899,
            79187272,
            79188204,
            79183059,
            79193595,
            79192774,
            79231073,
            79194712,
            79198266
        ],
        "C": [
            79163958,
            79167940,
            79163314,
            79167454,
            79171067,
            79172648,
            79188375,
            79171587,
            79170701,
            79174750,
            79169461,
            79175789,
            79173516,
            79172995,
            79172803,
            79176868,
            79181841,
            79172312,
            79173542,
            79175559
        ],
        "B": [
            79155063,
            79159060,
            79154263,
            79156872,
            79158896,
            79185288,
            79162853,
            79161753,
            79161038,
            79159421,
            79159787,
            79164882,
            79163754,
            79164480,
            79160984,
            79160540,
            79164542,
            79181585,
            79178109,
            79166538
        ],
        "A": [
            79148759,
            79148909,
            79148790,
            79148832,
            79148971,
            79151724,
            79149355,
            79151000,
            79150191,
            79163668,
            79149361,
            79149785,
            79152609,
            79150965,
            79162044,
            79148915,
            79156438,
            79149648,
            79150451,
            79148779
        ]
    },
    "name": "A. Hilbert s Hotel",
    "statement": "Hilbert\u2019s Hotel is a very unusual hotel since the number of rooms is\r\ninfinite! In fact, there is exactly one room for every integer, . Even\r\nstranger, the hotel is currently at full capacity, meaning there is\r\nexactly one guest in every room. The hotel\u2019s manager, David Hilbert\r\nhimself, decides he wants to shuffle the guests around because he thinks\r\nthis will create a vacancy (a room without a guest).For any integer k\r\nand positive integer n, let k\r\nbmod n denote the remainder when k is divided by n. More formally, r=k\r\nbmod n is the smallest non-negative integer such that k-r is divisible\r\nby n. It always holds that 0\r\nle k\r\nbmod n\r\nle n-1. For example, 100\r\nbmod 12=4 and (-1337)\r\nbmod 3=1.Then the shuffling works as follows. There is an array of n\r\nintegers a_0,a_1,\r\nldots,a_{n-1}. Then for each integer k, the guest in room k is moved to\r\nroom number k+a_{k\r\nbmod n}.After this shuffling process, determine if there is still\r\nexactly one guest assigned to each room. That is, there are no vacancies\r\nor rooms with multiple guests.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint n;\n\nvoid solve() {\n\tre(n);\n\tvi a(n); re(a);\n\tset<int> s;\n\tF0R(i,n) {\n\t\tint x = i+a[i];\n\t\tx = (x%n+n)%n;\n\t\ts.insert(x);\n\t}\n\tif (sz(s) == n) ps(\"YES\");\n\telse ps(\"NO\");\n}\n\nint main() {\n\tsetIO();\n\tint t; re(t); F0R(i,t) solve();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Hilbert s Hotel.json",
    "editorial_link": "https://codeforces.com//blog/entry/76819",
    "editorial": "Suppose that i+ai?j+aj(modn)\n for some 0?i<j<n\n. Then i+ai=j+aj+kn\n for some integer k\n, so the guest in room i\n is assigned the same room as guest j+kn\n.\n\nSimilarly, suppose that two different guests k\n and m\n are assigned the same room. Then we have i+ai?j+aj(modn)\n for i=kmodn\n and j=mmodn\n.\n\nThis proves there is a collision if and only if all i+ai\n are not distinct (modn)\n. That is, {(0+a0)modn,(1+a1)modn,\u0085,(n?1+an?1)modn}={0,1,\u0085,n?1}\n. This is simply checked with a boolean array to make sure each number from 0\n to n?1\n is included.\n\nNote that there are also no vacancies if this condition holds: Let k\n be some room. Then kmodn\n must appear in the array, so there is some i\n with i+ai?k(modn)\n. Then there is an integer m\n with i+mn+ai=k\n, meaning guest i+mn\n is moved to room k\n.\n\nComplexity is O(n)\n."
}