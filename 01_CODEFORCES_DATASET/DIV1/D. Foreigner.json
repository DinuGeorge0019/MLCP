{
    "link": "https://codeforces.com//contest/1142/problem/D",
    "problemId": "322164",
    "problem_idx": "D",
    "shortId": "1142D",
    "contest_number": "1142",
    "problem_submissions": {
        "D": [
            52052698,
            52044696,
            52050424,
            52048816,
            52048203,
            52050242,
            52051279,
            52044155,
            52053707,
            52051199,
            52050499,
            52052944,
            52052302,
            52053535,
            52051490,
            52049907
        ],
        "E": [
            52047622,
            52057339,
            52048974,
            77087643,
            52277900,
            52277787,
            52050784
        ],
        "C": [
            52040660,
            52041212,
            52036496,
            52039629,
            52044262,
            52039609,
            52039348,
            52038404,
            52053341,
            52038044,
            52046718,
            52044023,
            52041812,
            52045982,
            52050483,
            52043132,
            52044496,
            52082020
        ],
        "B": [
            52036028,
            52037384,
            52034327,
            52035419,
            52038173,
            52037529,
            52042911,
            52035003,
            52038458,
            52035088,
            52037475,
            52037895,
            52038479,
            52041354,
            52037902,
            52038519,
            52055164,
            52037338
        ],
        "A": [
            52032007,
            52031522,
            52030850,
            52033382,
            52032139,
            52033225,
            52032107,
            52040214,
            52033698,
            52034088,
            52034385,
            52034757,
            52033255,
            52055588,
            52032995,
            52035070
        ]
    },
    "name": "D. Foreigner",
    "statement": "Traveling around the world you noticed that many shop owners raise\r\nprices to inadequate values if the see you are a foreigner.You define\r\ninadequate numbers as follows: all integers from 1 to 9 are inadequate;\r\nfor an integer x\r\nge 10 to be inadequate, it is required that the integer\r\nlfloor x / 10\r\nrfloor is inadequate, but that’s not the only condition. Let’s sort all\r\nthe inadequate integers. Let\r\nlfloor x / 10\r\nrfloor have number k in this order. Then, the integer x is inadequate\r\nonly if the last digit of x is strictly less than the reminder of\r\ndivision of k by 11. Here\r\nlfloor x / 10\r\nrfloor denotes x/10 rounded down.Thus, if x is the m-th in increasing\r\norder inadequate number, and m gives the remainder c when divided by 11,\r\nthen integers 10\r\ncdot x + 0, 10\r\ncdot x + 1\r\nldots, 10\r\ncdot x + (c - 1) are inadequate, while integers 10\r\ncdot x + c, 10\r\ncdot x + (c + 1),\r\nldots, 10\r\ncdot x + 9 are not inadequate.The first several inadequate integers are\r\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 30, 31, 32\r\nldots. After that, since 4 is the fourth inadequate integer, 40, 41, 42,\r\n43 are inadequate, while 44, 45, 46,\r\nldots, 49 are not inadequate; since 10 is the 10-th inadequate number,\r\nintegers 100, 101, 102,\r\nldots, 109 are all inadequate. And since 20 is the 11-th inadequate\r\nnumber, none of 200, 201, 202,\r\nldots, 209 is inadequate.You wrote down all the prices you have seen in\r\na trip. Unfortunately, all integers got concatenated in one large digit\r\nstring s and you lost the bounds between the neighboring integers. You\r\nare now interested in the number of substrings of the resulting string\r\nthat form an inadequate number. If a substring appears more than once at\r\ndifferent positions, all its appearances are counted separately.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int M = 11;\nconst int N = 100100;\nll ans;\nint cntForLen[N];\nchar s[N];\nint a[N];\nint L;\nint dp[2][M][M][M];\n\nint getSum(int st, int len) {\n\tlen %= M;\n\treturn (st * len + len * (len - 1) / 2) % M;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tcntForLen[1] = 9;\n\tint cur = 1;\n\tfor (int i = 1; i < N - 1; i++) {\n\t\tcntForLen[i + 1] = getSum(cur, cntForLen[i]);\n\t\tcur = (cur + cntForLen[i]) % M;\n\t}\n\n\tscanf(\"%s\", s);\n\tL = strlen(s);\n\tfor (int i = 0; i < L; i++)\n\t\ta[i] = (int)(s[i] - '0');\n\n\tfor (int x = 0; x < M; x++)\n\t\tfor (int y = 0; y < M; y++)\n\t\t\tfor (int z = 0; z < M; z++)\n\t\t\t\tdp[0][x][y][z] = L;\n\n\tint xx, yy, zz;\n\tfor (int pos = L - 1; pos >= 0; pos--) {\n\t\tif (a[pos] > 0) {\n\t\t\txx = a[pos] - 1, yy = 1, zz = 9;\n\t\t\tans += dp[0][xx][yy][zz] - pos;\n\t\t}\n\t\tfor (int x = 0; x < M; x++)\n\t\t\tfor (int y = 0; y < M; y++) {\n\t\t\t\tint m = (x + y) % M;\n\t\t\t\tif (a[pos] >= m) {\n\t\t\t\t\tfor (int z = 0; z < M; z++) {\n\t\t\t\t\t\tdp[1][x][y][z] = pos;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int z = 0; z < M; z++) {\n\t\t\t\t\txx = (getSum(y, x) + a[pos]) % M;\n\t\t\t\t\tyy = (y + z) % M;\n\t\t\t\t\tzz = getSum(y, z);\n\t\t\t\t\tdp[1][x][y][z] = dp[0][xx][yy][zz];\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int x = 0; x < M; x++)\n\t\t\tfor (int y = 0; y < M; y++)\n\t\t\t\tfor (int z = 0; z < M; z++)\n\t\t\t\t\tdp[0][x][y][z] = dp[1][x][y][z];\n\t}\n/*\n\tfor (int l = 0; l < L; l++) {\n\t\tif (s[l] == '0') continue;\n\t\tans++;\n\t\tint startForLen = 1, cntLower = a[l] - 1;\n\t\tfor (int i = l + 1; i < L; i++) {\n\t\t\tint m = (startForLen + cntLower) % M;\n\t\t\tif (a[i] >= m) break;\n\t\t\tcntLower = (getSum(startForLen, cntLower) + a[i]) % M;\n\t\t\tstartForLen = (startForLen + cntForLen[i - l]) % M;\n\t\t\tans++;\n\t\t}\n\t}\n*/\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Foreigner.json",
    "editorial_link": "https://codeforces.com//blog/entry/66301",
    "editorial": "Letâs take any inadequate number of length . Letâs keep 3 parameters for\r\nit: which is the number of all inadequate numbers less of equal then ,\r\nwhich is the number of inadequate numbers less then which have length\r\nand which is the number of inadequate numbers grater then which have\r\nlength . We know that there are exactly modulo 11 inadequate numbers\r\nthat come from by adding a new digit to the end. Also, because we know\r\nand , we can find , and parameters for each of those numbers. Letâs now\r\nnotice, that if instead of keeping , and parameters we can keep all of\r\nthem modulo 11. The parameters of all numbers that come from will still\r\nbe defined because if we increase by 11, these parameters will be the\r\nsame modulo 11, if we increase by 11, and parameters of all numbers that\r\ncome from are increase by which is 0 modulo 11. The same is with\r\nparameter. So these 3 parameters modulo 11 exactly define what new\r\nnumbers will come from and the values of these 3 parameters for them.\r\nNow we can create some kind of automaton of size , where we will have 9\r\nstarting nodes and all paths from these nodes will be the inadequate\r\nnumbers and for any inadequate number there will be path which will\r\ndefine it. Now letâs create dynamic , which is how long we can go into\r\nthe automaton by the characters of suffix of length of our given string\r\nstarting from node in automaton. We can calculate this in time and using\r\nit we can check for each suffix of what is its longest prefix that is an\r\ninadequate number and so we can solve the problem.Actually, during the\r\ncontest it turned out that this problem has shorter solution, but this\r\nis more general one which doesnât depend on the starting numbers (in our\r\ncase they were ).\r\n",
    "hint": []
}