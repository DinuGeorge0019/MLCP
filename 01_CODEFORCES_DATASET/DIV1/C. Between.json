{
    "link": "https://codeforces.com//contest/1815/problem/C",
    "problemId": "1871721",
    "problem_idx": "C",
    "shortId": "1815C",
    "contest_number": "1815",
    "problem_submissions": {
        "F": [
            201555670,
            201558612,
            201561386,
            201567730,
            201566757,
            202046482,
            201726445,
            201935453,
            201585873
        ],
        "E": [
            201530172,
            201528832,
            201551207,
            201544435,
            201543833,
            201554402,
            201555894,
            201557703,
            201554929,
            201556101,
            201557247,
            201555003,
            201557950,
            201556139,
            201563294,
            201546853,
            201542261,
            201546492,
            201570815
        ],
        "D": [
            201513083,
            201506968,
            201521370,
            201517487,
            201522017,
            201533871,
            201533067,
            201531357,
            201527346,
            201537489,
            201539887,
            201539975,
            201543678,
            201546232,
            201566677,
            201568923,
            201534451
        ],
        "C": [
            201497483,
            201499771,
            201506268,
            201502220,
            201510933,
            201510356,
            201506402,
            201517502,
            201515562,
            201517401,
            201523915,
            201524806,
            201533994,
            201523878,
            201503778,
            201512320,
            201510486,
            201513744
        ],
        "B": [
            201489690,
            201490417,
            201495395,
            201494655,
            201496814,
            201493671,
            201494756,
            201502664,
            201501592,
            201503253,
            201515920,
            201510149,
            201510749,
            201492437,
            201503376,
            201496616,
            201500693
        ],
        "A": [
            201483243,
            201480897,
            201480866,
            201480768,
            201483195,
            201480859,
            201480836,
            201481081,
            201480782,
            201481965,
            201483607,
            201482857,
            201481459,
            201480707,
            201481969,
            201481110,
            201483462
        ]
    },
    "name": "C. Between",
    "statement": "You are given an integer n, as well as m pairs of integers (a_i,b_i),\r\nwhere 1\r\nleq a_i , b_i\r\nleq n, a_i\r\nne b_i.You want to construct a sequence satisfying the following\r\nrequirements: All elements in the sequence are integers between 1 and n.\r\nThere is exactly one element with value 1 in the sequence. For each i (1\r\nle i\r\nle m), between any two elements (on different positions) in the sequence\r\nwith value a_i, there is at least one element with value b_i. The\r\nsequence constructed has the length among all possible sequences\r\nsatisfying the above properties. Sometimes, it is possible that such a\r\nsequence can be arbitrarily long, in which case you should output \"\".\r\nOtherwise, you should output \"\" and the sequence itself. If there are\r\nmultiple possible constructions that yield the maximum length, output\r\nany.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 09.04.2023 11:03:05       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[y].push_back(x);\n    }\n    vector<int> d(n, -1);\n    vector<int> que(1, 0);\n    d[0] = 1;\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int u : g[que[b]]) {\n        if (d[u] == -1) {\n          que.push_back(u);\n          d[u] = d[que[b]] + 1;\n        }\n      }\n    }\n    if (*min_element(d.begin(), d.end()) == -1) {\n      cout << \"INFINITE\" << '\\n';\n      continue;\n    }\n    cout << \"FINITE\" << '\\n';\n    vector<vector<int>> at(n + 1);\n    for (int i = 0; i < n; i++) {\n      at[d[i]].push_back(i);\n    }\n    vector<int> seq;\n    for (int from = 1; from <= n; from++) {\n      for (int val = n; val >= from; val--) {\n        for (int x : at[val]) {\n          seq.push_back(x);\n        }\n      }\n    }\n    cout << seq.size() << '\\n';\n    for (int i = 0; i < (int) seq.size(); i++) {\n      cout << seq[i] + 1 << \" \\n\"[i == (int) seq.size() - 1];\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Between.json",
    "editorial_link": "https://codeforces.com//blog/entry/114899",
    "editorial": "Editorial Construct a graph with vertices and add a directed edge if\nbetween every two there must be a . Let be the number of occurrences of\n. The key observation is that if , then . Suppose is a directed path,\nwhere . Then since , we must have . In other words, . where is one plus\nthe length of the shortest directed path from to .Therefore, the total\narray length does not exceed . We claim that we can achieve this.It is\neasy to calculate the by a BFS. Let consists of vertices such that . Let\nthe largest value of among all . Consider where for each , vertices in\nvarious occurrences of must be arranged in the same order.It is easy to\ncheck that this construction satisfies all the constraints and achieve\nthe upper bound . Thus, this output is correct.The sequence can be\narbitrarily long if and only if there is some that does not have a path\ndirected to . To see this, let be the set of vertices that do not have\npath directed to , then the following construction gives an arbitrarily\nlong output that satisfy all constraints:\n",
    "hint": []
}