{"link": "https://codeforces.com//contest/582/problem/D", "problemId": "37188", "problem_idx": "D", "shortId": "582D", "contest_number": "582", "problem_submissions": {"E": [13382538, 13381116, 13378028, 13383504, 13383506, 13383917, 13383602, 145895898], "C": [13373394, 13375255, 13380779, 13374298, 13373776, 13372716, 13377174, 13375147, 13375206, 13375348, 13372216, 13373000, 13376950, 13374416, 13374597, 13371567, 13392220, 13380106, 13374816, 13375408], "B": [13370935, 13371321, 13372509, 13370999, 13368381, 13369232, 13374738, 13371115, 13372424, 13370249, 13368449, 13368172, 13372435, 13368862, 13369702, 13365121, 13392237, 13392226, 13370380, 13369378, 13369857], "A": [13366333, 13368173, 13364878, 13363160, 13374636, 13383874, 13368333, 13365806, 13366818, 13363090, 13364145, 13365273, 13365002, 13363636, 13374162, 13365145, 13364246, 13363367], "D": [13463010]}, "name": "D. Number of Binominal Coefficients", "statement": "For a given prime integer and integers calculate the number of pairs of\r\nintegers , such that and is divisible by . As the answer can be rather\r\nlarge, print the remainder of the answer moduly .Let us remind you that\r\nis the number of ways objects can be chosen from the set of objects.\r\n", "solutions": ["#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 3500;\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {\n  return a+b >= mod ? a+b-mod : a+b;\n}\n\ninline int sub(int a, int b) {\n  return a < b ? a-b+mod : a-b;\n}\n\ninline int mul(int a, int b) {\n  return llint(a)*b % mod;\n}\n\ninline void addd(int& a,int b) {\n  a = add(a, b);\n}\n\nchar A[MAX];\nint s[MAX];\nint f[MAX][2][2];\nint nf[MAX][2][2];\n\nint divv(char* A, int len, int p, int& q) {\n  int n = 0;\n  llint cur = 0;\n  REP(i, len) {\n    cur = cur * 10 + A[i];\n    if (n > 0 || cur >= p) {\n      A[n++] = cur / p;\n      cur %= p;\n    }\n  }\n  q = cur;\n  return n;\n}\n\ninline int calc(int p, int r) {\n  if (r < 0) return 0;\n  int hi = min(p-1, r);\n  int L = min(hi, max(-1, r+1-p));\n  llint ans = 1LL*p*(L+1);\n  if (L < hi) {\n    ans += 1LL*(hi-L)*(r+1);\n    ans -= (hi*1LL*(hi+1) - L*1LL*(L+1))/2;\n  }\n  return ans % mod;\n}\n\nint main(void) {\n  int p, alpha;\n  scanf(\"%d %d\", &p, &alpha);\n  scanf(\"%s\", A);\n  //p = 2;\n  //  alpha = 32000;\n  //  REP(i, 1000) A[i] = rand() % 10 + '0';\n  //  A[1000] = '\\0';\n\n  int len = strlen(A);\n  REP(i, len) A[i] -= '0';\n\n  int n = 0;\n  while (len > 0) len = divv(A, len, p, s[n++]);\n\n  f[0][0][0] = 1;\n  REP(i, n) {\n    REP(j, i+1) REP(gt, 2) REP(cr, 2) nf[j][gt][cr] = 0;\n    REP(j, i+1) REP(gt, 2) REP(cr, 2) {\n      int cur = f[j][gt][cr];\n      if (cur == 0) continue;\n\n      int B0 = calc(p, -cr+s[i]-1);\n      int C0 = calc(p, -cr+s[i]);\n      int D0 = calc(p, p-1-cr);\n      int B1 = calc(p, p-cr+s[i]-1);\n      int C1 = calc(p, p-cr+s[i]);\n      int D1 = calc(p, p+p-1-cr);\n\n      addd(nf[j][0][0], mul(cur, B0));\n      addd(nf[j][gt][0], mul(cur, sub(C0, B0)));\n      addd(nf[j][1][0], mul(cur, sub(D0, C0)));\n      addd(nf[j+1][0][1], mul(cur, sub(B1, D0)));\n      addd(nf[j+1][gt][1], mul(cur, sub(C1, B1)));\n      addd(nf[j+1][1][1], mul(cur, sub(D1, C1)));\n    }\n    REP(j, i+2) REP(gt, 2) REP(cr, 2) f[j][gt][cr] = nf[j][gt][cr];\n  }\n\n  int ans = 0;\n  FOR(j, alpha, n+1)\n    ans = add(ans, f[j][0][0]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "math", "number theory"], "dificulty": "3300", "interactive": false}