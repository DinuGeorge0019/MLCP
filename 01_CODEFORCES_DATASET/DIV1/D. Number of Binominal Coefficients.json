{
    "link": "https://codeforces.com//contest/582/problem/D",
    "problemId": "37188",
    "problem_idx": "D",
    "shortId": "582D",
    "contest_number": "582",
    "problem_submissions": {
        "E": [
            13382538,
            13381116,
            13378028,
            13383504,
            13383506,
            13383917,
            13383602,
            145895898
        ],
        "C": [
            13373394,
            13375255,
            13380779,
            13374298,
            13373776,
            13372716,
            13377174,
            13375147,
            13375206,
            13375348,
            13372216,
            13373000,
            13376950,
            13374416,
            13374597,
            13371567,
            13392220,
            13380106,
            13374816,
            13375408
        ],
        "B": [
            13370935,
            13371321,
            13372509,
            13370999,
            13368381,
            13369232,
            13374738,
            13371115,
            13372424,
            13370249,
            13368449,
            13368172,
            13372435,
            13368862,
            13369702,
            13365121,
            13392237,
            13392226,
            13370380,
            13369378,
            13369857
        ],
        "A": [
            13366333,
            13368173,
            13364878,
            13363160,
            13374636,
            13383874,
            13368333,
            13365806,
            13366818,
            13363090,
            13364145,
            13365273,
            13365002,
            13363636,
            13374162,
            13365145,
            13364246,
            13363367
        ],
        "D": [
            13463010
        ]
    },
    "name": "D. Number of Binominal Coefficients",
    "statement": "For a given prime integer and integers calculate the number of pairs of\r\nintegers , such that and is divisible by . As the answer can be rather\r\nlarge, print the remainder of the answer moduly .Let us remind you that\r\nis the number of ways objects can be chosen from the set of objects.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 3500;\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {\n  return a+b >= mod ? a+b-mod : a+b;\n}\n\ninline int sub(int a, int b) {\n  return a < b ? a-b+mod : a-b;\n}\n\ninline int mul(int a, int b) {\n  return llint(a)*b % mod;\n}\n\ninline void addd(int& a,int b) {\n  a = add(a, b);\n}\n\nchar A[MAX];\nint s[MAX];\nint f[MAX][2][2];\nint nf[MAX][2][2];\n\nint divv(char* A, int len, int p, int& q) {\n  int n = 0;\n  llint cur = 0;\n  REP(i, len) {\n    cur = cur * 10 + A[i];\n    if (n > 0 || cur >= p) {\n      A[n++] = cur / p;\n      cur %= p;\n    }\n  }\n  q = cur;\n  return n;\n}\n\ninline int calc(int p, int r) {\n  if (r < 0) return 0;\n  int hi = min(p-1, r);\n  int L = min(hi, max(-1, r+1-p));\n  llint ans = 1LL*p*(L+1);\n  if (L < hi) {\n    ans += 1LL*(hi-L)*(r+1);\n    ans -= (hi*1LL*(hi+1) - L*1LL*(L+1))/2;\n  }\n  return ans % mod;\n}\n\nint main(void) {\n  int p, alpha;\n  scanf(\"%d %d\", &p, &alpha);\n  scanf(\"%s\", A);\n  //p = 2;\n  //  alpha = 32000;\n  //  REP(i, 1000) A[i] = rand() % 10 + '0';\n  //  A[1000] = '\\0';\n\n  int len = strlen(A);\n  REP(i, len) A[i] -= '0';\n\n  int n = 0;\n  while (len > 0) len = divv(A, len, p, s[n++]);\n\n  f[0][0][0] = 1;\n  REP(i, n) {\n    REP(j, i+1) REP(gt, 2) REP(cr, 2) nf[j][gt][cr] = 0;\n    REP(j, i+1) REP(gt, 2) REP(cr, 2) {\n      int cur = f[j][gt][cr];\n      if (cur == 0) continue;\n\n      int B0 = calc(p, -cr+s[i]-1);\n      int C0 = calc(p, -cr+s[i]);\n      int D0 = calc(p, p-1-cr);\n      int B1 = calc(p, p-cr+s[i]-1);\n      int C1 = calc(p, p-cr+s[i]);\n      int D1 = calc(p, p+p-1-cr);\n\n      addd(nf[j][0][0], mul(cur, B0));\n      addd(nf[j][gt][0], mul(cur, sub(C0, B0)));\n      addd(nf[j][1][0], mul(cur, sub(D0, C0)));\n      addd(nf[j+1][0][1], mul(cur, sub(B1, D0)));\n      addd(nf[j+1][gt][1], mul(cur, sub(C1, B1)));\n      addd(nf[j+1][1][1], mul(cur, sub(D1, C1)));\n    }\n    REP(j, i+2) REP(gt, 2) REP(cr, 2) f[j][gt][cr] = nf[j][gt][cr];\n  }\n\n  int ans = 0;\n  FOR(j, alpha, n+1)\n    ans = add(ans, f[j][0][0]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Number of Binominal Coefficients.json",
    "editorial_link": "https://codeforces.com//blog/entry/20692",
    "editorial": "It is a common fact that for a prime p and integer n maximum ?, such that p?|n! is calculated as , where pw???n?<?pw?+?1. As soon as , the maximum ? for  is calculated as .\n\nOne could see, that if we consider numbers n, k and n?-?k in p-th based numeric system, rounded-down division by px means dropping last x digits of its p-th based representation. As soon as k?+?(n?-?k)?=?n, every i-th summand in ? corresponds to carry in adding k to n?-?k in p-th numeric system from i?-?1-th to i-th digit position and is to be 0 or 1.\n\nFirst, let convert A given in statement from 10 to p-th numeric system. In case, if ? is greater than number of digits in A in p-th numeric system, the answer is 0. Next we will calculate dynamic programming on A p-th based representation.\n\ndp[i][x][e][r] Â— the answer for prefix of length i possible equal to prefix of A representation (indicator e), x-th power of p was already calculated, and there must be carry equal to r from current to previous position. One could calculate it by bruteforcing all of p2 variants of placing i-th digits in n and k according to r and e and i-th digit of A, and make a translation to next state. It can be avoided by noticing that the number of variants of placing digits is always a sum of arithmetic progression and can be calculated in O(1).",
    "hint": []
}