{
    "link": "https://codeforces.com//contest/1074/problem/A",
    "problemId": "249086",
    "problem_idx": "A",
    "shortId": "1074A",
    "contest_number": "1074",
    "problem_submissions": {
        "E": [
            45303620,
            45300249,
            45344571,
            45304718,
            45304862,
            45306309,
            45306510,
            45315681,
            45302002,
            45303642
        ],
        "F": [
            45297925,
            45302412,
            45298748,
            45300083,
            45299480,
            45298818,
            45299827,
            45300561,
            45300985,
            45300910,
            45302087,
            45302359,
            45302549,
            45302342,
            45306149,
            45302208,
            45303449,
            45304102,
            45303226
        ],
        "D": [
            45294973,
            45293128,
            45295261,
            45296109,
            45292313,
            45291734,
            45297119,
            45297694,
            45297259,
            45298710,
            45297635,
            45297369,
            45298399,
            45297846,
            45294290,
            45297091,
            45296770,
            45296596,
            45297365,
            45299859
        ],
        "C": [
            45293553,
            45291475,
            45293844,
            45294044,
            45293914,
            45294012,
            45293608,
            45295772,
            45294886,
            45297284,
            45296110,
            45294396,
            45293720,
            45296080,
            45292596,
            45294430,
            45294994,
            45295210,
            45294620,
            45296058
        ],
        "B": [
            45292377,
            45294890,
            45292284,
            45297195,
            45296274,
            45295787,
            45291944,
            45293450,
            45293244,
            45294291,
            45295233,
            45293263,
            45291573,
            45294870,
            45303353,
            45293540,
            45298407,
            45293034,
            45292582,
            45292571
        ],
        "A": [
            45289520,
            45289825,
            45289616,
            45289578,
            45294985,
            45294783,
            45289998,
            45290374,
            45289949,
            45291060,
            45291837,
            45290090,
            45295330,
            45290627,
            45290102,
            45291029,
            45290582,
            45297889,
            45289941,
            45289786
        ]
    },
    "name": "A. The Tower is Going Home",
    "statement": "On a chessboard with a width of 10^9 and a height of 10^9, the rows are\r\nnumbered from bottom to top from 1 to 10^9, and the columns are numbered\r\nfrom left to right from 1 to 10^9. Therefore, for each cell of the\r\nchessboard you can assign the coordinates (x,y), where x is the column\r\nnumber and y is the row number.Every day there are fights between black\r\nand white pieces on this board. Today, the black ones won, but at what\r\nprice? Only the rook survived, and it was driven into the lower left\r\ncorner a cell with coordinates (1,1). But it is still happy, because the\r\nvictory has been won and it’s time to celebrate it! In order to do this,\r\nthe rook needs to go home, namely on the of the field (that is, in any\r\ncell that is in the row with number 10^9).Everything would have been\r\nfine, but the treacherous white figures put spells on some places of the\r\nfield before the end of the game. There are two types of spells:\r\nVertical. Each of these is defined by one number x. Such spells create\r\nan infinite between the columns x and x+1. Horizontal. Each of these is\r\ndefined by three numbers x_1, x_2, y. Such spells create a that passes\r\nthrough the top side of the cells, which are in the row y and in columns\r\nfrom x_1 to x_2 inclusive. The peculiarity of these spells is that it is\r\nfor a certain pair of such spells to have a common point. Note that\r\nhorizontal spells can have common points with vertical spells. Let’s\r\nrecall that the rook is a chess piece that in one move can move to any\r\npoint that is in the same row or column with its initial position. In\r\nour task, the rook can move from the cell (r_0,c_0) into the cell\r\n(r_1,c_1) only under the condition that r_1 = r_0 or c_1 = c_0 and there\r\nis no or between these cells (For better understanding, look at the\r\nsamples).Fortunately, the rook can remove spells, but for this it has to\r\nput tremendous efforts, therefore, it wants to remove the minimum\r\npossible number of spells in such way, that after this it can return\r\nhome. Find this number!\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int inf=1000*1000*1000;\n\nint n, m;\n\nvi pio;\n\nvi poz;\n\nint wyn;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\twyn=n+m;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tpio.push_back(x);\n\t}\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint a, b, x;\n\t\tscanf(\"%d%d%d\", &a, &b, &x);\n\t\tif (a==1)\n\t\t\tpoz.push_back(b);\n\t}\n\tsort(pio.begin(), pio.end());\n\tsort(poz.begin(), poz.end());\n\treverse(poz.begin(), poz.end());\n\tpio.push_back(inf);\n\tint w=poz.size();\n\tfor (int i=0; i<=n; i++)\n\t{\n\t\twhile(w>0 && poz[w-1]<pio[i])\n\t\t\tw--;\n\t\twyn=min(wyn, i+w);\n\t}\n\t\n\tprintf(\"%d\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "sortings",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. The Tower is Going Home.json",
    "editorial_link": "https://codeforces.com//blog/entry/62985",
    "editorial": "Observation 1. If we remove all the horizontal spells, than the rook can\r\nmove straightforward up to the upper side of the field. So the only\r\npurpose of removing the vertical spells is to reduce the number of\r\nhorizontal spells to be removed.Observation 2. If we want to remove the\r\n-th vertical spell, then we should also remove all such vertical spells\r\n, that . It is obvious, because when we delete a vertical spell, we\r\nsuppose that the rook would be able to outflank some horizontal spells\r\nby getting at rows that have greater number than . If there remains at\r\nleast one vertical spell , such that , than we will never be able to\r\nmove to the rows with number greater than , including .Letâs find some\r\nobservations about the horizontal spells:Letâs assume that we deleted\r\nvertical spells. It means, that the rook can move freely left and right\r\nat columns between and inclusive. Letâs say that our rook is on the row\r\n. If there is at least one cell which is located at row at any column\r\nbetween and , that there is no blocking segment on the top of it, then\r\nthe rook can move to this cell and move upwards into the row . It means\r\nthat if there is at least one gap in the blocking segments in row and in\r\ncolumns between and incluse, then there is no need to remove any of\r\nhorizontal spells in the row.Observation 3. We care only about such\r\nhorizontal spells, in which . We have already proved, that we only care\r\nabout such rows, that there are no gaps in blocking segments in them. If\r\nthere is no such horizontal spell with , it means that there is a gap in\r\nthe row at column . If there is such horizontal spell, then if there are\r\nmore spells in that row, there would be a gap between any pair of\r\nneighbouring segments. Since we only care only about segments with and\r\nit is guaranteed that no horizontal segments share a common point, it\r\nmeans that we might not care about the of any horizontal spell, because\r\nthere is no such pair of segments that both and of these are equal. So\r\nnow while reading the descriptions of the horizontal spells, if the of\r\n-th horizontal spell is not equal to , we can ignore it. Otherwise, we\r\nadd to some array.Now we can sort the array of -s, and solve the task\r\nusing the two-pointer technique. Here is the final algorithm: Add fake\r\nvertical spell with .Sort all the vertical spells in ascending\r\norder.While reading the descriptions of the horizontal spells, we ignore\r\nones with not equal to . In other case, we add to the array.Sort the\r\narray of -s in ascending order. Now we use the two pointer technique in\r\nthe following way: we iterate from 0 to n the number of vertical spells\r\nto be deleted and on each step we advance the pointer while the at which\r\nthe pointer points is less then of the -th vertical spell. Letâs denote\r\nthe position of the pointer as . The number of horizontal spells, that\r\nwe need to remove with vertical spells removed is . Letâs define the\r\nposition of the pointer at -th step as .The answer to the problem in\r\nminival value of among all from to .Overall complexity\r\n",
    "hint": []
}