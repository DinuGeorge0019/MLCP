{
    "link": "https://codeforces.com//contest/377/problem/E",
    "problemId": "4965",
    "problem_idx": "E",
    "shortId": "377E",
    "contest_number": "377",
    "problem_submissions": {
        "E": [
            5565104,
            5561250,
            5564607,
            5609766,
            5609753,
            16200081
        ],
        "C": [
            5557198,
            5559102,
            5556756,
            5557878,
            5557073,
            5556778,
            5561172,
            5559969,
            5556623,
            5561484,
            5557118,
            5556739,
            5555480,
            5555881,
            5556358,
            5558864,
            5562930,
            5557451
        ],
        "B": [
            5555860,
            5557367,
            5555019,
            5553998,
            5554910,
            5555169,
            5554737,
            5555727,
            5555389,
            5556153,
            5555427,
            5554761,
            5558108,
            5554728,
            5554498,
            5556897,
            5555212,
            5555735
        ],
        "D": [
            5554743,
            5555639,
            5559458,
            5563602,
            5559736,
            5559573,
            5557812,
            5558888,
            5560657,
            5558023,
            5561888,
            5561586,
            5561721,
            5561010,
            5567302,
            5562027,
            5561348,
            5557665,
            5560854
        ],
        "A": [
            5552294,
            5552852,
            5553023,
            5554895,
            5553159,
            5553613,
            5552588,
            5552740,
            5553136,
            5552790,
            5552857,
            5552997,
            5553105,
            5552479,
            5552633,
            5554023,
            5552441
        ]
    },
    "name": "E. Cookie Clicker",
    "statement": "Kostya is playing the computer game Cookie Clicker. The goal of this\r\ngame is to gather cookies. You can get cookies using different : you can\r\njust click a special field on the screen and get the cookies for the\r\nclicks, you can buy a cookie factory, an alchemy lab, a time machine and\r\nit all will bring lots and lots of cookies.At the beginning of the game\r\n(time 0), Kostya has 0 cookies and no buildings. He has available\r\nbuildings to choose from: the -th building is worth cookies and when\r\nit’s built it brings cookies at the end of each second. Also, to make\r\nthe game more interesting to play, Kostya decided to add a limit: at\r\neach moment of time, he can use only one building. Of course, he can\r\nchange the active building each second at his discretion.It’s important\r\nthat Kostya is playing a version of the game where he can buy new\r\nbuildings and change active building only at time moments that are\r\nmultiples of one second. Kostya can buy new building and use it at the\r\nsame time. If Kostya starts to use a building at the time moment , he\r\ncan get the first profit from it only at the time moment .Kostya wants\r\nto earn at least cookies as quickly as possible. Determine the number of\r\nseconds he needs to do that.\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst long long inf = (long long)1e18;\n\nconst int N = 400010;\n\npair <int, int> h[N];\nlong double xs[N];\nint st[N];\nlong long value[N], cost[N], f[N], g[N];\n\nlong double inter(int i, int j) {\n  long double vv = value[i];\n  vv *= value[j];\n  long double fvv = vv * (f[j] - f[i]);\n  long double gv = ((long double)g[i] * value[j]) - ((long double)g[j] * value[i]);\n  long double vmv = value[j] - value[i];\n  return (fvv + gv) / vmv;\n}\n\nint main() {\n  int n;\n  long long goal;\n  cin >> n >> goal;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &(h[i].second), &(h[i].first));\n    h[i].second = -h[i].second;\n  }\n  sort(h, h + n);\n  int m = 1;\n  for (int i = 1; i < n; i++) {\n    int profit = -h[i].second;\n    int last_p = -h[m - 1].second;\n    if (profit > last_p) {\n      h[m] = h[i];\n      m++;\n    }\n  }\n  n = m;\n  for (int i = 0; i < n; i++) {\n    cost[i] = h[i].first;\n    value[i] = -h[i].second;\n  }\n  int e = 0;\n  for (int i = 0; i < n; i++) {\n    f[i] = inf;\n    g[i] = 0;\n    if (cost[i] == 0) {\n      f[i] = 0;\n      g[i] = 0;\n    } else {\n      int ll = 1, rr = e;\n      while (ll < rr) {\n        int mid = (ll + rr) >> 1;\n        if (xs[mid] < cost[i]) ll = mid + 1;\n        else rr = mid;\n      }\n      for (int u = ll - 5; u <= ll + 5; u++) {\n        if (u < 1 || u > e) continue;\n        int j = st[u];\n        long long nf = f[j], ng = g[j];\n        if (ng < cost[i]) {\n          long long need = cost[i] - ng;\n          if (need > 0) {\n            long long days = (need + value[j] - 1) / value[j];\n            nf += days;\n            ng += days * value[j];\n          }\n        }\n        ng -= cost[i];\n        if (nf < f[i] || nf == f[i] && ng > g[i]) {\n          f[i] = nf;\n          g[i] = ng;\n        }\n      }\n    }\n    while (e > 1) {\n      long double xx = inter(st[e], i);\n      if (xx < xs[e - 1]) e--;\n      else break;\n    }\n    e++;\n    st[e] = i;\n    if (e > 1) {\n      xs[e - 1] = inter(st[e - 1], st[e]);\n    }\n  }\n  long long ans = inf;\n  for (int i = 0; i < n; i++) {\n    long long cur = f[i];\n    if (g[i] < goal) {\n      long long need = goal - g[i];\n      cur += (need + value[i] - 1) / value[i];\n    }\n    if (cur < ans) ans = cur;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "geometry"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Cookie Clicker.json",
    "editorial_link": "https://codeforces.com//blog/entry/10157",
    "editorial": "First of all, throw away the buildings which cannot be used in any\r\noptimal answer: for each remain only one building that has speed equal\r\nto and minimal . Also throw away all buildings whose speed is less than\r\nthe speed of the fastest building which has . Itâs fairly obvious that\r\nat any time we should use the fastest building. And if some building is\r\nused in the optimal answer, it should be bought and used immediately\r\nwhen we have enough money (I will use the word âmoneyâ instead of\r\nâcookiesâ). Letâs imagine the plane where axis stands for the time and\r\naxis stands for the money. We will maintain the graph of the function\r\nâmaximal number of money that can be obtained at the time â and process\r\nthe buildings one by one, changing the graph. This function is the union\r\nof the line segments with the slopes equal to , and each of these line\r\nsegments is active on a certain segment of the axis . For example, at\r\nthe beginning the graph is just the line , where is the speed of\r\nbuilding that can be bought for 0 units of money. Let the next\r\nbuildingâs price is . Find the minimal point where value of our function\r\nis greater or equal to and buy this building at the moment . Then we\r\nshould make the line where is the amount of money remaining after the\r\npurchase. Now we have two lines. Till some moment the first line is\r\nbetter (not till , maybe later), but as there exists a moment of time\r\n(itâs where is the -coordinate of the linesâ intersection) when the\r\nsecond line becomes better. Now we know the segments where a particular\r\nline is better than the others. Continue add all buildings to the graph\r\nthis way. Line segments should be stored in stack, as in all problems\r\nwith convex hull, and every step remove unnecessary line segments from\r\nthe stack (these are the lines those position in the stack is after the\r\nline which has an intersection with the currently added line). After we\r\nprocess all buildings, we use our graph to find the minimal time when we\r\nhave untis of money. If we also should say which building we must use,\r\nwe can store for any line segment its âparentâ the line segment which\r\nwas active when the current one was bought. With such parent array itâs\r\nnot hard to restore the sequence of buildings in the answer. We removed\r\nthis part from the problem to make it a bit easier.\r\n",
    "hint": []
}