{
    "link": "https://codeforces.com//contest/1628/problem/C",
    "problemId": "1270544",
    "problem_idx": "C",
    "shortId": "1628C",
    "contest_number": "1628",
    "problem_submissions": {
        "F": [
            143704137,
            143703628,
            143702221,
            143703556,
            147001965
        ],
        "E": [
            143675713,
            143683767,
            143678064,
            143684015,
            143703839,
            143703586,
            143684851,
            143683465,
            143685498,
            143691038,
            143689260,
            143676465,
            143693250,
            143684297,
            143687706,
            143698977,
            143697149,
            143693737,
            143726859,
            143698932,
            143695817,
            143695968
        ],
        "D2": [
            143658634,
            143670285,
            143666637,
            143665499,
            143666995,
            143667409,
            143672399,
            143672413,
            143661151,
            143647661,
            143658816,
            143673791,
            143659789,
            143650476,
            143675004,
            143660718,
            143676678,
            143684084,
            143660907
        ],
        "D1": [
            143652051,
            143661015,
            143649637,
            143665355,
            143640835,
            143647447,
            143672291,
            143669534,
            143658393,
            143632054,
            143652557,
            143673638,
            143659662,
            143650805,
            143669620,
            143647751,
            143667415,
            143668369,
            143654580
        ],
        "C": [
            143648600,
            143653504,
            143662609,
            143671130,
            143659087,
            143671994,
            143662240,
            143665901,
            143679854,
            143654744,
            143666734,
            143658744,
            143650933,
            143640762,
            143660335,
            143673771,
            143662259,
            143663580,
            143684690
        ],
        "B": [
            143641041,
            143647996,
            143687560,
            143645776,
            143664691,
            143661275,
            143640613,
            143649322,
            143664737,
            143644329,
            143690738,
            143695054,
            143657006,
            143653454,
            143666253,
            143657114,
            143649062,
            143668019
        ],
        "A": [
            143633679,
            143636764,
            143632428,
            143638866,
            143635799,
            143637277,
            143632341,
            143633434,
            143635604,
            143658928,
            143634190,
            143633884,
            143633848,
            143634819,
            143640442,
            143650623,
            143643930,
            143639364,
            143636998
        ]
    },
    "name": "C. Grid Xor",
    "statement": "Note: The XOR-sum of set\r\n{s_1,s_2,\r\nldots,s_m\r\n} is defined as s_1\r\noplus s_2\r\noplus\r\nldots\r\noplus s_m, where\r\noplus denotes the bitwise XOR operation.After almost winning IOI, Victor\r\nbought himself an n\r\ntimes n grid containing integers in each cell. The integer in the cell\r\nin the i-th row and j-th column is a_{i,j}.Sadly, Mihai stole the grid\r\nfrom Victor and told him he would return it with only one condition:\r\nVictor has to tell Mihai the XOR-sum of the integers in the whole\r\ngrid.Victor doesn\u2019t remember all the elements of the grid, but he\r\nremembers some information about it: For each cell, Victor remembers the\r\nXOR-sum of all its neighboring cells.Two cells are considered neighbors\r\nif they share an edge in other words, for some integers 1\r\nle i, j, k, l\r\nle n, the cell in the i-th row and j-th column is a neighbor of the cell\r\nin the k-th row and l-th column if |i - k| = 1 and j = l, or if i = k\r\nand |j - l| = 1.To get his grid back, Victor is asking you for your\r\nhelp. Can you use the information Victor remembers to find the XOR-sum\r\nof the whole grid?It can be proven that the answer is unique.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 22.01.2022 17:52:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> a(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        cin >> a[i][j];\n      }\n    }\n    int ans = 0;\n    for (int rot = 0; rot < 2; rot++) {\n      for (int i = 0; i < n; i += 4) {\n        int x = i;\n        int y = 0;\n        while (x >= 0 && x < n && y >= 0 && y < n) {\n          ans ^= a[x][y];\n          x -= 2;\n          y += 2;\n        }\n      }\n      for (int j = (n % 4 == 0 ? 1 : 3); j < n; j += 4) {\n        int x = n - 1;\n        int y = j;\n        while (x >= 0 && x < n && y >= 0 && y < n) {\n          ans ^= a[x][y];\n          x -= 2;\n          y += 2;\n        }\n      }\n      reverse(a.begin(), a.end());\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "interactive",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Grid Xor.json",
    "editorial_link": "https://codeforces.com//blog/entry/99276",
    "editorial": "Let\u00e2\u0080\u0099s denote count() the amount of times the cell () contributed in\r\nqueries. We notice that count() must be odd for all cells (). There are\r\nmultiple possible solutions for this problem. In the editorial we will\r\ndescribe two of them.<first solution>The following construction\r\nsatisfies the condition: Iterate Through all rows from row to n. For\r\neach row, traverse all its cells and query cell () if the cell above it\r\nif cell () was contributed (count() (mod )) an even amount of times and\r\nXOR curent_answer with (curent_answer initially being )Everule gave a\r\nproof of correctness of this approach.<first solution><second\r\nsolution>Let\u00e2\u0080\u0099s try making some pattern that takes all cells exactly\r\nonce: Something like this would work if the board was a triangle instead\r\nof a square. But it turns out we can actually completely cover the\r\nsquare by using 4 copies of such a triangle rotated:<second solution>\r\n"
}