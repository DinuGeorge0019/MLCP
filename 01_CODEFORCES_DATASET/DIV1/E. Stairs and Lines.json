{"link": "https://codeforces.com//contest/498/problem/E", "problemId": "19903", "problem_idx": "E", "shortId": "498E", "contest_number": "498", "problem_submissions": {"E": [9254353, 9255134, 9255917, 9257774, 9256751, 9258696, 9256130, 9254869, 9255218, 9257482, 9259085, 9259412, 9293653], "D": [9252551, 9253707, 9253982, 9253218, 9254235, 9256783, 9248603, 9260246, 9259443, 9259317, 9251692, 9252178, 9254847, 9253161, 9255257, 9254544, 9255567], "C": [9251331, 9245747, 9250927, 9247459, 9249177, 9251204, 9249816, 9248998, 9251162, 9248001, 9250917, 9253358], "B": [9248724, 9250737, 9247577, 9260817, 9250130, 9252321, 9249119, 9253380, 9258038, 9252693, 9253079, 9252863, 9250195], "A": [9245371, 9251410, 9245412, 9245364, 9247095, 9245481, 9245345, 9245357, 9245352, 9245488, 9245360, 9245992, 9246642, 9245626]}, "name": "E. Stairs and Lines", "statement": "You are given a figure on a grid representing stairs consisting of 7\r\nsteps. The width of the stair on height is squares. Formally, the figure\r\nis created by consecutively joining rectangles of size so that the sides\r\nlie on one straight line. Thus, for example, if all , the figure will\r\nlook like that (different colors represent different rectangles): And if\r\n, then it looks like that: Find the number of ways to color some borders\r\nof the figure\u2019s inner squares so that no square had all four borders\r\ncolored. The borders of the squares lying on the border of the figure\r\nshould be considered painted. The ways that differ with the figure\u2019s\r\nrotation should be considered distinct.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME \"\"\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\" #x \"] Time = %.3lfs\\n\",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef _WIN32\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst int INF = inf;\nconst double EPS = eps;\n\n#ifdef DEBUG\nstruct __timestamper {\n  ~__timestamper(){\n    TIMESTAMP(end);\n  }\n} __Timestamper;\n#else\nstruct __timestamper {};\n#endif\n\n/*Template end*/\n\nconst int MOD = int(1e9 + 7);\nvoid madd(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nint mmul(int a, int b) { return ll(a) * b % MOD; }\n\nconst int h = 7;\n\nstruct Mat {\n  static const int n = 1 << h;\n  int dat[n][n];\n\n  Mat(int x = 0) {\n    memset(dat, 0, sizeof dat);\n    forn (i, n) dat[i][i] = x;\n  }\n        int *operator[](int y)       { return dat[y]; }\n  const int *operator[](int y) const { return dat[y]; }\n\n  friend Mat operator*(const Mat &a, const Mat &b) {\n    const ll MOD2 = ll(MOD) * MOD;\n    Mat res;\n    forn (i, n)\n    forn (j, n) {\n      ll cur = 0;\n      forn (k, n) {\n        cur += ll(a[i][k]) * b[k][j];\n        if (cur >= MOD2) cur -= MOD2;\n      }\n      res[i][j] = cur % MOD;\n    }\n    return res;\n  }\n};\n\nMat mpow(Mat a, int b) {\n  Mat res = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) res = res * a;\n  return res;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME\".in\",\"r\",stdin);\n  freopen(TASKNAME\".out\",\"w\",stdout);\n  #endif\n\n  vi ws(h + 1);\n  while (scanf(\"%d\", &ws[1]) == 1) {\n    for (int y = 2; y <= h; y++)\n      scanf(\"%d\", &ws[y]);\n\n    Mat ans = 1;\n    int py = 0;\n    for (int y = 1; y <= h; y++) if (ws[y]) {\n      // first step\n      for (int x = 0; x < 2; x++) {\n        Mat cur;\n        int prevMsk = x ? (1 << y) : (1 << py);\n        forn (old, prevMsk) {\n          forn (vmsk, prevMsk) if (!(old & vmsk)) {\n            forn (hmsk, 1 << (y - 1)) {\n              int hasBottom = (hmsk << 1) | 1;\n              int hasMiddle = vmsk;\n              if (x == 0) hasMiddle |= ((1 << (y - py)) - 1) << py;\n              int hasTop = hmsk | (1 << (y - 1));\n              int ne = hasBottom & hasMiddle & hasTop;\n              madd(cur[old][ne], 1);\n            }\n          }\n        }\n\n        int need = 1;\n        if (x == 1) need = ws[y] - 1;\n        ans = ans * mpow(cur, need);\n      }\n      py = y;\n    }\n    printf(\"%d\\n\", ans[0][0]);\n  }\n\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "matrices"], "dificulty": "2700", "interactive": false}