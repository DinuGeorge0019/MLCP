{"link": "https://codeforces.com//contest/1707/problem/F", "problemId": "1465658", "problem_idx": "F", "shortId": "1707F", "contest_number": "1707", "problem_submissions": {"E": [164603668, 164525375, 164669454, 185901683, 185901618, 185901333, 164563417], "D": [164511528, 164496478, 164493571, 164495095, 164501925, 164506638, 166069487, 164497571, 164507609, 166120309, 166120066, 164509308, 164956360, 164507471, 164489918, 164511025, 164904470, 164514319, 164514325, 164497954, 164519148, 164515594, 164518158, 164516720, 164511294], "B": [164484745, 164460975, 164467918, 164471533, 164466867, 164467580, 164475668, 164466783, 166120253, 166119986, 164469792, 164956306, 164468045, 164461021, 164475290, 164475116, 164472236, 164466401, 164463086, 164472164, 164472283, 164465112, 164479683], "C": [164479539, 164485229, 164482780, 164482216, 164481698, 164485751, 164487589, 164482127, 166120011, 164486694, 164956347, 164484482, 164472573, 164487921, 164484938, 164484181, 164511081, 164483634, 164483996, 164493834, 164499762, 164491460], "A": [164463335, 164470733, 164464634, 164464640, 164458756, 164460631, 164457208, 164456721, 166119954, 164458999, 164956326, 164457788, 164466493, 164459761, 164467279, 164469592, 164460485, 164464829, 164460707, 164471416, 164466775], "F": [164529829, 164530227, 165361670, 165361592, 165360981, 165360617, 164565887, 164565715]}, "name": "F. Bugaboo", "statement": "A transformation of an array of positive integers a_1,a_2,\r\ndots,a_n is defined by replacing a with the array b_1,b_2,\r\ndots,b_n given by b_i=a_i\r\noplus a_{(i\r\nbmod n)+1}, where\r\noplus denotes the bitwise XOR operation.You are given integers n, t, and\r\nw. We consider an array c_1,c_2,\r\ndots,c_n (0\r\nle c_i\r\nle 2^w-1) to be if and only if there exists an array a_1,a_2,\r\ndots,a_n such that after transforming a for t times, a becomes c.For\r\nexample, when n=6, t=2, w=2, then the array [3,2,1,0,2,2] is bugaboo\r\nbecause it can be given by transforming the array [2,3,1,1,0,1] for 2\r\ntimes: [2,3,1,1,0,1]\r\nto [2\r\noplus 3,3\r\noplus 1,1\r\noplus 1,1\r\noplus 0,0\r\noplus 1,1\r\noplus 2]=[1,2,0,1,1,3];\r\nto [1\r\noplus 2,2\r\noplus 0,0\r\noplus 1,1\r\noplus 1,1\r\noplus 3,3\r\noplus 1]=[3,2,1,0,2,2]. And the array [4,4,4,4,0,0] is not bugaboo\r\nbecause 4 > 2^2 - 1. The array [2,3,3,3,3,3] is also not bugaboo because\r\nit can\u2019t be given by transforming one array for 2 times.You are given an\r\narray c with some positions lost (only m positions are known at first\r\nand the remaining positions are lost). And there are q modifications,\r\nwhere each modification is changing a position of c. A modification can\r\npossibly change whether the position is lost or known, and it can\r\npossibly redefine a position that is already given.You need to calculate\r\nhow many possible arrays c (with arbitrary elements on the lost\r\npositions) are bugaboos after each modification. Output the i-th answer\r\nmodulo p_i (p_i is a given array consisting of q elements).\r\n", "solutions": ["#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, t, w, q, b, len, a[10000005], xa[10000005], xa1[10000005], cnt, bcnt;\nvector<int> arr[35];\n\nvoid updf(int cur, int id, int coef)\n{\n\tif(cur == 0) {\n\t\tcnt += coef * (arr[cur][id] == -1); return;\n\t}\n\tint nid = id & ((1 << (cur - 1)) - 1);\n\tint ct = t >> (cur - 1) & 1;\n\tint u = arr[cur][nid], v = arr[cur][nid | 1 << (cur - 1)];\n\tif(ct == 1) bcnt += coef * (u != -1 && v != -1 && u != v);\n\telse cnt += coef * (arr[cur][nid] == -1 && arr[cur][nid | 1 << (cur - 1)] == -1);\n\tupdf(cur - 1, nid, coef);\n}\n\nvoid upd(int cur, int id)\n{\n\tif(cur == 0) return;\n\tint nid = id & ((1 << (cur - 1)) - 1);\n\tint ct = t >> (cur - 1) & 1;\n\tint u = arr[cur][nid], v = arr[cur][nid | 1 << (cur - 1)];\n\tif(ct == 1) arr[cur - 1][nid] = u != -1 ? u : v;\n\telse arr[cur - 1][nid] = u == -1 ? -1 : (v == -1 ? -1 : u ^ v);\n\tupd(cur - 1, nid);\n}\n\nvoid adda(int id, int val)\n{\n\tcnt -= max(xa1[id % b] - 1, 0);\n\tif(a[id] == -1) xa1[id % b] --;\n\telse xa[id % b] ^= a[id];\n\ta[id] = val;\n\tif(a[id] == -1) xa1[id % b] ++;\n\telse xa[id % b] ^= a[id];\n\tif(t == b) bcnt -= arr[len][id % b] != 0 && arr[len][id % b] != -1;\n\telse updf(len, id % b, -1);\n\tarr[len][id % b] = xa1[id % b] == 0 ? xa[id % b] : -1;\n\tupd(len, id % b);\n\tif(t == b) bcnt += arr[len][id % b] != 0 && arr[len][id % b] != -1;\n\telse updf(len, id % b, 1);\n\tcnt += max(xa1[id % b] - 1, 0);\n}\n\nint power(int x, int r, int p)\n{\n\tint ret = 1;\n\twhile(r > 0) {\n\t\tif(r & 1) ret = 1ULL * ret * x % p;\n\t\tx = 1ULL * x * x % p;\n\t\tr >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\", &n, &m, &t, &w);\n\trep(i, n) a[i] = -1;\n\tb = ((n ^ (n - 1)) + 1) >> 1;\n\tt = min(t, b);\n\tfor(; (1 << len) < b; len ++) ;\n\trep(i, len + 1) arr[i].resize(1 << i, -1);\n\trep(i, b) xa1[i] = n / b;\n\tcnt = n - t;\n\trep(i, m) {\n\t\tint d, e;\n\t\tscanf(\"%d%d\", &d, &e);\n\t\tadda(d - 1, e);\n\t}\n\tscanf(\"%d\", &q);\n\trep(i, q) {\n\t\tint f, g, p;\n\t\tscanf(\"%d%d%d\", &f, &g, &p);\n\t\tadda(f - 1, g);\n\t\tprintf(\"%d\\n\", bcnt ? 0 : power(1 << w, cnt, p));\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "dp", "number theory"], "dificulty": "3500", "interactive": false}