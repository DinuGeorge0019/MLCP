{"link": "https://codeforces.com//contest/280/problem/D", "problemId": "2728", "problem_idx": "D", "shortId": "280D", "contest_number": "280", "problem_submissions": {"A": [3287460, 3287361, 3276397, 3278813, 3276368, 3275958, 3278969, 3275819, 3275811, 3278894, 3281142, 3276025, 3282276, 3280827, 3278671, 3278926], "D": [3281691, 3283266, 3283731, 3285347, 3322215], "C": [3279306, 3279945, 3277746, 3276734, 3279642, 3277787, 3276636, 3278485, 3278848, 3279470, 3277629, 3279115, 3276052, 3276649, 3279355, 3279152], "B": [3276405, 3279061, 3277000, 3276260, 3284541, 3277306, 3275980, 3276370, 3276567, 3276408, 3276287, 3277081, 3278515, 3277959, 3275542, 3276177], "E": [3351075]}, "name": "D. k-Maximum Subsequence Sum", "statement": "Consider integer sequence . You should run queries of two types: The\r\nquery format is \" \". In reply to this query you should make the\r\nfollowing assignment: . The query format is \" \". In reply to this query\r\nyou should print the maximum sum of at most non-intersecting subsegments\r\nof sequence . Formally, you should choose at most pairs of integers such\r\nthat the sum is as large as possible. Note that you should choose at\r\nmost subsegments. Particularly, you can choose 0 subsegments. In this\r\ncase the described sum considered equal to zero.\r\n", "solutions": ["/*\nAuthor: elfness@UESTC\n*/\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long LL;\n\nconst int MAX = 105000;\n\n/**\n * Segment tree\n */\nstruct Seg\n{\n        int l, r;\n        int maxLeftValue, maxRightValue, minLeftValue, minRightValue, maxSum,\n                minSum, sum;\n        int maxLeftBound, maxRightBound, minLeftBound, minRightBound,\n                maxSumLeft, maxSumRight, minSumLeft, minSumRight;\n} seg[MAX << 2];\nint a[MAX];\n\nvoid update(int k)\n{\n    seg[k].sum = seg[k << 1].sum + seg[k << 1 | 1].sum;\n    if (seg[k << 1].maxLeftValue >= seg[k << 1].sum\n            + seg[k << 1 | 1].maxLeftValue)\n    {\n        seg[k].maxLeftValue = seg[k << 1].maxLeftValue;\n        seg[k].maxRightBound = seg[k << 1].maxRightBound;\n    }\n    else\n    {\n        seg[k].maxLeftValue = seg[k << 1].sum + seg[k << 1 | 1].maxLeftValue;\n        seg[k].maxRightBound = seg[k << 1 | 1].maxRightBound;\n    }\n    if (seg[k << 1 | 1].maxRightValue >= seg[k << 1 | 1].sum\n            + seg[k << 1].maxRightValue)\n    {\n        seg[k].maxRightValue = seg[k << 1 | 1].maxRightValue;\n        seg[k].maxLeftBound = seg[k << 1 | 1].maxLeftBound;\n    }\n    else\n    {\n        seg[k].maxRightValue = seg[k << 1 | 1].sum + seg[k << 1].maxRightValue;\n        seg[k].maxLeftBound = seg[k << 1].maxLeftBound;\n    }\n    if (seg[k << 1].minLeftValue <= seg[k << 1].sum\n            + seg[k << 1 | 1].minLeftValue)\n    {\n        seg[k].minLeftValue = seg[k << 1].minLeftValue;\n        seg[k].minRightBound = seg[k << 1].minRightBound;\n    }\n    else\n    {\n        seg[k].minLeftValue = seg[k << 1].sum + seg[k << 1 | 1].minLeftValue;\n        seg[k].minRightBound = seg[k << 1 | 1].minRightBound;\n    }\n    if (seg[k << 1 | 1].minRightValue <= seg[k << 1 | 1].sum\n            + seg[k << 1].minRightValue)\n    {\n        seg[k].minRightValue = seg[k << 1 | 1].minRightValue;\n        seg[k].minLeftBound = seg[k << 1 | 1].minLeftBound;\n    }\n    else\n    {\n        seg[k].minRightValue = seg[k << 1 | 1].sum + seg[k << 1].minRightValue;\n        seg[k].minLeftBound = seg[k << 1].minLeftBound;\n    }\n    if (seg[k << 1].maxSum >= seg[k << 1 | 1].maxSum)\n    {\n        seg[k].maxSum = seg[k << 1].maxSum;\n        seg[k].maxSumLeft = seg[k << 1].maxSumLeft;\n        seg[k].maxSumRight = seg[k << 1].maxSumRight;\n    }\n    else\n    {\n        seg[k].maxSum = seg[k << 1 | 1].maxSum;\n        seg[k].maxSumLeft = seg[k << 1 | 1].maxSumLeft;\n        seg[k].maxSumRight = seg[k << 1 | 1].maxSumRight;\n    }\n    if (seg[k].maxSum < seg[k << 1].maxRightValue\n            + seg[k << 1 | 1].maxLeftValue)\n    {\n        seg[k].maxSum = seg[k << 1].maxRightValue\n                + seg[k << 1 | 1].maxLeftValue;\n        seg[k].maxSumLeft = seg[k << 1].maxLeftBound;\n        seg[k].maxSumRight = seg[k << 1 | 1].maxRightBound;\n    }\n\n    if (seg[k << 1].minSum <= seg[k << 1 | 1].minSum)\n    {\n        seg[k].minSum = seg[k << 1].minSum;\n        seg[k].minSumLeft = seg[k << 1].minSumLeft;\n        seg[k].minSumRight = seg[k << 1].minSumRight;\n    }\n    else\n    {\n        seg[k].minSum = seg[k << 1 | 1].minSum;\n        seg[k].minSumLeft = seg[k << 1 | 1].minSumLeft;\n        seg[k].minSumRight = seg[k << 1 | 1].minSumRight;\n    }\n    if (seg[k].minSum > seg[k << 1].minRightValue\n            + seg[k << 1 | 1].minLeftValue)\n    {\n        seg[k].minSum = seg[k << 1].minRightValue\n                + seg[k << 1 | 1].minLeftValue;\n        seg[k].minSumLeft = seg[k << 1].minLeftBound;\n        seg[k].minSumRight = seg[k << 1 | 1].minRightBound;\n    }\n}\n\nvoid init(int k, int l, int r)\n{\n    seg[k].l = l;\n    seg[k].r = r;\n    if (l == r)\n    {\n        seg[k].sum = seg[k].maxLeftValue = seg[k].maxRightValue\n                = seg[k].minLeftValue = seg[k].minRightValue = seg[k].maxSum\n                        = seg[k].minSum = a[l];\n        seg[k].maxLeftBound = seg[k].minLeftBound = l;\n        seg[k].maxRightBound = seg[k].minRightBound = r;\n        seg[k].maxSumLeft = seg[k].maxSumRight = r;\n        seg[k].minSumLeft = seg[k].minSumRight = r;\n        return;\n    }\n    int mid = l + r >> 1;\n    init(k << 1, l, mid);\n    init(k << 1 | 1, mid + 1, r);\n    update(k);\n}\n\nvoid Up(int k,int pos,int v)\n{\n    if(seg[k].l==pos&&seg[k].r==pos)\n    {\n        seg[k].sum = seg[k].maxLeftValue = seg[k].maxRightValue\n                = seg[k].minLeftValue = seg[k].minRightValue = seg[k].maxSum\n                        = seg[k].minSum = v;\n        return;\n    }\n    int mid=(seg[k].l+seg[k].r)/2;\n    if(pos<=mid)Up(k << 1, pos, v);\n    else Up(k << 1 | 1, pos, v);\n    update(k);\n}\nint findMaxRight(int k, int l, int r, int& ll)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        ll = seg[k].maxLeftBound;\n        return seg[k].maxRightValue;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (l > mid)\n    {\n        return findMaxRight(k << 1 | 1, l, r, ll);\n    }\n    else\n    {\n        int l1, l2;\n        int retRight = findMaxRight(k << 1 | 1, mid + 1, r, l1);\n        int retLeft = findMaxRight(k << 1, l, mid, l2) + seg[k << 1 | 1].sum;\n        if (retRight >= retLeft)\n        {\n            ll = l1;\n            return retRight;\n        }\n        else\n        {\n            ll = l2;\n            return retLeft;\n        }\n    }\n}\n\nint findMaxLeft(int k, int l, int r, int& rr)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        rr = seg[k].maxRightBound;\n        return seg[k].maxLeftValue;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (r <= mid)\n    {\n        return findMaxLeft(k << 1, l, r, rr);\n    }\n    else\n    {\n        int r1, r2;\n        int retLeft = findMaxLeft(k << 1, l, mid, r1);\n        int retRight = seg[k << 1].sum\n                + findMaxLeft(k << 1 | 1, mid + 1, r, r2);\n        if (retLeft >= retRight)\n        {\n            rr = r1;\n            return retLeft;\n        }\n        else\n        {\n            rr = r2;\n            return retRight;\n        }\n    }\n}\n\nint findMax(int k, int l, int r, int& ll, int& rr)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        ll = seg[k].maxSumLeft;\n        rr = seg[k].maxSumRight;\n        return seg[k].maxSum;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (r <= mid)\n    {\n        return findMax(k << 1, l, r, ll, rr);\n    }\n    else if (l > mid)\n    {\n        return findMax(k << 1 | 1, l, r, ll, rr);\n    }\n    else\n    {\n        int l1, r1, l2, r2, l3, r3, ret;\n        int retLeft = findMax(k << 1, l, mid, l1, r1);\n        int retRight = findMax(k << 1 | 1, mid + 1, r, l2, r2);\n        int retMiddle = findMaxRight(k << 1, l, mid, l3)\n                + findMaxLeft(k << 1 | 1, mid + 1, r, r3);\n        if (retLeft >= retRight)\n        {\n            ll = l1;\n            rr = r1;\n            ret = retLeft;\n        }\n        else\n        {\n            ll = l2;\n            rr = r2;\n            ret = retRight;\n        }\n        if (ret < retMiddle)\n        {\n            ll = l3;\n            rr = r3;\n            ret = retMiddle;\n        }\n        return ret;\n    }\n}\n\nint findMinRight(int k, int l, int r, int& ll)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        ll = seg[k].minLeftBound;\n        return seg[k].minRightValue;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (l > mid)\n    {\n        return findMinRight(k << 1 | 1, l, r, ll);\n    }\n    else\n    {\n        int l1, l2;\n        int retRight = findMinRight(k << 1 | 1, mid + 1, r, l1);\n        int retLeft = findMinRight(k << 1, l, mid, l2) + seg[k << 1 | 1].sum;\n        if (retRight <= retLeft)\n        {\n            ll = l1;\n            return retRight;\n        }\n        else\n        {\n            ll = l2;\n            return retLeft;\n        }\n    }\n}\n\nint findMinLeft(int k, int l, int r, int& rr)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        rr = seg[k].minRightBound;\n        return seg[k].minLeftValue;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (r <= mid)\n    {\n        return findMinLeft(k << 1, l, r, rr);\n    }\n    else\n    {\n        int r1, r2;\n        int retLeft = findMinLeft(k << 1, l, mid, r1);\n        int retRight = seg[k << 1].sum\n                + findMinLeft(k << 1 | 1, mid + 1, r, r2);\n        if (retLeft <= retRight)\n        {\n            rr = r1;\n            return retLeft;\n        }\n        else\n        {\n            rr = r2;\n            return retRight;\n        }\n    }\n}\n\nint findMin(int k, int l, int r, int& ll, int& rr)\n{\n    if (seg[k].l == l && seg[k].r == r)\n    {\n        ll = seg[k].minSumLeft;\n        rr = seg[k].minSumRight;\n        return seg[k].minSum;\n    }\n    int mid = seg[k].l + seg[k].r >> 1;\n    if (r <= mid)\n    {\n        return findMin(k << 1, l, r, ll, rr);\n    }\n    else if (l > mid)\n    {\n        return findMin(k << 1 | 1, l, r, ll, rr);\n    }\n    else\n    {\n        int l1, r1, l2, r2, l3, r3, ret;\n        int retLeft = findMin(k << 1, l, mid, l1, r1);\n        int retRight = findMin(k << 1 | 1, mid + 1, r, l2, r2);\n        int retMiddle = findMinRight(k << 1, l, mid, l3)\n                + findMinLeft(k << 1 | 1, mid + 1, r, r3);\n        if (retLeft <= retRight)\n        {\n            ll = l1;\n            rr = r1;\n            ret = retLeft;\n        }\n        else\n        {\n            ll = l2;\n            rr = r2;\n            ret = retRight;\n        }\n        if (ret > retMiddle)\n        {\n            ll = l3;\n            rr = r3;\n            ret = retMiddle;\n        }\n        return ret;\n    }\n}\n\n/**\n * heap\n */\n\nstruct Node\n{\n        bool flag;\n        int v, l, r, ll, rr;\n        Node()\n        {\n        }\n        Node(bool flag, int v, int l, int r, int ll, int rr) :\n            flag(flag), v(v), l(l), r(r), ll(ll), rr(rr)\n        {\n        }\n} h[MAX];\nint K;\n\nvoid sink(int k)\n{\n    while ((k << 1) <= K)\n    {\n        int maxv = max(h[k].v, h[k << 1].v);\n        if ((k << 1 | 1) <= K)\n        {\n            maxv = max(maxv, h[k << 1 | 1].v);\n        }\n        if (maxv == h[k].v)\n            break;\n        else if (maxv == h[k << 1].v)\n        {\n            swap(h[k], h[k << 1]);\n            k = k << 1;\n        }\n        else\n        {\n            swap(h[k], h[k << 1 | 1]);\n            k = k << 1 | 1;\n        }\n    }\n}\n\nvoid flow(int k)\n{\n    while (k > 1)\n    {\n        int p = k >> 1;\n        if (h[p].v < h[k].v)\n        {\n            swap(h[p], h[k]);\n            k >>= 1;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n\nNode getMax()\n{\n    swap(h[1], h[K]);\n    K--;\n    sink(1);\n    return h[K + 1];\n}\n\nvoid add(const Node& node)\n{\n    h[++K] = node;\n    flow(K);\n}\n\nint main()\n{\n    int n, m, Q, t;\n    int l, r, L, R;\n    int ret;\n\n\n    while (~scanf(\"%d\", &n) )\n    {\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%d\", &a[i]);\n        }\n        init(1, 0, n - 1);\n        scanf(\"%d\",&Q);\n        while(Q--)\n        {\n            int op;\n            scanf(\"%d\",&op);\n            if(op==0)\n            {\n                scanf(\"%d%d\",&l,&r);l--;\n                Up(1,l,r);\n            }\n            else\n            {\n                scanf(\"%d%d%d\",&L,&R,&m);L--;R--;\n                K = 0;\n                ret = 0;\n                t = findMax(1, L, R, l, r);\n                add(\n                    Node(true, t, L, R, l,\n                         r));\n                while (m--)\n                {\n                    Node u = getMax();\n                    if (u.v <= 0)\n                    {\n                        break;\n                    }\n                    ret += u.v;\n                    if (!u.flag)\n                    {\n                        if (u.l != u.ll)\n                        {\n                            t = findMin(1, u.l, u.ll - 1, l, r);\n                            add(Node(false, -t, u.l, u.ll - 1, l, r));\n                        }\n                        if (u.r != u.rr)\n                        {\n                            t = findMin(1, u.rr + 1, u.r, l, r);\n                            add(Node(false, -t, u.rr + 1, u.r, l, r));\n                        }\n                        t = findMax(1, u.ll, u.rr, l, r);\n                        add(Node(true, t, u.ll, u.rr, l, r));\n                    }\n                    else\n                    {\n                        if (u.l != u.ll)\n                        {\n                            t = findMax(1, u.l, u.ll - 1, l, r);\n                            add(Node(true, t, u.l, u.ll - 1, l, r));\n                        }\n                        if (u.r != u.rr)\n                        {\n                            t = findMax(1, u.rr + 1, u.r, l, r);\n                            add(Node(true, t, u.rr + 1, u.r, l, r));\n                        }\n                        t = findMin(1, u.ll, u.rr, l, r);\n                        add(Node(false, -t, u.ll, u.rr, l, r));\n                    }\n                }\n                printf(\"%d\\n\", ret);\n            }\n        }\n    }\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "flows", "graphs", "implementation"], "dificulty": "2800", "interactive": false}