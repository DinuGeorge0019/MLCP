{
    "link": "https://codeforces.com//contest/763/problem/E",
    "problemId": "91413",
    "problem_idx": "E",
    "shortId": "763E",
    "contest_number": "763",
    "problem_submissions": {
        "D": [
            24392378,
            24392196,
            24381252,
            24386512,
            24392124,
            24394387,
            24386765,
            24382498,
            24486986,
            24394269,
            24386191,
            24424544,
            24380258,
            24380559
        ],
        "E": [
            24383804,
            24379798,
            24382054,
            24377568,
            24385205,
            24385996,
            24385356,
            24380328,
            24382103,
            24378328,
            24383177,
            24384291,
            24383316,
            24383261,
            26602690,
            26602470
        ],
        "A": [
            24374208,
            24365694,
            24369536,
            24379218,
            24368162,
            24370205,
            24368697,
            24367762,
            24372789,
            24371841,
            24370735,
            24374219,
            24381920,
            24369005,
            24365735,
            24371025,
            24372089,
            24366605,
            24368551
        ],
        "C": [
            24373544,
            24379290,
            24384264,
            24378866,
            24379343,
            24379755,
            24376326,
            24393137,
            24387552,
            24485763,
            24485746,
            24392939,
            24381638,
            24411493,
            36653644
        ],
        "B": [
            24368982,
            24386986,
            24385221,
            24380830,
            24369478,
            24372225,
            24370708,
            24368820,
            24374499,
            24373776,
            24373025,
            24382359,
            24374187,
            24370609,
            24367209,
            24373968,
            24375645,
            24368619,
            24371120
        ]
    },
    "name": "E. Timofey and our friends animals",
    "statement": "After his birthday party, Timofey went to his favorite tree alley in a\r\npark. He wants to feed there his favorite birds crows.It\u2019s widely known\r\nthat each tree is occupied by a single crow family. The trees in the\r\nalley form a row and are numbered from to . Some families are friends to\r\neach other. For some reasons, two families can be friends only if they\r\nlive not too far from each other, more precisely, there is no more than\r\ntrees between any pair of friend families. Formally, the family on the\r\n-th tree and the family on the -th tree can be friends only if holds.One\r\nof the friendship features is that if some family learns that Timofey is\r\nfeeding crows somewhere, it notifies about this all friend families.\r\nThus, after Timofey starts to feed crows under some tree, all the\r\nfamilies that are friends to the family living on this tree, as well as\r\ntheir friends and so on, fly to the feeding place. Of course, the family\r\nliving on the tree also comes to the feeding place.Today Timofey came to\r\nthe alley and noticed that all the families that live on trees with\r\nnumbers strictly less than or strictly greater than have flown away.\r\nThus, it is not possible to pass the information about feeding through\r\nthem. Moreover, there is no need to feed them. Help Timofey to learn\r\nwhat is the minimum number of trees under which he has to feed crows so\r\nthat all the families that have remained will get the information about\r\nfeeding. You are given several situations, described by integers and ,\r\nyou need to calculate the answer for all of them.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\n#include <stack>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=301000,M=1010000;\nstruct node {\n\tnode *s[2],*f,*minv;\n\tint val,d;\n\tPII id;\n\tbool rev;\n\tbool isr() { return !f||(f->s[0]!=this && f->s[1]!=this);}\n\tbool dir() { return f->s[1]==this;}\n\tvoid setc(node *c,int d) { s[d]=c;if (c) c->f=this;}\n\tvoid push() {\n\t\tif (rev) { swap(s[0],s[1]); rep(i,0,2) if (s[i]) s[i]->rev^=1;} rev=0;\n\t}\n\tvoid upd() {\n\t\tminv=this;val=d;\n\t\trep(i,0,2) if (s[i]&&s[i]->val>val) val=s[i]->val,minv=s[i]->minv;\n\t}\n}pool[M],*cur;\nstack<node*> sta;\nvoid rot(node *x) {\n\tnode *p=x->f;bool d=x->dir();\n\tif (!p->isr()) p->f->setc(x,p->dir()); else x->f=p->f;\n\tp->setc(x->s[!d],d);x->setc(p,!d);\n\tp->upd();\n}\nvoid splay(node *x) {\n\tnode *q=x;\n\twhile (1) { sta.push(q);if (q->isr()) break; q=q->f; }\n\twhile (!sta.empty()) sta.top()->push(),sta.pop();\n\twhile (!x->isr()) {\n\t\tif (x->f->isr()) rot(x);\n\t\telse if (x->dir()==x->f->dir()) rot(x->f),rot(x);\n\t\telse rot(x),rot(x);\n\t}\n\tx->upd();\n}\nnode *expose(node *x) {\n\tnode *q=NULL;\n\tfor (;x;x=x->f) splay(x),x->s[1]=q,(q=x)->upd();\n\treturn q;\n}\nvoid evert(node *x) { expose(x); splay(x); x->rev^=1; x->push();}\nvoid expose(node *x,node *y) { evert(x); expose(y); splay(x);}\nvoid link(node *x,node *y) { evert(x); evert(y); x->setc(y,1);}\nvoid cut(node *x,node *y) { expose(x,y); x->s[1]=y->f=NULL;}\n\nint n,m,l,r,Q,ret[N];\nVI e[N];\nvector<PII> q[N];\nint c[N];\nvoid modify(int x,int s) {\n\tfor (;x<=n+1;x+=x&-x) c[x]+=s;\n}\nint query(int x) {\n\tint s=0;\n\tfor (;x;x-=x&-x) s+=c[x];\n\treturn s;\n}\nint main() {\n\tscanf(\"%d%*d\",&n);\n\tscanf(\"%d\",&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif (l>r) swap(l,r);\n\t\te[l].pb(r);\n\t}\n\tn++;\n\tscanf(\"%d\",&Q);\n\trep(i,0,Q) {\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tret[i]=r-l+1;\n\t\tq[l].pb(mp(r,i));\n\t}\n\trep(i,1,n+2) pool[i].d=-1;\n\tcur=pool+n+2;\n\trep(i,1,n+1) {\n\t\tnode *u=pool+i,*v=pool+n+1;\n\t\tnode *x=cur++;\n\t\tx->d=n+1;\n\t\tx->id=mp(i,n+1);\n\t\tlink(x,u); link(x,v);\n\t\tmodify(n+1,1);\n\t}\n\tper(x,1,n+1) {\n\t\tfor (auto y:e[x]) {\n\t\t\tnode *u=pool+x,*v=pool+y;\n\t\t\texpose(u,v);\n\t\t\tif (y<u->val) {\n\t\t\t\tnode *w=u->minv;\n\t\t\t\tcut(pool+w->id.fi,w);\n\t\t\t\tcut(pool+w->id.se,w);\n\t\t\t\tmodify(w->d,-1);\n\t\t\t\tw=cur++;\n\t\t\t\tw->d=y;\n\t\t\t\tmodify(w->d,1);\n\t\t\t\tw->id=mp(x,y);\n\t\t\t\tlink(w,pool+x);\n\t\t\t\tlink(w,pool+y);\n\t\t\t}\n\t\t}\n\t\tfor (auto y:q[x]) {\n\t\t\tret[y.se]-=query(y.fi);\n\t\t}\n\t}\n\trep(i,0,Q) printf(\"%d\\n\",ret[i]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dsu"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Timofey and our friends animals.json",
    "editorial_link": "https://codeforces.com//blog/entry/50205",
    "editorial": "Let\u00e2\u0080\u0099s build a segment tree on crow families. Let\u00e2\u0080\u0099s save DSU in each\r\nvertex, having information about number of components of connectivity on\r\nit. In one vertex will be DSU with size . In two vertices will be DSU\r\nwith size . In four vertices will be DSU with size . It\u00e2\u0080\u0099s easy to show\r\nthat we will store only values. Let\u00e2\u0080\u0099s understand how we can unite\r\nsegments. Knowing answer (number of components) for [a; b) and [b; c) we\r\ncan obtain answer for [a; c) in the following way: We can sum answers\r\nfor for [a; b) and [b; c) and substract number of components, which\r\nunited during the \"gluing\". If components become united, there is edge\r\nbetween vertex in one and vertex in another. We have constraint on edge\r\nlegth: vertex and vertex can be connected only if Then we can easily\r\nunite two segments of the segment tree in time: we just unite some of\r\nthe components of families represented in the end of each segment when\r\nthey are connected by edge. Segment tree can split query in already\r\ncalculated segments. So we can answer the query in time. Precalc will\r\ntake nearly .Author\u00e2\u0080\u0099s solution: http://pastebin.com/1CwUVyME: Solve the\r\nproblem in time for the precalculation and time for the query.\r\n"
}