{"link": "https://codeforces.com//contest/338/problem/B", "problemId": "3397", "problem_idx": "B", "shortId": "338B", "contest_number": "338", "problem_submissions": {"D": [4295147, 4299466, 4295982, 4299910, 4297907, 4322675, 4322635, 4296295, 4300603, 4303747], "C": [4293877, 4292949, 4296119, 4290785, 4294450, 4290995, 4292819, 4294306, 4289507, 4319214, 4292496, 4292285, 4293888, 4293909, 4292095, 4292420], "A": [4292482, 4289057, 4289014, 4297071, 4289608, 4292907, 4298719, 4290998, 4292048, 4294562, 4288621, 4289027, 4288252, 4289309], "E": [4291715, 4297382, 4294190, 4295220, 4296654, 4297161, 4295153, 4304466, 4296200, 4296272, 4296355, 4296995, 4392972, 4307055], "B": [4289897, 4290803, 4292502, 4296197, 4291687, 4294720, 4290858, 4290695, 4291375, 4290406, 4289563, 4290575, 4290335, 4290751, 4293818, 4293496]}, "name": "B. Book of Evil", "statement": "Paladin Manao caught the trail of the ancient Book of Evil in a swampy\r\narea. This area contains settlements numbered from 1 to . Moving through\r\nthe swamp is very difficult, so people tramped exactly paths. Each of\r\nthese paths connects some pair of settlements and is bidirectional.\r\nMoreover, it is possible to reach any settlement from any other one by\r\ntraversing one or several paths.The between two settlements is the\r\nminimum number of paths that have to be crossed to get from one\r\nsettlement to the other one. Manao knows that the Book of Evil has got a\r\ndamage range . This means that if the Book of Evil is located in some\r\nsettlement, its damage (for example, emergence of ghosts and werewolves)\r\naffects other settlements at distance or less from the settlement where\r\nthe Book resides.Manao has heard of settlements affected by the Book of\r\nEvil. Their numbers are . Note that the Book may be affecting other\r\nsettlements as well, but this has not been detected yet. Manao wants to\r\ndetermine which settlements may contain the Book. Help him with this\r\ndifficult task.\r\n", "solutions": ["#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int N = 1000010;\n\nint ss[N], ff[N], pred[N], last[N], deep[N];\nbool was[N], bad[N];\nint d, ans;\n\nvoid build(int v) {\n  was[v] = true;\n  deep[v] = -1;\n  if (bad[v]) deep[v] = 0;\n  int j = last[v];\n  while (j > 0) {\n    if (!was[ff[j]]) {\n      build(ff[j]);\n      if (deep[ff[j]] >= 0) {\n        int cur = deep[ff[j]] + 1;\n        if (cur > deep[v]) deep[v] = cur;\n      }\n    }\n    j = pred[j];\n  }\n}\n\nvoid go(int v, int up) {\n  if (deep[v] <= d && up <= d) ans++;\n  was[v] = true;\n  vector <int> values, vertices;\n  int j = last[v];\n  while (j > 0) {\n    if (!was[ff[j]]) {\n      values.push_back(deep[ff[j]] == -1 ? -1 : (2 + deep[ff[j]]));\n      vertices.push_back(ff[j]);\n    }\n    j = pred[j];\n  }\n  int sz = values.size();\n  if (sz == 0) return;\n  vector <int> prefmax(sz), sufmax(sz);\n  int mx = -1;\n  for (int i=0;i<sz;i++) {\n    prefmax[i] = mx;\n    if (values[i] > mx) mx = values[i];\n  }\n  mx = -1;\n  for (int i=sz-1;i>=0;i--) {\n    sufmax[i] = mx;\n    if (values[i] > mx) mx = values[i];\n  }\n  for (int i=0;i<sz;i++) {\n    int newup = up == -1 ? -1 : (up + 1);\n    if (prefmax[i] > newup) newup = prefmax[i];\n    if (sufmax[i] > newup) newup = sufmax[i];\n    if (bad[v] && 1 > newup) newup = 1;\n    go(vertices[i], newup);\n  }\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d %d %d\", &n, &m, &d);\n  for (int i=1;i<=n;i++) bad[i] = false;\n  for (int i=0;i<m;i++) {\n    int foo;\n    scanf(\"%d\", &foo);\n    bad[foo] = true;\n  }\n  for (int i=1;i<=n-1;i++) {\n    scanf(\"%d %d\", ss+i, ff+i);\n    ss[i + n - 1] = ff[i];\n    ff[i + n - 1] = ss[i];\n  }\n  for (int i=1;i<=n;i++) last[i] = 0;\n  for (int i=1;i<=n+n-2;i++) {\n    pred[i] = last[ss[i]];\n    last[ss[i]] = i;\n  }\n  for (int i=1;i<=n;i++) was[i] = false;\n  build(1);\n  for (int i=1;i<=n;i++) was[i] = false;\n  ans = 0;\n  go(1, -1);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "trees"], "dificulty": "2000", "interactive": false}