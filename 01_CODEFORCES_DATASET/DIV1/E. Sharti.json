{"link": "https://codeforces.com//contest/494/problem/E", "problemId": "19368", "problem_idx": "E", "shortId": "494E", "contest_number": "494", "problem_submissions": {"D": [9118626, 9110497, 9186603, 9121795, 9113766, 9135685, 9135672, 9135646, 9135644, 9118440, 9118021, 9114872], "C": [9115660, 9117032, 9115729, 9112157, 9113416, 9118088, 9112989, 9113678, 9114840, 9114457, 9115024, 9116699, 9114578, 9115874, 9153533], "E": [9112090, 9123061, 9123029, 9114944, 9811638], "B": [9104681, 9106022, 9107594, 9107713, 9107377, 9105960, 9107410, 9107902, 9108808, 9108302, 9109468, 9108127, 9106911, 9107132, 9108038, 9109018], "A": [9103881, 9104046, 9103935, 9104128, 9103929, 9104036, 9104015, 9104004, 9104614, 9104250, 9104342, 9104831, 9104167, 9104248, 9104541, 9104804]}, "name": "E. Sharti", "statement": "During the last 24 hours Hamed and Malek spent all their time playing\r\n\"Sharti\". Now they are too exhausted to finish the last round. So they\r\nasked you for help to determine the winner of this round. \"Sharti\" is\r\nplayed on a board with some of cells colored white and others colored\r\nblack. The rows of the board are numbered from top to bottom using\r\nnumber to . Also the columns of the board are numbered from left to\r\nright using numbers to . The cell located at the intersection of -th row\r\nand -th column is denoted by .The players alternatively take turns. In\r\neach turn the player must choose a square with side-length at most with\r\nits lower-right cell painted white. Then the colors of all the cells in\r\nthis square are inversed (white cells become black and vice-versa). The\r\nplayer who cannot perform a move in his turn loses. You know Hamed and\r\nMalek are very clever and they would have played their best moves at\r\neach turn. Knowing this and the fact that Hamed takes the first turn,\r\ngiven the initial board as described in the input, you must determine\r\nwhich one of them will be the winner.\r\n", "solutions": ["#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 888888;\n\nint mn[N], add[N], cnt[N];\nint ry[N];\n\nvoid build(int x, int l, int r) {\n  mn[x] = 0;\n  add[x] = 0;\n  cnt[x] = ry[r] - ry[l - 1];\n  if (l < r) {\n    int y = (l + r) >> 1;\n    build(x + x, l, y);\n    build(x + x + 1, y + 1, r);\n  }\n}\n\nvoid modify(int x, int l, int r, int ll, int rr, int v) {\n  if (ll <= l && r <= rr) {\n    add[x] += v;\n    return;\n  }\n  if (add[x] != 0) {\n    add[x + x] += add[x];\n    add[x + x + 1] += add[x];\n    add[x] = 0;\n  }\n  int y = (l + r) >> 1;\n  if (ll <= y) {\n    modify(x + x, l, y, ll, rr, v);\n  }\n  if (rr > y) {\n    modify(x + x + 1, y + 1, r, ll, rr, v);\n  }\n  int w1 = mn[x + x] + add[x + x];\n  int w2 = mn[x + x + 1] + add[x + x + 1];\n  mn[x] = (w1 < w2 ? w1 : w2);\n  cnt[x] = (w1 == mn[x] ? cnt[x + x] : 0) + (w2 == mn[x] ? cnt[x + x + 1] : 0);\n}\n\nint xa[N], ya[N], xb[N], yb[N];\nint rya[N], ryb[N];\n\nint main() {\n  int n, m, k;\n  scanf(\"%d %d %d\", &n, &m, &k);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d %d %d\", xa + i, ya + i, xb + i, yb + i);\n  }\n  int step = 1;\n  while (step <= k) {\n    vector < pair <int, int> > ys;\n    for (int i = 0; i < m; i++) {\n      if (xa[i] > xb[i] || ya[i] > yb[i]) {\n        continue;\n      }\n      ys.push_back(make_pair(ya[i] - 1, i));\n      ys.push_back(make_pair(yb[i], ~i));\n    }\n    if (ys.empty()) {\n      break;\n    }\n    sort(ys.begin(), ys.end());\n    int t = 0;\n    ry[0] = ys[0].first;\n    int yss = ys.size();\n    for (int i = 0; i < yss; i++) {\n      if (i > 0 && ys[i].first != ys[i - 1].first) {\n        t++;\n        ry[t] = ys[i].first;\n      }\n      if (ys[i].second >= 0) {\n        rya[ys[i].second] = t + 1;\n      } else {\n        ryb[~ys[i].second] = t;\n      }\n    }\n    if (t == 0) {\n      break;\n    }\n    build(1, 1, t);\n    vector < pair <int, int> > e;\n    for (int i = 0; i < m; i++) {\n      if (xa[i] > xb[i] || ya[i] > yb[i]) {\n        continue;\n      }\n      e.push_back(make_pair(xa[i] - 1, i));\n      e.push_back(make_pair(xb[i], ~i));\n    }\n    sort(e.begin(), e.end());\n    int es = e.size();\n    int ans = 0;\n    for (int id = 0; id < es - 1; id++) {\n      int i = e[id].second;\n      if (i >= 0) {\n        modify(1, 1, t, rya[i], ryb[i], 1);\n      } else {\n        modify(1, 1, t, rya[~i], ryb[~i], -1);\n      }\n      int dx = e[id + 1].first - e[id].first;\n      int mul = ry[t] - ry[0];\n      if (mn[1] + add[1] == 0) {\n        mul -= cnt[1];\n      }\n      ans ^= ((dx & 1) * (mul & 1));\n    }\n    if (ans == 1) {\n      puts(\"Hamed\");\n      return 0;\n    }\n    for (int i = 0; i < m; i++) {\n      xa[i] = ((xa[i] + 1) >> 1);\n      ya[i] = ((ya[i] + 1) >> 1);\n      xb[i] = (xb[i] >> 1);\n      yb[i] = (yb[i] >> 1);\n    }\n    n >>= 1;\n    step <<= 1;\n  }\n  puts(\"Malek\");\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "games"], "dificulty": "3200", "interactive": false}