{
    "link": "https://codeforces.com//contest/1344/problem/F",
    "problemId": "600705",
    "problem_idx": "F",
    "shortId": "1344F",
    "contest_number": "1344",
    "problem_submissions": {
        "E": [
            79212522,
            79191531,
            80590953,
            79212872,
            79212690,
            79200320,
            79201434,
            79211282,
            79212433,
            79201854
        ],
        "F": [
            79198229,
            79194392,
            79201012,
            79200076,
            79187834,
            79207199,
            79809754,
            79207634,
            79321670,
            79237209
        ],
        "D": [
            79171968,
            79177519,
            79172745,
            79182190,
            79179127,
            79200953,
            79290388,
            79290327,
            79290278,
            79290202,
            79290106,
            79289995,
            79289887,
            79289860,
            79289837,
            79289762,
            79289686,
            79289607,
            79289576,
            79289521,
            79289422,
            79289347,
            79289280,
            79289191,
            79289098,
            79289025,
            79288951,
            79288889,
            79288802,
            79288740,
            79288714,
            79288657,
            79288619,
            79288562,
            79288537,
            79288505,
            79288461,
            79288426,
            79288386,
            79288343,
            79288285,
            79288204,
            79288164,
            79288116,
            79288088,
            79288039,
            79288012,
            79287980,
            79287919,
            79287860,
            79287808,
            79287736,
            79287668,
            79287637,
            79287604,
            79287566,
            79287547,
            79287511,
            79287459,
            79287434,
            79287397,
            79287350,
            79287296,
            79287262,
            79287211,
            79287167,
            79287127,
            79287079,
            79286996,
            79286949,
            79286890,
            79286845,
            79286781,
            79286728,
            79286696,
            79286656,
            79286614,
            79286579,
            79286534,
            79286474,
            79286420,
            79286389,
            79286352,
            79286300,
            79286206,
            79286092,
            79286033,
            79286000,
            79285960,
            79285920,
            79285841,
            79285783,
            79285724,
            79285687,
            79285642,
            79285596,
            79285548,
            79285495,
            79285449,
            79285406,
            79285333,
            79285275,
            79285210,
            79285148,
            79285111,
            79285080,
            79284856,
            79284810,
            79284730,
            79284667,
            79284608,
            79284558,
            79284511,
            79284467,
            79284408,
            79284359,
            79276900,
            79215004,
            79179390,
            79207200,
            79185960,
            79183492,
            79185743,
            79185899,
            79187272,
            79188204,
            79183059,
            79193595,
            79192774,
            79231073,
            79194712,
            79198266
        ],
        "C": [
            79163958,
            79167940,
            79163314,
            79167454,
            79171067,
            79172648,
            79188375,
            79171587,
            79170701,
            79174750,
            79169461,
            79175789,
            79173516,
            79172995,
            79172803,
            79176868,
            79181841,
            79172312,
            79173542,
            79175559
        ],
        "B": [
            79155063,
            79159060,
            79154263,
            79156872,
            79158896,
            79185288,
            79162853,
            79161753,
            79161038,
            79159421,
            79159787,
            79164882,
            79163754,
            79164480,
            79160984,
            79160540,
            79164542,
            79181585,
            79178109,
            79166538
        ],
        "A": [
            79148759,
            79148909,
            79148790,
            79148832,
            79148971,
            79151724,
            79149355,
            79151000,
            79150191,
            79163668,
            79149361,
            79149785,
            79152609,
            79150965,
            79162044,
            79148915,
            79156438,
            79149648,
            79150451,
            79148779
        ]
    },
    "name": "F. Piet s Palette",
    "statement": "A sequence of primary colors (red, yellow, blue) is mixed as follows.\r\nWhile there are at least two colors, look at the first two. If they are\r\ndistinct, replace them with the missing color. If they are the same,\r\nremove them from the sequence. In the end, if there is one color, that\r\nis the resulting color. Otherwise, if the sequence is empty, we say the\r\nresulting color is white. Here are two example mixings: Piet has a color\r\npalette with cells numbered from 1 to n. Each cell contains a primary\r\ncolor or is empty. Piet is very secretive, and will not share his\r\npalette with you, so you do not know what colors belong to each\r\ncell.However, he did perform k operations. There are four kinds of\r\noperations: In a operation, Piet chooses a subset of cells and mixes\r\ntheir colors together in some order. The order is not necessarily by\r\nincreasing indexes. He records the resulting color. Empty cells are\r\nskipped over, having no effect on the mixing process. The mixing does\r\nnot change the color values stored in the cells. In a operation, Piet\r\nchooses a subset of cells. Any red cells in this subset become yellow,\r\nand any yellow cells in this subset become red. Blue and empty cells\r\nremain unchanged. In a operation, Piet chooses a subset of cells. Any\r\nred cells in this subset become blue, and any blue cells in this subset\r\nbecome red. Yellow and empty cells remain unchanged. In a operation,\r\nPiet chooses a subset of cells. Any yellow cells in this subset become\r\nblue, and any blue cells in this subset become yellow. Red and empty\r\ncells remain unchanged. Piet only tells you the list of operations he\r\nperforms in chronological order, the indexes involved, and the resulting\r\ncolor of each mix operation. For each mix operation, you also know the\r\norder in which the cells are mixed. Given this information, determine\r\nthe color of each cell in the initial palette. That is, you should find\r\none possible state of the palette (before any operations were\r\nperformed), or say that the described situation is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint n,k;\nint col[1000][4];\nvector<bitset<2001>> b;\n\nvoid swa(int x, int a, int b) {\n\tint i = -1; F0R(z,4) if (col[x][z] == a) i = z;\n\tint j = -1; F0R(z,4) if (col[x][z] == b) j = z;\n\tassert(i != -1 && j != -1);\n\tswap(col[x][i],col[x][j]);\n}\n\nint main() {\n\tsetIO(); re(n,k);\n\tF0R(i,n) F0R(j,4) col[i][j] = j;\n\t// is red -> 2, is yellow -> 1\n\tF0R(i,k) {\n\t\tstr s; int m; re(s,m);\n\t\tif (s == \"mix\") b.eb(), b.eb();\n\t\tF0R(j,m) {\n\t\t\tint x; re(x); x --;\n\t\t\tif (s == \"RY\") swa(x,2,1);\n\t\t\telse if (s == \"RB\") swa(x,2,3);\n\t\t\telse if (s == \"YB\") swa(x,1,3);\n\t\t\telse {\n\t\t\t\tassert(s == \"mix\");\n\t\t\t\tif (col[x][2]&2) b[sz(b)-2][2*x] = 1;\n\t\t\t\tif (col[x][2]&1) b[sz(b)-1][2*x] = 1;\n\t\t\t\tif (col[x][1]&2) b[sz(b)-2][2*x+1] = 1;\n\t\t\t\tif (col[x][1]&1) b[sz(b)-1][2*x+1] = 1;\n\t\t\t}\n\t\t}\n\t\tif (s == \"mix\") {\n\t\t\tchar res; re(res);\n\t\t\tif (res == 'R' || res == 'B') b[sz(b)-2][2000] = 1;\n\t\t\tif (res == 'Y' || res == 'B') b[sz(b)-1][2000] = 1;\n\t\t}\n\t}\n\tint cur = 0;\n\tF0R(z,2001) {\n\t\tFOR(i,cur,sz(b)) if (b[i][z] == 1) {\n\t\t\tswap(b[i],b[cur]); assert(b[cur][z] == 1);\n\t\t\tF0R(j,sz(b)) if (j != cur && b[j][z]) b[j] ^= b[cur];\n\t\t\tcur ++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvi tmp(n);\n\tF0R(i,sz(b)) {\n\t\tint ind = 0; while (ind < 2001 && !b[i][ind]) ind ++;\n\t\tif (ind == 2001) continue;\n\t\tif (ind == 2000) {\n\t\t\tps(\"NO\");\n\t\t\texit(0);\n\t\t}\n\t\tassert(ind < 2*n);\n\t\tif (ind%2 == 0) tmp[ind/2] += 2*b[i][2000];\n\t\telse tmp[ind/2] += b[i][2000];\n\t}\n\tps(\"YES\");\n\tF0R(i,n) {\n\t\tif (tmp[i] == 3) pr('B');\n\t\telse if (tmp[i] == 2) pr('R');\n\t\telse if (tmp[i] == 1) pr('Y');\n\t\telse pr('.');\n\t}\n\tps();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "matrices"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Piet s Palette.json",
    "editorial_link": "https://codeforces.com//blog/entry/76819",
    "editorial": "Equate an empty cell with the color white, and let\u00e2\u0080\u0099s represent the\r\ncolors as 0/1 vectors: Under this representation, mixing becomes\r\naddition . And the operations , , are linear transformations of the\r\ncolors. That is, each of these operations is equivalent to multiplying\r\nthe corresponding matrix by a cell\u00e2\u0080\u0099s vector: We simply have a system of\r\nlinear equations on unknowns, which we can solve with Gaussian\r\nelimination using bitsets.Complexity is\r\n"
}