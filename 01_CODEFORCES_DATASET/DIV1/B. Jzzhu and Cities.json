{
    "link": "https://codeforces.com//contest/449/problem/B",
    "problemId": "11566",
    "problem_idx": "B",
    "shortId": "449B",
    "contest_number": "449",
    "problem_submissions": {
        "E": [
            7172419,
            7172014,
            7174895,
            7169365,
            7240994,
            7177576,
            9954696,
            9954686
        ],
        "A": [
            7167638,
            7162064,
            7159189,
            7170577,
            7159566,
            7171912,
            7174755,
            7177754,
            7174429,
            7180997,
            7161684,
            7182849,
            7192923,
            7180517,
            7168378,
            7168819,
            7159358
        ],
        "C": [
            7166638,
            7168442,
            7168589,
            7167422,
            7169338,
            7166871,
            7167683,
            7167793,
            7161177,
            7181293,
            7173309,
            7170890,
            7173119,
            7170721,
            7171917,
            7171483,
            7167450,
            7178771,
            7171038
        ],
        "D": [
            7161895,
            7168837,
            7161219,
            7163790,
            7163207,
            7165070,
            7164972,
            7165472,
            7166314,
            7182041,
            7171873,
            7166502,
            7159887,
            7192953,
            7166535,
            7169239,
            7169537,
            7165449,
            7159363,
            7166505
        ],
        "B": [
            7159593,
            7164450,
            7164390,
            7162671,
            7166735,
            7162159,
            7160515,
            7161879,
            7168809,
            7176245,
            7164684,
            7165872,
            7161265,
            7163102,
            7161569,
            7175028,
            7162358,
            7183380
        ]
    },
    "name": "B. Jzzhu and Cities",
    "statement": "Jzzhu is the president of country A. There are cities numbered from to\r\nin his country. City is the capital of A. Also there are roads\r\nconnecting the cities. One can go from city to (and vise versa) using\r\nthe -th road, the length of this road is . Finally, there are train\r\nroutes in the country. One can use the -th train route to go from\r\ncapital of the country to city (and vise versa), the length of this\r\nroute is .Jzzhu doesn’t want to waste the money of the country, so he is\r\ngoing to close some of the train routes. Please tell Jzzhu the maximum\r\nnumber of the train routes which can be closed under the following\r\ncondition: the length of the shortest path from every city to the\r\ncapital mustn’t change.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n#define MOD 1000000009\n#define ADD(X, Y) ((X) = ((X) + (Y)) % MOD)\n\ntypedef long long i64;\n\nint N, M, K;\nvector<int> to[100000], dist[100000];\nbool vis[100000];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\n\tfor (int i = 0; i < M; i++) {\n\t\tint u, v, x;\n\t\tscanf(\"%d%d%d\", &u, &v, &x);\n\n\t\t--u; --v;\n\n\t\tto[u].push_back(v);\n\t\tdist[u].push_back(x);\n\t\tto[v].push_back(u);\n\t\tdist[v].push_back(x);\n\t}\n\n\tfor (int i = 0; i < N; i++) vis[i] = false;\n\n\tpriority_queue<pair<i64, int> > Q;\n\tQ.push(make_pair((i64)0, 0));\n\t\n\tfor (int i = 0; i < K; i++) {\n\t\tint s, y;\n\t\tscanf(\"%d%d\", &s, &y);\n\n\t\t--s;\n\n\t\tQ.push(make_pair(-(i64)y, s - N));\n\t}\n\n\tint ret = 0;\n\n\twhile(!Q.empty()) {\n\t\tpair<i64, int> tmp = Q.top(); Q.pop();\n\n\t\tif (tmp.second < 0) {\n\t\t\ttmp.second += N;\n\n\t\t\tif(vis[tmp.second]) ++ret;\n\t\t}\n\n\t\tif(vis[tmp.second]) continue;\n\t\tvis[tmp.second] = true;\n\n\t\tint p = tmp.second;\n\n\t\tfor(int i=0;i<to[p].size();i++) Q.push(make_pair(tmp.first - dist[p][i], to[p][i]));\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Jzzhu and Cities.json",
    "editorial_link": "https://codeforces.com//blog/entry/13112",
    "editorial": "We consider a train route as an undirected deletable edge . Let be the\r\nshortest path between and . We add all of the edges weighted where into\r\na new directed graph. A deletable edge can be deleted only if it isnât\r\nin the new graph or the in-degree of in the new graph is more than ,\r\nbecause the connectivity of the new graph wonât be changed after\r\ndeleting these edges. Notice that you should subtract one from the\r\nin-degree of after you delete an edge .\r\n",
    "hint": []
}