{"link": "https://codeforces.com//contest/603/problem/E", "problemId": "42014", "problem_idx": "E", "shortId": "603E", "contest_number": "603", "problem_submissions": {"E": [14601511, 14617280, 14604705, 14600443], "B": [14593533, 14587045, 14589326, 14589031, 14586181, 14589818, 14588082, 14588941, 14588018, 14589775, 14590006, 14589946, 14591160, 14588048, 14591719, 14589609, 14588347, 14594211, 14588610], "C": [14591371, 14590095, 14592691, 14592593, 14589544, 14587905, 14590360, 14592646, 14593601, 14593350, 14595265, 14602871, 14589734, 14593412, 14595137, 14591430, 14591097, 14598084, 14593035], "A": [14587155, 14591228, 14594284, 14586714, 14587304, 14592455, 14586190, 14586556, 14586409, 14588357, 14613579, 14591988, 14586421, 14587516, 14587463, 14586240, 14590046, 14586262], "D": [14596780, 14600081, 14597772, 14601222, 14598361, 14599882, 14599185, 14602018, 14603122, 14599499]}, "name": "E. Pastoral Oddities", "statement": "In the land of Bovinia there are pastures, but no paths connecting the\r\npastures. Of course, this is a terrible situation, so Kevin Sun is\r\nplanning to rectify it by constructing undirected paths connecting pairs\r\nof distinct pastures. To make transportation more efficient, he also\r\nplans to pave some of these new paths.Kevin is very particular about\r\ncertain aspects of path-paving. Since he loves odd numbers, he wants\r\neach pasture to have an odd number of paved paths connected to it. Thus\r\nwe call a paving if each pasture is incident to an odd number of paved\r\npaths. He also enjoys short paths more than long paths, so he would like\r\nthe longest paved path to be as short as possible. After adding each\r\npath, Kevin wants to know if a sunny paving exists for the paths of\r\nBovinia, and if at least one does, the minimum possible length of the\r\nlongest path in such a paving. Note that \"longest path\" here means\r\nmaximum-weight edge.\r\n", "solutions": ["#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 611111\n\n#define TASK \"1\"\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, m;\nint x[N], y[N], l[N];\npair<int, int> q[N];\n\nint p[N], sz[N];\nint odd;\n\nvector<int> z, z3;\nvector<pair<int, int> > z2;\n\nint ans[N];\n\nint u[N];\n\n\nvoid unite(int id) {\n\tint a = x[id];\n\twhile (p[a] != a) a = p[a];\n\tint b = y[id];\n\twhile (p[b] != b) b = p[b];\n\tif (a == b) return;\n\n\tif (sz[a] < sz[b]) swap(a, b);\n\n\tif (sz[a] % 2 == 1&& sz[b] % 2 == 1) {\n\t\tz3.pb(2);\n\t\todd -= 2;\n\t} else {\n\t\tz3.pb(0);\n\t}\n\n\tz2.pb(mp(a, sz[a]));\n\tsz[a] += sz[b];\n\n\tz.pb(b);\n\n\tp[b] = a;\n}\n\nvoid backup(int ver) {\n\twhile (z.size() > ver) {\n\t\todd += z3.back();\n\t\tz3.pop_back();\n\n\t\tsz[z2.back().F] = z2.back().S;\n\t\tz2.pop_back();\n\n\t\tp[z.back()] = z.back();\n\t\tz.pop_back();\n\t}\n}\n\nvoid go(int l, int r, int ll, int rr) {\n\tif (l > r) return;\n\n\tif (odd == 0) {\n\t\tputs(\"!\");\n\t}\n\n\tint ver = z.size();\n\n\tint mid = (l + r) / 2;\n\tint nmid = -1;\n\n\tfor (int i = l; i <= mid; i++) if (u[i] < ll) unite(i);\n\tif (odd == 0) {\n\t\tputs(\"!\");\n\t}\n\n\tfor (int i = ll; i <= rr; i++) if (q[i].S <= mid) {\n\t\tunite(q[i].S);\n\t\tif (odd == 0) {\n\t\t\tnmid = i;\n\t\t\tbreak;\n\t\t}\t\t\n\t}\n\tbackup(ver);\n\n\tif (nmid == -1) {\n\t\tfor (int i = l; i <= mid; i++) ans[i] = -1;\n\t\tfor (int i = l; i <= mid; i++) if (u[i] < ll) {\n\t\t\tunite(i);\n\t\t}\n\n\t\tgo(mid + 1, r, ll, rr);\n\n\t\tbackup(ver);\n\t\treturn;\n\t}\n\tans[mid] = q[nmid].F;\n\n\tfor (int i = ll; i < nmid; i++) if (q[i].S < l) unite(q[i].S);\n\n\tgo(l, mid - 1, nmid, rr);\n\tbackup(ver);\n\n\n\tfor (int i = l; i <= mid; i++) if (u[i] < ll) unite(i);\n\n\tgo(mid + 1, r, ll, nmid);\n\n\tbackup(ver);\n}\n\nint main(){\n//\tfreopen(TASK\".in\",\"r\",stdin);\t\n//\tfreopen(TASK\".out\",\"w\",stdout);\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n\n\t\tq[i] = mp(l[i], i);\n\t}\n\tsort(q, q + m);\n\tfor (int i = 0; i < m; i++) {\n\t\tu[q[i].S] = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tp[i] = i;\n\t\tsz[i] = 1;\n\t}\t\t\n\todd = n;\n\n\tgo(0, m - 1, 0, m - 1);\n\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "dsu", "math", "trees"], "dificulty": "3000", "interactive": false}