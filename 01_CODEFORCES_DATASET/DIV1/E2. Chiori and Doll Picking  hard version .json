{"link": "https://codeforces.com//contest/1336/problem/E2", "problemId": "594571", "problem_idx": "E2", "shortId": "1336E2", "contest_number": "1336", "problem_submissions": {"D": [76886677, 76883955, 76872368, 76882178, 76894871, 76894177, 76885532, 76907882, 77033594, 77091883, 76900082, 76884934, 76874617], "A": [76864054, 76808839, 76828187, 76809546, 76814169, 76823336, 76827670, 76836840, 76814633, 76809091, 76816264, 76813939, 76811729, 76811390, 76834705, 76826600, 76815368, 76837049, 76817310], "B": [76860488, 76819320, 76814288, 76825429, 76828812, 76838781, 76838525, 76843572, 76826054, 76817907, 76825620, 76826257, 76821471, 76823111, 76831291, 76821337, 76838685, 76839113, 76827505], "C": [76854725, 76829511, 76835542, 76846764, 76855809, 76854630, 76858132, 76850152, 76839221, 76831744, 76838549, 76834558, 76833263, 76835970, 76841416, 76837215, 76859411, 76818388, 76844588], "E1": [76850288, 76855475, 76852735, 76883081, 76892755, 76881482, 76888504, 76867895, 76895876, 76859814, 76851085, 76862051, 77146034, 76864099, 76864337, 76853452, 150818764, 150818693, 76914981, 76914599, 76858346, 76859234], "E2": [76849352, 85264213, 76894287, 77317433, 76903834, 77032081, 227735667, 77145907], "F": [76895069, 142907140, 92908333, 92907865, 76904132, 77029817, 77028666, 77028475, 76902682, 76902541]}, "name": "E2. Chiori and Doll Picking  hard version ", "statement": "Chiori loves dolls and now she is going to decorate her bedroom! As a\r\ndoll collector, Chiori has got n dolls. The i-th doll has a non-negative\r\ninteger value a_i (a_i < 2^m, m is given). Chiori wants to pick some\r\n(maybe zero) dolls for the decoration, so there are 2^n different\r\npicking ways.Let x be the bitwise-xor-sum of values of dolls Chiori\r\npicks (in case Chiori picks no dolls x = 0). The value of this picking\r\nway is equal to the number of 1-bits in the binary representation of x.\r\nMore formally, it is also equal to the number of indices 0\r\nleq i < m, such that\r\nleft\r\nlfloor\r\nfrac{x}{2^i}\r\nright\r\nrfloor is odd.Tell her the number of picking ways with value i for each\r\ninteger i from 0 to m. Due to the answers can be very huge, print them\r\nby modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\nconst int maxN = 223456;\nconst int P = 998244353;\nint n, m, rnk;\ni64 base[maxN], p[maxN], dp[60][60][2];\nint cnt[maxN], ans[maxN];\n\nvoid dfs1(int d, i64 x)\n{\n\tif (d == rnk)\n\t{\n\t\tcnt[__builtin_popcountll(x)]++;\n\t}\n\telse\n\t{\n\t\tdfs1(d + 1, x);\n\t\tdfs1(d + 1, x ^ p[d]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ti64 x;\n\t\tscanf(\"%lld\", &x);\n\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (base[j])\n\t\t\t{\n\t\t\t\tx = min(x, base[j] ^ x);\n\t\t\t}\n\t\t\telse if (x & (1ll << j))\n\t\t\t{\n\t\t\t\tbase[j] = x;\n\t\t\t\tp[rnk++] = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (rnk <= m / 2)\n\t{\n\t\tdfs1(0, 0);\n\t\ti64 multi = 1;\n\t\tfor (int i = 0; i < n - rnk; i++)\n\t\t\tmulti = multi * 2 % P;\n\t\tfor (int i = 0; i <= m; i++)\n\t\t{\n\t\t\tprintf(\"%lld \", cnt[i] * multi % P);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i = m - 1; i >= 0; i--)\n\t\t{\n\t\t\tfor (int j = i - 1; j >= 0; j--)\n\t\t\t\tbase[i] = min(base[i], base[i] ^ base[j]);\n\t\t}\n\t\trnk = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif (base[i] == 0)\n\t\t\t{\n\t\t\t\ti64 x = (1ll << i);\n\t\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\t\tif (base[j] & (1ll << i))\n\t\t\t\t\t{\n\t\t\t\t\t\tx ^= (1ll << j);\n\t\t\t\t\t}\n\t\t\t\tp[rnk++] = x;\n\t\t\t}\n\t\tdfs1(0, 0);\n\t\tfor (int x = 0; x <= m; x++)\n\t\t{\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\tdp[0][0][0] = 1;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t\tfor (int par = 0; par <= 1; par++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[j + 1][k + 1][par ^ (j < x)] += dp[j][k][par];\n\t\t\t\t\t\tdp[j + 1][k][par] += dp[j][k][par];\n\t\t\t\t\t}\n\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t{\n\t\t\t\ti64 w = dp[m][k][0] - dp[m][k][1];\n\t\t\t\tw %= P;\n\t\t\t\tif (w < 0)\n\t\t\t\t\tw += P;\n\t\t\t\tans[k] = (ans[k] + cnt[x] * w) % P;\n\t\t\t\t//printf(\"%d %d %lld\\n\", x, k, );\n\t\t\t}\n\t\t}\n\t\ti64 multi = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmulti = multi * 2 % P;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tmulti = multi * (P + 1) / 2 % P;\n\t\tfor (int i = 0; i <= m; i++)\n\t\t{\n\t\t\tprintf(\"%lld \", ans[i] * multi % P);\n\t\t}\n\t}\n\n\t/*\tfor (int x = 0; x <= m; x++)\n\t{\n\t\tint S = (1 << x) - 1;\n\t\tfor (int j = 0; j <= m; j++)\n\t\t{\n\t\t\tint s = 0;\n\t\t\tfor (int T = 0; T < (1 << m); T++)\n\t\t\t\tif (__builtin_popcount(T) == j)\n\t\t\t\t{\n\t\t\t\t\tif (__builtin_parity(S & T))\n\t\t\t\t\t\ts -= 1;\n\t\t\t\t\telse\n\t\t\t\t\t\ts += 1;\n\t\t\t\t}\n\t\t\tprintf(\"%d %d %d\\n\", x, j, s);\n\t\t}\n\t}*/\n\t/*\n\tfor (int S = 0; S < (1 << m); S++)\n\t\tfor (int k = 0; k <= m; k++)\n\t\t{\n\t\t\tint ans = 0;\n\t\t\tfor (int T = 0; T < (1 << m); T++)\n\t\t\t{\n\t\t\t\tbool fs = 1;\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (__builtin_parity(a[k] & T))\n\t\t\t\t\t\tfs = 0;\n\t\t\t\t}\n\t\t\t\tif (__builtin_parity(S & T))\n\t\t\t\t\tans -= fs;\n\t\t\t\telse\n\t\t\t\t\tans += fs;\n\t\t\t\t//ans += fs;\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", ans >> (m - n));*/\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "combinatorics", "math"], "dificulty": "3500", "interactive": false}