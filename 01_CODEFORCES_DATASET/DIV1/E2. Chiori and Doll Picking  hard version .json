{
    "link": "https://codeforces.com//contest/1336/problem/E2",
    "problemId": "594571",
    "problem_idx": "E2",
    "shortId": "1336E2",
    "contest_number": "1336",
    "problem_submissions": {
        "D": [
            76886677,
            76883955,
            76872368,
            76882178,
            76894871,
            76894177,
            76885532,
            76907882,
            77033594,
            77091883,
            76900082,
            76884934,
            76874617
        ],
        "A": [
            76864054,
            76808839,
            76828187,
            76809546,
            76814169,
            76823336,
            76827670,
            76836840,
            76814633,
            76809091,
            76816264,
            76813939,
            76811729,
            76811390,
            76834705,
            76826600,
            76815368,
            76837049,
            76817310
        ],
        "B": [
            76860488,
            76819320,
            76814288,
            76825429,
            76828812,
            76838781,
            76838525,
            76843572,
            76826054,
            76817907,
            76825620,
            76826257,
            76821471,
            76823111,
            76831291,
            76821337,
            76838685,
            76839113,
            76827505
        ],
        "C": [
            76854725,
            76829511,
            76835542,
            76846764,
            76855809,
            76854630,
            76858132,
            76850152,
            76839221,
            76831744,
            76838549,
            76834558,
            76833263,
            76835970,
            76841416,
            76837215,
            76859411,
            76818388,
            76844588
        ],
        "E1": [
            76850288,
            76855475,
            76852735,
            76883081,
            76892755,
            76881482,
            76888504,
            76867895,
            76895876,
            76859814,
            76851085,
            76862051,
            77146034,
            76864099,
            76864337,
            76853452,
            150818764,
            150818693,
            76914981,
            76914599,
            76858346,
            76859234
        ],
        "E2": [
            76849352,
            85264213,
            76894287,
            77317433,
            76903834,
            77032081,
            227735667,
            77145907
        ],
        "F": [
            76895069,
            142907140,
            92908333,
            92907865,
            76904132,
            77029817,
            77028666,
            77028475,
            76902682,
            76902541
        ]
    },
    "name": "E2. Chiori and Doll Picking  hard version ",
    "statement": "Chiori loves dolls and now she is going to decorate her bedroom! As a\r\ndoll collector, Chiori has got n dolls. The i-th doll has a non-negative\r\ninteger value a_i (a_i < 2^m, m is given). Chiori wants to pick some\r\n(maybe zero) dolls for the decoration, so there are 2^n different\r\npicking ways.Let x be the bitwise-xor-sum of values of dolls Chiori\r\npicks (in case Chiori picks no dolls x = 0). The value of this picking\r\nway is equal to the number of 1-bits in the binary representation of x.\r\nMore formally, it is also equal to the number of indices 0\r\nleq i < m, such that\r\nleft\r\nlfloor\r\nfrac{x}{2^i}\r\nright\r\nrfloor is odd.Tell her the number of picking ways with value i for each\r\ninteger i from 0 to m. Due to the answers can be very huge, print them\r\nby modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\nconst int maxN = 223456;\nconst int P = 998244353;\nint n, m, rnk;\ni64 base[maxN], p[maxN], dp[60][60][2];\nint cnt[maxN], ans[maxN];\n\nvoid dfs1(int d, i64 x)\n{\n\tif (d == rnk)\n\t{\n\t\tcnt[__builtin_popcountll(x)]++;\n\t}\n\telse\n\t{\n\t\tdfs1(d + 1, x);\n\t\tdfs1(d + 1, x ^ p[d]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ti64 x;\n\t\tscanf(\"%lld\", &x);\n\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (base[j])\n\t\t\t{\n\t\t\t\tx = min(x, base[j] ^ x);\n\t\t\t}\n\t\t\telse if (x & (1ll << j))\n\t\t\t{\n\t\t\t\tbase[j] = x;\n\t\t\t\tp[rnk++] = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (rnk <= m / 2)\n\t{\n\t\tdfs1(0, 0);\n\t\ti64 multi = 1;\n\t\tfor (int i = 0; i < n - rnk; i++)\n\t\t\tmulti = multi * 2 % P;\n\t\tfor (int i = 0; i <= m; i++)\n\t\t{\n\t\t\tprintf(\"%lld \", cnt[i] * multi % P);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i = m - 1; i >= 0; i--)\n\t\t{\n\t\t\tfor (int j = i - 1; j >= 0; j--)\n\t\t\t\tbase[i] = min(base[i], base[i] ^ base[j]);\n\t\t}\n\t\trnk = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif (base[i] == 0)\n\t\t\t{\n\t\t\t\ti64 x = (1ll << i);\n\t\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\t\tif (base[j] & (1ll << i))\n\t\t\t\t\t{\n\t\t\t\t\t\tx ^= (1ll << j);\n\t\t\t\t\t}\n\t\t\t\tp[rnk++] = x;\n\t\t\t}\n\t\tdfs1(0, 0);\n\t\tfor (int x = 0; x <= m; x++)\n\t\t{\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\tdp[0][0][0] = 1;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t\tfor (int par = 0; par <= 1; par++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[j + 1][k + 1][par ^ (j < x)] += dp[j][k][par];\n\t\t\t\t\t\tdp[j + 1][k][par] += dp[j][k][par];\n\t\t\t\t\t}\n\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t{\n\t\t\t\ti64 w = dp[m][k][0] - dp[m][k][1];\n\t\t\t\tw %= P;\n\t\t\t\tif (w < 0)\n\t\t\t\t\tw += P;\n\t\t\t\tans[k] = (ans[k] + cnt[x] * w) % P;\n\t\t\t\t//printf(\"%d %d %lld\\n\", x, k, );\n\t\t\t}\n\t\t}\n\t\ti64 multi = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmulti = multi * 2 % P;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tmulti = multi * (P + 1) / 2 % P;\n\t\tfor (int i = 0; i <= m; i++)\n\t\t{\n\t\t\tprintf(\"%lld \", ans[i] * multi % P);\n\t\t}\n\t}\n\n\t/*\tfor (int x = 0; x <= m; x++)\n\t{\n\t\tint S = (1 << x) - 1;\n\t\tfor (int j = 0; j <= m; j++)\n\t\t{\n\t\t\tint s = 0;\n\t\t\tfor (int T = 0; T < (1 << m); T++)\n\t\t\t\tif (__builtin_popcount(T) == j)\n\t\t\t\t{\n\t\t\t\t\tif (__builtin_parity(S & T))\n\t\t\t\t\t\ts -= 1;\n\t\t\t\t\telse\n\t\t\t\t\t\ts += 1;\n\t\t\t\t}\n\t\t\tprintf(\"%d %d %d\\n\", x, j, s);\n\t\t}\n\t}*/\n\t/*\n\tfor (int S = 0; S < (1 << m); S++)\n\t\tfor (int k = 0; k <= m; k++)\n\t\t{\n\t\t\tint ans = 0;\n\t\t\tfor (int T = 0; T < (1 << m); T++)\n\t\t\t{\n\t\t\t\tbool fs = 1;\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (__builtin_parity(a[k] & T))\n\t\t\t\t\t\tfs = 0;\n\t\t\t\t}\n\t\t\t\tif (__builtin_parity(S & T))\n\t\t\t\t\tans -= fs;\n\t\t\t\telse\n\t\t\t\t\tans += fs;\n\t\t\t\t//ans += fs;\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", ans >> (m - n));*/\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "combinatorics",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E2. Chiori and Doll Picking  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/76099",
    "editorial": "Build linear basis with given numbers. Suppose: is the length of . is\r\nthe set consisted of numbers which can be produced in . is equal to the\r\nnumber of , where and . is equal to the number of doll picking ways with\r\nvalue . Thus, . Enumerate each base of is picked or not, so you can find\r\nout the whole in and get . Note that you should implement in to make\r\nsure the whole algorithm runs in . Let\u00e2\u0080\u0099s assume the highest -bits in\r\nevery base are , so in there are key bits and non-key bits. We can get a\r\nnew array of bases by Gauss-Jordan Elimination, such that every key bit\r\nis in exactly one base and is in other bases.Then, let be if we consider\r\nthe first bases in , the number of ways that key bits are in xor-sum and\r\nthe binary status of all non-key bits is . Enumerate -th base (suppose\r\nit is equal to ) is picked or not, we write the state transition: .At\r\nlast, we add up to . In conclusion, we get an algorithm.So far, the easy\r\nversion can be passed if you write a solution which runs Algorithm 1 or\r\nAlgorithm 2 by the value of . We can regard as a long zero-indexation\r\narray satisfying . Similarly, we define a long zero-indexation array\r\nsatisfying .By XOR Fast Walsh-Hadamard Transform, we calculate (also can\r\nbe written as ). is equal to the -th number of resulting array. That\r\nmeans is also equal to the sum of every number in . only contains two\r\ndifferent values: and .Proof: The linear space satisfies closure, which\r\nmeans . Thus, . We can proved the lemma by solving an equation. The -th\r\nnumber of is , if and only if is always even, where is any of bases in\r\n.Proof: XOR Fast Walsh-Hadamard Transform tells us, the -th number of is\r\nequal to the sum of for each . Once we find a base such that is odd, the\r\nsum must be according to Lemma 1. The indices of which their values are\r\n, compose an .Proof: See Lemma 2. If is even, is even, obviously is\r\neven. Suppose is the orthogonal linear basis. The length of is .Proof:\r\nWe know that , so . From this, we then find that should be , which means\r\nthe length of is .Let the key bits in are non-key bits in and the\r\nnon-key bits in are key bits in . Now I\u00e2\u0080\u0099ll show you how to get the bases\r\nin . Divide key bits for and put them to the left. Similarly, we put the\r\nkey bits in to the right. Let\u00e2\u0080\u0099s make those key bits form a diagonal.Look\r\nat the following picture. Do you notice that the non-key bit matrices\r\n(green areas) are symmetrical along the diagonal? The proof is\r\nintuitive. should be even according to Lemma 2, where is any of bases in\r\nand is any of bases in . Since we\u00e2\u0080\u0099ve divided key bits for two linear\r\nbasis, is not more than . Once two symmetrical non-key bits are ,\r\nrespectively, there will exist , satisfying . Otherwise, is always or\r\n.In order to get , you can also divide into small linear basis,\r\nconstruct their orthogonal linear basis and intersect them. It is harder\r\nto implement. The -th number of only depends on .Proof: The -th number\r\nof only depends on , so it still holds after Fast Walsh-Hadamard\r\nTransform.Let be the -th number of . Again, Fast Walsh-Hadamard\r\nTransform tells us: Note that . Let\u00e2\u0080\u0099s enumerate . There are different\r\nintersections, each one has ways to generate the remaining part of . So:\r\nIt takes to calculate all necessary combinatorial numbers and .Finally,\r\nlet\u00e2\u0080\u0099s consider the sum of every number in . Suppose is equal to the\r\nnumber of , where and . We can easily get: Just like Algorithm 1. We can\r\nenumerate each base of is picked or not, find out the whole in , get and\r\ncalculate at last. Since one of , has a length of not more than , we\r\njust need to enumerate bases of the smaller one in order to pass the\r\nhard version in .\r\n"
}