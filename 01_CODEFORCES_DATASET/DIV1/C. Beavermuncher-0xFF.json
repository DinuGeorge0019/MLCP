{"link": "https://codeforces.com//contest/77/problem/C", "problemId": "414", "problem_idx": "C", "shortId": "77C", "contest_number": "77", "problem_submissions": {"C": [401808, 400742, 400966, 404072, 400361, 400208, 400941, 399132, 399539, 399983, 400378, 399774, 407149, 402287, 402282, 402225, 399744, 398637, 400241, 400014, 400485], "E": [401176, 402597, 401454, 404668, 404079, 401115], "D": [400489, 400068, 398548, 399459, 399287, 399070, 400249, 400372, 401807, 401513, 401013, 400602, 401052, 401269, 401311, 401338, 401597], "B": [397537, 397714, 397225, 397036, 397723, 398174, 398236, 398396, 398520, 398673, 398469, 399312, 399073, 398622, 399195], "A": [396875, 396922, 399679, 397569, 397031, 397132, 397284, 396942, 397289, 397332, 421869, 407442, 397680, 397555, 399935, 397041, 397524, 397500]}, "name": "C. Beavermuncher-0xFF", "statement": "You are given a tree, completely occupied by beavers. A tree is a\r\nconnected undirected graph without cycles. The tree consists of\r\nvertices, the -th vertex contains beavers. \"Beavermuncher-0xFF\" works by\r\nthe following principle: being at some vertex , it can go to the vertex\r\n, if they are connected by an edge, and eat beaver located at the vertex\r\n. It is impossible to move to the vertex if there are no beavers left in\r\n. \"Beavermuncher-0xFF\" just stand at some vertex and eat beavers in it.\r\n\"Beavermuncher-0xFF\" must move without stops.Why does the\r\n\"Beavermuncher-0xFF\" works like this? Because the developers have not\r\nprovided place for the battery in it and eating beavers is necessary for\r\nconverting their mass into pure energy.It is guaranteed that the beavers\r\nwill be shocked by what is happening, which is why they will not be able\r\nto move from a vertex of the tree to another one. As for the\r\n\"Beavermuncher-0xFF\", it can move along each edge in both directions\r\nwhile conditions described above are fulfilled.The root of the tree is\r\nlocated at the vertex . This means that the \"Beavermuncher-0xFF\" begins\r\nits mission at the vertex and it must return there at the end of\r\nexperiment, because no one is going to take it down from a high place.\r\nDetermine the maximum number of beavers \"Beavermuncher-0xFF\" can eat and\r\nreturn to the starting vertex.\r\n", "solutions": ["#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define y0 y3487465\n#define y1 y8687969\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) {\n    re x > 0 ? x : -x;\n}\n\nint n;\nint m, s;\nvector<pair<ll, int> > v[200000];\nint k[200000];\n\nll go (int x, int p) {\n    k[x]--;\n    for (int i = 0; i < sz (v[x]); i++) {\n        int y = v[x][i].se;\n        if (k[y] > 0 && y != p) v[x][i].fi = go (y, x); else v[x][i].fi = -1;\n    }\n    sort (all (v[x]));\n    reverse (all (v[x]));\n    ll cur = 0;\n    for (int i = 0; i < sz (v[x]) && k[x] > 0; i++) {\n        if (v[x][i].fi < 0) continue;\n        cur += v[x][i].fi + 2;\n        k[x]--;\n    }   \n    for (int i = 0; i < sz (v[x]); i++) {\n        int y = v[x][i].se;\n        if (y == p) continue;\n        int tmp = min (k[x], k[y]);\n        k[x] -= tmp;\n        k[y] -= tmp;\n        cur += 2 * tmp;\n    }\n    re cur;\n}\n\nint main() {\n    scanf (\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf (\"%d\", &k[i]);\n    for (int i = 0; i + 1 < n; i++) {\n        int a, b;\n        scanf (\"%d%d\", &a, &b); a--; b--;\n        v[a].pb (mp (0, b));\n        v[b].pb (mp (0, a));\n    }\n    scanf (\"%d\", &s); s--;\n    k[s]++;\n    cout << go (s, s) << endl;\n    return 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "dsu", "greedy", "trees"], "dificulty": "2100", "interactive": false}