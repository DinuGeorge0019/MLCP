{"link": "https://codeforces.com//contest/1264/problem/D1", "problemId": "486704", "problem_idx": "D1", "shortId": "1264D1", "contest_number": "1264", "problem_submissions": {"B": [66341401, 66322874, 66336572, 66329159, 66325790, 66330100, 66345009, 66330236, 66376038, 66331864, 66336631, 66328124, 66347648, 66329347, 66322983, 66344650, 66327116, 66327090, 66332056], "D2": [66339545, 66335577, 66343751, 66352069, 66344993, 66344301, 66348378, 66362083, 66352256, 66376168, 66345089, 138527512, 66378228, 66393120, 66349950, 66338137, 66353567, 66351786], "D1": [66334941, 66334668, 66343694, 66345117, 66344078, 66344165, 66344520, 66350440, 66349159, 66376114, 66339049, 66358201, 66357642, 66351611, 66357362, 66352980, 66346482, 66338263, 66345809, 66347614], "A": [66330725, 66323882, 66323064, 66323750, 66337390, 66323088, 66323240, 66323608, 66323803, 66375789, 66323639, 66328235, 66324332, 66323365, 66323990, 66326030, 66323496, 66322830, 66323987, 66323760], "C": [66326327, 66330012, 66334720, 66339910, 66341281, 66334697, 66340151, 66333112, 66337232, 66376069, 66331626, 66349943, 66341121, 66340814, 66329673, 66346210, 66334293, 66333006, 66337575, 66339417, 66355906], "E": [66322750, 66338115, 66328737, 66333356, 66334932, 66353827, 66331679, 66338428, 66427601, 66422500, 66422400, 66421563, 66419015, 66419013, 66380135, 66362673, 66361972, 66357957, 66377834, 66346874, 66338003, 66349170, 66358017, 66342846, 66355768, 66361241, 66346679], "F": [66498558, 115183857]}, "name": "D1. Beautiful Bracket Sequence  easy version ", "statement": "Let\u2019s define a correct bracket sequence and its depth as follow: An\r\nempty string is a correct bracket sequence with depth 0. If \"\" is a\r\ncorrect bracket sequence with depth d then \"\" is a correct bracket\r\nsequence with depth d + 1. If \"\" and \"\" are both correct bracket\r\nsequences then their concatenation \"\" is a correct bracket sequence with\r\ndepth equal to the maximum depth of s and t. For a (not necessarily\r\ncorrect) bracket sequence s, we define its depth as the maximum depth of\r\nany bracket sequence induced by removing some characters from s\r\n(possibly zero). For example: the bracket sequence s = \"\" has depth 2,\r\nbecause by removing the third character we obtain a correct bracket\r\nsequence \"\" with depth 2.Given a string a consists of only characters \u201d,\r\n\u201d and \u201d. Consider all (not necessarily correct) bracket sequences\r\nobtained by replacing all characters \u201d in a by either \u201d or \u201d. Calculate\r\nthe sum of all the depths of all these bracket sequences. As this number\r\ncan be large, find it modulo 998244353. in this problem in the first\r\ndivision can be done only if easy and hard versions of this problem was\r\nsolved.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=2010;\nll c[N][N],sc[N][N];\nint lc[N],rc[N],qc[N],n;\nchar s[N];\nll ans;\nll comb(int x,int y) {\n\tif (y<0||y>x) return 0;\n\treturn c[x][y];\n}\nll ccomb(int x,int y) {\n\ty=max(y,0);\n\tif (y>x) return 0;\n\treturn sc[x][y];\n}\nint main() {\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\trep(i,1,n+1) {\n\t\tlc[i]=lc[i-1]+(s[i]=='(');\n\t\trc[i]=rc[i-1]+(s[i]==')');\n\t\tqc[i]=qc[i-1]+(s[i]=='?');\n\t}\n\tfor (int i=0;i<=n;i++) {\n\t\tc[i][0]=c[i][i]=1;\n\t\trep(j,1,i) {\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t\t}\n\t\tper(j,0,i+1) {\n\t\t\tsc[i][j]=(c[i][j]+sc[i][j+1])%mod;\n\t\t}\n\t}\n\trep(d,1,n/2+1) {\n\t\tfor (int pos=1;pos<=n;pos++) {\n\t\t\tif (s[pos]==')') continue;\n\t\t\t// 1..pos-1 \u6070\u597d d-1 \u4e2a\n\t\t\t// pos+1...n \u81f3\u5c11 d \u4e2a\n\t\t\tll lway=0,rway=0;\n\t\t\tlway=comb(qc[pos-1],d-1-lc[pos-1]);\n\t\t\trway=ccomb(qc[n]-qc[pos],d-(rc[n]-rc[pos]));\n\t\t\tans=(ans+lway*rway)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "probabilities"], "dificulty": "2600", "interactive": false}