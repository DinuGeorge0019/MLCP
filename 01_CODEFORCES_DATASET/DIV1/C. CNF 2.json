{"link": "https://codeforces.com//contest/571/problem/C", "problemId": "33723", "problem_idx": "C", "shortId": "571C", "contest_number": "571", "problem_submissions": {"D": [12660141, 12662761, 146472300, 12667793, 12667782, 12667705, 12667665, 12977746, 12977742], "C": [12653738, 12650335, 12656737, 12656719, 12656852, 12658376, 12657879, 12657167, 12658357, 12667656, 12659401, 12658758, 12659293, 12657644, 12661004, 12659862, 12660042, 12658285, 12661048, 12660704], "B": [12648491, 12654015, 12650873, 12650680, 12651137, 12650734, 12651603, 12652409, 12652256, 12649494, 12651874, 12649612, 12648817, 12649026, 12653251, 12652866, 12650455, 12653013, 12651835], "A": [12646811, 12656074, 12648816, 12646668, 12647772, 12648996, 12648968, 12649621, 12647841, 12646486, 12649024, 12647834, 12659587, 12647059, 12649810, 12649525, 12660696, 12648257, 12647136], "E": [13830424]}, "name": "C. CNF 2", "statement": "\u2019In Boolean logic, a formula is in conjunctive normal form (CNF) or\r\nclausal normal form if it is a conjunction of clauses, where a clause is\r\na disjunction of literals\u2019 (cited from\r\nhttps://en.wikipedia.org/wiki/Conjunctive_normal_form)In the other\r\nwords, CNF is a formula of type , where represents a logical \"AND\"\r\n(conjunction), represents a logical \"OR\" (disjunction), and are some\r\nboolean variables or their negations. Each statement in brackets is\r\ncalled a , and are called .You are given a CNF containing variables and\r\ntheir negations. We know that each variable occurs in at most two\r\nclauses (with negation and without negation in total). Your task is to\r\ndetermine whether this CNF is , that is, whether there are such values\r\nof variables where the CNF value is true. If CNF is satisfiable, then\r\nyou also need to determine the values of the variables at which the CNF\r\nis true. It is guaranteed that each variable occurs at most once in each\r\nclause.\r\n", "solutions": ["#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 322000\n\n#define TASK \"1\"\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, k;\nvector<int> pe[N];\nvector<pair<int, int> > vs[N];\n\nvector<pair<int, int> > v[N];\n\nint ok[N], ans[N], take[N];\n\nint used[N];\n\nint match(int x) {\n\tok[x] = 1;\n\tint r = 0;\n\tfor (int i = 0; i < v[x].size(); i++) {\n\t\tif (used[v[x][i].S]) continue;\n\t\tused[v[x][i].S] = 1;\n\n\n\t\tint to = v[x][i].F;\n\t\tif (ok[to]) {\n\t\t\tr = 1;\n\t\t\ttake[v[x][i].S] = x;\n\t\t\tbreak;\n\t\t}\n\n\t\tint t = match(to);\n\t\tif (t == 1) {\n\t\t\tr = 1;\n\t\t\ttake[v[x][i].S] = x;\n\t\t\tbreak;\n\t\t}\n\t\ttake[v[x][i].S] = to;\n\t}\n\treturn r;\n}\n\nint main(){\n//\tfreopen(TASK\".in\",\"r\",stdin);\t\n//\tfreopen(TASK\".out\",\"w\",stdout);\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tint kk;\n\t\tscanf(\"%d\", &kk);\n\t\tpe[i].resize(kk);\n\t\tfor (int j = 0; j < kk; j++) {\n\t\t\tscanf(\"%d\", &pe[i][j]);\n\n\t\t\tvs[abs(pe[i][j])].pb(mp(i, pe[i][j] / abs(pe[i][j])));\n\t\t}\t\t\t\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (vs[i].size() == 0) continue;\n\n\t\tif (vs[i].size() == 1) {\n\t\t\tans[i] = vs[i][0].S;\n\n\t\t\tok[abs(vs[i][0].F)] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (vs[i][0].S == vs[i][1].S) {\n\t\t\tans[i] = vs[i][0].S;\n\n\t\t\tok[abs(vs[i][0].F)] = 1;\n\t\t\tok[abs(vs[i][1].F)] = 1;\n\t\t} else {\n\t\t\tint x = abs(vs[i][0].F);\n\t\t\tint y = abs(vs[i][1].F);\n\n\t\t\tv[x].pb(mp(y, i));\n\t\t\tv[y].pb(mp(x, i));\n\t\t}\n\t}\n\tfor (int i = 1; i <= k; i++) take[i] = -1;\n\tfor (int i = 0; i < n; i++) if (!ok[i]) {\n\t\tint h = match(i);\n\t\tif (h == 0) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\tfor (int i = 1; i <= k; i++) if (take[i] != -1) {\n\t\tfor (int j = 0; j < vs[i].size(); j++) if (vs[i][j].F == take[i]) {\n\t\t\tans[i] = vs[i][j].S;\n\t\t}\t\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (ans[i] == -1) ans[i] = 0;\n\t\tprintf(\"%d\", ans[i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs", "greedy"], "dificulty": "2500", "interactive": false}