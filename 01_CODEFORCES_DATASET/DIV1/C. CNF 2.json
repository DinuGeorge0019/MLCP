{
    "link": "https://codeforces.com//contest/571/problem/C",
    "problemId": "33723",
    "problem_idx": "C",
    "shortId": "571C",
    "contest_number": "571",
    "problem_submissions": {
        "D": [
            12660141,
            12662761,
            146472300,
            12667793,
            12667782,
            12667705,
            12667665,
            12977746,
            12977742
        ],
        "C": [
            12653738,
            12650335,
            12656737,
            12656719,
            12656852,
            12658376,
            12657879,
            12657167,
            12658357,
            12667656,
            12659401,
            12658758,
            12659293,
            12657644,
            12661004,
            12659862,
            12660042,
            12658285,
            12661048,
            12660704
        ],
        "B": [
            12648491,
            12654015,
            12650873,
            12650680,
            12651137,
            12650734,
            12651603,
            12652409,
            12652256,
            12649494,
            12651874,
            12649612,
            12648817,
            12649026,
            12653251,
            12652866,
            12650455,
            12653013,
            12651835
        ],
        "A": [
            12646811,
            12656074,
            12648816,
            12646668,
            12647772,
            12648996,
            12648968,
            12649621,
            12647841,
            12646486,
            12649024,
            12647834,
            12659587,
            12647059,
            12649810,
            12649525,
            12660696,
            12648257,
            12647136
        ],
        "E": [
            13830424
        ]
    },
    "name": "C. CNF 2",
    "statement": "\u2019In Boolean logic, a formula is in conjunctive normal form (CNF) or\r\nclausal normal form if it is a conjunction of clauses, where a clause is\r\na disjunction of literals\u2019 (cited from\r\nhttps://en.wikipedia.org/wiki/Conjunctive_normal_form)In the other\r\nwords, CNF is a formula of type , where represents a logical \"AND\"\r\n(conjunction), represents a logical \"OR\" (disjunction), and are some\r\nboolean variables or their negations. Each statement in brackets is\r\ncalled a , and are called .You are given a CNF containing variables and\r\ntheir negations. We know that each variable occurs in at most two\r\nclauses (with negation and without negation in total). Your task is to\r\ndetermine whether this CNF is , that is, whether there are such values\r\nof variables where the CNF value is true. If CNF is satisfiable, then\r\nyou also need to determine the values of the variables at which the CNF\r\nis true. It is guaranteed that each variable occurs at most once in each\r\nclause.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 322000\n\n#define TASK \"1\"\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, k;\nvector<int> pe[N];\nvector<pair<int, int> > vs[N];\n\nvector<pair<int, int> > v[N];\n\nint ok[N], ans[N], take[N];\n\nint used[N];\n\nint match(int x) {\n\tok[x] = 1;\n\tint r = 0;\n\tfor (int i = 0; i < v[x].size(); i++) {\n\t\tif (used[v[x][i].S]) continue;\n\t\tused[v[x][i].S] = 1;\n\n\n\t\tint to = v[x][i].F;\n\t\tif (ok[to]) {\n\t\t\tr = 1;\n\t\t\ttake[v[x][i].S] = x;\n\t\t\tbreak;\n\t\t}\n\n\t\tint t = match(to);\n\t\tif (t == 1) {\n\t\t\tr = 1;\n\t\t\ttake[v[x][i].S] = x;\n\t\t\tbreak;\n\t\t}\n\t\ttake[v[x][i].S] = to;\n\t}\n\treturn r;\n}\n\nint main(){\n//\tfreopen(TASK\".in\",\"r\",stdin);\t\n//\tfreopen(TASK\".out\",\"w\",stdout);\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tint kk;\n\t\tscanf(\"%d\", &kk);\n\t\tpe[i].resize(kk);\n\t\tfor (int j = 0; j < kk; j++) {\n\t\t\tscanf(\"%d\", &pe[i][j]);\n\n\t\t\tvs[abs(pe[i][j])].pb(mp(i, pe[i][j] / abs(pe[i][j])));\n\t\t}\t\t\t\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (vs[i].size() == 0) continue;\n\n\t\tif (vs[i].size() == 1) {\n\t\t\tans[i] = vs[i][0].S;\n\n\t\t\tok[abs(vs[i][0].F)] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (vs[i][0].S == vs[i][1].S) {\n\t\t\tans[i] = vs[i][0].S;\n\n\t\t\tok[abs(vs[i][0].F)] = 1;\n\t\t\tok[abs(vs[i][1].F)] = 1;\n\t\t} else {\n\t\t\tint x = abs(vs[i][0].F);\n\t\t\tint y = abs(vs[i][1].F);\n\n\t\t\tv[x].pb(mp(y, i));\n\t\t\tv[y].pb(mp(x, i));\n\t\t}\n\t}\n\tfor (int i = 1; i <= k; i++) take[i] = -1;\n\tfor (int i = 0; i < n; i++) if (!ok[i]) {\n\t\tint h = match(i);\n\t\tif (h == 0) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\tfor (int i = 1; i <= k; i++) if (take[i] != -1) {\n\t\tfor (int j = 0; j < vs[i].size(); j++) if (vs[i][j].F == take[i]) {\n\t\t\tans[i] = vs[i][j].S;\n\t\t}\t\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (ans[i] == -1) ans[i] = 0;\n\t\tprintf(\"%d\", ans[i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. CNF 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/19923",
    "editorial": "Firstly let\u00e2\u0080\u0099s assign values to variables occurring in our fomula only\r\nwith negation or only without negation. After that we can throw away the\r\ndisjuncts which contained them, since they are already true, and\r\ncontinue the process until it is possible. To make it run in time limit,\r\none should use dfs or bfs algorithm to eliminate these variables and\r\ndisjuncts. So now we have only variables which have both types of\r\noccurrences in disjucnts. Let\u00e2\u0080\u0099s build a graph with the vertices\r\ncorresponding to disjuncts, and for each varible make an edge between\r\nthe disjuncts that contain and . Now we should choose the directions of\r\nedges in this graph in such a way that every vertex has at least one\r\nincoming edge. We can notice that if some connected component of this\r\ngraph is a tree, the solution is not possible: on each step we can take\r\nsome leaf of this tree, and we have to orient its only edge to it, and\r\nthen erase the leaf. In the end we\u00e2\u0080\u0099ll have only one vertex, and it\u00e2\u0080\u0099ll\r\nnot have any incoming edges. Otherwise, take some cycle in the component\r\nand orient the edges between neighbouring vertices along it. Then run\r\ndfs from every vertex of the cycle and orient each visited edge in the\r\ndirection we went along it. It is easy to easy that after this process\r\nevery vertex will have at least one incoming edge. So, we should\r\nconsider cases with the variables which values can be assigned at once,\r\nthan construct a graph from disjuncts and variables and find whether\r\neach connected component has a cycle. If so, we also should carefully\r\nconstruct the answer, assigning the remaining variables their values,\r\nlooking at the directions of the edges in the graph. The overall\r\ncomplexity is . Problem author: zeliboba. Problem developers: Kostroma,\r\nzeliboba, yarrr. Solution codes: 12873432 (linear solution), 12873446\r\n(), 12873456 (matching solution).\r\n"
}