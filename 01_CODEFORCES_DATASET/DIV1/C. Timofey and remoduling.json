{
    "link": "https://codeforces.com//contest/763/problem/C",
    "problemId": "91411",
    "problem_idx": "C",
    "shortId": "763C",
    "contest_number": "763",
    "problem_submissions": {
        "D": [
            24392378,
            24392196,
            24381252,
            24386512,
            24392124,
            24394387,
            24386765,
            24382498,
            24486986,
            24394269,
            24386191,
            24424544,
            24380258,
            24380559
        ],
        "E": [
            24383804,
            24379798,
            24382054,
            24377568,
            24385205,
            24385996,
            24385356,
            24380328,
            24382103,
            24378328,
            24383177,
            24384291,
            24383316,
            24383261,
            26602690,
            26602470
        ],
        "A": [
            24374208,
            24365694,
            24369536,
            24379218,
            24368162,
            24370205,
            24368697,
            24367762,
            24372789,
            24371841,
            24370735,
            24374219,
            24381920,
            24369005,
            24365735,
            24371025,
            24372089,
            24366605,
            24368551
        ],
        "C": [
            24373544,
            24379290,
            24384264,
            24378866,
            24379343,
            24379755,
            24376326,
            24393137,
            24387552,
            24485763,
            24485746,
            24392939,
            24381638,
            24411493,
            36653644
        ],
        "B": [
            24368982,
            24386986,
            24385221,
            24380830,
            24369478,
            24372225,
            24370708,
            24368820,
            24374499,
            24373776,
            24373025,
            24382359,
            24374187,
            24370609,
            24367209,
            24373968,
            24375645,
            24368619,
            24371120
        ]
    },
    "name": "C. Timofey and remoduling",
    "statement": "Little Timofey likes integers a lot. Unfortunately, he is very young and\r\ncan’t work with very big integers, so he does all the operations modulo\r\nhis favorite prime . Also, Timofey likes to look for arithmetical\r\nprogressions everywhere.One of his birthday presents was a sequence of\r\nintegers . Timofey wants to know whether he can rearrange the elements\r\nof the sequence so that is will be an arithmetical progression modulo ,\r\nor not.Arithmetical progression modulo of length with first element and\r\ndifference is sequence of integers , each taken modulo .\r\n",
    "solutions": [
        "// saratov 2013-2014 I Wuhongxun's code\n\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nconst int N = 1000010;\nint a[N], b[N], G, md, c[N], cl; int m, tot = 0;\nbool vis[N];\n#define nxt(x) (x == n ? 1 : x + 1)\n#define pre(x) (x == 1 ? n : x - 1)\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nvoid work(int n) {\n\ttot++; if (tot > 60) { printf(\"-1\\n\"); return; }\n\tif (m == n) {\n\t\tprintf(\"%d %d\\n\",md,G >= G * m ? 1 : G);\n\t} else if (m - 1 == n) {\n\t\trep(i,1,n) if (a[i] != i - 1) { printf(\"%d %d\\n\",a[i] * G + md,G); return; }\n\t} else if (n <= 1000) {\n\t\tif (n == 1) { printf(\"%d %d\\n\", a[1], 1); return; }\n\t\trep(i,2,n) {\n\t\t\tint d = a[i] - a[1]; if (gcd(d, m) != 1) continue;\n\t\t\tint cnt = 0, j = 1; bool haveans = true;\n\t\t\trep(k,1,n) {\n\t\t\t\tint x = (a[k] + d) % m, t = j; j = nxt(j);\n\t\t\t\twhile (j != t && a[j] != x) j = nxt(j);\n\t\t\t\tif (j == t) { cnt++; if (cnt == 2) { haveans = false; break; }}\n\t\t\t}\n\t\t\tif (haveans) {\n\t\t\t\tint j = n;  n = cl; d *= G, m *= G;\n\t\t\t\tdep(k,n,1) {\n\t\t\t\t\tint x = (c[k] - d + m) % m, t = j; j = pre(j);\n\t\t\t\t\twhile (j != t && c[j] != x) j = pre(j);\n\t\t\t\t\tif (j == t) { printf(\"%d %d\\n\",c[k],d); return; }\n\t\t\t\t}\n\t\t\t\tprintf(\"%d %d\\n\",c[1],d); return;\n\t\t\t}\n\t\t}\n\t\tprintf(\"-1\\n\");\n\t} else {\n\t\tbool flag = true;\n\t\twhile (flag) {\n\t\t\trep(i,1,n) vis[i] = false;\n\t\t\tint x = rand() % n + 1; vis[x] = true; int j = pre(x), k = nxt(x);\n\t\t\tfor(;j != k; j = pre(j)) {\n\t\t\t\twhile (k != j && (a[k] + m - a[x]) % m < (a[x] + m - a[j]) % m) k = nxt(k);\n\t\t\t\tif ((a[j] + a[k]) % m == 2 * a[x] % m) vis[j] = vis[k] = true;\n\t\t\t\tif (k == j) break;\n\t\t\t} \n\t\t\tint l = 0; rep(i,1,n) if (!vis[i]) b[++l] = a[i];\n\t\t\tflag = l < 2; if (!flag) { n = l; rep(i,1,n) a[i] = b[i]; } \n\t\t}\n\t\twork(n);\n\t}\n}\n\nvoid init(int n) {\n\tint g = gcd(m, a[1] + m - a[n]); rep(i,1,n - 1) g = gcd(g, a[i + 1] - a[i]);\n\tG = g, md = a[1] % g;\n\tm /= g; rep(i,1,n) a[i] /= g;\n}\n\nint main() {\n\tsrand(233); int n; scanf(\"%d%d\",&m,&n); cl = n;\n\trep(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\trep(i,1,n) c[i] = a[i];\n\tinit(n); work(n);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Timofey and remoduling.json",
    "editorial_link": "https://codeforces.com//blog/entry/50205",
    "editorial": "First, letâs think about the case when .In this editorial we say that an\r\noutcoming sequence is Assume is the difference of some two elements and\r\nof (). Letâs say that was on -th place in the sequence and was on -th\r\nplace. Then . On the other hand, we have that is less then , so must be\r\ndifference of exactly pairs of elements of . We can count this value in\r\ntime using binary search or in time using a hashtable. Then we know the\r\nvalue of . After that we calculate the value ( is prime so we can use\r\nFermatâs little theorem) and then we know the difference of the\r\nsequence. Then we just take any element of and look on values , and also\r\non . If we can get all of the numbers in in this way, then we know the\r\nfirst element of the sequence. Otherwise, the answer is NO.If , we just\r\nsolve the problem for the complement of in , and then add to the first\r\nelement value . If we had a correct sequence in , then we must have a\r\ncorrect sequence in its complement with the same difference (as long as\r\nis coprime with the difference, the complement is just set of numbers\r\n).Authorâs solution: http://pastebin.com/jTdcUpFM\r\n",
    "hint": []
}