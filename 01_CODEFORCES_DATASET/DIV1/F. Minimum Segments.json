{
    "link": "https://codeforces.com//contest/1887/problem/F",
    "problemId": "2279002",
    "problem_idx": "F",
    "shortId": "1887F",
    "contest_number": "1887",
    "problem_submissions": {
        "F": [
            229268085,
            229284035,
            229267071,
            229288213,
            229337643,
            229337387,
            229279061,
            229293399,
            229278730,
            229369273
        ],
        "E": [
            229253684,
            229249394,
            229294341,
            229258494,
            229338891,
            229258700,
            229275116,
            229278155,
            229250811,
            229297774,
            229297309,
            229282242,
            229283031,
            229282090,
            229282378,
            229286467,
            229267304,
            229286116,
            229271763,
            229270583,
            229329580,
            229283920
        ],
        "D": [
            229234655,
            229233555,
            229233641,
            229232712,
            229245990,
            229235831,
            229244954,
            229260058,
            229227922,
            229264964,
            229263601,
            229262619,
            229264376,
            229257713,
            229260427,
            229286289,
            229259421,
            229255789,
            229242200
        ],
        "C": [
            229225852,
            229226994,
            229224941,
            229350172,
            229237731,
            229225395,
            229233603,
            229237191,
            229279756,
            229270695,
            229241111,
            229246450,
            229246617,
            229251201,
            229242629,
            229237936,
            229246963,
            229224946,
            229244776,
            229494537,
            229293735
        ],
        "B": [
            229219341,
            229218026,
            229215277,
            229224722,
            229339363,
            229339262,
            229339141,
            229221501,
            229217084,
            229218884,
            229227598,
            229211736,
            229227850,
            229229211,
            229230972,
            229210296,
            229231115,
            229228032,
            229227594,
            229234703,
            229369549,
            229231109,
            229226253
        ],
        "A2": [
            229211901,
            229206611,
            229205624,
            229212250,
            229211246,
            229243386,
            229208241,
            229214123,
            229256240,
            229230513,
            229220464,
            229213039,
            229223811,
            229217374,
            229212405,
            229212960,
            229215200,
            229212576,
            229215764,
            229211258
        ],
        "A1": [
            229207683,
            229206848,
            229205786,
            229207920,
            229207504,
            229243262,
            229206160,
            229214648,
            229256343,
            229206102,
            229220609,
            229213336,
            229217825,
            229217804,
            229210022,
            229205186,
            229215529,
            229207309,
            229215990,
            229206166
        ]
    },
    "name": "F. Minimum Segments",
    "statement": "You had a sequence a_1, a_2,\r\nldots, a_n consisting of integers from 1 to n, not necessarily distinct.\r\nFor some unknown reason, you decided to calculate the following of the\r\nsequence: Let r_i (1\r\nle i\r\nle n) be the smallest j\r\nge i such that on the subsegment a_i, a_{i+1},\r\nldots, a_j all distinct numbers from the sequence a appear. More\r\nformally, for any k\r\nin [1, n], there exists l\r\nin [i, j] such that a_k = a_l. If such j does not exist, r_i is\r\nconsidered to be equal to n+1. The characteristic of the sequence a is\r\ndefined as the sequence r_1, r_2,\r\nldots, r_n. Unfortunately, the sequence a got lost, but you still have\r\nits characteristic r. You want to reconstruct any sequence a that\r\nmatches the characteristic, or determine that there is an error in the\r\ncharacteristic and such a sequence does not exist.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\n// std::mt19937 rng;\n// int ok = 0;\nvoid solve() {\n    // int n = rng() % 10 + 1;\n    int n;\n    std::cin >> n;\n    \n    // std::vector<int> A(n + 1);\n    // std::set<int> S;\n    // for (int i = 1; i <= n; i++) {\n    //     A[i] = rng() % i + 1;\n    //     S.insert(A[i]);\n    // }\n    \n    std::vector<int> r(n + 2);\n    for (int i = 1; i <= n; i++) {\n        std::cin >> r[i];\n    }\n    // for (int i = 1; i <= n; i++) {\n    //     int j = i - 1;\n    //     std::set<int> T;\n    //     while (j <= n && T.size() < S.size()) {\n    //         j++;\n    //         if (j <= n) {\n    //             T.insert(A[j]);\n    //         }\n    //     }\n    //     r[i] = j;\n    //     // std::cin >> r[i];\n    // }\n    r[n + 1] = n + 1;\n    if (r[1] > n) {\n        std::cout << \"No\\n\";\n        return;\n    }\n    \n    if (!std::is_sorted(r.begin(), r.end())) {\n        std::cout << \"No\\n\";\n        return;\n    }\n    \n    std::vector<int> L(n + 2, -1), R(n + 2, -1);\n    for (int i = 0; i <= n; i++) {\n        if (r[i] < r[i + 1]) {\n            R[i] = r[i + 1];\n            L[r[i + 1]] = i;\n        }\n    }\n    \n    std::vector<int> pl, pr;\n    for (int i = 1; i <= n; i++) {\n        if (R[i] == -1) {\n            pl.push_back(i);\n        }\n        if (L[i] == -1) {\n            pr.push_back(i);\n        }\n    }\n    \n    int k = pl.size();\n    assert(pr.size() == k);\n    int res = 0;\n    for (int i = 0, j = 0; i < k; i++) {\n        while (j < k && pl[i] >= pr[j]) {\n            j++;\n        }\n        res = std::max(res, j - i);\n    }\n    for (int i = 0; i < k; i++) {\n        R[pl[i]] = i + res < k ? pr[i + res] : n + 1;\n        L[pr[i]] = i - res >= 0 ? pl[i - res] : 0;\n    }\n    \n    std::vector<int> a(n + 1);\n    int tot = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = L[i] == 0 ? ++tot : a[L[i]];\n    }\n    \n    std::vector<int> f(n + 2);\n    for (int i = 1; i <= n; i++) {\n        f[i] = std::max(f[i], R[i]);\n        f[L[i]] = std::max(f[L[i]], i);\n    }\n    for (int i = 1; i <= n + 1; i++) {\n        f[i] = std::max(f[i], f[i - 1]);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (r[i] < f[i - 1]) {\n            std::cout << \"No\\n\";\n            return;\n        }\n    }\n    \n    std::cout << \"Yes\\n\";\n    for (int i = 1; i <= n; i++) {\n        std::cout << a[i] << \" \\n\"[i == n];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Minimum Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/121621",
    "editorial": "Let's consider a sequence a1,a2,,an\n. Let nxti\n be the smallest j>i\n such that aj=ai\n, or n+1\n if such j\n does not exist. It is claimed that the characteristic of the sequence can be uniquely determined from the values of nxt1,nxt2,,nxtn\n. Let's write down the conditions on nxti\n that we can obtain from the characteristic r1,r2,,rn\n:\n\nnxtn=n+1\n.\nIf ri=ri+1\n, then nxti?[i+1,ri]\n, since the number ai\n appears on the subsegment [i+1,ri]\n.\nIf ri<ri+1\n, then nxti=ri+1\n, since we need to extend the segment to the nearest occurrence of the number ai\n.\nFor each i>r1\n, there exists j\n such that nxtj=i\n, since the first occurrence of each number is on the subsegment [1,r1]\n.\nAll nxti?n\n are distinct, since each element can have at most one nearest equal element on its left.\nThese conditions are sufficient, as they can be used to obtain the characteristic equal to r\n.\nWe want to construct the array nxt\n that satisfies these conditions.\n\nWe have some values of nxti\n that we already know, as well as values of nxti\n that should lie in the intervals [i+1,ri+1]\n. Note that the left and right boundaries of these intervals are non-decreasing, so if condition 4 did not exist, we could greedily assign values to nxti\n, moving through the intervals in descending order and assigning the largest unused value of nxti\n that lies in the interval.\n\nLet's fix k\n as the number of intervals in which we will choose the number n+1\n. Obviously, it is more advantageous to place n+1\n in the k\n rightmost intervals, as all intervals in which n+1\n can be placed are nested within each other. After that, we can greedily assign the largest possible values of nxti\n to the intervals from right to left, thus obtaining an answer with the maximum number of nxti?[r1+1,n]\n for a given k\n. If we manage to cover all numbers from [r1+1,n]\n, then we have found a suitable sequence nxt\n.\n\nThus, we have a solution with O(n2)\n complexity: we iterate over k\n and solve it greedily. Let's learn how to optimize it.\n\nLet's find the smallest k\n for which there is an answer without considering condition 4. Note that as k\n increases, the number of nxti?[r1+1,n]\n obtained by the greedy algorithm does not increase, so it is sufficient to run it for the minimum k\n and check if condition 4 is satisfied for the obtained greedy algorithm answer for this k\n.\n\nAfter we find the array nxt\n, it is easy to obtain the array a\n from it.",
    "hint": []
}