{
    "link": "https://codeforces.com//contest/1246/problem/E",
    "problemId": "451071",
    "problem_idx": "E",
    "shortId": "1246E",
    "contest_number": "1246",
    "problem_submissions": {
        "F": [
            63515154,
            63481339,
            63483227,
            63527437
        ],
        "E": [
            63477457,
            63471160,
            63477982,
            63475906,
            63518064,
            63483383,
            63518604,
            97691403,
            63517633,
            63488500
        ],
        "D": [
            63464099,
            63460604,
            63460125,
            63467192,
            63463968,
            63466889,
            63467829,
            63473013,
            63471128,
            63459892,
            63474479,
            63467875,
            63476603,
            63468880,
            63466274,
            63468455,
            63468377,
            63471942,
            63478598,
            63471593
        ],
        "C": [
            63452409,
            63454665,
            63454015,
            63456906,
            63457379,
            63460403,
            63458338,
            63462999,
            63457035,
            63454754,
            63459839,
            63457021,
            63458327,
            63457758,
            63458226,
            63460931,
            63460824,
            63461992,
            63467689,
            63460739
        ],
        "B": [
            63442019,
            63440659,
            63440705,
            63445485,
            63449371,
            63449831,
            63445799,
            63449601,
            63451011,
            63449141,
            63439490,
            63447371,
            63445988,
            63447815,
            63451910,
            63451605,
            63453470,
            63443287,
            63451810,
            63450686
        ],
        "A": [
            63437903,
            63456370,
            63443580,
            63437815,
            63442162,
            63437666,
            63439166,
            63442383,
            63492730,
            63442467,
            63438366,
            63445898,
            63440290,
            63439417,
            63440796,
            63444393,
            63441301,
            63442558,
            63437991,
            63443933,
            63444495
        ]
    },
    "name": "E. To Make 1",
    "statement": "There are n positive integers written on the blackboard. Also, a\r\npositive number k\r\ngeq 2 is chosen, and none of the numbers on the blackboard are divisible\r\nby k. In one operation, you can choose any two integers x and y, erase\r\nthem and write one extra number f(x + y), where f(x) is equal to x if x\r\nis not divisible by k, otherwise f(x) = f(x / k).In the end, there will\r\nbe a single number of the blackboard. Is it possible to make the final\r\nnumber equal to 1? If so, restore any sequence of operations to do so.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void pr(const T& x) { \n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    \n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n    }\n    \n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n    }\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint n,k; // f[2001];\nvi a;\nbitset<2001> posi[1<<16]; // act[1<<16], \n\nint main() {\n\tsetIO(); re(n,k); a.rsz(n); re(a);\n\t/*FOR(i,1,2001) {\n\t\tf[i] = i;\n\t\twhile (f[i] % k == 0) f[i] /= k;\n\t}*/\n\tposi[0][0] = 1;\n\tF0R(i,1<<n) {\n\t\tfor (int j = 2000/k; j; --j) if (posi[i][j*k])\n\t\t\tposi[i][j] = 1;\n\t\tF0R(j,n) if (!(i&(1<<j)))\n\t\t\tposi[i^(1<<j)] |= posi[i]<<a[j];\n\t}\n\t// FOR(j,1,2001) if (posi[(1<<n)-1][j]) ps(\"HA\",j);\n\tif (posi[(1<<n)-1][1]) {\n\t\tps(\"YES\");\n\t\tint cur = (1<<n)-1, des = 1, num = 0;\n\t\tpriority_queue<pi> tmp;\n\t\tvpi ans;\n\t\twhile (cur) {\n\t\t\twhile (des*k <= 2000 && posi[cur][des*k]) des *= k, num ++;\n\t\t\tF0R(j,n) if (cur&(1<<j)) if (des >= a[j] && posi[cur^(1<<j)][des-a[j]]) {\n\t\t\t\tcur ^= 1<<j; des -= a[j];\n\t\t\t\ttmp.push({num,a[j]});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile (sz(tmp) > 1) {\n\t\t\tauto a = tmp.top(); tmp.pop();\n\t\t\tauto b = tmp.top(); tmp.pop();\n\t\t\tassert(a.f == b.f);\n\t\t\tans.pb({a.s,b.s});\n\t\t\tpi res = {a.f,a.s+b.s};\n\t\t\twhile (res.s % k == 0) {\n\t\t\t\tres.f --, res.s /= k;\n\t\t\t}\n\t\t\ttmp.push(res);\n\t\t}\n\t\ttrav(t,ans) ps(t.f,t.s);\n\t} else ps(\"NO\");\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. To Make 1.json",
    "editorial_link": "https://codeforces.com//blog/entry/70898",
    "editorial": null,
    "hint": []
}