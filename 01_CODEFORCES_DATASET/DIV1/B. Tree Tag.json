{
    "link": "https://codeforces.com//contest/1404/problem/B",
    "problemId": "718462",
    "problem_idx": "B",
    "shortId": "1404B",
    "contest_number": "1404",
    "problem_submissions": {
        "D": [
            92054708,
            92052158,
            92068012,
            92035788,
            92064459,
            92065822,
            92054867,
            92062050,
            92059537,
            92069600,
            92065308,
            92064419,
            92678119,
            92059471,
            92066519,
            92058523,
            92073497,
            92059060,
            92052830,
            92062741
        ],
        "E": [
            92047893,
            92058796,
            92034966,
            92060195,
            92054088,
            92055746,
            92059735,
            92056203,
            92048655,
            92056326,
            92057900,
            92058612,
            92678137,
            92064937,
            92060062,
            92063614,
            92088039,
            92051483,
            92069623,
            92058299,
            92069210
        ],
        "C": [
            92043774,
            92041285,
            92054338,
            92054493,
            92055420,
            92044472,
            92045777,
            92047843,
            92049348,
            92054237,
            92046120,
            92049505,
            92048234,
            92678067,
            92045429,
            92049783,
            92049154,
            92048569,
            92049406,
            92065327,
            92047261
        ],
        "B": [
            92036978,
            92033130,
            92045800,
            92048542,
            92038249,
            92036852,
            92044012,
            92035789,
            92064168,
            92038925,
            92038994,
            92035913,
            92678047,
            92035132,
            92035598,
            92039096,
            92040418,
            92033158,
            92055911,
            92034078
        ],
        "A": [
            92024360,
            92023992,
            92037661,
            92039271,
            92026103,
            92027740,
            92024181,
            92023800,
            92023879,
            92029391,
            92028274,
            92025652,
            92678042,
            92026279,
            92026582,
            92024999,
            92023858,
            92026444,
            92025837,
            92024282
        ]
    },
    "name": "B. Tree Tag",
    "statement": "Alice and Bob are playing a fun game of tree tag.The game is played on a\r\ntree of n vertices numbered from 1 to n. Recall that a tree on n\r\nvertices is an undirected, connected graph with n-1 edges.Initially,\r\nAlice is located at vertex a, and Bob at vertex b. They take turns\r\nalternately, and Alice makes the first move. In a move, Alice can jump\r\nto a vertex with distance da from the current vertex. And in a move, Bob\r\ncan jump to a vertex with distance db from the current vertex. The\r\ndistance between two vertices is defined as the number of edges on the\r\nunique simple path between them. In particular, either player is allowed\r\nto stay at the same vertex in a move. Note that when performing a move,\r\na player only occupies the starting and ending vertices of their move,\r\nnot the vertices between them.If after at most 10^{100} moves, Alice and\r\nBob occupy the same vertex, then Alice is declared the winner.\r\nOtherwise, Bob wins.Determine the winner if both players play optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//AGC33 C\ntemplate<class E>\nstruct treediameter{\n\tconst vvc<E>&g;\n\tint r1,r2;\n\tvi d1,d2;\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vi&d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vvc<E>&gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(all(d1))-d1.bg;\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(all(d1))-d1.bg;\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tint a,b,c,d;cin>>a>>b>>c>>d;\n\ta--;b--;\n\tauto t=readTree(n);\n\t\n\tint dia=treediameter<int>(t).dia;\n\tchmin(c,dia);\n\tchmin(d,dia);\n\t\n\tconst string Alice=\"Alice\\n\";\n\tconst string Bob=\"Bob\\n\";\n\t\n\tauto dfs=[&](auto self,int v,int p,int dist)->int{\n\t\tif(v==b)return dist;\n\t\tfor(auto to:t[v])if(to!=p){\n\t\t\tint w=self(self,to,v,dist+1);\n\t\t\tif(w!=-1)return w;\n\t\t}\n\t\treturn int(-1);\n\t};\n\tint ini=dfs(dfs,a,-1,0);\n\tif(ini<=c){\n\t\tdmp(ini);\n\t\tcout<<Alice;\n\t\treturn;\n\t}\n\t\n\tif(c*2>=d){\n\t\tdmp2(c,d);\n\t\tcout<<Alice;\n\t\treturn;\n\t}\n\t\n\tcout<<Bob;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;\n\trep(_,t)slv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "games",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Tree Tag.json",
    "editorial_link": "https://codeforces.com//blog/entry/82366",
    "editorial": "Let's consider several cases independently.\n\nCase 1: dist(a,b)?da\n\nUnsurprisingly, Alice wins in this case by tagging Bob on the first move.\n\nCase 2: 2da?tree diameter\n\nHere, the diameter of a tree is defined as the length of the longest simple path.\n\nIn this case, Alice can move to a center of the tree. Once Alice is there, it doesn't matter where Bob is, since Alice can reach any vertex in the tree in just one move, winning the game.\n\nCase 3: db>2da\n\nIn this case, let's describe a strategy for Bob to win. Because we are not in case 1, Bob will not lose before his first move. Then it is sufficient to show that Bob can always end his turn with distance greater than da\n from Alice.\n\nSince we are not in case 2, there is at least one vertex with distance at least da\n from Alice. If Bob is at such a vertex at the start of his turn, he should simply stay there. Otherwise, there is some vertex v\n with dist(a,v)=da+1\n. Then dist(b,v)?dist(b,a)+dist(a,v)?da+(da+1)=2da+1?db\n, so Bob can jump to v\n on his turn.\n\nCase 4: db?2da\n\nIn this case, Alice's strategy will be to capture Bob whenever possible or move one vertex closer to Bob otherwise. Let's prove that Alice will win in a finite number of moves with this strategy.\n\nLet's root the tree at a\n. Bob is located in some subtree of a\n, say with k\n vertices. Alice moves one vertex deeper, decreasing Bob's subtree size by at least one vertex. Since db?2da\n, Bob cannot move to another subtree without being immediately captured, so Bob must stay in this shrinking subtree until he meets his inevitable defeat.\n\nSolution\n\nThe only non-trivial part in the implementation is checking for cases 1\n and 2\n. Case 1\n is simply checked with DFS. Case 2 only requires computing the diameter of the tree, which is a standard problem.",
    "hint": []
}