{"link": "https://codeforces.com//contest/1630/problem/E", "problemId": "1276000", "problem_idx": "E", "shortId": "1630E", "contest_number": "1630", "problem_submissions": {"E": [144224769, 144215907, 144221628, 144228274, 144219804, 144218158, 144225764, 144238591, 144210990, 144217838, 144226182, 144224358, 144225778, 144221770, 144226514, 144222722, 144227026, 144226268, 144232930], "F": [144210863, 144246407, 144239829, 144237561, 144242088, 144244711, 144244456, 144246802, 144259720, 144255927, 144333444, 144255940, 144608342, 148502898, 148434493, 148432956], "D": [144197307, 144203996, 144209276, 144205176, 144207016, 144204010, 144211325, 144216890, 144199054, 144199808, 144201432, 144206931, 144201023, 144209262, 144204729, 144211122, 144210123, 144205407, 144205842], "C": [144191312, 144195772, 144199628, 144200731, 144196919, 144198723, 144205328, 144206861, 144191587, 144193957, 144195705, 144198126, 144190461, 144203715, 144198045, 144205577, 144200182, 144197491, 144198438], "B": [144182123, 144182453, 144193080, 144189508, 144185231, 144186871, 144189030, 144188822, 144178499, 144179435, 144183325, 144180542, 144180237, 144181268, 144190041, 144176578, 144186138, 144190693, 144189698], "A": [144175474, 144175629, 144182481, 144180498, 144176716, 144180161, 144180336, 144179468, 144172483, 144171609, 144171918, 144172250, 144173608, 144173794, 144181834, 144190017, 144177869, 144180828, 144177686]}, "name": "E. Expected Components", "statement": "Given a cyclic array a of size n, where a_i is the value of a in the\r\ni-th position, . Let us define that a permutation of a is equal to\r\nanother permutation of a if and only if their values are the same for\r\neach position i or we can transform them to each other by performing\r\nsome cyclic rotation. Let us define for a cyclic array b its number of\r\ncomponents as the number of connected components in a graph, where the\r\nvertices are the positions of b and we add an edge between each pair of\r\nadjacent positions of b with equal values (note that in a cyclic array\r\nthe first and last position are also adjacents).Find the expected value\r\nof components of a permutation of a if we select it equiprobably over\r\nthe set of all the different permutations of a.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int N = (int)1e6 + 7;\nint cnt[N];\nint n;\nint a[N];\nint m, g;\nMint dp[N][2];\n\nint gcd(int x, int y) {\n\treturn (y == 0 ? x : gcd(y, x % y));\n}\n\nFactorials F(N);\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tx--;\n\t\tcnt[x]++;\n\t}\n\tm = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (cnt[i] != 0)\n\t\t\ta[m++] = cnt[i];\n\tif (m == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[i][0] = dp[i][1] = 0;\n\tg = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tg = gcd(g, a[i]);\n\tfor (int x = g; x > 0; x--) {\n\t\tif (g % x) continue;\n\t\tassert(n % x == 0);\n\t\tint z = n / x;\n\t\tassert(z > 1);\n\t\tdp[x][1] = 0;\n\t\tdp[x][0] = F.f[z];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint f = a[i] / x;\n\t\t\tdp[x][1] -= Mint(f) * Mint(f - 1);\n\t\t\tdp[x][0] *= F.fi[f];\n\t\t}\n\t\tdp[x][1] /= z - 1;\n\t\tdp[x][1] += z;\n\t\tdp[x][1] *= dp[x][0];\n\t\tfor (int y = 2 * x; y <= g; y += x) {\n\t\t\tif (g % y) continue;\n\t\t\tdp[x][0] -= dp[y][0];\n\t\t\tdp[x][1] -= dp[y][1] * (y / x);\n\t\t}\n\t\t//eprintf(\"x = %d, cnt = %u, sum = %u\\n\", x, dp[x][0].x, dp[x][1].x);\n\t}\n\tMint P = 0, Q = 0;\n\tfor (int x = 1; x <= g; x++) if (g % x == 0) {\n\t\tP += (dp[x][1] * x) * x;\n\t\tQ += dp[x][0] * x;\n\t}\n\tprintf(\"%u\\n\", (P / Q).x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "math", "number theory", "probabilities"], "dificulty": "2900", "interactive": false}