{
    "link": "https://codeforces.com//contest/1630/problem/E",
    "problemId": "1276000",
    "problem_idx": "E",
    "shortId": "1630E",
    "contest_number": "1630",
    "problem_submissions": {
        "E": [
            144224769,
            144215907,
            144221628,
            144228274,
            144219804,
            144218158,
            144225764,
            144238591,
            144210990,
            144217838,
            144226182,
            144224358,
            144225778,
            144221770,
            144226514,
            144222722,
            144227026,
            144226268,
            144232930
        ],
        "F": [
            144210863,
            144246407,
            144239829,
            144237561,
            144242088,
            144244711,
            144244456,
            144246802,
            144259720,
            144255927,
            144333444,
            144255940,
            144608342,
            148502898,
            148434493,
            148432956
        ],
        "D": [
            144197307,
            144203996,
            144209276,
            144205176,
            144207016,
            144204010,
            144211325,
            144216890,
            144199054,
            144199808,
            144201432,
            144206931,
            144201023,
            144209262,
            144204729,
            144211122,
            144210123,
            144205407,
            144205842
        ],
        "C": [
            144191312,
            144195772,
            144199628,
            144200731,
            144196919,
            144198723,
            144205328,
            144206861,
            144191587,
            144193957,
            144195705,
            144198126,
            144190461,
            144203715,
            144198045,
            144205577,
            144200182,
            144197491,
            144198438
        ],
        "B": [
            144182123,
            144182453,
            144193080,
            144189508,
            144185231,
            144186871,
            144189030,
            144188822,
            144178499,
            144179435,
            144183325,
            144180542,
            144180237,
            144181268,
            144190041,
            144176578,
            144186138,
            144190693,
            144189698
        ],
        "A": [
            144175474,
            144175629,
            144182481,
            144180498,
            144176716,
            144180161,
            144180336,
            144179468,
            144172483,
            144171609,
            144171918,
            144172250,
            144173608,
            144173794,
            144181834,
            144190017,
            144177869,
            144180828,
            144177686
        ]
    },
    "name": "E. Expected Components",
    "statement": "Given a cyclic array a of size n, where a_i is the value of a in the\r\ni-th position, . Let us define that a permutation of a is equal to\r\nanother permutation of a if and only if their values are the same for\r\neach position i or we can transform them to each other by performing\r\nsome cyclic rotation. Let us define for a cyclic array b its number of\r\ncomponents as the number of connected components in a graph, where the\r\nvertices are the positions of b and we add an edge between each pair of\r\nadjacent positions of b with equal values (note that in a cyclic array\r\nthe first and last position are also adjacents).Find the expected value\r\nof components of a permutation of a if we select it equiprobably over\r\nthe set of all the different permutations of a.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int N = (int)1e6 + 7;\nint cnt[N];\nint n;\nint a[N];\nint m, g;\nMint dp[N][2];\n\nint gcd(int x, int y) {\n\treturn (y == 0 ? x : gcd(y, x % y));\n}\n\nFactorials F(N);\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tx--;\n\t\tcnt[x]++;\n\t}\n\tm = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (cnt[i] != 0)\n\t\t\ta[m++] = cnt[i];\n\tif (m == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[i][0] = dp[i][1] = 0;\n\tg = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tg = gcd(g, a[i]);\n\tfor (int x = g; x > 0; x--) {\n\t\tif (g % x) continue;\n\t\tassert(n % x == 0);\n\t\tint z = n / x;\n\t\tassert(z > 1);\n\t\tdp[x][1] = 0;\n\t\tdp[x][0] = F.f[z];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint f = a[i] / x;\n\t\t\tdp[x][1] -= Mint(f) * Mint(f - 1);\n\t\t\tdp[x][0] *= F.fi[f];\n\t\t}\n\t\tdp[x][1] /= z - 1;\n\t\tdp[x][1] += z;\n\t\tdp[x][1] *= dp[x][0];\n\t\tfor (int y = 2 * x; y <= g; y += x) {\n\t\t\tif (g % y) continue;\n\t\t\tdp[x][0] -= dp[y][0];\n\t\t\tdp[x][1] -= dp[y][1] * (y / x);\n\t\t}\n\t\t//eprintf(\"x = %d, cnt = %u, sum = %u\\n\", x, dp[x][0].x, dp[x][1].x);\n\t}\n\tMint P = 0, Q = 0;\n\tfor (int x = 1; x <= g; x++) if (g % x == 0) {\n\t\tP += (dp[x][1] * x) * x;\n\t\tQ += dp[x][0] * x;\n\t}\n\tprintf(\"%u\\n\", (P / Q).x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "number theory",
        "probabilities"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Expected Components.json",
    "editorial_link": "https://codeforces.com//blog/entry/99384",
    "editorial": "SolutionThe problem can be solved by applying Burnside\u00e2\u0080\u0099s lemma.The\r\nnumber of different permutations of the cyclic array is equal to the sum\r\nof number of fixed points for each permutation function divided by the\r\nnumber of permutations functions.Let\u00e2\u0080\u0099s focus on two parts.First part\r\n(find the number of different permutations of ):Let\u00e2\u0080\u0099s define a\r\npermutation function as the function that cyclically shifts the array by\r\npositions.In this problem for an array of size we have possible\r\npermutations functions and we would need to find the sum of the number\r\nof fixed points for each permutation function.To find the number of\r\nfixed points for a permutation function we have that must be equal to ,\r\nif we add an edge for each position then by number theory we would\r\nobtain that cycles would be formed and each one of size , then we can\r\nnote that each position will belong to the -th cycle, so we can say that\r\nthe problem can be transformed into counting the number of permutations\r\nwith repetition in an array of size .Let us denote as the number of\r\nvalues equal to in array , when we are processing the function and we\r\nreduce the problem to an array of size we should also decrease to since\r\neach component is made up of values, also we must observe that for\r\nsolving a problem for an array of size , then should be a divisor of\r\n.Let us denote So to count the number of permutations with repetition\r\nfor that can be formed with the frequency array we can use the formula\r\nLet us denote Let us denote as the number of divisors of .Let us denote\r\nas the number of permutations with repetition for an array of size ,\r\nfrom what has been said before we have that must be divisible by so we\r\nonly need to calculate the permutations with repetition for arrays.Now\r\nsuppose that the number of different values of array is then must be at\r\nmost because the gcd of several numbers is always less than or equal to\r\nthe smallest of them.Now to calculate the permutations with repetition\r\nfor a we do it in , for that we need to precalculate some factorials and\r\nmodular inverses before, and since we need to calculate them times, then\r\nwe have that in total the complexity would be but since is at most and\r\nis at most , substituting it would be equal to So to find the sum of the\r\nnumber of fixed points we need the sum of for and divides to , at the\r\nend of all we divide the sum of the number of fixed points by and we\r\nwould obtain the number of different permutations of .To find the for we\r\ndo it with the Euclid\u00e2\u0080\u0099s algorithm in complexity so in total the\r\ncomplexity is Second part (find the expected value of components of\r\ndifferent permutations of ):Here we will use the Linear Expectation\r\nproperty and we will focus on calculating the contribution of each\r\ncomponent separately, the first thing is to realize that the number of\r\ncomponents is equal to the number of different adjacent values, so we\r\nonly need to focus on two adjacent values, except if it is a single\r\ncomponent, this would be a special case. If we have different values we\r\ncan use each different pair of them that in total would be pairs, we can\r\nrealize that when we put a pair its contribution would be equal to the\r\nnumber of ways to permute the remaining values, which if we are in an\r\narray of size and we use the values and it would be equal to:because we\r\nremoving a value and another value from the set, so if we have the\r\nformula:and and are the first two elements then it would be:which would\r\nbe equivalent to:Now to calculate the contribution of the pairs we can\r\nrealize that taking common factor in the previous expression it only\r\nremains to find the sum of for all , this can be found in easily by\r\nkeeping the prefix sum and doing some multiplication. Then at the end we\r\nmultiply by since there are possible pairs of adjacent elements in the\r\ngeneral array.Let us define as the contribution of components of the\r\npermutations with repetition for an array of size , then:Now for each\r\npossible permutation with repetition we have by the Burnside\u00e2\u0080\u0099s lemma\r\nthat in the end we divide it by , so we should also divide by the\r\ncontribution of each component.Let\u00e2\u0080\u0099s define and Let\u00e2\u0080\u0099s define as the sum\r\nof for and divide to .Let\u00e2\u0080\u0099s define as the sum of for and divide to .The\r\nfinal answer would be:The final complexity then is Code\r\n"
}