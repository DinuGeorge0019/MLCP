{"link": "https://codeforces.com//contest/135/problem/E", "problemId": "720", "problem_idx": "E", "shortId": "135E", "contest_number": "135", "problem_submissions": {"C": [944684, 941895, 941745, 941532, 944650, 945527, 942928, 943119, 942454, 943300, 943389, 941561, 941623, 940913, 942350, 941874, 942533], "D": [941660, 943291, 945020, 944509, 943932, 944955, 945060, 946515, 946811, 946183, 947267, 1202616, 943338, 947399, 947531, 948318], "B": [938992, 939256, 939578, 939872, 939430, 940532, 941115, 940491, 940317, 940731, 941548, 939927, 939245, 939945, 939103, 940367, 940260, 939461], "A": [937548, 938377, 938253, 937895, 937980, 938055, 938264, 938797, 937811, 937813, 938237, 937770, 937935, 938511, 937731, 937759, 937846, 937880], "E": [949929, 947660, 945720, 950498, 947878, 947674]}, "name": "E. Weak Subsequence", "statement": "Little Petya very much likes strings. Recently he has received a voucher\r\nto purchase a string as a gift from his mother. The string can be bought\r\nin the local shop. One can consider that the shop has all sorts of\r\nstrings over the alphabet of fixed size. The size of the alphabet is\r\nequal to . However, the voucher has a string type limitation:\r\nspecifically, the voucher can be used to purchase string if the length\r\nof string\u2019s longest substring that is also its weak subsequence (see the\r\ndefinition given below) equals .String with the length of is considered\r\nthe weak subsequence of the string with the length of , if there exists\r\nsuch a set of indexes , that has the following two properties: for all\r\nfrom to ; there exists at least one such (), for which . Petya got\r\ninterested how many different strings are available for him to purchase\r\nin the shop. As the number of strings can be very large, please find it\r\nmodulo (). If there are infinitely many such strings, print \"-1\".\r\n", "solutions": ["#include <cstdio>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n#include <deque>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(abs(x))\n#define y0 y3487465\n#define y1 y8687969\n#define fill(x,y) memset(x,y,sizeof(x))\n                         \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double D;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) { re x > 0 ? x : -x; }\n\nconst int mod = 1000000000 + 7;\n\nint n;\nint m, w;\n\nint power (int a, int b) {\n    int c = 1;\n    while (b) {\n        if (b & 1) c = ((ll)c * a) % mod;\n        b /= 2;\n        a = ((ll)a * a) % mod;\n    }\n    re c;\n}\n\nint f[1000001], rf[1000001];\n\nint main () {\n    scanf (\"%d%d\", &n, &w);\n    f[0] = rf[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        f[i] = ((ll)f[i - 1] * i) % mod;\n        rf[i] = power (f[i], mod - 2);\n    }\n    int ans = 0, cur = 1;\n    for (int i = 1; i <= n; i++) {\n        cur = ((ll)cur * (n - i + 1)) % mod;\n        if (i + 2 <= w) {\n            int all = ((ll)cur * n) % mod;\n            all = ((ll)all * all) % mod;\n            int tmp = f[n];\n            if (n - i - 1 >= 0) tmp = ((ll)tmp * rf[n - i - 1]) % mod; else tmp = 0;\n            tmp = ((ll)tmp * tmp) % mod;\n            tmp = (all - tmp + mod) % mod;\n            tmp = ((ll)tmp * power (n, w - i - 2)) % mod;\n            ans = ((ll)ans + tmp) % mod;\n        } else\n        if (i + 1 == w) {\n            int all = ((ll)cur * cur) % mod;\n            all = ((ll)all * n) % mod;\n            int tmp = ((ll)f[n - 1]) % mod;\n            if (n - i - 1 >= 0) tmp = ((ll)tmp * rf[n - i - 1]) % mod; else tmp = 0;\n            tmp = ((ll)tmp * tmp) % mod;\n            tmp = ((ll)tmp * n) % mod;\n            ans = ((ll)ans + all - tmp + mod) % mod;\n        } else {\n            int k = i - w;\n            int all = ((ll)f[n] * rf[n - i]) % mod;\n            all = ((ll)all * f[n - k]) % mod;\n            all = ((ll)all * rf[n - i]) % mod;\n            int tmp = ((ll)f[n] * rf[n - i]) % mod;\n            tmp = ((ll)tmp * (n - i)) % mod;\n            tmp = ((ll)tmp * f[n - (k + 2)]) % mod;\n            if (n - i - 1 >= 0) tmp = ((ll)tmp * rf[n - i - 1]) % mod; else tmp = 0;\n            ans = ((ll)ans + all - tmp + mod) % mod;\n        }\n    }\n    printf (\"%d\\n\", ans);\n    return 0;\n}"], "input": "", "output": "", "tags": ["combinatorics"], "dificulty": "3000", "interactive": false}