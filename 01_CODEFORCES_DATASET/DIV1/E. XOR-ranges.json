{
    "link": "https://codeforces.com//contest/1456/problem/E",
    "problemId": "814140",
    "problem_idx": "E",
    "shortId": "1456E",
    "contest_number": "1456",
    "problem_submissions": {
        "E": [
            99945782,
            99945769,
            99943961,
            99943904,
            99943880,
            99873391,
            99943557,
            99954051
        ],
        "D": [
            99891549,
            99889664,
            99863279,
            99878437,
            99869286,
            99874783,
            99874448,
            100422602,
            99869392,
            99876033,
            99880017,
            99873016,
            99879341,
            99881425,
            99901920,
            99901451,
            99880281,
            99883086,
            99883614,
            99883199,
            99862733,
            99895776,
            99881158,
            99886907
        ],
        "C": [
            99848424,
            99849677,
            99857483,
            99857864,
            99851459,
            99859071,
            100422587,
            99858400,
            99858652,
            99852406,
            99861212,
            99863136,
            99859584,
            99860765,
            99858493,
            99859743,
            99856324,
            99876682,
            99869205,
            99867241
        ],
        "B": [
            99844017,
            99851835,
            99850170,
            99846295,
            99847821,
            99846905,
            100422569,
            99849394,
            99851833,
            99847449,
            99854585,
            99849459,
            99854424,
            99841592,
            99848884,
            99849963,
            99842794,
            99879792,
            99851060,
            99853174
        ],
        "A": [
            99840628,
            99840575,
            99844401,
            99841761,
            100523512,
            99844053,
            99842901,
            100422550,
            99843639,
            99845108,
            99841813,
            99849319,
            99843116,
            99843583,
            99849152,
            99843890,
            99842869,
            99850296,
            99867700,
            99845589,
            99842066
        ]
    },
    "name": "E. XOR-ranges",
    "statement": "Given integers c_{0}, c_{1},\r\nldots, c_{k-1} we can define the cost of a number 0\r\nle x < 2^{k} as p(x) =\r\nsum_{i=0}^{k-1}\r\nleft(\r\nleft\r\nlfloor\r\nfrac{x}{2^{i}}\r\nright\r\nrfloor\r\nbmod 2\r\nright)\r\ncdot c_{i}. In other words, the cost of number x is the sum of c_{i}\r\nover the bits of x which are equal to one.Let’s define the cost of array\r\na of length n\r\nge 2 with elements from [0, 2^{k}) as follows: cost(a) =\r\nsum_{i=1}^{n - 1} p(a_{i}\r\noplus a_{i+1}), where\r\noplus denotes bitwise exclusive OR operation.You have to construct an\r\narray of length n with minimal cost, given that each element should\r\nbelong to the given segment: l_{i}\r\nle a_{i}\r\nle r_{i}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\ntemplate <typename T> void setmin(T& a, T b) { if (b < a) a = b; }\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint N, K; cin >> N >> K;\n\tvector<array<int64_t, 2>> bounds(N);\n\t// make them both exclusive\n\tfor (auto& a : bounds) {\n\t\tcin >> a[0] >> a[1];\n\t\ta[0]--, a[1]++;\n\t}\n\tvector<int64_t> costs(K); for (auto& c : costs) cin >> c;\n\n\tconst int64_t INF = 1e18;\n\tvector<array<array<int64_t, 4>, 4>> dp((N+1)*(N+2)/2);\n\tauto I = [](int i, int j) {\n\t\treturn j * (j+1) / 2 + (j - i - 1);\n\t};\n\tfor (int k = K; k >= 0; k--) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tfor (int i = j-1; i >= -1; i--) {\n\t\t\t\tfor (int mi = 3; mi >= 0; mi--) {\n\t\t\t\t\tfor (int mj = 3; mj >= 0; mj--) {\n\t\t\t\t\t\tint64_t val;\n\t\t\t\t\t\tif (k == K) {\n\t\t\t\t\t\t\tval = (j-i == 1) ? 0 : INF;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbool needs = i >= 0 && j <= N-1 && bool((((bounds[i][mi>>1] ^ bounds[j][mj>>1]) >> k) ^ mi ^ mj) & 1);\n\t\t\t\t\t\t\tval = dp[I(i,j)][mi&2][mj&2] + (needs * costs[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((mi & 1) && (mj & 1)) {\n\t\t\t\t\t\t\t// we get to skip this part\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (int md = i+1; md <= j-1; md++) {\n\t\t\t\t\t\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\t\t\t\t\t\t// we can try using this midpoint\n\t\t\t\t\t\t\t\t\tint64_t mm = (bounds[md][z] >> k) ^ 1;\n\t\t\t\t\t\t\t\t\tif (bounds[md][0] < (mm << k) && ((mm + 1) << k) <= bounds[md][1]) {\n\t\t\t\t\t\t\t\t\t\tsetmin(val, dp[I(i,md)][mi][2*z+1] + dp[I(md,j)][2*z+1][mj]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[I(i,j)][mi][mj] = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp.back()[0][0] << '\\n';\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. XOR-ranges.json",
    "editorial_link": "https://codeforces.com//blog/entry/85118",
    "editorial": "First, we will make all segments exclusive for convenience.Assume we\r\nhave segment , we gonna analyze the process of forming from highest bit\r\nto lowest bit: Let is the highest bit such that -th bit of and are\r\ndifferent (Apparently, bits higher than of x has to be same with bits of\r\nand ). We call bit of the segment. Now we set -th bit of off (almost\r\nsimilar if we set on). From now on, we have and continue considering\r\nlower bits. If the considered bit is on in , we must set this bit on in\r\n, otherwise, we have two choices: Set this bit off in and consider lower\r\nbits. Set this bit on in and donât need to care about lower bits\r\n(Because now). Let call low bits that we donât need to care bits.Back to\r\nthe problem, imagine if we fixed all non-free bits of every element, how\r\nshould we set other bits in order to minimize the cost? Itâs quite\r\nsimple: Consider -th bit, call the pair if -th bits of and are non-free\r\nbut ones of are free. For each visible pair such that -th bit of\r\nendpoints in this pair are different from each other, weâll add to the\r\nanswer. This thing inspire us to write a dynamic programming function: (\r\nis with is how did you set key bit for -th element, and is where is\r\nlowest non-free bit of this element (equal to or lower than ), similar\r\nto ) is minimal cost at -th and higher bits of such that is currently\r\nvisible. We have two types of transition: Make really visible by going\r\nto -th bit. Make invisible by choosing and choosing such that lowest\r\nnon-free bit of -th element is . (Note that if is the highest bit, first\r\ntransition only be allowed if )Our answer is just\r\n",
    "hint": []
}