{
    "link": "https://codeforces.com//contest/613/problem/A",
    "problemId": "45531",
    "problem_idx": "A",
    "shortId": "613A",
    "contest_number": "613",
    "problem_submissions": {
        "D": [
            15370174,
            15369060,
            15371636,
            15370471,
            15379384,
            15362600,
            15363979,
            15354167,
            15368389,
            15426084,
            15425641,
            15365392,
            15373098,
            18779257,
            15368296,
            15377483,
            15371351
        ],
        "C": [
            15363274,
            15363231,
            15359913,
            15359671,
            15371545,
            15371994,
            15368974,
            15427099,
            15373779,
            15500484,
            15359086,
            15366208,
            15362711,
            15361056,
            15365561,
            15365370
        ],
        "B": [
            15355133,
            15358358,
            15354489,
            15354211,
            15353308,
            15367695,
            15366228,
            15357588,
            15366815,
            15355551,
            15352746,
            15361105,
            15353369,
            15358156,
            15356015,
            15356798
        ],
        "A": [
            15349386,
            15350249,
            15349384,
            15362764,
            15355920,
            15349371,
            15350969,
            15352662,
            15350106,
            15372771,
            15354161,
            15348878,
            15349502,
            15352202,
            15349256,
            15352650
        ],
        "E": [
            15391423,
            16723541,
            16067912,
            16067870
        ]
    },
    "name": "A. Peter and Snow Blower",
    "statement": "Peter got a new snow blower as a New Year present. Of course, Peter\r\ndecided to try it immediately. After reading the instructions he\r\nrealized that it does not work like regular snow blowing machines. In\r\norder to make it work, you need to tie it to some point that it does not\r\ncover, and then switch it on. As a result it will go along a circle\r\naround this point and will remove all the snow from its path.Formally,\r\nwe assume that Peter\u2019s machine is a polygon on a plane. Then, after the\r\nmachine is switched on, it will make a circle around the point to which\r\nPeter tied it (this point lies strictly outside the polygon). That is,\r\neach of the points lying within or on the border of the polygon will\r\nmove along the circular trajectory, with the center of the circle at the\r\npoint to which Peter tied his machine.Peter decided to tie his car to\r\npoint and now he is wondering what is the area of the region that will\r\nbe cleared from snow. Help him.\r\n",
    "solutions": [
        "#include<vector>\n#include<cstring>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n\n    Point (double x = 0, double y = 0) : x(x), y(y) {}\n\n    void in() {\n        scanf(\"%lf%lf\", &x, &y);\n    }\n\n    Point operator - (const Point &b) const {\n        return Point(x - b.x, y - b.y);\n    }\n\n    double dis() const {\n        return sqrt(x * x + y * y);\n    }\n};\n\nint sign(const double &x, const double EPS = 1e-9) {\n    return x < -EPS ? -1 : x > EPS;\n}\n\ndouble dot(const Point &a, const Point &b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble det(const Point &a, const Point &b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nconst int N = 100005;\n\nint n;\n\nPoint o, p[N];\n\nconst double PI = acos(-1);\n\nint main() {\n    scanf(\"%d\", &n);\n    o.in();\n    double mins = 1e100, maxs = 0;\n    for (int i = 0; i < n; ++i) {\n        p[i].in();\n    }\n    p[n] = p[0];\n    for (int i = 0; i < n; ++i) {\n        maxs = max(maxs, (p[i] - o).dis());\n        mins = min(mins, (p[i] - o).dis());\n        if (sign(dot(o - p[i], p[i + 1] - p[i])) >= 0 && sign(dot(o - p[i + 1], p[i] - p[i + 1])) >= 0) {\n            mins = min(mins, fabs(det(p[i + 1] - p[i], o - p[i]) / (p[i] - p[i + 1]).dis()));\n        }\n    }\n    printf(\"%.12f\\n\", PI * (maxs * maxs - mins * mins));\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "geometry",
        "ternary search"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Peter and Snow Blower.json",
    "editorial_link": "https://codeforces.com//blog/entry/22832",
    "editorial": "Consider distances between the point and\nall points of the polygon. Let be the largest among all distances, and\nbe the smallest among all distances. The swept area is then a ring\nbetween circles of radii and , and the answer is equal to . Clearly, is\nthe largest distance between and vertices of the polygon. However, can\nbe the distance between and some point lying on the side of the polygon,\ntherefore, is the smallest distance between and all sides of the\npolygon. To find the shortest distance between a point and a segment ,\nconsider a straight line containing the segment . Clearly, the shortest\ndistance between and is the length of the perpendicular segment. One\nshould consider two cases: when the end of the perpendicular segment\nlies on the segment (then the answer is the length of the perpendicular\nsegment), or when it lies out of (then the answer is the shortest\ndistance to the ends of ).\n"
}