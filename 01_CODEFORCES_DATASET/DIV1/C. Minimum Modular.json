{
    "link": "https://codeforces.com//contest/303/problem/C",
    "problemId": "2985",
    "problem_idx": "C",
    "shortId": "303C",
    "contest_number": "303",
    "problem_submissions": {
        "D": [
            3709553,
            3709363,
            3711716,
            3706959,
            3711238,
            3710228,
            3710306,
            3708941,
            3711129,
            3709516
        ],
        "C": [
            3708423,
            3712044,
            3708743,
            3711908,
            3708382,
            3713447,
            3708443,
            3708735,
            3709727,
            3721641,
            3721639,
            3708625,
            9135696,
            3709288,
            3710050,
            3710908,
            3710008
        ],
        "B": [
            3707219,
            3707849,
            3707392,
            3708158,
            3707654,
            3707136,
            3707080,
            3707477,
            3707196,
            3707562,
            3707548,
            3709279,
            3718742,
            3707141,
            3707469,
            3706781,
            3708750,
            3708294
        ],
        "A": [
            3706160,
            3706280,
            3706779,
            3706051,
            3706066,
            3706259,
            3706288,
            3706277,
            3707619,
            3706249,
            3706193,
            3706655,
            3706132,
            3706057,
            3706549,
            3706144,
            3707218,
            3706263,
            3706997
        ]
    },
    "name": "C. Minimum Modular",
    "statement": "You have been given distinct integers . You can remove at most of them.\r\nFind the minimum modular , so that for every pair of the remaining\r\nintegers , the following unequality holds: .\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nvector<int> df[1000005];\n\nbool taken[1000005];\nbool used[1000005];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n    for (int i = 0; i <= 1000000; ++i) {\n        df[i].reserve(10);\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (i != j) {\n                int c = abs(v[i] - v[j]);\n                if ((int) df[c].size() < 2 * (k + 1)) {\n                    df[c].PB(v[i]);\n                    df[c].PB(v[j]);\n                }\n            }\n        }\n    }\n    for (int m = 1; m <= 1000001; ++m) {\n        vector<int> cused;\n        int res = 0;\n        for (int d = 0; d <= 1000000; d += m) {\n            if ((int) df[d].size() >= 2 * (k + 1)) {\n                res = k + 1;\n                break;\n            }\n            FORE (it, df[d]) {\n                if (used[*it]) {\n                    continue;\n                }\n                int a = *it % m;\n                if (taken[a]) {\n                    ++res;\n                } else {\n                    taken[a] = true;\n                }\n                used[*it] = true;\n                cused.PB(*it);\n            }\n            if (res > k) {\n                break;\n            }\n        }\n        if (res <= k) {\n            cout << m << endl;\n            return 0;\n        }\n        FORE (it, cused) {\n            used[*it] = false;\n            taken[*it % m] = false;\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "graphs",
        "math",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Minimum Modular.json",
    "editorial_link": "https://codeforces.com//blog/entry/7641",
    "editorial": "Math, Graph theory, Brute-force, Congruent\n\nIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai?-?aj)?=?x.\n\nSo ans is legal <=> diff[ans], diff[2*ans] \u0085 are false.\n\nThe time-complexity O(n2?+?mlogm). Here m is the maximum ai.\n\nConsider on k?>?0, we need to know how many pairs which has difference x. Store them in\nvector<pair <int, int> > diff[x];\n\nThen use a dsu to maintain the how many a_i are congruent when enumerate on the ans."
}