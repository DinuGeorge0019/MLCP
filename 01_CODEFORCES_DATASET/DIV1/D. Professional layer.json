{
    "link": "https://codeforces.com//contest/1103/problem/D",
    "problemId": "286156",
    "problem_idx": "D",
    "shortId": "1103D",
    "contest_number": "1103",
    "problem_submissions": {
        "E": [
            48753270,
            48771690,
            48772282
        ],
        "C": [
            48737996,
            48751833,
            48742130,
            48750924,
            48753455,
            48785591,
            48744586,
            48747377,
            48750469,
            48752184,
            48749897,
            48750575,
            48750490,
            48749685,
            48751441
        ],
        "B": [
            48729408,
            48731995,
            48733031,
            48738196,
            48732688,
            48735686,
            48732548,
            48745783,
            48738143,
            48736855,
            48734767,
            48731627,
            48740835,
            48746307,
            48736276,
            48737788,
            48737739,
            48735990,
            48736042
        ],
        "A": [
            48723784,
            48727790,
            48725191,
            48732437,
            48724396,
            48725785,
            48724635,
            48726318,
            48725482,
            48726526,
            48724739,
            48726676,
            48725374,
            48729843,
            48724696,
            48726116,
            48730660,
            48725296,
            48724384
        ],
        "D": [
            48745574,
            48759308,
            48758091,
            48757563,
            48785689,
            48755420,
            48758598,
            48759719,
            48935021,
            48790648,
            48790368,
            48790273,
            48768973,
            48768847,
            48768502,
            48768204,
            48768156,
            48759654,
            48763805,
            48758531
        ]
    },
    "name": "D. Professional layer",
    "statement": "Cardbluff is popular sport game in Telegram. Each Cardbluff player has\r\never dreamed about entrance in the professional layer. There are n\r\njudges now in the layer and you are trying to pass the entrance exam.\r\nYou have a number k your skill in Cardbluff.Each judge has a number a_i\r\nan indicator of uncertainty about your entrance to the professional\r\nlayer and a number e_i an experience playing Cardbluff. To pass the exam\r\nyou need to convince all judges by playing with them. You can play only\r\ngame with each judge. As a result of a particular game, you can divide\r\nthe uncertainty of i-th judge by any natural divisor of a_i which is at\r\nmost k. If GCD of all indicators is equal to 1, you will enter to the\r\nprofessional layer and become a judge.Also, you want to minimize the\r\ntotal amount of spent time. So, if you play with x judges with total\r\nexperience y you will spend x\r\ncdot y seconds.Print minimal time to enter to the professional layer or\r\n-1 if it’s impossible.\r\n",
    "solutions": [
        "//#pragma GCC diagnostic error \"-std=c++11\"\n#pragma optimize(\"unroll-loops,no-stack-protector\")\n#include<bits/stdc++.h>\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define ALL(a) a.begin(),a.end()\n#define lowbit(x) ((x)&-(x))\n#define dec minus_down\nusing namespace std;\ntypedef unsigned long long u64;\ntypedef unsigned int u32;\ntypedef pair<int,int>pii;\ntypedef vector<int>VI;\ntypedef long long i64;\ntypedef long long ll;\ntypedef double ld;\nnamespace io{\n\tstruct eof{eof(){}};\n\tconst int L=(1<<21)|5;\n\tchar ibuf[L],*iS,*iT,obuf[L],*oS=obuf,*oT=obuf+L-1,c,qu[55];int f,qr;\n\t#define gc() (iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,L,stdin),(iS==iT?EOF:*iS++)):*iS++)\n\tinline void flush(){fwrite(obuf,1,oS-obuf,stdout),oS=obuf;}\n\tinline void putc(char x){*oS++=x;if(oS==oT)flush();}\n\ttemplate<class I>inline void gi(I&x){\n\t\tfor(f=1,c=gc();(c<'0'||c>'9')&&(c!=EOF);c=gc())if(c=='-')f=-1;\n \t\tif(c==EOF)throw eof();\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n\ttemplate<class I>inline void print(I x){\n\t\tif(!x)putc('0');if(x<0)putc('-'),x=-x;\n\t\twhile(x)qu[++qr]=x%10+'0',x/=10;while(qr)putc(qu[qr--]);\n\t}\n#if __cplusplus < 201103L\n\t// do nothing\n#else\n\tstruct StringReader{\n\t\tfunction<bool(char)>chk;\n\t\tStringReader(){chk=[&](char c){return c<='z'&&c>='a';};}\n\t\tStringReader(function<bool(char)>func){chk=func;}\n\t\tinline char read(){for(c=gc();!chk(c);c=gc());return c;}\n\t\tinline void gs(char*s){for(c=gc();!chk(c);c=gc());for(;chk(c);c=gc())*s++=c;*s=0;}\n\t\tstring readString(){string s;for(c=gc();!chk(c);c=gc());for(;chk(c);c=gc())s+=c;return s;}\n\t};\n#endif\n\tinline void ps(const char*s){int l=strlen(s),x;for(x=0;x<l;x++)putc(s[x]);}\n\tstruct IOC{~IOC(){flush();}}ioc;\n\tinline double readld(){\n\t\tdouble x=0,y=1;\n\t\tfor(c=gc();c<'0'||c>'9';c=gc())if(c=='-')y=-1;assert(c!='.');\n\t\tfor(;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=y;assert(c!='e');\n\t\tif(c=='.')for(c=gc();c<='9'&&c>='0';c=gc())y*=0.1,x+=y*(c&15);\n\t\treturn x;\n\t}\n\tinline void printld(double x,int y){\n\t\tif(x<0)putc('-'),x=-x;x+=.5*pow(.1,y);print((u64)x),putc('.');\n\t\tfor(x-=(u64)x;y;--y)x*=10,putc((int)x+'0'),x-=(int)x;\n\t}\n}using io::gi;using io::print;using io::putc;\ntemplate<class T>int ctz(T a){return sizeof(T)>4?__builtin_ctzll(a):__builtin_ctz(a);}\ntemplate<class T>inline T gcd(T a,T b){\n\tint shift=ctz(a|b);\n\tfor(b>>=ctz(b),a>>=ctz(a);a;a-=b,a>>=ctz(a))if(a<b)swap(a,b);\n\treturn b<<shift;\n}\ntemplate<class T>void exgcd(T a,T b,T&x,T&y){\n\tif(!b)return (void)(x=1,y=0);\n\texgcd(b,a%b,y,x),y-=a/b*x;\n}\ntemplate<class T>T Inv(T a,T p){T x,y;exgcd(a,p,x,y);return (x%p+p)%p;}\ninline int fpow(int a,int t,int p){static int r;for(r=1;t;a=(ll)a*a%p,t>>=1)if(t&1)r=(ll)r*a%p;return r;}\nstring to_string(string s){return '\"'+s+'\"';};\nstring to_string(const char*s){return to_string(string(s));}\nstring to_string(bool f){return f?\"true\":\"false\";}\ntemplate<class A,class B>string to_string(pair<A,B>p){return \"(\"+to_string(p.fi)+\", \"+to_string(p.se)+\")\";}\ntemplate<class T>string to_string(T v){string s=\"{\",e=\"\";for(auto&x:v)s+=e+to_string(x),e=\", \";s+=\"}\";return s;}\nvoid debug_out(){cerr<<endl;}template<class A,class...B>void debug_out(A x,B...y){cerr<<\" \"<<to_string(x),debug_out(y...);}\nvoid scan(){}template<class A,class...B>void scan(A&a,B&...b){gi(a),scan(b...);}\ntemplate<class T>void read(T first,T last){for(;first!=last;++first)gi(*first);}\ntemplate<class T>void write(T first,T last){for(;first!=last;putc(++first==last?'\\n':' '))print(*first);}\ntemplate<class T>void show(T x){print(x),putc('\\n');}\ntemplate<class A,class...B>void show(A a,B...b){print(a),putc(' '),show(b...);}\ntemplate<class T>inline bool chkmin(T&a,T b){return b<a?a=b,true:false;}\ntemplate<class T>inline bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>inline T abs(T x){return x<0?-x:x;}\nconst int P=1e9+7,mod=P;\ninline void inc(int&x,int y){x+=y;x<P?:x-=P;}\ninline void inc(int&x,u64 y){x=(x+y)%P;}\ninline void dec(int&x,int y){x-=y;x>=0?:x+=P;}\ninline void dec(int&x,u64 y){x-=y%P;x>=0?:x+=P;}\ninline int add(int x,int y){return (x+=y)<mod?x:x-mod;}\ninline int sub(int x,int y){return (x-=y)<0?x+mod:x;}\ninline int mul(int x,int y){return i64(x)*y%mod;}\ninline void addx(int&x,int y){(x+=y)<mod?:x-=mod;}\ninline void subx(int&x,int y){(x-=y)>=0?:x+=mod;}\ntemplate<class T>inline int sgn(T x){return (x>0)-(x<0);}\ninline int fpow(int a,i64 t){\n\tstatic const int fmod=mod-1;\n\tt%=fmod;if(t<0)t+=fmod;int r;\n\tfor(r=1;t;t>>=1,a=mul(a,a))if(t&1)r=mul(r,a);\n\treturn r;\n}\nconst int N=1e6+5,M=1<<12|5,L=12;\nconst i64 inf=1LL<<60;\nint n,m,f[M];\ni64 a[N],g,e[N],k;\nvector<i64>p;\nmap<vector<i64>,vector<i64>>ff;\ni64 dp[M][L],cp[M][L];\nvoid dfs(const vector<i64>&cur,i64 num,int subset,int pos){\n\tif(pos==cur.size()){f[subset]=1;return;}\n\tdfs(cur,num,subset,pos+1);\n\tif(num<=k/cur[pos])dfs(cur,num*cur[pos],subset|1<<pos,pos+1);\n}\nint main(){\n\tint i,j,s,l;\n\tscan(n,k);\n\tread(a+1,a+n+1),read(e+1,e+n+1);\n\tfor(i=1;i<=n;++i)g=__gcd(g,a[i]);\n\tfor(i=2;i64(i)*i<=g;++i)if(g%i==0){\n\t\twhile(g%i==0)g/=i;\n\t\tp.pb(i);\n\t}\n\tif(g>1)p.pb(g);\n\tm=p.size();\n\tfor(i=1;i<=n;++i){\n\t\tvector<i64>kk(m,1); \n\t\tfor(j=0;j<m;++j)while(a[i]%p[j]==0)a[i]/=p[j],kk[j]*=p[j];\n\t\tff[kk].pb(e[i]);\n\t}\n\tfor(i=0;i<1<<m;++i)for(j=0;j<=m;++j)dp[i][j]=inf;\n\tdp[0][0]=0;\n\tfor(auto &g:ff){\n\t\tsort(ALL(g.se));\n\t\tmemset(f,0,sizeof(int)*(1<<m));\n\t\tdfs(g.fi,1LL,0,0);\n\t\tfor(i=0;i<m;++i)for(j=0;j<1<<m;++j)if(~j>>i&1)f[j]+=f[j|1<<i];\n\t\tvector<int> op;\n\t\tfor(i=1;i<1<<m;++i)if(f[i]==1)op.pb(i);\n\t\tl=g.se.size();\n\t\tif(l>m)l=m;\n\t\tfor(s=0;s<l;++s){\n\t\t\tbool f=false;\n\t\t\tmemcpy(cp,dp,sizeof(dp[0])*(1<<m));\n\t\t\tfor(int t:op)for(i=0;i<1<<m;++i)for(j=0;j<m;++j)if(dp[i][j]!=inf)f|=chkmin(cp[i|t][j+1],dp[i][j]+g.se[s]);\n\t\t\tmemcpy(dp,cp,sizeof(cp[0])*(1<<m));\n\t\t\tif(!f)break;\n\t\t}\n\t}\n\ti64 res=inf;\n\tfor(i=0;i<=m;++i)if(dp[(1<<m)-1][i]!=inf)chkmin(res,dp[(1<<m)-1][i]*i); \n\tif(res==inf)puts(\"-1\");else cout<<res<<endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Professional layer.json",
    "editorial_link": "https://codeforces.com//blog/entry/64722",
    "editorial": "We supposed this as the author solution:Letâs find and factorize it. ,\r\nwhere -th prime number in factorization () and number of occurrences of\r\nthis prime. Itâs clear, that in our constraints, because . Obviously,\r\nthat in optimal answer is always best to divide set of our primes in\r\nsubsets and distribute these subsets between array numbers and divide\r\neach number by product of all primes (with powers) in corresponding\r\nsubset. Also clear, that we are interested in only vector of powers of\r\nprimes of , other primes in a factorization of we can ignore, but we\r\nneed to be cautious about costs, so, we can left the cheapest numbers\r\nwith the same prime-vector. After this compression we will left at most\r\nnumbers. We can get this estimation by this point: maximum numbers after\r\ncompression we can reach if all primes are small as possible and for all\r\n. Hence, we have at most possibilities and can easily brute all of them.\r\nAlso, after compression, letâs calculate vector - best numbers by cost\r\nto cover set of primes corresponding to . We can do it easily in .Now\r\nletâs fix a partition of our set of primes into subsets. Well known,\r\nthat the number of partitions is equal to , where -th Bell number. Now,\r\nwe want to update the current answer. We need to do it by value , where\r\nis number of subsets in the partition (we already know it) and is\r\nminimum cost to distribute our subsets between array numbers. Letâs\r\nconsider all indices for subset which we can match with this by\r\nconstraint \"divisor is at most k\". We will get the bipartite graph with\r\nweighted right part (part with indices) and our purpose is to find\r\nperfect matching with minimal cost of used vertices in the right part.\r\nWe can solve this problem with Kuhn algorithm greedily we can sort right\r\npart in not ascending order and do all iterations in this order. Itâs\r\ncorrect, because we can consider transversal matroid with elements in\r\nright part and apply greed Rado-Edmonds theorem. Now we need just to\r\nfigure out, that we can build this graph using precalced , because we\r\nare interested only in at most best indices for the particular vertex in\r\nthe left part. So, we will have graph with edges and size of the left\r\npart. Kuhn algorithm will be work in (even we do the algorithm in right\r\npart with size ) if we clear array carefully only after increasing of\r\nthe current matching. Summing up over all partitions of elements we will\r\nget operations.P. S. Solutions that were passed by participants during\r\nthe contest used same ideas about the compression. But instead of\r\nminimal matching we will use dynamic programming approach. Letâs\r\ndenote - minimal cost to correctly cover set of primes corresponding to\r\nusing exactly divisions. To calculate it letâs precalc (inversion of )\r\nmasks for which -th number of the array is one of best. Using this\r\nhelped data we can calculate our . For this, we can iterate over all\r\nnumbers and try to update all states where we can use our masks. It will\r\nbe work in and all algorithm will be work in\r\n",
    "hint": []
}