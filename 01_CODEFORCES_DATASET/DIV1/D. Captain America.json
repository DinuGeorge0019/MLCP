{"link": "https://codeforces.com//contest/704/problem/D", "problemId": "67580", "problem_idx": "D", "shortId": "704D", "contest_number": "704", "problem_submissions": {"D": [40927696, 40927622, 40927587, 40927467, 40927396, 19704142, 19710237, 19708323, 19774513, 19774457, 19774399, 19764110, 19708427, 19756062, 26821434, 22052930], "C": [19708702, 23913352, 19710963, 19714551, 19717256, 19728619, 19710982, 19720592, 22049772, 19704534], "B": [19698622, 19822826, 19698078, 19696251, 19698272, 19697250, 19698738, 19697542, 19699793, 19700128, 19700526, 19700174, 19702386, 19697314, 19708684, 19700116], "A": [19690324, 19692784, 19688619, 19690302, 19690344, 19691492, 19691120, 19689897, 19691217, 19692269, 19690729, 19691407, 19691187, 19689858, 19690147, 19691829, 19694517, 19693111, 19701512, 19690489], "E": [27277354, 20669015, 22073776, 22073733]}, "name": "D. Captain America", "statement": "Steve Rogers is fascinated with new vibranium shields S.H.I.E.L.D gave\r\nhim. They\u2019re all uncolored. There are shields in total, the -th shield\r\nis located at point of the coordinate plane. It\u2019s possible that two or\r\nmore shields share the same location.Steve wants to paint all these\r\nshields. He paints each shield in either red or blue. Painting a shield\r\nin red costs dollars while painting it in blue costs\r\ndollars.Additionally, there are constraints Steve wants to be satisfied.\r\nThe -th constraint is provided by three integers , and : If , then the\r\nabsolute difference between the number of red and blue shields on line\r\nshould not exceed . If , then the absolute difference between the number\r\nof red and blue shields on line should not exceed . Steve gave you the\r\ntask of finding the painting that satisfies all the condition and the\r\ntotal cost is minimum.\r\n", "solutions": ["#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <utility>\n\nusing namespace std;\n\n// usage:\n// MaxFlowDinic::init(n);\n// MaxFlowDinic::addEdge(0, 1, 100, 100); // for bidirectional edge\n// MaxFlowDinic::addEdge(1, 2, 100); // directional edge\n// result = MaxFlowDinic::solve(0, 2); // source -> sink\n// graph[i][edgeIndex].res -> residual\n//\n// in order to find out the minimum cut, use `l'.\n// if l[i] == 0, i is unreachable.\n\nstruct MaxFlowDinic {\n    typedef int cap_t;\n\n    struct Edge\n    {\n        int next;\n        int inv; /* inverse edge index */\n        cap_t res; /* residual */\n        cap_t save; /* save whatever you want. TODO: just remove if you don't need */\n    };\n\n    int n;\n    vector<vector<Edge>> graph;\n\n    vector<int> q, l, start;\n\n    void init(int _n) {\n        n = _n;\n        graph.resize(n);\n        for(int i = 0; i < n; i++) graph[i].clear();\n    }\n    void addNodes(int count) {\n        n += count;\n        graph.resize(n);\n    }\n\n    void addEdgeSave(int s, int e, cap_t cap, cap_t save) {\n        Edge forward = { e, (int)graph[e].size() + (s == e ? 1 : 0), cap, save};\n        Edge reverse = { s, (int)graph[s].size(), 0, -1};\n        graph[s].push_back(forward);\n        graph[e].push_back(reverse);\n    }\n\n    void addEdge(int s, int e, cap_t cap, cap_t caprev = 0) {\n        Edge forward = { e, (int)graph[e].size() + (s == e ? 1 : 0), cap, -1};\n        Edge reverse = { s, (int)graph[s].size(), caprev, -1};\n        graph[s].push_back(forward);\n        graph[e].push_back(reverse);\n    }\n\n    bool assignLevel(int source, int sink) {\n        int t = 0;\n        l.assign(n, 0);\n        l[source] = 1;\n        q[t++] = source;\n        for(int h = 0; h < t && !l[sink]; h++) {\n            int cur = q[h];\n            for (const auto &edge : graph[cur]) {\n                int next = edge.next;\n                if (l[next]) continue;\n                if (edge.res > 0) {\n                    l[next] = l[cur] + 1;\n                    q[t++] = next;\n                }\n            }\n        }\n        return l[sink] != 0;\n    }\n\n    cap_t blockFlow(int cur, int sink, cap_t currentFlow) {\n        if (cur == sink) return currentFlow;\n        for (auto &i = start[cur]; i < (int)graph[cur].size(); i++) {\n            int next = graph[cur][i].next;\n            if (graph[cur][i].res == 0 || l[next] != l[cur]+1)\n                continue;\n            if (cap_t res = blockFlow(next, sink, min(graph[cur][i].res, currentFlow))) {\n                int inv = graph[cur][i].inv;\n                graph[cur][i].res -= res;\n                graph[next][inv].res += res;\n                return res;\n            }\n        }\n        return 0;\n    }\n\n    cap_t solve(int source, int sink)\n    {\n        if (source == sink) {\n            // invalid case\n            return -1;\n        }\n        q.resize(n);\n        l.resize(n);\n        cap_t ans = 0;\n        while (assignLevel(source, sink)) {\n            start.assign(n, 0);\n            while (cap_t flow = blockFlow(source, sink, numeric_limits<cap_t>::max())) {\n                ans += flow;\n            }\n        }\n        return ans;\n    }\n};\n\nstruct MaxFlowEdgeDemand {\n    typedef MaxFlowDinic::cap_t cap_t;\n    MaxFlowDinic mf;\n\n    vector<cap_t> nodeSum;\n\n    void init(int _n) {\n        mf.init(_n + 2);\n        nodeSum.resize(_n + 2);\n    }\n\n    void addNodes(int count) {\n        mf.addNodes(count);\n        nodeSum.resize(mf.n + 2);\n    }\n\n    void addEdgeSave(int s, int e, cap_t demand, cap_t capacity, cap_t save) {\n        mf.addEdgeSave(s + 2, e + 2, capacity - demand, save);\n        nodeSum[s + 2] -= demand;\n        nodeSum[e + 2] += demand;\n    }\n\n    void addEdge(int s, int e, cap_t demand, cap_t capacity) {\n        mf.addEdge(s + 2, e + 2, capacity - demand);\n        nodeSum[s + 2] -= demand;\n        nodeSum[e + 2] += demand;\n    }\n\n    // -1 if it is impossible to satisfy demand\n    // return max flow.\n    cap_t solveFeasibility(int source, int sink) {\n        mf.addEdge(sink + 2, source + 2, numeric_limits<cap_t>::max());\n        cap_t saturation = 0;\n        for (int i = 2; i < (int)nodeSum.size(); i++) {\n            auto cap = nodeSum[i];\n            if (cap == 0) continue;\n            if (cap < 0) {\n                mf.addEdgeSave(i, 1, -cap, -cap);\n            } else if (cap > 0) {\n                mf.addEdgeSave(0, i, cap, cap);\n                saturation += cap;\n            }\n        }\n        cap_t result = mf.solve(0, 1);\n        if (result != saturation) {\n            return -1;\n        }\n        cap_t maxFlow = mf.solve(source + 2, sink + 2);\n        return maxFlow;\n    }\n};\n\n// maximize sum(selected profit) - sum(selected cost)\n// -> maximize sum(all profit) - sum(unselected profit) - sum(selected cost)\n// -> minimize sum(unselected profit) + sum(selected cost)\n// -> minimize sum(unselected profit) + sum(selected cost) + infinity * sum(selected project needs unselected project)\n// -> mincut on graph!\n// let A={unselected profit}, B={selected cost}.\n// Solution: connect profit projects to all dependent cost projects with infinity capacity. -> this is expensive,\n//        but anyway this forces all dependent cost projects of selected profit projects will be cut.\n// Solution improvement: no need to connect all. It just requires transitive path.\n// after connecting them, you need to cut profit or cut( = accept) cost\nstruct ProjectSelection {\n    typedef MaxFlowDinic::cap_t profit_t;\n    // profit can be negative if it induces costs\n    MaxFlowDinic mf;\n    int source, sink;\n\n    vector<profit_t> profits;\n\n    ProjectSelection(vector<profit_t> profits) : profits(move(profits)) {\n        int n = (int)profits.size();\n        mf.init(n + 2);\n        source = n;\n        sink = n + 1;\n        for (int i = 0; i < n; i++) {\n            auto p = profits[i];\n            if (p > 0) {\n                // profit!\n                mf.addEdge(source, i, p);\n            } else if (p < 0) {\n                // costly\n                mf.addEdge(i, sink, -p);\n            }\n        }\n    }\n\n    // \"a\" depends on \"b\". To do \"a\", you need \"b\" before.\n    void AddDependency(int a, int b) {\n        mf.addEdge(a, b, numeric_limits<MaxFlowDinic::cap_t>::max());\n    }\n\n    // return the best profit\n    //\n    // To get the actual selection,\n    // 1. get all selected profit projects (selected = not cut edges, so still reachable -> mf.l can be used)\n    // 2. find all dependencies by BFS\n    profit_t Solve() {\n        profit_t sum = 0;\n        for (int i = 0; i < (int)profits.size(); i++) {\n            auto p = profits[i];\n            if (p > 0) {\n                sum += p;\n            }\n        }\n        sum -= mf.solve(source, sink);\n        return sum;\n    }\n};\n\n\nint main() {\n    // CF366 D\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    int r, b;\n    scanf(\"%d%d\", &r, &b);\n    vector<pair<int, int>> points; points.reserve(n);\n    map<int, int> X, Y; // x -> count\n    map<int, int> Xi, Yi; // x -> count\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        points.emplace_back(x, y);\n        X[x]++;\n        Y[y]++;\n    }\n    vector<pair<int, int>> rangexy(X.size() + Y.size());\n    {\n\n        int i = 0;\n        for (auto kv : X) {\n            rangexy[i].second = kv.second;\n            Xi[kv.first] = i;\n            i++;\n        }\n        for (auto kv : Y) {\n            rangexy[i].second = kv.second;\n            Yi[kv.first] = i;\n            i++;\n        }\n    }\n    MaxFlowEdgeDemand mf;\n    int source = (int)(X.size() + Y.size());\n    int sink = (int)(X.size() + Y.size() + 1);\n    mf.init((int)(X.size() + Y.size() + 2));\n    for (int i = 0; i < n; i++) {\n        int xi = Xi[points[i].first];\n        int yi = Yi[points[i].second];\n        mf.addEdgeSave(xi, yi, 0, 1, i);\n    }\n    for (int i = 0; i < m; i++) {\n        int t, l, d;\n        scanf(\"%d%d%d\", &t, &l, &d);\n        if (t == 1) {\n            auto I = X.find(l);\n            if (I == X.end()) continue;\n            int cnt = I->second;\n            int lower = (-d + cnt); if (lower % 2) lower++; lower /= 2;\n            int upper = (d + cnt); if (upper % 2) upper--; upper /= 2;\n            rangexy[Xi[l]].first = max(rangexy[Xi[l]].first, lower);\n            rangexy[Xi[l]].second = min(rangexy[Xi[l]].second, upper);\n        } else if (t == 2) {\n            auto I = Y.find(l);\n            if (I == Y.end()) continue;\n            int cnt = I->second;\n            int lower = (-d + cnt); if (lower % 2) lower++; lower /= 2;\n            int upper = (d + cnt); if (upper % 2) upper--; upper /= 2;\n            rangexy[Yi[l]].first = max(rangexy[Yi[l]].first, lower);\n            rangexy[Yi[l]].second = min(rangexy[Yi[l]].second, upper);\n        }\n    }\n    for (int i = 0; i < (int)rangexy.size(); i++) {\n        if (rangexy[i].first > rangexy[i].second) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        if (i < (int)X.size()) {\n            mf.addEdge(source, i, rangexy[i].first, rangexy[i].second);\n        } else {\n            mf.addEdge(i, sink, rangexy[i].first, rangexy[i].second);\n        }\n    }\n\n    auto result = mf.solveFeasibility(source, sink);\n    if (result < 0) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    bool swapped = false;\n    if (r > b) {\n        swap(r, b);\n        swapped = true;\n    }\n\n    long long cost = (long long)r * n + (long long)(n-result) * (b-r);\n    printf(\"%lld\\n\", cost);\n    string ans(n, '?');\n    for (int i = 0; i < (int)X.size(); i++) {\n        for (const auto &edge : mf.mf.graph[i + 2]) {\n            if (edge.save >= 0) {\n                bool filled = (edge.res == 0);\n                ans[edge.save] = ((swapped == filled) ? 'b' : 'r');\n            }\n        }\n    }\n    printf(\"%s\\n\", ans.c_str());\n    return 0;\n}\n\n"], "input": "", "output": "", "tags": ["flows", "greedy"], "dificulty": "3100", "interactive": false}