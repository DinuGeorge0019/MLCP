{
    "link": "https://codeforces.com//contest/1336/problem/D",
    "problemId": "594569",
    "problem_idx": "D",
    "shortId": "1336D",
    "contest_number": "1336",
    "problem_submissions": {
        "D": [
            76886677,
            76883955,
            76872368,
            76882178,
            76894871,
            76894177,
            76885532,
            76907882,
            77033594,
            77091883,
            76900082,
            76884934,
            76874617
        ],
        "A": [
            76864054,
            76808839,
            76828187,
            76809546,
            76814169,
            76823336,
            76827670,
            76836840,
            76814633,
            76809091,
            76816264,
            76813939,
            76811729,
            76811390,
            76834705,
            76826600,
            76815368,
            76837049,
            76817310
        ],
        "B": [
            76860488,
            76819320,
            76814288,
            76825429,
            76828812,
            76838781,
            76838525,
            76843572,
            76826054,
            76817907,
            76825620,
            76826257,
            76821471,
            76823111,
            76831291,
            76821337,
            76838685,
            76839113,
            76827505
        ],
        "C": [
            76854725,
            76829511,
            76835542,
            76846764,
            76855809,
            76854630,
            76858132,
            76850152,
            76839221,
            76831744,
            76838549,
            76834558,
            76833263,
            76835970,
            76841416,
            76837215,
            76859411,
            76818388,
            76844588
        ],
        "E1": [
            76850288,
            76855475,
            76852735,
            76883081,
            76892755,
            76881482,
            76888504,
            76867895,
            76895876,
            76859814,
            76851085,
            76862051,
            77146034,
            76864099,
            76864337,
            76853452,
            150818764,
            150818693,
            76914981,
            76914599,
            76858346,
            76859234
        ],
        "E2": [
            76849352,
            85264213,
            76894287,
            77317433,
            76903834,
            77032081,
            227735667,
            77145907
        ],
        "F": [
            76895069,
            142907140,
            92908333,
            92907865,
            76904132,
            77029817,
            77028666,
            77028475,
            76902682,
            76902541
        ]
    },
    "name": "D. Yui and Mahjong Set",
    "statement": "Yui is a girl who enjoys playing Mahjong. She has a mysterious set which\r\nconsists of tiles (this set can be empty). Each tile has an integer\r\nvalue between 1 and n, and in the set have the same value. So the set\r\ncan contain at most n^2 tiles.You want to figure out which values are on\r\nthe tiles. But Yui is shy, she prefers to play a guessing game with\r\nyou.Let’s call a set consisting of tiles if their values are the same.\r\nFor example,\r\n{2,\r\n,2,\r\n,2\r\n} is a triplet, but\r\n{2,\r\n,3,\r\n,3\r\n} is not.Let’s call a set consisting of tiles if their values are\r\nconsecutive integers. For example,\r\n{2,\r\n,3,\r\n,4\r\n} is a straight, but\r\n{1,\r\n,3,\r\n,5\r\n} is not.At first, Yui gives you the number of triplet subsets and\r\nstraight subsets of the initial set respectively. After that, you can\r\ninsert a tile with an integer value between 1 and n into the set . Every\r\ntime you insert a tile, you will get the number of triplet subsets and\r\nstraight subsets of the current set as well.Note that two tiles with the\r\nsame value are treated different. In other words, in the set\r\n{1,\r\n,1,\r\n,2,\r\n,2,\r\n,3\r\n} you can find 4 subsets\r\n{1,\r\n,2,\r\n,3\r\n}.Try to guess the number of tiles in the initial set with value i for\r\nall integers i from 1 to n.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\nconst int maxN = 123;\nconst int P = 998244353;\n\nint p[123], q[123];\nint n;\n\nvector<vector<int>> pat;\n\nvoid genpattern(int d)\n{\n\tif (d == n)\n\t{\n\t\tpat.push_back(vector<int>(p, p + n));\n\t}\n\telse\n\t{\n\t\tfor (int x = 0; x <= n; x++)\n\t\t{\n\t\t\tp[d] = x;\n\t\t\tgenpattern(d + 1);\n\t\t}\n\t}\n}\npair<int, int> eval(vector<int> q)\n{\n\tint s = 0, t = 0;\n\tfor (int i = 0; i < n - 2; i++)\n\t\ts += q[i] * q[i + 1] * q[i + 2];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tt += q[i] * (q[i] - 1) * (q[i] - 2) / 6;\n\t}\n\treturn {s, t};\n}\n/*void dfs(int d)\n{\n\tif (d == n)\n\t{\n\t\tvector<int> a;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tq[i] = p[i];\n\t\tauto eval = [&]() {\n\t\t\ta.push_back(s);\n\t\t\ta.push_back(t);\n\t\t};\n\t\teval();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tq[i] += 1;\n\t\t\teval();\n\t\t}\n\n\t\tif (s.count(a))\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tprintf(\"%d \", p[i]);\n\t\t\tputs(\"\");\n\t\t\tfor (auto x : s[a])\n\t\t\t\tprintf(\"%d \", x);\n\t\t\tputs(\"\");\n\t\t\ta.clear();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tq[i] = p[i];\n\n\t\t\tprintf(\"%d \", p[i]);\n\t\t\tputs(\"\");\n\t\t}\n\t\ts[a] = vector<int>(p, p + n);\n\t}\n\telse\n\t{\n\t\tfor (int x = 0; x <= 2; x++)\n\t\t{\n\t\t\tp[d] = x;\n\t\t\tdfs(d + 1);\n\t\t}\n\t}\n}*/\n\nint add[maxN];\nvector<int> Tp;\nvoid solvesmall()\n{\n\tgenpattern(0);\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tint s, t;\n\t\tscanf(\"%d%d\", &t, &s);\n\t\t/*auto w = eval(Tp);\n\t\ts = w.first, t = w.second;*/\n\t\tvector<vector<int>> npat;\n\t\tfor (auto q : pat)\n\t\t{\n\t\t\tauto ss = eval(q);\n\t\t\tif (eval(q) == make_pair(s, t))\n\t\t\t{\n\t\t\t\tnpat.push_back(q);\n\t\t\t}\n\t\t}\n\t\tpat = npat;\n\t\tassert(!pat.empty());\n\t\tif (pat.size() == 1)\n\t\t{\n\t\t\tprintf(\"!\");\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tprintf(\" %d\", pat[0][i] - add[i]);\n\t\t\tprintf(\"\\n\");\n\t\t\tfflush(stdout);\n\t\t\treturn;\n\t\t}\n\t\tint maxd = -1, maxw = 1 << 30;\n\t\tfor (int d = 0; d < n; d++)\n\t\t{\n\t\t\tmap<pair<int, int>, int> cnt;\n\t\t\tfor (auto q : pat)\n\t\t\t{\n\t\t\t\tauto p = q;\n\t\t\t\tp[d] += 1;\n\t\t\t\tauto r = eval(p);\n\t\t\t\tcnt[r] += 1;\n\t\t\t}\n\t\t\tint maxcls = 0;\n\t\t\tfor (auto q : cnt)\n\t\t\t\tmaxcls = max(maxcls, q.second);\n\t\t\tif (maxcls <= maxw)\n\t\t\t{\n\t\t\t\tmaxw = maxcls;\n\t\t\t\tmaxd = d;\n\t\t\t}\n\t\t}\n\t\tadd[maxd]++;\n\t\tprintf(\"+ %d\\n\", maxd + 1);\n\t\tTp[maxd] += 1;\n\t\tfor (auto &p : pat)\n\t\t\tp[maxd]++;\n\t\tfflush(stdout);\n\t}\n}\nint fs[maxN], ft[maxN], c[maxN], d[maxN];\n\nbool check(int *d)\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (d[i] < 0 || d[i] > n)\n\t\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tauto w = eval(vector<int>(d + 1, d + n + 1));\n\t\t//printf(\"cc %d %d %d %d\\n\", w.first, w.second, fs[i], ft[i]);\n\t\tif (w != make_pair(fs[i], ft[i]))\n\t\t\treturn 0;\n\t\td[i + 1]++;\n\t}\n\treturn 1;\n}\n\nvoid solvelarge()\n{\n\tauto w = eval(Tp);\n\t/*fs[0] = w.first;\n\tft[0] = w.second;*/\n\tscanf(\"%d%d\", ft + 0, fs + 0);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tprintf(\"+ %d\\n\", i);\n\t\tTp[i - 1]++;\n\t\tfflush(stdout);\n\t\tauto w = eval(Tp);\n\t\tscanf(\"%d%d\", ft + i, fs + i);\n\t\t/*fs[i] = w.first;\n\t\tft[i] = w.second;*/\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint pt = ft[i] - ft[i - 1];\n\t\tif (pt == 0)\n\t\t{\n\t\t\tc[i] = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int x = 1; x <= n; x++)\n\t\t\t\tif (x * (x + 1) / 2 == pt)\n\t\t\t\t\tc[i] = x + 1;\n\t\t}\n\t}\n\tfor (int p1 = (c[n] == -1) ? 0 : c[n]; p1 <= ((c[n] == -1) ? 1 : c[n]); p1++)\n\t\tfor (int p2 = (c[n - 1] == -1) ? 0 : c[n - 1]; p2 <= ((c[n - 1] == -1) ? 1 : c[n - 1]); p2++)\n\t\t\tfor (int p3 = ((c[n - 2] == -1) ? 0 : c[n - 2]); p3 <= ((c[n - 2] == -1) ? 1 : c[n - 2]); p3++)\n\t\t\t{\n\t\t\t\td[n + 1] = 0;\n\t\t\t\td[n] = p1;\n\t\t\t\td[n - 1] = p2;\n\t\t\t\td[n - 2] = p3;\n\t\t\t\t//printf(\"gg %d %d %d %d\\n\", p1, p2, p3, c[n - 2]);\n\t\t\t\tbool valid = 1;\n\t\t\t\tfor (int i = n - 1; i >= 3; i--)\n\t\t\t\t{\n\t\t\t\t\tint ps = fs[i] - fs[i - 1];\n\t\t\t\t\t// (d[i - 2] + 1) * (d[i - 1] + 1) + (d[i - 1] + 1) * d[i + 1] + d[i + 1] * d[i + 2];\n\t\t\t\t\tint w = (d[i - 1] + 1) * d[i + 1] + d[i + 1] * d[i + 2];\n\t\t\t\t\t//printf(\"%d %d %d\\n\", ps, w, (d[i - 1] + 1));\n\t\t\t\t\tif (ps <= w || (ps - w) % (d[i - 1] + 1) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\td[i - 2] = (ps - w) / (d[i - 1] + 1) - 1;\n\t\t\t\t\t//printf(\"st %d %d\\n\", i - 2, d[i - 2]);\n\t\t\t\t}\n\t\t\t\tif (valid && check(d))\n\t\t\t\t{\n\t\t\t\t\tprintf(\"!\");\n\t\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\" %d\", d[i] - 1);\n\t\t\t\t\t}\n\t\t\t\t\tputs(\"\");\n\t\t\t\t\tfflush(stdout);\n\t\t\t\t}\n\t\t\t}\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tTp = vector<int>(n, 0);\n\tif (n <= 5)\n\t{\n\t\tsolvesmall();\n\t}\n\telse\n\t{\n\t\tsolvelarge();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Yui and Mahjong Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/76099",
    "editorial": "Suppose equals to the number of tiles in the current set with value\r\n(before making a query).If you insert a tile with value : The delta of\r\ntriplet subsets is . Once youâre sure that holds, you can determine the\r\nexact value of . The delta of straight subsets is . Once youâve known\r\nthe values of and youâre sure that , you can determine the exact value\r\nof . Letâs insert tiles with following values in order: , , , , , , .We\r\ncan easily get by the delta of triplet subsets since we insert tiles\r\nwith value twice.Consider the delta of straight subsets when you insert\r\nthe tile with value . It equals to for the first time and for the second\r\ntime. Use subtraction to get , then use division to get . (The divisor\r\nis , which is non-zero)Finally, let do the following for each from to .\r\nWeâve known the values of . Since weâve inserted a tile with value\r\nbefore inserting , we can use division to get by the delta of straight\r\nsubsets and avoid dividing zero.\r\n",
    "hint": []
}