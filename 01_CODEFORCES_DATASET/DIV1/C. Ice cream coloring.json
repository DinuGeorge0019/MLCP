{
    "link": "https://codeforces.com//contest/804/problem/C",
    "problemId": "105174",
    "problem_idx": "C",
    "shortId": "804C",
    "contest_number": "804",
    "problem_submissions": {
        "D": [
            26864569,
            26864084,
            26864065,
            26863844,
            26859532,
            26855737,
            26853547,
            26853205,
            26854566,
            26856630,
            26853214,
            26855855,
            26861591,
            26863648,
            26855151,
            26854613,
            26864015,
            26856289,
            26858468,
            26856391
        ],
        "C": [
            26847789,
            26844906,
            26857930,
            26847099,
            26856657,
            26848089,
            26857400,
            26856222,
            26845185,
            26848695,
            26846499,
            26847477,
            26843068,
            26846575,
            26859352,
            26846716,
            26860420,
            26846219,
            26852629
        ],
        "B": [
            26841209,
            26838692,
            26840551,
            26839159,
            26839206,
            26840437,
            26840273,
            26854727,
            26841332,
            26842906,
            26840147,
            26841623,
            26839518,
            26840190,
            26840304,
            26839516,
            26840017,
            26847973,
            26839966
        ],
        "A": [
            26838410,
            26837453,
            26837406,
            26837277,
            26841198,
            26837228,
            26837723,
            26837298,
            26837762,
            26837644,
            26837931,
            26837280,
            26837588,
            26838739,
            26837615,
            26837337,
            26846921,
            26837692
        ],
        "E": [
            26859757,
            26861113,
            26864419,
            26864227,
            26864109,
            26864035,
            26863863,
            26860566,
            26862404,
            26859605,
            26854745,
            26861397,
            26884422,
            26865231,
            26853306,
            26856744,
            26859172
        ]
    },
    "name": "C. Ice cream coloring",
    "statement": "Isart and Modsart were trying to solve an interesting problem when\r\nsuddenly Kasra arrived. Breathless, he asked: \"Can you solve a problem\r\nI\u2019m stuck at all day?\"We have a tree with vertices and types of ice\r\ncream numerated from to . Each vertex has a set of types of ice cream.\r\nVertices which have the -th () type of ice cream form a connected\r\nsubgraph. We build a new graph with vertices. We put an edge between the\r\n-th and the -th (, ) vertices in if and only if there exists a vertex in\r\nthat has both the -th and the -th types of ice cream in its set. The\r\nproblem is to paint the vertices of with minimum possible number of\r\ncolors in a way that no adjacent vertices have the same color.Please\r\nnote that we consider that empty set of vertices form a connected\r\nsubgraph in this problem.As usual, Modsart don\u2019t like to abandon the\r\nprevious problem, so Isart wants you to solve the new problem.\r\n",
    "solutions": [
        "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n#include <algorithm>\n\ntemplate <typename T>\nvoid updateMin(T& oldValue, const T& newValue) {\n\tif (newValue < oldValue) {\n\t\toldValue = newValue;\n\t}\n}\n\ntemplate <typename T>\nvoid updateMax(T& oldValue, const T& newValue) {\n\tif (oldValue < newValue) {\n\t\toldValue = newValue;\n\t}\n}\n\n#include <set>\n\nusing namespace std;\n\nclass TaskC {\npublic:\n\tvector<vector<int>> g;\n\tvector<vector<int>> colors;\n\n\tvector<int> anses;\n\n\tset<int> can_use;\n\n\tvoid dfs(int v, int p) {\n\t\tfor (int c: colors[v]) {\n\t\t\tif (anses[c] != -1) {\n\t\t\t\tcan_use.erase(anses[c]);\n\t\t\t}\n\t\t}\n\t\tfor (int c: colors[v]) {\n\t\t\tif (anses[c] == -1) {\n\t\t\t\tanses[c] = *can_use.begin();\n\t\t\t\tcan_use.erase(can_use.begin());\n\t\t\t}\n\t\t}\n\n\t\tfor (int c: colors[v]) {\n\t\t\tcan_use.insert(anses[c]);\n\t\t}\n\n\t\tfor (int to: g[v]) {\n\t\t\tif (p == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(to, v);\n\t\t}\n\t}\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, m;\n\t\tin >> n >> m;\n\n\t\tint ans = 1;\n\t\tg.resize(n);\n\t\tcolors.resize(n);\n\t\tfor (int i: range(n)) {\n\t\t\tint c;\n\t\t\tin >> c;\n\t\t\tupdateMax(ans, c);\n\t\t\tcolors[i].resize(c);\n\t\t\tfor (int j: range(c)) {\n\t\t\t\tin >> colors[i][j];\n\t\t\t\t--colors[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i: range(n - 1)) {\n\t\t\tint a, b;\n\t\t\tin >> a >> b;\n\t\t\t--a, --b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tout << ans << \"\\n\";\n\t\tanses.resize(m, -1);\n\t\tfor (int i: range(ans)) {\n\t\t\tcan_use.insert(i);\n\t\t}\n\n\t\tdfs(0, 0);\n\n\t\tfor (int i: range(m)) {\n\t\t\tout << max(0, anses[i]) + 1 << \" \";\n\t\t}\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskC solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Ice cream coloring.json",
    "editorial_link": "https://codeforces.com/blog/entry/51846",
    "editorial": "If the answer is 2, other wise l.To prove this phrase, assume the answer\r\nis (), consider all of multiples of from to as . If , is also a correct\r\nanswer, otherwise numbers from to make at least even number, and for\r\neach multiple from to as , or is even, so 2 is also a correct\r\nanswer.Bounce: Find the maximum number, occurs maximum number of times\r\nin the segment.\r\n"
}