{
    "link": "https://codeforces.com//contest/1580/problem/B",
    "problemId": "1124755",
    "problem_idx": "B",
    "shortId": "1580B",
    "contest_number": "1580",
    "problem_submissions": {
        "B": [
            130368546,
            130343157,
            130344628,
            130363173,
            130349401,
            130355243,
            130367468,
            130348461,
            130361528,
            130349821,
            130353521,
            130358877,
            130349956,
            130352430,
            130351206,
            130360978,
            130375295,
            130370586,
            130394237,
            130361703
        ],
        "F": [
            130365168,
            131645253,
            131635746,
            130511674,
            130411823,
            130434722,
            130858441,
            130432452
        ],
        "D": [
            130353694,
            130351879,
            130354504,
            130348465,
            130361242,
            130356218,
            130400584,
            130360744,
            130356043,
            130858484,
            130362840,
            130366863,
            130368106,
            130352099,
            130366694,
            130365720,
            130365962,
            130368047,
            130360831,
            130353993,
            130370294
        ],
        "C": [
            130347074,
            130348749,
            130348466,
            130344529,
            130355623,
            130348660,
            130349751,
            130374035,
            130353918,
            130350011,
            130356865,
            130358625,
            130355024,
            130348708,
            130393503,
            130361958,
            130360836,
            130360159,
            130358052,
            130357895,
            130349443,
            130349567
        ],
        "A": [
            130339939,
            130502005,
            130339930,
            130348093,
            130341897,
            130340621,
            130340244,
            130356449,
            130343417,
            130342143,
            130341207,
            130340481,
            130341559,
            130340530,
            130339691,
            130340905,
            130340089,
            130340579,
            130352882
        ],
        "E": [
            130370647,
            130421659
        ]
    },
    "name": "B. Mathematics Curriculum",
    "statement": "Let c_1, c_2,\r\nldots, c_n be a permutation of integers 1, 2,\r\nldots, n. Consider all subsegments of this permutation containing an\r\ninteger x. Given an integer m, we call the integer x if there are\r\nexactly m different values of maximum on these subsegments.Cirno is\r\nstudying mathematics, and the teacher asks her to count the number of\r\npermutations of length n with exactly k numbers.Unfortunately, Cirno\r\nisn\u2019t good at mathematics, and she can\u2019t answer this question.\r\nTherefore, she asks you for help.Since the answer may be very big, you\r\nonly need to tell her the number of permutations modulo p.A permutation\r\nis an array consisting of n distinct integers from 1 to n in arbitrary\r\norder. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a\r\npermutation (2 appears twice in the array) and [1,3,4] is also not a\r\npermutation (n=3 but there is 4 in the array).A sequence a is a\r\nsubsegment of a sequence b if a can be obtained from b by deletion of\r\nseveral (possibly, zero or all) elements from the beginning and several\r\n(possibly, zero or all) elements from the end.\r\n",
    "solutions": [
        "//n^5 for 100. What a nice problem.\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, k, p;\nint dp[105][105], ndp[105][105];\nint fac[105], comb[105][105];\n\nint main()\n{\n\tscanf(\"%d%d%d%d\", &n, &m, &k, &p);\n\tif(m + k - 1 > n) {\n\t\tprintf(\"0\\n\"); return 0;\n\t}\n\tfac[0] = 1;\n\trep1(i, 100) fac[i] = 1LL * fac[i - 1] * i % p;\n\tcomb[0][0] = 1;\n\trep1(i, 100) {\n\t\tcomb[i][0] = 1;\n\t\trep1(j, i) comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % p;\n\t}\n\t\n\tdp[0][0] = 1;\n\trep1(i, n) dp[1][i] = fac[i];\n\tfor(int i = m - 1; i >= 1; i --) {\n\t\tmemset(ndp, 0, sizeof(ndp));\n\t\tint maxn = n - i + 1, maxk = min(maxn, k);\n\t\tndp[0][0] = 1;\n\t\tfor(int u0 = 0; u0 <= maxk; u0 ++) rep1(v0, maxn) for(int u1 = 0; u1 <= u0; u1 ++) rep(v1, v0)\n\t\tndp[u0][v0] = (ndp[u0][v0] + 1ULL * dp[u1][v1] * dp[u0 - u1][v0 - v1 - 1] % p * comb[v0 - 1][v1]) % p;\n\t\tmemcpy(dp, ndp, sizeof(dp));\n\t}\n\tprintf(\"%d\\n\", dp[k][n]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "dp",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Mathematics Curriculum.json",
    "editorial_link": "https://codeforces.com//blog/entry/95477",
    "editorial": "Define the dp\nstate as the number of the permutaion length of with exactly such\nnumbers that all the subsegments containing them have exactly different\nmaxima in total. We enumerate the position of the bigest number in the\npermutaion. We call the position is . The numbers before and after are\nindependent. Then we transform the statement to and . We also have to\ndistribute the numbers to two parts, so the dp transformation is: In\naddition, the answer of the problem is . Actually, the dp proccess is\njust like a cartesian tree. The time complexity is , space complexity is\n. However, it\u00e2\u0080\u0099s enough to pass the tests. solution\n"
}