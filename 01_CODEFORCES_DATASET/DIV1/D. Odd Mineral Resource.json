{
    "link": "https://codeforces.com//contest/1479/problem/D",
    "problemId": "889629",
    "problem_idx": "D",
    "shortId": "1479D",
    "contest_number": "1479",
    "problem_submissions": {
        "D": [
            106806356,
            106798804,
            106791682,
            106791766,
            106783633,
            106814882,
            106806404,
            106823371,
            106808799,
            106822218,
            106817839,
            106848882,
            106812415,
            106835076,
            106827553,
            106802594,
            106816382,
            106815777,
            106820515,
            106838550,
            106850875,
            106833526
        ],
        "C": [
            106782305,
            106781616,
            106813281,
            106777792,
            106806652,
            106785851,
            106790598,
            106804329,
            106788311,
            106797179,
            106801693,
            106797158,
            106799023,
            106802871,
            106833768,
            106794280,
            106835769,
            106791359,
            106812286,
            106805528
        ],
        "B2": [
            106767251,
            106763833,
            106764524,
            106766365,
            106766872,
            106772583,
            106777899,
            106776623,
            106772714,
            106777329,
            106781346,
            106839134,
            106782598,
            106789550,
            106774779,
            106781374,
            106779953,
            106776541,
            106784819,
            106807842
        ],
        "B1": [
            106761871,
            106761547,
            106772762,
            106765327,
            106765110,
            106769139,
            106770176,
            106777978,
            106783437,
            106765790,
            106777195,
            106759777,
            106771397,
            106771604,
            106765950,
            106772183,
            106778477,
            106775679,
            106771753,
            106783453
        ],
        "A": [
            106755900,
            106753726,
            106756482,
            106751012,
            106869291,
            106756412,
            106753230,
            106749820,
            106752580,
            106752067,
            106756325,
            106758074,
            106749882,
            106753072,
            106759686,
            106753472,
            106830245,
            106764145,
            106862156,
            106753714,
            106755663
        ],
        "E": [
            106862710,
            106861209,
            106848127,
            128939200,
            106847859,
            106846880,
            112187125
        ]
    },
    "name": "D. Odd Mineral Resource",
    "statement": "In Homer\u2019s country, there are n cities numbered 1 to n and they form a\r\ntree. That is, there are (n-1) undirected roads between these n cities\r\nand every two cities can reach each other through these roads. Homer\u2019s\r\ncountry is an industrial country, and each of the n cities in it\r\ncontains some mineral resource. The mineral resource of city i is\r\nlabeled a_i. Homer is given the plans of the country in the following q\r\nyears. The plan of the i-th year is described by four parameters u_i,\r\nv_i, l_i and r_i, and he is asked to find any mineral resource c_i such\r\nthat the following two conditions hold: mineral resource c_i appears an\r\nnumber of times between city u_i and city v_i; and l_i\r\nleq c_i\r\nleq r_i. As the best friend of Homer, he asks you for help. For every\r\nplan, find any such mineral resource c_i, or tell him that there doesn\u2019t\r\nexist one.\r\n",
    "solutions": [
        "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n// Actual solution is at the bottom\n\n#include <algorithm>\n#include <array>\n#include <chrono>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef int64_t int64;\ntypedef uint64_t uint64;\ntypedef pair<int, int> ii;\n\ntypedef vector < vector<int> > graph;\ntypedef vector<int>::const_iterator const_graph_iter;\n\nclass DOddMineralResource {\n public:\n  int n;\n  vector<int> a;\n  graph adj;\n\n  vector<int> lca_h, lca_dfs_list, lca_first, lca_tree;\n  vector<char> lca_dfs_used;\n  vector<int> tleft;\n  vector<int> tright;\n  vector<uint64> thash;\n\n  uint64 mod1;\n  uint64 mod2;\n  uint64 base1;\n  uint64 base2;\n  vector<uint64> pow1;\n  vector<uint64> pow2;\n  vector<int> rootFor;\n\n  bool prime(uint64 x) {\n    for (uint64 p = 2; p * p <= x; ++p) if (x % p == 0) return false;\n    return true;\n  }\n\n  DOddMineralResource() {\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    mod1 = uniform_int_distribution((int) 9e8, (int) 1e9)(rng);\n    while (!prime(mod1)) ++mod1;\n    base1 = uniform_int_distribution((int) 3137, (int) mod1 - 3137)(rng);\n    mod2 = uniform_int_distribution((int) 9e8, (int) 1e9)(rng);\n    while (!prime(mod2)) ++mod2;\n    base2 = uniform_int_distribution((int) 3137, (int) mod2 - 3137)(rng);\n    pow1.resize((int) 3e5 + 10);\n    pow1[0] = 1;\n    pow2.resize((int) 3e5 + 10);\n    pow2[0] = 1;\n    for (int i = 1; i < pow1.size(); ++i) {\n      pow1[i] = base1 * pow1[i - 1] % mod1;\n      pow2[i] = base2 * pow2[i - 1] % mod2;\n    }\n  }\n\n  void lca_dfs (const graph & g, int v, int h = 1)\n  {\n    lca_dfs_used[v] = true;\n    lca_h[v] = h;\n    lca_dfs_list.push_back (v);\n    for (const_graph_iter i = g[v].begin(); i != g[v].end(); ++i)\n      if (!lca_dfs_used[*i])\n      {\n        lca_dfs (g, *i, h+1);\n        lca_dfs_list.push_back (v);\n      }\n  }\n\n  void lca_build_tree (int i, int l, int r)\n  {\n    if (l == r)\n      lca_tree[i] = lca_dfs_list[l];\n    else\n    {\n      int m = (l + r) >> 1;\n      lca_build_tree (i+i, l, m);\n      lca_build_tree (i+i+1, m+1, r);\n      if (lca_h[lca_tree[i+i]] < lca_h[lca_tree[i+i+1]])\n        lca_tree[i] = lca_tree[i+i];\n      else\n        lca_tree[i] = lca_tree[i+i+1];\n    }\n  }\n\n  void lca_prepare (const graph & g, int root)\n  {\n    int n = (int) g.size();\n    lca_h.resize (n);\n    lca_dfs_list.reserve (n*2);\n    lca_dfs_used.assign (n, 0);\n\n    lca_dfs (g, root);\n\n    int m = (int) lca_dfs_list.size();\n    lca_tree.assign (lca_dfs_list.size() * 4 + 1, -1);\n    lca_build_tree (1, 0, m-1);\n\n    lca_first.assign (n, -1);\n    for (int i = 0; i < m; ++i)\n    {\n      int v = lca_dfs_list[i];\n      if (lca_first[v] == -1)\n        lca_first[v] = i;\n    }\n  }\n\n  int lca_tree_min (int i, int sl, int sr, int l, int r)\n  {\n    if (sl == l && sr == r)\n      return lca_tree[i];\n    int sm = (sl + sr) >> 1;\n    if (r <= sm)\n      return lca_tree_min (i+i, sl, sm, l, r);\n    if (l > sm)\n      return lca_tree_min (i+i+1, sm+1, sr, l, r);\n    int ans1 = lca_tree_min (i+i, sl, sm, l, sm);\n    int ans2 = lca_tree_min (i+i+1, sm+1, sr, sm+1, r);\n    return lca_h[ans1] < lca_h[ans2] ? ans1 : ans2;\n  }\n\n  int lca (int a, int b)\n  {\n    int left = lca_first[a],\n        right = lca_first[b];\n    if (left > right)  swap (left, right);\n    return lca_tree_min (1, 0, (int)lca_dfs_list.size()-1, left, right);\n  }\n\n  int initTree(int left, int right) {\n    int at = tleft.size();\n    tleft.push_back(-1);\n    tright.push_back(-1);\n    thash.push_back(0);\n    if (left == right) {\n    } else {\n      int mid = (left + right) / 2;\n      tleft[at] = initTree(left, mid);\n      tright[at] = initTree(mid + 1, right);\n    }\n    return at;\n  }\n\n  uint64 mergeHashes(uint64 hleft, uint64 hright, int leftSize) {\n    uint64 h1 = ((hleft >> 32) + (hright >> 32) * pow1[leftSize]) % mod1;\n    uint64 h2 = ((hleft & (((uint64) 1 << 32) - 1)) + (hright & (((uint64) 1 << 32) - 1)) * pow2[leftSize]) % mod2;\n    return (h1 << 32) + h2;\n  }\n\n  int updateTree(int root, int left, int right, int updAt) {\n    int at = tleft.size();\n    tleft.push_back(tleft[root]);\n    tright.push_back(tright[root]);\n    thash.push_back(0);\n    if (left == right) {\n      assert(left == updAt);\n      uint64 one = (((uint64) 1) << 32) + 1;\n      if (thash[root] == 0) {\n        thash[at] = one;\n      } else {\n        assert(thash[root] == one);\n        thash[at] = 0;\n      }\n    } else {\n      int mid = (left + right) / 2;\n      if (updAt <= mid) {\n        tleft[at] = updateTree(tleft[root], left, mid, updAt);\n      } else {\n        tright[at] = updateTree(tright[root], mid + 1, right, updAt);\n      }\n      thash[at] = mergeHashes(thash[tleft[at]], thash[tright[at]], mid - left + 1);\n    }\n    return at;\n  }\n\n  void walk(int at, int skip, int treeRoot) {\n    treeRoot = updateTree(treeRoot, 0, n - 1, a[at]);\n    rootFor[at] = treeRoot;\n    for (int v : adj[at]) {\n      if (v == skip) continue;\n      walk(v, at, treeRoot);\n    }\n  }\n\n  int findDiff(int rootU, int rootV, int left, int right, int needLeft, int needRight) {\n    if (needLeft > needRight) return -1;\n    if (left == needLeft && right == needRight) {\n      if (thash[rootU] == thash[rootV]) {\n        return -1;\n      }\n      if (left == right) {\n        return left;\n      }\n    }\n    int mid = (left + right) / 2;\n    int c = findDiff(tleft[rootU], tleft[rootV], left, mid, needLeft, min(needRight, mid));\n    if (c >= 0) return c;\n    return findDiff(tright[rootU], tright[rootV], mid + 1, right, max(mid + 1, needLeft), needRight);\n  }\n\n  void solveOne() {\n    int q;\n    cin >> n >> q;\n    a = vector<int>(n);\n    for (auto& x : a) {\n      cin >> x;\n      --x;\n    }\n    adj = vector<vector<int>>(n);\n    for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      --u; --v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    int root = 0;\n    lca_prepare(adj, root);\n    tleft.clear();\n    tright.clear();\n    thash.clear();\n    int treeRoot = initTree(0, n - 1);\n    rootFor = vector<int>(n);\n    walk(root, -1, treeRoot);\n    for (int qi = 0; qi < q; ++qi) {\n      int u, v, l, r;\n      cin >> u >> v >> l >> r;\n      --u; --v; --l; --r;\n      int w = lca(u, v);\n      int rootU = rootFor[u];\n      int rootV = rootFor[v];\n      rootU = updateTree(rootU, 0, n - 1, a[w]);\n      int c = findDiff(rootU, rootV, 0, n - 1, l, r);\n      if (c >= 0) ++c;\n      cout << c << \"\\n\";\n    }\n  }\n\n  void solve() {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne();\n    }\n  }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    DOddMineralResource solver;\n\n\n    solver.solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "data structures",
        "probabilities",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Odd Mineral Resource.json",
    "editorial_link": "https://codeforces.com//blog/entry/87598",
    "editorial": "Let denote the number of cities between city and city , whose mineral\r\nresource is . We restate the problem that for each query , find an\r\ninteger such that and .We give a randomized algorithm with success\r\nprobability extremely high. For every kind of mineral resources , we\r\nassign a random variable to it. Those random variables are independent\r\nand identically uniformly distributed from . For every city , we assign\r\nits weight to be . For every query , Let be the bitwise XOR of all\r\nweights of all cities between city and city , whose mineral resources\r\nare in . We claim that , which means that if a suitable does not exist\r\nthen for certainty, and , which means that if a suitable does exist then\r\nwith high probability. Let\u00e2\u0080\u0099s consider the reverse that , which implies\r\nwith high probability no suitable mineral resource exists if , and ,\r\nwhich implies with certainty at least one suitable mineral resource\r\nexists. According to the above discussion, our strategy is to report no\r\nsolution if , and to find a () such that if . Our strategy will succeed\r\nwith probability . Now consider there are queries. Let denote the event\r\nthat the -th query succeeds. The -th query will succeed with probability\r\n(however, they may not be independent). Then we have which means all\r\nqueries succeed simultaneously with probability at least if , which is\r\nhigh enough under constraints of the problem.To this end, we shall\r\ncompute and find a () such that . This can be solved by consistent\r\nsegment trees. Let\u00e2\u0080\u0099s root the tree (by any vertex, say vertex ). For\r\nevery vertex , we maintain a (consistent) segment tree that for each\r\ninterval computes . Let be the father of vertex , and be the least\r\ncommon ancestor of vertex and vertex . Then For more details, please\r\naccording to SPOJ COT. Therefore, we have solved this problem with high\r\nenough probability in time and space.\r\n"
}