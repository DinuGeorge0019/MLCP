{
    "link": "https://codeforces.com//contest/790/problem/C",
    "problemId": "98951",
    "problem_idx": "C",
    "shortId": "790C",
    "contest_number": "790",
    "problem_submissions": {
        "D": [
            25675131,
            25621791,
            25620770,
            25622633,
            25623312,
            25623816,
            25680670,
            25648868
        ],
        "E": [
            25623895,
            26123540,
            26123499,
            26123493,
            26123456,
            26123432,
            26123251,
            25617517
        ],
        "C": [
            25613244,
            25614979,
            25616936,
            25615762,
            25617856,
            25618954,
            25661266,
            25614888,
            25615074,
            25614005,
            25609588,
            25614426,
            25615773,
            25615586,
            25615794,
            25615992,
            25615935,
            25616033
        ],
        "B": [
            25609297,
            25610960,
            25614995,
            25612479,
            25611945,
            25614279,
            25608753,
            25610247,
            25611326,
            25609739,
            25611787,
            25609929,
            25612272,
            25613816,
            25610322,
            25610272,
            25611239,
            25970156,
            25970140,
            25970114,
            25970098,
            25969741,
            25969717,
            25967914,
            25967797,
            25967715,
            25967642,
            25967579,
            25967531,
            25967441,
            25967437,
            25967418,
            25967341,
            25628594,
            25611848
        ],
        "A": [
            25606141,
            25607710,
            25610915,
            25606934,
            25606698,
            25609653,
            25606498,
            25607278,
            25607609,
            25607400,
            25613182,
            25606914,
            25607776,
            25606578,
            25607601,
            25607434,
            25608027,
            25628141,
            25608400
        ]
    },
    "name": "C. Bear and Company",
    "statement": "Bear Limak prepares problems for a programming competition. Of course,\r\nit would be unprofessional to mention the sponsor name in the statement.\r\nLimak takes it seriously and he is going to change some words. To make\r\nit still possible to read, he will try to modify each word as little as\r\npossible.Limak has a string that consists of uppercase English letters.\r\nIn one move he can swap two letters of the string. For example, he can\r\ntransform a string \"\" into \"\" or \"\" in one move.Limak wants to obtain a\r\nstring without a substring \"\" (i.e. there should be no letter \u201d\r\nimmediately followed by letter \u201d). It can be easily proved that it\u2019s\r\npossible for any initial string .What is the minimum possible number of\r\nmoves Limak can do?\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = 80;\nchar s[maxn];\nint a[maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d%s\", &n, s) < 2) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    a[i] = (s[i] == 'V' ? 0 : (s[i] == 'K' ? 1 : 2));\n  }\n  return 1;\n}\n\nint dp[3][maxn][maxn][maxn];\n\nint poss[3][maxn];\n\nvoid solve() {\n  int cnt[3];\n  for (int it = 0; it < 3; ++it) {\n    cnt[it] = count(a, a + n, it);\n    \n    int j = 0;\n    for (int i = 0; i < n; ++i) {\n      if (a[i] == it) {\n        poss[it][j++] = i;\n      }\n    }\n  }\n\n\n  for (int i0 = 0; i0 <= cnt[0]; ++i0) {\n    for (int i1 = 0; i1 <= cnt[1]; ++i1) {\n      for (int i2 = 0; i2 <= cnt[2]; ++i2) {\n        for (int last = 0; last < 3; ++last) {\n          auto &cur = dp[last][i0][i1][i2];\n          cur = inf;\n          if (!i0 && !i1 && !i2) {\n            cur = 0;\n            continue;\n          }\n          int &was = (!last ? i0 : (last == 1 ? i1 : i2));\n          if (!was) {\n            continue;\n          }\n          --was;\n\n          int x = poss[last][was];\n          int val = 0;\n          val += max(0, (int) (lower_bound(poss[0], poss[0] + cnt[0], x) - poss[0]) - i0);\n          val += max(0, (int) (lower_bound(poss[1], poss[1] + cnt[1], x) - poss[1]) - i1);\n          val += max(0, (int) (lower_bound(poss[2], poss[2] + cnt[2], x) - poss[2]) - i2);\n          for (int nlast = 0; nlast < 3; ++nlast) {\n            if (!nlast && last == 1) {\n              continue;\n            }\n            cur = min(cur, dp[nlast][i0][i1][i2]);\n          }\n          cur += val;\n          //eprintf(\"dp[%d][%d,%d,%d] = %d\\n\", last, i0, i1, i2, cur);\n          ++was;\n        }\n      }\n    }\n  }\n  int res = inf;\n  for (int last = 0; last < 3; ++last) {\n    res = min(res, dp[last][cnt[0]][cnt[1]][cnt[2]]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Bear and Company.json",
    "editorial_link": "https://codeforces.com//blog/entry/51068",
    "editorial": "Letters different than 'V' and 'K' are indistinguishable, so we can treat all of them as the same letter 'X'.\n\nWe will try to build the final string from left to right Let dp[v][k][x] denote the number of moves needed to move first v letters 'V', first k letters 'K' and first x letters 'X' to the beginning of the string (those letters should become first v?+?k?+?x letters of the string). We should also remember the last used letter (to ensure that there is no 'K' just after 'V') so let's extend the state to dp[v][k][x][lastLetter] (or it can be dp[v][k][x][is_the_last_letter_V]).\n\nTo move from a state, we should consider taking the next 'K' (i.e. the k?+?1-th letter 'K' in the initial string), the next 'V' or the next 'X'. Of course, we can't take 'K' if the last used letter was 'V'.\n\nThe last step is to see how we should add to the score when we add a new letter. It turns out that it isn't enough to just add the difference between indices (where the letter was and where it will be) and the third sample test (\"VVKEVKK\") showed that. Instead, we should notice that we know which letters are already moved to the beginning (first k letters 'K' and so on) so we know how exactly the string looks like currently.\n\nFor example, let's consider the string \"VVKXXVKVV\" and moving from the state v?=?4,?k?=?1,?x?=?1 by taking a new letter 'K'. We know that first 4 letters 'V', 1 letter 'K' and 1 letter 'X' are already moved to the beginning. To move the next letter 'K' (underlined in blue on the drawing below) to the left, we must swap it with all not-used letters that were initially on the left from this 'K'. Counting them in linear time gives the total complexity O(n4) but you can also think a bit and get O(n3) - it's quite easy but it wasn't required to get AC. On the drawing below, used letters are crossed out. There is only 1 not-crossed-out letter on the left from 'K' so we should increase the score by 1 (because we need 1 swap to move this 'K' to the x?+?k?+?v?+?1-th position)."
}