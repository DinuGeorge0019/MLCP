{"link": "https://codeforces.com//contest/273/problem/D", "problemId": "2630", "problem_idx": "D", "shortId": "273D", "contest_number": "273", "problem_submissions": {"E": [3122057, 3120720, 3116725, 3122040, 3119368, 3121838, 3121574, 3121579, 3125606, 3120011], "D": [3119497, 3117520, 3123565, 3124849, 3121281, 3120768, 3117933, 3118228, 3123569, 3119311, 3122877, 3126278], "C": [3115563, 3119236, 3114688, 3117048, 3114860, 3116598, 3116734, 3117277, 3123467, 3122916, 3115814, 3123127, 3120446, 3126351], "B": [3113600, 3113886, 3112899, 3112808, 3114287, 3114846, 3113647, 3114818, 3114980, 3115379, 3114362, 3114126, 3114530, 3115262, 3115087, 3115234, 3115233], "A": [3112248, 3112373, 3112176, 3115660, 3112665, 3115057, 3112184, 3113078, 3122087, 3114179, 3112232, 3112611, 3112527, 3114570, 3113385, 3113821, 3112715]}, "name": "D. Dima and Figure", "statement": "Dima loves making pictures on a piece of squared paper. And yet more\r\nthan that Dima loves the pictures that depict one of his favorite\r\nfigures. A piece of squared paper of size is represented by a table,\r\nconsisting of rows and columns. All squares are white on blank squared\r\npaper. Dima defines a as an image on a blank piece of paper, obtained by\r\npainting some squares black.The picture portrays one of Dima\u2019s favorite\r\nfigures, if the following conditions hold: The picture contains at least\r\none painted cell; All painted cells form a connected set, that is, you\r\ncan get from any painted cell to any other one (you can move from one\r\ncell to a side-adjacent one); The minimum number of moves needed to go\r\nfrom the painted cell at coordinates to the painted cell at coordinates\r\n, moving only through the colored cells, equals . Now Dima is wondering:\r\nhow many paintings are on an piece of paper, that depict one of his\r\nfavorite figures? Count this number modulo .\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define SZ(c) ((int)(c).size())\n\ntypedef long long LL;\nLL sum[2][2][2][155][155];\nLL dp[2][2][2][155][155];\nconst int MOD = 1e9+7;\nvoid add(LL &x, long long v) {\n    x = (x+v)%MOD;\n}\n\nLL require_sum(int u, int f1, int f2, int xL, int xR, int yL, int yR) {\n    return\n        sum[u][f1][f2][xR][yR] - sum[u][f1][f2][xL-1][yR]\n        -sum[u][f1][f2][xR][yL-1] + sum[u][f1][f2][xL-1][yL-1];\n}\nint main(void) {\n    int m, n;\n    LL sol=0;\n    scanf(\"%d%d\", &m, &n);\n    int u=0;\n    for(int i=1;i<=m;i++)\n        for(int j=i;j<=m;j++) {\n            dp[0][0][0][i][j] = 1;\n            add(sol, (n+1-1)*dp[0][0][0][i][j]);\n        }\n    for(int i=1;i<=m;i++)\n        for(int j=1;j<=m;j++) {\n            sum[0][0][0][i][j] = (dp[0][0][0][i][j] + sum[0][0][0][i-1][j] + sum[0][0][0][i][j-1] - sum[0][0][0][i-1][j-1])%MOD;\n        }\n    for(int row=2;row<=n;row++) {\n        memset(dp[1-u],0,sizeof(dp[1-u]));\n        memset(sum[1-u],0,sizeof(sum[1-u]));\n        for(int i=1;i<=m;i++)\n            for(int j=i;j<=m;j++) {\n                dp[1-u][0][0][i][j] = require_sum(u, 0, 0, i, j, i, j);\n                dp[1-u][0][1][i][j] = require_sum(u, 0, 1, i, j, j, m);\n                if(j<m) add(dp[1-u][0][1][i][j], require_sum(u, 0, 0, i, j, j+1, m));\n                \n                dp[1-u][1][0][i][j] = require_sum(u, 1, 0, 1, i, i, j);\n                if(i>1) add(dp[1-u][1][0][i][j], require_sum(u, 0, 0, 1, i-1, i, j));\n\n                dp[1-u][1][1][i][j] = require_sum(u, 1, 1, 1, i, j, m);\n                if(i>1) add(dp[1-u][1][1][i][j], require_sum(u, 0, 1, 1, i-1, j, m));\n                if(j<m) add(dp[1-u][1][1][i][j], require_sum(u, 1, 0, 1, i, j+1, m));\n                if(i>1&&j<m) add(dp[1-u][1][1][i][j], require_sum(u, 0, 0, 1, i-1, j+1, m));\n            }\n        u=1-u;\n                for(int f1=0;f1<2;f1++)\n                    for(int f2=0;f2<2;f2++) {\n        for(int i=1;i<=m;i++)\n            for(int j=1;j<=m;j++)\n                sum[u][f1][f2][i][j] = (dp[u][f1][f2][i][j] + sum[u][f1][f2][i-1][j]+sum[u][f1][f2][i][j-1] - sum[u][f1][f2][i-1][j-1])%MOD;\n        add(sol, (n+1-row)*1LL*sum[u][f1][f2][m][m]);\n                    }\n    }\n    sol = (sol%MOD+MOD)%MOD;\n    printf(\"%I64d\\n\", sol);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2400", "interactive": false}