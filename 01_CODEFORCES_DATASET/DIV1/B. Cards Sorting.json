{
    "link": "https://codeforces.com//contest/830/problem/B",
    "problemId": "114243",
    "problem_idx": "B",
    "shortId": "830B",
    "contest_number": "830",
    "problem_submissions": {
        "D": [
            28594647,
            28515632,
            28517135,
            28522787,
            28518930,
            28520136,
            28522520,
            28522651,
            28522385,
            28521029,
            28522173,
            28931336,
            28518846,
            28520792,
            28518779,
            28524006,
            28523790,
            28523582,
            28514145,
            28518855
        ],
        "E": [
            28524957,
            28527227,
            28776493,
            28776475,
            31868930,
            28528205
        ],
        "C": [
            28513312,
            28514258,
            28526449,
            28512880,
            28515933,
            28516073,
            28513800,
            28513739,
            28515967,
            28518241,
            29799228,
            29796538,
            28519327,
            28516487,
            28931386,
            28515691,
            28524374,
            28513589,
            28518503,
            28515655,
            28517033,
            28528492,
            28534968
        ],
        "B": [
            28508342,
            28509379,
            28507817,
            28511318,
            28509260,
            28508546,
            28510695,
            28510689,
            30628707,
            30615033,
            30614998,
            28512995,
            28509425,
            28513558,
            28509785,
            28511054,
            28519867,
            28511755,
            28512387,
            28511965,
            28515860,
            28511432
        ],
        "A": [
            28506433,
            28506738,
            28506322,
            28516214,
            28513064,
            28506171,
            28506332,
            28506901,
            28509003,
            28511010,
            28512266,
            28526236,
            28507144,
            28507136,
            28519649,
            28517536,
            28508069
        ]
    },
    "name": "B. Cards Sorting",
    "statement": "Vasily has a deck of cards consisting of cards. There is an integer on\r\neach of the cards, this integer is between and , inclusive. It is\r\npossible that some cards have the same integers on them.Vasily decided\r\nto sort the cards. To do this, he repeatedly takes the top card from the\r\ndeck, and if the number on it equals the minimum number written on the\r\ncards in the deck, then he places the card away. Otherwise, he puts it\r\nunder the deck and takes the next card from the top, and so on. The\r\nprocess ends as soon as there are no cards in the deck. You can assume\r\nthat Vasily always knows the minimum number written on some card in the\r\nremaining deck, but doesn’t know where this card (or these cards) is.You\r\nare to determine the total number of times Vasily takes the top card\r\nfrom the deck.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nint A[110000];\nvector<int>x[110000];\nconst int N=100000;\nint n;\nvoid add(int k1,int k2){\n\tfor (;k1<=n;k1+=k1&(-k1)) A[k1]+=k2;\n}\nint find(int k1){\n\tint ans=0;\n\tfor (;k1;k1-=k1&(-k1)) ans+=A[k1]; return ans;\n}\nint calc(int l,int r){\n\tif (l>r) return calc(l,n)+calc(0,r);\n\treturn find(r)-find(l);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tadd(i,1); int k1; scanf(\"%d\",&k1);\n\t\tx[k1].push_back(i);\n\t}\n\tint pre=0; long long ans=0;\n\tfor (int i=1;i<=N;i++){\n\t\tif (x[i].size()==0) continue;\n\t\tint where=lower_bound(x[i].begin(),x[i].end(),pre)-x[i].begin();\n\t\tif (where==x[i].size()) where=0;\n\t\tfor (int j=0;j<x[i].size();j++){\n\t\t\tans+=calc(pre,x[i][where]);\n\t\t\tadd(x[i][where],-1);\n\t\t\tpre=x[i][where];\n\t\t\twhere=(where+1)%(int)(x[i].size());\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Cards Sorting.json",
    "editorial_link": "https://codeforces.com//blog/entry/53302",
    "editorial": "First note that operation \"put a card under the deck\" is the same as\r\n\"stark viewing from the beginning when you reach the end\", and do not\r\nmove cards anywhere.Then, letâs proceed all cards with equal numbers on\r\nthem at once. Itâs obvious that Vasily puts them away one after another.\r\nLetâs denote the position where he was when he put the last card less\r\nthan be position in the deck. Two cases are possible. If all cards equal\r\nto are after position , then he looks all the cards until he takes the\r\nlast card with , and puts away all cards equal to ; Otherwise there is a\r\ncard with that is before . In this case Valisy looks at all cards from\r\nto the end, and after that at all cards from the beginning of the deck\r\nto the last card with that is before . Itâs easy to process both cases\r\nif we keep for each positions of all cards with from the top to the\r\nbottom of the deck. Aside of this we need any data structure that is\r\ncapable of computing sum on a segment and changing a single value (we\r\ncan store for a position with a card in the deck, and is the card is\r\nalready put away). We can use segment tree or Fenwick tree for example.\r\n",
    "hint": []
}