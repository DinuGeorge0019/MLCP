{
    "link": "https://codeforces.com//contest/1470/problem/B",
    "problemId": "855303",
    "problem_idx": "B",
    "shortId": "1470B",
    "contest_number": "1470",
    "problem_submissions": {
        "E": [
            103440669,
            103450045,
            103444324,
            103446807,
            103456209,
            103459429,
            103458872,
            103449311,
            103444803,
            103455366,
            103427287,
            103523513,
            103512117,
            107007766,
            103497278
        ],
        "C": [
            103424863,
            103419731,
            103412394,
            103420749,
            103473095,
            103443608,
            103423946,
            103436573,
            103483233,
            103668985,
            103426627,
            103424859,
            103478420,
            103478404,
            103478387,
            103478371,
            103478354,
            103478316,
            103478307,
            103478286,
            103478261,
            103478250,
            103415351,
            103438274,
            103450179,
            103434430,
            103429394,
            103442814,
            103435400
        ],
        "D": [
            103415926,
            103427083,
            103428552,
            103423208,
            103420751,
            103429115,
            103425438,
            103418855,
            103424458,
            103422509,
            103452603,
            103410374,
            103430035,
            103428165,
            103418606,
            103410543,
            103439473,
            103434901,
            103425306,
            103416679
        ],
        "B": [
            103406584,
            103402617,
            103400867,
            103408140,
            103415671,
            103407933,
            103428755,
            103407002,
            103406514,
            103413492,
            103439686,
            103403315,
            103398826,
            103407557,
            103405634,
            103400232,
            103409460,
            103410649,
            103414139,
            103409541
        ],
        "A": [
            103395440,
            103396207,
            103392457,
            120480996,
            103397804,
            103473156,
            103473127,
            103399272,
            103396942,
            103393409,
            103401022,
            103396664,
            103398098,
            103431488,
            103391970,
            103392128,
            103393954,
            103394467,
            103391951,
            103398410,
            103401147,
            103400351,
            103410763
        ],
        "F": [
            128458334,
            128458191,
            105649646,
            105647576
        ]
    },
    "name": "B. Strange Definition",
    "statement": "Let us call two integers x and y if\r\nfrac{lcm(x, y)}{gcd(x, y)} is a perfect square. For example, 3 and 12\r\nare adjacent, but 6 and 9 are not.Here gcd(x, y) denotes the greatest\r\ncommon divisor (GCD) of integers x and y, and lcm(x, y) denotes the\r\nleast common multiple (LCM) of integers x and y.You are given an array a\r\nof length n. Each second the following happens: each element a_i of the\r\narray is by the product of all elements of the array (including itself),\r\nthat are adjacent to the current value. Let d_i be the number of\r\nadjacent elements to a_i (including a_i itself). The of the array is\r\ndefined as\r\nmax_{1\r\nle i\r\nle n} d_i. You are given q queries: each query is described by an\r\ninteger w, and you have to output the beauty of the array after w\r\nseconds.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 05.01.2021 17:43:58       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int MAX = (int) 1e6 + 10;\n  vector<int> h(MAX, 1);\n  for (int i = 1; i < MAX; i++) {\n    int tmp = i;\n    for (int j = 2; j * j <= tmp; j++) {\n      if (tmp % j == 0) {\n        int cnt = 0;\n        while (tmp % j == 0) {\n          cnt += 1;\n          tmp /= j;\n        }\n        if (cnt % 2 == 1) {\n          h[i] *= j;\n        }\n      }\n    }\n    if (tmp > 1) {\n      h[i] *= tmp;\n    }\n  }\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      a[i] = h[a[i]];\n    }\n    sort(a.begin(), a.end());\n    vector<int> b = a;\n    int ans0 = 0;\n    int beg = 0;\n    while (beg < n) {\n      int end = beg;\n      while (end + 1 < n && a[end + 1] == a[end]) {\n        end += 1;\n      }\n      ans0 = max(ans0, end - beg + 1);\n      if ((end - beg + 1) % 2 == 0) {\n        for (int i = beg; i <= end; i++) {\n          b[i] = 1;\n        }\n      }\n      beg = end + 1;\n    }\n    sort(b.begin(), b.end());\n    int ans1 = 0;\n    beg = 0;\n    while (beg < n) {\n      int end = beg;\n      while (end + 1 < n && b[end + 1] == b[end]) {\n        end += 1;\n      }\n      ans1 = max(ans1, end - beg + 1);\n      beg = end + 1;\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n      long long w;\n      cin >> w;\n      cout << (w == 0 ? ans0 : ans1) << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "graphs",
        "hashing",
        "math",
        "number theory"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Strange Definition.json",
    "editorial_link": "https://codeforces.com//blog/entry/86464",
    "editorial": "It is well known that , and it immediately follows that , which means\r\nthat numbers and are adjacent if and only if is a perfect square.Let be\r\nthe maximum possible integer such that divides , and be the maximum\r\npossible integer such that divides . Then is perfect square if and only\r\nif is even, which means (mod ).Let . Letâs replace it with . After such\r\na replacement two integers are adjacent if and only if they are\r\nequal.Letâs replace each element of the array and split the numbers into\r\nclasses of equal numbers. If the number of integers in a single class is\r\neven, after a single operation each element from this class will be\r\ntransformed to , and if the number of integers is odd, the class of the\r\nelement will remain unchanged. Since the class of integer 1 always\r\nremains unchanged, all integers will keep their classes starting from\r\nafter the first operation.Since denotes the size of the class, the\r\nbeauty of the array is defined as the size of the maximal class. If if\r\nthe size of the maximal class at the beginning of the process, and the\r\ntotal number of elements with a class of even size or with the class\r\nequal to 1. Then for a query with the answer is , for a query with the\r\nanswer is .This solution can easily be implemented with complexity,\r\nwhere denotes the maximum number in the array.\r\n",
    "hint": []
}