{
    "link": "https://codeforces.com//contest/1924/problem/E",
    "problemId": "2447861",
    "problem_idx": "E",
    "shortId": "1924E",
    "contest_number": "1924",
    "problem_submissions": {
        "E": [
            243630255,
            243625417,
            243831471,
            243819146,
            243638029,
            243635094,
            243635575,
            243643653,
            243641448,
            243654047,
            243642725,
            243655474,
            243640193,
            243642282,
            243738773,
            243738280,
            243737868,
            243737472,
            243736583,
            243647040,
            243643392,
            243656506,
            243623598,
            243647525,
            243642926
        ],
        "D": [
            243610539,
            243613703,
            243615017,
            243615468,
            243616484,
            243609433,
            243612607,
            243604919,
            243590030,
            243626983,
            243620249,
            243611671,
            243630742,
            243627184,
            243647496,
            243637086,
            243615081
        ],
        "C": [
            243600996,
            243608465,
            243605004,
            243605423,
            243609031,
            243624334,
            243598851,
            243618516,
            243614897,
            243607146,
            243609954,
            243605925,
            243615697,
            243614877,
            243629728,
            243619721,
            243625857
        ],
        "B": [
            243576284,
            243596345,
            243574522,
            243584076,
            243591802,
            243608792,
            243595388,
            243582812,
            243591583,
            243581060,
            243590774,
            243588502,
            243614602,
            243593249,
            243586709,
            243594966,
            243581169,
            243586114
        ],
        "A": [
            243557786,
            243557461,
            243557951,
            243558389,
            243559700,
            243571068,
            243569238,
            243556739,
            243561136,
            243559764,
            243556383,
            243563507,
            243559787,
            243566206,
            243566244,
            243561059,
            243558400,
            243589028
        ],
        "F": [
            243674865,
            243667546,
            243888054,
            243737554,
            246427685
        ]
    },
    "name": "E. Paper Cutting Again",
    "statement": "There is a rectangular sheet of paper with initial height n and width m.\r\nLet the current height and width be h and w respectively. We introduce a\r\nxy-coordinate system so that the four corners of the sheet are (0, 0),\r\n(w, 0), (0, h), and (w, h). The sheet can then be cut along the lines x\r\n= 1,2,\r\nldots,w-1 and the lines y = 1,2,\r\nldots,h-1. In each step, the paper is cut randomly along any one of\r\nthese h+w-2 lines. After each vertical and horizontal cut, the right and\r\nbottom piece of paper respectively are discarded.Find the expected\r\nnumber of steps required to make the area of the sheet of paper strictly\r\nless than k. It can be shown that this answer can always be expressed as\r\na fraction\r\ndfrac{p}{q} where p and q are coprime integers. Calculate p\r\ncdot q^{-1}\r\nbmod (10^9+7).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 1000000007;\nusing Z = MInt<P>;\n\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        m = std::min(m, Z::getMod() - 1);\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nvoid solve() {\n    int n, m;\n    i64 k;\n    std::cin >> n >> m >> k;\n    \n    if (1LL * n * m < k) {\n        std::cout << 0 << \"\\n\";\n        return;\n    }\n    \n    Z ans = 1;\n    for (int i = 1; i < n; i++) {\n        if (1LL * i * m >= k) {\n            ans += comb.inv(i + m - 1);\n        }\n    }\n    for (int i = 1; i < m; i++) {\n        if (1LL * i * n >= k) {\n            ans += comb.inv(i + n - 1);\n        }\n    }\n    for (int s = 2, i = -1; s <= n + m - 2; s++) {\n        if (1LL * (s / 2) * ((s + 1) / 2) < k) {\n            continue;\n        }\n        if (i == -1) {\n            i = s / 2;\n        }\n        while (1LL * (i - 1) * (s - (i - 1)) >= k) {\n            i -= 1;\n        }\n        int l = std::max(i, s - (m - 1));\n        int r = std::min(s - i, n - 1);\n        ans += std::max(0, r - l + 1) * comb.inv(s) * comb.inv(s - 1) * 2;\n    }\n    \n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "probabilities"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Paper Cutting Again.json",
    "editorial_link": "https://codeforces.com//blog/entry/125137",
    "editorial": "TutorialFor the given problem we can solve it by dividing it into 4\r\ncases: Only Vertical Cuts: Let the largest integer for which be . The\r\nprobability of achieving the goal using only vertical cuts is since one\r\nof the lines needs to be cut before all the horizontal lines. Now we\r\nwill multiply this with the sum of conditional probabilities for each of\r\nthe vertical line. Sum of conditional probabilities of being cut for all\r\nlines from to is exactly , since for area to be smaller than , one of\r\nthem needs to be cut and as soon as one is cut, the area becomes less\r\nthan so no further cuts are required. Now for the lines from to , their\r\nconditional probabilities will form the following harmonic progression:\r\nThis is due to the fact that for a line to be cut it needs to occur\r\nbefore all horizontal lines and all vertical lines smaller than it. Case\r\nwith only horizontal cuts can be handled similarly. Case when the\r\noverall last cut is a horizontal one and there is at least one vertical\r\ncut: For this, we iterate over the last cut among all the vertical cuts.\r\nLet the last vertical cut be . We now find the largest such that . Let\r\nthis value be . The objective can be achieved using this case if the\r\nvertical line occurs before all the horizontal lines from to and all the\r\nvertical lines from to , and after that any one of the horizontal line\r\nfrom to occur before all the vertical lines from to . The probability of\r\nthis happening is . Now we just add the the conditional probabilities of\r\nbeing cut for every line and multiply this with the above probability to\r\nfind the contribution of this case to the final answer. a. Firstly the\r\nconditional probability of the vertical line being cut is . b. The sum\r\nof conditional probabilities for horizontal lines to is also . The order\r\nof the first vertical cuts and the first horizontal cuts for the given\r\ncase would look like:, , ( vertical lines and horizontal lines in any\r\nrelative ordering) [Total elements in the sequence]. denotes the\r\nvertical cut. denotes the horizontal cut which occurs first among all\r\nthe first horizontal cuts. c. Vertical cuts from to : For the cut, we\r\ncan look at this like it needs to occur before the vertical cut (or it\r\nhas one gap in the sequence to choose from a total of gaps). So the\r\nprobability is . For the cut, we can first place the cut with\r\nprobability now we need to place the cut after of this which will happen\r\nwith the probability of . So the overall probability is the product\r\ni.e., . Similarly, the probability for cut is . The sum of this Harmonic\r\nProgression can be computed in using pre computation. d. Horizontal cuts\r\nfrom to (Trickiest Case imo) Let us see the case for the cut It has\r\noptimal gaps (before and the gap between and ) so the probability is .\r\nNow for finding the probability for cut, we first place this cut into\r\none of the gaps and handle both cases separately. Gap before : this case\r\nis similar to case 3c and the answer is just . Gap between and . Here we\r\nagain have to ensure that all lines from to occur after . So we multiply\r\nsince after we place the cut, we have good gaps among a total of and so\r\non for all the other lines we place (Their relative ordering does not\r\nmatter since we are only concerned with cut). The final term for cut\r\noccurs out to be: .This forms a quadratic Harmonic Progression, the sum\r\nof which can be computed in using precomputation. Case when the overall\r\nlast cut is a vertical one and there is at least one horizontal cut:\r\nThis case can be handled in a similar way as the previous case.\r\n",
    "hint": []
}