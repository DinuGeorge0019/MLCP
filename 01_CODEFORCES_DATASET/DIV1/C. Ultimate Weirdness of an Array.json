{
    "link": "https://codeforces.com//contest/671/problem/C",
    "problemId": "60094",
    "problem_idx": "C",
    "shortId": "671C",
    "contest_number": "671",
    "problem_submissions": {
        "C": [
            17859826,
            17855876,
            17856835,
            17856633,
            17868793,
            17855934,
            17861023,
            17857706,
            17875161,
            17862375,
            17859845,
            17858064,
            17861176,
            17861443,
            17859543,
            17861818,
            17860617,
            17861505
        ],
        "D": [
            17855058,
            17860093,
            17861640,
            17860506,
            17858536,
            17860074,
            17856542,
            17860536,
            17867217,
            17862092,
            113815261,
            17863344
        ],
        "B": [
            17851051,
            17851923,
            17852738,
            17851471,
            17851318,
            17850433,
            17851332,
            17864729,
            17853960,
            17851556,
            17850811,
            17852416,
            17852063,
            17850570,
            17853947,
            17852904,
            17865543,
            17854165,
            17853404,
            17855052,
            17853301
        ],
        "A": [
            17848841,
            17848804,
            17848586,
            17853033,
            17848191,
            17848166,
            17848430,
            17861560,
            17848909,
            17848654,
            17848663,
            17850636,
            17849756,
            17860496,
            17850816,
            17850150,
            17847744,
            17849814,
            17855875,
            17849520
        ]
    },
    "name": "C. Ultimate Weirdness of an Array",
    "statement": "Yasin has an array containing integers. Yasin is a 5 year old, so he\r\nloves ultimate weird things.Yasin denotes of an array as maximum value\r\namong all . For weirdness is equal to , is the greatest common divisor\r\nof integers and .He also defines the of an array. Ultimate weirdness is\r\nwhere is weirdness of the new array obtained by removing all elements\r\nbetween and inclusive, so new array is .Since 5 year old boys can\u2019t\r\ncode, Yasin asks for your help to find the value of ultimate weirdness\r\nof the given array !\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 211111\n\n#define TASK \"1\"\n\nusing namespace std;\n\nint n;\nvector<int> d[N];\nint a[N];\nint s[N];\nint was[N];\n\nint ap[N], f[N];\nint did[N];\n\nvoid add(int x, int v) {\n\twhile (x < n) {\n\t\ts[x] = max(s[x], v);\n\t\tx  |= x + 1;\n\t}\n}\n\nint get(int x) {\n\tint r = 0;\n\twhile (x >= 0) {\n\t\tr = max(r, s[x]);\n\t\tx = (x & (x + 1)) - 1;\n\t}\n\treturn r;\n}\n\nlong long sum = 0;\n\nvoid up(int x, int val) {\n\tif (get(x) >= val) return;\n\twhile (get(x) < val) {\n\t\tint v = get(x);\n\n\t\tint l = x;\n\t\tint r = n - 1;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r + 1) >> 1;\n\t\t\tif (get(mid) == v) l = mid; else r = mid - 1;\n\t\t}\n\t\tint to = val;\n\t\tif (l < n - 1) to = min(to, get(l + 1));\n\n\t\tsum += (to - v) * (l - x + 1);\t\t\n\t\tadd(x, to);\n\t}\t\t\t\n}\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK\".in\",\"r\",stdin);\t\n\t\tfreopen(TASK\".out\",\"w\",stdout);\n\t#endif\t\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tfor (int i = 1; i <= 200000; i++) {\n\t\tint j = i;\n\t\twhile (j <= 200000) {\n\t\t\td[j].pb(i);\n\t\t\tj += i;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < d[a[i]].size(); j++) {\n\t\t\tif (was[d[a[i]][j]]) ap[i] = max(ap[i], d[a[i]][j]);\n\t\t\twas[d[a[i]][j]] = 1;\n\t\t}\t\t\t\n\t\tap[i + 1] = ap[i];\n\t}\n\tfor (int i = 0; i < n; i++) add(i, ap[i]);\n\tfor (int i = 0; i < n; i++) sum += ap[i];\n\t\n\tfor (int i = 1; i <= 200000; i++) f[i] = n, was[i] = 0;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < d[a[i]].size(); j++) f[d[a[i]][j]] = min(f[d[a[i]][j]], i);\n\n\tint my = 0;\n\tlong long ans = 0;\n\tfor (int i = 0; i < n - 1; i++) ans += ap[i];\n\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tint h = a[i];\n\t\tfor (int j = 0; j < d[h].size(); j++) {\n\t\t\tif (was[d[h][j]]) my = max(my, d[h][j]);\n\t\t\twas[d[h][j]] = 1;\n\n\t\t\tint ps = f[d[h][j]];\n\t\t\tif (!did[d[h][j]]) {\n\t\t\t\tdid[d[h][j]] = 1;\n\t\t\t\tup(ps, d[h][j]);\n\t\t\t}\n\t\t}\n\t\tans += my;\n\n\t\tup(0, my);\n\t\tup(i - 1, 1000000);\n\n\t\tint bad = n - i + 1;\n\n\t\tans += sum - bad * 1000000ll;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "number theory"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Ultimate Weirdness of an Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/44821",
    "editorial": "If we calculate an array where is how many s there are that , then we\r\ncan easily calculate the answer. How to calculate array . Let\u00e2\u0080\u0099s keep a\r\nvector, keeps all elements indexes which contain as a divisor in sorted\r\norder. We will iterate over to . When we are iterating we will keep\r\nanother array , Let\u00e2\u0080\u0099s suppose we are iterating over , will keep leftmost\r\nwhere . Sometimes there is no such , then will be . will be equal to ,\r\nbecause if we choose p as , must be at least , so for we can choose -+\r\ndifferent s. Let\u00e2\u0080\u0099s look how we update array when we iterate to . Let be\r\n. Note that our must be cover at least of this indexes. must less or\r\nequal to . So we have to maximize all with where . Otherwise If then\r\nmust be at least , that\u00e2\u0080\u0099s we will maximize all \u00e2\u0080\u0099s where with . And\r\nfinally for all \u00e2\u0080\u0099s where we have to maximize them with . Observe that\r\narray will be monotonic in non decreasing order after all operations. So\r\nwe can easily make our updates with a segment tree that can perform\r\nfollowing operations: Returns rightmost index where is less than some .\r\nReturns sum of all elements in array. Can assign some to all elements\r\nbetween some and . If all update and queries performed in then overall\r\ncomplexity will be , we can also apply all this operations with STL set\r\nin same complexity. Code with set structure: link Code with segment\r\ntree: link\r\n"
}