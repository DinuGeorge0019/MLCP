{"link": "https://codeforces.com//contest/1835/problem/E", "problemId": "1971171", "problem_idx": "E", "shortId": "1835E", "contest_number": "1835", "problem_submissions": {"F": [210161299, 210152027, 210200486, 210168915, 210168905, 210234528, 210498721], "E": [210154409, 210139670, 210181918, 210167680, 210186364, 210186293, 211288903, 210214448, 210232344], "D": [210137478, 210145210, 210140448, 210146614, 210150836, 210149175, 210153170, 210140966, 210145335, 210157557, 210152881, 210158282, 210161722, 210158416, 210154492, 210150489, 210158944, 210157853, 210161077, 210159964], "C": [210128217, 210152796, 210132819, 210132907, 210137216, 210139416, 210142582, 210132889, 210151723, 210144494, 210144705, 210148053, 210147474, 210148947, 210144617, 210156201, 210143729, 210131342, 210153921, 210147904], "A": [210111447, 210110992, 210111020, 210113789, 210120090, 210112664, 210112565, 210111866, 210115344, 210112666, 210121548, 210113387, 210112454, 210112268, 210111369, 210114825, 210112488, 210116562, 210113331, 210116729], "B": [210161645, 210167670, 210167549, 210140435, 210129507, 210130424, 210124576, 210153636, 210135720, 210132356, 210134355, 210136221, 210133381, 210135165, 210136236, 210132156, 210131717, 210148804, 210140447, 210134819]}, "name": "E. Old Mobile", "statement": "During the latest mission of the starship U.S.S. Coder, Captain Jan\r\nBitovsky was accidentally teleported to the surface of an unknown\r\nplanet. Trying to find his way back, Jan found an artifact from planet\r\nEarth\u2019s ancient civilization a mobile device capable of interstellar\r\ncalls created by Byterola. Unfortunately, there was another problem.\r\nEven though Jan, as a representative of humans, knew perfectly the old\r\nnotation of the cell phone numbers, the symbols on the device\u2019s keyboard\r\nwere completely worn down and invisible to the human eye. The old\r\nkeyboards had exactly m + 1 buttons, one for each digit from the base m\r\nnumerical system, and one single backspace button allowing one to erase\r\nthe last written digit (if nothing was written on the screen, then this\r\nbutton does nothing, but it\u2019s still counted as pressed).Jan would like\r\nto communicate with his crew. He needs to type a certain number (also\r\nfrom the base m numerical system, that is, digits from 0 to m - 1). He\r\nwants to know the expected number of button presses necessary to contact\r\nthe U.S.S. Coder. Jan always chooses the most optimal buttons based on\r\nhis current knowledge. Buttons are indistinguishable until pressed. Help\r\nhim!\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 1000000007;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int N = 1010;\nInverses I(N);\nFactorials F(N);\nMint dp[N][N];\nbool used[N];\nMint w[N];\nMint dp2[N][N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tfor (int k = 1; k < N; k++)\n\t\tfor (int n = k; n < N; n++) {\n\t\t\tdp[n][k] = dp[n - 1][k - 1] + Mint(k - 1) * (dp[n - 1][k - 1] + Mint(2));\n\t\t\tif (n > k) dp[n][k] += Mint(n - k) * (dp[n - 1][k] + Mint(2));\n\t\t\tdp[n][k] *= I.inv(n);\n\t\t}\n\tfor (int k = 0; k < N; k++)\n\t\tfor (int n = k; n < N; n++) {\n\t\t\tdp2[n][k] = dp[n][k];\n\t\t\tif (k > 0) dp2[n][k] += Mint(k) * (dp2[n - 1][k - 1] + Mint(2));\n\t\t\tif (n > k) dp2[n][k] += Mint(n - k) * (dp2[n - 1][k] + Mint(2));\n\t\t\tdp2[n][k] *= I.inv(n + 1);\n\t\t}\n\n\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tused[x] = 1;\n\t}\n\tint k = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tk += used[i];\n\n\tMint ans = n;\n\tfor (int i = 0; i <= m + 1; i++)\n\t\tw[i] = F.fi[m + 1] * F.f[m + 1 - i];\n\tfor (int i = 0; i < k; i++) {\n\t\tif (i == 0) {\n\t\t\tans += w[i + 1] * (dp[m - i][k - i] + 1);\n\t\t} else {\n\t\t\tans += w[i + 1] * (dp[m - i][k - i] + 2);\n\t\t}\n\t\tans += w[i + 1] * Mint(k - i - 1) * (dp2[m - i - 1][k - i - 1] + Mint(2));\n\t\tans += w[i + 1] * Mint(m - k) * (dp2[m - i - 1][k - i] + Mint(2));\n\t}\n\tprintf(\"%u\\n\", ans.x);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "probabilities"], "dificulty": "3500", "interactive": false}