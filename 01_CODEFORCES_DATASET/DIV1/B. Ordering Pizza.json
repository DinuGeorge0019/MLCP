{
    "link": "https://codeforces.com//contest/866/problem/B",
    "problemId": "125341",
    "problem_idx": "B",
    "shortId": "866B",
    "contest_number": "866",
    "problem_submissions": {
        "G": [
            48042764,
            48042747,
            48042330,
            48042234,
            48042200,
            30882226,
            30888984,
            57250068
        ],
        "D": [
            31044799,
            30877994,
            30876120,
            30879768,
            30877841,
            30935417,
            30935391,
            30878366,
            82427005,
            30877626,
            30880014,
            30879034,
            30880919,
            30880306,
            30879681,
            30881205,
            30880292,
            30878146,
            30881085,
            30880894
        ],
        "F": [
            30883978,
            30915539,
            30915526,
            30915506,
            30915496,
            30915492,
            30915483,
            30915431,
            30915401,
            30915351,
            30915334,
            30888671,
            30882806,
            57257664
        ],
        "C": [
            30875892,
            30877179,
            30883361,
            30877278,
            30966883,
            30966734,
            30935175,
            30876872,
            30891743,
            30891736,
            30880301,
            30877644,
            30878514,
            30877044,
            30878539,
            30877470,
            30877525,
            30878653,
            30881355,
            30877891,
            31274174,
            30878115
        ],
        "B": [
            30874326,
            30883354,
            30901870,
            30876267,
            30875622,
            30878803,
            30876656,
            30875923,
            30874820,
            30876008,
            30875772,
            30876212,
            30875972,
            30876853,
            30876928,
            30876128,
            30876479
        ],
        "A": [
            30872518,
            30872539,
            30872760,
            30872739,
            30875884,
            30873740,
            30872744,
            30872982,
            30875680,
            30874617,
            30872755,
            30881297,
            30873075,
            30873379,
            30873703,
            30873164,
            30874384
        ],
        "E": [
            30957127,
            30884728,
            30888758,
            30909701
        ]
    },
    "name": "B. Ordering Pizza",
    "statement": "It’s another Start[c]up finals, and that means there is pizza to order\r\nfor the onsite contestants. There are only 2 types of pizza (obviously\r\nnot, but let’s just pretend for the sake of the problem), and all pizzas\r\ncontain exactly slices.It is known that the -th contestant will eat\r\nslices of pizza, and gain happiness for each slice of type 1 pizza they\r\neat, and happiness for each slice of type 2 pizza they eat. We can order\r\nany number of type 1 and type 2 pizzas, but we want to buy the minimum\r\npossible number of pizzas for all of the contestants to be able to eat\r\ntheir required number of slices. Given that restriction, what is the\r\nmaximum possible total happiness that can be achieved?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.09.2017 20:08:25       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint eat[N], a[N], b[N];\n\nint main() {\n  int n, s;\n  scanf(\"%d %d\", &n, &s);\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d %d\", eat + i, a + i, b + i);\n    total += eat[i];\n  }\n  long long pizzas = (total + s - 1) / s;\n  eat[n] = s * pizzas - total;\n  a[n] = 0;\n  b[n] = 0;\n  n++;\n  vector< pair<long long, long long> > a_to_b, b_to_a;\n  long long ans = 0;\n  long long cnt_a = 0, cnt_b = 0;\n  for (int i = 0; i < n; i++) {\n    if (a[i] > b[i]) {\n      ans += eat[i] * 1LL * a[i];\n      a_to_b.emplace_back(a[i] - b[i], eat[i]);\n      cnt_a += eat[i];\n    } else {\n      ans += eat[i] * 1LL * b[i];\n      b_to_a.emplace_back(b[i] - a[i], eat[i]);\n      cnt_b += eat[i];\n    }\n  }\n  long long best = (long long) 1e18;\n  {\n    long long extra = cnt_a % s;\n    sort(a_to_b.begin(), a_to_b.end());\n    long long cur = 0;\n    for (int i = 0; i < (int) a_to_b.size(); i++) {\n      auto &p = a_to_b[i];\n      long long take = min(p.second, extra);\n      cur += take * p.first;\n      extra -= take;\n    }\n    best = min(best, cur);\n  }\n  {\n    long long extra = cnt_b % s;\n    sort(b_to_a.begin(), b_to_a.end());\n    long long cur = 0;\n    for (int i = 0; i < (int) b_to_a.size(); i++) {\n      auto &p = b_to_a[i];\n      long long take = min(p.second, extra);\n      cur += take * p.first;\n      extra -= take;\n    }\n    best = min(best, cur);\n  }\n  cout << (ans - best) << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Ordering Pizza.json",
    "editorial_link": "https://codeforces.com//blog/entry/54888",
    "editorial": "To simplify things, let's first add a dummy contestant who will eat all the \"leftover\" pizza but gain no happiness. Then let's sort the contestants by bi?-?ai. Now we can describe the optimal way to feed the contestants once the pizzas are already bought: we should line up the contestants in order, and line up the pizzas in order with the type 1 pizzas at the front and type 2 pizzas at the back. Then the first contestant should take the first s1 slices, then the second contestant should take the next s2 slices, and so on.\n\nObserve that there can be at most 1 pizza whose slices are taken by some contestants prefer type 1 and others prefer type 2. The remainder of pizzas will have only one type of preference (or possibly no preference), so those pizzas can be made of whichever type is preferred. For the final pizza we can check both possibilities and order the one that provides more happiness.",
    "hint": []
}