{"link": "https://codeforces.com//contest/83/problem/E", "problemId": "446", "problem_idx": "E", "shortId": "83E", "contest_number": "83", "problem_submissions": {"E": [451947, 450977, 459818, 465914], "D": [449763, 448488, 452955, 452808, 452804, 448288, 449164, 450962, 452221, 451606, 451773, 451891, 450141, 449774, 449599, 450292, 449258, 450035, 450619], "C": [448521, 455889, 451494, 451794, 449865, 450165, 450276, 450602, 449657, 452977, 452829, 452759], "B": [447440, 452573, 449754, 447625, 448201, 447469, 450579, 448308, 447785, 447475, 447853, 448099, 447816, 448223, 447713, 447775], "A": [446362, 452366, 446401, 446361, 446485, 446374, 446375, 446560, 446585, 446384, 446420, 446524, 446437, 447399, 446502, 446789]}, "name": "E. Two Subsequences", "statement": "On an IT lesson Valera studied data compression. The teacher told about\r\na new method, which we shall now describe to you.Let be the given\r\nsequence of lines needed to be compressed. Here and below we shall\r\nassume that all lines are and consist only of the digits and . Let\u2019s\r\ndefine the compression function: empty sequenceempty string . the\r\nsmallest in length string, which has one of the prefixes equal to and\r\none of the suffixes equal to . For example, , . . For example, . Valera\r\nfaces a real challenge: he should divide the given sequence into two\r\nsubsequences and , , so that the value of took the minimum possible\r\nvalue. Here denotes the length of the string .Note that it is not\r\nallowed to change the relative order of lines in the subsequences. It is\r\nallowed to make one of the subsequences empty. Each string from the\r\ninitial sequence should belong to exactly one subsequence. Elements of\r\nsubsequences and don\u2019t have to be consecutive in the original sequence ,\r\ni. e. elements of and can alternate in (see samples 2 and 3).Help Valera\r\nto find the minimum possible value of .\r\n", "solutions": ["#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint d;\nint n;\nint a[200000], at[200000], dp[200000];\nchar buf[30];\nint list;\nint t[2097152], ta[2097152], s;\n\nint f (int a, int b) {\n\tint res = d;\n\twhile (a != b) {\n\t\tb >>= 1;\n\t\tif (a & (1 << (res-1)))\n\t\t\ta ^= (1 << (res-1));\n\t\tres --;\n\t}\n\treturn d - res;\n}\n\nvoid push (int v) {\n\tt[v] += ta[v];\n\tif (v < list) {\n\t\tta[v*2] += ta[v];\n\t\tta[v*2+1] += ta[v];\n\t}\n\tta[v] = 0;\n}\n\nvoid update (int v, int l, int r, int a, int x) {\n\tpush (v);\n\tif (r < a || l > a)\n\t\treturn;\n\tif (l == a && r == a) {\n\t\tt[v] = min (t[v], x);\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tupdate (v*2, l, m, a, x);\n\tupdate (v*2+1, m+1, r, a, x);\n\tt[v] = min (t[v*2], t[v*2+1]);\n}\n\nint rmq (int v, int l, int r, int a, int b) {\n\tpush (v);\n\tif (r < a || l > b)\n\t\treturn inf;\n\tif (a <= l && r <= b) \n\t\treturn t[v];\n\tint m = (l + r) / 2;\n\treturn min (rmq (v*2, l, m, a, b),\n\t\trmq (v*2+1, m+1, r, a, b));\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tscanf (\"%d\", &n);\n\tforn (i, n) {\n\t\tscanf (\"%s\", buf);\n\t\td = strlen (buf);\n\t\ta[i] = at[i] = 0;\n\t\tforn (j, d) {\n\t\t\ta[i] = a[i] * 2 + buf[j] - '0';\n\t\t\tat[i] = at[i] * 2 + buf[d-j-1] - '0';\n\t\t}\n\t}\n\tif (n == 1) {\n\t\tcout << d << endl;\n\t\treturn 0;\n\t}\n\tlist = 1 << d;\n\tforn (i, list*2)\n\t\tt[i] = inf;\n\tseta (ta, 0);\n\ts = d;\n\tupdate (1, 0, list-1, at[0], s+d);\n\tdp[0] = s+d;\n\tfor (int i = 1; i < n-1; i ++) {\n\t\tint v = f(a[i-1], a[i]);\n\t\ts += v;\n\t\tdp[i] = s+d;\n\t\tta[1] += v;\n\t\tupdate (1, 0, list-1, at[i-1], dp[i-1]);\n\t\tforn (j, d+1) {\n\t\t\tint atc = at[i+1] & ((1 << j) - 1);\n\t\t\tint l = atc << (d-j);\n\t\t\tint r = l + (1 << (d-j)) - 1;\n\t\t\tdp[i] = min (dp[i], rmq (1, 0, list-1, l, r) + d-j);\n\t\t}\n\t}\n\ts += f(a[n-2], a[n-1]);\n\tint res = s;\n\ts = 0;\n\tfor (int i = n-2; i >= 0; i --) {\n\t\tres = min (res, dp[i] + s);\n\t\ts += f (a[i], a[i+1]);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp"], "dificulty": "2800", "interactive": false}