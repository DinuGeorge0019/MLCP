{"link": "https://codeforces.com//contest/329/problem/D", "problemId": "3357", "problem_idx": "D", "shortId": "329D", "contest_number": "329", "problem_submissions": {"D": [4118984, 4120313, 4119660, 4116785, 4117605, 4120902, 4120215, 4118708, 4120010, 4137748, 4119968, 4119996, 4119672, 4121809], "C": [4117113, 4117558, 4116367, 4121523, 4143349, 4121550, 4117988, 4118184, 4122060, 4117812, 4137746, 4121987, 4121389, 4120201, 4115159, 4117962, 4119458, 4118596], "B": [4114305, 4114368, 4113665, 4115021, 4115525, 4115412, 4114479, 4114580, 4118395, 4137745, 4114685, 4117097, 4121085, 4123377, 4114997, 4115233, 4115579], "A": [4112796, 4112854, 4120598, 4113396, 4112888, 4113555, 4112601, 4113197, 4113479, 4137744, 4112411, 4113271, 4115572, 4112548, 4113837, 4113786, 4113898], "E": [4137719]}, "name": "D. The Evil Temple and the Moving Rocks", "statement": "You are an adventurer currently journeying inside an evil temple. After\r\ndefeating a couple of weak monsters, you arrived at a square room\r\nconsisting of tiles forming an grid, surrounded entirely by walls. At\r\nthe end of the room lies a door locked with evil magical forces. The\r\nfollowing inscriptions are written on the door: Being a very senior\r\nadventurer, you immediately realize what this means. In the room next\r\ndoor lies an infinite number of magical rocks. There are four types of\r\nrocks: \u201d: this rock moves upwards; \u201d: this rock moves leftwards; \u201d: this\r\nrock moves rightwards; \u201d: this rock moves downwards. To open the door,\r\nyou first need to place the rocks on some of the tiles (one tile can be\r\noccupied by at most one rock). Then, you select a single rock that you\r\nhave placed and activate it. The activated rock will then move in its\r\ndirection until it hits another rock or hits the walls of the room (the\r\nrock will not move if something already blocks it in its chosen\r\ndirection). The rock then deactivates. If it hits the walls, or if there\r\nhave been already events of rock becoming activated, the movements end.\r\nOtherwise, the rock that was hit becomes activated and this procedure is\r\nrepeated.If a rock moves at least one cell before hitting either the\r\nwall or another rock, the hit produces a sound. The door will open once\r\nthe number of produced sounds is at least . It is okay for the rocks to\r\ncontinue moving after producing sounds.The following picture illustrates\r\nthe four possible scenarios of moving rocks. Moves at least one cell,\r\nthen hits another rock. A sound is produced, the hit rock becomes\r\nactivated. Moves at least one cell, then hits the wall (i.e., the side\r\nof the room). A sound is produced, the movements end. Does not move\r\nbecause a rock is already standing in the path. The blocking rock\r\nbecomes activated, but no sounds are produced. Does not move because the\r\nwall is in the way. No sounds are produced and the movements end. Assume\r\nthere\u2019s an infinite number of rocks of each type in the neighboring\r\nroom. You know what to do: place the rocks and open the door!\r\n", "solutions": ["/*\nID: espr1t\nTASK: \nKEYWORDS: \n*/\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nFILE *in; FILE *out;\n\nconst int MAX = 128;\n\nint main(void) {\n\tin = stdin; out = stdout;\n//\tin = fopen(\"D.in\", \"rt\"); out = fopen(\"D.out\", \"wt\");\n\t\n\tint n, k;\n\tfscanf(in, \"%d %d\", &n, &k);\n\tif (n == 3 && k == 2) {\n\t    fprintf(out, \">vv\\n\");\n\t    fprintf(out, \"^<.\\n\");\n\t    fprintf(out, \"^.<\\n\");\n\t    fprintf(out, \"1 3\\n\");\n\t    return 0;\n\t}\n\tif (n == 5 && k == 5) {\n        fprintf(out, \">...v\\n\");\n        fprintf(out, \"v.<..\\n\");\n        fprintf(out, \"..^..\\n\");\n        fprintf(out, \">....\\n\");\n        fprintf(out, \"..^.<\\n\");\n        fprintf(out, \"1 1\\n\");\n        return 0;\n\t}\n\t\n\tstatic char ans[MAX][MAX];\n\tmemset(ans, 0, sizeof(ans));\n\tfor (int i = 0; i < n; i++)\n\t    for (int c = 0; c < n; c++)\n\t        ans[i][c] = '.';\n\n\tint len = 33, idx = 0;\n\tfor (int i = 0; i < len; i++)\n\t    ans[0][idx++] = '>';\n\tfor (int i = 0; i < len; i++) {\n\t    ans[0][idx++] = '.';\n\t    ans[0][idx++] = '>';\n\t}\n\tans[0][idx++] = 'v';\n\t\n\tfor (int i = 1; i < n - 1; i += 2) {\n\t    int row = i;\n\t    idx = 0;\n\t    ans[row][idx++] = '^';\n\t    ans[row][idx++] = 'v';\n\t    for (int c = 0; c < len - 1; c++) {\n\t        ans[row][idx++] = '.';\n\t        ans[row][idx++] = '<';\n\t    }\n\t    while (idx < n)\n\t        ans[row][idx++] = '<';\n\t    \n\t    row++;\n\t    idx = 0;\n\t    ans[row][idx++] = '^';\n\t    for (int c = 0; c < len - 1; c++)\n\t        ans[row][idx++] = '>';\n\t    for (int c = 0; c < len - 1; c++) {\n\t        ans[row][idx++] = '.';\n\t        ans[row][idx++] = '>';\n\t    }\n\t    ans[row][n - 1] = 'v';\n\t}\n\t\n\tidx = 0;\n\tans[n - 1][idx++] = '^';\n\tfor (int i = 0; i < len; i++) {\n\t    ans[n - 1][idx++] = '.';\n\t    ans[n - 1][idx++] = '<';\n\t}\n\twhile (idx < n)\n\t    ans[n - 1][idx++] = '<';\n\t\n\tfor (int i = 0; i < n; i++)\n\t    fprintf(out, \"%s\\n\", ans[i]);\n\tfprintf(out, \"1 1\\n\");\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "2500", "interactive": false}