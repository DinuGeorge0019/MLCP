{
    "link": "https://codeforces.com//contest/406/problem/D",
    "problemId": "7390",
    "problem_idx": "D",
    "shortId": "406D",
    "contest_number": "406",
    "problem_submissions": {
        "E": [
            6113980,
            6115371,
            6117401,
            6114390,
            6114632,
            6115961,
            6113761,
            6119100,
            6122295,
            6132836,
            6117696,
            6115484
        ],
        "D": [
            6111550,
            6112818,
            6117396,
            6111602,
            6114018,
            6112889,
            6110196,
            6112558,
            6113207,
            6114342,
            6109879,
            6117233,
            6113495,
            6112560,
            6111190,
            6113785,
            6113949,
            6114279,
            6113928,
            6111720,
            6116758,
            6114622
        ],
        "C": [
            6110187,
            6111166,
            6117392,
            6115342,
            6111381,
            6110506,
            6110270,
            6108894,
            6114229,
            6110730,
            6111155,
            6113968,
            6111745,
            6111516,
            6128689,
            6128286,
            6111327,
            6111782,
            6108166
        ],
        "B": [
            6108889,
            6109179,
            6117390,
            6108130,
            6113002,
            6108132,
            6108085,
            6107339,
            6110967,
            6110982,
            6107994,
            6108825,
            6109585,
            6108127,
            6108320,
            6109839,
            6109061,
            6109268,
            6109691,
            6111113
        ],
        "A": [
            6107835,
            6107644,
            6117388,
            6107225,
            6112427,
            6117543,
            6106926,
            6106550,
            6108138,
            6107728,
            6107011,
            6108007,
            6108768,
            6106947,
            6107483,
            6108996,
            6107104,
            6108198,
            6108284,
            6109349
        ]
    },
    "name": "D. Hill Climbing",
    "statement": "This problem has nothing to do with Little Chris. It is about hill\r\nclimbers instead (and Chris definitely isn’t one).There are hills\r\narranged on a line, each in the form of a vertical line segment with one\r\nendpoint on the ground. The hills are numbered with numbers from 1 to\r\nfrom left to right. The -th hill stands at position with its top at\r\nheight . For every two hills and , if the top of hill can be seen from\r\nthe top of hill , their tops are connected by a rope. Formally, the tops\r\nof two hills are connected if the segment connecting their top points\r\ndoes not intersect or touch any of the other hill segments. Using these\r\nropes, the hill climbers can move from hill to hill.There are teams of\r\nclimbers, each composed of exactly two members. The first and the second\r\nclimbers of the -th team are located at the top of the -th and -th\r\nhills, respectively. They want to meet together at the top of some hill.\r\nNow, each of two climbers move according to the following process: if a\r\nclimber is at the top of the hill where the other climber is already\r\nlocated or will come eventually, the former climber stays at this hill;\r\notherwise, the climber picks a hill to the right of his current hill\r\nthat is reachable by a rope and , climbs this hill and continues the\r\nprocess (the climber can also climb a hill whose top is lower than the\r\ntop of his current hill). For each team of climbers, determine the\r\nnumber of the meeting hill for this pair!\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA \"sequence\"\n\nint n;\nPLL A[110000];\nint P[110000][20];\nint D[110000];\n\nbool cw(PLL a,PLL b,PLL c){\n\treturn (b.X-a.X)*(c.Y-b.Y)<(b.Y-a.Y)*(c.X-b.X);\n}\n\nint todep(int v,int d){\n\tfor(int i=19;i>=0;--i){\n\t\tif(D[P[v][i]]>=d)\n\t\t\tv=P[v][i];\n\t}\n\treturn v;\n}\n\nint lca(int a,int b){\n\tint d=min(D[a],D[b]);\n\ta=todep(a,d);\n\tb=todep(b,d);\n\tif(a==b)\n\t\treturn a;\n\tfor(int i=19;i>=0;--i){\n\t\tif(P[a][i]!=P[b][i])\n\t\t\ta=P[a][i],b=P[b][i];\n\t}\n\treturn P[a][0];\n}\n\nint main(){\n#ifdef __ASD__\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#else\n\t//freopen(TASKA\".in\", \"r\", stdin); freopen(TASKA\".out\", \"w\", stdout);\n#endif\n\t\n\tios_base::sync_with_stdio(false);\n\t\n\tcin>>n;\n\tforn(i,n){\n\t\tcin>>A[i].X>>A[i].Y;\n\t}\n\t\n\tvector<int> st;\n\tfor(int i=n-1;i>=0;--i){\n\t\twhile(sz(st)>=2 && cw(A[st[sz(st)-2]],A[st.back()],A[i]))\n\t\t\tst.pop_back();\n\t\tif(i<n-1){\n\t\t\tP[i][0]=st.back();\n\t\t\tD[i]=D[P[i][0]]+1;\n\t\t\t//cout<<i<<\": \"<<P[i][0]<<endl;\n\t\t}\n\t\tst.pb(i);\n\t}\n\tP[n-1][0]=n-1;\n\t\n\tforn(k,19){\n\t\tforn(i,n){\n\t\t\tP[i][k+1]=P[P[i][k]][k];\n\t\t}\n\t}\n\t\n\tint tc;\n\tcin>>tc;\n\tforn(qqq,tc){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;--b;\n\t\tcout<<lca(a,b)+1<<' ';\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "geometry",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Hill Climbing.json",
    "editorial_link": "https://codeforces.com//blog/entry/11186",
    "editorial": "Note that the path of each hill climber is strictly convex in any case.\r\nLetâs draw the paths from all hills to the rightmost hill. Then these\r\npaths form a tree with the \"root\" at the top of the rightmost hill. We\r\ncan apply the Graham scan from the right to the left to find the edges\r\nof this tree. Each pop and insert in the stack corresponds to a single\r\nedge in the tree. Now it is easy to see that for each team of climbers,\r\nwe should calculate the number of the lowest common ancestor for the\r\ncorresponding two vertices in the tree. The size if the tree is , so\r\neach query works in . Solution complexity: .\r\n",
    "hint": []
}