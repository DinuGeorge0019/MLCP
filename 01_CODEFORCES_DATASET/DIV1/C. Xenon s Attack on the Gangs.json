{"link": "https://codeforces.com//contest/1292/problem/C", "problemId": "519778", "problem_idx": "C", "shortId": "1292C", "contest_number": "1292", "problem_submissions": {"F": [69140685, 69148403, 71814085, 71814062, 71813990, 70217605, 69197847, 69495748, 71223361], "D": [69122533, 69114171, 69256713, 69123417, 69126885, 69163995, 69128025, 69127012, 69131460, 69130080, 69130342, 69128215, 69129378, 69133922, 69131233, 69132965, 69132809, 69134434, 69132903, 69127292, 69140744, 69136786], "C": [69113617, 69117304, 69112958, 69113829, 69164607, 69112261, 69111227, 69113942, 69113564, 69116428, 69114170, 69121126, 69118602, 69121886, 69119931, 69117602, 69119253, 69121231, 69130721, 69112217, 69119945], "B": [69102431, 69100917, 69105559, 69104060, 69164579, 69104349, 69103131, 69105348, 69102973, 69106424, 69106338, 69108218, 69106515, 69110303, 69110995, 69110488, 69109887, 69114588, 69102534, 69105217, 69108444], "A": [69100122, 69100064, 69101788, 69100300, 69164572, 69100144, 69100129, 69100151, 69100251, 69100494, 69100278, 69100280, 69100245, 69101280, 69102544, 69101036, 69101104, 69100156, 69100106, 69100348, 69100678], "E": [69145246, 69152430, 69165289, 69151098, 69168995, 69165203, 69152318, 69162582, 69185344]}, "name": "C. Xenon s Attack on the Gangs", "statement": "On another floor of the A.R.C. Markland-N, the young man Simon \"Xenon\"\r\nJackson, takes a break after finishing his project early (as always).\r\nHaving a lot of free time, he decides to put on his legendary hacker \"X\"\r\ninstinct and fight against the gangs of the cyber world.His target is a\r\nnetwork of n small gangs. This network contains exactly n - 1 direct\r\nlinks, each of them connecting two gangs together. The links are placed\r\nin such a way that every pair of gangs is connected through a sequence\r\nof direct links.By mining data, Xenon figured out that the gangs used a\r\nform of cross-encryption to avoid being busted: every link was assigned\r\nan integer from 0 to n - 2 such that all assigned integers are distinct\r\nand every integer was assigned to some link. If an intruder tries to\r\naccess the encrypted data, they will have to surpass S password layers,\r\nwith S being defined by the following formula:S =\r\nsum_{1\r\nleq u < v\r\nleq n} mex(u, v)Here, mex(u, v) denotes the smallest non-negative\r\ninteger that does not appear on any link on the unique simple path from\r\ngang u to gang v.Xenon doesn\u2019t know the way the integers are assigned,\r\nbut it\u2019s not a problem. He decides to let his AI\u2019s instances try all the\r\npasswords on his behalf, but before that, he needs to know the maximum\r\npossible value of S, so that the AIs can be deployed efficiently.Now,\r\nXenon is out to write the AI scripts, and he is expected to finish them\r\nin two hours. Can you find the maximum possible S before he returns?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 3030;\nint n;\nvector<int> g[N];\nint h[N];\nint par[N][N];\nint lca[N][N];\nll dp[N][N];\nint sz[N];\n\nvoid dfs(int v) {\n\tsz[v] = 1;\n\tpar[v][h[v]] = v;\n\tfor (int u : g[v]) {\n\t\tif (h[u] != -1) continue;\n\t\th[u] = h[v] + 1;\n\t\tfor (int i = 0; i <= h[v]; i++)\n\t\t\tpar[u][i] = par[v][i];\n\t\tdfs(u);\n\t\tsz[v] += sz[u];\n\t}\n}\n\nint LCA(int v, int u) {\n\tif (v == u) return v;\n\tif (v > u) swap(v, u);\n\tif (lca[v][u] != -1) return lca[v][u];\n\tif (h[v] > h[u])\n\t\tlca[v][u] = LCA(par[v][h[v] - 1], u);\n\telse\n\t\tlca[v][u] = LCA(v, par[u][h[u] - 1]);\n\treturn lca[v][u];\n}\n\nll DP(int v, int u) {\n\tif (v == u) return 0;\n\tif (v > u) swap(v, u);\n\tif (dp[v][u] != -1) return dp[v][u];\n\tdp[v][u] = 0;\n\tint w = LCA(v, u);\n\tif (v == w) {\n\t\tdp[v][u] = max(dp[v][u], DP(v, par[u][h[u] - 1]));\n\t\tdp[v][u] = max(dp[v][u], DP(par[u][h[v] + 1], u));\n\t\tdp[v][u] += (n - sz[par[u][h[v] + 1]]) * sz[u];\n\t} else if (u == w) {\n\t\tdp[v][u] = max(dp[v][u], DP(u, par[v][h[v] - 1]));\n\t\tdp[v][u] = max(dp[v][u], DP(par[v][h[u] + 1], v));\n\t\tdp[v][u] += (n - sz[par[v][h[u] + 1]]) * sz[v];\n\t} else {\n\t\tdp[v][u] = max(dp[v][u], DP(v, par[u][h[u] - 1]));\n\t\tdp[v][u] = max(dp[v][u], DP(par[v][h[v] - 1], u));\n\t\tdp[v][u] += sz[v] * sz[u];\n\t}\n\treturn dp[v][u];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\th[i] = -1;\n\th[0] = 0;\n\tdfs(0);\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tlca[i][j] = -1;\n\t\t\tdp[i][j] = -1;\n\t\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tans = max(ans, DP(i, j));\n\t\n//\tfor (int i = 0; i < n; i++)\n//\t\tfor (int j = i + 1; j < n; j++)\n//\t\t\teprintf(\"dp[%d][%d] = %lld\\n\", i, j, dp[i][j]);\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dfs and similar", "dp", "greedy", "trees"], "dificulty": "2300", "interactive": false}