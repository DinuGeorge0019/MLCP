{
    "link": "https://codeforces.com//contest/109/problem/B",
    "problemId": "573",
    "problem_idx": "B",
    "shortId": "109B",
    "contest_number": "109",
    "problem_submissions": {
        "E": [
            648441
        ],
        "D": [
            646409,
            647170,
            646652,
            646695,
            646352,
            645873,
            645392,
            646870,
            646386,
            646289,
            645803,
            647324,
            646355,
            647745,
            646444,
            645672
        ],
        "B": [
            644873,
            644785,
            645061,
            644222,
            644364,
            643745,
            643698,
            644283,
            643725,
            646460,
            646874,
            647648,
            646835,
            644816,
            646998,
            647078
        ],
        "C": [
            643742,
            645980,
            645707,
            645639,
            645273,
            644937,
            644325,
            645865,
            644801,
            645032,
            644836,
            644580,
            644697,
            646773,
            644867,
            646558
        ],
        "A": [
            642201,
            642453,
            642373,
            642819,
            642224,
            642165,
            642161,
            642217,
            642304,
            642733,
            643129,
            642289,
            642251,
            642497,
            642687,
            647423
        ]
    },
    "name": "B. Lucky Probability",
    "statement": "Petya and his friend Vasya play an interesting game. Petya randomly\r\nchooses an integer from the interval and Vasya chooses an integer from\r\nthe interval (also randomly). Both players choose their integers\r\nequiprobably. Find the probability that the interval contains exactly\r\nlucky numbers.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nvector <ll> v;\n\nvoid dfs(ll x){\n    if(x > 1000000000) return;\n    v.push_back(x);\n    dfs(10*x+4);\n    dfs(10*x+7);\n}\n\nll func(ll x1, ll x2, ll y1, ll y2, int K){ // x <= y\n    int i,j;\n    int sz = v.size();\n    \n    ll ans = 0;\n    REP(i,sz){\n        j = i + K - 1;\n        if(j >= sz) break;\n        ll xlow = x1, xhigh = x2, ylow = y1, yhigh = y2;\n        if(i != 0) xlow = max(xlow,v[i-1]+1);\n        xhigh = min(xhigh,v[i]);\n        ylow = max(ylow,v[j]);\n        if(j != sz-1) yhigh = min(yhigh,v[j+1]-1);\n        if(xhigh >= xlow && yhigh >= ylow) ans += (xhigh - xlow + 1) * (yhigh - ylow + 1);\n    }\n    \n    return ans;\n}\n\nint main(void){\n    int i;\n    \n    dfs(4); dfs(7);\n    sort(v.begin(),v.end());\n    int sz = v.size();\n    \n    ll x1,y1,x2,y2;\n    int K;\n    cin >> x1 >> x2 >> y1 >> y2 >> K;\n    \n    ll total = (x2 - x1 + 1) * (y2 - y1 + 1);\n    ll tmp = func(x1,x2,y1,y2,K) + func(y1,y2,x1,x2,K);\n    if(K == 1) REP(i,sz) if(v[i] >= x1 && v[i] <= x2 && v[i] >= y1 && v[i] <= y2) tmp--;\n    \n    double ans = (double)tmp / total;\n    printf(\"%.12f\\n\",ans);\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "probabilities"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Lucky Probability.json",
    "editorial_link": "https://codeforces.com/blog/entry/2547",
    "editorial": "Let L[i] - i-th lucky number, starting from 1 (L[0]?=?0, L[1]?=?4, L[2]?=?7...). At first choose first k lucky number, then second k numbers and so on. For each of that group lets find answer, result will be a sum of each of this probabilities. Let index of current first number if i, last - j (j?=?i?+?k?-?1). Then we need to find intersection of intervals [pl;pr] and (L[i?-?1];L[i]], and also [vl;vr] and [L[j];L[j?+?1]), product of that values will be a number of ways in which p?<?v, similarly for p?>?v. Sum of all that values for each group will be a total number of ways, then result = total number of ways / ((pr?-?pl?+?1)?*?(vr?-?vl?+?1)).",
    "hint": []
}