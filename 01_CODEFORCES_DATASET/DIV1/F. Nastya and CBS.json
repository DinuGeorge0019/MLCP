{"link": "https://codeforces.com//contest/1340/problem/F", "problemId": "599376", "problem_idx": "F", "shortId": "1340F", "contest_number": "1340", "problem_submissions": {"F": [77861280, 77852254, 77849797, 78528429, 78527982, 77845721, 77870771, 77870728, 77870667, 77809735, 77844929, 78038847, 77865877, 77864401, 77864363, 77862346, 77862326], "D": [77814886, 77820644, 77812632, 77817969, 78526970, 77818222, 77825103, 77825677, 77810183, 77803432, 77810910, 77812394, 77816455, 77825551, 77843873, 77828804, 77822663, 77822063], "C": [77795843, 77812380, 77824845, 77823255, 78526952, 77799809, 77811601, 77834672, 77830782, 77811370, 77793451, 77808028, 77797811, 77795450, 77802848, 77796169, 77858001, 77810294, 77809842], "A": [77782251, 77771158, 77774810, 77787508, 78526918, 78526910, 77776379, 77774309, 77776029, 77816613, 77771928, 77777830, 77775868, 77773607, 77771508, 77776009, 77776621, 77773349, 77795835, 77779579, 77772710, 77776861], "B": [77777625, 77796394, 77787259, 77781233, 78526935, 77868779, 77790975, 77793147, 77821618, 77789026, 77773962, 77770331, 77782427, 77780486, 77790796, 77783960, 77786770, 77783985, 77790124, 77791298, 77788341], "E": [77836196, 77868575, 77868568, 77868546, 77868525, 77868496, 77845628, 77864964, 77846936, 77902183, 77902167, 77902121, 77902068, 77902045, 77901978, 77850099, 77859253, 77828316, 77849841, 77848435, 77856908, 77842257]}, "name": "F. Nastya and CBS", "statement": "A string s is given. It consists of k kinds of pairs of brackets. Each\r\nbracket has the form t it is an integer, such that 1\r\nleq |t|\r\nleq k. If the bracket has a form t, then: If t > 0, then it\u2019s an opening\r\nbracket of the type t. If t < 0, then it\u2019s a closing bracket of the type\r\n-t. Thus, there are k types of pairs of brackets in total. The queries\r\nneed to be answered: Replace the bracket at position i with the bracket\r\nof the form t. Check if the substring from the l-th to r-th position\r\n(including) is the correct bracket sequence. Recall the definition of\r\nthe correct bracket sequence: An empty sequence is correct. If A and B\r\nare two correct bracket sequences, then their concatenation \"A B\" is\r\nalso correct bracket sequence. If A is the correct bracket sequence, c\r\n(1\r\nleq c\r\nleq k) is a type of brackets, then the sequence \"c A -c\" is also correct\r\nbracket sequence.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename U, typename V> struct pairnum {\n\tU u;\n\tV v;\n\n\tpairnum() : u(0), v(0) {}\n\tpairnum(long long val) : u(val), v(val) {}\n\tpairnum(const U& u_, const V& v_) : u(u_), v(v_) {}\n\n\tfriend std::ostream& operator << (std::ostream& out, const pairnum& n) { return out << '(' << n.u << ',' << ' ' << n.v << ')'; }\n\tfriend std::istream& operator >> (std::istream& in, pairnum& n) { long long val; in >> val; n = pairnum(val); return in; }\n\n\tfriend bool operator == (const pairnum& a, const pairnum& b) { return a.u == b.u && a.v == b.v; }\n\tfriend bool operator != (const pairnum& a, const pairnum& b) { return a.u != b.u || a.v != b.v; }\n\n\tpairnum inv() const {\n\t\treturn pairnum(u.inv(), v.inv());\n\t}\n\tpairnum neg() const {\n\t\treturn pairnum(u.neg(), v.neg());\n\t}\n\tpairnum operator- () const {\n\t\treturn pairnum(-u, -v);\n\t}\n\tpairnum operator+ () const {\n\t\treturn pairnum(+u, +v);\n\t}\n\n\tpairnum& operator ++ () {\n\t\t++u, ++v;\n\t\treturn *this;\n\t}\n\tpairnum& operator -- () {\n\t\t--u, --v;\n\t\treturn *this;\n\t}\n\n\tpairnum& operator += (const pairnum& o) {\n\t\tu += o.u;\n\t\tv += o.v;\n\t\treturn *this;\n\t}\n\tpairnum& operator -= (const pairnum& o) {\n\t\tu -= o.u;\n\t\tv -= o.v;\n\t\treturn *this;\n\t}\n\tpairnum& operator *= (const pairnum& o) {\n\t\tu *= o.u;\n\t\tv *= o.v;\n\t\treturn *this;\n\t}\n\tpairnum& operator /= (const pairnum& o) {\n\t\tu /= o.u;\n\t\tv /= o.v;\n\t\treturn *this;\n\t}\n\n\tfriend pairnum operator ++ (pairnum& a, int) { pairnum r = a; ++a; return r; }\n\tfriend pairnum operator -- (pairnum& a, int) { pairnum r = a; --a; return r; }\n\tfriend pairnum operator + (const pairnum& a, const pairnum& b) { return pairnum(a) += b; }\n\tfriend pairnum operator - (const pairnum& a, const pairnum& b) { return pairnum(a) -= b; }\n\tfriend pairnum operator * (const pairnum& a, const pairnum& b) { return pairnum(a) *= b; }\n\tfriend pairnum operator / (const pairnum& a, const pairnum& b) { return pairnum(a) /= b; }\n};\n\nusing mnum = modnum<998244353>;\nusing hsh = pairnum<mnum, mnum>;\n\nconst uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();\nmt19937 mt(FIXED_RANDOM);\nconst hsh BASE = hsh(mnum(mt()), mnum(mt()));\n\nconst int MAXN = 1.1e5;\nhsh BASE_POW[MAXN];\n\nstruct treap {\n\tint c[2] = {0,0};\n\tmt19937::result_type pri = mt();\n\n\thsh hash_val;\n\tint sz;\n\tint val;\n\n\tvoid update();\n\n};\nconst int TREAP_SZ = int(9.1e6);\ntreap treap_pool[TREAP_SZ];\nint TREAP_IND = 1;\nint alloc_treap() {\n\tint n = TREAP_IND++;\n\tassert(n < TREAP_SZ);\n\treturn n;\n}\n\nint get_sz(int a) {\n\treturn a ? treap_pool[a].sz : 0;\n}\nhsh get_hash_val(int a) {\n\treturn a ? treap_pool[a].hash_val : hsh(0);\n}\n\nvoid treap::update() {\n\tsz = 1 + get_sz(c[0]) + get_sz(c[1]);\n\thash_val = hsh(val);\n\tif (c[1]) {\n\t\thash_val = hash_val + BASE * get_hash_val(c[1]);\n\t}\n\tif (c[0]) {\n\t\thash_val = get_hash_val(c[0]) + BASE_POW[get_sz(c[0])] * hash_val;\n\t}\n}\n\nint merge(int a, int b) {\n\tif (!a) return b;\n\tif (!b) return a;\n\tint n = alloc_treap();\n\ttreap* r = &treap_pool[n];\n\tif (treap_pool[a].pri < treap_pool[b].pri) {\n\t\t*r = treap_pool[a];\n\t\tr->c[1] = merge(treap_pool[a].c[1], b);\n\t} else {\n\t\t*r = treap_pool[b];\n\t\tr->c[0] = merge(a, treap_pool[b].c[0]);\n\t}\n\tr->update();\n\treturn n;\n}\n\npair<int, int> split(int a, int k) {\n\tif (k == 0) return {0, a};\n\tassert(a);\n\tassert(k <= get_sz(a));\n\tif (k == get_sz(a)) return {a, 0};\n\n\tint l, r;\n\n\tint n = alloc_treap();\n\ttreap_pool[n] = treap_pool[a];\n\n\tif (k <= get_sz(treap_pool[a].c[0])) {\n\t\tr = n;\n\t\ttie(l, treap_pool[r].c[0]) = split(treap_pool[a].c[0], k);\n\t} else {\n\t\tl = n;\n\t\ttie(treap_pool[l].c[1], r) = split(treap_pool[a].c[1], k - 1 - get_sz(treap_pool[a].c[0]));\n\t}\n\n\ttreap_pool[n].update();\n\tassert(get_sz(l) == k);\n\treturn {l, r};\n}\n\nconst int S = 1 << 17;\nstruct seg_node {\n\tint pref = 0;\n\tint suff = 0;\n\tbool good = false;\n} seg[2*S];\n\nseg_node init_node(int v) {\n\tint ind = alloc_treap();\n\ttreap* n = &treap_pool[ind];\n\tn->pri = mt();\n\tn->c[0] = n->c[1] = 0;\n\tn->val = abs(v);\n\tn->update();\n\n\tif (v > 0) {\n\t\t// this is a suffix\n\t\treturn {0, ind, true};\n\t} else {\n\t\t// this is a prefix\n\t\treturn {ind, 0, true};\n\t}\n}\n\nseg_node merge_nodes(seg_node a, seg_node b) {\n\tif (!a.good || !b.good) {\n\t\treturn seg_node{0, 0, false};\n\t}\n\n\tint OLD_TREAP_IND = TREAP_IND;\n\n\tif (get_sz(a.suff) >= get_sz(b.pref)) {\n\t\tauto [x, y] = split(a.suff, get_sz(b.pref));\n\t\tassert(get_sz(x) == get_sz(b.pref));\n\t\tif (get_hash_val(x) != get_hash_val(b.pref)) {\n\t\t\tTREAP_IND = OLD_TREAP_IND;\n\t\t\treturn seg_node{0, 0, false};\n\t\t}\n\t\treturn {a.pref, merge(b.suff, y), true};\n\t} else {\n\t\tauto [x, y] = split(b.pref, get_sz(a.suff));\n\t\tassert(get_sz(x) == get_sz(a.suff));\n\t\tif (get_hash_val(x) != get_hash_val(a.suff)) {\n\t\t\tTREAP_IND = OLD_TREAP_IND;\n\t\t\treturn seg_node{0, 0, false};\n\t\t}\n\t\treturn {merge(a.pref, y), b.suff, true};\n\t}\n\n\tassert(false);\n}\n\nvoid updateNode(int i) {\n\tif (i >= S) {\n\t\t// do nothing\n\t} else {\n\t\tseg[i] = merge_nodes(seg[2*i], seg[2*i+1]);\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tBASE_POW[0] = hsh(1);\n\tfor (int i = 1; i < MAXN; i++) BASE_POW[i] = BASE_POW[i-1] * BASE;\n\n\tint N, K; cin >> N >> K;\n\tvector<int> V(N);\n\tfor (int i = 0; i < N; i++) cin >> V[i];\n\n\tauto init = [&]() {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tseg[S+i] = init_node(V[i]);\n\t\t}\n\t\tfor (int i = S-1; i; i--) updateNode(i);\n\t};\n\tinit();\n\n\tconst int reset_thresh = int(TREAP_SZ * 0.9);\n\n\tint Q; cin >> Q;\n\twhile (Q--) {\n\t\tif (TREAP_IND >= reset_thresh) {\n\t\t\tTREAP_IND = 1;\n\t\t\tinit();\n\t\t}\n\n\t\tint op; cin >> op;\n\t\tif (op == 1) {\n\t\t\tint i; cin >> i; i--; cin >> V[i];\n\t\t\tseg[S+i] = init_node(V[i]);\n\t\t\tfor (int a = S+i; a; a /= 2) updateNode(a);\n\t\t} else if (op == 2) {\n\t\t\tint OLD_TREAP_IND = TREAP_IND;\n\n\t\t\tint l, r; cin >> l >> r; l--, r--;\n\t\t\tseg_node lval = {0, 0, true};\n\t\t\tseg_node rval = {0, 0, true};\n\t\t\tfor (int a = S+l, b = S+r+1; a < b; a /= 2, b /= 2) {\n\t\t\t\tif (a & 1) lval = merge_nodes(lval, seg[a++]);\n\t\t\t\tif (b & 1) rval = merge_nodes(seg[--b], rval);\n\t\t\t}\n\n\t\t\tseg_node val = merge_nodes(lval, rval);\n\t\t\tcout << (val.good && val.pref == 0 && val.suff == 0 ? \"Yes\" : \"No\") << '\\n';\n\n\t\t\tTREAP_IND = OLD_TREAP_IND;\n\t\t} else assert(false);\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "hashing"], "dificulty": "3300", "interactive": false}