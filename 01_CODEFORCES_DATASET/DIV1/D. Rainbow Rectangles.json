{
    "link": "https://codeforces.com//contest/1396/problem/D",
    "problemId": "712376",
    "problem_idx": "D",
    "shortId": "1396D",
    "contest_number": "1396",
    "problem_submissions": {
        "E": [
            91420325,
            91433351,
            91395963,
            91403549,
            91401123,
            91402411,
            91409596,
            91414724,
            91398509,
            91431034,
            98258243,
            91413242,
            91418927,
            91416810,
            100070579,
            100069379,
            91404326
        ],
        "D": [
            91388366,
            91423836,
            91402660,
            91943822,
            91410504,
            91407249,
            91405665,
            91404955,
            92387331,
            91409139,
            91420254
        ],
        "C": [
            91373061,
            91380961,
            91375173,
            91383628,
            91383246,
            91370624,
            91378488,
            91375423,
            91372747,
            91401459,
            91603982,
            91437619,
            91381246,
            91378361,
            91395543,
            91392372,
            91380457,
            91391062,
            91392240,
            91390152,
            91380894
        ],
        "B": [
            91358979,
            91360664,
            91363530,
            91358594,
            91358724,
            91359119,
            91363085,
            91359172,
            91358745,
            91363826,
            91362155,
            91366158,
            91362751,
            91365359,
            91360322,
            91364106,
            91365992,
            91378262,
            91361724,
            91365744
        ],
        "A": [
            91354401,
            91357111,
            91359227,
            91352552,
            91352349,
            91355053,
            91358883,
            91356416,
            91355726,
            91357237,
            91356536,
            91360026,
            91358794,
            91362354,
            91356173,
            91360020,
            91356069,
            91361174,
            91357755,
            91354128
        ]
    },
    "name": "D. Rainbow Rectangles",
    "statement": "Shrimpy Duc is a fat and greedy boy who is always hungry. After a while\r\nof searching for food to satisfy his never-ending hunger, Shrimpy Duc\r\nfinds M&M candies lying unguarded on a L\r\ntimes L grid. There are n M&M candies on the grid, the i-th M&M is\r\ncurrently located at (x_i + 0.5, y_i + 0.5), and has color c_i out of a\r\ntotal of k colors (the size of M&Ms are insignificant).Shrimpy Duc wants\r\nto steal a of M&Ms, specifically, he wants to select a rectangle with\r\ncoordinates within the grid and steal all candies within the rectangle.\r\nShrimpy Duc doesn’t need to steal every single candy, however, he would\r\nlike to steal .In other words, he wants to select a rectangle whose\r\nsides are parallel to the coordinate axes and whose left-bottom vertex\r\n(X_1, Y_1) and right-top vertex (X_2, Y_2) are points with integer\r\ncoordinates satisfying 0\r\nle X_1 < X_2\r\nle L and 0\r\nle Y_1 < Y_2\r\nle L, so that for every color 1\r\nle c\r\nle k there is at least one M&M with color c that lies within that\r\nrectangle.How many such rectangles are there? This number may be large,\r\nso you only need to find it modulo 10^9 + 7.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.08.2020 18:09:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nstruct Point {\n  int x;\n  int y;\n  int c;\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k, L;\n  cin >> n >> k >> L;\n  vector<Point> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].x >> p[i].y >> p[i].c;\n    --p[i].c;\n  }\n  sort(p.begin(), p.end(), [&](const Point& a, const Point& b) {\n    return a.y < b.y;\n  });\n  long long c2 = (long long) L * (L + 1) / 2;\n  auto C2 = [&](int x, int y) -> long long {\n    if (x >= y) {\n      return 0;\n    }\n    return ((long long) (y - x) * (y - x + 1)) >> 1;\n  };\n  Mint ans = 0;\n  for (int start = 0; start <= n - k; start++) {\n    int coeff = p[start].y - (start == 0 ? -1 : p[start - 1].y);\n    if (coeff == 0) {\n      continue;\n    }\n    vector<multiset<int>> s(k);\n    for (int i = 0; i < k; i++) {\n      s[i].insert(-1);\n      s[i].insert(L);\n    }\n    for (int i = start; i < n; i++) {\n      s[p[i].c].insert(p[i].x);\n    }\n    set<pair<int, int>> segs;\n    long long value = 0;\n    auto Modify = [&](set<pair<int, int>>::iterator it, int q) {\n      if (it != segs.begin()) {\n        value -= q * C2(it->first, abs(prev(it)->second));\n      }\n      if (next(it) != segs.end()) {\n        value -= q * C2(next(it)->first, abs(it->second));\n      }\n      if (it != segs.begin() && next(it) != segs.end()) {\n        value += q * C2(next(it)->first, abs(prev(it)->second));\n      }\n      value += q * C2(it->first, abs(it->second));\n    };\n    auto Erase = [&](set<pair<int, int>>::iterator it) {\n      Modify(it, -1);\n      segs.erase(it);\n    };\n    auto Add = [&](int from, int to) {\n      if (from >= to) {\n        return;\n      }\n      pair<int, int> seg = make_pair(from, -to);\n      auto it = segs.lower_bound(seg);\n      while (it != segs.end() && abs(it->second) <= to) {\n        Erase(it);\n        it = segs.lower_bound(seg);\n      }\n      if (it != segs.begin()) {\n        it = prev(it);\n        if (abs(it->second) >= to) {\n          return;\n        }\n      }\n      auto ret = segs.insert(seg);\n      assert(ret.second);\n      it = ret.first;\n      Modify(it, 1);\n    };\n    bool have_all = true;\n    for (int i = 0; i < k; i++) {\n      if (s[i].size() == 2) {\n        have_all = false;\n        break;\n      }\n      auto it = s[i].begin();\n      while (*it < L) {\n        int me = *it;\n        ++it;\n        int nxt = *it;\n        Add(me + 1, nxt);\n      }\n    }\n    if (!have_all) {\n      break;\n    }\n    for (int finish = n - 1; finish >= start; finish--) {\n      int coeff2 = (finish == n - 1 ? L : p[finish + 1].y) - p[finish].y;\n      ans += Mint(coeff) * coeff2 * (c2 - value);\n      int col = p[finish].c;\n      auto it = s[col].find(p[finish].x);\n      assert(it != s[col].end());\n      auto pr = prev(it);\n      auto nx = next(it);\n      Add((*pr) + 1, *nx);\n      s[col].erase(it);\n      if (value == c2) {\n        break;\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "sortings",
        "two pointers"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Rainbow Rectangles.json",
    "editorial_link": "https://codeforces.com//blog/entry/82142",
    "editorial": "Let denote a rectangle with opposite corners and . For convenience,\r\nassume and .Letâs try solving the problem if coordinates are in range .\r\nWe could easily do this by coordinates compression.First, letâs look at\r\nthe problem with fixed. We define to be the smallest integer such that\r\nand is a rectangle (If there is no such integer, let ). It can be proven\r\nthat is non-decreasing, i.e. if , then .Now, letâs see how changes when\r\nwe iterate over a fixed . It is hard to add points to the set, so we\r\nwill try to support deleting points operation. For point , we have the\r\nfollowing definitions:Let set . Let with the largest .Let set . Let with\r\nthe smallest .(Note that or might represent empty set).With these two\r\nfunctions, we could see how changes after we delete point . It looks\r\nsomething like this: For every such that ;We could support this\r\noperation using segment tree with lazy propagation. The total time\r\ncomplexity is .\r\n",
    "hint": []
}