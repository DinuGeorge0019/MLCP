{
    "link": "https://codeforces.com//contest/1874/problem/E",
    "problemId": "2236840",
    "problem_idx": "E",
    "shortId": "1874E",
    "contest_number": "1874",
    "problem_submissions": {
        "F": [
            226041334,
            226055202,
            226083158,
            226054781,
            226061315,
            226045179,
            226057161,
            226024417,
            226094016,
            226151126,
            226979730,
            226372437,
            226704730,
            226099033,
            226098861,
            226001871
        ],
        "B": [
            225998357,
            225944596,
            225961498,
            226022662,
            225970503,
            226048661,
            225965106,
            225956535,
            225974109,
            226024200,
            226979960,
            226057337,
            225972372,
            225968693,
            225962068,
            226040739,
            225981051,
            226047279,
            226046003,
            225948785
        ],
        "D": [
            225989950,
            226004287,
            225983656,
            225994935,
            225998958,
            226008015,
            225977564,
            226002115,
            225985427,
            226003081,
            225989658,
            226979804,
            225989175,
            226003010,
            226023529,
            226002830,
            226078484,
            226078353,
            226002716,
            226024255,
            226018418,
            226137164,
            225986804
        ],
        "E": [
            225973607,
            225981897,
            226000134,
            225978662,
            226074388,
            226073614,
            226073223,
            226072631,
            226071563,
            226069387,
            226068777,
            226021358,
            225958738,
            226070894,
            225983588,
            226039851,
            226021998,
            226007010,
            226979776,
            226006499,
            226036184,
            226038920,
            226053631,
            226068817,
            226063126,
            226059742,
            226057237
        ],
        "C": [
            225967620,
            225968755,
            225972644,
            225961410,
            225983858,
            225989707,
            225987635,
            225970993,
            225986658,
            225975231,
            226979908,
            225973609,
            225986638,
            225980254,
            225971024,
            227431342,
            225959672,
            225996237,
            225972869,
            226057682,
            225972171
        ],
        "A": [
            225936409,
            225922035,
            225921764,
            225934682,
            225931922,
            225937474,
            225923760,
            225922674,
            225923828,
            225922214,
            226979999,
            225944454,
            225937163,
            225922982,
            225921695,
            226083093,
            226083061,
            225937017,
            225941961,
            225925562,
            226022851,
            225923156
        ],
        "G": [
            226095099,
            226164597,
            226979660,
            226967841,
            230907178
        ]
    },
    "name": "E. Jellyfish and Hack",
    "statement": "It is well known that quick sort works by randomly selecting a ’pivot’\r\nelement from the array and partitioning the other elements into two\r\nsub-arrays, according to whether they are less than or greater than the\r\npivot. But Jellyfish thinks that choosing a random element is just a\r\nwaste of time, so she always chooses the first element to be the pivot.\r\nThe time her code needs to run can be calculated by the following\r\npseudocode:function fun(A) if A.length > 0 let L[1 ... L.length] and R[1\r\n... R.length] be new arrays L.length = R.length = 0 for i = 2 to\r\nA.length if A[i] < A[1] L.length = L.length + 1 L[L.length] = A[i] else\r\nR.length = R.length + 1 R[R.length] = A[i] return A.length + fun(L) +\r\nfun(R) else return 0Now you want to show her that her code is slow. When\r\nthe function\r\nmathrm{fun(A)} is greater than or equal to lim, her code will get\r\ntext{Time Limit Exceeded}. You want to know how many distinct\r\npermutations P of [1, 2,\r\ndots, n] satisfies\r\nmathrm{fun(P)}\r\ngeq lim. Because the answer may be large, you will only need to find the\r\nanswer modulo 10^9+7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7, mod = 1e9 + 7;\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N], ifac[N], inv[N];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) (mod - mod / i) * inv[mod % i] % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n} \nint C(int x, int y) {\n\treturn x < y || y < 0 ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\nint n, lim;\nint dp[N];\nvi solve(vi dc) { // for 0....n point \n\tint n = sz(dc) - 1; \n\tvi A(n + 2), B(n + 2);\n\tA[0] = 1;\n\tL(i, 0, n) {\n\t\tint W = (ll) ifac[i] * ifac[n - i] % mod * dc[i] % mod;\n\t\tif((n - i) & 1) W = mod - W;\n\t\tR(j, i, 0) (B[j + 1] += B[j]) %= mod, B[j] = (ll) B[j] * (mod - i) % mod;\n\t\tL(j, 0, i) (B[j] += (ll) A[j] * W % mod) %= mod; \n\t\tR(j, i, 0) (A[j + 1] += A[j]) %= mod, A[j] = (ll) A[j] * (mod - i) % mod;\n\t}\n\treturn B.resize(n + 1), B;\n}\n\nint pw[N];\nint main() {\n\tios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> lim;\n//\tn = 200, lim = 114514;\n\tinit(n * n + 2);\n\tint mx = n * (n + 1) / 2;\n\tvi dc(mx + 1);\n\tL(v, 0, mx) {\n\t\tpw[0] = 1;\n\t\tL(i, 1, n) {\n\t\t\tpw[i] = (ll) pw[i - 1] * v % mod;\n\t\t}\n\t\tdp[0] = 1;\n\t\tL(i, 1, n) {\n\t\t\tdp[i] = 0;\n\t\t\tL(j, 0, i - 1) {\n\t\t\t\t(dp[i] += (ll) dp[j] * dp[i - j - 1] % mod * C(i - 1, j) % mod) %= mod;\n\t\t\t}\n\t\t\tdp[i] = (ll) dp[i] * pw[i] % mod;\n\t\t}\n\t\tdc[v] = dp[n];\n\t}\n\tdc = solve(dc);\n//\tL(i, 0, mx) {\n//\t\tcout << dc[i] << ' ';\n//\t}\n//\tcout << endl;\n\t\n\tint ans = fac[n];\n\tL(i, 0, min(lim - 1, mx)) \n\t\t(ans += mod - dc[i]) %= mod;\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Jellyfish and Hack.json",
    "editorial_link": "https://codeforces.com//blog/entry/120943",
    "editorial": "TutorialFirstly, if , the answer will be . So we only need to solve the\r\nproblem which satisfies .We can use dynamic programming to solve the\r\nproblem:Letâs define means the number of the permutations of ,\r\nsatisfying .Since only relative rankings are useful, we have the\r\nfollowing transition: The time complexity is , because , how can it\r\nbecomes faster?FFT (Fast Fourier Transform) might come to mind first. If\r\nwe use FFT instead of enumerating , The time complexity will become .\r\nThis is not enough because is large and is not a modulus suitable for\r\nNTT (Number-theoretic Transform).Tips. Also, if you use divide and\r\nconquer and FFT, The time complexity will be , but because FFT have a\r\nbig constant factor, this still canât pass the problem.But we can do\r\nsomething similar to what the FFT does. We define , then we will have\r\nthe following transition: For all , The degree of wonât exceed . So if\r\nwe have points on , We can get by in time complexity using Lagrange\r\nInterpolation. The only thing we need to do is the dot product of the\r\nfunctions, so the time complexity of the transition is also .Time\r\ncomplexity: Memory complexity:\r\n",
    "hint": []
}