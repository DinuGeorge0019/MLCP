{"link": "https://codeforces.com//contest/115/problem/D", "problemId": "605", "problem_idx": "D", "shortId": "115D", "contest_number": "115", "problem_submissions": {"D": [700677, 709440, 703439, 700783], "E": [699985, 700148, 699895, 700886, 700709, 699935, 700481, 704109, 702223, 702118, 701045, 699830, 700560], "C": [698491, 698807, 698911, 698386, 699374, 701004, 698059, 699204, 699619, 699661, 702059], "B": [697429, 697289, 697881, 697365, 697647, 697668, 699366, 697349, 697691, 697537, 697907, 698287, 699705], "A": [696588, 696258, 695843, 695844, 696704, 696136, 696907, 695911, 696007, 696195, 695937, 696483, 695990]}, "name": "D. Unambiguous Arithmetic Expression", "statement": "Let\u2019s define an (UAE) as follows. All non-negative integers are UAE\u2019s.\r\nIntegers may have leading zeroes (for example, and are considered valid\r\nintegers). If and are two UAE\u2019s, then \"\", \"\", \"\", and \"\" (all without\r\nthe double quotes) are UAE\u2019s. If is an UAE, then \"\" and \"\" (both without\r\nthe double quotes) are UAE\u2019s.You are given a string consisting only of\r\ndigits (\"\" - \"\") and characters \"\", \"\", \"\", and \"\". Your task is to\r\ncompute the number of different possible unambiguous arithmetic\r\nexpressions such that if all brackets (characters \"\" and \"\") of that\r\nunambiguous arithmetic expression are removed, it becomes the input\r\nstring. Since the answer may be very large, print it modulo ().\r\n", "solutions": ["#include <iostream>\n\nusing namespace std;\n\nconst int md = 1000003;\n\nint f[2222][2222];\nint a[2222], x[2222], y[2222], st[2222];\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.length(), i, j, k;\n  for (i=0;i<n-1;i++)\n    if (s[i] < '0' || s[i] > '9')\n      if (s[i+1] == '*' || s[i+1] == '/') {\n        cout << 0 << endl;\n        return 0;\n      }\n  if (s[0] == '*' || s[0] == '/') {\n    cout << 0 << endl;\n    return 0;\n  }\n  int m = 0, t = 0;\n  for (i=0;i<n;i++)\n    if (s[i] < '0' || s[i] > '9') t++; else\n    if (t || i == 0) {\n      a[m] = t-1;\n      m++;\n      t = 0;\n    }\n  a[0]++;\n  if (t) {\n    cout << 0 << endl;\n    return 0;\n  }\n  n = 0;\n  for (i=0;i<m;i++) {\n    st[i] = n;\n    for (j=a[i];j>=0;j--) {\n      x[n] = i;\n      y[n] = j;\n      n++;\n    }\n  }\n  long long g;\n  for (i=n-1;i>=0;i--) {\n    f[i][x[i]] = 1;\n    for (j=x[i]+1;j<m;j++) {\n      if (y[i] > 0) f[i][j] = f[i+1][j];\n      else f[i][j] = 0;\n      g = 0;\n      for (k=x[i];k<j;k++) g += (long long)f[i][k]*f[st[k+1]][j];\n      f[i][j] = (f[i][j]+g) % md;\n    }\n  }\n  cout << f[0][m-1] << endl;\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "expression parsing"], "dificulty": "2600", "interactive": false}