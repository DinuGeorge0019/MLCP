{
    "link": "https://codeforces.com//contest/123/problem/D",
    "problemId": "655",
    "problem_idx": "D",
    "shortId": "123D",
    "contest_number": "123",
    "problem_submissions": {
        "E": [
            830840,
            831942,
            831247,
            1154341
        ],
        "C": [
            830171,
            829602,
            829696,
            830545,
            830265,
            830647,
            831072,
            830094,
            829962,
            833283,
            832903,
            833096
        ],
        "D": [
            829496,
            830812,
            1447203,
            829637,
            831873,
            1185562,
            836113,
            832570,
            831822,
            839081,
            831840,
            834715,
            834693,
            831236,
            831444,
            830484,
            833338,
            833314,
            833310,
            830603,
            830534,
            831043,
            833652,
            831461,
            831555,
            831382,
            831934
        ],
        "B": [
            828403,
            828703,
            828120,
            829057,
            828829,
            829690,
            829686,
            832376,
            828694,
            829613,
            829313,
            828996,
            829196,
            828023,
            828574,
            829940,
            829279
        ],
        "A": [
            827847,
            827523,
            827572,
            827701,
            827834,
            828726,
            828164,
            828031,
            832616,
            827887,
            828344,
            829843,
            828296,
            829771,
            827580,
            829074,
            828185
        ]
    },
    "name": "D. String",
    "statement": "You are given a string . Each pair of numbers and that fulfill the\r\ncondition , correspond to a substring of the string , starting in the\r\nposition and ending in the position (inclusive).Let’s define the\r\nfunction of two strings like this. We’ll find a list of such pairs of\r\nnumbers for which the corresponding substrings of string are equal to\r\nstring . Let’s sort this list of pairs according to the pair’s first\r\nnumber’s increasing. The value of function equals the number of\r\nnon-empty continuous sequences in the list.For example: . The list of\r\npairs is as follows:Its continuous sequences are: Your task is to\r\ncalculate for the given string the sum for all , that belongs to the set\r\nof all substrings of a string .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef vector<string> vstr;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void pvp(T a, T b) { for (T i = a; i != b; ++i) cout << \"(\" << i->first << \", \" << i->second << \") \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in_c() { int c; for (; (c = getchar()) <= ' '; ) { if (!~c) throw ~0; } return c; }\nint in() { int x = 0, c; for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -in(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10); return x; }\nInt In() { Int x = 0, c; for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -In(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10); return x; }\n\nnamespace SA {\n    #define MAXN 100010\n    int n;\n    char t[MAXN];\n    int ki[MAXN], ik[MAXN], is[MAXN], hh;\n    bool cmp(const int &a, const int &b) {\n        return (a == b) ? 0 : (ik[a] != ik[b]) ? (ik[a] < ik[b]) : (ik[a + hh] < ik[b + hh]);\n    }\n    void makeSA() {\n        n = strlen(t);\n        int i;\n        for (i = 0; i <= n; ++i) ik[ki[i] = i] = t[i];\n        is[0] = is[n] = hh = 0;\n        sort(ki, ki + n + 1, cmp);\n        for (hh = 1; is[n] != n; hh <<= 1) {\n            sort(ki, ki + n + 1, cmp);\n            for (i = 0; i < n; ++i) is[i + 1] = is[i] + (cmp(ki[i], ki[i + 1]) ? 1 : 0);\n            for (i = 0; i <= n; ++i) ik[ki[i]] = is[i];\n        }\n    }\n    int lcp[MAXN];\n    void makeHA() {\n        int h = 0, i, j;\n        for (i = 0; i < n; ++i) {\n            for (j = ki[ik[i] - 1]; t[j + h] == t[i + h]; ++h);\n            lcp[ik[i] - 1] = h;\n            if (h) --h;\n        }\n    }\n}\n\nInt score(Int x) { return x * (x - 1) / 2; }\nint uf[MAXN];\nInt as[MAXN];\nInt now;\n\nint root(int x) { return (uf[x] < 0) ? x : (uf[x] = root(uf[x])); }\nbool conn(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return 0;\n    if (uf[x] > uf[y]) swap(x, y);\n    now -= score(as[x]) + score(as[y]);\n    uf[x] += uf[y]; uf[y] = x;\n    as[x] += as[y];\n    now += score(as[x]);\n    return 1;\n}\n\nint N;\nint A[MAXN];\npint ps[MAXN];\n\nint main() {\n    int i, k;\n    \n    for (; ~scanf(\"%s\", SA::t); ) {\n        SA::makeSA();\n        SA::makeHA();\n        N = SA::n;\n        for (i = 0; i < N; ++i) {\n            A[i] = SA::lcp[i];\n        }\n//cout<<\"A : \";pv(A,A+N);\n        for (i = 0; i < N; ++i) {\n            ps[i] = mp(A[i], i);\n        }\n        sort(ps, ps + N, greater<pint>());\n        Int ans = (Int)N * (N + 1) / 2;\n        for (i = 0; i <= N; ++i) {\n            as[i] = 1;\n            uf[i] = -1;\n        }\n        now = 0;\n        for (i = 0, k = N; k > 0; --k) {\n            for (; i < N && ps[i].first == k; ++i) {\n                conn(ps[i].second, ps[i].second + 1);\n            }\n//cout<<\"uf : \";pv(uf,uf+N+1);\n//cout<<\"now = \"<<now<<endl;\n            ans += now;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n    "
    ],
    "input": "",
    "output": "",
    "tags": [
        "string suffix structures"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. String.json",
    "editorial_link": "https://codeforces.com//blog/entry/3047",
    "editorial": "Sort all suffixes of the string (denoted by an array of strings ci). Then the answer to the problem is the amount of 1???i???j???|s| and 1???k, that the prefixes of length k in all ci..j are equal. Options when i?=?j, and 1???k???|ci| can calculate at once, it is the number of substrings in the string, ie |s|?*?(|s|?+?1)?/?2. Now let's count the LCP (longest common prefix) for adjacent suffixes, ie ai?=?LCP(ci,?ci?+?1) for 1???i?<?|s|. Then let's count the number of 1???i???j?<?|s| and 1???k, that k???min(ai..j). This task is to count the number of rectangles if there is a limit to the height of each column, ie ai the maximum height of the rectangle in the column i. Solve by a stack or list.",
    "hint": []
}