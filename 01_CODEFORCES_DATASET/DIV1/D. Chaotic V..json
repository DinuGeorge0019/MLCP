{
    "link": "https://codeforces.com//contest/1292/problem/D",
    "problemId": "519779",
    "problem_idx": "D",
    "shortId": "1292D",
    "contest_number": "1292",
    "problem_submissions": {
        "F": [
            69140685,
            69148403,
            71814085,
            71814062,
            71813990,
            70217605,
            69197847,
            69495748,
            71223361
        ],
        "D": [
            69122533,
            69114171,
            69256713,
            69123417,
            69126885,
            69163995,
            69128025,
            69127012,
            69131460,
            69130080,
            69130342,
            69128215,
            69129378,
            69133922,
            69131233,
            69132965,
            69132809,
            69134434,
            69132903,
            69127292,
            69140744,
            69136786
        ],
        "C": [
            69113617,
            69117304,
            69112958,
            69113829,
            69164607,
            69112261,
            69111227,
            69113942,
            69113564,
            69116428,
            69114170,
            69121126,
            69118602,
            69121886,
            69119931,
            69117602,
            69119253,
            69121231,
            69130721,
            69112217,
            69119945
        ],
        "B": [
            69102431,
            69100917,
            69105559,
            69104060,
            69164579,
            69104349,
            69103131,
            69105348,
            69102973,
            69106424,
            69106338,
            69108218,
            69106515,
            69110303,
            69110995,
            69110488,
            69109887,
            69114588,
            69102534,
            69105217,
            69108444
        ],
        "A": [
            69100122,
            69100064,
            69101788,
            69100300,
            69164572,
            69100144,
            69100129,
            69100151,
            69100251,
            69100494,
            69100278,
            69100280,
            69100245,
            69101280,
            69102544,
            69101036,
            69101104,
            69100156,
            69100106,
            69100348,
            69100678
        ],
        "E": [
            69145246,
            69152430,
            69165289,
            69151098,
            69168995,
            69165203,
            69152318,
            69162582,
            69185344
        ]
    },
    "name": "D. Chaotic V.",
    "statement": "The emotion samples are now sufficient. After almost 3 years, it’s time\r\nfor Ivy to awake her bonded sister, Vanessa.The system inside A.R.C.’s\r\nLibrary core can be considered as an undirected graph with infinite\r\nnumber of processing nodes, numbered with all positive integers (1, 2,\r\n3,\r\nldots). The node with a number x (x > 1), is directly connected with a\r\nnode with number\r\nfrac{x}{f(x)}, with f(x) being the lowest prime divisor of x.Vanessa’s\r\nmind is divided into n fragments. Due to more than 500 years of coma,\r\nthe fragments have been scattered: the i-th fragment is now located at\r\nthe node with a number k_i! (a factorial of k_i).To maximize the chance\r\nof successful awakening, Ivy decides to place the samples in a node P,\r\nso that the total length of paths from each fragment to P is smallest\r\npossible. If there are multiple fragments located at the same node, the\r\npath from that node to P needs to be counted multiple times.In the world\r\nof zeros and ones, such a requirement is very simple for Ivy. Not longer\r\nthan a second later, she has already figured out such a node.But for a\r\nmere human like you, is this still possible?For simplicity, please\r\nanswer the minimal sum of paths’ lengths from every fragment to the\r\nemotion samples’ assembly node P.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 5003;\nconst int M = 1001;\nint d[N];\nint pr[M];\nint m;\nint a[N][M];\nint b[N][M];\nint cnt[N];\nll curAns;\n\nvoid precalc() {\n\tm = 1;\n\tfor (int x = 2; x < N; x++) {\n\t\tif (d[x] != 0) continue;\n\t\tpr[m] = x;\n\t\tfor (int y = x; y < N; y += x)\n\t\t\td[y] = m;\n\t\tm++;\n\t}\n\tfor (int x = 2; x < N; x++) {\n\t\tint z = x;\n\t\twhile(z > 1) {\n\t\t\ta[x][d[z]]++;\n\t\t\tz /= pr[d[z]];\n\t\t}\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\ta[x][i] += a[x - 1][i];\n\t}\n\tfor (int x = 1; x < N; x++) {\n\t\tb[x][m] = 0;\n\t\tfor (int i = m - 1; i >= 0; i--)\n\t\t\tb[x][i] = b[x][i + 1] + a[x][i];\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tprecalc();\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (x == 0) x = 1;\n\t\tcnt[x]++;\n\t}\n\n\tcurAns = 0;\n\tfor (int x = 1; x < N; x++)\n\t\tcurAns += (ll)b[x][0] * cnt[x];\n\n\tint curP = m - 1;\n\tint curH = 0;\n\tint sumH = 0;\n\twhile(curP >= 0) {\n\t\tint tot = 0;\n\t\tint nextH = (int)1e9;\n\t\tfor (int x = 1; x < N; x++) {\n\t\t\tif (cnt[x] == 0) continue;\n\t\t\tif (b[x][curP + 1] != sumH || a[x][curP] <= curH) continue;\n\t\t\ttot += cnt[x];\n\t\t\tnextH = min(nextH, a[x][curP]);\n\t\t}\n\t\tif (2 * tot > n) {\n\t\t\tcurAns -= (ll)(2 * tot - n) * (nextH - curH);\n\t\t\tcurH = nextH;\n\t\t} else {\n\t\t\tsumH += curH;\n\t\t\tcurH = 0;\n\t\t\tcurP--;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", curAns);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "greedy",
        "math",
        "number theory",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Chaotic V..json",
    "editorial_link": "https://codeforces.com//blog/entry/73051",
    "editorial": "First of all, one can see that the network is a tree rooted at vertex ,\r\nthus for each pair of vertices in it there can only be one simple\r\npath.Also, the assembly node must be on at least one simple path of a\r\nfragment to the root (proof by contradiction, explicit solution is\r\ntrivial).Letâs start with being node .From here, moving down to any\r\nbranch will increase for each element not being in that branch and\r\ndecrease for each element being in, thus weâll only move down to the\r\nbranch having the most elements until the decreasing cannot outmatch the\r\nincreasing (in other words, the number of fragments in a branch must be\r\nmore than half for that branch to be reached).Given the criteria of the\r\ngraph, we can see that: two nodes are in the same branch from the root\r\nif having the same one largest factor from the prime factorization, they\r\nare in the same branch from a depth-1-node if having the same two\r\nlargest factors, ..., in the same branch from a depthânode if having the\r\nsame largest factors.Keep in mind that here the largest factors can be\r\nthe duplicated, i.e. in the case of , the two largest factors are and ,\r\nand the three largest factors are , and .The process will now become\r\nfactorizing the numbers, and then, cycle by cycle, pop the current\r\nlargest factor of each number and group them, find out the group\r\n(branch) with most occurences and either move on (if the total sum can\r\nbe lowered) or stop the process.Since all of these are factorials, the\r\nfactorizing can be done with a bottom-up dynamic programming\r\nfashion.Also, as and , consider grouping duplicated elements to reduce\r\ncalculating complexity.Both factorization and processing has the\r\nworst-case complexity of , with being the estimated quantity of prime\r\ndivisors of .Itâs proven that , with being the Meissel-Mertens\r\nconstant.The proof of this formula is based on the fact this number is\r\ncalculated through the sum of the reciprocals of the primes.\r\n",
    "hint": []
}