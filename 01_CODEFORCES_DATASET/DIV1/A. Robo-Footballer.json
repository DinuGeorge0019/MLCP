{"link": "https://codeforces.com//contest/249/problem/A", "problemId": "2270", "problem_idx": "A", "shortId": "249A", "contest_number": "249", "problem_submissions": {"B": [2649094, 2645222, 2648325, 2645133, 2741637, 2647160, 2646906, 2647140, 2647297, 2647803, 2649557, 2647782, 2649225, 2647984], "C": [2648016, 2646272, 2649752, 2649594, 2648682, 2650241, 2650113], "D": [2646289, 2646128, 2648091, 2747311, 2647914, 2649873, 2686963, 3563620], "A": [2645128, 2644427, 2643471, 2646603, 2643981, 2650080, 2644186, 2645243, 2644193, 2644672, 2644232, 2644059, 2650955, 2650931, 2645477, 2644588, 2644531], "E": [2649181, 2648187, 2749553, 2893989]}, "name": "A. Robo-Footballer", "statement": "It\u2019s a beautiful April day and Wallace is playing football with his\r\nfriends. But his friends do not know that Wallace actually stayed home\r\nwith Gromit and sent them his robotic self instead. Robo-Wallace has\r\nseveral advantages over the other guys. For example, he can hit the ball\r\ndirectly to the specified point. And yet, the notion of a giveaway is\r\nforeign to him. The combination of these features makes the Robo-Wallace\r\nthe perfect footballer as soon as the ball gets to him, he can just aim\r\nand hit the goal. He followed this tactics in the first half of the\r\nmatch, but he hit the goal rarely. The opposing team has a very good\r\ngoalkeeper who catches most of the balls that fly directly into the\r\ngoal. But Robo-Wallace is a quick thinker, he realized that he can cheat\r\nthe goalkeeper. After all, they are playing in a football box with solid\r\nwalls. Robo-Wallace can kick the ball to the other side, then the\r\ngoalkeeper will not try to catch the ball. Then, if the ball bounces off\r\nthe wall and flies into the goal, the goal will at last be scored.Your\r\ntask is to help Robo-Wallace to detect a spot on the wall of the\r\nfootball box, to which the robot should kick the ball, so that the ball\r\nbounces once and only once off this wall and goes straight to the goal.\r\nIn the first half of the match Robo-Wallace got a ball in the head and\r\nwas severely hit. As a result, some of the schemes have been damaged.\r\nBecause of the damage, Robo-Wallace can only aim to his right wall\r\n(Robo-Wallace is standing with his face to the opposing team\u2019s goal).The\r\nfootball box is rectangular. Let\u2019s introduce a two-dimensional\r\ncoordinate system so that point (, ) lies in the lower left corner of\r\nthe field, if you look at the box above. Robo-Wallace is playing for the\r\nteam, whose goal is to the right. It is an improvised football field, so\r\nthe gate of Robo-Wallace\u2019s rivals may be not in the middle of the left\r\nwall. In the given coordinate system you are given: , the -coordinates\r\nof the side pillars of the goalposts of robo-Wallace\u2019s opponents; the\r\n-coordinate of the wall to which Robo-Wallace is aiming; , the\r\ncoordinates of the ball\u2019s position when it is hit; the radius of the\r\nball. A goal is scored when the center of the ball crosses the axis in\r\nthe given coordinate system between (, ) and (, ). The ball moves along\r\na straight line. The ball\u2019s hit on the wall is perfectly elastic (the\r\nball does not shrink from the hit), the angle of incidence equals the\r\nangle of reflection. If the ball bounces off the wall not to the goal,\r\nthat is, if it hits the other wall or the goal post, then the opposing\r\nteam catches the ball and Robo-Wallace starts looking for miscalculation\r\nand gets dysfunctional. Such an outcome, if possible, should be avoided.\r\nWe assume that the ball touches an object, if the distance from the\r\ncenter of the ball to the object is no greater than the ball radius .\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1e-9;\n\nstruct line {\n  double a, b, c;\n  line(double x1, double y1, double x2, double y2) {\n    a = y2 - y1;\n    b = x1 - x2;\n    c = -a * x1 - b * y1;\n    double d = sqrt(a * a + b * b);\n    a /= d;\n    b /= d;\n    c /= d;\n  }\n  double getd(double x, double y) { return fabs(a * x + b * y + c); }\n};\n\nint main() {\n  #ifdef DEBUG\n  freopen(\"std.in\", \"r\", stdin);\n  freopen(\"std.out\", \"w\", stdout);\n  #endif\n\n  double y1, y2, ywall, xst, yst, r;\n  while (scanf(\"%lf%lf%lf%lf%lf%lf\", &y1, &y2, &ywall, &xst, &yst, &r) >= 1) {\n    ywall -= r;\n    double ytarg = 2 * ywall - (y1 + r + 1.01e-8);\n\n    line l(xst, yst, 0, ytarg);\n    double d = l.getd(0, 2 * ywall - y2);\n    if (d <= r + EPS)\n      printf(\"-1\\n\");\n    else {\n      double xans = xst - xst * (ywall - yst) / (ytarg - yst);\n      double tmp = ywall - (ywall - yst) * xans / (xst - xans);\n      eprintf(\"%.18lf\\n\", tmp);\n      printf(\"%.18e\\n\", xans);\n    }\n  }\n  return 0;\n}\n\n"], "input": "", "output": "", "tags": ["geometry"], "dificulty": "2000", "interactive": false}