{
    "link": "https://codeforces.com//contest/329/problem/B",
    "problemId": "3355",
    "problem_idx": "B",
    "shortId": "329B",
    "contest_number": "329",
    "problem_submissions": {
        "D": [
            4118984,
            4120313,
            4119660,
            4116785,
            4117605,
            4120902,
            4120215,
            4118708,
            4120010,
            4137748,
            4119968,
            4119996,
            4119672,
            4121809
        ],
        "C": [
            4117113,
            4117558,
            4116367,
            4121523,
            4143349,
            4121550,
            4117988,
            4118184,
            4122060,
            4117812,
            4137746,
            4121987,
            4121389,
            4120201,
            4115159,
            4117962,
            4119458,
            4118596
        ],
        "B": [
            4114305,
            4114368,
            4113665,
            4115021,
            4115525,
            4115412,
            4114479,
            4114580,
            4118395,
            4137745,
            4114685,
            4117097,
            4121085,
            4123377,
            4114997,
            4115233,
            4115579
        ],
        "A": [
            4112796,
            4112854,
            4120598,
            4113396,
            4112888,
            4113555,
            4112601,
            4113197,
            4113479,
            4137744,
            4112411,
            4113271,
            4115572,
            4112548,
            4113837,
            4113786,
            4113898
        ],
        "E": [
            4137719
        ]
    },
    "name": "B. Biridian Forest",
    "statement": "You\u2019re a mikemon breeder currently in the middle of your journey to\r\nbecome a mikemon master. Your current obstacle is go through the\r\ninfamous Biridian Forest.The Biridian Forest is a two-dimensional grid\r\nconsisting of rows and columns. Each cell in Biridian Forest may contain\r\na tree, or may be vacant. A vacant cell may be occupied by zero or more\r\nmikemon breeders (there may also be breeders other than you in the\r\nforest). Mikemon breeders (including you) cannot enter cells with trees.\r\nOne of the cells is designated as the exit cell.The initial grid,\r\nincluding your initial position, the exit cell, and the initial\r\npositions of all other breeders, will be given to you. Here\u2019s an example\r\nof such grid (from the first example): Breeders (including you) may move\r\nin the forest. In a single move, breeders may perform one of the\r\nfollowing actions: Do nothing. Move from the current cell to one of the\r\nfour adjacent cells (two cells are adjacent if they share a side). Note\r\nthat breeders cannot enter cells with trees. If you are located on the\r\nexit cell, you may leave the forest. Only you can perform this move all\r\nother mikemon breeders will never leave the forest by using this type of\r\nmovement. After each time you make a single move, each of the other\r\nbreeders simultaneously make a single move (the choice of which move to\r\nmake may be different for each of the breeders).If you and mikemon\r\nbreeders are located on the same cell, exactly mikemon battles will\r\nensue that time (since you will be battling each of those breeders\r\nonce). After the battle, all of those breeders will leave the forest to\r\nheal their respective mikemons.Note that the moment you leave the\r\nforest, no more mikemon battles can ensue, even if another mikemon\r\nbreeder move to the exit cell immediately after that. Also note that a\r\nbattle only happens between you and another breeders there will be no\r\nbattle between two other breeders (there may be multiple breeders\r\ncoexisting in a single cell).You would like to leave the forest. In\r\norder to do so, you have to make a sequence of moves, ending with a move\r\nof the final type. Before you make any move, however, you post this\r\nsequence on your personal virtual idol Blog. Then, you will follow this\r\nsequence of moves faithfully.Because you post the sequence in your Blog,\r\nthe other breeders will all know your exact sequence of moves even\r\nbefore you make your first move. All of them will move in such way that\r\nwill guarantee a mikemon battle with you, if possible. The breeders that\r\ncouldn\u2019t battle you will do nothing.Print the minimum number of mikemon\r\nbattles that you must participate in, assuming that you pick the\r\nsequence of moves that minimize this number. Note that you are not\r\nrequired to minimize the number of moves you make.\r\n",
    "solutions": [
        "/*\nID: espr1t\nTASK: \nKEYWORDS: \n*/\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <cctype>\n\nusing namespace std;\nFILE *in; FILE *out;\n\nconst int MAX = 1024;\nconst int INF = 1000000001;\n\nint n, m;\nchar a[MAX][MAX];\nint dist[MAX][MAX];\nint dir[4][2] = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };\n\nvoid bfs(int row, int col) {\n    memset(dist, 63, sizeof(dist));\n    queue < pair <int, int> > q;\n    q.push(make_pair(row, col));\n    dist[row][col] = 0;\n    while (!q.empty()) {\n        row = q.front().first;\n        col = q.front().second;\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int nrow = row + dir[i][0]; if (nrow < 0 || nrow >= n) continue;\n            int ncol = col + dir[i][1]; if (ncol < 0 || ncol >= m) continue;\n            if (a[nrow][ncol] == 'T')\n                continue;\n            if (dist[row][col] + 1 < dist[nrow][ncol]) {\n                dist[nrow][ncol] = dist[row][col] + 1;\n                q.push(make_pair(nrow, ncol));\n            }\n        }\n    }\n}\n\n\nint main(void) {\n\tin = stdin; out = stdout;\n//\tin = fopen(\"B.in\", \"rt\"); out = fopen(\"B.out\", \"wt\");\n\t\n\tfscanf(in, \"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t    fscanf(in, \"%s\", a[i]);\n\t\n\tint srow = -1, scol = -1;\n\tfor (int i = 0; i < n; i++) {\n\t    for (int c = 0; c < m; c++) {\n\t        if (a[i][c] == 'E') {\n\t            srow = i;\n\t            scol = c;\n\t            a[i][c] = '0';\n\t            break;\n\t        }\n\t    }\n\t    if (srow != -1 || scol != -1)\n\t        break;\n\t}\n\tbfs(srow, scol);\n\t\n\tint len = INF;\n\tfor (int i = 0; i < n; i++)\n\t    for (int c = 0; c < m; c++)\n\t        if (a[i][c] == 'S') len = dist[i][c], a[i][c] = '0';\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t    for (int c = 0; c < m; c++) {\n\t        if (isdigit(a[i][c]) && dist[i][c] <= len)\n\t            ans += a[i][c] - '0';\n\t    }\n\t}\n\tfprintf(out, \"%d\\n\", ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "shortest paths"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Biridian Forest.json",
    "editorial_link": "https://codeforces.com//blog/entry/8417",
    "editorial": "The only non ad hoc problem in the round! ...sort of. Despite the very\r\nlong problem statement, the solution is really simple. Thoughts I tried\r\nto make this clearer by separating the paragraphs by topic. Did it work\r\nwell? Btw, mikemon is pronounced \"mi-ke-mon\", not \"mike\"-mon \u00e2\u0080\u0093 similar\r\nto how Pokemon is pronounced \"po-ke-mon\" not \"poke\"-mon >:).\r\n"
}