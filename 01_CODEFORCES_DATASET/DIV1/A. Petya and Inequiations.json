{
    "link": "https://codeforces.com//contest/111/problem/A",
    "problemId": "582",
    "problem_idx": "A",
    "shortId": "111A",
    "contest_number": "111",
    "problem_submissions": {
        "D": [
            662767,
            662482,
            660714,
            662088,
            661622,
            661475,
            663213,
            662999,
            665139,
            663475,
            663580,
            663102,
            662156,
            662688,
            662062,
            663791,
            664321,
            664054,
            663134
        ],
        "C": [
            661017,
            660823,
            662136,
            659868,
            659913,
            660005,
            659563,
            660967,
            661428,
            660790,
            660974,
            661489,
            661410,
            663647,
            661449,
            661359,
            661322,
            659593
        ],
        "B": [
            658508,
            658276,
            660241,
            658067,
            658492,
            662345,
            658611,
            659356,
            658769,
            658223,
            658207,
            662686,
            663419,
            662647,
            660010,
            659052,
            661996,
            664110
        ],
        "A": [
            657728,
            657568,
            657631,
            658791,
            657382,
            657971,
            657490,
            657859,
            657378,
            659022,
            657338,
            658706,
            657670,
            657472,
            659525,
            659462,
            664166
        ]
    },
    "name": "A. Petya and Inequiations",
    "statement": "Little Petya loves inequations. Help him find positive integers , such\r\nthat the following two conditions are satisfied:\r\n",
    "solutions": [
        "// Authored by dolphinigle\n// CodeForces 83\n// 3 Sep 2011\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n\n#define FORN(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define DEBUG(x) cout << '>' << #x << ':' << x << '\\n';\n\n#define REP(X,Y,Z) for (int (X) = (Y);(X) < (Z);++(X))\n#define RESET(Z,Y) memset(Z,Y,sizeof(Z))\n\n#define SZ(Z) ((int)Z.size())\n#define ALL(W) W.begin(), W.end()\n#define PB push_back\n\n#define MP make_pair\n#define A first\n#define B second\n\n#define INF 1023123123\n#define EPS 1e-11\n\n#define MX(Z,Y) Z = max((Z),(Y))\n#define MN(X,Y) X = min((X),(Y))\n\n#define FORIT(X,Y) for(typeof((Y).begin()) X = (Y).begin();X!=(Y).end();X++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\n\nint main() {\n\n  ll n, x, y;\n  cin >> n >> x >> y;\n  FORN(i, n) {\n    if (i < n-1) {\n      --y;\n      --x;\n      if (y < 0LL) {\n        cout << -1 << endl;\n        return 0;\n      }\n    } else {\n      if (y <= 0LL) {\n        cout << -1 << endl;\n        return 0;\n      }\n      x -= y*y;\n      if (x > 0LL) {\n        cout << -1 << endl;\n        return 0;\n      }\n      FORN(j, n-1) {\n        printf(\"1\\n\");\n      }\n      cout << y << endl;\n      return 0;\n    }\n  }\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Petya and Inequiations.json",
    "editorial_link": "https://codeforces.com//blog/entry/2616",
    "editorial": "It is easy to see that in order to maximize the sum of squares, one should make all numbers except the first one equal to 1 and maximize the first number. Keeping this in mind we only need to check whether the given value of y is large enough to satisfy a restriction that all n numbers are positive. If y is not to small, then all we need is to ensure that x???1?+?1?+?Â…?+?(y?-?(n?-?1))2",
    "hint": []
}