{
    "link": "https://codeforces.com//contest/1034/problem/E",
    "problemId": "222954",
    "problem_idx": "E",
    "shortId": "1034E",
    "contest_number": "1034",
    "problem_submissions": {
        "E": [
            43279785,
            43212413,
            43229978,
            43294521,
            43208696,
            43220993,
            84865485,
            43443164,
            43443120,
            43443018,
            43216190
        ],
        "D": [
            43250433,
            43221298,
            43215071,
            43392001,
            47789625
        ],
        "B": [
            43205891,
            43195267,
            43193943,
            43195031,
            43196760,
            43197157,
            43191231,
            43195573,
            43213572,
            43195172,
            43208923,
            43193201,
            43202069,
            43195780,
            43197206,
            43192315,
            43197387,
            43207849,
            43201323,
            43198501
        ],
        "C": [
            43201825,
            43200815,
            43202708,
            43202190,
            43201916,
            43202773,
            43198929,
            43200220,
            43198793,
            43202127,
            43201792,
            43209061,
            43203518,
            43208155,
            43197731,
            43206185,
            43207426
        ],
        "A": [
            43186061,
            43219248,
            43187942,
            43187082,
            43188745,
            43197770,
            43193324,
            43188028,
            43186801,
            43186422,
            43193256,
            43186588,
            43188667,
            43226991,
            43226928,
            43187156,
            43187973,
            43187877,
            43186866,
            43188894,
            43192595
        ]
    },
    "name": "E. Little C Loves 3 III",
    "statement": "Little C loves number very much. He loves all things about it.Now he is\r\ninterested in the following problem:There are two arrays of 2^n\r\nintergers a_0,a_1,...,a_{2^n-1} and b_0,b_1,...,b_{2^n-1}.The task is\r\nfor each i (0\r\nleq i\r\nleq 2^n-1), to calculate c_i=\r\nsum a_j\r\ncdot b_k (j|k=i and j\r\n&k=0, where \"|\" denotes bitwise or operation and \"\r\n&\" denotes bitwise and operation).It’s amazing that it can be proved\r\nthat there are exactly 3^n triples (i,j,k), such that j|k=i, j\r\n&k=0 and 0\r\nleq i,j,k\r\nleq 2^n-1. So Little C wants to solve this excellent problem (because\r\nit’s well related to 3) excellently.Help him calculate all c_i. Little C\r\nloves 3 very much, so he only want to know each c_i\r\n& 3.\r\n",
    "solutions": [
        "#include<cstdio>\ntypedef unsigned long long ull;\nint n,pc[1<<21];\nchar a[1<<21|1],b[1<<21|1];\null f[1<<21],g[1<<21];\nvoid fmt(ull*f){\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<1<<n;j++)if(!(j>>i&1))f[j+(1<<i)]+=f[j];\n}\nvoid ifmt(ull*f){\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<1<<n;j++)if(!(j>>i&1))f[j+(1<<i)]-=f[j];\n}\nint main(){\n\tscanf(\"%d%s%s\",&n,a,b);\n\tfor(int i=0;i<1<<n;i++){\n\t\ta[i]-='0',b[i]-='0';\n\t\tpc[i]=i?pc[i&i-1]+1:0;\n\t\tf[i]=a[i]*1ull<<pc[i]*2;\n\t\tg[i]=b[i]*1ull<<pc[i]*2;\n\t}\n\tfmt(f);\n\tfmt(g);\n\tfor(int i=0;i<1<<n;i++)f[i]*=g[i];\n\tifmt(f);\n\tfor(int i=0;i<1<<n;i++){\n\t\tint t=f[i]>>pc[i]*2&3;\n\t\tputchar('0'+t);\n\t}\n\tputs(\"\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "math"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Little C Loves 3 III.json",
    "editorial_link": "https://codeforces.com//blog/entry/61993",
    "editorial": "SolutionIf we only need to calculate (), we can do these: Let (). Let ,\r\nit can be found that (). So ( and ). To calculate fast ( is the same),\r\nlet be the sum of which and the lower binary bits of is equal to âs.So ,\r\nif , if , and .We can calculate all and in time.Getting from is the\r\ninversion of getting from . So we can use once again. if , if . So we\r\ncan get all in total time.But in this problem we need to calculate ( and\r\n).In fact, there is a well-known algorithm for this problem.The main\r\nidea of this algorithm is consider the number of \"\" binary bits.First,\r\nlet be the number of \"\" binary bits in .Let ( and ).Then we calculate\r\n(), and ( and ).So ( and ).Finally we need to calculate is equal to ,\r\nbecause if and , must be .This algorithm cost time. Unfortunately, it\r\nmay be too slow in this problem.In this problem, we only need to\r\ncalculate , equal to modulo .In fact, when the answer is modulo , an\r\narbitrary integer, my solution works.Let .Then we calculate , and ( and\r\n).So ().If , . If and , .We find that , because if , can be divided by\r\n.So the total time is .A remainder problem is it can not be modulo when\r\ncalculating in this algorithm, so the number may be very\r\nlarge.Fortunately, in this problem, is only . We can use 128-bit\r\nintegers or merge two 64-bit integers into one number when\r\ncalculating.But in fact, we only care modulo , so we can let all number\r\nbe modulo . Single 64-bit integer is enough. How to come up with it?In\r\nfact, I did not come up with this solution directly.When I learnt about\r\nFast Walsh Hadamard transform, I could not understand it well but came\r\nup with it:Letâs define a transform about a pair of integers to be , and\r\ndefine to be .According to FWT, there is such a transform satisfies ,\r\nwhich , .Then we can solve an equation to get ! After calculating, I get\r\n, and , which is close to FWT!Then I find that if , there is no the\r\ninversion of this transform, so we can not get from .If we do this\r\ntransform for all the bits, itâs actually FWT!So we can use this method\r\nto solve bitwise xor convolution, and bitwise or convolution is similar,\r\nwhat about subset convolution?After calculating, I get or , or , , which\r\nmade me disappointed because itâs difficult to find the inversion.But at\r\nthis time, I came up with a special idea if we calculate in modulo ,\r\nsatisfied.Let , , , . We finally get a transform, which is actually my\r\nsolution above!And Iâm really interested about how the others (such as\r\nnikanqilaizhenhaoxiao and onsecutivelimit) came up with it?\r\n",
    "hint": []
}