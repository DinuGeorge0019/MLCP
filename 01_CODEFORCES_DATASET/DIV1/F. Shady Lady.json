{"link": "https://codeforces.com//contest/1045/problem/F", "problemId": "223468", "problem_idx": "F", "shortId": "1045F", "contest_number": "1045", "problem_submissions": {"E": [43261410, 43577517], "J": [43258702, 43260133, 43575980, 43263093, 43266033], "A": [43255060, 43256216, 43263322, 43263783, 43258806, 43275613], "D": [43251490, 43264794, 43257475, 43253807, 43257410, 43253327, 43248880], "C": [43250229, 43244156, 43255852, 43252661, 43258515, 43251235, 43259397], "G": [43247867, 43248087, 43251069, 43250948, 43255077, 43249900, 43251360], "H": [43246289, 43252595, 43260022, 43258468, 43261064, 43264435, 43263084], "B": [43243648, 43248788, 43247063, 43264324, 43264189, 43246587, 43256450, 43248333, 43254638], "I": [43243009, 43244706, 43243112, 43242671, 43255452, 43243089, 43243594], "F": [43577952]}, "name": "F. Shady Lady", "statement": "Ani and Borna are playing a short game on a two-variable polynomial.\r\nIt\u2019s a special kind of a polynomial: the monomials are fixed, but all of\r\nits coefficients are fill-in-the-blanks dashes, e.g.\r\n_ xy +\r\n_ x^4 y^7 +\r\n_ x^8 y^3 +\r\nldots Borna will fill in the blanks with positive integers. He wants the\r\npolynomial to be , i.e. his goal is to make sure there exists a real\r\nnumber M such that the value of the polynomial at any point is greater\r\nthan M. Ani is mischievous, and wants the polynomial to be unbounded.\r\nAlong with stealing Borna\u2019s heart, she can also steal parts of\r\npolynomials. Ani is only a petty kind of thief, though: she can only\r\nsteal monomial from the polynomial before Borna fills in the blanks. If\r\nAni and Borna play their only moves optimally, who wins?\r\n", "solutions": ["#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200000;\n\nstruct P { int x,y,id; P() {} P(int x,int y):x(x),y(y),id(-1) {} };\nbool operator<(const P &a,const P &b) { if(a.x!=b.x) return a.x<b.x; return a.y<b.y; }\nP operator-(const P &a,const P &b) { return P(a.x-b.x,a.y-b.y); }\nll operator^(const P &a,const P &b) { return (ll)a.x*b.y-(ll)a.y*b.x; }\nll side(const P &a,const P &b,const P &c) { return (b-a)^(c-a); }\n\nint no;\nP o[MAXN];\n\nint np;\nP p[MAXN+1];\nbool killed[MAXN+1];\n\nint nh;\nP h[MAXN+2];\n\nint lst[MAXN+1],nlst;\n\nvoid makehull() { // assumes sorted\n\tnh=0; assert(!killed[0]); h[nh++]=p[0]; int tmp,last=-1;\n\ttmp=nh; FOR(i,1,np) if(!killed[i]) { while(nh>tmp&&side(h[nh-2],h[nh-1],p[i])<=0) --nh; h[nh++]=p[i]; last=i; }\n\ttmp=nh; for(int i=last-1;i>=0;--i) if(!killed[i]) { while(nh>tmp&&side(h[nh-2],h[nh-1],p[i])<=0) --nh; h[nh++]=p[i]; }\n\t--nh;\n}\n\nbool solve() {\n\tno=np; REP(i,np) o[i]=p[i];\n\t\n\tp[np++]=P(0,0);\n\tsort(p,p+np);\n\tREP(i,np) p[i].id=i;\n\tREP(i,np) killed[i]=false;\n\tmakehull();\n\tREP(i,nh) if(h[i].x%2==1||h[i].y%2==1) return true;\n\n\tnlst=nh; REP(i,nh) lst[i]=h[i].id;\n\tFORE(off,1,2) {\n\t\tREP(i,np) killed[i]=false; for(int i=off;i<nlst;i+=2) killed[lst[i]]=true;\n\t\tmakehull();\n\t\tREP(i,nh) if(h[i].x%2==1||h[i].y%2==1) return true;\n\t}\n\treturn false;\n}\n\nvoid run() {\n\tscanf(\"%d\",&np);\n\tREP(i,np) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\tprintf(\"%s\\n\",solve()?\"Ani\":\"Borna\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["geometry", "math"], "dificulty": "3400", "interactive": false}