{
    "link": "https://codeforces.com//contest/763/problem/A",
    "problemId": "91409",
    "problem_idx": "A",
    "shortId": "763A",
    "contest_number": "763",
    "problem_submissions": {
        "D": [
            24392378,
            24392196,
            24381252,
            24386512,
            24392124,
            24394387,
            24386765,
            24382498,
            24486986,
            24394269,
            24386191,
            24424544,
            24380258,
            24380559
        ],
        "E": [
            24383804,
            24379798,
            24382054,
            24377568,
            24385205,
            24385996,
            24385356,
            24380328,
            24382103,
            24378328,
            24383177,
            24384291,
            24383316,
            24383261,
            26602690,
            26602470
        ],
        "A": [
            24374208,
            24365694,
            24369536,
            24379218,
            24368162,
            24370205,
            24368697,
            24367762,
            24372789,
            24371841,
            24370735,
            24374219,
            24381920,
            24369005,
            24365735,
            24371025,
            24372089,
            24366605,
            24368551
        ],
        "C": [
            24373544,
            24379290,
            24384264,
            24378866,
            24379343,
            24379755,
            24376326,
            24393137,
            24387552,
            24485763,
            24485746,
            24392939,
            24381638,
            24411493,
            36653644
        ],
        "B": [
            24368982,
            24386986,
            24385221,
            24380830,
            24369478,
            24372225,
            24370708,
            24368820,
            24374499,
            24373776,
            24373025,
            24382359,
            24374187,
            24370609,
            24367209,
            24373968,
            24375645,
            24368619,
            24371120
        ]
    },
    "name": "A. Timofey and a tree",
    "statement": "Each New Year Timofey and his friends cut down a tree of vertices and\r\nbring it home. After that they paint all the its vertices, so that the\r\n-th vertex gets color .Now it\u2019s time for Timofey birthday, and his\r\nmother asked him to remove the tree. Timofey removes the tree in the\r\nfollowing way: he takes some vertex in hands, while all the other\r\nvertices move down so that the tree becomes rooted at the chosen vertex.\r\nAfter that Timofey brings the tree to a trash can.Timofey doesn\u2019t like\r\nit when many colors are mixing together. A subtree annoys him if there\r\nare vertices of different color in it. Timofey wants to find a vertex\r\nwhich he should take in hands so that there are no subtrees that annoy\r\nhim. He doesn\u2019t consider the whole tree as a subtree since he can\u2019t see\r\nthe color of the root vertex.A subtree of some vertex is a subgraph\r\ncontaining that vertex and all its descendants.Your task is to determine\r\nif there is a vertex, taking which in hands Timofey wouldn\u2019t be annoyed.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=501000;\nint n,x[N],y[N],c[N],m;\nmap<int,int> hs;\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t}\n\trep(i,1,n+1) scanf(\"%d\",c+i),hs[i]=0;\n\trep(i,1,n) {\n\t\tif (c[x[i]]!=c[y[i]]) {\n\t\t\ths[x[i]]++; hs[y[i]]++;\n\t\t\tm++;\n\t\t}\n\t}\n\tint q=-1;\n\tfor (auto p:hs) if (p.se==m)  {\n\t\tq=p.fi;\n\t\tbreak;\n\t}\n\tif (q==-1) puts(\"NO\"); else {\n\t\tputs(\"YES\");\n\t\tprintf(\"%d\\n\",q);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "dsu",
        "graphs",
        "implementation",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Timofey and a tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/50205",
    "editorial": "Take edge which vertices are colored in different colors. If such edge\r\ndoesn\u00e2\u0080\u0099t exist you can print any vertex, because all the tree is colored\r\nin the same color. Otherwise, try to make a root from each of these\r\nvertices. Check if is possible with simple dfs. If it succeedes for one\r\nof them, print \"YES\" and this vertex. If it fails for both vertices, the\r\nanswer is \"NO\". Indeed, if both of them cannot be the root, they lay in\r\nthe same subtree and they are colored differently. So the condition\r\nisn\u00e2\u0080\u0099t fulfilled. The asymptotics of this solution is .Author\u00e2\u0080\u0099s solution:\r\nhttp://pastebin.com/M58NY7C1\r\n"
}