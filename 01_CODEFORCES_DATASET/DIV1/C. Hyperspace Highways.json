{"link": "https://codeforces.com//contest/1045/problem/C", "problemId": "223465", "problem_idx": "C", "shortId": "1045C", "contest_number": "1045", "problem_submissions": {"E": [43261410, 43577517], "J": [43258702, 43260133, 43575980, 43263093, 43266033], "A": [43255060, 43256216, 43263322, 43263783, 43258806, 43275613], "D": [43251490, 43264794, 43257475, 43253807, 43257410, 43253327, 43248880], "C": [43250229, 43244156, 43255852, 43252661, 43258515, 43251235, 43259397], "G": [43247867, 43248087, 43251069, 43250948, 43255077, 43249900, 43251360], "H": [43246289, 43252595, 43260022, 43258468, 43261064, 43264435, 43263084], "B": [43243648, 43248788, 43247063, 43264324, 43264189, 43246587, 43256450, 43248333, 43254638], "I": [43243009, 43244706, 43243112, 43242671, 43255452, 43243089, 43243594], "F": [43577952]}, "name": "C. Hyperspace Highways", "statement": "In an unspecified solar system, there are N planets. A space government\r\ncompany has recently hired space contractors to build M bidirectional\r\nHyperspace highways, each connecting two different planets. The primary\r\nobjective, which was to make sure that every planet can be reached from\r\nany other planet taking only Hyperspace highways, has been completely\r\nfulfilled. Unfortunately, lots of space contractors had friends and\r\ncousins in the Space Board of Directors of the company, so the company\r\ndecided to do much more than just connecting all planets. In order to\r\nmake spending enormous amounts of space money for Hyperspace highways\r\nlook neccessary, they decided to enforce a strict rule on the Hyperspace\r\nhighway network: whenever there is a way to travel through some planets\r\nand return to the starting point without travelling through any planet\r\ntwice, every pair of planets on the itinerary should be directly\r\nconnected by a Hyperspace highway. You are designing a Hyperspace\r\nnavigational app, and the key technical problem you are facing is\r\nfinding the minimal number of Hyperspace highways one needs to use to\r\ntravel from planet A to planet B. As this problem is too easy for Bubble\r\nCup, here is a harder task: your program needs to do it for Q pairs of\r\nplanets.\r\n", "solutions": ["#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int MAXN = 120000;\nconst int LOG = 20;\n\nint n, m, q;\nvector<int> eds[MAXN];\nint h[MAXN];\nint up[MAXN][LOG];\nint was[MAXN];\nint tin[MAXN];\nint tout[MAXN];\nint tm1;\n\nvoid dfs1(int v) {\n\ttin[v] = tm1++;\n\twas[v] = 1;\n\tup[v][0] = v;\n\tfor (int u: eds[v]) {\n\t\tif (!was[u]) {\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs1(u);\n\t\t}\n\t\telse {\n\t\t\tif (h[u] < h[up[v][0]])\n\t\t\t\tup[v][0] = u;\n\t\t}\n\t}\n\ttout[v] = tm1;\n}\n\nbool is_p(int a, int b) {\n\treturn tin[a] <= tin[b] && tin[b] < tout[a];\n}\n\nint get(int a, int b) {\n\tint ans = 0;\n\tif (!is_p(a, b)) {\n\t\tfor (int i = LOG - 1; i >= 0; --i) {\n\t\t\tif (!is_p(up[a][i], b))\n\t\t\t\ta = up[a][i], ans += (1 << i);\n\t\t}\n\t\ta = up[a][0];\n\t\tans += 1;\n\t}\n\tif (!is_p(b, a)) {\n\t\tfor (int i = LOG - 1; i >= 0; --i) {\n\t\t\tif (!is_p(up[b][i], a))\n\t\t\t\tb = up[b][i], ans += (1 << i);\n\t\t}\n\t\tb = up[b][0];\n\t\tans += 1;\n\t}\n\treturn ans;\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\teds[a].push_back(b);\n\t\teds[b].push_back(a);\n\t}\n\tdfs1(0);\n\tfor (int i = 1; i < LOG; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tup[j][i] = up[up[j][i - 1]][i - 1];\n\tfor (int i = 0; i < q; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\tcout << min(get(a, b), get(b, a)) << \"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "trees"], "dificulty": "2300", "interactive": false}