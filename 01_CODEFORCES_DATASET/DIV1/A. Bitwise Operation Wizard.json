{
    "link": "https://codeforces.com//contest/1936/problem/A",
    "problemId": "2503245",
    "problem_idx": "A",
    "shortId": "1936A",
    "contest_number": "1936",
    "problem_submissions": {
        "D": [
            249364690,
            248943933,
            248953790,
            249029415,
            248948695,
            249384877,
            248946718,
            249691560,
            248955075,
            248956184,
            248951174,
            248957366,
            248965278,
            248962414,
            248959804,
            248956212,
            248940582,
            248972190,
            248967537,
            248935591,
            248968777
        ],
        "F": [
            248959624,
            248956053,
            249024905,
            249024791,
            249617325,
            249616926,
            249616449,
            249616090
        ],
        "C": [
            248923874,
            248935905,
            248936411,
            248923821,
            249389527,
            249389485,
            249389471,
            248932096,
            249960032,
            249959905,
            248928496,
            248925527,
            248927912,
            248933135,
            248931237,
            248927110,
            248920757,
            248942173,
            248944746,
            248948052,
            248945719,
            248954792,
            249702139,
            249700847,
            248946434,
            248946276
        ],
        "B": [
            248915925,
            248925932,
            248926756,
            248909886,
            248921270,
            250626935,
            248920462,
            248915106,
            248915547,
            248917787,
            248924541,
            248919814,
            248929862,
            248928500,
            248928933,
            248958629,
            248930625,
            248933889,
            248965009,
            248934936
        ],
        "A": [
            248907152,
            248906597,
            248909183,
            248914647,
            248906656,
            250627352,
            248907025,
            248906362,
            248923349,
            248909550,
            248908351,
            248909231,
            248911552,
            248909761,
            248918833,
            248908591,
            248914734,
            248920857
        ],
        "E": [
            248969738,
            248981250,
            249019529,
            248981225,
            248968880,
            249091224,
            249090696,
            252634475,
            249522528
        ]
    },
    "name": "A. Bitwise Operation Wizard",
    "statement": "There is a secret sequence p_0, p_1,\r\nldots, p_{n-1}, which is a permutation of\r\n{0,1,\r\nldots,n-1\r\n}.You need to find any two indices i and j such that p_i\r\noplus p_j is maximized, where\r\noplus denotes the bitwise XOR operation.To do this, you can ask queries.\r\nEach query has the following form: you pick arbitrary indices a, b, c,\r\nand d (0\r\nle a,b,c,d < n). Next, the jury calculates x = (p_a\r\nmid p_b) and y = (p_c\r\nmid p_d), where | denotes the bitwise OR operation. Finally, you receive\r\nthe result of comparison between x and y. In other words, you are told\r\nif x < y, x > y, or x = y.Please find any two indices i and j (0\r\nle i,j < n) such that p_i\r\noplus p_j is maximum among all such pairs, using at most 3n queries. If\r\nthere are multiple pairs of indices satisfying the condition, you may\r\noutput any one of them.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nchar pyt(int a, int b, int c, int d)\n{\n\tprintf(\"? %d %d %d %d\\n\", a, b, c, d);\n\tff();\n\tchar ret;\n\tscanf(\" %c\", &ret);\n\treturn ret;\n}\n\nvoid ans(int a, int b)\n{\n\tprintf(\"! %d %d\\n\", a, b);\n\tff();\n}\n\nint n;\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tint g=0;\n\tfor (int i=1; i<n; i++)\n\t\tif (pyt(i, i, g, g)=='>')\n\t\t\tg=i;\n\tvi wek;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tif (i==g)\n\t\t\tcontinue;\n\t\tif (wek.empty())\n\t\t{\n\t\t\twek.push_back(i);\n\t\t\tcontinue;\n\t\t}\n\t\tchar c=pyt(g, i, g, wek.back());\n\t\tif (c=='>')\n\t\t{\n\t\t\twek={i};\n\t\t\tcontinue;\n\t\t}\n\t\tif (c=='=')\n\t\t{\n\t\t\twek.push_back(i);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tint x=wek[0];\n\tfor (int i : wek)\n\t\tif (pyt(x, x, i, i)=='>')\n\t\t\tx=i;\n\tans(g, x);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "greedy",
        "interactive",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Bitwise Operation Wizard.json",
    "editorial_link": "https://codeforces.com//blog/entry/126513",
    "editorial": "TutorialStep1:do queries like classic searching for the maximum value\r\namong numbers to get ;Step2:do queries to find all index such that\r\nreaches the maximum value. We store all such indexes in a vector\r\n.Step3:do queries to find in such that reaches the minimum value.\r\n"
}