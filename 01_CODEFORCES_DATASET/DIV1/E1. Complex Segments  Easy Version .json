{
    "link": "https://codeforces.com//contest/2018/problem/E1",
    "problemId": "2905187",
    "problem_idx": "E1",
    "shortId": "2018E1",
    "contest_number": "2018",
    "problem_submissions": {
        "F1": [
            283240998,
            283223838,
            283219415,
            283236306,
            283222916,
            283217600,
            283233290,
            283231886,
            283231256,
            283232151,
            283229995,
            283237003,
            283235478,
            283237574,
            283236444,
            283230142,
            283243735,
            283243123,
            283242008,
            283243508
        ],
        "F2": [
            283240981,
            283223708,
            283219380,
            283241370,
            283223162,
            283225122,
            283233500,
            283231817,
            283231569,
            283232589,
            283230224,
            283236870,
            283235839,
            283237529,
            283238353,
            283243847,
            283243386,
            283242191,
            283243811
        ],
        "F3": [
            283240882,
            283223675,
            283219246,
            283271588,
            283270237,
            283224933,
            283229369,
            283236884,
            283231408,
            283234186,
            283238623,
            283246555,
            283236714,
            283242719,
            283237265,
            283240426,
            283246144,
            283243432,
            283242213,
            283244419
        ],
        "E2": [
            283228724,
            283271415,
            283952156,
            285367980,
            285366320,
            284023567,
            283309295
        ],
        "E1": [
            283228436,
            283232974,
            283271394,
            283269080,
            283266646,
            283248084,
            283226474,
            285366140,
            284023512,
            283309260,
            283237845
        ],
        "D": [
            283195973,
            283206733,
            283203886,
            283202562,
            283199647,
            283202135,
            283203009,
            283209326,
            283212471,
            283208248,
            283213153,
            283210604,
            283213401,
            283215308,
            283215785,
            283193803,
            283212467,
            283216433,
            283217858,
            283213030
        ],
        "C": [
            283191019,
            283190311,
            283188296,
            283196136,
            283191568,
            283193617,
            283197810,
            283200878,
            283205239,
            283197789,
            283193479,
            283202635,
            283205964,
            283204336,
            283202253,
            283186865,
            283201070,
            283203016,
            283201349,
            283204359
        ],
        "B": [
            283187765,
            283200401,
            283192789,
            283188636,
            283190321,
            283192212,
            283195063,
            283200019,
            283195292,
            283189706,
            283199364,
            283199549,
            283199094,
            283197971,
            283197559,
            283195753,
            283198921,
            283194967,
            283197864
        ],
        "A": [
            283182907,
            283184407,
            283187228,
            283181621,
            283185198,
            283186414,
            283185582,
            283191793,
            283185688,
            283183522,
            283193549,
            283187676,
            283189523,
            283193094,
            283182769,
            283189185,
            283185401,
            283198807,
            283189030
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "SolutionLetâs write a function max_k(m), which returns the maximum such\r\nthat there exists a partition of valid sets containing intervals each.\r\nmax_k works in in the following way (using a lazy segment tree): (wlog)\r\n; for each not intersecting the previous subset, add on the interval ;\r\nas soon as a point belongs to intervals, they become a subset; return\r\nthe number of subsets. For a given , you can binary search the maximum\r\nsuch that max_k(m) in .The problem asks for the maximum . Since , for\r\nany constant either or . For , the total complexity becomes , which is\r\nenough to solve 2018E1 - Complex Segments (Easy Version). You can also\r\nfind max_k(m) for all with a divide and conquer approach, and the\r\ncomplexity becomes (see here).Now letâs go back to max_k(m). It turns\r\nout you can implement it in .First of all, letâs make all the endpoints\r\ndistinct, in such a way that two intervals intersect if and only if they\r\nwere intersecting before.Letâs maintain a binary string of size ,\r\ninitially containing only ones, that can support the following queries:\r\nset bit in position to 0; find the nearest 1 to the left of position .\r\nThis can be maintained with DSU, where the components are the maximal\r\nintervals containing 100...00.Now letâs reuse the previous solution\r\n(sweeping from left to right), but instead of a segment tree we will\r\nmaintain a binary string with the following information: the positions\r\nstore 1; the positions store 1 if and only if the value in that position\r\n(in the previous solution) is a suffix max. So the queries become: add\r\nto : changes, so you have to set elements in to ; the only other element\r\nthat changes is the nearest 1 to the left of position , which does not\r\nrepresent a suffix max anymore. find the maximum: itâs equal to the\r\nnumber of suffix maximums, which depends on and on the number of\r\ncomponents. This solution allows us to replace a factor with a\r\nfactor.Complexity: [Bonus: there exists a data structure faster than DSU\r\nto solve the subproblem above, so you can solve the problem in . See\r\nhere.]\r\n",
    "name": "E1. Complex Segments  Easy Version ",
    "statement": "A set of (closed) segments is if it can be partitioned into some subsets\r\nsuch that all the subsets have the same size; and a pair of segments\r\nintersects the two segments are in the same subset. You are given n\r\nsegments [l_1, r_1], [l_2, r_2],\r\nldots, [l_n, r_n]. Find the maximum size of a subset of these segments.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;struct DSU {    std::vector<int> f, siz;        DSU() {}    DSU(int n) {        init(n);    }        void init(int n) {        f.resize(n);        std::iota(f.begin(), f.end(), 0);        siz.assign(n, 1);    }        int find(int x) {        while (x != f[x]) {            x = f[x] = f[f[x]];        }        return x;    }        bool same(int x, int y) {        return find(x) == find(y);    }        bool merge(int x, int y) {        x = find(x);        y = find(y);        if (x == y) {            return false;        }        siz[x] += siz[y];        f[y] = x;        return true;    }        int size(int x) {        return siz[find(x)];    }};void solve() {    int n;    std::cin >> n;        std::vector<int> l(n), r(n);    for (int i = 0; i < n; i++) {        std::cin >> l[i];        l[i]--;    }    for (int i = 0; i < n; i++) {        std::cin >> r[i];        r[i]--;    }        std::vector<int> ans(n + 1);        std::vector<int> ord(n);    std::iota(ord.begin(), ord.end(), 0);    std::sort(ord.begin(), ord.end(),        [&](int i, int j) {            return r[i] < r[j];        });        DSU dsu(2 * n);    std::vector<int> L(2 * n, -1), d(2 * n);    auto get = [&](int k) {        dsu.init(2 * n);        int left = 0;        int ans = 0;        int cur = 0;        int p = -1;        int fp = 0;        for (auto i : ord) {            if (l[i] < left) {                continue;            }            if (r[i] > p) {                for (int j = std::max(p + 1, left); j < r[i]; j++) {                    dsu.merge(r[i], j);                }                L[r[i]] = p;                p = r[i];                d[r[i]] = fp;                fp = 0;            }            int j = dsu.find(l[i]);            d[j]--;            while (L[j] != -1 && d[j] <= 0) {                int x = L[j];                dsu.merge(j, x);                L[j] = L[x];                d[j] += d[x];            }            if (L[j] == -1) {                cur += -d[j];                d[j] = 0;            }            fp++;            if (cur == k) {                ans++;                cur = 0;                left = p + 1;                p = -1;                fp = 0;            }        }        return ans;    };        auto work = [&](auto &self, int l, int r, int vl, int vr) -> void {        if (l > r) {            return;        }        if (vl == vr) {            for (int i = l; i <= r; i++) {                ans[i] = vl;            }            return;        }        int m = (l + r) / 2;        int v = get(m);        ans[m] = v;        self(self, l, m - 1, vl, v);        self(self, m + 1, r, v, vr);    };    work(work, 1, n, n, 0);        int mx = 0;    for (int i = 1; i <= n; i++) {        mx = std::max(mx, ans[i] * i);    }    std::cout << mx << \"\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dsu",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E1. Complex Segments  Easy Version .json",
    "hint": [
        "Hint 1 Solve for a fixed (size of the subsets).",
        "Hint 2 is easy. Can you do something similar for other ?",
        "Hint 3 Solve for a fixed (number of subsets).",
        "Hint 4 If you have a solution for a fixed , note that there exists a faster solution!"
    ]
}