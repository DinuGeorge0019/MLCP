{
    "link": "https://codeforces.com//contest/917/problem/A",
    "problemId": "151487",
    "problem_idx": "A",
    "shortId": "917A",
    "contest_number": "917",
    "problem_submissions": {
        "C": [
            34680068,
            34681336,
            34678312,
            34684700,
            34684340,
            34684129,
            34684130,
            34686499,
            34795938,
            34730488,
            34696787
        ],
        "A": [
            34673920,
            34665747,
            34666503,
            34668041,
            34667604,
            34679203,
            34668301,
            34677179,
            34678218,
            34682551,
            34666784,
            34671651,
            34681613,
            34668433,
            34679190,
            34665183,
            34667188,
            34667822,
            34678091,
            34668342
        ],
        "B": [
            34672970,
            34673451,
            34671200,
            34673043,
            34673517,
            34672805,
            34670705,
            34675348,
            34676012,
            34676530,
            34670452,
            34673092,
            34671413,
            34673682,
            34678568,
            34669943,
            34672667,
            34674568,
            34678107,
            34670900
        ],
        "D": [
            34670187,
            34675817,
            34681965,
            34679140,
            34679490,
            34676721,
            34681020,
            34673182,
            34673535,
            34673684,
            34678521,
            34677964,
            34675981,
            34677937,
            34674919,
            37086325,
            34680194,
            34680489,
            34679577,
            34678015,
            34681680
        ],
        "E": [
            38254406,
            38253558,
            38252911
        ]
    },
    "name": "A. The Monster",
    "statement": "As Will is stuck in the Upside Down, he can still communicate with his\r\nmom, Joyce, through the Christmas lights (he can turn them on and off\r\nwith his mind). He can’t directly tell his mom where he is, because the\r\nmonster that took him to the Upside Down will know and relocate him.\r\nThus, he came up with a puzzle to tell his mom his coordinates. His\r\ncoordinates are the answer to the following problem.A string consisting\r\nonly of parentheses (” and ”) is called a bracket sequence. Some bracket\r\nsequence are called correct bracket sequences. More formally: Empty\r\nstring is a correct bracket sequence. if is a correct bracket sequence,\r\nthen is also a correct bracket sequence. if and are correct bracket\r\nsequences, then (concatenation of and ) is also a correct bracket\r\nsequence. A string consisting of parentheses and question marks (”) is\r\ncalled pretty if and only if there’s a way to replace each question mark\r\nwith either ” or ” such that the resulting string is a correct bracket\r\nsequence.Will gave his mom a string consisting of parentheses and\r\nquestion marks (using Morse code through the lights) and his coordinates\r\nare the number of pairs of integers such that and the string is pretty,\r\nwhere is -th character of .Joyce doesn’t know anything about bracket\r\nsequences, so she asked for your help.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=5010;\nchar s[10100];\nint n,win[N][N];\nint main() {\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\trep(i,0,n) {\n\t\tint cnt=0;\n\t\trep(j,i,n) {\n\t\t\tif (s[j]=='('||s[j]=='?') cnt++;\n\t\t\t\telse cnt--;\n\t\t\tif (cnt>=0) win[i][j]++;\n\t\t\telse break;\n\t\t}\n\t}\n\tper(i,0,n) {\n\t\tint cnt=0;\n\t\tper(j,0,i+1) {\n\t\t\tif (s[j]==')'||s[j]=='?') cnt++;\n\t\t\t\telse cnt--;\n\t\t\tif (cnt>=0) win[j][i]++;\n\t\t\telse break;\n\t\t}\n\t}\n\tint cnt=0;\n\trep(i,0,n) rep(j,i,n) if ((i+j)%2==1&&win[i][j]==2) cnt++;\n\tprintf(\"%d\\n\",cnt);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. The Monster.json",
    "editorial_link": "https://codeforces.com//blog/entry/57420",
    "editorial": "First, letâs denote as the substring of string . Also is the number of\r\noccurrences of in .A string consisting of parentheses and question marks\r\nis pretty if and only if: is even. for each . for each . : If then is a\r\ncorrect bracket sequence. Otherwise, let be an integer between to such\r\nthat .: We can replace by either â(â or â)â such that the three\r\nconditions above remain satisfied.Proof: Weâll use proof by\r\ncontradiction. If we can replace by either â(â or â)â such that the\r\nconditions remain satisfied, the lemma is proven. Otherwise, the\r\nconditions will be violated if we replace by â(â or â)â.Letâs denote as\r\nand as . Please note that and .By assumption, if we replace by â(â the\r\nconditions will be violated. By replacing the second condition canât be\r\nviolated, thus the third condition will be violated. So, thereâs an\r\ninteger such that and ( is after replacing by â(â). Thus, . Similarly,\r\nthereâs an integer such that and . Since all three conditions are\r\nsatisfied for (by assumption), then .Letâs break into three parts (they\r\ncould be empty): , and . and . Since the three conditions are satisfied\r\nfor , then . so . Thus , so . So . So . Since , then .Also, . So, . So .\r\nThis requires that and . Since and are even, then and are even, and\r\nsince is even (first condition), then is also even (because ). and and ,\r\nthus . Also, , thus , since is even, and are also even, thus, . and\r\nsince then . Thus, we have , which is false. So the lemma is true.Using\r\nthe lemma above, each time we can replace a question mark by parentheses\r\nand at the end we get a correct bracket sequence.: Knowing this fact, we\r\ncan find all such substrings by checking the three conditions. Pseudo\r\ncode:f[n][n] = {}g[n][n] = {}for l = 1 to n cur = 0 ok = true for r = l\r\nto n if s[r] == â)â cur = cur - 1 else cur = cur + 1 if cur < 0: ok =\r\nfalse f[l][r] = okfor r = 1 to n cur = 0 ok = true for l = r to 1 if\r\ns[l] == â(â cur = cur - 1 else cur = cur + 1 if cur < 0: ok = false\r\ng[l][r] = okans = 0for l = 1 to n for r = l to n if f[l][r] and g[l][r]\r\nand (r-l+1)\r\n",
    "hint": []
}