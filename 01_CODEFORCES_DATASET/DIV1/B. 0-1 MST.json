{
    "link": "https://codeforces.com//contest/1242/problem/B",
    "problemId": "461420",
    "problem_idx": "B",
    "shortId": "1242B",
    "contest_number": "1242",
    "problem_submissions": {
        "D": [
            64429860,
            64401395,
            64404795,
            64415190,
            64415054,
            64417615,
            65038601,
            64421033
        ],
        "E": [
            64409298,
            64420461,
            64419778,
            64424736,
            64419348,
            64414319,
            64418306,
            64411659,
            85134215,
            64416609
        ],
        "C": [
            64384054,
            64387078,
            64388913,
            64394464,
            64389930,
            64394199,
            64391758,
            64389823,
            64419752,
            64392841,
            64389286,
            64389598,
            64391081,
            64391511,
            64389424,
            64390727,
            64393812,
            64387821,
            64392710
        ],
        "B": [
            64375742,
            64376014,
            64376258,
            64379755,
            64379732,
            64382090,
            64380230,
            64379007,
            64378437,
            64381299,
            64377955,
            64379394,
            64386968,
            64379314,
            64379387,
            64378002,
            64378249,
            64378976,
            64378094,
            64382011
        ],
        "A": [
            64373553,
            64378605,
            64373529,
            64375482,
            64375227,
            64375209,
            64374548,
            64373968,
            64380733,
            64373781,
            64373964,
            64373921,
            64376154,
            64374077,
            64374590,
            64374513,
            64373655,
            64375273,
            64373875,
            64376239
        ]
    },
    "name": "B. 0-1 MST",
    "statement": "Ujan has a lot of useless stuff in his drawers, a considerable part of\r\nwhich are his math notebooks: it is time to sort them out. This time he\r\nfound an old dusty graph theory notebook with a description of a\r\ngraph.It is an undirected weighted graph on n vertices. It is a complete\r\ngraph: each pair of vertices is connected by an edge. The weight of each\r\nedge is either 0 or 1; exactly m edges have weight 1, and all others\r\nhave weight 0.Since Ujan doesn’t really want to organize his notes, he\r\ndecided to find the weight of the minimum spanning tree of the graph.\r\n(The weight of a spanning tree is the sum of all its edges.) Can you\r\nfind the answer for Ujan so he stops procrastinating?\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void pr(const T& x) { \n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    \n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n    }\n    \n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n    }\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nnamespace factorBasic {\n\ttemplate<class T> vector<pair<T,int>> factor(T x) { // x <= 10^{14} is fine\n\t\tvector<pair<T,int>> pri;\n\n\t\tfor (T i = 2; i*i <= x; ++i) if (x % i == 0) {\n\t\t\tint t = 0;\n\t\t\twhile (x % i == 0) x /= i, t ++;\n\t\t\tpri.pb({i,t});\n\t\t}\n\n\t\tif (x > 1) pri.pb({x,1});\n\t\treturn pri;\n\t}\n\n\t/* Note:\n\t * number of operations needed s.t.\n\t *\t\t\t\t  phi(phi(...phi(n)...))=1\n\t * is O(log n).\n\t * Euler's theorem: a^{\\phi(p)}\\equiv 1 (mod p), gcd(a,p)=1\n\t */\n\n\tll phi(ll x) {\n\t\ttrav(a,factor(x)) x -= x/a.f;\n\t\treturn x;\n\t}\n\n\ttemplate<class T> void tour(vector<pair<T,int>>& v, vector<T>& V, int ind, T cur) {\n\t\tif (ind == sz(v)) V.pb(cur);\n\t\telse {\n\t\t\tT mul = 1;\n\t\t\tF0R(i,v[ind].s+1) {\n\t\t\t\ttour(v,V,ind+1,cur*mul);\n\t\t\t\tmul *= v[ind].f;\n\t\t\t}\n\t\t}\n\t}\n\n\ttemplate<class T> vector<T> getDivi(T x) {\n\t\tauto v = factor(x);\n\t\tvector<T> V; tour(v,V,0,(T)1); sort(all(V));\n\t\treturn V;\n\t}\n}\n\nusing namespace factorBasic;\n\nint n,m,comp;\nset<int> lef, bad[MX];\n\nint main() {\n\tsetIO(); re(n,m);\n\tF0R(i,m) {\n\t\tint a,b; re(a,b);\n\t\tbad[a].insert(b), bad[b].insert(a);\n\t}\n\tFOR(i,1,n+1) lef.insert(i);\n\tFOR(i,1,n+1) if (lef.count(i)) {\n\t\tcomp ++;\n\t\tqueue<int> q; q.push(i); lef.erase(i);\n\t\twhile (sz(q)) {\n\t\t\tauto a = q.front(); q.pop();\n\t\t\tvi cool;\n\t\t\ttrav(t,lef) if (!bad[a].count(t)) cool.pb(t);\n\t\t\ttrav(t,cool) {\n\t\t\t\tlef.erase(t);\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t}\n\t}\n\tps(comp-1);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. 0-1 MST.json",
    "editorial_link": "https://codeforces.com//blog/entry/71216",
    "editorial": "First examine the given graph where there are only edges of weight :\r\nsuppose that the number of connected components in this subgraph is .\r\nThen the minimum spanning tree of the given graph is equal to .\r\nTherefore, we need to find the number of such (zero weight) components\r\nin the given graph.The following is a solution. Letâs maintain the zero\r\nweight components in the disjoint set union, and letâs also store the\r\nsize of each such component. Then we iterate over all vertices from to .\r\nPut the vertex in a new component of size . Then we iterate over the\r\nweight edges such that . For each of the zero weight components, we\r\ncount the number of edges from this component to . If the number of such\r\nedges is less than the size of the component of , we should merge the\r\ncomponent of with (because there is at least one weight edge between\r\nthis component and ). Otherwise we should not merge the component with .\r\nIn the end, we get the number of zero weight components.What is the\r\ncomplexity of such algorithm? In total, new components are created in\r\nthe course of the algorithm (a new one for each of the vertices). When\r\nwe merge some old component with , the number of components decreases by\r\n. Thus the total number of such cases during the algorithm is at most ,\r\nand for each we have one merge call for DSU. This part has\r\ncomplexity.When we donât merge an old component with , there is at least\r\none edge of weight from this component to . Therefore, the total number\r\nof such cases is at most the number of edges, . Thus the complexity of\r\nprocessing these cases is .Hence, the total complexity of the algorithm\r\nis .\r\n",
    "hint": []
}