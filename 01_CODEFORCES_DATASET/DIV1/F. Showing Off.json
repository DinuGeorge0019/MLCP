{"link": "https://codeforces.com//contest/1416/problem/F", "problemId": "740370", "problem_idx": "F", "shortId": "1416F", "contest_number": "1416", "problem_submissions": {"F": [94006266, 94013395, 94017337, 94007333, 94012350, 94016693, 94144598, 94144345, 94143862, 94143815, 94143507, 94143372, 94134107, 94022751, 94013371, 94123054, 93993751, 93995209, 94206946, 94047832], "D": [93996097, 94002143, 93994280, 93996848, 94000279, 93995262, 93992025, 94030965, 93988840, 94001509, 93996287, 94006105, 94007577, 94017080, 93995866, 93997659, 93998139, 93997214, 93995418, 94000331, 93999706], "E": [93989598, 93993245, 94005344, 94008684, 94029993, 94019586, 94015916, 94018911, 94274661, 94428216, 94428140, 94046134], "B": [93977851, 93981480, 93977205, 93989726, 93978642, 93985288, 93976209, 93981357, 93985099, 93999768, 93994963, 94270201, 93976947, 93987758, 93986950, 93981437, 93979361, 93987047, 93979513], "C": [93974213, 93978374, 93983878, 93979532, 94282160, 93989242, 93980978, 93980593, 93976201, 93990186, 93986370, 93974300, 93996660, 94001007, 93983516, 93980305, 93980649, 93977960, 93984553, 93980471, 93985644], "A": [93970422, 93970885, 93970919, 93970033, 93971425, 93971578, 93970140, 93970220, 93970538, 93970561, 93981050, 94269181, 94002877, 93970437, 93972131, 93974465, 93974988, 93972065, 93971571, 93970260]}, "name": "F. Showing Off", "statement": "Another dull quarantine day was going by when decided to start\r\nresearching matrices of size n\r\ntimes m. The rows are numerated 1 through n from top to bottom, and the\r\ncolumns are numerated 1 through m from left to right. The cell in the\r\ni-th row and j-th column is denoted as (i, j).For each cell (i, j) had\r\ntwo values: The cost of the cell, which is a single integer. The\r\ndirection of the cell, which is one of characters , , , . Those\r\ncharacters correspond to transitions to adjacent cells (i, j - 1), (i,\r\nj + 1), (i + 1, j) or (i - 1, j), respectively. No transition pointed\r\noutside of the matrix. Let us call a cell (i_2, j_2) from (i_1, j_1),\r\nif, starting from (i_1, j_1) and repeatedly moving to the adjacent cell\r\naccording to our current direction, we will, sooner or later, visit\r\n(i_2, j_2). decided to create another matrix from the existing two. For\r\na cell (i, j), let us denote S_{i, j} as a set of all reachable cells\r\nfrom it (including (i, j) itself). Then, the value at the cell (i, j) in\r\nthe new matrix will be equal to the sum of costs of all cells in S_{i,\r\nj}. After quickly computing the new matrix, immediately sent it to his\r\nfriends. However, he did not save any of the initial matrices! Help him\r\nto restore any two valid matrices, which produce the current one.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 27.09.2020 19:10:12       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass matching {\n public:\n  vector<vector<int>> g;\n  vector<vector<int>> g_rev;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was_a;\n  vector<int> was_b;\n  vector<bool> imp_a;\n  vector<bool> imp_b;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was_a = vector<int>(n, 0);\n    was_b = vector<int>(m, 0);\n    imp_a = vector<bool>(n, false);\n    imp_b = vector<bool>(m, false);\n    g.resize(n);\n    g_rev.resize(m);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n    g_rev[to].push_back(from);\n  }\n\n  bool dfs(int v) {\n    was_a[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was_a[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool dfs_rev(int v) {\n    was_b[v] = iter;\n    for (int u : g_rev[v]) {\n      if (pa[u] == -1) {\n        pb[v] = u;\n        pa[u] = v;\n        return true;\n      }\n    }\n    for (int u : g_rev[v]) {\n      if (was_b[pa[u]] != iter && dfs_rev(pa[u])) {\n        pb[v] = u;\n        pa[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      int add = 0;\n      iter++;\n      for (int i = 0; i < n; i++) {\n        if (imp_a[i] && pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      for (int i = 0; i < m; i++) {\n        if (imp_b[i] && pb[i] == -1 && dfs_rev(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, -1, 0, 1};\nconst string let = \"ULDR\";\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int h, w;\n    cin >> h >> w;\n    vector<vector<int>> a(h, vector<int>(w));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> a[i][j];\n      }\n    }\n    vector<vector<int>> id(h, vector<int>(w, -1));\n    vector<int> cnt(2);\n    for (int rot = 0; rot < 2; rot++) {\n      cnt[rot] = 0;\n      for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n          if ((i + j) % 2 == rot) {\n            id[i][j] = cnt[rot];\n            cnt[rot] += 1;\n          }\n        }\n      }\n    }\n    matching mat(cnt[0], cnt[1]);\n    vector<vector<bool>> critical(h, vector<bool>(w, true));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int dir = 0; dir < 4; dir++) {\n          int ni = i + di[dir];\n          int nj = j + dj[dir];\n          if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n            if (a[ni][nj] < a[i][j]) {\n              critical[i][j] = false;\n            }\n          }\n        }\n        if (critical[i][j]) {\n          if ((i + j) % 2 == 0) {\n            mat.imp_a[id[i][j]] = true;\n          } else {\n            mat.imp_b[id[i][j]] = true;\n          }\n        }\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (critical[i][j] && (i + j) % 2 == 0) {\n          for (int dir = 0; dir < 4; dir++) {\n            int ni = i + di[dir];\n            int nj = j + dj[dir];\n            if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n              if (a[i][j] == a[ni][nj] && critical[ni][nj]) {\n                mat.add(id[i][j], id[ni][nj]);\n              }\n            }\n          }\n        }\n      }\n    }\n    mat.solve();\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if ((i + j) % 2 == 0) {\n          for (int dir = 0; dir < 4; dir++) {\n            int ni = i + di[dir];\n            int nj = j + dj[dir];\n            if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n              if (a[i][j] == a[ni][nj]) {\n                if (critical[i][j] != critical[ni][nj]) {\n                  mat.add(id[i][j], id[ni][nj]);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    mat.solve();\n    bool ok = true;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if ((i + j) % 2 == 0) {\n          if (critical[i][j] && mat.pa[id[i][j]] == -1) {\n            ok = false;\n          }\n        } else {\n          if (critical[i][j] && mat.pb[id[i][j]] == -1) {\n            ok = false;\n          }\n        }\n      }\n    }\n    if (!ok) {\n      cout << \"NO\" << '\\n';\n      continue;\n    }\n    cout << \"YES\" << '\\n';\n    vector<vector<int>> cost(h, vector<int>(w, -1));\n    vector<vector<char>> go(h, vector<char>(w, '?'));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if ((i + j) % 2 == 0 && mat.pa[id[i][j]] != -1) {\n          for (int dir = 0; dir < 4; dir++) {\n            int ni = i + di[dir];\n            int nj = j + dj[dir];\n            if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n              if (mat.pa[id[i][j]] == id[ni][nj]) {\n                go[i][j] = let[dir];\n                go[ni][nj] = let[dir ^ 2];\n                cost[i][j] = 1;\n                cost[ni][nj] = a[i][j] - 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (cost[i][j] == -1) {\n          for (int dir = 0; dir < 4; dir++) {\n            int ni = i + di[dir];\n            int nj = j + dj[dir];\n            if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n              if (a[ni][nj] < a[i][j]) {\n                go[i][j] = let[dir];\n                cost[i][j] = a[i][j] - a[ni][nj];\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        assert(go[i][j] != '?' && cost[i][j] != -1);\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (j > 0) {\n          cout << \" \";\n        }\n        cout << cost[i][j];\n      }\n      cout << '\\n';\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (j > 0) {\n          cout << \" \";\n        }\n        cout << go[i][j];\n      }\n      cout << '\\n';\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["flows", "graph matchings", "greedy", "implementation"], "dificulty": "3300", "interactive": false}