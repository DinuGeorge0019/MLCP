{
    "link": "https://codeforces.com//contest/1500/problem/A",
    "problemId": "922992",
    "problem_idx": "A",
    "shortId": "1500A",
    "contest_number": "1500",
    "problem_submissions": {
        "F": [
            109882523,
            156894272,
            156888570,
            109926929,
            109926191,
            109893056,
            109892507,
            110407942
        ],
        "E": [
            109869658,
            109880186,
            109882627,
            109869772,
            109883572,
            110177251,
            112227681,
            112227008,
            112226855
        ],
        "C": [
            109851937,
            109858563,
            109855424,
            109847448,
            109897897,
            109858583,
            109868120,
            109862817,
            109862820,
            109847704,
            109864051,
            109866901,
            109862545,
            109862473,
            109864278,
            109866655,
            109866161,
            109873497,
            109866235,
            109876064
        ],
        "A": [
            109847522,
            109845877,
            109846878,
            109889115,
            109845620,
            109845386,
            109845664,
            109845260,
            109853758,
            109847140,
            109849368,
            109845237,
            109845429,
            109846259,
            109846562,
            109868273,
            109864425,
            109846842,
            109854328
        ],
        "B": [
            109845439,
            109853012,
            109858233,
            109878921,
            109849145,
            109848615,
            109856685,
            109852114,
            109880910,
            109854120,
            109859099,
            109849597,
            109849728,
            109854205,
            109854819,
            109853965,
            109859327,
            109857020,
            109863440
        ],
        "D": [
            109866969,
            109867253,
            109854472,
            109863287,
            109861346,
            109868138,
            109875304,
            109871552,
            109879597,
            109878283,
            109877726,
            109880816,
            109873581,
            109879840,
            109875506,
            109884990,
            109881921,
            109883609
        ]
    },
    "name": "A. Going Home",
    "statement": "It was the third month of remote learning, Nastya got sick of staying at\r\ndormitory, so she decided to return to her hometown. In order to make\r\nher trip more entertaining, one of Nastya’s friend presented her an\r\ninteger array a. Several hours after starting her journey home Nastya\r\nremembered about the present. To entertain herself she decided to check,\r\nare there four indices x, y, z, w such that a_x + a_y = a_z + a_w.Her\r\ntrain has already arrived the destination, but she still hasn’t found\r\nthe answer. Can you help her unravel the mystery?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 13.03.2021 12:04:29       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  int mx = *max_element(a.begin(), a.end()) + 1;\n  vector<int> p1(mx, -1);\n  vector<int> p2(mx, -1);\n  vector<int> p3(mx, -1);\n  for (int i = 0; i < n; i++) {\n    if (p1[a[i]] == -1) {\n      p1[a[i]] = i;\n      continue;\n    }\n    if (p2[a[i]] == -1) {\n      p2[a[i]] = i;\n      continue;\n    }\n    if (p3[a[i]] == -1) {\n      p3[a[i]] = i;\n      continue;\n    }\n    cout << \"YES\" << '\\n';\n    cout << p1[a[i]] + 1 << \" \" << p2[a[i]] + 1 << \" \" << p3[a[i]] + 1 << \" \" << i + 1 << '\\n';\n    return 0;\n  }\n  vector<int> ind;\n  int two = -1;\n  for (int i = 0; i < mx; i++) {\n    if (p1[i] == -1) {\n      continue;\n    }\n    ind.push_back(p1[i]);\n    if (p2[i] == -1) {\n      continue;\n    }\n    if (two != -1) {\n      cout << \"YES\" << '\\n';\n      cout << p1[two] + 1 << \" \" << p1[i] + 1 << \" \" << p2[two] + 1 << \" \" << p2[i] + 1 << '\\n';\n      return 0;\n    }\n    two = i;\n  }\n  vector<pair<int, int>> met(2 * mx, make_pair(-1, -1));\n  sort(ind.begin(), ind.end());\n  if (two != -1) {\n    met[two + two] = make_pair(p1[two], p2[two]);\n  }\n  for (int i = 0; i < (int) ind.size(); i++) {\n    for (int j = i + 1; j < (int) ind.size(); j++) {\n      int sum = a[ind[i]] + a[ind[j]];\n      if (met[sum].first != -1) {\n        cout << \"YES\" << '\\n';\n        cout << met[sum].first + 1 << \" \" << met[sum].second + 1 << \" \" << ind[i] + 1 << \" \" << ind[j] + 1 << '\\n';\n        return 0;\n      }\n      met[sum] = make_pair(ind[i], ind[j]);\n    }\n  }\n  cout << \"NO\" << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "hashing",
        "implementation",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Going Home.json",
    "editorial_link": "https://codeforces.com//blog/entry/88591",
    "editorial": "Letâs prove that if thereâre at least four different pairs indices with\r\nthe common sum (), then there necessarily will be two pairs such that\r\nall four indices in them are unique.Letâs analyze some cases: Thereâre\r\nfour pairs of the form with sum . Then from which we can conclude that ,\r\nand it means that pairs and are suitable as answer. Thereâre three pairs\r\nof the form and the fourth pair doesnât contain index . Then whatever\r\nthe fourth pair is, it necessarily doesnât contain index and at least\r\none of indices which means we can take as answer pairs and one of three\r\nthat contain . Other cases are analyzed in the same way. To make sure\r\nthat answer always exists among such four pairs, we can imagine graph,\r\nwhere vertices are indices, and there is an edge between two vertices if\r\nthe corresponding pair of indices has sum . If such a graph has at least\r\nfour edges and the degree of all vertices is at most two (we excluded\r\nthe larger degrees by examining the previous cases), then there will\r\nalways be two edges with disjoint ends. How to find answer using this?\r\nLetâs launch simple bruteforce which for every sum will save all found\r\npairs with such sum, and for each pair check if thereâs another already\r\nfound pair with the same sum and such indices that all four indices in\r\nthese two pairs are unique. Letâs notice it works in , because once for\r\nsome sum we find the fourth pair, we can immediately print the answer.\r\nAnd if the answer is \"\", then weâve done no more than iterations of\r\nbruteforce.\r\n",
    "hint": []
}