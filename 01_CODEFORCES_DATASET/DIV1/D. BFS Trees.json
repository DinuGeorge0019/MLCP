{
    "link": "https://codeforces.com//contest/1495/problem/D",
    "problemId": "920577",
    "problem_idx": "D",
    "shortId": "1495D",
    "contest_number": "1495",
    "problem_submissions": {
        "F": [
            109612449,
            109607835,
            109606482,
            109609150,
            109620903,
            109726650,
            109627363,
            109621999
        ],
        "E": [
            109601349,
            109614588,
            109615437,
            109622017,
            109595998,
            109609900,
            109608272,
            109611154,
            109618626,
            109616350,
            109613793,
            109616566,
            109663705,
            109745948
        ],
        "D": [
            109585527,
            109580228,
            109579316,
            109589541,
            109578458,
            109566916,
            109575841,
            109594019,
            109596254,
            109599839,
            109603208,
            109598498,
            109595100,
            109579185,
            109589312,
            109591284,
            109598520,
            109583665,
            109585365
        ],
        "C": [
            109580634,
            109591405,
            109587970,
            109577744,
            109586320,
            109593422,
            109611088,
            109582953,
            109580883,
            109580583,
            109587448,
            109605186,
            109581328,
            109584227,
            109579041,
            109577709,
            109589629,
            109602493
        ],
        "B": [
            109568471,
            109565101,
            109584053,
            109566115,
            109569156,
            109574304,
            109563074,
            109573615,
            109567542,
            109575207,
            109571021,
            109587658,
            109567505,
            109566798,
            109566339,
            109589966,
            109570284,
            109566248
        ],
        "A": [
            109557502,
            109557307,
            109557290,
            109557352,
            109558084,
            109569473,
            109557547,
            109559952,
            109558698,
            109558154,
            109557812,
            109558270,
            109557945,
            109558879,
            109557971,
            109558445,
            109560880,
            109558343,
            109559119
        ]
    },
    "name": "D. BFS Trees",
    "statement": "We define a spanning tree of a graph to be a BFS tree vertex s if and\r\nonly if for every node t the shortest distance between s and t in the\r\ngraph is equal to the shortest distance between s and t in the spanning\r\ntree. Given a graph, we define f(x,y) to be the number of spanning trees\r\nof that graph that are BFS trees rooted at vertices x and y at the same\r\ntime.You are given an undirected connected graph with n vertices and m\r\nedges. Calculate f(i,j) for all i, j by modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\nconst int inf=1e9;\nconst ll mod=998244353;\n\nint n, m;\n\nvi graf[nax];\n\nint mac[nax][nax];\n\nll wyn[nax][nax];\n\nll f(int a, int b)\n{\n\tll ret=1;\n\tint ile=0;\n\tint ory=mac[a][b];\n\tfor (int i=1; i<=n; i++)\n\t\tile+=(mac[a][i]+mac[b][i]==ory);\n\tif (ile!=ory+1)\n\t\treturn 0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (mac[a][i]+mac[b][i]==ory)\n\t\t\tcontinue;\n\t\tll tu=0;\n\t\tfor (int j : graf[i])\n\t\t\tif (mac[a][j]+1==mac[a][i] && mac[b][j]+1==mac[b][i])\n\t\t\t\ttu++;\n\t\tret=(ret*tu)%mod;\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tmac[i][j]=(i!=j)*inf;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tmac[a][b]=mac[b][a]=1;\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tfor (int l=1; l<=n; l++)\n\t\t\t\tmac[j][l]=min(mac[j][l], mac[j][i]+mac[i][l]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=i; j++)\n\t\t\twyn[i][j]=wyn[j][i]=f(i, j);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tprintf(\"%lld \", wyn[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "graphs",
        "math",
        "shortest paths",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. BFS Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/88533",
    "editorial": "Letâs enumerate vertexes , and calculate for them.Let denote the number\r\nof the vertexes which lie on the shortest-path between and on the\r\ngraph.It is obvious that the distance between and in the tree is equal\r\nto . And the vertex satisfying must be on the path between and . So the\r\nnumber of the vertexes must be equal to ( including and ).Then, letâs\r\nconsider the contributions of other vertexes . In the bfs-trees of both\r\nand , there must be and only be a edge linking and , which satisfies .\r\nLetâs prove it recursively.All the vertexes linked to the path between\r\nand satisfy the condition ( There is and only is a edge linking them ).\r\nWe can call them layer 1.All the vertexes linked to the layer 1 satisfy\r\nthe condition ( There is and only is a edge linking them ). We can call\r\nthem layer 2.All the vertexes ...And the contribution of each vertex is\r\nindependent, which means that for each vertex we can choose a vertex\r\nwithout considering other vertexes. No matter which we choose for , the\r\nlayer of will not change.So the choice of wonât change the number of\r\nchoices of others.So we only need calculate the number of for every ,\r\nand multiply them.For every , we should enumerate all the edges to\r\ncalculate for every . So the complexity is per . The total complexity is\r\n.\r\n",
    "hint": []
}