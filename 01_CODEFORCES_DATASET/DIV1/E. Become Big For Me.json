{"link": "https://codeforces.com//contest/1687/problem/E", "problemId": "1419369", "problem_idx": "E", "shortId": "1687E", "contest_number": "1687", "problem_submissions": {"E": [159400142, 159409445, 159415903], "D": [159385709, 159382982, 159386487, 159387507, 159397573, 159399320, 159391569, 159397786, 159396436, 159395456, 159398210, 159399180, 159407593, 159403303, 159404538, 159409257, 180746841, 159402849, 159401651, 159407966, 160388189, 159436063, 159436040, 159435984, 159419781, 159403828], "C": [159372815, 159372262, 159366644, 159367127, 159364840, 159377203, 159381172, 159372251, 159382727, 159384371, 159375023, 159388232, 159376434, 159382167, 159380993, 159376872, 159376695, 159388502, 159386180, 159388678], "B": [159359094, 159359944, 159359502, 159356648, 159356713, 159358784, 159359353, 159359146, 159369441, 159357746, 159365304, 159359951, 159364501, 159359761, 159371294, 159365665, 159363760, 159364175, 159366158, 159367949], "A": [159352673, 159354526, 159354098, 159352807, 159352456, 159352554, 159353893, 159353089, 159361438, 159353196, 159354069, 159353562, 159353431, 159353777, 159361194, 159354902, 159354475, 159353974, 159355709, 159356539]}, "name": "E. Become Big For Me", "statement": "Kijin Seija, Shinmyoumaru has a mallet that can turn objects bigger or\r\nsmaller. She is testing it out on a sequence a and a number v whose\r\ninitial value is 1. She wants to make v =\r\ngcd\r\nlimits_{i\r\nne j}\r\n{a_i\r\ncdot a_j\r\n} by 10^5 operations (\r\ngcd\r\nlimits_{i\r\nne j}\r\n{a_i\r\ncdot a_j\r\n} denotes the\r\ngcd of all products of two distinct elements of the sequence a). In each\r\noperation, she picks a subsequence b of a, and does one of the\r\nfollowings: : v = v\r\ncdot\r\nmathrm{lcm}(b) : v =\r\nfrac{v}{\r\nmathrm{lcm}(b)} Note that she does need to guarantee that v is an\r\ninteger, that is, v does need to be a multiple of\r\nmathrm{lcm}(b) when performing Reduce.Moreover, she wants to guarantee\r\nthat the total length of b chosen over the operations does not exceed\r\n10^6. Fine a possible operation sequence for her. .\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (int)1e6 + 7;\nint n;\nint a[N];\nint d[N];\nint cntDif[N];\nint c[N][3];\nbool u[N];\n\nvector<pair<vector<int>, int>> getGcd(int ban) {\n\tint g = 0;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tg = gcd(g, a[i]);\n\t}\n\tint gg = 0;\n\tvector<int> w;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tint ng = gcd(gg, a[i]);\n\t\tif (ng == gg) continue;\n\t\tif (gg == 0 || cntDif[gg / g] != cntDif[ng / g]) {\n\t\t\tw.push_back(i);\n\t\t}\n\t\tgg = ng;\n\t}\n\tvector<pair<vector<int>, int>> ans;\n\tint sz = (int)w.size();\n\tassert(sz > 0);\n\tfor (int mask = 1; mask < (1 << sz); mask++) {\n\t\tint t = 1;\n\t\tvector<int> cur;\n\t\tfor (int i = 0; i < sz; i++) if ((mask >> i) & 1) {\n\t\t\tt ^= 1;\n\t\t\tcur.push_back(w[i]);\n\t\t}\n\t\tans.push_back(mp(cur, t));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tfor (int x = 2; x < N; x++) {\n\t\tif (d[x] != 0) continue;\n\t\tc[x][0] = 0;\n\t\tc[x][1] = 30;\n\t\tc[x][2] = -1;\n\t\tfor (int y = x; y < N; y += x)\n\t\t\tif (d[y] == 0)\n\t\t\t\td[y] = x;\n\t}\n\tcntDif[1] = 0;\n\tfor (int x = 2; x < N; x++) {\n\t\tint y = x;\n\t\twhile(d[y] == d[x]) y /= d[x];\n\t\tcntDif[x] = cntDif[y] + 1;\n\t}\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tint x = a[i];\n\t\twhile(x > 1) {\n\t\t\tint p = d[x];\n\t\t\tint k = 0;\n\t\t\twhile(x % p == 0) {\n\t\t\t\tx /= p;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tc[p][0]++;\n\t\t\tif (k < c[p][1]) {\n\t\t\t\tc[p][1] = k;\n\t\t\t\tc[p][2] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int p = 2; p < N; p++) if (d[p] == p) {\n\t\tif (c[p][0] <= n - 2) continue;\n\t\tif (c[p][0] == n - 1) {\n\t\t\tint v = 0;\n\t\t\twhile(a[v] % p == 0) v++;\n\t\t\tu[v] = 1;\n\t\t} else {\n\t\t\tu[c[p][2]] = 1;\n\t\t}\n\t}\n\tvector<int> zz;\n\tfor (int i = 0; i < n; i++)\n\t\tif (u[i])\n\t\t\tzz.push_back(i);\n\tvector<pair<vector<int>, int>> ans;\n\tvector<pair<vector<int>, int>> ans0 = getGcd(-1);\n\tint w = 2 - (int)zz.size();\n\tif (w > 0) {\n\t\tfor (int it = 0; it < w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(z);\n\t} else {\n\t\tfor (int it = 0; it < -w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(mp(z.first, z.second ^ 1));\n\t}\n\tfor (int x : zz) {\n\t\tans0 = getGcd(x);\n\t\tfor (auto z : ans0)\n\t\t\tans.push_back(z);\n\t}\n\tprintf(\"%d\\n\", (int)ans.size());\n\tfor (auto z : ans) {\n\t\tprintf(\"%d %d\", z.second, (int)z.first.size());\n\t\tsort(all(z.first));\n\t\tfor (int id : z.first)\n\t\t\tprintf(\" %d\", id + 1);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "constructive algorithms", "greedy", "math", "number theory"], "dificulty": "3500", "interactive": false}