{
    "link": "https://codeforces.com//contest/449/problem/A",
    "problemId": "11565",
    "problem_idx": "A",
    "shortId": "449A",
    "contest_number": "449",
    "problem_submissions": {
        "E": [
            7172419,
            7172014,
            7174895,
            7169365,
            7240994,
            7177576,
            9954696,
            9954686
        ],
        "A": [
            7167638,
            7162064,
            7159189,
            7170577,
            7159566,
            7171912,
            7174755,
            7177754,
            7174429,
            7180997,
            7161684,
            7182849,
            7192923,
            7180517,
            7168378,
            7168819,
            7159358
        ],
        "C": [
            7166638,
            7168442,
            7168589,
            7167422,
            7169338,
            7166871,
            7167683,
            7167793,
            7161177,
            7181293,
            7173309,
            7170890,
            7173119,
            7170721,
            7171917,
            7171483,
            7167450,
            7178771,
            7171038
        ],
        "D": [
            7161895,
            7168837,
            7161219,
            7163790,
            7163207,
            7165070,
            7164972,
            7165472,
            7166314,
            7182041,
            7171873,
            7166502,
            7159887,
            7192953,
            7166535,
            7169239,
            7169537,
            7165449,
            7159363,
            7166505
        ],
        "B": [
            7159593,
            7164450,
            7164390,
            7162671,
            7166735,
            7162159,
            7160515,
            7161879,
            7168809,
            7176245,
            7164684,
            7165872,
            7161265,
            7163102,
            7161569,
            7175028,
            7162358,
            7183380
        ]
    },
    "name": "A. Jzzhu and Chocolate",
    "statement": "Jzzhu has a big rectangular chocolate bar that consists of unit squares.\r\nHe wants to cut this bar exactly times. Each cut must meet the following\r\nrequirements: each cut should be straight (horizontal or vertical); each\r\ncut should go along edges of unit squares (it is prohibited to divide\r\nany unit chocolate square with cut); each cut should go inside the whole\r\nchocolate bar, and all cuts must be distinct. The picture below shows a\r\npossible way to cut a chocolate for times. Imagine Jzzhu have made cuts\r\nand the big chocolate is splitted into several pieces. Consider the\r\nsmallest (by area) piece of the chocolate, Jzzhu wants this piece to be\r\nas large as possible. What is the maximum possible area of smallest\r\npiece he can get with exactly cuts? The area of a chocolate piece is the\r\nnumber of unit squares in it.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <cstring>\nusing namespace std;\n#define MOD 1000000009\n#define ADD(X, Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64;\n\ni64 N, M, K;\n\ni64 solve(i64 X)\n{\n\tif (X >= N || (K-X) >= M) return -1;\n\tif(X < 0 || K-X < 0) return -1;\n\n\treturn (N/(X+1)) * (M/(K-X+1));\n}\n\nint main()\n{\n\tcin >> N >> M >> K;\n\n\tif (N+M-2 < K) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\ti64 ret = 0;\n\tfor(int i=0;i<=100000;i++) {\n\t\tret = max(ret, solve(i));\n\t\tif(i>0) ret = max(ret, solve(min(K, N / i - 1)));\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Jzzhu and Chocolate.json",
    "editorial_link": "https://codeforces.com//blog/entry/13112",
    "editorial": "We assume that (if , we can simply swap and ). If we finally cut the\r\nchocolate into rows and columns , we should maximize the narrowest row\r\nand maximize the narrowest column, so the answer will be . There are two\r\nalgorithms to find the optimal . Notice that if is smaller, the answer\r\nusually will be better. Then we can find that if , the optimal can only\r\nbe or . If , the optimal can only be . If , the optimal can only be ,\r\nbecause let , . has at most values, so we can enum it and choose the\r\nmaximum for each value.\r\n",
    "hint": []
}