{
    "link": "https://codeforces.com//contest/429/problem/E",
    "problemId": "9406",
    "problem_idx": "E",
    "shortId": "429E",
    "contest_number": "429",
    "problem_submissions": {
        "E": [
            6595809,
            6600093,
            6592978,
            6601793,
            6652557,
            6599111,
            6619551,
            6619545,
            6597254,
            6597744
        ],
        "C": [
            6593728,
            6600070,
            6592280,
            6592740,
            6600977,
            6600868,
            6594386,
            6592397,
            6594791,
            6593656,
            6596025,
            6593807,
            6593862,
            6598107,
            6594449,
            6598559,
            6594937,
            6592148,
            6594524,
            6592432,
            6594909,
            6590473
        ],
        "D": [
            6591664,
            6600092,
            6591240,
            6590624,
            6590639,
            6591834,
            6591461,
            6591644,
            6590500,
            6592190,
            6591828,
            6591578,
            6591777,
            6592587,
            27994201,
            6591983,
            6594641,
            6604627,
            6593023,
            6594793,
            6591937,
            6593041
        ],
        "B": [
            6589690,
            6600091,
            6589488,
            6589367,
            6588962,
            6590036,
            6588367,
            6590786,
            6591308,
            6589466,
            6590642,
            6589551,
            6589761,
            6589966,
            6589108,
            6590082,
            6589028,
            6590294,
            6589190,
            6595125
        ],
        "A": [
            6588164,
            6600088,
            6588109,
            6588114,
            6588105,
            6588288,
            6588966,
            6588346,
            6592136,
            6588117,
            6588421,
            6588130,
            6588989,
            6588112,
            27994125,
            6589842,
            6588200,
            6588169,
            6588529,
            6590124,
            6593587
        ]
    },
    "name": "E. Points and Segments",
    "statement": "Iahub isn\u2019t well prepared on geometry problems, but he heard that this\r\nyear there will be a lot of geometry problems on the IOI selection camp.\r\nScared, Iahub locked himself in the basement and started thinking of new\r\nproblems of this kind. One of them is the following.Iahub wants to draw\r\ndistinct segments on the axis. He can draw each segment with either red\r\nor blue. The drawing is good if and only if the following requirement is\r\nmet: for each point of the axis consider all the segments that contains\r\npoint ; suppose, that red segments and blue segments contain point ; for\r\neach point inequality must be satisfied.A segment contains a point if\r\nand only if .Iahub gives you the starting and ending points of all the\r\nsegments. You have to find any good drawing for him.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nvector<pii> a;\nvector< vector<int> > g;\nvector<int> pos[100500];\nint col[200500];\n\nvoid error() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid go(int v, int c) {\n\tcol[v]= c;\n\tforn(i, g[v].size())\n\t\tif (col[g[v][i]] == -1)\n\t\t\tgo(g[v][i], 1 - c);\n\t\telse if (col[g[v][i]] == c)\n\t\t\terror();\t\t\t\t\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tcin >> n;\n\ta.clear();\n\tforn(i, n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx *= 2;\n\t\ty *= 2;\n\t\ta.pb(mp(x-1, i));\n\t\ta.pb(mp(y, i));\n\t}\t\n\tsort(all(a));\n\tforn(i, a.size())\n\t\tpos[a[i].sc].pb(i);\n\tg.resize(n * 2);\n\tforn(i, n) {\n\t\tg[i * 2].pb(i * 2 + 1);\n\t\tg[i * 2 + 1].pb(i * 2);\n\n\t\tg[pos[i][0]].pb(pos[i][1]);\n\t\tg[pos[i][1]].pb(pos[i][0]);\n\t}\n\tseta(col, 255);\n\tforn(i, n * 2)\n\t\tif (col[i] == -1)\n\t\t\tgo(i, 0);\n\tforn(i, n)\n\t\tprintf(\"%d \", col[pos[i][0]]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Points and Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/12265",
    "editorial": "The problem asks you to check the property for an infinity of points.\r\nObviously, we can t do that. However, we can observe that some\r\ncontiguous ranges on OX axis have the same rx and bx values. Like a\r\nsweep line algorithm, a possible change may appear only when a new\r\nsegment begins or when an old one ends. So let s consider set of points\r\nformed by all li reunited with set of points formed by all ri. Sort the\r\nvalues increasing. Suppose the set looks like {x1, x2, ..., xk}. Then\r\nranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones\r\nthat need to be considered. If we can take an arbitrary point from each\r\nrange and the property is respected for all points, then the drawing is\r\ngood. We need to color segments. But each segment is a reunion of ranges\r\nlike the ones from above. When you color a segment, all ranges from it\r\nwill be colored too. So, after coloring the segments, for each range,\r\n|number of times range was colored with blue number of times range was\r\ncolored with red| <= 1. It s time to think creative. We can see ranges\r\nas vertexes of a graph and segments as edges. For example, if a segment\r\nis formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge\r\nfrom i to j + 1. We need to color the edges. We divide the graph into\r\nconnected components and apply same logic for each component. Next, by\r\ngraph I ll refer to a connected graph. Let s assume that our graph has\r\nall degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2,\r\n..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ...\r\nxk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1,\r\nwe color edge between xi and xi+1 in red. Otherwise, we color it in\r\nblue. What happens for a node? Whenever a red edge crosses it (for\r\nexample edge 1-5 crosses node 4) a blue edge will always exist to cross\r\nit again (for example edge 6-2 crosses node 4). This is because of\r\nproperty of euler cycle: suppose we started from a node x and gone in\r\nleft . We need to return to it, but the only way to do it is an edge\r\nwhich goes to right . So, when degrees of graph are all even, for every\r\npoint on OX axis, difference between rx and bx will be always 0. Let s\r\nsolve the general case now. Some nodes have odd degree. But there will\r\nalways be an even number of nodes with odd degrees. Why? Suppose the\r\nproperty is respected for some edges added so far and now we add a new\r\none. There are two cases: 1/ the edge connects two nodes with odd\r\ndegree. in this case, the number of nodes with odd degrees decreases by\r\n2, but its parity does not change. 2/ the edge connects one node with\r\nodd degree and one node with even degree. Now, degree of old odd one\r\nbecomes even and degree of old even one becomes odd. So number of nodes\r\nwith odd degrees does not change. So suppose the nodes with odd degrees\r\nare X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one\r\nmore edge to each of these nodes, an euler cycle would be possible.\r\nHowever, we can t add edges, because edges are segments from the input.\r\nBut we can imagine them. Of course, this we ll create an imbalance\r\nbetween red and blue edges, but let s see how big it is. What if we add\r\na fictive edge between X1 to X2, between X3 to X4, ..., between X(k 1)\r\nto Xk? In this way, all those nodes will have even degree. So for each\r\nXi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi\r\nand from Yi to Xi+1. Now let s see the effect: if the fictive edges\r\nexisted, the balance would be 0. But they do not exist, so one of rx or\r\nbx will decrease. So now |rx bx| <= 1, good enough for problem s\r\nrestrictions.\r\n"
}