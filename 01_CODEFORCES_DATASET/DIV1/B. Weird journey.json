{"link": "https://codeforces.com//contest/788/problem/B", "problemId": "100722", "problem_idx": "B", "shortId": "788B", "contest_number": "788", "problem_submissions": {"E": [25924862, 25925377, 25915904, 25922582, 25915050, 25918684, 25941153, 25921354, 25925269, 25935314, 25926533, 25926046, 25936552, 25927749, 25926831, 25919133, 25921191], "D": [25915542, 25915181, 25939395, 25930075, 25941576, 25921672, 25929951, 25917640, 25923984, 26061916, 26104610, 25928092, 25925001, 25924944, 26043257], "C": [25904961, 25906051, 25905059, 25908402, 25906489, 25909800, 25905943, 25913627, 25910389, 25907305, 25913724, 25911198, 25913363, 25908585, 25910198, 25909085, 25915912, 25913369, 25907071, 25907012], "B": [25903079, 25903720, 25902453, 25904332, 25903705, 25904849, 25903086, 25902909, 25905715, 25902462, 25905159, 25905547, 25906945, 25904624, 25903809, 25910532, 25906509, 25927693, 25946077], "A": [25900169, 25901048, 25900244, 25901169, 25900572, 25900694, 25900718, 25900816, 25901339, 25905048, 25900137, 25900587, 25901139, 25902041, 25900581, 25899979, 25900864, 25900329, 25900280, 25900541]}, "name": "B. Weird journey", "statement": "Little boy Igor wants to become a traveller. At first, he decided to\r\nvisit all the cities of his motherland Uzhlyandia.It is widely known\r\nthat Uzhlyandia has cities connected with bidirectional roads. Also,\r\nthere are no two roads in the country that connect the same pair of\r\ncities, but roads starting and ending in the same city can exist. Igor\r\nwants to plan his journey beforehand. Boy thinks a path is if the path\r\ngoes over roads twice, and over the other exactly once. The good path\r\ncan start and finish in any city of Uzhlyandia.Now he wants to know how\r\nmany different good paths are in Uzhlyandia. Two paths are considered\r\ndifferent if the sets of roads the paths goes over exactly once differ.\r\nHelp Igor calculate the number of good paths.\r\n", "solutions": ["#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 1e6 + 10;\nint n, m;\n\nvector<vector<int> > es;\n\nint cool[maxn];\n\nint read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return 0;\n  }\n  es = vector<vector<int> >(n);\n  for (int i = 0; i < m; ++i) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    --s, --t;\n    es[s].pb(t);\n    if (s != t) {\n      es[t].pb(s);\n    }\n  }\n  return 1;\n}\n\nint used[maxn];\n\nvoid dfs(int v) {\n  used[v] = 1;\n  for (int u : es[v]) {\n    if (used[u]) {\n      continue;\n    }\n    dfs(u);\n  }\n}\n\nvoid solve() {\n  int root = 0;\n  while (!sz(es[root])) {\n    ++root;\n  }\n  assert(root < n);\n\n  for (int i = 0; i < n; ++i) {\n    used[i] = 0;\n  }\n  dfs(root);\n\n  for (int i = 0; i < n; ++i) {\n    if (used[i]) {\n      continue;\n    }\n    if (sz(es[i])) {\n      printf(\"0\\n\");\n      return;\n    }\n  }\n\n  int cool = 0;\n  for (int i = 0; i < n; ++i) {\n    int pos = find(es[i].begin(), es[i].end(), i) - es[i].begin();\n    if (pos < sz(es[i])) {\n      swap(es[i].back(), es[i][pos]);\n      es[i].pop_back();\n      ++cool;\n    }\n  }\n  long long res = (long long) cool * (m - cool) + (long long) cool * (cool - 1) / 2;\n  for (int i = 0; i < n; ++i) {\n    if (sz(es[i])) {\n      res += (long long) sz(es[i]) * (sz(es[i]) - 1) / 2;\n    }\n  }\n  printf(\"%lld\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "constructive algorithms", "dfs and similar", "dsu", "graphs"], "dificulty": "2100", "interactive": false}