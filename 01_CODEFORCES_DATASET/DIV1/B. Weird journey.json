{
    "link": "https://codeforces.com//contest/788/problem/B",
    "problemId": "100722",
    "problem_idx": "B",
    "shortId": "788B",
    "contest_number": "788",
    "problem_submissions": {
        "E": [
            25924862,
            25925377,
            25915904,
            25922582,
            25915050,
            25918684,
            25941153,
            25921354,
            25925269,
            25935314,
            25926533,
            25926046,
            25936552,
            25927749,
            25926831,
            25919133,
            25921191
        ],
        "D": [
            25915542,
            25915181,
            25939395,
            25930075,
            25941576,
            25921672,
            25929951,
            25917640,
            25923984,
            26061916,
            26104610,
            25928092,
            25925001,
            25924944,
            26043257
        ],
        "C": [
            25904961,
            25906051,
            25905059,
            25908402,
            25906489,
            25909800,
            25905943,
            25913627,
            25910389,
            25907305,
            25913724,
            25911198,
            25913363,
            25908585,
            25910198,
            25909085,
            25915912,
            25913369,
            25907071,
            25907012
        ],
        "B": [
            25903079,
            25903720,
            25902453,
            25904332,
            25903705,
            25904849,
            25903086,
            25902909,
            25905715,
            25902462,
            25905159,
            25905547,
            25906945,
            25904624,
            25903809,
            25910532,
            25906509,
            25927693,
            25946077
        ],
        "A": [
            25900169,
            25901048,
            25900244,
            25901169,
            25900572,
            25900694,
            25900718,
            25900816,
            25901339,
            25905048,
            25900137,
            25900587,
            25901139,
            25902041,
            25900581,
            25899979,
            25900864,
            25900329,
            25900280,
            25900541
        ]
    },
    "name": "B. Weird journey",
    "statement": "Little boy Igor wants to become a traveller. At first, he decided to\r\nvisit all the cities of his motherland Uzhlyandia.It is widely known\r\nthat Uzhlyandia has cities connected with bidirectional roads. Also,\r\nthere are no two roads in the country that connect the same pair of\r\ncities, but roads starting and ending in the same city can exist. Igor\r\nwants to plan his journey beforehand. Boy thinks a path is if the path\r\ngoes over roads twice, and over the other exactly once. The good path\r\ncan start and finish in any city of Uzhlyandia.Now he wants to know how\r\nmany different good paths are in Uzhlyandia. Two paths are considered\r\ndifferent if the sets of roads the paths goes over exactly once differ.\r\nHelp Igor calculate the number of good paths.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 1e6 + 10;\nint n, m;\n\nvector<vector<int> > es;\n\nint cool[maxn];\n\nint read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return 0;\n  }\n  es = vector<vector<int> >(n);\n  for (int i = 0; i < m; ++i) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    --s, --t;\n    es[s].pb(t);\n    if (s != t) {\n      es[t].pb(s);\n    }\n  }\n  return 1;\n}\n\nint used[maxn];\n\nvoid dfs(int v) {\n  used[v] = 1;\n  for (int u : es[v]) {\n    if (used[u]) {\n      continue;\n    }\n    dfs(u);\n  }\n}\n\nvoid solve() {\n  int root = 0;\n  while (!sz(es[root])) {\n    ++root;\n  }\n  assert(root < n);\n\n  for (int i = 0; i < n; ++i) {\n    used[i] = 0;\n  }\n  dfs(root);\n\n  for (int i = 0; i < n; ++i) {\n    if (used[i]) {\n      continue;\n    }\n    if (sz(es[i])) {\n      printf(\"0\\n\");\n      return;\n    }\n  }\n\n  int cool = 0;\n  for (int i = 0; i < n; ++i) {\n    int pos = find(es[i].begin(), es[i].end(), i) - es[i].begin();\n    if (pos < sz(es[i])) {\n      swap(es[i].back(), es[i][pos]);\n      es[i].pop_back();\n      ++cool;\n    }\n  }\n  long long res = (long long) cool * (m - cool) + (long long) cool * (cool - 1) / 2;\n  for (int i = 0; i < n; ++i) {\n    if (sz(es[i])) {\n      res += (long long) sz(es[i]) * (sz(es[i]) - 1) / 2;\n    }\n  }\n  printf(\"%lld\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Weird journey.json",
    "editorial_link": "https://codeforces.com//blog/entry/51312",
    "editorial": "We can consider the system of towns and roads as a graph, where edges\r\ncorrespond to roads and vertexes to cities.Now, letâs fix two edges,\r\nthat will be visited once. All other edges we can split into two. Then,\r\nthe good way in the old graph equivalents to any Euler path in the\r\ncomputed one. Widely known that Euler path exists in graph when and only\r\nwhen there are 0 or 2 vertexes with odd degree. Consider following cases\r\nof mutual placement of edges that will be visited once: Regular(not\r\nloops) edges that are not adjacent graph has four vertexes with odd\r\ndegree, so Euler path doesnât exist. Regular edges that are adjacent\r\ngraph has exactly two vertexes with odd degree, so Euler path exists.\r\nSo, any pair of adjacent regular edges satisfies Igor. One of the edges\r\nis a loop graph hasnât any vertex with the odd degree(if another chosen\r\nedge is a loop too) or has two of them(if another chosen edge is\r\nregular). So, any pair in which at least one edge is a loop satisfies\r\nIgor. So, we have to calculate the number of pairs of adjacent regular\r\nedges and add the answer for loops. For every vertex we can calculate\r\nthe number of regular edges incoming in it. General number of adjacent\r\nregular edges is . Also, we need to add the number of pairs with loops.\r\nLetâs count general number of loops in the graph. So we can add to the\r\nanswer. Now, we included pairs with two loops twice. Thatâs why we need\r\nto subtract the number of pairs with two loops. Also, we need to check\r\nthe graph to be connected . If the graph is not connected then the\r\nanswer is 0. We can do it using algorithms of DFS or BFS.Complexity of\r\nthe given solution if .\r\n",
    "hint": []
}