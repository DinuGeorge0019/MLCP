{"link": "https://codeforces.com//contest/1290/problem/E", "problemId": "529281", "problem_idx": "E", "shortId": "1290E", "contest_number": "1290", "problem_submissions": {"C": [70096929, 70064543, 70052395, 70054161, 70047406, 70047992, 70053917, 70053152, 70054979, 70214121, 70054528, 70058183, 70057014, 70052660, 70052531, 70060568, 70059018, 70063715, 70055920, 70058007, 70059153, 70056438], "D": [70071102, 70083418, 70081951, 70059761, 70062540, 70064117, 70088222, 70088118, 70087893, 70066142, 71762685, 70214194, 70214147, 70068516, 70069978, 70069936, 70074018, 70075546, 70074118, 70071674, 70072917, 70077679, 70075595, 70065164, 70078630], "F": [70059398, 70084031, 70111116, 70110928, 75833689, 70089144, 70131709], "A": [70040962, 70037530, 70037805, 70036026, 70036076, 70037499, 70037219, 70040023, 70214047, 70038241, 70036901, 70036876, 70037974, 70038261, 70038975, 70040060, 70041968, 70036027, 70043312, 70045091, 70039900], "B": [70038396, 70041221, 70041673, 70039846, 70040515, 70043644, 70043914, 70045743, 70214060, 70047838, 70043116, 70043411, 70045228, 70046548, 70048357, 70051227, 70051419, 70047415, 70062917, 70075181, 70045909], "E": [70074704, 70107871, 70086286, 70079191, 70214607, 70086883, 70085799, 70123893, 70086530, 70158475, 70100288, 70111014]}, "name": "E. Cartesian Tree ", "statement": "Ildar is the algorithm teacher of William and Harris. Today, Ildar is\r\nteaching Cartesian Tree. However, Harris is sick, so Ildar is only\r\nteaching William.A cartesian tree is a rooted tree, that can be\r\nconstructed from a sequence of distinct integers. We build the cartesian\r\ntree as follows: If the sequence is empty, return an empty tree; Let the\r\nposition of the element be x; Remove element on the position x from the\r\nsequence and break it into the left part and the right part (which might\r\nbe empty) (not actually removing it, just taking it away temporarily);\r\nBuild cartesian tree for each part; Create a new vertex for the element,\r\nthat was on the position x which will serve as the root of the new tree.\r\nThen, for the root of the left part and right part, if exists, will\r\nbecome the children for this vertex; Return the tree we have gotten.For\r\nexample, this is the cartesian tree for the sequence 4, 2, 7, 3, 5, 6,\r\n1: After teaching what the cartesian tree is, Ildar has assigned\r\nhomework. He starts with an empty sequence a.In the i-th round, he\r\ninserts an element with value i somewhere in a. Then, he asks a\r\nquestion: what is the sum of the sizes of the subtrees for every node in\r\nthe cartesian tree for the current sequence a?Node v is in the node u\r\nsubtree if and only if v = u or v is in the subtree of one of the vertex\r\nu children. The size of the subtree of node u is the number of nodes v\r\nsuch that v is in the subtree of u.Ildar will do n rounds in total. The\r\nhomework is the sequence of answers to the n questions.The next day,\r\nIldar told Harris that he has to complete the homework as well. Harris\r\nobtained the final state of the sequence a from William. However, he has\r\nno idea how to find the answers to the n questions. Help Harris!\r\n", "solutions": ["#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int inf=1e8;\nint n,a[1500010],b[1500010],f[1500010],p;\nstruct st\n{\n    int f[2000010],g[2000010],x[2000010],ad[2000010],mi[2000010];\n    L s[2000010];\n    inline void down(int i,int k)\n    {\n        if(ad[i])\n          {\n           ad[i<<1]+=ad[i];\n           mi[i<<1]+=ad[i];\n           f[i<<1]+=ad[i];\n           g[i<<1]+=ad[i];\n           s[i<<1]+=(L)(k>>1)*ad[i];\n           ad[(i<<1)|1]+=ad[i];\n           mi[(i<<1)|1]+=ad[i];\n           f[(i<<1)|1]+=ad[i];\n           g[(i<<1)|1]+=ad[i];\n           s[(i<<1)|1]+=(L)(k>>1)*ad[i];\n           ad[i]=0;\n          }\n        if(mi[i]<f[i<<1])\n          {\n           mi[i<<1]=mi[i];\n           s[i<<1]-=(L)x[i<<1]*(f[i<<1]-mi[i]);\n           f[i<<1]=mi[i];\n          }\n        if(mi[i]<f[(i<<1)|1])\n          {\n           mi[(i<<1)|1]=mi[i];\n           s[(i<<1)|1]-=(L)x[(i<<1)|1]*(f[(i<<1)|1]-mi[i]);\n           f[(i<<1)|1]=mi[i];\n          }\n        mi[i]=inf;\n    }\n    inline void upd(int i)\n    {\n        s[i]=s[i<<1]+s[(i<<1)|1];\n        f[i]=max(f[i<<1],f[(i<<1)|1]);\n        x[i]=0;\n        if(f[i]==f[i<<1])\n          x[i]+=x[i<<1];\n        if(f[i]==f[(i<<1)|1])\n          x[i]+=x[(i<<1)|1];\n        g[i]=-inf;\n        if(f[i]==f[i<<1])\n          g[i]=max(g[i],g[i<<1]);\n        else\n          g[i]=max(g[i],f[i<<1]);\n        if(f[i]==f[(i<<1)|1])\n          g[i]=max(g[i],g[(i<<1)|1]);\n        else\n          g[i]=max(g[i],f[(i<<1)|1]);\n    }\n    inline void add(int i,int j,int k,int l,int r,int p)\n    {\n        if(l<=j && k<=r)\n          {\n           ad[i]+=p;\n           mi[i]+=p;\n           f[i]+=p;\n           g[i]+=p;\n           s[i]+=(k-j+1)*p;\n          }\n        else\n          {\n           down(i,k-j+1);\n           if(l<=(j+k>>1))\n             add(i<<1,j,j+k>>1,l,r,p);\n           if(r>(j+k>>1))\n             add((i<<1)|1,(j+k>>1)+1,k,l,r,p);\n           upd(i);\n          }\n    }\n    inline void modify(int i,int j,int k,int l,int p)\n    {\n        if(j==k)\n          {\n           ad[i]=0;\n           mi[i]=inf;\n           f[i]=p;\n           g[i]=0;\n           x[i]=1;\n           s[i]=p;\n          }\n        else\n          {\n           down(i,k-j+1);\n           if(l<=(j+k>>1))\n             modify(i<<1,j,j+k>>1,l,p);\n           else\n             modify((i<<1)|1,(j+k>>1)+1,k,l,p);\n           upd(i);\n          }\n    }\n    inline void minn(int i,int j,int k,int l,int r,int p)\n    {\n        if(p>=f[i])\n          return;\n        down(i,k-j+1);\n        if(l<=j && k<=r && p>g[i])\n          {\n           mi[i]=p;\n           s[i]-=(L)x[i]*(f[i]-p);\n           f[i]=p;\n          }\n        else\n          {\n           if(l<=(j+k>>1))\n             minn(i<<1,j,j+k>>1,l,r,p);\n           if(r>(j+k>>1))\n             minn((i<<1)|1,(j+k>>1)+1,k,l,r,p);\n           upd(i);\n          }\n    }\n}x,y;\ninline void add(int i)\n{\n    for(;i<=n;i+=(i&-i))\n      f[i]++;\n}\ninline int sum(int i)\n{\n    int k=0;\n    for(;i;i^=(i&-i))\n      k+=f[i];\n    return k;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&a[i]),b[a[i]]=i;\n\tfor(p=1;p<n;p<<=1);\n\tfor(i=1;i<2*p;i++)\n\t  x.mi[i]=y.mi[i]=inf;\n\tfor(i=1;i<=n;i++)\n\t  {\n       x.f[p+i-1]=1;\n       x.x[p+i-1]=1;\n       x.s[p+i-1]=1;\n       y.f[p+i-1]=n-1;\n       y.x[p+i-1]=1;\n       y.s[p+i-1]=n-1;\n      }\n    for(i=p-1;i>0;i--)\n      {\n       x.upd(i);\n       y.upd(i);\n      }\n\tfor(i=1;i<=n;i++)\n\t  {\n       j=b[i];\n       add(b[i]);\n       k=sum(b[i]);\n       if(j<n)\n         x.add(1,1,p,j+1,n,1);\n       if(j>1)\n         x.minn(1,1,p,1,j-1,k);\n       x.modify(1,1,p,j,i+1);\n       if(j<n)\n         y.add(1,1,p,j+1,n,-1);\n       if(j<n)\n         y.minn(1,1,p,j+1,n,n-(k+1));\n       y.modify(1,1,p,j,n-1);\n       printf(\"%lld\\n\",x.s[1]-((L)n*n-y.s[1]));\n      }\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3300", "interactive": false}