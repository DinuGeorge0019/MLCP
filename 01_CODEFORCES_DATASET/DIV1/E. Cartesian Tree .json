{
    "link": "https://codeforces.com//contest/1290/problem/E",
    "problemId": "529281",
    "problem_idx": "E",
    "shortId": "1290E",
    "contest_number": "1290",
    "problem_submissions": {
        "C": [
            70096929,
            70064543,
            70052395,
            70054161,
            70047406,
            70047992,
            70053917,
            70053152,
            70054979,
            70214121,
            70054528,
            70058183,
            70057014,
            70052660,
            70052531,
            70060568,
            70059018,
            70063715,
            70055920,
            70058007,
            70059153,
            70056438
        ],
        "D": [
            70071102,
            70083418,
            70081951,
            70059761,
            70062540,
            70064117,
            70088222,
            70088118,
            70087893,
            70066142,
            71762685,
            70214194,
            70214147,
            70068516,
            70069978,
            70069936,
            70074018,
            70075546,
            70074118,
            70071674,
            70072917,
            70077679,
            70075595,
            70065164,
            70078630
        ],
        "F": [
            70059398,
            70084031,
            70111116,
            70110928,
            75833689,
            70089144,
            70131709
        ],
        "A": [
            70040962,
            70037530,
            70037805,
            70036026,
            70036076,
            70037499,
            70037219,
            70040023,
            70214047,
            70038241,
            70036901,
            70036876,
            70037974,
            70038261,
            70038975,
            70040060,
            70041968,
            70036027,
            70043312,
            70045091,
            70039900
        ],
        "B": [
            70038396,
            70041221,
            70041673,
            70039846,
            70040515,
            70043644,
            70043914,
            70045743,
            70214060,
            70047838,
            70043116,
            70043411,
            70045228,
            70046548,
            70048357,
            70051227,
            70051419,
            70047415,
            70062917,
            70075181,
            70045909
        ],
        "E": [
            70074704,
            70107871,
            70086286,
            70079191,
            70214607,
            70086883,
            70085799,
            70123893,
            70086530,
            70158475,
            70100288,
            70111014
        ]
    },
    "name": "E. Cartesian Tree ",
    "statement": "Ildar is the algorithm teacher of William and Harris. Today, Ildar is\r\nteaching Cartesian Tree. However, Harris is sick, so Ildar is only\r\nteaching William.A cartesian tree is a rooted tree, that can be\r\nconstructed from a sequence of distinct integers. We build the cartesian\r\ntree as follows: If the sequence is empty, return an empty tree; Let the\r\nposition of the element be x; Remove element on the position x from the\r\nsequence and break it into the left part and the right part (which might\r\nbe empty) (not actually removing it, just taking it away temporarily);\r\nBuild cartesian tree for each part; Create a new vertex for the element,\r\nthat was on the position x which will serve as the root of the new tree.\r\nThen, for the root of the left part and right part, if exists, will\r\nbecome the children for this vertex; Return the tree we have gotten.For\r\nexample, this is the cartesian tree for the sequence 4, 2, 7, 3, 5, 6,\r\n1: After teaching what the cartesian tree is, Ildar has assigned\r\nhomework. He starts with an empty sequence a.In the i-th round, he\r\ninserts an element with value i somewhere in a. Then, he asks a\r\nquestion: what is the sum of the sizes of the subtrees for every node in\r\nthe cartesian tree for the current sequence a?Node v is in the node u\r\nsubtree if and only if v = u or v is in the subtree of one of the vertex\r\nu children. The size of the subtree of node u is the number of nodes v\r\nsuch that v is in the subtree of u.Ildar will do n rounds in total. The\r\nhomework is the sequence of answers to the n questions.The next day,\r\nIldar told Harris that he has to complete the homework as well. Harris\r\nobtained the final state of the sequence a from William. However, he has\r\nno idea how to find the answers to the n questions. Help Harris!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int inf=1e8;\nint n,a[1500010],b[1500010],f[1500010],p;\nstruct st\n{\n    int f[2000010],g[2000010],x[2000010],ad[2000010],mi[2000010];\n    L s[2000010];\n    inline void down(int i,int k)\n    {\n        if(ad[i])\n          {\n           ad[i<<1]+=ad[i];\n           mi[i<<1]+=ad[i];\n           f[i<<1]+=ad[i];\n           g[i<<1]+=ad[i];\n           s[i<<1]+=(L)(k>>1)*ad[i];\n           ad[(i<<1)|1]+=ad[i];\n           mi[(i<<1)|1]+=ad[i];\n           f[(i<<1)|1]+=ad[i];\n           g[(i<<1)|1]+=ad[i];\n           s[(i<<1)|1]+=(L)(k>>1)*ad[i];\n           ad[i]=0;\n          }\n        if(mi[i]<f[i<<1])\n          {\n           mi[i<<1]=mi[i];\n           s[i<<1]-=(L)x[i<<1]*(f[i<<1]-mi[i]);\n           f[i<<1]=mi[i];\n          }\n        if(mi[i]<f[(i<<1)|1])\n          {\n           mi[(i<<1)|1]=mi[i];\n           s[(i<<1)|1]-=(L)x[(i<<1)|1]*(f[(i<<1)|1]-mi[i]);\n           f[(i<<1)|1]=mi[i];\n          }\n        mi[i]=inf;\n    }\n    inline void upd(int i)\n    {\n        s[i]=s[i<<1]+s[(i<<1)|1];\n        f[i]=max(f[i<<1],f[(i<<1)|1]);\n        x[i]=0;\n        if(f[i]==f[i<<1])\n          x[i]+=x[i<<1];\n        if(f[i]==f[(i<<1)|1])\n          x[i]+=x[(i<<1)|1];\n        g[i]=-inf;\n        if(f[i]==f[i<<1])\n          g[i]=max(g[i],g[i<<1]);\n        else\n          g[i]=max(g[i],f[i<<1]);\n        if(f[i]==f[(i<<1)|1])\n          g[i]=max(g[i],g[(i<<1)|1]);\n        else\n          g[i]=max(g[i],f[(i<<1)|1]);\n    }\n    inline void add(int i,int j,int k,int l,int r,int p)\n    {\n        if(l<=j && k<=r)\n          {\n           ad[i]+=p;\n           mi[i]+=p;\n           f[i]+=p;\n           g[i]+=p;\n           s[i]+=(k-j+1)*p;\n          }\n        else\n          {\n           down(i,k-j+1);\n           if(l<=(j+k>>1))\n             add(i<<1,j,j+k>>1,l,r,p);\n           if(r>(j+k>>1))\n             add((i<<1)|1,(j+k>>1)+1,k,l,r,p);\n           upd(i);\n          }\n    }\n    inline void modify(int i,int j,int k,int l,int p)\n    {\n        if(j==k)\n          {\n           ad[i]=0;\n           mi[i]=inf;\n           f[i]=p;\n           g[i]=0;\n           x[i]=1;\n           s[i]=p;\n          }\n        else\n          {\n           down(i,k-j+1);\n           if(l<=(j+k>>1))\n             modify(i<<1,j,j+k>>1,l,p);\n           else\n             modify((i<<1)|1,(j+k>>1)+1,k,l,p);\n           upd(i);\n          }\n    }\n    inline void minn(int i,int j,int k,int l,int r,int p)\n    {\n        if(p>=f[i])\n          return;\n        down(i,k-j+1);\n        if(l<=j && k<=r && p>g[i])\n          {\n           mi[i]=p;\n           s[i]-=(L)x[i]*(f[i]-p);\n           f[i]=p;\n          }\n        else\n          {\n           if(l<=(j+k>>1))\n             minn(i<<1,j,j+k>>1,l,r,p);\n           if(r>(j+k>>1))\n             minn((i<<1)|1,(j+k>>1)+1,k,l,r,p);\n           upd(i);\n          }\n    }\n}x,y;\ninline void add(int i)\n{\n    for(;i<=n;i+=(i&-i))\n      f[i]++;\n}\ninline int sum(int i)\n{\n    int k=0;\n    for(;i;i^=(i&-i))\n      k+=f[i];\n    return k;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&a[i]),b[a[i]]=i;\n\tfor(p=1;p<n;p<<=1);\n\tfor(i=1;i<2*p;i++)\n\t  x.mi[i]=y.mi[i]=inf;\n\tfor(i=1;i<=n;i++)\n\t  {\n       x.f[p+i-1]=1;\n       x.x[p+i-1]=1;\n       x.s[p+i-1]=1;\n       y.f[p+i-1]=n-1;\n       y.x[p+i-1]=1;\n       y.s[p+i-1]=n-1;\n      }\n    for(i=p-1;i>0;i--)\n      {\n       x.upd(i);\n       y.upd(i);\n      }\n\tfor(i=1;i<=n;i++)\n\t  {\n       j=b[i];\n       add(b[i]);\n       k=sum(b[i]);\n       if(j<n)\n         x.add(1,1,p,j+1,n,1);\n       if(j>1)\n         x.minn(1,1,p,1,j-1,k);\n       x.modify(1,1,p,j,i+1);\n       if(j<n)\n         y.add(1,1,p,j+1,n,-1);\n       if(j<n)\n         y.minn(1,1,p,j+1,n,n-(k+1));\n       y.modify(1,1,p,j,n-1);\n       printf(\"%lld\\n\",x.s[1]-((L)n*n-y.s[1]));\n      }\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Cartesian Tree .json",
    "editorial_link": "https://codeforces.com//blog/entry/73563",
    "editorial": "Instead of inserting numbers one by one, let\u00e2\u0080\u0099s imagine I have blanks in\r\na row, and I will fill the blanks with integers from in order, and I\r\nwant to know about the cartesian tree after each blank filled. In the\r\nfollowing parts of the solution, I will use positions in the original\r\narray instead of positions in the contracted array to label things.In\r\nthe process of building a cartesian tree, a node is created for each\r\nrecursive call of building a tree for a subarray . Let\u00e2\u0080\u0099s label the node\r\ncreated at that moment to be . We realize that will be the size of the\r\nsubtree of that node. However, in our problem, some positions can be\r\nblanks, so the actual subtree size of a node is the number of positions\r\nthat are not blanks in the subarray .So now we are finding the sum of\r\nthe number of non-blanks in the range for each node in our cartesian\r\ntree. Let be the number of non-blanks in the first positions of the\r\nsequence. Then we are finding sum of for each node .To proceed, observe\r\na property for a cartesian tree. Let\u00e2\u0080\u0099s define for each integer , let to\r\nbe the largest such that is a node, or just if there is no nodes of the\r\nform . Similarly, define to be the smallest such that is a node.Then,\r\nfor each node , of the following is true: . . Except when is the root.If\r\nwe know: sum of over all that is not . sum of over all that is not . sum\r\nof over all that is not . sum of over all that is not . Then we can find\r\nout the answer. As it is more or less symmetric I will only care about\r\npart (1) and (2) from now on.Let\u00e2\u0080\u0099s find out what would happen to nodes\r\nof our tree if we fill into position , replacing a blank. Let\u00e2\u0080\u0099s omit how\r\nthe nodes connect each other and just track the labels of each node. For\r\nconvenience, we will make the following definitions. Call the nearest\r\nnon-blank position on the left side of . Call the nearest non-blank\r\nposition on the right side of . Call the leftmost non-blank position.\r\nCall the rightmost non-blank position. Firstly, every node that is of\r\nthe form where , will be split into two halves of and . Then, duplicates\r\n(nodes that represent the same range) will be removed. Finally, there\r\nwill be a new node that would represent the root, which is .Let\u00e2\u0080\u0099s track\r\nhow changes. for all p in the range . Some modification to values of ,\r\nand . As the first step doesn\u00e2\u0080\u0099t change whether values are or not, and\r\nmodifications to the second step can be easily handled, part (2) can be\r\neasily maintained by a Fenwick tree. So it remains to compute part\r\n(1).Imagine instead of computing sum of , we are computing sum of Then,\r\nwe realise that we are having a Segment Tree Beats problem. You have to\r\nmaintain a sequence with 3 kinds of operation: Do for in . . Query the\r\nsum of the whole array. Check part 2 of this blog and this proof of time\r\ncomplexity.Then we can solve this variation of the problem in .So, we\r\nhave to modify the above variant into solving the real problem. Look at\r\nwhat we do every time we are doing query 1. We are doing a total of\r\ntimes of changing some occurrences of value to value . Which means, we\r\ncan maintain the frequency for values of . Therefore, for each put-tag\r\noperation in our segment tree beats, we just modify a Fenwick tree that\r\nrepresents the frequency of values in . Because we have updates to the\r\nsegment tree, the total time complexity is .It is also possible to\r\nreplace \"\" with \"\" and we can support online queries, but it is not\r\nrequired to pass this problem.We also allowed methods of slower\r\ncomplexity (i.e. ) to pass. It basically is the same but does the above\r\nthings by sqrt decomposition instead. Care is needed to be sure that\r\nthere is no extra factor.\r\n"
}