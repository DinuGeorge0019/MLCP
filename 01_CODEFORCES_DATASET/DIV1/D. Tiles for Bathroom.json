{
    "link": "https://codeforces.com//contest/1500/problem/D",
    "problemId": "922995",
    "problem_idx": "D",
    "shortId": "1500D",
    "contest_number": "1500",
    "problem_submissions": {
        "F": [
            109882523,
            156894272,
            156888570,
            109926929,
            109926191,
            109893056,
            109892507,
            110407942
        ],
        "E": [
            109869658,
            109880186,
            109882627,
            109869772,
            109883572,
            110177251,
            112227681,
            112227008,
            112226855
        ],
        "C": [
            109851937,
            109858563,
            109855424,
            109847448,
            109897897,
            109858583,
            109868120,
            109862817,
            109862820,
            109847704,
            109864051,
            109866901,
            109862545,
            109862473,
            109864278,
            109866655,
            109866161,
            109873497,
            109866235,
            109876064
        ],
        "A": [
            109847522,
            109845877,
            109846878,
            109889115,
            109845620,
            109845386,
            109845664,
            109845260,
            109853758,
            109847140,
            109849368,
            109845237,
            109845429,
            109846259,
            109846562,
            109868273,
            109864425,
            109846842,
            109854328
        ],
        "B": [
            109845439,
            109853012,
            109858233,
            109878921,
            109849145,
            109848615,
            109856685,
            109852114,
            109880910,
            109854120,
            109859099,
            109849597,
            109849728,
            109854205,
            109854819,
            109853965,
            109859327,
            109857020,
            109863440
        ],
        "D": [
            109866969,
            109867253,
            109854472,
            109863287,
            109861346,
            109868138,
            109875304,
            109871552,
            109879597,
            109878283,
            109877726,
            109880816,
            109873581,
            109879840,
            109875506,
            109884990,
            109881921,
            109883609
        ]
    },
    "name": "D. Tiles for Bathroom",
    "statement": "Kostya is extremely busy: he is renovating his house! He needs to hand\r\nwallpaper, assemble furniture throw away trash.Kostya is buying tiles\r\nfor bathroom today. He is standing in front of a large square stand with\r\ntiles in a shop. The stand is a square of n\r\ntimes n cells, each cell of which contains a small tile with color c_{i,\r\n,j}. The shop sells tiles in packs: more specifically, you can only buy\r\na subsquare of the initial square.A subsquare is any square part of the\r\nstand, i. e. any set S(i_0, j_0, k) =\r\n{c_{i,\r\n,j}\r\n|\r\ni_0\r\nle i < i_0 + k, j_0\r\nle j < j_0 + k\r\n} with 1\r\nle i_0, j_0\r\nle n - k + 1.Kostya still does not know how many tiles he needs, so he\r\nconsiders the subsquares of all possible sizes. He doesn’t want his\r\nbathroom to be too colorful. Help Kostya to count for each k\r\nle n the number of subsquares of size k\r\ntimes k that have at most q different colors of tiles. Two subsquares\r\nare considered different if their location on the stand is different.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n, q;\n    std::cin >> n >> q;\n    std::vector<int> A(n * n);\n    std::vector<std::vector<int>> R(n + 1), D[2], RD[2];\n    std::vector<bool> vis(n * n);\n    for (int i = 0; i < 2; i++) {\n        D[i].resize(n + 1);\n        RD[i].resize(n + 1);\n    }\n    for (int i = 0; i < n * n; i++) {\n        std::cin >> A[i];\n        A[i]--;\n    }\n    auto f = [&](int x, int y, int v) {\n        return std::max(v / n - x, v % n - y);\n    };\n    auto merge = [&](int x, int y, const std::vector<int> &a, const std::vector<int> &b, std::vector<int> &c) {\n        int i = 0, j = 0;\n        while ((i < int(a.size()) || j < int(b.size())) && int(c.size()) <= q) {\n            if (i < int(a.size()) && (j == int(b.size()) || f(x, y, a[i]) < f(x, y, b[j]))) {\n                if (!vis[A[a[i]]]) {\n                    c.push_back(a[i]);\n                    vis[A[a[i]]] = true;\n                }\n                i++;\n            } else {\n                if (!vis[A[b[j]]]) {\n                    c.push_back(b[j]);\n                    vis[A[b[j]]] = true;\n                }\n                j++;\n            }\n        }\n        for (auto x : c) {\n            vis[A[x]] = false;\n        }\n    };\n    std::vector<int> ans(n + 1);\n    int cur = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        cur ^= 1;\n        for (int j = 0; j <= n; j++) {\n            R[j].clear();\n            D[cur][j].clear();\n            RD[cur][j].clear();\n        }\n        for (int j = n - 1; j >= 0; j--) {\n            merge(i, j, RD[!cur][j + 1], {i * n + j}, RD[cur][j]);\n            merge(i, j, D[!cur][j], RD[cur][j], D[cur][j]);\n            merge(i, j, R[j + 1], RD[cur][j], R[j]);\n            std::vector<int> v;\n            merge(i, j, R[j], D[cur][j], v);\n            int x;\n            if (int(v.size()) > q) {\n                x = std::min({n - i, n - j, f(i, j, v.back())});\n            } else {\n                x = std::min(n - i, n - j);\n            }\n            ans[x]++;\n        }\n    }\n    for (int i = n; i >= 1; i--) {\n        ans[i - 1] += ans[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        std::cout << ans[i] << \"\\n\";\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Tiles for Bathroom.json",
    "editorial_link": "https://codeforces.com//blog/entry/88591",
    "editorial": "Letâs denote as max \"good\" subsquare side size with left top angle at\r\ncell. Itâs obvious that every subsquare with side less than is \"good\"\r\ntoo. So we need to find and then print answer for k-size side as . This\r\nvalue can be found with partial sums on count array of .Now we need to\r\ncalculate . Letâs notice that , because -th square is inside of square\r\nif itâs side is longer than 1. So, we can use amortized algorithm of\r\nsequential increase squareâs side. Every time when we can increase we\r\nwill do it, then we will go to calculating . Using linear algorithm to\r\ncheck if new squareâs size is \"good\", we will get solution, which is not\r\neffective enough, but can be optimized.Now letâs use small constraints\r\nfor . For each cell we will precalc array , which will have nearest\r\ncolors in line . For each color, we will keep itâs earliest occurrence\r\nIt can be calculated in , because . If exists in , we must change\r\nearliest occurrence. If it isnât, we should delete the most far color,\r\nthen insert the current one. All values can be keeped with increasing\r\nleft occurrence in for each cell.Last step we can merge in it will be\r\nthe array of values corresponding for earliest colors in line of width .\r\nMerging two lines is almost like merge of two sorted arrays it is used\r\nto find minimal left occurrences. Maximal \"good\" width can be found as\r\nleft occurrence of -th elementh minus .Now we need to unite some rows in\r\na structure and merge lines for current square, then erase first row and\r\nrepeat the process. The structure can be realized as queue on two\r\nstacks, each of whose is keeping merge value of all lines in itself. The\r\nalgorithm is almost like queue with minimal value\r\n(https://cp-algorithms.com/data_structures/stack_queue_modification.html).\r\nThatâs how we get solution with complexity .\r\n",
    "hint": []
}