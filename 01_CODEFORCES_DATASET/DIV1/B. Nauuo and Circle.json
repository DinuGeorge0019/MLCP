{
    "link": "https://codeforces.com//contest/1172/problem/B",
    "problemId": "355009",
    "problem_idx": "B",
    "shortId": "1172B",
    "contest_number": "1172",
    "problem_submissions": {
        "C2": [
            141600407,
            55254783,
            55254826,
            55257297,
            55253043,
            55256695,
            55259217,
            55259307,
            55260348,
            55256683,
            55270942,
            55262864,
            55394593,
            55256544,
            55256222,
            55256476
        ],
        "D": [
            55259812,
            55261379,
            55260385,
            55262554,
            55264421,
            55262846,
            55265864,
            55262949,
            55261237,
            55257268,
            55265259,
            55282819,
            55259099,
            55263111,
            55263637,
            55264769,
            55252234,
            55272471
        ],
        "C1": [
            55254052,
            55254936,
            55255627,
            55253139,
            55256736,
            55258621,
            55259255,
            55260376,
            55255981,
            55261688,
            55260260,
            55262975,
            55258783,
            55259505,
            55261611,
            55269127,
            55256504,
            55255804,
            55256553
        ],
        "B": [
            55249856,
            55248174,
            55250922,
            55254795,
            55250751,
            55252004,
            55254040,
            55251691,
            55250951,
            55253498,
            55253667,
            55248941,
            55252605,
            55253983,
            55255049,
            55260189,
            55249359,
            55251616,
            55252768
        ],
        "A": [
            55248325,
            55257508,
            55248960,
            55257490,
            55247357,
            55248700,
            55251742,
            55266272,
            55607192,
            55249619,
            55249678,
            55256938,
            55249251,
            55250622,
            55258815,
            55257623,
            55247019,
            55249926,
            55249357
        ],
        "E": [
            99401668,
            55317241,
            55479078,
            55479032,
            55478977
        ],
        "F": [
            55517893,
            55302923,
            55292935,
            55545710
        ]
    },
    "name": "B. Nauuo and Circle",
    "statement": "Nauuo is a girl who loves drawing circles.One day she has drawn a circle\r\nand wanted to draw a tree on it.The tree is a connected undirected graph\r\nconsisting of n nodes and n-1 edges. The nodes are numbered from 1 to\r\nn.Nauuo wants to draw a tree on the circle, the nodes of the tree should\r\nbe in n points on the circle, and the edges should be straight without\r\ncrossing each other.\"Without crossing each other\" means that every two\r\nedges have no common point or the only common point is an endpoint of\r\nboth edges.Nauuo wants to draw the tree using a permutation of n\r\nelements. A permutation of n elements is a sequence of integers p_1,p_2,\r\nldots,p_n in which every integer from 1 to n appears exactly once.After\r\na permutation is chosen Nauuo draws the i-th node in the p_i-th point on\r\nthe circle, then draws the edges connecting the nodes.The tree is given,\r\nNauuo wants to know how many permutations are there so that the tree\r\ndrawn satisfies the rule (the edges are straight without crossing each\r\nother). She only wants to know the answer modulo 998244353, can you help\r\nher?It is obvious that whether a permutation is valid or not does not\r\ndepend on which n points on the circle are chosen.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define maxn 200005\n#define ll long long\n#define ld double\n#define mod 998244353\nusing namespace std;\nint d[maxn];\nll jc[maxn];\nint main()\n{\n\tjc[0] = 1;\n\tfor(int i = 1; i < maxn; i++)\n\t\tjc[i] = jc[i - 1] * i % mod;\n\tint n;\n\tcin>>n;\n\tfor(int i = 1; i < n; i++)\n\t\t{\n\t\t\tint u, v;\n\t\t\tcin>>u>>v;\n\t\t\td[u]++, d[v]++;\n\t\t}\n\tll ans = n;\n\tfor(int i = 1; i <= n; i++)\n\t\tans = ans * jc[d[i]] % mod;\n\tcout<<ans<<endl;\n\treturn 0;\n } "
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Nauuo and Circle.json",
    "editorial_link": "https://codeforces.com//blog/entry/67511",
    "editorial": "First, if we choose a node as the root, then each subtree must\nbe in a continuous arc on the circle. Then, we can use DP to solve this\nproblem.Let be the number of plans to draw the subtree of , then choose\na position for each subtree and then itself, then draw the subtrees.\nHowever, instead of choosing the position of the root, we suppose the\nroot is on a certain point on the circle, then rotate the circle, thus\nget the answer: .In fact, we donât have to write a DP, the answer is\ntimes the product of the factorial of each nodeâs degree ().\n",
    "hint": []
}