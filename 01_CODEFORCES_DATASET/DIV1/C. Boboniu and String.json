{"link": "https://codeforces.com//contest/1394/problem/C", "problemId": "697386", "problem_idx": "C", "shortId": "1394C", "contest_number": "1394", "problem_submissions": {"E": [89738268, 89751614, 89751306, 89748113, 92138216, 90294852], "C": [89732445, 89683758, 89696028, 89683626, 89694594, 89712053, 89693715, 89701612, 89697873, 89702287, 89692727, 89701355, 89703625, 90289383, 89700363, 89706177, 89705251, 89703716, 89721405, 89690071, 89703493, 89708013], "D": [89693191, 89704513, 89710792, 89709417, 89804436, 89704286, 89710073, 89710943, 89707637, 89713733, 89713912, 89711885, 89714265, 90289402, 89722481, 89717905, 89719820, 89719453, 89709166, 89707845, 89725892, 89720000], "B": [89670028, 89681474, 89694856, 89677267, 89803448, 89803280, 89758188, 89757972, 89693039, 89682124, 89685684, 89674007, 89686030, 89674213, 89680671, 89691474, 90289363, 89685315, 89684531, 89683358, 89689040, 89677823, 89676540, 89686855, 89686732], "A": [89662871, 89663327, 89661651, 89662462, 89662370, 89664124, 89666251, 89712037, 89661542, 89665502, 89668072, 89669720, 90289341, 89661258, 89665118, 89665097, 89669384, 89661494, 89728914, 89662580, 89663285]}, "name": "C. Boboniu and String", "statement": "Boboniu defines as a string s of characters \u2019B\u2019 and \u2019N\u2019.You can perform\r\nthe following operations on the BN-string s: Remove a character of s.\r\nRemove a substring \"\" or \"\" of s. Add a character \u2019B\u2019 or \u2019N\u2019 to the end\r\nof s. Add a string \"\" or \"\" to the end of s. Note that a string a is a\r\nof a string b if a can be obtained from b by deletion of several\r\n(possibly, zero or all) characters from the beginning and several\r\n(possibly, zero or all) characters from the end.Boboniu thinks that\r\nBN-strings s and t are if and only if: |s|=|t|. There exists a\r\npermutation p_1, p_2,\r\nldots, p_{|s|} such that for all i (1\r\nle i\r\nle |s|), s_{p_i}=t_i. Boboniu also defines\r\ntext{dist}(s,t), the between s and t, as the minimum number of\r\noperations that makes s to t.Now Boboniu gives you n non-empty\r\nBN-strings s_1,s_2,\r\nldots, s_n and asks you to find a BN-string t such that the maximum\r\ndistance to string s is minimized, i.e. you need to minimize\r\nmax_{i=1}^n\r\ntext{dist}(s_i,t).\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 12.08.2020 17:47:26       \n**/\n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n \nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n \nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n \nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n \nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n \ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n \ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n \nvoid debug_out() { cerr << endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n \n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  const int inf = (int) 1e8;\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    for (char c : s) {\n      if (c == 'B') {\n        ++x[i];\n      } else {\n        ++y[i];\n      }\n    }\n  }\n  int px = -1, py = -1;\n  int low = 0, high = inf;\n  while (low <= high) {\n    int mid = (low + high) >> 1;\n    int mind = -inf;\n    int maxd = inf;\n    int minx = 0;\n    int maxx = inf;\n    int miny = 0;\n    int maxy = inf;\n    for (int i = 0; i < n; i++) {\n      mind = max(mind, x[i] - y[i] - mid);\n      maxd = min(maxd, x[i] - y[i] + mid);\n      minx = max(minx, x[i] - mid);\n      maxx = min(maxx, x[i] + mid);\n      miny = max(miny, y[i] - mid);\n      maxy = min(maxy, y[i] + mid);\n    }\n    bool ok = false;\n    if (mind <= maxd && minx <= maxx && miny <= maxy) {\n      for (int rot = 0; rot < 3; rot++) {\n        int x = (rot == 0 ? minx : (rot == 1 ? min(maxx, minx + 1) : maxx));\n        int from = max(miny, x-maxd);\n        int to = min(maxy, x-mind);\n        if (x == 0) {\n          from = max(from, 1);\n        }\n        if (from <= to) {\n          ok = true;\n          px = x;\n          py = from;\n        }\n      }\n      for (int rot = 0; rot < 3; rot++) {\n        int y = (rot == 0 ? miny : (rot == 1 ? min(maxy, miny + 1) : maxy));\n        int from = max(minx, mind + y);\n        int to = min(maxx, maxd + y);\n        if (y == 0) {\n          from = max(from, 1);\n        }\n        if (from <= to) {\n          ok = true;\n          px = from;\n          py = y;\n        }\n      }\n    }\n    if (low == high) {\n      assert(ok);\n      break;\n    }\n    if (ok) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n  cout << low << '\\n';\n  for (int i = 0; i < px; i++) {\n    cout << 'B';\n  }\n  for (int i = 0; i < py; i++) {\n    cout << 'N';\n  }\n  cout << '\\n';\n  return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "geometry", "ternary search"], "dificulty": "2600", "interactive": false}