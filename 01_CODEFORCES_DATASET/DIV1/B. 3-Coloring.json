{
    "link": "https://codeforces.com//contest/1503/problem/B",
    "problemId": "945470",
    "problem_idx": "B",
    "shortId": "1503B",
    "contest_number": "1503",
    "problem_submissions": {
        "F": [
            111939776,
            111936345,
            111953640,
            111949537,
            111942068,
            111944734,
            111944711,
            111948141,
            111947867,
            113984444
        ],
        "E": [
            111918055,
            111912666,
            111918864,
            111923939,
            111922990,
            111923269,
            111922053,
            111920801,
            111927922,
            111926604,
            111931364,
            111936374,
            111926173,
            111935792,
            111929517,
            111930613,
            111937713,
            111935328,
            111934244
        ],
        "D": [
            111903738,
            111902585,
            111898744,
            111893896,
            111901869,
            111902624,
            111880076,
            111902059,
            111906951,
            111905795,
            111910439,
            111899185,
            111916472,
            111904574,
            111913444,
            111910826,
            111914877,
            111924091,
            111906860
        ],
        "C": [
            111886477,
            111890876,
            111881938,
            111886094,
            111882409,
            111883959,
            111902446,
            111905834,
            111885208,
            111897171,
            111889963,
            111890061,
            111888926,
            111886850,
            111898651,
            111896248,
            111894668,
            111884135,
            111889304
        ],
        "B": [
            111876447,
            111888244,
            111877449,
            111876120,
            111878468,
            111878981,
            111893644,
            111877927,
            111878327,
            111877579,
            111878407,
            111882807,
            111900739,
            111880662,
            111889601,
            111886898,
            111883228,
            111878516,
            111916268
        ],
        "A": [
            111871860,
            111872029,
            111873354,
            111871912,
            111872701,
            111874636,
            111888931,
            111872574,
            111873406,
            111872331,
            111873739,
            111875192,
            111873092,
            111873513,
            111878839,
            111875591,
            111873509,
            111872858,
            111893066
        ]
    },
    "name": "B. 3-Coloring",
    "statement": "Alice and Bob are playing a game. There is n\r\ntimes n grid, initially empty. We refer to the cell in row i and column\r\nj by (i, j) for 1\r\nle i, j\r\nle n. There is an infinite supply of tokens that come in 3 colors\r\nlabelled 1, 2, and 3.The game proceeds with turns as follows. Each turn\r\nbegins with Alice naming one of the three colors, let’s call it a. Then,\r\nBob chooses a color b\r\nne a, chooses an empty cell, and places a token of color b on that\r\ncell.We say that there is a if there exist two adjacent cells containing\r\ntokens of the same color. Two cells are considered adjacent if they\r\nshare a common edge.If at any moment there is a conflict, Alice wins.\r\nOtherwise, if n^2 turns are completed (so that the grid becomes full)\r\nwithout any conflicts, Bob wins.We have a proof that Bob has a winning\r\nstrategy. Play the game as Bob and win.The interactor is . That is,\r\nAlice’s color choices can depend on Bob’s previous moves.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint n;\n\tcin >> n;\n\tset<pair<int,int>> odd, even;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif((i + j) & 1){\n\t\t\t\todd.insert({i, j});\n\t\t\t} else {\n\t\t\t\teven.insert({i, j});\n\t\t\t}\n\t\t}\n\t}\n\tfor(int t = 0; t < n*n; t++){\n\t\tint a;\n\t\tcin >> a;\n\t\tif(odd.size() && even.size()){\n\t\t\tint c = (a == 1) ? 2 : 1;\n\t\t\tset<pair<int,int>>& x = (c == 1) ? odd : even;\n\t\t\tpair<int,int> f = *x.begin();\n\t\t\tx.erase(f);\n\t\t\tcout << c << ' ' << (f.first + 1) << ' ' << (f.second + 1) << '\\n';\n\t\t\tcout << flush;\n\t\t} else {\n\t\t\tset<pair<int,int>>& x = even.empty() ? odd : even;\n\t\t\tint wh = even.empty() ? 1 : 2;\n\t\t\tpair<int,int> f = *x.begin();\n\t\t\tx.erase(f);\n\t\t\tint c = (a == 3) ? (wh) : 3;\n\t\t\tcout << c << ' ' << (f.first + 1) << ' ' << (f.second + 1) << '\\n';\n\t\t\tcout << flush;\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games",
        "interactive"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. 3-Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/89319",
    "editorial": "Imagine the grid is colored like a checkerboard with black and white squares. Then Bob's strategy is to put tokens 1\n on white squares and tokens 2\n on black squares as long as he is able. If he is unable, this means all squares of one color are filled, and he can start placing tokens 3\n without making an invalid coloring. More specifically, this is his strategy:\n\nIf Alice chooses 1\n:\nIf a black square is free, place a 2\n there.\nOtherwise, place a 3\n on a white cell.\nIf Alice chooses 2\n:\nIf a white square is free, place a 1\n there.\nOtherwise, place a 3\n on a black cell.\nIf Alice chooses 3\n:\nIf a white square is free, place a 1\n there.\nOtherwise, place a 2\n on a black cell.",
    "hint": []
}