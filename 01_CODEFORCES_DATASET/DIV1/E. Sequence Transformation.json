{"link": "https://codeforces.com//contest/280/problem/E", "problemId": "2729", "problem_idx": "E", "shortId": "280E", "contest_number": "280", "problem_submissions": {"A": [3287460, 3287361, 3276397, 3278813, 3276368, 3275958, 3278969, 3275819, 3275811, 3278894, 3281142, 3276025, 3282276, 3280827, 3278671, 3278926], "D": [3281691, 3283266, 3283731, 3285347, 3322215], "C": [3279306, 3279945, 3277746, 3276734, 3279642, 3277787, 3276636, 3278485, 3278848, 3279470, 3277629, 3279115, 3276052, 3276649, 3279355, 3279152], "B": [3276405, 3279061, 3277000, 3276260, 3284541, 3277306, 3275980, 3276370, 3276567, 3276408, 3276287, 3277081, 3278515, 3277959, 3275542, 3276177], "E": [3351075]}, "name": "E. Sequence Transformation", "statement": "You\u2019ve got a non-decreasing sequence . You\u2019ve also got two integers and\r\n.Your task is to transform sequence into some sequence . The\r\ntransformation price is the following sum: . Your task is to choose such\r\nsequence that minimizes the described transformation price.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n\n\nusing namespace std;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nll rdtsc() {\n    ll tmp;\n    asm(\"rdtsc\" : \"=A\"(tmp));\n    return tmp;\n}\n\n#define TASKNAME \"text\"\n#define pb push_back\n#define mp make_pair\n#define EPS (1e-9)\n#define INF ((int)1e9)\n#define sqr(x) ((x) * (x))         \n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\nconst int maxn = 6000;\nint A, B;\nint n, q;\nint x[maxn];\n\nstruct func {\n\tdouble a, b, c;\n\tdouble l, r;\n\t\n\tfunc() {}\n\tfunc(double _a, double _b, double _c, double _l, double _r) : a(_a), b(_b), c(_c), l(_l), r(_r) {}\n\t\n\tinline double get(double x) const {\n\t\treturn (a * x + b) * x + c;\n\t}\n\t\n\tinline void operator >>= (const double d) {\n\t\tc += d * (d * a - b);\n\t\tb -= 2 * a * d;\n\t}\n\t\n\tinline void operator += (const func &f) {\n\t\ta += f.a, b += f.b, c += f.c;\n\t}\n\t\n\tinline double getMiddle() const {\n\t\treturn -b / 2.0 / a;\n\t}\n\t\n\tinline void print() {\n\t\teprintf(\"%.3lf %.3lf %.3lf %.3lf %.3lf\\n\", a, b, c, l, r);\n\t}\n};\n\nfunc fs[2 * maxn + 10];\nint cntfs;\n\ndouble res;\ndouble ans[maxn];\n\nvoid solve(int iter) {\n\tif (!iter) {\n\t\tcntfs = 1;\n\t\tfs[0] = func(1, 0, 0, 1, q);\n\t\tfs[0] >>= x[0];\n\t\tsolve(1);\n\t\treturn;\n\t}\n\t\n\tint center;\n\tfor (center = 0; center < cntfs; center++) {\n\t\tif (fs[center].getMiddle() >= fs[center].r - EPS)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\t\n\tdouble minX = (center == cntfs ? fs[cntfs - 1].r : max(fs[center].l, fs[center].getMiddle()));\n\tdouble minY = center < cntfs ? fs[center].get(minX) : fs[cntfs - 1].get(minX);\n// \teprintf(\"minX = %.3lf, minY = %.3lf\\n\", minX, minY);\n\tif (iter == n) {\n\t\tres = minY;\n\t\tans[iter - 1] = minX;\n\t\treturn;\n\t}\n\tif (A < B) {\n\t\tif (center < cntfs && fs[center].l + EPS < minX && minX + EPS < fs[center].r) {\n\t\t\tcntfs += 2;\n\t\t\tfor (int i = cntfs - 1; i > center + 1; i--)\n\t\t\t\tfs[i] = fs[i - 2];\n\t\t\tfs[center + 2].l = fs[center].r = minX;\n\t\t\t++center;\n\t\t\tfs[center] = func(0, 0, fs[center - 1].get(minX), minX, minX);\n\t\t} else {\n\t\t\tcntfs += 1;\n\t\t\tfor (int i = cntfs - 1; i > center; i--)\n\t\t\t\tfs[i] = fs[i - 1];\n\t\t\tfs[center].l = fs[center].r = minX;\n\t\t}\n\t\tfs[center].a = fs[center].b = 0;\n\t\tfs[center].c = minY;\n\t}\n\t\n\tfunc toAdd = func(1, 0, 0, -1, -1);\n\ttoAdd >>= x[iter];\n\tfor (int i = 0; i < cntfs; i++) {\n\t\tfs[i].l += (i <= center ? A : B);\n\t\tfs[i].r += (i < center ? A : B);\n\t\tfs[i] >>= (i < center ? A : B);\n\t\tfs[i] += toAdd;\n\t}\n// \tfor (int i = 0; i < cntfs; i++)\n// \t\tfs[i].print();\n\twhile (cntfs && fs[cntfs - 1].l >= q - EPS)\n\t\tcntfs--;\n\tfs[cntfs - 1].r = min(fs[cntfs - 1].r, (double)q);\n\t\n\tsolve(iter + 1);\n\tdouble &cur = ans[iter - 1];\n\tcur = ans[iter];\n\tif (cur > minX + B + EPS)\n\t\tcur -= B;\n\telse { \n\t\tif (cur < minX + A - EPS)\n\t\t\tcur -= A;\n\t\telse\n\t\t\tcur = minX;\n\t}\n}\n\nint main() {\n\tsrand(rdtsc());\n#ifdef DEBUG\n\tfreopen(TASKNAME\".in\", \"r\", stdin);\n\tfreopen(TASKNAME\".out\", \"w\", stdout);\n#endif\n\t\n\twhile (scanf(\"%d%d%d%d\", &n, &q, &A, &B) >= 1) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t\n\t\tsolve(0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%.18lf%c\", ans[i], \" \\n\"[i == n - 1]);\n\t\tprintf(\"%.18lf\\n\", res);\n// \t\t\t\tbreak;\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "dp", "implementation", "math"], "dificulty": "3000", "interactive": false}