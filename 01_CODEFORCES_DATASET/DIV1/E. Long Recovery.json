{"link": "https://codeforces.com//contest/1446/problem/E", "problemId": "797260", "problem_idx": "E", "shortId": "1446E", "contest_number": "1446", "problem_submissions": {"D2": [98488179, 98479602, 98464320, 98467493, 98464495, 98464291, 98477056, 98482171, 98496133, 98469225, 98470769, 98488185, 98481918, 98482926, 98479038], "F": [98482236, 98470414, 98500090, 98497700, 98476856, 98476210, 98484136, 98489678, 98481827, 98491554, 98484171, 98504348, 98502497, 98493379, 98482100, 98486768, 98492674, 98490163, 98501084], "E": [98475344, 98498258, 98500804, 98495217, 115705388, 106404746], "D1": [98457158, 98460382, 98456556, 98456978, 98464440, 98464426, 98466567, 98470196, 98464176, 98472990, 98478320, 98479479, 98482287, 98493368, 98460232, 98466662, 98460275, 98466691, 98472979, 98478998], "C": [98450996, 98452840, 98450218, 98453943, 98450946, 98452214, 98452223, 98455447, 98455497, 98455239, 98461758, 98461392, 98466665, 98466780, 98453580, 98454283, 98455611, 98457408, 98454698, 98458074], "B": [98446682, 98448334, 98447974, 98447142, 98452896, 98448193, 98448567, 98451491, 98449697, 98450934, 98454616, 98452183, 98446811, 98455267, 98447295, 98450250, 98449344, 98450158, 98450376, 98449480], "A": [98444992, 98445944, 98444925, 98445065, 98445347, 98445666, 98444771, 98446535, 98446420, 98447534, 98447441, 98445935, 98450208, 98461593, 98445099, 98445257, 98445487, 98446333, 98447509, 98445254]}, "name": "E. Long Recovery", "statement": "A patient has been infected with an unknown disease. His body can be\r\nseen as an infinite grid of triangular cells which looks as follows: Two\r\ncells are neighboring if they share a side. Therefore, each cell (x, y)\r\nhas exactly three neighbors: (x+1, y) (x-1, y) (x+1, y-1) if x is even\r\nand (x-1, y+1) otherwise. Initially some cells are infected, all the\r\nothers are healthy. The process of recovery begins. Each second, for\r\ncell (even though there might be multiple cells that could change its\r\nstate) one of the following happens: A healthy cell with at least 2\r\ninfected neighbors also becomes infected. An infected cell with at least\r\n2 healthy neighbors also becomes healthy. If no such cell exists, the\r\nprocess of recovery stops. Patient is considered recovered if the\r\nprocess of recovery has stopped and all the cells are healthy.We\u2019re\r\ninterested in a scenario: is it possible that the patient never\r\nrecovers, or if it\u2019s not possible, what is the maximum possible duration\r\nof the recovery process?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 510;\nconst int M = N * N;\nint id[N][N];\nbool isBlack[M];\nvector<int> g[M];\nvector<pii> neigh[N][N];\nbool used[M];\nint n;\nint sumDeg;\nint szComp;\nbool allEmpty;\n\nvoid check(int x, int y) {\n\tassert(x >= 2 && y >= 2 && x < N - 2 && y < N - 2);\n\tif (id[x][y] != -1) return;\n\tint cnt = 0;\n\tfor (auto t : neigh[x][y]) {\n\t\tint xx = t.first, yy = t.second;\n\t\tif (id[xx][yy] != -1) cnt++;\n\t}\n\tif (cnt < 2) return;\n\tid[x][y] = n++;\n\tfor (auto t : neigh[x][y])\n\t\tcheck(t.first, t.second);\n}\n\nvoid dfs(int v) {\n\tszComp++;\n\tsumDeg += (int)g[v].size();\n\tfor (int u : g[v])\n\t\tif (isBlack[v] && isBlack[u])\n\t\t\tallEmpty = false;\n\tif (!isBlack[v]) {\n\t\tint cnt = 0;\n\t\tfor (int u : g[v])\n\t\t\tif (isBlack[u])\n\t\t\t\tcnt++;\n\t\tif (cnt == 2) allEmpty = false;\n\t}\n\tused[v] = 1;\n\tfor (int u : g[v])\n\t\tif (!used[u])\n\t\t\tdfs(u);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tfor (int x = 0; x < N; x++)\n\t\tfor (int y = 0; y < N; y++)\n\t\t\tid[x][y] = -1;\n\tfor (int x = 2; x < N - 2; x++)\n\t\tfor (int y = 2; y < N - 2; y++) {\n\t\t\tneigh[x][y].push_back(mp(x - 1, y));\n\t\t\tneigh[x][y].push_back(mp(x + 1, y));\n\t\t\tif (x % 2 == 0) {\n\t\t\t\tneigh[x][y].push_back(mp(x + 1, y - 1));\n\t\t\t} else {\n\t\t\t\tneigh[x][y].push_back(mp(x - 1, y + 1));\n\t\t\t}\n\t\t}\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx += 4;\n\t\ty += 4;\n\t\tid[x][y] = i;\n\t\tisBlack[i] = 1;\n\t}\n\tfor (int x = 2; x < N - 2; x++)\n\t\tfor (int y = 2; y < N - 2; y++) {\n\t\t\tcheck(x, y);\n\t\t}\n\tfor (int x = 2; x < N - 2; x++)\n\t\tfor (int y = 2; y < N - 2; y++) {\n\t\t\tif (id[x][y] == -1) continue;\n\t\t\tint v = id[x][y];\n\t\t\tfor (pii t : neigh[x][y]) {\n\t\t\t\tint u = id[t.first][t.second];\n\t\t\t\tif (u == -1) continue;\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\tint ans = 0;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (!isBlack[v]) continue;\n\t\tans += 3;\n\t\tfor (int u : g[v])\n\t\t\tif (isBlack[u])\n\t\t\t\tans--;\n\t}\n\tfor (int v = 0; v < n; v++) {\n\t\tif (used[v]) continue;\n\t\tsumDeg = 0;\n\t\tszComp = 0;\n\t\tallEmpty = true;\n\t\tans -= 2;\n\t\tdfs(v);\n\t\tif (sumDeg != 2 * szComp - 2) {\n\t\t\tprintf(\"SICK\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (allEmpty && szComp > 1) ans -= 2;\n\t}\n\tprintf(\"RECOVERED\\n%d\\n\", ans);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar"], "dificulty": "3500", "interactive": false}