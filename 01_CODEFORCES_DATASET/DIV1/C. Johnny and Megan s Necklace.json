{
    "link": "https://codeforces.com//contest/1361/problem/C",
    "problemId": "640970",
    "problem_idx": "C",
    "shortId": "1361C",
    "contest_number": "1361",
    "problem_submissions": {
        "F": [
            82547256,
            82558388,
            82548841,
            82560787,
            82546613,
            82571701,
            82569539,
            82568479,
            82553474,
            82561525
        ],
        "D": [
            82532533,
            82534707,
            82556057,
            82527759,
            82536652,
            82533679,
            82553972,
            82540929,
            82539127,
            82540566,
            86424872,
            82526480,
            82568104,
            82567738,
            82567880
        ],
        "E": [
            82521789,
            82543705,
            82541718,
            82540946,
            82583418,
            82541333,
            82541041,
            82533619,
            82550465,
            82553317,
            82579674,
            82579569,
            82559988,
            82559485,
            82543445,
            82543446,
            82551504,
            82544569,
            82550130,
            82547325,
            82579220,
            82517696
        ],
        "C": [
            82504494,
            82509183,
            82560689,
            82519634,
            82513804,
            82519054,
            82526119,
            82516120,
            82517904,
            82521411,
            82523427,
            82525691,
            82518977,
            82516229,
            82512604,
            82516960,
            82527524,
            82521519,
            82527700,
            82553581
        ],
        "B": [
            82495175,
            82498230,
            82507103,
            82567148,
            82501464,
            82497400,
            82516527,
            82498261,
            82504352,
            82509962,
            82510314,
            82502680,
            82509498,
            82502669,
            82499583,
            82499214,
            82513823,
            82505015,
            82504805,
            82531052
        ],
        "A": [
            82492363,
            82493600,
            82494974,
            82494327,
            82492565,
            82492329,
            82494389,
            82493605,
            82492642,
            82494930,
            82499298,
            82494769,
            82492795,
            82495342,
            82493416,
            82492640,
            82495622,
            82493415,
            82512573,
            82523180
        ]
    },
    "name": "C. Johnny and Megan s Necklace",
    "statement": "Johnny\u2019s younger sister Megan had a birthday recently. Her brother has\r\nbought her a box signed as \"\". It contains many necklace parts and some\r\nmagic glue. The necklace part is a chain connecting two pearls. Color of\r\neach pearl can be defined by a non-negative integer. The magic glue\r\nallows Megan to merge two pearls (possibly from the same necklace part)\r\ninto one. The beauty of a connection of pearls in colors u and v is\r\ndefined as follows: let 2^k be the greatest power of two dividing u\r\noplus v exclusive or of u and v. Then the beauty equals k. If u = v, you\r\nmay assume that beauty is equal to 20.Each pearl can be combined with\r\nanother at most once. Merging two parts of a necklace connects them.\r\nUsing the glue multiple times, Megan can finally build the necklace,\r\nwhich is a cycle made from connected necklace parts (so every pearl in\r\nthe necklace is combined with precisely one other pearl in it). The\r\nbeauty of such a necklace is the minimum beauty of a single connection\r\nin it. The girl wants to use all available necklace parts to build\r\nnecklace consisting of with the largest possible beauty. Help her!\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 04.06.2020 17:49:08       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass undigraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  undigraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nvector<int> find_eulerian_path(const graph<T> &g, int &root) {\n  vector<int> in_deg(g.n, 0);\n  vector<int> out_deg(g.n, 0);\n  int cnt_edges = 0;\n  for (int id = 0; id < (int) g.edges.size(); id++) {\n    cnt_edges++;\n    auto &e = g.edges[id];\n    out_deg[e.from]++;\n    in_deg[e.to]++;\n  }\n  root = -1;\n  int odd = 0;\n  for (int i = 0; i < g.n; i++) {\n    if ((in_deg[i] + out_deg[i]) % 2 == 1) {\n      odd++;\n      if (root == -1 || out_deg[i] - in_deg[i] > out_deg[root] - in_deg[root]) {\n        root = i;\n      }\n    }\n  }\n  if (odd > 2) {  \n    root = -1;\n    return vector<int>();\n  }\n  if (root == -1) {\n    root = 0;\n    while (root < g.n && in_deg[root] + out_deg[root] == 0) {\n      root++;\n    }\n    if (root == g.n) {\n      root = 0;\n      return vector<int>();\n    }\n  }\n  vector<bool> used(g.edges.size(), false);\n  vector<int> ptr(g.n, 0);\n  vector<int> balance(g.n, 0);\n  vector<int> res(cnt_edges);\n  int stack_ptr = 0;\n  int write_ptr = cnt_edges;\n  int v = root;\n  while (true) {\n    bool found = false;\n    while (ptr[v] < (int) g.g[v].size()) {\n      int id = g.g[v][ptr[v]++];\n      if (used[id]) {\n        continue;\n      }\n      used[id] = true;\n      res[stack_ptr++] = id;\n      auto &e = g.edges[id];\n      balance[v]++;\n      v ^= e.from ^ e.to;\n      balance[v]--;\n      found = true;\n      break;\n    }\n    if (!found) {\n      if (stack_ptr == 0) {\n        break;\n      }\n      int id = res[--stack_ptr];\n      res[--write_ptr] = id;\n      auto &e = g.edges[id];\n      v ^= e.from ^ e.to;\n    }\n  }\n  int disbalance = 0;\n  for (int i = 0; i < g.n; i++) {\n    disbalance += abs(balance[i]);\n  }\n  if (write_ptr != 0 || disbalance > 2) {\n    root = -1;\n    return vector<int>();\n  }\n  return res;\n  // returns edge ids in the path (or the cycle if it exists)\n  // root == -1 if there is no path\n  // (or res.empty(), but this is also true when there are no edges)\n}\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    cin >> a[i];\n  }\n  for (int p = 20; p >= 0; p--) {\n    int mask = (1 << p) - 1;\n    dsu d(mask + 1);\n    vector<int> deg(mask + 1);\n    for (int i = 0; i < 2 * n; i += 2) {\n      int x = a[i] & mask;\n      int y = a[i + 1] & mask;\n      d.unite(x, y);\n      deg[x] += 1;\n      deg[y] += 1;\n    }\n    bool ok = true;\n    for (int i = 0; i <= mask; i++) {\n      if (deg[i] & 1) {\n        ok = false;\n        break;\n      }\n    }\n    if (!ok) {\n      continue;\n    }\n    int z = -1;\n    for (int i = 0; i <= mask; i++) {\n      if (deg[i] == 0) {\n        continue;\n      }\n      int x = d.get(i);\n      if (z == -1) {\n        z = x;\n      } else {\n        if (z != x) {\n          ok = false;\n          break;\n        }\n      }\n    }\n    if (!ok) {\n      continue;\n    }\n    undigraph<int> g(mask + 1);\n    for (int i = 0; i < 2 * n; i += 2) {\n      int x = a[i] & mask;\n      int y = a[i + 1] & mask;\n      g.add(x, y);\n    }\n    int root = -1;\n    auto path = find_eulerian_path(g, root);\n    assert((int) path.size() == n);\n    cout << p << '\\n';\n    for (int i = 0; i < n; i++) {\n      if (i > 0) {\n        cout << \" \";\n      }\n      int j = path[i];\n      int x = a[2 * j] & mask;\n      int y = a[2 * j + 1] & mask;\n      if (x == root) {\n        cout << 2 * j + 1 << \" \" << 2 * j + 2;\n        root = y;\n      } else {\n        assert(y == root);\n        cout << 2 * j + 2 << \" \" << 2 * j + 1;\n        root = x;\n      }\n    }\n    cout << '\\n';\n    break;\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Johnny and Megan s Necklace.json",
    "editorial_link": "https://codeforces.com//blog/entry/78355",
    "editorial": "Say that we want to check if it is possible to construct a necklace with\r\nbeauty at least . To this end, we will construct a graph of vertices.\r\nFor a necklace part with pearls in colors and there will be an edge in\r\nthis graph between vertices with zero-based indices and . In a necklace\r\nwith beauty (at least) , only pearl with colors having last bits the\r\nsame can be glued together. Note that this is the exact condition that\r\nthe edge endpoints have to satisfy to be in the same vertex. Since all\r\nthe necklace parts have to be used, a necklace of beauty at least is an\r\nEuler cycle of this graph.The solution will construct the graph\r\nmentioned above for all possible values of (we can iterate over all of\r\nthem since there are only of them). If the constructed graph is\r\nEulerian, it is possible to achieve the current value of .In order to\r\nfind a sample necklace with the optimal beauty, one has to find the\r\nEuler cycle in the graph corresponding to the optimal value. : In\r\nanother version of this task you are not allowed to glue pearls of the\r\nsame color together. There is also a guarantee that there are no three\r\npearls of the same color. Time complexity of the solution is the same.\r\n"
}