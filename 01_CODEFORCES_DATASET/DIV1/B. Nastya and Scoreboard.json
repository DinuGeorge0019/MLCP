{
    "link": "https://codeforces.com//contest/1340/problem/B",
    "problemId": "599366",
    "problem_idx": "B",
    "shortId": "1340B",
    "contest_number": "1340",
    "problem_submissions": {
        "F": [
            77861280,
            77852254,
            77849797,
            78528429,
            78527982,
            77845721,
            77870771,
            77870728,
            77870667,
            77809735,
            77844929,
            78038847,
            77865877,
            77864401,
            77864363,
            77862346,
            77862326
        ],
        "D": [
            77814886,
            77820644,
            77812632,
            77817969,
            78526970,
            77818222,
            77825103,
            77825677,
            77810183,
            77803432,
            77810910,
            77812394,
            77816455,
            77825551,
            77843873,
            77828804,
            77822663,
            77822063
        ],
        "C": [
            77795843,
            77812380,
            77824845,
            77823255,
            78526952,
            77799809,
            77811601,
            77834672,
            77830782,
            77811370,
            77793451,
            77808028,
            77797811,
            77795450,
            77802848,
            77796169,
            77858001,
            77810294,
            77809842
        ],
        "A": [
            77782251,
            77771158,
            77774810,
            77787508,
            78526918,
            78526910,
            77776379,
            77774309,
            77776029,
            77816613,
            77771928,
            77777830,
            77775868,
            77773607,
            77771508,
            77776009,
            77776621,
            77773349,
            77795835,
            77779579,
            77772710,
            77776861
        ],
        "B": [
            77777625,
            77796394,
            77787259,
            77781233,
            78526935,
            77868779,
            77790975,
            77793147,
            77821618,
            77789026,
            77773962,
            77770331,
            77782427,
            77780486,
            77790796,
            77783960,
            77786770,
            77783985,
            77790124,
            77791298,
            77788341
        ],
        "E": [
            77836196,
            77868575,
            77868568,
            77868546,
            77868525,
            77868496,
            77845628,
            77864964,
            77846936,
            77902183,
            77902167,
            77902121,
            77902068,
            77902045,
            77901978,
            77850099,
            77859253,
            77828316,
            77849841,
            77848435,
            77856908,
            77842257
        ]
    },
    "name": "B. Nastya and Scoreboard",
    "statement": "The poor boy was very upset because of that. He was so sad that he\r\npunched some kind of scoreboard with numbers. The numbers are displayed\r\nin the same way as on an electronic clock: each digit position consists\r\nof 7 segments, which can be turned on or off to display different\r\nnumbers. The picture shows how all 10 decimal digits are displayed:\r\nAfter the punch, some segments stopped working, that is, some segments\r\nmight stop glowing if they glowed earlier. But Denis remembered how many\r\nsticks were glowing and how many are glowing now. Denis broke k segments\r\nand he knows which sticks are working now. Denis came up with the\r\nquestion: what is the maximum possible number that can appear on the\r\nboard if you turn on exactly k sticks (which are off now)? It is that\r\nthe number includes leading zeros.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nconst string DIGS[10] = {\"1110111\", \"0010010\", \"1011101\", \"1011011\", \"0111010\", \"1101011\", \"1101111\", \"1010010\", \"1111111\", \"1111011\"};\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tint N, K; cin >> N >> K;\n\tvector<string> A(N);\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n\tvector<vector<bool>> poss(N+1, vector<bool>(K+1));\n\tposs[N][K] = true;\n\n\tvector<vector<int>> diffs(N, vector<int>(10));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tint diff = 0;\n\t\t\tbool good = true;\n\t\t\tfor (int v = 0; v < 7; v++) {\n\t\t\t\tif (DIGS[d][v] < A[i][v]) {\n\t\t\t\t\tgood = false;\n\t\t\t\t} else if (DIGS[d][v] > A[i][v]) {\n\t\t\t\t\tdiff++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdiffs[i][d] = (good ? diff : -1);\n\t\t}\n\t}\n\n\tfor (int i = N-1; i >= 0; i--) {\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tint diff = diffs[i][d];\n\t\t\tif (diff == -1) continue;\n\t\t\tfor (int a = 0; a+diff <= K; a++) {\n\t\t\t\tif (poss[i+1][a+diff]) poss[i][a] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!poss[0][0]) {\n\t\tcout << -1 << '\\n';\n\t\texit(0);\n\t}\n\n\tstring ans;\n\tint cur = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tassert(poss[i][cur]);\n\t\tfor (int d = 9; true; d--) {\n\t\t\tassert(d >= 0);\n\t\t\tint diff = diffs[i][d];\n\t\t\tif (diff == -1) continue;\n\t\t\tif (cur+diff <= K && poss[i+1][cur+diff]) {\n\t\t\t\tans += char('0'+d);\n\t\t\t\tcur += diff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "graphs",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Nastya and Scoreboard.json",
    "editorial_link": "https://codeforces.com//blog/entry/76479",
    "editorial": "Let dp[i][j]=true\n, if at the suffix i\u0085n\n you can turn on exactly j\n sticks and get the correct sequence of digits and false\n otherwise. It is easy to recalculate this dynamics: we will make transitions to all possible digits (the mask at position i\n should be a submask of the digit).\n\nAsymptotic calculate of the dynamics O(10nd)\n.\n\nNow let's go in order from 1\n to n\n and will try to eagerly set the maximum possible figure using our dynamics. It is easy to understand that in this way we get the maximum possible number of n\n digits."
}