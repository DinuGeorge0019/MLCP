{
    "link": "https://codeforces.com//contest/553/problem/E",
    "problemId": "30217",
    "problem_idx": "E",
    "shortId": "553E",
    "contest_number": "553",
    "problem_submissions": {
        "D": [
            11744562,
            11744498,
            11745257,
            11745223,
            11745470,
            11745572,
            11744919,
            11745032,
            11745427,
            11746100,
            11746456,
            11746392,
            11746335,
            11745162,
            11746455,
            11746854,
            11746886,
            11745082
        ],
        "C": [
            11742306,
            11742552,
            11743239,
            11743506,
            11742528,
            11742781,
            11742831,
            11741480,
            11743177,
            11743672,
            11744065,
            11743860,
            11743962,
            11742856,
            11745114,
            11744324,
            11744734,
            11743321
        ],
        "B": [
            11740294,
            11741146,
            11741320,
            11741933,
            11744161,
            11741212,
            11741622,
            11743234,
            11743626,
            11740923,
            11740570,
            11741924,
            11742141,
            11741812,
            11743960,
            11742897,
            11743061,
            11741732
        ],
        "A": [
            11739123,
            11739635,
            11739748,
            11739276,
            11740077,
            11739044,
            11739303,
            11739327,
            11739192,
            11744185,
            11739212,
            11740023,
            11739776,
            11740185,
            11741127,
            11739503,
            11739666
        ],
        "E": [
            11751187,
            11762331
        ]
    },
    "name": "E. Kyoya and Train",
    "statement": "Kyoya Ootori wants to take the train to get to school. There are train\r\nstations and one-way train lines going between various stations. Kyoya\r\nis currently at train station , and the school is at station . To take a\r\ntrain, he must pay for a ticket, and the train also takes a certain\r\namount of time. However, the trains are not perfect and take random\r\namounts of time to arrive at their destination. If Kyoya arrives at\r\nschool strictly after time units, he will have to pay a fine of .Each\r\ntrain line is described by a ticket price, and a probability\r\ndistribution on the time the train takes. More formally, train line has\r\nticket cost , and a probability distribution which denotes the\r\nprobability that this train will take time units for all . Amounts of\r\ntime that each of the trains used by Kyouya takes are mutually\r\nindependent random values (moreover, if Kyoya travels along the same\r\ntrain more than once, it is possible for the train to take different\r\namounts of time and those amounts are also independent one from\r\nanother). Kyoya wants to get to school by spending the least amount of\r\nmoney in expectation (for the ticket price plus possible fine for being\r\nlate). Of course, Kyoya has an optimal plan for how to get to school,\r\nand every time he arrives at a train station, he may recalculate his\r\nplan based on how much time he has remaining. What is the expected cost\r\nthat Kyoya will pay to get to school if he moves optimally?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst double pi=acos(-1.);\nstruct CD {\n\tdouble a,b;\n\tCD() {}\n\tCD(double a,double b):a(a),b(b) {}\n};\ninline CD operator+(CD &a, CD &b) { return CD(a.a+b.a,a.b+b.b);}\ninline CD operator-(CD &a, CD &b) { return CD(a.a-b.a,a.b-b.b);}\ninline CD operator*(CD &a, CD &b) { return CD(a.a*b.a-a.b*b.b,a.b*b.a+a.a*b.b);}\nconst int N=80100;\nint r[N],n,m,x,t;\nint g[110][110];\nCD tmp[N],P[N],Q[N];\ndouble dp[60][N],E[110][N],p[N],q[N],sprob[110][N/4],prob[110][N/4];\nint a[110],b[110],c[110],pp;\nvoid rev(CD *a,int n) {\n\tr[0]=0;\n\trep(i,1,n) if (i&1) r[i]=(r[i>>1]>>1)+(n>>1); else r[i]=(r[i>>1]>>1);\n\trep(i,0,n) if (r[i]<i) swap(a[r[i]],a[i]);\n}\nvoid dft(CD* a,int n,bool inv) {\n\tCD wi,w,u,v;\n\trev(a,n);\n\tfor (int m=2;m<=n;m<<=1) {\n\t\tdouble Arg=2*pi/m*(inv?-1:1);\n\t\twi=CD(cos(Arg),sin(Arg));\n\t\tfor (int j=0;j<n;j+=m) { w=CD(1,0);\n\t\t\tfor (int k=j,k2=j+m/2;k2<j+m;k++,k2++)\n\t\t\t\tu=a[k],v=a[k2]*w,a[k]=u+v,a[k2]=u-v,w=w*wi;\n\t\t}\n\t}\n\tif (inv) for (int j=0;j<n;j++) a[j].a/=n;\n}\nvector<CD> qq[110][30];\ndouble pmt[N];\nvoid mul(int n,int j) {\n\tif (n<32) {\n\t\trep(i,0,n) pmt[i]=0;\n\t\trep(i,0,n/2) if (p[i]) rep(j,0,n/2) pmt[i+j]+=p[i]*q[j];\n\t\trep(i,0,n) tmp[i]=CD(pmt[i],0);\n\t\treturn;\n\t}\n\trep(i,0,n) P[i]=CD(p[i],0);\n\tdft(P,n,0);\n\tint r=0;\n\twhile ((1<<r)!=n) r++;\n\tif (SZ(qq[j][r])==0) {\n\t\trep(i,0,n) Q[i]=CD(q[i],0);\n\t\tdft(Q,n,0);\n\t\trep(i,0,n) qq[j][r].pb(Q[i]);\n\t}\n\trep(i,0,n) tmp[i]=P[i]*qq[j][r][i];\n\tdft(tmp,n,1);\n}\nvoid solve(int l,int r) {\n\tif (l+1==r) {\n\t\tif (l==0) rep(i,1,n) dp[i][0]=x+g[i][n];\n\t\telse {\n\t\t\trep(i,1,n) dp[i][l]=1e30;\n\t\t\trep(i,0,m) if (b[i]!=n) dp[a[i]][l]=min(dp[a[i]][l],E[i][l]+sprob[i][l+1]*(x+g[b[i]][n])+c[i]);\n\t\t\t\telse dp[a[i]][l]=min(dp[a[i]][l],E[i][l]+sprob[i][l+1]*(x+g[b[i]][n])+c[i]);\n\t\t}\n\t\treturn;\n\t}\n\tif (l>t) return;\n\tint md=(l+r)>>1;\n\tsolve(l,md);\n\trep(j,0,m) {\n\t\trep(i,0,2*(r-l)) p[i]=q[i]=0;\n\t\trep(i,0,md-l) p[i]=dp[b[j]][i+l];\n\t\trep(i,0,r-l) q[i]=prob[j][i];\n\t\tmul(2*(r-l),j);\n\t\trep(i,md,r) E[j][i]=E[j][i]+tmp[i-l].a;\n\t}\n\tsolve(md,r);\n}\nint main() {\n\tscanf(\"%d%d%d%d\",&n,&m,&t,&x);\n\trep(i,1,n+1) rep(j,1,n+1) g[i][j]=(i==j)?0:(1<<29);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",a+i,b+i,c+i);\n\t\tg[a[i]][b[i]]=min(g[a[i]][b[i]],c[i]);\n\t\trep(j,1,t+1) scanf(\"%d\",&pp),prob[i][j]=pp*0.00001;\n\t\tper(j,0,t+1) sprob[i][j]=sprob[i][j+1]+prob[i][j];\n\t}\n\trep(k,1,n+1) rep(i,1,n+1) rep(j,1,n+1) g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\tint M=1; while (M<=t) M*=2; \n\tsolve(0,M);\n\tprintf(\"%.10f\\n\",dp[1][t]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "fft",
        "graphs",
        "math",
        "probabilities"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Kyoya and Train.json",
    "editorial_link": "https://codeforces.com//blog/entry/18842",
    "editorial": "The Naive solution is . Let be the optimal expected time given we are at\r\nnode , with time units left. Also, let be the optimal expected time\r\ngiven we use edge at time . Now, we have And, if e = (u->v), we have\r\nDoing all this naively takes . Now, weâll speed this up using FFT. Weâll\r\nfocus on only a single edge for now. The problem here, however, is that\r\nnot all values are given in advance. Namely, the values require us to\r\ncompute the values for all edges at a particular time, and vice versa.\r\nSo we need some sort of fast \"online\" version of FFT. We do this as\r\nfollows. Letâs abstract away the original problem, and letâs say weâre\r\ngiven two arrays a,b, where a is only revealed one at a time to us, and\r\nb is given up front, and we need to compute c, their convolution (in the\r\noriginal problem b is , and a is , and c is ). Now, when we get the ith\r\nvalue of a, we need to return the ith value of the convolution of c. We\r\ncan only get the ith value of a when we compute the i-1th values of c\r\nfor all c. Split up b into a block of size 1, a block of size 1, then a\r\nblock of size 2, then a block of size 4, then 8, and so on. Now, we get\r\n, which will allow us to compute , which lets us get , which allows us\r\nto compute , and so on. So, now we have the following: Weâll describe\r\nthe processing of a single When we get , we will first convolve it with\r\nthe first two blocks, and add those to the appropriate entry. Now,\r\nsuppose is multiple of a for some k. Then, we will convolve .. with the\r\nblock in b with the same size. As an example. This gives us , which then\r\nallows us to get This gives us , which then allows us to get is now a\r\npower of 2, so this step will also additionally convolve with So, we can\r\nsee this gives us , which then allowus to get , and so on and so forth.\r\nThus, this process of breaking into blocks works. As for runtime, we run\r\nFFT on a block size of B T/B times, so this term contributes (T/B) * B\r\nlog B = T log B So, we sum T log 2 + T log 4 + ... + T log 2\r\n^(log T) <= T log\r\n^2 T Thus, the overall time per edge is , which gives us a total runtime\r\nof . Example code: http://codeforces.com/contest/553/submission/11767579\r\n",
    "hint": []
}