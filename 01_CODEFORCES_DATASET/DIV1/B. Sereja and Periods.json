{
    "link": "https://codeforces.com//contest/314/problem/B",
    "problemId": "3139",
    "problem_idx": "B",
    "shortId": "314B",
    "contest_number": "314",
    "problem_submissions": {
        "E": [
            30724544,
            3841662,
            3843754,
            3843819,
            3841502,
            3860384,
            3934694,
            3845808
        ],
        "D": [
            3838247,
            3837490,
            3833649,
            3839672,
            3836920,
            3843899,
            3843892,
            3843887,
            3839403,
            3837634,
            3841257,
            3841298,
            3842000,
            3842070,
            3840998,
            3841422,
            3840708,
            3840797,
            3839070,
            3842300,
            3841251
        ],
        "C": [
            3835839,
            3835172,
            3835831,
            3837510,
            3837765,
            3834791,
            3833737,
            3838762,
            3839170,
            3839102,
            3834408,
            3840072,
            3836332,
            3840999,
            3838170,
            3838751,
            3836736,
            3840325,
            3839207,
            3832923
        ],
        "B": [
            3832474,
            3833450,
            3837630,
            3835590,
            3835615,
            3836583,
            3840262,
            3835730,
            3832871,
            3835097,
            3839185,
            3834451,
            3840037,
            3832621,
            3841872,
            3837653,
            3838448,
            3841898,
            3834701
        ],
        "A": [
            3832264,
            3841936,
            3833100,
            3832334,
            3832542,
            3835485,
            3832690,
            3839877,
            3833260,
            3832812,
            3838983,
            3836728,
            3832398,
            3833247,
            3833000,
            3833823,
            3833650,
            3835970
        ]
    },
    "name": "B. Sereja and Periods",
    "statement": "Let’s introduce the designation , where is a string, is a positive\r\ninteger and operation \"\" is the string concatenation operation. For\r\nexample, .We’ll say that string from string , if we can remove some\r\ncharacters from string and obtain string . For example, strings and can\r\nbe obtained from string , and strings and cannot be obtained from\r\nit.Sereja has two strings, and . He wants to find such maximum integer ,\r\nthat can be obtained from string .\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <complex>\n#include <sstream>\nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n \n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SIZE(c) ((int)((c).size()))\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FOREACH(i,x) for (__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n#define ALL(v) (v).begin(), (v).end()\n \n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nint N,M;\nchar S[1000],T[1000];\nPII R[1000];\n\n\nint main() {\n    scanf(\"%d%d%s%s\",&N,&M,S,T);\n    \n    int SL = strlen(S), TL = strlen(T);\n    REP(i,TL) {\n        PII cur(0,i);\n        REP(j,SL) {\n            if (S[j] == T[cur.nd]) {\n                ++cur.nd;\n                if (cur.nd == TL) {\n                    ++cur.st;\n                    cur.nd = 0;\n                }            \n            }            \n        }\n        R[i] = cur;\n    } \n\n    int result = 0;\n    int cur = 0;\n    REP(i,N) {\n        result += R[cur].st;\n        cur = R[cur].nd;    \n    }\n    printf(\"%d\\n\",result / M);\n}    "
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Sereja and Periods.json",
    "editorial_link": "https://codeforces.com//blog/entry/7905",
    "editorial": "It is clear that we can use greedy algorithm to look for the number of occurrences of the 2nd string in the first string, but it works too slow. To speed up the process, you can look at the first line of the string that specifies the second period. And the answer is divided into how many string you need to set the second string. Next, we consider our greedy algorithm. We are going by the first string, till we find the first character of the second string, then the second, third and so on until the last, then again find the first, second, and so the cycle. It is clear that if we stand in the same twice in a state in which the positions in the first string corresponds to one character string that determines the period and the position of the second string are the same, then we obtain the period. When we find this period, we can just repeat it as many times as possible.",
    "hint": []
}