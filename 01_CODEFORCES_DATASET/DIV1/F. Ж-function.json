{"link": "https://codeforces.com//contest/1098/problem/F", "problemId": "278465", "problem_idx": "F", "shortId": "1098F", "contest_number": "1098", "problem_submissions": {"E": [51775559, 48006690, 48011091, 47996318, 48015799, 48015745, 48015679, 48016465], "D": [47994331, 47991784, 48004915, 47986667, 47997263, 47997207, 47997823, 48003406, 48012772, 48000542, 48002246, 47998686, 48003172, 48003847, 48013739, 48013700, 48013652, 48012961, 48012955, 48007481, 48004946, 47998449, 48006927, 47993907], "C": [47990851, 47988182, 48002088, 47984104, 47990986, 47992891, 47990373, 47996864, 47993728, 47992046, 48002685, 47997828, 47997416, 47983441, 47996246, 48004923, 47992474, 48000276], "B": [47984141, 47982505, 48010238, 47997345, 47983353, 47986135, 47985242, 47985258, 47997818, 47982827, 47991394, 47990410, 47990108, 47991143, 47984918, 47988149, 47999187, 48005571], "A": [47975157, 47974213, 48009223, 47974115, 47975580, 47975415, 47977674, 47976551, 47976714, 47995866, 47975779, 47977103, 47975994, 47986982, 47978302, 47975716, 47976034, 47978693], "F": [54648301]}, "name": "F. \u0416-function", "statement": "The length of the longest common prefix of two strings s=s_1 s_2\r\nldots s_n and t = t_1 t_2\r\nldots t_m is defined as the maximum k\r\nle\r\nmin(n, m) such that s_1 s_2\r\nldots s_k equals t_1 t_2\r\nldots t_k. Let\u2019s denote the longest common prefix of two strings s and t\r\nas lcp(s,t).Z-function of a string s_1 s_2\r\ndots s_n is a sequence of integers z_1, z_2,\r\nldots, z_n, where z_i = lcp(s_1 s_2\r\nldots s_n,\r\ns_i s_{i+1}\r\ndots s_n). of a string s is defined as z_1 + z_2 +\r\nldots + z_n.You\u2019re given a string s=s_1 s_2\r\nldots s_n and q queries. Each query is described by two integers l_i and\r\nr_i, where 1\r\nle l_i\r\nle r_i\r\nle n. The answer for the query is defined as -function of the string\r\ns_{l_i} s_{l_i +1}\r\nldots s_{r_i}.\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 400005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\ntemplate<class T, int SZ> struct RMQ {\n    int stor[SZ][32-__builtin_clz(SZ)];\n    vector<T> x;\n    \n    int comb(int a, int b) {\n        return x[a] < x[b] ? a : b;\n    }\n    \n    void build(const vector<T>& _x) {\n        x = _x; F0R(i,sz(x)) stor[i][0] = i;\n        FOR(j,1,32-__builtin_clz(SZ)) F0R(i,SZ-(1<<(j-1))) \n            stor[i][j] = comb(stor[i][j-1],\n                        stor[i+(1<<(j-1))][j-1]);\n    }\n    \n    T query(int l, int r) {\n        int x = 31-__builtin_clz(r-l+1);\n        return comb(stor[l][x],stor[r-(1<<x)+1][x]);\n    }\n};\n\nstruct LCP {\n    string S; int N;\n    vi sa, inv, lcp;\n    RMQ<int,MX> R; \n    \n    void suffixArray() { // http://ekzlib.herokuapp.com\n        sa.resz(N); vi classes(N);\n        F0R(i,N) sa[i] = N-1-i, classes[i] = S[i];\n        stable_sort(all(sa), [this](int i, int j) { return S[i] < S[j]; });\n        for (int len = 1; len < N; len *= 2) { \n            vi c(classes);\n            F0R(i,N) { // compare first len characters of each suffix\n                bool same = i && sa[i-1] + len < N\n                              && c[sa[i]] == c[sa[i-1]]\n                              && c[sa[i]+len/2] == c[sa[i-1] + len/2];\n                classes[sa[i]] = same ? classes[sa[i-1]] : i;\n            }\n            vi nex(N), s(sa); F0R(i,N) nex[i] = i; // suffixes with <= len chars will not change pos \n            F0R(i,N) {\n                int s1 = s[i]-len;\n                if (s1 >= 0) sa[nex[classes[s1]]++] = s1; // order pairs w/ same first len chars by next len chars \n            }\n        }\n    }\n    \n    void lcpArray() { // KACTL\n        int h = 0;\n        inv.resz(N), lcp.resz(N); F0R(i,N) inv[sa[i]] = i; // pos -> suffix rank\n        F0R(i,N) if (inv[i]) {\n            int pre = sa[inv[i]-1];\n            while (max(i,pre)+h < N && S[i+h] == S[pre+h]) h++;\n            lcp[inv[i]] = h; // lcp of suffixes starting at p0 and i\n            if (h) h--; // if we cut off first chars of two strings with lcp h, then remaining portions still have lcp h-1 \n        }\n    }\n    \n    void init(string _S) {\n        S = _S; N = sz(S);\n        suffixArray(); lcpArray();\n        R.build(lcp);\n    }\n    \n    int getLCP(int a, int b) {\n        if (max(a,b) >= N) return 0;\n        if (a == b) return N-a;\n        int t0 = inv[a], t1 = inv[b];\n        if (t0 > t1) swap(t0,t1);\n        return R.query(t0+1,t1);\n    }\n};\n\nLCP L;\n\nint nex = 1, rev[MX];\nvpi child[MX];\n\npl operator+(const pl& l, const pl& r) { return {l.f+r.f,l.s+r.s}; }\npl operator-(const pl& l, const pl& r) { return {l.f-r.f,l.s-r.s}; }\npl& operator+=(pl& l, const pl& r) { return l = l+r; }\npl& operator-=(pl& l, const pl& r) { return l = l-r; }\n\ntemplate <class T, int ...Ns> struct BIT {\n    T val = {0,0};\n    void upd(T v) { val += v; }\n    T query() { return val; }\n};\n\ntemplate <class T, int N, int... Ns> struct BIT<T, N, Ns...> {\n    BIT<T,Ns...> bit[N + 1];\n    template<typename... Args> void upd(int pos, Args... args) {\n        for (; pos <= N; pos += (pos&-pos)) bit[pos].upd(args...);\n    }\n    template<typename... Args> T sum(int r, Args... args) {\n        T res = {0,0}; for (; r; r -= (r&-r)) res += bit[r].query(args...); \n        return res;\n    }\n    template<typename... Args> T query(int l, int r, Args... args) {\n        return sum(r,args...)-sum(l-1,args...);\n    }\n}; // BIT<int,10,10> gives a 2D BIT\n\n\nnamespace treap {\n    typedef struct tnode* pt;\n    \n    struct tnode {\n        int pri, val; pt c[2]; // essential\n        int sz; ll sum; // for range queries\n        bool flip; // lazy update\n    \n        tnode (int _val) {\n            pri = rand()+(rand()<<15); val = _val; c[0] = c[1] = NULL;\n            sz = 1; sum = val;\n            flip = 0;\n        }\n    };\n    \n    int getsz(pt x) { return x?x->sz:0; }\n    ll getsum(pt x) { return x?x->sum:0; }\n    \n    pt prop(pt x) {\n        if (!x || !x->flip) return x;   \n        swap(x->c[0],x->c[1]);\n        x->flip = 0;\n        F0R(i,2) if (x->c[i]) x->c[i]->flip ^= 1;\n        return x;\n    }\n    \n    void tour(pt x, vi& v) {\n        if (!x) return;\n        prop(x);\n        tour(x->c[0],v); v.pb(x->val); tour(x->c[1],v);\n    }\n    \n    pt calc(pt x) {\n        assert(!x->flip);\n        prop(x->c[0]), prop(x->c[1]);\n        x->sz = 1+getsz(x->c[0])+getsz(x->c[1]);\n        x->sum = x->val+getsum(x->c[0])+getsum(x->c[1]);\n        return x;\n    }\n    \n    pair<pt,pt> split(pt t, int v) { // >= v goes to the right\n        if (!t) return {t,t};\n        prop(t);\n        if (t->val >= v) {\n            auto p = split(t->c[0], v); t->c[0] = p.s;\n            return {p.f, calc(t)};\n        } else {\n            auto p = split(t->c[1], v); t->c[1] = p.f;\n            return {calc(t), p.s};\n        }\n    }\n    \n    pair<pt,pt> splitsz(pt t, int sz) { // leftmost sz nodes go to left\n        if (!t) return {t,t};\n        prop(t);\n        if (getsz(t->c[0]) >= sz) {\n            auto p = splitsz(t->c[0], sz); t->c[0] = p.s;\n            return {p.f, calc(t)};\n        } else {\n            auto p = splitsz(t->c[1], sz-getsz(t->c[0])-1); t->c[1] = p.f;\n            return {calc(t), p.s};\n        }\n    }\n        \n    pt merge(pt l, pt r) {\n        if (!l || !r) return l ? l : r;\n        prop(l), prop(r);\n        pt t;\n        if (l->pri > r->pri) l->c[1] = merge(l->c[1],r), t = l;\n        else r->c[0] = merge(l,r->c[0]), t = r;\n        return calc(t);\n    }\n    \n    pt ins(pt x, int v) { // insert v\n        auto a = split(x,v), b = split(a.s,v+1);\n        return merge(a.f,merge(new tnode(v),b.s));\n    }\n    \n    pt del(pt x, int v) { // delete v\n        auto a = split(x,v), b = splitsz(a.s,1);\n        return merge(a.f,b.s);\n    }\n    \n    ll get(pt a, ll b) {\n        auto A = split(a,b);\n        ll res = A.s ? A.s->sz*b-A.s->sum : 0;\n        a = merge(A.f,A.s); return res;\n    }\n}\n\nusing namespace treap;\n\nvpi mod1[MX], mod2[MX];\n\ntemplate<int SZ, bool VALUES_IN_EDGES> struct HLD { \n    int N; \n    int par[SZ], sz[SZ], depth[SZ], ad[SZ];\n    int root[SZ], pos[SZ], rpos[SZ];\n    pt dumb[MX];\n    BIT<pl,SZ> B;\n\n    void dfs_sz(int v = 0) {\n        sz[v] = 1;\n        trav(u,child[v]) {\n            par[u.f] = v; depth[u.f] = depth[v]+u.s;\n            dfs_sz(u.f); sz[v] += sz[u.f];\n            if (sz[u.f] > sz[child[v][0].f]) swap(u, child[v][0]);\n        }\n    }\n    \n    int t = 1;\n    void dfs_hld(int v = 0) {\n        pos[v] = t; rpos[t] = v; t++;\n        trav(u,child[v]) {\n            root[u.f] = ((u == child[v][0] && v) ? root[v] : u.f);\n            dfs_hld(u.f);\n        }\n    }\n    \n    void init(int _N) {\n        N = _N; par[0] = depth[0] = 0; root[0] = 0; \n        dfs_sz(); dfs_hld();\n    }\n\n    template <class BinaryOperation>\n    void processPath(int v, BinaryOperation op) {\n        for (; root[v]; v = par[root[v]]) op(root[v],v);\n    }\n\n    /*void modifyPath(int u, int v, int val) { // add val to vertices/edges along path\n        processPath(u, v, [this, &val](int l, int r) { tree.upd(l, r, val); });\n    }\n    \n    void modifySubtree(int v, int val) { // add val to vertices/edges in subtree\n        tree.upd(pos[v]+VALUES_IN_EDGES,pos[v]+sz[v]-1,val);\n    }\n\n    ll queryPath(int u, int v) { // query sum of path\n        ll res = 0; processPath(u, v, [this, &res](int l, int r) { res += tree.qsum(l, r); });\n        return res;\n    }*/\n    \n    void upd1(int x) {\n        processPath(x,[this](int a, int b) {\n            ad[a] ++; B.upd(pos[b],mp(-1,depth[b]-depth[par[a]]));\n        });\n    }\n    \n    void upd2(pi t, int z = 1) { // v+h[par[root]]+1\n        int b = t.s, a = root[b];\n        ad[a] += z; // +pos\n        int d = t.f+depth[par[a]];\n        if (z == 1) dumb[a] = ins(dumb[a],d); // min(x-y,0)\n        else dumb[a] = del(dumb[a],d);\n        // min(r-pos-(t.f+depth[par[root]]),0) \n    }\n    \n    void upd3(pi t) { // vertex label, last thing on path \n        int b = t.s, a = root[b];\n        ad[a] ++; B.upd(pos[b],mp(-1,depth[b]-depth[par[a]]));\n    }\n    void upd9(int v, int x) {\n        processPath(x,[&v,this](int a, int b) {\n            // [l,r] = [v+depth[a] .. v+depth[b]]\n            mod1[v+depth[par[a]]+1].pb({v,b});\n            mod2[v+depth[b]].pb({v,b});\n            // .pb({,b});\n            // ad[a] ++; B.upd(pos[b],mp(-1,depth[b]-depth[par[a]]));\n        });\n    }\n    \n    int fst(int l, int r, int maxDepth) {\n        while (l < r) {\n            int m = (l+r)/2;\n            if (depth[rpos[m]] >= maxDepth) r = m;\n            else l = m+1;\n        }\n        return l;\n    }\n    ll qsum1(int v, int maxDepth) { // vertex, max depth \n        ll ans = 0;\n        processPath(v,[this,&maxDepth,&ans](int a, int b) {\n            if (maxDepth <= depth[par[a]]) return;\n            ckmin(maxDepth,depth[b]); assert(pos[a]);\n            auto res = B.query(pos[a],fst(pos[a],pos[b],maxDepth)-1); res.f += ad[a]; // first position such that depth >= y \n            ans += res.f*(maxDepth-depth[par[a]])+res.s;\n            // ans += dumb[root]->query(); // right-pos\n            // DEPTH[pos[a]], DEPTH[pos[b]]\n            // depth[par[a]] to depth[b]\n            // ad[a] ++; B.upd(pos[b],{-1,depth[b]-depth[par[a]]});\n        });\n        return ans;\n    }\n    ll qsum2(int v, int maxDepth, int r) { // vertex, max depth, right bound \n        ll ans = 0;\n        processPath(v,[this,&maxDepth,&r,&ans](int a, int b) {\n            if (maxDepth <= depth[par[a]]) return;\n            ckmin(maxDepth,depth[b]); assert(pos[a]);\n            auto res = B.query(pos[a],fst(pos[a],pos[b],maxDepth)-1); res.f += ad[a]; // first position such that depth >= y \n            ans += res.f*(maxDepth-depth[par[a]])+res.s;\n            ans += get(dumb[a],r-(maxDepth-depth[par[a]]));\n            // ans += dumb[root]->query(); // right-pos\n            // DEPTH[pos[a]], DEPTH[pos[b]]\n            // depth[par[a]] to depth[b]\n            // ad[a] ++; B.upd(pos[b],{-1,depth[b]-depth[par[a]]});\n        });\n        return ans;\n    }\n};\n\nHLD<MX,1> H;\n\nstring s; int q, N;\n\nint divi(int cur, int pre, int l, int r) {\n    if (l == r) {\n        int len = N-L.sa[l];\n        if (len != pre) {\n            child[cur].pb({nex,len-pre}); cur = nex++;\n        }\n        rev[L.sa[l]] = cur;\n        return cur;\n    }\n    int t = L.R.query(l+1,r);\n    // ps(\"??\",l,r,t);\n    if (L.lcp[t] != pre) {\n        child[cur].pb({nex,L.lcp[t]-pre}); cur = nex++;\n        pre = L.lcp[t];\n    }\n    divi(cur,pre,l,t-1); divi(cur,pre,t,r);\n    return cur;\n} // OK\n\nvoid init() {\n\tre(s,q); N = sz(s); L.init(s); \n\tdivi(0,0,0,N-1);\n\t/*F0R(i,nex) ps(i,child[i]);\n\tcout << \"----\\n\";\n\tps(L.sa,L.lcp);\n\tF0R(i,N) ps(i,rev[i]);\n\texit(0);*/\n} // OK\n\nvector<array<int,3>> neg[MX], pos[MX]; // index for answer, the starting node, the max depth\nll ans[MX];\n\nvoid processL() {\n    // F0R(i,nex) ps(i,H.root[i],H.depth[i]);\n    // exit(0);\n    H = HLD<MX,1>(); H.init(nex);\n\tF0R(i,N) {\n\t    trav(t,neg[i]) ans[t[0]] -= H.qsum1(t[1],t[2]);\n\t    H.upd1(rev[i]); // add one \n\t}\n\t/*F0R(i,q) ps(ans[i]);\n\texit(0);*/\n}\n\nvoid processR() {\n    H = HLD<MX,1>(); H.init(nex);\n    F0R(i,N) H.upd9(i,rev[i]); // store v=i, x\n    FOR(i,1,MX) {\n        // if (sz(mod1[i]) || sz(mod2[i])) ps(i,mod1[i],mod2[i]);\n        trav(t,mod1[i]) H.upd2(t,1); // v+h[par[root]]+1 ... v+h[x] -> store v, x \n        // upd2: min(pos,r-a+1) = pos+min(r-pos-(v+h[par[root]]),0): store the vertex label, last thing on path??\n        trav(t,mod2[i]) H.upd2(t,-1), H.upd3(t); // store vertex label, last thing on path label\n        // upd3: pos+min(r-pos-a+1,0) -> min(b-a+1,pos)\n        trav(t,pos[i]) ans[t[0]] += H.qsum2(t[1],t[2],i);\n    }\n    // [a,b] = v+h[par[root]]+1 ... v+h[x], find a prefix of length at most l which is <= r \n    // query [1,pos]\n    // r < a: zero\n    // a <= r < b: pos+min(r-a+1-pos,0) \n    // b <= r: min(b-a+1,pos) // query a BIT based on pos \n}\n\nint main() {\n    init();\n\tF0R(i,q) {\n\t    int l,r; re(l,r); l--,r--;\n\t    neg[l].pb({i,rev[l],r-l+1}); // ancestor of rev[l] at depth r-l+1\n\t    pos[r+1].pb({i,rev[l],r-l+1}); // v+depth[x] <= r+1 \n\t}\n\tprocessL(); processR();\n\tF0R(i,q) ps(ans[i]);\n    // you should actually read the stuff at the bottom\n} // OK\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"], "input": "", "output": "", "tags": ["string suffix structures", "strings"], "dificulty": "3500", "interactive": false}