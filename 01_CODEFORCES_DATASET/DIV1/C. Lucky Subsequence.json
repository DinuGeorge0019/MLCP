{
    "link": "https://codeforces.com//contest/145/problem/C",
    "problemId": "837",
    "problem_idx": "C",
    "shortId": "145C",
    "contest_number": "145",
    "problem_submissions": {
        "E": [
            1105208,
            1105912,
            1104894,
            1102760,
            1106240,
            1105850,
            1107323,
            1106178,
            1106652,
            1107141,
            1106053,
            1106917,
            1110162,
            1106271,
            1108116,
            1106093,
            1106858,
            1105628,
            1106422
        ],
        "C": [
            1103754,
            1105077,
            1104008,
            1104728,
            1104390,
            1104502,
            1105076,
            1107490,
            1105685,
            1104716,
            1104727,
            1105594,
            1110098,
            1102678,
            1104471,
            1104980,
            1102716,
            1106604,
            1105209
        ],
        "B": [
            1102413,
            1103328,
            1106135,
            1106485,
            1102911,
            1103531,
            1103090,
            1103085,
            1103776,
            1103710,
            1107536,
            1102801,
            1110016,
            1106756,
            1108339
        ],
        "A": [
            1101171,
            1101193,
            1101307,
            1101588,
            1101358,
            1101247,
            1101150,
            1101748,
            1101315,
            1101364,
            1101363,
            1110038,
            1103077,
            1101351,
            1101685,
            1101209,
            1101163,
            1101232
        ],
        "D": [
            1131693,
            1131692,
            1124995,
            107142023,
            107141858,
            107141498,
            107140808,
            107137178
        ]
    },
    "name": "C. Lucky Subsequence",
    "statement": "Petya has sequence consisting of integers.The subsequence of the\r\nsequence is such subsequence that can be obtained from by removing zero\r\nor more of its elements.Two sequences are considered different if index\r\nsets of numbers included in them are different. That is, the values of\r\nthe elements do not matter in the comparison of subsequences. In\r\nparticular, any sequence of length has exactly different subsequences\r\n(including an empty subsequence).A subsequence is considered lucky if it\r\nhas a length exactly and does not contain two identical lucky numbers\r\n(unlucky numbers can be repeated any number of times).Help Petya find\r\nthe number of different lucky subsequences of the sequence . As Petya’s\r\nparents don’t let him play with large numbers, you should print the\r\nresult modulo prime number .\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define REP(i,n) for (int i=0,_n=(n); i < _n; i++)\n#define REPD(i,n) for (int i=(n)-1; i >= 0; i--)\n#define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n\n#define CLEAR(x) memset(x,0,sizeof x);\n#define CLEARA(x) memset(&x,0,sizeof x);\n#define FILL(x,v) memset(x,v,sizeof x);\n#define FILLA(x,v) memset(&x,v,sizeof x);\n\n#define VAR(a,b) __typeof(b) a=(b)\n#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)\n\n#define REVERSE(c) reverse(ALL(c))\n#define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())\n#define INF 0x7fffffff\n#define X first\n#define Y second\n#define pb push_back\n#define SZ(c) (int)(c).size()\n#define MP make_pair\n#define eps 1.0e-11\nconst double pi = acos(-1.0);\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long LL;\n\ntemplate<class T> inline T gcd(T a,T b) {\n\tif(a<0)a=-a; if(b<0)b=-b; if(a<b)swap(a,b);\n\twhile (b) {T t = b; b=a%b; a=t;} return a; }\ntemplate <typename T> T euclide(T a, T b, T &x, T &y) {\n\tif (a<0) { T g = euclide(-a,b,x,y); x=-x; return g; }\n\tif (b<0) { T g = euclide(a,-b,x,y); y=-y; return g; }\n\tif (a<b) return euclide(b,a,y,x);\n\tif (!b) { x = 1; y = 0; return a; }\n\tT x1, y1;\n\tT g = euclide(b, a%b, x1, y1);\n\tx = y1;\n\ty = x1 - (a/b)*y1;\n\treturn g; }\ntemplate<class T> inline T inverse(T a, T n)\n{\tT x,y; euclide(a,n,x,y); return ((x%n)+n)%n;}\n\n#define N 1050\n#define MOD 1000000007\nint n,k;\nVI nums;\nint cnt[N],rest;\nint d[N][N];\nint cnk[N][N];\nint fact[111000];\n\nint getcnk(int n, int k)\n{\n\tif (k < 0 || k > n) return 0;\n\treturn ((fact[n]*(LL)inverse<LL>(fact[k],MOD))%MOD*(LL)inverse<LL>(fact[n-k],MOD))%MOD;\n}\n\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tCLEAR(cnk);\n\tREP(i,N)\n\t{\n\t\tcnk[i][0]=1;\n\t\tFOR(j,1,i)\n\t\t\tcnk[i][j] = (cnk[i-1][j-1]+cnk[i-1][j])%MOD;\n\t}\n\tFOR(len,1,9) REP(mask,1<<len)\n\t{\n\t\tint x = 0;\n\t\tREPD(i,len)\n\t\t\tx = x*10 + ((mask&(1<<i))?7:4);\n\t\tnums.pb(x);\n\t}\n\tfact[0]=1;\n\tFOR(i,1,111000-1)\n\t\tfact[i]=(fact[i-1]*(LL)i)%MOD;\n\tSORT(nums);\n\t//fprintf(stderr,\"%d\\n\",SZ(nums));\n\n\tscanf(\"%d%d\",&n,&k);\n\trest=0;\n\tCLEAR(cnt);\n\tREP(i,n)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tint p = lower_bound(ALL(nums),x)-nums.begin();\n\t\tif (p < SZ(nums) && nums[p]==x)\n\t\t\t++cnt[p];\n\t\telse\n\t\t\t++rest;\n\t}\n\tCLEAR(d);\n\td[0][0]=1;\n\tint top = min(k,SZ(nums));\n\tREP(i,SZ(nums))\n\t{\n\t\tFOR(x,0,top)\n\t\t{\n\t\t\td[i+1][x] = (d[i+1][x]+d[i][x])%MOD;\n\t\t\tif (x+1 <= top)\n\t\t\t\td[i+1][x+1] = (d[i+1][x+1]+d[i][x]*(LL)cnt[i])%MOD;\n\t\t}\n\t}\n\tint res = 0;\n\tFOR(x,0,top)\n\t\tres = (res + getcnk(rest,k-x)*(LL)d[SZ(nums)][x])%MOD;\n\tprintf(\"%d\\n\",res%MOD);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Lucky Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/3746",
    "editorial": "As you probably know, the number of lucky numbers in range [1;109] is 1022. We use this fact to solve problem. Let C[i] - number of occurrences of i-th lucky number in array a. Now we schould calculate DP with parameters DP[pos][cnt] - what is the number of subsequences that we use lucky numbers up to pos-th and our subsequence contains exactly cnt lucky number. If we are on state DP[pos][cnt] we can do two things: do not use pos-th lucky number (and do DP[pos+1][cnt] += DP[pos][cnt]) or use pos-th lucky (and do DP[pos+1][cnt+1] += DP[pos][cnt]*C[pos], because you have C[pos] of pos-th lucky number).\n\nNow we need to find total result. To do that we iterate through the number of lucky numbers in our subsequence i. Then you need to multiple that number by C(countunlucky,?k?-?i) (bin. coefficient), where countunlucky - number of unlucky numbers of sequence. Sum for all such i will be the total result.",
    "hint": []
}