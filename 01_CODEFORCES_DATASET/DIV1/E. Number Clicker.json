{
    "link": "https://codeforces.com//contest/995/problem/E",
    "problemId": "193037",
    "problem_idx": "E",
    "shortId": "995E",
    "contest_number": "995",
    "problem_submissions": {
        "A": [
            39622634,
            39624778,
            39611857,
            39613075,
            39612504,
            39633809,
            39730739,
            39630464,
            39614560,
            39615127,
            39615945,
            39627850,
            39644544
        ],
        "D": [
            39620886,
            39622276,
            39624260,
            39625402,
            39620954,
            39619269,
            39625858,
            39622750,
            39648307,
            39621953,
            39623820,
            39630198,
            39624907,
            39620407,
            39624158,
            40152305,
            39628532
        ],
        "B": [
            39618347,
            39610962,
            39613221,
            39614545,
            39609629,
            39615815,
            39611873,
            39613569,
            39613133,
            39612138,
            39610926,
            39611393,
            39611858,
            39611928,
            39613545,
            39611754,
            39609705,
            53817193,
            39610836
        ],
        "C": [
            39617499,
            39614510,
            39626416,
            39624999,
            39616008,
            39617835,
            39618295,
            39616280,
            39624435,
            39625816,
            39622945,
            39621745,
            39619276,
            39618758,
            39619323,
            40151840,
            39622131
        ],
        "F": [
            39615335,
            39621081,
            39625550,
            39626823,
            39628939,
            39628609,
            39627481,
            39618994,
            39618157,
            39650537,
            39650510,
            39650502,
            39650497,
            39650286,
            39626413,
            39619718,
            39628948,
            39622378,
            39621430,
            39618390
        ],
        "E": [
            39614170,
            39617964,
            39622775,
            39619679,
            39622645,
            39623654,
            39624609,
            39619924,
            39623004,
            39785499,
            39632072,
            39631884,
            39631853,
            39631837,
            39631822,
            39620887,
            39627781,
            39618907,
            39627618,
            39627288,
            39618749,
            39642305
        ]
    },
    "name": "E. Number Clicker",
    "statement": "Allen is playing Number Clicker on his phone.He starts with an integer u\r\non the screen. Every second, he can press one of 3 buttons. Turn u\r\nto u+1\r\npmod{p}. Turn u\r\nto u+p-1\r\npmod{p}. Turn u\r\nto u^{p-2}\r\npmod{p}. Allen wants to press at most 200 buttons and end up with v on\r\nthe screen. Help him!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b,ll mod) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint u,v,p,w,ty;\nqueue<PII> q;\nmap<int,int> hs;\nmap<int,PII> pre;\nvoid add(int z,int way) {\n\tif (hs.count(z)) {\n\t\tif (hs[z]==ty) return;\n\t\telse {\n\t\t\tint c=z;\n\t\t\tVI ret;\n\t\t\twhile (c!=u&&c!=v) {\n\t\t\t\tauto d=pre[c];\n\t\t\t\tret.pb(d.se);\n\t\t\t\tc=d.fi;\n\t\t\t}\n\t\t\treverse(all(ret));\n\t\t\tret.pb(way);\n\t\t\tint b=w;\n\t\t\twhile (b!=u&&b!=v) {\n\t\t\t\tauto d=pre[b];\n\t\t\t\tret.pb(d.se);\n\t\t\t\tb=d.fi;\n\t\t\t}\n\t\t\tif (c==v) reverse(all(ret));\n\t\t\tint ww=u;\n\t\t\tprintf(\"%d\\n\",SZ(ret));\n\t\t\tfor (auto q:ret) {\n\t\t\t\tprintf(\"%d \",q);\n\t\t\t\tif (q==1) ww=(ww+1)%p;\n\t\t\t\telse if (q==2) ww=(ww+p-1)%p;\n\t\t\t\telse ww=powmod(ww,p-2,p);\n\t\t\t}\n\t\t\tassert(ww==v);\n\t\t\tputs(\"\");\n\t\t\texit(0);\n\t\t}\n\t}\n\tq.push(mp(z,ty));\n\ths[z]=ty;\n\tpre[z]=mp(w,way);\n}\nint main() {\n\tscanf(\"%d%d%d\",&u,&v,&p);\n\tif (u==v) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\ths[u]=1;\n\ths[v]=2;\n\tq.push(mp(u,1)); q.push(mp(v,2));\n\twhile (!q.empty()) {\n\t\tauto z=q.front(); q.pop();\n\t\tw=z.fi; ty=z.se;\n\t\tadd((w+1)%p,ty==1?1:2);\n\t\tadd((w+p-1)%p,ty==1?2:1);\n\t\tadd(powmod(w,p-2,p),3);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "graphs",
        "meet-in-the-middle",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Number Clicker.json",
    "editorial_link": "https://codeforces.com//blog/entry/60217",
    "editorial": "Our first observation is that the game can be modeled the following way.\r\nConstruct an undirected graph on such that is connected to and We want\r\nto find a path of length at most 200 between and in this graph. Running\r\na BFS will take too long, so we need different techniques. We present\r\ntwo solutions, which both essentially use the fact that the graph is\r\nalmost \"random\". This follows from some known number theoretic results\r\non expander graphs (keyword is \"Margulis expanders\").Solution 1:\r\nGenerate random paths of length from vertex . Now, generate random paths\r\nfrom of length until some pair of endpoints coincide. By the birthday\r\nparadox, assuming that the graph is approximately random, the runtime\r\nwill be Solution 2: We can try running a simultaneous BFS from both\r\ndirections (starting at and ). When they meet, make that path. If you\r\nare careful, it should be possible to cover vertices, which should then\r\nrun in time.Additionally, our tester found a different solution. It\r\nsuffices to find a path from of length The way we do this is: pick a\r\nrandom Now run the Euclidean algorithm on , using operation for a normal\r\nsubtraction step, and a for the flipping the two entries step. It\r\nhappens to take a few steps in most cases, but we have no proof.\r\n",
    "hint": []
}