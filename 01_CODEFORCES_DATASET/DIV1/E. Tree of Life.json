{
    "link": "https://codeforces.com//contest/2023/problem/E",
    "problemId": "2964368",
    "problem_idx": "E",
    "shortId": "2023E",
    "contest_number": "2023",
    "problem_submissions": {
        "F": [
            287014608,
            287072234,
            299830672,
            287085195,
            287027962,
            287042299,
            287238133,
            287043650
        ],
        "E": [
            286990891,
            287003441,
            287204391,
            287202274,
            287014470,
            287010378,
            287009293,
            287034992,
            287190288,
            287004818,
            287142133
        ],
        "D": [
            286943910,
            286985197,
            287179114,
            287178062,
            286983477,
            286986708,
            286993474,
            286930212,
            286984453,
            286985894,
            286983025,
            286981875,
            287091406,
            286988866,
            286991623,
            286991730,
            286972363,
            290388826,
            290388744,
            286996161,
            286993279,
            287000155,
            287068676,
            287061033,
            286997472,
            287003784
        ],
        "C": [
            286925333,
            287063584,
            286928411,
            286930839,
            286944563,
            286945303,
            286973941,
            286936797,
            286923792,
            286935049,
            286934113,
            286960906,
            286944493,
            286935726,
            286931426,
            286988231,
            286961072,
            286929444,
            286959433,
            286973882,
            286960461
        ],
        "B": [
            286913842,
            286912400,
            286915696,
            286920706,
            286917936,
            286918820,
            286920898,
            286929873,
            286915247,
            286917134,
            286915488,
            286916176,
            286919025,
            286919305,
            286914068,
            286921817,
            286912738,
            286921828,
            286922164,
            286920262
        ],
        "A": [
            286905356,
            286905575,
            286907414,
            286907460,
            286908014,
            286911602,
            286910636,
            286905107,
            286906378,
            286906055,
            286906420,
            286919318,
            286909880,
            286905489,
            286910067,
            286910062,
            286905533,
            286909956,
            286907288,
            286911621
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "This problem has several solutions that are similar to varying degrees.\r\nWe will describe one of them.We will apply the following greedy\r\napproach. We will construct the answer by combining the answers for the\r\nsubtrees. To do this, we will perform a depth-first traversal, and when\r\nexiting a vertex, we return a triplet , where is the minimum number of\r\npaths needed to cover all pairs of adjacent edges in the subtree\r\n(considering the edge upwards), is the number of edges upwards, and is\r\nthe number of paths that are connected at some vertex of the subtree but\r\ncan be separated into two paths upwards without violating the\r\ncoverage.Then, if we are at vertex and receive from child the triplet ,\r\nwe need to increase to at least (to satisfy the coverage). Next, we will\r\neffectively reduce it by , implying that we have satisfied all such\r\npairs. Meanwhile, we will sum and , and subtract from when connecting.\r\nWe first increase using (), and then simply by adding new paths.After\r\nthis, we have remaining excess paths () leading to , which we might be\r\nable to combine to reduce the answer. This is represented by the set .\r\nIf , we can combine all pairs (leaving at most path upwards) in , adding\r\nthese paths to . Otherwise, we increase all using until is satisfied.\r\nFinally, we return if the condition is met, and , while and are the sums\r\nthat may have changed during the process. Don\u00e2\u0080\u0099t forget to account for\r\nthe paths that merged at .The root needs to be handled separately, as\r\nthere are no paths upwards there.To prove this solution, one can\r\nconsider the minimum number of paths needed to cover subtree if paths go\r\nupwards. It is not hard to notice that the triplet in the greedy\r\nsolution describes all optimal states of the dynamic programming.P.S.\r\nStrict proofs are left as an exercise for the reader.\r\n",
    "name": "E. Tree of Life",
    "statement": "In the heart of an ancient kingdom grows the legendary Tree of Life the\r\nonly one of its kind and the source of magical power for the entire\r\nworld. The tree consists of n nodes. Each node of this tree is a magical\r\nsource, connected to other such sources through magical channels\r\n(edges). In total, there are n-1 channels in the tree, with the i-th\r\nchannel connecting nodes v_i and u_i. Moreover, there exists a unique\r\nsimple path through the channels between any two nodes in the\r\ntree.However, the magical energy flowing through these channels must be\r\nbalanced; otherwise, the power of the Tree of Life may disrupt the\r\nnatural order and cause catastrophic consequences. The sages of the\r\nkingdom discovered that when two magical channels converge at a single\r\nnode, a dangerous \"magical resonance vibration\" occurs between them. To\r\nprotect the Tree of Life and maintain its balance, it is necessary to\r\nselect several paths and perform special rituals along them. A path is a\r\nsequence of distinct nodes v_1, v_2,\r\nldots, v_k, where each pair of adjacent nodes v_i and v_{i+1} is\r\nconnected by a channel. When the sages perform a ritual along such a\r\npath, the resonance vibration between the channels (v_i, v_{i+1}) and\r\n(v_{i+1}, v_{i+2}) is blocked for each 1\r\nleq i\r\nleq k - 2.The sages\u2019 task is to select the minimum number of paths and\r\nperform rituals along them to block all resonance vibrations. This means\r\nthat for every pair of channels emanating from a single node, there must\r\nexist selected path that contains of these channels.Help the sages find\r\nthe minimum number of such paths so that the magical balance of the Tree\r\nof Life is preserved, and its power continues to nourish the entire\r\nworld!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;\u00a0void solve() {    int n;    std::cin >> n;        std::vector<std::vector<int>> adj(n);    for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--;        v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        i64 ans = 0;    for (int i = 0; i < n; i++) {        i64 d = adj[i].size();        ans += d * (d - 1) / 2;    }    std::vector<i64> f(n), g(n);    auto dfs = [&](this auto &&self, int x, int p) -> void {        i64 d = adj[x].size();                i64 max = 0;        for (auto y : adj[x]) {            if (y == p) {                continue;            }            self(y, x);                        i64 t = std::min(d - 1, f[y]);            f[y] -= t;            ans -= t;                        t = d - 1 - t;            i64 v = std::min(t, 2 * g[y]);            ans -= v;                        g[y] -= v / 2;            if (v % 2 == 1) {                g[y]--;                f[y]++;            }                        g[x] += g[y];            f[x] += f[y];            max = std::max(max, f[y]);        }                if (max * 2 > f[x]) {            i64 v = g[x];            for (auto y : adj[x]) {                if (y == p) {                    continue;                }                if (f[y] == max) {                    v -= g[y];                    break;                }            }            g[x] += f[x] - max;            f[x] = max * 2 - f[x];            v = std::min(v, f[x] / 2);            f[x] -= 2 * v;            g[x] += v;        } else {            g[x] += f[x] / 2;            f[x] %= 2;        }                f[x] += d - 1;    };    dfs(0, -1);        ans -= g[0];        std::cout << ans << \"\\n\";}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }\u00a0    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Tree of Life.json"
}