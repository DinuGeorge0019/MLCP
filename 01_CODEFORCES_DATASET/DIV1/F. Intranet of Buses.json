{
    "link": "https://codeforces.com//contest/781/problem/F",
    "problemId": "96954",
    "problem_idx": "F",
    "shortId": "781F",
    "contest_number": "781",
    "problem_submissions": {
        "B": [
            25258392,
            25257297,
            25250177,
            25250748,
            25251116,
            25249653,
            25250716,
            25250834,
            25250705,
            25251947,
            25250575,
            31121662,
            25252893,
            25252683,
            25253146,
            25255775,
            25252991,
            25253498
        ],
        "E": [
            25256397,
            25254067,
            25258825,
            25260075,
            26145785,
            25259028,
            25259758,
            25260563,
            25260848,
            25261488,
            25260086,
            25703349,
            25261912,
            25262169,
            25262264,
            25261946,
            25261665,
            25262876,
            25262009
        ],
        "D": [
            25252423,
            25259248,
            25255529,
            25254368,
            25256042,
            25256267,
            25256774,
            25256075,
            25254834,
            25256057,
            25266603,
            25256151,
            25257817,
            25258124,
            25258109,
            25258052,
            25258679,
            25258333
        ],
        "C": [
            25249500,
            25249747,
            25251802,
            25252056,
            25252378,
            25250971,
            25252726,
            25253382,
            25252087,
            25253151,
            25252105,
            25254478,
            25253975,
            25254827,
            25254070,
            25255284,
            25254950
        ],
        "A": [
            25247143,
            25247027,
            25247783,
            25247695,
            25248775,
            25247133,
            25247620,
            25248678,
            25249108,
            25249147,
            25247139,
            25249553,
            25248502,
            25248323,
            25249740,
            25249518,
            25247402
        ],
        "F": [
            25268984,
            25267317,
            25271843,
            25271410,
            25271394,
            25271157,
            25270611,
            26202615
        ]
    },
    "name": "F. Intranet of Buses",
    "statement": "A new bus route is opened in the city . The route is a closed polygon\r\nline in the place, with all segments parallel to one of the axes. buses\r\nwill operate on the route. All buses move in a loop along the route in\r\nthe same direction with equal constant velocities (stopping times are\r\nnegligible in this problem).Buses start their movement in the first\r\nvertex of the route with equal interval. Suppose that is the total time\r\nfor a single bus to travel the whole loop of the route. Then, the bus 1\r\nstarts moving at time 0, the bus 2 starts at time , the bus 3 starts at\r\ntime , and so on; finally, the bus starts moving at time . Thus, all\r\nintervals between pairs of consecutive buses (including the interval\r\nbetween the last and the first bus) are equal.Buses can communicate with\r\neach other via wireless transmitters of equal power. If the transmitters\r\nhave power , then only buses within distance of each other can\r\ncommunicate.The buses are also equipped with a distributed system of\r\nschedule tracking. For all buses to stick to the schedule, the system\r\nhas to synchronize the necessary data between all buses from time to\r\ntime. At the moment of synchronization, the bus 1 communicates with the\r\nbus 2, the bus 2 with bus 3, and so on; also, the bus communicates with\r\nthe bus 1.As a research employee, you are tasked with finding the\r\nsmallest value of such that it is possible to find a time moment to\r\nperform synchronization once all buses have started moving.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nstruct point {\n  ld x, y;\n\n  void read() {\n    int x_, y_;\n    assert(scanf(\"%d%d\", &x_, &y_) == 2);\n    x = x_, y = y_;\n  }\n\n  point(ld x_ = 0, ld y_ = 0) : x(x_), y(y_) {}\n\n  point operator - (const point &p) const {\n    return point(x - p.x, y - p.y);\n  }\n\n  point operator + (const point &p) const {\n    return point(x + p.x, y + p.y);\n  }\n\n  point operator * (const ld &k) const {\n    return point(x * k, y * k);\n  }\n\n  ld operator * (const point &p) const {\n    return x * p.x + y * p.y;\n  }\n\n  ld slen() const {\n    return *this * *this;\n  }\n\n  ld len() const {\n    return sqrt(slen());\n  }\n\n  bool operator == (const point &p) const {\n    return abs(x - p.x) <= eps && abs(y - p.y) <= eps;\n  }\n\n  point norm() const {\n    return *this * (1 / len());\n  }\n\n  point rot() const {\n    return point(-y, x);\n  }\n};\n\nconst int maxn = (int) 1e5 + 10;\nint n, m;\n\npoint ps[maxn];\n\nint read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    ps[i].read();\n  }\n  return 1;\n}\n\nbool mcmp(pair<ld, int> &x, pair<ld, int> &y) {\n  if (abs(x.first - y.first) > eps) {\n    return x.first < y.first;\n  }\n  return 0;\n}\n\nbool ok(vector<pair<ld, point> > &ss, ld y, ld len) {\n  //eprintf(\"len = %.3f\\n\", (double) len);\n  static vector<pair<ld, int> > a;\n  a.clear();\n\n  int it = 0;\n  for (int i = 0; i < sz(ss) - 1; ++i) {\n    ld x1 = ss[i].first;\n    ld x2 = ss[i + 1].first;\n    point p1 = ss[i].second, p2 = ss[i + 1].second;\n\n    if (!(p1 == p2)) {\n      point dir = (p2 - p1).norm();\n      point norm = dir.rot();\n\n      point c = norm * (norm * p1);\n      if (c.len() > y) {\n        continue;\n      }\n      ld dx = y * y - c.slen();\n      dx = sqrt(max((ld) 0, dx));\n\n      ld dx1 = (p1 - c) * dir;\n      ld dx2 = (p2 - c) * dir;\n\n      ld ndx1 = dx1, ndx2 = dx2;\n      if (abs(dx1) > dx) {\n        ndx1 = (dx1 > 0 ? dx : -dx);\n      }\n      if (abs(dx2) > dx) {\n        ndx2 = (dx2 > 0 ? dx : -dx);\n      }\n      if (abs(ndx1 - ndx2) <= eps) {\n        continue;\n      }\n      point np1 = p1 + (p2 - p1) * ((ndx1 - dx1) / (dx2 - dx1));\n      point np2 = p1 + (p2 - p1) * ((ndx2 - dx1) / (dx2 - dx1));\n      ld nx1 = x1 + (x2 - x1) * (ndx1 - dx1) / (dx2 - dx1);\n      ld nx2 = x1 + (x2 - x1) * (ndx2 - dx1) / (dx2 - dx1);\n      p1 = np1, p2 = np2;\n      x1 = nx1, x2 = nx2;\n    } else {\n      if (p1.len() > y) {\n        continue;\n      }\n    }\n\n    //eprintf(\"[%.3f, %.3f]\\n\", (double) x1, (double) x2);\n    assert(max(p1.len(), p2.len()) <= y + eps);\n\n    while (x1 < x2 - eps) {\n      ld xsmall = x1 - it * len;\n      if (xsmall >= len - eps) {\n        ++it;\n        continue;\n      }\n      a.pb(mp(xsmall, 1));\n\n      ld x2s = xsmall + (x2 - x1);\n      if (x2s >= len - eps) {\n        //eprintf(\"adds  [%.3f..%.3f]\\n\", (double) xsmall, (double) len);\n        a.pb(mp(len, -1));\n        ++it;\n        x1 += len - xsmall;\n        continue;\n      }\n      //eprintf(\"adds  [%.3f..%.3f]\\n\", (double) xsmall, (double) x2s);\n      a.pb(mp(x2s, -1));\n      break;\n    }\n  }\n\n  sort(a.begin(), a.end(), mcmp);\n\n  int bal = 0;\n  for (int i = 0; i < sz(a);) {\n    int i0 = i;\n    while (i < sz(a) && !mcmp(a[i0], a[i])) {\n      bal += a[i].second;\n      ++i;\n    }\n    //eprintf(\"%d\\n\", bal);\n    if (bal >= m) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nvoid solve() {\n  ld len = 0;\n\n  ps[n] = ps[0];\n  for (int i = 0; i < n; ++i) {\n    len += (ps[i + 1] - ps[i]).len();\n  }\n\n  len /= m;\n\n  ld x = 0;\n\n  int i = 1 % n, j = 1 % n;\n  point p = ps[0], q = ps[0];\n  {\n    ld left = len;\n    while (1) {\n      ld clen = (ps[j] - q).len();\n      if (left >= clen - eps) {\n        left -= clen;\n        q = ps[j];\n        j = (j + 1) % n;\n        continue;\n      }\n      q = q + (ps[j] - q) * (left / clen);\n      break;\n    }\n  }\n\n  vector<pair<ld, point> > ss;\n  while (1) {\n    ss.pb(mp(x, (p - q)));\n    if (x >= len * m - eps) {\n      break;\n    }\n\n    ld len1 = (ps[i] - p).len();\n    ld len2 = (ps[j] - q).len();\n    //eprintf(\"%.3f %.3f\\n\", (double) len1, (double) len2);\n\n    ld mn = min(len1, len2);\n    mn = min(mn, len * m - x);\n    assert(mn > eps);\n\n    p = p + (ps[i] - p) * (mn / len1);\n    q = q + (ps[j] - q) * (mn / len2);\n    len1 -= mn, len2 -= mn;\n    x += mn;\n    if (len1 <= eps) {\n      i = (i + 1) % n;\n    }\n    if (len2 <= eps) {\n      j = (j + 1) % n;\n    }\n  }\n\n  /*for (int i = 0; i < sz(ss); ++i) {\n    eprintf(\"(%.3f, (%.3f,%.3f))\\n\", (double) ss[i].first, (double) ss[i].second.x, (double) ss[i].second.y);\n  }\n  assert(!ok(ss, 23.1, len));\n  */\n\n  ld left = 0, right = 1e4;\n\n  for (int iter = 0; iter < 50; ++iter) {\n    ld mid = (left + right) / 2;\n    if (ok(ss, mid, len)) {\n      right = mid;\n    } else {\n      left = mid;\n    }\n  }\n\n  printf(\"%.18f\\n\", (double) right);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "geometry",
        "two pointers"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Intranet of Buses.json",
    "editorial_link": "https://codeforces.com//blog/entry/50854",
    "editorial": "Let us do a binary search on the answer. Inside it, we have to check if\r\nat any time moment bus pairs 1 and 2, 2 and 3, ..., and 1 are within\r\ndistance of each other simultaneously.Let be the location of the bus 1\r\n(that departed at time 0) at time . Let us call a time moment , if we\r\nhave , with equal to the distance between points and . If there is a\r\nmoment such that , , ..., are all good, then the answer is at least .We\r\ncan build the two-dimensional graph (as in \"function graph\", not \"graph\r\nwith vertices and edges\") of over time by keeping track of segments\r\nwhere points and are. When the points are bounded to a pair of sides,\r\nthe vector changes linearly in time. There are time moments when either\r\npoint switches from side to side, hence the difference graph can be\r\nconstructed in time with the two pointers approach.Now, for a certain\r\nletâs find the set of good moments . We will do this separately for each\r\nsegment of the difference graph, and then paste the answers. We have the\r\ncondition , where ranges over a segment. This is the segment-circle\r\nintersection problem, which is a standard geometrical primitive, with\r\nvarious approaches from solving quadratic equations to rotating a\r\ncertain vector by an angle. In any case, the result will be a time range\r\nor an empty set. Note that may stay still for a certain time range of\r\nthe graph, which should be treated separately.To ensure that , , and so\r\non are all good for certain , let us \"cut\" the segment into equal parts\r\nand superimpose them, with \"good\" segments possibly being cut into\r\nparts, now overlapping each other. A suitable moment is now a point that\r\nis covered times. Finding such point is a simple scan-line\r\napplication.Complexity: , where is the required relative precision.\r\n",
    "hint": []
}