{"link": "https://codeforces.com//contest/1558/problem/C", "problemId": "1088951", "problem_idx": "C", "shortId": "1558C", "contest_number": "1558", "problem_submissions": {"F": [126899482, 126888055, 126902100, 126890640, 126888389, 126894123, 126904590, 126900041, 126902212, 126902942, 127549735, 127006693], "E": [126883583, 126896785, 126884151, 126898148, 126905418, 126902611, 126899238, 126907028, 126907352, 126891363, 126891974, 126891356, 126892061, 126902546, 126900088, 126903655, 126904227, 126900317, 126902700], "D": [126869704, 126870708, 126871179, 126874038, 126874151, 126876731, 126871810, 126867588, 126872511, 126871952, 126882884, 126882215, 126882465, 126878861, 126876122, 126890668, 126874784, 126883630, 126892178, 126890480], "B": [126858181, 126855670, 126854102, 126855872, 126858058, 126860085, 126854841, 126852806, 126853901, 126856718, 126855353, 126856232, 126858032, 126857658, 126854131, 126863721, 126854756, 126864821, 126867061, 126863501], "A": [126854362, 126850555, 126848635, 126848815, 126849088, 126855964, 126848126, 126847884, 126848457, 126849581, 126847772, 126849333, 126852232, 126849014, 126848809, 126853376, 126847687, 126859049, 126849750, 126850402], "C": [126850882, 126858888, 126859482, 126861350, 126866099, 126867225, 126859442, 126858664, 126862495, 126861859, 126865577, 126860578, 126863128, 126865366, 126858535, 126873768, 126863562, 126873408, 126874458, 126871983]}, "name": "C. Bottom-Tier Reversals", "statement": "You have a permutation: an array a = [a_1, a_2,\r\nldots, a_n] of distinct integers from 1 to n. The length of the\r\npermutation n is odd.You need to sort the permutation in increasing\r\norder.In one step, you can choose any prefix of the permutation with an\r\nodd length and reverse it. Formally, if a = [a_1, a_2,\r\nldots, a_n], you can choose any odd integer p between 1 and n,\r\ninclusive, and set a to [a_p, a_{p-1},\r\nldots, a_1, a_{p+1}, a_{p+2},\r\nldots, a_n].Find a way to sort a using no more than\r\nfrac{5n}{2} reversals of the above kind, or determine that such a way\r\ndoesn\u2019t exist. The number of reversals doesn\u2019t have to be minimized.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor(int& x : a){\n\t\tcin >> x;\n\t\tx--;\n\t}\n\tvector<int> res;\n\twhile(n > 1){\n\t\tint x = n-2;\n\t\tint y = n-1;\n\t\tint lx = 0;\n\t\tint ly = 0;\n\t\tauto set_val = [&](){\n\t\t\tlx = 0;\n\t\t\tly = 0;\n\t\t\twhile(a[lx] != x) lx++;\n\t\t\twhile(a[ly] != y) ly++;\n\t\t};\n\t\tset_val();\n\t\tif(((x - lx) & 1) || ((y - ly) & 1)){\n\t\t\tcout << -1 << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tres.push_back(ly + 1);\n\t\treverse(a.begin(), a.begin() + ly + 1);\n\t\tset_val();\n\t\tres.push_back(lx);\n\t\treverse(a.begin(), a.begin() + lx);\n\t\tset_val();\n\t\tres.push_back(lx + 2);\n\t\treverse(a.begin(), a.begin() + lx + 2);\n\t\tset_val();\n\t\tres.push_back(3);\n\t\treverse(a.begin(), a.begin() + 3);\n\t\tres.push_back(n);\n\t\treverse(a.begin(), a.begin() + n);\n\t\tn -= 2;\n\t}\n\tcout << res.size() << '\\n';\n\tfor(int r : res){\n\t\tcout << r << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "2000", "interactive": false}