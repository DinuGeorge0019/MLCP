{"link": "https://codeforces.com//contest/1936/problem/B", "problemId": "2503246", "problem_idx": "B", "shortId": "1936B", "contest_number": "1936", "problem_submissions": {"D": [249364690, 248943933, 248953790, 249029415, 248948695, 249384877, 248946718, 249691560, 248955075, 248956184, 248951174, 248957366, 248965278, 248962414, 248959804, 248956212, 248940582, 248972190, 248967537, 248935591, 248968777], "F": [248959624, 248956053, 249024905, 249024791, 249617325, 249616926, 249616449, 249616090], "C": [248923874, 248935905, 248936411, 248923821, 249389527, 249389485, 249389471, 248932096, 249960032, 249959905, 248928496, 248925527, 248927912, 248933135, 248931237, 248927110, 248920757, 248942173, 248944746, 248948052, 248945719, 248954792, 249702139, 249700847, 248946434, 248946276], "B": [248915925, 248925932, 248926756, 248909886, 248921270, 250626935, 248920462, 248915106, 248915547, 248917787, 248924541, 248919814, 248929862, 248928500, 248928933, 248958629, 248930625, 248933889, 248965009, 248934936], "A": [248907152, 248906597, 248909183, 248914647, 248906656, 250627352, 248907025, 248906362, 248923349, 248909550, 248908351, 248909231, 248911552, 248909761, 248918833, 248908591, 248914734, 248920857], "E": [248969738, 248981250, 249019529, 248981225, 248968880, 249091224, 249090696, 252634475, 249522528]}, "name": "B. Pinball", "statement": "There is a one-dimensional grid of length n. The i-th cell of the grid\r\ncontains a character s_i, which is either \u201d or \u201d.When a pinball is\r\nplaced on one of the cells, it moves according to the following rules:\r\nIf the pinball is on the i-th cell and s_i is \u201d, the pinball moves one\r\ncell to the left in the next second. If s_i is \u201d, it moves one cell to\r\nthe right. After the pinball has moved, the character s_i is inverted\r\n(i. e. if s_i used to be \u201d, it becomes \u201d, and vice versa). The pinball\r\nstops moving when it leaves the grid: either from the left border or\r\nfrom the right one. You need to answer n queries. In the i-th query, a\r\npinball will be placed on the i-th cell. Note that we always place a\r\npinball on the initial grid.For each query, calculate how many seconds\r\nit takes the pinball to leave the grid. It can be shown that the pinball\r\nwill always leave the grid within a finite number of steps.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nchar wcz[nax];\n\nvector<pll> lew, pra;\n\nll wyn[nax];\n\nll suma(vector<pll> &wek, int ile)\n{\n\tint r=wek.size();\n\treturn wek.back().second-wek[r-ile-1].second;\n}\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz+1);\n\tlew.clear();\n\tpra.clear();\n\tlew.push_back({0, 0});\n\tpra.push_back({n+1, 0});\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (wcz[i]=='<')\n\t\t{\n\t\t\tll x=i+pra.back().second;\n\t\t\tpra.push_back({i, x});\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (pra.back().first==i)\n\t\t\tpra.pop_back();\n\t\tint l=(int)lew.size()-1;\n\t\tint p=(int)pra.size()-1;\n\t\tif (wcz[i]=='<')\n\t\t{\n\t\t\tif (l<=p)\n\t\t\t{\n\t\t\t\twyn[i]=i+suma(pra, l)*2-suma(lew, l)*2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twyn[i]=n+1+i+suma(pra, p)*2-suma(lew, p+1)*2;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (l>=p)\n\t\t\t{\n\t\t\t\twyn[i]=n+1-i+suma(pra, p)*2-suma(lew, p)*2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twyn[i]=-i+suma(pra, l+1)*2-suma(lew, l)*2;\n\t\t\t}\n\t\t}\n\t\tif (wcz[i]=='>')\n\t\t{\n\t\t\tll x=i+lew.back().second;\n\t\t\tlew.push_back({i, x});\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(\"%lld \", wyn[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "implementation", "math", "two pointers"], "dificulty": "2000", "interactive": false}