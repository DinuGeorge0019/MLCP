{
    "link": "https://codeforces.com//contest/1172/problem/C2",
    "problemId": "355011",
    "problem_idx": "C2",
    "shortId": "1172C2",
    "contest_number": "1172",
    "problem_submissions": {
        "C2": [
            141600407,
            55254783,
            55254826,
            55257297,
            55253043,
            55256695,
            55259217,
            55259307,
            55260348,
            55256683,
            55270942,
            55262864,
            55394593,
            55256544,
            55256222,
            55256476
        ],
        "D": [
            55259812,
            55261379,
            55260385,
            55262554,
            55264421,
            55262846,
            55265864,
            55262949,
            55261237,
            55257268,
            55265259,
            55282819,
            55259099,
            55263111,
            55263637,
            55264769,
            55252234,
            55272471
        ],
        "C1": [
            55254052,
            55254936,
            55255627,
            55253139,
            55256736,
            55258621,
            55259255,
            55260376,
            55255981,
            55261688,
            55260260,
            55262975,
            55258783,
            55259505,
            55261611,
            55269127,
            55256504,
            55255804,
            55256553
        ],
        "B": [
            55249856,
            55248174,
            55250922,
            55254795,
            55250751,
            55252004,
            55254040,
            55251691,
            55250951,
            55253498,
            55253667,
            55248941,
            55252605,
            55253983,
            55255049,
            55260189,
            55249359,
            55251616,
            55252768
        ],
        "A": [
            55248325,
            55257508,
            55248960,
            55257490,
            55247357,
            55248700,
            55251742,
            55266272,
            55607192,
            55249619,
            55249678,
            55256938,
            55249251,
            55250622,
            55258815,
            55257623,
            55247019,
            55249926,
            55249357
        ],
        "E": [
            99401668,
            55317241,
            55479078,
            55479032,
            55478977
        ],
        "F": [
            55517893,
            55302923,
            55292935,
            55545710
        ]
    },
    "name": "C2. Nauuo and Pictures  hard version ",
    "statement": "Nauuo is a girl who loves random picture websites.One day she made a\r\nrandom picture website by herself which includes n pictures.When Nauuo\r\nvisits the website, she sees exactly one picture. The website does not\r\ndisplay each picture with equal probability. The i-th picture has a\r\nnon-negative weight w_i, and the probability of the i-th picture being\r\ndisplayed is\r\nfrac{w_i}{\r\nsum_{j=1}^nw_j}. That is to say, the probability of a picture to be\r\ndisplayed is proportional to its weight.However, Nauuo discovered that\r\nsome pictures she does not like were displayed too often. To solve this\r\nproblem, she came up with a great idea: when she saw a picture she\r\nlikes, she would add 1 to its weight; otherwise, she would subtract 1\r\nfrom its weight.Nauuo will visit the website m times. She wants to know\r\nthe expected weight of each picture after all the m visits modulo\r\n998244353. Can you help her?The expected weight of the i-th picture can\r\nbe denoted by\r\nfrac {q_i} {p_i} where\r\ngcd(p_i,q_i)=1, you need to print an integer r_i satisfying 0\r\nle r_i<998244353 and r_i\r\ncdot p_i\r\nequiv q_i\r\npmod{998244353}. It can be proved that such r_i exists and is unique.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#define maxn 300005\n#define ll long long\n#define ld double\n#define mod 998244353\n#define maxm 3005\nusing namespace std;\nint n, m; \nint a[maxn], w[maxn];\nll ksm(ll a, ll b)\n{\n\tif(!b) return 1;\n\tll ns = ksm(a, b >> 1);\n\tns = ns * ns % mod;\n\tif(b & 1) ns = ns * a % mod;\n\treturn ns;\n}\nll dp[maxm][maxm];\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tll S[2] = {0, 0};\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &w[i]), \n\t\tS[a[i]] += w[i], \n\t\tS[a[i]] %= mod;\n\tll f[2] = {S[0], S[1]};\n\tdp[1][0] = 1;\n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tll n1 = S[1] + j, n2 = S[0] - (i - 1 - j);\n\t\t\tif(!dp[i][j]) continue;\n\t\t\tll bk = ksm((n1 + n2) % mod, mod - 2);\n\t\t\tn1 = n1 * bk % mod, \n\t\t\tn2 = n2 * bk % mod;\n\t\t\tdp[i + 1][j] += n2 * dp[i][j], dp[i + 1][j] %= mod;\n\t\t\tdp[i + 1][j + 1] += n1 * dp[i][j], dp[i + 1][j + 1] %= mod;\n\t\t}\n\tfor(int j = 0; j <= m + 1; j++)\n\t\tf[1] += dp[m + 1][j] * j, f[1] %= mod, \n\t\tf[0] -= dp[m + 1][j] * (m - j), f[0] %= mod;\n\tS[0] = ksm(S[0], mod - 2);\n\tS[1] = ksm(S[1], mod - 2);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tll ns = f[a[i]] * S[a[i]] % mod * w[i] % mod;\n\t\tif(ns < 0) ns += mod;\n\t\tprintf(\"%lld\\n\", ns);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "probabilities"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C2. Nauuo and Pictures  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/67511",
    "editorial": "Tutorial First, letâs focus on a single picture with weight which Nauuo\nlikes, so we only have to know the sum of the weights of the pictures\nNauuo likes () and the sum of the disliked ones () instead of all the\nweights.Then, we can use DP to solve this problem.Let be the expected\nweight of a picture Nauuo likes with weight after another visits since\nand .Obviously, .The state transition: The next visit displays the\npicture we focus on. Probaility: . Lead to: . The next visit displays a\npicture Nauuo likes but is not the one we focus on. Probaility: . Lead\nto: . The next visit displays a picture Nauuo doesnât like. Probaility:\n. Lead to: . So, .Let be the expected weight of a picture Nauuo doesnât\nlike with weight after another visits since and . The state transition\nis similar.Note that have some relation. In fact we can let be ( and are\nthe initial ones here).But up to now, we can only solve the easy\nversion.To solve the hard version, letâs introduce a lemma:\nProof:Obviously, this is true when .Then, suppose we have already proved\n.Also, a brief but not so strict proof: the increment in each step is\nproportional to the expectation.So, we only have to calculate ().In\nconclusion:If , the expected weight of the -th picture is , otherwise,\nthe expected weight is .Last question: how to calculate the result\nmodulo ?If you donât know how, please read the wiki to learn it.You can\ncalculate and store all the inverses at first, then you can get an\nsolution instead of ( here).\n",
    "hint": []
}