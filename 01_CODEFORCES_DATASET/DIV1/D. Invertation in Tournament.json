{
    "link": "https://codeforces.com//contest/1268/problem/D",
    "problemId": "499895",
    "problem_idx": "D",
    "shortId": "1268D",
    "contest_number": "1268",
    "problem_submissions": {
        "E": [
            67361424,
            67355016,
            67380799,
            67371033,
            67446934,
            67376813,
            68023098,
            68022997
        ],
        "D": [
            67348266,
            67347319,
            67365084,
            67357673,
            67360949,
            67364747,
            67359296,
            67368756,
            67411806,
            68016271
        ],
        "C": [
            67338375,
            67339405,
            67344042,
            67338561,
            67344169,
            67346111,
            67349295,
            67348401,
            67341037,
            67348166,
            67347179,
            67340159,
            67353050,
            67348258,
            67346505,
            67347427,
            67342845,
            67349401,
            67353151,
            67341052
        ],
        "B": [
            67331667,
            67334127,
            67337536,
            67334592,
            67334504,
            67337007,
            67342216,
            67338670,
            67336021,
            67336364,
            67336274,
            67334552,
            67335765,
            67336571,
            67336933,
            67336456,
            67331340,
            67342411,
            67336844,
            67347736
        ],
        "A": [
            67329853,
            67333177,
            67334199,
            67331820,
            67331197,
            67332489,
            67334260,
            67332404,
            67331188,
            67334825,
            67333497,
            67332015,
            67333739,
            67334436,
            67335762,
            67333434,
            67335595,
            67333162,
            67332954,
            67335847
        ]
    },
    "name": "D. Invertation in Tournament",
    "statement": "You are given a tournament complete directed graph.In one operation you\r\ncan pick any vertex v and change the direction of all edges with v on\r\none of the ends (i.e all edges u\r\nto v change their orientation to v\r\nto u and vice versa).You want to make the tournament strongly connected\r\nwith the smallest possible number of such operations if it is possible.\r\nAlso, if it is possible, you need to find the number of ways to make\r\nthis number of operations to make graph strongly connected (two ways are\r\ndifferent if for some i vertex that we chose on i-th operation in one\r\nway is different from vertex that we chose on i-th operation in another\r\nway). You only need to find this value modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 21.12.2019 14:34:39       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass digraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  digraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n\n  digraph<T> reverse() const {\n    digraph<T> rev(n);\n    for (auto &e : edges) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    return rev;\n  }\n};\n\ntemplate <typename T>\nvector<int> find_scc(const digraph<T> &g, int &cnt) {\n  digraph<T> g_rev = g.reverse();\n  vector<int> order;\n  vector<bool> was(g.n, false);\n  function<void(int)> dfs1 = [&](int v) {\n    was[v] = true;\n    for (int id : g.g[v]) {\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (!was[to]) {\n        dfs1(to);\n      }\n    }\n    order.push_back(v);\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (!was[i]) {\n      dfs1(i);\n    }\n  }\n  vector<int> c(g.n, -1);\n  function<void(int)> dfs2 = [&](int v) {\n    for (int id : g_rev.g[v]) {\n      auto &e = g_rev.edges[id];\n      int to = e.to;\n      if (c[to] == -1) {\n        c[to] = c[v];\n        dfs2(to);\n      }\n    }\n  };\n  cnt = 0;\n  for (int id = g.n - 1; id >= 0; id--) {\n    int i = order[id];\n    if (c[i] != -1) {\n      continue;\n    }\n    c[i] = cnt++;\n    dfs2(i);\n  }\n  return c;\n  // c[i] <= c[j] for every edge i -> j\n}\n\nconst int N = 2010;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<string> s(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n  int backup = -1;\n  {\n    digraph<int> g(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (s[i][j] == '1') {\n          g.add(i, j);\n        }\n      }\n    }\n    int cnt = -1;\n    vector<int> foo = find_scc(g, cnt);\n    if (cnt == 1) {\n      cout << \"0 1\" << '\\n';\n      return 0;\n    }\n    if (cnt == 2) {\n      vector<int> cc(2, 0);\n      for (int x : foo) {\n        ++cc[x];\n      }\n      if (min(cc[0], cc[1]) == 1) {\n        backup = 0;\n      } else {\n        backup = 2 * cc[0] * cc[1];\n      }\n    }\n  }\n  vector<bitset<N>> g(n);\n  vector<bitset<N>> g_rev(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (s[i][j] == '1') {\n        g[i].set(j);\n        g_rev[j].set(i);\n      }\n    }\n  }\n  int ans = 0;\n  for (int v = 0; v < n; v++) {\n    for (int i = 0; i < n; i++) {\n      if (i != v) {\n        g[i].flip(v);\n        g[v].flip(i);\n        g_rev[i].flip(v);\n        g_rev[v].flip(i);\n      }\n    }\n    vector<int> order;\n    bitset<N> alive;\n    for (int i = 0; i < n; i++) {\n      alive.set(i);\n    }\n    function<void(int)> Dfs1 = [&](int v) {\n      alive.reset(v);\n      while (true) {\n        auto who = alive & g[v];\n        int i = who._Find_first();\n        if (0 <= i && i < n) {\n          Dfs1(i);\n        } else {\n          break;\n        }\n      }\n      order.push_back(v);\n    };\n    for (int i = 0; i < n; i++) {\n      if (alive[i] == 1) {\n        Dfs1(i);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      alive.set(i);\n    }\n    function<void(int)> Dfs2 = [&](int v) {\n      alive.reset(v);\n      while (true) {\n        auto who = alive & g_rev[v];\n        int i = who._Find_first();\n        if (0 <= i && i < n) {\n          Dfs2(i);\n        } else {\n          break;\n        }\n      }\n    };\n    Dfs2(order.back());\n    if (alive.count() == 0) {\n      ++ans;\n    }\n    for (int i = 0; i < n; i++) {\n      if (i != v) {\n        g[i].flip(v);\n        g[v].flip(i);\n        g_rev[i].flip(v);\n        g_rev[v].flip(i);\n      }\n    }\n  }\n  if (ans > 0) {\n    cout << \"1 \" << ans << '\\n';\n  } else {\n    assert(backup != -1);\n    if (backup == 0) {\n      cout << -1 << '\\n';\n    } else {\n      cout << \"2 \" << backup << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "divide and conquer",
        "graphs",
        "math"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Invertation in Tournament.json",
    "editorial_link": "https://codeforces.com//blog/entry/72358",
    "editorial": "Lemma: for it is always possible to invert one vertex. Start by proving\r\nthat for in the strongly connected tournament it is possible to invert\r\none vertex so it will remain strongly connected, it is possible by\r\ninduction. If there is a big SCC (with at least four vertices), invert\r\ngood vertex in it. If there are at least three strongly connected\r\ncomponents, invert random vertex in the middle one. If there are two\r\nSCCs, then all of them have size , so the number of vertices is .So you\r\ncan check each vertex in with bitset. But also it is possible to check\r\nthat tournament is strongly connected by degree sequence in . For this,\r\nyou can note that the degree of each vertex in the rightest SCC is\r\nsmaller than degrees of all other vertices. So in the sorted by degree\r\norder you can check for the prefix of length , that the number of edges\r\noutgoing from them (sum of degrees) is if there exists which satisfy\r\nthis constraint, then it is simple to prove that the graph is not\r\nstrongly connected.So, you can solve this problem in or in .\r\n",
    "hint": []
}