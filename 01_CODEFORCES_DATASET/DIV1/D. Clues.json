{"link": "https://codeforces.com//contest/156/problem/D", "problemId": "962", "problem_idx": "D", "shortId": "156D", "contest_number": "156", "problem_submissions": {"E": [1251034, 1250912, 1253282, 1312001, 1252010, 1252212], "D": [1249184, 1247144, 1248677, 1244853, 1248432, 1249652, 1248827, 1249495, 1249499, 1249691, 1251015, 1250308, 1250503, 1250715, 1247775, 1249330, 1248752, 1249953], "C": [1246457, 1246202, 1245021, 1245780, 1246904, 1247167, 1247068, 1245810, 1248007, 1247482, 1246141, 1247596, 1248235, 1246808, 1249384, 1245140, 1248141, 1247379], "B": [1245938, 1245171, 1246054, 1247267, 1245759, 1246347, 1246009, 1246866, 1246408, 1246550, 1245203, 1246446, 1245623, 1245940, 1248731, 1247154, 1246738, 1246814], "A": [1244965, 1244119, 1244125, 1246346, 1244442, 1244222, 1247281, 1244463, 1247485, 1245043, 1244152, 1244905, 1244423, 1244550, 1252481, 1251048, 1252049]}, "name": "D. Clues", "statement": "As Sherlock Holmes was investigating another crime, he found a certain\r\nnumber of clues. Also, he has already found between some of those clues.\r\nThe direct links between the clues are mutual. That is, the direct link\r\nbetween clues and and the direct link between clues and is the same\r\nthing. No more than one direct link can exist between two clues.Of\r\ncourse Sherlock is able to find direct links between all clues. But it\r\nwill take too much time and the criminals can use this extra time to\r\nhide. To solve the crime, Sherlock needs each clue to be linked to all\r\nother clues (maybe not directly, via some other clues). Clues and are\r\nconsidered linked either if there is a direct link between them or if\r\nthere is a direct link between and some other clue which is linked to .\r\nSherlock Holmes counted the minimum number of additional direct links\r\nthat he needs to find to solve the crime. As it turns out, it equals\r\n.Please count the number of different ways to find exactly direct links\r\nbetween the clues so that the crime is solved in the end. Two ways to\r\nfind direct links are considered different if there exist two clues\r\nwhich have a direct link in one way and do not have a direct link in the\r\nother way. As the number of different ways can turn out rather big,\r\nprint it modulo .\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nint MOD;\nvoid add(int &a, int b) {\n  a = (a + b) % MOD;\n}\nint mul(int a, int b) { return ll(a) * b % MOD; }\n\nvvi es;\nvb was;\n\nint dfs(int v) {\n  if (was[v]) return 0;\n  was[v] = true;\n  int res = 1;\n  for (int i = 0; i < sz(es[v]); i++)\n    res += dfs(es[v][i]);\n  return res;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\"std.in\", \"r\", stdin);\n  freopen(\"std.out\", \"w\", stdout);\n  #endif\n\n  int n, m;\n  while (scanf(\"%d%d%d\", &n, &m, &MOD) >= 1) {\n    es = vvi(n);\n    for (int i = 0; i < m; i++) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b), a--, b--;\n      es[a].pb(b);\n      es[b].pb(a);\n    }\n    if (MOD == 1) {\n      printf(\"0\\n\");\n      continue;\n    }\n\n    vi ws;\n    was = vb(n, false);\n    for (int i = 0; i < n; i++) if (!was[i])\n      ws.pb(dfs(i));\n\n    n = sz(ws);\n    int res = 1;\n\n    if (n != 1) {\n      for (int i = 0; i < n; i++)\n        res = mul(res, ws[i]);\n\n      int k = 0;\n      for (int i = 0; i < n; i++) add(k, ws[i]);\n      for (int i = 0; i < n - 2; i++) res = mul(res, k);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "graphs"], "dificulty": "2500", "interactive": false}