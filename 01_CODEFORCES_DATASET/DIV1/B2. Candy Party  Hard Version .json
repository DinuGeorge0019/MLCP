{
    "link": "https://codeforces.com//contest/1868/problem/B2",
    "problemId": "2185404",
    "problem_idx": "B2",
    "shortId": "1868B2",
    "contest_number": "1868",
    "problem_submissions": {
        "E": [
            223228586,
            222815728,
            231588269
        ],
        "D": [
            223110671,
            222776638,
            222777162,
            222782980,
            222782523,
            223072795,
            222790549,
            222790677,
            222793420,
            222800103,
            222795470,
            222793980,
            222802561,
            222799384,
            222797784,
            222800727,
            222795823,
            222801192,
            223669050,
            222801040,
            222802199
        ],
        "F": [
            223085466,
            222790947,
            247646963,
            222898179
        ],
        "C": [
            222763067,
            222759154,
            222746616,
            222760340,
            222756156,
            222763622,
            222756124,
            222762393,
            222751686,
            222776556,
            222772834,
            222764583,
            222781677,
            222774228,
            222779099,
            222765233,
            222774182,
            222776098,
            222768907
        ],
        "B2": [
            222745832,
            222748527,
            222758458,
            222744648,
            222743313,
            223073100,
            222746136,
            222743413,
            222746166,
            222738003,
            222740242,
            222749443,
            222748125,
            222749951,
            222757155,
            222748050,
            222749211,
            222753148,
            222756646,
            222747692
        ],
        "B1": [
            222740122,
            222740465,
            222751668,
            222737311,
            222738981,
            222739684,
            222744732,
            222739960,
            222731387,
            222735455,
            222736795,
            222740857,
            222744073,
            222747258,
            222741914,
            222742503,
            222742541,
            222746683,
            222738741
        ],
        "A": [
            222734071,
            222731429,
            222729599,
            222732029,
            222733115,
            222733400,
            222731753,
            222727215,
            222726334,
            222729722,
            222729267,
            222729343,
            222736621,
            222732161,
            222735584,
            222730265,
            222732117,
            222730488,
            222728959
        ]
    },
    "name": "B2. Candy Party  Hard Version ",
    "statement": "After Zhongkao examination, Daniel and his friends are going to have a\r\nparty. Everyone will come with some candies.There will be n people at\r\nthe party. Initially, the i-th person has a_i candies. During the party,\r\nthey will swap their candies. To do this, they will line up and everyone\r\nwill do the following : Choose an integer p (1\r\nle p\r\nle n) and a integer x, then give his 2^{x} candies to the p-th person.\r\nNote that one give more candies than currently he has (he might receive\r\ncandies from someone else before) and he give candies to himself. Daniel\r\nlikes fairness, so he will be happy if and only if everyone receives\r\ncandies from . Meanwhile, his friend Tom likes average, so he will be\r\nhappy if and only if all the people have the same number of candies\r\nafter all swaps.Determine whether there exists a way to swap candies, so\r\nthat both Daniel and Tom will be happy after the swaps.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT ã§æ°åãç®¡çããã¨ãã«ä½¿ã (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify ãã¦ãªãã\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ã½ã¼ããã¦ i çªç®ã idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//ä¾ãã° sortidx ã§å¾ã idx ãä½¿ãã°åã«ã½ã¼ãåã«ãªã£ã¦è¿ã£ã¦ãã\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS revv(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t>\nvoid pb(vc<t>&a,const vc<t>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t>\nvc<t> cat(vc<t> a,const vc<t>&b){\n\tpb(a,b);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\nbool dbg=false;\n\npi calc(int d){\n\tint a=botbit(d);\n\td+=1<<a;\n\tif(ispow2(d))return pi(botbit(d),a);\n\telse return pi(-1,-1);\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tint s=SUM(a);\n\tif(s%n){\n\t\treturn No(0);\n\t}\n\tint tar=s/n;\n\t\n\tconst int L=35;\n\tvi ls[L][2];\n\tvi arb;\n\tint cnt[L][2]{};\n\trep(i,n){\n\t\tif(a[i]<tar){\n\t\t\tif(ispow2(tar-a[i])){\n\t\t\t\tcnt[topbit(tar-a[i])][0]++;\n\t\t\t}else{\n\t\t\t\tauto [x,y]=calc(tar-a[i]);\n\t\t\t\tif(x==-1)return No(0);\n\t\t\t\tls[x][0].pb(i);\n\t\t\t\tls[y][1].pb(i);\n\t\t\t}\n\t\t}else if(a[i]>tar){\n\t\t\tif(ispow2(a[i]-tar)){\n\t\t\t\tcnt[topbit(a[i]-tar)][1]++;\n\t\t\t}else{\n\t\t\t\tauto [x,y]=calc(a[i]-tar);\n\t\t\t\tif(x==-1)return No(0);\n\t\t\t\tls[y][0].pb(i);\n\t\t\t\tls[x][1].pb(i);\n\t\t\t}\n\t\t}else{\n\t\t\tarb.pb(i);\n\t\t}\n\t}\n\t\n\tper(lv,L){\n\t\trep(k,2){\n\t\t\tcnt[lv][k]+=si(ls[lv][k]);\n\t\t}\n\t\trep(k,2){\n\t\t\tint u=max(cnt[lv][k^1]-cnt[lv][k],0ll);\n\t\t\tif(u>0){\n\t\t\t\tif(lv==0||cnt[lv-1][k]<u){\n\t\t\t\t\treturn No(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(k,2){\n\t\t\tint u=max(cnt[lv][k^1]-cnt[lv][k],0ll);\n\t\t\tif(u>0){\n\t\t\t\tcnt[lv-1][k]-=u;\n\t\t\t\tcnt[lv-1][k^1]+=u;\n\t\t\t\tcnt[lv][k]+=u;\n\t\t\t}\n\t\t}\n\t\tassert(cnt[lv][0]==cnt[lv][1]);\n\t}\n\t\n\tYes(0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B2. Candy Party  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/116642",
    "editorial": "Read the tutorial for D1 first.Consider the graph we built in this\r\nversion. It should only consist of chains and cycles.For the start nodes\r\nof chains and the end nodes of chains, must hold.Thus, for , we sill\r\nhave only one way to decide the number of candies given away and\r\nreceived (the same as D1). However, for , we have two ways: the same way\r\nas D1 (use the equation ); let this person be the start or end node of\r\nchains, that is, or . (Suppose is the number of candies he gives away or\r\nreceives) Again, letâs omit those nodes with first. Then we can\r\nsimilarly maintain two sets and to D1.Let be the number of -s in set and\r\nbe the number of -s in . Note that now we omit nodes with when\r\nmaintaining both sets.Let be the number of nodes with and be the number\r\nof nodes with .For nodes with , the two ways are: , or ; , or . To make\r\nthe two sets and equal, we must make for all .Now consider nodes with .\r\nWe can determine bit-by-bit. Letâs start from the first bit.Consider :\r\nif we choose elements to use the first way, then: ; ; .Consider : if we\r\nchoose elements to use the first way, then: ; ; .Letâs consider the\r\nhighest bit. All elements in must be chosen the second way (),\r\notherwise, it will influence . Then we can determine the for , then .At\r\nlast, we check if (we have made for all ). If so, the answer is \"\",\r\notherwise the answer is \"\".\r\n",
    "hint": [
        "Hint 4 For whom may not give or receive candies?",
        "Hint 5 When is a power of , how many ways can the person gives/receives candies at most?",
        "Hint 6 Try to determine some people's way to give/receive candies first, then others. How to do this? Bit-by-bit."
    ]
}