{
    "link": "https://codeforces.com//contest/790/problem/D",
    "problemId": "98952",
    "problem_idx": "D",
    "shortId": "790D",
    "contest_number": "790",
    "problem_submissions": {
        "D": [
            25675131,
            25621791,
            25620770,
            25622633,
            25623312,
            25623816,
            25680670,
            25648868
        ],
        "E": [
            25623895,
            26123540,
            26123499,
            26123493,
            26123456,
            26123432,
            26123251,
            25617517
        ],
        "C": [
            25613244,
            25614979,
            25616936,
            25615762,
            25617856,
            25618954,
            25661266,
            25614888,
            25615074,
            25614005,
            25609588,
            25614426,
            25615773,
            25615586,
            25615794,
            25615992,
            25615935,
            25616033
        ],
        "B": [
            25609297,
            25610960,
            25614995,
            25612479,
            25611945,
            25614279,
            25608753,
            25610247,
            25611326,
            25609739,
            25611787,
            25609929,
            25612272,
            25613816,
            25610322,
            25610272,
            25611239,
            25970156,
            25970140,
            25970114,
            25970098,
            25969741,
            25969717,
            25967914,
            25967797,
            25967715,
            25967642,
            25967579,
            25967531,
            25967441,
            25967437,
            25967418,
            25967341,
            25628594,
            25611848
        ],
        "A": [
            25606141,
            25607710,
            25610915,
            25606934,
            25606698,
            25609653,
            25606498,
            25607278,
            25607609,
            25607400,
            25613182,
            25606914,
            25607776,
            25606578,
            25607601,
            25607434,
            25608027,
            25628141,
            25608400
        ]
    },
    "name": "D. Bear and Rectangle Strips",
    "statement": "Limak has a grid that consists of rows and columns. The -th cell in the\r\n-th row contains an integer which can be positive, negative or zero.A\r\nnon-empty rectangle of cells is called if and only if the sum of numbers\r\nin its cells is equal to .Limak wants to choose some nice rectangles and\r\ngive them to his friends, as gifts. No two chosen rectangles should\r\nshare a cell. What is the maximum possible number of nice rectangles\r\nLimak can choose?\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 3e5 + 10;\nint a[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < n; ++j) {\n      scanf(\"%d\", a[i] + j);\n    }\n  }\n  return 1;\n}\n\nint go[3][maxn];\n\nint ans[maxn];\n\nvector<pair<int, int> > toup[maxn][2];\n\nvoid mmax(int &x, int y) {\n  x = max(x, y);\n}\n\nvoid process(int s, int t, int val) {\n  mmax(ans[max(s, t)], val);\n\n  for (int j = 0; j < 3; ++j) {\n    int from = (!j ? s : (j == 1 ? t : max(s, t)));\n    from = go[j][from];\n    if (from > n) {\n      continue;\n    }\n    int ns = s, nt = t;\n    if (j != 1) {\n      ns = from;\n    }\n    if (j != 0) {\n      nt = from;\n    }\n\n    mmax(ans[max(ns, nt)], val + 1);\n    if (ns < nt) {\n      toup[ns][1].pb(mp(val + 1, nt));\n    }\n    if (nt < ns) {\n      toup[nt][0].pb(mp(val + 1, ns));\n    }\n  }\n}\n\nvoid solve() {\n  for (int iter = 0; iter < 3; ++iter) {\n    go[iter][n] = n + 1;\n    map<long long, int> last;\n\n    long long sum = 0;\n    last[sum] = n;\n    for (int i = n - 1; i >= 0; --i) {\n      for (int j = 0; j < 2; ++j) {\n        if ((iter + 1) & (1 << j)) {\n          sum += a[j][i];\n        }\n      }\n      auto &cur = go[iter][i];\n      cur = go[iter][i + 1];\n      auto iter = last.find(sum);\n      if (iter != last.end()) {\n        int pos = iter->second;\n        cur = min(cur, pos);\n      }\n      last[sum] = i;\n    }\n  }\n\n  for (int i = 0; i <= n; ++i) {\n    ans[i] = 0;\n    toup[i][0].clear();\n    toup[i][1].clear();\n  }\n\n  for (int i = 0; i < n; ++i) {\n    process(i, i, ans[i]);\n\n    for (int j = 0; j < 2; ++j) {\n      int best = n + 1;\n      for (auto p : toup[i][j]) {\n        if (p.first == ans[i] + 1) {\n          best = min(best, p.second);\n        }\n      }\n      if (best > n) {\n        continue;\n      }\n\n      int s = i, t = best;\n      if (!j) {\n        swap(s, t);\n      }\n      process(s, t, ans[i] + 1);\n    }\n  }\n\n  int res = *max_element(ans, ans + n + 1);\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Bear and Rectangle Strips.json",
    "editorial_link": "https://codeforces.com//blog/entry/51068",
    "editorial": "There are three types of rectangles: in the top row, in the bottom row, and in both rows (with height 2). For each type, and for each starting index i we can quite easily find the first possible ending index - it's the first index on the right with the same prefix sum of numbers (it means that the difference of prefix sums is 0). We can iterate from right to left for each of three types, use store prefix sums in the set and for each type and each starting index we can remember the first possible ending index (or we will know that there is no such index). The complexity of this part is .\n\nNow, the naive square solution would be to create an array dp[n][n] and compute dp[i][j] as the maximum possible score, if we are allowed to use only first i cells in the first row and first j cells in the second row. Thanks to the precomputing above, we can move from a state in O(1), considering the following options:\n\nincrease i by 1 (without taking any rectangle)\nincrease j by 1\ntake the first possible rectangle in the first row (check what is the first possible ending index of a rectangle in the first row, starting at index i?+?1)\ntake the first possible rectangle in the second row\nif i?=?j, also consider taking first possible rectangle of height 2 (in both rows)\nNow let's improve this part to O(n). Let Ci denote the best score if we were allowed to use only first i cells in each row (Ci?=?dp[i][i]). It turns out that the following values for each i are enough to solve the problem:\n\nCi\nIf we were allowed to use only first i cells in the first row, how far we must go in the second row, in order to get the score Ci?+?1. In other words, what is the smallest j such that dp[i][j]?=?Ci?+?1\nSimilarly, the smallest j such that dp[j][i]?=?Ci?+?1\nTake a look at the drawings below. The value Ci is the maximum possible score for light-blue cells on the left drawing. The right drawing shows the third of situation listed above - we want to know what prefix of cells in the first row is needed, if we want to get the score Ci?+?1.\n\n\nTo see that it works, we must prove that we don't have to care how far we must go in one row to get the score Ci?+?2 or higher. The crucial observation that getting score at least Ci?+?2 means that we took at least two rectangles that are at least partially on the right from index i (i.e. each of them contains at least one cell with index greater than i) - see the drawing below. So, instead of considering this situation now, we can first take some rectangle in the second row (or skip a few cells) because we can take that last rectangle in the first row later. In other words, when we are in the state dp[i][j] where i?<?j, it's enough to consider taking a rectangle in the first row or just increasing i without taking anything.",
    "hint": []
}