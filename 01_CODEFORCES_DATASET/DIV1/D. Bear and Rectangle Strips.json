{"link": "https://codeforces.com//contest/790/problem/D", "problemId": "98952", "problem_idx": "D", "shortId": "790D", "contest_number": "790", "problem_submissions": {"D": [25675131, 25621791, 25620770, 25622633, 25623312, 25623816, 25680670, 25648868], "E": [25623895, 26123540, 26123499, 26123493, 26123456, 26123432, 26123251, 25617517], "C": [25613244, 25614979, 25616936, 25615762, 25617856, 25618954, 25661266, 25614888, 25615074, 25614005, 25609588, 25614426, 25615773, 25615586, 25615794, 25615992, 25615935, 25616033], "B": [25609297, 25610960, 25614995, 25612479, 25611945, 25614279, 25608753, 25610247, 25611326, 25609739, 25611787, 25609929, 25612272, 25613816, 25610322, 25610272, 25611239, 25970156, 25970140, 25970114, 25970098, 25969741, 25969717, 25967914, 25967797, 25967715, 25967642, 25967579, 25967531, 25967441, 25967437, 25967418, 25967341, 25628594, 25611848], "A": [25606141, 25607710, 25610915, 25606934, 25606698, 25609653, 25606498, 25607278, 25607609, 25607400, 25613182, 25606914, 25607776, 25606578, 25607601, 25607434, 25608027, 25628141, 25608400]}, "name": "D. Bear and Rectangle Strips", "statement": "Limak has a grid that consists of rows and columns. The -th cell in the\r\n-th row contains an integer which can be positive, negative or zero.A\r\nnon-empty rectangle of cells is called if and only if the sum of numbers\r\nin its cells is equal to .Limak wants to choose some nice rectangles and\r\ngive them to his friends, as gifts. No two chosen rectangles should\r\nshare a cell. What is the maximum possible number of nice rectangles\r\nLimak can choose?\r\n", "solutions": ["#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 3e5 + 10;\nint a[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < n; ++j) {\n      scanf(\"%d\", a[i] + j);\n    }\n  }\n  return 1;\n}\n\nint go[3][maxn];\n\nint ans[maxn];\n\nvector<pair<int, int> > toup[maxn][2];\n\nvoid mmax(int &x, int y) {\n  x = max(x, y);\n}\n\nvoid process(int s, int t, int val) {\n  mmax(ans[max(s, t)], val);\n\n  for (int j = 0; j < 3; ++j) {\n    int from = (!j ? s : (j == 1 ? t : max(s, t)));\n    from = go[j][from];\n    if (from > n) {\n      continue;\n    }\n    int ns = s, nt = t;\n    if (j != 1) {\n      ns = from;\n    }\n    if (j != 0) {\n      nt = from;\n    }\n\n    mmax(ans[max(ns, nt)], val + 1);\n    if (ns < nt) {\n      toup[ns][1].pb(mp(val + 1, nt));\n    }\n    if (nt < ns) {\n      toup[nt][0].pb(mp(val + 1, ns));\n    }\n  }\n}\n\nvoid solve() {\n  for (int iter = 0; iter < 3; ++iter) {\n    go[iter][n] = n + 1;\n    map<long long, int> last;\n\n    long long sum = 0;\n    last[sum] = n;\n    for (int i = n - 1; i >= 0; --i) {\n      for (int j = 0; j < 2; ++j) {\n        if ((iter + 1) & (1 << j)) {\n          sum += a[j][i];\n        }\n      }\n      auto &cur = go[iter][i];\n      cur = go[iter][i + 1];\n      auto iter = last.find(sum);\n      if (iter != last.end()) {\n        int pos = iter->second;\n        cur = min(cur, pos);\n      }\n      last[sum] = i;\n    }\n  }\n\n  for (int i = 0; i <= n; ++i) {\n    ans[i] = 0;\n    toup[i][0].clear();\n    toup[i][1].clear();\n  }\n\n  for (int i = 0; i < n; ++i) {\n    process(i, i, ans[i]);\n\n    for (int j = 0; j < 2; ++j) {\n      int best = n + 1;\n      for (auto p : toup[i][j]) {\n        if (p.first == ans[i] + 1) {\n          best = min(best, p.second);\n        }\n      }\n      if (best > n) {\n        continue;\n      }\n\n      int s = i, t = best;\n      if (!j) {\n        swap(s, t);\n      }\n      process(s, t, ans[i] + 1);\n    }\n  }\n\n  int res = *max_element(ans, ans + n + 1);\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "3000", "interactive": false}