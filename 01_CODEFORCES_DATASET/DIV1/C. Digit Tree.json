{
    "link": "https://codeforces.com//contest/715/problem/C",
    "problemId": "71752",
    "problem_idx": "C",
    "shortId": "715C",
    "contest_number": "715",
    "problem_submissions": {
        "C": [
            20696388,
            20695004,
            21061298,
            20699940,
            20701250,
            20701868,
            20701116,
            20702792,
            20705491,
            20706113,
            20706200,
            20706281,
            20707436,
            24089587,
            24089381,
            24088919,
            20705717,
            20710613,
            20711318,
            20708989,
            20702215
        ],
        "B": [
            20690967,
            20701021,
            20694773,
            20689928,
            20695175,
            20694958,
            20694279,
            20691617,
            20695201,
            20696087,
            20696649,
            20697145,
            20700774,
            20699191,
            20696353,
            20693835,
            20699900,
            20710746
        ],
        "A": [
            20686008,
            20686996,
            20686577,
            20686363,
            20687890,
            20687984,
            20686198,
            20687360,
            20686283,
            20689813,
            20687583,
            20686153,
            20687354,
            20704067,
            20689971,
            20689194,
            20690664,
            20687863,
            20690670,
            20692537
        ],
        "D": [
            20709863,
            20712963,
            20746777,
            20704223,
            20700524
        ]
    },
    "name": "C. Digit Tree",
    "statement": "ZS the Coder has a large tree. It can be represented as an undirected\r\nconnected graph of vertices numbered from to and edges between them.\r\nThere is a single digit written on each edge.One day, ZS the Coder was\r\nbored and decided to investigate some properties of the tree. He chose a\r\npositive integer , which is to , i.e. .ZS consider an of distinct\r\nvertices when if he would follow the shortest path from vertex to vertex\r\nand write down all the digits he encounters on his path in the same\r\norder, he will get a decimal representaion of an integer divisible by\r\n.Formally, ZS consider an ordered pair of distinct vertices interesting\r\nif the following states true: Let be the sequence of vertices on the\r\nshortest path from to in the order of encountering them; Let () be the\r\ndigit written on the edge between vertices and ; The integer is\r\ndivisible by . Help ZS the Coder find the number of interesting pairs!\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint q[N],f[N],vis[N],sz[N],ms[N];\nvector<PII> e[N];\nmap<int,int> c2;\nint n,u,v,d;\nll ret,pw[N],ipw[N],vv,M,r2;\nint find(int u) {\n\tint t=1;q[0]=u;f[u]=-1;\n\trep(i,0,t) {\n\t\tu=q[i];\n\t\trep(j,0,e[u].size()) {\n\t\t\tint v=e[u][j].fi;\n\t\t\tif (!vis[v]&&v!=f[u]) f[q[t++]=v]=u;\n\t\t}\n\t\tms[q[i]]=0;\n\t\tsz[q[i]]=1;\n\t}\n\tfor (int i=t-1;i>=0;i--) {\n\t\tms[q[i]]=max(ms[q[i]],t-sz[q[i]]);\n\t\tif (ms[q[i]]*2<=t) return q[i];\n\t\tsz[f[q[i]]]+=sz[q[i]];\n\t\tms[f[q[i]]]=max(ms[f[q[i]]],sz[q[i]]);\n\t}\n\treturn 0;\n}\nvoid dfs1(int u,int f,int w,int d) {\n\tif (w==0) ++r2;\n\tret+=c2[(M-w)*ipw[d]%M];\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (v==f||vis[v]) continue;\n\t\tdfs1(v,u,(10ll*w+p.se)%M,d+1);\n\t}\n}\nvoid dfs2(int u,int f,int w,int d) {\n\tif (w==0) ++r2;\n\tc2[w]++;\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (v==f||vis[v]) continue;\n\t\tdfs2(v,u,(w+p.se*pw[d])%M,d+1);\n\t}\n}\n\nll inv(ll q,ll m) {\n\tq%=m;if (q<0) q+=m;\n\tif (q==0) return 0;\n\tll a1=m,b1=0,a2=q,b2=1,a3=0,b3=0,t=0;\n\twhile (a2!=1) {\tt=a1/a2,a3=a1-t*a2,b3=b1-t*b2%m,\n\t\ta1=a2,a2=a3,b1=b2,b2=b3;if (b2<0) b2+=m;}\n\treturn b2;\n}\n\nvoid solve(int u) {\n\tu=find(u);\n\tc2.clear();\n\tfor (auto p:e[u]) if (!vis[p.fi]) {\n\t\tint v=p.fi;\n\t\tdfs1(v,u,p.se%M,1);\n\t\tdfs2(v,u,p.se%M,1);\n\t}\n\tc2.clear();\n\treverse(all(e[u]));\n\tfor (auto p:e[u]) if (!vis[p.fi]) {\n\t\tint v=p.fi;\n\t\tdfs1(v,u,p.se%M,1);\n\t\tdfs2(v,u,p.se%M,1);\n\t}\n\tvis[u]=1;\n\tfor (auto p:e[u]) if (!vis[p.fi]) solve(p.fi);\n}\nint main() {\n\tscanf(\"%d%lld\",&n,&M);\n\tvv=inv(10,M);\n\tpw[0]=1; ipw[0]=1;\n\trep(i,1,n+1) {\n\t\tpw[i]=pw[i-1]*10%M;\n\t\tipw[i]=ipw[i-1]*vv%M;\n\t}\n\trep(i,1,n) {\n\t\tscanf(\"%d%d%d\",&u,&v,&d);\n\t\te[u].pb(mp(v,d));\n\t\te[v].pb(mp(u,d));\n\t}\n\tsolve(0);\n\tprintf(\"%lld\\n\",ret+r2/2);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "divide and conquer",
        "dsu",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Digit Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/47169",
    "editorial": "Prerequisites : Tree DP, Centroid Decomposition, Math Compared to the\r\nother problems, this one is more standard. The trick is to first solve\r\nthe problem if we have a fixed vertex as root and we want to find the\r\nnumber of paths passing through that works. This can be done with a\r\nsimple tree dp. For each node , compute the number obtained when going\r\nfrom down to and the number obtained when going from up to , where each\r\nnumber is taken modulo . This can be done with a simple dfs. To\r\ncalculate the down value, just multiply the value of the parent node by\r\nand add the value on the edge to it. To calculate the up value, we also\r\nneed to calculate the height of the node. (i.e. the distance from to )\r\nThen, if we let be the height of , be the digit on the edge connecting\r\nto its parent and be the up value of the parent of , then the up value\r\nfor is equal to . Thus, we can calculate the up and down value for each\r\nnode with a single dfs. Next, we have to figure out how to combine the\r\nup values and down values to find the number of paths passing through\r\nthat are divisible by . For this, note that each path is the\r\nconcatenation of a path from to and to , where and are pairs of vertices\r\nfrom different subtrees, and the paths that start from and end at . For\r\nthe paths that start and end at the answer can be easily calculated with\r\nthe up and down values (just iterate through all nodes as the other\r\nendpoint). For the other paths, we iterate through all possible , and\r\nfind the number of vertices such that going from to will give a multiple\r\nof . Since is fixed, we know its height and down value, which we denote\r\nas and respectively. So, if the up value of is equal to , then must be a\r\nmultiple of . So, we can solve for to be modulo . Note that in this case\r\nthe multiplicative inverse of modulo is well-defined, as we have the\r\ncondition . To find the multiplicative inverse of , we can find and\r\nsince by Eulerâs Formula we have if , we have , which is the\r\nmultiplicative inverse of (in this case we have ) modulo . After that,\r\nfinding the value can be done by binary exponentiation. Thus, we can\r\nfind the unique value of such that the path from to is a multiple of .\r\nThis means that we can just use a map to store the up values of all\r\nnodes and also the up values for each subtree. Then, to find the number\r\nof viable nodes , find the required value of and subtract the number of\r\nsuitable nodes that are in the same subtree as from the total number of\r\nsuitable nodes. Thus, for each node , we can find the number of suitable\r\nnodes in time. Now, we have to generalize this for the whole tree. We\r\ncan use centroid decomposition. We pick the centroid as the root and\r\nfind the number of paths passing through as above. Then, the other paths\r\nwonât pass through , so we can remove and split the tree into more\r\nsubtrees, and recursively solve for each subtree as well. Since each\r\nsubtree is at most half the size of the original tree, and the time\r\ntaken to solve the problem where the path must pass through the root for\r\na single tree takes time proportional to the size of the tree, this\r\nsolution works in time, where the other comes from using maps. Time\r\nComplexity : Code\r\n",
    "hint": []
}