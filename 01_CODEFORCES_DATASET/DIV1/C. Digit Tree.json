{"link": "https://codeforces.com//contest/715/problem/C", "problemId": "71752", "problem_idx": "C", "shortId": "715C", "contest_number": "715", "problem_submissions": {"C": [20696388, 20695004, 21061298, 20699940, 20701250, 20701868, 20701116, 20702792, 20705491, 20706113, 20706200, 20706281, 20707436, 24089587, 24089381, 24088919, 20705717, 20710613, 20711318, 20708989, 20702215], "B": [20690967, 20701021, 20694773, 20689928, 20695175, 20694958, 20694279, 20691617, 20695201, 20696087, 20696649, 20697145, 20700774, 20699191, 20696353, 20693835, 20699900, 20710746], "A": [20686008, 20686996, 20686577, 20686363, 20687890, 20687984, 20686198, 20687360, 20686283, 20689813, 20687583, 20686153, 20687354, 20704067, 20689971, 20689194, 20690664, 20687863, 20690670, 20692537], "D": [20709863, 20712963, 20746777, 20704223, 20700524]}, "name": "C. Digit Tree", "statement": "ZS the Coder has a large tree. It can be represented as an undirected\r\nconnected graph of vertices numbered from to and edges between them.\r\nThere is a single digit written on each edge.One day, ZS the Coder was\r\nbored and decided to investigate some properties of the tree. He chose a\r\npositive integer , which is to , i.e. .ZS consider an of distinct\r\nvertices when if he would follow the shortest path from vertex to vertex\r\nand write down all the digits he encounters on his path in the same\r\norder, he will get a decimal representaion of an integer divisible by\r\n.Formally, ZS consider an ordered pair of distinct vertices interesting\r\nif the following states true: Let be the sequence of vertices on the\r\nshortest path from to in the order of encountering them; Let () be the\r\ndigit written on the edge between vertices and ; The integer is\r\ndivisible by . Help ZS the Coder find the number of interesting pairs!\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint q[N],f[N],vis[N],sz[N],ms[N];\nvector<PII> e[N];\nmap<int,int> c2;\nint n,u,v,d;\nll ret,pw[N],ipw[N],vv,M,r2;\nint find(int u) {\n\tint t=1;q[0]=u;f[u]=-1;\n\trep(i,0,t) {\n\t\tu=q[i];\n\t\trep(j,0,e[u].size()) {\n\t\t\tint v=e[u][j].fi;\n\t\t\tif (!vis[v]&&v!=f[u]) f[q[t++]=v]=u;\n\t\t}\n\t\tms[q[i]]=0;\n\t\tsz[q[i]]=1;\n\t}\n\tfor (int i=t-1;i>=0;i--) {\n\t\tms[q[i]]=max(ms[q[i]],t-sz[q[i]]);\n\t\tif (ms[q[i]]*2<=t) return q[i];\n\t\tsz[f[q[i]]]+=sz[q[i]];\n\t\tms[f[q[i]]]=max(ms[f[q[i]]],sz[q[i]]);\n\t}\n\treturn 0;\n}\nvoid dfs1(int u,int f,int w,int d) {\n\tif (w==0) ++r2;\n\tret+=c2[(M-w)*ipw[d]%M];\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (v==f||vis[v]) continue;\n\t\tdfs1(v,u,(10ll*w+p.se)%M,d+1);\n\t}\n}\nvoid dfs2(int u,int f,int w,int d) {\n\tif (w==0) ++r2;\n\tc2[w]++;\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (v==f||vis[v]) continue;\n\t\tdfs2(v,u,(w+p.se*pw[d])%M,d+1);\n\t}\n}\n\nll inv(ll q,ll m) {\n\tq%=m;if (q<0) q+=m;\n\tif (q==0) return 0;\n\tll a1=m,b1=0,a2=q,b2=1,a3=0,b3=0,t=0;\n\twhile (a2!=1) {\tt=a1/a2,a3=a1-t*a2,b3=b1-t*b2%m,\n\t\ta1=a2,a2=a3,b1=b2,b2=b3;if (b2<0) b2+=m;}\n\treturn b2;\n}\n\nvoid solve(int u) {\n\tu=find(u);\n\tc2.clear();\n\tfor (auto p:e[u]) if (!vis[p.fi]) {\n\t\tint v=p.fi;\n\t\tdfs1(v,u,p.se%M,1);\n\t\tdfs2(v,u,p.se%M,1);\n\t}\n\tc2.clear();\n\treverse(all(e[u]));\n\tfor (auto p:e[u]) if (!vis[p.fi]) {\n\t\tint v=p.fi;\n\t\tdfs1(v,u,p.se%M,1);\n\t\tdfs2(v,u,p.se%M,1);\n\t}\n\tvis[u]=1;\n\tfor (auto p:e[u]) if (!vis[p.fi]) solve(p.fi);\n}\nint main() {\n\tscanf(\"%d%lld\",&n,&M);\n\tvv=inv(10,M);\n\tpw[0]=1; ipw[0]=1;\n\trep(i,1,n+1) {\n\t\tpw[i]=pw[i-1]*10%M;\n\t\tipw[i]=ipw[i-1]*vv%M;\n\t}\n\trep(i,1,n) {\n\t\tscanf(\"%d%d%d\",&u,&v,&d);\n\t\te[u].pb(mp(v,d));\n\t\te[v].pb(mp(u,d));\n\t}\n\tsolve(0);\n\tprintf(\"%lld\\n\",ret+r2/2);\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "divide and conquer", "dsu", "trees"], "dificulty": "2700", "interactive": false}