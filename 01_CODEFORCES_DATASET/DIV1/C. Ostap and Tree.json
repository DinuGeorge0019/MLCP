{
    "link": "https://codeforces.com//contest/736/problem/C",
    "problemId": "82053",
    "problem_idx": "C",
    "shortId": "736C",
    "contest_number": "736",
    "problem_submissions": {
        "C": [
            22555337,
            22554506,
            22542338,
            22535831,
            22538132,
            22542963,
            22545295,
            22544856,
            22555696,
            22545920,
            22543329,
            22542401,
            22544023,
            22544088,
            22549626,
            22550878
        ],
        "E": [
            22551348,
            22559840,
            22556062,
            22550741,
            22535583,
            22555885,
            22560242,
            22554763,
            22557400,
            22557039,
            22555474,
            22555738,
            22555988,
            22544797,
            22548099
        ],
        "B": [
            22540910,
            22533406,
            22531522,
            22550856,
            22532550,
            22535729,
            22553163,
            22533593,
            22532530,
            22545935,
            22532493,
            22534671,
            22535087,
            22535221,
            22540506,
            22540155,
            22534429,
            22543621,
            22539284,
            22532660
        ],
        "D": [
            22539634,
            22548080,
            22543151,
            22542192,
            22547599,
            22543734,
            22549554,
            22547719,
            22543270,
            22554259,
            22553954,
            22555670,
            22555340
        ],
        "A": [
            22535135,
            22530967,
            22530408,
            22545237,
            22532700,
            22532341,
            22531205,
            22530536,
            22540413,
            22530773,
            22536724,
            22531871,
            22532439,
            22531278,
            22530654,
            22531077,
            22533541,
            22530767,
            22530574
        ]
    },
    "name": "C. Ostap and Tree",
    "statement": "Ostap already settled down in Rio de Janiero suburb and started to grow\r\na tree in his garden. Recall that a tree is a connected undirected\r\nacyclic graph. Ostapâ€™s tree now has vertices. He wants to paint some\r\nvertices of the tree black such that from any vertex there is at least\r\none black vertex at distance no more than . between two vertices of the\r\ntree is the minimum possible number of edges of the path between them.As\r\nthis number of ways to paint the tree can be large, Ostap wants you to\r\ncompute it modulo . Two ways to paint the tree are considered different\r\nif there exists a vertex that is painted black in one way and is not\r\npainted in the other one.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\nconst int mo=1e9+7;\nint qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nint n,k;\n\n// manually set n = number of vertices \n// vertex index from 1 to n\n// first call tree_init();\n// ae(u,v) only one direction\n\nconst int TREE_MAXV=3000+5;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pre[TREE_MAXV];\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpre[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t}\n\t}\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\nvoid readedge(){\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;gn(x);gn(y);\n\t\tae(x,y);ae(y,x);\n\t}\n}\n\n\nint f[111][33][33];\nvoid dp(int u){\n\tint h[33][33];\n\tint h2[33][33];\n\tint deg=0;\n\tmemset(h,0,sizeof(h));\n\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\tif(deg==0){\n\t\t\tdeg++;\n\t\t\trep(j,0,k+3)rep(t,0,k+3)h[j][t]=f[e[i].v][j][t];\n\t\t}else{\n\t\t\tcl(h2);\n\t\t\trep(j,0,k+3)rep(t,0,k+3)if(h[j][t])\n\t\t\t\trep(jj,0,k+3)rep(tt,0,k+3)if(f[e[i].v][jj][tt]){\n\t\t\t\t\tint qian=min(jj,j);\n\t\t\t\t\tint xu=k+2;\n\t\t\t\t\tif(t!=k+2){\n\t\t\t\t\t\tif(jj+2>t)upmin(xu,t);\n\t\t\t\t\t}\n\t\t\t\t\tif(tt!=k+2){\n\t\t\t\t\t\tif(j+2>tt)upmin(xu,tt);\n\t\t\t\t\t}\n\t\t\t\t\tupmo(h2[qian][xu],1ll*h[j][t]*f[e[i].v][jj][tt]);\n\t\t\t\t}\n\t\t\trep(j,0,k+3)rep(t,0,k+3)h[j][t]=h2[j][t];\n\t\t\tdeg++;\n\t\t}\n\t}\n\tif(deg){\n\t\trep(j,0,k+3)rep(t,1,k+3){\n\t\t\t//white\n\t\t\tint xu=k+2;\n\t\t\tif(j+1>k)xu=k;\n\t\t\tif(t!=k+2)xu=min(xu,t-1);\n\t\t\tint qian=min(k+2,j+1);\n\t\t\tif(xu>=0)upmo(f[u][qian][xu],h[j][t]);\n\n\t\t\t//black\n\t\t\tupmo(f[u][0][k+2],h[j][t]);\n\t\t}\n\t}else{\n\t\tf[u][0][k+2]=1;\n\t\tf[u][k+2][k]=1;\n\n\t}\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\ttree_init();\n\tgn(n);gn(k);\n\treadedge();\n\tbfs(1);\n\tfor (int i=n-1;i>=0;i--){\n\t\tdp(qu[i]);\n\t}\n\tint ans=0;\n\trep(i,0,k+3)upmo(ans,f[1][i][k+2]);\n\tprintf(\"%d\\n\",ans);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Ostap and Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/48659",
    "editorial": "First of all, thanks to albert96 and GlebsHP for their help with the\r\ntutorial of this problem. Secondly, sorry for being late. Problem can be\r\nsolved by the method of dynamic programming. Let dp[v][i][j] be the\r\nnumber of possibilities to color subtree of vertex v in such a way that\r\nthe closest black vertex is on depth i, and the closest white vertex on\r\ndepth j (we also store dp[v][-1][j] and dp[v][i][-1] in the cases where\r\nthere are no black and white vertexes in diapason k of v respectively).\r\nIn order to connect two subtrees, we can check all pairs (i,j) in both\r\nsubtrees (by brute-force algorithm). Then let we have pair (a,c) in the\r\nfirst subtree and pair (b,d) in the second one. If min(a,c)+max(b,d)<=k,\r\nthen we update value of current vertex. Complexity of the algorithm\r\nO(n*k^4), which is acceptable for this particular problem (n the number\r\nof vertexes, k^4 brute force search of pairs (a,b); (c,d)).\r\n",
    "hint": []
}