{
    "link": "https://codeforces.com//contest/1464/problem/C",
    "problemId": "839212",
    "problem_idx": "C",
    "shortId": "1464C",
    "contest_number": "1464",
    "problem_submissions": {
        "D": [
            101893944,
            101884165,
            101894987,
            101897288,
            101893426,
            101899167,
            101898742,
            101897221,
            101904879,
            101902404,
            101904041,
            101898196,
            101901056,
            101893113,
            101900043,
            101901977,
            101879521,
            101891500
        ],
        "E": [
            101884958,
            101888698,
            101880762,
            101885481,
            101895459,
            101874392,
            101918343,
            101889791,
            101890948,
            101887375,
            142038158,
            102279161,
            102087511,
            101887630,
            101883023,
            101908666,
            101908552,
            101908506,
            101893369,
            101884575,
            101899034,
            101888272,
            101881773,
            101903223,
            101903745,
            101882555
        ],
        "C": [
            101877309,
            101876849,
            101885303,
            101878303,
            101875140,
            101886810,
            101875737,
            101878040,
            101880124,
            101880970,
            101877103,
            101881975,
            101878148,
            101882821,
            101880363,
            101877971,
            101885296,
            101877773,
            101876637
        ],
        "B": [
            101870508,
            101872024,
            101876423,
            101872980,
            101870882,
            101883179,
            101870101,
            101869654,
            101875498,
            101874908,
            101869353,
            101877667,
            101902344,
            101877756,
            101876619,
            101904584,
            101891390,
            101873346,
            101870962
        ],
        "A": [
            101862412,
            101862840,
            101865321,
            101865985,
            101861233,
            101876553,
            101861535,
            101873147,
            101867432,
            101867877,
            101872819,
            101866189,
            101865464,
            101863366,
            101870449,
            101865209,
            101894436,
            101867001,
            101859824
        ],
        "F": [
            101921592,
            101921489,
            101921368,
            101920713,
            113148352,
            197483789,
            101923610,
            101916398,
            101915019,
            107239743,
            103939202
        ]
    },
    "name": "C. Poman Numbers",
    "statement": "You\u2019ve got a string S consisting of n lowercase English letters from\r\nyour friend. It turned out that this is a number written in numerals.\r\nThe poman numeral system is long forgotten. All that\u2019s left is the\r\nalgorithm to transform number from poman numerals to the numeral system\r\nfamiliar to us. Characters of S are numbered from 1 to n from left to\r\nright. Let\u2019s denote the value of S as f(S), it is defined as follows: If\r\n|S| > 1, an arbitrary integer m (1\r\nle m < |S|) is chosen, and it is defined that f(S) = -f(S[1, m]) +\r\nf(S[m + 1, |S|]), where S[l, r] denotes the substring of S from the l-th\r\nto the r-th position, inclusively. Otherwise S = c, where c is some\r\nEnglish letter. Then f(S) = 2^{pos(c)}, where pos(c) is the position of\r\nletter c in the alphabet (pos() = 0, pos() = 25). Note that m is chosen\r\nindependently on each step.Your friend thinks it is possible to get f(S)\r\n= T by choosing the right m on every step. Is he right?\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nint n;\nint cnt[27];\n\nll T;\nll w[27];\n\nchar s[MAXN];\n\nint main()\n{\n\tscanf(\"%d%lld%s\",&n,&T,s + 1);\n\tw[0] = 1;\n\tfor (int i = 1;i <= 26;i++)\n\t\tw[i] = w[i - 1] * 2;\n\tT -= w[s[n] - 'a'];\n\tT += w[s[n - 1] - 'a'];\n\tfor (int i = 1;i <= n - 2;i++)\n\t\tT -= w[s[i] - 'a'];\n\tif (T > 0)\n\t{\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tT = -T;\n\tfor (int i = 1;i <= n - 2;i++)\n\t\tcnt[s[i] - 'a' + 1]++;\n\tfor (int i = 26;i >= 0;i--)\n\t\twhile (cnt[i] && T >= w[i])\n\t\t{\n\t\t\tT -= w[i];\n\t\t\tcnt[i]--;\n\t\t}\n\tputs(!T ? \"Yes\" : \"No\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Poman Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/85792",
    "editorial": "First, note that the last digit will always be taken with a plus sign, and the one before the last \u0097 with a minus sign. It turns out that all other digits may be taken with any sign. Let's prove it.\n\nSuppose we want to get the mask ???++??++???+\n. All minuses on the left can be obtained by simply splitting one character at a time. We are left with the ++??++???+\n mask, split it as follows: (++??++?)(??+)\n. That is, we left in the left part only one minus from the last segment of consecutive minuses. Change the signs in the left part: (??++??+)(??+)\n. We reduced it to a smaller problem. Doing this, we will end up with masks of the form +\n.\n\nNow the problem is reduced to whether we can get the number X\n using the first n?2\n letters. Since the weights of the items are powers of two, we can choose them greedily."
}