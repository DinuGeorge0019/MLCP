{
    "link": "https://codeforces.com//contest/2046/problem/E1",
    "problemId": "3064643",
    "problem_idx": "E1",
    "shortId": "2046E1",
    "contest_number": "2046",
    "problem_submissions": {
        "E2": [
            294584009,
            294914447,
            299392707
        ],
        "E1": [
            294583764,
            294575583,
            294575752,
            294582430,
            294565503,
            294626979,
            294869963,
            294674514,
            294674138,
            294611999,
            294672171,
            295181016,
            299301861,
            294579122,
            294609733
        ],
        "D": [
            294560152,
            294564191,
            294566638,
            294575690,
            294573167,
            294577461,
            294570961,
            294577018,
            294582440,
            294580055,
            294581279,
            294580878,
            294578858,
            294578559,
            294582493,
            294576385,
            294578827
        ],
        "C": [
            294540710,
            294545229,
            294545966,
            294548359,
            294558363,
            294545738,
            294550008,
            294552252,
            294555169,
            294551693,
            294558653,
            294550648,
            294551477,
            294560374,
            294559914,
            294555355,
            294557938,
            294552127,
            294543297,
            294557586
        ],
        "B": [
            294535038,
            294535101,
            294537375,
            294540562,
            294536849,
            294536519,
            294541688,
            294539018,
            294541654,
            294536164,
            294543153,
            294539414,
            294540802,
            294537409,
            294549010,
            294540274,
            294543427,
            294535624,
            294535094,
            294536775
        ],
        "A": [
            294532826,
            294532846,
            294539095,
            294533971,
            294533241,
            294533253,
            294534636,
            294533446,
            294534152,
            294532988,
            294537957,
            294533256,
            294533123,
            294534271,
            294537609,
            294533346,
            294537414,
            294532885,
            294532806,
            294533598
        ],
        "F2": [
            301103610,
            294606357
        ],
        "F1": [
            301085708,
            295825018,
            294574079
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136908",
    "editorial": "For convenience, we will call groups that include certain cities.\n\nThe key condition is that each specialization can correspond to no more than one task. Thus, cities from different groups must have \"practically sorted\" strength values as the group order increases.\n\nLet [li,ri]\n denote the segment that includes all the strengths of the cities in group i\n, where ri\n is the maximum strength of a city from this group, and li\n is the minimum. If li?ri+2\n, it is impossible to build a contest, as there must be at least a difference of 2 tasks between the cities corresponding to li\n and ri+2\n, but they can differ by at most 1 task in specialization. After this, the problem reduces to considering two neighboring groups and subsequently checking the task difficulties for compliance with the linear conditions of each group.\n\nLet's consider two cases:\n\nIf li?ri+1\n, it is sufficient to add a few tasks (specifically, just 2) of difficulty from the segment [ri+1+1,li]\n to maintain order.\n\nOtherwise, each city in the i\n-th group that lies in the intersection must solve a task with its specialization. In this case, no task can be in the segment [li+1,ri+1]\n, as the city with the highest strength in group i+1\n will solve at least as many tasks as the weakest city in group i\n, which we cannot allow. To maintain order with the other groups, it is sufficient to add 2 tasks of difficulty ri+1+1\n (unlike the first case, due to the fact that li?ri+2\n cannot occur, we can immediately determine the appropriate task difficulty, but they can be arranged using the same algorithm as for the first case).\n\nIt can be noted that when adding pairs of tasks, they need to choose an unused specification (since we are not using it in principle, but otherwise it may cause collisions).\n\nWe conclude that we need to arrange tasks with a specified specification that a city from the intersection of groups can solve, meaning its difficulty must not exceed the wisdom of that city, and also arrange 2 tasks of certain difficulties to maintain order between groups. These difficulties arise from possible intersections with other groups when using ri+1+1\n as the task difficulty and possible specification collisions of cities, which may allow a city from a weaker group to solve a task that we did not intend for it, thus violating the strictness conditions between groups.\n\nMost problems cannot arise when m=2\n, so what has been said above is already a solution (without minor adjustments) to the simple version of the problem.\n\nFirst, we will solve how to choose the difficulty for tasks with a specific specification. To do this, we will prohibit using the task specification corresponding to cities that form the second case (i.e., from the i+1\n-th group) with difficulty [li,bj]\n, where j is the number of such a city. Also, as mentioned, we cannot have a task from the segment [li+1,ri+1]\n regardless of the type. To determine the difficulty, it is sufficient to set it to the maximum possible (equal to wisdom) and then gradually decrease it until we reach an allowed difficulty.\n\nTo resolve the problem from the first case, we will place barriers with 2 tasks of difficulty equal to the strength of a certain city wherever possible.\n\nIf there exists an answer for the given configuration, we will guarantee to construct it this way, using no more than 3?n\n tasks. After all calculations, we need to check whether the contest we constructed meets the problem's conditions and output -1 otherwise.",
    "name": "E1. Cheops and a Contest  Easy Version ",
    "statement": "There is a problem-solving competition in Ancient Egypt with n\r\nparticipants, numbered from 1 to n. Each participant comes from a\r\ncertain city; the cities are numbered from 1 to m. There is at least one\r\nparticipant from each city.The i-th participant has strength a_i,\r\nspecialization s_i, and wisdom b_i, so that b_i\r\nge a_i. Each problem in the competition will have a difficulty d and a\r\nunique topic t. The i-th participant will solve the problem if a_i\r\nge d, i.e., their strength is not less than the problem\u2019s difficulty, or\r\ns_i = t, and b_i\r\nge d, i.e., their specialization matches the problem\u2019s topic, and their\r\nwisdom is not less than the problem\u2019s difficulty. Cheops wants to choose\r\nthe problems in such a way that each participant from city i will solve\r\nstrictly more problems than each participant from city j, for all i <\r\nj.Please find a set of at most 5n problems, where the , so that Cheops\u2019\r\nwill is satisfied, or state that it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;using u128 = unsigned __int128;\u00a0constexpr int inf = 1E9;\u00a0void solve() {    int n, m;    std::cin >> n >> m;        std::vector<int> a(n), b(n), s(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i] >> b[i] >> s[i];    }        auto ss = s;    auto vs = a;    vs.insert(vs.end(), b.begin(), b.end());    std::sort(ss.begin(), ss.end());    std::sort(vs.begin(), vs.end());        vs.erase(std::unique(vs.begin(), vs.end()), vs.end());    ss.erase(std::unique(ss.begin(), ss.end()), ss.end());        for (int i = 0; i < n; i++) {        a[i] = std::lower_bound(vs.begin(), vs.end(), a[i]) - vs.begin();        b[i] = std::lower_bound(vs.begin(), vs.end(), b[i]) - vs.begin();        s[i] = std::lower_bound(ss.begin(), ss.end(), s[i]) - ss.begin();    }        std::vector<std::vector<int>> q(m);    for (int i = 0; i < m; i++) {        int k;        std::cin >> k;        q[i].resize(k);        for (int j = 0; j < k; j++) {            std::cin >> q[i][j];            q[i][j]--;        }    }        const int nv = vs.size();    const int ns = ss.size();        int maxa = -1;        std::vector<int> L(ns, -inf), R(ns, inf);        std::vector<std::vector<std::array<int, 2>>> ban(ns + 1);    auto addSeg = [&](int s, int l, int r) {        ban[s].push_back({l, r});    };        for (int i = m - 1; i >= 0; i--) {        for (auto j : q[i]) {            if (maxa < a[j]) {                continue;            }            R[s[j]] = std::min(R[s[j]], b[j]);            L[s[j]] = std::max(L[s[j]], maxa + 1);            if (a[j] < maxa) {                addSeg(ns, a[j] + 1, maxa);            }        }        for (auto j : q[i]) {            maxa = std::max(maxa, a[j]);        }    }        std::vector<std::vector<int>> vec(ns);    for (int i = 0; i < n; i++) {        vec[s[i]].push_back(i);    }        for (int i = 0; i < ns; i++) {        if (L[i] > R[i]) {            std::cout << -1 << \"\\n\";            return;        }    }        int mina = inf;    for (int i = 0; i < m; i++) {        for (auto j : q[i]) {            if (mina > a[j]) {                continue;            }            if (b[j] > a[j]) {                addSeg(s[j], a[j] + 1, b[j]);            }        }        for (auto j : q[i]) {            mina = std::min(mina, a[j]);        }    }        std::vector<bool> can(nv);    {        std::vector<int> d(nv);        for (auto [l, r] : ban[ns]) {            d[l]++;            if (r + 1 < nv) {                d[r + 1]--;            }        }        for (int i = 1; i < nv; i++) {            d[i] += d[i - 1];        }        for (int i = 0; i < nv; i++) {            can[i] = (d[i] == 0);        }    }        std::vector<int> left(nv, -1);    for (int i = 0; i < nv; i++) {        if (i > 0) {            left[i] = left[i - 1];        }        if (can[i]) {            left[i] = i;        }    }        std::vector<std::array<int, 2>> ans;    for (int i = 0; i < ns; i++) {        if (L[i] < 0) {            continue;        }        int lst = -1;        std::vector<std::array<int, 2>> e;        for (auto [l, r] : ban[i]) {            e.push_back({l - 1, -1});            e.push_back({r, 1});        }        std::sort(e.begin(), e.end());        int sum = 0;        int val = -1;        for (auto [x, t] : e) {            if (sum == 0 && x >= 0) {                int u = left[std::min(x, R[i])];                if (u > lst && u >= L[i]) {                    val = u;                }            }            sum += t;            lst = x;        }        if (int u = left[R[i]]; u > lst && u >= L[i]) {            val = u;        }        if (val == -1) {            std::cout << -1 << \"\\n\";            return;        }        ans.push_back({vs[val], ss[i]});    }        std::vector<int> score(n);    std::sort(ans.begin(), ans.end());    std::map<int, int> diff;    for (auto [d, p] : ans) {        diff[p] = d;    }    for (int i = 0; i < n; i++) {        score[i] += std::lower_bound(ans.begin(), ans.end(), std::array {vs[a[i]] + 1, 0}) - ans.begin();        if (diff.contains(ss[s[i]])) {            int x = diff[ss[s[i]]];            if (vs[a[i]] < x && x <= vs[b[i]]) {                score[i]++;            }        }    }        int cur = 0;    std::vector<std::set<int>> set(n + 1);    for (int i = m - 1; i >= 0; i--) {        for (auto j : q[i]) {            int val = -1;            for (int k = score[j]; k <= score[j] + 1 && k <= n; k++) {                auto it = set[k].lower_bound(a[j]);                if (it != set[k].begin()) {                    val = std::max(val, *std::prev(it));                }            }            if (val != -1) {                int u = left[a[j]];                if (u <= val) {                    std::cout << -1 << \"\\n\";                    return;                }                for (int t = 0; t < 2; t++) {                    while (std::binary_search(ss.begin(), ss.end(), cur)) {                        cur++;                    }                    ans.push_back({vs[u], cur});                    cur++;                }            }        }        for (auto j : q[i]) {            set[score[j]].insert(a[j]);        }    }        std::cout << ans.size() << \"\\n\";    for (auto [d, p] : ans) {        std::cout << d << \" \" << p << \"\\n\";    }        // {    //     std::vector<int> score(n);    //     for (int i = 0; i < n; i++) {    //         for (auto [d, p] : ans) {    //             if (vs[a[i]] >= d || (ss[s[i]] == p && vs[b[i]] >= d)) {    //                 score[i]++;    //             }    //         }    //     }    //     for (int i = 0; i < m; i++) {    //         for (int j = i + 1; j < m; j++) {    //             for (auto x : q[i]) {    //                 for (auto y : q[j]) {    //                     assert(score[x] > score[y]);    //                 }    //             }    //         }    //     }    //     assert(!ans.empty());    //     for (int i = 0; i < ans.size(); i++) {    //         for (int j = 0; j < i; j++) {    //             assert(ans[i][1] != ans[j][1]);    //         }    //     }    // }}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E1. Cheops and a Contest  Easy Version .json"
}