{
    "link": "https://codeforces.com//contest/1479/problem/B2",
    "problemId": "889627",
    "problem_idx": "B2",
    "shortId": "1479B2",
    "contest_number": "1479",
    "problem_submissions": {
        "D": [
            106806356,
            106798804,
            106791682,
            106791766,
            106783633,
            106814882,
            106806404,
            106823371,
            106808799,
            106822218,
            106817839,
            106848882,
            106812415,
            106835076,
            106827553,
            106802594,
            106816382,
            106815777,
            106820515,
            106838550,
            106850875,
            106833526
        ],
        "C": [
            106782305,
            106781616,
            106813281,
            106777792,
            106806652,
            106785851,
            106790598,
            106804329,
            106788311,
            106797179,
            106801693,
            106797158,
            106799023,
            106802871,
            106833768,
            106794280,
            106835769,
            106791359,
            106812286,
            106805528
        ],
        "B2": [
            106767251,
            106763833,
            106764524,
            106766365,
            106766872,
            106772583,
            106777899,
            106776623,
            106772714,
            106777329,
            106781346,
            106839134,
            106782598,
            106789550,
            106774779,
            106781374,
            106779953,
            106776541,
            106784819,
            106807842
        ],
        "B1": [
            106761871,
            106761547,
            106772762,
            106765327,
            106765110,
            106769139,
            106770176,
            106777978,
            106783437,
            106765790,
            106777195,
            106759777,
            106771397,
            106771604,
            106765950,
            106772183,
            106778477,
            106775679,
            106771753,
            106783453
        ],
        "A": [
            106755900,
            106753726,
            106756482,
            106751012,
            106869291,
            106756412,
            106753230,
            106749820,
            106752580,
            106752067,
            106756325,
            106758074,
            106749882,
            106753072,
            106759686,
            106753472,
            106830245,
            106764145,
            106862156,
            106753714,
            106755663
        ],
        "E": [
            106862710,
            106861209,
            106848127,
            128939200,
            106847859,
            106846880,
            112187125
        ]
    },
    "name": "B2. Painting the Array II",
    "statement": "Homer likes arrays a lot. Today he is painting an array a_1, a_2,\r\ndots, a_n with two kinds of colors, and . A painting assignment for a_1,\r\na_2,\r\ndots, a_n is described by an array b_1, b_2,\r\ndots, b_n that b_i indicates the color of a_i (0 for white and 1 for\r\nblack).According to a painting assignment b_1, b_2,\r\ndots, b_n, the array a is split into two new arrays a^{(0)} and a^{(1)},\r\nwhere a^{(0)} is the sub-sequence of all white elements in a and a^{(1)}\r\nis the sub-sequence of all black elements in a. For example, if a =\r\n[1,2,3,4,5,6] and b = [0,1,0,1,0,0], then a^{(0)} = [1,3,5,6] and\r\na^{(1)} = [2,4].The number of segments in an array c_1, c_2,\r\ndots, c_k, denoted\r\nmathit{seg}(c), is the number of elements if we merge all adjacent\r\nelements with the same value in c. For example, the number of segments\r\nin [1,1,2,2,3,3,3,2] is 4, because the array will become [1,2,3,2] after\r\nmerging adjacent elements with the same value. Especially, the number of\r\nsegments in an empty array is 0.Homer wants to find a painting\r\nassignment b, according to which the number of segments in both a^{(0)}\r\nand a^{(1)}, i.e.\r\nmathit{seg}(a^{(0)})+\r\nmathit{seg}(a^{(1)}), is as as possible. Find this number.\r\n",
    "solutions": [
        "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n// Actual solution is at the bottom\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef int64_t int64;\ntypedef pair<int, int> ii;\n\nclass B2PaintingTheArrayII {\n public:\n  void solveOne() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& x : a) {\n      cin >> x;\n      --x;\n    }\n    vector<vector<int>> occs(n);\n    for (int i = 0; i < n; ++i) {\n      occs[a[i]].push_back(i);\n    }\n    for (int i = 0; i < n; ++i) occs[i].push_back(n);\n    int x = -1;\n    int y = -1;\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n      int z = a[i];\n      if (z == x || z == y) {\n      } else {\n        int px = x < 0 ? n : *lower_bound(all(occs[x]), i);\n        int py = y < 0 ? n : *lower_bound(all(occs[y]), i);\n        if (px > py) {\n          x = z;\n        } else {\n          y = z;\n        }\n        ++res;\n      }\n    }\n    cout << res << \"\\n\";\n  }\n\n  void solve() {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne();\n    }\n  }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    B2PaintingTheArrayII solver;\n\n\n    solver.solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B2. Painting the Array II.json",
    "editorial_link": "https://codeforces.com//blog/entry/87598",
    "editorial": "There are two approaches from different perspectives. The first\r\nobservation is that merging adjacent elements with the same value will\r\nnot influence the answer. Therefore, without loss of generality, we may\r\nassume that there are no adjacent elements with the same value, i.e. for\r\nevery .We can solve this problem by a DP approach. Let denote the\r\nminimal possible number of segments for sub-array over all assignments\r\nwith , where for convenience. To obtain the answer, we enumerate the\r\nlast position such that , and append all elements to the end of , which\r\nimplies an arrangement with segments. The minimal number of segments\r\nwill be the minimum among over all .It is straightforward to see that\r\nand .For , can be computed by enumerating every possible position such\r\nthat . That is, are assigned to the same sub-sequence, and and are\r\nassigned to the other sub-sequence. Since no adjacent elements has the\r\nsame value (by our assumption), there are segments in (we note that the\r\nfirst segment, i.e. the segment of , is counted in ). Moreover, there\r\nwill be zero or one new segment when concatenating and depending on\r\nwhether or not. Hence, for every , we have where if the Boolean\r\nexpression is true and otherwise. Here, we obtain an DP solution.To\r\noptimize the DP recurrence, we fix , and let , then . We can observe\r\nthat. For , we have where , , and .This lemma is very intuitive, which\r\nmeans we need only to consider two cases: one is to just append after in\r\nthe same sub-sequence, and the other is to append after the closest with\r\nthe same value, i.e. , and then assign the elements between them (not\r\ninclusive) to the other sub-sequence. With this observation, we\r\nimmediately obtain an DP solution.The proof is appended below for\r\ncompleteness. For every , we have which implies that for every . Now we\r\nconsider for every in two cases. . We have . Suppose there are two\r\ndifferent positions and such that and , then Combine the two cases, we\r\nconclude that , where . Consider we have a computer whose cache has only\r\ntwo registers. Letâs suppose the array is a sequence of memory access to\r\nthe computer. The problem is then converted to a more intuitive one that\r\nasks the optimal cache replacement. Suppose the current two registers\r\ncontains two memory accesses and , and the current requirement memory\r\naccess is . The greedy strategy is simple: If matches one of and , just\r\ndo nothing. Otherwise, the register that contains the memory access\r\nwhose next occurrence is farther than the other will be replaced by\r\n.This strategy is know as B l dyâs algorithm or farthest-in-the-future\r\ncache/page replacement policy (see here for more information). The\r\ncomplexity is since we only need to preprocess every elementâs next\r\noccurrence.\r\n",
    "hint": []
}