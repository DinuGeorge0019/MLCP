{
    "link": "https://codeforces.com//contest/91/problem/D",
    "problemId": "480",
    "problem_idx": "D",
    "shortId": "91D",
    "contest_number": "91",
    "problem_submissions": {
        "E": [
            503728,
            502526,
            502324,
            502390,
            507083,
            507754,
            507742,
            507704,
            503634,
            502642,
            504726,
            503639,
            504548,
            503486,
            503083
        ],
        "D": [
            502276,
            503817,
            503388,
            504083,
            503790,
            503692,
            503693,
            502719,
            503528
        ],
        "C": [
            500481,
            501267,
            503127,
            500359,
            500890,
            501727,
            501793,
            501879,
            501823,
            691241,
            500724
        ],
        "B": [
            500029,
            500306,
            499798,
            499713,
            500770,
            500316,
            500169,
            500955,
            501299,
            500855,
            500308,
            500853,
            500345,
            500259,
            501038,
            510135,
            501272,
            500210
        ],
        "A": [
            499372,
            499587,
            499153,
            501187,
            499642,
            499614,
            500028,
            500088,
            499525,
            499582,
            499555,
            499393,
            499483,
            499408,
            510127,
            499780,
            499366
        ]
    },
    "name": "D. Grocer s Problem",
    "statement": "Yesterday was a fair in a supermarket\u2019s grocery section. There were jars\r\nwith spices on the fair. Before the event the jars were numbered from to\r\nfrom the left to the right. After the event the jars were moved and the\r\ngrocer had to sort them by the increasing of the numbers.The grocer has\r\na special machine at his disposal. The machine can take any or less jars\r\nand rearrange them in the way the grocer wants. Note that the jars stand\r\nconsecutively. For example, from the permutation , , , , , one can get\r\npermutation , , , , , , if pick the jars on the positions , , , and .\r\nWhich minimum number of such operations is needed to arrange all the\r\njars in the order of their numbers\u2019 increasing?\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nvector < pair < vector <int>, vector <int> > > ans, threes, twos;\nint n;\nvector <int> a;\nchar buf[100];\n\npair < vector <int>, vector <int> > merge (pair < vector <int>, vector <int> > a, pair < vector <int>, vector <int> > b) {\n\ta.fs.insert (a.fs.end(), b.fs.begin(), b.fs.end());\n\ta.sc.insert (a.sc.end(), b.sc.begin(), b.sc.end());\n\treturn a;\n}\n\nvoid split (pair < vector <int>, vector <int> > a) {\n\tpair < vector <int>, vector <int> > a1, a2;\n\ta1.fs.pb (a.fs[0]);\n\ta1.fs.pb (a.fs[1]);\n\ta1.sc.pb (a.fs[1]);\n\ta1.sc.pb (a.fs[0]);\n\n\ta2.fs.pb (a.fs[0]);\n\ta2.fs.pb (a.fs[2]);\n\ta2.sc.pb (a.fs[2]);\n\ta2.sc.pb (a.fs[0]);\n\n\ttwos.pb (a2);\n\ttwos.pb (a1);\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tscanf (\"%d\", &n);\n\ta.resize (n);\n\tforn (i, n)\n\t\tscanf (\"%d\", &a[i]);\n\tforn (i, n)\n\t\ta[i] --;\n\tans.clear ();\n\tthrees.clear ();\n\ttwos.clear ();\n\tforn (i, n)\n\t\twhile (a[i] != i) {\n\t\t\tint v = i;\n\t\t\tvector <int> tmp;\n\t\t\ttmp.pb (v);\n\t\t\twhile (I tmp.size() < 5 && a[v] != i) {\n\t\t\t\tv = a[v];\n\t\t\t\ttmp.pb (v);\n\t\t\t}\n\t\t\tvector <int> tmpans;\n\t\t\tforn (i, tmp.size()) \n\t\t\t\ttmpans.pb (tmp[(i+1)%tmp.size()]);\n\t\t\tif (tmp.size() == 2)\n\t\t\t\ttwos.pb (mp (tmp, tmpans));\n\t\t\telse\n\t\t\tif (tmp.size() == 3)\n\t\t\t\tthrees.pb (mp (tmp, tmpans));\n\t\t\telse\n\t\t\t\tans.pb (mp (tmp, tmpans));\n\t\t\tford (i, tmp.size())\n\t\t\t\tif (i)\n\t\t\t\t\tswap (a[tmp[(i+1)%tmp.size()]], a[tmp[i]]);\n\t\t}\n\twhile (threes.size() > 0) {\n\t\tif (twos.size() > 0) {\n\t\t\tans.pb (merge (twos.back(), threes.back()));\n\t\t\ttwos.pop_back();\n\t\t\tthrees.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tif (threes.size() == 1) {\n\t\t\tans.pb (threes.back());\n\t\t\tthrees.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tsplit (threes.back());\n\t\tthrees.pop_back();\n\t}\n\n\twhile (twos.size() > 0) {\n\t\tif (twos.size() == 1) {\n\t\t\tans.pb (twos.back());\n\t\t\ttwos.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tpair < vector <int>, vector <int> > tmp = twos.back();\n\t\ttwos.pop_back();\n\t\tans.pb (merge (tmp, twos.back()));\n\t\ttwos.pop_back();\n\t}\n\tprintf (\"%d\\n\", ans.size());\n\tforn (i, ans.size()) {\n\t\tprintf (\"%d\\n\", ans[i].fs.size());\n\t\tforn (j, ans[i].fs.size())\n\t\t\tprintf (\"%d \", ans[i].fs[j]+1);\n\t\tprintf (\"\\n\");\n\t\tforn (j, ans[i].fs.size())\n\t\t\tprintf (\"%d \", ans[i].sc[j]+1);\n\t\tprintf (\"\\n\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Grocer s Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/2182",
    "editorial": "Let's find all cycles in substitution:\n1 2 3 4 5 ...\na1 a2 a3 a4 a5 ...\nFor example, in sequence a?=?{2,?1,?4,?5,?3} exist two cycles with length 2 and 3 on positions 1 2 and 3 4 5 respectively. If the length of the cycle is more than 5, then we can take 5 consecutive elements and make a new order in such way that 4 elements will take their places where they should be in sorted array. In common: if we take p elements in a cycle of length more than p, the we can make a new order in such way that p?-?1 elements  will take their places where they should be in sorted array. If the cycle length is p we can sort all the elements taking p elements from it. Next in the analysis I will define length of a cycle as a real length of a cycle - 1 (now I can say that if we take p consecutive elements then p?-?1 will take the right places).\nWe also can take some elements in one and some elements in other cycles. We can make up division numbers from 2 to 5 into a sum to see how we can use them: 5, 4, 3, 2, 2?+?3, 2?+?2. We can take, for example, three elements in one cycle and two in other, their sizes were reduced by 2 and 1.\nThe task now is to get all cycle lengths equal to zero. Let's to suppose that an optimal solution have four operations which decrease the same cycle length by one. We will work with operations of 5 elements and which are not process the same cycle except one, because it's more stronger condition.\nSuch operation can be shown as a table where rows are operations, columns are cycles and cells of table are the values on which cycles will be reduced.\na    b   c    d    e\n1    2\n1        2\n1              2\n1                   2 \nReplace operations this way:\na    b    c    d    e\n4\n      2   1\n           1    2\n                       2\nThe number of operations was not increased, but now we can see that if there is an optimal solution where one cycle reduced by one four times then there is an optimal solution where no cycles reduced by one four times. Look at some other replacements:\na    b    c\n2    1\n2          1\nReplace by:\na    b    c\n4\n      1    1\n\nand\n\na    b    c    d\n2    1\n1         2\n1               2\nReplace by:\na    b    c    d\n4\n      1   2\n                 2\nNow we can see that there is an optimal solution where no operation reducing one cycle in ways:1?+?1?+?1?+?1, 2?+?2, 1?+?1?+?2. That's why we can reduce any cycle by 4 while it's size is ?>??=?4. Let's use zhe same method to prove that cycles of size 3 reduced by 3 in some optimal solution.\n\na    b    c  \n2    1\n1          2\nReplace by:\na    b    c    d\n3\n      1    2\n\nand\n\n\na    b    c    d\n1    2\n1         2\n1               2\nReplace by:\na    b    c    d\n3\n      2   1\n           1    2\n\nNow we have cycles only with size 1 or 2. Let's brute the number of operations to process like {2,?2}?-??>?{0,?1} (one cycle will be reduced from 2 to 1 and the other will be reduced from 2 to 0). Fix some such number and make these operations. Now we should process the maximum available operations like {2,?1}?-??>?{0,?0}. After it we will have no cycles or some cycles of size 1 or  some cycles of size 2. In the second case  we should do the maximum of available operations like {1,?1}?-??>?{0,?0} and if one cycle lasts we should do {1}?-??>?{0}. In the third case we should to do operations like {2}?-??>?{0}. Using such way we can find the optimal set of operations. We shouldn't divide cycle into a parts because it makes the number of operation bigger or the same. Stress test shows the uniting cycles will not improve the answer.  "
}