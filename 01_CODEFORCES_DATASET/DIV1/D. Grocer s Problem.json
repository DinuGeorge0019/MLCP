{"link": "https://codeforces.com//contest/91/problem/D", "problemId": "480", "problem_idx": "D", "shortId": "91D", "contest_number": "91", "problem_submissions": {"E": [503728, 502526, 502324, 502390, 507083, 507754, 507742, 507704, 503634, 502642, 504726, 503639, 504548, 503486, 503083], "D": [502276, 503817, 503388, 504083, 503790, 503692, 503693, 502719, 503528], "C": [500481, 501267, 503127, 500359, 500890, 501727, 501793, 501879, 501823, 691241, 500724], "B": [500029, 500306, 499798, 499713, 500770, 500316, 500169, 500955, 501299, 500855, 500308, 500853, 500345, 500259, 501038, 510135, 501272, 500210], "A": [499372, 499587, 499153, 501187, 499642, 499614, 500028, 500088, 499525, 499582, 499555, 499393, 499483, 499408, 510127, 499780, 499366]}, "name": "D. Grocer s Problem", "statement": "Yesterday was a fair in a supermarket\u2019s grocery section. There were jars\r\nwith spices on the fair. Before the event the jars were numbered from to\r\nfrom the left to the right. After the event the jars were moved and the\r\ngrocer had to sort them by the increasing of the numbers.The grocer has\r\na special machine at his disposal. The machine can take any or less jars\r\nand rearrange them in the way the grocer wants. Note that the jars stand\r\nconsecutively. For example, from the permutation , , , , , one can get\r\npermutation , , , , , , if pick the jars on the positions , , , and .\r\nWhich minimum number of such operations is needed to arrange all the\r\njars in the order of their numbers\u2019 increasing?\r\n", "solutions": ["#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nvector < pair < vector <int>, vector <int> > > ans, threes, twos;\nint n;\nvector <int> a;\nchar buf[100];\n\npair < vector <int>, vector <int> > merge (pair < vector <int>, vector <int> > a, pair < vector <int>, vector <int> > b) {\n\ta.fs.insert (a.fs.end(), b.fs.begin(), b.fs.end());\n\ta.sc.insert (a.sc.end(), b.sc.begin(), b.sc.end());\n\treturn a;\n}\n\nvoid split (pair < vector <int>, vector <int> > a) {\n\tpair < vector <int>, vector <int> > a1, a2;\n\ta1.fs.pb (a.fs[0]);\n\ta1.fs.pb (a.fs[1]);\n\ta1.sc.pb (a.fs[1]);\n\ta1.sc.pb (a.fs[0]);\n\n\ta2.fs.pb (a.fs[0]);\n\ta2.fs.pb (a.fs[2]);\n\ta2.sc.pb (a.fs[2]);\n\ta2.sc.pb (a.fs[0]);\n\n\ttwos.pb (a2);\n\ttwos.pb (a1);\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tscanf (\"%d\", &n);\n\ta.resize (n);\n\tforn (i, n)\n\t\tscanf (\"%d\", &a[i]);\n\tforn (i, n)\n\t\ta[i] --;\n\tans.clear ();\n\tthrees.clear ();\n\ttwos.clear ();\n\tforn (i, n)\n\t\twhile (a[i] != i) {\n\t\t\tint v = i;\n\t\t\tvector <int> tmp;\n\t\t\ttmp.pb (v);\n\t\t\twhile (I tmp.size() < 5 && a[v] != i) {\n\t\t\t\tv = a[v];\n\t\t\t\ttmp.pb (v);\n\t\t\t}\n\t\t\tvector <int> tmpans;\n\t\t\tforn (i, tmp.size()) \n\t\t\t\ttmpans.pb (tmp[(i+1)%tmp.size()]);\n\t\t\tif (tmp.size() == 2)\n\t\t\t\ttwos.pb (mp (tmp, tmpans));\n\t\t\telse\n\t\t\tif (tmp.size() == 3)\n\t\t\t\tthrees.pb (mp (tmp, tmpans));\n\t\t\telse\n\t\t\t\tans.pb (mp (tmp, tmpans));\n\t\t\tford (i, tmp.size())\n\t\t\t\tif (i)\n\t\t\t\t\tswap (a[tmp[(i+1)%tmp.size()]], a[tmp[i]]);\n\t\t}\n\twhile (threes.size() > 0) {\n\t\tif (twos.size() > 0) {\n\t\t\tans.pb (merge (twos.back(), threes.back()));\n\t\t\ttwos.pop_back();\n\t\t\tthrees.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tif (threes.size() == 1) {\n\t\t\tans.pb (threes.back());\n\t\t\tthrees.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tsplit (threes.back());\n\t\tthrees.pop_back();\n\t}\n\n\twhile (twos.size() > 0) {\n\t\tif (twos.size() == 1) {\n\t\t\tans.pb (twos.back());\n\t\t\ttwos.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tpair < vector <int>, vector <int> > tmp = twos.back();\n\t\ttwos.pop_back();\n\t\tans.pb (merge (tmp, twos.back()));\n\t\ttwos.pop_back();\n\t}\n\tprintf (\"%d\\n\", ans.size());\n\tforn (i, ans.size()) {\n\t\tprintf (\"%d\\n\", ans[i].fs.size());\n\t\tforn (j, ans[i].fs.size())\n\t\t\tprintf (\"%d \", ans[i].fs[j]+1);\n\t\tprintf (\"\\n\");\n\t\tforn (j, ans[i].fs.size())\n\t\t\tprintf (\"%d \", ans[i].sc[j]+1);\n\t\tprintf (\"\\n\");\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "greedy"], "dificulty": "2600", "interactive": false}