{
    "link": "https://codeforces.com//contest/343/problem/E",
    "problemId": "3471",
    "problem_idx": "E",
    "shortId": "343E",
    "contest_number": "343",
    "problem_submissions": {
        "E": [
            31188435,
            31188116,
            31188087,
            31187398,
            31187368,
            31187305,
            31187274,
            31186747,
            31186631,
            31186607,
            31177883,
            31177811,
            31177677,
            31177529,
            31177512,
            31177472,
            31174332,
            31174236,
            31174170,
            31174117,
            31174081,
            31173996,
            31173900,
            31173784,
            31168439,
            31168047,
            31166077,
            31166040,
            31165937,
            31165886,
            31165811,
            31165582,
            4470358,
            4472396,
            4467502,
            4481337,
            4469008,
            4469285,
            4479327,
            4479319
        ],
        "D": [
            4464141,
            4463979,
            4464572,
            4466164,
            4464136,
            4464708,
            4465038,
            4464000,
            4465958,
            4466077,
            4464624,
            4465035,
            4466293,
            4465384,
            4466009,
            4465578,
            4464050,
            4465103
        ],
        "C": [
            4460935,
            4462263,
            4462661,
            4463142,
            4461571,
            4460298,
            4462624,
            4461379,
            4461808,
            4462541,
            4462074,
            4461269,
            4462489,
            4463445,
            4463917,
            4463308,
            4465676,
            4463306
        ],
        "B": [
            4459735,
            4460433,
            4460596,
            4461468,
            4460532,
            4461066,
            4460953,
            4459496,
            4459676,
            4461679,
            4460850,
            4460112,
            4461095,
            4461548,
            4461352,
            4461258,
            4460882,
            4461288
        ],
        "A": [
            4458959,
            4458766,
            4460268,
            4460108,
            4459407,
            4461767,
            4460061,
            4464549,
            4459033,
            4459762,
            4460186,
            4459277,
            4459980,
            4460247,
            4461189,
            4460304,
            4459784,
            4460498
        ]
    },
    "name": "E. Pumping Stations",
    "statement": "Mad scientist Mike has applied for a job. His task is to manage a system\r\nof water pumping stations.The system consists of pumping stations, which\r\nare numbered by integers from 1 to . Some pairs of stations are\r\nconnected by bidirectional pipes through which water can flow in either\r\ndirection (but only in one at a time). For each pipe you know its\r\nbandwidth the maximum number of liters of water that can flow through it\r\nin one hour. Each pumping station can pump incoming water from some\r\nstations to other stations through the pipes, provided that in one hour\r\nthe total influx of water to the station is equal to the total outflux\r\nof water from the station.It is Mikeâ€™s responsibility to pump water\r\nbetween stations. From station to station through the pipes (possibly\r\nthrough other stations) within one hour one can transmit a certain\r\nnumber of liters of water according to the rules described above. During\r\nthis time, water from other stations can not flow into station , and can\r\nnot flow out of the station . However, any amount of water can flow out\r\nof station or in station . If a total of litres of water flows out of\r\nthe station in an hour, then Mike gets bollars more to his salary.To get\r\npaid, Mike needs to work for days, according to the contract. On the\r\nfirst day he selects two stations and , and within one hour he pumps a\r\ncertain amount of water from to . Next, on the -th day Mike chooses a\r\nstation that has been never selected before, and pumps a certain amount\r\nof water out of the station to station for one hour. The quantity of\r\nwater he pumps on the -th day on the amount of water pumped on the -th\r\nday.Mike needs to earn as much bollars as he can for his projects. Help\r\nMike find such a permutation of station numbers , , , so Mike will be\r\nable to earn the highest possible salary.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 09.10.2017 16:22:05       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n  public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector <edge> edges;\n  vector < vector <int> > g;\n  int n;\n\n  graph(int n) : n(n) {\n    g.resize(n);\n  }\n\n  virtual void add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass undigraph : public graph<T> {\n  public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  undigraph(int n) : graph<T>(n) {\n  }\n\n  void add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    g[from].push_back(edges.size());\n    g[to].push_back(edges.size());\n    edges.push_back({from, to, cost});\n  }\n};\n\ntemplate <typename T>\nclass forest : public graph<T> {\n  public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  forest(int n) : graph<T>(n) {\n  }\n\n  void add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    g[from].push_back(edges.size());\n    g[to].push_back(edges.size());\n    edges.push_back({from, to, cost});\n  }\n};\n\ntemplate <typename T>\nclass flow_graph {\n  public:\n  static constexpr T eps = (T) 1e-9;\n\n  struct edge {\n    int to;\n    T c;\n    T f;\n    int rev;\n  };\n\n  vector< vector<edge> > g;\n  vector<int> ptr;\n  vector<int> d;\n  vector<int> q;\n  vector<int> cnt_on_layer;\n  vector<int> prev_edge;\n  vector<T> to_push;\n  vector<T> pushed;\n  vector<int> smallest;\n  bool can_reach_sink;\n\n  int n;\n  int st, fin;\n  T flow;\n   \n  flow_graph(int n, int st, int fin) : n(n), st(st), fin(fin) {\n    assert(0 <= st && st < n && 0 <= fin && fin < n && st != fin);\n    g.resize(n);\n    ptr.resize(n);\n    d.resize(n);\n    q.resize(n);\n    cnt_on_layer.resize(n + 1);\n    prev_edge.resize(n);\n    to_push.resize(n);\n    pushed.resize(n);\n    smallest.resize(n);\n    flow = 0;\n  }\n\n  void clear_flow() {\n    for (int i = 0; i < n; i++) {\n      for (edge &e : g[i]) {\n        e.f = 0;\n      }\n    }\n    flow = 0;\n  }\n   \n  void add(int from, int to, T forward_cap, T backward_cap) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int from_size = g[from].size();\n    int to_size = g[to].size();\n    g[from].push_back({to, forward_cap, 0, to_size});\n    g[to].push_back({from, backward_cap, 0, from_size});\n  }\n\n  bool expath() {\n    fill(d.begin(), d.end(), n);\n    q[0] = fin;\n    d[fin] = 0;\n    fill(cnt_on_layer.begin(), cnt_on_layer.end(), 0);\n    cnt_on_layer[n] = n - 1;\n    cnt_on_layer[0] = 1;\n    int beg = 0, end = 1;\n    while (beg < end) {\n      int i = q[beg++];\n      for (const edge &e : g[i]) {\n        const edge &back = g[e.to][e.rev];\n        if (back.c - back.f > eps && d[e.to] == n) {\n          cnt_on_layer[d[e.to]]--;\n          d[e.to] = d[i] + 1;\n          cnt_on_layer[d[e.to]]++;\n          q[end++] = e.to;\n        }\n      }\n    }\n    return (d[st] != n);\n  }\n\n  void rollback(int &v) {\n    edge &e = g[v][prev_edge[v]];\n    if (pushed[v]) {\n      edge &back = g[e.to][e.rev];\n      back.f += pushed[v];\n      e.f -= pushed[v];\n      pushed[e.to] += pushed[v];\n      to_push[e.to] -= pushed[v];\n      pushed[v] = 0;\n    }\n    v = e.to;\n  }\n\n  void augment(int &v) {\n    pushed[v] += to_push[v];\n    to_push[v] = 0;\n    int new_v = smallest[v];\n    while (v != new_v) {\n      rollback(v);\n    }\n  }\n\n  void retreat(int &v) {\n    int new_dist = n - 1;\n    for (const edge &e : g[v]) {\n      if (e.c - e.f > eps && d[e.to] < new_dist) {\n        new_dist = d[e.to];\n      }\n    }\n    cnt_on_layer[d[v]]--;\n    if (cnt_on_layer[d[v]] == 0) {\n      if (new_dist + 1 > d[v]) {\n        can_reach_sink = false;\n      }\n    }\n    d[v] = new_dist + 1;\n    cnt_on_layer[d[v]]++;\n    if (v != st) {\n      rollback(v);\n    }\n  }\n   \n  T max_flow() {\n    can_reach_sink = true;\n    for (int i = 0; i < n; i++) {\n      ptr[i] = (int) g[i].size() - 1;\n    }\n    if (expath()) {\n      int v = st;\n      to_push[v] = numeric_limits<T>::max();\n      smallest[v] = v;\n      while (d[st] < n) {\n        while (ptr[v] >= 0) {\n          const edge &e = g[v][ptr[v]];\n          if (e.c - e.f > eps && d[e.to] == d[v] - 1) {\n            prev_edge[e.to] = e.rev;\n            to_push[e.to] = to_push[v];\n            smallest[e.to] = smallest[v];\n            if (e.c - e.f < to_push[e.to]) {\n              to_push[e.to] = e.c - e.f;\n              smallest[e.to] = v;\n            }\n            v = e.to;\n            if (v == fin) {\n              augment(v);\n            }\n            break;\n          }\n          ptr[v]--;\n        }\n        if (ptr[v] < 0) {\n          ptr[v] = (int) g[v].size() - 1;\n          retreat(v);\n          if (!can_reach_sink) {\n            break;\n          }\n        }\n      }\n      while (v != st) {\n        rollback(v);\n      }\n      flow += pushed[st];\n      pushed[st] = 0;\n    }\n    return flow;\n  }\n\n  vector<bool> min_cut() {\n    max_flow();\n    assert(!expath());\n    vector<bool> ret(n);\n    for (int i = 0; i < n; i++) {\n      ret[i] = (d[i] != n);\n    }\n    return ret;\n  }\n};\n\ntemplate <typename T>\nforest<T> gomory_hu(const undigraph<T> &g) {\n  int n = g.n;\n  flow_graph<T> fg(n, 0, 1);\n  for (auto &e : g.edges) {\n    fg.add(e.from, e.to, e.cost, e.cost);\n  }\n  forest<T> ret(n);\n  vector<int> pr(n, 0);\n  for (int i = 1; i < n; i++) {\n    fg.clear_flow();\n    fg.st = i;\n    fg.fin = pr[i];\n    T flow = fg.max_flow();\n    vector<bool> cut = fg.min_cut();\n    for (int j = i + 1; j < n; j++) {\n      if (cut[j] == cut[i] && pr[j] == pr[i]) {\n        pr[j] = i;\n      }\n    }\n    ret.add(i, pr[i], flow);\n  }\n  return ret;\n  // can be optimized by compressing components\n}\n\nclass dsu {\n  public:\n  vector<int> p;\n  int n;\n  vector< vector<int> > seq;\n\n  dsu(int n) : n(n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n    seq.resize(n);\n    for (int i = 0; i < n; i++) {\n      seq[i].push_back(i);\n    }\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      seq[y].insert(seq[y].end(), seq[x].begin(), seq[x].end());\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  undigraph<int> g(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, z;\n    scanf(\"%d %d %d\", &x, &y, &z);\n    x--; y--;\n    g.add(x, y, z);\n  }\n  forest<int> t = gomory_hu(g);\n  int sum = 0;\n  for (auto &e : t.edges) {\n    sum += e.cost;\n  }\n  vector< pair<int, int> > edges;\n  for (int i = 0; i < n - 1; i++) {\n    edges.emplace_back(t.edges[i].cost, i);\n  }\n  sort(edges.rbegin(), edges.rend());\n  dsu d(n);\n  for (int id = 0; id < n - 1; id++) {\n    int i = edges[id].second;\n    auto &e = t.edges[i];\n    d.unite(e.from, e.to);\n  }\n  vector<int> res = d.seq[d.get(0)];\n  printf(\"%d\\n\", sum);\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      putchar(' ');\n    }\n    printf(\"%d\", res[i] + 1);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "divide and conquer",
        "flows",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Pumping Stations.json",
    "editorial_link": "https://codeforces.com//blog/entry/8860",
    "editorial": "In this problem we are asked to find such graph vertex permutation that\r\nmaximizes the sum of the maximum flows sent between each two consequtive\r\nvertices in the permutation. The problem can be solved with Gomory-Hu\r\ntree data structure. For a given weighted graph the tree has the\r\nfollowing properties: Surprisingly, such a tree exists for any weighted\r\ngraph, and can be built in . It appears that the answer to the problem\r\nis equal to the sum of the edge weights in this tree. We prove this\r\nstatement by induction on the number of the tree vertices. Pick the edge\r\nwith the smallest weight in the tree. Consider that in an optimal\r\npermutation more than one path between two adjacent verteces in the\r\npermutation passes through this edge. Erase all these paths, then each\r\nof the and subtrees holds a set of disjoint remaining paths from the\r\npermutation. For each set, join all the paths in one chain, obtaining\r\ntwo chains. These chains we join by a path that goes trough the edge .\r\nThus we have built a permutation that is not worse than the considered\r\none. For a path the edge is the smallest, so the flow along this path is\r\nequal to the weight of this edge. It follows from the induction that in\r\nsubtrees and the answer is equal to the sum of edges. By adding the\r\nweight of edge , we get the desired result. From the last paragraph it\r\nis clear how to build such a permutation: take the smallest edge, obtain\r\ntwo chains from the vertex subtrees recursively, and add them together\r\nto form a one chain. Since there are not many vertices, we can do this\r\npart in . Solution complexity: . Problem authors: gen, Gerald. Bonus:\r\nShortly before the contest we decided to make the constraints more\r\nloyal, so some solution that find Gomory-Hu tree by finding flow times\r\nalso passed. We hope that nobody is particularly saddened by this fact.\r\n(;\r\n",
    "hint": []
}