{"link": "https://codeforces.com//contest/264/problem/D", "problemId": "2529", "problem_idx": "D", "shortId": "264D", "contest_number": "264", "problem_submissions": {"D": [2970633, 2970188, 2969616, 2972161, 2970655, 2972191, 2971577, 2970650, 2971498, 2971572, 2972055, 2972383, 2971674, 2972692, 2971818, 2972335], "C": [2968127, 2967219, 2967855, 2968130, 2966487, 2966588, 2967563, 2967148, 2967835, 2968495, 2969405, 2968262, 2968182, 2968431, 2970284, 2968742, 2969164, 2966742], "B": [2965253, 2965388, 2965967, 2964982, 2964487, 2965047, 2964632, 2965554, 2964885, 2965097, 2966188, 2965309, 2965972, 2965497, 2965546, 2967550, 2966171], "A": [2963692, 2963886, 2964531, 2963631, 2963360, 2963339, 2963656, 2963270, 2995453, 2963462, 2963614, 2963459, 2963970, 2964239, 2963708, 2963681, 2964333, 2963722], "E": [2971453, 3192402, 2977035, 2974561, 2972662]}, "name": "D. Colorful Stones", "statement": "There are two sequences of colorful stones. The color of each stone is\r\none of red, green, or blue. You are given two strings and . The -th\r\n(1-based) character of represents the color of the -th stone of the\r\nfirst sequence. Similarly, the -th (1-based) character of represents the\r\ncolor of the -th stone of the second sequence. If the character is \"\",\r\n\"\", or \"\", the color of the corresponding stone is red, green, or blue,\r\nrespectively.Initially Squirrel Liss is standing on the first stone of\r\nthe first sequence and Cat Vasya is standing on the first stone of the\r\nsecond sequence. You can perform the following instructions zero or more\r\ntimes.Each instruction is one of the three types: \"\", \"\", or \"\". After\r\nan instruction , the animals standing on stones whose colors are will\r\nmove one stone forward. For example, if you perform an instruction , the\r\nanimals standing on red stones will move one stone forward. You are not\r\nallowed to perform instructions that lead some animals out of the\r\nsequences. In other words, if some animals are standing on the last\r\nstones, you can\u2019t perform the instructions of the colors of those\r\nstones.A pair of positions (position of Liss, position of Vasya) is\r\ncalled a state. A state is called if the state is reachable by\r\nperforming instructions zero or more times from the initial state (1,\r\n1). Calculate the number of distinct reachable states.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:60000000\")\n//#define _MY_OPT_MODE_\n#define _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <list>\n\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long double ldb;\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef pair <double, double> pdd;\n\n#define y0 wwwwwww\n#define y1 qqqqqqq\n#define next NEXT\n#define prev PREV\n#define forn(i, n) for (int i = 0; i < (int) n; i++)\n#define ford(i, n) for (int i = (int) n - 1; i >= 0; i--)\n#define seta(a, b) memset(a, b, sizeof(a))\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n#define last(a) a[a.size() - 1]\n#define mp make_pair\n#define fs first\n#define sc second\n\ntemplate <class T> T sqr(T x) { return x * x; }\n\ndouble const pi = 3.1415926535897932384626433832795;\nint const inf = (int) 1e9;\nint64 const inf64 = (int64) 4e18;\nconst string name = \"d\";\n\nconst int NMAX = 1001000;\n\nint f(int c)\n{\n\tif (c == 'R') return 0;\n\tif (c == 'G') return 1;\n\tif (c == 'B') return 2;\n\tassert(0);\n}\n\nint n, m, l, r, pre[NMAX][3][3];\nint64 ans;\nchar s[NMAX], t[NMAX];\n\nint calc(int idx, int ept)\n{\n\tif (idx < 0 || ept == 0) return 0;\n\treturn pre[idx][f(s[ept])][f(s[ept - 1])];\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen((name + \".in\").data(), \"r\", stdin);\n\tfreopen((name + \".out\").data(), \"w\", stdout);\n#endif\n\n\tscanf(\"%s\", s);\n\tscanf(\"%s\", t);\n\tn = strlen(s);\n\tm = strlen(t);\n\n\tseta(pre, 0);\n\tforn(i, m)\n\t\tif (i)\n\t\t{\n\t\t\tmemcpy(pre[i], pre[i - 1], sizeof(pre[i]));\n\t\t\tpre[i][f(t[i - 1])][f(t[i])]++;\n\t\t\tforn(j, 3)\n\t\t\t\tpre[i][j][j] = 0;\n\t\t}\n\n\tl = 0, r = 0;\n\tans = 0;\n\tforn(i, n)\n\t{\n\t\twhile (r < m - 1 && s[i] != t[r]) r++;\n\t\tans += r - l + 1 - (calc(r, i) - calc(l - 1, i));\n\t\tif (r < m - 1) r++;\n\t\tif (s[i] == t[l]) l++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "two pointers"], "dificulty": "2500", "interactive": false}