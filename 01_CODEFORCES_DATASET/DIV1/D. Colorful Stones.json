{
    "link": "https://codeforces.com//contest/264/problem/D",
    "problemId": "2529",
    "problem_idx": "D",
    "shortId": "264D",
    "contest_number": "264",
    "problem_submissions": {
        "D": [
            2970633,
            2970188,
            2969616,
            2972161,
            2970655,
            2972191,
            2971577,
            2970650,
            2971498,
            2971572,
            2972055,
            2972383,
            2971674,
            2972692,
            2971818,
            2972335
        ],
        "C": [
            2968127,
            2967219,
            2967855,
            2968130,
            2966487,
            2966588,
            2967563,
            2967148,
            2967835,
            2968495,
            2969405,
            2968262,
            2968182,
            2968431,
            2970284,
            2968742,
            2969164,
            2966742
        ],
        "B": [
            2965253,
            2965388,
            2965967,
            2964982,
            2964487,
            2965047,
            2964632,
            2965554,
            2964885,
            2965097,
            2966188,
            2965309,
            2965972,
            2965497,
            2965546,
            2967550,
            2966171
        ],
        "A": [
            2963692,
            2963886,
            2964531,
            2963631,
            2963360,
            2963339,
            2963656,
            2963270,
            2995453,
            2963462,
            2963614,
            2963459,
            2963970,
            2964239,
            2963708,
            2963681,
            2964333,
            2963722
        ],
        "E": [
            2971453,
            3192402,
            2977035,
            2974561,
            2972662
        ]
    },
    "name": "D. Colorful Stones",
    "statement": "There are two sequences of colorful stones. The color of each stone is\r\none of red, green, or blue. You are given two strings and . The -th\r\n(1-based) character of represents the color of the -th stone of the\r\nfirst sequence. Similarly, the -th (1-based) character of represents the\r\ncolor of the -th stone of the second sequence. If the character is \"\",\r\n\"\", or \"\", the color of the corresponding stone is red, green, or blue,\r\nrespectively.Initially Squirrel Liss is standing on the first stone of\r\nthe first sequence and Cat Vasya is standing on the first stone of the\r\nsecond sequence. You can perform the following instructions zero or more\r\ntimes.Each instruction is one of the three types: \"\", \"\", or \"\". After\r\nan instruction , the animals standing on stones whose colors are will\r\nmove one stone forward. For example, if you perform an instruction , the\r\nanimals standing on red stones will move one stone forward. You are not\r\nallowed to perform instructions that lead some animals out of the\r\nsequences. In other words, if some animals are standing on the last\r\nstones, you can\u2019t perform the instructions of the colors of those\r\nstones.A pair of positions (position of Liss, position of Vasya) is\r\ncalled a state. A state is called if the state is reachable by\r\nperforming instructions zero or more times from the initial state (1,\r\n1). Calculate the number of distinct reachable states.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n//#define _MY_OPT_MODE_\n#define _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <list>\n\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long double ldb;\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef pair <double, double> pdd;\n\n#define y0 wwwwwww\n#define y1 qqqqqqq\n#define next NEXT\n#define prev PREV\n#define forn(i, n) for (int i = 0; i < (int) n; i++)\n#define ford(i, n) for (int i = (int) n - 1; i >= 0; i--)\n#define seta(a, b) memset(a, b, sizeof(a))\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n#define last(a) a[a.size() - 1]\n#define mp make_pair\n#define fs first\n#define sc second\n\ntemplate <class T> T sqr(T x) { return x * x; }\n\ndouble const pi = 3.1415926535897932384626433832795;\nint const inf = (int) 1e9;\nint64 const inf64 = (int64) 4e18;\nconst string name = \"d\";\n\nconst int NMAX = 1001000;\n\nint f(int c)\n{\n\tif (c == 'R') return 0;\n\tif (c == 'G') return 1;\n\tif (c == 'B') return 2;\n\tassert(0);\n}\n\nint n, m, l, r, pre[NMAX][3][3];\nint64 ans;\nchar s[NMAX], t[NMAX];\n\nint calc(int idx, int ept)\n{\n\tif (idx < 0 || ept == 0) return 0;\n\treturn pre[idx][f(s[ept])][f(s[ept - 1])];\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen((name + \".in\").data(), \"r\", stdin);\n\tfreopen((name + \".out\").data(), \"w\", stdout);\n#endif\n\n\tscanf(\"%s\", s);\n\tscanf(\"%s\", t);\n\tn = strlen(s);\n\tm = strlen(t);\n\n\tseta(pre, 0);\n\tforn(i, m)\n\t\tif (i)\n\t\t{\n\t\t\tmemcpy(pre[i], pre[i - 1], sizeof(pre[i]));\n\t\t\tpre[i][f(t[i - 1])][f(t[i])]++;\n\t\t\tforn(j, 3)\n\t\t\t\tpre[i][j][j] = 0;\n\t\t}\n\n\tl = 0, r = 0;\n\tans = 0;\n\tforn(i, n)\n\t{\n\t\twhile (r < m - 1 && s[i] != t[r]) r++;\n\t\tans += r - l + 1 - (calc(r, i) - calc(l - 1, i));\n\t\tif (r < m - 1) r++;\n\t\tif (s[i] == t[l]) l++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Colorful Stones.json",
    "editorial_link": "https://codeforces.com/blog/entry/6478",
    "editorial": "First, let's consider a simpler version of the problem: You are given a start state and a goal state. Check whether the goal state is reachable from the start state.\n\nDefine A, B, C, and D as in the picture below, and let I be the string of your instructions. A and B are substrings of s, and C and D are substrings of t.\n\n \n\nIt is possible to reach the goal state from the start state if there exists an instruction I such that:\n\n1 A is a subsequence of I.\n2 B is not a subsequence of I.\n3 C is a subsequence of I.\n4 D is not a subsequence of I.\nSo we want to check if such string I exists. (string s1 is called a subsequence of s2 if it is possible to get s2 by removing some characters of s1)\n\nThere are some obvious \"NO\" cases. When D is a subsequence of A, it is impossible to satisfy both conditions 1 and 4. Similarly, B must not be a subsequence of C. Are these sufficient conditions? Let's try to prove this hypothesis.\n\nTo simplify the description we will introduce some new variables. Let A', B', C', and D' be strings that can be obtained by removing the first characters of A, B, C, and D. Let c1 and c2 be the first characters of A and C.\n\n \n\nSuppose that currently the conditions are satisfied (i.e. D is not a subsequence of A and B is not a subsequence of C).\n\nIf c1?=?c2, you should perform the instruction c1?=?c2. The new quatruplet will be (A',?B',?C',?D') and this also satisies the conditions.\nIf c1???c2 and B' is not a subsequnce of C, you should perform the instruction c1. The new quatruplet will be (A',?B',?C,?D) and this also satisies the conditions.\nIf c1???c2 and D' is not a subsequnce of A, you should perform the instruction c2. The new quatruplet will be (A,?B,?C',?D') and this also satisies the conditions.\nWhat happens if all of the above three conditions don't hold? In this case A and C have the same length and A?=?c1c2c1c2..., B?=?c2c1c2c1. In particular the last two characters of A and B are swapped: there are different characters x and y and A?=?...xy, B?=?...yx. Now you found a new necessary condition! Generally, if A and B are of the form A?=?...xy and B?=?...yx, the goal state is unreachable. If the last instruction is x, Vasya must be in the goal before the last instruction, but then Vasya will go further after the last instruction. If the last instruction is y, we will also get a contradiction.\n\nFinally we have a solution. The goal state is reachable from the start state if and only if D is not a subsequence of A, B is not a subsequnce of C, and A and C are not of the form A?=?...xy, C?=?...yx. The remaining part is relatively easy, so I'll leave it as an exercise for readers."
}