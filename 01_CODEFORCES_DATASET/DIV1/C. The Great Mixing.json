{
    "link": "https://codeforces.com//contest/788/problem/C",
    "problemId": "100723",
    "problem_idx": "C",
    "shortId": "788C",
    "contest_number": "788",
    "problem_submissions": {
        "E": [
            25924862,
            25925377,
            25915904,
            25922582,
            25915050,
            25918684,
            25941153,
            25921354,
            25925269,
            25935314,
            25926533,
            25926046,
            25936552,
            25927749,
            25926831,
            25919133,
            25921191
        ],
        "D": [
            25915542,
            25915181,
            25939395,
            25930075,
            25941576,
            25921672,
            25929951,
            25917640,
            25923984,
            26061916,
            26104610,
            25928092,
            25925001,
            25924944,
            26043257
        ],
        "C": [
            25904961,
            25906051,
            25905059,
            25908402,
            25906489,
            25909800,
            25905943,
            25913627,
            25910389,
            25907305,
            25913724,
            25911198,
            25913363,
            25908585,
            25910198,
            25909085,
            25915912,
            25913369,
            25907071,
            25907012
        ],
        "B": [
            25903079,
            25903720,
            25902453,
            25904332,
            25903705,
            25904849,
            25903086,
            25902909,
            25905715,
            25902462,
            25905159,
            25905547,
            25906945,
            25904624,
            25903809,
            25910532,
            25906509,
            25927693,
            25946077
        ],
        "A": [
            25900169,
            25901048,
            25900244,
            25901169,
            25900572,
            25900694,
            25900718,
            25900816,
            25901339,
            25905048,
            25900137,
            25900587,
            25901139,
            25902041,
            25900581,
            25899979,
            25900864,
            25900329,
            25900280,
            25900541
        ]
    },
    "name": "C. The Great Mixing",
    "statement": "Sasha and Kolya decided to get drunk with Coke, again. This time they\r\nhave types of Coke. -th type is characterised by its carbon dioxide\r\nconcentration . Today, on the party in honour of Sergiy of Vancouver\r\nthey decided to prepare a glass of Coke with carbon dioxide\r\nconcentration . The drink should also be tasty, so the glass can contain\r\nonly integer number of liters of each Coke type (some types can be not\r\npresented in the glass). Also, they want to minimize the total volume of\r\nCoke in the glass.Carbon dioxide concentration is defined as the volume\r\nof carbone dioxide in the Coke divided by the total volume of Coke. When\r\nyou mix two Cokes, the volume of carbon dioxide sums up, and the total\r\nvolume of Coke sums up as well.Help them, find the minimal natural\r\nnumber of liters needed to create a glass with carbon dioxide\r\nconcentration . Assume that the friends have unlimited amount of each\r\nCoke type.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 1e3 + 10;\nint can[maxn];\n\nint need, k;\n\nint read() {\n  if (scanf(\"%d%d\", &need, &k) < 2) {\n    return 0;\n  }\n  for (int i = 0; i < maxn; ++i) {\n    can[i] = 0;\n  }\n  for (int i = 0; i < k; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    can[x] = 1;\n  }\n  return 1;\n}\n\nint dp[2 * maxn];\n\nvoid solve() {\n  for (int i = 0; i < maxn * 2; ++i) {\n    dp[i] = inf;\n  }\n\n  vector<int> st;\n  for (int i = 0; i < maxn; ++i) {\n    if (can[i]) {\n      dp[i - need + maxn] = 1;\n      st.pb(i - need + maxn);\n    }\n  }\n\n  for (int l = 0; l < sz(st); ++l) {\n    int x = st[l];\n    for (int i = 0; i < maxn; ++i) {\n      if (can[i]) {\n        int nx = x + i - need;\n        if (0 <= nx && nx < 2 * maxn && dp[nx] > dp[x] + 1) {\n          dp[nx] = dp[x] + 1;\n          st.pb(nx);\n        }\n      }\n    }\n  }\n\n  int res = dp[maxn];\n  if (res == inf) {\n    res = -1;\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. The Great Mixing.json",
    "editorial_link": "https://codeforces.com//blog/entry/51312",
    "editorial": "Let needed concentration and concentration of types weâll use. Then, we\r\ncan decrease every by . So, we reduced the problem to finding a set of\r\nnumbers with zero sum. Now we can build a graph, where vertexes are our\r\nsum.There will be edges from each vertex, where the number of different\r\nconcentrations. Obviously, weâll have at most 1001 different\r\nconcentrations, so there are at most 1001 edges from each vertex. Now,\r\nwe need to find a cycle of smallest length. We can do this using BFS\r\nstarting from vertex 0. With BFS we can find the first vertex with the\r\nexisting edge to vertex 0.We need at most 1000 vertexes to each side\r\n(from -1000 to 1000), so the solution complexity is .\r\n",
    "hint": []
}