{
    "link": "https://codeforces.com//contest/1801/problem/C",
    "problemId": "1817546",
    "problem_idx": "C",
    "shortId": "1801C",
    "contest_number": "1801",
    "problem_submissions": {
        "G": [
            203657914,
            201155712,
            196755049,
            196760812,
            203134482
        ],
        "E": [
            196675152,
            196635209,
            196644302,
            196640748,
            196641519,
            196635379,
            196630013,
            196657513,
            196650893,
            196653405,
            196644576,
            196654360,
            196640172,
            196683603,
            196680417,
            196653431,
            196644218,
            196626389,
            199502352,
            199501873,
            199501660,
            199501455,
            199501378,
            199501277,
            199501214,
            199501173,
            199500937,
            199500810,
            196645808,
            196668272,
            196658312,
            196656102,
            196652330
        ],
        "F": [
            196622978,
            196623206,
            196631833,
            196626066,
            196642170,
            196635485,
            196619644,
            196630879,
            196631678,
            196626069,
            196641735,
            196624132,
            196623158,
            196622410,
            196637181,
            196627815,
            196619025,
            196627461,
            196633301,
            196628988
        ],
        "D": [
            196614757,
            196616104,
            196610930,
            196615603,
            196617463,
            196615380,
            196614983,
            196615414,
            196624090,
            196611332,
            196624396,
            196619261,
            196612951,
            196616838,
            196613243,
            196620716,
            196612736,
            196620435,
            196615283,
            196621604
        ],
        "C": [
            196609472,
            196608959,
            196606372,
            196605050,
            196609433,
            196606282,
            196610970,
            196610779,
            196613465,
            196606986,
            196612839,
            196609050,
            196607813,
            196663784,
            196670930,
            196612044,
            196605520,
            196611174,
            196610757,
            196615745
        ],
        "B": [
            196607492,
            196604951,
            196602514,
            196611006,
            196605854,
            196603175,
            196607224,
            196607805,
            196609864,
            196732242,
            196608899,
            196725334,
            196673072,
            196604282,
            196604121,
            196602391,
            196666183
        ],
        "A": [
            196601824,
            196601543,
            196601334,
            196601281,
            196602802,
            196601554,
            196623981,
            196603178,
            196605892,
            196601290,
            196604431,
            196602393,
            196602511,
            196601410,
            196601549,
            196603512,
            196601416,
            196607954,
            196604235,
            196602401
        ]
    },
    "name": "C. Music Festival",
    "statement": "The boy Vitya loves to listen to music very much. He knows that n albums\r\nare due to be released this Friday, i-th of which contains k_i tracks.\r\nOf course, Vitya has already listened to all the tracks, and knows that\r\nin the i-th album, the coolness of the j-th track is equal to\r\na_{i,j}.Vitya has a friend Masha, whom he really wants to invite to the\r\nfestival, where his favorite bands perform. However, in order for a\r\nfriend to agree, she must first evaluate the released novelties. Vitya\r\nknows that if Masha listens to a track that was cooler than all the\r\nprevious ones, she will get 1 unit of impression. Unfortunately, albums\r\ncan only be listened to in their entirety, without changing the songs in\r\nthem in places.Help Vitya find such an order of albums so that Masha\u2019s\r\nimpression turns out to be as much as possible, and she definitely went\r\nto the festival with him.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT \u3067\u6570\u5217\u3092\u7ba1\u7406\u3059\u308b\u3068\u304d\u306b\u4f7f\u3046 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify \u3057\u3066\u306a\u3044\u3084\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//\u30bd\u30fc\u30c8\u3057\u3066 i \u756a\u76ee\u304c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//\u4f8b\u3048\u3070 sortidx \u3067\u5f97\u305f idx \u3092\u4f7f\u3048\u3070\u5358\u306b\u30bd\u30fc\u30c8\u5217\u306b\u306a\u3063\u3066\u8fd4\u3063\u3066\u304f\u308b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<tuple<int,int,int>> es;\n\trep(_,n){\n\t\tint k;cin>>k;\n\t\tvi a;\n\t\trep(j,k){\n\t\t\tint v;cin>>v;\n\t\t\tif(a.empty()||a.back()<v)a.pb(v);\n\t\t}\n\t\trep(i,si(a)){\n\t\t\tes.eb(a[i],a.back()+1,si(a)-i);\n\t\t}\n\t}\n\tvi vs;\n\tfor(auto [u,v,w]:es){\n\t\tvs.pb(u);\n\t\tvs.pb(v);\n\t}\n\tmkuni(vs);\n\tint s=si(vs);\n\tvi dp(s,-inf);\n\tdp[0]=0;\n\tvvc<pi> g(s);\n\tfor(auto [u,v,w]:es){\n\t\tu=lwb(vs,u);\n\t\tv=lwb(vs,v);\n\t\tg[u].eb(v,w);\n\t}\n\trep(i,s-1){\n\t\tchmax(dp[i+1],dp[i]);\n\t\tfor(auto [j,c]:g[i])\n\t\t\tchmax(dp[j],dp[i]+c);\n\t}\n\tprint(dp[s-1]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Music Festival.json",
    "editorial_link": "https://codeforces.com//blog/entry/113857",
    "editorial": "Solution Let\u00e2\u0080\u0099s introduce the concept of a compressed album for an album,\nwhich is obtained from the original one by removing all elements except\nthose that are the first maxima on their corresponding prefixes.For\nexample:For the album the album will be compressed .Now we note that the\nsolution of the original problem is reduced to solving the same problem,\nbut on compressed albums. Indeed, the answer to them will not be\ndifferent, because if some element increased the impression on ordinary\nalbums, then it will increase if you compress albums and vice versa.\nNext, it will be assumed that all albums have been compressed\nbeforehand.Let\u00e2\u0080\u0099s introduce the maximum impression that can be obtained\nif there were no albums such that they have elements larger than . Then,\nis equal to , or you can add another element or two if is the maximum\nelement for some album. Then for all compressed albums, it can be\nrecalculated through the value of at the point before the first element\nof the album, or through . Thus, for recalculation, it is enough to know\nfor each which albums ended in this index, as well as for each album its\nfirst element. Solution for Let\u00e2\u0080\u0099s now solve the complete problem. For\neach value of , let\u00e2\u0080\u0099s remember the indexes of albums that contain an\nelement equal to . We go in order of increasing , we maintain for each\nalbum the value of the maximum impression that can be obtained if there\nwere no elements of large and Masha listened to the last album. Suppose\nfor the next there is an album , that there is a song with the coolness\nof in it. Then should be taken as the maximum of and the values for all\n, such that the maximum element in the th album is less than the maximum\nelement of th, since she could listen to this track, either next in this\nalbum, or after listening to some other album completely. Note that you\ncan store the value of maximum for all albums for which the maximum\nvalue in them is less than and recalculate it when moving to , storing\nthose albums that have ended, then you will get a solution for .\n"
}