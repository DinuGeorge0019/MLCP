{
    "link": "https://codeforces.com//contest/1876/problem/F",
    "problemId": "2251950",
    "problem_idx": "F",
    "shortId": "1876F",
    "contest_number": "1876",
    "problem_submissions": {
        "F": [
            227177806,
            227207094,
            227205539,
            227205151
        ],
        "E": [
            227157151,
            227151734,
            227168660,
            227172380,
            227183052,
            227309041,
            227308704,
            227174767,
            227180790,
            227181408,
            227180728,
            227180621,
            227182335,
            227260713,
            227259829,
            227186766,
            227170474,
            227321208,
            227261014
        ],
        "D": [
            227143743,
            227138577,
            227308847,
            227146942,
            227140586,
            227141511,
            227160448,
            227153072,
            227151615,
            227160275,
            227166901,
            227141697,
            227262091,
            227163246,
            227151371,
            227141424,
            227141434,
            227152662,
            227155489,
            227148839,
            227151040,
            227154461
        ],
        "C": [
            227128643,
            227130062,
            227133604,
            227130971,
            227129714,
            227144982,
            227139072,
            227133756,
            227145578,
            227141605,
            227156976,
            227263099,
            227135346,
            227132471,
            227128506,
            227133146,
            227135885,
            227135604,
            227140440,
            227137265
        ],
        "B": [
            227120010,
            227119885,
            227123059,
            227119488,
            227120157,
            227125041,
            227123945,
            227122604,
            227124586,
            227123169,
            227160403,
            227263121,
            227124143,
            227123043,
            227120364,
            227120185,
            227120687,
            227125676,
            227123006,
            227129980,
            227122132
        ],
        "A": [
            227117267,
            227116977,
            227118151,
            227116487,
            227116831,
            227118490,
            227120408,
            227118388,
            227121296,
            227117209,
            227162962,
            227263136,
            227118862,
            227118193,
            227117199,
            227115769,
            227117422,
            227121537,
            227118512,
            227124495,
            227116510
        ],
        "G": [
            227270487,
            229852864,
            229527555
        ]
    },
    "name": "F. Indefinite Clownfish",
    "statement": "Pak Chanek has just bought an empty fish tank and he has been dreaming\r\nto fill it with his favourite kind of fish, clownfish. Pak Chanek likes\r\nclownfish because of their ability to change their genders on demand.\r\nBecause of the size of his fish tank, Pak Chanek wants to buy exactly k\r\nclownfish to fill the tank.Pak Chanek goes to the local fish shop. The\r\nshop provides n clownfish numbered from 1 to n, with clownfish i having\r\na size of a_i. Initially, every clownfish in the store does not have an\r\nassigned gender, but has the ability to be assigned to two possible\r\nclownfish genders, female or male.The store has a procedure which Pak\r\nChanek should follow to buy clownfish. The shop owner will point at each\r\nclownfish sequentially from 1 to n and for each clownfish, she asks Pak\r\nChanek whether to buy it or not. Each time Pak Chanek is asked, he must\r\ndeclare whether to buy the currently asked clownfish or not, before the\r\nshop owner moves on to the next clownfish. If Pak Chanek declares to buy\r\nthe currently asked clownfish, he must also declare the gender to be\r\nassigned to that clownfish immediately. When assigning the gender for\r\nthe currently asked clownfish, the following conditions must be\r\nsatisfied: If Pak Chanek assigns it to be female and he has bought a\r\nfemale clownfish before, then the size of the current one must be\r\nexactly 1 than the last female one. If Pak Chanek assigns it to be male\r\nand he has bought a male clownfish before, then the size of the current\r\none must be exactly 1 than the last male one. Pak Chanek wants to buy\r\nexactly k clownfish such that: There is at least one female clownfish\r\nand one male clownfish. Among the k clownfish Pak Chanek buys, the mean\r\nsize of the female clownfish is equal to the mean size of the male\r\nclownfish. Let l and r respectively be the minimum and maximum of a\r\nclownfish Pak Chanek buys. What is the minimum possible value of r-l?\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\n\nint tab[nax];\n\nvi jump[nax][2];//0 to w dol, 1 to w gore\nint ost[nax];\n\nint musi[nax][2][2];\n\nint odw[nax][2][2];\n\nvoid nope()\n{\n\tprintf(\"-1\\n\");\n\texit(0);\n}\n\nint policz(int h, int v)\n{\n\tint ret=0;\n\twhile(!jump[v][h].empty())\n\t{\n\t\tint x=jump[v][h].size();\n\t\tx--;\n\t\tret+=(1<<x);\n\t\tint ter=jump[v][h][x];\n\t\tv=ter;\n\t}\n\treturn ret;\n}\n\nint skocz(int h, int v, int ile)\n{\n\tint ory=v;\n\tfor (int i=0; (1<<i)<=ile; i++)\n\t{\n\t\tif (ile&(1<<i))\n\t\t{\n\t\t\tif ((int)jump[v][h].size()<=i)\n\t\t\t\treturn nax;\n\t\t\tint ter=jump[v][h][i];\n\t\t\tv=ter;\n\t\t}\n\t}\n\treturn ory-v;\n}\n\nvoid mini(int &a, int b)\n{\n\ta=min(a, b);\n}\n\nvoid calc()\n{\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tjump[i][0].clear();\n\t\tjump[i][1].clear();\n\t\tost[i]=0;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tost[tab[i]]=i;\n\t\tif (ost[tab[i]-1])\n\t\t\tjump[i][0].push_back(ost[tab[i]-1]);\n\t\tif (ost[tab[i]+1])\n\t\t\tjump[i][1].push_back(ost[tab[i]+1]);\n\t\tfor (int h=0; h<2; h++)\n\t\t{\n\t\t\tfor (int j=0; 1; j++)\n\t\t\t{\n\t\t\t\tif ((int)jump[i][h].size()<=j)\n\t\t\t\t\tbreak;\n\t\t\t\tint x=jump[i][h][j];\n\t\t\t\tif ((int)jump[x][h].size()<=j)\n\t\t\t\t\tbreak;\n\t\t\t\tint y=jump[x][h][j];\n\t\t\t\tjump[i][h].push_back(y);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int a=0; a<2; a++)\n\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\tmusi[i][a][b]=nax;\n\t\tint p0=policz(0, i);\n\t\tint p1=policz(1, i);\n\t\tif (p0+p1+1<k)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint bsa=0;\n\t\tint bsb=k-1;\n\t\twhile(bsa<bsb)\n\t\t{\n\t\t\tint bss=(bsa+bsb)/2;\n\t\t\tint s0=skocz(0, i, bss);\n\t\t\tint s1=skocz(1, i, k-1-bss);\n\t\t\tif (s0<s1)\n\t\t\t\tbsa=bss+1;\n\t\t\telse\n\t\t\t\tbsb=bss;\n\t\t}\n\t\tassert(skocz(0, i, bsa)>=skocz(1, i, k-1-bsa));\n\t\tfor (int j=max(0, bsa-2); j<=min(k-1, bsa+2); j++)\n\t\t{\n\t\t\tint s0=skocz(0, i, j);\n\t\t\tint s1=skocz(1, i, k-1-j);\n\t\t\tmini(musi[i][j>0][j<k-1], max(s0, s1));\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int a=0; a<2; a++)\n\t\t{\n\t\t\tfor (int b=0; b<2; b++)\n\t\t\t{\n\t\t\t\tmini(musi[i][a][0], musi[i][a][b]);\n\t\t\t\tmini(musi[i][0][b], musi[i][a][b]);\n\t\t\t\tmini(musi[i][0][0], musi[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tif (k&1)\n\t\tnope();\n\tk>>=1;\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\treverse(tab+1, tab+1+n);\n\tcalc();\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int a=0; a<2; a++)\n\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\todw[n+1-i][a][b]=musi[i][a][b];\n\treverse(tab+1, tab+1+n);\n\tcalc();\n\t//~ for (int i=1; i<=n; i++)\n\t//~ {\n\t\t//~ debug() << i;\n\t\t//~ for (int j=0; j<2; j++)\n\t\t\t//~ debug() << range(musi[i][j], musi[i][j]+2);\n\t\t//~ debug();\n\t\t//~ for (int j=0; j<2; j++)\n\t\t\t//~ debug() << range(odw[i][j], odw[i][j]+2);\n\t\t//~ debug();\n\t//~ }\n\tint wyn=nax;\n\tfor (int i=1; i<=n; i++)\n\t\tost[i]=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=tab[i]-1; j<=tab[i]+1; j++)\n\t\t{\n\t\t\tif (!ost[j])\n\t\t\t\tcontinue;\n\t\t\tint g=ost[j];\n\t\t\tif (j<tab[i])\n\t\t\t{\n\t\t\t\tmini(wyn, i-g+musi[g][0][1]+odw[i][0][0]);\n\t\t\t\tmini(wyn, i-g+musi[g][0][0]+odw[i][1][0]);\n\t\t\t}\n\t\t\tif (j>tab[i])\n\t\t\t{\n\t\t\t\tmini(wyn, i-g+musi[g][1][0]+odw[i][0][0]);\n\t\t\t\tmini(wyn, i-g+musi[g][0][0]+odw[i][0][1]);\n\t\t\t}\n\t\t\tif (j==tab[i])\n\t\t\t{\n\t\t\t\tmini(wyn, i-g+musi[g][0][0]+odw[i][0][0]);\n\t\t\t}\n\t\t\t//~ debug() << imie(g) << imie(i) << imie(wyn);\n\t\t}\n\t\tost[tab[i]]=i;\n\t}\n\tif (wyn>=nax/2)\n\t\twyn=-1;\n\tprintf(\"%d\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "graphs"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Indefinite Clownfish.json",
    "editorial_link": "https://codeforces.com//blog/entry/121200",
    "editorial": "We want to find two subsequences (for the females and the males) such\r\nthat: The female subsequence contains consecutively increasing values.\r\nThe male subsequence contains consecutively decreasing values The total\r\nlength is exactly . The mean values of both subsequences are the same.\r\nFor a group of consecutive values with minimum value and maximum value ,\r\nthe mean is . So we must make both values of the same.We can obtain that\r\nsince both means are equal, the two subsequences must contain at least\r\none common value. And a common value can only occur twice in the\r\nentirety of the two subsequences.For a way to choose the two\r\nsubsequences, let be a common value of the two subsequences such that\r\nthe difference in indices of its two occurences is minimum. Let and be\r\nthe indices of the left and right occurences of respectively. There are\r\ntwo cases, either the is female and is male, or vice versa. If the is\r\nfemale, the following must be true: To the left , in decreasing indices,\r\nthe chosen subsequence (the female one) has the values , , , and so on.\r\nTo the right of , in increasing indices, the chosen subsequence (the\r\nmale one) has the values , , , and so on. How about the values in the\r\nchosen subsequences that are bigger than ? Would they conflict in the\r\nindices between and ? Well, since we choose with the minimum difference\r\nin indices of its two occurences, then all values bigger than in the\r\nchosen subsequences that are located between and are either only from\r\nthe female subsequence or only from the male subsequence. So, we only\r\nneed to consider where for a fixed index that is either or : To the left\r\nof that index, in decreasing indices, the chosen subsequence (the male\r\none) has the values , , , and so on. To the right of that index, in\r\nincreasing indices, the chosen subsequence (the female one) has the\r\nvalues , , , and so on. That means, if is female, there are two cases\r\n(either choosing the index to be or ). If is male, a similar thing also\r\napplies, but the roles of the values smaller than and the values bigger\r\nthan are switched, so there are also two cases. So there are only four\r\ncases in total.Notice that in each of the four cases, we can see it as\r\nhaving a pair of indices with the same value and having four legs of\r\nconsecutive values coming out of it in four different directions. Notice\r\nthat the elements in different legs can never conflict with each other.\r\nEach leg is independent.Let\u00e2\u0080\u0099s group the four legs into two groups, the\r\ntwo left legs and the two right legs. Next, define and as the minimum\r\nand maximum value in the female subsequence and define and as the\r\nminimum and maximum value in the male subsequence. It must hold that .\r\nSo .Notice that is the total number of elements in the two left legs and\r\nis the total number of elements in the two right legs if we exclude and\r\n. Since we want to make the number of elements in the two groups the\r\nsame, each group must contain exactly elements. This means if is odd, it\r\nis impossible.We obtain that we can handle the two groups independently.\r\nWe just need to make sure the number of elements in one group is exactly\r\n. We want to minimise the value of . This means, we want to maximise in\r\nthe left group and minimise in the right group. These two tasks are\r\nequivalent, just mirrored.To solve this, let\u00e2\u0080\u0099s construct a graph using\r\nthe array. Each element in the array has four parents: The rightmost\r\nelement to the left of it with value . The rightmost element to the left\r\nof it with value . The leftmost element to the right of it with value .\r\nThe leftmost element to the right of it with value . For each type of\r\nparent, construct the binary lifting for it so that for each element, we\r\ncan get its -th parent of a certain for any value of in .Using this, in\r\norder to calculate the maximum value of of the left group, we can do a\r\nbinary search to find the optimal number of elements in each of the two\r\nleft legs. We do the same thing for the right group. We do this for each\r\nof the four cases to finally find the minimum value of for a particular\r\npair of .We do that entire process repeatedly for all pairs of adjacent\r\noccurences of the same value.Time complexity:\r\n"
}