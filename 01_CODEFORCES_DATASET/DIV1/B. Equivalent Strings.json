{
    "link": "https://codeforces.com//contest/559/problem/B",
    "problemId": "31961",
    "problem_idx": "B",
    "shortId": "559B",
    "contest_number": "559",
    "problem_submissions": {
        "E": [
            12182515,
            12187399,
            141685289,
            12274173,
            12181231,
            12175304,
            12176173
        ],
        "D": [
            12174436,
            12174384,
            12175184,
            12184862,
            12179042,
            12177010,
            12178587,
            49075843,
            12177521,
            12178544,
            12177403,
            12177707,
            12177850,
            12180968,
            12184700,
            12184490,
            12181105,
            12182102,
            12177181
        ],
        "B": [
            12168424,
            12165732,
            12167442,
            12165414,
            12170869,
            12165053,
            12170711,
            12167857,
            12167750,
            12165064,
            12170170,
            12165197,
            12169015,
            12167991,
            12167961,
            12167252,
            12165704,
            12179411
        ],
        "C": [
            12166898,
            12169572,
            12170142,
            12166836,
            12168670,
            12169914,
            12171548,
            12172425,
            12171036,
            12171573,
            12167528,
            12170704,
            12170899,
            12172108,
            12170757,
            12172559,
            12170995,
            12170579
        ],
        "A": [
            12164711,
            12164664,
            12165120,
            12164570,
            12172440,
            12167121,
            12167930,
            12166447,
            12185370,
            12166201,
            12165955,
            12170667,
            12167349,
            12166038,
            12183406,
            12165416,
            12164553,
            12178800
        ]
    },
    "name": "B. Equivalent Strings",
    "statement": "Today on a lecture about strings Gerald learned a new definition of\r\nstring equivalency. Two strings and of equal length are called in one of\r\nthe two cases: They are equal. If we split string into two halves of the\r\nsame size and , and string into two halves of the same size and , then\r\none of the following is correct: is equivalent to , and is equivalent to\r\nis equivalent to , and is equivalent to As a home task, the teacher gave\r\ntwo strings to his students and asked to determine if they are\r\nequivalent.Gerald has already completed this home task. Now it\u2019s your\r\nturn!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nstring s,t;\nstring gao(string a) {\n\tif (SZ(a)%2==1) return a;\n\telse {\n\t\tstring a1=\"\";\n\t\trep(i,0,SZ(a)/2) a1.pb(a[i]);\n\t\tstring s1=gao(a1);\n\t\ta1.clear();\n\t\trep(i,SZ(a)/2,SZ(a)) a1.pb(a[i]);\n\t\tstring s2=gao(a1);\n\t\tif (s1<s2) return s1+s2; else return s2+s1;\n\t}\n}\nint main() {\n\tcin>>s>>t;\n\tputs(gao(s)==gao(t)?\"YES\":\"NO\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "hashing",
        "sortings",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Equivalent Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/19237",
    "editorial": "Let us note that \"equivalence\" described in the statements is actually\r\nequivalence relation, it is reflexively, simmetrically and transitive.\r\nIt is meant that set of all string is splits to equivalence classes.\r\nLet\u00e2\u0080\u0099s find lexicographic minimal strings what is equivalent to first and\r\nto second given string. And then check if its are equals. It is remain\r\nfind the lexicographic minimal strings what is equivalent to given. For\r\ninstance we can do it such a way: Every recursive call time works is\r\n(where is length of strings) and string splitten by two twice smaller\r\nstrings. Therefore time of work this function is , where is length of\r\nstrings.\r\n"
}