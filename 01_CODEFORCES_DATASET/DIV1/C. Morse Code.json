{
    "link": "https://codeforces.com//contest/1129/problem/C",
    "problemId": "303019",
    "problem_idx": "C",
    "shortId": "1129C",
    "contest_number": "1129",
    "problem_submissions": {
        "D": [
            50457140,
            50468228,
            50468213,
            50452551,
            50784588,
            50784524,
            50784516,
            50784486,
            50455866,
            50463030,
            50451241,
            50455843,
            50456518,
            50444260,
            50455126,
            50471374,
            50469822,
            50469757,
            50469734,
            50469338,
            50469151,
            50468662,
            50468322,
            50468273,
            50465415,
            50464634,
            50455747,
            50457843,
            50458250,
            50464059,
            50449299,
            50457330
        ],
        "E": [
            50451183,
            50458483,
            50460101,
            50455688,
            50458301,
            75936467,
            50458791
        ],
        "C": [
            50447279,
            50446245,
            50449561,
            50445538,
            50440385,
            50445043,
            50447738,
            50448032,
            50454787,
            50450606,
            50457517,
            58851047,
            58850895,
            50459942,
            50451465,
            50454057,
            50448457,
            50449663
        ],
        "B": [
            50443936,
            50443531,
            50442156,
            50441155,
            50445396,
            50439298,
            50442768,
            50443504,
            50459278,
            50443656,
            50448178,
            50451750,
            50447513,
            50459190,
            50456796,
            50442875,
            50451493
        ],
        "A1": [
            50438306,
            50436838,
            50435800,
            50454577,
            50434391,
            50434469,
            50436959,
            50437853,
            50449686,
            50439524,
            50436300,
            50436664,
            50460719,
            50444960,
            50438530,
            50438635,
            50437445
        ],
        "A2": [
            50438193,
            50437084,
            50435385,
            50454632,
            50434194,
            50434343,
            50437228,
            50438028,
            50449587,
            50439649,
            50436143,
            50436524,
            50460819,
            50444992,
            50438364,
            50437253,
            50437622
        ]
    },
    "name": "C. Morse Code",
    "statement": "In Morse code, an letter of English alphabet is represented as a string\r\nof some length from 1 to 4. Moreover, each Morse code representation of\r\nan English letter contains only dots and dashes. In this task, we will\r\nrepresent a dot with a \"\" and a dash with a \"\".Because there are\r\n2^1+2^2+2^3+2^4 = 30 strings with length 1 to 4 containing only \"\"\r\nand/or \"\", not all of them correspond to one of the 26 English letters.\r\nIn particular, each string of \"\" and/or \"\" of length 4 translates into a\r\ndistinct English letter, except the following four strings that do not\r\ncorrespond to any English alphabet: \"\", \"\", \"\", and \"\".You will work\r\nwith a string S, which is initially empty. For m times, either a dot or\r\na dash will be appended to S, one at a time. Your task is to find and\r\nreport, after each of these modifications to string S, the number of\r\nnon-empty sequences of English letters that are represented with some\r\nsubstring of S in Morse code.Since the answers can be incredibly\r\ntremendous, print them modulo 10^9 + 7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct SA {\n  vector<map<char, int>> edges;\n  VI link, length;\n  int last;\n\n  SA(string s) : edges(1), link{-1}, length(1), last(0) {\n    REP (i, SZ(s)) {\n      edges.emplace_back();\n      length.PB(i + 1);\n      link.PB(0);\n      int r = SZ(edges) - 1, p = last;\n      while (p >= 0 && edges[p].find(s[i]) == edges[p].end()) {\n        edges[p][s[i]] = r;\n        p = link[p];\n      }\n      if (p != -1) {\n        int q = edges[p][s[i]];\n        if (length[p] + 1 == length[q]) {\n          link[r] = q;\n        } else {\n          edges.PB(edges[q]);\n          length.PB(length[p] + 1);\n          link.PB(link[q]);\n          int qq = SZ(edges) - 1;\n          link[q] = qq; link[r] = qq;\n          while (p >= 0 && edges[p][s[i]] == q) {\n            edges[p][s[i]] = qq;\n            p = link[p];\n          }\n        }\n      }\n      last = r;\n    }\n  }\n};\n\nconst int Mod = 1e9 + 7;\nconst int MaxN = 3005;\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  string s;\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; ++i) { char ch; cin >> ch; s += ch; }\n  SA sa(s);\n\n  const int size = SZ(sa.edges);\n  vector<int> first_occur(size, 0);\n  vector<bool> visited(size);\n  function<void(int)> Dfs = [&](int v) {\n    visited[v] = true;\n    for (auto &edge : sa.edges[v]) {\n      if (!visited[edge.nd]) { Dfs(edge.nd); }\n      maxi(first_occur[v], first_occur[edge.nd] + 1);\n    }\n  };\n\n  Dfs(0);\n  for (int i = 0; i < size; ++i) {\n    first_occur[i] = N - first_occur[i];\n  }\n  debug(first_occur);\n\n  vector<LL> answers(N);\n\n  for (int L = 0; L < N; ++L) {\n    int pos = 0;\n    LL num_found[4] = {1, 0, 0, 0};\n\n    for (int R = L; R < N; ++R) {\n      pos = sa.edges[pos][s[R]];\n      LL n0 = 0;\n\n      if (R >= 3) {\n        const string my = s.substr(R - 3, 4);\n        if (my != \"0011\" && my != \"0101\" && my != \"1110\" && my != \"1111\") {\n          n0 += num_found[3];\n        }\n      }\n\n      n0 += num_found[0] + num_found[1] + num_found[2];\n      num_found[3] = num_found[2];\n      num_found[2] = num_found[1];\n      num_found[1] = num_found[0];\n      num_found[0] = n0 % Mod;\n\n      debug(L, R, pos, first_occur[pos], num_found[0], num_found[1], num_found[2], num_found[3]);\n      if (first_occur[pos] == R + 1) {\n        debug(L, R);\n        answers[R] = (answers[R] + num_found[0]) % Mod;\n      }\n    }\n  }\n\n  for (int i = 1; i < N; ++i) {\n    answers[i] = (answers[i - 1] + answers[i]) % Mod;\n  }\n\n  for (LL v : answers) { cout << v << \"\\n\"; }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "hashing",
        "sortings",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Morse Code.json",
    "editorial_link": "https://codeforces.com/blog/entry/65520",
    "editorial": "We will be computing the answers offline instead of doing so immediately\r\nafter each modification.Let . Now, we need to find the number of English\r\nsequences that, if considered backward, would translate into some\r\nsubstring of each suffix of T.Let be the number of English sequences\r\nthat translate to exactly .Let be sum of over all . Note that can be\r\ncalculated with dynamic programming for all in where denotes the longest\r\nlength of an English alphabet in Morse code (which is ). Following that,\r\nwe can calculate for all in .The answer for the suffix is simply the sum\r\nof over all subtracted by the number of over-counted English sequences.\r\nThe number of over-counted sequences can be calculated by considering\r\nthe suffix array of . Namely, for each two adjacent suffixes in the\r\nlist, we over-counted them by with and denoting the corresponding\r\nindices of their longest common prefix (LCP).Therefore, the answer for\r\nis subtracted by the sum of of the LCP between each pair of adjacent\r\nsuffixes.Transitioning to solve the problem for where can be done\r\nefficiently, since the removal character of the string affects only one\r\nentry in the suffix list.To sum up, we find for all valid and in . Then,\r\nwe sort the suffixes naively in , before computing the answer in the\r\nfinal step in .The time complexity is .\r\n",
    "hint": []
}