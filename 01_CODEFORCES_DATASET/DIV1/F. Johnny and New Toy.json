{"link": "https://codeforces.com//contest/1361/problem/F", "problemId": "640973", "problem_idx": "F", "shortId": "1361F", "contest_number": "1361", "problem_submissions": {"F": [82547256, 82558388, 82548841, 82560787, 82546613, 82571701, 82569539, 82568479, 82553474, 82561525], "D": [82532533, 82534707, 82556057, 82527759, 82536652, 82533679, 82553972, 82540929, 82539127, 82540566, 86424872, 82526480, 82568104, 82567738, 82567880], "E": [82521789, 82543705, 82541718, 82540946, 82583418, 82541333, 82541041, 82533619, 82550465, 82553317, 82579674, 82579569, 82559988, 82559485, 82543445, 82543446, 82551504, 82544569, 82550130, 82547325, 82579220, 82517696], "C": [82504494, 82509183, 82560689, 82519634, 82513804, 82519054, 82526119, 82516120, 82517904, 82521411, 82523427, 82525691, 82518977, 82516229, 82512604, 82516960, 82527524, 82521519, 82527700, 82553581], "B": [82495175, 82498230, 82507103, 82567148, 82501464, 82497400, 82516527, 82498261, 82504352, 82509962, 82510314, 82502680, 82509498, 82502669, 82499583, 82499214, 82513823, 82505015, 82504805, 82531052], "A": [82492363, 82493600, 82494974, 82494327, 82492565, 82492329, 82494389, 82493605, 82492642, 82494930, 82499298, 82494769, 82492795, 82495342, 82493416, 82492640, 82495622, 82493415, 82512573, 82523180]}, "name": "F. Johnny and New Toy", "statement": "Johnny has a new toy. As you may guess, it is a little bit\r\nextraordinary. The toy is a permutation P of numbers from 1 to n,\r\nwritten in one row next to each other. For each i from 1 to n - 1\r\nbetween P_i and P_{i + 1} there is a weight W_i written, and those\r\nweights form a permutation of numbers from 1 to n - 1. There are also\r\nextra weights W_0 = W_n = 0.The instruction defines subsegment [L, R] as\r\ngood if W_{L - 1} < W_i and W_R < W_i for any i in\r\n{L, L + 1,\r\nldots, R - 1\r\n}. For such subsegment it also defines W_M as minimum of set\r\n{W_L, W_{L + 1},\r\nldots, W_{R - 1}\r\n}. Now the fun begins. In one move, the player can choose one of the\r\ngood subsegments, cut it into [L, M] and [M + 1, R] and swap the two\r\nparts. More precisely, before one move the chosen subsegment of our toy\r\nlooks like: W_{L - 1}, P_L, W_L,\r\nldots, W_{M - 1}, P_M, W_M, P_{M + 1}, W_{M + 1},\r\nldots, W_{R - 1}, P_R, W_R and afterwards it looks like this: W_{L - 1},\r\nP_{M + 1}, W_{M + 1},\r\nldots, W_{R - 1}, P_R, W_M, P_L, W_L,\r\nldots, W_{M - 1}, P_M, W_R Such a move can be performed multiple times\r\n(possibly zero), and the goal is to achieve the minimum number of\r\ninversions in P. Johnny\u2019s younger sister Megan thinks that the rules are\r\ntoo complicated, so she wants to test her brother by choosing some pair\r\nof indices X and Y, and swapping P_X and P_Y (X might be equal Y). After\r\neach sister\u2019s swap, Johnny wonders, what is the minimal number of\r\ninversions that he can achieve, starting with current P and making legal\r\nmoves?You can assume that the input is generated . P and W were chosen\r\nindependently and equiprobably over all permutations; also, Megan\u2019s\r\nrequests were chosen independently and equiprobably over all pairs of\r\nindices.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 04.06.2020 18:55:22       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n\nusing namespace __gnu_pbds;\n\ntypedef int tp;\ntypedef tree<tp,null_type,less<tp>,rb_tree_tag,tree_order_statistics_node_update> pbds;\n// tp a;\n// T.insert(a), T.erase(a), T.size()\n// T.order_of_key(a) -- number of elements strictly less than a\n// *T.find_by_order(k) -- k-th element in increasing order\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nstruct Node {\n  int parent;\n  int from;\n  int to;\n  int k;\n  long long inv;\n  long long pairs;\n  pbds L;\n  pbds R;\n};\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n  }\n  vector<int> w(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    cin >> w[i];\n    --w[i];\n  }\n  vector<int> ids(n - 1);\n  iota(ids.begin(), ids.end(), 0);\n  SparseTable<int> st(ids, [&](int i, int j) { return (w[i] < w[j] ? i : j); });\n  vector<Node> nodes(n - 1);\n  {\n    Node& node = nodes[0];\n    node.parent = -1;\n    node.from = 0;\n    node.to = n - 1;\n    node.k = -1;\n    node.inv = 0;\n    node.pairs = 0;\n  }\n  vector<int> leaf(n);\n  long long ans = 0;\n  long long total = 0;\n  int ptr = 1;\n  for (int b = 0; b < n - 1; b++) {\n    Node& node = nodes[b];\n//    debug(b, node.from, node.to);\n    assert(node.from < node.to);\n    node.k = st.get(node.from, node.to - 1);\n    for (int i = node.k + 1; i <= node.to; i++) {\n      node.R.insert(p[i]);\n    }\n    for (int i = node.from; i <= node.k; i++) {\n      node.inv += node.R.order_of_key(p[i]);\n      node.L.insert(p[i]);\n    }\n    total += (int) node.L.size();\n    total += (int) node.R.size();\n    node.pairs = (long long) (node.to - node.k) * (node.k - node.from + 1);\n//    debug(node.from, node.to, node.k, node.inv, node.pairs);\n    ans += min(node.inv, node.pairs - node.inv);\n    if (node.from == node.k) {\n      leaf[node.from] = b;\n    } else {\n      Node& new_node = nodes[ptr];\n      ptr += 1;\n      new_node.parent = b;\n      new_node.from = node.from;\n      new_node.to = node.k;\n      new_node.k = -1;\n      new_node.inv = 0;\n      new_node.pairs = 0;\n    }\n    if (node.k + 1 == node.to) {\n      leaf[node.to] = b;\n    } else {\n      Node& new_node = nodes[ptr];\n      ptr += 1;\n      new_node.parent = b;\n      new_node.from = node.k + 1;\n      new_node.to = node.to;\n      new_node.k = -1;\n      new_node.inv = 0;\n      new_node.pairs = 0;\n    }\n  }\n//  debug(\"done\");\n  debug(ans, clock(), nodes.size(), total);\n//  debug(leaf);\n  auto Modify = [&](int i, int val) {\n    int b = leaf[i];\n    while (b >= 0) {\n      Node& node = nodes[b];\n      ans -= min(node.inv, node.pairs - node.inv);\n      if (i <= node.k) {\n        node.inv -= node.R.order_of_key(p[i]);\n        node.inv += node.R.order_of_key(val);\n        node.L.erase(p[i]);\n        node.L.insert(val);\n      } else {\n        node.inv += node.L.order_of_key(p[i]);\n        node.inv -= node.L.order_of_key(val);\n        node.R.erase(p[i]);\n        node.R.insert(val);\n      }\n      ans += min(node.inv, node.pairs - node.inv);\n      b = node.parent;\n    }\n    p[i] = val;\n  };\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    int px = p[x];\n    int py = p[y];\n    Modify(x, -1);\n    Modify(y, px);\n    Modify(x, py);\n    cout << ans << '\\n';\n  }\n  debug(clock());\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "implementation", "math"], "dificulty": "3300", "interactive": false}