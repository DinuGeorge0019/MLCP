{"link": "https://codeforces.com//contest/512/problem/E", "problemId": "21646", "problem_idx": "E", "shortId": "512E", "contest_number": "512", "problem_submissions": {"E": [9689055, 9689637, 9689329, 9688006, 9687653, 9689489, 9689150, 9686860, 9690989, 9687876], "D": [9687125, 9687387, 9685060, 9686450, 9688310, 9687526, 9848172, 9687098, 9689725], "C": [9684294, 9683675, 9686457, 9682885, 9681860, 9683241, 9686129, 9685822, 9688905, 9683891, 9686124, 9685967, 9682813, 9687765, 9684696, 9686605, 9690364, 9690022], "B": [9681311, 9680720, 9682911, 9680295, 9679957, 9680851, 9679895, 9681573, 9681772, 9685086, 9682711, 9681029, 9681643, 9680950, 9691594, 9680058], "A": [9679078, 9679241, 9683617, 9678600, 9678498, 9679465, 9682231, 9681794, 9679166, 9679612, 9683011, 9689408, 9679816, 9678578, 9678585, 9679972, 9678357]}, "name": "E. Fox And Polygon", "statement": "Fox Ciel just designed a puzzle game called \"Polygon\"! It is played\r\nusing triangulations of a regular -edge polygon. The goal is to\r\ntransform one to another by some tricky rules. of an -edge poylgon is a\r\nset of diagonals satisfying the condition that no two diagonals share a\r\ncommon internal point.For example, the initial state of the game may\r\nlook like (a) in above figure. And your goal may look like (c). In each\r\nstep you can choose a diagonal inside the polygon (but not the one of\r\nedges of the polygon) and this diagonal. Suppose you are going to a\r\ndiagonal . There always exist two triangles sharing as a side, let\u2019s\r\ndenote them as and . As a result of this operation, the diagonal is\r\nreplaced by a diagonal . It can be easily proven that after operation\r\nresulting set of diagonals is still a of the polygon.So in order to\r\nsolve above case, you may first diagonal , it will be replaced by\r\ndiagonal . Then you diagonal and get figure (c) as result.Ciel just\r\nproved that for any starting and destination triangulations this game\r\nhas a solution. She wants you to solve it in no more than steps for any\r\npuzzle satisfying .\r\n", "solutions": ["#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T>\nbool uin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool uax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint m[1000][1000];\n\nvoid invert(int a, int b, int c, int d, vector<pii> &res, bool inv) {\n    assert(m[a][b] && m[a][c] && m[b][c] && m[a][d] && m[b][d] && !m[c][d]);\n    m[a][b] = m[b][a] = 0;\n    m[c][d] = m[d][c] = 1;\n    res.pb(inv ? mp(c, d) : mp(a, b));\n}\n\nvoid dfs(int l, int r, vector<pii> &res, bool inv) {\n    if (r - l <= 1) return;\n    vi a;\n    for (int i = r; i > l; --i) {\n        if (m[l][i]) a.pb(i);\n    }\n    for (int i = 0; i + 1 < a.size(); ++i) {\n        invert(l, a[i], 0, a[i + 1], res, inv);\n        dfs(a[i + 1], a[i], res, inv);\n    }\n    dfs(a.back(), r, res, inv);\n}\n\nvector<pii> solve(vector<pii> tr, bool inv) {\n    int N = tr.size() + 3;\n    forn(i, N) forn(j, N) m[i][j] = 0;\n    forn(i, N) m[i][(i + 1) % N] = m[(i + 1) % N][i] = 1;\n    forn(i, tr.size()) {\n        --tr[i].fi, --tr[i].se;\n        m[tr[i].fi][tr[i].se] = m[tr[i].se][tr[i].fi] = 1;\n    }\n    vector<pii> res;\n    dfs(1, N - 1, res, inv);\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    vector<pii> tr1(N - 3), tr2(N - 3);\n    forn(i, N - 3) cin >> tr1[i].fi >> tr1[i].se;\n    forn(i, N - 3) cin >> tr2[i].fi >> tr2[i].se;\n    vector<pii> res1 = solve(tr1, false);\n    vector<pii> res2 = solve(tr2, true);\n    reverse(all(res2));\n    res1.insert(res1.end(), all(res2));\n    cout << res1.size() << '\\n';\n    for (pii p: res1) {\n        cout << p.fi + 1 << ' ' << p.se + 1 << '\\n';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "divide and conquer"], "dificulty": "2900", "interactive": false}