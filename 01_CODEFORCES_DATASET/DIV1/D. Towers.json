{
    "link": "https://codeforces.com//contest/229/problem/D",
    "problemId": "1893",
    "problem_idx": "D",
    "shortId": "229D",
    "contest_number": "229",
    "problem_submissions": {
        "E": [
            2282826,
            2281727,
            2285054,
            2283563,
            2285346,
            2285087,
            2285039,
            2284707,
            2406707,
            2284567,
            2285340,
            2286716
        ],
        "D": [
            2279442,
            2279718,
            2280046,
            2280344,
            2282950,
            2281962,
            2282776,
            2282602,
            2281974,
            2283282,
            2282070,
            2283551,
            2282480,
            2282427,
            2282188,
            2281610,
            2283171
        ],
        "B": [
            2276814,
            2277758,
            2276080,
            2280606,
            2279078,
            2281037,
            2280028,
            2279270,
            2278615,
            2280162,
            2280493,
            2279459,
            2280601,
            2279970,
            2281238
        ],
        "C": [
            2274858,
            2273646,
            2277243,
            2277231,
            2276597,
            2280255,
            2276975,
            2277162,
            2279947,
            2277171,
            2276063,
            2277931,
            2277827,
            2275487,
            2283199,
            2278070
        ],
        "A": [
            2274032,
            2286414,
            2274348,
            2275349,
            2275192,
            2274716,
            2276132,
            2302218,
            2286476,
            2274187,
            2274224,
            2275364,
            2275231,
            2276851,
            2274395,
            2275579
        ]
    },
    "name": "D. Towers",
    "statement": "The city of D consists of towers, built consecutively on a straight\r\nline. The height of the tower that goes -th (from left to right) in the\r\nsequence equals . The city mayor decided to rebuild the city to make it\r\n. In a city all towers are are arranged in non-descending order of their\r\nheight from left to right.The rebuilding consists of performing several\r\n(perhaps zero) operations. An operation constitutes using a crane to\r\ntake any tower and put it altogether on the top of some other\r\nneighboring tower. In other words, we can take the tower that stands -th\r\nand put it on the top of either the -th tower (if it exists), or the -th\r\ntower (of it exists). The height of the resulting tower equals the sum\r\nof heights of the two towers that were put together. After that the two\r\ntowers can’t be split by any means, but more similar operations can be\r\nperformed on the resulting tower. Note that after each operation the\r\ntotal number of towers on the straight line decreases by 1.Help the\r\nmayor determine the minimum number of operations required to make the\r\ncity beautiful.\r\n",
    "solutions": [
        "/*\n * d.cpp\n *\n *  Created on: 2012-10-1\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_N = 5000 + 10;\nconst int INF = ~0U >> 1;\n\nint h[MAX_N], n, S[MAX_N];\nint dp[MAX_N][MAX_N]; //k,i\nint val[MAX_N];\nint perm[MAX_N];\n\nbool cmp(int a, int b) {\n\treturn val[a] < val[b];\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> h[i];\n\t}\n//\tn = 5000;\n//\tfor (int i = 0; i < n; ++i) {\n//\t\th[i] = i + 1;\n//\t}\n\tpartial_sum(h, h + n, S);\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tdp[1][i] = S[i];\n\t}\n\tfor (int k = 2; k <= n; ++k) {\n\t\t//dpk,j+Sj\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (dp[k - 1][j] != INF) {\n\t\t\t\tval[j] = dp[k - 1][j] + S[j];\n\t\t\t\tperm[cnt++] = j;\n\t\t\t}\n\t\t}\n\t\tsort(perm, perm + cnt, cmp);\n\t\tint at = 0, mx = -1;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\twhile (at < cnt && val[perm[at]] <= S[j]) {\n\t\t\t\tmx = max(mx, perm[at]);\n\t\t\t\t++at;\n\t\t\t}\n\t\t\tif (mx == -1) {\n\t\t\t\tdp[k][j] = INF;\n\t\t\t} else {\n\t\t\t\tdp[k][j] = S[j] - S[mx];\n\t\t\t}\n\t\t}\n\t\tif (dp[k][n - 1] == INF)\n\t\t\tbreak;\n\t}\n\tfor (int i = n; i >= 0; --i) {\n\t\tif (dp[i][n - 1] != INF) {\n\t\t\tcout << n - i << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Towers.json",
    "editorial_link": "https://codeforces.com//blog/entry/5437",
    "editorial": "Letâs calculate the dynamics d[i][k] the minimal possible height of the\r\nlast tower that we can obtain by merging the first left towers into at\r\nleast towers. Assume we already have calculated the dynamicsâ values for\r\nthe first towers. Now we iterate over the all possible tower intervals ;\r\nsay the sum in the pending interval is equal to . Now we find the\r\ngreatest such that d[i][k] is not greater than . Then we update the\r\nvalue of d[j][k+1] to the minimum of and d[j][k+1]. Notice that when\r\nincreases the values d[i][k] do not decrease. Because of that we can\r\niterate over intervals in the decreasing value of , and corresponding\r\ncan be found using a single pointer over values of d[i][k]. When we\r\narrive in the position during the dynamics, some of the d[j][k] values\r\nare updated, but some are still not. Using the same observation that\r\nalong with the increasing of the values d[j][k] do not decrease as well,\r\nwe can make a single run over the values of in the decreasing order and\r\nupdate the dynamicsâ values as follows: d[j][k] := min(d[j][k],\r\nd[j][k+1]). This is done in the beginning of the dynamicsâ iteration. In\r\nthe end we can find the greatest for which there exists an answer among\r\nthe values of d[n][k]. The answer to the problem then is . The\r\ncomplexity of the solution is . Sample solution:\r\nhttp://pastie.org/4897515 (archived copy)\r\n",
    "hint": []
}