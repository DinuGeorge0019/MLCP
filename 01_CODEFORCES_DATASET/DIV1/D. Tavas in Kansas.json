{"link": "https://codeforces.com//contest/536/problem/D", "problemId": "26045", "problem_idx": "D", "shortId": "536D", "contest_number": "536", "problem_submissions": {"A": [10719921, 10706737, 10707689, 10711529, 10709676, 10707375, 10709573, 10707885, 10708720, 10706564, 10708318, 10709355, 10713459, 10725217, 10725216, 10725186, 10708292, 10706905, 10741377, 10713738], "B": [10718101, 10710644, 10709758, 10712675, 10707296, 10709351, 10713281, 10710208, 10710709, 10710095, 10711429, 10711411, 10707838, 10710289, 10713790, 10709325, 10709558], "E": [10716637, 10733077, 10733033, 10731562, 10741189], "C": [10709726, 10713480, 10715583, 10715941, 10717945, 10721487, 10717235, 10716651, 10717759, 10716150, 10716761, 10720841, 10718866], "D": [10717797, 10717420, 10719832, 10715603, 10716972, 10718818, 10719396, 10719946, 10724775, 10717671]}, "name": "D. Tavas in Kansas", "statement": "Tavas lives in Kansas. Kansas has cities numbered from 1 to connected\r\nwith bidirectional roads. We can travel from any city to any other city\r\nvia these roads. Kansas is as strange as Tavas. So there may be a road\r\nbetween a city and itself or more than one road between two cities.Tavas\r\ninvented a game and called it \"Dashti\". He wants to play Dashti with his\r\ngirlfriends, Nafas.In this game, they assign an arbitrary integer value\r\nto each city of Kansas. The value of -th city equals to .During the\r\ngame, Tavas is in city and Nafas is in city . They play in turn and\r\nTavas goes first. A player in his/her turn, must choose a non-negative\r\ninteger and his/her score increases by the sum of values of all cities\r\nwith (shortest) distance no more than from his/her city. Each city may\r\nbe used once, or in the other words, after first time a player gets\r\nscore from a city, city score becomes zero.There is an additional rule:\r\nthe player must choose such that he/she gets the point of at least one\r\ncity that was not used before. Note that city may initially have value\r\n0, such city isn\u2019t considered as been used at the beginning of the game,\r\ni. e. each player may use it to fullfill this rule.The game ends when\r\nnobody can make a move.A player\u2019s score is the sum of the points he/she\r\nearned during the game. The winner is the player with greater score, or\r\nthere is a draw if players score the same value. Both players start game\r\nwith zero points. If Tavas wins, he\u2019ll break his girlfriend\u2019s heart, and\r\nif Nafas wins, Tavas will cry. But if their scores are equal, they\u2019ll be\r\nhappy and Tavas will give Nafas flowers.They\u2019re not too emotional after\r\nall, so they\u2019ll play optimally. Your task is to tell Tavas what\u2019s going\r\nto happen after the game ends.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<60)\n\nint N,S,T;\nll graph[2010][2010];\nll p[2010];\nll dist[2010];\nbool used[2010];\nll dists[2010],distt[2010];\n\nvector <pair <ll, int> > vs,vt; // dist, id\nint ranks[2010],rankt[2010];\nll dps[2010][2010],dpt[2010][2010];\nbool new_s[2010][2010],new_t[2010][2010];\n\nll calc_s(int x, int y){\n    if(x == N) return 0;\n    if(!new_s[x][y]) return dps[x+1][y];\n    \n    ll next_cost = p[vs[x].second];\n    ll ans = next_cost + dps[x+1][y];\n    \n    for(int i=x+1;i<=N;i++){\n        ans = max(ans, next_cost - dpt[i][y]);\n        if(new_s[i][y]) break;\n    }\n    \n    return ans;\n}\n\nll calc_t(int x, int y){\n    if(y == N) return 0;\n    if(!new_t[x][y]) return dpt[x][y+1];\n    \n    ll next_cost = p[vt[y].second];\n    ll ans = next_cost + dpt[x][y+1];\n    \n    for(int i=y+1;i<=N;i++){\n        ans = max(ans, next_cost - dps[x][i]);\n        if(new_t[x][i]) break;\n    }\n    \n    return ans;\n}\n\nvoid main2(void){\n    int i,j;\n    \n    REP(i,N) REP(j,N+1) new_s[i][j] = (rankt[vs[i].second] >= j);\n    REP(i,N+1) REP(j,N) new_t[i][j] = (ranks[vt[j].second] >= i);\n    \n    for(i=N;i>=0;i--) for(j=N;j>=0;j--){\n        dps[i][j] = calc_s(i, j);\n        dpt[i][j] = calc_t(i, j);\n    }\n    \n    ll ans = dps[0][0];\n    if(ans > 0) cout << \"Break a heart\" << endl;\n    if(ans < 0) cout << \"Cry\" << endl;\n    if(ans == 0) cout << \"Flowers\" << endl;\n}\n\nvoid get_dist(int s){\n    int i,j;\n    \n    REP(i,N) dist[i] = INF;\n    REP(i,N) used[i] = false;\n    dist[s] = 0;\n    \n    REP(i,N){\n        int x = -1;\n        REP(j,N) if(!used[j] && (x == -1 || dist[j] < dist[x])) x = j;\n        used[x] = true;\n        REP(j,N) dist[j] = min(dist[j], dist[x] + graph[x][j]);\n    }\n}\n\nint main(void){\n    int M,i,j;\n    \n    cin >> N >> M >> S >> T;\n    S--; T--;\n    REP(i,N){\n        int tmp;\n        scanf(\"%d\", &tmp);\n        p[i] = tmp;\n    }\n    REP(i,N) REP(j,N) if(i != j) graph[i][j] = INF;\n    REP(i,M){\n        int u,v,w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        u--; v--;\n        graph[u][v] = min(graph[u][v], (ll)w);\n        graph[v][u] = min(graph[v][u], (ll)w);\n    }\n    \n    get_dist(S);\n    REP(i,N) dists[i] = dist[i];\n    get_dist(T);\n    REP(i,N) distt[i] = dist[i];\n    \n    REP(i,N) vs.push_back(make_pair(dists[i], i));\n    sort(vs.begin(),vs.end());\n    REP(i,N) vt.push_back(make_pair(distt[i], i));\n    sort(vt.begin(),vt.end());\n    \n    REP(i,N) ranks[vs[i].second] = i;\n    REP(i,N) rankt[vt[i].second] = i;\n    \n    main2();\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "games"], "dificulty": "2900", "interactive": false}