{
    "link": "https://codeforces.com//contest/536/problem/D",
    "problemId": "26045",
    "problem_idx": "D",
    "shortId": "536D",
    "contest_number": "536",
    "problem_submissions": {
        "A": [
            10719921,
            10706737,
            10707689,
            10711529,
            10709676,
            10707375,
            10709573,
            10707885,
            10708720,
            10706564,
            10708318,
            10709355,
            10713459,
            10725217,
            10725216,
            10725186,
            10708292,
            10706905,
            10741377,
            10713738
        ],
        "B": [
            10718101,
            10710644,
            10709758,
            10712675,
            10707296,
            10709351,
            10713281,
            10710208,
            10710709,
            10710095,
            10711429,
            10711411,
            10707838,
            10710289,
            10713790,
            10709325,
            10709558
        ],
        "E": [
            10716637,
            10733077,
            10733033,
            10731562,
            10741189
        ],
        "C": [
            10709726,
            10713480,
            10715583,
            10715941,
            10717945,
            10721487,
            10717235,
            10716651,
            10717759,
            10716150,
            10716761,
            10720841,
            10718866
        ],
        "D": [
            10717797,
            10717420,
            10719832,
            10715603,
            10716972,
            10718818,
            10719396,
            10719946,
            10724775,
            10717671
        ]
    },
    "name": "D. Tavas in Kansas",
    "statement": "Tavas lives in Kansas. Kansas has cities numbered from 1 to connected\r\nwith bidirectional roads. We can travel from any city to any other city\r\nvia these roads. Kansas is as strange as Tavas. So there may be a road\r\nbetween a city and itself or more than one road between two cities.Tavas\r\ninvented a game and called it \"Dashti\". He wants to play Dashti with his\r\ngirlfriends, Nafas.In this game, they assign an arbitrary integer value\r\nto each city of Kansas. The value of -th city equals to .During the\r\ngame, Tavas is in city and Nafas is in city . They play in turn and\r\nTavas goes first. A player in his/her turn, must choose a non-negative\r\ninteger and his/her score increases by the sum of values of all cities\r\nwith (shortest) distance no more than from his/her city. Each city may\r\nbe used once, or in the other words, after first time a player gets\r\nscore from a city, city score becomes zero.There is an additional rule:\r\nthe player must choose such that he/she gets the point of at least one\r\ncity that was not used before. Note that city may initially have value\r\n0, such city isn’t considered as been used at the beginning of the game,\r\ni. e. each player may use it to fullfill this rule.The game ends when\r\nnobody can make a move.A player’s score is the sum of the points he/she\r\nearned during the game. The winner is the player with greater score, or\r\nthere is a draw if players score the same value. Both players start game\r\nwith zero points. If Tavas wins, he’ll break his girlfriend’s heart, and\r\nif Nafas wins, Tavas will cry. But if their scores are equal, they’ll be\r\nhappy and Tavas will give Nafas flowers.They’re not too emotional after\r\nall, so they’ll play optimally. Your task is to tell Tavas what’s going\r\nto happen after the game ends.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<60)\n\nint N,S,T;\nll graph[2010][2010];\nll p[2010];\nll dist[2010];\nbool used[2010];\nll dists[2010],distt[2010];\n\nvector <pair <ll, int> > vs,vt; // dist, id\nint ranks[2010],rankt[2010];\nll dps[2010][2010],dpt[2010][2010];\nbool new_s[2010][2010],new_t[2010][2010];\n\nll calc_s(int x, int y){\n    if(x == N) return 0;\n    if(!new_s[x][y]) return dps[x+1][y];\n    \n    ll next_cost = p[vs[x].second];\n    ll ans = next_cost + dps[x+1][y];\n    \n    for(int i=x+1;i<=N;i++){\n        ans = max(ans, next_cost - dpt[i][y]);\n        if(new_s[i][y]) break;\n    }\n    \n    return ans;\n}\n\nll calc_t(int x, int y){\n    if(y == N) return 0;\n    if(!new_t[x][y]) return dpt[x][y+1];\n    \n    ll next_cost = p[vt[y].second];\n    ll ans = next_cost + dpt[x][y+1];\n    \n    for(int i=y+1;i<=N;i++){\n        ans = max(ans, next_cost - dps[x][i]);\n        if(new_t[x][i]) break;\n    }\n    \n    return ans;\n}\n\nvoid main2(void){\n    int i,j;\n    \n    REP(i,N) REP(j,N+1) new_s[i][j] = (rankt[vs[i].second] >= j);\n    REP(i,N+1) REP(j,N) new_t[i][j] = (ranks[vt[j].second] >= i);\n    \n    for(i=N;i>=0;i--) for(j=N;j>=0;j--){\n        dps[i][j] = calc_s(i, j);\n        dpt[i][j] = calc_t(i, j);\n    }\n    \n    ll ans = dps[0][0];\n    if(ans > 0) cout << \"Break a heart\" << endl;\n    if(ans < 0) cout << \"Cry\" << endl;\n    if(ans == 0) cout << \"Flowers\" << endl;\n}\n\nvoid get_dist(int s){\n    int i,j;\n    \n    REP(i,N) dist[i] = INF;\n    REP(i,N) used[i] = false;\n    dist[s] = 0;\n    \n    REP(i,N){\n        int x = -1;\n        REP(j,N) if(!used[j] && (x == -1 || dist[j] < dist[x])) x = j;\n        used[x] = true;\n        REP(j,N) dist[j] = min(dist[j], dist[x] + graph[x][j]);\n    }\n}\n\nint main(void){\n    int M,i,j;\n    \n    cin >> N >> M >> S >> T;\n    S--; T--;\n    REP(i,N){\n        int tmp;\n        scanf(\"%d\", &tmp);\n        p[i] = tmp;\n    }\n    REP(i,N) REP(j,N) if(i != j) graph[i][j] = INF;\n    REP(i,M){\n        int u,v,w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        u--; v--;\n        graph[u][v] = min(graph[u][v], (ll)w);\n        graph[v][u] = min(graph[v][u], (ll)w);\n    }\n    \n    get_dist(S);\n    REP(i,N) dists[i] = dist[i];\n    get_dist(T);\n    REP(i,N) distt[i] = dist[i];\n    \n    REP(i,N) vs.push_back(make_pair(dists[i], i));\n    sort(vs.begin(),vs.end());\n    REP(i,N) vt.push_back(make_pair(distt[i], i));\n    sort(vt.begin(),vt.end());\n    \n    REP(i,N) ranks[vs[i].second] = i;\n    REP(i,N) rankt[vt[i].second] = i;\n    \n    main2();\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Tavas in Kansas.json",
    "editorial_link": "https://codeforces.com//blog/entry/17401",
    "editorial": "For each vertex , put a point with its point (score) in the Cartesian\r\nplane. The first player in his/her turn chooses a vertical line and\r\nerases all the points on its left side. Second player in his/her turn\r\nchooses a horizontal line and erases all the point below it. Each player\r\ntries to maximize his/her score. Obviously, each time a player chooses a\r\nline on the right/upper side of his/her last choice. Imagine that there\r\nare different components and different components among all these lines.\r\nSo, we can show each state before the game ends with a pair ( It means\r\nthat in this state a point is not erased yet if and only if and ). So,\r\nusing dp, () is the maximum score of player in state and it s player s\r\nturn. So, consider is the sum of the scores of all valid points in state\r\nand is the amount of them. So, If then, (). Otherwise (). So we need two\r\nbackward fors for our dp and another for on . So, now the only thing\r\nthat matters is updating the dp. For this purpose, we need two more\r\narrays and . the minimum value of pairs and minimum value of pairs such\r\nthat in the states we ve seen so far. Similarly, the minimum value of\r\npairs and minimum value of pairs such that in the states we ve seen so\r\nfar. Now updating dp is pretty easy : . . And updating and is super\r\neasy. Now, let and be the sum of scores of all points. So, the score of\r\nfirst player is and the second one is . Time complexity: Code by\r\nsobhan.miryoosefi Another Code by Haghani Java Code by Zlobober\r\n",
    "hint": []
}