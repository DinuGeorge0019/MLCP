{
    "link": "https://codeforces.com//contest/788/problem/D",
    "problemId": "100724",
    "problem_idx": "D",
    "shortId": "788D",
    "contest_number": "788",
    "problem_submissions": {
        "E": [
            25924862,
            25925377,
            25915904,
            25922582,
            25915050,
            25918684,
            25941153,
            25921354,
            25925269,
            25935314,
            25926533,
            25926046,
            25936552,
            25927749,
            25926831,
            25919133,
            25921191
        ],
        "D": [
            25915542,
            25915181,
            25939395,
            25930075,
            25941576,
            25921672,
            25929951,
            25917640,
            25923984,
            26061916,
            26104610,
            25928092,
            25925001,
            25924944,
            26043257
        ],
        "C": [
            25904961,
            25906051,
            25905059,
            25908402,
            25906489,
            25909800,
            25905943,
            25913627,
            25910389,
            25907305,
            25913724,
            25911198,
            25913363,
            25908585,
            25910198,
            25909085,
            25915912,
            25913369,
            25907071,
            25907012
        ],
        "B": [
            25903079,
            25903720,
            25902453,
            25904332,
            25903705,
            25904849,
            25903086,
            25902909,
            25905715,
            25902462,
            25905159,
            25905547,
            25906945,
            25904624,
            25903809,
            25910532,
            25906509,
            25927693,
            25946077
        ],
        "A": [
            25900169,
            25901048,
            25900244,
            25901169,
            25900572,
            25900694,
            25900718,
            25900816,
            25901339,
            25905048,
            25900137,
            25900587,
            25901139,
            25902041,
            25900581,
            25899979,
            25900864,
            25900329,
            25900280,
            25900541
        ]
    },
    "name": "D. Finding lines",
    "statement": "After some programming contest Roma decided to try himself in tourism.\r\nHis home country Uzhlyandia is a Cartesian plane. He wants to walk along\r\neach of the Main Straight Lines in Uzhlyandia. It is known that each of\r\nthese lines is a straight line parallel to one of the axes (i.e. it is\r\ndescribed with the equation or , where is integer called the coordinate\r\nof this line).Roma lost his own map, so he should find out the\r\ncoordinates of all lines at first. Uncle Anton agreed to help him, using\r\nthe following rules: Initially Roma doesn\u2019t know the number of vertical\r\nand horizontal lines and their coordinates; Roma can announce integer\r\ncoordinates of some point in Uzhlandia, and Anton then will tell him the\r\nminimum among the distances from the chosen point to each of the lines.\r\nHowever, since the coordinates of the lines don\u2019t exceed by absolute\r\nvalue, Roma can\u2019t choose a point with coordinates exceeding by absolute\r\nvalue. Uncle Anton is in a hurry to the UOI (Uzhlandian Olympiad in\r\nInformatics), so he can only answer no more than questions.The problem\r\nis that Roma doesn\u2019t know how to find out the coordinates of the lines.\r\nWrite a program that plays Roma\u2019s role and finds the coordinates.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxc = (int) 1e8;\n\nint rot;\nint check(int x, int y) {\n  if (rot) {\n    swap(x, y);\n  }\n  assert(abs(x) <= maxc && abs(y) <= maxc);\n  printf(\"0 %d %d\\n\", x, y);\n  fflush(stdout);\n  int res;\n  assert(scanf(\"%d\", &res) == 1);\n  assert(res >= 0);\n  return res;\n}\n\nset<int> xs, ys;\n\nset<pair<int, int> > deltay;\n\nconst int K = 9995;\n\nvoid update0(int x, int y) {\n  assert(!xs.count(x));\n  assert(!ys.count(y));\n\n  for (int iter = 0; iter < 3; ++iter) {\n    int cy = rnd(2 * maxc + 1) - maxc;\n    if (check(x, cy)) {\n      auto iter = ys.lower_bound(y);\n      int mx = ((iter == ys.end()) ? maxc : *iter);\n      int mn = -maxc;\n      if (iter != ys.begin()) {\n        --iter;\n        mn = *iter;\n      }\n      deltay.erase(mp(mx - mn, mn));\n      deltay.insert(mp(y - mn, mn));\n      deltay.insert(mp(mx - y, y));\n      ys.insert(y);\n      return;\n    }\n  }\n  xs.insert(x);\n}\n\nvoid update(int x, int y, int got) {\n  assert(got >= 0);\n  if (x - got >= -maxc) {\n    if (check(x - got, y) == 0) {\n      update0(x - got, y);\n      return;\n    }\n  }\n  if (x + got <= maxc) {\n    if (check(x + got, y) == 0) {\n      update0(x + got, y);\n      return;\n    }\n  }\n  if (y - got >= -maxc) {\n    if (check(x, y - got) == 0) {\n      update0(x, y - got);\n      return;\n    }\n  }\n  update0(x, y + got);\n}\n\nvoid solve() {\n  xs.clear(), ys.clear();\n  rot = 0;\n\n  for (int iter = 0; iter < 2; ++iter) {\n    deltay.clear();\n    int lasty = -maxc;\n    for (int y : ys) {\n      deltay.insert(mp(y - lasty, lasty));\n      lasty = y;\n    }\n    deltay.insert(mp(maxc - lasty, lasty));\n\n    int x = -maxc - 1;\n    while (x < maxc) {\n      auto iter = xs.lower_bound(x + 1);\n      if (iter != xs.end() && *iter == x + 1) {\n        ++x;\n        continue;\n      }\n      int delta = K;\n      delta = min(delta, maxc - x);\n      if (iter != xs.end()) {\n        delta = min(delta, (*iter - x) / 2);\n      }\n      assert(delta > 0);\n\n      auto diter = deltay.end();\n      --diter;\n      assert(diter->first >= delta * 2);\n      int y1 = diter->second;\n      int y2 = y1 + diter->first;\n\n      int y = (y1 + y2) / 2;\n\n      int got = check(x + delta, y);\n      if (got >= delta) {\n        x += delta + got - 1;\n        continue;\n      }\n\n      update(x + delta, y, got);\n    }\n\n    swap(xs, ys);\n    rot ^= 1;\n  }\n\n  printf(\"1 %d %d\\n\", sz(xs), sz(ys));\n  {\n    bool was = 0;\n    for (int x : xs) {\n      if (was) {\n        printf(\" \");\n      }\n      printf(\"%d\", x);\n      was = 1;\n    }\n    printf(\"\\n\");\n  }\n  {\n    bool was = 0;\n    for (int x : ys) {\n      if (was) {\n        printf(\" \");\n      }\n      printf(\"%d\", x);\n      was = 1;\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main() {\n  precalc();\n\n  solve();\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "divide and conquer",
        "interactive"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Finding lines.json",
    "editorial_link": "https://codeforces.com//blog/entry/51312",
    "editorial": "First we solve another problem. Let we have points not straight lines,\r\nbut points on one axis. Let , that is, the maximum coordinate. First, we\r\nfind the left and right points. The left is (), and the right one ().\r\nThen we solve the problem recursively. There will be a function that\r\nfinds all points on the segment if and are points. We have already found\r\nthe extreme points, so we can call this function.The function makes a\r\nquery at the center point between and , that is, . If the answer is\r\nequal to the distance to the extreme points, then there are no more\r\npoints between and . If the distance is less, then for one more query we\r\ncan find out the point on the left or right. Let this point , then we\r\nstart and .We introduce a function that checks if there is a vertical\r\nline . We can select a random point in the range and make a query, if\r\nthe answer is a straight line. If , and the maximum , then the error\r\nprobability is , if you querys twice, then .Now we will solve the main\r\ntask. We make a query at the point , we can find out whether the minimum\r\ndistance to the vertical or horizontal line. We introduce the function ,\r\nwhich will find the nearest straight line whose coordinates are greater\r\nthan or , and . How is this solved? If there are no more lines, then for\r\nnon-negative , . Then we can find a minimal power such that . Then we\r\nknow that this applies to either the vertical line , or the horizontal .\r\nWe can find out which one. If, for example, to the vertical one, then we\r\nsolve the problem for .Then we find either all horizontal lines, or all\r\nvertical lines. To find out which straight lines we found, we need to\r\nlook at the last function , namely our \"ray\". If it rests on the\r\nvertical straight , then we find all the vertical ones. And vice\r\nversa.Now how to find other lines. Let\u00e2\u0080\u0099s say we found all the vertical\r\nones. Then we will find the maximum distance between the neighbors,\r\nbetween the first line and , between the last line and , this distance\r\nwill be at least .That is, we search in what position the maximum will\r\nbe reached, if there are no horizontal lines, let it be . Let this be\r\nthe coordinate , we will make queries on the line , starting with ,\r\nending with , with the step . We find all the points whose answer is not\r\nequal to . Then we can divide all these points into \"segments\", that is,\r\na set of points that go successively. For each \"segment\", the minimum\r\ndistance will only apply to horizontal lines, that is, vertical ones\r\nwill not affect in any way. Therefore, each \"segment\" can be solved\r\nindependently, by the method already known to us (assume that there are\r\nno vertical lines).\r\n"
}