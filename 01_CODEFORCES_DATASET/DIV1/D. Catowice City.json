{
    "link": "https://codeforces.com//contest/1239/problem/D",
    "problemId": "445272",
    "problem_idx": "D",
    "shortId": "1239D",
    "contest_number": "1239",
    "problem_submissions": {
        "E": [
            63001388,
            63007812,
            63001212,
            62998603,
            62990662,
            63117343,
            63007827,
            63012207,
            63007702,
            63021047,
            63020870,
            63040886
        ],
        "D": [
            62993444,
            63002135,
            62996508,
            63001623,
            62995711,
            62993045,
            63000352,
            62994034,
            62999922,
            62999498,
            63002761,
            62998053,
            63001594,
            63004252,
            63000233,
            63002463,
            63005010,
            63003977,
            62998357
        ],
        "B": [
            62989194,
            62990960,
            62989442,
            62985984,
            62996888,
            63004499,
            62991996,
            62990441,
            62993848,
            62995834,
            62994077,
            62994574,
            62993602,
            63006960,
            62992838,
            62991953,
            62991668,
            63005078
        ],
        "A": [
            62977858,
            62978636,
            62977879,
            62980136,
            62977536,
            62989410,
            62977583,
            62981078,
            62979832,
            62980911,
            62979401,
            62984325,
            62979180,
            62979930,
            62979559,
            62978773,
            62979723,
            62981340,
            62977762,
            62982272
        ],
        "F": [
            63121011,
            63120329,
            63015127,
            63015060,
            63092303,
            63016718,
            63113841,
            63051142
        ],
        "C": [
            62999891,
            62991092,
            62996408,
            62989929,
            62996641,
            62997220,
            62997894,
            63001762,
            62998162,
            62999500,
            63034189,
            62998511,
            62992701,
            62998753,
            62995987,
            62998509,
            62994268
        ]
    },
    "name": "D. Catowice City",
    "statement": "In the Catowice city next weekend the cat contest will be held. However,\r\nthe jury members and the contestants haven’t been selected yet. There\r\nare n residents and n cats in the Catowice, and each resident has\r\nexactly one cat living in his house. The residents and cats are numbered\r\nwith integers from 1 to n, where the i-th cat is living in the house of\r\ni-th resident.Each Catowice resident is in friendship with several cats,\r\nincluding the one living in his house. In order to conduct a contest, at\r\nleast one jury member is needed and at least one cat contestant is\r\nneeded. Of course, every jury member should know none of the\r\ncontestants. For the contest to be successful, it’s also needed that the\r\nnumber of jury members plus the number of contestants is equal to\r\nn.Please help Catowice residents to select the jury and the contestants\r\nfor the upcoming competition, or determine that it’s impossible to do.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MOD = 1e9+7;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nint n, m;\nvector<int> lis[1000100];\nvector<int> ris[1000100];\nint vis[1000100];\nvector<int>ord;\n\nvoid idfs(int here) {\n    vis[here] = 1;\n    for (int &there : lis[here]){\n        if (vis[there]) continue;\n        idfs(there);\n    }\n    ord.push_back(here);\n}\n\nvector<int> scc[1000100];\nvoid rdfs(int here, int sn) {\n    scc[sn].push_back(here);\n    vis[here] = 2;\n    for (int &there : ris[here]) {\n        if (vis[there]==2) continue;\n        rdfs(there,sn);\n    }\n}\n\nint main() {\n    int tt;\n\n    scanf(\"%d\",&tt);\n    while(tt--) {\n        scanf(\"%d%d\",&n,&m);\n        for (int i=0;i<n;i++) vis[i] = 0;\n        for (int i=0;i<m;i++) {\n            int a, b;\n            scanf(\"%d%d\",&a,&b); --a; --b;\n            if (a!=b) {\n                lis[a].push_back(b);\n                ris[b].push_back(a);\n            }\n        }\n        for (int i=0;i<n;i++) {\n            if (vis[i]) continue;\n            idfs(i);\n        }\n        int p = 0;\n        for (int idx=n-1;idx>=0;idx--) {\n            int i = ord[idx];\n            if (vis[i]==2) continue;\n            rdfs(i,p);\n            p++;\n        }\n        if (p==1) {\n            puts(\"No\");\n        }\n        else {\n            puts(\"Yes\");\n            printf(\"%d %d\\n\",scc[p-1].size(),n-(int)scc[p-1].size());\n            for (int &v : scc[p-1]) printf(\"%d \",v+1);\n            printf(\"\\n\");\n            for (int i=0;i+1<p;i++) {\n                for (int &v :scc[i]) printf(\"%d \",v+1);\n            }\n            printf(\"\\n\");\n        }\n        for (int i=0;i<n;i++) {\n            lis[i].clear();\n            ris[i].clear();\n            scc[i].clear();\n        }\n        ord.clear();\n    }\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "dfs and similar",
        "graph matchings",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Catowice City.json",
    "editorial_link": "https://codeforces.com/blog/entry/70720",
    "editorial": "You are given bipartite graph and a perfect matching in it. You have to\r\nfind independent set of size which doesnât coincide with either of two\r\nparts. Suppose such independent set exists, letâs call it . Also, letâs\r\ncall left part of graph as and right part of graph as . Then define , ,\r\nis set of all nodes which are connected by edges from matching with ,\r\nsimilarly for . Itâs easy to see that . Letâs direct all edges in graph.\r\nEdges from matching will be directed from right to left, and all other\r\nedges will be directed from left to right. Now edges from matching will\r\ndirect from to and from to . Other edges could direct from to , from to\r\nand from to . Observe that edges cannot direct from to , cause it\r\nwouldnât be an independent set otherwise. Itâs easy to see that isnât\r\nreachable from . So, letâs find all strongly connected components (SCC)\r\nin this graph. If thereâs only one such component, answer doesnât exist\r\ndue to the fact that any node of isnât reachable from any node of . If\r\nSCC is only one, any node is reachable from any other node therefore in\r\nthis case either or are empty. If there are at least two SCC, letâs\r\nchoose any source SCC and call it . Consider and define as set of all\r\nnodes in left part which are not connected by edges from matching with .\r\nLetâs proof that if some lies in , then pair of in matching also lies in\r\n. Thatâs obvious since there are no incoming edges in and thereâs edge\r\nfrom to . So, none of nodes from will lay in chosen SCC. Thus wonât be\r\nreachable from and will be an independent set.The only exception is , in\r\nsuch case there are two SCC but answer doesnât exist (cause chosen will\r\nbe empty).\r\n",
    "hint": []
}