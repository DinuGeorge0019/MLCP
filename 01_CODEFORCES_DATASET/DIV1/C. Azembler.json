{"link": "https://codeforces.com//contest/93/problem/C", "problemId": "489", "problem_idx": "C", "shortId": "93C", "contest_number": "93", "problem_submissions": {"A": [521776, 517818, 515968, 521620, 515336, 515494, 515586, 516401, 516364, 515835, 515706, 515699, 516086, 515571, 516451, 515686, 517180, 515890], "C": [521495, 523124, 520751, 518945, 519514, 522564, 518461, 518952, 520378, 523893], "B": [520104, 519620, 517351, 522194, 517866, 516448, 517227, 517424, 518501, 518059, 517716, 516479, 517644, 518282, 517141, 521658, 521081, 517510], "D": [519028, 516572, 521899, 520914, 520442, 521998, 519962, 521491, 519991, 520880, 521627], "E": [517896, 522663, 522642, 521575, 519373, 517632, 518940, 522345, 524441, 519972, 520124, 519740, 523045, 522914, 520561, 1336700]}, "name": "C. Azembler", "statement": "After the Search Ultimate program that searched for strings in a text\r\nfailed, Igor K. got to think: \"Why on Earth does my program work so\r\nslowly?\" As he double-checked his code, he said: \"My code contains no\r\nerrors, yet I know how we will improve Search Ultimate!\" and took a\r\nlarge book from the shelves. The book read \"Azembler. Principally New\r\nApproach\".Having carefully thumbed through the book, Igor K. realised\r\nthat, as it turns out, you can multiply the numbers dozens of times\r\nfaster. \"Search Ultimate will be faster than it has ever been!\" the\r\nfellow shouted happily and set to work.Let us now clarify what Igor\u2019s\r\nidea was. The thing is that the code that was generated by a compiler\r\nwas far from perfect. Standard multiplying does work slower than with\r\nthe trick the book mentioned.The Azembler language operates with 26\r\nregisters (eax, ebx, ..., ezx) and two commands: [] returns the value\r\nlocated in the address . For example, [eax] returns the value that was\r\nlocated in the address, equal to the value in the register eax. lea ,\r\nassigns to the register , indicated as the first operand, the second\r\noperand\u2019s address. Thus, for example, the \"lea ebx, [eax]\" command will\r\nwrite in the ebx register the content of the eax register: first the\r\n[eax] operation will be fulfilled, the result of it will be some value\r\nthat lies in the address written in eax. But we do not need the value\r\nthe next operation will be lea, that will take the [eax] address, i.e.,\r\nthe value in the eax register, and will write it in ebx. On the first\r\nthought the second operation seems meaningless, but as it turns out, it\r\nis acceptable to write the operation as lea ecx, [eax + ebx],lea ecx,\r\n[k*eax]or evenlea ecx, [ebx + k*eax],where k = 1, 2, 4 or 8.As a result,\r\nthe register ecx will be equal to the numbers eax + ebx, k*eax and ebx +\r\nk*eax correspondingly. However, such operation is fulfilled many times,\r\ndozens of times faster that the usual multiplying of numbers. And using\r\nseveral such operations, one can very quickly multiply some number by\r\nsome other one. Of course, instead of eax, ebx and ecx you are allowed\r\nto use any registers.For example, let the eax register contain some\r\nnumber that we should multiply by 41. It takes us 2 lines:lea ebx,\r\n[eax + 4*eax] // now ebx = 5*eaxlea eax, [eax + 8*ebx] // now eax =\r\neax + 8*ebx = 41*eaxIgor K. got interested in the following question:\r\nwhat is the minimum number of lea operations needed to multiply by the\r\ngiven number and how to do it? Your task is to help him.Consider that at\r\nthe initial moment of time eax contains a number that Igor K. was about\r\nto multiply by , and the registers from ebx to ezx contain number 0. At\r\nthe final moment of time the result can be located in any register.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint a[100];\nstring command[100];\n\nstring ex(int id){\n    string ans = \"eax\";\n    ans[1] += id;\n    return ans;\n}\n\nbool dfs(int MAX, int pos, int N){\n    int i,j,k;\n    \n    if(a[pos] > N) return false;\n    if(pos == MAX){\n        if(a[pos] != N) return false;\n        cout << MAX << endl;\n        REP(i,MAX) cout << command[i] << endl;\n        return true;\n    }\n    \n    REP(i,pos+1) for(k=1;k<=8;k*=2){\n        a[pos+1] = a[i] * k;\n        if(a[pos+1] > N) continue;\n        if(pos+1 == MAX && a[pos+1] != N) continue;\n        command[pos] = \"lea \" + ex(pos+1) + \", [\" + (char)('0' + k) + \"*\" + ex(i) + \"]\";\n        if(dfs(MAX,pos+1,N)) return true;\n    }\n    \n    REP(i,pos+1) REP(j,pos+1) for(k=1;k<=8;k*=2){\n        a[pos+1] = a[i] * k + a[j];\n        if(a[pos+1] > N) continue;\n        if(pos+1 == MAX && a[pos+1] != N) continue;\n        command[pos] = \"lea \" + ex(pos+1) + \", [\" + ex(j) + \" + \" + (char)('0' + k) + \"*\" + ex(i) + \"]\";\n        if(dfs(MAX,pos+1,N)) return true;\n    }\n}\n\nint main(void){\n    int N,i;\n    cin >> N;\n    a[0] = 1;\n    for(i=0;;i++) if(dfs(i,0,N)) break;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "implementation"], "dificulty": "2500", "interactive": false}