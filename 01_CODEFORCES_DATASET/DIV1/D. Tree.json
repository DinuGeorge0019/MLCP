{"link": "https://codeforces.com//contest/468/problem/D", "problemId": "13937", "problem_idx": "D", "shortId": "468D", "contest_number": "468", "problem_submissions": {"B": [7871506, 7871511, 7872060, 7872742, 7871156, 7871190, 7873292, 7877835, 7874498, 7874530, 7873260, 7871798, 7873431, 7880646, 7874764, 7872991, 7872224, 7874914, 7872816, 7873434], "A": [7869312, 7868480, 7868920, 7869884, 7868194, 7868219, 7869275, 7872981, 7868801, 7869110, 7869014, 7868639, 7874076, 7868501, 7869672, 7868999, 7869364, 7868817, 7869566, 7868775], "C": [7874970, 7875437, 7876233, 7877737, 7878511, 7880116, 7875038, 7877328, 7876648, 7878979, 7879987, 7876686, 7878460, 7880319, 7881048, 7879895, 7881839], "D": [7884795, 7885524, 7879880]}, "name": "D. Tree", "statement": "Little X has a tree consisting of nodes (they are numbered from to ).\r\nEach edge of the tree has a positive length. Let\u2019s define the distance\r\nbetween two nodes and (we\u2019ll denote it ) as the sum of the lengths of\r\nedges in the shortest path between and . A permutation is a sequence of\r\ndistinct integers . Little X wants to find a permutation such that sum\r\nis maximal possible. If there are multiple optimal permutations, he\r\nwants to find the lexicographically smallest one. Help him with the\r\ntask!\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define ford(i,n) for (int i = int(n) - 1; i >= 0; --i)\n#define forv(i,v) for (auto i = v.begin(); i != v.end(); ++i)\n#define forr(i,v) for (auto i = v.end(); i != v.begin() && (--i, 1); )\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T> inline T abs (T x) {return x > T() ? x : -x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\nstruct Input {\n\tint n;\n\tve<pii> e[N];\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n - 1) {\n\t\t\tint x, y, z;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\t--x;\n\t\t\t--y;\n\t\t\te[x].pb(mp(y, z));\n\t\t\te[y].pb(mp(x, z));\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tll ans;\n\tint p[N];\n\n\tvoid write () {\n\t\tcout << ans << endl;\n\t\tforn (i, n) {\n\t\t\tif (i) {\n\t\t\t\tprintf(\" \");\n\t\t\t}\n\t\t\tprintf(\"%d\", p[i] + 1);\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\tvirtual void solve () {}\n\t\n\tvirtual void clear () {\n\t\t*this = Data();\n\t}\n};\n\nstruct Solution: Data {\n\tint cnt[N];\n\n\tvoid dfs0 (int v, int pr) {\n\t\tcnt[v] = 1;\n\t\tforn (i, sz(e[v])) {\n\t\t\tif (e[v][i].fs != pr) {\n\t\t\t\tdfs0(e[v][i].fs, v);\n\t\t\t\tcnt[v] += cnt[e[v][i].fs];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint root;\n\t\n\tstatic const int D = 300;\n\n\tint num[N];\n\n\tvoid dfs1 (int v, int pr, int c, set<int> &s) {\n\t\tnum[v] = c;\n\t\ts.insert(v);\n\t\tforn (i, sz(e[v])) {\n\t\t\tif (e[v][i].fs != pr) {\n\t\t\t\tdfs1(e[v][i].fs, v, c, s);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve () {\n\t\tdfs0(0, -1);\n\t\tforn (i, n) {\n\t\t\tforn (j, sz(e[i])) {\n\t\t\t\tll s = min(cnt[i], cnt[e[i][j].fs]);\n\t\t\t\tans += min(s, n - s) * e[i][j].sc;\n\t\t\t}\n\t\t}\n\t\troot = 0;\n\t\twhile (1) {\n\t\t\tbool done = 0;\n\t\t\tforn (i, sz(e[root])) {\n\t\t\t\tif (cnt[e[root][i].fs] < cnt[root] && 2 * cnt[e[root][i].fs] > n) {\n\t\t\t\t\troot = e[root][i].fs;\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tve<set<int> > s(sz(e[root]) + 1);\n\t\tnum[root] = sz(e[root]);\n\t\ts.back().insert(root);\n\t\tforn (i, sz(e[root])) {\n\t\t\tdfs1(e[root][i].fs, root, i, s[i]);\n\t\t}\n\t\tve<set<int> > g((sz(s) + D - 1) / D);\n\t\tforn (i, sz(s)) {\n\t\t\tfor (auto j: s[i]) {\n\t\t\t\tg[i / D].insert(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tset<pii> szs;\n\t\tvi ss;\n\t\tforn (i, sz(s)) {\n\t\t\tss.pb((i == sz(s) - 1) ? -2 * N : 2 * sz(s[i]));\n\t\t\tszs.insert(mp(-ss[i], i));\n\t\t}\n\n\t\tint n1 = n;\n\t\tforn (i, n) {\n\t\t\tif (-szs.begin()->fs == n1 && num[i] != szs.begin()->sc) {\n\t\t\t\tp[i] = *s[szs.begin()->sc].begin();\n\t\t\t} else {\n\t\t\t\tp[i] = N;\n\t\t\t\tforn (j, sz(g)) {\n\t\t\t\t\tif (j != num[i] / D || i == root) {\n\t\t\t\t\t\tif (sz(g[j])) {\n\t\t\t\t\t\t\tumn(p[i], *g[j].begin());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tforn (k, min(D, sz(s) - j * D)) {\n\t\t\t\t\t\t\tif (j * D + k != num[i]) {\n\t\t\t\t\t\t\t\tif (sz(s[j * D + k])) {\n\t\t\t\t\t\t\t\t\tumn(p[i], *s[j * D + k].begin());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tszs.erase(mp(-ss[num[i]], num[i]));\n\t\t\tss[num[i]]--;\n\t\t\tszs.insert(mp(-ss[num[i]], num[i]));\n\t\t\tszs.erase(mp(-ss[num[p[i]]], num[p[i]]));\n\t\t\tss[num[p[i]]]--;\n\t\t\tszs.insert(mp(-ss[num[p[i]]], num[p[i]]));\n\t\t\tn1--;\n\t\t\ts[num[p[i]]].erase(p[i]);\n\t\t\tg[num[p[i]] / D].erase(p[i]);\n\t\t}\n\t}\n\t\n\tvoid clear () {\n\t\t*this = Solution();\n\t}\n};\n\nSolution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\twhile (sol.read()) {\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n#else\n\tsol.read();\n\tsol.solve();\n\tsol.write();\n#endif\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["graph matchings"], "dificulty": "3100", "interactive": false}