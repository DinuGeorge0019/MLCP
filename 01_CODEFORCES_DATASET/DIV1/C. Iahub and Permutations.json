{"link": "https://codeforces.com//contest/341/problem/C", "problemId": "3424", "problem_idx": "C", "shortId": "341C", "contest_number": "341", "problem_submissions": {"D": [4376750, 4378780, 4376395, 4376720, 4378230, 4379371, 4379846, 4378978, 4379778, 4378578, 4381466, 4381249, 4379639, 4434623, 4381692, 4380681, 4380927, 4380941, 4449185, 4374777], "C": [4375168, 4374068, 4379294, 4375659, 4375652, 4375871, 4375036, 4378006, 4374746, 4375347, 4374858, 4376054, 4375611, 4377642, 4376535, 4378502, 4380054, 4385371], "B": [4372755, 4372469, 4374229, 4375035, 4374390, 4374268, 4379570, 4373332, 4379590, 4372609, 4373078, 4372906, 4373853, 4373520, 4374372, 4374299, 4376277, 4376672], "A": [4372149, 4371769, 4372926, 4372916, 4383777, 4373604, 4372813, 4371963, 4372756, 4380996, 4371671, 4372384, 4372154, 4458518, 4372373, 4372183, 4373535, 4372955, 4378126, 4376128], "E": [4404432, 4383929, 4395989, 4381763]}, "name": "C. Iahub and Permutations", "statement": "Iahub is so happy about inventing bubble sort graphs that he\u2019s staying\r\nall day long at the office and writing permutations. Iahubina is angry\r\nthat she is no more important for Iahub. When Iahub goes away, Iahubina\r\ncomes to his office and sabotage his research work.The girl finds an\r\nimportant permutation for the research. The permutation contains\r\ndistinct integers , , ..., . She replaces some of permutation elements\r\nwith -1 value as a revenge. When Iahub finds out his important\r\npermutation is broken, he tries to recover it. The only thing he\r\nremembers about the permutation is it didn\u2019t have any fixed point. A\r\nfixed point for a permutation is an element which has value equal to .\r\nYour job is to proof to Iahub that trying to recover it is not a good\r\nidea. Output the number of permutations which could be originally\r\nIahub\u2019s important permutation, modulo ().\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int MOD = 1e9 + 7;\nvoid madd(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nint mmul(int a, int b) { return ll(a) * b % MOD; }\n\nconst int MAXN = 2003;\nint facs[MAXN + 1];\nint dyn[MAXN + 1][MAXN + 1];\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  facs[0] = 1;\n  for (int i = 1; i <= MAXN; i++)\n    facs[i] = mmul(facs[i - 1], i);\n\n  dyn[0][0] = 1;\n  for (int fc = 1; fc <= MAXN; fc++) {\n    dyn[fc][fc] = facs[fc];\n    dyn[fc][0] = mmul(fc - 1, dyn[fc - 1][1]);\n    for (int gc = 1; gc < fc; gc++) {\n      madd(dyn[fc][gc], mmul(gc, dyn[fc - 1][gc - 1]));\n      madd(dyn[fc][gc], mmul(fc - gc, dyn[fc - 1][gc]));\n    }\n  }\n\n  int n;\n  while (scanf(\"%d\", &n) >= 1) {\n    vb wasVal(n, false);\n    vb isFr(n, false);\n    for (int i = 0; i < n; i++) {\n      int x;\n      scanf(\"%d\", &x), x--;\n      if (x < 0) isFr[i] = true;\n      else wasVal[x] = true;\n    }\n    int fc = 0, gc = 0;\n    for (int i = 0; i < n; i++)\n      if (isFr[i]) {\n        fc++;\n        if (wasVal[i]) gc++;\n      }\n    eprintf(\"%d %d\\n\", fc, gc);\n    printf(\"%d\\n\", dyn[fc][gc]);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "math"], "dificulty": "2000", "interactive": false}