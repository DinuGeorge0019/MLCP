{
    "link": "https://codeforces.com//contest/341/problem/C",
    "problemId": "3424",
    "problem_idx": "C",
    "shortId": "341C",
    "contest_number": "341",
    "problem_submissions": {
        "D": [
            4376750,
            4378780,
            4376395,
            4376720,
            4378230,
            4379371,
            4379846,
            4378978,
            4379778,
            4378578,
            4381466,
            4381249,
            4379639,
            4434623,
            4381692,
            4380681,
            4380927,
            4380941,
            4449185,
            4374777
        ],
        "C": [
            4375168,
            4374068,
            4379294,
            4375659,
            4375652,
            4375871,
            4375036,
            4378006,
            4374746,
            4375347,
            4374858,
            4376054,
            4375611,
            4377642,
            4376535,
            4378502,
            4380054,
            4385371
        ],
        "B": [
            4372755,
            4372469,
            4374229,
            4375035,
            4374390,
            4374268,
            4379570,
            4373332,
            4379590,
            4372609,
            4373078,
            4372906,
            4373853,
            4373520,
            4374372,
            4374299,
            4376277,
            4376672
        ],
        "A": [
            4372149,
            4371769,
            4372926,
            4372916,
            4383777,
            4373604,
            4372813,
            4371963,
            4372756,
            4380996,
            4371671,
            4372384,
            4372154,
            4458518,
            4372373,
            4372183,
            4373535,
            4372955,
            4378126,
            4376128
        ],
        "E": [
            4404432,
            4383929,
            4395989,
            4381763
        ]
    },
    "name": "C. Iahub and Permutations",
    "statement": "Iahub is so happy about inventing bubble sort graphs that he\u2019s staying\r\nall day long at the office and writing permutations. Iahubina is angry\r\nthat she is no more important for Iahub. When Iahub goes away, Iahubina\r\ncomes to his office and sabotage his research work.The girl finds an\r\nimportant permutation for the research. The permutation contains\r\ndistinct integers , , ..., . She replaces some of permutation elements\r\nwith -1 value as a revenge. When Iahub finds out his important\r\npermutation is broken, he tries to recover it. The only thing he\r\nremembers about the permutation is it didn\u2019t have any fixed point. A\r\nfixed point for a permutation is an element which has value equal to .\r\nYour job is to proof to Iahub that trying to recover it is not a good\r\nidea. Output the number of permutations which could be originally\r\nIahub\u2019s important permutation, modulo ().\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int MOD = 1e9 + 7;\nvoid madd(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nint mmul(int a, int b) { return ll(a) * b % MOD; }\n\nconst int MAXN = 2003;\nint facs[MAXN + 1];\nint dyn[MAXN + 1][MAXN + 1];\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  facs[0] = 1;\n  for (int i = 1; i <= MAXN; i++)\n    facs[i] = mmul(facs[i - 1], i);\n\n  dyn[0][0] = 1;\n  for (int fc = 1; fc <= MAXN; fc++) {\n    dyn[fc][fc] = facs[fc];\n    dyn[fc][0] = mmul(fc - 1, dyn[fc - 1][1]);\n    for (int gc = 1; gc < fc; gc++) {\n      madd(dyn[fc][gc], mmul(gc, dyn[fc - 1][gc - 1]));\n      madd(dyn[fc][gc], mmul(fc - gc, dyn[fc - 1][gc]));\n    }\n  }\n\n  int n;\n  while (scanf(\"%d\", &n) >= 1) {\n    vb wasVal(n, false);\n    vb isFr(n, false);\n    for (int i = 0; i < n; i++) {\n      int x;\n      scanf(\"%d\", &x), x--;\n      if (x < 0) isFr[i] = true;\n      else wasVal[x] = true;\n    }\n    int fc = 0, gc = 0;\n    for (int i = 0; i < n; i++)\n      if (isFr[i]) {\n        fc++;\n        if (wasVal[i]) gc++;\n      }\n    eprintf(\"%d %d\\n\", fc, gc);\n    printf(\"%d\\n\", dyn[fc][gc]);\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Iahub and Permutations.json",
    "editorial_link": "https://codeforces.com/blog/entry/8755",
    "editorial": "In this task, author's intended solution is an O(N ^ 2) dp. However, during testing Gerald fount a solution using principle of inclusion and exclusion. We've thought to keep both solutions. We're sorry if you say the problem was well-known, but for both me and the author of the task, it was first time we saw it.\n\nDynamic programming solution\n\nAfter reading the sequence, we can find which elements are deleted. Suppose we have in a set D all deleted elements. I'll define from now on a \"free position\" a position which has -1 value, so it needs to be completed with a deleted element.\n\nWe observe that some elements from D can appear on all free positions of permutation without creating a fixed point. The other elements from D can appear in all free positions except one, that will create the fixed point. It's intuitive that those two \"classes\" don't influence in the same way the result, so they need to be treated separated.\n\nSo from here we can get the dp state. Let dp(n, k) = in how many ways can I fill (n + k) free positions, such as n elements from D can be placed anywhere in the free position and the other k elements can be placed in all free positions except one, which will create the fixed point. As we'll prove by the recurrences, we are not interested of the values from elements of D. Instead, we'll interested in their property: if they can(not) appear in all free positions.\n\nIf k = 0, the problem becomes straight-forward. The answer for dp(n, 0) will be n!, as each permutation of (n + 0) = n numbers is valid, because all numbers can appear on all free positions. We can also calculate dp(n, 1). This means we are not allowed to place an element in a position out of (n + 1) free positions. However, we can place it in the other n positions. From now we get n elements which can be placed anywhere in the n free positions left. Hence, dp(n, 1) = n! * n.\n\nWe want to calculate dp(n, k) now, k > 1. Our goal is to reduce the number k, until find something we know how to calculate. That is, when k becomes 0 or 1 problem is solved. Otherwise, we want to reduce the problem to a problem when k becomes 0 or 1. I have two cases. In a first case, I take a number from numbers which can be placed anywhere in order to reduce the numbers which can form fixed points. In the second case, I take a number from those which can form fixed points in order to make the same goal as in the first case. Let's analyze them.\n\nCase 1. Suppose X is the first free position, such as in the set of k numbers there exist one which cannot be placed there (because it will make a fixed point). Obviously, this position exist, otherwise k = 0. Also obviously, this position will need to be completed with a term when having a solution. In this case, I complete position X with one of n numbers. This will make number equal to X from the k numbers set to become a number which can be placed anywhere. So I \"loose\" one number which can be placed anywhere, but I also \"gain\" one. As well, I loose one number which can form a fixed point.\n\nHence dp(n, k) += n * dp(n, k \u0097 1).\n\nCase 2. In this case position X will be completed with one number from the k numbers set. All numbers which can form fixed points can appear there, except number having value equal to X. So there are k \u0097 1 of them. I choose an arbitrary number Y from those k \u0097 1 to place on the position X. This time I \"loose\" two numbers which could form fixed points: X and Y. As well, I \"gain\" one number which can be placed anywhere: X.\n\nHence dp(n, k) += (k \u0097 1) * dp(n + 1, k \u0097 2).\n\nTL;DR\n\ndp[N][0]=N!\n\ndp[N][1]=N*dp[N][0]\n\ndp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2\n\nThis recurrences can be computed by classical dp or by memoization. I'll present DamianS's source, which used memoization. As you can see, it's very short and easy to implement. Link\n\nInclusion and exclusion principle\n\nI'll present here an alternative to the dynamic programming solution. Let's calculate in tot the number of deleted numbers. Also, let's calculate in fixed the maximal number of fixed points a permutation can have. For calculate fixed, let's iterate with an index i each permutation position. We can have a fixed point on position i if element from position i was deleted (ai = -1) and element i does not exist in sequence a. With other words, element i was deleted and now I want to add it back on position i to obtain maximal number of fixed points.\n\nWe iterate now an index i from fixed to 0. Let sol[i] = the number of possible permutations having exactly i fixed points. Obviously, sol[0] is the answer to our problem. Let's introduce a combination  representing in how many ways I can choose k objects out of n. I have list of positions which can be transformed into fix points (they are fixed positions). I need to choose i of them. According to the above definition, I get sol[i] =  . Next, I have to fill tot?-?i positions with remained elements. We'll consider for this moment valid each permutation of not used values. So, sol[i] =  . Where is the problem to this formula?\n\nThe problem is that it's possible, when permuting (tot \u0097 i) remained elements to be added, one (or more) elements to form more (new) fixed points. But if somehow I can exclude (subtract) the wrong choices from sol[i], sol[i] will be calculated correctly. I iterate another index j from i + 1 to fixed. For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j. I'll subtract from sol[i] this value calculated for each j. If I do this, obviously sol[i] will be calculated correctly.\n\nSuppose we fixed a j. We know that exactly sol[j] permutations have j fixed points (as j > i, this value is calculated correctly). Suppose now I fix a permutation having j fixed points. For get the full result, I need to calculate for all sol[j] permutations. Happily, I can multiply result obtained for a single permutation with sol[j] and obtain the result for all permutations having j fixed points. So you have a permutation having j fixed points. The problem reduces to choosing i objects from a total of j. Why? Those i objects chosen are actually the positions considered in sol[i] to be ones having exactly i fixed points. But permutation has j fixed points. Quoting for above, \"For each j, I'll calculate how many permutations I considered in sol[i] having i fixed points but actually they have j\" . This is exactly what algorithm does."
}