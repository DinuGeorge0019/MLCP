{
    "link": "https://codeforces.com//contest/480/problem/D",
    "problemId": "15741",
    "problem_idx": "D",
    "shortId": "480D",
    "contest_number": "480",
    "problem_submissions": {
        "E": [
            8311013,
            8313055,
            8314156,
            8325797,
            8315473,
            8325232,
            11709971,
            8353321
        ],
        "C": [
            8305908,
            8306095,
            8306489,
            8305168,
            8306046,
            8307120,
            8307521,
            8307102,
            8305050,
            8306309,
            8306145,
            8307452,
            8307404,
            8307470,
            8307938,
            8306829,
            8309720,
            8308359
        ],
        "A": [
            8304671,
            8302322,
            8301986,
            8303885,
            8302500,
            8302484,
            8302315,
            8302995,
            8305921,
            8302490,
            8302288,
            8303565,
            8303850,
            8303423,
            8302746,
            8302974,
            8303485,
            8317285
        ],
        "B": [
            8303927,
            8304607,
            8304712,
            8306656,
            8304745,
            8305167,
            8304670,
            8305422,
            8307631,
            8304999,
            8304658,
            8305487,
            8305732,
            8314422,
            8305673,
            8308163,
            8305105,
            8306250
        ],
        "D": [
            8310575,
            8311382,
            8313441,
            8312962,
            8315083,
            8315272,
            8314092,
            8316276,
            8315227,
            8311890,
            8317405,
            8315325,
            8316637
        ]
    },
    "name": "D. Parcels",
    "statement": "Jaroslav owns a small courier service. He has recently got and\r\nintroduced a new system of processing parcels. Each parcel is a box, the\r\nbox has its weight and strength. The system works as follows. It\r\noriginally has an empty platform where you can put boxes by the\r\nfollowing rules: If the platform is empty, then the box is put directly\r\non the platform, otherwise it is put on the topmost box on the platform.\r\nThe total weight of all boxes on the platform cannot exceed the strength\r\nof platform at any time. The strength of any box of the platform at any\r\ntime must be no less than the total weight of the boxes that stand\r\nabove. You can take only the topmost box from the platform.The system\r\nreceives parcels, the -th parcel arrives exactly at time , its weight\r\nand strength are equal to and , respectively. Each parcel has a value of\r\nbourles. However, to obtain this value, the system needs to give the\r\nparcel exactly at time , otherwise Jaroslav will get 0 bourles for it.\r\nThus, Jaroslav can skip any parcel and not put on the platform, formally\r\ndeliver it at time and not get anything for it. Any operation in the\r\nproblem is performed instantly. This means that it is possible to make\r\nseveral operations of receiving and delivering parcels at the same time\r\nand in any order. Please note that the parcel that is delivered at time\r\n, immediately gets outside of the system, and the following activities\r\ntaking place at the same time are made without taking it into\r\nconsideration. Since the system is very complex, and there are a lot of\r\nreceived parcels, Jaroslav asks you to say what maximum amount of money\r\nhe can get using his system.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct box {\n    int in;\n    int out;\n    int w;\n    int s;\n    int v;\n    \n    bool operator<(const box &b) const\n    {\n        if (in != b.in) {\n            return in < b.in;\n        } else {\n            return out > b.out;\n        }\n    }\n};\n\nint dp[500][1001];\nint dp2[501][1000];\nvector <box> v;\n\nint dfs(int x, int y)\n{\n    int i, j;\n    \n    if (x == -1) {\n        int ans = 0, sum = 0;\n        \n        for (i = 0, j = 0; i < v.size(); i++) {\n            int tmp;\n            \n            if (v[i].w > y) continue;\n            \n            while (j <= v[i].in) {\n                sum = max(sum, dp2[500][j]);\n                \n                j++;\n            }\n            \n            tmp = sum + dfs(i, min(y - v[i].w, v[i].s)) + v[i].v;\n            \n            dp2[500][v[i].out] = max(dp2[500][v[i].out], tmp);\n            ans = max(ans, tmp);\n        }\n        \n        return ans;\n    } else {\n        int ans = 0, sum = 0;\n        \n        if (dp[x][y] >= 0) return dp[x][y];\n        \n        for (i = v[x].in; i <= v[x].out; i++) dp2[x][i] = 0;\n        \n        for (i = x + 1, j = v[x].in; i < v.size(); i++) {\n            int tmp;\n            \n            if (v[i].in > v[x].out) break;\n            if (v[i].out > v[x].out || v[i].w > y) continue;\n            \n            while (j <= v[i].in) {\n                sum = max(sum, dp2[x][j]);\n                \n                j++;\n            }\n            \n            tmp = sum + dfs(i, min(y - v[i].w, v[i].s)) + v[i].v;\n            \n            dp2[x][v[i].out] = max(dp2[x][v[i].out], tmp);\n            ans = max(ans, tmp);\n        }\n        \n        return dp[x][y] = ans;\n    }\n}\n\nint main()\n{\n    int n, s, i, j;\n    \n    scanf(\"%d %d\", &n, &s);\n    \n    for (i = 0; i < n; i++) {\n        box b;\n        \n        scanf(\"%d %d %d %d %d\", &b.in, &b.out, &b.w, &b.s, &b.v);\n        \n        v.push_back(b);\n    }\n    \n    sort(v.begin(), v.end());\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j <= s; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    printf(\"%d\\n\", dfs(-1, s));\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Parcels.json",
    "editorial_link": "https://codeforces.com//blog/entry/14351",
    "editorial": "Let s make two observations. First, consider the parcels as time\r\nsegments . It is true that if at some moment of time both parcel and\r\nparcel are on the platform, and is higher than , then . Second, let s\r\nimagine that there are some parcels on the platform. It turns out that\r\nit is enough to know just a single number to be able to decide whether\r\nwe can put another parcel on top of them. Let s denote this value as\r\nresidual strength . For a parcel (or a platform itself) the residual\r\nstrength is it s strength minus the total weight of parcels on top of\r\nit. For a set of parcels, the residual strength is the minimum of\r\nindividual residual strengths. So, we can put another parcel on top if\r\nit s weight does not exceed the residual strength. These observations\r\nlead us to a dynamic programming solution. Let the top parcel at the\r\ngiven moment has number , and the residual strength is . Make this pair\r\nthe state of DP, because it is exactly the original problem, where the\r\nplatform strength is and there are only parcels with . In we will store\r\nthe answer to this instance of the original problem. Which transitions\r\nare there? We can choose a set of parcels such that This choice\r\ncorresponds to the following sequence of actions: first put parcel on\r\nthe top of . This gets us to the state , so we add up the answer for\r\nthis state and the cost of . Then we take away all parcels, including ,\r\nand put the parcel on top of , and so on. As the number of states in DP\r\nis , all transitions should take linear time. It can be achieved by\r\nmaking an inner helper DP. This give a solution in . Note that for\r\nsimplicity the platform can be considered as a parcel too.\r\n"
}