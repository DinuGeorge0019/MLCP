{
    "link": "https://codeforces.com//contest/2006/problem/B",
    "problemId": "2845531",
    "problem_idx": "B",
    "shortId": "2006B",
    "contest_number": "2006",
    "problem_submissions": {
        "F": [
            278838627,
            278834885,
            278839605,
            278842896,
            283040284,
            278849665,
            279479840,
            279030892,
            278872889
        ],
        "E": [
            278816205,
            278815039,
            278825195,
            278819088,
            278823646,
            278824405,
            278834146,
            278833851,
            278836845,
            278834660,
            278831348,
            278835070,
            278824284,
            278835798,
            278834079,
            278836349,
            278834150,
            278840676,
            278837721,
            278840281
        ],
        "D": [
            278802409,
            278805803,
            278813224,
            278825476,
            278809587,
            278813203,
            278814738,
            278815896,
            278817434,
            278818422,
            278823248,
            278822269,
            278830412,
            278825693,
            278818908,
            278819966,
            278823289,
            278817077,
            278823950,
            278818832
        ],
        "C": [
            278788793,
            278798461,
            278801097,
            278797423,
            278800136,
            278800438,
            278797097,
            278802996,
            278798370,
            278802119,
            278807042,
            278803250,
            278809464,
            278800483,
            278808112,
            278808529,
            278813687,
            278799260,
            278808716,
            278807375
        ],
        "B": [
            278783201,
            278791628,
            278792112,
            278787764,
            278787151,
            278789090,
            278788997,
            278795304,
            278790397,
            278793228,
            278796651,
            278795483,
            278796854,
            278787538,
            278797112,
            278796560,
            278796305,
            278792796,
            278798821,
            278792242
        ],
        "A": [
            278774854,
            278780780,
            278783421,
            278777635,
            278777703,
            278778768,
            278777654,
            278780623,
            278781426,
            278784680,
            278779860,
            278783271,
            278779619,
            278776511,
            278786116,
            278783656,
            278783630,
            278778742,
            278777793,
            278783717
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133382",
    "editorial": "The nodes are numbered by dfs order, which tells us the vertex numbers\r\nin one subtree are always consecutive. Letâs consider an edge connecting\r\nvertex and . Suppose the size of the subtree is , so the vertices are\r\nnumbered between . Then for each that , the path between node and is\r\nalways in the subtree, so it doesnât pass the edge. The only two paths\r\nthat passes edge is the path between and , and between and .Letâs\r\ncalculate the maximum value of . First, if all of the weights of its\r\nedges have been determined, then itâs already calculated. Otherwise,\r\nitâs optimal to set one of the edges with undetermined weight with\r\nweight . Then the answer is .How to maintain the process? Each time we\r\nknow the weight of an edge, we specially check whether the weights of\r\nthe two paths that passes this edge are uniquely determined or not. For\r\nall other paths that are not uniquely determined, the contribution of\r\nthe edge is ( is the weight). We can use addition tags to handle\r\nthis.The time complexity is .\r\n",
    "name": "B. Iris and the Tree",
    "statement": "Given a rooted tree with the root at vertex 1. For any vertex i (1 < i\r\nleq n) in the tree, there is an edge connecting vertices i and p_i (1\r\nleq p_i < i), with a weight equal to t_i.Iris does not know the values\r\nof t_i, but she knows that\r\ndisplaystyle\r\nsum_{i=2}^n t_i = w and each of the t_i is a .The vertices of the tree\r\nare numbered in a special way: the numbers of the vertices in each\r\nsubtree are consecutive integers. In other words, the vertices of the\r\ntree are numbered in the order of a depth-first search. We define\r\noperatorname{dist}(u, v) as the length of the simple path between\r\nvertices u and v in the tree.Next, there will be n - 1 events: Iris is\r\ngiven integers x and y, indicating that t_x = y. After each event, Iris\r\nwants to know the maximum possible value of\r\noperatorname{dist}(i, i\r\nbmod n + 1) for each i (1\r\nle i\r\nle n). She only needs to know the sum of these n values. Please help\r\nIris quickly get the answers.Note that when calculating the maximum\r\npossible values of\r\noperatorname{dist}(i, i\r\nbmod n + 1) and\r\noperatorname{dist}(j, j\r\nbmod n + 1) for i\r\nne j, the unknown edge weights .\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 30.08.2024 07:41:17**/#include <bits/stdc++.h> using namespace std; #ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif template <typename T>class graph { public:  struct edge {    int from;    int to;    T cost;  };   vector<edge> edges;  vector<vector<int>> g;  int n;   graph(int _n) : n(_n) {    g.resize(n);  }   virtual int add(int from, int to, T cost) = 0;}; template <typename T>class forest : public graph<T> { public:  using graph<T>::edges;  using graph<T>::g;  using graph<T>::n;   forest(int _n) : graph<T>(_n) {  }   int add(int from, int to, T cost = 1) {    assert(0 <= from && from < n && 0 <= to && to < n);    int id = (int) edges.size();    assert(id < n - 1);    g[from].push_back(id);    g[to].push_back(id);    edges.push_back({from, to, cost});    return id;  }}; template <typename T>class dfs_forest : public forest<T> { public:  using forest<T>::edges;  using forest<T>::g;  using forest<T>::n;   vector<int> pv;  vector<int> pe;  vector<int> order;  vector<int> pos;  vector<int> end;  vector<int> sz;  vector<int> root;  vector<int> depth;  vector<T> dist;   dfs_forest(int _n) : forest<T>(_n) {  }   void init() {    pv = vector<int>(n, -1);    pe = vector<int>(n, -1);    order.clear();    pos = vector<int>(n, -1);    end = vector<int>(n, -1);    sz = vector<int>(n, 0);    root = vector<int>(n, -1);    depth = vector<int>(n, -1);    dist = vector<T>(n);  }   void clear() {    pv.clear();    pe.clear();    order.clear();    pos.clear();    end.clear();    sz.clear();    root.clear();    depth.clear();    dist.clear();  }  private:  void do_dfs(int v) {    pos[v] = (int) order.size();    order.push_back(v);    sz[v] = 1;    for (int id : g[v]) {      if (id == pe[v]) {        continue;      }      auto &e = edges[id];      int to = e.from ^ e.to ^ v;      depth[to] = depth[v] + 1;      dist[to] = dist[v] + e.cost;      pv[to] = v;      pe[to] = id;      root[to] = (root[v] != -1 ? root[v] : to);      do_dfs(to);      sz[v] += sz[to];    }    end[v] = (int) order.size() - 1;  }   void do_dfs_from(int v) {    depth[v] = 0;    dist[v] = T{};    root[v] = v;    pv[v] = pe[v] = -1;    do_dfs(v);  }  public:  void dfs(int v, bool clear_order = true) {    if (pv.empty()) {      init();    } else {      if (clear_order) {        order.clear();      }    }    do_dfs_from(v);  }   void dfs_all() {    init();    for (int v = 0; v < n; v++) {      if (depth[v] == -1) {        do_dfs_from(v);      }    }    assert((int) order.size() == n);  }}; template <typename T>class hld_forest : public dfs_forest<T> { public:  using dfs_forest<T>::edges;  using dfs_forest<T>::g;  using dfs_forest<T>::n;  using dfs_forest<T>::pv;  using dfs_forest<T>::sz;  using dfs_forest<T>::root;  using dfs_forest<T>::pos;  using dfs_forest<T>::end;  using dfs_forest<T>::order;  using dfs_forest<T>::depth;  using dfs_forest<T>::dfs;  using dfs_forest<T>::dfs_all;   vector<int> head;  vector<int> visited;   hld_forest(int _n) : dfs_forest<T>(_n) {    visited.resize(n);  }   void build_hld(const vector<int> &vs) {    for (int tries = 0; tries < 2; tries++) {      if (vs.empty()) {        dfs_all();      } else {        order.clear();        for (int v : vs) {          dfs(v, false);        }        assert((int) order.size() == n);      }      if (tries == 1) {        break;      }      for (int i = 0; i < n; i++) {        if (g[i].empty()) {          continue;        }        int best = -1, bid = 0;        for (int j = 0; j < (int) g[i].size(); j++) {          int id = g[i][j];          int v = edges[id].from ^ edges[id].to ^ i;          if (pv[v] != i) {            continue;          }          if (sz[v] > best) {            best = sz[v];            bid = j;          }        }        swap(g[i][0], g[i][bid]);      }    }    head.resize(n);    for (int i = 0; i < n; i++) {      head[i] = i;    }    for (int i = 0; i < n - 1; i++) {      int x = order[i];      int y = order[i + 1];      if (pv[y] == x) {        head[y] = head[x];      }    }  }   void build_hld(int v) {    build_hld(vector<int>(1, v));  }   void build_hld_all() {    build_hld(vector<int>());  }   bool apply_on_path(int x, int y, bool with_lca, function<void(int,int,bool)> f) {    // f(x, y, up): up -- whether this part of the path goes up    assert(!head.empty());    int z = lca(x, y);    if (z == -1) {      return false;    }    {      int v = x;      while (v != z) {        if (depth[head[v]] <= depth[z]) {          f(pos[z] + 1, pos[v], true);          break;        }        f(pos[head[v]], pos[v], true);        v = pv[head[v]];      }    }    if (with_lca) {      f(pos[z], pos[z], false);    }    {      int v = y;      int cnt_visited = 0;      while (v != z) {        if (depth[head[v]] <= depth[z]) {          f(pos[z] + 1, pos[v], false);          break;        }        visited[cnt_visited++] = v;        v = pv[head[v]];      }      for (int at = cnt_visited - 1; at >= 0; at--) {        v = visited[at];        f(pos[head[v]], pos[v], false);      }    }    return true;  }   inline bool anc(int x, int y) {    return (pos[x] <= pos[y] && end[y] <= end[x]);  }   inline int go_up(int x, int up) {    int target = depth[x] - up;    if (target < 0) {      return -1;    }    while (depth[head[x]] > target) {      x = pv[head[x]];    }    return order[pos[x] - depth[x] + target];  }   inline int lca(int x, int y) {    if (root[x] != root[y]) {      return -1;    }    while (head[x] != head[y]) {      if (depth[head[x]] > depth[head[y]]) {        x = pv[head[x]];      } else {        y = pv[head[y]];      }    }    return depth[x] < depth[y] ? x : y;  }}; class dsu { public:  vector<int> p;  int n;   dsu(int _n) : n(_n) {    p.resize(n);    iota(p.begin(), p.end(), 0);  }   inline int get(int x) {    return (x == p[x] ? x : (p[x] = get(p[x])));  }   inline bool unite(int x, int y) {    x = get(x);    y = get(y);    if (x != y) {      p[x] = y;      return true;    }    return false;  }}; template <typename T>class FenwickTree { public:  vector<T> fenw;  int n;  int pw;   FenwickTree() : n(0) {}  FenwickTree(int n_) : n(n_) {    fenw.resize(n);    pw = bit_floor(unsigned(n));  }   void Modify(int x, T v) {    assert(0 <= x && x < n);    while (x < n) {      fenw[x] += v;      x |= x + 1;    }  }   T Query(int x) {    assert(0 <= x && x <= n);    T v{};    while (x > 0) {      v += fenw[x - 1];      x &= x - 1;    }    return v;  }   // Returns the length of the longest prefix with sum <= c  int MaxPrefix(T c) {    T v{};    int at = 0;    for (int len = pw; len > 0; len >>= 1) {      if (at + len <= n) {        auto nv = v;        nv += fenw[at + len - 1];        if (!(c < nv)) {          v = nv;          at += len;        }      }    }    assert(0 <= at && at <= n);    return at;  }}; int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int n;    int64_t w;    cin >> n >> w;    hld_forest<int> g(n);    vector<int> p(n);    for (int i = 1; i < n; i++) {      cin >> p[i];      --p[i];      g.add(p[i], i);    }    g.build_hld(0);    vector<int64_t> sum(n);    for (int i = 0; i < n; i++) {      int j = (i + 1) % n;      int u = g.lca(i, j);      sum[i] += 1;      sum[j] += 1;      sum[u] -= 2;    }    for (int i = n - 1; i > 0; i--) {      sum[p[i]] += sum[i];    }    vector<set<int>> comp(n);    for (int i = 0; i < n; i++) {      comp[i].insert(i);    }    int disc = n;    int64_t total = 0;    dsu d(n);    for (int it = 0; it < n - 1; it++) {      int i;      int64_t cur;      cin >> i >> cur;      --i;      int x = d.get(i);      int y = d.get(p[i]);      assert(d.unite(x, y));      if (comp[x].size() > comp[y].size()) {        swap(comp[x], comp[y]);      }      for (int u : comp[x]) {        if (comp[y].find((u + 1) % n) != comp[y].end()) {          disc -= 1;        }        if (comp[y].find((u + n - 1) % n) != comp[y].end()) {          disc -= 1;        }      }      for (int u : comp[x]) {        comp[y].insert(u);      }      set<int>().swap(comp[x]);      total += cur * sum[i];      w -= cur;      int64_t ans = total;      cout << ans + disc * w << \" \\n\"[it == n - 2];    }  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "dsu",
        "math",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Iris and the Tree.json",
    "hint": [
        "Hint1 On a tree with nodes numbered with dfs order, we have to find the distance between two consecutive nodes. What can you think of? Answer Each edge is passed by exactly two of the paths.",
        "Hint2 How to calculate the maximum value of ? Is it different when the weight of all of its edges are known?"
    ]
}