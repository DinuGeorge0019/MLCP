{
    "link": "https://codeforces.com//contest/1641/problem/C",
    "problemId": "1306246",
    "problem_idx": "C",
    "shortId": "1641C",
    "contest_number": "1641",
    "problem_submissions": {
        "D": [
            147518709,
            147518438,
            147518414,
            147427811,
            147454243,
            147448667,
            147443879,
            147448778,
            147461315,
            147449736,
            147438286,
            147472049,
            147446117,
            147443730,
            147449435,
            147452074,
            147451905,
            147452006,
            147454020,
            147456098,
            147454778,
            147430439
        ],
        "F": [
            147463572,
            147488364,
            147487709,
            147487635,
            147487566,
            147487511,
            147487448,
            147487273,
            147474513,
            147473910,
            147473584,
            147541615
        ],
        "E": [
            147445838,
            147446189,
            147454919,
            147456452,
            147460049,
            147450489,
            147462542,
            147543257,
            147542937,
            147453651,
            147456356,
            147459732,
            147462090,
            147455497,
            147527427,
            147590875
        ],
        "B": [
            147438181,
            147420165,
            147422523,
            147421140,
            147420036,
            147420813,
            147426049,
            147460937,
            147441628,
            147446219,
            147424792,
            147434886,
            147431843,
            147422293,
            147424883,
            147440401
        ],
        "C": [
            147435041,
            147431185,
            147429914,
            147434109,
            147426743,
            147452293,
            147436064,
            147458110,
            147432571,
            147432541,
            147431796,
            147432454,
            147435151,
            147433502,
            147424256,
            147417819,
            147434463,
            147437219,
            147451475
        ],
        "A": [
            147414901,
            147414810,
            147414544,
            147414530,
            147414675,
            147414742,
            147414833,
            147461626,
            147414843,
            147414962,
            147414590,
            147414549,
            147415904,
            147414474,
            147414750,
            147414483,
            147415173,
            147414668,
            147414647
        ]
    },
    "name": "C. Anonymity Is Important",
    "statement": "In the work of a doctor, it is important to maintain the anonymity of\r\nclients and the results of tests. The test results are sent to everyone\r\npersonally by email, but people are very impatient and they want to know\r\nthe results right away.That\u2019s why in the testing lab \"De-vitro\" doctors\r\ncame up with an experimental way to report the results. Let\u2019s assume\r\nthat n people took the tests in the order of the queue. Then the chief\r\ndoctor Sam can make several statements, in each telling if there is a\r\nsick person among the people in the queue from l-th to r-th (inclusive),\r\nfor some values l and r.During the process, Sam will check how well this\r\nscheme works and will be interested in whether it is possible to find\r\nout the test result of i-th person from the information he announced.\r\nAnd if it can be done, then is that patient sick or not.Help Sam to test\r\nhis scheme.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 23.02.2022 13:39:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, tt;\n  cin >> n >> tt;\n  vector<pair<int, int>> qs;\n  set<int> s;\n  for (int i = 0; i < n; i++) {\n    s.insert(i);\n  }\n  for (int i = 0; i < tt; i++) {\n    int op;\n    cin >> op;\n    if (op == 1) {\n      int x;\n      cin >> x;\n      --x;\n      qs.emplace_back(x, -1);\n    } else {\n      int l, r, x;\n      cin >> l >> r >> x;\n      --l; --r;\n      if (x == 0) {\n        while (true) {\n          auto it = s.lower_bound(l);\n          if (it != s.end() && (*it) <= r) {\n            qs.emplace_back(*it, -2);\n            s.erase(it);\n          } else {\n            break;\n          }\n        }\n      } else {\n        qs.emplace_back(l, r);\n      }\n    }\n  }\n  tt = (int) qs.size();\n  vector<int> low(tt);\n  vector<int> high(tt);\n  for (int i = 0; i < tt; i++) {\n    if (qs[i].second >= 0) {\n      low[i] = i;\n      high[i] = tt;\n    }\n  }\n  vector<int> mid(tt);\n  while (true) {\n    vector<vector<int>> at(tt + 1);\n    bool any = false;\n    for (int i = 0; i < tt; i++) {\n      if (low[i] < high[i]) {\n        mid[i] = (low[i] + high[i]) >> 1;\n        at[mid[i]].push_back(i);\n        any = true;\n      }\n    }\n    if (!any) {\n      break;\n    }\n    fenwick<int> fenw(n);\n    for (int i = 0; i < tt; i++) {\n      if (qs[i].second == -2) {\n        fenw.modify(qs[i].first, +1);\n      }\n      for (int j : at[i]) {\n        int sum = fenw.get(qs[j].second) - fenw.get(qs[j].first - 1);\n        int len = qs[j].second - qs[j].first + 1;\n        assert(sum < len);\n        if (sum == len - 1) {\n          high[j] = mid[j];\n        } else {\n          low[j] = mid[j] + 1;\n        }\n      }\n    }\n  }\n  vector<vector<int>> at(tt + 1);\n  for (int i = 0; i < tt; i++) {\n    if (qs[i].second >= 0) {\n      at[low[i]].push_back(i);\n    }\n  }\n  fenwick<long long> fenw(n);\n  for (int i = 0; i < n; i++) {\n    fenw.modify(i, i);\n  }\n  vector<int> res(n, 0);\n  for (int i = 0; i < tt; i++) {\n    if (qs[i].second == -2) {\n      fenw.modify(qs[i].first, -qs[i].first);\n      res[qs[i].first] = -1;\n    }\n    if (qs[i].second == -1) {\n      int x = res[qs[i].first];\n      cout << (x == 0 ? \"N/A\" : (x == 1 ? \"YES\" : \"NO\")) << '\\n';\n    }\n    if (qs[i].second >= 0) {\n      // pass\n    }\n    for (int j : at[i]) {\n      long long sum = fenw.get(qs[j].second) - fenw.get(qs[j].first - 1);\n      assert(qs[j].first <= sum && sum <= qs[j].second);\n      res[sum] = 1;\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dsu",
        "greedy",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Anonymity Is Important.json",
    "editorial_link": "https://codeforces.com//blog/entry/100249",
    "editorial": "If i\n-th person is not ill, the following query exists: 0 l r 0\n, such that l?i?r\n.\n\nOtherwise, the person's status is either unknown or they are ill.\n\nIf i\n-th person is ill, the following query exists:0 l r 1\n, such that l?i?r\n, and every person i\n such that l?j?r\n are not ill. If there is such person j\n that they are not ill, and j?i,l?j?r\n. In this case, it is impossible to determine if i\n-th person is ill or not.\n\nLet's maintain the indices of the people who might be ill using set. When we get a query 0 l r 0\n, we can find the first possible ill person with an index of at least l\n using lower_bound, after that, we need to delete this person from our set, find the next one and do the same thing until we find the first index greater than r\n. This works in O(nlogn)\n.\n\nIf a person is not in the set, he is totally healthy. Otherwise, we can use a segment tree to store such index j\n that there is a query 0 i j 1\n and store it in the i\n-th slot of our segment tree. We can update it when we get a new query. When we understand that the i\n-th person might be ill, we can find the first elements to the left (l\n) and to the right (r\n) of i\n, which might be ill using our set. The i\n-th person is ill when the minimal element on segment [l+1;i]\n is <r\n.\n\nThe solution works in O(nlogn+qlogn)\n."
}