{"link": "https://codeforces.com//contest/809/problem/A", "problemId": "106950", "problem_idx": "A", "shortId": "809A", "contest_number": "809", "problem_submissions": {"E": [27253997, 27253429], "D": [27249075, 27251826, 27251250, 27252529, 27250844, 27248855, 27249814, 27250805, 27251747, 27249258, 27246563, 27254846, 27254749], "C": [27246781, 27244976, 27248082, 27245390, 27251108, 27243956, 27253183, 27253135, 27244552, 27253129, 27245688, 27244697, 27248015, 27245843, 27247902, 27248924, 27249554, 27245267, 27250102, 27250477], "B": [27242404, 27247452, 27245322, 27249228, 27241882, 27241895, 27246216, 27242600, 27252141, 27243365, 27243040, 27244839, 27249122, 27244039, 27244488], "A": [27238822, 27238882, 27238974, 27238780, 27251619, 27238718, 27238690, 27238879, 27238895, 27238975, 27238855, 27238770, 27239286, 27239029, 27238990, 27239207, 27238846, 27239176, 27238782]}, "name": "A. Do you want a date ", "statement": "Leha decided to move to a quiet town Vi kopolis, because he was tired by\r\nliving in Bankopolis. Upon arrival he immediately began to expand his\r\nnetwork of hacked computers. During the week Leha managed to get access\r\nto computers throughout the town. Incidentally all the computers, which\r\nwere hacked by Leha, lie on the same straight line, due to the reason\r\nthat there is the only one straight street in Vi kopolis.Let\u2019s denote\r\nthe coordinate system on this street. Besides let\u2019s number all the\r\nhacked computers with integers from to . So the -th hacked computer is\r\nlocated at the point . Moreover the coordinates of all computers are\r\ndistinct. Leha is determined to have a little rest after a hard week.\r\nTherefore he is going to invite his friend Noora to a restaurant.\r\nHowever the girl agrees to go on a date with the only one condition:\r\nLeha have to solve a simple task.Leha should calculate a sum of for all\r\n, where is a non-empty subset of the set, that consists of all hacked\r\ncomputers. Formally, let\u2019s denote the set of all integers from to .\r\nNoora asks the hacker to find value of the expression . Here is\r\ncalculated as the maximum among the distances between all pairs of\r\ncomputers from the set . Formally, . Since the required sum can be quite\r\nlarge Noora asks to find it modulo .Though, Leha is too tired.\r\nConsequently he is not able to solve this task. Help the hacker to\r\nattend a date.\r\n", "solutions": ["//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJ\u015aCIE I WYJ\u015aCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=1000*1007;\nconst long long mod=1000*1000*1000+7;\n\nint n;\nlong long tab[nax];\n\nlong long pot[nax];\n\nlong long wyn;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &tab[i]);\n\tsort(tab+1, tab+1+n);\n\tpot[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tpot[i]=(pot[i-1]*2)%mod;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twyn+=tab[i]*pot[i-1]-tab[i]*pot[n-i];\n\t\twyn%=mod;\n\t}\n\twyn%=mod;\n\twyn+=mod;\n\twyn%=mod;\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["implementation", "math", "sortings"], "dificulty": "1500", "interactive": false}