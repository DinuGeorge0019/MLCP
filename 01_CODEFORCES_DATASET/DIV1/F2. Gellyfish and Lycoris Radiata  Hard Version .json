{
    "link": "https://codeforces.com//contest/2115/problem/F2",
    "problemId": "3415149",
    "problem_idx": "F2",
    "shortId": "2115F2",
    "contest_number": "2115",
    "problem_submissions": {
        "A": [
            322373149,
            322373057,
            322191671,
            322196906,
            322191306,
            322207089,
            322339019,
            322205731,
            322191602,
            322193299,
            322321188,
            322320656,
            322193684,
            322193937,
            322193846,
            322195728,
            322193849,
            322208657,
            322196496,
            322194770,
            322195138,
            322193397,
            322277408,
            322205364,
            322201021
        ],
        "E": [
            322277481,
            322279542,
            322287881,
            322287269,
            322268790,
            322276073,
            322479322,
            322316002,
            322463290,
            322674274,
            322484220
        ],
        "D": [
            322247280,
            322249604,
            322253666,
            322244252,
            322244159,
            322252360,
            322259840,
            322274633,
            322274421,
            322243918,
            322262198,
            322264257,
            322258885,
            322256903,
            322256375,
            322270049,
            322285061,
            322255261,
            322270426,
            322274051
        ],
        "C": [
            322226886,
            322242092,
            322247023,
            322262817,
            322237987,
            322228189,
            322234047,
            322256038,
            322250633,
            322253986,
            322247586,
            322244155,
            322267167,
            322253884,
            322236170,
            322239045,
            322256498,
            322247239
        ],
        "B": [
            322199788,
            322207830,
            322209032,
            322228331,
            322214165,
            322204435,
            322203425,
            322201226,
            322209167,
            322226797,
            322225099,
            322216043,
            322219704,
            322219745,
            322213225,
            322218856,
            322205348,
            322216288,
            322222101,
            322216208
        ],
        "F2": [
            322365448
        ],
        "F1": [
            322365418
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/143418",
    "editorial": "SolutionWe consider using leafy persistent balanced trees to maintain\r\nthe sequence. At each non-leaf node, we store a set as a lazy tag,\r\nindicating that every set in the subtree rooted at contains . However,\r\nsince can be large, it’s difficult to push down the tag efficiently.To\r\naddress this, we split each set into two components: : A part of stored\r\ndirectly at node A collection of child nodes , each storing a subset of\r\nWe maintain the invariant: .Thus, we make the balanced tree persistent.\r\nWhen we create a new node and initialize its children as and , we add\r\ninto both and . During split and merge, we do not modify , which ensures\r\nthese operations still run in logarithmic time. Type 1 (Insert): We\r\nsplit the balanced tree into two parts. Let the root of the first part\r\nbe , and simply add an element into . Type 2 (Reverse a segment): Just\r\nmark the root of the relevant subtree with a \"reverse\" flag. Type 3\r\n(Delete): Since each element appears in only one , we can directly\r\nremove it from that node’s . For queries, We first locate the leaf node\r\n. To compute , we need to compute all . Due to persistence, we can\r\nguarantee: Thus, we can sequentially check whether each is empty.We\r\nprocess this recursively. Every time we encounter a node with and is not\r\npart of the latest tree version, then will always be empty, and we can\r\nsafely delete . During a query, we encounter three types of nodes: Nodes\r\nwith : We only encounter one such node per query this is where we find\r\nthe minimum value. Nodes with and not in the latest tree: These nodes\r\nare deleted. Since the total number of persistent nodes is , these nodes\r\nalso appear at most that many times. Nodes with and in the latest tree:\r\nThese are ancestors of leaf , so there are at most of them per query.\r\nWhy can we just do rounds of recursion? Because we replace all the nodes\r\nwe pass through on the path, so the size of the subtree doesn’t change\r\nfrom the time the node is created to the time it is removed from the\r\ntree. Furthermore, if we recurse from node to node , this means that is\r\nthe parent of at least at some point on the WBLT. Since the WBLT is\r\nweight-balanced, the size of the subtree is actually at least a constant\r\nmultiple of the size of the subtree, and this constant greater than will\r\nbe based on your WBLT.Time complexity: .Memory complexity: .\r\n",
    "name": "F2. Gellyfish and Lycoris Radiata  Hard Version ",
    "statement": "Gellyfish has an array consisting of n sets. Initially, all the sets are\r\nempty.Now Gellyfish will do q operations. Each operation contains one\r\nmodification operation and one query operation, for the i-th (1\r\nleq i\r\nleq q) operation:First, there will be a modification operation, which is\r\none of the following: operation: You are given an integer r. For the\r\n1-th to r-th sets, insert element i. Note that the element inserted here\r\nis i, the index of the operation, not the index of the set. operation:\r\nYou are given an integer r. Reverse the 1-th to r-th sets. operation:\r\nYou are given an integer x. Delete element x from all sets that contain\r\nx. Followed by a query operation: operation: You are given an integer p.\r\nOutput the smallest element in the p-th set (If the p-th set is empty,\r\nthe answer is considered to be 0). Now, Flower needs to provide the\r\nanswer for each query operation. Please help her!: Gellyfish will only\r\ngive the next operation after Flower has answered the previous query\r\noperation. That is, you need to solve this problem . Please refer to the\r\ninput format for more details.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F2. Gellyfish and Lycoris Radiata  Hard Version .json",
    "hint": []
}