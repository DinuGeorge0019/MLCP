{
    "link": "https://codeforces.com//contest/95/problem/D",
    "problemId": "500",
    "problem_idx": "D",
    "shortId": "95D",
    "contest_number": "95",
    "problem_submissions": {
        "E": [
            535779,
            536171,
            535576,
            534631,
            535449,
            537379,
            535935,
            538215,
            538206,
            535203,
            543889,
            535690,
            536003,
            536745,
            536509,
            549025
        ],
        "B": [
            535031,
            532607,
            533801,
            533350,
            537169,
            534776,
            532824,
            533550,
            533473,
            533499,
            533085,
            534188,
            533285,
            537343,
            537019,
            533757
        ],
        "D": [
            534913,
            535339,
            534808,
            950906,
            535637,
            535740,
            536719,
            535872,
            536920,
            536227,
            537633
        ],
        "C": [
            534317,
            533819,
            536411,
            534119,
            533891,
            533661,
            534495,
            534743,
            534102,
            533774,
            534164,
            535462,
            533913,
            536894,
            535197,
            535469,
            534630,
            534725
        ],
        "A": [
            533274,
            536622,
            537207,
            536153,
            533227,
            532424,
            532796,
            532812,
            532729,
            532727,
            533283,
            534618,
            532955,
            532983,
            533855,
            532880
        ]
    },
    "name": "D. Horse Races",
    "statement": "Petya likes horse racing very much. Horses numbered from to take part in\r\nthe races. Petya wants to evaluate the probability of victory; for some\r\nreason, to do that he needs to know the amount of nearly lucky horses\u2019\r\nnumbers. A number is an integer number that has at least two lucky\r\ndigits the distance between which does not exceed . Petya learned from\r\nsome of his mates from Lviv that lucky digits are digits and . The\r\ndistance between the digits is the absolute difference between their\r\npositions in the number of a horse. For example, if , then numbers , ,\r\nare nearly lucky and numbers , , are not.Petya prepared intervals and\r\ninvented number , common for all of them. Your task is to find how many\r\nnearly happy numbers there are in each of these segments. Since the\r\nanswers can be quite large, output them modulo ().\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=1000+20;\nconst int mod=1000000007;\n\nint f[maxn][maxn];\nchar L[maxn],R[maxn];\nint test,dist;\n\nvoid renew(int &a,int b)\n{\n\ta+=b;\n\tif (a>=mod) a-=mod;\n}\n\nint calc(char st[],bool flag)\n{\n\tint n=strlen(st+1);\n\tint res=0;\n\tfor (int i=1;i<n;i++)\n\tfor (int j=1;j<10;j++)\n\tif (j==4 || j==7) renew(res,f[i-1][1]);\n\telse renew(res,f[i-1][dist+1]);\n\n\tint state=dist+1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint digit=st[i]-'0';\n\t\tfor (int j=(i>1?0:1);j<digit;j++)\n\t\tif (state==0) renew(res,f[n-i][0]);else\n\t\tif (j==4 || j==7)\n\t\t{\n\t\t\tif (state<=dist) renew(res,f[n-i][0]);\n\t\t\telse renew(res,f[n-i][1]);\n\t\t} else\n\t\t{\n\t\t\tif (state+1<=dist) renew(res,f[n-i][state+1]);\n\t\t\telse renew(res,f[n-i][dist+1]);\n\t\t}\n\n\t\tif (state==0) state=0;else\n\t\tif (digit==4 || digit==7)\n\t\t{\n\t\t\tif (state<=dist) state=0;\n\t\t\telse state=1;\n\t\t} else state=min(state+1,dist+1);\n\t}\n\tif (flag) renew(res,state==0);\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&test,&dist);\n\n\tf[0][0]=1;\n\tfor (int i=1;i<=1005;i++)\n\tfor (int j=0;j<=dist+1;j++)\n\tfor (int k=0;k<10;k++)\n\tif (j==0) renew(f[i][j],f[i-1][j]);else\n\tif (k==4 || k==7)\n\t{\n\t\tif (j<=dist) renew(f[i][j],f[i-1][0]);\n\t\telse renew(f[i][j],f[i-1][1]);\n\t} else\n\t{\n\t\tif (j+1<=dist) renew(f[i][j],f[i-1][j+1]);\n\t\telse renew(f[i][j],f[i-1][dist+1]);\n\t}\n\n\tfor (;test--;)\n\t{\n\t\tscanf(\"%s%s\",L+1,R+1);\n\t\tint A=calc(R,1);\n\t\tint B=calc(L,0);\n\t\tA-=B;\n\t\tif (A<0) A+=mod;\n\t\tprintf(\"%d\\n\",A);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Horse Races.json",
    "editorial_link": "https://codeforces.com//blog/entry/2257",
    "editorial": "Let we have array DP[x][y][z] \u0096 number of x-digits number if last lucky digit was on position y, bool z (0 or 1) \u0096 was the pair of lucky digits with less than or equal distance then K (call it lucky pair)? Now, let S \u0096 string which represent number N. Let F(x, y, z) \u0096 result for substring of first x digits, y \u0096 position of last lucky digit, z \u0096 (0 or 1) \u0096 was the lucky pair before? Try to assign some digits on position x. If this digit is less than S[i], then add to result for F(x, y, z) DP[n-x-1][yy][zz] (yy \u0096 updated position of last lucky digit, zz \u0096 updated bool for lucky pairs). If this digit is equal to S[i], add F(x+1, yy, zz). DP can be calculated simply. Let from state (x, y, z) we place some digit d on position x. Then, we can go to state (x+1, yy, zz). Again, yy and zz \u0096 updated parameters."
}