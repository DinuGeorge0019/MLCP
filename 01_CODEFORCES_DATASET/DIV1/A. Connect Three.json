{
    "link": "https://codeforces.com//contest/1086/problem/A",
    "problemId": "273651",
    "problem_idx": "A",
    "shortId": "1086A",
    "contest_number": "1086",
    "problem_submissions": {
        "F": [
            47429292,
            47449995,
            47444202
        ],
        "E": [
            47422474,
            47423961,
            47424550,
            47426933,
            47428109,
            47426232,
            47427511,
            47426695,
            47427218,
            47427849,
            47427630,
            47511510,
            47428346,
            47425158,
            47429712,
            47428661,
            47421857,
            47429322,
            47440462,
            63950917
        ],
        "D": [
            47415205,
            47413571,
            47418835,
            47417078,
            47414191,
            47418078,
            47418526,
            47419686,
            47418954,
            47419229,
            47421725,
            47466322,
            47418774,
            47416004,
            47420225,
            47422460,
            47411471,
            47420807,
            47421473,
            47423600,
            47420881
        ],
        "C": [
            47410346,
            47408923,
            47412203,
            47411518,
            47409578,
            47407257,
            47412943,
            47414708,
            47412730,
            47413883,
            47416006,
            47414439,
            47428921,
            47417547,
            47419740,
            47412059,
            47415581,
            47415787
        ],
        "B": [
            47402010,
            47400574,
            47400073,
            47401453,
            47402762,
            47411548,
            47405929,
            47406096,
            47405616,
            47407353,
            47404186,
            47400750,
            47404258,
            47404681,
            47402882,
            47426003,
            47408582,
            47404099,
            47404538,
            47406586
        ],
        "A": [
            47400483,
            47400094,
            47413170,
            47400357,
            47400599,
            47410258,
            47403179,
            47403378,
            47401193,
            47402951,
            47401486,
            47403915,
            47400561,
            47403260,
            47400323,
            47425175,
            47409292,
            47400702,
            47401450,
            47402988
        ]
    },
    "name": "A. Connect Three",
    "statement": "The Squareland national forest is divided into equal 1\r\ntimes 1 square plots aligned with north-south and east-west directions.\r\nEach plot can be uniquely described by integer Cartesian coordinates (x,\r\ny) of its south-west corner.Three friends, Alice, Bob, and Charlie are\r\ngoing to buy three distinct plots of land A, B, C in the forest.\r\nInitially, all plots in the forest (including the plots A, B, C) are\r\ncovered by trees. The friends want to visit each other, so they want to\r\nclean some of the plots from trees. After cleaning, one should be able\r\nto reach any of the plots A, B, C from any other one of those by moving\r\nthrough adjacent cleared plots. Two plots are adjacent if they share a\r\nside. Of course, the friends donâ€™t want to strain too much. Help them\r\nfind out the smallest number of plots they need to clean from trees.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int xs[3], ys[3];\n  for (int i = 0; i < 3; ++i)\n    cin >> xs[i] >> ys[i];\n\n  int x1 = -1, y1 = -1;\n  const int M = 1024;\n  int ans = 1e9;\n\n  for (int x = 0; x <= M; ++x)\n    for (int y = 0; y <= M; ++y) {\n      int cand = 0;\n      for (int i = 0; i < 3; ++i)\n        cand += abs(xs[i] - x) + abs(ys[i] - y);\n      if (ans > cand) {\n        mini(ans, cand);\n        x1 = x; y1 = y;\n      }\n    }\n\n  set<PII> s;\n  for (int i = 0; i < 3; ++i) {\n    int x = x1, y = y1;\n    s.emplace(x, y);\n    while (x != xs[i]) {\n      if (x > xs[i]) { --x; } else { ++x; }\n      s.emplace(x, y);\n    }\n    while (y != ys[i]) {\n      if (y > ys[i]) { --y; } else { ++y; }\n      s.emplace(x, y);\n    }\n    debug(x, y, x1, y1);\n  }\n\n  cout << SZ(s) << \"\\n\";\n  for (auto [x, y] : s)\n    cout << x << \" \" << y << \"\\n\";\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Connect Three.json",
    "editorial_link": "https://codeforces.com//blog/entry/64078",
    "editorial": "The smallest possible number of plots required to connect all three\r\nplots is at least , where and (here , , , are extreme coordinate values\r\namong the three given plots). It now suffices to find any suitable\r\ncollection of plots of this size.Let and be the median values of and .\r\nFor each of the plots , , connect it with the plot with any shortest\r\npath (if one of , , coincides with , just do nothing). One can check\r\nthat the resulting collection has size exactly , and it clearly connects\r\n, and together.The above solution has complexity , where is the largest\r\ncoordinate value. Given that is quite small, one could go with slower\r\nsolutions, for instance, instead of try all plots as the connecting\r\nplot.\r\n",
    "hint": []
}