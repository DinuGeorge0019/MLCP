{
    "link": "https://codeforces.com//contest/1483/problem/B",
    "problemId": "931271",
    "problem_idx": "B",
    "shortId": "1483B",
    "contest_number": "1483",
    "problem_submissions": {
        "F": [
            110657198,
            110657366,
            110680394,
            110676074,
            110665233,
            113439308,
            113059400,
            111430671,
            111430417
        ],
        "D": [
            110640647,
            110642867,
            110640739,
            110649362,
            110656109,
            110648351,
            110669875,
            110646025,
            110641671,
            110641253,
            110642818,
            110645567,
            110644771,
            110644923,
            110644779,
            110648343,
            110645625,
            110649200,
            110647913
        ],
        "C": [
            110637482,
            110639495,
            110638107,
            110639034,
            110636245,
            110643783,
            110646712,
            110639119,
            110637748,
            110637078,
            110639242,
            110639215,
            110640002,
            110638528,
            110640575,
            110640398,
            110641125,
            110641145,
            110641078,
            110642087
        ],
        "B": [
            110634536,
            110634072,
            110635529,
            110635361,
            110642670,
            110636167,
            110639544,
            110634766,
            110633516,
            110637084,
            110643607,
            110635632,
            110634992,
            110636625,
            110637243,
            110635431,
            110638777,
            110635673,
            110637846
        ],
        "A": [
            110629442,
            110628350,
            110629067,
            110628964,
            110631520,
            110629138,
            110634726,
            110632933,
            110628500,
            110629504,
            110630632,
            110632453,
            110628740,
            110630017,
            110629975,
            110630962,
            110628508,
            110633725,
            110630402,
            110630508
        ],
        "E": [
            110660726,
            110669157,
            204375141,
            110665918,
            110662689,
            110666386,
            110657015,
            113441196,
            113891758,
            110672789,
            111426124,
            110692107
        ]
    },
    "name": "B. Playlist",
    "statement": "Arkady has a playlist that initially consists of n songs, numerated from\r\n1 to n in the order they appear in the playlist. Arkady starts listening\r\nto the songs in the playlist one by one, starting from song 1. The\r\nplaylist is cycled, i. e. after listening to the last song, Arkady will\r\ncontinue listening from the beginning.Each song has a genre a_i, which\r\nis a positive integer. Let Arkady finish listening to a song with genre\r\ny, and the genre of the next-to-last listened song be x. If\r\noperatorname{gcd}(x, y) = 1, he deletes the last listened song (with\r\ngenre y) from the playlist. After that he continues listening normally,\r\nskipping the deleted songs, and about songs he listened to before. In\r\nother words, after he deletes a song, he can’t delete the next song\r\nimmediately.Here\r\noperatorname{gcd}(x, y) denotes the greatest common divisor (GCD) of\r\nintegers x and y.For example, if the initial songs’ genres were [5, 9,\r\n2, 10, 15], then the playlist is converted as follows: [, 9, 2, 10, 15]\r\nto [, , 2, 10, 15]\r\nto [5, 2, 10, 15] (because\r\noperatorname{gcd}(5, 9) = 1)\r\nto [5, , 10, 15]\r\nto [5, , , 15]\r\nto [5, 2, , ]\r\nto [, 2, 10, ]\r\nto [, , 10, 15]\r\nto [5, 10, 15] (because\r\noperatorname{gcd}(5, 2) = 1)\r\nto [5, , 15]\r\nto [5, , ]\r\nto ... The bold numbers represent the two last played songs. Note that\r\nafter a song is deleted, Arkady forgets that he listened to that and the\r\nprevious songs.Given the initial playlist, please determine which songs\r\nare eventually deleted and the order these songs are deleted.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; cin >> N;\n\t\tvector<int> A(N); for (auto& a : A) cin >> a;\n\n\t\tvector<int> prv(N); iota(prv.begin(), prv.end(), -1); prv[0] = N-1;\n\t\tvector<int> nxt(N); iota(nxt.begin(), nxt.end(), 1); nxt[N-1] = 0;\n\n\t\tset<int> to_delete;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (std::gcd(A[prv[i]], A[i]) == 1) {\n\t\t\t\tto_delete.insert(i);\n\t\t\t}\n\t\t}\n\n\t\tvector<int> ans; ans.reserve(N);\n\n\t\tfor (int cur_pos = 0; int(ans.size()) < N && !to_delete.empty(); ) {\n\t\t\tauto it = to_delete.upper_bound(cur_pos);\n\t\t\tif (it == to_delete.end()) it = to_delete.begin();\n\t\t\tint i = *it;\n\t\t\tans.push_back(i);\n\t\t\tto_delete.erase(i);\n\n\t\t\tint p = prv[i];\n\t\t\tint n = nxt[i];\n\t\t\tif (n == i) break;\n\n\t\t\tto_delete.erase(n);\n\t\t\tnxt[p] = n;\n\t\t\tprv[n] = p;\n\t\t\tif (std::gcd(A[p], A[n]) == 1) to_delete.insert(n);\n\n\t\t\tcur_pos = n;\n\t\t}\n\n\t\tcout << ans.size(); for (int v : ans) { cout << ' ' << v+1; } cout << '\\n';\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Playlist.json",
    "editorial_link": "https://codeforces.com//blog/entry/88963",
    "editorial": "Let's call a pair of songs bad if GCD of their genres is 1\n. It is easy to check if two songs are bad with Euclid's algorithm in O(logC)\n.\n\nThere are at most n\n deletions, so simulation is fine in terms of time limit, but we should be able to find the next deleted song quickly. Let's maintain an ordered set of songs on the playlist, and also another ordered set that stores pairs of bad consecutive songs. It is easy to see that after we delete a song, only constant number of changes is needed to these sets. Let the song being deleted be b\n, while the previous song be a\n, and the next song in the playlist be c\n. It is easy to find a\n and c\n using the playlist set. Then we should:\n\nremove b\n from the playlist set;\nremove (a,b)\n from the bad pairs set;\nremove (b,c)\n from the bad pairs set if this pair is bad;\nadd (a,c)\n to the bad pairs set if this pair is bad.\nThen we proceed to the next song that needs to be deleted. It is easy to find it using the bad pairs set.\nIf we store the sets in some fast enough data structure (e. g. balanced binary tree, standard C++'s set is enough), we have fast running time (O(n(logn+logC))\n).\n\nIt is also possible to solve this problem with double-linked lists or DSU with O(nlogC)\n complexity.",
    "hint": []
}