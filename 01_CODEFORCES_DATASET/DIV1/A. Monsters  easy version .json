{
    "link": "https://codeforces.com//contest/1785/problem/A",
    "problemId": "1767284",
    "problem_idx": "A",
    "shortId": "1785A",
    "contest_number": "1785",
    "problem_submissions": {
        "F": [
            192340988,
            192367706,
            192347284,
            192344077,
            192349198,
            192347771,
            192385993,
            192336126,
            192406311,
            192343375,
            192348787,
            192366544,
            192344262,
            192411258,
            192345259,
            192363821,
            192484658
        ],
        "E": [
            192334775,
            192378839,
            192330680,
            192327219,
            192332119,
            192339722,
            192385982,
            192341740,
            192412077,
            192337184,
            192336634,
            192325309,
            192324682,
            192330314,
            192339341,
            192328941,
            192342934,
            192342640,
            192343285,
            192338492,
            192348718
        ],
        "D": [
            192309677,
            192304720,
            192308363,
            192312353,
            192300737,
            192385972,
            192323435,
            192411822,
            192411698,
            192411631,
            192411452,
            192307092,
            192297940,
            192289422,
            192305735,
            192292206,
            192306351,
            192303021,
            192324811,
            192312541,
            192301962,
            192316529,
            192316093,
            192321567,
            192314574
        ],
        "C": [
            192301226,
            192367208,
            192300659,
            192294893,
            192304774,
            192305847,
            192385966,
            192316174,
            192318962,
            192301773,
            192292324,
            192299527,
            193510779,
            192315363,
            192293483,
            192308504,
            192291605,
            192310063,
            192307486,
            192299043,
            192314808,
            192308858
        ],
        "B": [
            192291042,
            192291589,
            192316742,
            192291514,
            192291590,
            192385951,
            192288659,
            192292597,
            192289761,
            192297426,
            192300042,
            192305089,
            192297247,
            192288814,
            192295447,
            192337551,
            192290254,
            192297732,
            192303838,
            192303907,
            192291091
        ],
        "A": [
            192284331,
            192283441,
            192283155,
            192282660,
            192283131,
            192385935,
            192282844,
            192284622,
            192283277,
            192290652,
            192292611,
            192296096,
            192286915,
            192282931,
            192283418,
            192285228,
            192283044,
            192283110,
            192282987,
            192288048,
            192282867
        ]
    },
    "name": "A. Monsters  easy version ",
    "statement": "In a computer game, you are fighting against n monsters. Monster number\r\ni has a_i health points, all a_i are integers. A monster is alive while\r\nit has at least 1 health point.You can cast spells of two types: Deal 1\r\ndamage to any single alive monster of your choice. Deal 1 damage to all\r\nalive monsters. If at least one monster dies (ends up with 0 health\r\npoints) as a result of this action, then repeat it (and keep repeating\r\nwhile at least one monster dies every time). Dealing 1 damage to a\r\nmonster reduces its health by 1.Spells of type 1 can be cast any number\r\nof times, while a spell of type 2 can be cast at most once during the\r\ngame.What is the smallest number of times you need to cast spells of\r\ntype 1 to kill all monsters?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n\nusing ll = int64_t;\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<ll> A(N);\n\tfor(ll& x : A) cin >> x;\n\tsort(A.begin(), A.end());\n\tll b = 1;\n\tll ans = 0;\n\tfor(ll& x : A){\n\t\tif(x > b){\n\t\t\tans += x-b;\n\t\t\tx = min(x, b);\n\t\t}\n\t\tif(x == b) b++;\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Monsters  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/112875",
    "editorial": "First, let\u00e2\u0080\u0099s prove that it\u00e2\u0080\u0099s always optimal to use a spell of type 2 as\r\nyour last spell in the game and kill all monsters with it. Indeed,\r\nsuppose you use a spell of type 2 earlier and it deals damage to all\r\nmonsters. Suppose that some monsters are still alive. For any such\r\nmonster, say they had health points before the spell of type 2, and .\r\nThen, you will need to cast more spells of type 1 to kill it afterwards.\r\nBut you could just cast these spells of type 1 on this monster casting\r\nthe spell of type 2. Thus, you can move all usages of spells of type 1\r\nbefore the usage of the spell of type 2 without changing the\r\nanswer.Without loss of generality, assume that . Let be the amount of\r\nhealth points monster has right before the spell of type 2 is cast ().\r\nThen, the number of spells of type 1 needed is , which means we want to\r\nmaximize .Note that we can rearrange so that : since is sorted too, the\r\ncondition will still hold.Also, since all monsters must be killed by a\r\nspell of type 2 afterwards, must hold.Thus, we should go through all\r\nmonsters in non-decreasing order of and decide their greedily, picking\r\nthe largest value satisfying both and . Specifically, we should choose\r\nand .\r\n"
}