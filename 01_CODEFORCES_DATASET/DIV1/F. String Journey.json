{
    "link": "https://codeforces.com//contest/1063/problem/F",
    "problemId": "236990",
    "problem_idx": "F",
    "shortId": "1063F",
    "contest_number": "1063",
    "problem_submissions": {
        "F": [
            44321779,
            44310989,
            44539942,
            44524512,
            44473039,
            44472562,
            50480317,
            51150998,
            44317621,
            44317615,
            44312825,
            44373124
        ],
        "D": [
            44311197,
            44305997,
            44303323,
            44313702,
            44361765,
            44361136,
            44376357,
            44376258,
            44307498,
            44337552,
            44311559,
            44305058,
            44311516,
            44304459,
            44311498,
            44312697,
            44315110
        ],
        "E": [
            44305503,
            44313651,
            44315069,
            44307031,
            44313364,
            44308262,
            44337210,
            44313717,
            44317640,
            44314472,
            44311650
        ],
        "C": [
            44298733,
            44296257,
            44305349,
            44298667,
            44298705,
            44299697,
            44299069,
            44300205,
            44299465,
            44299657,
            44301626,
            44302301,
            44304486,
            44306960,
            44302436,
            44309287,
            44301972,
            44304513,
            44301966
        ],
        "A": [
            44295781,
            44291759,
            44291627,
            44296582,
            44291453,
            44291198,
            44292770,
            44291128,
            44296111,
            44296432,
            44292644,
            44293693,
            44292723,
            44296227,
            44292099,
            44305135,
            44297417,
            44292247,
            44291472
        ],
        "B": [
            44295123,
            44298986,
            44296043,
            44295205,
            44297251,
            44302092,
            44296710,
            44297936,
            44295873,
            44297588,
            44298080,
            44299136,
            44294684,
            44297166,
            44295722,
            44296834,
            44296659,
            44296927
        ]
    },
    "name": "F. String Journey",
    "statement": "We call a sequence of strings a of length , if for each is a substring\r\nof and length of is strictly less than length of . For example, is a\r\njourney, but and are not.Define a as journey , such that all its parts\r\ncan be nested inside in such a way that there exists a sequence of\r\nstrings (each of these strings can be empty) and . As an example, is a\r\njourney on string , but not on because the journey strings should appear\r\nfrom the left to the right.The of a journey on a string is the number of\r\nstrings in it. Determine the maximum possible length of a journey on the\r\ngiven string .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n// #define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct SA {\n  vector<pair<PII, int>> x;\n  VI suf; // <- numery kolejnych sufiksow w porzadku leksykograficznym\n  VI rank; // <- odwrotnosc tablicy sufiksowej (suf)\n  VI lcp; // lcp[i] == lcp(suf[i-1],suf[i])\n  string z;\n  int n;\n  SA(string z_, int n_) : z(z_), n(n_) {\n    z[n] = -1; // straznik zaklada ze -1 nie wystepuje w z\n    //ostroznie coby nic nie nadpisac    \n    suf.resize(n); rank.resize(n); x.resize(n);\n    R(i, n) { x[i] = {{z[i], 0}, i}; }\n    mapuj();\n    int krok = 1;\n    while (krok < n) {\n      R (i, n) { x[i] = {{rank[i], i + krok < n ? rank[i + krok] : -1}, i}; }\n      mapuj();\n      krok *= 2;\n    }\n    R(i, n) { suf[rank[i]] = i; }\n    \n    //LCP - opcjonalnie\n    lcp.resize(n);\n    int k = 0;\n    R(i, n) {\n      int ak = rank[i];\n      if(ak) { while (z[suf[ak] + k] == z[suf[ak - 1] + k]) k++; }\n      lcp[rank[i]] = k;\n      if(k) { k--; }\n    }\n    //koniec LCP\n  };\n  void mapuj() {\n    sort(ALL(x));\n    int id = 0;\n    R (i, n) {\n      if (i && x[i - 1].st != x[i].st) id++;\n      rank[x[i].nd] = id;\n    }\n  }\n};\n/*\n                              // 13 1 2 1 1 2 1 2 1 1 2 1 1 2\nint z[(int)1e6], n;           //   -> 10 7 2 11 8 5 0 3 12 9 6 1 4\nint32_t main(){               //   -> 3 4 1 2 5 6 3 0 1 4 5 2\n  scanf(\"%lld\",&n);\n  R(i,n)scanf(\"%lld\",&z[i]);\n  SA sa(z,n);\n  R(i,n)printf(\"%lld \",sa.suf[i]);\n  puts(\"\");\n  for(int i = 1; i < n; i++) printf(\"%lld \",sa.lcp[i]);\n  puts(\"\");\n} */\n\nint N;\nstring s;\n\nconst int MaxCh = 26;\nconst int MaxN = 5e5 + 100;\n\nbool is_of_length[MaxN];\nbool next_is_of_length[MaxN];\nint total_infos = 0;\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> s;\n  SA sa(s, N);\n  fill_n(is_of_length, N, true);\n  int length = 1;\n\n  debug(sa.suf, sa.lcp);\n\n  while (count(is_of_length, is_of_length + N, true)) {\n#ifdef LOCAL\n    debug(length);\n    for (int i = 0; i < N; ++i)\n      cerr << is_of_length[i];\n    cerr << \"\\n\";\n#endif\n    fill_n(next_is_of_length, N, false);\n\n\n    int intv_end = N - 1;\n    while (intv_end >= 0) {\n      int intv_start = intv_end;\n      int last_good = -1;\n      while (intv_start && sa.lcp[intv_start] >= length)\n        --intv_start;\n      debug(intv_start, intv_end);\n      for (int i = intv_start; i <= intv_end; ++i)\n        if (is_of_length[sa.suf[i]])\n          maxi(last_good, sa.suf[i]);\n      for (int i = intv_start; i <= intv_end; ++i) {\n        const int pos = sa.suf[i];\n        if (pos && last_good >= pos + length)\n          next_is_of_length[pos - 1] = true;\n        if (last_good > pos + length)\n          next_is_of_length[pos] = true;\n      }\n\n      intv_end = intv_start - 1;\n    }\n\n    copy(next_is_of_length, next_is_of_length + N, is_of_length);\n    ++length;\n  }\n\n  cout << length - 1 << \"\\n\";\n\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "string suffix structures"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. String Journey.json",
    "editorial_link": "https://codeforces.com/blog/entry/62455",
    "editorial": "This problem required quite a lot of nice observations!. We can only\r\nconsider journeys in which neighboring strings differ exactly by\r\nremoving one symbol.All other journeys can be modified a bit to match\r\nthe criterion above.. If it is possible to start a journey at the symbol\r\nwith lengths of strings , , ..., , it is always possible to start a\r\njourney at the same symbol with lengths , , ..., , given that .This\r\nsuggests doing dynamic programming: is the maximum possible such that\r\nthere is a journey starting at position of strings with lengths , ...,\r\n.Due to observation we only care about maximum if we know maximum, we\r\nalso known that all lesser values are also OK.So let\u00e2\u0080\u0099s calculate this\r\ndynamic programming from right to left.How to check whether (given that\r\ntool, we can just use binary search for example)?There must be such ,\r\nthat , and string must be a substring of string (basically just two\r\ncases \"left substring\" or \"right substring\").This almost gives us a\r\nsolution, but we need few more observations to have , and not .. If ,\r\nthen .We can use this to kick binary search from the solution when you\r\ncalculate you can start trying with , descending until the success.Since\r\nthere are exactly grows, there will be at most descendings and the total\r\nnumber of checks is linear. . We need to check whether such exists in a\r\nfast way.Recall there are few conditions for us to follow, , and some\r\nstring equality.If you carefully look at the restriction you can see,\r\nthat when we move our dp calculation or make this lower bound on also\r\nmoves only left, like in two pointers. So each moment some indexes are\r\n\"available\" and some are not, and the border moves only left.Finally,\r\ntime for some structures. Build Suffix Array and build segment tree over\r\nit. Let\u00e2\u0080\u0099s store in the leaf of the segment tree if it\u00e2\u0080\u0099s already\r\navailable or otherwise.Let\u00e2\u0080\u0099s check whether is good. We want for string\r\nstarting at be either , or . Consider these cases independently (however\r\nthe procedure is pretty much same).All such strings form a segment of\r\nSuffix Array, we can for example use LCP + binary search over sparse\r\ntables to find corresponding bounds.Then we just need to query this\r\nsegment and check if the maximum on it is at least .The solution is\r\n"
}