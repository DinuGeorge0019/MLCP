{"link": "https://codeforces.com//contest/93/problem/D", "problemId": "490", "problem_idx": "D", "shortId": "93D", "contest_number": "93", "problem_submissions": {"A": [521776, 517818, 515968, 521620, 515336, 515494, 515586, 516401, 516364, 515835, 515706, 515699, 516086, 515571, 516451, 515686, 517180, 515890], "C": [521495, 523124, 520751, 518945, 519514, 522564, 518461, 518952, 520378, 523893], "B": [520104, 519620, 517351, 522194, 517866, 516448, 517227, 517424, 518501, 518059, 517716, 516479, 517644, 518282, 517141, 521658, 521081, 517510], "D": [519028, 516572, 521899, 520914, 520442, 521998, 519962, 521491, 519991, 520880, 521627], "E": [517896, 522663, 522642, 521575, 519373, 517632, 518940, 522345, 524441, 519972, 520124, 519740, 523045, 522914, 520561, 1336700]}, "name": "D. Flags", "statement": "When Igor K. was a freshman, his professor strictly urged him, as well\r\nas all other freshmen, to solve programming Olympiads. One day a problem\r\ncalled \"Flags\" from a website called Timmy\u2019s Online Judge caught his\r\nattention. In the problem one had to find the number of three-colored\r\nflags that would satisfy the condition... actually, it doesn\u2019t matter.\r\nIgor K. quickly found the formula and got the so passionately desired\r\nAccepted.However, the professor wasn\u2019t very much impressed. He decided\r\nthat the problem represented on Timmy\u2019s Online Judge was very dull and\r\nsimple: it only had three possible colors of flag stripes and only two\r\nlimitations. He suggested a complicated task to Igor K. and the fellow\r\nfailed to solve it. Of course, we won\u2019t tell anybody that the professor\r\ncouldn\u2019t solve it as well.And how about you? Can you solve the\r\nproblem?The flags consist of one or several parallel stripes of similar\r\nwidth. The stripes can be one of the following colors: white, black, red\r\nor yellow. You should find the number of different flags with the number\r\nof stripes from to , if: a flag cannot have adjacent stripes of one\r\ncolor; a flag cannot have adjacent white and yellow stripes; a flag\r\ncannot have adjacent red and black stripes; a flag cannot have the\r\ncombination of black, white and red stripes following one after another\r\nin this or reverse order; symmetrical flags (as, for example, a WB and a\r\nBW flag, where W and B stand for the white and black colors) are\r\nconsidered the same.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007ll\n\n#define D 51\nstruct matrix {ll a[D][D];};\n\nmatrix mat_prod(matrix &A, matrix &B){\n    int i,j,k;\n    matrix ans;\n    REP(i,D) REP(j,D) ans.a[i][j] = 0;\n    REP(i,D) REP(k,D) REP(j,D) ans.a[i][j] = (ans.a[i][j] + A.a[i][k] * B.a[k][j]) % MOD;\n    return ans;\n}\n\nmatrix mat_pow(matrix &A, ll N){\n    int i,j;\n    matrix ans;\n    REP(i,D) REP(j,D) ans.a[i][j] = ((i == j) ? 1 : 0);\n    for(i=62;i>=0;i--) if(N&(1ll<<i)) break;\n    for(;i>=0;i--){\n        ans = mat_prod(ans,ans);\n        if(N&(1ll<<i)) ans = mat_prod(ans,A);\n    }\n    return ans;\n}\n\nll func(int N){\n    int i,j,k;\n    \n    matrix A;\n    REP(i,51) REP(j,51) A.a[i][j] = 0;\n    REP(i,5) REP(j,5) REP(k,4) if(j/2 != k/2 && (j != 2 || i >= 2 || k >= 2 || i == k)){\n        A.a[25+i*5+j][j*5+k]++;\n        A.a[i*5+j][25+j*5+k]++;\n        A.a[25+i*5+j][50]++;\n        A.a[i*5+j][50]++;\n    }\n    A.a[50][50]++;\n    \n    matrix B = mat_pow(A,N);\n    return B.a[24][50];\n}\n\nll func2(int N){\n    return (func(N) + func((N+1)/2)) % MOD;\n}\n\nint main(void){\n    int L,R;\n    \n    cin >> L >> R;\n    ll ans = func2(R);\n    if(L > 1) ans -= func2(L-1);\n    ans = (ans + MOD) % MOD;\n    ans = ans * ((MOD + 1) / 2) % MOD;\n    cout << ans << endl;\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "math", "matrices"], "dificulty": "2500", "interactive": false}