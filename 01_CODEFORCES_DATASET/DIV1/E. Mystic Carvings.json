{"link": "https://codeforces.com//contest/297/problem/E", "problemId": "2863", "problem_idx": "E", "shortId": "297E", "contest_number": "297", "problem_submissions": {"E": [3573577, 3572177, 3599204, 3789658, 3600333], "C": [3572198, 3569026, 3567778, 3569809, 3574619, 3568949, 3571082, 3571182, 3571915, 3572417, 3571389, 3576338, 3581124], "D": [3571285, 3568393, 3572434, 3572411, 3572809, 3569746, 3574175, 3574132, 3574196, 3574904, 3574825, 3575155, 3572689, 3572000, 3569044, 3569682, 3569691, 3570483, 3570423], "B": [3565273, 3565232, 3566085, 3565337, 3567367, 3565921, 3564958, 3565122, 3565530, 3566819, 3566006, 3566209, 3567427, 3565310, 3565669, 3565428, 3567419, 3567159, 3565321], "A": [3564985, 3564892, 3565047, 3564918, 3565603, 3565210, 3574423, 3565848, 3568320, 3564943, 3565186, 3565376, 3565311, 3564926, 3564908, 3564901, 3566394, 3565891, 3566461]}, "name": "E. Mystic Carvings", "statement": "The polar bears have discovered a gigantic circular piece of floating\r\nice with some mystic carvings on it. There are lines carved on the ice.\r\nEach line connects two points on the boundary of the ice (we call these\r\npoints ). The endpoints are numbered counter-clockwise along the\r\ncircumference. No two lines share an endpoint.Now a group of 6 polar\r\nbears (Alice, Bob, Carol, Dave, Eve, Frank) are going to build caves on\r\nthe endpoints. Each polar bear would build a cave and live in it. No two\r\npolar bears can build a cave on the same endpoints. Alice and Bob is a\r\npair of superstitious lovers. They believe the lines are carved by\r\naliens (or humans, which are pretty much the same thing to polar bears),\r\nand have certain spiritual power. Therefore they want to build their\r\ncaves on two endpoints which are connected by a line. The same for Carol\r\nand Dave, Eve and Frank.The between two caves X and Y is defined as one\r\nplus minimum number of other caves one need to pass through in order to\r\ntravel from X to Y along the boundary of the ice (endpoints without\r\ncaves are not counted).To ensure fairness, the distances between the\r\nthree pairs of lovers have to be the same (that is, the distance between\r\nAlice and Bob, the distance between Carol and Dave, and the distance\r\nbetween Eve and Frank are the same).The figures below show two different\r\nconfigurations, where the dots on the circle are the endpoints. The\r\nconfiguration on the left is not valid. Although each pair of lovers (A\r\nand B, C and D, E and F) is connected a line, the distance requirement\r\nis not satisfied. The distance between A and B is 2 (one can go from A\r\nto B in the clockwise direction passing through F). The distance between\r\nE and F is also 2. However, the distance between C and D is 1 (one can\r\ngo from C to D in the counter-clockwise direction without passing\r\nthrough any other caves). The configuration on the right is valid. All\r\nthree pairs have the same distance 1. Count the number of ways to build\r\nthe caves under the requirements. Two configurations are considered the\r\nsame if the same set of 6 endpoints are used.\r\n", "solutions": ["#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nconst int N = 444444;\n\nint a[N], b[N], s[N], inter[N], inside[N], p[N], id[N];\nint t;\n\nvoid modify(int x, int v) {\n  while (x <= t) {\n    s[x] += v;\n    x = (x | (x-1)) + 1;\n  }\n}\n\nint find(int x) {\n  int v = 0;\n  while (x > 0) {\n    v += s[x];\n    x &= x-1;\n  }\n  return v;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i=1;i<=n;i++) {\n    scanf(\"%d %d\", a+i, b+i);\n    if (a[i] > b[i]) { int tmp = a[i]; a[i] = b[i]; b[i] = tmp; }\n  }\n  for (int i=1;i<=n;i++) {\n    p[a[i]] = b[i];\n    p[b[i]] = a[i];\n    id[a[i]] = i;\n    id[b[i]] = i;\n  }\n  t = 2*n;\n  for (int i=1;i<=t;i++) s[i] = 0;\n  for (int i=1;i<=t;i++) {\n    if (p[i] < i) {\n      inside[id[i]] = find(i) - find(p[i]-1);\n      modify(p[i], 1);\n    }\n  }\n  for (int i=1;i<=n;i++) inter[i] = (b[i]-a[i]-1) - 2*inside[i];\n  long long ans = (long long)n*(n-1)*(n-2)/6;\n  long long cnt1 = 0, cnt2 = 0;\n  for (int i=1;i<=n;i++) {\n    cnt1 += (long long)inter[i] * (n-inter[i]-1);\n    cnt2 += (long long)inside[i] * (n-inter[i]-inside[i]-1);\n  }\n  ans -= (cnt1/2 + cnt2);\n  cout << ans << endl;\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3000", "interactive": false}