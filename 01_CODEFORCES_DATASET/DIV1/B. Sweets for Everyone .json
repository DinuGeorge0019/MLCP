{"link": "https://codeforces.com//contest/249/problem/B", "problemId": "2271", "problem_idx": "B", "shortId": "249B", "contest_number": "249", "problem_submissions": {"B": [2649094, 2645222, 2648325, 2645133, 2741637, 2647160, 2646906, 2647140, 2647297, 2647803, 2649557, 2647782, 2649225, 2647984], "C": [2648016, 2646272, 2649752, 2649594, 2648682, 2650241, 2650113], "D": [2646289, 2646128, 2648091, 2747311, 2647914, 2649873, 2686963, 3563620], "A": [2645128, 2644427, 2643471, 2646603, 2643981, 2650080, 2644186, 2645243, 2644193, 2644672, 2644232, 2644059, 2650955, 2650931, 2645477, 2644588, 2644531], "E": [2649181, 2648187, 2749553, 2893989]}, "name": "B. Sweets for Everyone ", "statement": "For he knew every Who down in Whoville beneath, Was busy now, hanging a\r\nmistletoe wreath. \"And they\u2019re hanging their stockings!\" he snarled with\r\na sneer, \"Tomorrow is Christmas! It\u2019s practically here!\"Dr. Suess, How\r\nThe Grinch Stole ChristmasChristmas celebrations are coming to Whoville.\r\nCindy Lou Who and her parents Lou Lou Who and Betty Lou Who decided to\r\ngive sweets to all people in their street. They decided to give the\r\nresidents of each house on the street, one kilogram of sweets. So they\r\nneed as many kilos of sweets as there are homes on their street.The\r\nstreet, where the Lou Who family lives can be represented as consecutive\r\nsections of equal length. You can go from any section to a neighbouring\r\none in one unit of time. Each of the sections is one of three types: an\r\nempty piece of land, a house or a shop. Cindy Lou and her family can buy\r\nsweets in a shop, but no more than one kilogram of sweets in one shop\r\n(the vendors care about the residents of Whoville not to overeat on\r\nsweets).After the Lou Who family leave their home, they will be on the\r\nfirst section of the road. To get to this section of the road, they also\r\nrequire one unit of time. We can assume that Cindy and her mom and dad\r\ncan carry an unlimited number of kilograms of sweets. Every time they\r\nare on a house section, they can give a kilogram of sweets to the\r\ninhabitants of the house, or they can simply move to another section. If\r\nthe family have already given sweets to the residents of a house, they\r\ncan\u2019t do it again. Similarly, if they are on the shop section, they can\r\neither buy a kilo of sweets in it or skip this shop. If they\u2019ve bought a\r\nkilo of sweets in a shop, the seller of the shop remembered them and the\r\nwon\u2019t sell them a single candy if they come again. The time to buy and\r\ngive sweets can be neglected. The Lou Whos do not want the people of any\r\nhouse to remain without food.The Lou Whos want to spend no more than\r\ntime units of time to give out sweets, as they really want to have\r\nenough time to prepare for the Christmas celebration. In order to have\r\ntime to give all the sweets, they may have to initially bring additional\r\nkilos of sweets.Cindy Lou wants to know the minimum number of kilos of\r\nsweets they need to take with them, to have time to give sweets to the\r\nresidents of each house in their street.Your task is to write a program\r\nthat will determine the minimum possible value of .\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int MAXL = 5e5 + 1e3;\nint n, t;\nchar dat[MAXL + 1];\n\nint main() {\n  #ifdef DEBUG\n  freopen(\"std.in\", \"r\", stdin);\n  freopen(\"std.out\", \"w\", stdout);\n  #endif\n\n  int n;\n  while (scanf(\"%d%d%s\", &n, &t, dat) >= 1) {\n    int hl = n, hr = -1, hcnt = 0;\n    vi shops;\n    for (int i = 0; i < n; i++)\n      if (dat[i] == 'H') {\n        hl = min(hl, i);\n        hr = max(hr, i);\n        hcnt++;\n      } else if (dat[i] == 'S') {\n        shops.pb(i);\n      }\n\n    t--;\n    if (hr > t) printf(\"-1\\n\");\n    else {\n      int L = -1, R = hcnt;\n      while (L + 1 < R) {\n        int M = (L + R) / 2;\n        assert(M < hcnt);\n        bool good = false;\n        int rem = hcnt - M;\n        if (rem <= sz(shops)) {\n          int maxpos = max(hr, shops[rem - 1]);\n\n          int ctim = maxpos;\n          int btim = 2e9;\n\n          int bal = M;\n\n          for (int i = 0; i <= maxpos; i++) {\n            if (dat[i] == 'H') bal--;\n            else if (dat[i] == 'S') bal++;\n            if (bal < 0) {\n              btim = min(btim, ctim + maxpos - i);\n              ctim += 2;\n            }\n          }\n          btim = min(btim, ctim);\n          if (btim <= t) good = true;\n//          eprintf(\"M=%d %d; %d %d\\n\", M, good, ctim, t);\n        }\n        if (good) R = M;\n        else L = M;\n      }\n      printf(\"%d\\n\", R);\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "greedy"], "dificulty": "2300", "interactive": false}