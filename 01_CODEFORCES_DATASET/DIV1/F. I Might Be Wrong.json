{
    "link": "https://codeforces.com//contest/1693/problem/F",
    "problemId": "1430893",
    "problem_idx": "F",
    "shortId": "1693F",
    "contest_number": "1693",
    "problem_submissions": {
        "F": [
            160880007,
            160880972,
            160861674,
            160875588,
            160882783,
            160878948,
            160890167,
            160899913,
            161040863,
            160893311,
            160892940
        ],
        "E": [
            160864775,
            160851833,
            160876978,
            160893451,
            160863343,
            160869365,
            160873611,
            160876701,
            160883190,
            160881001,
            160869009,
            160890042,
            160889537,
            160889370,
            160888603,
            160888570,
            160884303
        ],
        "D": [
            160848374,
            160868923,
            160880702,
            160854200,
            160854032,
            160862911,
            160859336,
            160861278,
            160860933,
            160866823,
            160880935,
            160874455,
            160855846,
            160857826,
            160858928,
            160851586,
            160859103
        ],
        "C": [
            160833863,
            160838237,
            160831750,
            160839496,
            160831595,
            160847471,
            160845192,
            160845432,
            160842623,
            160834916,
            160845029,
            160853816,
            160836315,
            160837724,
            160840237,
            160837127,
            160842065,
            160837528
        ],
        "B": [
            160829995,
            160831749,
            160828393,
            160835792,
            160838408,
            160836721,
            160840343,
            160837858,
            160837790,
            160829673,
            160840637,
            160838527,
            160830551,
            160831811,
            160831387,
            160832406,
            160834629,
            160831231
        ],
        "A": [
            160824784,
            160824733,
            160824181,
            160826982,
            160842765,
            160829489,
            160836610,
            160834230,
            160827824,
            160825693,
            160827125,
            160830489,
            160824662,
            160825298,
            160825387,
            160826936,
            160829963,
            160825879
        ]
    },
    "name": "F. I Might Be Wrong",
    "statement": "You are given a binary string S of length n indexed from 1 to n. You can\r\nperform the following operation any number of times (possibly\r\nzero):Choose two integers l and r (1\r\nle l\r\nle r\r\nle n). Let cnt_0 be the number of times occurs in S[l\r\nldots r] and cnt_1 be the number of times occurs in S[l\r\nldots r]. You can pay |cnt_0 - cnt_1| + 1 coins and sort the S[l\r\nldots r]. (by S[l\r\nldots r] we mean the substring of S starting at position l and ending at\r\nposition r)For example if S = , we can perform the operation on S[2\r\nldots 4], paying |2 - 1| + 1 = 2 coins, and obtain S = as a new\r\nstring.Find the minimum total number of coins required to sort S in\r\nincreasing order.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nint tab[nax];\n\nchar wcz[nax];\n\nint kt[nax];\nint dp[nax];\n\nvoid ans(int v)\n{\n\tprintf(\"%d\\n\", v);\n}\n\nint fen[10*nax];\n\nvoid reset()\n{\n\tfor (int i=1; i<=20*(n+17); i++)\n\t\tfen[i]=nax;\n}\n\nvoid pisz(int v, int w)\n{\n\tv+=(n+17)*10;\n\tfor (int i=v; i<=20*(n+17); i+=(i&(-i)))\n\t\tfen[i]=min(fen[i], w);\n}\n\nint czyt(int v)\n{\n\tint ret=nax;\n\tv+=(n+17)*10;\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tret=min(fen[i], ret);\n\treturn ret;\n}\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t\ttab[i]=wcz[i]-'0';\n\tvi ile{0, 1};\n\tfor (int i=1; i<=n; i++)\n\t\tile[tab[i]]++;\n\tif (ile[1]>ile[0])\n\t{\n\t\treverse(tab+1, tab+1+n);\n\t\tfor (int i=1; i<=n; i++)\n\t\t\ttab[i]^=1;\n\t}\n\t//~ debug() << range(tab+1, tab+1+n);\n\t{\n\t\tint zero=1;\n\t\tfor (int i=2; i<=n; i++)\n\t\t\tif (tab[i]<tab[i-1])\n\t\t\t\tzero=0;\n\t\tif (zero)\n\t\t{\n\t\t\tans(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tkt[i]=kt[i-1]+tab[i];\n\t\tdp[i]=nax;\n\t}\n\tint p=1;\n\twhile(!tab[p])\n\t\tp++;\n\tdp[p]=0;\n\treset();\n\tfor (int i=p+1; i<=n; i++)\n\t{\n\t\tpisz((i-1)-kt[i-1], dp[i-1]-((i-1)-kt[i-1]));\n\t\tdp[i]=czyt(i-2*kt[i])+i-2*kt[i]+1;\n\t}\n\t//~ for (int i=p+1; i<=n; i++)\n\t//~ {\n\t\t//~ for (int j=p; j<i; j++)\n\t\t//~ {\n\t\t\t//~ if (i-2*kt[i]>=(j-kt[j]))\n\t\t\t\t//~ dp[i]=min(dp[i], dp[j]+abs(i-j-2*kt[i]+kt[j])+1);\n\t\t//~ }\n\t//~ }\n\t//~ debug() << range(kt+1, kt+1+n);\n\t//~ debug() << range(dp+1, dp+1+n);\n\tint wyn=dp[n];\n\tfor (int i=p; i<=n; i++)\n\t{\n\t\t//~ if (kt[i]!=kt[n])\n\t\t\t//~ continue;\n\t\t//~ debug() << i << \" \" << \n\t\twyn=min(wyn, dp[i]+max(n-i-2*kt[n]+kt[i], 0)+1);\n\t}\n\tprintf(\"%d\\n\", wyn);\n\t//~ exit(0);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "two pointers"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. I Might Be Wrong.json",
    "editorial_link": "https://codeforces.com//blog/entry/103952",
    "editorial": "- we only sort with segments with balance .Proof: Imagine we have sorted\r\ninterval and it has more zeros than it has ones. So this operation costs\r\ncoins. has to be otherwise we could just sort with coins.Now that we\r\nknow is there exists some that the interval has equal number of zeros\r\nand ones. Because the interval has more ones but the interval has more\r\nzeros.Sort with cost and then sort with cost . And we know we can sort\r\nsuch that we only sort segments with balance .- If everything is sorted\r\ncool. Suppose now the number of ones is greater than the number of\r\nzeros.- Replace by , by , draw prefix sums. We have points , (initially\r\n), where , , and the operation is: choosing , such that and making\r\npoints between them first decrease then increase.Denote by AmShZ\r\nstrategy the following procedure: while isnât sorted, Let be the\r\nsmallest such that numbers from to increase. If , we sort in operation.\r\nOtherwise, let be the smallest such that . Apply operation to . We have\r\nto show that AmShZ strategy is optimal.Letâs denote by the smallest\r\nnumber of operations required for the current configuration. We will\r\nprove that AmShZ strategy ends in iterations by induction over and over\r\nnumber of inversions in . (Clearly any non-identical operation decreases\r\nnumber of inversions so thatâs useful).Denote by string in which suffix\r\nof length is sorted.: If , then AmShZ strategy for uses at most as many\r\noperations as for . : trivialSuppose now that we have proved our\r\nstatement for all strings with the number of inversions less than in\r\n.Now, let be the smallest such that numbers from to increase and be the\r\nsmallest such that . Suppose that there is a sorting sequence that uses\r\nfewer operations than AmShZ strategy. Letâs denote its first operation\r\nby .Consider several cases: . This means that we basically end up in\r\nstring . But we could have ended up in string , which uses at most the\r\nsame number of operations . Clearly, after operation can only decrease,\r\nso will still be the smallest index with . By induction hypothesis,\r\nAmShZ strategy is optimal for resulting string, so the next operation in\r\nresulting string will be opertion . But then we could have done first\r\nand then . . As , the smallest index such that are increasing hasnât\r\nchanged. Numbers from to also havenât changed, so remains the same. So\r\nthe next move according to AmShZ strategy will be operation , so\r\noperation was useless Last case. . Note that all numbers up to will be\r\nstrictly smallest then now. So we will have some new smallest such that\r\n. Then according to AmShZ strategy in the next move we will do operation\r\n. But then we could instead do first, and then . But this is not\r\noptimal, as AmShZ strategy sorts at least as fast as .\r\n",
    "hint": []
}