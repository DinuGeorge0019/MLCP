{
    "link": "https://codeforces.com//contest/559/problem/C",
    "problemId": "31962",
    "problem_idx": "C",
    "shortId": "559C",
    "contest_number": "559",
    "problem_submissions": {
        "E": [
            12182515,
            12187399,
            141685289,
            12274173,
            12181231,
            12175304,
            12176173
        ],
        "D": [
            12174436,
            12174384,
            12175184,
            12184862,
            12179042,
            12177010,
            12178587,
            49075843,
            12177521,
            12178544,
            12177403,
            12177707,
            12177850,
            12180968,
            12184700,
            12184490,
            12181105,
            12182102,
            12177181
        ],
        "B": [
            12168424,
            12165732,
            12167442,
            12165414,
            12170869,
            12165053,
            12170711,
            12167857,
            12167750,
            12165064,
            12170170,
            12165197,
            12169015,
            12167991,
            12167961,
            12167252,
            12165704,
            12179411
        ],
        "C": [
            12166898,
            12169572,
            12170142,
            12166836,
            12168670,
            12169914,
            12171548,
            12172425,
            12171036,
            12171573,
            12167528,
            12170704,
            12170899,
            12172108,
            12170757,
            12172559,
            12170995,
            12170579
        ],
        "A": [
            12164711,
            12164664,
            12165120,
            12164570,
            12172440,
            12167121,
            12167930,
            12166447,
            12185370,
            12166201,
            12165955,
            12170667,
            12167349,
            12166038,
            12183406,
            12165416,
            12164553,
            12178800
        ]
    },
    "name": "C. Gerald and Giant Chess",
    "statement": "Giant chess is quite common in Geraldion. We will not delve into the\r\nrules of the game, we’ll just say that the game takes place on an field,\r\nand it is painted in two colors, but not like in chess. Almost all cells\r\nof the field are white and only some of them are black. Currently Gerald\r\nis finishing a game of giant chess against his friend Pollard. Gerald\r\nhas almost won, and the only thing he needs to win is to bring the pawn\r\nfrom the upper left corner of the board, where it is now standing, to\r\nthe lower right corner. Gerald is so confident of victory that he became\r\ninterested, in how many ways can he win?The pawn, which Gerald has got\r\nleft can go in two ways: one cell down or one cell to the right. In\r\naddition, it can not go to the black cells, otherwise the Gerald still\r\nloses. There are no other pawns or pieces left on the field, so that,\r\naccording to the rules of giant chess Gerald moves his pawn until the\r\ngame is over, and Pollard is just watching this process.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nPII p[2010];\nll dp[2010],f[201000];\nint h,w,n;\nll go(ll x,ll y) {\n\tassert(x>=0&&y>=0);\n\treturn f[x+y]*powmod(f[x]*f[y],mod-2)%mod;\n}\nint main() {\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tf[0]=1;\n\trep(i,1,200001) f[i]=f[i-1]*i%mod;\n\trep(i,0,n) scanf(\"%d%d\",&p[i].fi,&p[i].se);\n\tp[n]=mp(h,w); p[n+1]=mp(1,1); n+=2;\n\tsort(p,p+n); \n\tdp[0]=1;\n\trep(i,1,n) {\n\t\tdp[i]=go(p[i].fi-1,p[i].se-1);\n\t\trep(j,1,i) if (p[j].fi<=p[i].fi&&p[j].se<=p[i].se)\n\t\t\tdp[i]=(dp[i]-go(p[i].fi-p[j].fi,p[i].se-p[j].se)*dp[j])%mod;\n\t}\n\t(dp[n-1]+=mod)%=mod;\n\tprintf(\"%I64d\\n\",dp[n-1]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Gerald and Giant Chess.json",
    "editorial_link": "https://codeforces.com//blog/entry/19237",
    "editorial": "Letâs denote black cells ad . First of all, we have to sort black cells\r\nin increasing order of (row, column). If cell available from cell ,\r\nstands after in this order. Let . Now we have to find number of paths\r\nfrom to avoiding . Let is number of paths from to avoiding . Itâs easy\r\nto see that is answer for the problem. Number of all paths from to is .\r\nWe should subtract from that value all paths containing at least one of\r\nprevious black cells. We should enumerate first black cell on the path.\r\nIt could be one of previous cell that is not below or righter than . For\r\neach such cell we have to subtract number of paths from to avoiding\r\nblack cells multiplied by number of all paths from to . We have to\r\ncalculate factorials of numbers from to and inverse elements of them\r\nmodulo for calculating binomial coefficients.\r\n",
    "hint": []
}