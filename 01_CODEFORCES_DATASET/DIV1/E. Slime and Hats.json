{
    "link": "https://codeforces.com//contest/1349/problem/E",
    "problemId": "619063",
    "problem_idx": "E",
    "shortId": "1349E",
    "contest_number": "1349",
    "problem_submissions": {
        "D": [
            79861873,
            79861806,
            79948658,
            79858494,
            79903166,
            131108532,
            79877857,
            79879188,
            79879019,
            79872081,
            80757765,
            79874857,
            79891331
        ],
        "C": [
            79835117,
            79843720,
            79834387,
            79845607,
            79830281,
            79843236,
            79849443,
            79848794,
            79845617,
            79852466,
            79831253,
            79854349,
            79853472,
            79844058,
            79856498,
            79879255,
            79856862,
            79848324,
            79861537
        ],
        "B": [
            79827155,
            79837122,
            79822255,
            79821907,
            79838530,
            79834646,
            79835497,
            79841171,
            79842066,
            79829421,
            79839013,
            79841661,
            79841348,
            79839739,
            79833357,
            79841018,
            79840476,
            79842544,
            79837256,
            79834808
        ],
        "A": [
            79817454,
            79821533,
            79816750,
            79834360,
            79820968,
            90907998,
            90906860,
            90496887,
            79817368,
            94393615,
            79825623,
            79828847,
            79817688,
            79819374,
            79828023,
            79820779,
            79831851,
            79831246,
            79823300,
            79821494,
            79829816,
            79823411,
            79929306,
            79822107
        ],
        "E": [
            85193181,
            79886501,
            80023736
        ],
        "F2": [
            81605329,
            85716790,
            84837609,
            84835671,
            80416603,
            80415302,
            80161085
        ],
        "F1": [
            79982046,
            79890867,
            79859528,
            80154258,
            79886462,
            79874667,
            79884418,
            79878453,
            79892295,
            79881330,
            79892657,
            79875367,
            79882448,
            79932700
        ]
    },
    "name": "E. Slime and Hats",
    "statement": "Slime and Orac are holding a turn-based game. In a big room, there are n\r\nplayers sitting on the chairs, looking forward to a column and each of\r\nthem is given a number: player 1 sits in the front of the column, player\r\n2 sits directly behind him; player 3 sits directly behind player 2, and\r\nso on; player n sits directly behind player n-1. Each player wears a hat\r\nthat is either black or white. As each player faces forward, player i\r\nknows the color of player j’s hat if and only if i is larger than j.At\r\nthe start of each turn, Orac will tell .After Orac speaks, if the player\r\ncan uniquely identify the color of his hat, he will put his hat on the\r\nchair, stand up and leave the room. All players are smart, so if it is\r\npossible to understand the color of their hat using the obtained\r\ninformation during this and previous rounds, they will understand it. In\r\neach turn, all players who know the color of their hats will leave at\r\nthe same time in this turn, which means a player can only leave in the\r\nnext turn if he gets to know the color of his hat only after someone\r\nleft the room at this turn.Note that when the player needs to leave, he\r\nwill put the hat on the chair before leaving, so the players ahead of\r\nhim still cannot see his hat. The i-th player will know who exactly left\r\nthe room among players 1,2,\r\nldots,i-1, and how many players among i+1,i+2,\r\nldots,n have left the room.Slime stands outdoor. He watches the players\r\nwalking out and records the numbers of the players and the time they get\r\nout. Unfortunately, Slime is so careless that he has only recorded some\r\nof the data, and this given data is in the format \"\".Slime asked you to\r\ntell him the color of each player’s hat. If there are multiple\r\nsolutions, you can find any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\n//[l,r)\nbool canmake(int l,int r,int tar){\n\tif(tar<0)return false;\n\tif(tar==0)return true;\n\tint lw=0,up=r-l+1;\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tint v=(r-mid+r-1)*mid/2;\n\t\tif(v>=tar)up=mid;\n\t\telse lw=mid;\n\t}\n\tif(up==r-l+1)return false;\n\tint v=(l+l+up-1)*up/2;\n\treturn v<=tar;\n}\n\nvi restore(int l,int r,int tar){\n\tif(tar<0)assert(0);\n\tif(tar==0)return {};\n\tint lw=0,up=r-l+1;\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tint v=(r-mid+r-1)*mid/2;\n\t\tif(v>=tar)up=mid;\n\t\telse lw=mid;\n\t}\n\tif(up==r-l+1)assert(0);\n\tint v=(l+l+up-1)*up/2;\n\tassert(v<=tar);\n\tvi res(up);\n\trep(i,up)res[i]=l+i;\n\tint dif=tar-v;\n\tper(i,up){\n\t\tint u=min(r-up+i-res[i],dif);\n\t\tres[i]+=u;\n\t\tdif-=u;\n\t}\n\tassert(dif==0);\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tvi t=readvi(n);\n\tt.pb(0);\n\treverse(all(t));\n\tn++;\n\tfor(auto&v:t)if(v)v+=n;\n\tt.pb(n++);\n\tdmp(t);\n\t\n\tvi pre(n,-1);\n\tpre[n-1]=-2;\n\tvi mx(n,-1);\n\tvi left(n);\n\tvc<tuple<int,int,int>> buf(n);\n\tint fix=n-1;\n\tdeque<int> fr,bc;\n\tconst int B=5;\n\tper(i,n-1){\n\t\tauto waf=[&](int z,int tar){\n\t\t\tif(i==1&&z==5){\n\t\t\t\tdmp(tar);\n\t\t\t\tdmp(mx[z]);\n\t\t\t}\n\t\t\tif(pre[z]!=-1){\n\t\t\t\tint ad=tar-t[z];\n\t\t\t\tif(canmake(left[z],z,ad)){\n\t\t\t\t\tbuf[i]=mt(left[z],z,ad);\n\t\t\t\t\tpre[i]=z;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mx[z]!=-1){\n\t\t\t\tint ad=tar-(t[z]-1);\n\t\t\t\tif(canmake(left[z],mx[z],ad)){\n\t\t\t\t\tbuf[i]=mt(left[z],mx[z],ad);\n\t\t\t\t\tpre[i]=mx[z];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(t[i]){\n\t\t\tfr.push_front(fix);\n\t\t\twhile(t[fr.front()]!=t[fr.back()]){\n\t\t\t\tbc.push_front(fr.back());\n\t\t\t\tfr.pop_back();\n\t\t\t}\n\t\t\tleft[fix]=i+1;\n\t\t\tfix=i;\n\t\t\tint tar=t[i]-i;\n\t\t\tdmp2(i,tar);\n\t\t\tif(i<B){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(auto z:fr){\n\t\t\t\t\tif(ok)waf(z,tar);\n\t\t\t\t\tif(t[z]!=t[i]+1)ok=false;\n\t\t\t\t}\n\t\t\t\tfor(auto z:bc){\n\t\t\t\t\tif(ok)waf(z,tar);\n\t\t\t\t\tif(t[z]!=t[i]+1)ok=false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(t[fr[0]]==t[i]+1){\n\t\t\t\t\tif(si(bc)){\n\t\t\t\t\t\twaf(bc[0],tar);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\twaf(fr[0],tar);\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(si(fr)){\n\t\t\tint tar=t[fix]-1-i;\n\t\t\tif(i<B){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(auto z:fr){\n\t\t\t\t\tif(ok)waf(z,tar);\n\t\t\t\t\tif(t[z]!=t[fix])ok=false;\n\t\t\t\t}\n\t\t\t\tfor(auto z:bc){\n\t\t\t\t\tif(ok)waf(z,tar);\n\t\t\t\t\tif(t[z]!=t[fix])ok=false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(t[fr[0]]==t[fix]){\n\t\t\t\t\tif(si(bc)){\n\t\t\t\t\t\twaf(bc[0],tar);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\twaf(fr[0],tar);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pre[i]!=-1&&mx[fix]==-1)mx[fix]=i;\n\t\t}\n\t}\n\tdmp(pre);\n\tdmp(buf);\n\tvi res(n);\n\tint cur;\n\trep(i,n)if(pre[i]!=-1){\n\t\tcur=i;\n\t\tbreak;\n\t}\n\twhile(1){\n\t\tres[cur]=1;\n\t\tif(pre[cur]==-2)break;\n\t\tint l,r,ad;\n\t\ttie(l,r,ad)=buf[cur];\n\t\t\n\t\tvi idx=restore(l,r,ad);\n\t\tfor(auto i:idx)res[i]=1;\n\t\t\n\t\tcur=pre[cur];\n\t}\n\tdmp(res);\n\tgnr(i,1,n-1)print(res[i],0);\n\tcout<<endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Slime and Hats.json",
    "editorial_link": "https://codeforces.com//blog/entry/77284",
    "editorial": "First, letâs renumber the players for convenience. Number the player at\r\nthe front as the player sitting behind him as , and so on. Let be the\r\ncolor of player âs hat. Consider how to calculate if we have already\r\nknown . If , then . Otherwise, let be the maximal number of a player\r\nwith a black hat. In the first turn, player knows that someone wears a\r\nblack hat. If , player finds out that everyone except him wears a white\r\nhat, so he wears a black hat and he leaves. In the second turn, other\r\nplayers can figure out that . Therefore, . If , there is a player with a\r\nblack hat sitting in front of player , so he canât figure out the color\r\nof his own hat and doesnât leave. Other players know that in the next\r\nturn, and the problem is transformed into a subproblem on player . No\r\none leaves until the -th turn, player knows that there is at least one\r\nplayer with a black hat in , but player all wear white hats, so he\r\nleaves. In the next turn, leaves.According to the above process, player\r\nleaves in the -th turn, player leave in the -th turn, and a new process\r\nbegins. Therefore, we can figure out the value of . - If , then . Let\r\n. - If , let be the maximal number which satisfies and , then . For\r\nconvenience, let , so always exists. Let .Therefore, we can calculate\r\nusing , and is satisfied. Consider how to solve the original problem.\r\nBefore using dynamic programming to solve the problem, we need to do\r\nsome preparation for that.If and , it is obviously that . Also, if , .\r\nTherefore, In fact, if , we have It is not difficult to prove the\r\nformula above with some simple classified discussions.Define a set of\r\nintervals which satisfies these rules: , is given. , if is given, For\r\nall pairs where and are both given, and are in the same interval if and\r\nonly if . If , it can be known that and . Let .After the preparatory\r\nwork, letâs work on dp. Let be the maximal possible value of when .\r\nConsider how to calculate if we know the value of and . For , enumerate\r\nall possible from large to small, might be satisfied if If can be\r\nnoticed that are already known, so we just need to check whether there\r\nexists some distinct integers in where the sum of them equals to , which\r\ncan be easily solved by binary search.Besides , record whether is\r\ntransformed from or . Using these we can easily give a solution.Notice\r\nthat when , doesnât satisfy . However, there is at most one in where .\r\nJust brute force which equals to is okay. The whole complexity is .\r\n",
    "hint": []
}