{"link": "https://codeforces.com//contest/1053/problem/C", "problemId": "223966", "problem_idx": "C", "shortId": "1053C", "contest_number": "1053", "problem_submissions": {"D": [43320967, 43321366, 43322493, 43325653, 43328216, 43329157, 43314103, 43329594, 43327708, 43331398, 43331864, 43331980, 43333170, 43320772, 43321907, 43347759, 43334692, 43316971, 43343476, 43341620, 43339949, 43337790], "C": [43307138, 43309894, 43312505, 43313721, 43312808, 43316109, 43324397, 43311885, 43312845, 43316905, 43321077, 43314278, 43317163, 43317332, 43329507, 43330889, 43311412, 43324598, 43338761, 46354235, 44718358, 43709718, 43709703, 43709682, 43515057, 43515052, 43483892, 43465752, 43464250, 43421524, 43400433, 43400425, 43385421, 43385407, 43354392, 43354373, 43354256, 43354129, 43354084, 43353946, 43353875, 43353862, 43338127, 43337856, 43317491], "B": [43302550, 43398321, 43398298, 43302971, 43303874, 43305537, 43304419, 43304489, 43303672, 43303860, 43307726, 43304869, 43306808, 43305251, 43304148, 43307156, 43307659, 43324162, 43300449, 43315267, 43326866, 43338204, 43337888, 43307003], "A": [43297754, 43298564, 43298952, 43299495, 43299534, 43304596, 43317168, 43299723, 43304344, 43300713, 43301168, 43300378, 43300680, 43298079, 43302518, 43299165, 43304630, 43311156, 43322106, 43301598], "E": [43366979, 43333450, 44387266, 43369111]}, "name": "C. Putting Boxes Together", "statement": "There is an infinite line consisting of cells. There are n boxes in some\r\ncells of this line. The i-th box stands in the cell a_i and has weight\r\nw_i. All a_i are distinct, moreover, a_{i - 1} < a_i holds for all valid\r\ni.You would like to put together some boxes. Putting together boxes with\r\nin the segment [l, r] means that you will move some of them in such a\r\nway that their will form some segment [x, x + (r - l)].In one step you\r\ncan move any box to a neighboring cell if it isn\u2019t occupied by another\r\nbox (i.e. you can choose i and change a_i by 1, all positions should\r\nremain distinct). You spend w_i units of energy moving the box i by one\r\ncell. You can move any box any number of times, in arbitrary\r\norder.Sometimes weights of some boxes change, so you have queries of two\r\ntypes: id nw weight w_{id} of the box id becomes nw. l r you should\r\ncompute the minimum total energy needed to put together boxes with\r\nindices in [l, r]. Since the answer can be rather big, print the\r\nremainder it gives when divided by 1000\r\n,000\r\n,007 = 10^9 + 7. Note that the boxes are not moved during the query, you\r\nonly should compute the answer.\r\n", "solutions": ["#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nconst int MOD=1e9+7;\nint n,q,a[SZ],w[SZ];\nstruct Fenwick1\n{\nll bs[SZ];\nvoid edt(int x,ll y)\n{\n\tfor(;x<=n;x+=x&-x) bs[x]+=y;\n}\nll qs(int x)\n{\n\tll s=0;\n\tfor(;x>=1;x-=x&-x) s+=bs[x];\n\treturn s;\n}\n}B0;\nstruct Fenwick\n{\nint bs[SZ];\nvoid edt(int x,int y)\n{\n\tfor(;x<=n;x+=x&-x) (bs[x]+=y)%=MOD;\n}\nll qs(int x)\n{\n\tint s=0;\n\tfor(;x>=1;x-=x&-x) (s+=bs[x])%=MOD;\n\treturn s;\n}\n}B1;\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",a+i),a[i]-=i;\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",w+i);\n\tfor(int i=1;i<=n;++i)\n\t\tB0.edt(i,w[i]),\n\t\tB1.edt(i,w[i]*(ll)a[i]%MOD);\n\twhile(q--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x<0)\n\t\t{\n\t\t\tx=-x; int dt=y-w[x];\n\t\t\tw[x]=y; B0.edt(x,dt);\n\t\t\tB1.edt(x,dt*(ll)a[x]%MOD);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll sl=B0.qs(x-1),\n\t\t\tsu=B0.qs(y)-sl;\n\t\t\tsu=(su+1)/2;\n\t\t\tint l=x,r=y;\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tint m=(l+r)>>1;\n\t\t\t\tif(B0.qs(m)-sl>=su) r=m;\n\t\t\t\telse l=m+1;\n\t\t\t}\n\t\t\tint m=l;\n\t\t\t//mid pos is m\n\t\t\tll ans=(B1.qs(y)-B1.qs(m))-\n\t\t\t(B0.qs(y)-B0.qs(m))%MOD*(a[m])%MOD\n\t\t\t-(B1.qs(m)-B1.qs(x-1))\n\t\t\t+(B0.qs(m)-B0.qs(x-1))%MOD*(a[m])%MOD;\n\t\t\tans=(ans%MOD+MOD)%MOD;\n\t\t\tprintf(\"%d\\n\",int(ans));\n\t\t}\n\t}\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures"], "dificulty": "2500", "interactive": false}