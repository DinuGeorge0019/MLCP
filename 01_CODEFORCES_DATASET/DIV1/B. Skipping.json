{
    "link": "https://codeforces.com//contest/2023/problem/B",
    "problemId": "2964365",
    "problem_idx": "B",
    "shortId": "2023B",
    "contest_number": "2023",
    "problem_submissions": {
        "F": [
            287014608,
            287072234,
            299830672,
            287085195,
            287027962,
            287042299,
            287238133,
            287043650
        ],
        "E": [
            286990891,
            287003441,
            287204391,
            287202274,
            287014470,
            287010378,
            287009293,
            287034992,
            287190288,
            287004818,
            287142133
        ],
        "D": [
            286943910,
            286985197,
            287179114,
            287178062,
            286983477,
            286986708,
            286993474,
            286930212,
            286984453,
            286985894,
            286983025,
            286981875,
            287091406,
            286988866,
            286991623,
            286991730,
            286972363,
            290388826,
            290388744,
            286996161,
            286993279,
            287000155,
            287068676,
            287061033,
            286997472,
            287003784
        ],
        "C": [
            286925333,
            287063584,
            286928411,
            286930839,
            286944563,
            286945303,
            286973941,
            286936797,
            286923792,
            286935049,
            286934113,
            286960906,
            286944493,
            286935726,
            286931426,
            286988231,
            286961072,
            286929444,
            286959433,
            286973882,
            286960461
        ],
        "B": [
            286913842,
            286912400,
            286915696,
            286920706,
            286917936,
            286918820,
            286920898,
            286929873,
            286915247,
            286917134,
            286915488,
            286916176,
            286919025,
            286919305,
            286914068,
            286921817,
            286912738,
            286921828,
            286922164,
            286920262
        ],
        "A": [
            286905356,
            286905575,
            286907414,
            286907460,
            286908014,
            286911602,
            286910636,
            286905107,
            286906378,
            286906055,
            286906420,
            286919318,
            286909880,
            286905489,
            286910067,
            286910062,
            286905533,
            286909956,
            286907288,
            286911621
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "Notice that it makes no sense for us to skip problems for which , since\r\nwe can solve the problem, earn points for it, and the next problem will\r\nbe chosen from the numbers . If we skip it, we do not earn points, and\r\nthe next problem will be chosen from the same set of problems or even a\r\nsmaller one.We also note that if we are at problem and the maximum\r\nproblem number that has been assigned to us earlier in the competition\r\nis , then it makes no sense to skip this problem, because after\r\nskipping, we could have reached the next problem from problem simply by\r\nsolving problems.Under these conditions, it turns out that all the\r\nproblems assigned to us, after the competition ends, are on some prefix\r\nof the set of problems (i.e., there exists some number from to such that\r\nall problems with numbers were received by us, and problems with numbers\r\nwere not received). This is indeed the case; let be the maximum problem\r\nnumber that has been assigned to us. After this problem is assigned, we\r\nwill not skip any more problems, as we have already proven that it is\r\nnot beneficial, which means we will only solve problems and will solve\r\nall problems with numbers that have not been visited before.Instead of\r\ntrying to maximize the total score for the solved problems, we will aim\r\nto minimize the total score for the skipped problems. We will incur a\r\npenalty equal to for a skipped problem and if we solve it. We know that\r\nthe answer lies on some prefix, so now we want to determine the minimum\r\npenalty required to reach each problem.Let\u00e2\u0080\u0099s solve the following\r\nsubproblem. We are given the same problems, and the following two\r\noptions if we are at problem : Pay a penalty of and move to problem , if\r\nsuch a problem exists; Pay a penalty of and move to problem . Now we are\r\nallowed to visit each problem as many times as we want. In this case, we\r\ncan construct a weighted directed graph of the following form: The graph\r\nhas vertices, each vertex corresponds to problem ; For each , there is\r\nan edge of weight from vertex to vertex ; For each , there is an edge of\r\nweight from vertex to vertex . Thus, our task reduces to finding the\r\nshortest distance from vertex to each vertex. Recall that the shortest\r\ndistance guarantees that on the way to vertex , we visited each vertex\r\nat most once, which means that if we reached problem with some penalty,\r\nwe can solve all problems on the prefix up to (inclusive), since the\r\npoints for all skipped problems will be compensated by the penalty.\r\nSince we already know that the optimal answer lies on one of the\r\nprefixes, we need to know the total points for the problems for each\r\nprefix, which can be easily done using prefix sums. After that, from all\r\nthe values of the difference between the prefix sum and the minimum\r\npenalty needed to reach vertex , we will choose the maximum across all\r\nprefixes , and this will be the answer.We will find the shortest\r\ndistance using Dijkstra\u00e2\u0080\u0099s algorithm in .Prefix sums are calculated in\r\n.Final asymptotic complexity: .\r\n",
    "name": "B. Skipping",
    "statement": "It is already the year 3024, ideas for problems have long run out, and\r\nthe olympiad now takes place in a modified individual format. The\r\nolympiad consists of n problems, numbered from 1 to n. The i-th problem\r\nhas its own score a_i and a certain parameter b_i (1\r\nle b_i\r\nle n).Initially, the testing system gives the participant the problem.\r\nWhen the participant is given the i-th problem, they have two options:\r\nThey can submit the problem and receive a_i points; They can skip the\r\nproblem, in which case they will never be able to submit it. Then, the\r\ntesting system selects the next problem for the participant from\r\nproblems with indices j, such that: If he submitted the i-th problem, it\r\nlooks at problems with indices j < i; If he skipped the i-th problem, it\r\nlooks at problems with indices j\r\nleq b_i. Among these problems, it selects the problem with the index\r\nthat it has to the participant (he has neither submitted nor skipped it\r\nbefore). If there is no such problem, then the competition for the\r\nparticipant , and their result is equal to the sum of points for all\r\nsubmitted problems. In particular, if the participant submits the first\r\nproblem, then the competition for them ends. Note that the participant\r\nreceives each problem .Prokhor has prepared thoroughly for the olympiad,\r\nand now he can submit any problem. Help him determine the maximum number\r\nof points he can achieve.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;\u00a0constexpr i64 inf = 1E18;\u00a0void solve() {    int n;    std::cin >> n;        std::vector<int> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }        std::vector<int> b(n);    for (int i = 0; i < n; i++) {        std::cin >> b[i];        b[i]--;    }        std::vector<i64> dp(n, inf);        std::priority_queue<std::pair<i64, int>, std::vector<std::pair<i64, int>>, std::greater<>> q;    q.emplace(0LL, 0);        while (!q.empty()) {        auto [d, i] = q.top();        q.pop();                if (dp[i] != inf) {            continue;        }        dp[i] = d;                q.emplace(d + a[i], b[i]);        if (i > 0) {            q.emplace(d, i - 1);        }    }        i64 ans = 0;    i64 sum = 0;    for (int i = 0; i < n; i++) {        sum += a[i];        ans = std::max(ans, sum - dp[i]);    }    std::cout << ans << \"\\n\";}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);\u00a0    int t;    std::cin >> t;\u00a0    while (t--) {        solve();    }\u00a0    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Skipping.json"
}