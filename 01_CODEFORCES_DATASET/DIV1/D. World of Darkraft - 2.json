{
    "link": "https://codeforces.com//contest/464/problem/D",
    "problemId": "13527",
    "problem_idx": "D",
    "shortId": "464D",
    "contest_number": "464",
    "problem_submissions": {
        "D": [
            7709708,
            7703672,
            7707768,
            7709029,
            7710992,
            7714718,
            7711118,
            7710774,
            7711609,
            7712288,
            7712591,
            7712787,
            7710684,
            7706753
        ],
        "B": [
            7707364,
            7708530,
            7705479,
            7704768,
            7708864,
            7707171,
            7708559,
            7708825,
            7709917,
            7707346,
            7709741,
            7707538,
            8183505,
            7706050,
            7707819,
            7709775
        ],
        "C": [
            7704070,
            7705447,
            7708594,
            7706019,
            7703932,
            7708284,
            7708480,
            7706511,
            7704666,
            7709574,
            7707010,
            7705245,
            7706182,
            7708374,
            7703721,
            7711028,
            7703271
        ],
        "A": [
            7701335,
            7709425,
            7702860,
            7710099,
            7708555,
            7702605,
            7703010,
            7704248,
            7702307,
            7705030,
            7704432,
            7701212,
            7711093,
            7707511,
            7702270,
            7703295,
            7705744
        ]
    },
    "name": "D. World of Darkraft - 2",
    "statement": "Roma found a new character in the game \"World of Darkraft - 2\". In this\r\ngame the character fights monsters, finds the more and more advanced\r\nstuff that lets him fight stronger monsters.The character can equip\r\nhimself with distinct types of items. Power of each item depends on its\r\nlevel (positive integer number). Initially the character has one -level\r\nitem of each of the types.After the victory over the monster the\r\ncharacter finds exactly one new randomly generated item. The generation\r\nprocess looks as follows. Firstly the type of the item is defined; each\r\nof the types has the same probability. Then the level of the new item is\r\ndefined. Let’s assume that the level of player’s item of the chosen type\r\nis equal to at the moment. Level of the new item will be chosen\r\nuniformly among integers from segment [; ].From the new item and the\r\ncurrent player’s item of the same type Roma chooses the best one (i.e.\r\nthe one with greater level) and equips it (if both of them has the same\r\nlevel Roma choses any). The remaining item is sold for coins. Roma sells\r\nan item of level of any type for coins.Help Roma determine the expected\r\nnumber of earned coins after the victory over monsters.\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAGIC = 2000;\n\nlong double f[MAGIC + 10], inv[MAGIC + 10];\n\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  for (int j = 1; j < MAGIC; j++) {\n    f[j] = 0.0;\n    inv[j] = 1.0 / j;\n  }\n  f[1] = 1.0;\n  long double q = 1.0 / k;\n  long double ans = 0.0;\n  for (int it = 0; it < n; it++) {\n    for (int j = MAGIC - 1; j >= 1; j--) {\n      if (f[j] < 1e-100) {\n        f[j] = 0.0;\n        continue;\n      }\n      ans += f[j] * j * (0.5 + inv[j + 1]);\n      long double u = f[j] * q * inv[j + 1];\n      f[j + 1] += u;\n      f[j] -= u;\n    }\n  }\n  printf(\"%.17lf\\n\", (double)ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "probabilities"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. World of Darkraft - 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/13694",
    "editorial": "This problem required some skill at probabilities handling, but other\r\nthan that itâs quite simple too. Denote number of earned coins as , and\r\nnumber of earned coins from selling items of type as . Clearly , and\r\n(here is expectation of ). As all types have equal probability of\r\nappearance, all are equal, so . Now to find . If we look only at the\r\nitems of one type, say, 1, items generation looks like this: with\r\nprobability we get nothing, and with probability we get out item with\r\nlevel distributed as usual. Denote expectation of earned money after\r\nkilling monsters if we have an item of level at the start. Clearly, (we\r\nhave no opportunity to earn any money), and , which is equal to = . To\r\nget the answer note that . The sad note is that this DP has states,\r\nwhich is too much for . Maybe if we cut off some\r\nextremely-low-probability cases we can do better? For instance, it is\r\nclear that probability of upgrading an item descreases with its level,\r\nso apparently it does not get very high. We know that expected number of\r\ntries before first happening of event with probability in a series of\r\nsimilar independent events is . Therefore, expected number of monsters\r\nwe have to kill to get item of level is . So, in common case our level\r\ncan get up to about , which does not exceed in our limitations. We would\r\nwant to set such bound that ignoring cases with would not influence our\r\nanswer too much. That can be done with rigorous bounding of variance of\r\nand applying some bounding theorem, or with an empirical method: if we\r\nincrease the bound and the answer doesnât visibly change, then this\r\nbound is fine. It turns out is good enough for achieving demanded\r\nprecision. Thus solution with complexity is obtained (here we assert\r\nthat , and constant is buried in the big O). A challenge: suppose we\r\nhave the same rules of killing monsters and obtaining items, but now we\r\nare free to choose whether to sell a new item or an old one. We act so\r\nthat to maximize our number of coins in the end. What is the expected\r\nnumber of coins if we act optimally? Now it is sometimes more profitable\r\nto sell a powerful item, but sometimes it isnât. How fast a solution can\r\nyou come up with?\r\n",
    "hint": []
}