{
    "link": "https://codeforces.com//contest/1302/problem/J",
    "problemId": "530380",
    "problem_idx": "J",
    "shortId": "1302J",
    "contest_number": "1302",
    "problem_submissions": {
        "G": [
            70178308,
            70181430
        ],
        "F": [
            70174410,
            70180942
        ],
        "B": [
            70169462,
            70166865
        ],
        "C": [
            70167717,
            70168002
        ],
        "A": [
            70167198,
            70167522
        ],
        "J": [
            70183433
        ],
        "D": [
            70170852
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/73599",
    "editorial": "A freaking ton of if-else operators strikes back.In this problem one\r\ncould use some sort of heuristics, like define being the hamming\r\ndistance between the desired string and the obtained one, and then do\r\nsome simulated annealing or maybe gradient descent or something else (we\r\ndidn’t manage to make the gradient descent work, but simulated annealing\r\ndid the job). Feel free to share your approaches in comments!\r\n",
    "name": "J. Keep talking and nobody explodes – hard",
    "statement": "You have the safe lock which consists of 100 decimal digits. If you\r\nrotate some digit, it increases by one, except 9 which becomes\r\n0.Initially, the lock contains number x. To unlock the safe you must do\r\nthe following operations in order (and be careful, don’t mix up if and\r\nelse statements).If digit 39 is odd, rotate digit 39 by 9 times, else\r\nrotate digit 37 by 1 times. If digit 24 is odd, rotate digit 24 by 1\r\ntimes, else rotate digit 76 by 3 times. If sum of digits 13 and 91 is\r\ngreater than 10, rotate digit 14 by 6 times, else rotate digit 34 by 8\r\ntimes. If digit 87 is odd, rotate digit 87 by 7 times, else rotate digit\r\n22 by 9 times. If digit 79 is greater than digit 15, rotate digit 74 by\r\n7 times, else rotate digit 84 by 6 times. If sum of digits 26 and 66 is\r\ngreater than 9, rotate digit 31 by 7 times, else rotate digit 95 by 4\r\ntimes. If sum of digits 53 and 1 is greater than 8, rotate digit 66 by 1\r\ntimes, else rotate digit 94 by 6 times. If digit 41 is greater than\r\ndigit 29, rotate digit 67 by 5 times, else rotate digit 41 by 9 times.\r\nIf sum of digits 79 and 20 is greater than 10, rotate digit 18 by 2\r\ntimes, else rotate digit 72 by 9 times. If sum of digits 14 and 24 is\r\ngreater than 10, rotate digit 64 by 2 times, else rotate digit 84 by 2\r\ntimes. If digit 16 is greater than digit 34, rotate digit 81 by 5 times,\r\nelse rotate digit 15 by 2 times. If sum of digits 48 and 65 is greater\r\nthan 9, rotate digit 57 by 2 times, else rotate digit 28 by 5 times. If\r\ndigit 81 is odd, rotate digit 81 by 5 times, else rotate digit 25 by 4\r\ntimes. If digit 70 is odd, rotate digit 70 by 9 times, else rotate digit\r\n93 by 3 times. If sum of digits 92 and 49 is greater than 9, rotate\r\ndigit 81 by 2 times, else rotate digit 42 by 3 times. If digit 96 is\r\ngreater than digit 20, rotate digit 45 by 4 times, else rotate digit 45\r\nby 1 times. If digit 91 is greater than digit 21, rotate digit 60 by 3\r\ntimes, else rotate digit 72 by 1 times. If digit 89 is greater than\r\ndigit 7, rotate digit 98 by 9 times, else rotate digit 52 by 7 times. If\r\ndigit 38 is greater than digit 97, rotate digit 92 by 6 times, else\r\nrotate digit 35 by 4 times. If digit 96 is greater than digit 99, rotate\r\ndigit 42 by 4 times, else rotate digit 40 by 9 times. If digit 86 is\r\nodd, rotate digit 86 by 1 times, else rotate digit 14 by 3 times. If\r\ndigit 23 is odd, rotate digit 23 by 5 times, else rotate digit 55 by 9\r\ntimes. If digit 79 is odd, rotate digit 79 by 1 times, else rotate digit\r\n29 by 8 times. If digit 4 is greater than digit 91, rotate digit 98 by 8\r\ntimes, else rotate digit 69 by 4 times. If digit 93 is greater than\r\ndigit 24, rotate digit 75 by 9 times, else rotate digit 95 by 3 times.\r\nIf sum of digits 32 and 50 is greater than 10, rotate digit 91 by 3\r\ntimes, else rotate digit 1 by 5 times. If digit 81 is greater than digit\r\n31, rotate digit 86 by 7 times, else rotate digit 67 by 5 times. If\r\ndigit 83 is greater than digit 86, rotate digit 48 by 7 times, else\r\nrotate digit 2 by 6 times. If digit 20 is greater than digit 88, rotate\r\ndigit 9 by 2 times, else rotate digit 99 by 4 times. If digit 14 is odd,\r\nrotate digit 14 by 5 times, else rotate digit 97 by 7 times. If digit 38\r\nis greater than digit 14, rotate digit 48 by 2 times, else rotate digit\r\n81 by 5 times. If digit 92 is greater than digit 74, rotate digit 92 by\r\n1 times, else rotate digit 50 by 9 times. If digit 76 is greater than\r\ndigit 89, rotate digit 68 by 6 times, else rotate digit 69 by 5 times.\r\nIf digit 2 is greater than digit 28, rotate digit 75 by 1 times, else\r\nrotate digit 89 by 1 times. If digit 67 is odd, rotate digit 67 by 9\r\ntimes, else rotate digit 49 by 1 times. If digit 23 is odd, rotate digit\r\n23 by 1 times, else rotate digit 59 by 3 times. If digit 81 is odd,\r\nrotate digit 81 by 9 times, else rotate digit 9 by 4 times. If sum of\r\ndigits 92 and 82 is greater than 9, rotate digit 81 by 2 times, else\r\nrotate digit 91 by 5 times. If sum of digits 42 and 48 is greater than\r\n9, rotate digit 35 by 8 times, else rotate digit 59 by 6 times. If digit\r\n55 is odd, rotate digit 55 by 9 times, else rotate digit 61 by 6 times.\r\nIf digit 83 is odd, rotate digit 83 by 5 times, else rotate digit 85 by\r\n4 times. If digit 96 is odd, rotate digit 96 by 1 times, else rotate\r\ndigit 72 by 4 times. If digit 17 is odd, rotate digit 17 by 1 times,\r\nelse rotate digit 28 by 3 times. If digit 85 is greater than digit 74,\r\nrotate digit 37 by 3 times, else rotate digit 10 by 3 times. If sum of\r\ndigits 50 and 67 is greater than 9, rotate digit 85 by 9 times, else\r\nrotate digit 42 by 4 times. If sum of digits 11 and 43 is greater than\r\n10, rotate digit 56 by 7 times, else rotate digit 50 by 7 times. If sum\r\nof digits 95 and 64 is greater than 9, rotate digit 95 by 4 times, else\r\nrotate digit 95 by 9 times. If sum of digits 21 and 16 is greater than\r\n9, rotate digit 87 by 3 times, else rotate digit 30 by 1 times. If digit\r\n91 is odd, rotate digit 91 by 1 times, else rotate digit 77 by 1 times.\r\nIf digit 95 is greater than digit 82, rotate digit 53 by 2 times, else\r\nrotate digit 100 by 5 times. If sum of digits 88 and 66 is greater than\r\n10, rotate digit 34 by 4 times, else rotate digit 57 by 4 times. If\r\ndigit 73 is greater than digit 84, rotate digit 52 by 3 times, else\r\nrotate digit 42 by 9 times. If digit 66 is greater than digit 38, rotate\r\ndigit 94 by 7 times, else rotate digit 78 by 7 times. If digit 23 is\r\ngreater than digit 12, rotate digit 78 by 2 times, else rotate digit 62\r\nby 8 times. If digit 13 is greater than digit 9, rotate digit 42 by 7\r\ntimes, else rotate digit 1 by 9 times. If digit 43 is greater than digit\r\n29, rotate digit 20 by 2 times, else rotate digit 47 by 2 times. If sum\r\nof digits 100 and 51 is greater than 8, rotate digit 10 by 6 times, else\r\nrotate digit 89 by 1 times. If digit 19 is greater than digit 37, rotate\r\ndigit 26 by 7 times, else rotate digit 30 by 8 times. If digit 73 is\r\ngreater than digit 25, rotate digit 77 by 3 times, else rotate digit 41\r\nby 1 times. If sum of digits 67 and 96 is greater than 10, rotate digit\r\n47 by 6 times, else rotate digit 33 by 5 times. If digit 11 is greater\r\nthan digit 10, rotate digit 33 by 3 times, else rotate digit 4 by 3\r\ntimes. If digit 85 is odd, rotate digit 85 by 7 times, else rotate digit\r\n37 by 9 times. If digit 14 is odd, rotate digit 14 by 1 times, else\r\nrotate digit 28 by 4 times. If sum of digits 30 and 18 is greater than\r\n8, rotate digit 93 by 5 times, else rotate digit 68 by 1 times. If sum\r\nof digits 54 and 72 is greater than 8, rotate digit 88 by 8 times, else\r\nrotate digit 25 by 8 times. If digit 72 is odd, rotate digit 72 by 5\r\ntimes, else rotate digit 10 by 3 times. If digit 15 is odd, rotate digit\r\n15 by 3 times, else rotate digit 68 by 1 times. If sum of digits 81 and\r\n31 is greater than 9, rotate digit 2 by 5 times, else rotate digit 35 by\r\n1 times. If digit 57 is odd, rotate digit 57 by 1 times, else rotate\r\ndigit 25 by 9 times. If sum of digits 75 and 51 is greater than 9,\r\nrotate digit 73 by 8 times, else rotate digit 49 by 1 times. If sum of\r\ndigits 81 and 61 is greater than 10, rotate digit 61 by 3 times, else\r\nrotate digit 88 by 1 times. If digit 60 is odd, rotate digit 60 by 1\r\ntimes, else rotate digit 31 by 2 times. If digit 93 is odd, rotate digit\r\n93 by 5 times, else rotate digit 50 by 1 times. If sum of digits 19 and\r\n82 is greater than 9, rotate digit 48 by 7 times, else rotate digit 88\r\nby 8 times. If digit 45 is odd, rotate digit 45 by 7 times, else rotate\r\ndigit 100 by 1 times. If digit 46 is greater than digit 71, rotate digit\r\n28 by 8 times, else rotate digit 37 by 6 times. If digit 79 is odd,\r\nrotate digit 79 by 5 times, else rotate digit 10 by 1 times. If digit 19\r\nis greater than digit 95, rotate digit 76 by 9 times, else rotate digit\r\n95 by 8 times. If digit 49 is odd, rotate digit 49 by 5 times, else\r\nrotate digit 66 by 3 times. If digit 62 is odd, rotate digit 62 by 1\r\ntimes, else rotate digit 26 by 8 times. If digit 67 is greater than\r\ndigit 33, rotate digit 27 by 8 times, else rotate digit 96 by 2 times.\r\nIf sum of digits 73 and 15 is greater than 8, rotate digit 98 by 6\r\ntimes, else rotate digit 11 by 6 times. If digit 63 is greater than\r\ndigit 42, rotate digit 66 by 1 times, else rotate digit 58 by 2 times.\r\nIf digit 41 is odd, rotate digit 41 by 9 times, else rotate digit 99 by\r\n5 times. If digit 93 is odd, rotate digit 93 by 5 times, else rotate\r\ndigit 53 by 1 times. If digit 46 is odd, rotate digit 46 by 3 times,\r\nelse rotate digit 64 by 4 times. If sum of digits 99 and 64 is greater\r\nthan 10, rotate digit 72 by 9 times, else rotate digit 51 by 5 times. If\r\ndigit 75 is greater than digit 23, rotate digit 89 by 2 times, else\r\nrotate digit 76 by 7 times. If digit 6 is odd, rotate digit 6 by 1\r\ntimes, else rotate digit 44 by 6 times. If digit 58 is odd, rotate digit\r\n58 by 3 times, else rotate digit 49 by 9 times. If digit 5 is greater\r\nthan digit 13, rotate digit 46 by 9 times, else rotate digit 21 by 7\r\ntimes. If sum of digits 44 and 94 is greater than 9, rotate digit 36 by\r\n4 times, else rotate digit 15 by 3 times. If sum of digits 52 and 43 is\r\ngreater than 8, rotate digit 29 by 8 times, else rotate digit 72 by 6\r\ntimes. If sum of digits 87 and 48 is greater than 9, rotate digit 61 by\r\n8 times, else rotate digit 14 by 3 times. If digit 81 is odd, rotate\r\ndigit 81 by 7 times, else rotate digit 64 by 2 times. If digit 88 is\r\nodd, rotate digit 88 by 7 times, else rotate digit 53 by 9 times. If sum\r\nof digits 86 and 78 is greater than 10, rotate digit 96 by 7 times, else\r\nrotate digit 79 by 1 times. If digit 20 is odd, rotate digit 20 by 7\r\ntimes, else rotate digit 2 by 7 times. If digit 77 is greater than digit\r\n80, rotate digit 60 by 5 times, else rotate digit 38 by 8 times. If\r\ndigit 65 is odd, rotate digit 65 by 1 times, else rotate digit 85 by 3\r\ntimes.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long; int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n;    std::cin >> n;        std::vector<int> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }        std::vector<std::vector<int>> adj(n);        for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--, v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        std::vector<int> dp(n), t(n);    std::vector<std::set<int>> s(n);    std::function<void(int, int)> dfs = [&](int x, int p) {        std::map<int, int> cnt;        if (adj[x].size() == 1 && x) {            s[x].insert(0);            dp[x] = 1;        }        for (auto y : adj[x]) {            if (y == p) {                continue;            }            dfs(y, x);            dp[x] += dp[y] + 1;            if (s[x].size() < s[y].size()) {                std::swap(s[x], s[y]);                std::swap(t[x], t[y]);            }            for (auto z : s[y]) {                z ^= t[x] ^ t[y];                if (s[x].count(z)) {                    cnt[z ^ t[x]]++;                } else {                    s[x].insert(z);                }            }        }        if (!cnt.empty()) {            int mx = 0;            for (auto [_, v] : cnt) {                mx = std::max(mx, v);            }            dp[x] -= mx + 1;            s[x].clear();            t[x] = a[x];            for (auto [z, v] : cnt) {                if (v == mx) {                    s[x].insert(z);                }            }        } else {            dp[x] -= 1;            t[x] ^= a[x];        }    };    dfs(0, -1);        int ans = dp[0] + !s[0].count(t[0]);    std::cout << ans << \"\\n\";        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\J. Keep talking and nobody explodes – hard.json",
    "hint": []
}