{
    "link": "https://codeforces.com//contest/1580/problem/A",
    "problemId": "1124754",
    "problem_idx": "A",
    "shortId": "1580A",
    "contest_number": "1580",
    "problem_submissions": {
        "B": [
            130368546,
            130343157,
            130344628,
            130363173,
            130349401,
            130355243,
            130367468,
            130348461,
            130361528,
            130349821,
            130353521,
            130358877,
            130349956,
            130352430,
            130351206,
            130360978,
            130375295,
            130370586,
            130394237,
            130361703
        ],
        "F": [
            130365168,
            131645253,
            131635746,
            130511674,
            130411823,
            130434722,
            130858441,
            130432452
        ],
        "D": [
            130353694,
            130351879,
            130354504,
            130348465,
            130361242,
            130356218,
            130400584,
            130360744,
            130356043,
            130858484,
            130362840,
            130366863,
            130368106,
            130352099,
            130366694,
            130365720,
            130365962,
            130368047,
            130360831,
            130353993,
            130370294
        ],
        "C": [
            130347074,
            130348749,
            130348466,
            130344529,
            130355623,
            130348660,
            130349751,
            130374035,
            130353918,
            130350011,
            130356865,
            130358625,
            130355024,
            130348708,
            130393503,
            130361958,
            130360836,
            130360159,
            130358052,
            130357895,
            130349443,
            130349567
        ],
        "A": [
            130339939,
            130502005,
            130339930,
            130348093,
            130341897,
            130340621,
            130340244,
            130356449,
            130343417,
            130342143,
            130341207,
            130340481,
            130341559,
            130340530,
            130339691,
            130340905,
            130340089,
            130340579,
            130352882
        ],
        "E": [
            130370647,
            130421659
        ]
    },
    "name": "A. Portal",
    "statement": "CQXYM found a rectangle A of size n\r\ntimes m. There are n rows and m columns of blocks. Each block of the\r\nrectangle is an obsidian block or empty. CQXYM can change an obsidian\r\nblock to an empty block or an empty block to an obsidian block in one\r\noperation.A rectangle M size of a\r\ntimes b is called a portal if and only if it satisfies the following\r\nconditions: a\r\ngeq 5,b\r\ngeq 4. For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian\r\nblocks. For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian\r\nblocks. For all 1<x<a,1<y<b, block M_{x,y} is an empty block. M_{1, 1},\r\nM_{1, b}, M_{a, 1}, M_{a, b} . Note that the there must be a rows and b\r\ncolumns, not b rows and a columns.CQXYM wants to know the minimum number\r\nof operations he needs to make at least one sub-rectangle a portal.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\nchar A[405][405];\nint psum[405][405];\nint frec(int l0, int r0, int l1, int r1)\n{\n\treturn psum[r0][r1] - (l0 == 0 ? 0 : psum[l0 - 1][r1]) - (l1 == 0 ? 0 : psum[r0][l1 - 1]) + (l0 == 0 || l1 == 0 ? 0 : psum[l0 - 1][l1 - 1]);\n}\n\nint c0[405], c1[405];\nint calc(int l, int r)\n{\n\trep(i, m) {\n\t\tc0[i] = (A[l][i] == '0') + (A[r][i] == '0') + frec(l + 1, r - 1, i, i);\n\t\tc1[i] = r - l - 1 - frec(l + 1, r - 1, i, i);\n\t}\n\t\n\tint ret = INF, tmp = INF;\n\trep(i, m - 3) {\n\t\ttmp = min(tmp + c0[i], c1[i]);\n\t\tret = min(ret, tmp + c0[i + 1] + c0[i + 2] + c1[i + 3]);\n\t}\n\treturn ret;\n}\n\nvoid solve()\n{\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n) scanf(\"%s\", A[i]);\n\trep(i, n) rep(j, m) psum[i][j] = A[i][j] == '1';\n\trep(i, n) rep(j, m) psum[i][j + 1] += psum[i][j];\n\trep(i, n) rep(j, m) psum[i + 1][j] += psum[i][j];\n\t\n\tint ans = INF;\n\trep(l, n) for(int r = l + 4; r < n; r ++) ans = min(ans, calc(l, r));\n\tprintf(\"%d\\n\", ans); \n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile(T --) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Portal.json",
    "editorial_link": "https://codeforces.com//blog/entry/95477",
    "editorial": "We can enumerate the two\ncorner of the submatrix, calculate the answer by precalculating the\nprefix sums. The time complexity is . When we enumerated the upper edge\nand the lower edge of the submatrix, we can calculate the answer by\nprefix sum. Assume the left edge of the submatrix is , and the right\nedge is . The part of anwer contributed by upper and lower edge are two\nsegments, we can calculate the answer by prefix sums. The middle empty\npart is a submaxtrix, and we can use prefix sums too. Since we have\nenumerated the upper edge and lower edge, the left edge part is just\nabout , and the right part is just about . Then we enumerate , the\nanswer of the best can be calculated by precalculating the suffix\nminiums. The time complexity is , space complexity is . solution\n",
    "hint": []
}