{
    "link": "https://codeforces.com//contest/1874/problem/F",
    "problemId": "2236841",
    "problem_idx": "F",
    "shortId": "1874F",
    "contest_number": "1874",
    "problem_submissions": {
        "F": [
            226041334,
            226055202,
            226083158,
            226054781,
            226061315,
            226045179,
            226057161,
            226024417,
            226094016,
            226151126,
            226979730,
            226372437,
            226704730,
            226099033,
            226098861,
            226001871
        ],
        "B": [
            225998357,
            225944596,
            225961498,
            226022662,
            225970503,
            226048661,
            225965106,
            225956535,
            225974109,
            226024200,
            226979960,
            226057337,
            225972372,
            225968693,
            225962068,
            226040739,
            225981051,
            226047279,
            226046003,
            225948785
        ],
        "D": [
            225989950,
            226004287,
            225983656,
            225994935,
            225998958,
            226008015,
            225977564,
            226002115,
            225985427,
            226003081,
            225989658,
            226979804,
            225989175,
            226003010,
            226023529,
            226002830,
            226078484,
            226078353,
            226002716,
            226024255,
            226018418,
            226137164,
            225986804
        ],
        "E": [
            225973607,
            225981897,
            226000134,
            225978662,
            226074388,
            226073614,
            226073223,
            226072631,
            226071563,
            226069387,
            226068777,
            226021358,
            225958738,
            226070894,
            225983588,
            226039851,
            226021998,
            226007010,
            226979776,
            226006499,
            226036184,
            226038920,
            226053631,
            226068817,
            226063126,
            226059742,
            226057237
        ],
        "C": [
            225967620,
            225968755,
            225972644,
            225961410,
            225983858,
            225989707,
            225987635,
            225970993,
            225986658,
            225975231,
            226979908,
            225973609,
            225986638,
            225980254,
            225971024,
            227431342,
            225959672,
            225996237,
            225972869,
            226057682,
            225972171
        ],
        "A": [
            225936409,
            225922035,
            225921764,
            225934682,
            225931922,
            225937474,
            225923760,
            225922674,
            225923828,
            225922214,
            226979999,
            225944454,
            225937163,
            225922982,
            225921695,
            226083093,
            226083061,
            225937017,
            225941961,
            225925562,
            226022851,
            225923156
        ],
        "G": [
            226095099,
            226164597,
            226979660,
            226967841,
            230907178
        ]
    },
    "name": "F. Jellyfish and OEIS",
    "statement": "Jellyfish always uses OEIS to solve math problems, but now she finds a\r\nproblem that cannot be solved by OEIS:Count the number of permutations p\r\nof [1, 2,\r\ndots, n] such that for all (l, r) such that l\r\nleq r\r\nleq m_l, the subarray [p_l, p_{l+1},\r\ndots, p_r] is not a permutation of [l, l+1,\r\ndots, r].Since the answer may be large, you only need to find the answer\r\nmodulo 10^9+7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 207, mod = 1e9 + 7;\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N], ifac[N], inv[N];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) (mod - mod / i) * inv[mod % i] % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n} \nint C(int x, int y) {\n\treturn x < y || y < 0 ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\nint n, dp[N][N], mg[N][N], m[N];\n// dp : [l,r] is good, but not splitable \n// mg : any answer, maybe splitable \n\nint ans;\nint f[N]; \n\nint hm[N][N];\nint perm[N];\nint g[N];\nint p[N];\n\nint H[N][N];\nint dr[N];\nint main() {\n\tios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> m[i];\n\t}\n\tinit(n + 1);\n\tL(i, 1, n) {\n\t\tg[i] = fac[i];\n\t\tL(j, 1, i - 1) {\n\t\t\t(g[i] += mod - (ll) g[j] * fac[i - j] % mod) %= mod;\n\t\t}\n\t}\n\t\n\tf[0] = 1;\n\thm[1][1] = 1;\n\tL(i, 1, n) {\n\t\tf[i] = g[i];\n\t\tL(j, 0, i - 1) {\n\t\t\tL(k, 0, i - j) {\n\t\t\t\t(hm[i][k + 1] += (ll) hm[i - j - 1][k] * fac[j] % mod) %= mod;\n\t\t\t}\n\t\t}\n\t\tL(j, 1, i - 1) {\n\t\t\t(f[i] += mod - (ll) hm[i][j] * f[j] % mod) %= mod;\n\t\t}\n\t} \n\t\n\t/*\n\tL(i, 1, n) {\n\t\tcout << f[i] << ' ';\n\t}\n\tcout << endl;\n\tL(k, 1, n) {\n\t\tL(i, 1, k) p[i] = i;\n\t\tint cnt = 0;\n\t\tdo {\n\t\t\tint win = 1;\n\t\t\tL(l, 1, k) {\n\t\t\t\tL(r, l, k) {\n\t\t\t\t\tif(l == 1 && r == k) \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tL(j, l, r) {\n\t\t\t\t\t\tok &= l <= p[j] && p[j] <= r;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\twin = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(win) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t} while(next_permutation(p + 1, p + k + 1));\n\t\tcout << cnt << ' ';\n\t}\n\tcout << endl;\n\t*/\n\t\n\tL(l, 1, n + 1) \n\t\tmg[l][l - 1] = 1;\n\tR(l, n, 1) {\n\t\tme(H, 0);\n\t\tH[l][1] = 1;\n\t\tL(r, l, n) {\n\t\t\tL(p, l, r) {\n\t\t\t\tL(k, 0, p - l) {\n\t\t\t\t\t(H[r][k + 1] += (ll) H[p - 1][k] * mg[p][r - 1] % mod) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[l][r] = 0;\n\t\t\tL(p, 1, r - l + 1) {\n\t\t\t\t(dp[l][r] += (ll) H[r][p] * f[p] % mod) %= mod;\n\t\t\t}\n\t\t\tif(r <= m[l]) {\n\t\t\t\tdp[l][r] = 0;\n\t\t\t}\n\t\t\tL(j, l - 1, r) {\n\t\t\t\tdr[j] = 0;\n\t\t\t}\n\t\t\tdr[l - 1] = 1;\n\t\t\tL(p, l, r) \n\t\t\t\tif(m[p] < r && dr[p - 1]) {\n\t\t\t\t\tL(i, p, r) \n\t\t\t\t\t\t(dr[i] += (ll) dr[p - 1] * dp[p][i] % mod) %= mod;\n\t\t\t\t}\n\t\t\tmg[l][r] = dr[r];\n//\t\t\tcout << l << ' ' << r << \" : \" << dp[l][r] << ' ' << mg[l][r] << endl; \n\t\t}\n\t}\n\tcout << mg[1][n] << '\\n';\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Jellyfish and OEIS.json",
    "editorial_link": "https://codeforces.com//blog/entry/120943",
    "editorial": "TutorialLetâs call a section bad if is a permutation of and .Letâs call\r\na section primitive if itâs a bad section and there are no section\r\nsatisfying is also a bad section and covers .Lemma. For all primitive\r\nsections, none two of them intersect.Proof. If is a bad section, is a\r\nbad section and , the section will also be a bad section, but both and\r\ncovers , so and canât be primitive at the same time.Letâs use the\r\nprinciple of inclusion-exclusion and dynamic programming to solve the\r\nproblem.Letâs define as the number of which is a primitive section. By\r\nthe principle of inclusion-exclusion, we count the ways to fix primitive\r\nsections in range , and arrange the rest arbitrarily.Then we can define\r\nas the number of ways to fix ( is odd/even) primitive sections in range\r\n, and the number of the positions which doesnât cover by any primitive\r\nsection is .Finally we define , We will have the following transition:\r\nTips. In the transition of , We add because contributes to , but it\r\nshould not contribute to , This problem can be solved by ordering the\r\ntransitions.According to the definition, is the answer.Time complexity:\r\nMemory complexity:\r\n",
    "hint": []
}