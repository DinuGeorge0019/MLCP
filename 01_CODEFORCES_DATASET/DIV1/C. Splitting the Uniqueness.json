{
    "link": "https://codeforces.com//contest/297/problem/C",
    "problemId": "2861",
    "problem_idx": "C",
    "shortId": "297C",
    "contest_number": "297",
    "problem_submissions": {
        "E": [
            3573577,
            3572177,
            3599204,
            3789658,
            3600333
        ],
        "C": [
            3572198,
            3569026,
            3567778,
            3569809,
            3574619,
            3568949,
            3571082,
            3571182,
            3571915,
            3572417,
            3571389,
            3576338,
            3581124
        ],
        "D": [
            3571285,
            3568393,
            3572434,
            3572411,
            3572809,
            3569746,
            3574175,
            3574132,
            3574196,
            3574904,
            3574825,
            3575155,
            3572689,
            3572000,
            3569044,
            3569682,
            3569691,
            3570483,
            3570423
        ],
        "B": [
            3565273,
            3565232,
            3566085,
            3565337,
            3567367,
            3565921,
            3564958,
            3565122,
            3565530,
            3566819,
            3566006,
            3566209,
            3567427,
            3565310,
            3565669,
            3565428,
            3567419,
            3567159,
            3565321
        ],
        "A": [
            3564985,
            3564892,
            3565047,
            3564918,
            3565603,
            3565210,
            3574423,
            3565848,
            3568320,
            3564943,
            3565186,
            3565376,
            3565311,
            3564926,
            3564908,
            3564901,
            3566394,
            3565891,
            3566461
        ]
    },
    "name": "C. Splitting the Uniqueness",
    "statement": "Polar bears like that is, arrays without repeated elements. You have got\r\na unique array with length containing non-negative integers. Since you\r\nare good friends with Alice and Bob, you decide to split the array in\r\ntwo. Precisely, you need to construct two arrays and that are also of\r\nlength , with the following conditions for all : are non-negative\r\nintegers; . Ideally, and should also be unique arrays. However, life in\r\nthe Arctic is hard and this is not always possible. Fortunately, Alice\r\nand Bob are still happy if their arrays are . We define an array of\r\nlength to be almost unique, if and only if it can be turned into a\r\nunique array by removing no more than entries.For example, the array is\r\nalmost unique because after removing the first two entries, it becomes .\r\nThe array is not almost unique because we need to remove at least\r\nentries to turn it into a unique array.So, your task is to split the\r\ngiven unique array into two almost unique arrays and .\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\npair <int, int> a[444444];\nint x[444444], y[444444];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i=0;i<n;i++) {\n    scanf(\"%d\", &(a[i].first));\n    a[i].second = i;\n  }\n  sort(a, a+n);\n  int need = n - (n+2) / 3;\n  int z = 0;\n  for (int i=n-need;i<n;i++) {\n    if (z % 2 == 0) {\n      x[a[i].second] = z/2;\n      y[a[i].second] = a[i].first-z/2;\n    } else {\n      x[a[i].second] = a[i].first-z/2;\n      y[a[i].second] = z/2;\n    }\n    z++;\n  }\n  for (int i=0;i<n-need;i++) {\n    x[a[i].second] = 0;\n    y[a[i].second] = a[i].first;\n  }\n  printf(\"YES\\n\");\n  for (int i=0;i<n-1;i++) printf(\"%d \", x[i]);\n  printf(\"%d\\n\", x[n-1]);\n  for (int i=0;i<n-1;i++) printf(\"%d \", y[i]);\n  printf(\"%d\\n\", y[n-1]);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Splitting the Uniqueness.json",
    "editorial_link": "https://codeforces.com//blog/entry/7437",
    "editorial": "An equivalent definition for almost unique, is an array with at least\r\ndifferent elements. The idea is to split into three parts: In the first\r\npart, we give uniqueness to . In the second part, we give uniqueness to\r\n. In the third part, we give uniqueness to both. Lets assume is sorted.\r\nSince is an unique array, we know for all (0-based). The image below\r\nwill give some intuition on how we are going to split it. is red, is\r\nblue, the length of the bar represent the magnitude of the number. In\r\nthe first and second part, we do not care about the array that we are\r\nnot giving uniqueness to. For exampmle, if : assign (do not care values\r\nof ) assign (do not care values of ) assign and set . From , will have\r\nstrictly increasing values starting from at least .\r\n"
}