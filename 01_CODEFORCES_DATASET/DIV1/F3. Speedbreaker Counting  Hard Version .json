{
    "link": "https://codeforces.com//contest/2018/problem/F3",
    "problemId": "2905191",
    "problem_idx": "F3",
    "shortId": "2018F3",
    "contest_number": "2018",
    "problem_submissions": {
        "F1": [
            283240998,
            283223838,
            283219415,
            283236306,
            283222916,
            283217600,
            283233290,
            283231886,
            283231256,
            283232151,
            283229995,
            283237003,
            283235478,
            283237574,
            283236444,
            283230142,
            283243735,
            283243123,
            283242008,
            283243508
        ],
        "F2": [
            283240981,
            283223708,
            283219380,
            283241370,
            283223162,
            283225122,
            283233500,
            283231817,
            283231569,
            283232589,
            283230224,
            283236870,
            283235839,
            283237529,
            283238353,
            283243847,
            283243386,
            283242191,
            283243811
        ],
        "F3": [
            283240882,
            283223675,
            283219246,
            283271588,
            283270237,
            283224933,
            283229369,
            283236884,
            283231408,
            283234186,
            283238623,
            283246555,
            283236714,
            283242719,
            283237265,
            283240426,
            283246144,
            283243432,
            283242213,
            283244419
        ],
        "E2": [
            283228724,
            283271415,
            283952156,
            285367980,
            285366320,
            284023567,
            283309295
        ],
        "E1": [
            283228436,
            283232974,
            283271394,
            283269080,
            283266646,
            283248084,
            283226474,
            285366140,
            284023512,
            283309260,
            283237845
        ],
        "D": [
            283195973,
            283206733,
            283203886,
            283202562,
            283199647,
            283202135,
            283203009,
            283209326,
            283212471,
            283208248,
            283213153,
            283210604,
            283213401,
            283215308,
            283215785,
            283193803,
            283212467,
            283216433,
            283217858,
            283213030
        ],
        "C": [
            283191019,
            283190311,
            283188296,
            283196136,
            283191568,
            283193617,
            283197810,
            283200878,
            283205239,
            283197789,
            283193479,
            283202635,
            283205964,
            283204336,
            283202253,
            283186865,
            283201070,
            283203016,
            283201349,
            283204359
        ],
        "B": [
            283187765,
            283200401,
            283192789,
            283188636,
            283190321,
            283192212,
            283195063,
            283200019,
            283195292,
            283189706,
            283199364,
            283199549,
            283199094,
            283197971,
            283197559,
            283195753,
            283198921,
            283194967,
            283197864
        ],
        "A": [
            283182907,
            283184407,
            283187228,
            283181621,
            283185198,
            283186414,
            283185582,
            283191793,
            283185688,
            283183522,
            283193549,
            283187676,
            283189523,
            283193094,
            283182769,
            283189185,
            283185401,
            283198807,
            283189030
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "Lemma 1\nFor a fixed starting city, if you can win, this strategy works:\n\n[Strategy 1] If there is a city on the right whose distance is t\n and whose deadline is in t\n turns, go to the right. Otherwise, go to the left.\nProof:\n\nAll constraints on the right hold.\nThis strategy minimizes the time to reach any city on the left. So, if any strategy works, this strategy works too.\nCorollary\nFor a fixed starting city, if you can win, this strategy works:\n\n[Strategy 2] If there is a city whose distance is t\n and whose deadline is in t\n turns, go to that direction. Otherwise, go to any direction.\nLemma 2\nThe valid starting cities are either zero, or all the cities in I:=?ni=1[i?ai+1,i+ai?1]=[l,r]\n.\n\nProof:\n\nThe cities outside I\n are losing, because there exists at least one unreachable city.\nLet's start from any city x\n in I\n, and use Strategy 2.\nYou want to show that, for any x\n in I\n, Strategy 2 can visit all cities in I\n first, then all the other cities. Then, you can conclude that either all the cities in I\n are winning, or they are all losing.\nThe interval I\n gives bounds on the ai\n: specifically, ai?max(i?l+1,r?i+1)\n. Then, you can verify that visiting the interval I\n first does not violate Strategy 2.\nCorollary\nIf you use Strategy 1, the first move on the right determines l\n.\n\nO(n4)\n DP\nLet's iterate on the (non-empty) interval I\n. Let's calculate the bounds ai?max(i?l+1,r?i+1)\n. Note that Strategy 1 is deterministic (i.e., it gives exactly one visiting order for each fixed pair (starting city, a\n)). From now, you will use Strategy 1.\n\nNow you will calculate the number of pairs (a\n, visiting order) such that the cities in I\n are valid starting cities (and there might be other valid starting cities).\n\nLet's define dp[i][j][k] = number of pairs (a\n, visiting order), restricted to the interval [i,j]\n, where k=\n \"are you forced to go to the right in the next move?\". Here are the main ideas to find the transitions:\n\nIf you go from [i+1,j]\n to [i,j]\n, you must ensure that ai?max(i?l+1,r?i+1,j?i+1)\n (because you visit it at time j?i+1\n). Also, k\n must be 0\n.\nIf you go from [i,j?1]\n to [i,j]\n, and you want to make k=0\n, you must make aj=j?i+1\n. It means that j\n was the city that was enforcing you to go to the right.\nIn my code, the result is stored in int_ans[i][j].\n\nNow you want to calculate the number of pairs (a\n, visiting order) such that the cities in I\n are the only valid starting cities. This is similar to 2D prefix sums, and it's enough to make int_ans[i][j] -= int_ans[i - 1][j] + int_ans[i][j + 1] - int_ans[i - 1][j + 1].\n\nSince, for a fixed a\n, the visiting order only depends on the starting city, the number of a\n for the interval [i,j]\n is now int_ans[i][j] / (j - i + 1).\n\nYou have solved k?1\n. The answer for k=0\n is just nn\n minus all the other answers.\n\nO(n3)\n DP\nIn the previous section, you are running the same DP for O(n2)\n different \"bound arrays\" on the ai\n (in particular, O(n)\n arrays for each k\n). Now you want to solve a single k\n with a single DP.\n\nFor a fixed k\n, you can notice that, if you run the DP on an array of length 2n\n instead of n\n, the bound array obtained from I=[n?k+1,n]\n contains all the bound arrays you wanted as subarrays of length n\n. So you can run the DP and get all the results as dp[i][i + n - 1][0].\n\nO(n2)\n DP\nYou still have O(n3)\n distinct states in total. How to make \"bound arrays\" simpler?\n\nIt turns out that you can handle l\n and r\n differently! You can create bound arrays only based on r\n (and get O(n2)\n distinct states), and find l\n using the Corollary of Lemma 2. The transitions before finding l\n are very simple (you always go to the left). So a possible way to get O(n2)\n complexity is processing Strategy 1 and the DP in reverse order (from time n\n to time 1\n).\n\nComplexity: O(n2)",
    "name": "F3. Speedbreaker Counting  Hard Version ",
    "statement": "This is the statement of : There are n cities in a row, numbered 1, 2,\r\nldots, n left to right. At time 1, you conquer exactly one city, called\r\nthe . At time 2, 3,\r\nldots, n, you can choose a city adjacent to the ones conquered so far\r\nand conquer it. You win if, for each i, you conquer city i at a time no\r\nlater than a_i. A winning strategy may or may not exist, also depending\r\non the starting city. How many starting cities allow you to win? For\r\neach 0\r\nleq k\r\nleq n, count the number of arrays of positive integers a_1, a_2,\r\nldots, a_n such that 1\r\nleq a_i\r\nleq n for each 1\r\nleq i\r\nleq n; the answer to is k. The answer can be very large, so you have to\r\ncalculate it modulo a given prime p.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;\u00a0u32 p;void inc(u32 &a, u32 b) {    a += b;    if (a >= p) {        a -= p;    }}\u00a0u32 add(u32 a, u32 b) {    inc(a, b);    return a;}\u00a0void solve() {    int n;    std::cin >> n >> p;        std::vector dp(n, std::vector<std::array<u32, 2>>(n));    for (int l = 0; l < n; l++) {        for (int r = n - 1; r >= l; r--) {            if (l == 0 && r == n - 1) {                dp[l][r][1] = 1;            } else {                if (r != n - 1) {                    dp[l][r][1] = (1ULL * dp[l][r + 1][1] * (n - (r - l + 1)) + dp[l][r + 1][0]) % p;                }                if (l != 0) {                    dp[l][r][0] = 1ULL * (dp[l - 1][r][1] + dp[l - 1][r][0]) * (n - (r - l + 1)) % p;                }            }        }    }        std::vector<u32> g(n);    for (int k = 0; k < n; k++) {        g[k] = 1;        for (int i = 0; i <= k; i++) {            g[k] = 1ULL * g[k] * (n - k + std::min(i, k - i)) % p;        }    }    std::vector<u32> ans(n + 1);    for (int l = 0; l < n; l++) {        for (int r = l; r < n; r++) {            inc(ans[r - l + 1], 1ULL * g[r - l] * (dp[l][r][0] + dp[l][r][1]) % p);        }    }    for (int i = n; i >= 1; i--) {        for (int j = i - 1; j >= 1; j--) {            inc(ans[j], 1ULL * ans[i] * (p - (i - j + 1)) % p);        }    }        u32 tot = 1;    for (int i = 1; i <= n; i++) {        tot = 1ULL * tot * n % p;    }    for (int i = 1; i <= n; i++) {        inc(tot, p - ans[i]);    }    ans[0] = tot;    for (int i = 0; i <= n; i++) {        std::cout << ans[i] << \" \\n\"[i == n];    }}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F3. Speedbreaker Counting  Hard Version .json"
}