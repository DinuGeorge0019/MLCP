{
    "link": "https://codeforces.com//contest/204/problem/D",
    "problemId": "1545",
    "problem_idx": "D",
    "shortId": "204D",
    "contest_number": "204",
    "problem_submissions": {
        "D": [
            1890391,
            1887471,
            1890599,
            1889369,
            1889690,
            1887786,
            1890524,
            1888787,
            1890893,
            1890291,
            1889544,
            1889099,
            1890138,
            1888234
        ],
        "C": [
            1887005,
            1885936,
            1886676,
            1884378,
            1886948,
            1886445,
            1888022,
            1890493,
            1887876,
            1887950,
            1890335,
            1891041,
            1888850,
            1891535
        ],
        "B": [
            1885016,
            1884494,
            1884426,
            1885084,
            1884105,
            1885072,
            1886343,
            1886124,
            1885617,
            1886009,
            1886808,
            1885527,
            1884342,
            1885170
        ],
        "A": [
            1884472,
            1883818,
            1883786,
            1886039,
            1884808,
            1892033,
            1884885,
            1884244,
            1884597,
            1885114,
            1886281,
            1884488,
            1890685,
            1884595
        ],
        "E": [
            1922274,
            1922268,
            1922264,
            1922262,
            1922224,
            1922202,
            1922184,
            1922174,
            1922170,
            1922131,
            1922121,
            1892756
        ]
    },
    "name": "D. Little Elephant and Retro Strings",
    "statement": "The Little Elephant has found a ragged old black-and-white string on the\r\nattic.The characters of string are numbered from the left to the right\r\nfrom to , where is the length of the string. Let\u2019s denote the -th\r\ncharacter of string as . As the string is black-and-white, each\r\ncharacter of the string is either letter \"\", or letter \"\".\r\nUnfortunately, the string is very old and some characters are damaged.\r\nThe damaged positions are denoted as \"\".The Little Elephant in\r\ndetermined to restore the string and hang it on the wall. For that he\r\nneeds to replace each character \"\" by a \"\" or a \"\". The string must look\r\ngood on the wall, so it must be . The Little Elephant considers a string\r\nbeautiful if it has two non-intersecting substrings of a given length ,\r\nsuch that the left one fully consists of characters \"\", and the right\r\none fully consists of characters \"\". More formally, there are four\r\nintegers such that = \"\" and = \"\" . Help the Little Elephant find the\r\nnumber of different beautiful strings he can obtain from string . Two\r\nstrings are considered different if there is such position, where the\r\ncharacter in the first string differs from the corresponding character\r\nin the second string. If this string doesn\u2019t contain characters and it\r\nis already beautiful the answer is .As the answer can be rather large,\r\nprint it modulo .\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:65777216\")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long ull;\n\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\n\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nconst int mod = 1000000007;\n\nint n,k;\nchar s[1111111];\nchar t[1111111];\nvi v1,v2;\n\nint sum[1111111];\nvi tmp;\n\nint tp[1111111];\nint w[1111111];\nint q[1111111];\nint sw[1111111];\n\nvi solve(char *s){\n\ttmp.clear();\n\ttmp.resize(n, 0);\n\tCL(w,0);CL(sw,0);CL(q,0);\n\tint num = 0;\n\tint lastw = -1;\n\tREP(i,n){\n\t\tif(s[i]=='X') q[i]=1;\n\t\tif(i) q[i]+=q[i-1];\n\t\tif(s[i]=='B' || s[i]=='X') num++;\n\t\telse num = 0;\n\n\t\tif(num>=k){\n\t\t\tint pos = i - k;\n\t\t\tif(pos<0) tmp[i] = 1;\n\t\t\telse  tmp[i] = w[pos];\n\t\t}\n\n\t\tw[i] = 0;\n\t\tif(s[i]=='W' || s[i]=='X'){\n\t\t\tif(i==0) w[i] = 1;\n\t\t\telse {\n\t\t\t\tif(i-1-k<-1){\n\t\t\t\t\tw[i] = tp[q[i-1]];\n\t\t\t\t}else{\n\t\t\t\t\tint pos = i-1-k;\n\t\t\t\t\tif(lastw>pos) pos = lastw-1;\n\t\t\t\t\tw[i] += sw[i-1] - (pos>=0?sw[pos]:0);\n\t\t\t\t}\n\t\t\t\tw[i]%=mod;\n\t\t\t\tif(w[i]<0) w[i]+=mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsw[i] = w[i];\n\t\tif(i) sw[i]+=sw[i-1],sw[i]%=mod;\n\t\t\n\t//\tcout<<i<<\" -> w[i] \"<<w[i]<<\"   sw[i] \"<<sw[i]<<\"  tmp \"<<tmp[i]<<endl;\n\t\tif(s[i]=='W') lastw=i;\n\t}\n\t\n\treturn tmp;\n}\n\nint go(string z, int pos){\n\tif(pos==z.size()){\n\t\tint num=0;\n\t\tREP(i,n){\n\t\t\tif(z[i]=='B') num++;\n\t\t\telse num = 0;\n\t\t\tif(num==k){\n\t\t\t\tnum=0;\n\t\t\t\tFOR(j,i,n){\n\t\t\t\t\tif(z[j]=='W') num++;\n\t\t\t\t\telse num=0;\n\t\t\t\t\tif(num==k) return 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tif(z[pos]=='X'){\n\t\tstring t1 = z;\n\t\tt1[pos]='B';\n\t\tres += go(t1, pos+1);\n\t\tt1[pos]='W';\n\t\tres += go(t1, pos+1);\n\t\treturn res;\n\t}\n\treturn go(z,pos+1);\n}\nint num(){\n\tstring z = s;\n\treturn go(z, 0);\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\ttp[0]= 1;\n\tFOR(i,1,1111111) tp[i]=(tp[i-1]*2)%mod;\n\tcin>>n>>k;\n\n\tscanf(\" %s\",s);\n\t\n\tv1 = solve(s);\n\t//REP(i,v1.size()) cout<<v1[i]<<' ';puts(\"\");\n\n\tREP(i,n) t[i] = s[n-1-i];\n\tREP(i,n) if(t[i]=='W') t[i]='B';\n\telse if(t[i]=='B') t[i]='W';\n\tv2 = solve(t);\n\treverse(v2.begin(),v2.end());\n\t//REP(i,v2.size()) cout<<v2[i]<<' ';puts(\"\");\n\n\tll res = 0;\n\tREP(i,v1.size()){\n\t\tsum[i] = v1[i];\n\t\tif(i){\n\t\t\tint add = sum[i-1];\n\t\t\tif(s[i]=='X') add*=2,add%=mod;\n\t\t\tsum[i] += add;\n\t\t\tsum[i] %= mod;\n\t\t}\n\t}\n\t//REP(i,v1.size()) cout<<i<<' '<<sum[i]<<endl;\n\n\t\n\n\tFOR(i,1,v2.size())if(v2[i]){\n\t\tres += v2[i] * ll(sum[i-1]);\n\t\t//cout<<\"add \"<<i<<' '<<v2[i]<<\" \"<< ll(sum[i-1])<<endl;\n\t\tres %= mod;\n\t}\n//\tcout<<res<<' '<<num()<<endl;\n\tcout<<res<<endl;\n\t\n#ifdef LocalHost\n\tcerr<<endl<<endl<<\"TIME: \"<<clock()<<endl;\n#endif\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Little Elephant and Retro Strings.json",
    "editorial_link": "https://codeforces.com/blog/entry/4849",
    "editorial": "Firstly we should solve following subproblem: for each prefix find the\r\nnumber of it\u00e2\u0080\u0099s fillings such that there is no consecutive block of\r\ncharacters . Let it be , where is the index in of the last character if\r\nthe prefix. Assing , where if = \u00e2\u0080\u0099X\u00e2\u0080\u0099 and otherwise. After such assing\r\nthere may be some bad filling included to . Since we suppouse that is\r\ncaclulated correctly, all bad filling must contain blocks of charcters\r\nonly at the end of the prefix (they may be included only if substring\r\ndoesn\u00e2\u0080\u0099t contain characters and character is not ). So, if it\u00e2\u0080\u0099s possible,\r\nwe must subtract from value , because it\u00e2\u0080\u0099s exactly the number of bad\r\nfillings. With the same DP you should you calc the same values for\r\nsuffixes (but this time changing by and vice versa). Now we should\r\ncarefully calculate the result in such way that now repeatings occur.\r\nLet iterate (from right to left) through all possible positions of the\r\nfirst blocks of characters (this means that we suppose that no block\r\noccur to the left). Using our DP we can simply find the number of\r\nfillings of all characters to the left from that block in such way that\r\nno another blocks of characters occur. Considering solutions, we can\r\niterate through all possible indexes of the begging of the last block of\r\ncharacters (again we suppose that this blocks must be the last and no\r\nanother may occur to the right) and agin using our DP count the number\r\nof fillings to the right. We don\u00e2\u0080\u0099t care what is between that blocks, so\r\nwe just multiply answer by 2^(the number of characters between blocks).\r\nBut, since we are going from right to the left, we can just keep\r\ntracking on all possible last blocks and get solution.\r\n"
}