{"link": "https://codeforces.com//contest/1508/problem/E", "problemId": "958785", "problem_idx": "E", "shortId": "1508E", "contest_number": "1508", "problem_submissions": {"D": [113258208, 113225842, 113232066, 113242382, 113242310, 113248310, 113252824, 113256393, 113240058, 113236672, 113233206, 113240165, 113242005, 113242817, 113243142], "F": [113247954, 113415583, 113275748, 113263512, 113569093, 113516939], "C": [113237315, 113213039, 113214478, 113213780, 113212574, 113213010, 113224842, 113226169, 113232722, 113215825, 113215542, 113224987, 113223453, 113228420, 113228228, 113217788, 113226078, 113229271, 113230097], "E": [113228353, 113239041, 113241831, 113228851, 113231701, 113244425, 113243109, 113247201, 113253919, 113253035, 113238610, 113246155, 113333091, 113246539, 113240797, 113246922], "A": [113201428, 113189518, 113189456, 113190605, 113198010, 113192641, 113194080, 113204739, 113207875, 113194317, 113200012, 113222414, 113194745, 113195037, 113199971, 113199286, 113193286, 113195565, 113191574, 113194231], "B": [113197951, 113196658, 113192904, 113196665, 113201215, 113199153, 113202442, 113210198, 113217372, 113203624, 113208530, 113197629, 113206458, 113203987, 113206383, 113212945, 113200476, 113197819, 113199529, 113200558]}, "name": "E. Tree Calendar", "statement": "Yuu Koito and Touko Nanami are newlyweds! On the wedding day, Yuu gifted\r\nTouko a directed tree with n nodes and rooted at 1, and a labeling a\r\nwhich is DFS order of the tree. Every edge in this tree is directed away\r\nfrom the root.After calling the following algorithm returns a as a DFS\r\norder of a tree rooted at 1 :order := 0a := array of length n function\r\ndfs(u): order := order + 1 a[u] := order for all v such that there is a\r\ndirected edge (u -> v): dfs(v)Note that there may be different DFS\r\norders for a given tree.Touko likes the present so much she decided to\r\nplay with it! On each day following the wedding day, Touko performs this\r\nprocedure once: Among all directed edges u\r\nrightarrow v such that a_u < a_v, select the edge u\u2019\r\nrightarrow v\u2019 with the lexicographically smallest pair (a_{u\u2019}, a_{v\u2019}).\r\nSwap a_{u\u2019} and a_{v\u2019}.Days have passed since their wedding, and Touko\r\nhas somehow forgotten which date the wedding was and what was the\r\noriginal labeling a! Fearing that Yuu might get angry, Touko decided to\r\nask you to derive these two pieces of information using the current\r\nlabeling.Being her good friend, you need to find the number of days that\r\nhave passed since the wedding, and the original labeling of the tree.\r\nHowever, there is a chance that Touko might have messed up her\r\nprocedures, which result in the current labeling being impossible to\r\nobtain from some original labeling; in that case, please inform Touko as\r\nwell.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N; cin >> N;\n\tvector<int> A(N); for (auto& a : A) { cin >> a; a--; }\n\tvector<vector<int>> adj(N);\n\tfor (int e = 0; e < N-1; e++) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tvector<int> B(N);\n\tvector<int> par(N);\n\tvector<int> depth(N);\n\tvector<int> C(N);\n\t{\n\t\tpar[0] = -1;\n\t\tdepth[0] = 0;\n\t\tint cur_idx = 0;\n\t\tint cur_post_idx = 0;\n\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\tB[cur] = cur_idx++;\n\t\t\tsort(adj[cur].begin(), adj[cur].end(), [&](int a, int b) { return A[a] < A[b]; });\n\t\t\tfor (int nxt : adj[cur]) {\n\t\t\t\tpar[nxt] = cur;\n\t\t\t\tadj[nxt].erase(std::find(adj[nxt].begin(), adj[nxt].end(), cur));\n\t\t\t\tdepth[nxt] = depth[cur]+1;\n\t\t\t\tself(nxt);\n\t\t\t}\n\t\t\tC[cur] = cur_post_idx++;\n\t\t})(0);\n\t\tassert(cur_idx == N);\n\t\tassert(cur_post_idx == N);\n\t}\n\n\tint64_t T = 0;\n\tbool is_good = [&]() -> bool {\n\t\tif (A[0] == 0) {\n\t\t\treturn A == B;\n\t\t}\n\t\tint last_move = A[0] - 1;\n\t\tint cur_loc = 0;\n\t\twhile (A[cur_loc] != last_move) cur_loc++;\n\t\t// We'll just extend the process a little bit\n\t\twhile (true) {\n\t\t\tauto it = adj[cur_loc].begin();\n\t\t\twhile (it != adj[cur_loc].end() && !(A[cur_loc] < A[*it])) ++it;\n\t\t\tif (it == adj[cur_loc].end()) break;\n\t\t\tstd::swap(A[cur_loc], A[*it]);\n\t\t\tcur_loc = *it;\n\t\t\tT--;\n\t\t}\n\n\t\t//for (int i = 0; i < N; i++) { cerr << A[i] << \" \\n\"[i+1==N]; }\n\n\t\t// Now, A must equal the known state, i.e. the prefix of size A[0] must be in postorder, and the rest are in preorder\n\t\tvector<int> V(N);\n\t\t{\n\t\t\tint cur_idx = last_move+1;\n\t\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\t\tif (C[cur] <= last_move) {\n\t\t\t\t\tT += depth[cur];\n\t\t\t\t\tV[cur] = C[cur];\n\t\t\t\t} else {\n\t\t\t\t\tV[cur] = cur_idx++;\n\t\t\t\t}\n\t\t\t\tfor (int nxt : adj[cur]) {\n\t\t\t\t\tself(nxt);\n\t\t\t\t}\n\t\t\t})(0);\n\t\t\tassert(cur_idx == N);\n\t\t}\n\t\t//for (int i = 0; i < N; i++) { cerr << V[i] << \" \\n\"[i+1==N]; }\n\t\treturn A == V;\n\t}();\n\n\tif (is_good) {\n\t\tcout << \"YES\" << '\\n';\n\t\tcout << T << '\\n';\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << B[i]+1 << \" \\n\"[i+1==N];\n\t\t}\n\t} else {\n\t\tcout << \"NO\" << '\\n';\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "data structures", "dfs and similar", "sortings", "trees"], "dificulty": "3100", "interactive": false}