{
    "link": "https://codeforces.com//contest/1508/problem/E",
    "problemId": "958785",
    "problem_idx": "E",
    "shortId": "1508E",
    "contest_number": "1508",
    "problem_submissions": {
        "D": [
            113258208,
            113225842,
            113232066,
            113242382,
            113242310,
            113248310,
            113252824,
            113256393,
            113240058,
            113236672,
            113233206,
            113240165,
            113242005,
            113242817,
            113243142
        ],
        "F": [
            113247954,
            113415583,
            113275748,
            113263512,
            113569093,
            113516939
        ],
        "C": [
            113237315,
            113213039,
            113214478,
            113213780,
            113212574,
            113213010,
            113224842,
            113226169,
            113232722,
            113215825,
            113215542,
            113224987,
            113223453,
            113228420,
            113228228,
            113217788,
            113226078,
            113229271,
            113230097
        ],
        "E": [
            113228353,
            113239041,
            113241831,
            113228851,
            113231701,
            113244425,
            113243109,
            113247201,
            113253919,
            113253035,
            113238610,
            113246155,
            113333091,
            113246539,
            113240797,
            113246922
        ],
        "A": [
            113201428,
            113189518,
            113189456,
            113190605,
            113198010,
            113192641,
            113194080,
            113204739,
            113207875,
            113194317,
            113200012,
            113222414,
            113194745,
            113195037,
            113199971,
            113199286,
            113193286,
            113195565,
            113191574,
            113194231
        ],
        "B": [
            113197951,
            113196658,
            113192904,
            113196665,
            113201215,
            113199153,
            113202442,
            113210198,
            113217372,
            113203624,
            113208530,
            113197629,
            113206458,
            113203987,
            113206383,
            113212945,
            113200476,
            113197819,
            113199529,
            113200558
        ]
    },
    "name": "E. Tree Calendar",
    "statement": "Yuu Koito and Touko Nanami are newlyweds! On the wedding day, Yuu gifted\r\nTouko a directed tree with n nodes and rooted at 1, and a labeling a\r\nwhich is DFS order of the tree. Every edge in this tree is directed away\r\nfrom the root.After calling the following algorithm returns a as a DFS\r\norder of a tree rooted at 1 :order := 0a := array of length n function\r\ndfs(u): order := order + 1 a[u] := order for all v such that there is a\r\ndirected edge (u -> v): dfs(v)Note that there may be different DFS\r\norders for a given tree.Touko likes the present so much she decided to\r\nplay with it! On each day following the wedding day, Touko performs this\r\nprocedure once: Among all directed edges u\r\nrightarrow v such that a_u < a_v, select the edge u\u2019\r\nrightarrow v\u2019 with the lexicographically smallest pair (a_{u\u2019}, a_{v\u2019}).\r\nSwap a_{u\u2019} and a_{v\u2019}.Days have passed since their wedding, and Touko\r\nhas somehow forgotten which date the wedding was and what was the\r\noriginal labeling a! Fearing that Yuu might get angry, Touko decided to\r\nask you to derive these two pieces of information using the current\r\nlabeling.Being her good friend, you need to find the number of days that\r\nhave passed since the wedding, and the original labeling of the tree.\r\nHowever, there is a chance that Touko might have messed up her\r\nprocedures, which result in the current labeling being impossible to\r\nobtain from some original labeling; in that case, please inform Touko as\r\nwell.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N; cin >> N;\n\tvector<int> A(N); for (auto& a : A) { cin >> a; a--; }\n\tvector<vector<int>> adj(N);\n\tfor (int e = 0; e < N-1; e++) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tvector<int> B(N);\n\tvector<int> par(N);\n\tvector<int> depth(N);\n\tvector<int> C(N);\n\t{\n\t\tpar[0] = -1;\n\t\tdepth[0] = 0;\n\t\tint cur_idx = 0;\n\t\tint cur_post_idx = 0;\n\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\tB[cur] = cur_idx++;\n\t\t\tsort(adj[cur].begin(), adj[cur].end(), [&](int a, int b) { return A[a] < A[b]; });\n\t\t\tfor (int nxt : adj[cur]) {\n\t\t\t\tpar[nxt] = cur;\n\t\t\t\tadj[nxt].erase(std::find(adj[nxt].begin(), adj[nxt].end(), cur));\n\t\t\t\tdepth[nxt] = depth[cur]+1;\n\t\t\t\tself(nxt);\n\t\t\t}\n\t\t\tC[cur] = cur_post_idx++;\n\t\t})(0);\n\t\tassert(cur_idx == N);\n\t\tassert(cur_post_idx == N);\n\t}\n\n\tint64_t T = 0;\n\tbool is_good = [&]() -> bool {\n\t\tif (A[0] == 0) {\n\t\t\treturn A == B;\n\t\t}\n\t\tint last_move = A[0] - 1;\n\t\tint cur_loc = 0;\n\t\twhile (A[cur_loc] != last_move) cur_loc++;\n\t\t// We'll just extend the process a little bit\n\t\twhile (true) {\n\t\t\tauto it = adj[cur_loc].begin();\n\t\t\twhile (it != adj[cur_loc].end() && !(A[cur_loc] < A[*it])) ++it;\n\t\t\tif (it == adj[cur_loc].end()) break;\n\t\t\tstd::swap(A[cur_loc], A[*it]);\n\t\t\tcur_loc = *it;\n\t\t\tT--;\n\t\t}\n\n\t\t//for (int i = 0; i < N; i++) { cerr << A[i] << \" \\n\"[i+1==N]; }\n\n\t\t// Now, A must equal the known state, i.e. the prefix of size A[0] must be in postorder, and the rest are in preorder\n\t\tvector<int> V(N);\n\t\t{\n\t\t\tint cur_idx = last_move+1;\n\t\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\t\tif (C[cur] <= last_move) {\n\t\t\t\t\tT += depth[cur];\n\t\t\t\t\tV[cur] = C[cur];\n\t\t\t\t} else {\n\t\t\t\t\tV[cur] = cur_idx++;\n\t\t\t\t}\n\t\t\t\tfor (int nxt : adj[cur]) {\n\t\t\t\t\tself(nxt);\n\t\t\t\t}\n\t\t\t})(0);\n\t\t\tassert(cur_idx == N);\n\t\t}\n\t\t//for (int i = 0; i < N; i++) { cerr << V[i] << \" \\n\"[i+1==N]; }\n\t\treturn A == V;\n\t}();\n\n\tif (is_good) {\n\t\tcout << \"YES\" << '\\n';\n\t\tcout << T << '\\n';\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << B[i]+1 << \" \\n\"[i+1==N];\n\t\t}\n\t} else {\n\t\tcout << \"NO\" << '\\n';\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "sortings",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Tree Calendar.json",
    "editorial_link": "https://codeforces.com//blog/entry/89644",
    "editorial": "From the structure, we see that until the end, the process is divided\r\ninto phases, where the -th involves phase pushing value from the root to\r\nthe smallest-labeled leaf. Also in the following tutorial, I will use\r\npost-order and exit order, as well as pre-order and DFS order\r\ninterchangeably. After finishing pushing , labels to are at the\r\npost-order positions, and the remaining labels from to form the\r\npre-order of the remaining part of the tree offsetted by . There\u00e2\u0080\u0099s a\r\nformal proof, but I think a better way is to show an illustration\r\ninstead. After pushing , we see that all green labels (label from to )\r\nare at their post-order positions, while all red labels (labels from to\r\n) are connected and form the pre-order of the red subtree, with an\r\noffset of . Moreover, this suggests that while pushing , the label of\r\nthe root is . On any day, the order of the values of the children of any\r\nnode stays the same.The proof will be left as an exercise for the\r\nreader, but a hint would be that for any node, a prefix of its children\r\nwill be green nodes (nodes that have been pushed), the rest are red\r\nnodes (nodes that haven\u00e2\u0080\u0099t been pushed). We can prove that the green\r\nnodes are ordered the same, the red nodes are ordered the same, and the\r\ngreen nodes are always less than the red nodes. Suppose we are\r\npushing/have just finished pushing . Then the number of days that have\r\npassed is the sum of heights of all labels from to . All labels that\r\nhave finished being pushed, or are being pushed, have all traversed from\r\nthe root down to their current position, which means the number of days\r\nto push each of these labels is equal to the height of the node\r\ncontaining the label.With the three lemmas, we can finally discuss the\r\nalgorithm: First, we sort the children of each node by its value. Then\r\nwe use this order to create the pre-order of the tree, and we can also\r\nfigure out the current value that is being pushed (it is the value of\r\nthe root minus 1). Call this value . Knowing the current value being\r\npushed, we first check if the current value is being pushed to the\r\ncorrect destination (i.e. check if the node with label is an ancestor of\r\nthe node with post-order ). Then, we can \"revert\" the pushing of by\r\nswapping it back up the root, also taking to account the number of days.\r\nFinally, we check if values are in the post-order positions, and values\r\nthat are form the pre-order shifted by of the remaining of the\r\ntree.Complexity is .\r\n"
}