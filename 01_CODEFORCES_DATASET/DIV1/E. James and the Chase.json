{
    "link": "https://codeforces.com//contest/1361/problem/E",
    "problemId": "640972",
    "problem_idx": "E",
    "shortId": "1361E",
    "contest_number": "1361",
    "problem_submissions": {
        "F": [
            82547256,
            82558388,
            82548841,
            82560787,
            82546613,
            82571701,
            82569539,
            82568479,
            82553474,
            82561525
        ],
        "D": [
            82532533,
            82534707,
            82556057,
            82527759,
            82536652,
            82533679,
            82553972,
            82540929,
            82539127,
            82540566,
            86424872,
            82526480,
            82568104,
            82567738,
            82567880
        ],
        "E": [
            82521789,
            82543705,
            82541718,
            82540946,
            82583418,
            82541333,
            82541041,
            82533619,
            82550465,
            82553317,
            82579674,
            82579569,
            82559988,
            82559485,
            82543445,
            82543446,
            82551504,
            82544569,
            82550130,
            82547325,
            82579220,
            82517696
        ],
        "C": [
            82504494,
            82509183,
            82560689,
            82519634,
            82513804,
            82519054,
            82526119,
            82516120,
            82517904,
            82521411,
            82523427,
            82525691,
            82518977,
            82516229,
            82512604,
            82516960,
            82527524,
            82521519,
            82527700,
            82553581
        ],
        "B": [
            82495175,
            82498230,
            82507103,
            82567148,
            82501464,
            82497400,
            82516527,
            82498261,
            82504352,
            82509962,
            82510314,
            82502680,
            82509498,
            82502669,
            82499583,
            82499214,
            82513823,
            82505015,
            82504805,
            82531052
        ],
        "A": [
            82492363,
            82493600,
            82494974,
            82494327,
            82492565,
            82492329,
            82494389,
            82493605,
            82492642,
            82494930,
            82499298,
            82494769,
            82492795,
            82495342,
            82493416,
            82492640,
            82495622,
            82493415,
            82512573,
            82523180
        ]
    },
    "name": "E. James and the Chase",
    "statement": "James Bond has a new plan for catching his enemy. There are some cities\r\nand roads between them, such that it is possible to travel between any\r\ntwo cities using these roads. When the enemy appears in some city, Bond\r\nknows her next destination but has no idea which path she will choose to\r\nmove there. The city a is called interesting, if for each city b, there\r\nis exactly one simple path from a to b. By a simple path, we understand\r\na sequence of distinct cities, such that for every two neighboring\r\ncities, there exists a directed road from the first to the second city.\r\nBond\u2019s enemy is the mistress of escapes, so only the chase started in an\r\ninteresting city gives the possibility of catching her. James wants to\r\narrange his people in such cities. However, if there are not enough\r\ninteresting cities, the whole action doesn\u2019t make sense since Bond\u2019s\r\npeople may wait too long for the enemy.You are responsible for finding\r\nall the interesting cities or saying that there is not enough of them.\r\nBy not enough, James means strictly less than 20\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 04.06.2020 18:07:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MAGIC = 239;\n\nconst int N = 100010;\n\nvector<int> g[N];\nbool in_st[N];\nbool was[N];\n\nbool dfs(int v) {\n  was[v] = true;\n  in_st[v] = true;\n  for (int u : g[v]) {\n    if (was[u]) {\n      if (!in_st[u]) {\n        in_st[v] = false;\n        return false;\n      }\n    } else {\n      if (!dfs(u)) {\n        in_st[v] = false;\n        return false;\n      }\n    }\n  }\n  in_st[v] = false;\n  return true;\n}\n\nvector<int> vis;\nint depth[N];\nint md[N];\nint md2[N];\nint mver[N];\nint mver2[N];\n\nvoid Update(int v, int x, int y) {\n  if (x < md[v]) {\n    md2[v] = md[v];\n    mver2[v] = mver[v];\n    md[v] = x;\n    mver[v] = y;\n  } else {\n    if (x < md2[v]) {\n      md2[v] = x;\n      mver2[v] = y;\n    }\n  }\n}\n\nvoid solve(int v) {\n  vis.push_back(v);\n  was[v] = true;\n  md[v] = md2[v] = depth[v];\n  mver[v] = mver2[v] = v;\n  for (int u : g[v]) {\n    if (was[u]) {\n      assert(depth[u] < depth[v]);\n      Update(v, depth[u], u);\n    } else {\n      depth[u] = depth[v] + 1;\n      solve(u);\n      Update(v, md[u], mver[u]);\n      Update(v, md2[u], mver2[u]);\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n      g[i].clear();\n    }\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n    }\n    vector<int> order(n);\n    iota(order.begin(), order.end(), 0);\n    shuffle(order.begin(), order.end(), rng);\n    int root = -1;\n    for (int iter = 0; iter < min(n, MAGIC); iter++) {\n      for (int i = 0; i < n; i++) {\n        was[i] = in_st[i] = false;\n      }\n      if (dfs(order[iter])) {\n        root = order[iter];\n        break;\n      }\n    }\n    if (root == -1) {\n      cout << -1 << '\\n';\n      continue;\n    }\n    for (int i = 0; i < n; i++) {\n      was[i] = false;\n    }\n    vis.clear();\n    depth[root] = 0;\n    solve(root);\n    vector<bool> is_good(n);\n    for (int i : vis) {\n      if (i == root) {\n        is_good[i] = true;\n      } else {\n        if (md[i] < depth[i] && md2[i] >= depth[i]) {\n          is_good[i] = is_good[mver[i]];\n        } else {\n          is_good[i] = false;\n        }\n      }\n    }\n    vector<int> res;\n    for (int i = 0; i < n; i++) {\n      if (is_good[i]) {\n        res.push_back(i);\n      }\n    }\n    if ((int) res.size() * 5 < n) {\n      cout << -1 << '\\n';\n      continue;\n    }\n    for (int i = 0; i < (int) res.size(); i++) {\n      if (i > 0) {\n        cout << \" \";\n      }\n      cout << res[i] + 1;\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "probabilities",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. James and the Chase.json",
    "editorial_link": "https://codeforces.com//blog/entry/78355",
    "editorial": "First, let us describe an algorithm for checking if a vertex is\r\ninteresting. Let be the vertex we want to check. Find any DFS tree\r\nrooted in that vertex. We can see that is interesting if and only if\r\nthat tree is unique. The tree is unique iff every non-tree edge leads\r\nfrom some vertex to \u00e2\u0080\u0099s ancestor. That condition can be easily checked in\r\n.Using the fact that we are interested only in cases when at least of\r\nvertices are interesting, we can find any interesting vertex by choosing\r\na random vertex, checking if it is interesting and repeating that\r\nalgorithm times or until we find an interesting vertex. For the\r\nprobability of failure is around .Denote that vertex as . Find the DFS\r\ntree rooted in that vertex. We can notice that vertex is interesting if\r\nand only if it has a unique path to all of its ancestors in this tree.\r\nWe will say that edge is passing vertex if it starts in its subtree\r\n(including ) and ends in one of the proper ancestors of . It is evident\r\nthat if two edges pass through , then cannot be interesting.Let us pick\r\nvertex such that there is at most one edge passing through it. It is\r\nevident that if , then there is at least one such edge (because our\r\ngraph is strongly connected). Let be the endpoint of this edge being a\r\nproper ancestor of . We prove that is interesting if and only if is\r\ninteresting.Pick arbitrary ancestor of which is an ancestor of , let us\r\ndenote it by . There is precisely one simple path from to descending in\r\nthe subtree of , using the non-tree edge to and then tree edges to reach\r\n.Now pick arbitrary common ancestor of and , let it be . If there is\r\nmore than one simple path from to , then obviously there is more than\r\none simple path from to . Otherwise, there is precisely one simple path\r\nfrom to descend in the subtree, use edge to and from there is one simple\r\npath to .The above observations allow computing interesting vertices\r\nusing simple DFSs. The final complexity is .\r\n"
}