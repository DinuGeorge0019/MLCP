{
    "link": "https://codeforces.com//contest/800/problem/C",
    "problemId": "103097",
    "problem_idx": "C",
    "shortId": "800C",
    "contest_number": "800",
    "problem_submissions": {
        "A": [
            26437824,
            26437413,
            26424399,
            26417348,
            26417549,
            26416882,
            26417345,
            26417672,
            26417220,
            26417679,
            26421663,
            26417804,
            26418603,
            26418392,
            26418074,
            26417524,
            26460923,
            26420581,
            26435242,
            26677047,
            26429059
        ],
        "E": [
            26433415,
            26477309,
            26437062,
            26436411
        ],
        "D": [
            26430216,
            26421580,
            26427879,
            26424854,
            26429250,
            26431239,
            26427030,
            26429935,
            26430978,
            26427918,
            26431811,
            26431775,
            26432322,
            26483339,
            26483333,
            26483260,
            26429237,
            26433768,
            26460903,
            26434200,
            26431466,
            26431322,
            26427768
        ],
        "C": [
            26426299,
            26426474,
            26424315,
            26429087,
            26424916,
            26425781,
            26430517,
            26426280,
            26425889,
            26430194,
            26427437,
            26427899,
            26428225,
            26431339,
            26426820,
            26427120,
            26426356,
            26426998,
            26421900
        ],
        "B": [
            26421783,
            26423033,
            26420771,
            26420198,
            26421833,
            26421342,
            26421711,
            26421555,
            26422110,
            26423813,
            26422982,
            26422079,
            26421473,
            26421858,
            26421532,
            26422706,
            26418487,
            26420698,
            26435223,
            26435196,
            26435077
        ]
    },
    "name": "C. Vulnerable Kerbals",
    "statement": "You are given an integer , and a list of distinct integers between and\r\n.You would like to construct a sequence satisfying the properties: Each\r\nelement is an integer between and , inclusive. All prefix products of\r\nthe sequence modulo are distinct. No prefix product modulo appears as an\r\nelement of the input list. The length of the sequence is maximized.\r\nConstruct any sequence satisfying the properties above.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 200000;\n\nstruct Input {\n\tint n, m;\n\tint a[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n >> m)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tvi ans;\n\t\n\tvoid write () {\n\t\tcout << sz(ans) << endl;\n\t\tforn (i, sz(ans)) {\n\t\t\tif (i) {\n\t\t\t\tprintf(\" \");\n\t\t\t}\n\t\t\tprintf(\"%d\", ans[i]);\n\t\t}\n\t\tputs(\"\");\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\t\n\t\tint gcd (int x, int y) {\n\t\t\tif (!x) {\n\t\t\t\treturn y;\n\t\t\t}\n\t\t\treturn gcd(y % x, x);\n\t\t}\n\t\t\n\t\tset<int> v[N + 1];\n\t\t\n\t\tint d[N + 1], pr[N + 1];\n\t\tll rev[N];\n\t\t\n\t\tll cur;\n\t\t\n\t\tvoid rec (int i) {\n\t\t\tif (pr[i] != -1) {\n\t\t\t\trec(pr[i]);\n\t\t\t}\n\t\t\tfor (ll x : v[i]) {\n\t\t\t\tll p = x;\n\t\t\t\tll q = cur;\n\t\t\t\tll g = gcd(p, q);\n\t\t\t\tp /= g;\n\t\t\t\tq /= g;\n\t\t\t\tll val = p * rev[q] % m;\n\t\t\t\tans.pb(val);\n\t\t\t\tcur = cur * val % m;\n\t\t\t\tassert(cur == x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tint phi = m;\n\t\t\t{\n\t\t\t\tint m0 = m;\n\t\t\t\tforn (i, 2, N + 1) {\n\t\t\t\t\tif (m0 % i == 0) {\n\t\t\t\t\t\twhile (m0 % i == 0) {\n\t\t\t\t\t\t\tm0 /= i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphi /= i;\n\t\t\t\t\t\tphi *= i - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tforn (i, m) {\n\t\t\t\trev[i] = 1;\n\t\t\t\tll x = i;\n\t\t\t\tll pw = phi - 1;\n\t\t\t\twhile (pw) {\n\t\t\t\t\tif (pw & 1) {\n\t\t\t\t\t\t(rev[i] *= x) %= m;\n\t\t\t\t\t}\n\t\t\t\t\t(x *= x) %= m;\n\t\t\t\t\tpw >>= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tforn (i, m) {\n\t\t\t\tv[gcd(i, m)].insert(i);\n\t\t\t}\n\t\t\tforn (i, n) {\n\t\t\t\tv[gcd(a[i], m)].erase(a[i]);\n\t\t\t}\n\t\t\t\n\t\t\tmemset(d, 0, sizeof d);\n\t\t\tmemset(pr, -1, sizeof pr);\n\t\t\tforn (i, m + 1) {\n\t\t\t\td[i] = sz(v[i]);\n\t\t\t}\n\t\t\tforn (i, 1, m + 1) {\n\t\t\t\tfor (int j = 2 * i; j <= m; j += i) {\n\t\t\t\t\tif (umx(d[j], d[i] + sz(v[j]))) {\n\t\t\t\t\t\tpr[j] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bst = 0;\n\t\t\tint mx = 0;\n\t\t\tforn (i, m + 1) {\n\t\t\t\tif (umx(mx, d[i])) {\n\t\t\t\t\tbst = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = 1;\n\t\t\tdebug(mx);\n\t\t\trec(bst);\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Vulnerable Kerbals.json",
    "editorial_link": "https://codeforces.com//blog/entry/51598",
    "editorial": "Let's consider a directed graph with m nodes, labeled from 1 to m, where there is an edge between nodes i and node j if there exists a number x such that .\n\nNow, we can notice there is an edge between node i and node j if and only if gcd(n,?i) divides gcd(n,?j).\n\nSo, there are two directed edges between two nodes i and j if and only if gcd(n,?i)?=?gcd(n,?j). So, these form some directed cliques in our graphs.\n\nWe can also notice that this happens to form the SCC decomposition of our graph (i.e. condensation). So this problem reduces to finding the heaviest path in a DAG with weights on nodes. The nodes in this dag correspond to divisors of n, and the weight corresponds to the number of allowed numbers with that gcd.",
    "hint": []
}