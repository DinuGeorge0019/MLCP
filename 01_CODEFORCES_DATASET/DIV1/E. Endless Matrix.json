{"link": "https://codeforces.com//contest/249/problem/E", "problemId": "2274", "problem_idx": "E", "shortId": "249E", "contest_number": "249", "problem_submissions": {"B": [2649094, 2645222, 2648325, 2645133, 2741637, 2647160, 2646906, 2647140, 2647297, 2647803, 2649557, 2647782, 2649225, 2647984], "C": [2648016, 2646272, 2649752, 2649594, 2648682, 2650241, 2650113], "D": [2646289, 2646128, 2648091, 2747311, 2647914, 2649873, 2686963, 3563620], "A": [2645128, 2644427, 2643471, 2646603, 2643981, 2650080, 2644186, 2645243, 2644193, 2644672, 2644232, 2644059, 2650955, 2650931, 2645477, 2644588, 2644531], "E": [2649181, 2648187, 2749553, 2893989]}, "name": "E. Endless Matrix", "statement": "A Russian space traveller Alisa Selezneva, like any other schoolgirl of\r\nthe late 21 century, is interested in science. She has recently visited\r\nthe MIT (Moscow Institute of Time), where its chairman and the\r\nco-inventor of the time machine academician Petrov told her about the\r\nconstruction of a time machine.During the demonstration of the time\r\nmachine performance Alisa noticed that the machine does not have high\r\nspeed and the girl got interested in the reason for such disadvantage.\r\nAs it turns out on closer examination, one of the problems that should\r\nbe solved for the time machine isn\u2019t solved by an optimal algorithm. If\r\nyou find a way to solve this problem optimally, the time machine will\r\nrun faster and use less energy.A task that none of the staff can solve\r\noptimally is as follows. There exists a matrix , which is filled by the\r\nfollowing rule:The cells are consecutive positive integers, starting\r\nwith one. Besides, (), if: ; and ; , and . So, after the first numbers\r\nare inserted, matrix will look as follows: To solve the problem, you\r\nshould learn to find rather quickly for the given values of and () the\r\nmeaning of expression:As the meaning of this expression can be large\r\nenough, it is sufficient to know only the last digits of the sought\r\nvalue.So, no one in MTI can solve the given task. Alice was brave enough\r\nto use the time machine and travel the past to help you.Your task is to\r\nwrite a program that uses the given values and finds the last digits of\r\nthe given expression.\r\n", "solutions": ["#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef double du;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, s, t) for(i = (s); i < (t); i++)\n#define RFOR(i, s, t) for(i = (s)-1; i >= (t); i--)\nconst ll MOD = 10000000000LL;\nconst ll MOD1 = 120000000000LL;\n\nll mul(ll a, ll b){\n    return (a*b - ((int)((du)a*b/MOD1) - 2) * MOD1) % MOD1;\n}\n\n//ll pow(int a, int k){\n//    ll ret = 1;\n//    while(k--)\n//        ret = ret*a%MOD;\n//    return ret;\n//}\n//\n//struct Num{\n//    int p2, p5, etc;\n//    du v;\n//    \n//    Num(){}\n//    Num(int v){\n//        p2 = p5 = 0;\n//        this->v = v;\n//        while(v % 2 == 0){\n//            p2++;\n//            v /= 2;\n//        }\n//        while(v % 5 == 0){\n//            p5++;\n//            v /= 5;\n//        }\n//        etc = v % MOD;\n//    }\n//    \n//    Num operator+(const Num& a){\n//        Num ret;\n//        ret.v = v + a.v;\n//        \n//    }\n//}\n\nll s3(int n){\n    return mul(n, mul(n, mul(n+1, n+1)))/4;\n}\n\nll s2(int n){\n    return mul(n, mul(n+1, 2*n+1))/6;\n}\n\nll s1(int n){\n    return mul(n, n+1)/2;\n}\n\nll s0(int n){\n    return n;\n}\n\nll solve(int x1, int x2, int y1, int y2){\n    if(x2 < x1 || y2 < y1)\n        return 0;\n    if(x1 == y1 && x2 == y2){\n        return (2*(s3(x2) - s3(x1-1) - s2(x2) + s2(x1-1) + s1(x2) - s1(x1-1)) - mul(2*x1-1, s2(x2) - s2(x1-1) - s1(x2) + s1(x1-1) + s0(x2) - s0(x1-1))) % MOD;\n    }\n    if(x2 < y1){\n        return (mul(x2-x1+1, s2(y2)-s2(y1-1)+s0(y2)-s0(y1-1)) - mul(y2-y1+1, s1(x2) - s1(x1-1))) % MOD;\n    }\n    if(y2 < x1){\n        return (mul(y2-y1+1, s2(x2-1)-s2(x1-2)) + mul(x2-x1+1, s1(y2) - s1(y1-1))) % MOD;\n    }\n    int p1, p2;\n    p1 = max(x1, y1);\n    p2 = min(x2, y2);\n    return (solve(x1, p1-1, y1, p1-1) + solve(x1, p1-1, p1, p2) + solve(x1, p1-1, p2+1, y2)\n            + solve(p1, p2, y1, p1-1) + solve(p1, p2, p1, p2) + solve(p1, p2, p2+1, y2)\n            + solve(p2+1, x2, y1, p1-1) + solve(p2+1, x2, p1, p2) + solve(p2+1, x2, p2+1, y2)) % MOD;\n}\n\nll f(int x, int y){\n    if(x < y)\n        return (ll)y*y+1-x;\n    return (ll)(x-1)*(x-1)+y;\n}\n\nll solve1(int x1, int x2, int y1, int y2){\n    ll ret = 0;\n    int i, j;\n    for(i = x1; i <= x2 && ret < MOD; i++)\n        for(j = y1; j <= y2 && ret < MOD; j++)\n            ret += f(i, j);\n    if(ret < MOD)\n        cout<<ret<<endl;\n    else{\n        ll t = (solve(x1, x2, y1, y2)%MOD + MOD) % MOD;\n        printf(\"...%010I64d\\n\", t);\n    }\n}\n\nint main()\n{\n    #ifdef __FIO\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    #endif\n    int n;\n    int x1, x2, y1, y2;\n    scanf(\"%d\", &n);\n    while(n--){\n        cin>>x1>>y1>>x2>>y2;\n        solve1(y1, y2, x1, x2);\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["math"], "dificulty": "2600", "interactive": false}