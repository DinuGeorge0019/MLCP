{
    "link": "https://codeforces.com//contest/1198/problem/F",
    "problemId": "380940",
    "problem_idx": "F",
    "shortId": "1198F",
    "contest_number": "1198",
    "problem_submissions": {
        "F": [
            58070272,
            58050274,
            58050240,
            58050207,
            58050120,
            58050094,
            58050069,
            58050046,
            58050006,
            58049923,
            58049860,
            58049749,
            58019601,
            58020980,
            58023606,
            58025464,
            58030444,
            58024358,
            58026672,
            58028904,
            58162403,
            58161986,
            58161687,
            58161301,
            58039796,
            58039793,
            58039362,
            58039355,
            58039125,
            58039123,
            58038995,
            58038994,
            58038812,
            58038810,
            58038134,
            58038133,
            58037905,
            58037904,
            58037582,
            58037581,
            58037164,
            58036882,
            58036679,
            58032989,
            58029905,
            58028352,
            58028560,
            58031397,
            58032467,
            58052909,
            58052897,
            58051859,
            58036577,
            58036553
        ],
        "D": [
            58009170,
            58008663,
            58011717,
            58013706,
            58003645,
            58007012,
            58019265,
            58015153,
            58015508,
            58008652,
            58007749,
            58009878,
            58015548,
            58020689,
            58012149,
            58011680,
            58013790,
            58004635
        ],
        "E": [
            58005211,
            58006936,
            58007024,
            58005225,
            58009765,
            58014251,
            58015403,
            58012193,
            58011483,
            58014790,
            58013911,
            58010339,
            58023389,
            58007572,
            58008131,
            57999112,
            58014046
        ],
        "C": [
            58001259,
            57997749,
            58001059,
            58007271,
            58013728,
            58018717,
            58005961,
            58006629,
            58048331,
            58006607,
            57998153,
            58003794,
            58001508,
            58001992,
            58002563,
            58001272,
            58004043,
            57999919
        ],
        "B": [
            57998572,
            58004780,
            57994973,
            58001340,
            57998225,
            58001182,
            57997197,
            58002237,
            57998507,
            58005059,
            58000720,
            57998812,
            57999975,
            57997709,
            58009338,
            57997300
        ],
        "A": [
            57995047,
            57995575,
            57997676,
            57995156,
            57995500,
            57997301,
            57995357,
            57998877,
            57995263,
            58002849,
            58004383,
            58026838,
            57997108,
            57995572,
            58007187,
            57995267
        ]
    },
    "name": "F. GCD Groups 2",
    "statement": "You are given an array of n integers. You need to split all integers\r\ninto two groups so that the GCD of all integers in the first group is\r\nequal to one and the GCD of all integers in the second group is equal to\r\none.The GCD of a group of integers is the largest non-negative integer\r\nthat divides all the integers in the group.Both groups have to be\r\nnon-empty.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\n \nint n;\nint tab[nax];\n \nint naj[nax];\nint g[19][nax];\n \nint sito[nax];\nvi pie;\n \nvoid nope()\n{\n\tprintf(\"NO\\n\");\n\texit(0);\n}\n \nvoid mam(vi wek)\n{\n\tprintf(\"YES\\n\");\n\tvi wyp(n, 1);\n\tfor (int i : wek)\n\t\twyp[i-1]++;\n\tfor (int i : wyp)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n\");\n\texit(0);\n}\n \nint daj(int a, int b)\n{\n\tint d=naj[b-a+1];\n\treturn __gcd(g[d][a], g[d][b-(1<<d)+1]);\n}\n \nint czycos(int a, int b, int w)\n{\n\tif (!w)\n\t\treturn 1;\n\tint d=naj[b-a+1];\n\treturn (g[d][a]%w)>0 || (g[d][b-(1<<d)+1]%w)>0;\n}\n \nvi stos;\n \nvoid czysc(int &v)\n{\n\tfor (int i : pie)\n\t{\n\t\tif (i>2000)\n\t\t\tbreak;\n\t\tint w=i*i;\n\t\twhile(!(v%w))\n\t\t\tv/=i;\n\t}\n}\n \nint znajdz(int v, int c)\n{\n\tint bsa=v;\n\tint bsb=n+1;\n\twhile(bsa<bsb)\n\t{\n\t\tint bss=(bsa+bsb)>>1;\n\t\tif (czycos(v, bss, c))\n\t\t\tbsb=bss;\n\t\telse\n\t\t\tbsa=bss+1;\n\t}\n\treturn bsa;\n}\n \nvoid rek(int v, int a, int b)\n{\n\tif (a==1 && b==1)\n\t\tmam(stos);\n\tif (v>n)\n\t\treturn;\n\tif (!czycos(v, n, a) && !czycos(v, n, b))\n\t\treturn;\n\tint x=znajdz(v, a);\n\tint y=znajdz(v, b);\n\tif (x==y)\n\t{\n\t\tstos.push_back(x);\n\t\trek(x+1, __gcd(a, tab[x]), b);\n\t\tstos.pop_back();\n\t\trek(x+1, a, __gcd(b, tab[x]));\n\t}\n\telse\n\t{\n\t\tif (x<y)\n\t\t{\n\t\t\tstos.push_back(x);\n\t\t\trek(x+1, __gcd(a, tab[x]), b);\n\t\t\tstos.pop_back();\n\t\t}\n\t\telse\n\t\t{\n\t\t\trek(y+1, a, __gcd(b, tab[y]));\n\t\t}\n\t}\n}\n \nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\tfor (int i=2; i<nax; i++)\n\t{\n\t\tif (!sito[i])\n\t\t{\n\t\t\tpie.push_back(i);\n\t\t\tfor (int j=i; j<nax; j+=i)\n\t\t\t\tsito[j]=1;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tczysc(tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tnaj[i]=naj[i-1];\n\t\tif ((1<<(naj[i]+1))<=i)\n\t\t\tnaj[i]++;\n\t\tg[0][i]=tab[i];\n\t}\n\tfor (int h=1; h<=naj[n]; h++)\n\t\tfor (int i=1; i+(1<<h)-1<=n; i++)\n\t\t\tg[h][i]=__gcd(g[h-1][i], g[h-1][i+(1<<(h-1))]);\n\trek(1, 0, 0);\n\tnope();\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "number theory",
        "probabilities"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. GCD Groups 2.json",
    "editorial_link": "https://codeforces.com/blog/entry/68812",
    "editorial": "All numbers have no more than different prime divisors.If there exist a\r\nsolution, then for every number there exist a solution in which this\r\nnumber is in group of size not more than , because all we have to do is\r\nto \"kill\" all prime numbers from this number, and to do it we only need\r\none number for each prime.If , we can try all the splits in time .Let\u00e2\u0080\u0099s\r\ntake two numbers which will be in different groups. How to do it? let\u00e2\u0080\u0099s\r\ntake random pair. For fixed first number probability of mistake is no\r\nmore than . Now in each group we have to kill no more than primes. Let\u00e2\u0080\u0099s\r\ndo subset DP our state is what primes are still alive. This solution has\r\ncomplexity .But we actually don\u00e2\u0080\u0099t need all numbers. For each prime we\r\ncan look at no more than candidates which can kill it, because to kill\r\nall other primes we need strictly less numbers, and we will have a spare\r\none anyways. Thus the solution has complexity . We don\u00e2\u0080\u0099t need\r\nfactorization for any numbers except two chosen, and we can factorize\r\nthem in .\r\n"
}