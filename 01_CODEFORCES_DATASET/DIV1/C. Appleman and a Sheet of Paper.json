{
    "link": "https://codeforces.com//contest/461/problem/C",
    "problemId": "13282",
    "problem_idx": "C",
    "shortId": "461C",
    "contest_number": "461",
    "problem_submissions": {
        "E": [
            7595647,
            7593699,
            7595828,
            7594579,
            7595368,
            7600512,
            7595421,
            7661605,
            9294347,
            9294343,
            10452636
        ],
        "D": [
            7592651,
            7591771,
            7603387,
            7594572,
            7594433,
            7594196,
            7595170,
            7595635,
            7724393,
            7593683,
            7594245,
            7661058,
            8893908,
            10452336
        ],
        "C": [
            7587261,
            7587069,
            7586600,
            7586584,
            7590688,
            7588429,
            7587923,
            7590253,
            7588926,
            7591752,
            7589784,
            7592394,
            7587055,
            7589392,
            7587666,
            7587706,
            7588473
        ],
        "B": [
            7582196,
            7583106,
            209010830,
            7582794,
            7583033,
            7586901,
            7583221,
            7584128,
            7587075,
            7584566,
            7585023,
            7585807,
            7586879,
            7595401,
            7583774,
            7584143,
            7583861
        ],
        "A": [
            7580528,
            7580809,
            7580521,
            7581246,
            7587762,
            7581843,
            7580912,
            7581190,
            7581018,
            7581719,
            7581029,
            7581078,
            7581003,
            7584251,
            7580442,
            7580814,
            7580452
        ]
    },
    "name": "C. Appleman and a Sheet of Paper",
    "statement": "Appleman has a very big sheet of paper. This sheet has a form of\r\nrectangle with dimensions . Your task is help Appleman with folding of\r\nsuch a sheet. Actually, you need to perform queries. Each query will\r\nhave one of the following types: Fold the sheet of paper at position .\r\nAfter this query the leftmost part of the paper with dimensions must be\r\nabove the rightmost part of the paper with dimensions . Count what is\r\nthe total width of the paper pieces, if we will make two described later\r\ncuts and consider only the pieces between the cuts. We will make one cut\r\nat distance from the left border of the current sheet of paper and the\r\nother at distance from the left border of the current sheet of paper.\r\nPlease look at the explanation of the first test example for better\r\nunderstanding of the problem.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAX_N = int(1e5) + 10;\n\nstruct TA {\n\tint a[MAX_N], n;\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t\tmemset(a, 0, sizeof a);\n\t}\n\tvoid add(int p, int x) {\n\t\tfor (p++; p <= n; p += p & -p)\n\t\t\ta[p - 1] += x;\n\t}\n\tint get(int p) {\n\t\tint r = 0;\n\t\tfor (p++; p; p -= p & -p)\n\t\t\tr += a[p - 1];\n\t\treturn r;\n\t}\n} ta;\nint a[MAX_N];\n\nstruct Node {\n\tint val, idx;\n\tNode(int val, int idx) :\n\t\t\tval(val), idx(idx) {\n\t}\n};\n\nvoid putOn(Node&a, Node b) {\n\ta.val += b.val;\n\tta.add(a.idx, b.val);\n}\n\nint main() {\n\tint n, Q;\n\tcin >> n >> Q;\n\tta.init(n);\n\n\tdeque<Node> que;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = 1;\n\t\tta.add(i, 1);\n\t\tque.push_back(Node(a[i], i));\n\t}\n\tbool rev = false;\n\twhile (Q--) {\n\n//\t\tfor (int i = 0; i < n; ++i) {\n//\t\t\tcout << que[i].val << \" \";\n//\t\t}\n//\t\tcout << endl;\n\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d%d\", &l, &r);\n\t\t\t--r;\n\t\t\tint L, R;\n\t\t\tif (!rev) {\n\t\t\t\tL = que[l].idx;\n\t\t\t\tR = que[r].idx;\n\t\t\t} else {\n\t\t\t\tL = que[que.size() - 1 - l].idx;\n\t\t\t\tR = que[que.size() - 1 - r].idx;\n\t\t\t}\n\t\t\tif (L > R)\n\t\t\t\tswap(L, R);\n\t\t\tprintf(\"%d\\n\", ta.get(R) - ta.get(L - 1));\n\t\t} else {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (!rev) {\n\t\t\t\tif (q * 2 <= que.size()) {\n\t\t\t\t\tvector<Node> get;\n\t\t\t\t\tfor (int i = 0; i < q; ++i) {\n\t\t\t\t\t\tget.push_back(que.front());\n\t\t\t\t\t\tque.pop_front();\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < q; ++i) {\n//\t\t\t\t\t\tta.add(que[i].idx, get[q - 1 - i].val);\n\t\t\t\t\t\tputOn(que[i], get[q - 1 - i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint last = que.size() - q;\n\t\t\t\t\tvector<Node> get;\n\t\t\t\t\tfor (int i = 0; i < last; ++i) {\n\t\t\t\t\t\tget.push_back(que.back());\n\t\t\t\t\t\tque.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < last; ++i) {\n\t\t\t\t\t\tputOn(que[que.size() - 1 - i], get[last - 1 - i]);\n\t\t\t\t\t}\n\t\t\t\t\trev ^= 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (q * 2 <= que.size()) {\n\t\t\t\t\tint last = q;\n\t\t\t\t\tvector<Node> get;\n\t\t\t\t\tfor (int i = 0; i < last; ++i) {\n\t\t\t\t\t\tget.push_back(que.back());\n\t\t\t\t\t\tque.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < last; ++i) {\n\t\t\t\t\t\tputOn(que[que.size() - 1 - i], get[last - 1 - i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint last = que.size() - q;\n\t\t\t\t\tvector<Node> get;\n\t\t\t\t\tfor (int i = 0; i < last; ++i) {\n\t\t\t\t\t\tget.push_back(que.front());\n\t\t\t\t\t\tque.pop_front();\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < last; ++i) {\n\t\t\t\t\t\tputOn(que[i], get[last - 1 - i]);\n\t\t\t\t\t}\n\t\t\t\t\trev ^= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Appleman and a Sheet of Paper.json",
    "editorial_link": "https://codeforces.com/blog/entry/13568",
    "editorial": "For each first type queries that p_i > (the length of the paper) p_i,\r\nyou should express the operation in another way: not fold the left side\r\nof the paper but fold the right side of the paper. After such query you\r\nneed to think as the paper is flipped. Let\u00e2\u0080\u0099s define count[i] as the\r\nnumber of papers piled up at the segment [i,i+1] (absolute position).\r\nFor each query of first type you can update each changed count[i]\r\nnaively. Use BIT or segment tree for count[i] because you can answer\r\neach second type queries in O(log n). The complexity of a first type\r\nquery is O((the decrement of the length of the paper) log n) so total\r\ncomplexity of a first type query is O(n log n).\r\n"
}