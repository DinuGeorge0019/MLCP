{
    "link": "https://codeforces.com//contest/605/problem/E",
    "problemId": "42721",
    "problem_idx": "E",
    "shortId": "605E",
    "contest_number": "605",
    "problem_submissions": {
        "C": [
            14733414,
            14720384,
            14720999,
            14727321,
            14722464,
            14721634,
            14727835,
            14731363,
            14731595,
            14730092,
            14726129,
            14721720,
            14724282,
            14722284,
            14722209,
            14728049
        ],
        "D": [
            14724788,
            14728609,
            14730065,
            14729000,
            14724493,
            14732219,
            14728421,
            14723804,
            14721730,
            14724221,
            14732566,
            14780111,
            14732774,
            14732416,
            14730015,
            14724377
        ],
        "A": [
            14722715,
            14715950,
            14715817,
            14716990,
            14715828,
            14715926,
            14717224,
            14715773,
            14715784,
            14715907,
            14716365,
            14720150,
            14715839,
            14716429,
            14716499,
            14716967,
            14715831,
            14715776
        ],
        "B": [
            14721948,
            14718121,
            14718105,
            14718689,
            14718666,
            14718313,
            14719575,
            14717722,
            14717902,
            14718552,
            14718421,
            14718419,
            14718059,
            14719671,
            14718443,
            14719771,
            14718528,
            14719776
        ],
        "E": [
            14718635,
            14725044,
            14723153,
            14726864,
            14729961,
            14722181,
            14723791,
            14727330,
            14729035,
            14727305,
            14723008,
            14728473,
            14728113,
            14731024,
            14729704,
            14736246,
            14736224
        ]
    },
    "name": "E. Intergalaxy Trips",
    "statement": "The scientists have recently discovered wormholes objects in space that\r\nallow to travel very long distances between galaxies and star systems.\r\nThe scientists know that there are galaxies within reach. You are in the\r\ngalaxy number and you need to get to the galaxy number . To get from\r\ngalaxy to galaxy , you need to fly onto a wormhole and in exactly one\r\ngalaxy day you will find yourself in galaxy . Unfortunately, the\r\nrequired wormhole is not always available. Every galaxy day they\r\ndisappear and appear at random. However, the state of wormholes does not\r\nchange within one galaxy day. A wormhole from galaxy to galaxy exists\r\nduring each galaxy day taken separately with probability . You can\r\nalways find out what wormholes exist at the given moment. At each moment\r\nyou can either travel to another galaxy through one of wormholes that\r\nexist at this moment or you can simply wait for one galaxy day to see\r\nwhich wormholes will lead from your current position at the next\r\nday.Your task is to find the expected value of time needed to travel\r\nfrom galaxy to galaxy , if you act in the optimal way. It is guaranteed\r\nthat this expected value exists.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint n,p[N][N],vis[N];\nlong double E[N],prob[N],coef[N];\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,0,n) rep(j,0,n) scanf(\"%d\",&p[i][j]);\n\trep(i,0,n) E[i]=1e30,prob[i]=1,coef[i]=0;\n\tE[n-1]=0;\n\trep(k,0,n) {\n\t\tlong double mv=1e30; int ps=-1;\n\t\trep(i,0,n) if (!vis[i]&&E[i]<mv) mv=E[i],ps=i;\n\t\tvis[ps]=1;\n\t\tif (ps==0) {\n\t\t\tprintf(\"%.15f\\n\",(double)E[0]);\n\t\t\treturn 0;\n\t\t}\n\t\trep(i,0,n) if (!vis[i]) {\n\t\t\tcoef[i]+=E[ps]*prob[i]*0.01*p[i][ps];\n\t\t\tprob[i]*=(1-0.01*p[i][ps]);\n\t\t\tif (prob[i]<1-1e-6) E[i]=(1+coef[i])/(1-prob[i]);\n\t\t}\n\t}\n\tassert(0);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "probabilities",
        "shortest paths"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Intergalaxy Trips.json",
    "editorial_link": "https://codeforces.com//blog/entry/22019",
    "editorial": "m(x) = p(x, v[0]) * ans(v[0]) + (1 p(x, v[0]) * p(x, v[1]) * ans(v[1]) +\r\n(1 p(x, v[0]) * (1 p(x, v[1]) * p(x, v[2]) * ans(v[2]) + + (1 p(x,\r\nv[0]) * (1 p(x, v[1]) * * (1 p(x, v[i-1]) * m(x) + 1 Here m(x) estimate\r\nfor vertex x, p(a,b) the probability of existence of edge (a,b), and\r\nans(v) known answer for vertex v. Note that m(x) expressed by itself,\r\nbecause there is a probability of staying in place. We will keep\r\nestimating expression for each vertex in the form of m(x) = A[x] *\r\nm(x) + B[x]. For each vertex we will keep A[x] and B[x]. This would mean\r\nthat with some probabilites it would be possible to move to some better\r\nvertex, and this opportunity gives contribution to expected time equal\r\nto B[x], and also with some probability we have to stay in place, and\r\nthis probability is A[x] (this is just the same as coefficient before\r\nm(x) in the expression). So, on each step we select one currently\r\nnon-fixed vertex v with minimal estimate, then fix it and do relaxation\r\nfrom it, refreshing estimates for other vertices. When we refresh\r\nestimate for some vertex x, we change its A[x] and B[x]. A[x] is reduced\r\nby A[x] * p(x,v), because the probability of staying still consider it s\r\nnot possible to move to v. B[x] is increased by A[x] * p(x,v) * ans(v),\r\nwhere A[x] is the probability that it s not possible to use some vertex\r\nbetter than v, A[x] * p(x,v) is the probability that it s also possible\r\nto use vertex v, and ans(v) known answer we just fixed for vertex v. To\r\ncalculate the value of estimate for some vertex x, we can use expression\r\nm(x) = A[x] * m(x) + B[x] and express m(x) from it. Exactly m(x) is that\r\nvalue we should keep on the priority queue in out Dijkstra analogue, and\r\nexactly m(x) is the value to fix as the final answer for vertex x, when\r\nthis vertex is announced as vertex with minimal estimate at the start of\r\na step.\r\n",
    "hint": []
}