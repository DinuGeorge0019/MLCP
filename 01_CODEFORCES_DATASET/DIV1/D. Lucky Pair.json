{
    "link": "https://codeforces.com//contest/145/problem/D",
    "problemId": "838",
    "problem_idx": "D",
    "shortId": "145D",
    "contest_number": "145",
    "problem_submissions": {
        "E": [
            1105208,
            1105912,
            1104894,
            1102760,
            1106240,
            1105850,
            1107323,
            1106178,
            1106652,
            1107141,
            1106053,
            1106917,
            1110162,
            1106271,
            1108116,
            1106093,
            1106858,
            1105628,
            1106422
        ],
        "C": [
            1103754,
            1105077,
            1104008,
            1104728,
            1104390,
            1104502,
            1105076,
            1107490,
            1105685,
            1104716,
            1104727,
            1105594,
            1110098,
            1102678,
            1104471,
            1104980,
            1102716,
            1106604,
            1105209
        ],
        "B": [
            1102413,
            1103328,
            1106135,
            1106485,
            1102911,
            1103531,
            1103090,
            1103085,
            1103776,
            1103710,
            1107536,
            1102801,
            1110016,
            1106756,
            1108339
        ],
        "A": [
            1101171,
            1101193,
            1101307,
            1101588,
            1101358,
            1101247,
            1101150,
            1101748,
            1101315,
            1101364,
            1101363,
            1110038,
            1103077,
            1101351,
            1101685,
            1101209,
            1101163,
            1101232
        ],
        "D": [
            1131693,
            1131692,
            1124995,
            107142023,
            107141858,
            107141498,
            107140808,
            107137178
        ]
    },
    "name": "D. Lucky Pair",
    "statement": "Petya has an array of integers. The numbers in the array are numbered\r\nstarting from . Unfortunately, Petya has been misbehaving and so, his\r\nparents don’t allow him play with arrays that have many lucky numbers.\r\nIt is guaranteed that no more than elements in the array are lucky\r\nnumbers. Petya needs to find the number of pairs of non-intersecting\r\nsegments and (, all four numbers are integers) such that there’s no such\r\nlucky number that occurs simultaneously in the subarray and in the\r\nsubarray . Help Petya count the number of such pairs.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:65777216\")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint n;\nint a[111111];\nvi v;\n\nbool lucky(int x){\n\twhile(x){\n\t\tint c = x%10;\n\t\tif(c!=4 && c!=7) return 0;\n\t\tx/=10;\n\t}\n\treturn 1;\n}\n\nmap<int,vi> pos;\nset<int> cannot;\n\nint stupid(){\n\tint res = 0;\n\tREP(i,n){\n\t\tcannot.clear();\n\t\tFOR(j,i,n){\n\t\t\tif(lucky(a[j])) cannot.insert(a[j]);\n\t\t\tFOR(x,j+1,n){\n\t\t\t\tFOR(z,x,n){\n\t\t\t\t\tif(lucky(a[z]) && cannot.count(a[z])) break;\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nset<int> parsed;\nbool DEBUG=0;\n\nint main(){\n#ifdef LocalHost\n    freopen(\"input.txt\",\"r\",stdin);\n//    freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tcin>>n;\n\tREP(i,n) scanf(\"%d\",a+i);\n\n\tREP(i,n)\n\t\tif(lucky(a[i])) v.pb(a[i]),pos[a[i]].pb(i);\n\t\telse{\n\t\t\tif(v.size() && v.back()<0) v.back()--;\n\t\t\telse v.pb(-1);\n\t\t}\n\tll res = 0;\n\tint rpos = 0;\n\tREP(i,v.size()){\t\t\n\t\tcannot.clear();\n\t\tint nextpos = rpos;\n\t\tif(v[i]<0) nextpos -= v[i];\n\t\telse nextpos++;\n\n\t\tint tpos = rpos;\n\t\tparsed.clear();\n\t\tll cnt = (n-nextpos)*ll(n-nextpos+1)/2;\n\t\tfor(int j=i;j<v.size();j++){\n\n\t\t\tint rnextpos = tpos;\n\t\t\tif(v[j]<0) rnextpos -= v[j];\n\t\t\telse rnextpos ++;\n\t\t\t\n\t\t\tif(v[j]>0){\n\n\t\t\t\tif(cannot.count(tpos))\n\t\t\t\t\tcannot.erase(tpos);\n\t\t\t\tif(!parsed.count(v[j])){\n\t\t\t\t\tparsed.insert(v[j]);\n\t\t\t\t\tvi &vv = pos[v[j]];\n\t\t\t\t\tfor(int k=vv.size()-1;vv[k]>=rnextpos;k--){\n\n\t\t\t\t\t\tcannot.insert(vv[k]);\n\t\t\t\t\t\tset<int>::iterator it = cannot.find(vv[k]);\n\t\t\t\t\t\tset<int>::iterator it2 = it;\n\t\t\t\t\t\tll end = n;\n\t\t\t\t\t\tit2++;\n\t\t\t\t\t\tif(it2!=cannot.end()) end = *it2;\n\t\t\t\t\t\tll beg = rnextpos-1;\n\t\t\t\t\t\tif(it!=cannot.begin()){\n\t\t\t\t\t\t\tit--;\n\t\t\t\t\t\t\tbeg = *it;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tll len = end - beg - 1;\n\n\t\t\t\t\t\tcnt -= len*(len+1)/2;\n\t\t\t\t\t\tcnt += (end-vv[k]-1)*(end-vv[k])/2;\n\t\t\t\t\t\tcnt += (vv[k]-beg-1)*(vv[k]-beg)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll c1 = -v[i];if(c1<0) c1=1;\n\t\t\tll c2 = -v[j];if(c2<0) c2=1;\n\t\t\tif(i==j){\n\t\t\t\tres += c1*(c1+1)/2*cnt;\n\t\t\t\t\t\n\t\t\t}else{\n\t\t\t\tres += c1*c2*cnt;\n\t\t\t\t\t\n\t\t\t}\n\t\t\tif(c2>1){\n\t\t\t\tif(i==j){\n\t\t\t\t\tres += c1*(c1-1)/2;\n\t\t\t\t\tres += c1*(c1-1)*(c1-2)/3;\n\t\t\t\t\tll t = c1*(c1-1)/2*(c1-2)/3;\n\t\t\t\t\tll t2 = (c1-3);\n\t\t\t\t\tif(t%4==0) t/=4;\n\t\t\t\t\telse if(t2%4==0) t2/=4;\n\t\t\t\t\telse t/=2,t2/=2;\n\t\t\t\t\tres += t*t2;\n\t\t\t\t\tint val = n;\n\t\t\t\t\tif(cannot.size()) val = *cannot.begin();\n\t\t\t\t\tres += c1 *(c1-1) / 2 *(val - rnextpos);\n\t\t\t\t\tres += c1 * (c1-1)*(c1-2)/6*(val - rnextpos);\n\t\t\t\t}else{\n\t\t\t\t\tres += c1*c2*(c2-1)/2;\n\t\t\t\t\tll t = c1*c2*(c2-1)/2;\n\t\t\t\t\tll t2 = (c2-2);\n\t\t\t\t\tif(t%3==0) t/=3;\n\t\t\t\t\telse t2/=3;\n\t\t\t\t\tres += t*t2;\n\n\t\t\t\t\tint val = n;\n\t\t\t\t\tif(cannot.size()) val = *cannot.begin();\n\t\t\t\t\tres += c1 * c2*(c2-1)/2*(val - rnextpos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j+1<n){\n\t\t\t\tint val = n;\n\t\t\t\tif(cannot.size()) val = *cannot.begin();\n\t\t\t\tll nm = -v[j+1];\n\t\t\t\tif(nm<0) nm = 1;\n\t\t\t\tcnt -= (val-rnextpos+val-rnextpos-nm+1)*nm/2;\n\t\t\t\ttpos=rnextpos;\n\t\t\t}\n\t\t}\n\t\trpos = nextpos;\n\t}\n\tcout<<res<<endl;//' '<<stupid()<<endl;\n\n#ifdef LocalHost\n\tcout<<endl<<endl<<\"TIME: \"<<clock()<<endl;\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "implementation"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Lucky Pair.json",
    "editorial_link": "https://codeforces.com//blog/entry/3746",
    "editorial": "The main point of this problem is that number of lucky numbers in array is ???1000. Imagine that there is array of 1000 number in range [1;1000] each, and you want to find number of such pairs that there is no equal number in both segments. How to solve this problem? Let we have fixed left point of right segment, let it be i. The you should iterate through all j (i???j) - right point of right segment. If you have some fixed right segment [i;j], then there is some set S of numbers that are in that right segment. So, segment [0;i?-?1] will be divided in some subsegments that don't contain any number from S. For example, let S = {1,?2,?3} and segment [0;i?-?1] is [2,?4,?2,?3,?6,?5,?7,?1], then there will be such subsegments (0-based numeration): [1;1], [4;6]. Of course, any subsegment of that subsegments will be good too: they dont contain any number from S, too. So, you can keep in set (or some structure like set) all good subsegments and keep number of all good subsegments in [0;i?-?1]. When you iterate j from i to n?-?1, you will add some numbers to S. When you add some number in S, you should add all occurrences of that number in subarray [0;i]. Notice, that when some number is already in S, you don't need to look at that numbers. So, for fixed i you should do O(n?*?logn) operations - any number from a[0;i?-?1] will be added at most once to set. \n\nNow, we have not only lucky numbers. So, the problem is the same, but between number there are some \"bad\" numbers - in this case this are unlucky numbers. But, you can notice, that if we will fix only such i that a[i] is lucky and iterate j only such that a[j] is lucky then you can calculate result in the same way that in simpler problem. But that method allow you to only count such pairs that right one contains some lucky number. So you also need to count other ones. To do so you can fix some i - left point of right segment, such that a[i] is unlucky. Let F(i) equals to minimum such j (j?>?i) that a[i] is lucky. Then there are F(i)?-?i ways to expand right segment. All such right segments doesn't contain any lucky number. So any left segment will be good. And there are i?*?(i?+?1)?/?2 of such left segments (0-based). ",
    "hint": []
}