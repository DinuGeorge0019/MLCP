{"link": "https://codeforces.com//contest/145/problem/D", "problemId": "838", "problem_idx": "D", "shortId": "145D", "contest_number": "145", "problem_submissions": {"E": [1105208, 1105912, 1104894, 1102760, 1106240, 1105850, 1107323, 1106178, 1106652, 1107141, 1106053, 1106917, 1110162, 1106271, 1108116, 1106093, 1106858, 1105628, 1106422], "C": [1103754, 1105077, 1104008, 1104728, 1104390, 1104502, 1105076, 1107490, 1105685, 1104716, 1104727, 1105594, 1110098, 1102678, 1104471, 1104980, 1102716, 1106604, 1105209], "B": [1102413, 1103328, 1106135, 1106485, 1102911, 1103531, 1103090, 1103085, 1103776, 1103710, 1107536, 1102801, 1110016, 1106756, 1108339], "A": [1101171, 1101193, 1101307, 1101588, 1101358, 1101247, 1101150, 1101748, 1101315, 1101364, 1101363, 1110038, 1103077, 1101351, 1101685, 1101209, 1101163, 1101232], "D": [1131693, 1131692, 1124995, 107142023, 107141858, 107141498, 107140808, 107137178]}, "name": "D. Lucky Pair", "statement": "Petya has an array of integers. The numbers in the array are numbered\r\nstarting from . Unfortunately, Petya has been misbehaving and so, his\r\nparents don\u2019t allow him play with arrays that have many lucky numbers.\r\nIt is guaranteed that no more than elements in the array are lucky\r\nnumbers. Petya needs to find the number of pairs of non-intersecting\r\nsegments and (, all four numbers are integers) such that there\u2019s no such\r\nlucky number that occurs simultaneously in the subarray and in the\r\nsubarray . Help Petya count the number of such pairs.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:65777216\")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint n;\nint a[111111];\nvi v;\n\nbool lucky(int x){\n\twhile(x){\n\t\tint c = x%10;\n\t\tif(c!=4 && c!=7) return 0;\n\t\tx/=10;\n\t}\n\treturn 1;\n}\n\nmap<int,vi> pos;\nset<int> cannot;\n\nint stupid(){\n\tint res = 0;\n\tREP(i,n){\n\t\tcannot.clear();\n\t\tFOR(j,i,n){\n\t\t\tif(lucky(a[j])) cannot.insert(a[j]);\n\t\t\tFOR(x,j+1,n){\n\t\t\t\tFOR(z,x,n){\n\t\t\t\t\tif(lucky(a[z]) && cannot.count(a[z])) break;\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nset<int> parsed;\nbool DEBUG=0;\n\nint main(){\n#ifdef LocalHost\n    freopen(\"input.txt\",\"r\",stdin);\n//    freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tcin>>n;\n\tREP(i,n) scanf(\"%d\",a+i);\n\n\tREP(i,n)\n\t\tif(lucky(a[i])) v.pb(a[i]),pos[a[i]].pb(i);\n\t\telse{\n\t\t\tif(v.size() && v.back()<0) v.back()--;\n\t\t\telse v.pb(-1);\n\t\t}\n\tll res = 0;\n\tint rpos = 0;\n\tREP(i,v.size()){\t\t\n\t\tcannot.clear();\n\t\tint nextpos = rpos;\n\t\tif(v[i]<0) nextpos -= v[i];\n\t\telse nextpos++;\n\n\t\tint tpos = rpos;\n\t\tparsed.clear();\n\t\tll cnt = (n-nextpos)*ll(n-nextpos+1)/2;\n\t\tfor(int j=i;j<v.size();j++){\n\n\t\t\tint rnextpos = tpos;\n\t\t\tif(v[j]<0) rnextpos -= v[j];\n\t\t\telse rnextpos ++;\n\t\t\t\n\t\t\tif(v[j]>0){\n\n\t\t\t\tif(cannot.count(tpos))\n\t\t\t\t\tcannot.erase(tpos);\n\t\t\t\tif(!parsed.count(v[j])){\n\t\t\t\t\tparsed.insert(v[j]);\n\t\t\t\t\tvi &vv = pos[v[j]];\n\t\t\t\t\tfor(int k=vv.size()-1;vv[k]>=rnextpos;k--){\n\n\t\t\t\t\t\tcannot.insert(vv[k]);\n\t\t\t\t\t\tset<int>::iterator it = cannot.find(vv[k]);\n\t\t\t\t\t\tset<int>::iterator it2 = it;\n\t\t\t\t\t\tll end = n;\n\t\t\t\t\t\tit2++;\n\t\t\t\t\t\tif(it2!=cannot.end()) end = *it2;\n\t\t\t\t\t\tll beg = rnextpos-1;\n\t\t\t\t\t\tif(it!=cannot.begin()){\n\t\t\t\t\t\t\tit--;\n\t\t\t\t\t\t\tbeg = *it;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tll len = end - beg - 1;\n\n\t\t\t\t\t\tcnt -= len*(len+1)/2;\n\t\t\t\t\t\tcnt += (end-vv[k]-1)*(end-vv[k])/2;\n\t\t\t\t\t\tcnt += (vv[k]-beg-1)*(vv[k]-beg)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll c1 = -v[i];if(c1<0) c1=1;\n\t\t\tll c2 = -v[j];if(c2<0) c2=1;\n\t\t\tif(i==j){\n\t\t\t\tres += c1*(c1+1)/2*cnt;\n\t\t\t\t\t\n\t\t\t}else{\n\t\t\t\tres += c1*c2*cnt;\n\t\t\t\t\t\n\t\t\t}\n\t\t\tif(c2>1){\n\t\t\t\tif(i==j){\n\t\t\t\t\tres += c1*(c1-1)/2;\n\t\t\t\t\tres += c1*(c1-1)*(c1-2)/3;\n\t\t\t\t\tll t = c1*(c1-1)/2*(c1-2)/3;\n\t\t\t\t\tll t2 = (c1-3);\n\t\t\t\t\tif(t%4==0) t/=4;\n\t\t\t\t\telse if(t2%4==0) t2/=4;\n\t\t\t\t\telse t/=2,t2/=2;\n\t\t\t\t\tres += t*t2;\n\t\t\t\t\tint val = n;\n\t\t\t\t\tif(cannot.size()) val = *cannot.begin();\n\t\t\t\t\tres += c1 *(c1-1) / 2 *(val - rnextpos);\n\t\t\t\t\tres += c1 * (c1-1)*(c1-2)/6*(val - rnextpos);\n\t\t\t\t}else{\n\t\t\t\t\tres += c1*c2*(c2-1)/2;\n\t\t\t\t\tll t = c1*c2*(c2-1)/2;\n\t\t\t\t\tll t2 = (c2-2);\n\t\t\t\t\tif(t%3==0) t/=3;\n\t\t\t\t\telse t2/=3;\n\t\t\t\t\tres += t*t2;\n\n\t\t\t\t\tint val = n;\n\t\t\t\t\tif(cannot.size()) val = *cannot.begin();\n\t\t\t\t\tres += c1 * c2*(c2-1)/2*(val - rnextpos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j+1<n){\n\t\t\t\tint val = n;\n\t\t\t\tif(cannot.size()) val = *cannot.begin();\n\t\t\t\tll nm = -v[j+1];\n\t\t\t\tif(nm<0) nm = 1;\n\t\t\t\tcnt -= (val-rnextpos+val-rnextpos-nm+1)*nm/2;\n\t\t\t\ttpos=rnextpos;\n\t\t\t}\n\t\t}\n\t\trpos = nextpos;\n\t}\n\tcout<<res<<endl;//' '<<stupid()<<endl;\n\n#ifdef LocalHost\n\tcout<<endl<<endl<<\"TIME: \"<<clock()<<endl;\n#endif\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "data structures", "implementation"], "dificulty": "2900", "interactive": false}