{"link": "https://codeforces.com//contest/1528/problem/C", "problemId": "994164", "problem_idx": "C", "shortId": "1528C", "contest_number": "1528", "problem_submissions": {"F": [117241784, 117237625, 117249711, 117251014, 117237719, 117247531, 117250487, 117296792, 117362083], "C": [117229826, 117199788, 117206577, 117201851, 117204674, 117206245, 117218212, 117196904, 117210131, 117210736, 117206890, 117212730, 117208145, 117211669, 117203428, 117211467, 117203007, 117206081, 117210746, 117210824], "E": [117212844, 117230561, 117222959, 117226469, 117224989, 117238353, 117239558, 117216115, 117234224, 117239827, 117237600, 117238423, 117244129, 117238121, 117240390, 117239904, 117240349, 117240625, 117238487, 117240173], "D": [117201259, 117208270, 117212623, 117211738, 117242708, 117216479, 117225362, 117203170, 117222650, 117216984, 117223735, 117223429, 117215498, 117223732, 117224661, 117222534, 117223454, 117224387, 117255573, 117255349, 117255220, 117226605, 117221662], "B": [117190972, 117190286, 117191599, 117193984, 117197139, 117198582, 117200082, 117188842, 117200429, 117191737, 117195913, 117196829, 117195712, 117199801, 117193006, 117201359, 117211353, 117194542, 117198721, 117194778], "A": [117185385, 117182301, 117183363, 117182330, 117185042, 117182254, 117192623, 117181878, 117188021, 117186007, 117186714, 117183913, 117183194, 117189883, 117184967, 117183486, 117187212, 117183227, 117187339, 117198905]}, "name": "C. Trees of Tranquillity", "statement": "Soroush and Keshi each have a labeled and rooted tree on n vertices.\r\nBoth of their trees are rooted from vertex 1.Soroush and Keshi used to\r\nbe at war. After endless decades of fighting, they finally became allies\r\nto prepare a Codeforces round. To celebrate this fortunate event, they\r\ndecided to make a memorial graph on n vertices.They add an edge between\r\nvertices u and v in the memorial graph if of the following conditions\r\nhold: One of u or v is the ancestor of the other in Soroush\u2019s tree.\r\nNeither of u or v is the ancestor of the other in Keshi\u2019s tree. Here\r\nvertex u is considered ancestor of vertex v, if u lies on the path from\r\n1 (the root) to the v.Popping out of nowhere, Mashtali tried to find the\r\nmaximum clique in the memorial graph for no reason. He failed because\r\nthe graph was too big. Help Mashtali by finding the size of the maximum\r\nclique in the memorial graph.As a reminder, clique is a subset of\r\nvertices of the graph, each two of which are connected by an edge.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = 1e9;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi, mset = inf, madd = 0, val = -1;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tint query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -1;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, int x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\n\ntemplate <bool VALS_EDGES> struct HLD {\n\tint N, tim = 0;\n\tvector<vi> adj;\n\tvi par, siz, depth, rt, pos;\n\tNode *tree;\n\tHLD(vector<vi> adj_)\n\t\t: N(sz(adj_)), adj(adj_), par(N, -1), siz(N, 1), depth(N),\n\t\t  rt(N),pos(N),tree(new Node(0, N)){ dfsSz(),dfsHld();}\n\tvoid dfsSz(int v = 0) {\n\t\tif (par[v] != -1) adj[v].erase(find(all(adj[v]), par[v]));\n\t\ttrav(u, adj[v]) {\n\t\t\tpar[u] = v, depth[u] = depth[v] + 1;\n\t\t\tdfsSz(u);\n\t\t\tsiz[v] += siz[u];\n\t\t\tif (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);\n\t\t}\n\t}\n\tvoid dfsHld(int v = 0) {\n\t\tpos[v] = tim++;\n\t\ttrav(u, adj[v]) {\n\t\t\trt[u] = (u == adj[v][0] ? rt[v] : u);\n\t\t\tdfsHld(u);\n\t\t}\n\t}\n\ttemplate <class B> void process(int u, int v, B op) {\n\t\tfor (; rt[u] != rt[v]; v = par[rt[v]]) {\n\t\t\tif (depth[rt[u]] > depth[rt[v]]) swap(u, v);\n\t\t\top(pos[rt[v]], pos[v] + 1);\n\t\t}\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\top(pos[u] + VALS_EDGES, pos[v] + 1);\n\t}\n\tvoid modifyPath(int u, int v, int val) {\n\t\tprocess(u, v, [&](int l, int r) { tree->add(l, r, val); });\n\t}\n\tint queryPath(int u, int v) { // Modify depending on query\n\t\tint res = -1e9;\n\t\tprocess(u, v, [&](int l, int r) {\n\t\t\t\tres = max(res, tree->query(l, r));\n\t\t});\n\t\treturn res;\n\t}\n\tint querySubtree(int v) { // modifySubtree is similar\n\t\treturn tree->query(pos[v] + VALS_EDGES, pos[v] + siz[v]);\n\t}\n};\n\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<int> par1(n);\n\tvector<vector<int> > ch1(n);\n\tpar1[0] = -1;\n\tfor(int i = 1; i < n; i++){\n\t\tcin >> par1[i];\n\t\tpar1[i]--;\n\t\tch1[par1[i]].push_back(i);\n\t}\n\tvector<int> par2(n);\n\tvector<vector<int> > ch2(n);\n\n\tvector<vector<int> > e2(n);\n\tpar2[0] = -1;\n\tfor(int i = 1; i < n; i++){\n\t\tcin >> par2[i];\n\t\tpar2[i]--;\n\t\tch2[par2[i]].push_back(i);\n\t\te2[i].push_back(par2[i]);\n\t\te2[par2[i]].push_back(i);\n\t}\n\tvector<pair<int,int> > events;\n\ty_combinator([&](auto self, int v) -> void {\n\t\tevents.push_back({0, v});\n\t\tfor(int w : ch1[v]){\n\t\t\tself(w);\n\t\t}\n\t\tevents.push_back({1, v});\n\t})(0);\n\tvector<int> st(n);\n\tvector<int> en(n);\n\tint T = 0;\n\ty_combinator([&](auto self, int v) -> void {\n\t\tst[v] = T;\n\t\tT++;\n\t\tfor(int w : ch2[v]){\n\t\t\tself(w);\n\t\t}\n\t\ten[v] = T-1;\n\t})(0);\n\n\tvector<int> idx(n);\n\tfor(int i = 0; i < n; i++){\n\t\tidx[st[i]] = i;\n\t}\n\n\tHLD<false> hld(e2);\n\tset<int> alive_set;\n\tint ans = 0;\n\tint cnt = 0;\n\tvector<int> used(n, 0);\n\tfor(auto [type, v] : events){\n\t\tif(type == 0){\n\t\t\tint w = hld.queryPath(0, v);\n\t\t\tif(w >= 0){\n\t\t\t\tw = idx[w];\n\t\t\t\tif(used[w]){\n\t\t\t\t\tused[w] = 0;\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t}\n\t\t\thld.modifyPath(v, v, 1 + st[v]);\n\t\t\talive_set.insert(st[v]);\n\t\t\tauto f = alive_set.upper_bound(st[v]);\n\t\t\tif(f == alive_set.end() || *f > en[v]){\n\t\t\t\tused[v] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else if(type == 1){\n\t\t\thld.modifyPath(v, v, -(1 + st[v]));\n\t\t\talive_set.erase(st[v]);\n\t\t\tif(used[v]){\n\t\t\t\tused[v] = 0;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tint w = hld.queryPath(0, v);\n\t\t\tif(w >= 0){\n\t\t\t\tw = idx[w];\n\t\t\t\tif(!used[w]){\n\t\t\t\t\tauto f = alive_set.upper_bound(st[w]);\n\t\t\t\t\tif(f == alive_set.end() || *f > en[w]){\n\t\t\t\t\t\tused[w] = 1;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else assert(false);\n\t\tans = max(ans, cnt);\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "greedy", "trees"], "dificulty": "2300", "interactive": false}