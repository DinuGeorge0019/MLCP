{
    "link": "https://codeforces.com//contest/1349/problem/F1",
    "problemId": "619064",
    "problem_idx": "F1",
    "shortId": "1349F1",
    "contest_number": "1349",
    "problem_submissions": {
        "D": [
            79861873,
            79861806,
            79948658,
            79858494,
            79903166,
            131108532,
            79877857,
            79879188,
            79879019,
            79872081,
            80757765,
            79874857,
            79891331
        ],
        "C": [
            79835117,
            79843720,
            79834387,
            79845607,
            79830281,
            79843236,
            79849443,
            79848794,
            79845617,
            79852466,
            79831253,
            79854349,
            79853472,
            79844058,
            79856498,
            79879255,
            79856862,
            79848324,
            79861537
        ],
        "B": [
            79827155,
            79837122,
            79822255,
            79821907,
            79838530,
            79834646,
            79835497,
            79841171,
            79842066,
            79829421,
            79839013,
            79841661,
            79841348,
            79839739,
            79833357,
            79841018,
            79840476,
            79842544,
            79837256,
            79834808
        ],
        "A": [
            79817454,
            79821533,
            79816750,
            79834360,
            79820968,
            90907998,
            90906860,
            90496887,
            79817368,
            94393615,
            79825623,
            79828847,
            79817688,
            79819374,
            79828023,
            79820779,
            79831851,
            79831246,
            79823300,
            79821494,
            79829816,
            79823411,
            79929306,
            79822107
        ],
        "E": [
            85193181,
            79886501,
            80023736
        ],
        "F2": [
            81605329,
            85716790,
            84837609,
            84835671,
            80416603,
            80415302,
            80161085
        ],
        "F1": [
            79982046,
            79890867,
            79859528,
            80154258,
            79886462,
            79874667,
            79884418,
            79878453,
            79892295,
            79881330,
            79892657,
            79875367,
            79882448,
            79932700
        ]
    },
    "name": "F1. Slime and Sequences  Easy Version ",
    "statement": "Slime is interested in sequences. He defined positive integer sequences\r\np of length n as follows: For each k>1 that presents in p, there should\r\nbe at least one pair of indices i,j, such that 1\r\nleq i < j\r\nleq n, p_i = k - 1 and p_j = k.For the given integer n, the set of all\r\ngood sequences of length n is s_n. For the fixed integer k and the\r\nsequence p, let f_p(k) be the number of times that k appears in p. For\r\neach k from 1 to n, Slime wants to know the following value:\r\nleft(\r\nsum_{p\r\nin s_n} f_p(k)\r\nright)\r\ntextrm{mod}\r\n998\r\n,244\r\n,353\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nstruct modinfo{uint mod,root;};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(int n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\nusing mint=modular<base>;\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_GOOD_MOD\n\n//size of input must be a power of 2\n//output of forward fmt is bit-reversed\n//output elements are in the range [0,mod*4)\n//input of inverse fmt should be bit-reversed\ntemplate<class mint>\nvoid inplace_fmt(const int n,mint*const f,bool inv){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],ig[L],p2[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tmint w=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\tg[i]=w;\n\t\t\tig[i]=w.inv();\n\t\t\tp2[i]=mint(1<<i).inv();\n\t\t}\n\t}\n\tif(!inv){\n\t\tint b=n;\n\t\tif(b>>=1){//input:[0,mod)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*2)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\twhile(b){\n\t\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tint b=1;\n\t\tif(b<n/2){//input:[0,mod)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t\tb<<=1;\n\t\t}\n\t\tfor(;b<n/2;b<<=1){\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b/2){//input:[0,mod*2)\n\t\t\t\t\tull x=f[j].v+mod2-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j].v=(f[j].v)<mod2?f[j].v:f[j].v-mod2;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\trng(j,i+b/2,i+b){//input:[0,mod)\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b<n){//input:[0,mod*2)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod2-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tmint z=p2[__lg(n)];\n\t\trep(i,n)f[i]*=z;\n\t}\n}\n\ntemplate<class mint>\nvoid inplace_fmt(vector<mint>&f,bool inv){\n\tinplace_fmt(si(f),f.data(),inv);\n}\n\ntemplate<class mint>\nvoid half_fmt(const int n,mint*const f){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],h[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tg[i]=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\th[i]=mint::root().pow((mod-1)>>(i+2));\n\t\t}\n\t}\n\tint b=n;\n\tint lv=0;\n\tif(b>>=1){//input:[0,mod)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\tif(b>>=1){//input:[0,mod*2)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\twhile(b){\n\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<class mint>\nvoid half_fmt(vector<mint>&f){\n\thalf_fmt(si(f),f.data());\n}\n\ntemplate<class mint>\nvc<mint> multiply(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint n=si(x)+si(y)-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tvc<mint> z(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\n//59501818244292734739283969-1=5.95*10^25 \u307e\u3067\u306e\u5024\u3092\u6b63\u3057\u304f\u8a08\u7b97\n//\u6700\u7d42\u7684\u306a\u5217\u306e\u5927\u304d\u3055\u304c 2^24 \u307e\u3067\u306a\u3089\u52d5\u304f\n//\u6700\u7d42\u7684\u306a\u5217\u306e\u5927\u304d\u3055\u304c 2^20 \u4ee5\u4e0b\u306e\u3068\u304d\u306f\uff0c\u4e0b\u306e 3 \u3064\u306e\u7d20\u6570\u3092\u4f7f\u3063\u305f\u307b\u3046\u304c\u901f\u3044\uff08\u306f\uff1f\uff09\n//VERIFY: yosupo\n//Yukicoder No980 (same=true)\nnamespace arbitrary_convolution{\n\t//constexpr modinfo base0{167772161,3};//2^25 * 5 + 1\n\t//constexpr modinfo base1{469762049,3};//2^26 * 7 + 1\n\t//constexpr modinfo base2{754974721,11};//2^24 * 45 + 1\n\tconstexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\tconstexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\tconstexpr modinfo base2{1053818881,7};//2^20 * 1005 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\tusing mint2=modular<base2>;\n\ttemplate<class t,class mint>\n\tvc<t> sub(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tauto d2=sub<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tvc<mint> res(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tres[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n//using arbitrary_convolution::multiply;\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n;cin>>n;\n\tvc<mint> cur(n+2,1);\n\tvc<mint> ans(n+1);\n\trng(i,1,n+1){\n\t\trep(j,n+2)cur[j]*=j;\n\t\tvc<mint> w(i+1);\n\t\trep(j,i+1){\n\t\t\tw[j]=finv[j]*finv[i-j];\n\t\t\tif(j%2)w[j]=-w[j];\n\t\t}\n\t\tvc<mint> z(i+1);\n\t\trep(j,i+1)\n\t\t\tz[j]=cur[j+1]-cur[j];\n\t\tauto t=multiply(w,z);\n\t\trep(j,i+1)ans[j]+=t[j];\n\t}\n\tans.pop_back();\n\trep(i,n)ans[i]*=fact[n];\n\tprint(ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F1. Slime and Sequences  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/77284",
    "editorial": "First we can make a bijection between all the good sequences and\r\npermutations. Let a permutation of length be , and we fill \u00e2\u0080\u0099>\u00e2\u0080\u0099 or \u00e2\u0080\u0099<\u00e2\u0080\u0099\r\nsign between each and , so the value of is the number of \u00e2\u0080\u0099<\u00e2\u0080\u0099 sign\r\nbetween plus one, it\u00e2\u0080\u0099s easy to proof that this is a correct\r\nbijection.Let be the number of permutations of length that have at least\r\n\u00e2\u0080\u0099<\u00e2\u0080\u0099 signs in it. Then for each \u00e2\u0080\u0099<\u00e2\u0080\u0099 sign, we can combine the places next\r\nto it, so for some combined places, there are only one way to put the\r\nnumbers in it for a fix set of numbers. And we know that have sets of\r\ncombined places, so the value of is the number of ways to assign numbers\r\ninto different sets. From the EGF of the second kind of Stirling\r\nnumbers, we know that . We can also use DP that similar with the\r\nStirling numbers to get all .When we find the answers, for each , we\r\nconsider the contribution of each places, so for each , we need to find\r\nthe number of permutations that have \u00e2\u0080\u0099<\u00e2\u0080\u0099 signs before it. So we can get:\r\nIf we can find for each , then we can find the answer in one\r\nconvolution.And because of the simple DP algorithm to find all , so we\r\ncan get a complexity to solve the problem, and it can pass the easy\r\nversion (other forms of DP can also get to this time complexity, but now\r\nwe only introduce the form that leads to the solution of the hard\r\nversion).\r\n"
}