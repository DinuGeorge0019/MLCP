{
    "link": "https://codeforces.com//contest/403/problem/B",
    "problemId": "7184",
    "problem_idx": "B",
    "shortId": "403B",
    "contest_number": "403",
    "problem_submissions": {
        "E": [
            6040937,
            154984304,
            6052630,
            6052356,
            14574817,
            14574735,
            14574710,
            14574669,
            14574665,
            6040453
        ],
        "A": [
            6035160,
            6030951,
            6030860,
            6031178,
            6034007,
            6030859,
            6031215,
            6036883,
            6034828,
            6031673,
            6031177,
            6031105,
            6030857,
            6031293,
            6030993,
            6042179,
            6030867,
            6040743,
            6030907,
            6031032
        ],
        "D": [
            6032031,
            6036149,
            6037514,
            6035188,
            6038552,
            6036821,
            6037360,
            6035214,
            6032979,
            6051793,
            6039305,
            6040517,
            6037815,
            6037208,
            6040122,
            6042199,
            6036355,
            6036730,
            6039500,
            6040454
        ],
        "B": [
            6037462,
            6032575,
            6037115,
            6031670,
            6038606,
            6034965,
            6038593,
            6037275,
            6035133,
            6032908,
            6036968,
            6034116,
            6033389,
            6034279,
            6042123,
            6032620,
            6032444,
            6034225
        ],
        "C": [
            6033086,
            6035964,
            6032440,
            6032942,
            6033609,
            6032046,
            6031154,
            6035769,
            6036195,
            6034842,
            6032124,
            6038424,
            6038292,
            6035730,
            6042190,
            6033591,
            6038234,
            6037774,
            6036096
        ]
    },
    "name": "B. Upgrading Array",
    "statement": "You have an array of positive integers and a set of prime numbers . The\r\nprime numbers that do not occur in the set are considered . The of array\r\nis the sum , where function is determined as follows: ; Let’s assume\r\nthat is the minimum prime divisor of . If is a good prime, then ,\r\notherwise . You are allowed to perform an arbitrary (probably zero)\r\nnumber of operations to improve array . The is the following sequence of\r\nactions: Choose some number () and calculate the value = GCD(). Apply\r\nthe assignments: , , , . What is the maximum beauty of the array you can\r\nget?\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\ninline int gcd(int a, int b) {\n\tfor (; b; swap(a, b)) a %= b;\n\treturn a;\n}\nint a, b, c, d, n, m, k;\nint mas[5002];\nint pr[32000];\n\nint dp[5002], cg[5002];\nint cntg[5002], cntb[5002];\nset<int> bad;\npii calc(int t) {\n\tint cb = 0, cg = 0;\n\tfor (int j = 0; j < k && pr[j] * pr[j] <= t; ++j) {\n\t\tif (t % pr[j]) continue;\n\t\tbool good = !bad.count(pr[j]);\n\t\twhile (t % pr[j] == 0) {\n\t\t\tif (!good) ++cb; else\n\t\t\t\t++cg;\n\t\t\tt /= pr[j];\n\t\t}\n\t}\n\tif (t > 1) {\n\t\tif (bad.count(t)) ++cb; else\n\t\t\t++cg;\n\t}\n\treturn mp(cg, cb);\n}\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\trept(i, n) scanf(\"%d\", &mas[i]);\n\trept(i, m) {\n\t\tscanf(\"%d\", &a);\n\t\tbad.insert(a);\n\t}\n\n\tfor (int i = 2; i * i <= INF; ++i) {\n\t\tbool ok = 1;\n\t\tfor (int j = 2; j * j <= i; ++j) {\n\t\t\tif (i % j == 0) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) pr[k++] = i;\n\t}\n\n\tcg[0] = mas[0];\n\trep(i, n - 1) {\n\t\tcg[i] = gcd(cg[i - 1], mas[i]);\n\t}\n\tcg[n] = 1;\n\n\tmemset(dp, 63, sizeof(dp));\n\tdp[n] = 0;\n\n\trept(i, n + 1) {\n\t\tpii r = calc(cg[i]);\n\t\tcntg[i] = r.x;\n\t\tcntb[i] = r.y;\n\t}\n\tFORD(i, n - 1, 0) {\n\t\tdp[i] = -INF;\n\t\tFOR(j, i + 1, n) {\n\t\t\tint cur = dp[j] + (i + 1) * (cntb[i] - cntb[j]) - (i + 1) * (cntg[i] - cntg[j]);\n\t\t\tdp[i] = max(dp[i], cur);\n\t\t}\n\t}\n\n\tint ans = *max_element(dp, dp + n + 1);\n\trept(i, n) {\n\t\tpii r = calc(mas[i]);\n\t\tans += r.x;\n\t\tans -= r.y;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Upgrading Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/10972",
    "editorial": "I will describe two solutions. First. Dynamic programming approach.\r\nLetâs calculate an DP which is the best possible answer we can achieve,\r\nif current prefix has length and we used operation of Upgrading last\r\ntime in position . It is clear to understand, that we should iterate\r\nfrom to , and from to . There are only two transitions: Second. Greedy.\r\nLetâs find position , which can upgrade our answer. If there some values\r\nof we will take most right position. We will add this position to the\r\nanswer and upgrade our answer. Why itâs correct? Letâs fix an optimal\r\nsolution (sequence of position, where we used an upgrading operation) .\r\nAlso we have an solution which was built by using greedy . Itâs clear,\r\nthat , because all position with cannot upgrade anything (otherwise\r\ngreedy will choose it as first position). In other hand, , because\r\notherwise we can upgrade in position and make answer better. So, , and\r\nafter that we can use our propositions for big indexes .\r\n",
    "hint": []
}