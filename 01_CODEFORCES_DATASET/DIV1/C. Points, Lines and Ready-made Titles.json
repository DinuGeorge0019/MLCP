{
    "link": "https://codeforces.com//contest/871/problem/C",
    "problemId": "128428",
    "problem_idx": "C",
    "shortId": "871C",
    "contest_number": "871",
    "problem_submissions": {
        "D": [
            31355895,
            31362333,
            31356242,
            31355369,
            31353137,
            31356572,
            31350479,
            31349876,
            31357261,
            31360056,
            31358528,
            31351384,
            31359864,
            31356104,
            31350689,
            31354294,
            31357470
        ],
        "C": [
            31344782,
            31345046,
            31354747,
            31341122,
            31347757,
            31339514,
            31345476,
            31343571,
            31352939,
            31343640,
            31347078,
            31353076,
            31354366,
            31357931,
            31352546,
            31348044,
            31356324,
            31348388,
            31344111,
            31340976
        ],
        "B": [
            31340037,
            31339973,
            31340246,
            31344130,
            31345296,
            31350867,
            31351902,
            31348642,
            31355117,
            31356940,
            31344400,
            31347404,
            31350125,
            31355555,
            31345128,
            31496128,
            31350503
        ],
        "A": [
            31334951,
            31334542,
            31334472,
            31334988,
            31334223,
            31337899,
            42189225,
            37478044,
            37460318,
            31335310,
            31335726,
            31334028,
            31336751,
            31333319,
            31341866,
            31334833,
            31352270,
            31340759,
            31335206,
            31350845,
            31354568,
            31333534,
            31334865
        ],
        "E": [
            31356130,
            31349981,
            31355349,
            31497224
        ]
    },
    "name": "C. Points, Lines and Ready-made Titles",
    "statement": "You are given distinct points on a plane with integral coordinates. For\r\neach point you can either draw a vertical line through it, draw a\r\nhorizontal line through it, or do nothing.You consider several\r\ncoinciding straight lines as a single one. How many distinct pictures\r\nyou can get? Print the answer modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n - 1); i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << ' ';\\\n    cerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nconst int N = 1e5 + 10;\n\nvector<int> e[2 * N];\nchar used[2 * N];\nll pow2[2 * N];\n\nint vers, eds;\n\nvoid dfs(int u) {\n    if (used[u]) return;\n    used[u] = 1;\n    ++vers;\n    eds += (int)e[u].size();\n    for (int v : e[u]) dfs(v);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); \n    srand((unsigned)chrono::high_resolution_clock::now().time_since_epoch().count());\n    pow2[0] = 1;\n    forn(i, 1, 2 * N)\n        pow2[i] = 2 * pow2[i - 1] % MOD;\n    int n;\n    cin >> n;\n    vector<int> x(n), y(n);\n    forn(i, 0, n) cin >> x[i] >> y[i];\n    map<int, int> xs, ys;\n    forn(i, 0, n) xs[x[i]] = 0;\n    forn(i, 0, n) ys[y[i]] = 0;\n    int cnt = 0;\n    for (auto& p : xs)\n        p.sn = cnt++;\n    cnt = 0;\n    for (auto& p : ys)\n        p.sn = cnt++;\n    forn(i, 0, n) {\n        int u = xs[x[i]];\n        int v = ys[y[i]] + (int)xs.size();\n        e[u].eb(v);\n        e[v].eb(u);\n    }\n    int sz = (int)xs.size() + (int)y.size();\n    ll ans = 1;\n    forn(i, 0, sz) if (!used[i]) {\n        vers = 0, eds = 0;\n        dfs(i);\n        eds /= 2;\n        if (eds == vers - 1)\n            ans *= pow2[vers] - 1;\n        else\n            ans *= pow2[vers];\n        ans %= MOD;\n    }\n    cout << ans << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Points, Lines and Ready-made Titles.json",
    "editorial_link": "https://codeforces.com//blog/entry/55200",
    "editorial": "Let's build graph on points. Add edge from point to left, right, top and bottom neighbours (if such neigbour exist). Note that we can solve problem independently for each connected component and then print product of answer for components. So we can consider only connected graphs without loss of generality.\n\nLet's define X as number of different x-coords, Y as number of different y-coords.\n\nWhat if graph contains some cycle? Let's consider this cycle without immediate vertices (vertices that lie on the same line with previous and next vertices of cycle). Draw a line from each such vertex to the next vertex of cycle (and from last to the first). We got all lines that are corresponding to x-coords and y-coords of vertices of cycle. Let's prove by induction that we can got all such lines from the whole graph\n\nRun depth-first search from vertices of cycle. Let we enter in some vertex that is not from cycle. It mush have at least one visited neighbour. By induction for graph consisting of visited vertices we can get all lines. So there is line from visited neighbour. Draw line in another direction and continue depth-first search. Sooner or later we will get all lines for the whole graph. Please note that intermediate vertices of cycle will be processed correctly too.\n\nIf we can get all lines the we can get all subsets of lines. Answer for cyclic graph is 2X?+?Y.\n\nNow look at another case  Â— acyclic graph or tree. We can prove that we can get any incomplete subset of lines.\n\nLet's fix subset and some line not from this subset. Just draw this line without restriction. By similar induction as in cyclic graph case we can prove that we can get all lines (but fixed line doesn't exist really).\n\nNow let's prove that it is impossible to take all lines. For graph consisting of only one vertex it is obvious. Else fix some leaf. We must draw a line which are not directed to any neigbour because it is the only way to draw this line. But now we have tree with less number of vertices. So our statement is correct by induction.\n\nAnswer for tree is 2X?+?Y?-?1.\n\nSo the problem now is just about building graph on points and checking each component on having cycles.",
    "hint": []
}