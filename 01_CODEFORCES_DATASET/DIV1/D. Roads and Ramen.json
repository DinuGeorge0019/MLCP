{
    "link": "https://codeforces.com//contest/1434/problem/D",
    "problemId": "773401",
    "problem_idx": "D",
    "shortId": "1434D",
    "contest_number": "1434",
    "problem_submissions": {
        "E": [
            96677024,
            96703305,
            96695061,
            105543081,
            96703526,
            96698372
        ],
        "C": [
            96660091,
            96659353,
            96663643,
            96664995,
            96666231,
            96665833,
            96660295,
            96665975,
            96667697,
            96663270,
            96667899,
            96671631,
            96669472,
            96667880,
            96663509,
            96656865,
            96675583,
            96671215,
            96671994,
            96665979
        ],
        "B": [
            96653756,
            96655206,
            96656896,
            96653660,
            96657305,
            96660070,
            96656102,
            96658196,
            96659133,
            96653643,
            96661876,
            96658486,
            96660839,
            96661406,
            96658185,
            96654001,
            96679983,
            96658727,
            96658564,
            96660622
        ],
        "A": [
            96649454,
            96650673,
            96653179,
            96660619,
            96651935,
            96654803,
            96651530,
            96652454,
            96653264,
            96657461,
            96658652,
            96653143,
            96656680,
            96654396,
            96655185,
            96650897,
            96672264,
            96652811,
            96654828,
            96652745
        ],
        "D": [
            96673411,
            96677110,
            96683665,
            96678842,
            96678338,
            96679519,
            96679771,
            96683979,
            96680244,
            96683615,
            96681902,
            96685151,
            96688093,
            96669235,
            96686214,
            96686134,
            96682142
        ]
    },
    "name": "D. Roads and Ramen",
    "statement": "In the Land of Fire there are n villages and n-1 bidirectional road, and\r\nthere is a path between any pair of villages by roads. There are only\r\ntwo types of roads: stone ones and sand ones. Since the Land of Fire is\r\nconstantly renovating, every morning workers choose a single road and\r\nflip its type (so it becomes a stone road if it was a sand road and vice\r\nversa). Also everyone here loves ramen, that\u2019s why every morning a ramen\r\npavilion is set in the middle of every road, and at the end of each day\r\nall the pavilions are removed.For each of the following m days, after\r\nanother road is flipped, Naruto and Jiraiya choose a simple path that\r\nis, a route which starts in a village and ends in a (possibly, the same)\r\nvillage, and doesn\u2019t contain any road twice. Since Naruto and Jiraiya\r\nalso love ramen very much, they buy a single cup of ramen on each stone\r\nroad and one of them eats it. Since they don\u2019t want to offend each\r\nother, they only choose routes where they can eat equal number of ramen\r\ncups. Since they both like traveling, they choose any longest possible\r\npath. After every renovation find the maximal possible length of a path\r\n(that is, the number of roads in it) they can follow.\r\n",
    "solutions": [
        "/*\nAuthor: QAQAutoMaton\nLang: C++\nCode: D.cpp\nMail: [email\u00a0protected]\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\ntemplate<class T>bool sort2(T &a,T &b){return a>b?swap(a,b),1:0;}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint n;\nint u[500005],v[500005],uv[500005];\nbitset<500005>c;\nvector<int> to[500005];\nbitset<500005>w,ww;\nint dep[500005];\nint mn[21][1000005],t;\nint st[1000005];\nint dfn[500005],low[500005],d;\nint id[500005];\nvoid dfs(int x,int f){\n\tmn[0][st[x]=++t]=dep[x];\n\tww[dfn[x]=++d]=w[x];\n\tid[d]=x;\n\tfor(auto i:to[x])if(i!=f){\n\t\tif(v[i]==x)swap(u[i],v[i]);\n\t\tw[uv[i]^x]=w[x]^c[i];\n\t\tdep[uv[i]^x]=dep[x]+1;\n\t\tmn[0][++t]=dep[x];\n\t\tdfs(uv[i]^x,i);\n\t}\n\tlow[x]=d;\n}\nint lg[1000005];\nvoid init(){\n\tfor(int i=2;i<=t;++i)lg[i]=lg[i>>1]+1;\n\tfor(int i=1;(1<<i)<=t;++i)for(int j=1;j+(1<<i)-1<=t;++j)mn[i][j]=min(mn[i-1][j],mn[i-1][j+(1<<(i-1))]);\n}\nint query(int l,int r){\n\tif(l>r)swap(l,r);\n\tint h=lg[r-l+1];\n\treturn min(mn[h][l],mn[h][r-(1<<h)+1]);\n}\nint dist(int x,int y){\n\treturn dep[x]+dep[y]-(query(st[x],st[y])<<1);\n}\nstruct xmx{\n\tint s,u,v;\n\txmx(){}\n\txmx(int s,int u,int v):s(s),u(u),v(v){}\n\txmx(int u,int v):u(u),v(v){s=dist(u,v);}\n\txmx(int u):s(0),u(u),v(u){}\n\tvoid merge(int x){\n\t\tif(!~x)return;\n\t\tif(!~u){u=v=x;s=0;return;}\n\t\tint xu=u,xv=v;\n\t\tif(chkmax(s,dist(x,xu))){u=xu;v=x;}\n\t\tif(chkmax(s,dist(x,xv))){u=x;v=xv;}\n\t}\n\tvoid merge(xmx b){\n\t\tif(b.u)merge(b.u);\n\t\tif(b.v!=b.u)merge(b.v);\n\t}\n};\nxmx operator +(const xmx &a,const xmx &b){xmx c=a;c.merge(b);return c;}\nstruct smt{\n\tint ls,rs,rev;\n\txmx mx0,mx1;\n\tsmt *l,*r;\n\tsmt(){}\n\tsmt(int,int);\n\tvoid putrev(){rev^=1;swap(mx0,mx1);}\n\tvoid reverse(int la,int ra){\n\t\tif(la<=ls && rs<=ra){putrev();return;}\n\t\tif(rev){l->putrev();r->putrev();rev=0;}\n\t\tif(la<=l->rs)l->reverse(la,ra);\n\t\tif(r->ls<=ra)r->reverse(la,ra);\n\t\tmx0=l->mx0+r->mx0;\n\t\tmx1=l->mx1+r->mx1;\n\t}\n};\nsmt *rt,node[1000005],*at=node;\nsmt *newsmt(int la,int ra){\n\tsmt *rt=++at;\n\t*rt=smt(la,ra);\n\treturn rt;\n}\nsmt::smt(int la,int ra){\n\tls=la;rs=ra;\n\trev=0;\n\tif(ls==rs){if(ww[ls])mx1=id[ls],mx0=-1;else mx0=id[ls],mx1=-1;l=r=0;return;}\n\tint mid=(ls+rs)>>1;\n\tl=newsmt(ls,mid);\n\tr=newsmt(mid+1,rs);\n\tmx0=l->mx0+r->mx0;\n\tmx1=l->mx1+r->mx1;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint q;\n\tread(n);\n\tint w=0;\n\tfor(int i=1;i<n;++i){\n\t\tread(u[i],v[i],w);\n\t\tc[i]=w;\n\t\tuv[i]=u[i]^v[i];\n\t\tto[u[i]].emplace_back(i);\t\n\t\tto[v[i]].emplace_back(i);\t\n\t}\n\tdfs(1,0);\n\tinit();\n\tread(q);\n\trt=newsmt(1,n);\n\tfor(;q;--q){\n\t\tint x;\n\t\tread(x);\n\t\trt->reverse(dfn[v[x]],low[v[x]]);\n\t\twrite(max(rt->mx0.s,rt->mx1.s),'\\n');\n\t}\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Roads and Ramen.json",
    "editorial_link": "https://codeforces.com//blog/entry/84056",
    "editorial": "Let AB\n be a diameter of the tree, and the optimal answer be EF\n. Then the parity of the number of stone roads on DE\n is the same as on DF\n, and also the same holds for CE\n and CF\n. Since a diameter has the greatest length among all paths in the tree, the stone roads parity is different on AC\n and on BC\n (otherwise, the diameter would be an answer). Hence, the stone roads parity on CE\n coincides with one of AC\n and BC\n. Assume without loss of generality that the stone roads parities of AC\n and CE\n are the same. Then the path AE\n contains an even number of stone roads. Note that since AB\n is a diameter, AC\n is no shorter than CF\n, hence AD\n is no shorter than DF\n, which implies that AE\n is not shorter than EF\n. This means that there is an optimal path starting at one of the diameter's endpoints.\n\nNow remaining is to solve the problem if one of the endpoints is fixed. If we root the tree from it, and write down for each vertex the stone roads parity between it and the root, then each query is basically changing the parity of a subtree. In an euler-tour traversal every such subtree is represented by a contiguous subsegment. Now the original problem can be reformulated in a following way: we have a binary array, there are queries of type \"flip a subsegment\", and after each query we need to find a zero with the greatest depth parameter. This can be done via a segment tree, where in each node we store the deepest zero and the deepest one on the subsegment corresponding to that node. The final time complexity is O(nlogn)\n."
}