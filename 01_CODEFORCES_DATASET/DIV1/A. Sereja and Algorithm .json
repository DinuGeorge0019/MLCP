{"link": "https://codeforces.com//contest/367/problem/A", "problemId": "4096", "problem_idx": "A", "shortId": "367A", "contest_number": "367", "problem_submissions": {"A": [5253633, 5248539, 5245621, 5246967, 5245187, 5245239, 5244912, 5260352, 5248460, 5246717, 5247161, 5247626, 5250480, 5245644, 5245467, 5248078], "D": [5251109, 5249684, 5251377, 5253799, 5250841, 5254107, 5254017, 5254422, 5250750, 5253666, 5254820, 5253839, 5253605, 5254366, 5255055, 5254149], "E": [5249574, 5253117, 5253114, 5256266, 5249949, 5258981, 5256724, 5261975, 5266872, 5268278, 5260869], "B": [5248117, 5245452, 5253998, 5248352, 5248954, 5247801, 5248088, 5250697, 5246678, 5248495, 5245796, 5247335, 5247628, 5249396, 5248757, 5249320], "C": [5246223, 5247815, 5247820, 5249874, 5249775, 5249473, 5249680, 5248776, 5247935, 5249664, 5249146, 5249197, 5249315, 5250702, 5250582, 5251144]}, "name": "A. Sereja and Algorithm ", "statement": "Sereja loves all sorts of algorithms. He has recently come up with a new\r\nalgorithm, which receives a string as an input. Let\u2019s represent the\r\ninput string of the algorithm as . The algorithm consists of two steps:\r\nFind any continuous subsequence (substring) of three characters of\r\nstring , which doesn\u2019t equal to either string \"\", \"\", \"\". If doesn\u2019t\r\ncontain any such subsequence, terminate the algorithm, otherwise go to\r\nstep 2. Rearrange the letters of the found subsequence randomly and go\r\nto step 1. Sereja thinks that the algorithm works correctly on string if\r\nthere is a non-zero probability that the algorithm will be terminated.\r\nBut if the algorithm anyway will work for infinitely long on a string,\r\nthen we consider the algorithm to work incorrectly on this string.Sereja\r\nwants to test his algorithm. For that, he has string , consisting of\r\ncharacters. The boy conducts a series of tests. As the -th test, he\r\nsends substring to the algorithm input. Unfortunately, the\r\nimplementation of his algorithm works too long, so Sereja asked you to\r\nhelp. For each test determine if the algorithm works correctly on this\r\ntest or not.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nchar buf[100010];\nint cnt[3][100010];\n\nbool query(int L, int R){\n    if(R - L <= 2) return true;\n    int INF = (1<<29);\n    int small = INF, big = -INF;\n    int i;\n    REP(i,3){\n        small = min(small, cnt[i][R] - cnt[i][L]);\n        big = max(big, cnt[i][R] - cnt[i][L]);\n    }\n    return (big - small <= 1);\n}\n\nint main(void){\n    int Q,i,j,L,R;\n    \n    scanf(\"%s\", buf);\n    \n    int N = 0;\n    for(N=0;;N++) if(buf[N] == '\\0') break;\n    \n    REP(i,3){\n        char c = 'x' + i;\n        REP(j,N) cnt[i][j+1] = cnt[i][j] + ((buf[j] == c) ? 1 : 0);\n    }\n    \n    cin >> Q;\n    REP(i,Q){\n        scanf(\"%d%d\", &L, &R);\n        L--;\n        if(query(L, R)) printf(\"YES\\n\"); else printf(\"NO\\n\");\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "implementation"], "dificulty": "1500", "interactive": false}