{
    "link": "https://codeforces.com//contest/2006/problem/F",
    "problemId": "2845535",
    "problem_idx": "F",
    "shortId": "2006F",
    "contest_number": "2006",
    "problem_submissions": {
        "F": [
            278838627,
            278834885,
            278839605,
            278842896,
            283040284,
            278849665,
            279479840,
            279030892,
            278872889
        ],
        "E": [
            278816205,
            278815039,
            278825195,
            278819088,
            278823646,
            278824405,
            278834146,
            278833851,
            278836845,
            278834660,
            278831348,
            278835070,
            278824284,
            278835798,
            278834079,
            278836349,
            278834150,
            278840676,
            278837721,
            278840281
        ],
        "D": [
            278802409,
            278805803,
            278813224,
            278825476,
            278809587,
            278813203,
            278814738,
            278815896,
            278817434,
            278818422,
            278823248,
            278822269,
            278830412,
            278825693,
            278818908,
            278819966,
            278823289,
            278817077,
            278823950,
            278818832
        ],
        "C": [
            278788793,
            278798461,
            278801097,
            278797423,
            278800136,
            278800438,
            278797097,
            278802996,
            278798370,
            278802119,
            278807042,
            278803250,
            278809464,
            278800483,
            278808112,
            278808529,
            278813687,
            278799260,
            278808716,
            278807375
        ],
        "B": [
            278783201,
            278791628,
            278792112,
            278787764,
            278787151,
            278789090,
            278788997,
            278795304,
            278790397,
            278793228,
            278796651,
            278795483,
            278796854,
            278787538,
            278797112,
            278796560,
            278796305,
            278792796,
            278798821,
            278792242
        ],
        "A": [
            278774854,
            278780780,
            278783421,
            278777635,
            278777703,
            278778768,
            278777654,
            278780623,
            278781426,
            278784680,
            278779860,
            278783271,
            278779619,
            278776511,
            278786116,
            278783656,
            278783630,
            278778742,
            278777793,
            278783717
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133382",
    "editorial": "Read the hints.From the hints, you may understand that, when given the\r\ndegrees of each node, you can get the initial beauty of a matrix in . To\r\nquickly perform topological sort, you should use addition tags to\r\nmaintain the degrees of each node. Also, this is equal to sorting them\r\nby degrees.Brute-force traversal of each edge solves in . First, letâs\r\ntry to solve the problem in .For an inverted edge between column and row\r\n, we claim that the beauty is still not if and only if column and row\r\nare in adjacent layers in the initial topological sort.If they are not\r\nin adjacent layers, WLOG let the initial direction be . Since itâs a\r\nbipartite graph, we canât get , but we can definitely get . If the edge\r\nis inverted, then there exists a cycle: , which means that the beauty\r\nbecomes . Otherwise, it can also be proved that no new cycle is\r\ncreated.Since the answer is , a modification will only lead to changes\r\nin terms, and can therefore be easily calculated.Note that this is a\r\nbipartite graph. This means, if there is a cycle, then there must be a\r\ncycle of exactly vertices. If we can find the cycle of any number of\r\nvertices, we can get a cycle of vertices, and after that we can simply\r\ntry to invert only the edges and sum the answer up, otherwise the cycle\r\nstill exists. The problem is turned down to how to find a cycle.We can\r\ntry to DFS from each vertex. If a cycle is found, it will contain no\r\nmore than edges, and we can do as the proof does to reduce the number of\r\nedges (so that the size eventually becomes ).Then, letâs move on to (In\r\nfact, solutions may pass as well).Letâs assume that all the blocks are\r\nfrom being to being , and then you can calculate the answer efficiently\r\nenough. Then, brute go over the blocks and recalculate its contribution\r\nto the answer.Since the topo sorting is done halfway (some nodes are\r\nfirst extracted as previous \"layers\"), we need to flip an edge to\r\ncontinue. At the moment, however, no remaining vertices have an indegree\r\nof . Then, after a flip, there should be a vertex with an indegree of\r\n(otherwise the beauty remains and we skip it). From this point of view,\r\nif there is no vertex with an indegree of , then the beauty will always\r\nbe after one flip.If there is a node with an indegree of (assume that it\r\nis ), we can easily find a cycle of vertices containing : We find the\r\nonly node satisfying . We find a node satisfying . We find a node ,\r\nagain, satisfying . There must be since the indegree of is only . There\r\nare some other ways to find the cycle. For example, you are just going\r\nto find apattern, and after selecting a node, you can do sweepline on\r\nall the occurrences of . If you implement it well, it is also in linear\r\ntime.Time complexity: .\r\n",
    "name": "F. Dora s Paint",
    "statement": "Sadly, Dora poured the paint when painting the class mural. Dora\r\nconsiders the mural as the matrix b of size n\r\ntimes n. Initially, b_{i,j} = 0 for all 1\r\nle i, j\r\nle n.Dora has only two brushes which have two different colors. In one\r\noperation, she can paint the matrix with one of two brushes: The first\r\nbrush has color 1 on it and can paint one column of the matrix. That is,\r\nDora chooses 1\r\nleq j\r\nleq n and makes b_{i,j} := 1 for all 1\r\nleq i\r\nleq n; The second brush has color 2 on it and can paint one row of the\r\nmatrix. That is, Dora chooses 1\r\nleq i\r\nleq n and makes b_{i,j} := 2 for all 1\r\nleq j\r\nleq n. Dora paints the matrix so that the resulting matrix b 1 and 2.For\r\na matrix b, let f(b) denote the minimum number of operations needed to\r\nturn the initial matrix (containing only 0) into b. The of a matrix b is\r\nthe number of ways to paint the initial matrix in exactly f(b)\r\noperations to turn it into b. If there’s no way to turn the initial\r\nmatrix into b, the beauty of b is 0.However, Dora made a uniformly\r\nrandom mistake; there’s element different in the matrix a given to you\r\nfrom the real matrix b. That is, there is exactly one pair (i, j) such\r\nthat a_{i, j} = 3 - b_{i, j}.Please help Dora compute the expected\r\nbeauty of the real matrix b modulo 998\r\n,244\r\n,353 (all possible n^2 mistakes have equal probability).Since the size\r\nof the matrix is too large, Dora will only tell you the positions of m\r\nelements of color 1, and the remaining n^2-m elements have color 2.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 30.08.2024 09:04:14**/#include <bits/stdc++.h> using namespace std; #ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif template <typename T>T inverse(T a, T m) {  T u = 0, v = 1;  while (a != 0) {    T t = m / a;    m -= t * a; swap(a, m);    u -= t * v; swap(u, v);  }  assert(m == 1);  return u;} template <typename T>class Modular { public:  using Type = typename decay<decltype(T::value)>::type;   constexpr Modular() : value() {}  template <typename U>  Modular(const U& x) {    value = normalize(x);  }   template <typename U>  static Type normalize(const U& x) {    Type v;    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);    else v = static_cast<Type>(x % mod());    if (v < 0) v += mod();    return v;  }   const Type& operator()() const { return value; }  template <typename U>  explicit operator U() const { return static_cast<U>(value); }  constexpr static Type mod() { return T::value; }   Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }  Modular& operator++() { return *this += 1; }  Modular& operator--() { return *this -= 1; }  Modular operator++(int) { Modular result(*this); *this += 1; return result; }  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }  Modular operator-() const { return Modular(-value); }   template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));    return *this;  }  template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {    int64_t q = int64_t(static_cast<long double>(value) * rhs.value / mod());    value = normalize(value * rhs.value - q * mod());    return *this;  }  template <typename U = T>  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(value * rhs.value);    return *this;  }   Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }   friend const Type& abs(const Modular& x) { return x.value; }   template <typename U>  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);   template <typename U>  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);   template <typename V, typename U>  friend V& operator>>(V& stream, Modular<U>& number);  private:  Type value;}; template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; } template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); } template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; } template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; } template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; } template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; } template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; } template<typename T, typename U>Modular<T> power(const Modular<T>& a, const U& b) {  assert(b >= 0);  Modular<T> x = a, res = 1;  U p = b;  while (p > 0) {    if (p & 1) res *= x;    x *= x;    p >>= 1;  }  return res;} template <typename T>bool IsZero(const Modular<T>& number) {  return number() == 0;} template <typename T>string to_string(const Modular<T>& number) {  return to_string(number());} // U == std::ostream? but done this way because of fastoutputtemplate <typename U, typename T>U& operator<<(U& stream, const Modular<T>& number) {  return stream << number();} // U == std::istream? but done this way because of fastinputtemplate <typename U, typename T>U& operator>>(U& stream, Modular<T>& number) {  typename common_type<typename Modular<T>::Type, int64_t>::type x;  stream >> x;  number.value = Modular<T>::normalize(x);  return stream;} // using ModType = int; // struct VarMod { static ModType value; };// ModType VarMod::value;// ModType& md = VarMod::value;// using Mint = Modular<VarMod>; constexpr int md = 998244353;using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>; vector<Mint> fact(1, 1);vector<Mint> inv_fact(1, 1); Mint C(int n, int k) {  if (k < 0 || k > n) {    return 0;  }  while ((int) fact.size() < n + 1) {    fact.push_back(fact.back() * (int) fact.size());    inv_fact.push_back(1 / fact.back());  }  return fact[n] * inv_fact[k] * inv_fact[n - k];} void wssert(bool) {} int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int n, m;    cin >> n >> m;    C(2 * n + 10, 0);    vector<vector<int>> row_ones(n);    vector<vector<int>> col_ones(n);    vector<int> cnt_row_ones(n, 0);    vector<int> cnt_col_twos(n, n);    for (int i = 0; i < m; i++) {      int x, y;      cin >> x >> y;      --x; --y;      row_ones[x].push_back(y);      col_ones[y].push_back(x);      cnt_row_ones[x] += 1;      cnt_col_twos[y] -= 1;    }    auto backup1 = cnt_row_ones;    auto backup2 = cnt_col_twos;    auto backup3 = row_ones;    auto backup4 = col_ones;    Mint ans = 0;    auto Test = [&](auto&& self, int fx, int fy) -> void {      cnt_row_ones = backup1;      cnt_col_twos = backup2;      row_ones = backup3;      col_ones = backup4;      if (fx != -1) {        auto& v = row_ones[fx];        auto it = find(v.begin(), v.end(), fy);        if (it != v.end()) {          // 1 -> 2          v.erase(it);          col_ones[fy].erase(find(col_ones[fy].begin(), col_ones[fy].end(), fx));          cnt_row_ones[fx] -= 1;          cnt_col_twos[fy] += 1;        } else {          // 2 -> 1          row_ones[fx].push_back(fy);          col_ones[fy].push_back(fx);          cnt_row_ones[fx] += 1;          cnt_col_twos[fy] -= 1;        }      }      vector<vector<int>> row_by(n + 1);      vector<vector<int>> col_by(n + 1);      for (int i = 0; i < n; i++) {        row_by[cnt_row_ones[i]].push_back(i);        col_by[cnt_col_twos[i]].push_back(i);      }      vector<bool> row_alive(n, true);      vector<bool> col_alive(n, true);      int cnt_row_alive = n;      int cnt_col_alive = n;      vector<int> lens;      while (cnt_row_alive > 0 && cnt_col_alive > 0) {        {          auto& row_ids = row_by[n - cnt_col_alive];          if (!row_ids.empty()) {            lens.push_back(int(row_ids.size()));            for (int r : row_ids) {              wssert(row_alive[r]);              row_alive[r] = false;              cnt_row_alive -= 1;            }            row_ids.clear();            continue;          }        }        {          auto& col_ids = col_by[n - cnt_row_alive];          if (!col_ids.empty()) {            lens.push_back(int(col_ids.size()));            for (int c : col_ids) {              wssert(col_alive[c]);              col_alive[c] = false;              cnt_col_alive -= 1;            }            col_ids.clear();            continue;          }        }        if (fx != -1) {          return;        }        // flip something and call Test        vector<pair<int, int>> cells;        {          auto& row_ids = row_by[n - cnt_col_alive + 1];          if (!row_ids.empty()) {            int sz = int(row_ids.size());            vector<int> col_ids(sz);            for (int i = 0; i < sz; i++) {              col_ids[i] = -1;              for (int j : row_ones[row_ids[i]]) {                if (col_alive[j]) {                  wssert(col_ids[i] == -1);                  col_ids[i] = j;                }              }              wssert(col_ids[i] != -1);            }            if (sz == 1) {              cells.emplace_back(row_ids[0], col_ids[0]);            } else {              map<int, int> mp;              for (int i = 0; i < sz; i++) {                mp[col_ids[i]] += 1;              }              if (mp.size() == 2) {                for (int i = 0; i < sz; i++) {                  if (mp[col_ids[i]] == 1) {                    cells.emplace_back(row_ids[i], col_ids[i]);                  }                }              }            }          }        }        {          auto& col_ids = col_by[n - cnt_row_alive + 1];          if (!col_ids.empty()) {            int sz = int(col_ids.size());            int64_t sum_alive = 0;            for (int i = 0; i < n; i++) {              if (row_alive[i]) {                sum_alive += i;              }            }            vector<int> row_ids(sz);            for (int i = 0; i < sz; i++) {              int64_t sum_alive_here = 0;              for (int j : col_ones[col_ids[i]]) {                if (row_alive[j]) {                  sum_alive_here += j;                }              }              row_ids[i] = int(sum_alive - sum_alive_here);              wssert(0 <= row_ids[i] && row_ids[i] < n && row_alive[row_ids[i]]);            }            if (sz == 1) {              cells.emplace_back(row_ids[0], col_ids[0]);            } else {              map<int, int> mp;              for (int i = 0; i < sz; i++) {                mp[row_ids[i]] += 1;              }              if (mp.size() == 2) {                for (int i = 0; i < sz; i++) {                  if (mp[row_ids[i]] == 1) {                    cells.emplace_back(row_ids[i], col_ids[i]);                  }                }              }            }          }        }        sort(cells.begin(), cells.end());        cells.resize(unique(cells.begin(), cells.end()) - cells.begin());        for (auto& [x, y] : cells) {          self(self, x, y);        }        return;      }      Mint init = 1;      for (int x : lens) {        init *= fact[x];      }      if (fx == -1) {        lens.push_back(cnt_row_alive + cnt_col_alive);        for (int i = 0; i < int(lens.size()) - 1; i++) {          Mint cells = Mint(lens[i]) * lens[i + 1];          auto cur = init;          cur /= lens[i];          if (i + 1 < int(lens.size()) - 1) {            cur /= lens[i + 1];          }          if (lens[i] == 1 && i > 0) {            cur *= lens[i - 1] + 1;          }          if (lens[i + 1] == 1 && i + 2 < int(lens.size()) - 1) {            cur *= lens[i + 2] + 1;          }          ans += cur * cells;        }      } else {        ans += init;      }    };    Test(Test, -1, -1);    ans /= Mint(n) * n;    cout << ans << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "graphs",
        "implementation"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Dora s Paint.json",
    "hint": [
        "Hint1 Each column or row should be painted at most once. Suppose we paint each column and row exactly once. Then what does the number on one position tell us? Answer It tells us whether the row was painted first of the column was painted first. Try to build a graph.",
        "Hint2 We can build a directed bipartite graph. How to judge whether it is possible to paint the graph? How to calculate the beauty of one single grid? Answer Do topological sort on the graph. A cycle means it is impossible. Otherwise, the topo sort splits the graph into several layers. The beauty is the product of factorials of number of nodes in the layers (except the first layer, for we needn't do those operations).",
        "Hint3 How to solve the original problem when the initial grid has positive beauty? How to optimize? Consider adjacent layers.",
        "Hint4 How to solve the original problem when the initial grid is impossible to be painted out? Are there too many ways to flip a block?",
        "Hint5 How to optimize the process of building the graph and doing topological sort?",
        "Hint1 Try to find some way to \"sort\" the grid, for swapping different rows and different columns doesn't matter. How? Answer Sort by the number of .",
        "Hint2 How to calculate the beauty? Answer The beauty is the product of factorials of number of equal rows and equal columns.",
        "Hint3 How to solve the original problem when the initial grid has positive beauty? How to optimize?"
    ]
}