{
    "link": "https://codeforces.com//contest/800/problem/A",
    "problemId": "103095",
    "problem_idx": "A",
    "shortId": "800A",
    "contest_number": "800",
    "problem_submissions": {
        "A": [
            26437824,
            26437413,
            26424399,
            26417348,
            26417549,
            26416882,
            26417345,
            26417672,
            26417220,
            26417679,
            26421663,
            26417804,
            26418603,
            26418392,
            26418074,
            26417524,
            26460923,
            26420581,
            26435242,
            26677047,
            26429059
        ],
        "E": [
            26433415,
            26477309,
            26437062,
            26436411
        ],
        "D": [
            26430216,
            26421580,
            26427879,
            26424854,
            26429250,
            26431239,
            26427030,
            26429935,
            26430978,
            26427918,
            26431811,
            26431775,
            26432322,
            26483339,
            26483333,
            26483260,
            26429237,
            26433768,
            26460903,
            26434200,
            26431466,
            26431322,
            26427768
        ],
        "C": [
            26426299,
            26426474,
            26424315,
            26429087,
            26424916,
            26425781,
            26430517,
            26426280,
            26425889,
            26430194,
            26427437,
            26427899,
            26428225,
            26431339,
            26426820,
            26427120,
            26426356,
            26426998,
            26421900
        ],
        "B": [
            26421783,
            26423033,
            26420771,
            26420198,
            26421833,
            26421342,
            26421711,
            26421555,
            26422110,
            26423813,
            26422982,
            26422079,
            26421473,
            26421858,
            26421532,
            26422706,
            26418487,
            26420698,
            26435223,
            26435196,
            26435077
        ]
    },
    "name": "A. Voltage Keepsake",
    "statement": "You have devices that you want to use simultaneously.The -th device uses\r\nunits of power per second. This usage is continuous. That is, in\r\nseconds, the device will use units of power. The -th device currently\r\nhas units of power stored. All devices can store an arbitrary amount of\r\npower.You have a single charger that can plug to any single device. The\r\ncharger will add units of power per second to a device. This charging is\r\ncontinuous. That is, if you plug in a device for seconds, it will gain\r\nunits of power. You can switch which device is charging at any arbitrary\r\nunit of time (including real numbers), and the time it takes to switch\r\nis negligible.You are wondering, what is the maximum amount of time you\r\ncan use the devices until one of them hits units of power.If you can use\r\nthe devices indefinitely, print . Otherwise, print the maximum amount of\r\ntime before any one device hits power.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\n\nstruct Input {\n\tint n, p;\n\tint a[N], b[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n >> p)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tld ans;\n\t\n\tvoid write () {\n\t\tif (ans == -1) {\n\t\t\tputs(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\n\t\tbool check (ld x) {\n\t\t\tld sum = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tsum += max<ld>(0, a[i] * x - b[i]);\n\t\t\t}\n\t\t\treturn p * x > sum;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tll sum = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\tif (sum <= p) {\n\t\t\t\tans = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tld l = 0, r = 1e18;\n\t\t\tforn (i, 100) {\n\t\t\t\tld md = (l + r) / 2;\n\t\t\t\tif (check(md)) {\n\t\t\t\t\tl = md;\n\t\t\t\t} else {\n\t\t\t\t\tr = md;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = (l + r) / 2;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Voltage Keepsake.json",
    "editorial_link": "https://codeforces.com//blog/entry/51598",
    "editorial": "First, let's deal with the infinite case. If the supply of power is at least as big as the sum of demands, we can keep all devices alive indefinitely.\n\nOtherwise, let's binary search for the result. We can do binary search since if we can keep all devices alive for E seconds, we can keep it alive for any time less than E seconds.\n\nSince all usage/charging is continuous, we can think about it as \"splitting\" up the charge amount.\n\nFor each device and a fixed time T, we can compute the rate that we need to charge it so that the device always has positive power. Well, it uses ai power per second, so it uses a total of T?*?ai power. It currently has bi power, so we need Xi?=?max(0,?T?*?ai?-?bi) units of power. This means we need Xi?/?T units of power per second to this device.\n\nSo, we just need to check that . If so, then it is possible to keep the devices alive for T seconds, and we can use this to continue our binary search.\n\nSince we are binary searching on doubles, it is useful to just do it for a fixed number of steps. We can approximate the max answer is somewhere around 1014 and we need a precision of 10?-?4, so we need approximately  iterations.",
    "hint": []
}