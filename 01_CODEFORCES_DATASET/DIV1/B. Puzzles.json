{
    "link": "https://codeforces.com//contest/696/problem/B",
    "problemId": "65169",
    "problem_idx": "B",
    "shortId": "696B",
    "contest_number": "696",
    "problem_submissions": {
        "E": [
            20498917,
            19122817,
            19128171,
            19128416,
            19128548,
            19128551,
            19129321,
            142908498,
            19129056,
            19129065,
            19148528,
            19121431
        ],
        "A": [
            19119258,
            19112517,
            19113245,
            19130646,
            19113356,
            19114035,
            19112027,
            19112329,
            19113544,
            19115943,
            19114049,
            19111947,
            19112445,
            19112591,
            19113340,
            19112458,
            19127604,
            19113354,
            19112419,
            19122807
        ],
        "B": [
            19118714,
            19115949,
            19116617,
            19115367,
            19115254,
            19116922,
            19113777,
            19114248,
            19115893,
            19113611,
            19114745,
            19113499,
            19115275,
            19114851,
            19115798,
            19115867,
            19113047,
            19115983,
            19115146,
            19124178
        ],
        "D": [
            19117852,
            19121638,
            19123814,
            19122693,
            19131199,
            19131585,
            19120524,
            19123388,
            19122212,
            19124637,
            19122311,
            19124184,
            19125355,
            19124738,
            19124393,
            19125186,
            19123099,
            19124323,
            19124512,
            19154347
        ],
        "C": [
            19113058,
            19119301,
            19121245,
            19119819,
            19118377,
            19124627,
            19116332,
            19120250,
            19118573,
            19118620,
            19122282,
            19118411,
            19120542,
            19120806,
            19119142,
            19121243,
            19119728,
            19127751
        ],
        "F": [
            19223787,
            19134194
        ]
    },
    "name": "B. Puzzles",
    "statement": "Barney lives in country USC (United States of Charzeh). USC has cities\r\nnumbered from through and roads between them. Cities and roads of USC\r\nform a rooted tree (Barney’s not sure why it is rooted). Root of the\r\ntree is the city number . Thus if one will start his journey from city ,\r\nhe can visit any city he wants by following roads. Some girl has stolen\r\nBarney’s heart, and Barney wants to find her. He starts looking for in\r\nthe root of the tree and (since he is Barney Stinson not a random guy),\r\nhe uses a to search in the cities. A pseudo code of this algorithm is as\r\nfollows:let starting_time be an array of length ncurrent_time = 0dfs(v):\r\ncurrent_time = current_time + 1 starting_time[v] = current_time shuffle\r\nchildren[v] randomly (each permutation with equal possibility) //\r\nchildren[v] is vector of children cities of city v for u in children[v]:\r\ndfs(u)As told before, Barney will start his journey in the root of the\r\ntree (equivalent to call ).Now Barney needs to pack a backpack and so he\r\nwants to know more about his upcoming journey: for every city , Barney\r\nwants to know the expected value of . He’s a friend of Jon Snow and\r\nknows nothing, that’s why he asked for your help.\r\n",
    "solutions": [
        "#include <cstdio>\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n\nconst int N=101000;\nint n,p[N],sz[N];\ndouble dp[N];\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,2,n+1) scanf(\"%d\",p+i);\n\trep(i,1,n+1) sz[i]=1;\n\tper(i,2,n+1) sz[p[i]]+=sz[i];\n\tdp[1]=1;\n\trep(i,2,n+1) dp[i]=dp[p[i]]+0.5*(1+sz[p[i]]-sz[i]);\n\trep(i,1,n+1) printf(\"%.10f \",dp[i]);\n\tputs(\"\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "math",
        "probabilities",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Puzzles.json",
    "editorial_link": "https://codeforces.com//blog/entry/46031",
    "editorial": "First of all starting_time of a vertex is the number of dfs calls before the dfs call of this vertex plus 1. Now suppose we want to find the answer for vertex v. For any vertex u that is not in subtree of v and is not an ancestor v, denote vertices x and y such that:\n\nx???y\nx is an ancestor of v but not u\ny is an ancestor of u but not v\nx and y share the same direct parent; That is par[x]?=?par[y].\n \n\nThe probability that y occurs sooner than x in children[par[x]] after shuffling is 0.5. So the probability that starting_time[u]?<?starting_time[v] is 0.5. Also We know if u is ancestor of v this probability is 1 and if it's in subtree of v the probability is 0. That's why answer for v is equal to  (depth is 1-based and sub[v] is the number of vertices in subtree of v including v itself). Because n?-?sub[v]?-?h[v] is the number of vertices like the first u (not in subtree of v and not an ancestor of v).\n\nThus answer is always either an integer or an integer and a half.",
    "hint": []
}