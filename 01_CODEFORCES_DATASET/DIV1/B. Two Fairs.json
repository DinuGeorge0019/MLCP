{
    "link": "https://codeforces.com//contest/1276/problem/B",
    "problemId": "495589",
    "problem_idx": "B",
    "shortId": "1276B",
    "contest_number": "1276",
    "problem_submissions": {
        "D": [
            66855093,
            66857065,
            66845974,
            66997276,
            66858540,
            66861684,
            66862730,
            66868898,
            66866703,
            66862266,
            66863710,
            66863337,
            66865506,
            66863170,
            66863353,
            66867792,
            66869234,
            66868492,
            66866182,
            66863049
        ],
        "C": [
            66843940,
            66846263,
            66855304,
            66856299,
            66850349,
            66850097,
            66849241,
            66845111,
            66840733,
            66851808,
            66846583,
            66853445,
            66848190,
            66854997,
            66857353,
            66855797,
            66855510,
            66860652,
            66856100,
            66851090
        ],
        "B": [
            66838883,
            66837202,
            66851887,
            66837950,
            66845504,
            66843521,
            66841052,
            66839337,
            66846582,
            66845011,
            66837082,
            66842169,
            66845204,
            66846655,
            66853297,
            66842949,
            66842748,
            66847818,
            66847458,
            66873447,
            66868214
        ],
        "A": [
            66836393,
            66834386,
            66848931,
            66834574,
            66835090,
            66834499,
            66835628,
            66834748,
            66844259,
            66835765,
            66834448,
            66836891,
            66834649,
            66835369,
            66834624,
            66839341,
            66838551,
            66839846,
            66837852,
            66838233
        ],
        "F": [
            66875333,
            66866989,
            68039784,
            67198171,
            67466141
        ],
        "E": [
            93753835,
            67190434,
            67455260,
            81662494
        ]
    },
    "name": "B. Two Fairs",
    "statement": "There are n cities in Berland and some pairs of them are connected by\r\ntwo-way roads. It is guaranteed that you can pass from any city to any\r\nother, moving along the roads. Cities are numerated from 1 to n.Two\r\nfairs are currently taking place in Berland they are held in two\r\ndifferent cities a and b (1\r\nle a, b\r\nle n; a\r\nne b).Find the number of pairs of cities x and y (x\r\nne a, x\r\nne b, y\r\nne a, y\r\nne b) such that if you go from x to y you will have to go through both\r\nfairs (the order of visits doesn\u2019t matter). Formally, you need to find\r\nthe number of pairs of cities x,y such that any path from x to y goes\r\nthrough a and b (in any order).Print the required number of pairs. The\r\norder of two cities in a pair does not matter, that is, the pairs (x,y)\r\nand (y,x) must be taken into account only once.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\nusing namespace std;\nint w[N_], n, m, A, B, chk[N_], vis[N_], T1[N_], T2[N_];\nvector<int>E[N_];\nvoid DFS(int a) {\n\tvis[a] = 1;\n\tfor (auto &x : E[a]) {\n\t\tif (!vis[x] && !chk[x])DFS(x);\n\t}\n}\nvoid Solve() {\n\tint i, a, b;\n\tscanf(\"%d%d%d%d\", &n,&m,&A,&B);\n\tfor (i = 1; i <= n; i++) {\n\t\tE[i].clear();\n\t\tT1[i] = T2[i] = vis[i] = 0;\n\t\tchk[i] = 0;\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tchk[B] = 1;\n\tDFS(A);\n\tlong long c1 = 0, c2 = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (!vis[i] && i != B)T1[i] = 1,c1++;\n\t\tvis[i] = 0;\n\t}\n\tchk[B] = 0;\n\tchk[A] = 1;\n\tDFS(B);\n\tfor (i = 1; i <= n; i++) {\n\t\tif (!vis[i] && i != A)T2[i] = 1,c2++;\n\t}\n\tprintf(\"%lld\\n\", c1*c2);\n}\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tint TC;\n\tscanf(\"%d\", &TC);\n\twhile (TC--) {\n\t\tSolve();\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Two Fairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/72239",
    "editorial": "This problem has a simple linear solution (just two depth-first searches) without involving cut points, biconnected components, and other advanced techniques.\n\nLet's reformulate this problem in the language of graph theory: you are given an undirected graph and two vertices a\n and b\n, you need to find the number of pairs of vertices (x,y\n) such that any path from x\n to y\n contains both vertices a\n and b\n.\n\nIn other words, we are interested in pairs of vertices (x,y\n) such that deleting the vertex a\n (while going from b\n) breaks the connection from x\n to y\n and deleting the vertex b\n (while going from a\n) breaks the connection from x\n to y\n.\n\nLet's remove the vertex a\n and select the connected components in the resulting graph. Similarly, we remove the vertex b\n and select the connected components in the resulting graph. Then the pair (x,y\n) interests us if x\n and y\n belong to different components both when removing a\n and when removing b\n.\n\nThus, let's find a pair of (?u,?u)\n for each vertex u\n. It will be numbers of the connected components when a\n and b\n are removed, respectively. The pair (x,y\n) interests us if (?x,?x)?(?y,?y)\n.\n\nThe total number of vertex pairs is n?(n?1)/2\n. Let's subtract the number of uninteresting pairs from it.\n\nFirstly, these are pairs such that (?x,?x)\n and (?y,?y)\n partially equals (in exactly one component). For example, let the equality be on the first component in the common value of ?\n. Let the total number of pairs (?u,?u)\n such that ?u=?\n be equal to c\n, then subtract c?(c?1)/2\n from the current answer. We will do this with all ?\n and ?\n.\n\nNote that some uninteresting pairs were counted twice. These are pairs of vertices such that (?x,?x)\n and (?y,?y)\n equals in both components. We can count the number of corresponding vertices c\n and add c?(c?1)/2\n to the current answer for each pair.\n\nIn the following code, let p\n be an array of pairs of component numbers for all vertices except a\n and b\n. Each pair is the number of the connected component of this vertex if a\n is removed, and the number of the connected component of this vertex if b\n is removed. Then the main part of the solution can be like this:"
}