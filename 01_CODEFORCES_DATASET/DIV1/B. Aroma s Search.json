{
    "link": "https://codeforces.com//contest/1292/problem/B",
    "problemId": "519777",
    "problem_idx": "B",
    "shortId": "1292B",
    "contest_number": "1292",
    "problem_submissions": {
        "F": [
            69140685,
            69148403,
            71814085,
            71814062,
            71813990,
            70217605,
            69197847,
            69495748,
            71223361
        ],
        "D": [
            69122533,
            69114171,
            69256713,
            69123417,
            69126885,
            69163995,
            69128025,
            69127012,
            69131460,
            69130080,
            69130342,
            69128215,
            69129378,
            69133922,
            69131233,
            69132965,
            69132809,
            69134434,
            69132903,
            69127292,
            69140744,
            69136786
        ],
        "C": [
            69113617,
            69117304,
            69112958,
            69113829,
            69164607,
            69112261,
            69111227,
            69113942,
            69113564,
            69116428,
            69114170,
            69121126,
            69118602,
            69121886,
            69119931,
            69117602,
            69119253,
            69121231,
            69130721,
            69112217,
            69119945
        ],
        "B": [
            69102431,
            69100917,
            69105559,
            69104060,
            69164579,
            69104349,
            69103131,
            69105348,
            69102973,
            69106424,
            69106338,
            69108218,
            69106515,
            69110303,
            69110995,
            69110488,
            69109887,
            69114588,
            69102534,
            69105217,
            69108444
        ],
        "A": [
            69100122,
            69100064,
            69101788,
            69100300,
            69164572,
            69100144,
            69100129,
            69100151,
            69100251,
            69100494,
            69100278,
            69100280,
            69100245,
            69101280,
            69102544,
            69101036,
            69101104,
            69100156,
            69100106,
            69100348,
            69100678
        ],
        "E": [
            69145246,
            69152430,
            69165289,
            69151098,
            69168995,
            69165203,
            69152318,
            69162582,
            69185344
        ]
    },
    "name": "B. Aroma s Search",
    "statement": "With a new body, our idol Aroma White (or should we call her Kaori\r\nMinamiya?) begins to uncover her lost past through the OS space.The\r\nspace can be considered a 2D plane, with an infinite number of data\r\nnodes, indexed from 0, with their coordinates defined as follows: The\r\ncoordinates of the 0-th node is (x_0, y_0) For i > 0, the coordinates of\r\ni-th node is (a_x\r\ncdot x_{i-1} + b_x, a_y\r\ncdot y_{i-1} + b_y) Initially Aroma stands at the point (x_s, y_s). She\r\ncan stay in OS space for at most t seconds, because after this time she\r\nhas to warp back to the real world. She need to return to the entry\r\npoint (x_s, y_s) to warp home.While within the OS space, Aroma can do\r\nthe following actions: From the point (x, y), Aroma can move to one of\r\nthe following points: (x-1, y), (x+1, y), (x, y-1) or (x, y+1). This\r\naction requires 1 second. If there is a data node at where Aroma is\r\nstaying, she can collect it. We can assume this action costs 0 seconds.\r\nOf course, each data node can be collected at most once. Aroma wants to\r\ncollect as many data as possible before warping back. Can you help her\r\nin calculating the maximum number of data nodes she could collect within\r\nt seconds?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100;\nconst ll INF = (ll)3e16;\nll a[N][2];\nint n;\n\nvoid read() {\n\tscanf(\"%lld%lld\", &a[0][0], &a[0][1]);\n\tll ax, ay, bx, by;\n\tscanf(\"%lld%lld%lld%lld\", &ax, &ay, &bx, &by);\n\tn = 0;\n\twhile(a[n][0] < INF && a[n][1] < INF) {\n\t\tn++;\n\t\ta[n][0] = ax * a[n - 1][0] + bx;\n\t\ta[n][1] = ay * a[n - 1][1] + by;\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tread();\n\tll x, y, t;\n\tscanf(\"%lld%lld%lld\", &x, &y, &t);\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (abs(x - a[i][0]) + abs(y - a[i][1]) + abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1]) <= t)\n\t\t\t\tans = max(ans, abs(i - j) + 1);\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "geometry",
        "greedy",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Aroma s Search.json",
    "editorial_link": "https://codeforces.com//blog/entry/73051",
    "editorial": "First, keep a list of \"important\" nodes (nodes that are reachable from\r\nthe starting point with seconds), and denote this list . Since , there\r\nare no more than important nodes (in other words, . In an optimal route,\r\nwe must first reach a data node in fastest time possible. Suppose that\r\nwe reach node first, and we now have seconds left.Letâs denote the time\r\nrequired to travel from the -th node to the -th node. is also the\r\nManhattan distance between the -th and the -th node in other words, .\r\nSince and , we have for all . Therefore, if we consider all the nodes to\r\nstay in a line in such a way that , the problem is reduced to the\r\nfollowing problem:To solve the above problem, one should notice that it\r\nis optimal to collect nodes in a continuous segment. Suppose that we\r\ncollect all nodes from the -th to -th (for some ). An optimal route is\r\none of the two below: Go from to and then go to . The time required for\r\nthis route is . Go from to and then go to . The time required for this\r\nroute is . Therefore, the minimum amount of energy required to collect\r\nall the nodes from -th to -th is .Since is small, one can brute-force\r\nthrough all triple of such that and check if seconds are enough to go to\r\n-th node and then collect all the nodes from -th to -th or not.The time\r\ncomplexity for that approach is .However, we can notice that itâs always\r\nthe most optimal to choose as either or , for a few reasons: As the\r\naforementioned formula, either or will be counted twice (one there, and\r\none within , so having it reduced to nullifies the exceeded step. The\r\ndistance from to does not break the minimal properties of the\r\nendpoint(s) regardless of âs position. We can prove it by considering\r\nall possible relative positions of over the segment (weâll consider the\r\n-coordinates only, -coordinates will have the same properties, without\r\nloss of generality): If , the distance is minimal at . If , the distance\r\nis minimal at . If , the travelling time in -coordinates is . One can\r\nsee that , therefore any (including the endpoints, of course) is equally\r\noptimal. Proof for the above formula is trivial. The optimal solutionâs\r\ntime complexity is .\r\n",
    "hint": []
}