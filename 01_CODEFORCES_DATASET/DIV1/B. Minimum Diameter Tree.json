{"link": "https://codeforces.com//contest/1086/problem/B", "problemId": "273652", "problem_idx": "B", "shortId": "1086B", "contest_number": "1086", "problem_submissions": {"F": [47429292, 47449995, 47444202], "E": [47422474, 47423961, 47424550, 47426933, 47428109, 47426232, 47427511, 47426695, 47427218, 47427849, 47427630, 47511510, 47428346, 47425158, 47429712, 47428661, 47421857, 47429322, 47440462, 63950917], "D": [47415205, 47413571, 47418835, 47417078, 47414191, 47418078, 47418526, 47419686, 47418954, 47419229, 47421725, 47466322, 47418774, 47416004, 47420225, 47422460, 47411471, 47420807, 47421473, 47423600, 47420881], "C": [47410346, 47408923, 47412203, 47411518, 47409578, 47407257, 47412943, 47414708, 47412730, 47413883, 47416006, 47414439, 47428921, 47417547, 47419740, 47412059, 47415581, 47415787], "B": [47402010, 47400574, 47400073, 47401453, 47402762, 47411548, 47405929, 47406096, 47405616, 47407353, 47404186, 47400750, 47404258, 47404681, 47402882, 47426003, 47408582, 47404099, 47404538, 47406586], "A": [47400483, 47400094, 47413170, 47400357, 47400599, 47410258, 47403179, 47403378, 47401193, 47402951, 47401486, 47403915, 47400561, 47403260, 47400323, 47425175, 47409292, 47400702, 47401450, 47402988]}, "name": "B. Minimum Diameter Tree", "statement": "You are given a tree (an undirected connected graph without cycles) and\r\nan integer s.Vanya wants to put weights on all edges of the tree so that\r\nall weights are non-negative real numbers and their sum is s. At the\r\nsame time, he wants to make the diameter of the tree as small as\r\npossible.Let\u2019s define the diameter of a weighed tree as the maximum sum\r\nof the weights of the edges lying on the path between two some vertices\r\nof the tree. In other words, the diameter of a weighed tree is the\r\nlength of the longest simple path in the tree, where length of a path is\r\nequal to the sum of weights over all edges in the path.Find the minimum\r\npossible diameter that Vanya can get.\r\n", "solutions": ["#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, S;\n  cin >> N >> S;\n\n  vector<int> degs(N + 1);\n  for (int i = 0; i < N - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    ++degs[u];\n    ++degs[v];\n  }\n\n  const int leaves = count(ALL(degs), 1);\n\n  cout << (LD)2 * S / leaves << \"\\n\";\n}\n\n"], "input": "", "output": "", "tags": ["greedy", "implementation", "trees"], "dificulty": "1700", "interactive": false}