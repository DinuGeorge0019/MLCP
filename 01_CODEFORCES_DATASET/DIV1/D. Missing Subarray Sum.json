{
    "link": "https://codeforces.com//contest/1965/problem/D",
    "problemId": "2614998",
    "problem_idx": "D",
    "shortId": "1965D",
    "contest_number": "1965",
    "problem_submissions": {
        "F": [
            258465624,
            258627065,
            263837667,
            258481689
        ],
        "D": [
            258447727,
            258460812,
            258466117,
            258450218,
            258464835,
            258457510,
            258458513,
            258465971,
            259573719,
            258506961,
            258454027,
            258456282,
            258483429,
            258453210,
            258453791
        ],
        "C": [
            258425895,
            258434352,
            258433902,
            258442030,
            258433331,
            258429762,
            258434494,
            258427059,
            258424566,
            258435014,
            258430069,
            258434394,
            258430905,
            258434841,
            258457386,
            258428580,
            258429520,
            258434274
        ],
        "B": [
            258420424,
            258428605,
            258430303,
            258433453,
            258426877,
            258424079,
            258428403,
            258433720,
            259639909,
            258437552,
            258428917,
            258424298,
            258428062,
            258424086,
            258427169,
            258427222,
            258425398,
            258424422,
            258426595
        ],
        "A": [
            258418141,
            258418841,
            258425010,
            258419725,
            258419999,
            258418044,
            258419071,
            258418897,
            258418989,
            258419441,
            258418664,
            258419165,
            258419761,
            258418751,
            258419361,
            258418280,
            258427816,
            258420207
        ],
        "E": [
            258446500,
            258464809,
            258455602,
            258503208,
            258466942,
            258468402,
            258463371,
            258447373,
            258452406,
            258457290,
            258460561,
            258509487,
            258461569,
            302317911,
            258464177,
            258450702,
            258478527
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128914",
    "editorial": "Letâs first look at the set of subarray sums of a palindromic array of\r\npositive integers. Because is a palindrome, the sum of the subarray with\r\nindices in the range is the same as the sum of the subarray with indices\r\nin the range . So if we ignore all subarrays where (subarrays centered\r\nat the center of ), each sum must appear an even number of times.Also,\r\nevery \"centered\" subarray must have a unique sum. This is because all\r\nelements of are strictly positive, and if the \"centered\" subarrays are\r\nordered by length, each one contains all elements in the previous one,\r\nalong with two new elements, so its sum must be strictly\r\ngreater.Therefore, the set of subarray sums that appear an odd number of\r\ntimes is exactly the set of sums of subarrays centered at the center of\r\n. For example, in the array , the sums that appear an odd number of\r\ntimes are: (, , ) () () Note that they can appear more than once.So if\r\nwe have all subarray sums of , we can then use the \"centered\" sums to\r\nreconstruct itself. The smallest \"centered\" sum is either the middle\r\nelement or the sum of the middle two (equal) elements, depending on the\r\nparity of , and for each \"centered\" sum in ascending order after that,\r\nits difference with the previous sum must be the sum of the next two\r\n(equal) elements closest to the center of .Now, letâs find out how to\r\nreconstruct the missing sum. We consider two cases: If the missing sum\r\nis for a \"centered\" subarray, then there will be exactly sums that\r\nappear an odd number of times in the input. We can use these sums to\r\nconstruct a palindromic array of size as described above.We can then\r\nremove all sums of subarrays of from the initial input list, and look at\r\nwhat is remaining. If we let be the indices of the missing subarray, the\r\nlargest remaining sum in the list must be the sum of in (or equivalently\r\n). Let this sum be and the sum of be .If (and therefore ), the missing\r\nsum must be , because the part includes everything in the missing\r\nsubarray twice, and everything else once, and includes everything once.\r\n, initially seems like it will be an edge case, but the same equation\r\nworks there as well, since includes everything in the missing array (all\r\nof ) once, and everything in once, and includes everything in once. If\r\nthe missing sum is not for a \"centered\" subarray, then there will be\r\nexactly sums that appear an odd number of times in the input. We can use\r\nthese sums to construct a palindromic array of size as described\r\nabove.In a similar way to the previous case, we can then remove all sums\r\nfrom the initial input list from the set of subset sums of . If we let\r\nbe the indices of the extra \"centered\" subarray in , the largest\r\nremaining sum in the list must be the sum of in (or equivalently ). If\r\nwe let be this largest sum, and be the sum of , we can use similar logic\r\nto the previous case to determine that the missing sum is .So we can\r\ndetermine the missing sum, using the number of sums that appear an odd\r\nnumber of times in the input to determine which case we are in. Once we\r\nhave found the missing sum, we just need to reconstruct using the\r\nprocess above. Also, notice that by the construction we have followed so\r\nfar, the solution is always unique.Complexity:\r\n",
    "name": "D. Missing Subarray Sum",
    "statement": "There is a hidden array a of n positive integers. You know that a is a ,\r\nor in other words, for all 1\r\nle i\r\nle n, a_i = a_{n + 1 - i}. You are given the sums of all but one of its\r\ndistinct subarrays, in arbitrary order. The subarray whose sum is not\r\ngiven can be any of the\r\nfrac{n(n+1)}{2} distinct subarrays of a.Recover any possible palindrome\r\na. The input is chosen such that there is always at least one array a\r\nthat satisfies the conditions.An array b is a subarray of a if b can be\r\nobtained from a by the deletion of several (possibly, zero or all)\r\nelements from the beginning and several (possibly, zero or all) elements\r\nfrom the end.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;template<class T>constexpr T power(T a, i64 b) {    T res {1};    for (; b; b /= 2, a *= a) {        if (b % 2) {            res *= a;        }    }    return res;} constexpr i64 mul(i64 a, i64 b, i64 p) {    i64 res = a * b - i64(1.L * a * b / p) * p;    res %= p;    if (res < 0) {        res += p;    }    return res;} template<i64 P>struct MInt {    i64 x;    constexpr MInt() : x {0} {}    constexpr MInt(i64 x) : x {norm(x % getMod())} {}        static i64 Mod;    constexpr static i64 getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(i64 Mod_) {        Mod = Mod_;    }    constexpr i64 norm(i64 x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr i64 val() const {        return x;    }    constexpr MInt operator-() const {        MInt res;        res.x = norm(getMod() - x);        return res;    }    constexpr MInt inv() const {        return power(*this, getMod() - 2);    }    constexpr MInt &operator*=(MInt rhs) & {        if (getMod() < (1ULL << 31)) {            x = x * rhs.x % int(getMod());        } else {            x = mul(x, rhs.x, getMod());        }        return *this;    }    constexpr MInt &operator+=(MInt rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MInt &operator-=(MInt rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MInt &operator/=(MInt rhs) & {        return *this *= rhs.inv();    }    friend constexpr MInt operator*(MInt lhs, MInt rhs) {        MInt res = lhs;        res *= rhs;        return res;    }    friend constexpr MInt operator+(MInt lhs, MInt rhs) {        MInt res = lhs;        res += rhs;        return res;    }    friend constexpr MInt operator-(MInt lhs, MInt rhs) {        MInt res = lhs;        res -= rhs;        return res;    }    friend constexpr MInt operator/(MInt lhs, MInt rhs) {        MInt res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {        i64 v;        is >> v;        a = MInt(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {        return os << a.val();    }    friend constexpr bool operator==(MInt lhs, MInt rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MInt lhs, MInt rhs) {        return lhs.val() != rhs.val();    }    friend constexpr bool operator<(MInt lhs, MInt rhs) {        return lhs.val() < rhs.val();    }}; template<>i64 MInt<0>::Mod = 998244353; constexpr i64 P = i64(1E18) + 9;using Z = MInt<P>;constexpr Z B = 125796162171LL; void solve() {    int n;    std::cin >> n;        std::vector<int> s(n * (n + 1) / 2 - 1);        Z sum = 0;    i64 tot = 0;    for (auto &x : s) {        std::cin >> x;        sum += power(B, x);        tot += x;    }        std::vector<int> ans;    int need = ((n + 1) / 2);    std::sort(s.begin(), s.end());    std::vector<int> odd;    for (int i = 0, j = 0; i < s.size(); i = j) {        while (j < s.size() && s[i] == s[j]) {            j++;        }        if ((j - i) % 2 == 1) {            odd.push_back(s[i]);        }    }        auto check = [&](const std::vector<int> &a, int missing) {        Z res = 0;        Z suf = 0;        for (auto x : a) {            suf = (suf + 1) * power(B, x);            res += suf;        }        if (res == sum + power(B, missing)) {            ans = a;        }    };        std::sort(odd.begin(), odd.end());    std::vector<int> a;    a.reserve(n);    if (odd.size() < need) {        std::reverse(odd.begin(), odd.end());        for (int i = 0; i <= odd.size(); i++) {            if (n % 2 == 1 && i == odd.size()) {                continue;            }            i64 sum = 0;            for (int j = 0; j < odd.size(); j++) {                int k = j + (j >= i);                sum += 1LL * (k + 1) * (n - k) * odd[j];                if (k > 0) {                    sum -= 1LL * k * (n - k + 1) * odd[j];                }            }            int coef = (i + 1) * (n - i);            if (i > 0) {                coef -= i * (n - i + 1);            }            assert(coef > 1);            int missing = (tot - sum) / (coef - 1);            if (i > 0 && missing > odd[i - 1]) {                continue;            }            if (i < odd.size() && missing < odd[i]) {                continue;            }            a.clear();            int lst = 0;            for (int j = 0; j < odd.size() + 1; j++) {                int k = odd.size() - j;                int v;                if (i == k) {                    v = missing;                } else {                    v = odd[k - (k > i)];                }                if (lst == 0) {                    a.push_back(n % 2 == 1 ? v : v / 2);                } else {                    a.push_back((v - lst) / 2);                }                lst = v;            }            std::reverse(a.begin(), a.end());            for (int i = a.size(); i < n; i++) {                a.push_back(a[n - 1 - i]);            }            check(a, missing);        }        if (ans.empty()) {            std::multiset mset(s.begin(), s.end());            a.clear();            for (int i = 1; i < odd.size(); i++) {                a.push_back((odd[i - 1] - odd[i]) / 2);            }            for (int i = 0; i < a.size(); i++) {                int s = 0;                for (int j = i; j < a.size(); j++) {                    s += a[j];                    mset.extract(s);                    mset.extract(s);                }            }            int v = *mset.begin();            a.push_back(v);            a.push_back(odd.back() - 2 * v);            for (int i = a.size(); i < n; i++) {                a.push_back(a[n - 1 - i]);            }            check(a, a[(n - 1) / 2]);        }    } else {        for (int i = 0; i < odd.size(); i++) {            int lst = 0;            a.clear();            for (int j = 0; j < odd.size(); j++) {                if (i == j) {                    continue;                }                if (lst == 0) {                    a.push_back(n % 2 == 1 ? odd[j] : odd[j] / 2);                } else {                    a.push_back((odd[j] - lst) / 2);                }                lst = odd[j];            }            std::reverse(a.begin(), a.end());            for (int i = a.size(); i < n; i++) {                a.push_back(a[n - 1 - i]);            }            check(a, odd[i]);        }    }    assert(!ans.empty());    for (int i = 0; i < ans.size(); i++) {        std::cout << ans[i] << \" \\n\"[i == ans.size() - 1];    }} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Missing Subarray Sum.json",
    "hint": []
}