{"link": "https://codeforces.com//contest/1753/problem/E", "problemId": "1601080", "problem_idx": "E", "shortId": "1753E", "contest_number": "1753", "problem_submissions": {"F": [177651080, 177647555, 177657470, 188911747, 188911656, 188911570, 188911428, 188910549, 188910073, 188909646, 188909166, 188907827, 188904326, 188904190, 188903731, 177833531, 177833492], "E": [177581778, 177583727, 177589838, 177589285, 177593827, 177594409, 177597830, 177594087, 177592707, 177585112, 177601527, 177590220, 177673253, 177974155, 177974124, 177973591, 177724036], "D": [177563465, 177565205, 177564757, 177573155, 177575242, 177580076, 177576436, 177570973, 177566523, 177596897, 177580588, 177604329, 177563352, 177570046, 177566269, 177573602, 177755461, 177576614, 177574911], "C": [177552151, 177550933, 177551820, 177553154, 177551866, 177564888, 177563099, 177563169, 177574479, 177556455, 177565810, 177544648, 177550098, 177548226, 177548338, 177556464, 177755441, 177552144, 177557310], "B": [177547853, 177542169, 177543741, 177547659, 177545799, 177543102, 177548449, 177558513, 177542410, 177547120, 177556897, 177532887, 177540969, 177543956, 177543358, 177547075, 177755409, 177545453, 177551061], "A2": [177545216, 177538464, 177539211, 177543167, 177542984, 177539535, 177544288, 177553832, 177538606, 177548841, 177551155, 177550293, 177537648, 177536071, 177539594, 177543961, 177755345, 177539530, 177545423], "A1": [177533578, 177538639, 177539788, 177537288, 177537340, 177539306, 177543813, 177553991, 177538938, 177533253, 177550897, 177550032, 177537887, 177533119, 177533588, 177544324, 177755312, 177540035, 177546684]}, "name": "E. N Machines", "statement": "You have been invited as a production process optimization specialist to\r\nsome very large company. The company has n machines at its factory,\r\nstanding one behind another in the production chain. Each machine can be\r\ndescribed in one of the following two ways: (+,\u00a0a_i) or (*,\u00a0a_i).If a\r\nworkpiece with the value x is supplied to the machine of kind (+,\u00a0a_i),\r\nthen the output workpiece has value x + a_i.If a workpiece with the\r\nvalue x is supplied to the machine of kind (*,\u00a0a_i), then the output\r\nworkpiece has value x\r\ncdot a_i.The whole production process is as follows. The workpiece with\r\nthe value 1 is supplied to the first machine, then the workpiece\r\nobtained after the operation of the first machine is supplied to the\r\nsecond machine, then the workpiece obtained after the operation of the\r\nsecond machine is supplied to the third machine, and so on. The company\r\nis not doing very well, so now the value of the resulting product does\r\nnot exceed 2\r\ncdot 10^9.The directors of the company are not satisfied with the\r\nefficiency of the production process and have given you a budget of b\r\ncoins to optimize it.To optimize production you can change the order of\r\nmachines in the chain. Namely, by spending p coins, you can take any\r\nmachine of kind (+,\u00a0a_i) and move it to any place in the chain without\r\nchanging the order of other machines. Also, by spending m coins, you can\r\ntake any machine of kind (*,\u00a0a_i) and move it to any place in the\r\nchain.What is the maximum value of the resulting product that can be\r\nachieved if the total cost of movements that are made should not exceed\r\nb coins?\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 inf = 4E18;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, b, p, m;\n    std::cin >> n >> b >> p >> m;\n    \n    std::vector<int> x;\n    int total = 0;\n    \n    std::vector<std::vector<int>> a;\n    std::vector<int> mul;\n    for (int i = 0; i < n; i++) {\n        char t;\n        int y;\n        std::cin >> t >> y;\n        \n        if (t == '+') {\n            x.push_back(y);\n            total++;\n        } else if (y > 1) {\n            a.push_back(std::move(x));\n            mul.push_back(y);\n        }\n    }\n    \n    a.push_back(std::move(x));\n    \n    int cntm = mul.size();\n    \n    for (int i = 0; i <= cntm; i++) {\n        std::sort(a[i].begin(), a[i].end());\n    }\n    \n    std::vector<std::vector<i64>> suf(cntm + 1);\n    for (int i = 0; i <= cntm; i++) {\n        suf[i].resize(a[i].size() + 1);\n        for (int j = int(a[i].size()) - 1; j >= 0; j--) {\n            suf[i][j] = suf[i][j + 1] + a[i][j];\n        }\n    }\n    \n    i64 ans = 0;\n    \n    std::map<int, std::vector<int>> mpos;\n    for (int i = 0; i < cntm; i++) {\n        mpos[mul[i]].push_back(i);\n    }\n    \n    std::vector<bool> move(cntm);\n    auto dfs = [&](auto self, auto it) {\n        if (it == mpos.end()) {\n            std::vector<i64> val(cntm + 1, 1);\n            i64 cost = 0;\n            for (int i = 0; i < cntm; i++) {\n                if (move[i]) {\n                    val[cntm] *= mul[i];\n                    cost += m;\n                } else {\n                    val[i] *= mul[i];\n                }\n            }\n            for (int i = cntm - 1; i >= 0; i--) {\n                val[i] *= val[i + 1];\n            }\n            if (cost > b) {\n                return;\n            }\n            const int rest = std::min((b - cost) / p, 1LL * total);\n            i64 cur = val[0];\n            for (int i = 0; i <= cntm; i++) {\n                cur += val[i] * suf[i][0];\n            }\n            \n            auto get = [&](auto x) {\n                int cnt = 0;\n                i64 sum = 0;\n                for (int i = 0; i <= cntm; i++) {\n                    if (val[i] == val[0]) {\n                        continue;\n                    }\n                    i64 y = x / (val[0] - val[i]);\n                    auto it = std::upper_bound(a[i].begin(), a[i].end(), y);\n                    int k = it - a[i].begin();\n                    cnt += a[i].size() - k;\n                    sum += suf[i][k] * (val[0] - val[i]);\n                }\n                return std::pair(cnt, sum);\n            };\n            \n            i64 lo = 0, hi = inf;\n            while (lo < hi) {\n                i64 x = (lo + hi) / 2;\n                if (get(x).first > rest) {\n                    lo = x + 1;\n                } else {\n                    hi = x;\n                }\n            }\n            auto [c, s] = get(lo);\n            cur += s + 1LL * (rest - c) * lo;\n            ans = std::max(ans, cur);\n            return;\n        }\n        self(self, std::next(it));\n        for (int i = 0; i < int(it->second.size()); i++) {\n            move[it->second[i]] = true;\n            self(self, std::next(it));\n        }\n        for (auto i : it->second) {\n            move[i] = false;\n        }\n    };\n    dfs(dfs, mpos.begin());\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "greedy"], "dificulty": "3300", "interactive": false}