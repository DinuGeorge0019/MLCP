{
    "link": "https://codeforces.com//contest/1753/problem/E",
    "problemId": "1601080",
    "problem_idx": "E",
    "shortId": "1753E",
    "contest_number": "1753",
    "problem_submissions": {
        "F": [
            177651080,
            177647555,
            177657470,
            188911747,
            188911656,
            188911570,
            188911428,
            188910549,
            188910073,
            188909646,
            188909166,
            188907827,
            188904326,
            188904190,
            188903731,
            177833531,
            177833492
        ],
        "E": [
            177581778,
            177583727,
            177589838,
            177589285,
            177593827,
            177594409,
            177597830,
            177594087,
            177592707,
            177585112,
            177601527,
            177590220,
            177673253,
            177974155,
            177974124,
            177973591,
            177724036
        ],
        "D": [
            177563465,
            177565205,
            177564757,
            177573155,
            177575242,
            177580076,
            177576436,
            177570973,
            177566523,
            177596897,
            177580588,
            177604329,
            177563352,
            177570046,
            177566269,
            177573602,
            177755461,
            177576614,
            177574911
        ],
        "C": [
            177552151,
            177550933,
            177551820,
            177553154,
            177551866,
            177564888,
            177563099,
            177563169,
            177574479,
            177556455,
            177565810,
            177544648,
            177550098,
            177548226,
            177548338,
            177556464,
            177755441,
            177552144,
            177557310
        ],
        "B": [
            177547853,
            177542169,
            177543741,
            177547659,
            177545799,
            177543102,
            177548449,
            177558513,
            177542410,
            177547120,
            177556897,
            177532887,
            177540969,
            177543956,
            177543358,
            177547075,
            177755409,
            177545453,
            177551061
        ],
        "A2": [
            177545216,
            177538464,
            177539211,
            177543167,
            177542984,
            177539535,
            177544288,
            177553832,
            177538606,
            177548841,
            177551155,
            177550293,
            177537648,
            177536071,
            177539594,
            177543961,
            177755345,
            177539530,
            177545423
        ],
        "A1": [
            177533578,
            177538639,
            177539788,
            177537288,
            177537340,
            177539306,
            177543813,
            177553991,
            177538938,
            177533253,
            177550897,
            177550032,
            177537887,
            177533119,
            177533588,
            177544324,
            177755312,
            177540035,
            177546684
        ]
    },
    "name": "E. N Machines",
    "statement": "You have been invited as a production process optimization specialist to\r\nsome very large company. The company has n machines at its factory,\r\nstanding one behind another in the production chain. Each machine can be\r\ndescribed in one of the following two ways: (+, a_i) or (*, a_i).If a\r\nworkpiece with the value x is supplied to the machine of kind (+, a_i),\r\nthen the output workpiece has value x + a_i.If a workpiece with the\r\nvalue x is supplied to the machine of kind (*, a_i), then the output\r\nworkpiece has value x\r\ncdot a_i.The whole production process is as follows. The workpiece with\r\nthe value 1 is supplied to the first machine, then the workpiece\r\nobtained after the operation of the first machine is supplied to the\r\nsecond machine, then the workpiece obtained after the operation of the\r\nsecond machine is supplied to the third machine, and so on. The company\r\nis not doing very well, so now the value of the resulting product does\r\nnot exceed 2\r\ncdot 10^9.The directors of the company are not satisfied with the\r\nefficiency of the production process and have given you a budget of b\r\ncoins to optimize it.To optimize production you can change the order of\r\nmachines in the chain. Namely, by spending p coins, you can take any\r\nmachine of kind (+, a_i) and move it to any place in the chain without\r\nchanging the order of other machines. Also, by spending m coins, you can\r\ntake any machine of kind (*, a_i) and move it to any place in the\r\nchain.What is the maximum value of the resulting product that can be\r\nachieved if the total cost of movements that are made should not exceed\r\nb coins?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 inf = 4E18;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, b, p, m;\n    std::cin >> n >> b >> p >> m;\n    \n    std::vector<int> x;\n    int total = 0;\n    \n    std::vector<std::vector<int>> a;\n    std::vector<int> mul;\n    for (int i = 0; i < n; i++) {\n        char t;\n        int y;\n        std::cin >> t >> y;\n        \n        if (t == '+') {\n            x.push_back(y);\n            total++;\n        } else if (y > 1) {\n            a.push_back(std::move(x));\n            mul.push_back(y);\n        }\n    }\n    \n    a.push_back(std::move(x));\n    \n    int cntm = mul.size();\n    \n    for (int i = 0; i <= cntm; i++) {\n        std::sort(a[i].begin(), a[i].end());\n    }\n    \n    std::vector<std::vector<i64>> suf(cntm + 1);\n    for (int i = 0; i <= cntm; i++) {\n        suf[i].resize(a[i].size() + 1);\n        for (int j = int(a[i].size()) - 1; j >= 0; j--) {\n            suf[i][j] = suf[i][j + 1] + a[i][j];\n        }\n    }\n    \n    i64 ans = 0;\n    \n    std::map<int, std::vector<int>> mpos;\n    for (int i = 0; i < cntm; i++) {\n        mpos[mul[i]].push_back(i);\n    }\n    \n    std::vector<bool> move(cntm);\n    auto dfs = [&](auto self, auto it) {\n        if (it == mpos.end()) {\n            std::vector<i64> val(cntm + 1, 1);\n            i64 cost = 0;\n            for (int i = 0; i < cntm; i++) {\n                if (move[i]) {\n                    val[cntm] *= mul[i];\n                    cost += m;\n                } else {\n                    val[i] *= mul[i];\n                }\n            }\n            for (int i = cntm - 1; i >= 0; i--) {\n                val[i] *= val[i + 1];\n            }\n            if (cost > b) {\n                return;\n            }\n            const int rest = std::min((b - cost) / p, 1LL * total);\n            i64 cur = val[0];\n            for (int i = 0; i <= cntm; i++) {\n                cur += val[i] * suf[i][0];\n            }\n            \n            auto get = [&](auto x) {\n                int cnt = 0;\n                i64 sum = 0;\n                for (int i = 0; i <= cntm; i++) {\n                    if (val[i] == val[0]) {\n                        continue;\n                    }\n                    i64 y = x / (val[0] - val[i]);\n                    auto it = std::upper_bound(a[i].begin(), a[i].end(), y);\n                    int k = it - a[i].begin();\n                    cnt += a[i].size() - k;\n                    sum += suf[i][k] * (val[0] - val[i]);\n                }\n                return std::pair(cnt, sum);\n            };\n            \n            i64 lo = 0, hi = inf;\n            while (lo < hi) {\n                i64 x = (lo + hi) / 2;\n                if (get(x).first > rest) {\n                    lo = x + 1;\n                } else {\n                    hi = x;\n                }\n            }\n            auto [c, s] = get(lo);\n            cur += s + 1LL * (rest - c) * lo;\n            ans = std::max(ans, cur);\n            return;\n        }\n        self(self, std::next(it));\n        for (int i = 0; i < int(it->second.size()); i++) {\n            move[it->second[i]] = true;\n            self(self, std::next(it));\n        }\n        for (auto i : it->second) {\n            move[i] = false;\n        }\n    };\n    dfs(dfs, mpos.begin());\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. N Machines.json",
    "editorial_link": "https://codeforces.com//blog/entry/108336",
    "editorial": "Let bi the maximum value of the resulting product before any movements.\r\nThe problem statement says that it is guaranteed that . Observation 0\r\nafter each movements the value of the resulting product is not greater\r\nthan . Observation 1 each machine of kind should be moved to the end of\r\nthe sequence, and each machine of kind to the beginning of the sequence,\r\nand the order of movements does not make sense. Observation 2 there are\r\nat most non-trivial machines of kind (such machines that ). We will need\r\nsome more strong observation for machines of kind , but this will be\r\nuseful too. Observation 3 if there are two machines , , where and , then\r\nin optimal answer machine may be moved if and only if machine is moved\r\ntoo. It is true because we could increase the answer otherwise, by\r\nmoving machine instead of machine . The last two observations says that\r\nthere are not many subsets of machines of kind (that satisfies the\r\nproperty from observation 3). Letâs say that there are such subsets, in\r\nthe end of the editorial we will estimate this value.Letâs pick out\r\nsubsegments of machines of kind between machines of kind , sort them and\r\ncount prefix sums. There will be not more than such segments. In the\r\noptimal answer some maximums will be moved from each of the\r\nsegments.Letâs fix some subset of machines of kind , that will be moved\r\nto the end, and count the current value of the output product. Consider\r\nsome element in the array. Let the product of machines to the left of it\r\nbe , and to the right of it to be . Now if we move this element to the\r\nbeginning of the array, the value of the resulting product will increase\r\nby . Letâs call this . Now we have to find the sum of some numbers of\r\nmaximum values .Letâs use binary search to find some \"critical\" value :\r\nsuch value that all elements will be moved to the beginning. of each\r\nelement is not greater than . Inside binary search we have to iterate\r\nover all segments of elements and find the number of elements with\r\ninside this segment using binary search. We have to check if we can to\r\nmove the selected amount of elements to the beginning of the array to\r\nunderstand how to move borders of the external binary search.After we\r\nfind the critical value , letâs iterate over all segments and add the\r\nsum of elements that are to the answer. Separately letâs consider\r\nelements with = . We could move some of them to the beginning too. Letâs\r\nupdate the answer with this value.Time complexity: . It should be noted\r\nthat this estimate is actually higher than in fact.Letâs estimate the\r\nvalue now: Consider some sequence , such that and Sort it by ascending,\r\nthe product of elements will not change and the number of \"interesting\"\r\nsubsets will not become smaller. Replace all the smallest elements of\r\nthe sequence with , the second minimums with and so on. If there are\r\nsmaller number of elements equals to than elements equals to and , letâs\r\nswap their numbers. Now the number of interesting subsets is not\r\nchanged, is not increased. The sequence looks like now. The number of\r\ninteresting subsets in the new sequence equals to , where is the number\r\nof elements if sequence equals to . (Letâs run the code that will\r\nbrute-force over all sequences of such kind and see that the number of\r\ninteresting subsets is , which is achieved on sequence ) Letâs continue\r\nestimating this value \"fairly\": the elements of the sequence do not\r\nexceed because . Letâs replace each number with a prime number\r\ncorresponding to it by order: and replace all elements with . The\r\nproduct of elements will increate in at most times, so the product will\r\nnot exceed . It is easy to check that the maximum is achieved in , so\r\nthe product is not greater than . The number of interesting subsets of\r\nour sequence does not exceed the number of divisors of received numbers\r\nthat can be estimated as\r\n",
    "hint": []
}