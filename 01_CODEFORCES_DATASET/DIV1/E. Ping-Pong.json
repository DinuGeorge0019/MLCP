{"link": "https://codeforces.com//contest/319/problem/E", "problemId": "3259", "problem_idx": "E", "shortId": "319E", "contest_number": "319", "problem_submissions": {"D": [3948106, 3949160, 3951651, 3949707, 3949637, 3949775, 3962727, 3950884, 4081627, 3951853], "C": [3946594, 3947263, 3948244, 3948613, 3948176, 3945420, 3945758, 3945713, 3946296, 3946346, 3946524, 3946613, 3946482, 3945816, 3947039, 3946470], "B": [3944659, 3943682, 3946080, 3946044, 3946423, 3943572, 3944269, 3944276, 3944495, 3944694, 3944617, 3944629, 3943999, 3945031, 3943612, 3945716], "A": [3942928, 3944735, 3943181, 3943824, 3943092, 3942620, 3942968, 3942994, 3942953, 3943439, 3942852, 3943177, 3942732, 3944034, 3944966, 3944250], "E": [4934160]}, "name": "E. Ping-Pong", "statement": "In this problem at each moment you have a set of intervals. You can move\r\nfrom interval from our set to interval from our set if and only if .\r\nAlso there is a path from interval from our set to interval from our set\r\nif there is a sequence of successive moves starting from so that we can\r\nreach .Your program should handle the queries of the following two\r\ntypes: \"\" add the new interval to the set of intervals. The length of\r\nthe new interval is guaranteed to be strictly greater than all the\r\nprevious intervals. \"\" answer the question: is there a path from -th\r\n(one-based) added interval to -th (one-based) added interval? Answer all\r\nthe queries. Note, that initially you have an empty set of intervals.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n\n\nusing namespace std;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nll rdtsc() {\n    ll tmp;\n    asm(\"rdtsc\" : \"=A\"(tmp));\n    return tmp;\n}\n\ninline int myrand() {\n\treturn abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n\treturn myrand() % x;\n}\n\n#define TASKNAME \"text\"\n#define pb push_back\n#define mp make_pair\n#define EPS (1e-9)\n#define INF ((int)1e9)\n#define sqr(x) ((x) * (x))         \n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\nconst int maxn = (int)1e5;\nint pr[maxn], w[maxn];\npair<int, int> segms[maxn + 1];\nint xVals[maxn + 1];\n\nstruct Node {\n\tint x;\n\tint y;\n\n\tNode *l, *r;\n\n\tint maxr;\n\n\tNode(int _x) : x(_x), y(myrand()), l(0), r(0) {update();}\n\n\tinline Node* update() {\n\t\tmaxr = segms[x].second;\n\t\tif (l && l->maxr > maxr)\n\t\t\tmaxr = l->maxr;\n\t\tif (r && r->maxr > maxr)\n\t\t\tmaxr = r->maxr;\n\t\treturn this;\n\t}\n} *root;\n\nstruct xComp {\n\tinline bool operator () (const int x1, const int x2) {\n\t\tif (segms[x1].first != segms[x2].first)\n\t\t\treturn segms[x1].first < segms[x2].first;\n\t\tif (segms[x1].second != segms[x2].second)\n\t\t\treturn segms[x1].second > segms[x2].second;\n\t\treturn xVals[x1] < xVals[x2];\n\t}\n};\n\nint get(int v) {\n\tif (pr[v] == v)\n\t\treturn v;\n\treturn pr[v] = get(pr[v]);\n}\n\ninline void myUnion(int v1, int v2) {\n\t//eprintf(\"myUnion %d %d\\n\", v1, v2);\n\tv1 = get(v1), v2 = get(v2);\n\tif (v1 == v2)\n\t\treturn;\n\tif (w[v1] == w[v2])\n\t\t++w[v1];\n\tif (w[v1] < w[v2])\n\t\tswap(v1, v2);\n\tpr[v2] = v1;\n\tsegms[v1].first = min(segms[v1].first, segms[v2].first);\n\tsegms[v1].second = max(segms[v1].second, segms[v2].second);\n}\n\n\nNode* merge(Node *l, Node *r) {\n\tif (!l)\n\t\treturn r;\n\tif (!r)\n\t\treturn l;\n\tif (l->y > r->y) {\n\t\tl->r = merge(l->r, r);\n\t\treturn l->update();\n\t} else {\n\t\tr->l = merge(l, r->l);\n\t\treturn r->update();\n\t}\n}\n\nvoid split(Node *v, int x, Node *&l, Node *&r) {\n\tif (!v) {\n\t\tl = r = 0;\n\t\treturn;\n\t}\n\n\tif (xComp()(v->x, x)) {\n\t\tsplit(v->r, x, v->r, r);\n\t\tl = v->update();\n\t} else {\n\t\tsplit(v->l, x, l, v->l);\n\t\tr = v->update();\n\t}\n}\n\nNode *getNode(Node *root, int needr) {\n\tif (!root || root->maxr < needr)\n\t\treturn 0;\n\tNode *res = getNode(root->l, needr);\n\tif (res)\n\t\treturn res;\n\tif (segms[root->x].second >= needr)\n\t\treturn root;\n\tres = getNode(root->r, needr);\n\tassert(res);\n\treturn res;\n}\n\nvoid addSegm(int l, int r, int id) {\n\tpr[id] = id, w[id] = 0;\n\tsegms[id] = mp(l, r);\n\txVals[id] = id;\n\n\tfor (int side = 0; side < 2; ++side) {\n\t\tint needr = !side ? (l + 1) : (r + 1);\n\t\twhile (1) {\n\t\t\tNode *v = getNode(root, needr);\n\t\t\tif (!v)\n\t\t\t\tbreak;\n\t\t\tif (!side && segms[v->x].first >= l)\n\t\t\t\tbreak;\n\t\t\tif (side && segms[v->x].first >= r)\n\t\t\t\tbreak;\n\t\t\tNode *left, *mid, *right;\n\t\t\t{\n\t\t\t\tint tmp = id + 1;\n\t\t\t\tsegms[tmp] = segms[v->x];\n\t\t\t\txVals[tmp] = xVals[v->x];\n\n\t\t\t\tsplit(root, tmp, left, mid);\n\t\t\t\t++xVals[tmp];\n\t\t\t\tsplit(mid, tmp, mid, right);\n\t\t\t\tassert(mid == v);\n\t\t\t}\n\t\t\tmyUnion(id, mid->x);\n\t\t\troot = merge(left, right);\n\t\t}\n\t}\n\n\tint toadd = get(id);\n\tNode *newv = new Node(toadd);\n\tNode *left, *mid, *right;\n\t{\n\t\tint tmp = id + 1;\n\t\tsegms[tmp] = segms[newv->x];\n\t\txVals[tmp] = xVals[newv->x];\n\n\t\tsplit(root, tmp, left, mid);\n\t\t++xVals[tmp];\n\t\tsplit(mid, tmp, mid, right);\n\t\tassert(!mid);\n\t}\n\t//eprintf(\"add (%d..%d)\\n\", segms[toadd].first, segms[toadd].second);\t\n\troot = merge(left, merge(newv, right));\n}\n\n\nbool solve() {\n\tint n;\n\tif (scanf(\"%d\", &n) < 1)\n\t\treturn 0;\n\n\tint added = 0;\n\n\troot = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d%d\", &l, &r);\n\t\t\taddSegm(l, r, added);\n\t\t\t++added;\n\t\t\tcontinue;\n\t\t}\n\t\tassert(type == 2);\n\t\tint s, t;\n\t\tscanf(\"%d%d\", &s, &t);\n\t\t--s, --t;\n\t\tswap(s, t);\n\n\t\ts = get(s), t = get(t);\n\t\tprintf((segms[s].first <= segms[t].first && segms[t].second <= segms[s].second) ? \"YES\\n\" : \"NO\\n\");\n\t}\n\treturn 1;\n}\n\nint main() {\n\tlong long tmp = rdtsc();\n\tsrand(tmp);\n\t//eprintf(\"%I64d\\n\", tmp);\n#ifdef DEBUG\n\tfreopen(TASKNAME\".in\", \"r\", stdin);\n\tfreopen(TASKNAME\".out\", \"w\", stdout);\n#endif\n\t\n\twhile (1) {\n\t\tif (!solve())\n\t\t\tbreak;\n\t\t#ifdef DEBUG\n\t\t\teprintf(\"%.18lf\\n\", (double)clock() / CLOCKS_PER_SEC);\n\t\t#endif\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3000", "interactive": false}