{
    "link": "https://codeforces.com//contest/1188/problem/D",
    "problemId": "366823",
    "problem_idx": "D",
    "shortId": "1188D",
    "contest_number": "1188",
    "problem_submissions": {
        "A2": [
            56584964,
            56567602,
            56566524,
            56572382,
            56589644,
            56583972,
            56579938,
            56582233,
            56570590,
            56576661,
            56589231,
            56587448,
            56570901,
            56587024,
            56574198,
            56581669,
            56571222
        ],
        "E": [
            56582671,
            56589474,
            56589239,
            141774833,
            57345099,
            56596996,
            56642394
        ],
        "D": [
            56576903,
            56585842,
            56583846,
            56589764,
            56584452,
            56586331,
            56584084,
            56596587,
            56577947,
            56602284
        ],
        "C": [
            56571735,
            56576008,
            56572799,
            56580329,
            56577305,
            56572037,
            56574271,
            56570306,
            56577496,
            56576142,
            56583479,
            56585009,
            56584467,
            56575353,
            56583067,
            56585221,
            56572902,
            56587295,
            56575946,
            56586708
        ],
        "B": [
            56568214,
            56570555,
            56562488,
            56571471,
            56575984,
            56607436,
            56565158,
            56574148,
            56570733,
            56572983,
            56567704,
            56568743,
            56568263,
            56575440,
            56583939,
            56576017,
            56588907,
            56575865
        ],
        "A1": [
            56561659,
            56562944,
            56561298,
            56564728,
            56563727,
            56577205,
            56564216,
            56561247,
            56563294,
            56561568,
            56563293,
            56566261,
            56569194,
            56564914,
            56561283,
            56572778,
            56565086,
            56564073,
            56561536,
            56563748
        ]
    },
    "name": "D. Make Equal",
    "statement": "You are given n numbers a_1, a_2,\r\ndots, a_n. In one operation we can add to any one of those numbers a\r\nnonnegative integer power of 2.What is the smallest number of operations\r\nwe need to perform to make all n numbers equal? It can be proved that\r\nunder given constraints it doesn’t exceed 10^{18}.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int INF = (int)1e9;\nconst int N = 100100;\nconst int K = 60;\nll a[N];\nint n;\nll b[K][N];\nint dp[K][N];\n\nint getCount(int k, ll x) {\n\tll W = 1LL << (k - 1);\n\tif (x < W) {\n\t\treturn upper_bound(b[k], b[k] + n, x + W) - upper_bound(b[k], b[k] + n, x);\n\t} else {\n\t\treturn (upper_bound(b[k], b[k] + n, x - W) - b[k]) + \n\t\t\t(b[k] + n - upper_bound(b[k], b[k] + n, x));\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tfor (int k = 1; k < K; k++) {\n\t\tll U = (1LL << k) - 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[k][i] = a[i] & U;\n\t\tsort(b[k], b[k] + n);\n\t}\n\tfor (int k = 0; k < K; k++)\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tdp[k][i] = INF;\n\tdp[0][n] = 0;\n\tfor (int k = 1; k < K; k++) \n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (dp[k - 1][i] == INF) continue;\n\t\t\tif (i == 0 && b[k - 1][i] == 0) continue;\n\t\t\tfor (ll z = 0; z < 2; z++) {\n\t\t\t\tll x = (i == 0 ? 0 : b[k - 1][i - 1]) + (z << (k - 1));\n\t\t\t\tint p = upper_bound(b[k], b[k] + n, x) - b[k];\n\t\t\t\tdp[k][p] = min(dp[k][p], dp[k - 1][i] + getCount(k, x));\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", dp[K - 1][n]);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Make Equal.json",
    "editorial_link": "https://codeforces.com//blog/entry/68079",
    "editorial": "We will suppose, that array is sorted. Let x\n be the final number. Than x?an\n. Also, if we define bits[c]\n  as number of ones in binary notation of c\n, than, to get x\n from ai\n we will spend at least bits[x?ai]\n moves(it follows from the fact, that minumum number of powers of two, which in sum are equal to the number, corresponds to it binary notation). Let t=x?an\n, than x?ai=t+an?ai\n. So we need the following task:\n\nMinimize sum bits[t+an?a1]+bits[t+an?a2]++bits[t+an?an]\n, where t\n is some nonnegative integer. Also, let's define bi\n as an?ai\n.\n\nWe will solve this task using dp  value, which we want to minimize is sum bits[t+bi]\n, taken over bits up to (k?1)\n. Then, suppose we want to decide something about k\n-th bit. Let's understand, which information from the previous bits is needed for us. Imagine, that we sum t\n ? bi\n in vertical format. Clearly, to find k\n-th bit in number t+bi\n it's sufficient to know k\n-th bit in number t\n and do we have carry from previous digit. Furthermore, if we know this information for the previous bit, we can get it for the next(carry in new digit will occur iff bitk[bi]\n + bitk[t]\n + (didwehavecarry)?2\n). But we should save information about carry for all numbers t+bi\n, so, at first sight, for one bit we have at least 2n\n different states of dp. To reduce the number of states we need to note key fact:\n\nLet t?=t\n mod\n 2k\n, c?=c\n mod\n 2k\n. Than, carry in k\n-th bit will occur t+c\n iff t?+c??2k\n. Indeed, carry corresponds to the fact that the sum of \"cutoff\" numbers is at least 2k\n.\n\nUsing this fact we understand that, if we sort numbers b?i=bi\n mod\n 2k\n, than carry in k\n-th bit will happen only for some suffix of b?i\n. That's why, we get n+1\n different states for one bit, which is good. So we only need to learn how to make transitions fast. It's useful to note, that we don't need to know numbers bi\n, it's sufficient to know do we have a carry and value of k\n-th bit of bi\n. Then, transition reduces to count the number of 1\n and 0\n in k\n-th bit on some segment of the array sorted by b?i\n. This can be easily done in constant time if we precalculated prefix sums(for better understanding you can read attached code). So, we can solve the task in nlog(n)F\n time, where F\n is bit up to which we'll write dp. So, it' left to show (or to believe :)), that there is no sense to consider big F\n.",
    "hint": []
}