{"link": "https://codeforces.com//contest/1188/problem/D", "problemId": "366823", "problem_idx": "D", "shortId": "1188D", "contest_number": "1188", "problem_submissions": {"A2": [56584964, 56567602, 56566524, 56572382, 56589644, 56583972, 56579938, 56582233, 56570590, 56576661, 56589231, 56587448, 56570901, 56587024, 56574198, 56581669, 56571222], "E": [56582671, 56589474, 56589239, 141774833, 57345099, 56596996, 56642394], "D": [56576903, 56585842, 56583846, 56589764, 56584452, 56586331, 56584084, 56596587, 56577947, 56602284], "C": [56571735, 56576008, 56572799, 56580329, 56577305, 56572037, 56574271, 56570306, 56577496, 56576142, 56583479, 56585009, 56584467, 56575353, 56583067, 56585221, 56572902, 56587295, 56575946, 56586708], "B": [56568214, 56570555, 56562488, 56571471, 56575984, 56607436, 56565158, 56574148, 56570733, 56572983, 56567704, 56568743, 56568263, 56575440, 56583939, 56576017, 56588907, 56575865], "A1": [56561659, 56562944, 56561298, 56564728, 56563727, 56577205, 56564216, 56561247, 56563294, 56561568, 56563293, 56566261, 56569194, 56564914, 56561283, 56572778, 56565086, 56564073, 56561536, 56563748]}, "name": "D. Make Equal", "statement": "You are given n numbers a_1, a_2,\r\ndots, a_n. In one operation we can add to any one of those numbers a\r\nnonnegative integer power of 2.What is the smallest number of operations\r\nwe need to perform to make all n numbers equal? It can be proved that\r\nunder given constraints it doesn\u2019t exceed 10^{18}.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int INF = (int)1e9;\nconst int N = 100100;\nconst int K = 60;\nll a[N];\nint n;\nll b[K][N];\nint dp[K][N];\n\nint getCount(int k, ll x) {\n\tll W = 1LL << (k - 1);\n\tif (x < W) {\n\t\treturn upper_bound(b[k], b[k] + n, x + W) - upper_bound(b[k], b[k] + n, x);\n\t} else {\n\t\treturn (upper_bound(b[k], b[k] + n, x - W) - b[k]) + \n\t\t\t(b[k] + n - upper_bound(b[k], b[k] + n, x));\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tfor (int k = 1; k < K; k++) {\n\t\tll U = (1LL << k) - 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[k][i] = a[i] & U;\n\t\tsort(b[k], b[k] + n);\n\t}\n\tfor (int k = 0; k < K; k++)\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tdp[k][i] = INF;\n\tdp[0][n] = 0;\n\tfor (int k = 1; k < K; k++) \n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (dp[k - 1][i] == INF) continue;\n\t\t\tif (i == 0 && b[k - 1][i] == 0) continue;\n\t\t\tfor (ll z = 0; z < 2; z++) {\n\t\t\t\tll x = (i == 0 ? 0 : b[k - 1][i - 1]) + (z << (k - 1));\n\t\t\t\tint p = upper_bound(b[k], b[k] + n, x) - b[k];\n\t\t\t\tdp[k][p] = min(dp[k][p], dp[k - 1][i] + getCount(k, x));\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", dp[K - 1][n]);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "3100", "interactive": false}