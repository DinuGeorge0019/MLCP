{
    "link": "https://codeforces.com//contest/367/problem/D",
    "problemId": "4099",
    "problem_idx": "D",
    "shortId": "367D",
    "contest_number": "367",
    "problem_submissions": {
        "A": [
            5253633,
            5248539,
            5245621,
            5246967,
            5245187,
            5245239,
            5244912,
            5260352,
            5248460,
            5246717,
            5247161,
            5247626,
            5250480,
            5245644,
            5245467,
            5248078
        ],
        "D": [
            5251109,
            5249684,
            5251377,
            5253799,
            5250841,
            5254107,
            5254017,
            5254422,
            5250750,
            5253666,
            5254820,
            5253839,
            5253605,
            5254366,
            5255055,
            5254149
        ],
        "E": [
            5249574,
            5253117,
            5253114,
            5256266,
            5249949,
            5258981,
            5256724,
            5261975,
            5266872,
            5268278,
            5260869
        ],
        "B": [
            5248117,
            5245452,
            5253998,
            5248352,
            5248954,
            5247801,
            5248088,
            5250697,
            5246678,
            5248495,
            5245796,
            5247335,
            5247628,
            5249396,
            5248757,
            5249320
        ],
        "C": [
            5246223,
            5247815,
            5247820,
            5249874,
            5249775,
            5249473,
            5249680,
            5248776,
            5247935,
            5249664,
            5249146,
            5249197,
            5249315,
            5250702,
            5250582,
            5251144
        ]
    },
    "name": "D. Sereja and Sets",
    "statement": "Sereja has non-empty sets of integers . What a lucky coincidence! The\r\ngiven sets are a partition of the set of all integers from 1 to . In\r\nother words, for any integer there is exactly one set such that . Also\r\nSereja has integer .Sereja decided to choose some sets from the sets he\r\nhas. Let’s suppose that are indexes of the chosen sets. Then let’s\r\ndefine an array of integers , sorted in ascending order, as a union of\r\nthe chosen sets, that is, . We’ll represent the element with number in\r\nthis array (in ascending order) as . Sereja considers his choice of sets\r\n, if the following conditions are met:Sereja wants to know what is the\r\nminimum number of sets that he can choose so that his choice will be\r\ncorrect. Help him with that.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint N,K,D;\nint a[100010];\nint freq[30];\nbool bad[(1<<20)];\n\nvoid add(void){\n    int mask = 0;\n    int i;\n    REP(i,K) if(freq[i] == 0) mask |= (1<<i);\n    bad[mask] = true;\n//  cout << mask << endl;\n}\n\nint main(void){\n    int i,j,mask;\n    \n    cin >> N >> K >> D;\n    REP(i,K){\n        int sz;\n        cin >> sz;\n        int x;\n        REP(j,sz){\n            scanf(\"%d\", &x);\n            a[x-1] = i;\n        }\n    }\n    \n    REP(i,D) freq[a[i]]++;\n    add();\n    for(i=D;i<N;i++){\n        freq[a[i]]++;\n        freq[a[i-D]]--;\n        add();\n    }\n    \n    int ans = K;\n    for(mask=(1<<K)-1;mask>=0;mask--){\n        if(!bad[mask]){\n            int cnt = 0;\n            REP(i,K) if(mask&(1<<i)) cnt++;\n            ans = min(ans, cnt);\n        } else {\n            REP(i,K) if(mask&(1<<i)) bad[mask^(1<<i)] = true;\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Sereja and Sets.json",
    "editorial_link": "https://codeforces.com//blog/entry/9726",
    "editorial": "Replace out sets by array, where the element the number set to which its\r\nindex belongs. Now take all the consequitive sub-arrays with lengths of\r\nand find a set of elements that were not found in that sub array.\r\nClearly, if we as a response to select a subset of such set, it does not\r\nfit us. Remember all those \"bad set.\" As we know all of them, we can\r\nfind all the \"bad\" subsets. Now we choose the set with maximum count of\r\nelements which is not a bad set. It is better to work here with bit\r\nmasks.\r\n",
    "hint": []
}