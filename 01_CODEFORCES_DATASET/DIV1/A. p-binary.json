{
    "link": "https://codeforces.com//contest/1246/problem/A",
    "problemId": "451067",
    "problem_idx": "A",
    "shortId": "1246A",
    "contest_number": "1246",
    "problem_submissions": {
        "F": [
            63515154,
            63481339,
            63483227,
            63527437
        ],
        "E": [
            63477457,
            63471160,
            63477982,
            63475906,
            63518064,
            63483383,
            63518604,
            97691403,
            63517633,
            63488500
        ],
        "D": [
            63464099,
            63460604,
            63460125,
            63467192,
            63463968,
            63466889,
            63467829,
            63473013,
            63471128,
            63459892,
            63474479,
            63467875,
            63476603,
            63468880,
            63466274,
            63468455,
            63468377,
            63471942,
            63478598,
            63471593
        ],
        "C": [
            63452409,
            63454665,
            63454015,
            63456906,
            63457379,
            63460403,
            63458338,
            63462999,
            63457035,
            63454754,
            63459839,
            63457021,
            63458327,
            63457758,
            63458226,
            63460931,
            63460824,
            63461992,
            63467689,
            63460739
        ],
        "B": [
            63442019,
            63440659,
            63440705,
            63445485,
            63449371,
            63449831,
            63445799,
            63449601,
            63451011,
            63449141,
            63439490,
            63447371,
            63445988,
            63447815,
            63451910,
            63451605,
            63453470,
            63443287,
            63451810,
            63450686
        ],
        "A": [
            63437903,
            63456370,
            63443580,
            63437815,
            63442162,
            63437666,
            63439166,
            63442383,
            63492730,
            63442467,
            63438366,
            63445898,
            63440290,
            63439417,
            63440796,
            63444393,
            63441301,
            63442558,
            63437991,
            63443933,
            63444495
        ]
    },
    "name": "A. p-binary",
    "statement": "Vasya will fancy any number as long as it is an integer power of two.\r\nPetya, on the other hand, is very conservative and only likes a single\r\ninteger p (which may be positive, negative, or zero). To combine their\r\ntastes, they invented of the form 2^x + p, where x is a integer.For\r\nexample, some -9-binary (\"minus nine\" binary) numbers are: -8 (minus\r\neight), 7 and 1015 (-8=2^0-9, 7=2^4-9, 1015=2^{10}-9).The boys now use\r\np-binary numbers to represent everything. They now face a problem: given\r\na positive integer n, what’s the smallest number of p-binary numbers\r\n(not necessarily distinct) they need to represent n as their sum? It may\r\nbe possible that representation is impossible altogether. Help them\r\nsolve this problem.For example, if p=0 we can represent 7 as 2^0 + 2^1 +\r\n2^2.And if p=-9 we can represent 7 as one number (2^4-9).Note that\r\nnegative p-binary numbers are allowed to be in the sum (see the Notes\r\nsection for an example).\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void pr(const T& x) { \n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    \n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n    }\n    \n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n    }\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n\tsetIO();\n\tint n,p; re(n,p);\n\tfor (int i = 1;;++i) {\n\t\tint tmp = n-i*p; if (tmp < i) break;\n\t\tif (__builtin_popcount(tmp) <= i) {\n\t\t\tps(i);\n\t\t\texit(0);\n\t\t}\n\t}\n\tps(-1);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. p-binary.json",
    "editorial_link": "https://codeforces.com//blog/entry/70898",
    "editorial": "Suppose we want to represent n\n as the sum of k\n p\n-binary numbers. We must have n=?ki=1(2xi+p)\n for a suitable choice of x1,,xk\n. Moving all p\n's to the left-hand side, we must have n?kp=?ki=12xi\n. In particular, n?kp\n has to be at least k\n.\n\nConsider the binary representation of n?kp\n. If it has more than k\n bits equal to 1\n, there is no way we can split it into k\n powers of two. Otherwise, we can start by taking the binary representation, and if it contains less than k\n powers, we can always split larger powers into two smaller ones.\n\nWe can now check all values of k\n starting from the smallest. If n?31p+31\n, then the answer will not exceed 31\n since n?31p\n is less than 231\n, hence is always representable with 31\n powers. Otherwise, we have n?31(p+1)<0\n. Since n>0\n, it means that p+1<0\n, and n?kp<k\n for all k>31\n, thus the answer does not exist.",
    "hint": []
}