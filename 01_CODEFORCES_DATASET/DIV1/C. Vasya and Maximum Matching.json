{"link": "https://codeforces.com//contest/1078/problem/C", "problemId": "257668", "problem_idx": "C", "shortId": "1078C", "contest_number": "1078", "problem_submissions": {"D": [45940862, 45933303, 45935766, 45933853, 45930995, 45936488, 45940747, 45943827, 45939112, 45949887, 45939231, 45940966, 45940947, 45958692, 45958625, 45928396, 45942294, 45942258, 45942248, 45942159, 45942142, 45942044, 45941921, 45940689], "E": [45937493, 45942033, 45960731, 45946630], "B": [45928126, 45925305, 45926274, 45926072, 45923067, 45926568, 45940774, 45920994, 45922995, 45940934, 45949871, 45927955, 45922044, 45923855, 45923008, 45958814, 45932880, 45923428, 45938791, 45941333, 45925850, 45924600, 45924279], "C": [45926441, 45929882, 45930167, 45929211, 45934188, 45931921, 45926885, 45928260, 45930909, 45932518, 45925565, 45924426, 45931751, 45929018, 45958808, 45923916, 45927809, 45932834, 45932060, 45934408], "A": [45921892, 45921151, 45920874, 45923123, 45920460, 45920490, 45920725, 45923466, 45934579, 45920717, 45924554, 45958821, 45927000, 45931917, 45930488, 45922107, 45922245, 45921493]}, "name": "C. Vasya and Maximum Matching", "statement": "Vasya has got a tree consisting of n vertices. He wants to delete some\r\n(possibly zero) edges in this tree such that the maximum matching in the\r\nresulting graph is unique. He asks you to calculate the number of ways\r\nto choose a set of edges to remove.A matching in the graph is a subset\r\nof its edges such that there is no vertex incident to two (or more)\r\nedges from the subset. A maximum matching is a matching such that the\r\nnumber of edges in the subset is maximum possible among all matchings in\r\nthis graph.Since the answer may be large, output it modulo 998244353.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nvector<vector<int> > edges;\nconst LL MOD = 998244353;\nstruct dp {\n\tint a, b, c;\n};\ndp solve(int v, int p){\n\tvector<LL> matched;\n\tvector<LL> unmatched;\n\tvector<LL> unused;\n\tfor(int a : edges[v]){\n\t\tif(a == p) continue;\n\t\tdp x = solve(a, v);\n\t\tmatched.push_back(x.a);\n\t\tunmatched.push_back(x.b);\n\t\tunused.push_back(x.c);\n\t}\n\tint k = matched.size();\n\tdp x;\n\tx.a = 1;\n\tx.b = 0;\n\tx.c = 1;\n\tif(k == 0) return x;\n\tfor(int i = 0; i < k; i++){\n\t\tx.a = (x.a * (unmatched[i] + unused[i])) % MOD;\n\t}\n\tfor(int i = 0; i < k; i++){\n\t\tx.c = (x.c * (unused[i])) % MOD;\n\t}\n\tvector<LL> left_prod(k);\n\tvector<LL> right_prod(k);\n\tleft_prod[0] = 1;\n\tright_prod[k-1] = 1;\n\tfor(int i = 1; i < k; i++){\n\t\tleft_prod[i] = (left_prod[i-1] * (unmatched[i-1] + unused[i-1])) % MOD;\n\t}\n\tfor(int i = k-2; i >= 0; i--){\n\t\tright_prod[i] = (right_prod[i+1] * (unmatched[i+1] + unused[i+1])) % MOD;\n\t}\n\tfor(int i = 0; i < k; i++){\n\t\tLL z = left_prod[i] * right_prod[i];\n\t\tz %= MOD;\n\t\tz = (z * matched[i]) % MOD;\n\t\tx.b = (x.b + z) % MOD;\n\t}\n\tx.c = (x.c + x.b) % MOD;\n\treturn x;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tedges.resize(n);\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--; \n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tLL ans = solve(0, -1).c;\n\tans %= MOD;\n\tif(ans < 0) ans += MOD;\n\tcout << ans << '\\n';\n}"], "input": "", "output": "", "tags": ["combinatorics", "dp", "trees"], "dificulty": "2400", "interactive": false}