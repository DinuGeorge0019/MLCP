{"link": "https://codeforces.com//contest/132/problem/E", "problemId": "710", "problem_idx": "E", "shortId": "132E", "contest_number": "132", "problem_submissions": {"E": [925463, 924045, 926495, 927129, 930757, 927949, 927053], "B": [923684, 925104, 927721, 923959, 924110, 922324, 922978, 923016, 925081, 924882, 922141, 926108, 923013, 925452, 925520, 925045, 926157, 926077], "D": [922457, 922554, 924871, 922974, 924948, 924454, 924331, 923366, 923651, 925293, 923560, 925565, 922791, 924076, 923184, 923568, 923999], "C": [920611, 921352, 922698, 921318, 922939, 921777, 922465, 921286, 921687, 923127, 921959, 921893, 920032, 922242, 921743, 922634, 922920], "A": [919809, 919078, 921073, 919691, 920209, 919403, 919950, 919419, 920157, 919937, 920116, 920376, 920930, 921451, 922067, 920124, 920860]}, "name": "E. Bits of merry old England", "statement": "Another feature of Shakespeare language is that the variables are named\r\nafter characters of plays by Shakespeare, and all operations on them\r\n(value assignment, output etc.) look like a dialog with other\r\ncharacters. New values of variables are defined in a rather lengthy way,\r\nso a programmer should try to minimize their usage.You have to print the\r\ngiven sequence of integers. To do this, you have variables and two types\r\nof operations on them: Any of the variables can be used as . Variables\r\nare denoted by lowercase letters between \"\" and \"\", inclusive. Any\r\ninteger number can be used as .Let\u2019s say that the penalty for using\r\nfirst type of operations equals to the number of set bits in the number\r\n. There is no penalty on using second type of operations. Find and\r\noutput the program which minimizes the penalty for printing the given\r\nsequence of numbers.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:65777216\")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint nb(int x){return x==0?0:1+nb(x&(x-1));}\n\nint n,m;\nint a[555];\n\nvector<pii> v[666];\n\nconst int inf = 1011111111;\n\nint d[666];\nint f[666];\n\nint flow(){\n\tint N = 2*n+m+2;\n\tREP(i,N) d[i] = inf;\n\tint start = N - 2;\n\n\td[start] = 0;\n\tpriority_queue<pii> q;\n\tq.push(pii(0, start));\n\n\twhile(!q.empty()){\n\t\tpii curr = q.top();q.pop();\n\t\tint ver = curr.second;\n\t\tint cost = -curr.first;\n\t\tif(d[ver]<cost) continue;\n\n\t\tREP(i,v[ver].size()){\n\n\t\t\tint nw = v[ver][i].first;\n\t\t\tint ncost = cost + v[ver][i].second;\n\n\t\t\tif(d[nw] > ncost){\n\t\t\t\td[nw] = ncost;\n\t\t\t\tf[nw] = ver;\n\t\t\t\tq.push(pii(-ncost, nw));\n\t\t\t}\n\t\t}\n\t}\n\n\tint curr = N-1;\n\twhile(curr!=N-2){\n\t\tint prev = f[curr];\n\n\t\tbool found = false;\n\t\tREP(i,v[prev].size()) if(v[prev][i].first == curr){\n\t\t\tswap(v[prev][i], v[prev].back());\n\t\t\tint cost = v[prev].back().second;\n\t\t\tv[prev].pop_back();\n\n\t\t\tv[curr].pb(pii(prev, -cost));\n\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tif(!found) puts(\"FACK\");\n\t\tcurr = prev;\n\t}\n\n\t\n\treturn d[N-1];\n}\n\nstring conv(int a){\n\tstringstream ss;\n\tss<<a;\n\treturn ss.str();\n}\n\nstring var[333];\n\nint main(){\n#ifdef LocalHost\n\n    freopen(\"input.txt\",\"r\",stdin);\n//  freopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tcin>>n>>m;\n\tREP(i,n) cin>>a[i];\n\tREP(i,n) FOR(j,i+1,n) if(a[i]==a[j]) v[i].pb(pii(n+m+j,0));\n\telse v[i].pb(pii(n+m+j,nb(a[j])));\n\tREP(i,m)REP(j,n) v[n+i].pb(pii(n+m+j,nb(a[j])));\n\tREP(i,n+m) v[2*n+m].pb(pii(i,0));\n\tREP(i,n) v[n+m+i].pb(pii(2*n+m+1,0));\n\n\tif(0)REP(i,2*n+m+2){\n\t\tcout<<\"ver \"<<i<<\": \";\n\t\tREP(j,v[i].size())\n\t\t\tcout<<v[i][j].first<<','<<v[i][j].second<<\" \";\n\t\tputs(\"\");\n\t\t//\tcout<<v[n+m+i].size()<<endl;\n\t\t//res.pb(\"print(\"+a+\")\");\n\t}\n\n\tint cost = 0;\n\tREP(tt,n) cost += flow();\n\tvector<string> res;\n\n\tREP(i,n){\n\t\t//cout<<\"ver \"<<i<<\": \";\n\t\t//REP(j,v[n+m+i].size())\n\t\t//\tcout<<v[n+m+i][j].first<<','<<v[n+m+i][j].second<<\" \";\n\t\t//puts(\"\");\n\t\t//cout<<v[n+m+i].size()<<endl;\n\t\tint from = v[n+m+i][0].first;\n\t\tif(from>=n){\n\t\t\tvar[i] = string(1,char('a'+from-n));\n\t\t\tres.pb(var[i]+\"=\"+conv(a[i]));\n\t\t}else{\n\t\t\tvar[i] = var[from];\n\t\t\tif(a[i]!=a[from]) res.pb(var[i]+\"=\"+conv(a[i]));\n\t\t}\n\t\tres.pb(\"print(\"+var[i]+\")\");\n\n\t}\n\n\tcout<<res.size()<<' '<<cost<<endl;\n\tREP(i,res.size()) cout<<res[i]<<endl;\n\n\n#ifdef LocalHost\n    cout<<endl<<endl<<\"TIME: \"<<clock()<<endl;\n#endif\n    return 0;\n}"], "input": "", "output": "", "tags": ["flows", "graphs"], "dificulty": "2700", "interactive": false}