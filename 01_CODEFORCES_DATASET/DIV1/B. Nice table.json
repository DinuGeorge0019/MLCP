{
    "link": "https://codeforces.com//contest/1098/problem/B",
    "problemId": "278461",
    "problem_idx": "B",
    "shortId": "1098B",
    "contest_number": "1098",
    "problem_submissions": {
        "E": [
            51775559,
            48006690,
            48011091,
            47996318,
            48015799,
            48015745,
            48015679,
            48016465
        ],
        "D": [
            47994331,
            47991784,
            48004915,
            47986667,
            47997263,
            47997207,
            47997823,
            48003406,
            48012772,
            48000542,
            48002246,
            47998686,
            48003172,
            48003847,
            48013739,
            48013700,
            48013652,
            48012961,
            48012955,
            48007481,
            48004946,
            47998449,
            48006927,
            47993907
        ],
        "C": [
            47990851,
            47988182,
            48002088,
            47984104,
            47990986,
            47992891,
            47990373,
            47996864,
            47993728,
            47992046,
            48002685,
            47997828,
            47997416,
            47983441,
            47996246,
            48004923,
            47992474,
            48000276
        ],
        "B": [
            47984141,
            47982505,
            48010238,
            47997345,
            47983353,
            47986135,
            47985242,
            47985258,
            47997818,
            47982827,
            47991394,
            47990410,
            47990108,
            47991143,
            47984918,
            47988149,
            47999187,
            48005571
        ],
        "A": [
            47975157,
            47974213,
            48009223,
            47974115,
            47975580,
            47975415,
            47977674,
            47976551,
            47976714,
            47995866,
            47975779,
            47977103,
            47975994,
            47986982,
            47978302,
            47975716,
            47976034,
            47978693
        ],
        "F": [
            54648301
        ]
    },
    "name": "B. Nice table",
    "statement": "You are given an n\r\ntimes m table, consisting of characters , , , . Let\u2019s call a table , if\r\nevery 2\r\ntimes 2 square contains all four distinct characters. Your task is to\r\nfind a nice table (also consisting of , , , ), that differs from the\r\ngiven table in the minimum number of characters.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\n\nusing pla=vector<vi>;\n\nint n, m;\n\npla tab;\n\nint pam;\npla wyn;\n\nchar wcz[nax];\nchar zn[]={'A', 'C', 'T', 'G'};\n\nint tlu(char v)\n{\n\tfor (int i=0; i<4; i++)\n\t\tif (zn[i]==v)\n\t\t\treturn i;\n\tassert(0);\n}\n\nint roz(const pla &a, const pla &b)\n{\n\tint ret=0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<m; j++)\n\t\t\tret+=(a[i][j]!=b[i][j]);\n\treturn ret;\n}\n\nint rozr(const pla &a, const pla &b, int r)\n{\n\tint ret=0;\n\tfor (int i=r; i<=r; i++)\n\t\tfor (int j=0; j<m; j++)\n\t\t\tret+=(a[i][j]!=b[i][j]);\n\treturn ret;\n}\n\nint rozc(const pla &a, const pla &b, int c)\n{\n\tint ret=0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=c; j<=c; j++)\n\t\t\tret+=(a[i][j]!=b[i][j]);\n\treturn ret;\n}\n\nvoid cons(pla v)\n{\n\tint x=roz(v, tab);\n\tif (wyn.empty() || x<pam)\n\t{\n\t\twyn=v;\n\t\tpam=x;\n\t}\n}\n\nvoid dajr(int a, int b)\n{\n\tvi tu[2];\n\ttu[0]={a, b};\n\tfor (int i=0; i<4; i++)\n\t\tif (i!=a && i!=b)\n\t\t\ttu[1].push_back(i);\n\tpla gen(n, vi(m, 0));\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tvi rozy;\n\t\tfor (int j=0; j<2; j++)\n\t\t{\n\t\t\tfor (int l=0; l<m; l++)\n\t\t\t\tgen[i][l]=(tu[i&1][(l+j)&1]);\n\t\t\trozy.push_back(rozr(gen, tab, i));\n\t\t}\n\t\tint w=(rozy[0]>rozy[1]);\n\t\tfor (int l=0; l<m; l++)\n\t\t\tgen[i][l]=(tu[i&1][(l+w)&1]);\n\t}\n\tcons(gen);\n}\n\nvoid dajc(int a, int b)\n{\n\tvi tu[2];\n\ttu[0]={a, b};\n\tfor (int i=0; i<4; i++)\n\t\tif (i!=a && i!=b)\n\t\t\ttu[1].push_back(i);\n\tpla gen(n, vi(m, 0));\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tvi rozy;\n\t\tfor (int j=0; j<2; j++)\n\t\t{\n\t\t\tfor (int l=0; l<n; l++)\n\t\t\t\tgen[l][i]=(tu[i&1][(l+j)&1]);\n\t\t\trozy.push_back(rozc(gen, tab, i));\n\t\t}\n\t\tint w=(rozy[0]>rozy[1]);\n\t\tfor (int l=0; l<n; l++)\n\t\t\tgen[l][i]=(tu[i&1][(l+w)&1]);\n\t}\n\tcons(gen);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\ttab.resize(n, vi(m, 0));\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tscanf(\"%s\", wcz);\n\t\tfor (int j=0; j<m; j++)\n\t\t\ttab[i][j]=tlu(wcz[j]);\n\t}\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tfor (int j=0; j<i; j++)\n\t\t{\n\t\t\tdajr(i, j);\n\t\t\tdajc(i, j);\n\t\t}\n\t}\n\t\n\t\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<m; j++)\n\t\t\tprintf(\"%c\", zn[wyn[i][j]]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Nice table.json",
    "editorial_link": "https://codeforces.com/blog/entry/64331",
    "editorial": "Key idea:\n\nIn a good matrix, either each row contain at most two different characters, or each column contain at most two different characters.\n\nProof: (it will be here, but for now the editorial fields are too narrow to contain it).\n\nIn other words, the field looks either like (up to a permutation of \u00abAGCT\u00bb):\n\n\u00abAGAGAG\u00bb\n\n\u00abCTCTCT\u00bb\n\n\u00abAGAGAG\u00bb (or \u00abGAGAGA\u00bb)\n\n\u00abCTCTCT\u00bb (or \u00abTCTCTC\u00bb)\n\n\u00abAGAGAG\u00bb (or \u00abGAGAGA\u00bb)\n\n\u00abCTCTCT\u00bb (or \u00abTCTCTC\u00bb)\n\n(and so on)\n\nor similarly by columns.\n\nSo, the solution is to say that we have this alternation by rows, iterate over the permutation of letters, for each row choose from the row and its inversion the one that differs from the row of the original matrix in the minimum number of characters. Then rotate the matrix, and solve similarly again, and take a more optimal one."
}