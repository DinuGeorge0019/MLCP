{
    "link": "https://codeforces.com//contest/1158/problem/A",
    "problemId": "343486",
    "problem_idx": "A",
    "shortId": "1158A",
    "contest_number": "1158",
    "problem_submissions": {
        "E": [
            54043697,
            54045364,
            54049022
        ],
        "D": [
            54034270,
            54037737,
            54037081,
            54029996,
            54039126,
            54036378,
            54039507,
            54040185,
            54038993,
            54040201,
            54038641,
            54040565,
            54035763,
            54041644,
            54031772,
            54033510,
            54035224
        ],
        "C": [
            54032525,
            54035029,
            54036135,
            54034332,
            54036498,
            54034178,
            54037957,
            54038859,
            54034328,
            54037431,
            54037039,
            54036368,
            54038382,
            54039919,
            54034772,
            54037883,
            54036347,
            54039155
        ],
        "B": [
            54031111,
            54032629,
            54034184,
            54032709,
            54033881,
            54040878,
            54036260,
            54033097,
            54031744,
            54033322,
            54032381,
            54039897,
            54035074,
            54040745,
            54038527,
            54041411,
            68070838,
            54045735,
            54041323
        ],
        "A": [
            54029723,
            54029634,
            54031071,
            54030974,
            54029203,
            54030224,
            54030247,
            54030013,
            54029682,
            54030151,
            54031232,
            54030952,
            54031158,
            54031859,
            54031283,
            54032676,
            54031617,
            54030225
        ],
        "F": [
            54045740,
            54049931,
            74200730,
            74200612,
            73657677,
            73657539,
            73657494,
            73657445,
            73007148,
            68077713,
            68077566,
            68077199,
            68077121,
            68076937
        ]
    },
    "name": "A. The Party and Sweets",
    "statement": "n boys and m girls came to the party. Each boy presented each girl some\r\ninteger number of sweets (possibly zero). All boys are numbered with\r\nintegers from 1 to n and all girls are numbered with integers from 1 to\r\nm. For all 1\r\nleq i\r\nleq n the minimal number of sweets, which i-th boy presented to some\r\ngirl is equal to b_i and for all 1\r\nleq j\r\nleq m the maximal number of sweets, which j-th girl received from some\r\nboy is equal to g_j.More formally, let a_{i,j} be the number of sweets\r\nwhich the i-th boy give to the j-th girl. Then b_i is equal exactly to\r\nthe minimum among values a_{i,1}, a_{i,2},\r\nldots, a_{i,m} and g_j is equal exactly to the maximum among values\r\nb_{1,j}, b_{2,j},\r\nldots, b_{n,j}.You are interested in the minimum total number of sweets\r\nthat boys could present, so you need to minimize the sum of a_{i,j} for\r\nall (i,j) such that 1\r\nleq i\r\nleq n and 1\r\nleq j\r\nleq m. You are given the numbers b_1,\r\nldots, b_n and g_1,\r\nldots, g_m, determine this number.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  cin >> N >> M;\n  vector<int> bi(N), gi(M);\n  for (int &b : bi) { cin >> b; }\n  for (int &g : gi) { cin >> g; }\n\n  sort(ALL(bi), greater<int>());\n\n  if (*min_element(ALL(gi)) < *max_element(ALL(bi))) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  const int max_b = *max_element(ALL(bi));\n\n  LL answer = 0;\n  for (int b : bi) { answer += b; }\n  answer *= M;\n  for (int g : gi) {\n    answer += g - max_b;\n  }\n  if (*min_element(ALL(gi)) != bi[0]) {\n    answer += bi[0] - bi[1];\n  }\n  cout << answer << \"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "greedy",
        "implementation",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. The Party and Sweets.json",
    "editorial_link": "https://codeforces.com/blog/entry/66993?locale=en",
    "editorial": "Let's note, that for all 1?i?n,1?j?m\n is is true, that bi?gj\n, because bi?aij?gj\n. So max(b1,b2,,bn)?min(g1,g2,,gm)\n. If it is not true, the answer is ?1\n.\n\nLet's prove, that if max(b1,b2,,bn)?min(g1,g2,,gm)\n the answer always exists and let's find it. Let's make all aij=bi\n. Let's note, that bi=min(ai1,ai2,,aim)\n. But in this case maximums in each column can be wrong. To make them correct we should place 1?j?m\n into the j\n-th column of the table a\n the number gj\n. To make the sum as small as possible we want to place all gj\n into the row with maximal bi\n. If we will make it the minimal in this row will be equal min(g1,g2,,gm)\n. But the number b\n for this row is equal to max(b1,b2,,bn)\n. So, if max(b1,b2,,bn)=min(g1,g2,,gm)\n the answer is equal to (b1+b2++bn)m+g1+g2++gm?max(b1,b2,,bn)m\n. But if max(b1,b2,,bn)<min(g1,g2,,gm)\n we should place some of the gj\n in the other row. Let's place g1\n into the row there bi\n is second maximum in the array b\n. It's easy to check in this case, that all minimums, maximums will be correct in this case. In this case the answer is equal to (b1+b2++bn)m+g1+g2++gm?max(b1,b2,,bn)(m?1)?max2(b1,b2,,bn)\n.\n\nSo:\n\nIf max(b1,b2,,bn)>min(g1,g2,,gm)\n the answer is ?1\n;\nIf max(b1,b2,,bn)=min(g1,g2,,gm)\n the answer is (b1+b2++bn)m+g1+g2++gm?max(b1,b2,,bn)m\n;\nIf max(b1,b2,,bn)<min(g1,g2,,gm)\n the answer is (b1+b2++bn)m+g1+g2++gm?max(b1,b2,,bn)(m?1)?max2(b1,b2,,bn)\n.\nMaximum, second maximum in the array b\n, minimum in the array g\n and the sums in the arrays b\n and g\n can be easily computed in the linear time. So, we have a linear time solution.",
    "hint": []
}