{
    "link": "https://codeforces.com//contest/1322/problem/A",
    "problemId": "555646",
    "problem_idx": "A",
    "shortId": "1322A",
    "contest_number": "1322",
    "problem_submissions": {
        "E": [
            72651847,
            72667619,
            72663863,
            81989702,
            73455963,
            72654927,
            72662345,
            72661386,
            72662000,
            72646344
        ],
        "D": [
            72644625,
            72640728,
            72645597,
            72646886,
            72650508,
            72648101,
            72647799,
            73117806,
            72646593,
            73115826,
            72647714,
            72648983,
            72649173,
            72652083,
            72650733,
            72645310,
            72649530,
            72653676,
            72654635,
            72652516
        ],
        "C": [
            72636777,
            72636963,
            72637518,
            72639394,
            72637388,
            72638096,
            72639734,
            73117801,
            72640343,
            72640613,
            72638032,
            72638943,
            72642117,
            72644813,
            72641527,
            72650551,
            72650396,
            72639973,
            72642914,
            72642962,
            72643894
        ],
        "B": [
            72630406,
            72634706,
            72633179,
            72634815,
            72634956,
            72641590,
            72633350,
            73117683,
            72635692,
            72635442,
            72633727,
            72635100,
            72639222,
            72636092,
            72637879,
            72655301,
            72636262,
            72636039,
            72637209,
            72638209,
            72636501
        ],
        "A": [
            72628149,
            72629253,
            72629705,
            72631540,
            72628375,
            72630668,
            72629135,
            73117511,
            72629708,
            72630674,
            72628794,
            72628291,
            72630330,
            72629133,
            72629728,
            72647587,
            72628383,
            72631203,
            72630004,
            72630007,
            72628407
        ],
        "F": [
            74191172,
            73465587,
            77378072,
            77728968
        ]
    },
    "name": "A. Unusual Competitions",
    "statement": "A bracketed sequence is called correct (regular) if by inserting \"+\" and\r\n\"1\" you can get a well-formed mathematical expression from it. For\r\nexample, sequences \"\", \"\" and \"\" are correct, while \"\", \"\" and \"\" are\r\nnot.The teacher gave Dmitry’s class a very strange task she asked every\r\nstudent to come up with a sequence of arbitrary length, consisting only\r\nof opening and closing brackets. After that all the students took turns\r\nnaming the sequences they had invented. When Dima’s turn came, he\r\nsuddenly realized that all his classmates got the correct bracketed\r\nsequence, and whether he got the correct bracketed sequence, he did not\r\nknow.Dima suspects now that he simply missed the word \"correct\" in the\r\ntask statement, so now he wants to save the situation by modifying his\r\nsequence slightly. More precisely, he can (possibly zero) perform the\r\noperation.The reorder operation consists of choosing an arbitrary\r\nconsecutive subsegment (substring) of the sequence and then reordering\r\nall the characters in it in an arbitrary way. Such operation takes l\r\nnanoseconds, where l is the length of the subsegment being reordered.\r\nIt’s easy to see that reorder operation doesn’t change the number of\r\nopening and closing brackets. For example for \"\" he can choose the\r\nsubstring \"\" and do reorder \"\" (this operation will take 2\r\nnanoseconds).Since Dima will soon have to answer, he wants to make his\r\nsequence correct as fast as possible. Help him to do this, or determine\r\nthat it’s impossible.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint n;\nchar s[1000005];\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\n\tint ss=0,sum=0;\n\tFor(i,1,n){\n\t\tint ns=(ss+(s[i]=='('?1:-1));\n\t\tif (ns<0||ss<0) ++sum;\n\t\tss=ns;\n\t}\n\tif (ss) puts(\"-1\");\n\telse printf(\"%d\\n\",sum);\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Unusual Competitions.json",
    "editorial_link": "https://codeforces.com//blog/entry/74148",
    "editorial": "Obviously, if the number of opening brackets is not equal to the number\r\nof closing ones, then since the described operation does not change\r\ntheir number, it will be impossible to get the correct sequence.\r\nOtherwise, if their numbers are equal, you can take the entire string\r\nand rearrange its characters so that the string becomes a right\r\nbracketed sequence, for example, .Let be a prefix balance on the first\r\ncharacters, that is, the difference between the number of opening and\r\nclosing brackets.Consider an index such that , , or , . Then, if the\r\ncharacter does not participate in any shuffle oeration, the resulting\r\nstring will have a th or th prefix balance negative, making the\r\nresulting sequence incorrect. This means that at least characters with\r\nsuch indexes must participate in at least one operation. It will be\r\nshown below how to use only them in shuffles to make a right bracketed\r\nsequence.Letâs represent this bracketed sequence as a polyline. It will\r\nstart at the point with coordinates , end at the point with coordinates\r\n, - th vector of this polyline will be equal to , if and otherwise. Then\r\nthe above-described indexes , which must participate in at least one\r\noperation are exactly all the segments below the line . To make the\r\nsequence correct, we will turn all consecutive segments of such brackets\r\nbackwards. Itâs not hard to see that the sequence will become correct.An\r\nexample of this conversion is shown below: Given sequence was After\r\nreshuffling 2 segments of total length 8, we can get a right bracketed\r\nsequence:\r\n",
    "hint": []
}