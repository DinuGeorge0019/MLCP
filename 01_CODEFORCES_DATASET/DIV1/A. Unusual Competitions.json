{"link": "https://codeforces.com//contest/1322/problem/A", "problemId": "555646", "problem_idx": "A", "shortId": "1322A", "contest_number": "1322", "problem_submissions": {"E": [72651847, 72667619, 72663863, 81989702, 73455963, 72654927, 72662345, 72661386, 72662000, 72646344], "D": [72644625, 72640728, 72645597, 72646886, 72650508, 72648101, 72647799, 73117806, 72646593, 73115826, 72647714, 72648983, 72649173, 72652083, 72650733, 72645310, 72649530, 72653676, 72654635, 72652516], "C": [72636777, 72636963, 72637518, 72639394, 72637388, 72638096, 72639734, 73117801, 72640343, 72640613, 72638032, 72638943, 72642117, 72644813, 72641527, 72650551, 72650396, 72639973, 72642914, 72642962, 72643894], "B": [72630406, 72634706, 72633179, 72634815, 72634956, 72641590, 72633350, 73117683, 72635692, 72635442, 72633727, 72635100, 72639222, 72636092, 72637879, 72655301, 72636262, 72636039, 72637209, 72638209, 72636501], "A": [72628149, 72629253, 72629705, 72631540, 72628375, 72630668, 72629135, 73117511, 72629708, 72630674, 72628794, 72628291, 72630330, 72629133, 72629728, 72647587, 72628383, 72631203, 72630004, 72630007, 72628407], "F": [74191172, 73465587, 77378072, 77728968]}, "name": "A. Unusual Competitions", "statement": "A bracketed sequence is called correct (regular) if by inserting \"+\" and\r\n\"1\" you can get a well-formed mathematical expression from it. For\r\nexample, sequences \"\", \"\" and \"\" are correct, while \"\", \"\" and \"\" are\r\nnot.The teacher gave Dmitry\u2019s class a very strange task she asked every\r\nstudent to come up with a sequence of arbitrary length, consisting only\r\nof opening and closing brackets. After that all the students took turns\r\nnaming the sequences they had invented. When Dima\u2019s turn came, he\r\nsuddenly realized that all his classmates got the correct bracketed\r\nsequence, and whether he got the correct bracketed sequence, he did not\r\nknow.Dima suspects now that he simply missed the word \"correct\" in the\r\ntask statement, so now he wants to save the situation by modifying his\r\nsequence slightly. More precisely, he can (possibly zero) perform the\r\noperation.The reorder operation consists of choosing an arbitrary\r\nconsecutive subsegment (substring) of the sequence and then reordering\r\nall the characters in it in an arbitrary way. Such operation takes l\r\nnanoseconds, where l is the length of the subsegment being reordered.\r\nIt\u2019s easy to see that reorder operation doesn\u2019t change the number of\r\nopening and closing brackets. For example for \"\" he can choose the\r\nsubstring \"\" and do reorder \"\" (this operation will take 2\r\nnanoseconds).Since Dima will soon have to answer, he wants to make his\r\nsequence correct as fast as possible. Help him to do this, or determine\r\nthat it\u2019s impossible.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint n;\nchar s[1000005];\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\n\tint ss=0,sum=0;\n\tFor(i,1,n){\n\t\tint ns=(ss+(s[i]=='('?1:-1));\n\t\tif (ns<0||ss<0) ++sum;\n\t\tss=ns;\n\t}\n\tif (ss) puts(\"-1\");\n\telse printf(\"%d\\n\",sum);\n} "], "input": "", "output": "", "tags": ["greedy"], "dificulty": "1300", "interactive": false}