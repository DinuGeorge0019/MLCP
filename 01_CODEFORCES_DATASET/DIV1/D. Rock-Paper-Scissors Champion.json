{
    "link": "https://codeforces.com//contest/1086/problem/D",
    "problemId": "273654",
    "problem_idx": "D",
    "shortId": "1086D",
    "contest_number": "1086",
    "problem_submissions": {
        "F": [
            47429292,
            47449995,
            47444202
        ],
        "E": [
            47422474,
            47423961,
            47424550,
            47426933,
            47428109,
            47426232,
            47427511,
            47426695,
            47427218,
            47427849,
            47427630,
            47511510,
            47428346,
            47425158,
            47429712,
            47428661,
            47421857,
            47429322,
            47440462,
            63950917
        ],
        "D": [
            47415205,
            47413571,
            47418835,
            47417078,
            47414191,
            47418078,
            47418526,
            47419686,
            47418954,
            47419229,
            47421725,
            47466322,
            47418774,
            47416004,
            47420225,
            47422460,
            47411471,
            47420807,
            47421473,
            47423600,
            47420881
        ],
        "C": [
            47410346,
            47408923,
            47412203,
            47411518,
            47409578,
            47407257,
            47412943,
            47414708,
            47412730,
            47413883,
            47416006,
            47414439,
            47428921,
            47417547,
            47419740,
            47412059,
            47415581,
            47415787
        ],
        "B": [
            47402010,
            47400574,
            47400073,
            47401453,
            47402762,
            47411548,
            47405929,
            47406096,
            47405616,
            47407353,
            47404186,
            47400750,
            47404258,
            47404681,
            47402882,
            47426003,
            47408582,
            47404099,
            47404538,
            47406586
        ],
        "A": [
            47400483,
            47400094,
            47413170,
            47400357,
            47400599,
            47410258,
            47403179,
            47403378,
            47401193,
            47402951,
            47401486,
            47403915,
            47400561,
            47403260,
            47400323,
            47425175,
            47409292,
            47400702,
            47401450,
            47402988
        ]
    },
    "name": "D. Rock-Paper-Scissors Champion",
    "statement": "n players are going to play a rock-paper-scissors tournament. As you\r\nprobably know, in a one-on-one match of rock-paper-scissors, two players\r\nchoose their shapes independently. The outcome is then determined\r\ndepending on the chosen shapes: \"paper\" beats \"rock\", \"rock\" beats\r\n\"scissors\", \"scissors\" beat \"paper\", and two equal shapes result in a\r\ndraw.At the start of the tournament all players will stand in a row,\r\nwith their numbers increasing from 1 for the leftmost player, to n for\r\nthe rightmost player. Each player has a pre-chosen shape that they will\r\nuse in every game throughout the tournament. Here’s how the tournament\r\nis conducted: If there is only one player left, he is declared the\r\nchampion. Otherwise, two adjacent players in the row are chosen\r\narbitrarily, and they play the next match. The losing player is\r\neliminated from the tournament and leaves his place in the row (with his\r\nformer neighbours becoming adjacent). If the game is a draw, the losing\r\nplayer is determined by a coin toss.The organizers are informed about\r\nall players’ favoured shapes. They wish to find out the total number of\r\nplayers who have a chance of becoming the tournament champion (that is,\r\nthere is a suitable way to choose the order of the games and manipulate\r\nthe coin tosses). However, some players are still optimizing their\r\nstrategy, and can inform the organizers about their new shapes. Can you\r\nfind the number of possible champions after each such request?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nstruct Tree {\n  int Base;\n  vector<int> data;\n\n  Tree(int N) : Base(1) {\n    while (Base < N + 2) { Base *= 2; }\n    data.resize(Base * 2);\n  }\n\n  void Add(int v, int p) {\n    v += Base;\n    while (v) {\n      data[v] += p;\n      v /= 2;\n    }\n  }\n\n  int GetSum(int L, int R) {\n    if (L > R) { return 0; }\n    L += Base; R += Base;\n    if (L == R) { return data[L]; }\n    int ans = data[L] + data[R];\n\n    while (L / 2 != R / 2) {\n      if (L % 2 == 0) { ans += data[L + 1]; }\n      if (R % 2 == 1) { ans += data[R - 1]; }\n      L /= 2; R /= 2;\n    }\n    return ans;\n  }\n};\n\nint N, Q;\nVI cur_setup;\nset<int> all_vals[3];\nint mapping[256];\nvector<Tree> trees;\n\nint GetResult() {\n  int ans = N;\n\n  for (int type : {0, 1, 2}) {\n    const int winning = (type + 1) % 3;\n    const int losing = (type + 2) % 3;\n\n    if (!all_vals[losing].empty()) {\n      if (all_vals[winning].empty()) {\n        ans -= SZ(all_vals[type]);\n      } else {\n        const int first_lose = *all_vals[losing].begin();\n        const int last_lose = *all_vals[losing].rbegin();\n        const int first_win = *all_vals[winning].begin();\n        const int last_win = *all_vals[winning].rbegin();\n\n        if (first_lose < first_win) {\n          ans -= trees[type].GetSum(first_lose, first_win);\n        }\n        if (last_lose > last_win) {\n          ans -= trees[type].GetSum(last_win, last_lose);\n        }\n      }\n\n    }\n  }\n  return ans;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> Q;\n  mapping[(int)'R'] = 0;\n  mapping[(int)'S'] = 1;\n  mapping[(int)'P'] = 2;\n\n  trees.resize(3, Tree(N + 2));\n\n  for (int i = 0; i < N; ++i) {\n    char ch;\n    cin >> ch;\n    const int val = mapping[(int)ch];\n    trees[val].Add(i, 1);\n    all_vals[val].insert(i);\n    cur_setup.PB(val);\n  }\n\n  cout << GetResult() << \"\\n\";\n\n  for (int i = 0; i < Q; ++i) {\n    int pos;\n    char ch;\n    cin >> pos >> ch;\n    --pos;\n    const int old_val = cur_setup[pos];\n    const int new_val = mapping[(int)ch];\n\n    debug(pos, old_val, new_val);\n\n    trees[old_val].Add(pos, -1);\n    all_vals[old_val].erase(pos);\n    trees[new_val].Add(pos, 1);\n    all_vals[new_val].insert(pos);\n    cur_setup[pos] = new_val;\n\n    cout << GetResult() << \"\\n\";\n    debug(cur_setup);\n#ifdef LOCAL\n    for (int j = 0; j < 3; ++j) {\n      debug(vector<int>(ALL(all_vals[j])));\n    }\n#endif\n  }\n\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Rock-Paper-Scissors Champion.json",
    "editorial_link": "https://codeforces.com//blog/entry/64078",
    "editorial": "First, letâs determine which players can win in a given configuration.\r\nIf all players have the same shape, then everyone can win. If there are\r\nonly two kinds of shapes, then one shape always loses, and everyone with\r\nthe other shape can win. Letâs now assume there are all three shapes\r\npresent. If a player can win, then they have to independently eliminate\r\neveryone to either side. It suffices to determine if can win everyone to\r\ntheir left (the other side can be treated symmetrically).Suppose that\r\nthe player has the shape (all the other cases are similar). We will show\r\nthat can eliminate everyone to the left if and only if two conditions\r\nhold: there is no to the left of ; there is at least one to the left of\r\n.Indeed, if both of these are true, there is nothing stopping a from\r\neliminating . Otherwise, if there are no to the left of , he can\r\npotentially win everyone there.Finally, suppose that there is an to the\r\nleft of . Hereâs how can eliminate everyone to the left. First,\r\neliminate all âs as follows: locate the closest pair of and , bring them\r\ntogether by eliminating all âs in between with the , then eliminate the\r\n. When weâve eiliminated all âs this way, we are left with the previous\r\ncase (no âs).Now, how to deal with modifications? Assume that there are\r\ncurrently all three shapes present (otherwise we can easily find the\r\nanswer as described at the start). How many âs can not win (similar for\r\nâs and âs)? According to our criterion, all âs losing because they can\r\nnot eliminate their respective left-hand sides are located between and ,\r\nwhere and are positions of the first and (that is, when , otherwise\r\nthere are no âs losing this way). A similar condition applies to the âs\r\nlosing because of the right-hand side. Now we simply count the number of\r\nâs in these ranges and subtract them from the total. Note that we can\r\nnever subtract an twice since there is at one on one of its sides.It now\r\nsuffices to use any data structure that supports range summing and\r\nfinding extreme values in a set, with modifications. For the range\r\nsumming we may use a Fenwick tree (BIT) or a segment tree, and for\r\nextreme values an will suffice. All operations we need take time, hence\r\neach modification and answer takes time.\r\n",
    "hint": []
}