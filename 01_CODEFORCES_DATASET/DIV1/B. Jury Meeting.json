{
    "link": "https://codeforces.com//contest/853/problem/B",
    "problemId": "121089",
    "problem_idx": "B",
    "shortId": "853B",
    "contest_number": "853",
    "problem_submissions": {
        "D": [
            30147648,
            30145874,
            30152169,
            30145670,
            30147401,
            30148548,
            30157869,
            30157814,
            30157512,
            30150989,
            30149728,
            30151353,
            30151549,
            30150847,
            30147708,
            30168803,
            30167984,
            30151241,
            30151140,
            30151931,
            30151709,
            30155800,
            30154094,
            30151955
        ],
        "C": [
            30142518,
            30148496,
            30147073,
            30143792,
            30144399,
            30146037,
            30145612,
            30146271,
            30147784,
            30146395,
            30148182,
            30151583,
            30168390,
            30147533,
            30148448,
            30148036,
            30147775,
            30144847,
            30147101,
            30148563
        ],
        "B": [
            30137358,
            30139471,
            30141499,
            30138298,
            30137334,
            30139875,
            30139930,
            30139800,
            30141449,
            30137864,
            30144203,
            30143376,
            30142744,
            30143145,
            30140773,
            30144005,
            30140202,
            30140453,
            30142525
        ],
        "A": [
            30133427,
            30134359,
            30136395,
            30133742,
            30132639,
            30132563,
            30134311,
            30135028,
            30134993,
            30133338,
            30136720,
            30135878,
            30134302,
            30137681,
            30134274,
            30133388,
            30133609,
            30133814,
            30134640
        ],
        "E": [
            30179221,
            30179071,
            31229560,
            30173059
        ]
    },
    "name": "B. Jury Meeting",
    "statement": "Country of Metropolia is holding Olympiad of Metrpolises soon. It mean\r\nthat all jury members of the olympiad should meet together in Metropolis\r\n(the capital of the country) for the problem preparation process.There\r\nare cities consecutively numbered from to . City is Metropolis that is\r\nthe meeting point for all jury members. For each city from to there is\r\nexactly one jury member living there. Olympiad preparation is a long and\r\ndemanding process that requires days of work. For all of these days each\r\nof the jury members should be present in Metropolis to be able to work\r\non problems.You know the flight schedule in the country (jury members\r\nconsider themselves important enough to only use flights for\r\ntransportation). All flights in Metropolia are either going to\r\nMetropolis or out of Metropolis. There are no night flights in\r\nMetropolia, or in the other words, plane always takes off at the same\r\nday it arrives. On his arrival day and departure day jury member is not\r\nable to discuss the olympiad. All flights in Megapolia depart and arrive\r\nat the same day.Gather everybody for days in the capital is a hard\r\nobjective, doing that while spending the minimum possible money is even\r\nharder. Nevertheless, your task is to arrange the cheapest way to bring\r\nall of the jury members to Metrpolis, so that they can work together for\r\ndays and then send them back to their home cities. Cost of the\r\narrangement is defined as a total cost of tickets for all used flights.\r\nIt is allowed for jury member to stay in Metropolis for more than days.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n#define mp make_pair\n\nconst ll INF = (ll)1e12;\nconst int N = (int)1e6 + 10;\nint n, m, k;\nll a[N];\nll b[N];\nll c[N];\nll ANS = INF * N;\nvector<pli> d[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\twhile(m--) {\n\t\tint t, v, u;\n\t\tll w;\n\t\tscanf(\"%d%d%d%lld\", &t, &v, &u, &w);\n\t\tif (v == 0)\n\t\t\tv = -u;\n\t\td[t].push_back(mp(w, v));\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\ta[i] = INF;\n\tfor (int i = 0; i < N; i++)\n\t\tb[i] = c[i] = INF;\n\tll val = n * INF;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (pli t : d[i]) {\n\t\t\tif (t.second < 0) continue;\n\t\t\tint id = t.second;\n\t\t\tll w = t.first;\n\t\t\tif (w >= a[id]) continue;\n\t\t\tval -= a[id];\n\t\t\ta[id] = w;\n\t\t\tval += a[id];\n\t\t}\n\t\tb[i] = val;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\ta[i] = INF;\n\tval = n * INF;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tfor (pli t : d[i]) {\n\t\t\tif (t.second > 0) continue;\n\t\t\tint id = -t.second;\n\t\t\tll w = t.first;\n\t\t\tif (w >= a[id]) continue;\n\t\t\tval -= a[id];\n\t\t\ta[id] = w;\n\t\t\tval += a[id];\n\t\t}\n\t\tc[i] = val;\n\t}\n\tfor (int i = 0; i + k + 1 < N; i++)\n\t\tANS = min(ANS, b[i] + c[i + k + 1]);\n\tif (ANS >= INF)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tprintf(\"%lld\\n\", ANS);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Jury Meeting.json",
    "editorial_link": "https://codeforces.com//blog/entry/54368",
    "editorial": "Obviously, each member of the jury needs to buy exactly two tickets to\r\nthe capital and back. Sort all flights by the day of departure. Now go\r\nthrough flights to the capital (forward flights) and one by one assume\r\nit is the last forward flight in answer (let\u00e2\u0080\u0099s say it is scheduled on\r\nday ). Thus you are assuming that all forward flights are contained in\r\nsome fixed prefix of flights. Make sure that there is at least one\r\nforward flight for every jury member in this prefix and find the\r\ncheapest forward flight among them for every person. All return flights\r\nwe are interested in are contained in the suffix of flights list such\r\nthat every flight\u00e2\u0080\u0099s departure date is at least . Take similar steps:\r\nmake sure that there is at least one return flight for every jury member\r\nin this suffix and find the cheapest return flight among them for every\r\nperson as well. Select minimal cost among these variants or find out\r\nthat the problem has no solution. Expected complexity: or .Just as the\r\nboundary of considered prefix moves right, the boundary of considered\r\nsuffix moves right as well. This suggests that the problem could be\r\nsolved by the two pointers method. Assume you are storing minimum\r\nforward flight\u00e2\u0080\u0099s cost on current prefix (infinity if no flight exists)\r\nfor every person, and you are storing multiset (ordered by cost) of all\r\nreturn flights on current suffix for each person as well. To proceed\r\nnext prefix and conforming suffix do the following: Move prefix boundary\r\nto the next forward flight. If its cost is less than minimum forward\r\nflight\u00e2\u0080\u0099s cost from that city, then you could improve total cost:\r\ndecrease it by and set to since it\u00e2\u0080\u0099s new minimal cost. Move suffix\r\nboundary to the next backward flight until there is such flight exists\r\nand it departure date difference with prefix boundary departure date is\r\nunder . While moving suffix boundary, keep return flights multisets\r\nconsistent: remove boundary flight right before moving that boundary to\r\nthe next flight. Also check out if you are removing cheapest flight from\r\nmultiset. If it is so, minimal flight cost for that city changed as well\r\nas total cost: it increases by difference between old minimal cost and\r\nnew minimal cost. Keep in mind that if you are removing last flight from\r\nmultiset, then there is no more appropriate return flight for this city\r\nand you should terminate the process. Proceed these steps moving\r\nboundaries to the right until the process terminates. In this way you\u00e2\u0080\u0099ve\r\nreviewed the same prefixes and corresponding suffixes as in slower\r\nsolution described above. Expected complexity: .\r\n"
}