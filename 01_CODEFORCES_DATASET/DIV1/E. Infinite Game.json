{"link": "https://codeforces.com//contest/1785/problem/E", "problemId": "1767288", "problem_idx": "E", "shortId": "1785E", "contest_number": "1785", "problem_submissions": {"F": [192340988, 192367706, 192347284, 192344077, 192349198, 192347771, 192385993, 192336126, 192406311, 192343375, 192348787, 192366544, 192344262, 192411258, 192345259, 192363821, 192484658], "E": [192334775, 192378839, 192330680, 192327219, 192332119, 192339722, 192385982, 192341740, 192412077, 192337184, 192336634, 192325309, 192324682, 192330314, 192339341, 192328941, 192342934, 192342640, 192343285, 192338492, 192348718], "D": [192309677, 192304720, 192308363, 192312353, 192300737, 192385972, 192323435, 192411822, 192411698, 192411631, 192411452, 192307092, 192297940, 192289422, 192305735, 192292206, 192306351, 192303021, 192324811, 192312541, 192301962, 192316529, 192316093, 192321567, 192314574], "C": [192301226, 192367208, 192300659, 192294893, 192304774, 192305847, 192385966, 192316174, 192318962, 192301773, 192292324, 192299527, 193510779, 192315363, 192293483, 192308504, 192291605, 192310063, 192307486, 192299043, 192314808, 192308858], "B": [192291042, 192291589, 192316742, 192291514, 192291590, 192385951, 192288659, 192292597, 192289761, 192297426, 192300042, 192305089, 192297247, 192288814, 192295447, 192337551, 192290254, 192297732, 192303838, 192303907, 192291091], "A": [192284331, 192283441, 192283155, 192282660, 192283131, 192385935, 192282844, 192284622, 192283277, 192290652, 192292611, 192296096, 192286915, 192282931, 192283418, 192285228, 192283044, 192283110, 192282987, 192288048, 192282867]}, "name": "E. Infinite Game", "statement": "Alice and Bob are playing an infinite game consisting of . Each set\r\nconsists of . In each round, one of the players wins. The first player\r\nto win two rounds in a set wins this set. Thus, a set always ends with\r\nthe score of 2:0 or 2:1 in favor of one of the players.Let\u2019s call a a\r\nfinite string s consisting of characters \u201d and \u201d. Consider an infinite\r\nstring formed with repetitions of string s: sss\r\nldots Suppose that Alice and Bob play rounds according to this infinite\r\nstring, left to right. If a character of the string sss\r\nldots is \u201d, then Alice wins the round; if it\u2019s \u201d, Bob wins the round. As\r\nsoon as one of the players wins two rounds, the set ends in their favor,\r\nand a new set starts from the next round.Let\u2019s define a_i as the number\r\nof sets won by Alice among the first i sets while playing according to\r\nthe given scenario. Let\u2019s also define r as the limit of ratio\r\nfrac{a_i}{i} as i\r\nrightarrow\r\ninfty. If r >\r\nfrac{1}{2}, we\u2019ll say that scenario s is . If r =\r\nfrac{1}{2}, we\u2019ll say that scenario s is . If r <\r\nfrac{1}{2}, we\u2019ll say that scenario s is .You are given a string s\r\nconsisting of characters \u201d, \u201d, and \u201d. Consider all possible ways of\r\nreplacing every \u201d with \u201d or \u201d to obtain a string consisting only of\r\ncharacters \u201d and \u201d. Count how many of them result in a scenario winning\r\nfor Alice, how many result in a tied scenario, and how many result in a\r\nscenario winning for Bob. Print these three numbers modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> add(vector<num> a, vector<num> b){\n\tfor(int i = 0; i < a.size(); i++) a[i] += b[i];\n\treturn a;\n}\n\nvector<num> solve(string s){\n\tif(s.size() == 1){\n\t\tif(s == \"a\") return {1, 0, 0};\n\t\tif(s == \"b\") return {0, 0, 1};\n\t\tif(s == \"?\") return {1, 0, 1};\n\t}\n\tif(s[0] == '?'){\n\t\tstring sa = s;\n\t\tstring sb = s;\n\t\tsa[0] = 'a'; sb[0] = 'b';\n\t\treturn add(solve(sa), solve(sb));\n\t}\n\tif(s[1] == '?'){\n\t\tstring sa = s;\n\t\tstring sb = s;\n\t\tsa[1] = 'a'; sb[1] = 'b';\n\t\treturn add(solve(sa), solve(sb));\n\t}\n\tvector<num> ans(3, 0);\n\tauto pack = [&](tuple<int, array<int, 3>, array<int, 2>> state) -> int {\n\t\tauto [score, f, pc] = state;\n\t\tint a = score + 300;\n\t\tfor(int x : f) a = 3 * a + x;\n\t\tfor(int c : pc) a = 2 * a + c;\n\t\treturn a;\n\t};\n\tauto unpack = [&](int a) -> tuple<int, array<int, 3>, array<int, 2>> {\n\t\tint score;\n\t\tarray<int, 3> f;\n\t\tarray<int, 2> pc;\n\t\tfor(int i = 1; i >= 0; i--){\n\t\t\tpc[i] = a % 2;\n\t\t\ta /= 2;\n\t\t}\n\t\tfor(int i = 2; i >= 0; i--){\n\t\t\tf[i] = a % 3;\n\t\t\ta /= 3;\n\t\t}\n\t\tscore = a - 300;\n\t\treturn {score, f, pc};\n\t};\n\tint C = 90000;\n\tfor(int mask = 0; mask < 8; mask++){\n\t\tif(mask == 0) continue;\n\t\tvector<num> dp(C, 0);\n\t\t// [score] [f from 0, 1, 2] s[i-2] s[i-1]\n\t\t{\n\t\t\tint score = 0;\n\t\t\tint f0 = 0;\n\t\t\tif(s[0] == s[1]){\n\t\t\t\tf0 = 2;\n\t\t\t\tscore += (s[0] == 'a' ? 1 : -1) * (((mask >> 0) & 1) ? 1 : 0);\n\t\t\t}\n\t\t\tdp[pack({score, {f0, 1, 2}, {s[0] - 'a', s[1] - 'a'}})] += 1;\n\t\t}\n\t\tfor(int c = 2; c < (int)s.size(); c++){\n\t\t\tvector<num> ndp(C, 0);\n\t\t\tfor(char x : {'a', 'b'}){\n\t\t\t\tint xi = x - 'a';\n\t\t\t\tif(s[c] != '?' && s[c] != x) continue;\n\t\t\t\tfor(int state = 0; state < dp.size(); state++){\n\t\t\t\t\tnum cnt = dp[state];\n\t\t\t\t\tif(cnt == 0) continue;\n\t\t\t\t\tauto [score, f, opc] = unpack(state);\n\t\t\t\t\t// array<int, 3> pc {opc[0], opc[1], x - 'a'};\n\t\t\t\t\tfor(int b = 0; b < 3; b++){\n\t\t\t\t\t\tif(f[b] == 0){\n\t\t\t\t\t\t\tif(opc[0] == opc[1]){\n\t\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscore += (xi == 0 ? 1 : -1) * (((mask >> b) & 1) ? 1 : 0);\n\t\t\t\t\t\t\t\tf[b] = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(f[b] == 1){\n\t\t\t\t\t\t\tif(opc[1] == xi){\n\t\t\t\t\t\t\t\tscore += (xi == 0 ? 1 : -1) * (((mask >> b) & 1) ? 1 : 0);\n\t\t\t\t\t\t\t\tf[b] = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf[b]--;\n\t\t\t\t\t}\n\t\t\t\t\tndp[pack({score, f, {opc[1], xi}})] += cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = ndp;\n\t\t}\n\t\tfor(int state = 0; state < dp.size(); state++){\n\t\t\tnum cnt = dp[state];\n\t\t\tif(cnt == 0) continue;\n\t\t\tauto [score, f, pc] = unpack(state);\n\t\t\tvector<int> go(3);\n\t\t\tfor(int b = 0; b < 3; b++){\n\t\t\t\tif(f[b] == 2){\n\t\t\t\t\tgo[b] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tvector<int> cur;\n\t\t\t\t\tfor(int x = f[b]; x < 2; x++){\n\t\t\t\t\t\tcur.push_back(pc[x]);\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcur.push_back(s[i] - 'a');\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(cur.size() >= 3 || cur[0] == cur[1]){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tscore += (cur.back() == 0 ? 1 : -1) * (((mask >> b) & 1) ? 1 : 0);\n\t\t\t\t\tif(s.size() == 2 && i == 2) i = 0;\n\t\t\t\t\tgo[b] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = go[go[go[go[0]]]];\n\t\t\tif(!((mask >> r) & 1)) continue;\n\t\t\tint c = r;\n\t\t\tint real_mask = 0;\n\t\t\twhile(true){\n\t\t\t\treal_mask ^= (1 << c);\n\t\t\t\tc = go[c];\n\t\t\t\tif(c == r) break;\n\t\t\t}\n\t\t\tif(real_mask != mask) continue;\n\t\t\tint which;\n\t\t\tif(score > 0){\n\t\t\t\twhich = 0;\n\t\t\t} else if(score == 0){\n\t\t\t\twhich = 1;\n\t\t\t} else if(score < 0){\n\t\t\t\twhich = 2;\n\t\t\t} else assert(false);\n\t\t\tans[which] += cnt;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tstring s;\n\tcin >> s;\n\tvector<num> ans = solve(s);\n\tfor(num x : ans) cout << x << '\\n';\n}"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "dp", "games"], "dificulty": "3100", "interactive": false}