{
    "link": "https://codeforces.com//contest/301/problem/C",
    "problemId": "2971",
    "problem_idx": "C",
    "shortId": "301C",
    "contest_number": "301",
    "problem_submissions": {
        "E": [
            3682464,
            3681114,
            4247515
        ],
        "D": [
            3677749,
            3677901,
            3677912,
            3678115,
            3677526,
            3679062,
            3677723,
            3677856,
            3679979,
            3679661,
            3680028,
            3677527,
            3675796,
            3683550,
            3682695,
            3682463,
            3677874,
            3677050,
            3678347,
            3678222,
            3680032
        ],
        "B": [
            3675021,
            3674605,
            3676912,
            3676771,
            3675890,
            3677633,
            3681284,
            3684667,
            3684661,
            3684653,
            3684635,
            3678354,
            3678161,
            3680771,
            3678425,
            3681027,
            3676146,
            3677734,
            3676031,
            3675130
        ],
        "A": [
            3674025,
            3673473,
            3675526,
            3674656,
            3679541,
            3673757,
            3674334,
            3676412,
            3677059,
            3674545,
            3673945,
            3673341,
            3675089,
            3673194,
            3673129,
            3673585,
            3673171,
            3675681
        ],
        "C": [
            3679265,
            3679801,
            3681253,
            3680718,
            3680819,
            3680781,
            3681151,
            3681956,
            3682034,
            3680652,
            3688897,
            3683565,
            3679128,
            3680822
        ]
    },
    "name": "C. Yaroslav and Algorithm",
    "statement": "Yaroslav likes algorithms. We\u2019ll describe one of his favorite\r\nalgorithms. The algorithm receives a string as the input. We denote this\r\ninput string as . The algorithm consists of some number of command.\r\nommand number looks either as , or as , where and are some possibly\r\nempty strings of length at most , consisting of digits and characters\r\n\"\". At each iteration, the algorithm looks for a command with the\r\nminimum index , such that occurs in as a substring. If this command is\r\nnot found the algorithm terminates. Let\u2019s denote the number of the found\r\ncommand as . In string the first occurrence of the string is replaced by\r\nstring . If the found command at that had form , then the algorithm\r\ncontinues its execution and proceeds to the next iteration. Otherwise,\r\nthe algorithm terminates. The value of string after algorithm\r\ntermination is considered to be the output of the algorithm. Yaroslav\r\nhas a set of positive integers, he needs to come up with his favorite\r\nalgorithm that will increase each of the given numbers by one. More\r\nformally, if we consider each number as a string representing the\r\ndecimal representation of the number, then being run on each of these\r\nstrings separately, the algorithm should receive the output string that\r\nis a recording of the corresponding number increased by one.Help\r\nYaroslav.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:128777216\")\n\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <string>\n#include <map>\n#include <set>\n#include <iostream>\n#include <functional>\n#include <numeric>\n#include <sstream>\n#include <exception>\n#include <cassert>\n\ntypedef long long i64;\ntypedef unsigned int u32;\nconst int null = 0;\n\nusing namespace std;\n\ntemplate<class T> int size(const T &a) {\n\treturn int(a.size());\n}\ntemplate<class T> T abs(const T &a) {\n\treturn (a < 0? -a: a);\n}\ntemplate<class T> T sqr(const T &a) {\n\treturn a * a;\n}\n\n#define all(a) a.begin(),a.end()\n\nint main() {\n#ifdef pperm\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"input.txt\", \"w\", stdout);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tfor (int i = 0; i < 9; i++) {\n\t\tprintf(\"%d??<>%d\\n\", i, i + 1);\n\t}\n\tprintf(\"9??>>??0\\n\");\n\tprintf(\"??<>1\\n\");\n\tfor (int i = 0; i < 10; i++) {\n\t\tprintf(\"?%d>>%d?\\n\", i, i);\n\t}\n\tprintf(\"?>>??\\n\");\n\tprintf(\">>?\\n\");\n#ifdef pperm\n\tfprintf(stderr, \"\\n%.3lf\\n\", clock() / double(CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Yaroslav and Algorithm.json",
    "editorial_link": "https://codeforces.com//blog/entry/7560",
    "editorial": "We will use ? as iterator. In the begin we will set ? before the number. Then we will move it to the end of the string. Then we will change ? to ?? and we will move it to the begin, while we have 9 before ??. If we have another digit, we just increase it, and finish the algorithm. If we have ?? at the begin, we change it to 1, and end the algorithm."
}