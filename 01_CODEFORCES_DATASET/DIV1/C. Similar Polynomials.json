{"link": "https://codeforces.com//contest/1817/problem/C", "problemId": "1897391", "problem_idx": "C", "shortId": "1817C", "contest_number": "1817", "problem_submissions": {"F": [204497444, 204371393, 203993098, 203987643, 204188728, 204003142, 203943098, 204213507], "D": [203955544, 203961086, 203937236, 203945800, 203945643, 203942818, 203943723, 203947591, 203989196, 203948036, 204052212, 203947419, 203952089, 203947882, 203954628], "A": [203949751, 203917796, 203915319, 203915702, 203915256, 203915135, 203915119, 203915216, 203933837, 203916532, 203915895, 203917033, 203915580, 203915390, 203917321, 203916497, 203915656, 203929967, 203917829], "E": [203947509, 203943737, 203948086, 203949930, 204001172, 203962099, 204158074, 203951990, 204009291, 203987561, 203984105, 203980085, 203953471, 203990042, 203976606, 203976302, 203953675, 204066570, 204065539, 204106022], "B": [203928063, 203919631, 203920186, 203920581, 203923300, 203919216, 203918930, 203922691, 203924157, 203921090, 203921763, 203924664, 203924354, 203989898, 203930016, 203924048, 203922828, 203936658, 203924723], "C": [203916741, 203929205, 203922679, 203923849, 203928212, 203926222, 203931210, 203933759, 203932269, 203931148, 203930247, 203931616, 203931791, 203922648, 203924454, 204016237, 203932091, 203930473, 203925061, 203933416]}, "name": "C. Similar Polynomials", "statement": "A polynomial A(x) of degree d is an expression of the form A(x) = a_0 +\r\na_1 x + a_2 x^2 +\r\ndots + a_d x^d, where a_i are integers, and a_d\r\nneq 0. Two polynomials A(x) and B(x) are called similar if there is an\r\ninteger s such that for any integer x it holds that B(x)\r\nequiv A(x+s)\r\npmod{10^9+7}. For two similar polynomials A(x) and B(x) of degree d,\r\nyou\u2019re given their values in the points x=0,1,\r\ndots, d modulo 10^9+7.Find a value s such that B(x)\r\nequiv A(x+s)\r\npmod{10^9+7} for all integers x.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\nconst int N = 3e6;\nint fact[N];\nint invfact[N];\n\nint binom(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  return fact[n] * (1LL*invfact[k]*invfact[n-k] % MOD) % MOD;\n}\n\nint inversemod(int p, int q) {\n  // assumes p > 0\n  // https://codeforces.com/blog/entry/23365\n  return (p > 1 ? q-1LL*inversemod(q%p, p)*q/p : 1);\n}\n\npair<int, int> calc(vector<int>& a) {\n  pair<int, int> ans;\n  int n = (int)a.size()-1;\n  for (int i = 0; i < n; i++) {\n    ans.first = (ans.first+(i&1 ? -1LL : 1LL)*binom(n-1, i)*a[i]) % MOD;\n    ans.second = (ans.second+(i&1 ? -1LL : 1LL)*binom(n-1, i)*a[i+1]) % MOD;\n  }\n  return ans;\n}\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  fact[0] = 1;\n  for (int i = 1; i < N; i++) fact[i] = 1LL*i*fact[i-1] % MOD;\n  invfact[N-1] = inversemod(fact[N-1], MOD);\n  for (int i = N-1; i >= 1; i--) invfact[i-1] = 1LL*i*invfact[i] % MOD;\n  int n;\n  cin >> n;\n  vector<int> a(n+1), b(n+1);\n  for (int& x: a) cin >> x;\n  for (int& x: b) cin >> x;\n  auto [a0, a1] = calc(a);\n  auto [b0, b1] = calc(b);\n  int slope = (a1-a0) % MOD;\n  if (slope < 0) slope += MOD;\n  int ans = 1LL*(b0-a0)*inversemod(slope, MOD) % MOD;\n  if (ans < 0) ans += MOD;\n  cout << ans << '\\n';\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "math"], "dificulty": "2400", "interactive": false}