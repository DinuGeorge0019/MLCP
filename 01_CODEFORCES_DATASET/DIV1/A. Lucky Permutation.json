{"link": "https://codeforces.com//contest/286/problem/A", "problemId": "2765", "problem_idx": "A", "shortId": "286A", "contest_number": "286", "problem_submissions": {"E": [3390546, 3391792, 3395790, 3391048, 3391288, 3390752, 3393756, 3405899, 3968761, 3584732, 3395321, 3395288, 3395060, 17994831, 3469466, 3469320], "D": [3389279, 3388966, 3389901, 3389906, 3391845, 3389722, 3392796, 3388857, 3395013, 3392782, 3391848, 3410751], "C": [3387722, 3387213, 3387005, 3386396, 3389739, 3391778, 3386453, 3386344, 3393851, 3387073, 3388380, 3388932, 3386042, 3389551, 3388553, 3389696, 3389128], "B": [3386275, 3386079, 3392121, 3386991, 3387709, 3390895, 3385630, 3385043, 3386200, 3386745, 3386272, 3387033, 3387460, 3387793, 3388156], "A": [3385050, 3384757, 3384907, 3384734, 3386122, 3385898, 3384517, 3384557, 3387291, 3384991, 3385549, 3387419, 3387088, 3385205, 3386011, 3386619, 3386427]}, "name": "A. Lucky Permutation", "statement": "A permutation of size is the sequence , consisting of distinct integers,\r\neach of them is from to .A lucky permutation is such permutation , that\r\nany integer meets this condition .You have integer . Find some lucky\r\npermutation of size .\r\n", "solutions": ["#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nint res[110000];\n\nint main() {\n#ifdef __ASD__\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\twhile(cin>>n){\n\t\tif(n/2%2){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tres[n/2]=n/2;\n\t\tfor(int i=0;i<n/2;i+=2){\n\t\t\tres[i]=i+1;\n\t\t\tres[i+1]=n-i-1;\n\t\t\tres[n-i-1]=n-i-2;\n\t\t\tres[n-i-2]=i;\n\t\t}\n\t\tforn(i,n){\n\t\t\tcout<<res[i]+1<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "1400", "interactive": false}