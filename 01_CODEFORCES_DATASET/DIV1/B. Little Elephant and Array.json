{
    "link": "https://codeforces.com//contest/220/problem/B",
    "problemId": "1619",
    "problem_idx": "B",
    "shortId": "220B",
    "contest_number": "220",
    "problem_submissions": {
        "D": [
            2080540,
            2080418,
            2074895,
            2078075,
            2079217,
            2081403,
            2081824,
            2081006,
            2076381,
            2093601,
            2093590,
            3084971,
            2086233
        ],
        "E": [
            2078891,
            2078702,
            2081885,
            2081411,
            2081777,
            2080333,
            2079988,
            2077021,
            2081284,
            2080936,
            2080773,
            2080185,
            2080971,
            2082030,
            2080110,
            2081659,
            2081994,
            2086312,
            2082178
        ],
        "C": [
            2077244,
            2077402,
            2078300,
            2079325,
            2076073,
            2077207,
            2078341,
            2080109,
            2076476,
            2078366,
            2079100,
            2080050,
            2078605,
            2081663,
            2079424,
            2078933,
            2080721
        ],
        "B": [
            2074621,
            2083029,
            2082854,
            2073372,
            2075693,
            2075380,
            2073348,
            2074150,
            2075655,
            2074877,
            2074146,
            2076125,
            2083532,
            2074043,
            2074785,
            2086353,
            2077672,
            2098154,
            2098144,
            2076395,
            2075929,
            2074543
        ],
        "A": [
            2072304,
            2072260,
            2072332,
            2072289,
            2079727,
            2072355,
            2072380,
            2072450,
            2072425,
            2072416,
            2072763,
            2072261,
            2072442,
            2073395,
            2073046,
            2072395,
            2072278
        ]
    },
    "name": "B. Little Elephant and Array",
    "statement": "The Little Elephant loves playing with arrays. He has array , consisting\r\nof positive integers, indexed from 1 to . Letâ€™s denote the number with\r\nindex as . Additionally the Little Elephant has queries to the array,\r\neach query is characterised by a pair of integers and . For each query\r\nthe Little Elephant has to count, how many numbers exist, such that\r\nnumber occurs exactly times among numbers .Help the Little Elephant to\r\ncount the answers to all queries.\r\n",
    "solutions": [
        "// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint in[101000];\nint l[101000],r[101000];\nint cnt[101000];\nvector<int> qs[1010];\nint ans[101000];\ninline bool cmp(int a,int b){return r[a]<r[b];}\nint qq;\nint n;\ninline void add(int x){\n    if(x>n)return;\n    if(cnt[x]==x)qq--;\n    cnt[x]++;\n    if(cnt[x]==x)qq++;\n}\ninline void del(int x){\n    if(x>n)return;\n    if(cnt[x]==x)qq--;\n    cnt[x]--;\n    if(cnt[x]==x)qq++;\n}\nint main(){\n    int m,i,j,k;\n    scanf(\"%d%d\",&n,&m);\n    for(i=0;i<n;i++)scanf(\"%d\",&in[i]);\n    int sn=(int)(sqrt(n)+1);\n    for(i=0;i<m;i++){\n        scanf(\"%d%d\",&l[i],&r[i]);\n        l[i]--;r[i]--;\n        qs[l[i]/sn].push_back(i);\n    }\n    for(i=0;i<=n/sn;i++){\n        if(qs[i].size()==0)continue;\n        sort(qs[i].begin(),qs[i].end(),cmp);\n        memset(cnt,0,sizeof(cnt));\n        qq=0;\n        int ll=l[qs[i][0]],rr=r[qs[i][0]];\n        for(j=ll;j<=rr;j++)add(in[j]);\n        ans[qs[i][0]]=qq;\n        for(j=1;j<qs[i].size();j++){\n            int ii=qs[i][j];\n            int lll=l[ii],rrr=r[ii];\n            for(k=rr+1;k<=rrr;k++)add(in[k]);\n            if(lll<ll){\n                for(k=ll-1;k>=lll;k--)add(in[k]);\n            }else if(lll>ll){\n                for(k=ll;k<lll;k++)del(in[k]);\n            }\n            ll=lll;rr=rrr;\n            ans[ii]=qq;\n        }\n    }\n    for(i=0;i<m;i++)printf(\"%d\\n\",ans[i]);\n}\n// vim: fdm=marker:commentstring=\\ \\\"\\ %s:nowrap:autoread\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Little Elephant and Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/5177",
    "editorial": "This problem can be solve in simpler solution, but I will describe one.\r\nWe will solve this problem in offline. For each we should keep all the\r\nqueries that end in . Iterate that from 0 to . Also we need to keep some\r\narray such that for current will be the answer for query . To keep\r\ncorrect, before the processing all queries that end in , we need to\r\nupdate . Let be the current integer in , i. e. , and vector be the list\r\nof indices of previous occurences of (0-based numeration of vector).\r\nThen, if , you need to add to , because this position is now the first\r\n(from right) that contains exactly occurences of . After that, if , you\r\nneed to subtract from , in order to close current interval and cancel\r\nprevious. Finally, if , then you need additionally add to to cancel\r\nprevious close of the interval.\r\n",
    "hint": []
}