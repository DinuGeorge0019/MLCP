{
    "link": "https://codeforces.com//contest/607/problem/A",
    "problemId": "43758",
    "problem_idx": "A",
    "shortId": "607A",
    "contest_number": "607",
    "problem_submissions": {
        "E": [
            14958443,
            14961849,
            14961838,
            14961831,
            16737326
        ],
        "D": [
            14951724,
            14952244,
            14950470,
            14950039,
            14952208,
            14949972,
            14952659,
            14968005,
            14967954,
            14967922,
            14967912,
            14967907,
            14967903,
            14967896,
            14967707,
            14967669,
            14956925,
            14956428,
            14958812,
            14957599,
            14953577,
            14952372,
            14951711,
            14957330,
            14954653,
            14952137,
            14951821,
            14954577,
            14952711
        ],
        "C": [
            14947368,
            14953869,
            14954714,
            14954225,
            14954959,
            14954407,
            14957641,
            14951200,
            14952263,
            14949536,
            14956671,
            14955594,
            14955895,
            14951583,
            14957050
        ],
        "B": [
            14944943,
            14943843,
            14943439,
            14944195,
            14944079,
            14951944,
            14944759,
            14945484,
            14944543,
            14945215,
            14944778,
            14945950,
            14944649,
            14947158,
            14943778,
            14944962,
            14948034,
            14943374,
            14945989
        ],
        "A": [
            14941938,
            14942696,
            14942042,
            14943122,
            14941989,
            14950953,
            14942232,
            14942613,
            14942728,
            14942057,
            14942385,
            14946665,
            14948612,
            14942429,
            14941952,
            14943906,
            14943291,
            15059376,
            14942040,
            14942093
        ]
    },
    "name": "A. Chain Reaction",
    "statement": "There are beacons located at distinct positions on a number line. The\r\n-th beacon has position and power level . When the -th beacon is\r\nactivated, it destroys all beacons to its left (direction of decreasing\r\ncoordinates) within distance inclusive. The beacon itself is not\r\ndestroyed however. Saitama will activate the beacons one at a time from\r\nright to left. If a beacon is destroyed, it cannot be activated.Saitama\r\nwants Genos to add a beacon of all the existing beacons, with any\r\nposition and any power level, such that the least possible number of\r\nbeacons are destroyed. Note that Genos’s placement of the beacon means\r\nit will be the first beacon activated. Help Genos by finding the minimum\r\nnumber of beacons that could be destroyed.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 100000;\n\nint n;\npair<int, int> a[maxn + 5];\n\nint dep[maxn + 5];\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d\", &n);\n\tREP(i, 0, n) scanf(\"%d%d\", &a[i].x, &a[i].y);\n\tsort(a, a + n);\n\tREP(i, 0, n)\n\t{\n\t\tint tmp = lower_bound(a, a + n, mp(a[i].x - a[i].y, 0)) - a - 1;\n\t\tif (tmp < 0) dep[i] = 1;\n\t\telse dep[i] = dep[tmp] + 1;\n\t}\n\tprintf(\"%d\\n\", n - *max_element(dep, dep + n));\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Chain Reaction.json",
    "editorial_link": "https://codeforces.com//blog/entry/22256",
    "editorial": "It turns out that it is actually easier to compute the complement of the problem  the maximum number of objects not destroyed. We can subtract this from the total number of objects to obtain our final answer.\n\nWe can solve this problem using dynamic programming. Let dp[x] be the maximum number of objects not destroyed in the range [0,?x] given that position x is unaffected by an explosion. We can compute dp[x] using the following recurrence:\n\n\nNow, if we can place an object to the right of all objects with any power level, we can destroy some suffix of the (sorted list of) objects. The answer is thus the maximum number of destroyed objects objects given that we destroy some suffix of the objects first. This can be easily evaluated as\n\n\nSince this is the complement of our answer, our final answer is actually\n\n\nTime Complexity  O(max(ai)), Memory Complexity  O(max(ai))",
    "hint": []
}