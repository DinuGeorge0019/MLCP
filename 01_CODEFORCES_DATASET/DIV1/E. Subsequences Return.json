{
    "link": "https://codeforces.com//contest/497/problem/E",
    "problemId": "19575",
    "problem_idx": "E",
    "shortId": "497E",
    "contest_number": "497",
    "problem_submissions": {
        "E": [
            9174487,
            9174196,
            9175010,
            9199333,
            9175252,
            9176527,
            9176653,
            9180194
        ],
        "D": [
            9170679,
            9173274,
            9174804,
            9174751,
            9171031,
            9176067,
            9175754
        ],
        "C": [
            9168733,
            9168537,
            9168027,
            43565108,
            9170031,
            9168979,
            9168260,
            9169684,
            9168763,
            9174362,
            9172330,
            9171998,
            9173920,
            9168319,
            9168825,
            9168629,
            43565576,
            9168203
        ],
        "B": [
            9166459,
            9166265,
            9166436,
            9199442,
            9167203,
            9166878,
            9166797,
            9166926,
            9170793,
            9172501,
            9170015,
            9168743,
            9169417,
            9166154,
            9166746,
            9166737,
            9165998
        ],
        "A": [
            9164122,
            9164273,
            9164359,
            9164060,
            9163922,
            9164065,
            9163958,
            9164600,
            9164390,
            9164526,
            9164902,
            9167522,
            9163923,
            9163921,
            9164484,
            9163952
        ]
    },
    "name": "E. Subsequences Return",
    "statement": "Assume that equals the sum of digits of number in the -based notation.\r\nFor example, , .The sequence of integers is defined as . Your task is to\r\ncalculate the number of distinct of sequence . Calculate the answer\r\nmodulo .Sequence is called to be a of sequence , if there is a sequence\r\nof indices , such that , ..., . In particular, an empty sequence (i.e.\r\nthe sequence consisting of zero elements) is a subsequence of any\r\nsequence.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define ford(i,n) for (int i = int(n) - 1; i >= 0; --i)\n#define forv(i,v) for (auto i = v.begin(); i != v.end(); ++i)\n#define forr(i,v) for (auto i = v.end(); i != v.begin() && (--i, 1); )\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T> inline T abs (T x) {return x > T() ? x : -x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst ll mod = 1000000007;\n\nstruct Input {\n\tll n;\n\tint k;\n\t\n\tbool read () {\n\t\treturn cin >> n >> k;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tll ans;\n\t\n\tvoid write () {\n\t\tcout << ans << endl;\n\t}\n\t\n\tvirtual void solve () {}\n\t\n\tvirtual void clear () {\n\t\t*this = Data();\n\t}\n};\n\nstruct Solution: Data {\n\tint s;\n\t\n\tve<ve<ll> > mul (const ve<ve<ll> > &a, const ve<ve<ll> > &b) {\n\t\tve<ve<ll> > ans(s, ve<ll>(s, 0));\n\t\tforn (i, s) {\n\t\t\tforn (j, s) {\n\t\t\t\tforn (k, s) {\n\t\t\t\t\t(ans[i][j] += a[i][k] * b[k][j]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tve<ve<ll> > shift (const ve<ve<ll> > &a, int t) {\n\t\tve<ve<ll> > ans(s, ve<ll>(s));\n\t\tforn (i, k) {\n\t\t\tforn (j, k) {\n\t\t\t\tans[(i + t) % k][(j + t) % k] = a[i][j];\n\t\t\t}\n\t\t}\n\t\tforn (i, k) {\n\t\t\tans[k][(i + t) % k] = a[k][i];\n\t\t\tans[(i + t) % k][k] = a[i][k];\n\t\t}\n\t\tans[k][k] = a[k][k];\n\t\treturn ans;\n\t}\n\t\n\tint f (ll n) {\n\t\tint res = 0;\n\t\twhile (n) {\n\t\t\t(res += n % k) %= k;\n\t\t\tn /= k;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid solve () {\n\t\ts = k + 1;\n\t\tve<ve<ll> > a(s, ve<ll>(s, 0));\n\t\tforn (i, s) {\n\t\t\ta[i][i] = 1;\n\t\t}\n\t\ta[0][k] = 1;\n\t\ta[0][0] = 0;\n\t\ta[k][0] = mod - 1;\n\t\ta[k][k] = 2;\n\t\t\n\t\tve<ve<ll> > res(s, ve<ll>(s, 0));\n\t\tforn (i, s) {\n\t\t\tres[i][i] = 1;\n\t\t}\n\t\twhile (n) {\n\t\t\twhile (n % k) {\n\t\t\t\tres = mul(shift(a, f(n - 1)), res);\n\t\t\t\t--n;\n\t\t\t}\n\t\t\tve<ve<ll> > b = a;\n\t\t\tfor (int t = 1; t < k; ++t) {\n\t\t\t\ta = mul(a, shift(b, t));\n\t\t\t}\n\t\t\tn /= k;\n\t\t}\n\t\tdebug(res[k]);\n\t\tans = res[k][k];\n\t}\n\t\n\tvoid clear () {\n\t\t*this = Solution();\n\t}\n};\n\nSolution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\twhile (sol.read()) {\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n#else\n\tsol.read();\n\tsol.solve();\n\tsol.write();\n#endif\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "matrices"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Subsequences Return.json",
    "editorial_link": "https://codeforces.com/blog/entry/15208",
    "editorial": "Consider some string; how does one count the number of its distinct\r\nsubsequences? Let us append symbols to the string consequently and each\r\ntime count the number of subsequences that were not present before.\r\nLet\u00e2\u0080\u0099s append a symbol to a string ; in the string there are as many\r\nsubsequences that end in as there were subsequences in overall. Add all\r\nthese subsequences to the number of subsequnces of ; now each\r\nsubsequence is counted once, except for the subsequences that end in but\r\nwere already present in before; these are counted twice. Thus, the total\r\nnumber of subsequences in the new string is twice the total number of\r\nsubsequences in the old string minus the number of subsequences in the\r\nold string which end in . This leads us to the following solution: for\r\neach symbol store how many subsequences end in , denote . Append symbol\r\n; now becomes equal to the sum of all \u00e2\u0080\u0099s plus one (for the empty\r\nsubsequence), and all the other \u00e2\u0080\u0099s do not change. For example, consider\r\nthe first few symbols of the Thue-Morse sequence: (0, 0) ( 0 + 0 + 1 =\r\n1, 0) (1, 1 + 0 + 1 = 2) (1, 1 + 2 + 1 = 4) ( 1 + 4 + 1 = 6, 4) ... Let\r\nus put the values of in the coordinates of a vector, and also append a\r\ncoordinate which is always equal to 1. It is now clear that appending a\r\nsymbol to the string alters the vector as a multiplication by some\r\nmatrix. Let us assign a matrix for each symbol, and also for each string\r\nas a product of matrices for the symbols of the strings in that order.\r\nNow, consider the prefix of the sequence of length . Divide it into\r\nparts of length ; -th (-based) of these parts can be obtained from the\r\n-th one by adding modulo to all elements of the part. Let us count the\r\nmatrices (see above) for the prefixes of length , and also for all\r\nstrings that are obtained by adding to all of the prefixes\u00e2\u0080\u0099 elements;\r\ndenote such matrix . It is easy to see that if , then . This formula\r\nallows us to count for all and all from 0 to in time. Now, upon having\r\nall we can multiply some of them in the right order to obtain the matrix\r\nfor the prefix of the sequence of length . Unfortunately, this is not\r\nquite enough as the solution doesn\u00e2\u0080\u0099t fit the time limit yet. Here is one\r\nway to speed up sufficiently: note that the product in the formula can\r\nbe divided as shown: (if , take the second part to be empty). Count all\r\nthe \"prefixes\" and \"suffixes\" products of the set : , . Now . Thus, the\r\ncomputation of for all and a given can be done as computing all , using\r\nmatrix multiplications, and each is now can be found using one matrix\r\nmultiplication. Finally, the solution now works in time, which fits the\r\nlimits by a margin. Challenge: solve the problem for .\r\n"
}