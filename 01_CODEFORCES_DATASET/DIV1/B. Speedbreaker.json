{
    "link": "https://codeforces.com//contest/2018/problem/B",
    "problemId": "2905184",
    "problem_idx": "B",
    "shortId": "2018B",
    "contest_number": "2018",
    "problem_submissions": {
        "F1": [
            283240998,
            283223838,
            283219415,
            283236306,
            283222916,
            283217600,
            283233290,
            283231886,
            283231256,
            283232151,
            283229995,
            283237003,
            283235478,
            283237574,
            283236444,
            283230142,
            283243735,
            283243123,
            283242008,
            283243508
        ],
        "F2": [
            283240981,
            283223708,
            283219380,
            283241370,
            283223162,
            283225122,
            283233500,
            283231817,
            283231569,
            283232589,
            283230224,
            283236870,
            283235839,
            283237529,
            283238353,
            283243847,
            283243386,
            283242191,
            283243811
        ],
        "F3": [
            283240882,
            283223675,
            283219246,
            283271588,
            283270237,
            283224933,
            283229369,
            283236884,
            283231408,
            283234186,
            283238623,
            283246555,
            283236714,
            283242719,
            283237265,
            283240426,
            283246144,
            283243432,
            283242213,
            283244419
        ],
        "E2": [
            283228724,
            283271415,
            283952156,
            285367980,
            285366320,
            284023567,
            283309295
        ],
        "E1": [
            283228436,
            283232974,
            283271394,
            283269080,
            283266646,
            283248084,
            283226474,
            285366140,
            284023512,
            283309260,
            283237845
        ],
        "D": [
            283195973,
            283206733,
            283203886,
            283202562,
            283199647,
            283202135,
            283203009,
            283209326,
            283212471,
            283208248,
            283213153,
            283210604,
            283213401,
            283215308,
            283215785,
            283193803,
            283212467,
            283216433,
            283217858,
            283213030
        ],
        "C": [
            283191019,
            283190311,
            283188296,
            283196136,
            283191568,
            283193617,
            283197810,
            283200878,
            283205239,
            283197789,
            283193479,
            283202635,
            283205964,
            283204336,
            283202253,
            283186865,
            283201070,
            283203016,
            283201349,
            283204359
        ],
        "B": [
            283187765,
            283200401,
            283192789,
            283188636,
            283190321,
            283192212,
            283195063,
            283200019,
            283195292,
            283189706,
            283199364,
            283199549,
            283199094,
            283197971,
            283197559,
            283195753,
            283198921,
            283194967,
            283197864
        ],
        "A": [
            283182907,
            283184407,
            283187228,
            283181621,
            283185198,
            283186414,
            283185582,
            283191793,
            283185688,
            283183522,
            283193549,
            283187676,
            283189523,
            283193094,
            283182769,
            283189185,
            283185401,
            283198807,
            283189030
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "Solution At some time , consider the minimal interval that contains all\nthe cities with (letâs call it \"the minimal interval at time \"). You\nhave to visit all this interval within time , otherwise there are some\ncities with which you do not visit in time. So if this interval has\nlength , you cannot visit it all within time , and the answer is\n.Otherwise, the answer is at least . A possible construction is visiting\n\"the minimal interval at time \", then \"the minimal interval at time \",\n..., then \"the minimal interval at time \". Note that, when you visit\n\"the minimal interval at time \", the actual time is equal to the length\nof the interval, which is . In this way, at time you will have conquered\nall the cities in the minimal interval at time , and possibly other\ncities.Starting from city is equivalent to setting . After this\noperation, you have to guarantee that, for each , the minimal interval\nat time is short enough. If this interval is before the operation, it\ncan become either (if ), or (if ), or stay the same. In all this cases,\nthe resulting length must be . With some calculations (e.g., ), you can\nget than must be contained in . So itâs enough to calculate and\nintersect the intervals obtained at , and print the length of the final\ninterval.You can calculate the minimal intervals by iterating on the\ncities in increasing order of . Again, if the old interval is and the\nnew city has index , the new possible intervals are , , .Another correct\nsolution is to intersect the intervals . The proof is contained in the\neditorial of 2018F3 - Speedbreaker Counting (Hard Version).Complexity:\n",
    "name": "B. Speedbreaker",
    "statement": "There are n cities in a row, numbered 1, 2,\r\nldots, n left to right. At time 1, you conquer exactly one city, called\r\nthe . At time 2, 3,\r\nldots, n, you can choose a city adjacent to the ones conquered so far\r\nand conquer it. You win if, for each i, you conquer city i at a time no\r\nlater than a_i. A winning strategy may or may not exist, also depending\r\non the starting city. How many starting cities allow you to win?\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned; void solve() {    int n;    std::cin >> n;        std::vector<int> a(n);    std::vector<int> l(n, n), r(n, -1);    for (int i = 0; i < n; i++) {        std::cin >> a[i];        a[i]--;        l[a[i]] = std::min(l[a[i]], i);        r[a[i]] = std::max(r[a[i]], i);    }    int L = n, R = -1;    std::vector<int> f(n);    for (int i = 0; i < n; i++) {        L = std::min(L, l[i]);        R = std::max(R, r[i]);        if (R - L <= i) {            int l = std::max(0, R - i);            int r = std::min(n - 1, L + i);            f[l]++;            if (r < n - 1) {                f[r + 1]--;            }        }    }        for (int i = 1; i < n; i++) {        f[i] += f[i - 1];    }        int ans = std::count(f.begin(), f.end(), n);    std::cout << ans << \"\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Speedbreaker.json",
    "hint": [
        "Hint 1 When is the answer ?",
        "Hint 2 Starting from city is equivalent to setting ."
    ]
}