{
    "link": "https://codeforces.com//contest/1753/problem/A2",
    "problemId": "1601076",
    "problem_idx": "A2",
    "shortId": "1753A2",
    "contest_number": "1753",
    "problem_submissions": {
        "F": [
            177651080,
            177647555,
            177657470,
            188911747,
            188911656,
            188911570,
            188911428,
            188910549,
            188910073,
            188909646,
            188909166,
            188907827,
            188904326,
            188904190,
            188903731,
            177833531,
            177833492
        ],
        "E": [
            177581778,
            177583727,
            177589838,
            177589285,
            177593827,
            177594409,
            177597830,
            177594087,
            177592707,
            177585112,
            177601527,
            177590220,
            177673253,
            177974155,
            177974124,
            177973591,
            177724036
        ],
        "D": [
            177563465,
            177565205,
            177564757,
            177573155,
            177575242,
            177580076,
            177576436,
            177570973,
            177566523,
            177596897,
            177580588,
            177604329,
            177563352,
            177570046,
            177566269,
            177573602,
            177755461,
            177576614,
            177574911
        ],
        "C": [
            177552151,
            177550933,
            177551820,
            177553154,
            177551866,
            177564888,
            177563099,
            177563169,
            177574479,
            177556455,
            177565810,
            177544648,
            177550098,
            177548226,
            177548338,
            177556464,
            177755441,
            177552144,
            177557310
        ],
        "B": [
            177547853,
            177542169,
            177543741,
            177547659,
            177545799,
            177543102,
            177548449,
            177558513,
            177542410,
            177547120,
            177556897,
            177532887,
            177540969,
            177543956,
            177543358,
            177547075,
            177755409,
            177545453,
            177551061
        ],
        "A2": [
            177545216,
            177538464,
            177539211,
            177543167,
            177542984,
            177539535,
            177544288,
            177553832,
            177538606,
            177548841,
            177551155,
            177550293,
            177537648,
            177536071,
            177539594,
            177543961,
            177755345,
            177539530,
            177545423
        ],
        "A1": [
            177533578,
            177538639,
            177539788,
            177537288,
            177537340,
            177539306,
            177543813,
            177553991,
            177538938,
            177533253,
            177550897,
            177550032,
            177537887,
            177533119,
            177533588,
            177544324,
            177755312,
            177540035,
            177546684
        ]
    },
    "name": "A2. Make Nonzero Sum  hard version ",
    "statement": "You are given an array [a_1, a_2,\r\nldots a_n] consisting of integers -1, 0 and 1. You have to build a\r\npartition of this array into the set of segments [l_1, r_1], [l_2, r_2],\r\nldots, [l_k, r_k] with the following property: Denote the alternating\r\nsum of all elements of the i-th segment as s_i: s_i = a_{l_i} -\r\na_{l_i+1} + a_{l_i+2} - a_{l_i+3} +\r\nldots\r\npm a_{r_i}. For example, the alternating sum of elements of segment [2,\r\n4] in array [1, 0, -1, 1, 1] equals to 0 - (-1) + 1 = 2. The sum of s_i\r\nover all segments of partition should be equal to zero. Note that each\r\ns_i does have to be equal to zero, this property is about sum of s_i\r\nover all segments of partition.The set of segments [l_1, r_1], [l_2,\r\nr_2],\r\nldots, [l_k, r_k] is called a of the array a of length n if 1 = l_1\r\nle r_1, l_2\r\nle r_2,\r\nldots, l_k\r\nle r_k = n and r_i + 1 = l_{i+1} for all i = 1, 2,\r\nldots k-1. In other words, each element of the array must belong to\r\nexactly one segment.You have to build a partition of the given array\r\nwith properties described above or determine that such partition does\r\nnot exist.Note that it is required to minimize the number of segments in\r\nthe partition.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    \n    std::vector<int> p;\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        if (a[i]) {\n            p.push_back(i);\n        }\n    }\n    \n    if (p.size() & 1) {\n        std::cout << -1 << \"\\n\";\n        return;\n    }\n    \n    std::vector<std::array<int, 2>> ans;\n    int last = -1;\n    \n    for (int i = 0; i < int(p.size()); i += 2) {\n        int x = p[i], y = p[i + 1];\n        if ((y - x) % 2 == (a[x] == a[y])) {\n            ans.push_back({last + 1, y});\n        } else {\n            if ((x - last) % 2 == 0) {\n                a[x] *= -1;\n            }\n            if (a[x] != a[y]) {\n                ans.push_back({last + 1, y - 1});\n                ans.push_back({y, y});\n            } else if (y - x > 1) {\n                ans.push_back({last + 1, y - 2});\n                ans.push_back({y - 1, y});\n            } else if (x - last > 1) {\n                ans.push_back({last + 1, last + 1});\n                ans.push_back({last + 2, y - 1});\n                ans.push_back({y, y});\n            } else {\n                assert(false);\n            }\n        }\n        last = y;\n    }\n    if (last < n - 1) {\n        ans.push_back({last + 1, n - 1});\n    }\n    \n    std::cout << ans.size() << \"\\n\";\n    for (auto [x, y] : ans) {\n        std::cout << x + 1 << \" \" << y + 1 << \"\\n\";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A2. Make Nonzero Sum  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/108336",
    "editorial": "If the sum of all numbers in the array is odd, then splitting is\r\nimpossible, because splitting does not affect the evenness of the sum.\r\nOtherwise, we will build the answer constructively. Suppose we have\r\nconsidered some kind of array prefix. Let\u00e2\u0080\u0099s keep going until we get\r\nexactly non-zero numbers.We want to make these two non-zero numbers add\r\nup to . Then if on the last segment the sum is already equal to , then\r\njust take it as an answer. Otherwise, consider a few cases: If the\r\nlength of the segment is even, then we simply separate the last number\r\n(it will be non-zero) into a separate segment. Then its sign will change\r\nand in total these two numbers will give . The same can be done if the\r\nlength of the segment is odd, but its first element is equal to .\r\nSeparate this and repeat the algorithm above. If the length of the\r\nsegment is odd and the first element is not equal to , then we separate\r\nit. Then the value of the first element will not change, and the last\r\nwill change to the opposite, and then their sum will be equal to .\r\n"
}