{
    "link": "https://codeforces.com//contest/891/problem/E",
    "problemId": "134544",
    "problem_idx": "E",
    "shortId": "891E",
    "contest_number": "891",
    "problem_submissions": {
        "D": [
            32405811,
            32403732,
            32402138,
            32430714,
            32405646
        ],
        "B": [
            32397173,
            32384884,
            32383268,
            32389067,
            32402095,
            32392144,
            32390145,
            32392706,
            32386797,
            32391950,
            32394619,
            32391275,
            32387784,
            32402908,
            32394168,
            32390852,
            32393424,
            32402498,
            32390071,
            32396268
        ],
        "C": [
            32396218,
            32388086,
            32389360,
            32395431,
            32392168,
            32396723,
            32397239,
            32390965,
            32393675,
            32398647,
            32398521,
            32396975,
            32390007,
            32404522,
            32396953,
            32387277,
            32386884,
            32403069
        ],
        "A": [
            32391368,
            32389450,
            32385263,
            32382597,
            32388551,
            32393309,
            32385252,
            32391318,
            32384125,
            32393321,
            32386822,
            32382673,
            32385160,
            32385074,
            32382459,
            32389480,
            32400282,
            32382452,
            32383065
        ],
        "E": [
            32389900,
            32397841,
            32401538,
            32399718,
            32400691,
            32399515,
            32401892,
            32401660,
            32405427,
            32400764,
            32394075,
            32405328,
            32405995,
            32402118,
            32511522,
            32397327
        ]
    },
    "name": "E. Lust",
    "statement": "You are given a sequence containing integers. There is a variable that\r\nis equal to initially. The following process repeats times.Choose an\r\nindex from to uniformly at random. Name it . Add to the multiply of all\r\n\u2019s such that , but . Then, subtract by .You have to find expected value\r\nof at the end of the process. It can be proved that the expected value\r\nof can be represented as an irreducible fraction . You have to find .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=10100;\nint n;\nll poly[N],q[N],ret[N],k,ans;\nint a[N];\nint main() {\n\tscanf(\"%d%lld\",&n,&k);\n\tpoly[0]=1;\n\trep(i,0,n) {\n\t\tscanf(\"%d\",a+i);\n\t\tper(j,0,i+1) poly[j+1]=(poly[j]+poly[j+1])%mod,poly[j]=poly[j]*(mod-a[i])%mod;\n\t}\n\trep(i,0,n) {\n\t\tper(j,0,n+1) q[j]=poly[j];\n\t\tper(j,1,n+1) {\n\t\t\tret[j-1]=(ret[j-1]+q[j])%mod;\n\t\t\tq[j-1]=(q[j-1]+q[j]*a[i])%mod;\n\t\t}\n\t}\n\tll coef=1;\n\trep(i,0,n) {\n\t\tcoef=coef*(k-i)%mod;\n\t\tans=(ans+powmod(n,mod-2-i)%mod*coef%mod*powmod(i+1,mod-2)%mod*ret[i])%mod;\n\t}\n\tans=ans*powmod(mod-1,n+1)%mod;\n\tprintf(\"%lld\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "matrices"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Lust.json",
    "editorial_link": "https://codeforces.com//blog/entry/55841",
    "editorial": "Lemma : expected value of res is equal to multiply of s minus expected\r\nvalue of multiply of s at the end of process. Prove : Imagine that at\r\nthe end of process, turns to (). For this case, it is easy to prove that\r\nres is equal to multiply of s minus multiply of s (can be proved by\r\ninduction). So we can see truth of lemma.Define as expected value of\r\nmultiply of mask\u00e2\u0080\u0099s subset after k\u00e2\u0080\u0099th repeat. Now we want to calculate\r\nthis dp. Fix index of k\u00e2\u0080\u0099th chosen number. If mask\u00e2\u0080\u0099s subset contains that\r\nfixed number, then expected value of multiply of mask\u00e2\u0080\u0099s subset decreases\r\nby expected value of (mask2 is equal to subset of mask minus chosen\r\nfixed number). If mask\u00e2\u0080\u0099s subset doesn\u00e2\u0080\u0099t contains fixed index, then\r\nexpected value of multiply of mask\u00e2\u0080\u0099s subset doesn\u00e2\u0080\u0099t change. More\r\nformally , for all indices i from 1 to n :. (If mask contains i\u00e2\u0080\u0099th\r\nelement). (If mask dosent contains i\u00e2\u0080\u0099th element)So we can write : (If\r\nmask contains i\u00e2\u0080\u0099th element)After calculating this dp, we can find\r\nexpected value of res, using lemma and . This algorithm runs in . Now we\r\nwant to optimize this solution. First of all, we can calculate this dp ,\r\nusing matrix exponential; because updates by a coefficient from . so if\r\nwe write coefficient of update from in , and write multiply of mask\r\nsubset if , then \u00e2\u0080\u0099th element of , equals to expected value of s after\r\nk\u00e2\u0080\u0099th repeat process. After his optimization, algorithm runs in .In our\r\nsecond solution, we learned that expected value of multiply of \u00e2\u0080\u0099s after\r\nk\u00e2\u0080\u0099th operation (name it as ) equals to \u00e2\u0080\u0099th element of . this element\r\nequals to . Now we want to calculate coefficients of . by this\r\ncoefficients, we can calculate value . if we take a look at update of ,\r\nwe can define another meaning for this . imagine directed hypercube and\r\nadd a self loop for every vertex. now , can be this : for every walk\r\nthat ends in in moves, add to . So it\u00e2\u0080\u0099s easy to see that all s that have\r\nequal number of elements, have equal . (regardless of base of ) So is\r\nequals to this value for walks from mask to . Now, by fixing non self\r\nloop edges, we can see that is equal to :So this value is equal for all\r\nmasks with equal ones. name this value by . By our equation : (for )\r\n(for )(for )So s can be easily calculated in . Now we want to calculate\r\n(for all masks with w ones). (for ). This value can be calculated by\r\n(sigma of j_tuples multiplies in first i elements) in . So, finally,\r\nthis algorithm runs if\r\n"
}