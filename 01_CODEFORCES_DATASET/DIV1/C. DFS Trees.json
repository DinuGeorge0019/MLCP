{
    "link": "https://codeforces.com//contest/1707/problem/C",
    "problemId": "1465655",
    "problem_idx": "C",
    "shortId": "1707C",
    "contest_number": "1707",
    "problem_submissions": {
        "E": [
            164603668,
            164525375,
            164669454,
            185901683,
            185901618,
            185901333,
            164563417
        ],
        "D": [
            164511528,
            164496478,
            164493571,
            164495095,
            164501925,
            164506638,
            166069487,
            164497571,
            164507609,
            166120309,
            166120066,
            164509308,
            164956360,
            164507471,
            164489918,
            164511025,
            164904470,
            164514319,
            164514325,
            164497954,
            164519148,
            164515594,
            164518158,
            164516720,
            164511294
        ],
        "B": [
            164484745,
            164460975,
            164467918,
            164471533,
            164466867,
            164467580,
            164475668,
            164466783,
            166120253,
            166119986,
            164469792,
            164956306,
            164468045,
            164461021,
            164475290,
            164475116,
            164472236,
            164466401,
            164463086,
            164472164,
            164472283,
            164465112,
            164479683
        ],
        "C": [
            164479539,
            164485229,
            164482780,
            164482216,
            164481698,
            164485751,
            164487589,
            164482127,
            166120011,
            164486694,
            164956347,
            164484482,
            164472573,
            164487921,
            164484938,
            164484181,
            164511081,
            164483634,
            164483996,
            164493834,
            164499762,
            164491460
        ],
        "A": [
            164463335,
            164470733,
            164464634,
            164464640,
            164458756,
            164460631,
            164457208,
            164456721,
            166119954,
            164458999,
            164956326,
            164457788,
            164466493,
            164459761,
            164467279,
            164469592,
            164460485,
            164464829,
            164460707,
            164471416,
            164466775
        ],
        "F": [
            164529829,
            164530227,
            165361670,
            165361592,
            165360981,
            165360617,
            164565887,
            164565715
        ]
    },
    "name": "C. DFS Trees",
    "statement": "You are given a connected undirected graph consisting of n vertices and\r\nm edges. The weight of the i-th edge is i.Here is a wrong algorithm of\r\nfinding a minimum spanning tree (MST) of a graph:vis := an array of\r\nlength ns := a set of edgesfunction dfs(u): vis[u] := true iterate\r\nthrough each edge (u, v) in the order from smallest to largest edge\r\nweight if vis[v] = false add edge (u, v) into the set (s) dfs(v)function\r\nfindMST(u): reset all elements of (vis) to false reset the edge set (s)\r\nto empty dfs(u) return the edge set (s)Each of the calls , , ..., gives\r\nyou a spanning tree of the graph. Determine which of these trees are\r\nminimum spanning trees.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nint n,m;\nint head[100001],nxt[200001],b[200001],k;\nint sum[100001];\nint f[100001];\nint find(int x){\n\treturn f[x]?f[x]=find(f[x]):x;\n}\nvoid push(int s,int t){\n\tnxt[++k]=head[s];\n\thead[s]=k;\n\tb[k]=t;\n}\nstd::vector<std::pair<int,int> >vec;\nint dep[100001],fa[100001][21];\nvoid dfs(int x,int f){\n\tdep[x]=dep[f]+1;\n\tfa[x][0]=f;\n\tfor(int i=1;i<=20;++i)\n\t\tfa[x][i]=fa[fa[x][i-1]][i-1];\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(b[i]!=f){\n\t\t\tdfs(b[i],x);\n\t\t}\n}\nint LCA(int x,int y){\n\tif(x==y)return x;\n\tif(dep[x]<dep[y])std::swap(x,y);\n\tfor(int i=20;~i;--i)\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n\tif(x==y)return x;\n\tfor(int i=20;~i;--i)\n\t\tif(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n\t\treturn fa[x][0];\n}\nvoid dfs2(int x,int f){\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(b[i]!=f){\n\t\t\tsum[b[i]]+=sum[x];\n\t\t\tdfs2(b[i],x);\n\t\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,u,v;i<=m;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tint du=find(u),dv=find(v);\n\t\tif(du!=dv){\n\t\t\tpush(u,v),push(v,u);\n\t\t\tf[du]=dv;\n\t\t\t// printf(\"**%d %d\\n\",u,v);\n\t\t}\n\t\telse{\n\t\t\tvec.push_back(std::make_pair(u,v));\n\t\t}\n\t}\n\tdfs(1,0);\n\tfor(auto v:vec){\n\t\tint x=v.first,y=v.second,l=LCA(x,y);\n\t\tif(x==l||y==l){\n\t\t\tint tem=(x^y^l);\n\t\t\tfor(int i=20;~i;--i)\n\t\t\t\tif(dep[fa[tem][i]]>dep[l])tem=fa[tem][i];\n\t\t\t++sum[tem];\n\t\t\t--sum[x^y^l];\n\t\t}\n\t\telse{\n\t\t\t++sum[1];\n\t\t\t--sum[x],--sum[y];\n\t\t}\n\t\t// sum[fa[LCA(v.first,v.second)][0]]-=2;\n\t\t// printf(\"%d %d %d\\n\",v.first,v.second,LCA(v.first,v.second));\n\t}\n\tdfs2(1,0);\n\t// for(int i=1;i<=n;++i)printf(\"%d \",sum[i]);putchar('\\n');\n\tfor(int i=1;i<=n;++i)printf(\"%d\",sum[i]==0);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "sortings",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. DFS Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/104930",
    "editorial": "Minimum spanning tree is unique in the given graph.If (x) creates an\r\nMST, there is no in the graph. So if you can determine whether there is\r\na cross edge starting DFS from every node, the problem is solved.Pay\r\nattention to every edge that is not in the MST. Letâs focus on one\r\nsingle edge and see starting DFS from which node, is a cross edge. Take\r\nthe following graph as an example.If we start from nodes , , , , or , is\r\na cross edge. If we start from nodes , , or , is not a cross edge. We\r\ncan find that when considering as the root of the tree, and are on the\r\nsubtree of . When considering as the root of the tree, and are on the\r\nsubtree of .So if an edge is not in the MST, only the subtree of (\r\nincluded, when considering as the root) and the subtree of ( included,\r\nwhen considering as the root) can be answers. We just need to do this\r\nprocess for each edge not in the MST. After that we can get the\r\nanswers.We can finish the process in with bin-up on tree and BIT or in\r\nwith some case work while dfs.\r\n",
    "hint": []
}