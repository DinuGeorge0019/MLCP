{"link": "https://codeforces.com//contest/1188/problem/A2", "problemId": "366820", "problem_idx": "A2", "shortId": "1188A2", "contest_number": "1188", "problem_submissions": {"A2": [56584964, 56567602, 56566524, 56572382, 56589644, 56583972, 56579938, 56582233, 56570590, 56576661, 56589231, 56587448, 56570901, 56587024, 56574198, 56581669, 56571222], "E": [56582671, 56589474, 56589239, 141774833, 57345099, 56596996, 56642394], "D": [56576903, 56585842, 56583846, 56589764, 56584452, 56586331, 56584084, 56596587, 56577947, 56602284], "C": [56571735, 56576008, 56572799, 56580329, 56577305, 56572037, 56574271, 56570306, 56577496, 56576142, 56583479, 56585009, 56584467, 56575353, 56583067, 56585221, 56572902, 56587295, 56575946, 56586708], "B": [56568214, 56570555, 56562488, 56571471, 56575984, 56607436, 56565158, 56574148, 56570733, 56572983, 56567704, 56568743, 56568263, 56575440, 56583939, 56576017, 56588907, 56575865], "A1": [56561659, 56562944, 56561298, 56564728, 56563727, 56577205, 56564216, 56561247, 56563294, 56561568, 56563293, 56566261, 56569194, 56564914, 56561283, 56572778, 56565086, 56564073, 56561536, 56563748]}, "name": "A2. Add on a Tree  Revolution", "statement": "You are given a tree with n nodes. In the beginning, 0 is written on all\r\nedges. In one operation, you can choose any 2 distinct u, v and any\r\nnumber x and add x to values written on all edges on the simple path\r\nbetween u and v. .For example, on the picture below you can see the\r\nresult of applying two operations to the graph: adding 2 on the path\r\nfrom 7 to 6, and then adding -1 on the path from 4 to 5. You are given\r\nsome configuration of numbers, written on the edges. For a given\r\nconfiguration determine if it is possible to achieve it with these\r\noperations, and, if it is possible, output the sequence of operations\r\nthat leads to the given configuration. Constraints on the operations are\r\nlisted in the output format section.Leave is a node of a tree of\r\ndegree 1. Simple path is a path that doesn\u2019t contain any node twice.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1100;\nint n;\nvector<int> g[N];\nint ed[N][3];\nint ans[10 * N][3];\nint ansSz;\n\nvoid addAns(int v, int u, int x) {\n\tans[ansSz][0] = v + 1;\n\tans[ansSz][1] = u + 1;\n\tans[ansSz][2] = x;\n\tansSz++;\n}\n\nint getLeaf(int v, int par, int u) {\n\tif (v == u) return -1;\n\tif ((int)g[v].size() == 1) return v;\n\tint res = -2;\n\tfor (int w : g[v]) {\n\t\tif (w == par) continue;\n\t\tint z = getLeaf(w, v, u);\n\t\tif (z == -1) return -1;\n\t\tres = z;\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, w;\n\t\tscanf(\"%d%d%d\", &v, &u, &w);\n\t\tv--;u--;\n\t\ted[i][0] = v;\n\t\ted[i][1] = u;\n\t\ted[i][2] = w;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tfor (int v = 0; v < n; v++) {\n\t\tif ((int)g[v].size() == 2) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint v = ed[i][0], u = ed[i][1], x = ed[i][2] / 2;\n\t\tvector<int> vv, uu;\n\t\tif ((int)g[v].size() == 1) {\n\t\t\tvv.push_back(v);\n\t\t} else {\n\t\t\tfor (int w : g[v]) {\n\t\t\t\tint z = getLeaf(w, v, u);\n\t\t\t\tif (z != -1)\n\t\t\t\t\tvv.push_back(z);\n\t\t\t\tif ((int)vv.size() == 2) break;\n\t\t\t}\n\t\t}\n\t\tif ((int)g[u].size() == 1) {\n\t\t\tuu.push_back(u);\n\t\t} else {\n\t\t\tfor (int w : g[u]) {\n\t\t\t\tint z = getLeaf(w, u, v);\n\t\t\t\tif (z != -1)\n\t\t\t\t\tuu.push_back(z);\n\t\t\t\tif ((int)uu.size() == 2) break;\n\t\t\t}\n\t\t}\n\t\tif ((int)uu.size() == 1) swap(vv, uu);\n\t\tif ((int)uu.size() == 1) {\n\t\t\taddAns(vv[0], uu[0], 2 * x);\n\t\t} else if ((int)vv.size() == 1) {\n\t\t\taddAns(vv[0], uu[0], x);\n\t\t\taddAns(vv[0], uu[1], x);\n\t\t\taddAns(uu[0], uu[1], -x);\n\t\t} else {\n\t\t\taddAns(vv[0], uu[0], x);\n\t\t\taddAns(vv[1], uu[1], x);\n\t\t\taddAns(vv[0], vv[1], -x);\n\t\t\taddAns(uu[0], uu[1], -x);\n\t\t}\n\t}\n\n\tprintf(\"YES\\n\");\n\tprintf(\"%d\\n\", ansSz);\n\tfor (int i = 0; i < ansSz; i++)\n\t\tprintf(\"%d %d %d\\n\", ans[i][0], ans[i][1], ans[i][2]);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "implementation", "trees"], "dificulty": "2500", "interactive": false}