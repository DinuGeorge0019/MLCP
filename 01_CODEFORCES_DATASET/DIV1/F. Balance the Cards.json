{
    "link": "https://codeforces.com//contest/1503/problem/F",
    "problemId": "945474",
    "problem_idx": "F",
    "shortId": "1503F",
    "contest_number": "1503",
    "problem_submissions": {
        "F": [
            111939776,
            111936345,
            111953640,
            111949537,
            111942068,
            111944734,
            111944711,
            111948141,
            111947867,
            113984444
        ],
        "E": [
            111918055,
            111912666,
            111918864,
            111923939,
            111922990,
            111923269,
            111922053,
            111920801,
            111927922,
            111926604,
            111931364,
            111936374,
            111926173,
            111935792,
            111929517,
            111930613,
            111937713,
            111935328,
            111934244
        ],
        "D": [
            111903738,
            111902585,
            111898744,
            111893896,
            111901869,
            111902624,
            111880076,
            111902059,
            111906951,
            111905795,
            111910439,
            111899185,
            111916472,
            111904574,
            111913444,
            111910826,
            111914877,
            111924091,
            111906860
        ],
        "C": [
            111886477,
            111890876,
            111881938,
            111886094,
            111882409,
            111883959,
            111902446,
            111905834,
            111885208,
            111897171,
            111889963,
            111890061,
            111888926,
            111886850,
            111898651,
            111896248,
            111894668,
            111884135,
            111889304
        ],
        "B": [
            111876447,
            111888244,
            111877449,
            111876120,
            111878468,
            111878981,
            111893644,
            111877927,
            111878327,
            111877579,
            111878407,
            111882807,
            111900739,
            111880662,
            111889601,
            111886898,
            111883228,
            111878516,
            111916268
        ],
        "A": [
            111871860,
            111872029,
            111873354,
            111871912,
            111872701,
            111874636,
            111888931,
            111872574,
            111873406,
            111872331,
            111873739,
            111875192,
            111873092,
            111873513,
            111878839,
            111875591,
            111873509,
            111872858,
            111893066
        ]
    },
    "name": "F. Balance the Cards",
    "statement": "A balanced bracket sequence is defined as an integer sequence that can\r\nbe built with the following rules: The empty sequence is balanced. If\r\n[a_1,\r\nldots,a_n] and [b_1,\r\nldots, b_m] are balanced, then their concatenation [a_1,\r\nldots,a_n,b_1,\r\nldots,b_m] is balanced. If x is a positive integer and [a_1,\r\nldots,a_n] is balanced, then [x,a_1,\r\nldots,a_n,-x] is balanced. The positive numbers can be imagined as\r\nopening brackets and the negative numbers as closing brackets, where\r\nmatching brackets must have the same type (absolute value). For example,\r\n[1, 2, -2, -1] and [1, 3, -3, 2, -2, -1] are balanced, but [1, 2, -1,\r\n-2] and [-1, 1] are not balanced.There are 2n cards. Each card has a\r\nnumber on the front and a number on the back. Each integer 1,-1,2,-2,\r\nldots,n,-n appears exactly once on the front of some card and exactly\r\nonce on the back of some (not necessarily the same) card.You can reorder\r\nthe cards however you like. You are allowed to flip cards, so numbers\r\ncannot move between the front and back. Your task is to order the cards\r\nso that the sequences given by the front numbers and the back numbers\r\nare both balanced, or report that it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint n;\n\tcin >> n;\n\tn *= 2;\n\tvector<vector<int> > card(n, vector<int>(2));\n\tvector<map<int,int> > idx(2);\n\tauto sgn = [&](int a) -> int {\n\t\treturn a / abs(a);\n\t};\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> card[i][0] >> card[i][1];\n\t\tidx[0][card[i][0]] = i;\n\t\tidx[1][card[i][1]] = i;\n\t}\n\tvector<vector<int> > ocard = card;\n\tset<int> exists;\n\tfor(int i = 0; i < n; i++) exists.insert(i);\n\tvector<vector<int> > ins(n);\n\tauto check = [&](int v) -> int {\n\t\tif(!exists.count(v)) return -1;\n\t\tint a = card[v][0];\n\t\tint b = card[v][1];\n\t\tassert(idx[0].count(-a));\n\t\tassert(idx[1].count(-b));\n\t\tif(sgn(a) != sgn(b)){\n\t\t\tint p, q;\n\t\t\tif(sgn(a) == -1){\n\t\t\t\tp = idx[0][-a];\n\t\t\t\tq = idx[1][-b];\n\t\t\t} else {\n\t\t\t\tp = idx[1][-b];\n\t\t\t\tq = idx[0][-a];\n\t\t\t}\n\t\t\tins[p].push_back(v);\n\t\t\tins[p].push_back(q);\n\t\t\tins.push_back({p, v, q});\n\t\t\tfor(int x : {p, v, q}){\n\t\t\t\tidx[0].erase(card[x][0]);\n\t\t\t\tidx[1].erase(card[x][1]);\n\t\t\t}\n\t\t\texists.erase(v);\n\t\t\texists.erase(q);\n\t\t\tif(sgn(a) == -1){\n\t\t\t\tcard[p][0] = card[q][0];\n\t\t\t} else {\n\t\t\t\tcard[p][1] = card[q][1];\n\t\t\t}\n\t\t\tidx[0][card[p][0]] = p;\n\t\t\tidx[1][card[p][1]] = p;\n\t\t\treturn p;\n\t\t}\n\t\treturn -1;\n\t};\n\tvector<int> b;\n\tfor(int i = 0; i < n; i++) b.push_back(i);\n\tint s = 0;\n\twhile(s < (int)b.size()){\n\t\tint v = b[s];\n\t\ts++;\n\t\tint k = check(v);\n\t\tif(k >= 0) b.push_back(k);\n\t}\n\tvector<int> ans;\n\tfor(int i = 0; i < n; i++){\n\t\tif(exists.count(i)){\n\t\t\tassert(sgn(card[i][0]) == sgn(card[i][1]));\n\t\t\tif(sgn(card[i][0]) == -1) continue;\n\t\t\tint v = idx[0][-card[i][0]];\n\t\t\tint w = idx[1][-card[i][1]];\n\t\t\tif(v != w){\n\t\t\t\tcout << \"NO\" << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\texists.erase(i);\n\t\t\texists.erase(v);\n\t\t\tauto add_vals = y_combinator(\n\t\t\t\t[&](auto self, int x) -> void {\n\t\t\t\t\tans.push_back(x);\n\t\t\t\t\tfor(int y : ins[x]){\n\t\t\t\t\t\tself(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tadd_vals(i);\n\t\t\tadd_vals(v);\n\t\t}\n\t}\n\tvector<vector<int> > seq(2);\n\tfor(int p : ans){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tif(!seq[j].empty() && seq[j].back() > 0 && seq[j].back() == -ocard[p][j]){\n\t\t\t\tseq[j].pop_back();\n\t\t\t} else {\n\t\t\t\tseq[j].push_back(ocard[p][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif((int)ans.size() == n && seq[0].empty() && seq[1].empty()){\n\t\tcout << \"YES\" << '\\n';\n\t\tfor(int p : ans){\n\t\t\tcout << ocard[p][0] << ' ' << ocard[p][1] << '\\n';\n\t\t}\n\t} else {\n\t\tcout << \"NO\" << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "divide and conquer",
        "geometry",
        "graphs",
        "implementation"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Balance the Cards.json",
    "editorial_link": "https://codeforces.com//blog/entry/89319",
    "editorial": "Suppose we have a deck of cards where the front and back are both\r\nbalanced bracket sequences. Letâs line the cards up horizontally and\r\ndraw them as points. For each pair of matching brackets on the front and\r\nback, we will connect them with an edge. For matched brackets on the\r\nfront, we add an edge as a semicircle lying above the points. And for\r\nmatched brackets on the back, we add a similar edge below the points.\r\nSince every point is incident to exactly two edges, this graph\r\ndecomposes into cycles. Since the edges are non-intersecting, each cycle\r\nis a Jordan curve in the plane. Imagine the curve as a track, and a\r\nmonorail makes one full trip clockwise around the track. Each edge turns\r\nthe monorail clockwise or counterclockwise by 180 degrees. Since the\r\noverall effect must turn the monorail a full 360 degrees clockwise,\r\nthere are two more clockwise edges than counterclockwise edges in the\r\ncycle. If a cycle has edges, then there are clockwise edges and\r\ncounterclockwise edges.Now, in the actual problem we are given a\r\nshuffled deck of cards. If there exists a way to reorder them so that\r\nthe front and back are both balanced, then we know the above property\r\nmust hold. Even though the cards are shuffled, we still have enough\r\ninformation to construct the edges and distinguish two edges in the same\r\ncycle by orientation (clockwise and counterclockwise). If there are\r\nedges of one orientation, we should call them the clockwise edges.\r\nOtherwise if the number of edges of both orientations are invalid, we\r\nshould report that no solution exists.Now that we have restricted\r\nourselves to the case where this important condition holds, we should\r\nconstruct a solution. We can do this by solving for all the cycles\r\nindependently and concatenating them together.Consider a cycle. Letâs\r\nmake a binary string describing the sequence of orientations, where\r\ndenotes a clockwise turn and denotes a counterclockwise turn. Since\r\nthere are clockwise turns, we can find two adjacent âs in the string.\r\nFor consistency, letâs cyclically shift the string so that it begins and\r\nends with , and we can consider the curve to begin at the leftmost\r\npoint. Letâs see how we can build the curve recursively. First, there is\r\nthe base case where the string is . Clearly, we can build the curve with\r\ntwo points like this. Now, suppose we have constructed a curve\r\ncorresponding to for some string . We will hide the turns of in the\r\ndrawing, and just display it as a blue box. From this, we can build a\r\ncurve corresponding to the string as shown on the right. This requires\r\nus to add two new points and reverse the order of the points in the blue\r\nbox. Similarly, if we have constructed a curve for , we can build the\r\ncurve for . Suppose we have constructed the curves and for two strings\r\nand . The turns of are displayed as a blue box, and the turns of are\r\ndisplayed as a green box. Then we can build the curve as shown on the\r\nright. We take the last point in the blue box visited by the curve, and\r\nreplace it with the points in the green box, in the same order. It turns\r\nout that the base case and these three operations are enough to build\r\nany curve satisfying the required condition. We can do it recursively as\r\nfollows. If the string is , return the base case. If the string is for\r\nsome , build the curve and apply operation 1. If the string is for some\r\n, build the curve and apply operation 2. Otherwise, there exist\r\nnon-empty strings and so that the string is , and contains the same\r\nnumber of âs and âs (and thus so does ). Recursively build the curves\r\nand , and apply operation 3. How can we apply these operations\r\nefficiently? When constructing a curve, we only care about the list of\r\npoints (ignoring the leftmost one) as they appear from left to right,\r\nand which points are visited immediately before and after the leftmost\r\npoint by the curve. If we store the list in the form of a doubly linked\r\nlist, the operations of reversing and inserting in the middle can be\r\ndone in constant time.To build it recursively, we also need an efficient\r\nway to find a splitting point in the case of . If we just scan from one\r\nendpoint maintaining a prefix sum (number of âs minus number of âs), the\r\nalgorithm will take time overall. Instead, we should scan from both\r\nendpoints in parallel, and stop when one of them finds a splitting\r\npoint. If it splits into lengths and , then the time is given by the\r\nrecurrence Complexity is .There is also an solution. Scan the string\r\n(ignoring the first and last ) from left to right, maintaining a stack\r\nof linked lists. When the prefix sum (number of âs minus number of âs)\r\nincreases in absolute value, we push the base case to the stack. When\r\nthe prefix sum decreases in absolute value, we apply an operation or to\r\nthe curve on the top of the stack, then merge the top two curves with\r\noperation .\r\n",
    "hint": []
}