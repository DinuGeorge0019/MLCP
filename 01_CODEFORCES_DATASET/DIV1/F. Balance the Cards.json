{"link": "https://codeforces.com//contest/1503/problem/F", "problemId": "945474", "problem_idx": "F", "shortId": "1503F", "contest_number": "1503", "problem_submissions": {"F": [111939776, 111936345, 111953640, 111949537, 111942068, 111944734, 111944711, 111948141, 111947867, 113984444], "E": [111918055, 111912666, 111918864, 111923939, 111922990, 111923269, 111922053, 111920801, 111927922, 111926604, 111931364, 111936374, 111926173, 111935792, 111929517, 111930613, 111937713, 111935328, 111934244], "D": [111903738, 111902585, 111898744, 111893896, 111901869, 111902624, 111880076, 111902059, 111906951, 111905795, 111910439, 111899185, 111916472, 111904574, 111913444, 111910826, 111914877, 111924091, 111906860], "C": [111886477, 111890876, 111881938, 111886094, 111882409, 111883959, 111902446, 111905834, 111885208, 111897171, 111889963, 111890061, 111888926, 111886850, 111898651, 111896248, 111894668, 111884135, 111889304], "B": [111876447, 111888244, 111877449, 111876120, 111878468, 111878981, 111893644, 111877927, 111878327, 111877579, 111878407, 111882807, 111900739, 111880662, 111889601, 111886898, 111883228, 111878516, 111916268], "A": [111871860, 111872029, 111873354, 111871912, 111872701, 111874636, 111888931, 111872574, 111873406, 111872331, 111873739, 111875192, 111873092, 111873513, 111878839, 111875591, 111873509, 111872858, 111893066]}, "name": "F. Balance the Cards", "statement": "A balanced bracket sequence is defined as an integer sequence that can\r\nbe built with the following rules: The empty sequence is balanced. If\r\n[a_1,\r\nldots,a_n] and [b_1,\r\nldots, b_m] are balanced, then their concatenation [a_1,\r\nldots,a_n,b_1,\r\nldots,b_m] is balanced. If x is a positive integer and [a_1,\r\nldots,a_n] is balanced, then [x,a_1,\r\nldots,a_n,-x] is balanced. The positive numbers can be imagined as\r\nopening brackets and the negative numbers as closing brackets, where\r\nmatching brackets must have the same type (absolute value). For example,\r\n[1, 2, -2, -1] and [1, 3, -3, 2, -2, -1] are balanced, but [1, 2, -1,\r\n-2] and [-1, 1] are not balanced.There are 2n cards. Each card has a\r\nnumber on the front and a number on the back. Each integer 1,-1,2,-2,\r\nldots,n,-n appears exactly once on the front of some card and exactly\r\nonce on the back of some (not necessarily the same) card.You can reorder\r\nthe cards however you like. You are allowed to flip cards, so numbers\r\ncannot move between the front and back. Your task is to order the cards\r\nso that the sequences given by the front numbers and the back numbers\r\nare both balanced, or report that it is impossible.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint n;\n\tcin >> n;\n\tn *= 2;\n\tvector<vector<int> > card(n, vector<int>(2));\n\tvector<map<int,int> > idx(2);\n\tauto sgn = [&](int a) -> int {\n\t\treturn a / abs(a);\n\t};\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> card[i][0] >> card[i][1];\n\t\tidx[0][card[i][0]] = i;\n\t\tidx[1][card[i][1]] = i;\n\t}\n\tvector<vector<int> > ocard = card;\n\tset<int> exists;\n\tfor(int i = 0; i < n; i++) exists.insert(i);\n\tvector<vector<int> > ins(n);\n\tauto check = [&](int v) -> int {\n\t\tif(!exists.count(v)) return -1;\n\t\tint a = card[v][0];\n\t\tint b = card[v][1];\n\t\tassert(idx[0].count(-a));\n\t\tassert(idx[1].count(-b));\n\t\tif(sgn(a) != sgn(b)){\n\t\t\tint p, q;\n\t\t\tif(sgn(a) == -1){\n\t\t\t\tp = idx[0][-a];\n\t\t\t\tq = idx[1][-b];\n\t\t\t} else {\n\t\t\t\tp = idx[1][-b];\n\t\t\t\tq = idx[0][-a];\n\t\t\t}\n\t\t\tins[p].push_back(v);\n\t\t\tins[p].push_back(q);\n\t\t\tins.push_back({p, v, q});\n\t\t\tfor(int x : {p, v, q}){\n\t\t\t\tidx[0].erase(card[x][0]);\n\t\t\t\tidx[1].erase(card[x][1]);\n\t\t\t}\n\t\t\texists.erase(v);\n\t\t\texists.erase(q);\n\t\t\tif(sgn(a) == -1){\n\t\t\t\tcard[p][0] = card[q][0];\n\t\t\t} else {\n\t\t\t\tcard[p][1] = card[q][1];\n\t\t\t}\n\t\t\tidx[0][card[p][0]] = p;\n\t\t\tidx[1][card[p][1]] = p;\n\t\t\treturn p;\n\t\t}\n\t\treturn -1;\n\t};\n\tvector<int> b;\n\tfor(int i = 0; i < n; i++) b.push_back(i);\n\tint s = 0;\n\twhile(s < (int)b.size()){\n\t\tint v = b[s];\n\t\ts++;\n\t\tint k = check(v);\n\t\tif(k >= 0) b.push_back(k);\n\t}\n\tvector<int> ans;\n\tfor(int i = 0; i < n; i++){\n\t\tif(exists.count(i)){\n\t\t\tassert(sgn(card[i][0]) == sgn(card[i][1]));\n\t\t\tif(sgn(card[i][0]) == -1) continue;\n\t\t\tint v = idx[0][-card[i][0]];\n\t\t\tint w = idx[1][-card[i][1]];\n\t\t\tif(v != w){\n\t\t\t\tcout << \"NO\" << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\texists.erase(i);\n\t\t\texists.erase(v);\n\t\t\tauto add_vals = y_combinator(\n\t\t\t\t[&](auto self, int x) -> void {\n\t\t\t\t\tans.push_back(x);\n\t\t\t\t\tfor(int y : ins[x]){\n\t\t\t\t\t\tself(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tadd_vals(i);\n\t\t\tadd_vals(v);\n\t\t}\n\t}\n\tvector<vector<int> > seq(2);\n\tfor(int p : ans){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tif(!seq[j].empty() && seq[j].back() > 0 && seq[j].back() == -ocard[p][j]){\n\t\t\t\tseq[j].pop_back();\n\t\t\t} else {\n\t\t\t\tseq[j].push_back(ocard[p][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif((int)ans.size() == n && seq[0].empty() && seq[1].empty()){\n\t\tcout << \"YES\" << '\\n';\n\t\tfor(int p : ans){\n\t\t\tcout << ocard[p][0] << ' ' << ocard[p][1] << '\\n';\n\t\t}\n\t} else {\n\t\tcout << \"NO\" << '\\n';\n\t}\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "divide and conquer", "geometry", "graphs", "implementation"], "dificulty": "3500", "interactive": false}