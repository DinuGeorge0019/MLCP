{
    "link": "https://codeforces.com//contest/737/problem/C",
    "problemId": "81051",
    "problem_idx": "C",
    "shortId": "737C",
    "contest_number": "737",
    "problem_submissions": {
        "D": [
            22352998,
            22361676,
            22361660,
            22352983,
            22352295,
            22352107,
            22352670,
            22355408,
            22353859,
            22355150,
            22355124,
            22355580,
            22352603,
            22354241,
            22355135,
            22367415,
            22354851,
            22353195,
            22355191,
            22354766,
            22354567,
            22355616,
            22355720
        ],
        "C": [
            22346894,
            22348992,
            22348428,
            22346364,
            22349019,
            22347742,
            22344273,
            22349093,
            22344153,
            22348276,
            22349914,
            22349222,
            22351285,
            22350460,
            22350277,
            22351065,
            22348263,
            22347006,
            22351260,
            22349703
        ],
        "B": [
            22345266,
            22344047,
            22346326,
            22344623,
            22347286,
            22345951,
            22346273,
            22346654,
            22345815,
            22347161,
            22347731,
            22346343,
            22348170,
            22348193,
            22348953,
            22349108,
            22345433,
            22343951,
            22343981,
            22347679
        ],
        "A": [
            22344335,
            22346876,
            22344812,
            22348251,
            22345241,
            22344610,
            22348244,
            22344836,
            22349514,
            22345867,
            22345524,
            22349952,
            22345718,
            22346457,
            22347708,
            22346937,
            22344148,
            22348610,
            22348383,
            22345809
        ],
        "F": [
            22363265,
            22374526
        ],
        "E": [
            22411333
        ]
    },
    "name": "C. Subordinates",
    "statement": "There are workers in a company, each of them has a unique id from to .\r\none of them is a chief, his id is . Each worker except the chief has\r\nexactly one immediate superior.There was a request to each of the\r\nworkers to tell how how many superiors (not only immediate). Worker\u2019s\r\nsuperiors are his immediate superior, the immediate superior of the his\r\nimmediate superior, and so on. For example, if there are three workers\r\nin the company, from which the first is the chief, the second worker\u2019s\r\nimmediate superior is the first, the third worker\u2019s immediate superior\r\nis the second, then the third worker has two superiors, one of them is\r\nimmediate and one not immediate. The chief is a superior to all the\r\nworkers except himself.Some of the workers were in a hurry and made a\r\nmistake. You are to find the minimum number of workers that could make a\r\nmistake.\r\n",
    "solutions": [
        "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\nusing namespace std;\n\nclass TaskC {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, s;\n\t\tin >> n >> s;\n\t\t--s;\n\t\tvector<int> v(n);\n\t\tint ans = 0, free = 0;\n\t\tvector<int> d;\n\t\tfor (int i: range(n)) {\n\t\t\tin >> v[i];\n\t\t\tif (i == s && v[i] != 0) {\n\t\t\t\t++ans;\n\t\t\t}\n\t\t\tif (i == s) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (v[i] == 0) {\n\t\t\t\t++ans;\n\t\t\t\t++free;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\td.push_back(v[i]);\n\t\t}\n\n\t\tsort(d);\n\n\t\tint mxDepth = 0;\n\n\t\tfor (int i = 0; i < (int)d.size();) {\n\t\t\tif (d[i] <= mxDepth + 1) {\n\t\t\t\tmxDepth = max(d[i], mxDepth);\n\t\t\t\t++i;\n\t\t\t} else if (free) {\n\t\t\t\t--free;\n\t\t\t\t++mxDepth;\n\t\t\t} else {\n\t\t\t\td.pop_back();\n\t\t\t\t++ans;\n\t\t\t\t++mxDepth;\n\t\t\t}\n\t\t}\n\n\t\tout << ans << \"\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskC solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Subordinates.json",
    "editorial_link": "https://codeforces.com//blog/entry/48501",
    "editorial": "At first if the chief reported that he has one or more superiors let's change as in zero. If there are workers who do not chiefs but reported that they have no superiors let assume that they reported a number which more than the other workers, for example, number n.\n\nIt is necessarily that there must be the worker which has exactly one superior. If there is no such worker let's take the worker who reported the maximum number and change this number on 1. Then we need to make the same algorithm for numbers 2, 3, and etc. while there are workers, which have not yet considered.\n\nAfter we considered all workers the answer is the number of workers which reported numbers were changed."
}