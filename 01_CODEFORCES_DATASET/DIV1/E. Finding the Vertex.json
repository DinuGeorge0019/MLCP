{"link": "https://codeforces.com//contest/1444/problem/E", "problemId": "781578", "problem_idx": "E", "shortId": "1444E", "contest_number": "1444", "problem_submissions": {"E": [177060864, 97660118, 97359218, 97528673, 105295397, 97391457, 107899094], "D": [97340003, 97340266, 97342285, 97342896, 97337709, 97340895, 97341601, 97345333, 97349700, 97373326, 97348927, 97326702, 97346935, 97347842, 97348566, 97344354, 97348921, 97341198, 97348249, 97341495, 97349542], "C": [97320701, 97319171, 97319507, 97327690, 97320892, 97327102, 97328013, 97321796, 97328337, 97336256, 97330742, 97325357, 97336388, 97333742, 97327914, 97322996, 97331358, 99653258, 97349832, 97328361], "B": [97309345, 97307941, 97312731, 97313742, 97309124, 97318228, 97312056, 97312423, 97316008, 97338138, 97314968, 97311029, 97312318, 97313371, 97314101, 97346837, 97315650, 97314655, 97317415], "A": [97303759, 97308441, 97306115, 97307464, 97305751, 97307808, 97306079, 97306446, 97310249, 97339306, 97309724, 97306667, 97305992, 97307462, 97306550, 97306839, 97306977, 97308612, 97308951]}, "name": "E. Finding the Vertex", "statement": "You are given a tree connected undirected graph without cycles. One\r\nvertex of the tree is special, and you have to find which one. You can\r\nask questions in the following form: given an edge of the tree, which\r\nendpoint is closer to the special vertex, meaning which endpoint\u2019s\r\nshortest path to the special vertex contains fewer edges. You have to\r\nfind the special vertex by asking the minimum number of questions in the\r\nworst case for a given tree.Please note that the special vertex might\r\nnot be fixed by the interactor in advance: it might change the vertex to\r\nany other one, with the requirement of being consistent with the\r\npreviously given answers.\r\n", "solutions": ["#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &as) { const int sz = as.size(); os << \"[\"; for (int i = 0; i < sz; ++i) { if (i >= 256) { os << \", ...\"; break; } if (i > 0) { os << \", \"; } os << as[i]; } return os << \"]\"; }\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cerr << *i << \" \"; cerr << endl; }\ntemplate <class T> bool chmin(T &t, const T &f) { if (t > f) { t = f; return true; } return false; }\ntemplate <class T> bool chmax(T &t, const T &f) { if (t < f) { t = f; return true; } return false; }\n\n\nconstexpr unsigned __int128 toUInt128(const char *s) {\n  unsigned __int128 x = 0;\n  for (; *s; ++s) x = x * 10 + (*s - '0');\n  return x;\n}\nconstexpr __int128 toInt128(const char *s) {\n  if (*s == '-') return -toInt128(s + 1);\n  __int128 x = 0;\n  for (; *s; ++s) x = x * 10 + (*s - '0');\n  return x;\n}\nunsigned __int128 inUInt128() {\n  static char buf[41];\n  scanf(\"%s\", buf);\n  return toUInt128(buf);\n}\n__int128 inInt128() {\n  static char buf[41];\n  scanf(\"%s\", buf);\n  return toInt128(buf);\n}\n\nvoid out(unsigned __int128 x) {\n  static char buf[41];\n  int len = 0;\n  do { buf[len++] = '0' + static_cast<int>(x % 10); } while (x /= 10);\n  for (int i = len; --i >= 0; ) putchar(buf[i]);\n}\nvoid out(__int128 x) {\n  if (x < 0) {\n    putchar('-');\n    out(-static_cast<unsigned __int128>(x));\n  } else {\n    out(static_cast<unsigned __int128>(x));\n  }\n}\nstd::ostream &operator<<(std::ostream &os, unsigned __int128 x) {\n  static char buf[41];\n  int len = 0;\n  do { buf[len++] = '0' + static_cast<int>(x % 10); } while (x /= 10);\n  for (int i = len; --i >= 0; ) os << buf[i];\n  return os;\n}\nstd::ostream &operator<<(std::ostream &os, __int128 x) {\n  if (x < 0) {\n    os << '-' << -static_cast<unsigned __int128>(x);\n  } else {\n    os << static_cast<unsigned __int128>(x);\n  }\n  return os;\n}\n\n\n// T: monoid representing information of an interval.\n//   T()  should return the identity.\n//   T(S s)  should represent a single element of the array.\n//   T::merge(const T &l, const T &r)  should merge two intervals.\ntemplate <class T> struct SegmentTreePoint {\n  int logN, n;\n  vector<T> ts;\n  SegmentTreePoint() {}\n  explicit SegmentTreePoint(int n_) {\n    for (logN = 0, n = 1; n < n_; ++logN, n <<= 1) {}\n    ts.resize(n << 1);\n  }\n  template <class S> explicit SegmentTreePoint(const vector<S> &ss) {\n    const int n_ = ss.size();\n    for (logN = 0, n = 1; n < n_; ++logN, n <<= 1) {}\n    ts.resize(n << 1);\n    for (int i = 0; i < n_; ++i) at(i) = T(ss[i]);\n    build();\n  }\n  T &at(int i) {\n    return ts[n + i];\n  }\n  void build() {\n    for (int u = n; --u; ) merge(u);\n  }\n\n  inline void merge(int u) {\n    ts[u].merge(ts[u << 1], ts[u << 1 | 1]);\n  }\n\n  // Changes the value of point a to s.\n  template <class S> void change(int a, const S &s) {\n    assert(0 <= a); assert(a < n);\n    ts[a += n] = T(s);\n    for (; a >>= 1; ) merge(a);\n  }\n\n  // Applies T::f(args...) to point a.\n  template <class F, class... Args>\n  void ch(int a, F f, Args &&... args) {\n    assert(0 <= a); assert(a < n);\n    (ts[a += n].*f)(args...);\n    for (; a >>= 1; ) merge(a);\n  }\n\n  // Calculates the product for [a, b).\n  T get(int a, int b) {\n    assert(0 <= a); assert(a <= b); assert(b <= n);\n    if (a == b) return T();\n    a += n; b += n;\n    T prodL, prodR, t;\n    for (int aa = a, bb = b; aa < bb; aa >>= 1, bb >>= 1) {\n      if (aa & 1) { t.merge(prodL, ts[aa++]); prodL = t; }\n      if (bb & 1) { t.merge(ts[--bb], prodR); prodR = t; }\n    }\n    t.merge(prodL, prodR);\n    return t;\n  }\n\n  // Calculates T::f(args...) of a monoid type for [a, b).\n  //   op(-, -)  should calculate the product.\n  //   e()  should return the identity.\n  template <class Op, class E, class F, class... Args>\n#if __cplusplus >= 201402L\n  auto\n#else\n  decltype((std::declval<T>().*F())())\n#endif\n  get(int a, int b, Op op, E e, F f, Args &&... args) {\n    assert(0 <= a); assert(a <= b); assert(b <= n);\n    if (a == b) return e();\n    a += n; b += n;\n    auto prodL = e(), prodR = e();\n    for (int aa = a, bb = b; aa < bb; aa >>= 1, bb >>= 1) {\n      if (aa & 1) prodL = op(prodL, (ts[aa++].*f)(args...));\n      if (bb & 1) prodR = op((ts[--bb].*f)(args...), prodR);\n    }\n    return op(prodL, prodR);\n  }\n\n  // Find min b s.t. T::f(args...) returns true,\n  // when called for the partition of [a, b) from left to right.\n  //   Returns n + 1 if there is no such b.\n  template <class F, class... Args>\n  int findRight(int a, F f, Args &&... args) {\n    assert(0 <= a); assert(a <= n);\n    if ((T().*f)(args...)) return a;\n    if (a == n) return n + 1;\n    a += n;\n    for (; ; a >>= 1) if (a & 1) {\n      if ((ts[a].*f)(args...)) {\n        for (; a < n; ) {\n          if (!(ts[a <<= 1].*f)(args...)) ++a;\n        }\n        return a - n + 1;\n      }\n      ++a;\n      if (!(a & (a - 1))) return n + 1;\n    }\n  }\n\n  // Find max a s.t. T::f(args...) returns true,\n  // when called for the partition of [a, b) from right to left.\n  //   Returns -1 if there is no such a.\n  template <class F, class... Args>\n  int findLeft(int b, F f, Args &&... args) {\n    assert(0 <= b); assert(b <= n);\n    if ((T().*f)(args...)) return b;\n    if (b == 0) return -1;\n    b += n;\n    for (; ; b >>= 1) if ((b & 1) || b == 2) {\n      if ((ts[b - 1].*f)(args...)) {\n        for (; b <= n; ) {\n          if (!(ts[(b <<= 1) - 1].*f)(args...)) --b;\n        }\n        return b - n - 1;\n      }\n      --b;\n      if (!(b & (b - 1))) return -1;\n    }\n  }\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// given binary integers a[i]\n// minimize  \\sum_i b[i]\n// subject to  b[i] >= a[i]  &&  b[i] \\cap b[j] = 0\nstruct AdditionWithoutCarry {\n  string ans;\n  // (pos, next largest)\n  vector<pair<int, int>> ones;\n  // u: index in ones -> index in seg\n  vector<int> ord;\n\n  void addBigEndian(string s) {\n    const int len = s.size();\n    int last = -1;\n    for (int x = 0; x < len; ++x) if (s[len - 1 - x] == '1') {\n      ones.emplace_back(x, last);\n      last = (int)ones.size() - 1;\n    }\n  }\n  template <class T> void addInt(T a) {\n    int last = -1;\n    for (int x = 0; a; ++x) {\n      if (a >> x & 1) {\n        ones.emplace_back(x, last);\n        last = (int)ones.size() - 1;\n        a &= a - 1;\n      }\n    }\n  }\n\n  // max (pos + (index from right))\n  struct Node {\n    int mx, num, id;\n    Node() : mx(-1), num(0), id(-1) {}\n    Node(int val, int id_) : mx(val), num(1), id(id_) {}\n    void merge(const Node &l, const Node &r) {\n      if (l.mx + r.num <= r.mx) {\n        mx = r.mx;\n        id = r.id;\n      } else {\n        mx = l.mx + r.num;\n        id = l.id;\n      }\n      num = l.num + r.num;\n    }\n  };\n  SegmentTreePoint<Node> seg;\n  bool rec(int used, int r) {\n    const auto res = seg.get(0, r);\n    const int u = res.id;\n    if (!~u) return true;\n    const int x = ones[u].first;\n    const int k = seg.get(ord[u], r).num;\n    // try to assign 1 for [x, x + k)\n    if (x + k <= used) {\n      const int v = ones[u].second;\n      if (~v) seg.change(ord[v], Node(ones[v].first, v));\n      if (rec(x, ord[u])) {\n        fill(ans.begin() + x, ans.begin() + (x + k), '1');\n        return true;\n      }\n      if (~v) seg.change(ord[v], Node());\n    }\n    // try to assign 1 for [x + 1, x + 1 + k)\n    if (x + 1 + k <= used) {\n      if (rec(x + 1, ord[u])) {\n        fill(ans.begin() + (x + 1), ans.begin() + (x + 1 + k), '1');\n        return true;\n      }\n    }\n    return false;\n  }\n  void run() {\n    if (ones.empty()) {\n      // might need \"0\"\n      ans = \"\";\n      return;\n    }\n    const int onesLen = ones.size();\n    int limX = 0;\n    for (int u = 0; u < onesLen; ++u) chmax(limX, ones[u].first + 1);\n    vector<vector<int>> uss(limX);\n    for (int u = 0; u < onesLen; ++u) uss[ones[u].first].push_back(u);\n    ord.assign(onesLen, -1);\n    {\n      int id = 0;\n      for (int j = 0; j < limX; ++j) {\n        sort(uss[j].begin(), uss[j].end(), [&](int u, int v) -> bool {\n          return (((~ones[u].second) ? ord[ones[u].second] : -1) < \n                  ((~ones[v].second) ? ord[ones[v].second] : -1));\n        });\n        for (const int u : uss[j]) ord[u] = id++;\n      }\n    }\n    seg = SegmentTreePoint<Node>(onesLen);\n    for (int u = 0; u < onesLen; ++u) {\n      if (~ones[u].second) seg.at(ord[ones[u].second]) = Node();\n      seg.at(ord[u]) = Node(ones[u].first, u);\n    }\n    seg.build();\n    ans.assign(seg.ts[1].mx + 2, '0');\n    rec(seg.ts[1].mx + 2, onesLen);\n    if (ans.back() == '0') ans.pop_back();\n    assert(!ans.empty());\n    assert(ans.back() == '1');\n  }\n};\n\n\nint N;\nvector<int> A, B;\n\nint Ask(int i) {\n  printf(\"? %d %d\\n\", A[i] + 1, B[i] + 1);\n  fflush(stdout);\n  int u;\n  scanf(\"%d\", &u);\n  --u;\n  return u;\n}\nvoid Answer(int u) {\n  printf(\"! %d\\n\", u + 1);\n  fflush(stdout);\n}\n\nvector<vector<int>> G;\nvector<int> del;\n\nvector<__int128> dp;\nint neck, cut;\nvoid dfs(int u, int pi) {\n  for (const int i : G[u]) if (!del[i] && pi != i) {\n    const int v = A[i] ^ B[i] ^ u;\n    dfs(v, i);\n  }\n  __int128 mx = -1;\n  int im = -1;\n  AdditionWithoutCarry f;\n  for (const int i : G[u]) if (!del[i] && pi != i) {\n    const int v = A[i] ^ B[i] ^ u;\n    if (chmax(mx, dp[v])) {\n      im = i;\n    }\n    f.addInt(dp[v] + 1);\n  }\n  f.run();\n  dp[u] = 0;\n  for (int x = 0; x < (int)f.ans.size(); ++x) if (f.ans[x] == '1') {\n    dp[u] |= (__int128)1 << x;\n    if (chmax(neck, x)) {\n      cut = im;\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  A.resize(N - 1);\n  B.resize(N - 1);\n  for (int i = 0; i < N - 1; ++i) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n    --A[i];\n    --B[i];\n  }\n  \n  G.assign(N, {});\n  for (int i = 0; i < N - 1; ++i) {\n    G[A[i]].push_back(i);\n    G[B[i]].push_back(i);\n  }\n  del.assign(N - 1, 0);\n  \n  for (int r = 0; ; ) {\n    neck = -1;\n    cut = -1;\n    dp.assign(N, -1);\n    dfs(r, -1);\n// cerr<<\"dp = \"<<dp<<endl;\n    if (~cut) {\n      del[cut] = 1;\n      r = Ask(cut);\n    } else {\n      Answer(r);\n      break;\n    }\n  }\n  \n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dfs and similar", "dp", "interactive", "trees"], "dificulty": "3500", "interactive": false}