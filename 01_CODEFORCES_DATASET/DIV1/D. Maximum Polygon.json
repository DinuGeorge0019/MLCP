{
    "link": "https://codeforces.com//contest/2077/problem/D",
    "problemId": "3258033",
    "problem_idx": "D",
    "shortId": "2077D",
    "contest_number": "2077",
    "problem_submissions": {
        "G": [
            309832760,
            309860088,
            309851540,
            309848221,
            311207472,
            310643380,
            309915851,
            309944262
        ],
        "F": [
            309823042,
            309848959,
            309836201,
            309847924,
            309850803,
            309857022,
            309854713,
            309842987,
            309854239,
            310235363,
            310235052,
            309864534,
            311561393,
            309848336,
            309865507,
            309848201,
            309920332
        ],
        "E": [
            309814547,
            309822026,
            309803897,
            309812180,
            309819977,
            309821234,
            309826906,
            309814658,
            309814285,
            309826850,
            309828976,
            309810457,
            309817172,
            309822795,
            309821505,
            309823930,
            309833684,
            309841497
        ],
        "D": [
            309810661,
            309841330,
            309817779,
            309828860,
            309864595,
            309838978,
            309831379,
            309838725,
            309833102,
            309844316,
            309857259,
            309845857,
            309834684,
            309837147,
            309839781,
            309843697,
            309834330
        ],
        "C": [
            309796305,
            309810106,
            309790482,
            309800177,
            309798892,
            309797717,
            309811288,
            309792650,
            309808525,
            309807618,
            309801148,
            309800770,
            309804252,
            309798025,
            309803813,
            309813707,
            309813039
        ],
        "B": [
            309784641,
            309781213,
            309781563,
            309787242,
            309783611,
            309775002,
            309793111,
            309779586,
            309794861,
            309797121,
            309792810,
            309785991,
            309784888,
            309781524,
            309791774,
            309797996,
            309797135
        ],
        "A": [
            309769674,
            309774026,
            309772451,
            309770706,
            309770901,
            309768685,
            309779277,
            309769944,
            309780319,
            309777428,
            309775104,
            309774863,
            309769470,
            309769900,
            309773872,
            309773155,
            309785608
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140505",
    "editorial": "SolutionSuppose we consider some integer , and we try to find the\r\nlexicographically largest subsequence (say ) such that the maximum\r\nelement of is .We can do it greedily.For the subsequence to be valid, we\r\nneed to ensure that the sum of the elements of is greater than .So, our\r\ngreedy strategy is like we have an empty vector , and we iterate over\r\nthe array from left to right, and for each element , we do the\r\nfollowing:If is not empty and is greater than the last element of , we\r\nwill check whether we can make the total sum of greater than , if we\r\nremove the last element of . Now what can be the maximum possible sum of\r\n? We can just append all the elements of which are less than or equal to\r\n, and are present to the right of to .Append to .Thus, we see that the\r\nsubsequence is the lexicographically largest subsequence such that the\r\nmaximum element of is .Now, we have candidates for the maximum element\r\nof . We cannot find the best subsequence for each candidate, as it will\r\nbe too slow.Here comes the key observation.Now, what can be the maximum\r\npossible size of a sorted vector such that there does not exist any\r\nsubsequence of which can form the sides of a valid polygon?We should\r\nhave .Now, to get the maximum possible size of , we should have and for\r\n.Thus, the maximum possible size of can be .Our claim is that in the\r\nlexicographically largest subsequence , the maximum element should be\r\none of the largest elements of .Suppose we do not have the maximum\r\nelement of in the largest elements of . Letâ€™s consider the multiset of\r\nthe largest elements of . As we saw above, there should be a subsequence\r\n(say ) of this multiset which forms the sides of a valid polygon. Now if\r\nwe insert the elements of in , we will get a subsequence such that is\r\nvalid and is lexicographically larger than .Thus, we cannot have a\r\nsubsequence such that is the largest possible subsequence and the\r\nmaximum element of is not in the largest elements of .Time complexity:\r\nper test case.Submission: 310298095\r\n",
    "name": "D. Maximum Polygon",
    "statement": "Given an array a of length n, determine the lexicographically largest^{\r\ntext{ }} subsequence^{\r\ntext{ }} s of a such that s can be the side lengths of a polygon.Recall\r\nthat s can be the side lengths of a polygon if and only if |s|\r\ngeq 3 and 2\r\ncdot\r\nmax(s_1, s_2,\r\nldots, s_{|s|}) < s_1 + s_2 +\r\nldots + s_{|s|}. If no such subsequence s exists, print -1.^{\r\ntext{ }}A sequence x is lexicographically smaller than a sequence y if\r\nand only if one of the following holds: x is a prefix of y, but x\r\nne y; in the first position where x and y differ, the sequence x has a\r\nsmaller element than the corresponding element in y.^{\r\ntext{ }}A sequence x is a subsequence of a sequence y if x can be\r\nobtained from y by deleting several (possibly zero or all) elements.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Maximum Polygon.json",
    "hint": [
        "Hint 1 Find a way to get the answer if you fixed the largest value or the first value of the subsequence.",
        "Hint 2 Sufficiently long (which is not that long) arrays will definitely be polygon side lengths."
    ]
}