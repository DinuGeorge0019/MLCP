{"link": "https://codeforces.com//contest/201/problem/C", "problemId": "1457", "problem_idx": "C", "shortId": "201C", "contest_number": "201", "problem_submissions": {"D": [1842426, 1845322, 1848015, 2017065, 1845704, 1843679, 1843165, 1843645, 1843721, 1842642, 3962764, 1843892], "E": [1841059, 1842295, 1842570, 1848002, 1842412, 1843333, 1841361, 1842083, 1843064, 1842151, 1843347], "A": [1840364, 1839374, 1839153, 1847954, 1840731, 1839399, 1844333, 1839094, 1839993, 1841295, 1840073, 1839956, 1838952, 1839521, 1838849, 1839719, 1839105, 1839524], "C": [1840066, 1840781, 1840491, 1847992, 1840261, 1840947, 1839278, 1840815, 1841258, 1842024, 1841894, 1844043, 1841094, 1844134, 1840094, 1867350, 1840802, 1840979], "B": [1839596, 1838940, 1839961, 1847965, 1841485, 1840001, 1840567, 1839860, 1841578, 1839437, 1840889, 1840454, 1839972, 1839833, 1841387, 1839459, 1840240, 1840100, 1840475]}, "name": "C. Fragile Bridges", "statement": "You are playing a video game and you have just reached the bonus level,\r\nwhere the only possible goal is to score as many points as possible.\r\nBeing a perfectionist, you\u2019ve decided that you won\u2019t leave this level\r\nuntil you\u2019ve gained the maximum possible number of points there.The\r\nbonus level consists of small platforms placed in a line and numbered\r\nfrom to from left to right and () bridges connecting adjacent platforms.\r\nThe bridges between the platforms are very fragile, and for each bridge\r\nthe number of times one can pass this bridge from one of its ends to the\r\nother before it collapses forever is known in advance.The player\u2019s\r\nactions are as follows. First, he selects one of the platforms to be the\r\nstarting position for his hero. After that the player can freely move\r\nthe hero across the platforms moving by the undestroyed bridges. As soon\r\nas the hero finds himself on a platform with no undestroyed bridge\r\nattached to it, the level is automatically ended. The number of points\r\nscored by the player at the end of the level is calculated as the number\r\nof transitions made by the hero between the platforms. Note that if the\r\nhero started moving by a certain bridge, he has to continue moving in\r\nthe same direction until he is on a platform.Find how many points you\r\nneed to score to be sure that nobody will beat your record, and move to\r\nthe next level with a quiet heart.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nint a[100010];\nll dp[100010][5];\n\nint c0[] = {0, 4, 4, 4, 4};\nint c1[] = {2, 2, 2, -1, -1};\nint c2[] = {1, 1, 3, 3, -1};\n\nint main(void){\n    int N,i,j;\n    \n    cin >> N; N--;\n    REP(i,N) cin >> a[i];\n    \n    REP(i,N+1) REP(j,5) dp[i][j] = -1;\n    dp[0][0] = 0;\n    \n    REP(i,N) REP(j,5) if(dp[i][j] != -1){\n        // zero\n        dp[i+1][c0[j]] = max(dp[i+1][c0[j]], dp[i][j]);\n        \n        // odd\n        {\n            ll x = a[i];\n            if(x%2 != 1) x--;\n            if(x > 0 && c1[j] != -1) dp[i+1][c1[j]] = max(dp[i+1][c1[j]], dp[i][j] + x);\n        }\n        \n        // even\n        {\n            ll x = a[i];\n            if(x%2 != 0) x--;\n            if(x > 0 && c2[j] != -1) dp[i+1][c2[j]] = max(dp[i+1][c2[j]], dp[i][j] + x);\n        }\n    }\n    \n    ll ans = 0;\n    REP(i,N+1) REP(j,5) ans = max(ans,dp[i][j]);\n    cout << ans << endl;\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2000", "interactive": false}