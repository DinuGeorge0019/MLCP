{"link": "https://codeforces.com//contest/240/problem/E", "problemId": "1967", "problem_idx": "E", "shortId": "240E", "contest_number": "240", "problem_submissions": {"E": [27068673, 2369567, 6952646, 2369757, 2372786, 5412996, 2514695], "F": [2367683, 2368675, 2369245, 2369452, 2368590, 2369852, 2369859, 5410059, 2375572, 2369032, 2369175, 2372869, 2372867, 2372756, 2381339, 2372940, 2385773, 2373920, 2373882, 2373878, 2373867], "D": [2366591, 2366807, 2363963, 2366681, 2367043, 2367828, 2368196, 2368922, 2368559, 2366576, 2366169, 2366259, 2366076, 2366376, 2367080, 2367061, 2367534, 2366309], "B": [2364839, 2363209, 2363076, 2364268, 2364613, 2366303, 2366338, 2365433, 2365795, 2362822, 2364543, 2364502, 2364524, 2365151, 2363226, 2365069, 2363254, 2365130], "C": [2364074, 2363771, 2362766, 2363402, 2365229, 2364773, 2365070, 2366607, 2366758, 2363283, 2363525, 2363778, 2363522, 2364178, 2364017, 2363965, 2364497, 2363876], "A": [2363037, 2364923, 2364871, 2365199, 2363710, 2364055, 2364242, 2363918, 2364327, 2364439, 2363218, 2363258, 2363183, 2363585, 2365038, 2363271, 2365712, 2363292]}, "name": "E. Road Repairs", "statement": "A country named Berland has cities. They are numbered with integers from\r\nto . City with index is the capital of the country. Some pairs of cities\r\nhave monodirectional roads built between them. However, not all of them\r\nare in good condition. For each road we know whether it needs repairing\r\nor not. If a road needs repairing, then it is forbidden to use it.\r\nHowever, the Berland government can repair the road so that it can be\r\nused.Right now Berland is being threatened by the war with the\r\nneighbouring state. So the capital officials decided to send a military\r\nsquad to each city. The squads can move only along the existing roads,\r\nas there\u2019s no time or money to build new roads. However, some roads will\r\nprobably have to be repaired in order to get to some cities.Of course\r\nthe country needs much resources to defeat the enemy, so you want to be\r\ncareful with what you\u2019re going to throw the forces on. That\u2019s why the\r\nBerland government wants to repair the minimum number of roads that is\r\nenough for the military troops to get to any city from the capital,\r\ndriving along good or repaired roads. Your task is to help the Berland\r\ngovernment and to find out, which roads need to be repaired.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100000 + 10;\nconst int M = 100000 + 10;\nstruct Cost;\nvector<Cost*> csts;\n\nstruct Cost {\n\tint c;\n\tCost*a, *b; //a-b\n\tint id;\n\tint nUsed;\n\n\tbool operator<(Cost o) const { return c < o.c; }\n\tCost(int c, int id) {\n\t\tthis->c = c;this->id = id;a = b = 0;nUsed = 0;\n\t\tcsts.push_back(this);\n\t}\n\n\tCost(Cost*a, Cost*b) {\n\t\tthis->a = a;this->b = b;id = -1;c = a->c - b->c;nUsed = 0;\n\t\tcsts.push_back(this);\n\t}\n\n\tvoid push() {\n\t\tif (id == -1) {\n\t\t\ta->nUsed += nUsed;\n\t\t\tb->nUsed -= nUsed;\n\t\t}\n\t}\n\n\tvoid useIt() {++nUsed;}\n};\n\nstruct edge {\n\tint u, v;\n\tCost* cost;\n\tedge() {\n\t}\n\tedge(int u, int v, int c, int id) :\n\t\t\tu(u), v(v) {\n\t\tcost = new Cost(c, id);\n\t}\n} e[M];\n\nint pre[N], hash1[N], vis[N];\nCost* In[N];\n\nbool better(Cost*a, Cost*b) { //a better than b?\n\tif (a == 0 || b == 0)\n\t\treturn b == 0;\n\treturn a->c < b->c;\n}\nint Directed_MST(int root, int n, int m) {\n\tint ret = 0;\n\twhile (true) {\n\t\trep(i,0,n) In[i] = 0;\n\t\trep(i,0,m) {\n\t\t\tint u = e[i].u; int v = e[i].v;\n\t\t\tif (better(e[i].cost, In[v]) && u != v) {\n\t\t\t\tpre[v] = u;\n\t\t\t\tIn[v] = e[i].cost;\n\t\t\t}\n\t\t}\n\t\trep(i,0,n) {\n\t\t\tif (i == root) continue;\n\t\t\tif (In[i] == 0) return -1;\n\t\t}\n\t\tint cntnode = 0;\n\t\tmemset(hash1, -1, sizeof(int) * n);\n\t\tmemset(vis, -1, sizeof(int) * n);\n\n\t\trep(i,0,n) if (i != root) {\n\t\t\tret += In[i]->c;\n\t\t\tIn[i]->useIt();\n\t\t\tint v = i;\n\t\t\twhile (vis[v] != i && hash1[v] == -1 && v != root) {\n\t\t\t\tvis[v] = i;\n\t\t\t\tv = pre[v];\n\t\t\t}\n\t\t\tif (v != root && hash1[v] == -1) {\n\t\t\t\tfor (int u = pre[v]; u != v; u = pre[u])\n\t\t\t\t\thash1[u] = cntnode;\n\t\t\t\thash1[v] = cntnode++;\n\t\t\t}\n\t\t}\n\t\tif (cntnode == 0)\n\t\t\tbreak;\n\t\trep(i,0,n)\n\t\t\tif (hash1[i] == -1)\n\t\t\t\thash1[i] = cntnode++;\n\t\trep(i,0,m) {\n\t\t\tint v = e[i].v;\n\t\t\te[i].u = hash1[e[i].u];\n\t\t\te[i].v = hash1[e[i].v];\n\t\t\tif (e[i].u != e[i].v) {\n\t\t\t\te[i].cost = new Cost(e[i].cost, In[v]);\n\t\t\t}\n\t\t}\n\t\tn = cntnode;\n\t\troot = hash1[root];\n\t}\n\treturn ret;\n}\nint n, m;\nint main() {\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tscanf(\"%d %d\", &n, &m);\n\tint mm = 0;\n\trep(i,0,m) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ta--, b--;\n\t\te[mm++] = edge(a, b, c, i + 1);\n\t}\n\tint ans = Directed_MST(0, n, mm);\n\tif (ans == -1)\n\t\tputs(\"-1\");\n\telse {\n\t\tcout << ans << endl;\n\t\tper(i,0,csts.size()) csts[i]->push();\n\t\tvector<int> lst;\n\t\trep(i,0,csts.size()) {\n\t\t\tCost*c = csts[i];\n\t\t\tif (c->id != -1 && c->c > 0 && c->nUsed > 0) {\n\t\t\t\tlst.push_back(c->id);\n\t\t\t}\n\t\t}\n\t\tsort(lst.begin(), lst.end());\n\t\trep(i,0,lst.size()) {\n\t\t\tcout << lst[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "greedy"], "dificulty": "2800", "interactive": false}