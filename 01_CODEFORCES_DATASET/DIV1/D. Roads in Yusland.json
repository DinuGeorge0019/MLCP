{
    "link": "https://codeforces.com//contest/671/problem/D",
    "problemId": "60095",
    "problem_idx": "D",
    "shortId": "671D",
    "contest_number": "671",
    "problem_submissions": {
        "C": [
            17859826,
            17855876,
            17856835,
            17856633,
            17868793,
            17855934,
            17861023,
            17857706,
            17875161,
            17862375,
            17859845,
            17858064,
            17861176,
            17861443,
            17859543,
            17861818,
            17860617,
            17861505
        ],
        "D": [
            17855058,
            17860093,
            17861640,
            17860506,
            17858536,
            17860074,
            17856542,
            17860536,
            17867217,
            17862092,
            113815261,
            17863344
        ],
        "B": [
            17851051,
            17851923,
            17852738,
            17851471,
            17851318,
            17850433,
            17851332,
            17864729,
            17853960,
            17851556,
            17850811,
            17852416,
            17852063,
            17850570,
            17853947,
            17852904,
            17865543,
            17854165,
            17853404,
            17855052,
            17853301
        ],
        "A": [
            17848841,
            17848804,
            17848586,
            17853033,
            17848191,
            17848166,
            17848430,
            17861560,
            17848909,
            17848654,
            17848663,
            17850636,
            17849756,
            17860496,
            17850816,
            17850150,
            17847744,
            17849814,
            17855875,
            17849520
        ]
    },
    "name": "D. Roads in Yusland",
    "statement": "Mayor of Yusland just won the lottery and decided to spent money on\r\nsomething good for town. For example, repair all the roads in the\r\ntown.Yusland consists of intersections connected by bidirectional roads.\r\nOne can travel from any intersection to any other intersection using\r\nonly these roads.There is only one road repairing company in town, named\r\n\"RC company\". Company\u2019s center is located at the intersection . RC\r\ncompany doesn\u2019t repair roads you tell them. Instead, they have workers\r\nat some intersections, who can repair only some specific paths. The -th\r\nworker can be paid coins and then he repairs on a path from to some that\r\nfrom to intersection . Mayor asks you to choose the cheapest way to hire\r\nsome subset of workers in order to repair all the roads in Yusland. It\u2019s\r\nallowed that some roads will be repaired more than once.If it\u2019s\r\nimpossible to repair all roads print .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 311111\n\n#define TASK \"1\"\n\nusing namespace std;\n\nvector<int> v[N], ch[N];\nvector<pair<int, int> > z[N];\nint n, m;\n\nint d[N];\n\n\nvoid dfs(int x, int pr, int de) {\n\td[x] = de;\n\tfor (int i = 0; i < v[x].size(); i++) {\n\t\tint to = v[x][i];\n\t\tif (to != pr) {\n\t\t\tdfs(to, x, de + 1);\n\t\t\tch[x].pb(to);\n\t\t}\n\t}\n}\n\n\nlong long dp[N];\n\nset<pair<long long, int > > Q[N];\nlong long ad[N];\nint bad = 0;\n\nvoid calc(int x) {\n\tif (ch[x].size() == 0) {\n\t\tad[x] = 0;\n\t\tfor (int i = 0; i < z[x].size(); i++) Q[x].insert(mp(z[x][i].S, z[x][i].F));\n\t\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\t\tif (Q[x].size() == 0) {\n\t\t\tbad = 1;\n\t\t\tdp[x] = 0;\n\t\t} else {\n\t\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i < ch[x].size(); i++) calc(ch[x][i]);\n\tlong long sum = 0;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tsum += dp[ch[x][i]];\n\t}\n\tint la = -1;\n\tfor (int i = 0; i < ch[x].size(); i++) {\n\t\tad[ch[x][i]] += sum - dp[ch[x][i]];\n\t\tif (la == -1 || Q[ch[x][i]].size() > Q[la].size()) la = ch[x][i];\n\t}\n\n\tfor (int i = 0; i < ch[x].size(); i++) if (ch[x][i] != la) {\n\t\tint u = ch[x][i];\n\t\tfor (auto it = Q[u].begin(); it != Q[u].end(); ++it) {\n\t\t\tlong long cost = (*it).F + ad[u] - ad[la];\n\t\t\tQ[la].insert(mp(cost, (*it).S));\n\t\t}\n\t}\n\tfor (int i = 0; i < z[x].size(); i++) {\n\t\tlong long cost = z[x][i].S + sum - ad[la];\n\t\tQ[la].insert(mp(cost, z[x][i].F));\n\t}\n\tswap(Q[la], Q[x]);\n\tad[x] = ad[la];\n\twhile (Q[x].size() > 0 && (*Q[x].begin()).S >= d[x]) Q[x].erase(Q[x].begin());\n\tif (Q[x].size() == 0) {\n\t\tbad = 1;\n\t\tdp[x] = 0;\n\t} else {\n\t\tdp[x] = ad[x] + (*Q[x].begin()).F;\n\t}\n}\n\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK\".in\",\"r\",stdin);\t\n\t\tfreopen(TASK\".out\",\"w\",stdout);\n\t#endif\t\t\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tdfs(0, 0, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y, co;\n\t\tscanf(\"%d%d%d\", &x, &y, &co);\n\t\tx--;\n\t\ty--;\n\t\tif (d[x] < d[y]) swap(x, y);\n\n\t\tz[x].pb(mp(d[y], co));\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < v[0].size(); i++) {\n\t\tcalc(v[0][i]);\n\t\tans += dp[v[0][i]];\n\t}\n\tif (bad) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Roads in Yusland.json",
    "editorial_link": "https://codeforces.com//blog/entry/44821",
    "editorial": "I want to thank GlebsHP, i originally came up with another problem\r\nsimilar to it, GlebsHP suggested to use this one in stead of it. Let\u00e2\u0080\u0099s\r\nlook for a optimal subset of paths, paths may intersect. To prevent from\r\nthis let\u00e2\u0080\u0099s change the problem litte bit. A worker can repair all nodes\r\nbetween and some , where is in the path between and with cost , also\r\npaths must not intersect. In this way we will never find better solution\r\nfrom original problem and we can express optimal subset in original\r\nproblem without any path intersections in new problem. Let\u00e2\u0080\u0099s keep a\r\narray, keeps minimum cost to cover all edges in subtree of node , also\r\nthe edge between and . How to find answer of some . Let\u00e2\u0080\u0099s choose a\r\nworker which is in the subtree of and is a parent of node . Then if we\r\nchoose this worker answer must be + ( where is child of a node in the\r\npath from to for all \u00e2\u0080\u0099s). Of course we have to exclude nodes chosen as\r\nand in the path from to since we will cover them with -th worker. We\r\nwill construct a segment tree by dfs travel times so that for all nodes,\r\nworkers which start his path in subtree of this node can be reached by\r\nlooking a contiguous segment in tree. In node , segment will keep values\r\nwhat will be equal to if we choose this worker to cover path between and\r\n. We will travel our tree with dfs, in each after we calculated node \u00e2\u0080\u0099s\r\nchildren dp\u00e2\u0080\u0099s we will update our segment in following way, add all\r\nworkers to segment where with value + (sum of node \u00e2\u0080\u0099s children dp\u00e2\u0080\u0099s).\r\nFor all workers equal to , we must delete it from segment, this is\r\nassigning to it. The only thing we didn\u00e2\u0080\u0099t handle is what to do with\r\nworkers under this node. Imagine all updates in subtree of node where is\r\na child of node . We have to increase all of them by (sum of node \u00e2\u0080\u0099s\r\nchildren dp\u00e2\u0080\u0099s-). After applying all of this operations answer will be\r\nminimum value of workers start their path from a node in subtree of in\r\nsegment tree. Overall complexity will be . Please look at the code to be\r\nmore clear.\r\n"
}