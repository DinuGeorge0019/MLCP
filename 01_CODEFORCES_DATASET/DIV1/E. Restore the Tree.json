{
    "link": "https://codeforces.com//contest/871/problem/E",
    "problemId": "128430",
    "problem_idx": "E",
    "shortId": "871E",
    "contest_number": "871",
    "problem_submissions": {
        "D": [
            31355895,
            31362333,
            31356242,
            31355369,
            31353137,
            31356572,
            31350479,
            31349876,
            31357261,
            31360056,
            31358528,
            31351384,
            31359864,
            31356104,
            31350689,
            31354294,
            31357470
        ],
        "C": [
            31344782,
            31345046,
            31354747,
            31341122,
            31347757,
            31339514,
            31345476,
            31343571,
            31352939,
            31343640,
            31347078,
            31353076,
            31354366,
            31357931,
            31352546,
            31348044,
            31356324,
            31348388,
            31344111,
            31340976
        ],
        "B": [
            31340037,
            31339973,
            31340246,
            31344130,
            31345296,
            31350867,
            31351902,
            31348642,
            31355117,
            31356940,
            31344400,
            31347404,
            31350125,
            31355555,
            31345128,
            31496128,
            31350503
        ],
        "A": [
            31334951,
            31334542,
            31334472,
            31334988,
            31334223,
            31337899,
            42189225,
            37478044,
            37460318,
            31335310,
            31335726,
            31334028,
            31336751,
            31333319,
            31341866,
            31334833,
            31352270,
            31340759,
            31335206,
            31350845,
            31354568,
            31333534,
            31334865
        ],
        "E": [
            31356130,
            31349981,
            31355349,
            31497224
        ]
    },
    "name": "E. Restore the Tree",
    "statement": "Petya had a tree consisting of vertices numbered with integers from to .\r\nAccidentally he lost his tree. Petya remembers information about\r\nvertices: distances from each of them to each of the tree vertices.Your\r\ntask is to restore any tree that satisfies the information that Petya\r\nremembers or report that such tree doesn\u2019t exist.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge {c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nvector<pair<int,int>> output;\nconst int nax = 30123;\nvector<int> w_ans[nax];\nvoid add_edge(int a, int b) {\n\tdebug() << imie(a) imie(b);\n\tw_ans[a].push_back(b);\n\tw_ans[b].push_back(a);\n\toutput.push_back({a+1, b+1});\n}\n\nvoid NO() {\n\tputs(\"-1\");\n\texit(0);\n}\n\nint n, k;\n\nvector<vector<int>> input;\nvector<int> where_zero;\n\nvoid rec(const vector<vector<int>> & tree, int which_line) {\n\t\n\tdebug() << \"rec\" imie(tree) imie(which_line);\n\t\n\tassert(!tree.empty());\n\tassert((int) tree[0].size() == 1);\n\tfor(const vector<int> & row : tree)\n\t\tif(row.empty())\n\t\t\tNO();\n\t\n\tif(which_line == k) {\n\t\tfor(int i = 1; i < (int) tree.size(); ++i)\n\t\t\tfor(int x : tree[i])\n\t\t\t\tadd_edge(tree[i-1][0], x);\n\t\treturn;\n\t}\n\t\n\tconst int spec = where_zero[which_line];\n\tint depth = -1;\n\t\n\tfor(int d = 0; d < (int) tree.size(); ++d)\n\t\tfor(int x : tree[d])\n\t\t\tif(x == spec)\n\t\t\t\tdepth = d;\n\t\n\tif(depth == -1) {\n\t\trec(tree, which_line + 1);\n\t\treturn;\n\t}\n\t\n\tvector<  vector<vector<int>> > new_trees;\n\t\n\tfor(int h = 0; h < (int) tree.size(); ++h)\n\t\tfor(int x : tree[h]) {\n\t\t\tint dist = input[which_line][x];\n\t\t\tint lca = h + depth - dist;\n\t\t\tif(lca % 2) NO();\n\t\t\tlca /= 2;\n\t\t\tdebug() << imie(lca);\n\t\t\tif(!(0 <= lca && lca < n)) NO();\n\t\t\t\n\t\t\tif((int) new_trees.size() <= lca)\n\t\t\t\tnew_trees.push_back({});\n\t\t\tif((int) new_trees.size() <= lca)\n\t\t\t\tNO();\n\t\t\t\n\t\t\tvector<vector<int>> & that_tree = new_trees[lca];\n\t\t\tint how = h - lca;\n\t\t\tif((int) that_tree.size() <= how)\n\t\t\t\tthat_tree.push_back({});\n\t\t\tif((int) that_tree.size() <= how)\n\t\t\t\tNO();\n\t\t\tthat_tree[how].push_back(x);\n\t\t}\n\t\n\tfor(const vector<vector<int>> & tr : new_trees)\n\t\tif(tr.empty() || tr[0].empty())\n\t\t\tNO();\n\t\n\tfor(int i = 1; i < (int) new_trees.size(); ++i) {\n\t\tadd_edge(new_trees[i][0][0], new_trees[i-1][0][0]);\n\t}\n\t\n\tfor(const auto & xx : new_trees)\n\t\trec(xx, which_line + 1);\n}\n\nvoid dfs(int a, int par, int so_far, const vector<int> & should) {\n\tdebug() << \"dfs\" imie(a) imie(par) imie(so_far) imie(should);\n\tif(so_far != should[a])\n\t\tNO();\n\tfor(int b : w_ans[a]) if(b != par)\n\t\tdfs(b, a, so_far + 1, should);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\t\n\tinput.resize(k, vector<int>(n));\n\twhere_zero.resize(k);\n\t\n\tfor(int which = 0; which < k; ++which) {\n\t\tvector<int> & line = input[which];\n\t\tint zeros = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tscanf(\"%d\", &line[i]);\n\t\t\tif(line[i] == 0) {\n\t\t\t\t++zeros;\n\t\t\t\twhere_zero[which] = i;\n\t\t\t}\n\t\t}\n\t\tif(zeros != 1) NO();\n\t}\n\t\n\tvector<vector<int>> tree;\n\tfor(int i = 0; i < n; ++i) {\n\t\tint v = input[0][i];\n\t\twhile((int) tree.size() <= v)\n\t\t\ttree.push_back({});\n\t\ttree[v].push_back(i);\n\t}\n\tdebug() << imie(tree);\n\trec(tree, 1);\n\t\n\tfor(int i = 0; i < k; ++i)\n\t\tdfs(where_zero[i], -1, 0, input[i]);\n\t\n\tfor(pair<int,int> p : output)\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Restore the Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/55200",
    "editorial": "In the beginning, it should be noted that it is possible to find out\r\nnumbers of vertices from which distances are given, the number of the th\r\nspecified vertex is , such that . If there is no such a vertex, or more\r\nthan one, then there is no answer.Fix the equal to some vertex from\r\nwhich distances are given in the input data. Assume . For any vertex ,\r\nwe can find vertices lying in the path from to this vertex, since for\r\nsuch and only for such vertices . And accordingly, the vertex suitable\r\nfor this condition will be at a distance from . So, we have learned to\r\nbuild a part of a tree that consists of vertices that lie on the path\r\nfrom to some vertex . If we couldn\u00e2\u0080\u0099t build the path in such a way, then\r\nthere is no answer. Time complexity of this phase is .Now consider the\r\nremaining vertices, in order of increasing depth (distance to the root).\r\nLet\u00e2\u0080\u0099s consider a fixed vertex , look at the path from it to , this path\r\ncan be divided into parts - where is the vertex from the already\r\nconstructed tree, let\u00e2\u0080\u0099s find the deepest of such , this can be done with\r\noperations by using the fact that is the deepest vertex among all ,\r\nwhich equals the vertex on the path from to at a depth of . Then the\r\nancestor is the vertex that was added in the same way to the subtree but\r\nwith a depth of less, or the vertex (if the depth is less than the depth\r\nof the vertex ). If no such vertices have been added yet, then there is\r\nno answer, since we considered the vertices in order of increasing\r\ndepth. Time complexity of adding each vertex is .The resulting tree is\r\nalso the desired tree. Time complexity of the whole algorithm is .\r\n"
}