{"link": "https://codeforces.com//contest/963/problem/E", "problemId": "175450", "problem_idx": "E", "shortId": "963E", "contest_number": "963", "problem_submissions": {"E": [37408346, 37407644, 51152346, 37411847, 37415664, 37414743, 37424807, 37560510, 63561204, 37525085], "D": [37404929, 37404881, 37407341, 37406493, 37404117, 37403898, 37407185, 37408546, 37404537, 37409644, 37405529, 37411456, 37412888, 37408258, 37411536, 37411945, 37405408, 37405454, 37410330], "C": [37403149, 37410272, 37405789, 37402217, 37408755, 37410613, 37405532, 37406058, 37410998, 37406279, 37408081, 37407255, 37409639, 37405742, 37409484, 37407736, 37415193, 37408262], "A": [37400764, 37398530, 37400243, 37398542, 37398672, 37398448, 37403076, 37400054, 37401968, 37403020, 37402655, 37401825, 37399871, 37409184, 37400223, 37401116, 37399078, 37407652], "B": [37399438, 37401875, 37403648, 37403088, 37402069, 37401815, 37401672, 37402933, 37403748, 37400539, 37403834, 37404008, 37402988, 37412215, 37402134, 37404563, 37403658, 37399677, 37411986]}, "name": "E. Circles of Waiting", "statement": "A chip was placed on a field with coordinate system onto point .Every\r\nsecond the chip moves randomly. If the chip is currently at a point ,\r\nafter a second it moves to the point with probability , to the point\r\nwith probability , to the point with probability and to the point with\r\nprobability . It\u2019s guaranteed that . The moves are independent.Find out\r\nthe expected time after which chip will move away from origin at a\r\ndistance greater than (i.e. will be satisfied).\r\n", "solutions": ["#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\nusing ll = long long;\nusing ld = long double;\nusing ull = uint64_t;\nusing namespace std;\n\nvector<pair<int,int>> pts;\n\nconst int MAXN = 7845;\n\nconst int MOD = 1e9 + 7;\n\nll pw(ll a, ll b = MOD - 2) {\n\tif (!b) {\n\t\treturn 1;\n\t}\n\n\tll v = pw(a, b / 2);\n\tv = (v * v) % MOD;\n\n\tif (b & 1) {\n\t\tv = (v * a) % MOD;\n\t}\n\n\treturn v;\n}\n\nint f[MAXN][MAXN + 1];\nll rev[MAXN];\nll ans[MAXN];\n\nint n;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\nint p[4];\nint r;\n\nbool g(int x, int y) {\n\treturn x * x + y * y <= r * r;\n}\n\nint gtid(int nx, int ny) {\n\tpair<int,int> p{nx, ny};\n\tint id =lower_bound(pts.begin(), pts.end(), p) - pts.begin();\n\treturn id;\n}\n\nconst int MV = 102;\n\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(20);\n\tcin >> r;\n\tll s = 0;\n\tfor (int& x: p) {\n\t\tcin >> x;\n\t\ts += x;\n\t}\n\n\ts = pw(s, MOD - 2);\n\tfor (int& x: p) {\n\t\tx = (s * x) % MOD;\n\t}\n\n\n\tfor (int i = -r; i <= r; ++i) {\n\t\tfor (int j = -r; j <= r; ++j) {\n\t\t\tif (g(i, j)) {\n\t\t\t\tpts.emplace_back(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tn = pts.size();\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tf[i][i] = 1;\n\t\tf[i][n] = 1;\n\n\t\tint x = pts[i].first, y = pts[i].second;\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tint nx = x + dx[j], ny = y + dy[j];\n\t\t\tif (g(nx, ny)) {\n\t\t\t\tint id = gtid(nx, ny);\n\t\t\t\tf[i][id] = -p[j];\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tassert(f[i][i]);\n\n\t\tvector<int> ids = {n};\n\t\t\n\t\tint rg = min(n, i + MV);\n\t\tfor (int j = i; j < rg; ++j) {\n\t\t\tids.push_back(j);\n\t\t}\n\n\t\trev[i] = pw(f[i][i]);\n\n\t\tfor (int j = i + 1; j < rg; ++j) {\n\t\t\tll cmul = f[j][i] * rev[i] % MOD;\n\t\t\tif (!cmul) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int id: ids) {\n\t\t\t\tf[j][id] = (f[j][id] - f[i][id] * cmul) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tll cf = f[i][n];\n\t\tint rg = min(n, i + MV);\n\n\t\tfor (int j = i + 1; j < rg; ++j) {\n\t\t\tcf = (cf - ans[j] * f[i][j]) % MOD;\n\t\t}\n\n\t\tans[i] = cf * rev[i] % MOD;\n\t}\n\n\tint id = gtid(0, 0);\n\tif (ans[id] < 0) {\n\t\tans[id] += MOD;\n\t}\n\n\tcout << ans[id] << \"\\n\";\n}\n\n\n\n\n\n"], "input": "", "output": "", "tags": ["math"], "dificulty": "3100", "interactive": false}