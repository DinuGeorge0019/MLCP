{"link": "https://codeforces.com//contest/101/problem/E", "problemId": "536", "problem_idx": "E", "shortId": "101E", "contest_number": "101", "problem_submissions": {"E": [581450, 581204, 582032, 581815, 583533, 582350, 582875, 581883, 582940, 581812, 581652, 609865, 581480], "D": [579906, 580370, 580629, 580693, 580455, 580917, 580822, 581264, 581190, 582420, 581878, 582155, 581732, 582283], "C": [578895, 579347, 578679, 583091, 579544, 583517, 579698, 580054, 580264, 580522, 579262, 580371, 580419, 580066, 579637, 580178, 581241, 579664], "B": [578351, 578696, 579172, 578659, 578843, 578821, 579066, 579006, 579025, 579013, 578685, 579291, 579413, 581846, 582516, 579343, 595573], "A": [577898, 577949, 577912, 577914, 578124, 577923, 577940, 577996, 578084, 577915, 577920, 578550, 577975, 578049, 577936, 578126, 578340, 577971]}, "name": "E. Candies and Stones", "statement": "Little Gerald and his coach Mike play an interesting game. At the\r\nbeginning of the game there is a pile consisting of candies and a pile\r\nconsisting of stones. Gerald and Mike move in turns, Mike goes first.\r\nDuring his move Mike checks how many candies and stones Gerald has\r\neaten. Let Gerald eat candies and stones. Then Mike awards Gerald prize\r\npoints. Gerald during his move either eats a candy from the pile of\r\ncandies or a stone from the pile of stones. As Mike sees that Gerald has\r\neaten everything apart one candy and one stone, he awards points for the\r\nlast time and the game ends. Gerald is not allowed to eat all the\r\ncandies, and he is not allowed to eat all the stones too. Tell Gerald\r\nhow to play to get the largest possible number of points: it is required\r\nto find one of the possible optimal playing strategies for Gerald.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:65777216\")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++) \n#define REP(i,n) FOR(i,0,n) \n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint n,m,p;\nint x[22222];\nint y[22222];\nint d[10007][650];\n\nint d1[20000];\nint d2[20000];\n\nstring res;\nbool first = true;\n\nvoid go(){\n\tif(n==0 && m==0) return;\n\tif(n==0){\n\t\tres.pb('S');\n\t\tm--;\n\t\tgo();\n\t\treturn;\n\t}\n\tif(m==0){\n\t\tres.pb('C');\n\t\tn--;\n\t\tgo();\n\t\treturn;\n\t}\n\t\n\tif(n==10000 && first){\n\t\tfirst = false;\n\t\treturn;\n\t}\n\n\tint row = n;\n\tif(row>10000) row-=10000;\n\n\tint md = m % 31;\n\tint dv = m / 31;\n\t\t\t\n\tif(d[row][dv] &(1<<md)){\n\t\tres.pb('S');\n\t\tm--;\n\t\tgo();\n\t}else{\n\t\tres.pb('C');\n\t\tn--;\n\t\tgo();\n\t}\n}\n\nint solve(){\n\tCL(d1,0);\n\tCL(d2,0);\n\tCL(d,0);\n\n\tint *f1 = d1;\n\tint *f2 = d2;\n\n\tREP(i,n){\n\t\tint md = -1;\n\t\tint dv = 0;\n\t\tREP(j,m){\n\t\t\tmd ++;\n\t\t\tif(md>=31) md-=31,dv++;\n\t\t\tint row = i;\n\t\t\tif(row>10000) row-=10000;\n\t\t\tif(d[row][dv] &(1<<md))\n\t\t\t\td[row][dv] ^= (1<<md);\n\n\t\t\tf1[j] = (x[i]+y[j]);\n\t\t\tif(f1[j]>=p) f1[j]-=p;\n\n\t\t\tint v1 = j?f1[j-1]:-1;\n\t\t\tint v2 = i?f2[j]:-1;\n\n\t\t\tif(v1==-1 && v2==-1) continue;\n\t\t\t\n\t\t\t\n\t\t\tif(v1>v2){\n\t\t\t\tf1[j] += v1;\n\t\t\t\td[row][dv] |= (1<<md);\n\t\t\t}else{\n\t\t\t\tf1[j] += v2;\n\t\t\t}\n\t\t}\n\t\tswap(f1,f2);\n\t}\n\treturn f2[m-1];\n}\n\nbool check(string s,int val){\n\tint t = (x[0] +y[0])%p;\n\tint a = 0, b = 0;\n\tREP(i,s.size()){\n\t\tif(s[i]=='C') a++;\n\t\telse b++;\n\t\tt += (x[a] + y[b])%p;\n\t}\n\tif(t!=val){\n\t\tputs(\"FUCK\");\n\t\treturn 0;\n\t}\n\telse puts(\"OK\");\n\treturn 1;\n}\n\nint main(){ \n#ifdef LocalHost\n\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\tcin>>n>>m>>p;\n\t\n\t/*int it = 0;\nhere:\n\tit++;\n\tsrand(it);\n\t\n\tn = 11111;//9999 + rand()%10 + 1;\n\tm = 5;// + rand() %100 + 1;\n\tp = rand() % 1000 + 1;\n\t*/\n\tREP(i,n){\n\t\tscanf(\"%d\",x+i);\n\t\t//x[i] = rand();\n\t\tx[i]%=p;\n\t}\n\tREP(i,m){\n\t\tscanf(\"%d\",y+i);\n\t\t//y[i] = rand();\n\t\ty[i]%=p;\n\t}\n\t\n\tres=\"\";\n\tint qq = solve();\n\tcout<<qq<<endl;\n\tn--,m--;\n\tgo();\n\tn++,m++;\n\tsolve();\n\tn--,m--;\n\tgo();\n\treverse(res.begin(),res.end());\n\t//if(check(res,qq))\n\t//\tgoto here;\n\tprintf(\"%s\\n\",res.c_str());\n#ifdef LocalHost\n\tcout<<endl<<endl<<\"TIME: \"<<clock()<<endl;\n#endif\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["divide and conquer", "dp"], "dificulty": "2500", "interactive": false}