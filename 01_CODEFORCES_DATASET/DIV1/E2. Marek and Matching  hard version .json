{"link": "https://codeforces.com//contest/1229/problem/E2", "problemId": "419080", "problem_idx": "E2", "shortId": "1229E2", "contest_number": "1229", "problem_submissions": {"E2": [66535857, 61153989, 61162985, 61167725, 61164541, 61175914, 73169874, 73169292, 67251679, 61176348, 61171644, 61168314, 61282274], "C": [61156990, 61139280, 61133462, 61168973, 61144252, 61152507, 61152114, 61139574, 61138824, 61139511, 61146010, 61154268, 61140423, 61146503, 61146999, 61163280, 61145517, 61140699], "E1": [61153988, 61160360, 61157052, 61164602, 61165567, 61168930, 61169365, 61171555, 61161774, 61282244, 91100857], "D": [61143107, 61152425, 61148639, 61156853, 61153552, 61162885, 61162936, 61151975, 61157442, 61157392, 61156341, 61210834, 61160744, 61159221, 61160510, 61155666, 61165039, 61163062], "B": [61128405, 61132933, 61165615, 61142364, 61131741, 61140527, 61129638, 61133794, 61131083, 61134616, 61139186, 61132543, 61141781, 61139438, 61135873, 61137164, 61151652], "A": [61122880, 61126193, 61123596, 61131920, 61125660, 61128699, 61125244, 61171108, 61124176, 61136192, 61128585, 61129134, 61124511, 61133577, 61132336, 61124059, 61130617, 61131139], "F": [61198842, 61176125, 61453900, 61180269, 61179508, 61398042]}, "name": "E2. Marek and Matching  hard version ", "statement": "Marek is working hard on creating strong test cases to his new\r\nalgorithmic problem. Do you want to know what it is? Nah, we\u2019re not\r\ntelling you. However, we can tell you how he generates test cases.Marek\r\nchooses an integer n and n^2 integers p_{ij} (1\r\nle i\r\nle n, 1\r\nle j\r\nle n). He then generates a random bipartite graph with 2n vertices.\r\nThere are n vertices on the left side:\r\nell_1,\r\nell_2,\r\ndots,\r\nell_n, and n vertices on the right side: r_1, r_2,\r\ndots, r_n. For each i and j, he puts an edge between vertices\r\nell_i and r_j with probability p_{ij} percent.It turns out that the\r\ntests will be strong only if a perfect matching exists in the generated\r\ngraph. What is the probability that this will occur?It can be shown that\r\nthis value can be represented as\r\nfrac{P}{Q} where P and Q are coprime integers and Q\r\nnot\r\nequiv 0\r\npmod{10^9+7}. Let Q^{-1} be an integer for which Q\r\ncdot Q^{-1}\r\nequiv 1\r\npmod{10^9+7}. Print the value of P\r\ncdot Q^{-1} modulo 10^9+7.\r\n", "solutions": ["// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC optimize(\"Ofast,no-stack-protector\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define debug(x) std::cerr << (#x) << \":\\t\" << (x) << std::endl;\n#define fastIO std::ios_base::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);\n#define NAME \"Problem Name\"\n\ntypedef long long ll;\ntypedef long double ld;\n\nstd::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst double PI = atan2(0., -1.);\nconst int INF = 0x3f3f3f3f;\nconst int N = 10;\nconst int MOD = (int)1e9 + 7;\n\nint add(int a, int b) {\n\tif (a + b >= MOD) {\n\t\treturn a + b - MOD;\n\t}\n\treturn a + b;\n}\n\nint sub(int a, int b) {\n\tif (a - b < 0) {\n\t\treturn a - b + MOD;\n\t}\n\treturn a - b;\n}\n\nint mul(int a, int b) {\n\treturn 1ll * a * b % MOD;\n}\n\nint binpow(int a, int n) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n % 2 == 0) {\n\t\treturn binpow(mul(a, a), n / 2);\n\t} else {\n\t\treturn mul(binpow(a, n - 1), a);\n\t}\n}\n\nint rev(int a) {\n\treturn binpow(a, MOD - 2);\n}\n\nint p[N][N], q[N][N];\nint ppp[N][1 << N];\n\nint main(void) {\n\t// #ifdef ONLINE_JUDGE\n\t// \tfreopen(NAME\".in\", \"r\", stdin);\n\t// \tfreopen(NAME\".out\", \"w\", stdout);\n\t// #endif\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tscanf(\"%d\", &p[i][j]);\n\t\t\tq[i][j] = 100 - p[i][j];\n\n\t\t\tp[i][j] = mul(p[i][j], rev(100));\n\t\t\tq[i][j] = mul(q[i][j], rev(100));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int mask = 0; mask < (1 << n); ++mask) {\n\t\t\tint prob = 1;\n\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (((mask >> j) & 1) == 1) {\n\t\t\t\t\tprob = mul(prob, p[i][j]);\n\t\t\t\t} else {\n\t\t\t\t\tprob = mul(prob, q[i][j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tppp[i][mask] = prob;\n\t\t}\n\t}\n\n\tstd::vector<std::pair<std::vector<int>, int>> q;\n\tq.push_back(std::make_pair(std::vector<int>(1, 0), 1));\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tstd::vector<std::pair<std::vector<int>, int>> newQ;\n\n\t\t// debug(i);\n\t\t// debug(q.size());\n\n\t\tstd::map<std::vector<int>, int> mapikkkkkkumenyagoritzhopaaa;\n\n\t\tfor (int mask = 0; mask < (1 << n); ++mask) {\n\t\t\tfor (auto cur : q) {\n\t\t\t\tauto allPrevMasks = cur.first;\n\t\t\t\tint prevProb = cur.second;\n\t\t\t\tint curProb = ppp[i][mask];\n\t\t\t\t// int curProb = 0; \n\t\t\t\t// debug(prevProb);\n\n\t\t\t\t// debug(q[0].first);\n\t\t\t\t// debug(q[1].first);\n\n\t\t\t\t// std::vector<std::pair<int, int>> sh;\n\t\t\t\tstd::vector<int> curShit;\n\n\t\t\t\tfor (auto prevMask : allPrevMasks) {\n\t\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\t\tif (((mask) & (1 << j)) != 0 && ((prevMask) & (1 << j)) == 0) {\n\t\t\t\t\t\t\tcurShit.push_back(prevMask | (1 << j));\n\t\t\t\t\t\t\t// debug(mul(prevProb, curProb));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tstd::sort(curShit.begin(), curShit.end());\n\t\t\t\tcurShit.resize(std::unique(curShit.begin(), curShit.end()) - curShit.begin());\n\n\t\t\t\tif (!curShit.empty()) {\n\t\t\t\t\tmapikkkkkkumenyagoritzhopaaa[curShit] = add(mapikkkkkkumenyagoritzhopaaa[curShit], mul(prevProb, curProb));\n\t\t\t\t\t// newQ.push_back(std::make_pair(curShit, mul(prevProb, curProb)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (auto i : mapikkkkkkumenyagoritzhopaaa) {\n\t\t\tnewQ.push_back(i);\n\t\t}\n\n\t\t// debug(newQ.size());\n\n\t\tq.swap(newQ);\n\t}\n\n\t// debug(q.size());\n\n\tint ans = 0;\n\tfor (auto i : q) {\n\t\t// debug(i.second);\n\t\tans = add(ans, i.second);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["brute force", "probabilities"], "dificulty": "3200", "interactive": false}