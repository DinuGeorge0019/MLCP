{
    "link": "https://codeforces.com//contest/850/problem/F",
    "problemId": "120880",
    "problem_idx": "F",
    "shortId": "850F",
    "contest_number": "850",
    "problem_submissions": {
        "E": [
            30079147,
            30079321,
            30076520,
            30070445,
            30072131,
            30067095,
            30068181,
            30093004,
            30078840,
            30069238,
            30121826,
            30081582,
            30080429,
            30062854,
            30075459,
            30063501
        ],
        "C": [
            30074039,
            30065285,
            30068848,
            30063413,
            30062879,
            30062229,
            30071925,
            30062969,
            30065613,
            30065926,
            30075756,
            30070129,
            30073758,
            30065190,
            30073153,
            30074735,
            30076259,
            30065744,
            30070888
        ],
        "A": [
            30069678,
            30056916,
            30058041,
            30057755,
            30055909,
            30056498,
            30059213,
            30058881,
            30065583,
            30059587,
            30062587,
            30059533,
            30059618,
            30080413,
            30064068,
            30056411,
            30066966,
            30056135,
            30056956,
            30066903
        ],
        "B": [
            30068250,
            30061127,
            30081762,
            30072437,
            30058838,
            30066243,
            30062293,
            30085846,
            30070994,
            30120525,
            30071520,
            30064497,
            30064013,
            30059633,
            30059864,
            30081342,
            30120546,
            30077952,
            30076711
        ],
        "F": [
            30064851,
            30071271,
            30075755,
            30077357,
            30079821,
            30089510,
            30071025
        ],
        "D": [
            30071702,
            30081255,
            30092254,
            30077349,
            30092387,
            30073378,
            30075318,
            30101681,
            30076176,
            30093362,
            30082776,
            30070573
        ]
    },
    "name": "F. Rainbow Balls",
    "statement": "You have a bag of balls of different colors. You have balls of the -th\r\ncolor.While there are at least two different colored balls in the bag,\r\nperform the following steps: Take out two random balls without\r\nreplacement one by one. These balls might be the same color. Color the\r\nsecond ball to the color of the first ball. You are not allowed to\r\nswitch the order of the balls in this step. Place both balls back in the\r\nbag. All these actions take exactly one second. Let . It can be proven\r\nthat the expected amount of time needed before you stop can be\r\nrepresented as a rational number , where and are coprime integers and\r\nwhere is not divisible by . Return the value .\r\n",
    "solutions": [
        "#include<map>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 100000 + 10;\nconst int MOD = (int)1e9 + 7;\n\nint n;\nint a[N];\nlong long f[N];\n\nlong long mod_pow(long long a, long long p, long long MOD)\n{\n    long long ret = 1;\n    for( ; p; p >>= 1) {\n        if (p & 1) ret = ret * a % MOD;\n        a = a * a % MOD;\n    }\n    return ret;\n}\n\nlong long inv(long long x)\n{\n    return mod_pow(x, MOD - 2, MOD);\n}\n\nvoid solve()\n{\n    cin >> n;\n    long long c = 0;\n    for(int i = 0; i < n; ++ i) {\n        scanf(\"%d\", a + i);\n        c += a[i];\n    }\n    f[0] = 0;\n    f[1] = (c - 1) * (c - 1) % MOD * inv(c) % MOD;\n    for(int i = 1; i + 1 < N; ++ i) {\n        f[i + 1] = (2 * f[i] - f[i - 1] - (c - 1) * inv(c - i)) % MOD;\n    }\n    long long ans = 0;\n    for(int i = 0; i < n; ++ i) {\n        ans += f[a[i]];\n    }\n    cout << (ans % MOD + MOD) % MOD << endl;\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Rainbow Balls.json",
    "editorial_link": "https://codeforces.com//blog/entry/54317",
    "editorial": "First, let\u00e2\u0080\u0099s fix the final color of the balls.After fixing the final\r\ncolor, we can see the other colors don\u00e2\u0080\u0099t matter.Define an \"interesting\"\r\ndraw as one where we choose a ball of the final color and one of a\r\ndifferent color.Once we do an interesting draw, we can see there is an\r\nequal probability of increasing or decreasing the number of balls of our\r\nfinal color.So, we can view this as a random walk, with equal\r\nprobability of going in either direction. Let be the number of balls of\r\nthe final color at time . Let be the first time we hit 0 or balls.Now,\r\nwe can write the expected value of time as follows: Let (i.e. in words,\r\nexpected value of time, given we are at , only counting the events that\r\nreach first).Let be the probability of an interesting draw, so . Then,\r\nwe can write . Rearranging gives us .So, in particular, So, letting , we\r\nget . Doing some more manipulation can get us .So, we just need to print\r\nthe sum of .\r\n"
}