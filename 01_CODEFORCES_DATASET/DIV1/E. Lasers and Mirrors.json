{"link": "https://codeforces.com//contest/1063/problem/E", "problemId": "236989", "problem_idx": "E", "shortId": "1063E", "contest_number": "1063", "problem_submissions": {"F": [44321779, 44310989, 44539942, 44524512, 44473039, 44472562, 50480317, 51150998, 44317621, 44317615, 44312825, 44373124], "D": [44311197, 44305997, 44303323, 44313702, 44361765, 44361136, 44376357, 44376258, 44307498, 44337552, 44311559, 44305058, 44311516, 44304459, 44311498, 44312697, 44315110], "E": [44305503, 44313651, 44315069, 44307031, 44313364, 44308262, 44337210, 44313717, 44317640, 44314472, 44311650], "C": [44298733, 44296257, 44305349, 44298667, 44298705, 44299697, 44299069, 44300205, 44299465, 44299657, 44301626, 44302301, 44304486, 44306960, 44302436, 44309287, 44301972, 44304513, 44301966], "A": [44295781, 44291759, 44291627, 44296582, 44291453, 44291198, 44292770, 44291128, 44296111, 44296432, 44292644, 44293693, 44292723, 44296227, 44292099, 44305135, 44297417, 44292247, 44291472], "B": [44295123, 44298986, 44296043, 44295205, 44297251, 44302092, 44296710, 44297936, 44295873, 44297588, 44298080, 44299136, 44294684, 44297166, 44295722, 44296834, 44296659, 44296927]}, "name": "E. Lasers and Mirrors", "statement": "Oleg came to see the maze of mirrors. The maze is a n by n room in which\r\neach cell is either empty or contains a mirror connecting opposite\r\ncorners of this cell. Mirrors in this maze reflect light in a perfect\r\nway, which causes the interesting visual effects and contributes to the\r\nloss of orientation in the maze.Oleg is a person of curious nature, so\r\nhe decided to install n lasers facing internal of the maze on the south\r\nwall of the maze. On the north wall of the maze, Oleg installed n\r\nreceivers, also facing internal of the maze. Let\u2019s number lasers and\r\nreceivers from west to east with distinct integers from 1 to n. Each\r\nlaser sends a beam of some specific kind and receiver with number a_i\r\nshould receive the beam sent from laser number i. Since two lasers\u2019\r\nbeams can\u2019t come to the same receiver, these numbers form a each of the\r\nreceiver numbers occurs exactly once.You came to the maze together with\r\nOleg. Help him to place the mirrors in the initially empty maze so that\r\nthe maximum number of lasers\u2019 beams will come to the receivers they\r\nshould. There are no mirrors outside the maze, so if the laser beam\r\nleaves the maze, it will not be able to go back.\r\n", "solutions": ["#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nconst int MaxN = 1024;\n\nint N;\nint order[MaxN];\nint prev_order[MaxN];\nbool visited[MaxN];\n\nVI GetCycle(int x) {\n  assert(!visited[x]);\n  VI answer;\n  do {\n    visited[x] = true;\n    answer.push_back(x);\n    x = prev_order[x];\n  } while (x != answer[0]);\n  return answer;\n}\n\nvector<string> last_answer;\nvector<string> answer;\n\nvoid MoveRibbon(string &s, int from, int to) {\n  assert(from != to);\n  if (from < to) {\n    s[from] = s[to] = '\\\\';\n  } else {\n    s[from] = s[to] = '/';\n  }\n}\n\nvoid SolveFirst() {\n  auto cyc0 = GetCycle(0);\n  const int S = SZ(cyc0);\n\n  for (int i = S - 1; i > 0; --i) {\n    const int cur = cyc0[i];\n    const int nxt = cyc0[(i + 1) % S];\n    string line(N, '.');\n    MoveRibbon(line, cur, nxt);\n    last_answer.push_back(line);\n  }\n}\n\nvoid SolveOther(int base) {\n  if (visited[base]) { return; }\n  auto cycle = GetCycle(base);\n  const int S = SZ(cycle);\n  if (S == 1) { return; }\n\n  string first_line(N, '.');\n  MoveRibbon(first_line, base, 0);\n  MoveRibbon(first_line, cycle.back(), base);\n  answer.push_back(first_line);\n\n  cycle[0] = 0;\n\n  for (int d = S - 1; d > 0; --d) {\n    const int src = cycle[d - 1];\n    const int dest = cycle[d];\n    string line(N, '.');\n    MoveRibbon(line, src, dest);\n    answer.push_back(line);\n  }\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  int num_matching = 0;\n  for (int i = 0; i < N; ++i) {\n    cin >> order[i];\n    --order[i];\n    prev_order[order[i]] = i;\n    num_matching += order[i] == i;\n  }\n\n  if (num_matching == N) {\n    cout << N << \"\\n\";\n    for (int i = 0; i < N; ++i)\n      cout << string(N, '.') << \"\\n\";\n    return 0;\n  }\n\n  SolveFirst();\n  for (int fst = 1; fst < N; ++fst)\n    SolveOther(fst);\n\n  for (string s : last_answer)\n    answer.PB(s);\n\n  while ((int)answer.size() != N)\n    answer.push_back(string(N, '.'));\n\n  cout << N - 1 << \"\\n\";\n  for (auto &s : answer)\n    cout << s << \"\\n\";\n\n}\n\n"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "3000", "interactive": false}