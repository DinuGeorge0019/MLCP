{
    "link": "https://codeforces.com//contest/1641/problem/F",
    "problemId": "1306249",
    "problem_idx": "F",
    "shortId": "1641F",
    "contest_number": "1641",
    "problem_submissions": {
        "D": [
            147518709,
            147518438,
            147518414,
            147427811,
            147454243,
            147448667,
            147443879,
            147448778,
            147461315,
            147449736,
            147438286,
            147472049,
            147446117,
            147443730,
            147449435,
            147452074,
            147451905,
            147452006,
            147454020,
            147456098,
            147454778,
            147430439
        ],
        "F": [
            147463572,
            147488364,
            147487709,
            147487635,
            147487566,
            147487511,
            147487448,
            147487273,
            147474513,
            147473910,
            147473584,
            147541615
        ],
        "E": [
            147445838,
            147446189,
            147454919,
            147456452,
            147460049,
            147450489,
            147462542,
            147543257,
            147542937,
            147453651,
            147456356,
            147459732,
            147462090,
            147455497,
            147527427,
            147590875
        ],
        "B": [
            147438181,
            147420165,
            147422523,
            147421140,
            147420036,
            147420813,
            147426049,
            147460937,
            147441628,
            147446219,
            147424792,
            147434886,
            147431843,
            147422293,
            147424883,
            147440401
        ],
        "C": [
            147435041,
            147431185,
            147429914,
            147434109,
            147426743,
            147452293,
            147436064,
            147458110,
            147432571,
            147432541,
            147431796,
            147432454,
            147435151,
            147433502,
            147424256,
            147417819,
            147434463,
            147437219,
            147451475
        ],
        "A": [
            147414901,
            147414810,
            147414544,
            147414530,
            147414675,
            147414742,
            147414833,
            147461626,
            147414843,
            147414962,
            147414590,
            147414549,
            147415904,
            147414474,
            147414750,
            147414483,
            147415173,
            147414668,
            147414647
        ]
    },
    "name": "F. Covering Circle",
    "statement": "Sam started playing with round buckets in the sandbox, while also\r\nscattering pebbles. His mom decided to buy him a new bucket, so she\r\nneeds to solve the following task.You are given n distinct points with\r\ninteger coordinates A_1, A_2,\r\nldots, A_n. All points were generated from the square [-10^8, 10^8]\r\ntimes [-10^8, 10^8] uniformly and independently.You are given positive\r\nintegers k, l, such that k\r\nleq l\r\nleq n. You want to select a subsegment A_i, A_{i+1},\r\nldots, A_{i+l-1} of the points array (for some 1\r\nleq i\r\nleq n + 1 - l), and some circle on the plane, containing\r\ngeq k points of the selected subsegment (inside or on the border).What\r\nis the smallest possible radius of that circle?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 23.02.2022 14:47:30       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\n// code below from https://www.codechef.com/viewsolution/12429578\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n\nconst double _0=1e-10;\nstruct pos{\n\tdouble x,y;\n\tpos operator+(pos w){return (pos){x+w.x,y+w.y};}\n\tpos operator-(pos w){return (pos){x-w.x,y-w.y};}\n\tpos operator*(double k){return (pos){x*k,y*k};}\n\tdouble abs(){return sqrt(x*x+y*y);}\n\tdouble atan2(){return ::atan2(y,x);}\n\tbool operator<(pos w)const{return x<w.x;}\n}ps[50007],ps2[50007];\ndouble _c=cos(0.937),_s=sin(0.937);\nvoid mins(double&a,double b){if(a>b)a=b;}\nstruct dir{\n\tdouble d;int t;\n\tbool operator<(dir w)const{return d<w.d;}\n}ds[100007];\nconst double pi=acos(-1),_2pi=pi*2;\ndouble fix(double x){\n\twhile(x<0)x+=_2pi;\n\twhile(x>=_2pi)x-=_2pi;\n\treturn x;\n}\nvoid Solve(vector<pair<double, double>> PTS, int m, double& ans){\n        int n = (int) PTS.size();\n\tfor(int i=1;i<=n;++i){\n\t\tdouble x,y;\n\t        x = PTS[i - 1].first;\n\t        y = PTS[i - 1].second;\n\t\tps[i]=ps2[i]=(pos){_c*x+_s*y,-_s*x+_c*y};\n\t}\n\tsrand(n+m+2571);\n\tstd::random_shuffle(ps+1,ps+n+1);\n\tfor(int i=1;i<=n;++i)std::swap(ps[rand()%n+1],ps[rand()%n+1]);\n\tstd::sort(ps2+1,ps2+n+1);\n\tfor(int i=1;i<=n;++i){\n\t\tdouble L=0,R=ans,M;\n\t\tbool ed=0;\n\t\twhile((R-L)/max(1.0, L)>_0){\n\t\t\tif (L < 1 && R > 1) M=1; else\n\t\t\tif (L < 1) M = (L+R)/2;\n\t\t\telse M = sqrt(L*R);\n\t\t\tif(!ed)M=R,ed=1;\n\t\t\tint ls=std::lower_bound(ps2+1,ps2+n+1,(pos){ps[i].x-M*2-_0,0})-ps2;\n\t\t\tint rs=std::upper_bound(ps2+1,ps2+n+1,(pos){ps[i].x+M*2+_0,0})-ps2;\n\t\t\tint c=0,ab=0;\n\t\t\tif(rs-ls>=m){\n\t\t\t\tint dp=0;\n\t\t\t\tfor(int j=ls;j<rs;++j){\n\t\t\t\t\tpos p=ps2[j]-ps[i];\n\t\t\t\t\tdouble d=p.abs(),r=M*2;\n\t\t\t\t\tif(d>r)continue;\n\t\t\t\t\tif(d<_0){\n\t\t\t\t\t\t++c;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble a=p.atan2(),b=asin(sqrt(1-d*d/(r*r)));\n\t\t\t\t\tdouble la=fix(a-b),ra=fix(a+b);\n\t\t\t\t\tif(la>ra)++c;\n\t\t\t\t\tds[dp++]=(dir){la,1};\n\t\t\t\t\tds[dp++]=(dir){ra,-1};\n\t\t\t\t}\n\t\t\t\tstd::sort(ds,ds+dp);\n\t\t\t\tif(c>=m)ab=1;\n\t\t\t\tfor(int j=0;j<dp;++j){\n\t\t\t\t\tc+=ds[j].t;\n\t\t\t\t\tif(c>=m)ab=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ab)R=ans=M;\n\t\t\telse L=M;\n\t\t}\n\t}\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, l, k;\n    cin >> n >> l >> k;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i];\n    }\n    double ans = 1e9;\n    set<pair<int, int>> s;\n    for (int i = 0; i < n; i++) {\n//      if (i % 1000 == 0) debug(i, ans, clock());\n      s.emplace(x[i], y[i]);\n      if (i - l >= 0) {\n        s.erase(make_pair(x[i - l], y[i - l]));\n      }\n      vector<pair<double, double>> ps;\n      auto it = s.lower_bound(make_pair((int) (x[i] - 2 * ans - 2), (int) -1e9));\n      while (it != s.end()) {\n        auto p = *it;\n        long long dx = p.first - x[i];\n        if (dx > 2 * ans + 2) {\n          break;\n        }\n        dx = abs(dx);\n        long long dy = abs(p.second - y[i]);\n        if (dx * dx + dy * dy < 4 * ans * ans) {\n          ps.emplace_back(p.first, p.second);\n        }\n        ++it;\n      }\n      Solve(ps, k, ans);\n    }\n    cout << fixed << setprecision(17) << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Covering Circle.json",
    "editorial_link": "https://codeforces.com//blog/entry/100249",
    "editorial": "If the answer is letâs consider circles with centers and radius . If a\r\nrequired circle with radius exists it should be true, that circles has\r\nnon empty intersection for some and . For some we can find intersection\r\npoint of these circles on circle . Letâs define .Letâs define as the\r\nminimal possible , such that there exists circles and , such that for\r\nsome and these circles intersect on circle . Then the answer to the\r\nproblem is .Letâs make a procedure to check, that for some . To check\r\nthat letâs consider circles with centers and radius . Each of them\r\nintersect with with some arc (circular segment). We can find all these\r\narcs. Letâs now make scanline and mantain all indices of arcs covering\r\nthe current point. With segment tree with lazy propagation we can check\r\nif there exists indices with difference at most . The complexity of this\r\ncheck is , where is the number of arcs.Letâs iterate from to and\r\nmaintain the current answer . Initially letâs initialize with (itâs easy\r\nto prove that the answer canât be bigger than these constant for any\r\npoints). Now if we have some letâs firstly check, that (if not the\r\nanswer wonât be updated), if it is true letâs make a binary search to\r\nfind a new answer. The only problem is the number of arcs can be big.\r\nLetâs note, that makes an arc on if and only if . So letâs make an\r\ninfinite grid with step and maintain a set of points in each square.\r\nAlso, we should maintain points from the segment . After that, we can\r\nonly check indices, that are in the same square as the point and in\r\nneighboring squares. Itâs easy to prove, that if the expected number of\r\npoints in each grid square is . In practice, the average number of\r\npoints to check is around . So we can find these candidate points and\r\nthen use in procedures to check, that , which will work in . If is\r\nchanged we can reconstruct all grid in .Due to all points are random the\r\nexpected number of times when will change is (famous Blogewoosh 6 idea).\r\nSo the complexity of this solution is .\r\n",
    "hint": []
}