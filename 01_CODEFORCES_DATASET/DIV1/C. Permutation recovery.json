{
    "link": "https://codeforces.com//contest/1158/problem/C",
    "problemId": "343488",
    "problem_idx": "C",
    "shortId": "1158C",
    "contest_number": "1158",
    "problem_submissions": {
        "E": [
            54043697,
            54045364,
            54049022
        ],
        "D": [
            54034270,
            54037737,
            54037081,
            54029996,
            54039126,
            54036378,
            54039507,
            54040185,
            54038993,
            54040201,
            54038641,
            54040565,
            54035763,
            54041644,
            54031772,
            54033510,
            54035224
        ],
        "C": [
            54032525,
            54035029,
            54036135,
            54034332,
            54036498,
            54034178,
            54037957,
            54038859,
            54034328,
            54037431,
            54037039,
            54036368,
            54038382,
            54039919,
            54034772,
            54037883,
            54036347,
            54039155
        ],
        "B": [
            54031111,
            54032629,
            54034184,
            54032709,
            54033881,
            54040878,
            54036260,
            54033097,
            54031744,
            54033322,
            54032381,
            54039897,
            54035074,
            54040745,
            54038527,
            54041411,
            68070838,
            54045735,
            54041323
        ],
        "A": [
            54029723,
            54029634,
            54031071,
            54030974,
            54029203,
            54030224,
            54030247,
            54030013,
            54029682,
            54030151,
            54031232,
            54030952,
            54031158,
            54031859,
            54031283,
            54032676,
            54031617,
            54030225
        ],
        "F": [
            54045740,
            54049931,
            74200730,
            74200612,
            73657677,
            73657539,
            73657494,
            73657445,
            73007148,
            68077713,
            68077566,
            68077199,
            68077121,
            68076937
        ]
    },
    "name": "C. Permutation recovery",
    "statement": "Vasya has written some permutation p_1, p_2,\r\nldots, p_n of integers from 1 to n, so for all 1\r\nleq i\r\nleq n it is true that 1\r\nleq p_i\r\nleq n and all p_1, p_2,\r\nldots, p_n are different. After that he wrote n numbers next_1, next_2,\r\nldots, next_n. The number next_i is equal to the minimal index i < j\r\nleq n, such that p_j > p_i. If there is no such j let’s let’s define as\r\nnext_i = n + 1.In the evening Vasya went home from school and due to\r\nrain, his notebook got wet. Now it is impossible to read some written\r\nnumbers. Permutation and some values next_i are completely lost! If for\r\nsome i the value next_i is lost, let’s say that next_i = -1.You are\r\ngiven numbers next_1, next_2,\r\nldots, next_n (maybe some of them are equal to -1). Help Vasya to find\r\nsuch permutation p_1, p_2,\r\nldots, p_n of integers from 1 to n, that he can write it to the notebook\r\nand all numbers next_i, which are not equal to -1, will be correct.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct Testcase {\n  int N;\n  vector<int> nxt;\n  vector<VI> graph;\n  vector<int> vis;\n  vector<int> order;\n\n  bool Topo(int v) {\n    vis[v] = 1;\n    for (int s : graph[v]) {\n      debug(v, s);\n      if (vis[s] == 1) { return false; }\n      if (vis[s] == 0) {\n        if (!Topo(s)) { return false; }\n      }\n    }\n    vis[v] = 2;\n    order.PB(v);\n    return true;\n  }\n\n  void Run() {\n    cin >> N;\n    nxt.resize(N);\n    for (int &v : nxt) { cin >> v; --v; }\n\n    graph.resize(N + 1);\n\n    vector<int> max_stack{N};\n    for (int i = N - 1; i >= 0; --i) {\n      const int where = nxt[i];\n      if (where >= 0) {\n        graph[i].PB(where);\n        while (max_stack.back() < where) {\n          graph[max_stack.back()].PB(i);\n          max_stack.pop_back();\n        }\n      }\n\n      max_stack.PB(i);\n    }\n    for (int i = 0; i < N; ++i) {\n      graph[i].PB(N);\n    }\n\n    vis.resize(N + 1);\n\n    for (int i = 0; i <= N; ++i) {\n      if (!vis[i]) {\n        if (!Topo(i)) {\n          cout << \"-1\\n\";\n          return;\n        }\n      }\n    }\n\n    vector<int> answer(N + 1);\n    int val = N;\n    for (int x : order) {\n      answer[x] = val--;\n    }\n\n    for (int i = 0; i < N; ++i) {\n      cout << answer[i] + 1 << \" \";\n    }\n    cout << \"\\n\";\n  }\n};\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int T;\n  cin >> T;\n\n  for (int i = 0; i < T; ++i) {\n    Testcase().Run();\n  }\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Permutation recovery.json",
    "editorial_link": "https://codeforces.com/blog/entry/66993?locale=en",
    "editorial": "Note that if there are indices i<j\n for which the values nexti\n and nextj\n are defined and i<j<nexti<nextj\n are satisfied, then there is no answer. Suppose that this is not true and there exists permutation p1,p2,,pn\n. Note that since j<nexti\n we get that pi>pj\n (otherwise nexti\n would not be the minimum position in which the number is greater than pi\n). But then pj<pi<pnexti\n, so nextj\n is not the minimum position for j\n. Contradiction.\n\nNow we prove that if for any pair of indices i<j\n such condition is not satisfied, then the permutation always exists.\n\nFirst, let's get rid of nexti=?1\n. If nexti=?1\n let's say nexti=i+1\n. Note that for any pair i<j\n the condition i<j<nexti<nextj\n is still not satisfied (since nexti=i+1\n cannot take part in such inequality).\n\nConsider the following rooted tree with n+1\n vertices: the vertex with index n+1\n will be the root, and the ancestor of the vertex with index i\n will be nexti\n. Since it is always i<nexti\n we get the rooted tree.\n\nLet's run the depth first search algorithm (dfs\n) from the vertex n+1\n in this tree. In this case, we will bypass the sons of each vertex in order from the smaller number to the larger one. Let's make some global variable timer=n+1\n. Each time we come to the vertex i\n, we will make pi=timer\n and reduce timer\n by 1\n. Note that p1,p2,,pn\n will form a permutation of numbers from 1\n to n\n.\n\nWe prove that this permutation is the answer.\n\nFirst of all, for all i\n due to nexti\n was the ancestor of i\n, we'll go there early and so pnexti>pi\n. Let i<j<nexti\n. We need to prove that we will come to the vertex j\n later than to the vertex i\n. Note that then the vertex nexti\n will be a descendant of j\n in the tree, because if you start go from j\n by next\n, you cannot jump over nexti\n, because otherwise there is an index x\n, for which the inequality i<x<nexti<nextx\n is satisfied. But such pair of indexes i\n, x\n cannot exist. We'll get to j\n later because the son of nexti\n, which is the ancestor of j\n will be ?j\n, and thus >i\n.\n\nThat is, we understood what is the criterion of the answer and learned how to quickly build an answer, if this criterion is satisfied. But we still need to check that this criterion is satisfied. This can be done by some simple linear algorithm. But we will do this: let's make an algorithm for constructing the answer (without checking the criterion) and find the permutation p\n. Now, using the stack and the standard algorithm, we find the nexti\n values for it. If they match the given nexti\n, then we have found the answer, otherwise, let's say that there is no answer. If the criterion is satisfied we will find the answer and if not satisfied after checking p\n we will say there are no answers.",
    "hint": []
}