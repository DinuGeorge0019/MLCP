{
    "link": "https://codeforces.com//contest/1967/problem/D",
    "problemId": "2620323",
    "problem_idx": "D",
    "shortId": "1967D",
    "contest_number": "1967",
    "problem_submissions": {
        "E2": [
            258916135,
            258921598,
            280919018,
            283055351,
            258925888,
            258925224,
            258926598,
            259116859,
            258926070,
            258925546,
            259722295,
            258957419
        ],
        "E1": [
            258904834,
            258921659,
            258894575,
            258912226,
            258903044,
            258906344,
            258912831,
            258915891,
            258918877,
            258922310,
            259006535,
            258965622,
            258951459,
            258945783,
            258913874,
            258917530,
            258919711,
            258921338,
            258917617,
            258919765,
            259722116,
            258915462,
            258933640,
            258908305,
            258913393,
            258909598
        ],
        "D": [
            258893511,
            258891796,
            258909116,
            258896081,
            258913757,
            258931804,
            258897887,
            258899842,
            258900877,
            258900605,
            258900883,
            258903500,
            258906692,
            258903262,
            258903546,
            258905322,
            258906645,
            259721880,
            258919184,
            258918997,
            258920966,
            258894127
        ],
        "C": [
            258884312,
            258885547,
            258878790,
            258885577,
            258886778,
            258891500,
            258888513,
            258894435,
            258891427,
            258888089,
            258895759,
            258890296,
            258893524,
            258896216,
            258896443,
            258888021,
            258883737,
            258891226,
            258889628,
            258879732
        ],
        "B2": [
            258880311,
            258879319,
            258874379,
            258880426,
            258874860,
            258887764,
            258882431,
            258886567,
            258994245,
            258885903,
            258878827,
            258889665,
            258882193,
            258884237,
            258880372,
            258891352,
            258877071,
            258876977,
            258886917,
            258884212
        ],
        "B1": [
            258869431,
            258871590,
            258870854,
            258865105,
            258869777,
            258876404,
            258873073,
            258874727,
            258869407,
            258874121,
            258875290,
            258873932,
            258869896,
            258873122,
            258871143,
            258871635,
            258872574,
            258874952,
            258869924,
            258867671
        ],
        "A": [
            258865187,
            258866636,
            258865467,
            258874287,
            258866222,
            258865534,
            258866742,
            258868436,
            258867130,
            258868014,
            258872371,
            258870129,
            258865415,
            258868641,
            258868839,
            258866810,
            258868141,
            258871863,
            258867322,
            258865436
        ],
        "F": [
            283293514,
            273029197
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129027",
    "editorial": "If we separately consider each operation, it could be really hard.Thus,\r\nbinary search on the answer of magics. Greedily, we want as small as\r\npossible, and then , etc.Enumerate from to . Enumerate for from to . If\r\nit is possible for after steps, ; Otherwise, . If gets to first, itâs\r\nvalid. If gets to first, itâs invalid.The last question is how to judge\r\nin time.Build a graph with edges . Assume that the graph is a tree, now\r\nthe condition is equivalent to ; is in the subtree of . We can simply\r\ncheck the DFS order and size: . However, the graph contains vertices and\r\nedges, so it turns out to be a pseudo forest. One of the processing ways\r\nis to cut one edge on the cycle of each pseudo tree. If the path from to\r\ndoesnât contain the edge, we process the above method. Otherwise, let\r\nthe cut edge be (In fact, is exactly the root of the tree), and we want\r\n, so ; is in the subtree of , while is in the subtree of . It takes a\r\nlittle time to implement, but be patient and clear-minded, and you are\r\nsure to get Accepted.\r\n",
    "name": "D. Long Way to be Non-decreasing",
    "statement": "Little R is a magician who likes non-decreasing arrays. She has an array\r\nof length n, initially as a_1,\r\nldots, a_n, in which each element is an integer between [1, m]. She\r\nwants it to be non-decreasing, i.e., a_1\r\nleq a_2\r\nleq\r\nldots\r\nleq a_n.To do this, she can perform several magic tricks. Little R has a\r\nfixed array b_1\r\nldots b_m of length m. Formally, let’s define a trick as a procedure\r\nthat does the following things in order: Choose a set S\r\nsubseteq\r\n{1, 2,\r\nldots, n\r\n}. For each u\r\nin S, assign a_u with b_{a_u}. Little R wonders how many tricks are\r\nneeded at least to make the initial array non-decreasing. If it is not\r\npossible with any amount of tricks, print -1 instead.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 30.04.2024 11:19:29**/#include <bits/stdc++.h> using namespace std; #ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif class dsu { public:  vector<int> p;  int n;   dsu(int _n) : n(_n) {    p.resize(n);    iota(p.begin(), p.end(), 0);  }   inline int get(int x) {    return (x == p[x] ? x : (p[x] = get(p[x])));  }   inline bool unite(int x, int y) {    x = get(x);    y = get(y);    if (x != y) {      p[x] = y;      return true;    }    return false;  }}; int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n, m;    cin >> n >> m;    vector<int> a(n);    for (int i = 0; i < n; i++) {      cin >> a[i];      --a[i];    }    vector<int> b(m);    for (int i = 0; i < m; i++) {      cin >> b[i];      --b[i];    }    dsu d(m);    vector<vector<int>> g(m);    vector<int> roots;    for (int i = 0; i < m; i++) {      if (d.unite(i, b[i])) {        g[b[i]].push_back(i);      } else {        roots.push_back(i);      }    }    int T = 0;    vector<int> tin(m, -1);    vector<int> tout(m, -1);    vector<int> depth(m, -1);    vector<int> root(m, -1);    auto Dfs = [&](auto&& self, int v) -> void {      tin[v] = ++T;      for (int u : g[v]) {        depth[u] = depth[v] + 1;        root[u] = root[v];        self(self, u);      }      tout[v] = ++T;    };    for (int v : roots) {      depth[v] = 0;      root[v] = v;      Dfs(Dfs, v);    }    auto Anc = [&](int x, int y) -> bool {      return tin[x] <= tin[y] && tout[y] <= tout[x];    };    int low = 0, high = m + 1;    while (low < high) {      int mid = (low + high) >> 1;      int v = 0;      for (int x : a) {        while (v < m) {          if (Anc(v, x) && depth[x] - depth[v] <= mid) {            break;          }          int to = b[root[x]];          int rem = mid - depth[x] - 1;          if (Anc(v, to) && depth[to] - depth[v] <= rem) {            break;          }          v += 1;        }      }      if (v < m) {        high = mid;      } else {        low = mid + 1;      }    }    cout << (low == m + 1 ? -1 : low) << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "graphs",
        "implementation",
        "shortest paths",
        "two pointers"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Long Way to be Non-decreasing.json",
    "hint": [
        "Hint 1 Binary search on the answer of magics.",
        "Hint 2 You may come up with many solutions with heavy data structures. Unfortunately, none of them is helpful.",
        "Hint 3 The key is to judge times whether vertex is reachable from vertex in steps, instead of querying the minimal value or something else."
    ]
}