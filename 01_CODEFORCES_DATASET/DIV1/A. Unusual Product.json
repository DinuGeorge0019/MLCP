{
    "link": "https://codeforces.com//contest/406/problem/A",
    "problemId": "7387",
    "problem_idx": "A",
    "shortId": "406A",
    "contest_number": "406",
    "problem_submissions": {
        "E": [
            6113980,
            6115371,
            6117401,
            6114390,
            6114632,
            6115961,
            6113761,
            6119100,
            6122295,
            6132836,
            6117696,
            6115484
        ],
        "D": [
            6111550,
            6112818,
            6117396,
            6111602,
            6114018,
            6112889,
            6110196,
            6112558,
            6113207,
            6114342,
            6109879,
            6117233,
            6113495,
            6112560,
            6111190,
            6113785,
            6113949,
            6114279,
            6113928,
            6111720,
            6116758,
            6114622
        ],
        "C": [
            6110187,
            6111166,
            6117392,
            6115342,
            6111381,
            6110506,
            6110270,
            6108894,
            6114229,
            6110730,
            6111155,
            6113968,
            6111745,
            6111516,
            6128689,
            6128286,
            6111327,
            6111782,
            6108166
        ],
        "B": [
            6108889,
            6109179,
            6117390,
            6108130,
            6113002,
            6108132,
            6108085,
            6107339,
            6110967,
            6110982,
            6107994,
            6108825,
            6109585,
            6108127,
            6108320,
            6109839,
            6109061,
            6109268,
            6109691,
            6111113
        ],
        "A": [
            6107835,
            6107644,
            6117388,
            6107225,
            6112427,
            6117543,
            6106926,
            6106550,
            6108138,
            6107728,
            6107011,
            6108007,
            6108768,
            6106947,
            6107483,
            6108996,
            6107104,
            6108198,
            6108284,
            6109349
        ]
    },
    "name": "A. Unusual Product",
    "statement": "Little Chris is a huge fan of linear algebra. This time he has been\r\ngiven a homework about the of a square matrix.The of two integer number\r\nvectors and of size is the sum of the products of the corresponding\r\ncomponents of the vectors. The of an square matrix is defined as the sum\r\nof dot products. The -th of them is the dot product of the -th row\r\nvector and the -th column vector in the matrix .Fortunately for Chris,\r\nhe has to work only in ! This means that all operations (addition,\r\nmultiplication) are calculated modulo 2. In fact, the matrix is binary:\r\neach element of is either 0 or 1. For example, consider the following\r\nmatrix : The unusual square of is equal to .However, there is much more\r\nto the homework. Chris has to process queries; each query can be one of\r\nthe following: given a row index , flip all the values in the -th row in\r\n; given a column index , flip all the values in the -th column in ; find\r\nthe unusual square of . To flip a bit value means to change it to ,\r\ni.e., 1 changes to 0 and 0 changes to 1.Given the initial matrix ,\r\noutput the answers for each query of the third type! Can you solve\r\nChris\u2019s homework?\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA \"sequence\"\n\nint A[1100][1100];\n\nint main(){\n#ifdef __ASD__\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#else\n\t//freopen(TASKA\".in\", \"r\", stdin); freopen(TASKA\".out\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin>>n;\n\tforn(i,n){\n\t\tforn(j,n){\n\t\t\tscanf(\"%d\",A[i]+j);\n\t\t}\n\t}\n\tint r=0;\n\tforn(i,n){\n\t\tforn(j,n){\n\t\t\tr^=A[i][j]*A[j][i];\n\t\t}\n\t}\n\tint tc;\n\tcin>>tc;\n\tforn(qqq,tc){\n\t\tint t,a;\n\t\tscanf(\"%d\",&t);\n\t\tif(t==3){\n\t\t\tprintf(\"%d\",r);\n\t\t\tcontinue;\n\t\t}\n\t\tscanf(\"%d\",&a);\n\t\tr^=1;\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Unusual Product.json",
    "editorial_link": "https://codeforces.com//blog/entry/11186",
    "editorial": "Written as a formula, the problem asks to find the value of Suppose that\r\n. Then the sum contains summands and . Since the sum is taken modulo 2,\r\nthese summands together give 0 to the sum. It follows that the\r\nexpression is always equal to the sum of the diagonal bits: Now, each\r\nquery of type 1 and 2 flips the value of exactly one bit on the\r\ndiagonal. Thus we can calculate the unusual product of the original\r\nmatrix, and flip its value after each query of type 1 and 2. Solution\r\ncomplexity: , if we don\u00e2\u0080\u0099t take the reading of the input into account...\r\n:)\r\n"
}