{
    "link": "https://codeforces.com//contest/87/problem/B",
    "problemId": "458",
    "problem_idx": "B",
    "shortId": "87B",
    "contest_number": "87",
    "problem_submissions": {
        "E": [
            480522,
            480373,
            480563,
            481052,
            487220,
            487031,
            486475,
            483729,
            480251,
            482514,
            479707,
            481257
        ],
        "D": [
            479023,
            478767,
            478527,
            480005,
            478079,
            479874,
            481953,
            479744,
            478788,
            480461,
            479633,
            479612,
            480061,
            1186292,
            480377
        ],
        "C": [
            477696,
            477515,
            477634,
            477346,
            478564,
            477717,
            482287,
            482259,
            482254,
            482249,
            478031,
            477748,
            478549,
            478513,
            478021,
            477556,
            477965,
            477701,
            478643,
            478646
        ],
        "B": [
            477395,
            477959,
            480915,
            478219,
            479510,
            478272,
            478602,
            479590,
            477948,
            477912,
            477626,
            478345,
            478853,
            480591,
            477860,
            478043
        ],
        "A": [
            477178,
            477245,
            477382,
            477797,
            478932,
            477255,
            477225,
            477234,
            477375,
            477368,
            477236,
            477191,
            477429,
            479893,
            477216,
            477325
        ]
    },
    "name": "B. Vasya and Types",
    "statement": "Programmer Vasya is studying a new programming language &K*. The &K*\r\nlanguage resembles the languages of the C family in its syntax. However,\r\nit is more powerful, which is why the rules of the actual C-like\r\nlanguages are unapplicable to it. To fully understand the statement,\r\nplease read the language’s description below carefully and follow it and\r\nnot the similar rules in real programming languages.There is a very\r\npowerful system of pointers on &K* you can add an asterisk to the right\r\nof the existing type that will result in new type . That is called\r\npointer-definition operation. Also, there is the operation that does the\r\nopposite to any type of , which is a pointer, you can add an ampersand\r\nthat will result in a type , to which refers . That is called a\r\ndereference operation.The &K* language has only two basic data types and\r\n. Also, the language has operators and . The operator \"\" defines a new\r\ndata type , which is equivalent to . can have asterisks and ampersands,\r\nand cannot have them. For example, the operator will create a new type ,\r\nthat can be used as . The operator \"\" returns type of , brought to ,\r\nthat is, returns the type , equivalent to it with the necessary number\r\nof asterisks (the number can possibly be zero). That is, having defined\r\nthe type, as shown above, the operator will return .An attempt of\r\ndereferencing of the type will lead to an error: to a special data type\r\n. For the following equation holds true: . An attempt to use the data\r\ntype that hasn’t been defined before that will also lead to the .Using ,\r\nwe can define one type several times. Of all the definitions only the\r\nlast one is valid. However, all the types that have been defined earlier\r\nusing this type do not change.Let us also note that the dereference\r\noperation has the lower priority that the pointer operation, in other\r\nwords is always equal to .Note, that the operators are executed\r\nconsecutively one by one. If we have two operators \"\" and \"\", then at\r\nfirst becomes , and after that becomes , but (see sample 2).Vasya does\r\nnot yet fully understand this powerful technology, that’s why he asked\r\nyou to help him. Write a program that analyzes these operators.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <bitset>\n#include <cmath>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#define mp make_pair\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef long long int64;\ntypedef vector<int> vi;\n\ntemplate<class T> T abs(T x) {return x > 0 ? x : (-x); }\ntemplate<class T> T sqr(T x) {return x * x; }\n\nmap<string, int> M;\n\nint eval(string s) {\n    int c1 = 0, c2 = 0;\n    string t;\n    int ind1 = 0;\n    while (ind1 < sz(s) && s[ind1] == '&') ++ind1, ++c1;\n    int ind2 = sz(s) - 1;\n    while (ind2 >= 0 && s[ind2] == '*') --ind2, ++c2;\n    t = s.substr(ind1, ind2 - ind1 + 1);\n    if (!M.count(t)) return -1;\n    int x = M[t];\n    if (x == -1) return -1;\n    x += c2;\n    x -= c1;\n    if (x < 0) return -1;\n    return x;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    M[\"void\"] = 0;\n    for (int i = 0; i < n; ++i) {\n        string ws;\n        cin >> ws;\n        if (ws == \"typeof\") {\n            string s;\n            cin >> s;\n            int x = eval(s);\n            if (x == -1)\n                printf(\"errtype\\n\");\n            else {\n                printf(\"void\");\n                for (int j = 0; j < x; ++j) printf(\"*\");\n                printf(\"\\n\");\n            }\n        } else {\n            string s, t;\n            cin >> s >> t;\n            M[t] = eval(s);\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "strings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Vasya and Types.json",
    "editorial_link": "https://codeforces.com//blog/entry/2121",
    "editorial": "In this task, it was necessary to do exactly what is written in the problem's statement, for practically any complexity.\nYou are suggested to do the following. For each data type we shall store two values - its name and the number of asterisks when it is brought to void. Then the typeof request is processed by consecutively looking at each element of an array of definitions, in which we find the desired name of the type and the number of asterisks in it.\nThe type errtype is convenient to store as void, to which we added ?-?inf asterisks.\nThus, fulfilling a typedef request, we find the number of asterisks in the type A, add to it a number of asterisks and subtract the number of ampersands. Do not forget to replace any negative number of asterisks by ?-?inf, and create a new definition of type B, removing the old one.",
    "hint": []
}