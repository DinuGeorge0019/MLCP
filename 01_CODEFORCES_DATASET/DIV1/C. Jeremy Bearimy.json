{
    "link": "https://codeforces.com//contest/1280/problem/C",
    "problemId": "495762",
    "problem_idx": "C",
    "shortId": "1280C",
    "contest_number": "1280",
    "problem_submissions": {
        "E": [
            66917544,
            66918710,
            66922267,
            66921342,
            66922263,
            66926965,
            66926660,
            66927067,
            66925334,
            66928850,
            66995264,
            66984642,
            66984352,
            66984306,
            66929552,
            66927288,
            66928819,
            66918756,
            67988551,
            66935139,
            67027185,
            66930594
        ],
        "D": [
            66910755,
            66913056,
            66911496,
            66913696,
            66913107,
            66913708,
            66913839,
            66916865,
            66916639,
            66915491,
            66986758,
            66986656,
            66986610,
            66986506,
            66986162,
            66985974,
            66985915,
            66985866,
            66985681,
            66985603,
            66985529,
            66917639,
            66918143,
            66919046,
            66912800,
            66915483,
            66915027,
            67988467,
            66920051,
            66917432,
            66918759,
            66917692
        ],
        "C": [
            66906002,
            66909093,
            66907333,
            66908961,
            66908129,
            66909339,
            66908240,
            66909052,
            66911854,
            66908829,
            66908393,
            66909027,
            66913164,
            66908797,
            66903678,
            66908260,
            67988454,
            66908965,
            66910137,
            66910802,
            66910959
        ],
        "B": [
            66904540,
            66906897,
            66902891,
            66906439,
            66906232,
            66906362,
            66905756,
            66906434,
            66909740,
            66905894,
            66905319,
            66906149,
            66910474,
            66930936,
            66909557,
            66906748,
            67988445,
            66907466,
            66906183,
            66908402,
            66907579
        ],
        "A": [
            66901496,
            66903238,
            66905004,
            66902693,
            66904062,
            66902839,
            66902110,
            66903240,
            66903755,
            66903072,
            66902272,
            66903347,
            66905647,
            66902258,
            66906539,
            66904016,
            67988407,
            66934409,
            66903855,
            66903188,
            66903009,
            66902847
        ],
        "F": [
            66936996,
            66936445,
            69949014,
            71271095,
            66930593,
            67311416
        ]
    },
    "name": "C. Jeremy Bearimy",
    "statement": "Welcome! Everything is fine.You have arrived in The Medium Place, the\r\nplace between The Good Place and The Bad Place. You are assigned a task\r\nthat will either make people happier or torture them for eternity.You\r\nhave a list of k pairs of people who have arrived in a new inhabited\r\nneighborhood. You need to assign each of the 2k people into one of the\r\n2k houses. Each person will be the resident of exactly one house, and\r\neach house will have exactly one resident.Of course, in the\r\nneighborhood, it is possible to visit friends. There are 2k - 1 roads,\r\neach of which connects two houses. It takes some time to traverse a\r\nroad. We will specify the amount of time it takes in the input. The\r\nneighborhood is designed in such a way that from anyone\u2019s house, there\r\nis exactly one sequence of distinct roads you can take to any other\r\nhouse. In other words, the graph with the houses as vertices and the\r\nroads as edges is a tree.The truth is, these k pairs of people are\r\nactually soulmates. We index them from 1 to k. We denote by f(i) the\r\namount of time it takes for the i-th pair of soulmates to go to each\r\nother\u2019s houses.As we have said before, you will need to assign each of\r\nthe 2k people into one of the 2k houses. You have two missions, one from\r\nthe entities in The Good Place and one from the entities of The Bad\r\nPlace. Here they are: The first mission, from The Good Place, is to\r\nassign the people into the houses such that the sum of f(i) over all\r\npairs i is minimized. Let\u2019s define this minimized sum as G. This makes\r\nsure that soulmates can easily and efficiently visit each other; The\r\nsecond mission, from The Bad Place, is to assign the people into the\r\nhouses such that the sum of f(i) over all pairs i is maximized. Let\u2019s\r\ndefine this maximized sum as B. This makes sure that soulmates will have\r\na difficult time to visit each other. What are the values of G and B?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nvector<vector<pair<int,ll> > > edges;\n\nll a1, a2;\nint n;\n\nint dfs(int v, int p){\n\tint sz = 1;\n\tfor(pair<int,ll> e : edges[v]){\n\t\tif(e.first == p) continue;\n\t\tint csz = dfs(e.first, v);\n\t\tsz += csz;\n\t\tif(csz & 1){\n\t\t\ta1 += e.second;\n\t\t}\n\t\ta2 += e.second * min(n - csz, csz);\n\t}\n\treturn sz;\n}\nvoid solve(){\n\ta1 = a2 = 0;\n\tcin >> n;\n\tn *= 2;\n\tedges.assign(n, {});\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tll t;\n\t\tcin >> a >> b >> t;\n\t\ta--; b--;\n\t\tedges[a].push_back({b, t});\n\t\tedges[b].push_back({a, t});\n\t}\n\tdfs(0, -1);\n\tcout << a1 << ' ' << a2 << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Jeremy Bearimy.json",
    "editorial_link": "https://codeforces.com//blog/entry/72212",
    "editorial": "Maximization\n\nSuppose we're maximizing the sum. Consider a single edge (a,b)\n, and consider the two components on either side of this edge. Then we have an important observation: in the optimal solution, the nodes of one component are all paired with nodes on the other component. This is because otherwise, there will be at least one pair in each component that lies entirely in that component, say (ia,ja)\n and (ib,jb\n). But if we switch the pairing to, say, (ia,ib)\n and (ja,jb)\n, then the cost increases, because we're introducing new edges (namely (a,b)\n, among possibly others) while keeping everything from the previous pairing.\n\n\nRepeating this, we can construct an optimal solution where all nodes in one component are paired with nodes in the other component.\n\nThis means that in the optimal solution, the edge (a,b)\n is counted exactly min(ca,cb)\n times, where ca\n is the size of the component on a\n's side, and cb\n is the size of the component on b\n's side. Therefore, the edge contributes exactly weight(a,b)?min(ca,cb)\n to the answer.\n\nBut the same is true for all edges! Therefore, we can compute the answer by just summing up all contributions. The only remaining step needed is to compute the sizes of all subtrees, and this can be done with a single BFS/DFS and DP. This runs in O(n)\n.\n\nMinimization\n\nNow, suppose we're minimizing the sum. Consider again a single edge (a,b)\n. Again, we have an important observation: in the optimal solution, at most one pair passes through (a,b)\n. This is because otherwise, if there are at least two such pairs, then we can again switch the pairing (essentially the reverse of maximizing), which decreases the cost, because it doesn't introduce additional edges but it decreases the number of pairs passing through (a,b)\n by 2\n.\n\n\nRepeating this, we can ensure that at most one pair passes through (a,b)\n.\n\nFurthermore, the parity of the number of pairs passing through (a,b)\n is fixed. (Why?) Therefore, in the optimal solution, (a,b)\n is counted exactly (camod2)\n times. (Note that ca?cb(mod2)\n)\n\nBut again, the same is true for all edges! Therefore, we can compute the answer in O(n)\n as well, by summing up all contributions."
}