{"link": "https://codeforces.com//contest/1280/problem/C", "problemId": "495762", "problem_idx": "C", "shortId": "1280C", "contest_number": "1280", "problem_submissions": {"E": [66917544, 66918710, 66922267, 66921342, 66922263, 66926965, 66926660, 66927067, 66925334, 66928850, 66995264, 66984642, 66984352, 66984306, 66929552, 66927288, 66928819, 66918756, 67988551, 66935139, 67027185, 66930594], "D": [66910755, 66913056, 66911496, 66913696, 66913107, 66913708, 66913839, 66916865, 66916639, 66915491, 66986758, 66986656, 66986610, 66986506, 66986162, 66985974, 66985915, 66985866, 66985681, 66985603, 66985529, 66917639, 66918143, 66919046, 66912800, 66915483, 66915027, 67988467, 66920051, 66917432, 66918759, 66917692], "C": [66906002, 66909093, 66907333, 66908961, 66908129, 66909339, 66908240, 66909052, 66911854, 66908829, 66908393, 66909027, 66913164, 66908797, 66903678, 66908260, 67988454, 66908965, 66910137, 66910802, 66910959], "B": [66904540, 66906897, 66902891, 66906439, 66906232, 66906362, 66905756, 66906434, 66909740, 66905894, 66905319, 66906149, 66910474, 66930936, 66909557, 66906748, 67988445, 66907466, 66906183, 66908402, 66907579], "A": [66901496, 66903238, 66905004, 66902693, 66904062, 66902839, 66902110, 66903240, 66903755, 66903072, 66902272, 66903347, 66905647, 66902258, 66906539, 66904016, 67988407, 66934409, 66903855, 66903188, 66903009, 66902847], "F": [66936996, 66936445, 69949014, 71271095, 66930593, 67311416]}, "name": "C. Jeremy Bearimy", "statement": "Welcome! Everything is fine.You have arrived in The Medium Place, the\r\nplace between The Good Place and The Bad Place. You are assigned a task\r\nthat will either make people happier or torture them for eternity.You\r\nhave a list of k pairs of people who have arrived in a new inhabited\r\nneighborhood. You need to assign each of the 2k people into one of the\r\n2k houses. Each person will be the resident of exactly one house, and\r\neach house will have exactly one resident.Of course, in the\r\nneighborhood, it is possible to visit friends. There are 2k - 1 roads,\r\neach of which connects two houses. It takes some time to traverse a\r\nroad. We will specify the amount of time it takes in the input. The\r\nneighborhood is designed in such a way that from anyone\u2019s house, there\r\nis exactly one sequence of distinct roads you can take to any other\r\nhouse. In other words, the graph with the houses as vertices and the\r\nroads as edges is a tree.The truth is, these k pairs of people are\r\nactually soulmates. We index them from 1 to k. We denote by f(i) the\r\namount of time it takes for the i-th pair of soulmates to go to each\r\nother\u2019s houses.As we have said before, you will need to assign each of\r\nthe 2k people into one of the 2k houses. You have two missions, one from\r\nthe entities in The Good Place and one from the entities of The Bad\r\nPlace. Here they are: The first mission, from The Good Place, is to\r\nassign the people into the houses such that the sum of f(i) over all\r\npairs i is minimized. Let\u2019s define this minimized sum as G. This makes\r\nsure that soulmates can easily and efficiently visit each other; The\r\nsecond mission, from The Bad Place, is to assign the people into the\r\nhouses such that the sum of f(i) over all pairs i is maximized. Let\u2019s\r\ndefine this maximized sum as B. This makes sure that soulmates will have\r\na difficult time to visit each other. What are the values of G and B?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nvector<vector<pair<int,ll> > > edges;\n\nll a1, a2;\nint n;\n\nint dfs(int v, int p){\n\tint sz = 1;\n\tfor(pair<int,ll> e : edges[v]){\n\t\tif(e.first == p) continue;\n\t\tint csz = dfs(e.first, v);\n\t\tsz += csz;\n\t\tif(csz & 1){\n\t\t\ta1 += e.second;\n\t\t}\n\t\ta2 += e.second * min(n - csz, csz);\n\t}\n\treturn sz;\n}\nvoid solve(){\n\ta1 = a2 = 0;\n\tcin >> n;\n\tn *= 2;\n\tedges.assign(n, {});\n\tfor(int i = 0; i < n-1; i++){\n\t\tint a, b;\n\t\tll t;\n\t\tcin >> a >> b >> t;\n\t\ta--; b--;\n\t\tedges[a].push_back({b, t});\n\t\tedges[b].push_back({a, t});\n\t}\n\tdfs(0, -1);\n\tcout << a1 << ' ' << a2 << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "greedy", "trees"], "dificulty": "2000", "interactive": false}