{
    "link": "https://codeforces.com//contest/377/problem/A",
    "problemId": "4961",
    "problem_idx": "A",
    "shortId": "377A",
    "contest_number": "377",
    "problem_submissions": {
        "E": [
            5565104,
            5561250,
            5564607,
            5609766,
            5609753,
            16200081
        ],
        "C": [
            5557198,
            5559102,
            5556756,
            5557878,
            5557073,
            5556778,
            5561172,
            5559969,
            5556623,
            5561484,
            5557118,
            5556739,
            5555480,
            5555881,
            5556358,
            5558864,
            5562930,
            5557451
        ],
        "B": [
            5555860,
            5557367,
            5555019,
            5553998,
            5554910,
            5555169,
            5554737,
            5555727,
            5555389,
            5556153,
            5555427,
            5554761,
            5558108,
            5554728,
            5554498,
            5556897,
            5555212,
            5555735
        ],
        "D": [
            5554743,
            5555639,
            5559458,
            5563602,
            5559736,
            5559573,
            5557812,
            5558888,
            5560657,
            5558023,
            5561888,
            5561586,
            5561721,
            5561010,
            5567302,
            5562027,
            5561348,
            5557665,
            5560854
        ],
        "A": [
            5552294,
            5552852,
            5553023,
            5554895,
            5553159,
            5553613,
            5552588,
            5552740,
            5553136,
            5552790,
            5552857,
            5552997,
            5553105,
            5552479,
            5552633,
            5554023,
            5552441
        ]
    },
    "name": "A. Maze",
    "statement": "Pavel loves grid mazes. A grid maze is an rectangle maze where each cell\r\nis either empty, or is a wall. You can go from one cell to another only\r\nif both cells are empty and have a common side.Pavel drew a grid maze\r\nwith all empty cells forming a connected area. That is, you can go from\r\nany empty cell to any other one. Pavel doesn\u2019t like it when his maze has\r\ntoo little walls. He wants to turn exactly empty cells into walls so\r\nthat all the remaining cells still formed a connected area. Help him.\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nconst int N = 1234;\n\nchar a[N][N];\nbool was[N][N];\nint x[N * N], y[N * N];\n\nint main() {\n  int n, m, s;\n  scanf(\"%d %d %d\", &n, &m, &s);\n  for (int i = 0; i < n; i++) scanf(\"%s\", a[i]);\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++) was[i][j] = false;\n  bool found = false;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n      if (!found && a[i][j] == '.') {\n        int b = 1, e = 1;\n        x[1] = i;\n        y[1] = j;\n        was[i][j] = true;\n        while (b <= e) {\n          for (int q = 0; q < 4; q++) {\n            int xk = x[b] + dx[q];\n            int yk = y[b] + dy[q];\n            if (xk >= 0 && yk >= 0 && xk < n && yk < m)\n              if (a[xk][yk] == '.' && !was[xk][yk]) {\n                e++;\n                x[e] = xk;\n                y[e] = yk;\n                was[xk][yk] = true;\n              }\n          }\n          b++;\n        }\n        for (int id = e - s + 1; id <= e; id++) a[x[id]][y[id]] = 'X';\n        found = true;\n      }\n  for (int i = 0; i < n; i++) printf(\"%s\\n\", a[i]);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Maze.json",
    "editorial_link": "https://codeforces.com//blog/entry/10157",
    "editorial": "Start BFS or DFS from any free cell. As the maze is connected, this\r\nsearch will visit all free cells. But we can stop the search when it\r\nvisits free cells. It\u00e2\u0080\u0099s obvious that these cells are connected to each\r\nother. Remaining cells can be transformed into the walls. Solutions\r\nwhich every move transform the cell which has the minimal number of\r\nneighbours passed pretests. However, it\u00e2\u0080\u0099s wrong. Here is the\r\ncounter-test: Top-left cell has no more neighbours than any other cell\r\nbut we cannot transform it into the wall.\r\n"
}