{"link": "https://codeforces.com//contest/377/problem/A", "problemId": "4961", "problem_idx": "A", "shortId": "377A", "contest_number": "377", "problem_submissions": {"E": [5565104, 5561250, 5564607, 5609766, 5609753, 16200081], "C": [5557198, 5559102, 5556756, 5557878, 5557073, 5556778, 5561172, 5559969, 5556623, 5561484, 5557118, 5556739, 5555480, 5555881, 5556358, 5558864, 5562930, 5557451], "B": [5555860, 5557367, 5555019, 5553998, 5554910, 5555169, 5554737, 5555727, 5555389, 5556153, 5555427, 5554761, 5558108, 5554728, 5554498, 5556897, 5555212, 5555735], "D": [5554743, 5555639, 5559458, 5563602, 5559736, 5559573, 5557812, 5558888, 5560657, 5558023, 5561888, 5561586, 5561721, 5561010, 5567302, 5562027, 5561348, 5557665, 5560854], "A": [5552294, 5552852, 5553023, 5554895, 5553159, 5553613, 5552588, 5552740, 5553136, 5552790, 5552857, 5552997, 5553105, 5552479, 5552633, 5554023, 5552441]}, "name": "A. Maze", "statement": "Pavel loves grid mazes. A grid maze is an rectangle maze where each cell\r\nis either empty, or is a wall. You can go from one cell to another only\r\nif both cells are empty and have a common side.Pavel drew a grid maze\r\nwith all empty cells forming a connected area. That is, you can go from\r\nany empty cell to any other one. Pavel doesn\u2019t like it when his maze has\r\ntoo little walls. He wants to turn exactly empty cells into walls so\r\nthat all the remaining cells still formed a connected area. Help him.\r\n", "solutions": ["#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nconst int N = 1234;\n\nchar a[N][N];\nbool was[N][N];\nint x[N * N], y[N * N];\n\nint main() {\n  int n, m, s;\n  scanf(\"%d %d %d\", &n, &m, &s);\n  for (int i = 0; i < n; i++) scanf(\"%s\", a[i]);\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++) was[i][j] = false;\n  bool found = false;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n      if (!found && a[i][j] == '.') {\n        int b = 1, e = 1;\n        x[1] = i;\n        y[1] = j;\n        was[i][j] = true;\n        while (b <= e) {\n          for (int q = 0; q < 4; q++) {\n            int xk = x[b] + dx[q];\n            int yk = y[b] + dy[q];\n            if (xk >= 0 && yk >= 0 && xk < n && yk < m)\n              if (a[xk][yk] == '.' && !was[xk][yk]) {\n                e++;\n                x[e] = xk;\n                y[e] = yk;\n                was[xk][yk] = true;\n              }\n          }\n          b++;\n        }\n        for (int id = e - s + 1; id <= e; id++) a[x[id]][y[id]] = 'X';\n        found = true;\n      }\n  for (int i = 0; i < n; i++) printf(\"%s\\n\", a[i]);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar"], "dificulty": "1600", "interactive": false}