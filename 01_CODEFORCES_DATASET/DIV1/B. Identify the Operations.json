{
    "link": "https://codeforces.com//contest/1442/problem/B",
    "problemId": "782907",
    "problem_idx": "B",
    "shortId": "1442B",
    "contest_number": "1442",
    "problem_submissions": {
        "F": [
            97498578,
            135803098
        ],
        "E": [
            97475216,
            97479604,
            97479996,
            97476389,
            97475771,
            97482490,
            97482122,
            97486462,
            97481313,
            97514122,
            97491110,
            97570605,
            97570447,
            97483367,
            97482486,
            97530901,
            97530677,
            97490693,
            97491170,
            97483183,
            97744761,
            97465807,
            97518516,
            97525092
        ],
        "D": [
            97466130,
            97467957,
            97470622,
            97481203,
            97465568,
            97454688,
            97470507,
            97479495,
            97471531,
            97513997,
            97513923,
            97474497,
            97524422,
            97524418,
            97524414,
            97523769,
            97523651,
            97523580,
            97514880,
            97514861,
            97470422,
            97454149,
            97469561,
            97480908,
            97475630,
            97456546,
            97494847,
            97472947,
            97473292
        ],
        "C": [
            97461787,
            97460269,
            97457703,
            97453909,
            97462173,
            97474564,
            97455050,
            97455856,
            97466820,
            97514136,
            97458387,
            97515471,
            97514818,
            97514812,
            97514752,
            97514717,
            97462625,
            97478118,
            97463398,
            97456934,
            97468590,
            97472482,
            97456397,
            97465702,
            97461718
        ],
        "B": [
            97444657,
            97444364,
            97444049,
            97441804,
            97446454,
            97444215,
            97443077,
            97445131,
            97444667,
            97514148,
            97444728,
            97447073,
            97465519,
            97447003,
            97445633,
            97445150,
            97448727,
            97454658,
            97448347,
            97442585
        ],
        "A": [
            97436722,
            97436568,
            97436299,
            97438819,
            97440488,
            97436328,
            97437458,
            97436707,
            97440205,
            97514153,
            97437001,
            97448738,
            97444789,
            97436058,
            97438579,
            97436174,
            97437755,
            97436528,
            97438505,
            97439502
        ]
    },
    "name": "B. Identify the Operations",
    "statement": "We start with a permutation a_1, a_2,\r\nldots, a_n and with an empty array b. We apply the following operation k\r\ntimes.On the i-th iteration, we select an index t_i (1\r\nle t_i\r\nle n-i+1), remove a_{t_i} from the array, and append one of the numbers\r\na_{t_i-1} or a_{t_i+1} (if t_i-1 or t_i+1 are within the array bounds)\r\nto the right end of the array b. Then we move elements a_{t_i+1},\r\nldots, a_n to the left in order to fill in the empty space.You are given\r\nthe initial permutation a_1, a_2,\r\nldots, a_n and the resulting array b_1, b_2,\r\nldots, b_k. All elements of an array b are . Calculate the number of\r\npossible sequences of indices t_1, t_2,\r\nldots, t_k modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn't exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << \", \";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: A set (not multiset!) with support for finding the $n$'th\n * element, and finding the index of an element. Change \\texttt{null\\_type} for map.\n * Time: O(\\log N)\n * Source: KACTL\n   * https://codeforces.com/blog/entry/11080\n * Verification: many\n */\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, \n\trb_tree_tag, tree_order_statistics_node_update>; \n#define ook order_of_key\n#define fbo find_by_order\n\nvoid treeExample() {\n\tTree<int> t, t2; t.insert(8);\n\tauto it = t.insert(10).f; assert(it == t.lb(9));\n\tassert(t.ook(10) == 1 && t.ook(11) == 2 && *t.fbo(0) == 8);\n\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t\n}\n\n// int atMost(Tree<int>& T, int r) { \n// \treturn T.ook(r+1); }\n// int getSum(Tree<int>& T, int l, int r) { \n// \treturn atMost(T,r)-atMost(T,l-1); }\n\nint getSum(vi& v, int l, int r) {\n\treturn v[r]-v[l-1];\n}\n\nint N,K;\nvi A,B;\n\nvoid solve(int tc) {\n\tre(N,K);\n\tA.rsz(N), B.rsz(K); re(A,B);\n\tmap<int,int> m;\n\tF0R(i,N) m[A[i]] = i+1;\n\ttrav(t,B) {\n\t\tif (!m.count(t)) {\n\t\t\tps(0);\n\t\t\treturn;\n\t\t}\n\t\tt = m[t];\n\t}\n\tset<int> inds;\n\tinds.ins(0), inds.ins(N+1);\n\ttrav(t,B) inds.ins(t);\n\tvi emp(N+5);\n\tFOR(i,1,N+1) if (!inds.count(i)) emp[i] ++;\n\tFOR(i,1,sz(emp)) emp[i] += emp[i-1];\n\tmi ans = 1;\n\t// dbg(\"WHOOPS\",B);\n\ttrav(t,B) {\n\t\tauto it = inds.find(t);\n\t\tint x = *prev(it), y = *next(it);\n\t\t// dbg(\"HA\",getSum(emp,x+1,y-1));\n\t\tans *= (getSum(emp,x+1,*it-1) > 0) + (getSum(emp,*it+1,y-1) > 0);\n\t\tinds.erase(it);\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dsu",
        "greedy",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Identify the Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/84298",
    "editorial": "Consider element with index that has value in the array . There are\r\nthree options: Both and are present in the array . Then both of them\r\nshould stay in the array after the first operation we will write them\r\ndown later on. However, can only be added to the array b while removing\r\none of the neighbors. We have reached a contradiction, so the answer is\r\n0. One of the numbers , is present in the array , another is not. Then\r\nwe have to remove the one that is not present in and continue solving\r\nthe problem. Neither nor is present in . is not present in any other\r\nplace in (because all number in are unique), and , and are\r\nindistinguishable by the following operations. Let us then remove any\r\none of them (say, left) and \"remove\" all remaining tags. In this case,\r\nwe can multiply answer by 2 and continue solving the problem.Now we know\r\nthat the answer is either 0 or a power of 2. To calculate the answer we\r\nonly need to implement the above-mentioned algorithm. Let us store a of\r\navailable numbers in the array , and a of numbers that are yet to appear\r\nin the array to implement necessary checks. The solution will have\r\ncomplexity (that can be optimized to with help of arrays and\r\ndouble-linked lists, but it was not necessary for this particular\r\nproblem).\r\n"
}