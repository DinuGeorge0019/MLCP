{
    "link": "https://codeforces.com//contest/1852/problem/B",
    "problemId": "2099133",
    "problem_idx": "B",
    "shortId": "1852B",
    "contest_number": "1852",
    "problem_submissions": {
        "F": [
            215258181,
            215285692,
            217509901,
            217509714
        ],
        "E": [
            215240027,
            215239122,
            215243644,
            215243658,
            215248799,
            215245960,
            215237098,
            215240727,
            215296441,
            215327365,
            215336328,
            217901271,
            215247415
        ],
        "D": [
            215222100,
            215222081,
            215222261,
            215225730,
            215218775,
            215382147,
            215226776,
            215250750,
            215250174,
            215230611,
            215232642,
            215226731,
            215232589,
            215240152,
            215237043,
            215236182,
            215239579,
            215241752,
            215242725
        ],
        "C": [
            215209363,
            215208759,
            215214250,
            215220833,
            215208505,
            215217394,
            215219756,
            215218376,
            215205472,
            215208510,
            215213920,
            215221691,
            215216406,
            215223920,
            215226652,
            215216927,
            215221642,
            215210662,
            215212429
        ],
        "B": [
            215201282,
            215200579,
            215202726,
            215199335,
            215200474,
            215207713,
            215208166,
            215202505,
            215214027,
            215200003,
            215206319,
            215205331,
            215204344,
            215212727,
            215206313,
            215209315,
            215209426,
            215199777,
            215204560
        ],
        "A": [
            215201184,
            215192031,
            215194261,
            215194419,
            215219859,
            215194029,
            215260286,
            215197669,
            215196351,
            215192202,
            215192228,
            215192416,
            215194163,
            215196399,
            215195136,
            215198712,
            215191998,
            215201193,
            215192233,
            215195682
        ]
    },
    "name": "B. Imbalanced Arrays",
    "statement": "Ntarsis has come up with an array a of n non-negative integers.Call an\r\narray b of n integers if it satisfies the following: -n\r\nle b_i\r\nle n, b_i\r\nne 0, there are no two indices (i, j) (1\r\nle i, j\r\nle n) such that b_i + b_j = 0, for each 1\r\nleq i\r\nleq n, there are a_i indices j (1\r\nle j\r\nle n) such that b_i+b_j>0, where i and j are not necessarily distinct.\r\nGiven the array a, Ntarsis wants you to construct some imbalanced array.\r\nHelp him solve this task, or determine it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> p(n);\n    std::iota(p.begin(), p.end(), 0);\n    std::sort(p.begin(), p.end(), [&](int i, int j) {\n        return a[i] < a[j];\n    });\n    \n    int l = 0, r = n - 1;\n    int pos = 0;\n    std::vector<int> ans(n);\n    for (int i = n; i > 0; i--) {\n        if (a[p[l]] - pos == 0) {\n            ans[p[l]] = -i;\n            l++;\n        } else if (a[p[r]] - pos == i) {\n            ans[p[r]] = i;\n            pos++;\n            r--;\n        } else {\n            std::cout << \"NO\\n\";\n            return;\n        }\n    }\n    std::cout << \"YES\\n\";\n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << \" \\n\"[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Imbalanced Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/116940",
    "editorial": "Analysis: buffering, nsqrtlog SolutionAt the\nstart, let be an index such that has the greatest absolute value. If is\nnegative, we have , and else . Moreover, we canât have for any indices\nand , because that implies is both positive and negative, contradiction.\nHence, the necessary and sufficient condition to check if we can\ndetermine an element in array with maximum absolute value is (there\nexists an element of array equal to ) xor (there exists an element of\narray equal to ). Then, we can remove that element and re-calculate the\narray, leading to an solution. If the check fails at any moment, there\nis no valid solution.To optimize it further, note that we can sort array\nat the start and keep track of them in a deque-like structure. We only\nneed to check the front and end of the deque to see if our key condition\nholds. Finally, we can use a variable to record the number of positive\nelements deleted so far and subtract it from the front and end of the\ndeque when checking our condition, so that each check is . The overall\ncomplexity becomes due to sorting.\n",
    "hint": [
        "Hint 1 You can solve the problem by picking one number from each pair , , .",
        "Hint 2 implies .",
        "Hint 3 First, try to determine one index in , or determine if that's impossible.",
        "Hint 4 Sort the array to optimize the solution."
    ]
}