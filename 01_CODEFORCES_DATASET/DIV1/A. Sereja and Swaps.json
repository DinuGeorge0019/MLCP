{
    "link": "https://codeforces.com//contest/425/problem/A",
    "problemId": "8917",
    "problem_idx": "A",
    "shortId": "425A",
    "contest_number": "425",
    "problem_submissions": {
        "B": [
            6493816,
            6490109,
            6487858,
            6492945,
            6493447,
            6494871,
            6503981,
            6490064,
            6487024,
            6487873,
            6488901,
            6490848,
            6487215,
            6488740,
            6491398,
            6488181,
            6494124
        ],
        "E": [
            6490795,
            6493696,
            6491349,
            6492041,
            6492843,
            6491006,
            6493942,
            6492765,
            6494748,
            6494561,
            6492813,
            6495319,
            6492515
        ],
        "D": [
            6489455,
            6489243,
            6493425,
            6488979,
            6491658,
            6492358,
            6492448,
            6491514,
            6489861,
            6490799,
            6495344,
            6495192,
            6489703,
            6494515,
            6492875,
            6489743,
            6494196,
            6487259
        ],
        "C": [
            6487948,
            6491220,
            6490395,
            6494547,
            6494500,
            6494191,
            6490274,
            6489790,
            6489399,
            6488464,
            6495052,
            6490305,
            6492770,
            6492019,
            6492713,
            6491433,
            6490329,
            6492999,
            6490722
        ],
        "A": [
            6485874,
            6485358,
            6485796,
            6485600,
            6486055,
            6486577,
            6485984,
            6486210,
            6485602,
            6485840,
            6487099,
            6485836,
            6485353,
            6486318,
            6486057,
            6485564,
            6493037
        ]
    },
    "name": "A. Sereja and Swaps",
    "statement": "As usual, Sereja has array , its elements are integers: . Let’s\r\nintroduce notation:A swap operation is the following sequence of\r\nactions: choose two indexes ; perform assignments . What maximum value\r\nof function can Sereja get if he is allowed to perform at most swap\r\noperations?\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\nint a[300];\n\nint main() {\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"wt\", stdout);\n#endif\n\n    int N, K;\n    cin >> N >> K;\n    forn(i, N) cin >> a[i];\n    int ans = -1e9;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i; j < N; ++j) {\n            multiset<int> del, add;\n            int sum = 0;\n            forn(k, N) {\n                if (k >= i && k <= j) {\n                    del.insert(a[k]);\n                    sum += a[k];\n                    if (del.size() > K) {\n                        del.erase(--del.end());\n                    }\n                } else {\n                    add.insert(a[k]);\n                    if (add.size() > K) {\n                        add.erase(add.begin());\n                    }\n                }\n            } \n            while (!add.empty() && !del.empty() && *add.rbegin() > *del.begin()) {\n                sum += *add.rbegin() - *del.begin();\n                add.erase(--add.end());\n                del.erase(del.begin());\n            }\n            ans = max(ans, sum);\n        }\n    }\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Sereja and Swaps.json",
    "editorial_link": "https://codeforces.com//blog/entry/11998",
    "editorial": "Lets backtrack interval on which will contain maximal sum. To improve\r\nour sum we can swap not more then minimal elements from the interval to\r\nmaximal elements that donât belong to interval. As isnât big we can do\r\nit in any way. Author solution sort all elemets from interval in\r\nincreasing order and all elements that donât belong to interval by\r\ndescreasing order. We will swap elements one by one while we havenât\r\ndone swaps and we have some unswaped elements in first set and we have\r\nsome unswaped elemets in second set and swap is optimal(we will optimize\r\nthe answer after this swap). Author solution works in time . Is there\r\nsome ideas how to solve this problem in time or ?\r\n",
    "hint": []
}