{
    "link": "https://codeforces.com//contest/708/problem/D",
    "problemId": "68953",
    "problem_idx": "D",
    "shortId": "708D",
    "contest_number": "708",
    "problem_submissions": {
        "D": [
            20128638,
            20126204,
            20127943,
            20128433,
            20129319,
            20131176,
            20131436,
            20129838,
            20122993,
            20128159,
            20142291,
            20131523,
            20133302
        ],
        "C": [
            20118349,
            20120224,
            20122617,
            20118594,
            20120712,
            20117957,
            20121003,
            20121397,
            20122448,
            20125761,
            20125377,
            20142883,
            20115423,
            20116938,
            20120664,
            20122725,
            20120078,
            20120943
        ],
        "B": [
            20114040,
            20113824,
            20115208,
            20114995,
            20116521,
            20114682,
            20122861,
            20116437,
            20115616,
            20134188,
            20115824,
            20122403,
            20114546,
            20119679,
            20134838,
            20114458,
            20118558,
            20114710,
            20134501
        ],
        "A": [
            20109754,
            20109973,
            20109781,
            20109720,
            20110304,
            20110371,
            20110361,
            20110988,
            20111867,
            20110273,
            20109747,
            20109936,
            20109851,
            20109665,
            20123051,
            20111085,
            20110162,
            20110043,
            20110060
        ],
        "E": [
            20132586,
            20171243,
            20148122,
            20129101,
            20132661,
            20128262,
            20149149
        ]
    },
    "name": "D. Incorrect Flow",
    "statement": "At the entrance examination for the magistracy of the MSU\r\nCyber-Mechanics Department Sasha got the question about Ford-Fulkerson\r\nalgorithm. He knew the topic perfectly as he worked with it many times\r\non programming competition. As the task for the question he was given a\r\nnetwork with partially build flow that he had to use in order to\r\ndemonstrate the workflow of the algorithm. He quickly finished to write\r\nthe text and took a look at the problem only to understand that the\r\ngiven network is incorrect!Suppose you are given a directed graph with\r\ntwo special nodes and called source and sink. We denote as the number of\r\nnodes in the graph, i.e. and stands for the number of directed edges in\r\nthe graph, i.e. . For the purpose of this problem we always consider\r\nnode to be the source and node to be the sink. In addition, for each\r\nedge of the graph we define the capacity function and flow function .\r\nFunction represents the correct flow if the following conditions are\r\nsatisfied: For each edge the flow is non-negative and does not exceed\r\ncapacity , i.e. . For each node , that is not source or sink ( and ) the\r\nsum of flows of all edges going in is equal to the sum of the flows\r\namong all edges going out from . In other words, there is no flow stuck\r\nin . It was clear that as the exam was prepared last night and there are\r\nplenty of mistakes in the tasks. Sasha asked one of the professors to\r\nfix the network or give the correct task, but the reply was that the\r\nmagistrate student should be able to fix the network himself. As the\r\nprofessor doesn\u2019t want the task to become easier, he asks Sasha to fix\r\nthe network in a such way that the total number of changes is minimum\r\npossible. Sasha is not allowed to remove edges, add new ones or reverse\r\nthe direction of existing edges. The only thing he is able to do is to\r\nchange capacity function and flow function . Moreover, all the values\r\nshould remain non-negative integers. There is no requirement on the flow\r\nto be maximum in any sense.Find the minimum possible total change of the\r\nfunctions and that Sasha has to make in order to make the flow correct.\r\nThe total change is defined as the sum of absolute differences, i.e. if\r\nnew functions are and , then the total change is .\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int N = 110;\nconst int E = 20000;\nconst int INF = (int)5e8 + 10;\n\nstruct Edge\n{\n\tint v, to;\n\tint flow, cap, cost;\n\n\tEdge() : v(), to(), flow(), cap(), cost() {}\n\tEdge (int _v, int _to, int _cap, int _cost) : v(_v), to(_to), flow(0), cap(_cap), cost(_cost) {}\n};\nEdge ed[E];\nint edSz;\nint S, T;\nint n;\nint ans = 0;\nint fl[N];\nint dist[N];\nint par[N];\n\nvoid addEdge(int v, int to, int cap, int cost)\n{\n\ted[edSz++] = Edge(v, to, cap, cost);\n\ted[edSz++] = Edge(to, v, 0, -cost);\n}\n\nvoid read()\n{\n\tint m;\n\tscanf(\"%d%d\", &n, &m);\n\tS = n;\n\tT = n + 1;\n\twhile(m--)\n\t{\n\t\tint v, u, c, f;\n\t\tscanf(\"%d%d%d%d\", &v, &u, &c, &f);\n\t\tv--;u--;\n\t\tfl[v] -= f;\n\t\tfl[u] += f;\n\t\tif (c < f)\n\t\t{\n\t\t\tans += f - c;\n\t\t\taddEdge(u, v, f - c, 0);\n\t\t\taddEdge(u, v, c, 1);\n\t\t\taddEdge(v, u, INF, 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\taddEdge(u, v, f, 1);\n\t\t\taddEdge(v, u, c - f, 1);\n\t\t\taddEdge(v, u, INF, 2);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (fl[i] > 0)\n\t\t\taddEdge(S, i, fl[i], 0);\n\t\telse\n\t\t\taddEdge(i, T, -fl[i], 0);\n\t}\n\taddEdge(n - 1, 0, INF, 0);\n\tn += 2;\n\treturn;\n}\n\nbool FB()\n{\n\tfor (int i = 0; i < n; i++)\n\t\tdist[i] = INF;\n\tdist[S] = 0;\n\tbool ch = true;\n\twhile(ch)\n\t{\n\t\tch = false;\n\t\tfor (int i = 0; i < edSz; i++)\n\t\t{\n\t\t\tEdge e = ed[i];\n\t\t\tif (e.flow == e.cap) continue;\n\t\t\tint v = e.v;\n\t\t\tif (dist[v] == INF) continue;\n\t\t\tint u = e.to;\n\t\t\tif (dist[u] <= dist[v] + e.cost) continue;\n\t\t\tdist[u] = dist[v] + e.cost;\n\t\t\tpar[u] = i;\n\t\t\tch = true;\n\t\t}\n\t}\n\treturn dist[T] != INF;\n}\n\nint MCMF()\n{\n\tint res = 0;\n\twhile(FB())\n\t{\n\t\tint flow = INF;\n\t\tint v = T;\n\t\twhile(v != S)\n\t\t{\n\t\t\tEdge e = ed[par[v]];\n\t\t\tflow = min(flow, e.cap - e.flow);\n\t\t\tv = e.v;\n\t\t}\n\t\tv = T;\n\t\twhile(v != S)\n\t\t{\n\t\t\tint id = par[v];\n\t\t\ted[id].flow += flow;\n\t\t\ted[id ^ 1].flow -= flow;\n\t\t\tv = ed[id].v;\n\t\t}\n\t\tres += flow * dist[T];\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tread();\n\tans += MCMF();\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Incorrect Flow.json",
    "editorial_link": "https://codeforces.com//blog/entry/46763",
    "editorial": "This problem could be solved by max-flow-min-cost algorithm. At first we\r\nwill fix edges with flow exceeding capacity. We will just increase\r\ncapacity to the flow value and add sum of all these changes to the\r\nanswer. Now we need to get rid of excess incoming flow in some vertices\r\nand excess outcoming flow in some other vertices. Consider new flow-cost\r\nnetwork, source and sink will be new vertices. We add edge from new\r\nsource into every vertex with excess of incoming flow with zero cost and\r\ncapacity equals to the excess flow. We add edge into new sink every\r\nvertex with excess of outcoming flow with zero cost and capacity equals\r\nto the excess flow. We add edge from old sink to the old source with\r\nzero cost and infinite capacity. Instead of every edge of the initial\r\ngraph (denote its capacity as , flow as ) we will create three edges:\r\nthe first one could decrease flow in the initial graph without change of\r\ncapacity (its cost equals 1, capacity equals , it has opposite\r\ndirection), the second one could increase flow without change of\r\ncapacity (its cost equals 1, capacity equals , it has same direction),\r\nthe third one could increase flow and capacity as much as you need (its\r\ncost equals 1, capacity equals infinity, it has same direction). One\r\nmore trick is that cost of part of the second type edge should be zero\r\ninstead of one if it had , because in this case we make changes which\r\nhave already pay.\r\n"
}