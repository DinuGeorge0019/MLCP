{"link": "https://codeforces.com//contest/223/problem/D", "problemId": "1799", "problem_idx": "D", "shortId": "223D", "contest_number": "223", "problem_submissions": {"D": [2201204, 2227460, 2224793], "B": [2192755, 2191107, 2190792, 2191517, 2191782, 2192823, 2191897, 2192037, 2190839, 2192321, 2191711, 2193472, 2192118, 2192281, 2191191], "C": [2191764, 2193929, 2191887, 2192482, 2192857, 2191011, 2194134, 2193589, 2192831, 2190279, 2193227, 2192079, 2193334, 2194145, 2192669], "A": [2189710, 2189450, 2189566, 2189994, 2190232, 2194735, 2190245, 2190504, 2195271, 2194162, 2190423, 2195205, 2191251, 2190814, 2195342], "E": [17753349, 2235305]}, "name": "D. Spider", "statement": "A plane contains a not necessarily convex polygon without\r\nself-intersections, consisting of vertexes, numbered from 1 to . There\r\nis a spider sitting on the border of the polygon, the spider can move\r\nlike that: The spider moves from the point with coordinates , lying on\r\nthe polygon border, to the point with coordinates , also lying on the\r\nborder. The spider can\u2019t go beyond the polygon border as it transfers,\r\nthat is, the spider\u2019s path from point to point goes along the polygon\r\nborder. It\u2019s up to the spider to choose the direction of walking round\r\nthe polygon border (clockwise or counterclockwise). The spider moves\r\nfrom point with coordinates to point with coordinates , at that points\r\nand must lie on one vertical straight line (), point must be not lower\r\nthan point () and segment mustn\u2019t have points, located strictly outside\r\nthe polygon (specifically, the segment can have common points with the\r\nborder). Initially the spider is located at the polygon vertex with\r\nnumber . Find the length of the shortest path to the vertex number ,\r\nconsisting of transfers and descends. The distance is determined by the\r\nusual Euclidean metric .\r\n", "solutions": ["// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\nstruct XD{\n    double x,y;\n    int id;\n    XD(double xx=0,double yy=0):x(xx),y(yy){}\n    void get(int ii){\n        id=ii;\n        scanf(\"%lf%lf\",&x,&y);\n    }\n    XD operator-(const XD& b)const{\n        return XD(x-b.x,y-b.y);\n    }\n    XD operator-()const{\n        return XD(-x,-y);\n    }\n    double operator*(const XD& b)const{\n        return x*b.x+y*b.y;\n    }\n    double operator^(const XD& b)const{\n        return x*b.y-y*b.x;\n    }\n    int ss()const{\n        return x>0||(x>=-1e-9&&y>0);\n    }\n    bool operator<(const XD& b)const{\n        if(ss()!=b.ss())return ss()<b.ss();\n        return ((*this)^b)<0;\n    }\n    void print(const char* c){printf(\"%s: %.3lf %.3lf\\n\",c,x,y);}\n    double len(){return sqrt(x*x+y*y);}\n};\nconst double eps=1e-7;\nbool cmpx(const XD& a,const XD& b){\n    return a.x==b.x?a.y<b.y:a.x<b.x;\n}\nbool cmpy(const XD& a,const XD& b){\n    return a.y==b.y?a.x<b.x:a.y<b.y;\n}\nXD in[101000];\ndouble nowx;\nstruct line{\n    int a,b,id;\n    line(){}\n    line(int aa,int bb,int ii):a(aa),b(bb),id(ii){\n        if(cmpx(in[b],in[a]))swap(a,b);\n    }\n    double get(double x)const{\n        if(in[a].x==in[b].x)return in[b].y;\n        return ((x-in[a].x)*in[b].y+(in[b].x-x)*in[a].y)/((double)in[b].x-in[a].x);\n    }\n    bool isv()const{\n        return fabs(in[a].x-in[b].x)<eps;\n    }\n    bool isin(double x)const{\n        return x>=in[a].x&&x<=in[b].x;\n    }\n    bool operator<(const line& x)const{\n        double x1=get(nowx),x2=x.get(nowx);\n        if(fabs(x1-x2)<eps){\n            if(x.isv())return 0;\n            if(isv())return 1;\n            double n1=nowx-1e-4,n2=nowx+1e-4;\n            if(isin(n1)&&x.isin(n1))return get(n1)<x.get(n1);\n            else if(isin(n2)&&x.isin(n2))return get(n2)<x.get(n2);\n            else return id<x.id;\n        }\n        return x1<x2;\n    }\n    void print()const{\n        in[a].print(\"a\");\n        in[b].print(\"b\");\n    }\n};\nline lns[101000];\nstruct ev{\n    int ln;\n    int isin;\n    ev(){}\n    ev(int ll,int ii):ln(ll),isin(ii){}\n    int pt()const{\n        if(isin)return lns[ln].a;\n        else return lns[ln].b;\n    }\n    bool operator<(const ev& b)const{\n        int p1=pt(),p2=b.pt();\n        if(in[p1].x==in[p2].x)return isin>b.isin;\n        return cmpx(in[p1],in[p2]);\n    }\n};\nev evs[201000];\nstruct ee{\n    int y;\n    double l;\n    ee(int yy=0,double ll=0):y(yy),l(ll){}\n};\nvector<ee> ed[101000];\nbool hasd[101000];\nbool hasu[101000];\nint que[101000],qs,qe;\ndouble dis[101000];\nbool inq[101000];\nint n;\ninline void push(int x){\n    if(inq[x])return;\n    inq[x]=1;\n    que[qe++]=x;\n    if(qe==101000)qe=0;\n}\ninline int pop(){\n    int a=que[qs++];\n    if(qs==101000)qs=0;\n    inq[a]=0;\n    return a;\n}\ninline double spfa(int st,int end){\n    int i;\n    for(i=0;i<n;i++)dis[i]=1e100;\n    dis[st]=0;\n    qs=qe=0;\n    push(st);\n    while(qs!=qe){\n        int np=pop();\n        for(i=0;i<ed[np].size();i++){\n            int y=ed[np][i].y;\n            double l=ed[np][i].l;\n            if(dis[y]>dis[np]+l){\n                dis[y]=dis[np]+l;\n                push(y);\n            }\n        }\n    }\n    return dis[end];\n}\nint main(){\n    scanf(\"%d\",&n);\n    int i,j;\n    for(i=0;i<n;i++){\n        in[i].get(i);\n    }\n    for(i=0;i<n;i++){\n        int ii=(i+1==n?0:i+1);\n        double d=(in[i]-in[ii]).len();\n        ed[i].push_back(ee(ii,d));\n        ed[ii].push_back(ee(i,d));\n    }\n    for(i=0;i<n;i++){\n        int p1=(i==0?n-1:i-1);\n        int p2=(i==n-1?0:i+1);\n        XD l1=in[p1]-in[i];\n        XD l2=in[p2]-in[i];\n        XD b(0,-1);\n        if((l1.x==0&&l1.y<0)||(l2.x==0&&l2.y<0))hasd[i]=0;\n        else if(l2<l1)hasd[i]=1;\n        else hasd[i]=0;\n        if((l1.x==0&&l1.y>0)||(l2.x==0&&l2.y>0))hasu[i]=0;\n        else if(-l2<-l1)hasu[i]=1;\n        else hasu[i]=0;\n//        printf(\"hasd[%d] = %d %d\\n\",i,hasd[i],hasu[i]);\n    }\n    int ec=0;\n    for(i=0;i<n;i++){\n        int ii=(i+1==n?0:i+1);\n        lns[i]=line(i,ii,i);\n        evs[ec++]=ev(i,0);\n        evs[ec++]=ev(i,1);\n    }\n    sort(evs,evs+ec);\n    multiset<line> ss;\n    for(i=0;i<ec;i++){\n        int id=evs[i].ln;\n        int isin=evs[i].isin;\n        int p=evs[i].pt();\n        nowx=in[p].x;\n        if(hasd[p]||hasu[p]){\n            multiset<line>::iterator i2;\n//            for(i2=ss.begin();i2!=ss.end();i2++)i2->print();\n//            puts(\"-----------\");\n            multiset<line>::iterator it=ss.lower_bound(line(p,p,-1));\n            if(hasu[p]){\n                i2=it;\n                while(i2!=ss.end()&&i2->get(nowx)<in[p].y+eps)i2++;\n                if(i2!=ss.end()){\n                    double y=i2->get(nowx);\n//                    in[i2->a].print(\"a\");\n//                    in[i2->b].print(\"b\");\n//                    printf(\"p=%d nowx=%d y=%.3lf\\n\",p,nowx,y);\n                    if(y>in[p].y+eps){\n                        double d=y-in[p].y;\n                        XD pp(nowx,y);\n                        ed[i2->a].push_back(ee(p,d+(in[i2->a]-pp).len()));\n                        ed[i2->b].push_back(ee(p,d+(in[i2->b]-pp).len()));\n                    }\n                }\n            }\n            if(hasd[p]&&it!=ss.begin()){\n                i2=it;\n                i2--;\n                while(i2!=ss.begin()&&i2->get(nowx)>in[p].y-eps)i2--;\n                double y=i2->get(nowx);\n//                in[i2->a].print(\"a\");\n//                in[i2->b].print(\"b\");\n                //printf(\"p=%d nowx=%d y=%.3lf\\n\",p,nowx,y);\n                if(y<in[p].y-eps){\n                    double d=in[p].y-y;\n                    XD pp(nowx,y);\n                    ed[p].push_back(ee(i2->a,d+(in[i2->a]-pp).len()));\n                    ed[p].push_back(ee(i2->b,d+(in[i2->b]-pp).len()));\n                }\n            }\n        }\n//        printf(\"i=%d p=%d %s %d\\n\",i,p,isin?\"add\":\"remove\",id);\n        if(isin){\n            ss.insert(lns[id]);\n        }else{\n            ss.erase(lns[id]);\n        }\n    }\n    /*\n    for(i=0;i<n;i++){\n        printf(\"%d: \",i);\n        for(int j=0;j<ed[i].size();j++)printf(\"(%d,%.3lf) \",ed[i][j].y,ed[i][j].l);\n        puts(\"\");\n    }*/\n    int start,end;\n    scanf(\"%d%d\",&start,&end);start--;end--;\n    printf(\"%.9lf\\n\",spfa(start,end));\n}\n// vim: fdm=marker:commentstring=\\ \\\"\\ %s:nowrap:autoread\n\n"], "input": "", "output": "", "tags": ["geometry", "graphs"], "dificulty": "3000", "interactive": false}