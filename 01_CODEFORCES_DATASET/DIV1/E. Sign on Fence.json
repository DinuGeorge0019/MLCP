{"link": "https://codeforces.com//contest/484/problem/E", "problemId": "16632", "problem_idx": "E", "shortId": "484E", "contest_number": "484", "problem_submissions": {"C": [8575684, 8569482, 8574840, 8573079, 8568696, 8568968, 8568953, 8573362, 8573344, 8575027, 8567400, 8571965, 8576498, 8577415], "D": [8571455, 8567671, 8570841, 8566590, 8573430, 8573737, 8570084, 8567140, 8569185, 8572829, 8569478, 8568570, 8570839, 8567603, 8570405, 8575447, 8576600, 8570465], "E": [8569351, 8573776, 8571793, 8588317, 8599514, 8573714, 8570287, 8574072, 8576131, 8573638, 8564834, 8574687], "B": [8564067, 8565086, 8563436, 8564295, 8563987, 8571069, 8564862, 8565541, 8565694, 8569521, 8562876, 8561100, 8562368, 8567973, 8567211, 8562295, 8570348, 8565013], "A": [8560332, 8562129, 8565876, 8560720, 8562390, 8561095, 8562048, 8560946, 8561471, 8562609, 8565347, 8560391, 8562975, 8560379, 8563409, 8565195, 8567495, 8562118]}, "name": "E. Sign on Fence", "statement": "Bizon the Champion has recently finished painting his wood fence. The\r\nfence consists of a sequence of panels of meter width and of arbitrary\r\nheight. The -th panel\u2019s height is meters. The adjacent planks follow\r\nwithout a gap between them.After Bizon painted the fence he decided to\r\nput a \"for sale\" sign on it. The sign will be drawn on a rectangular\r\npiece of paper and placed on the fence so that the sides of the sign are\r\nparallel to the fence panels and are also aligned with the edges of some\r\npanels. Bizon the Champion introduced the following constraints for the\r\nsign position: The width of the sign should be exactly meters. The sign\r\nmust fit into the segment of the fence from the -th to the -th panels,\r\ninclusive (also, it can\u2019t exceed the fence\u2019s bound in vertical\r\ndirection). The sign will be really pretty, So Bizon the Champion wants\r\nthe sign\u2019s height to be as large as possible.You are given the\r\ndescription of the fence and several queries for placing sign. For each\r\nquery print the maximum possible height of the sign that can be placed\r\non the corresponding segment of the fence with the given fixed width of\r\nthe sign.\r\n", "solutions": ["#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\nstruct TResult {\n    int lx, rx, maxs, l;\n\n    TResult(int lx = 0, int rx = 0, int maxs = 0, int l = 0)\n        : lx(lx)\n        , rx(rx)\n        , maxs(maxs)\n        , l(l)\n    {\n    }\n\n    TResult operator+(const TResult &r) const {\n        TResult res;\n        res.l = l + r.l;\n        if (lx == l) res.lx = lx + r.lx;\n        else res.lx = lx;\n        if (r.rx == r.l) res.rx = r.rx + rx;\n        else res.rx = r.rx;\n        res.maxs = max(max(res.lx, res.rx), max(maxs, r.maxs));\n        res.maxs = max(res.maxs, rx + r.lx);\n        return res;\n//        return TResult(lx, r.rx, max(max(maxs, r.maxs), rx + r.lx));\n    }\n};\n\nstruct TNode {\n    int L, R;\n    int left, right;\n    TResult res;\n\n    TNode(int L = 0, int R = 0)\n        : L(L)\n        , R(R)\n        , left(0)\n        , right(0)\n        , res()\n    {\n    }\n};\n\nconst int MAXT = 4000000;\nTNode tree[MAXT];\nint tc = 0;\n\nint buildTree(int L, int R) {\n    int node = tc++;\n    tree[node] = TNode(L, R);\n    tree[node].res = TResult(0, 0, 0, R - L);\n    if (R - L == 1) {\n        return node;\n    }\n    int M = (L + R) / 2;\n    tree[node].left = buildTree(L, M);\n    tree[node].right = buildTree(M, R);\n    return node;\n}\n\nTResult query(int node, int L, int R) {\n    if (L <= tree[node].L && tree[node].R <= R) return tree[node].res;\n    if (R <= tree[node].L || tree[node].R <= L) return TResult();\n    return query(tree[node].left, L, R) + query(tree[node].right, L, R);\n}\n\nint set1(int node, int i) {\n    if (i < tree[node].L || i >= tree[node].R) return node;\n    int newNode = tc++;\n    tree[newNode] = tree[node];    \n    if (tree[node].R - tree[node].L == 1) {\n        tree[newNode].res = TResult(1, 1, 1, 1);\n        return newNode;\n    }\n    tree[newNode].left = set1(tree[node].left, i);\n    tree[newNode].right = set1(tree[node].right, i);\n    tree[newNode].res = tree[tree[newNode].left].res + tree[tree[newNode].right].res;\n    return newNode;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    vector<pii> a(N);\n    forn(i, N) {\n        cin >> a[i].fi;\n        a[i].se = i;\n    }\n    sort(rall(a));\n    vi roots(N + 1);\n    roots[0] = buildTree(0, N);\n    forn(i, N) roots[i + 1] = set1(roots[i], a[i].se);\n    int Q;\n    cin >> Q;\n    forn(q, Q) {\n        int A, B, W;\n        cin >> A >> B >> W;\n        --A;\n        int l = 0, r = N;\n        while (r - l > 1) {\n            int m = (l + r) / 2;\n            if (query(roots[m], A, B).maxs >= W) r = m;\n            else l = m;\n        }\n        cout << a[r - 1].fi << '\\n';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "constructive algorithms", "data structures"], "dificulty": "2500", "interactive": false}