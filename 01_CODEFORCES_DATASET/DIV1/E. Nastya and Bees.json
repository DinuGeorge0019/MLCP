{"link": "https://codeforces.com//contest/1340/problem/E", "problemId": "599369", "problem_idx": "E", "shortId": "1340E", "contest_number": "1340", "problem_submissions": {"F": [77861280, 77852254, 77849797, 78528429, 78527982, 77845721, 77870771, 77870728, 77870667, 77809735, 77844929, 78038847, 77865877, 77864401, 77864363, 77862346, 77862326], "D": [77814886, 77820644, 77812632, 77817969, 78526970, 77818222, 77825103, 77825677, 77810183, 77803432, 77810910, 77812394, 77816455, 77825551, 77843873, 77828804, 77822663, 77822063], "C": [77795843, 77812380, 77824845, 77823255, 78526952, 77799809, 77811601, 77834672, 77830782, 77811370, 77793451, 77808028, 77797811, 77795450, 77802848, 77796169, 77858001, 77810294, 77809842], "A": [77782251, 77771158, 77774810, 77787508, 78526918, 78526910, 77776379, 77774309, 77776029, 77816613, 77771928, 77777830, 77775868, 77773607, 77771508, 77776009, 77776621, 77773349, 77795835, 77779579, 77772710, 77776861], "B": [77777625, 77796394, 77787259, 77781233, 78526935, 77868779, 77790975, 77793147, 77821618, 77789026, 77773962, 77770331, 77782427, 77780486, 77790796, 77783960, 77786770, 77783985, 77790124, 77791298, 77788341], "E": [77836196, 77868575, 77868568, 77868546, 77868525, 77868496, 77845628, 77864964, 77846936, 77902183, 77902167, 77902121, 77902068, 77902045, 77901978, 77850099, 77859253, 77828316, 77849841, 77848435, 77856908, 77842257]}, "name": "E. Nastya and Bees", "statement": "A beehive is a connected undirected graph where bees and Nastya can move\r\nalong the edges. A graph satisfies two properties: The degree of any of\r\nits vertex is no more than 3. For each edge, there exists a cycle of\r\nlength not greater than 5 passing through this edge. There are three\r\nbees and Nastya. You play for bees. Firstly, you choose the vertices\r\nwhere you put the bees. Then Nastya chooses another vertex in which she\r\nwill initially appear. One move is first moving the bees, then Nastya,\r\nin turn: For each of your bees, you can either move each one along some\r\nedge from the vertex they are currently staying or leave it in place.\r\nThen Nastya will move along some edge of the graph from the vertex she\r\nis currently staying/. You win if at least one of the bees and Nastya\r\nare in the same vertex at any time of the game.If this situation does\r\nnot occur after n moves, then you lose.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nconst int LOCAL = 0;\nint N, M;\nvector<int> paths[5000];\nint dist[5000][5000];\nvector<int> v(3);\nint target = -1;\nvoid bfs(int idx, int s) {\n    for(int i = 0; i < N; i++) dist[idx][i] = 1e9;\n    dist[idx][s] = 0;\n    queue<int> que;\n    que.push(s);\n    while(!que.empty()) {\n        int now = que.front();\n        que.pop();\n        for(auto to : paths[now]) {\n            if(chmin(dist[idx][to], dist[idx][now] + 1)) {\n                que.push(to);\n            }\n        }\n    }\n}\n\nvoid ask() {\n    for(int i = 0; i < 3; i++) {\n        cout << v[i] + (1 - LOCAL) << \" \";\n    }\n    cout << endl;\n    for(int i = 0; i < 3; i++) {\n        if(v[i] == target) exit(0);\n    }\n    if(LOCAL) {\n        cerr << \"target: \" << target << \" -> \";\n        if(target == -1) target = 0;\n        target = paths[target][0];\n        cerr << target << endl;\n    } else {\n        cin >> target;\n        target--;\n    }\n    for(int i = 0; i < 3; i++) {\n        if(v[i] == target) exit(0);\n    }\n}\n\nint main() {\n    cin >> N >> M;\n    for(int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        paths[a].push_back(b);\n        paths[b].push_back(a);\n    }\n    for(int i = 0; i < N; i++) {\n        bfs(i, i);\n    }\n    int maxival = 1e9;\n    for(int i = 0; i < N; i++) {\n        int tmpval = 0;\n        for(int j = 0; j < N; j++) {\n            chmax(tmpval, dist[i][j]);\n        }\n        if(chmin(maxival, tmpval)) {\n            v[0] = v[1] = v[2] = i;\n        }\n    }\n    ask();\n    for(int t = 0; t < N; t++) {\n        for(int i = 0; i < 3; i++) {\n            bool exist = false;\n            for(auto to : paths[v[i]]) {\n                if(to == target) exist = true;\n            }\n            if(exist) {\n                v[i] = target;\n                ask();\n            }\n        }\n        vector<int> u(3);\n        for(int i = 0; i < 3; i++) {\n            if(paths[target].size() > i) {\n                u[i] = paths[target][i];\n            } else {\n                u[i] = target;\n            }\n        }\n        sort(u.begin(), u.end());\n        for(int i = 0; i < 3; i++) {\n            bfs(i, u[i]);\n        }\n        int nowval = 1e9;\n        vector<int> query(3);\n        vector<int> idx(3);\n        vector<int> tmp(3);\n        for(int i = 0; i < 3; i++) {\n            idx[i] = i;\n        }\n        do {\n            int tmpval = 0;\n            for(int i = 0; i < 3; i++) {\n                tmp[i] = v[i];\n                for(auto to : paths[v[i]]) {\n                    if(dist[idx[i]][to] < dist[idx[i]][tmp[i]]) tmp[i] = to;\n                }\n                tmpval += dist[idx[i]][tmp[i]];\n            }\n            if(chmin(nowval, tmpval)) swap(query, tmp);\n        } while(next_permutation(idx.begin(), idx.end()));\n        swap(query, v);\n        ask();\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "interactive", "probabilities"], "dificulty": "3000", "interactive": false}