{
    "link": "https://codeforces.com//contest/338/problem/D",
    "problemId": "3399",
    "problem_idx": "D",
    "shortId": "338D",
    "contest_number": "338",
    "problem_submissions": {
        "D": [
            4295147,
            4299466,
            4295982,
            4299910,
            4297907,
            4322675,
            4322635,
            4296295,
            4300603,
            4303747
        ],
        "C": [
            4293877,
            4292949,
            4296119,
            4290785,
            4294450,
            4290995,
            4292819,
            4294306,
            4289507,
            4319214,
            4292496,
            4292285,
            4293888,
            4293909,
            4292095,
            4292420
        ],
        "A": [
            4292482,
            4289057,
            4289014,
            4297071,
            4289608,
            4292907,
            4298719,
            4290998,
            4292048,
            4294562,
            4288621,
            4289027,
            4288252,
            4289309
        ],
        "E": [
            4291715,
            4297382,
            4294190,
            4295220,
            4296654,
            4297161,
            4295153,
            4304466,
            4296200,
            4296272,
            4296355,
            4296995,
            4392972,
            4307055
        ],
        "B": [
            4289897,
            4290803,
            4292502,
            4296197,
            4291687,
            4294720,
            4290858,
            4290695,
            4291375,
            4290406,
            4289563,
            4290575,
            4290335,
            4290751,
            4293818,
            4293496
        ]
    },
    "name": "D. GCD Table",
    "statement": "Consider a table of size such that for all . is the greatest common\r\ndivisor of numbers and .You have a sequence of positive integer numbers\r\n. We say that this sequence occurs in table if it coincides with\r\nconsecutive elements in some row, starting from some position. More\r\nformally, such numbers and should exist that for all .Determine if the\r\nsequence occurs in table .\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nlong long a[424242];\n\nlong long gcd(long long a, long long b) {\n  while (a > 0 && b > 0)\n    if (a > b) a %= b;\n    else b %= a;\n  return a + b;\n}\n\nvoid update(long long &a, long long &b, long long c, long long d) {\n  if (b < d) {\n    long long tmp;\n    tmp = a; a = c; c = tmp;\n    tmp = b; b = d; d = tmp;\n  }\n  while (a % d != c) a += b;\n  b *= d;\n}\n\nint main() {\n  long long n, m;\n  int k;\n  cin >> n >> m >> k;\n  for (int i=0;i<k;i++) {\n    a[i] = 0;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') ch = getchar();\n    while (ch >= '0' && ch <= '9') {\n      a[i] = a[i] * 10 + ch - 48;\n      ch = getchar();\n    }\n  }\n  long long lcm = 1;\n  for (int i=0;i<k;i++) {\n    long long g = gcd(lcm, a[i]);\n    lcm /= g;\n    if (1.0 * lcm * a[i] > 1e15) {\n      puts(\"NO\");\n      return 0;\n    }\n    lcm *= a[i];\n  }\n  if (lcm > n) {\n    puts(\"NO\");\n    return 0;\n  }\n  long long x = lcm;\n  vector < pair <long long, int> > primes;\n  for (long long j = 2; j * j <= x; j++)\n    if (x % j == 0) {\n      int cnt = 0;\n      while (x % j == 0) {\n        x /= j;\n        cnt++;\n      }\n      primes.push_back(make_pair(j, cnt));\n    }\n  if (x > 1) primes.push_back(make_pair(x, 1));\n  int sz = primes.size();\n  vector <long long> power, rem;\n  for (int i=0;i<sz;i++) {\n    power.push_back(1);\n    int cnt = primes[i].second;\n    for (int j=0;j<cnt;j++) power[i] *= primes[i].first;\n    for (int j=0;j<k;j++)\n      if (a[j] % power[i] == 0) {\n        long long z = (-j) % power[i];\n        if (z < 0) z += power[i];\n        rem.push_back(z);\n        break;\n      }\n  }\n  long long num = 0, den = 1;\n  for (int i=0;i<sz;i++) {\n    update(num, den, rem[i], power[i]);\n  }\n  if (num == 0) num += den;\n  if (num + k - 1 > m) puts(\"NO\"); else {\n    for (int i=0;i<k;i++)\n      if (gcd(lcm, num + i) != a[i]) {\n        puts(\"NO\");\n        return 0;\n      }\n    puts(\"YES\");\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "chinese remainder theorem",
        "math",
        "number theory"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. GCD Table.json",
    "editorial_link": "https://codeforces.com//blog/entry/8629",
    "editorial": "Observation 1. If the sequence a occurs in table G, then it should occur\r\nin row i = LCM(a[1], ..., a[k]). The proof follows. It is clear that\r\ntheoretically it may only occur in rows with numbers which are multiple\r\nto i, since the row number should divide by each of a[index]. Consider\r\nsome a row with number i*x, where x>1. The rows i and i*x differ only in\r\nsuch elements j that i*x and j both divide by some p^q (where p is\r\nprime) which does not divide i (hence, G(i*x, j) is divisible by p^q).\r\nBut none of the a[index] may divide by such p^q, since then i would be\r\nalso divisible by it. Therefore, if a occurs in row i*x, then it does\r\nnot intersect with index j. Since it can only reside on indices where i\r\nand i*x coincide, checking only the i-th row is enough. It also clear\r\nthat if i > n, the answer is NO. Observation 2. The sought index j\r\nshould satisfy the following modular linear equations system: In other\r\nwords, j + l must divide by a[l+1] for each l=0..k-1. According to\r\nChinese Remainder Theorem, such a system has a solution iff for each\r\npair of indices x, y (0 <= x, y <= k-1) we have -x = -y (mod GCD(a[x+1],\r\na[y+1])). Letâs denote L = LCM(a[1], ..., a[k]). If the system has a\r\nsolution, then it is singular on interval [0, L) and all the other\r\nsolutions are congruent to it modulo L. Suppose that we have found the\r\nminimum non-negative j which satisfies the given system. Then, if a\r\noccurs in G, it will start from the j-th element of the i-th row.\r\nTheoretically, it may begin at any index of form j+x*L, x>=0, but since\r\ni = L, we have G(i, j+X*L) = GCD(i, j+X*i) = GCD(i, j). So it is\r\nsufficient to check whether the k consecutive elements which begin at\r\nindex j in row i coincide with sequence a. It is also clear that when\r\nj > m-k+1, the answer is NO. Finally, letâs consider how to solve a\r\nsystem of modular linear equations. We can use an auxiliary method\r\nwhich, given r1, m1, r2, m2, finds minimum X such that X = r1 (mod m1)\r\nand X = r2 (mod m2), or determines that such number does not exist. Let\r\nX = m1*x + r1, then we have m1*x + r1 = r2 (mod m2). This can be\r\nrepresented as a Diophantine equation m1*x + m2*y = r2-r1 and solved\r\nusing Extended Euclidean Algorithm. The least non-negative x, if it\r\nexists, yields the sought X = m1*x + r1. Now this method can be used to\r\nfind the minimum X1 which satisfies the first two equations. After that,\r\nwe can say that we have a system with k-1 equation, where the first two\r\nold equations are replaced with a new j = X1 (mod LCM(a[1], a[2])), and\r\nrepeat the same procedure again. After using this method k-1 times, we\r\nobtain the solution to the whole system. Also note that the proposed\r\nsolution does not require long arithmetics: The computation of LCM(a[1],\r\n..., a[k]) can be implemented with a check before each multiplication:\r\nif the result will become larger than n, the answer is NO; When it comes\r\nto solving the system of equations, we already know that L <= n <=\r\n10^12, thus all the intermediate moduli will also obide to this\r\nconstraint; The Extended Euclidean Algorithm can find a solution in the\r\nsame bounds as its inputs, so it will also use numbers up to 10^12. The\r\noverall complexity of the algorithm is O(k logn).\r\n",
    "hint": []
}