{"link": "https://codeforces.com//contest/338/problem/D", "problemId": "3399", "problem_idx": "D", "shortId": "338D", "contest_number": "338", "problem_submissions": {"D": [4295147, 4299466, 4295982, 4299910, 4297907, 4322675, 4322635, 4296295, 4300603, 4303747], "C": [4293877, 4292949, 4296119, 4290785, 4294450, 4290995, 4292819, 4294306, 4289507, 4319214, 4292496, 4292285, 4293888, 4293909, 4292095, 4292420], "A": [4292482, 4289057, 4289014, 4297071, 4289608, 4292907, 4298719, 4290998, 4292048, 4294562, 4288621, 4289027, 4288252, 4289309], "E": [4291715, 4297382, 4294190, 4295220, 4296654, 4297161, 4295153, 4304466, 4296200, 4296272, 4296355, 4296995, 4392972, 4307055], "B": [4289897, 4290803, 4292502, 4296197, 4291687, 4294720, 4290858, 4290695, 4291375, 4290406, 4289563, 4290575, 4290335, 4290751, 4293818, 4293496]}, "name": "D. GCD Table", "statement": "Consider a table of size such that for all . is the greatest common\r\ndivisor of numbers and .You have a sequence of positive integer numbers\r\n. We say that this sequence occurs in table if it coincides with\r\nconsecutive elements in some row, starting from some position. More\r\nformally, such numbers and should exist that for all .Determine if the\r\nsequence occurs in table .\r\n", "solutions": ["#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nlong long a[424242];\n\nlong long gcd(long long a, long long b) {\n  while (a > 0 && b > 0)\n    if (a > b) a %= b;\n    else b %= a;\n  return a + b;\n}\n\nvoid update(long long &a, long long &b, long long c, long long d) {\n  if (b < d) {\n    long long tmp;\n    tmp = a; a = c; c = tmp;\n    tmp = b; b = d; d = tmp;\n  }\n  while (a % d != c) a += b;\n  b *= d;\n}\n\nint main() {\n  long long n, m;\n  int k;\n  cin >> n >> m >> k;\n  for (int i=0;i<k;i++) {\n    a[i] = 0;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') ch = getchar();\n    while (ch >= '0' && ch <= '9') {\n      a[i] = a[i] * 10 + ch - 48;\n      ch = getchar();\n    }\n  }\n  long long lcm = 1;\n  for (int i=0;i<k;i++) {\n    long long g = gcd(lcm, a[i]);\n    lcm /= g;\n    if (1.0 * lcm * a[i] > 1e15) {\n      puts(\"NO\");\n      return 0;\n    }\n    lcm *= a[i];\n  }\n  if (lcm > n) {\n    puts(\"NO\");\n    return 0;\n  }\n  long long x = lcm;\n  vector < pair <long long, int> > primes;\n  for (long long j = 2; j * j <= x; j++)\n    if (x % j == 0) {\n      int cnt = 0;\n      while (x % j == 0) {\n        x /= j;\n        cnt++;\n      }\n      primes.push_back(make_pair(j, cnt));\n    }\n  if (x > 1) primes.push_back(make_pair(x, 1));\n  int sz = primes.size();\n  vector <long long> power, rem;\n  for (int i=0;i<sz;i++) {\n    power.push_back(1);\n    int cnt = primes[i].second;\n    for (int j=0;j<cnt;j++) power[i] *= primes[i].first;\n    for (int j=0;j<k;j++)\n      if (a[j] % power[i] == 0) {\n        long long z = (-j) % power[i];\n        if (z < 0) z += power[i];\n        rem.push_back(z);\n        break;\n      }\n  }\n  long long num = 0, den = 1;\n  for (int i=0;i<sz;i++) {\n    update(num, den, rem[i], power[i]);\n  }\n  if (num == 0) num += den;\n  if (num + k - 1 > m) puts(\"NO\"); else {\n    for (int i=0;i<k;i++)\n      if (gcd(lcm, num + i) != a[i]) {\n        puts(\"NO\");\n        return 0;\n      }\n    puts(\"YES\");\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["chinese remainder theorem", "math", "number theory"], "dificulty": "2900", "interactive": false}