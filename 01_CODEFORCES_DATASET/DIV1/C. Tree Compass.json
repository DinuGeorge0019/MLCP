{
    "link": "https://codeforces.com//contest/1943/problem/C",
    "problemId": "2535041",
    "problem_idx": "C",
    "shortId": "1943C",
    "contest_number": "1943",
    "problem_submissions": {
        "E2": [
            251755986,
            251774166,
            251721110,
            251772938,
            251976046,
            251850394,
            251783692,
            252482559,
            251768795,
            251806219,
            251801786,
            251784602,
            251808955,
            251786442,
            251790915,
            251791945,
            252167133,
            254017076,
            252396752,
            251948632
        ],
        "E1": [
            251743400,
            251761808,
            251720570,
            251764606,
            251765135,
            251768616,
            251774247,
            251768081,
            251767041,
            251779764,
            251763055,
            251770682,
            251776382,
            251772657,
            253458372,
            251772270,
            251777192,
            251779122,
            251781255
        ],
        "D2": [
            251730537,
            251743841,
            251769783,
            251827860,
            251827638,
            251812685,
            251750876,
            251749250,
            251743677,
            251754133,
            251758370,
            251752785,
            251846892,
            251763163,
            251753145,
            251743858,
            251746564,
            251754334,
            251790796,
            253458316,
            251757628,
            251757687,
            251759092,
            251761488
        ],
        "D1": [
            251727886,
            251730644,
            251753185,
            251730641,
            251733326,
            251727921,
            251742335,
            251739558,
            251743910,
            251737861,
            251737457,
            251736749,
            251746112,
            251745451,
            251785836,
            252959932,
            251749532,
            251743349,
            251754372,
            251751101
        ],
        "C": [
            251715534,
            251721073,
            251747865,
            251720444,
            251722988,
            251756982,
            251730923,
            251730217,
            251735041,
            251727939,
            251724586,
            251722879,
            251721249,
            251735499,
            251732028,
            252959913,
            251731321,
            251736408,
            251741233,
            251741283
        ],
        "B": [
            251709195,
            251712754,
            251737904,
            251712353,
            251714193,
            252482757,
            251715199,
            251720530,
            251721280,
            251721320,
            251719084,
            251718139,
            251714047,
            251713923,
            251720644,
            251719922,
            252531274,
            251717454,
            251716526,
            251722194,
            252064777,
            251726935
        ],
        "A": [
            251701793,
            251702717,
            251723885,
            251701730,
            251702780,
            251702880,
            251702623,
            251701902,
            251707932,
            251702391,
            251707705,
            251702309,
            251701731,
            251703701,
            251706521,
            252531268,
            251732626,
            251703091,
            251704741,
            251703882
        ],
        "F": [
            251801182,
            252436931,
            251845260,
            251783880
        ]
    },
    "name": "C. Tree Compass",
    "statement": "You are given a tree with n vertices numbered 1, 2,\r\nldots, n. Initially, all vertices are colored white.You can perform the\r\nfollowing two-step operation: Choose a vertex v (1\r\nleq v\r\nleq n) and a distance d (0\r\nleq d\r\nleq n-1). For all vertices u (1\r\nleq u\r\nleq n) such that\r\ntext{dist}^\r\ndagger(u,v)=d, color u black. Construct a sequence of operations to\r\ncolor all the nodes in the tree black using the minimum possible number\r\nof operations. It can be proven that it is always possible to do so\r\nusing at most n operations.^\r\ndagger\r\ntext{dist}(x, y) denotes the number of edges on the (unique) simple path\r\nbetween vertices x and y on the tree.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.03.2024 10:47:30\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass forest : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  forest(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    assert(id < n - 1);\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nclass dfs_forest : public forest<T> {\n public:\n  using forest<T>::edges;\n  using forest<T>::g;\n  using forest<T>::n;\n\n  vector<int> pv;\n  vector<int> pe;\n  vector<int> order;\n  vector<int> pos;\n  vector<int> end;\n  vector<int> sz;\n  vector<int> root;\n  vector<int> depth;\n  vector<T> dist;\n\n  dfs_forest(int _n) : forest<T>(_n) {\n  }\n\n  void init() {\n    pv = vector<int>(n, -1);\n    pe = vector<int>(n, -1);\n    order.clear();\n    pos = vector<int>(n, -1);\n    end = vector<int>(n, -1);\n    sz = vector<int>(n, 0);\n    root = vector<int>(n, -1);\n    depth = vector<int>(n, -1);\n    dist = vector<T>(n);\n  }\n\n  void clear() {\n    pv.clear();\n    pe.clear();\n    order.clear();\n    pos.clear();\n    end.clear();\n    sz.clear();\n    root.clear();\n    depth.clear();\n    dist.clear();\n  }\n\n private:\n  void do_dfs(int v) {\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    sz[v] = 1;\n    for (int id : g[v]) {\n      if (id == pe[v]) {\n        continue;\n      }\n      auto &e = edges[id];\n      int to = e.from ^ e.to ^ v;\n      depth[to] = depth[v] + 1;\n      dist[to] = dist[v] + e.cost;\n      pv[to] = v;\n      pe[to] = id;\n      root[to] = (root[v] != -1 ? root[v] : to);\n      do_dfs(to);\n      sz[v] += sz[to];\n    }\n    end[v] = (int) order.size() - 1;\n  }\n\n  void do_dfs_from(int v) {\n    depth[v] = 0;\n    dist[v] = T{};\n    root[v] = v;\n    pv[v] = pe[v] = -1;\n    do_dfs(v);\n  }\n\n public:\n  void dfs(int v, bool clear_order = true) {\n    if (pv.empty()) {\n      init();\n    } else {\n      if (clear_order) {\n        order.clear();\n      }\n    }\n    do_dfs_from(v);\n  }\n\n  void dfs_all() {\n    init();\n    for (int v = 0; v < n; v++) {\n      if (depth[v] == -1) {\n        do_dfs_from(v);\n      }\n    }\n    assert((int) order.size() == n);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    dfs_forest<int> g(n);\n    for (int i = 0; i < n - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g.add(x, y);\n    }\n    g.dfs(0);\n    int st = int(max_element(g.depth.begin(), g.depth.end()) - g.depth.begin());\n    g.dfs(st);\n    int fin = int(max_element(g.depth.begin(), g.depth.end()) - g.depth.begin());\n    vector<int> diam(1, fin);\n    while (diam.back() != st) {\n      diam.push_back(g.pv[diam.back()]);\n    }\n    int sz = int(diam.size());\n    vector<pair<int, int>> ops;\n    for (int par = 0; par < 2; par++) {\n      if (sz == 1 && par == 1) {\n        continue;\n      }\n      int l = 0, r = sz - 1;\n      while (l % 2 != par) {\n        l += 1;\n      }\n      while (r % 2 != par) {\n        r -= 1;\n      }\n      while (l <= r) {\n        ops.emplace_back(diam[(l + r) / 2], (r - l) / 2);\n        l += 2;\n        r -= 2;\n      }\n    }\n    cout << ops.size() << '\\n';\n    for (auto& p : ops) {\n      cout << p.first + 1 << \" \" << p.second << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Tree Compass.json",
    "editorial_link": "https://codeforces.com//blog/entry/127195",
    "editorial": "Solution For a line, an obvious bound on the answer is , as we can colour\natmost nodes per operation. I claim this is achieveable except for when\nmod , where we do worse. That is however still provably optimal as you\ncan bicolour the line and operations only colours nodes black which are\nin the same bicolouring. Construction for lineWhen mod , simply use the\ncentre of the line and do operations of the form ().When mod , for\nconvenience let the line be . Then, we can do operations like .When mod\n, either of the above methods can be adapted to work because we are\nallowed \"extra\" operation.Now that we have the solution for the line\ncase, lets divide into cases based on parity of diamater (maximum number\nof nodes on a path) : diameter mod : Find the centre of the diamater.\nThen we can simply do operations of the form (for all ). If this doesnât\ncolour all nodes, then one can easily check that the diamater we found\nis not the real diamater, as the node which is not coloured is an\nendpoint of a larger diameter.diamater mod : Find the centres of the\ndiameter. Then the following set of operations satisfy the requirements\n: and for all odd satisfying . The intuition behind this is to basically\nsplit the nodes into sets according to a bicolouring, and then centre\ncolours all nodes of a certain colour, while the other centre colours\nall nodes of the other colour.\n",
    "hint": [
        "Hint 1 Try to solve for line case.",
        "Hint 2 You may have to use more than node for certain cases.",
        "Hint 3 Extend the solution for the line to the general tree version (consider the diamater)."
    ]
}