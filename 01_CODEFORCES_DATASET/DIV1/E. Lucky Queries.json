{
    "link": "https://codeforces.com//contest/145/problem/E",
    "problemId": "839",
    "problem_idx": "E",
    "shortId": "145E",
    "contest_number": "145",
    "problem_submissions": {
        "E": [
            1105208,
            1105912,
            1104894,
            1102760,
            1106240,
            1105850,
            1107323,
            1106178,
            1106652,
            1107141,
            1106053,
            1106917,
            1110162,
            1106271,
            1108116,
            1106093,
            1106858,
            1105628,
            1106422
        ],
        "C": [
            1103754,
            1105077,
            1104008,
            1104728,
            1104390,
            1104502,
            1105076,
            1107490,
            1105685,
            1104716,
            1104727,
            1105594,
            1110098,
            1102678,
            1104471,
            1104980,
            1102716,
            1106604,
            1105209
        ],
        "B": [
            1102413,
            1103328,
            1106135,
            1106485,
            1102911,
            1103531,
            1103090,
            1103085,
            1103776,
            1103710,
            1107536,
            1102801,
            1110016,
            1106756,
            1108339
        ],
        "A": [
            1101171,
            1101193,
            1101307,
            1101588,
            1101358,
            1101247,
            1101150,
            1101748,
            1101315,
            1101364,
            1101363,
            1110038,
            1103077,
            1101351,
            1101685,
            1101209,
            1101163,
            1101232
        ],
        "D": [
            1131693,
            1131692,
            1124995,
            107142023,
            107141858,
            107141498,
            107140808,
            107137178
        ]
    },
    "name": "E. Lucky Queries",
    "statement": "Petya brought home string with the length of . The string only consists\r\nof lucky digits. The digits are numbered from the left to the right\r\nstarting with . Now Petya should execute queries of the following form:\r\n\"switch\" digits (i.e. replace them with their opposites) at all\r\npositions with indexes from to , inclusive: each digit is replaced with\r\nand each digit is replaced with ; find and print on the screen the\r\nlength of the longest non-decreasing subsequence of string . Subsequence\r\nof a string is a string that can be obtained from by removing zero or\r\nmore of its elements. A string is called non-decreasing if each\r\nsuccessive digit is not less than the previous one.Help Petya process\r\nthe requests.\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define REP(i,n) for (int i=0,_n=(n); i < _n; i++)\n#define REPD(i,n) for (int i=(n)-1; i >= 0; i--)\n#define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n\n#define CLEAR(x) memset(x,0,sizeof x);\n#define CLEARA(x) memset(&x,0,sizeof x);\n#define FILL(x,v) memset(x,v,sizeof x);\n#define FILLA(x,v) memset(&x,v,sizeof x);\n\n#define VAR(a,b) __typeof(b) a=(b)\n#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)\n\n#define REVERSE(c) reverse(ALL(c))\n#define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())\n#define INF 0x7fffffff\n#define X first\n#define Y second\n#define pb push_back\n#define SZ(c) (int)(c).size()\n#define MP make_pair\n#define eps 1.0e-11\nconst double pi = acos(-1.0);\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long LL;\n\nint n,m;\ntypedef struct {\n\tint n4,n7,n47,n74;\n\tint delayed;\n} T;\n\nint init[1024000];\nconst int LIMIT = (1<<21);\nT a[LIMIT];\n\ninline void change(int v)\n{\n\tswap(a[v].n4,a[v].n7);\n\tswap(a[v].n47,a[v].n74);\n\ta[v].delayed ^= 1;\n}\n\ninline void down(int v)\n{\n\tif (!a[v].delayed) return;\n\ta[v].delayed = 0;\n\tif (v*2 < LIMIT) change(v*2);\n\tif (v*2+1 < LIMIT) change(v*2+1);\n}\n\ninline void up(int v)\n{\n\tdown(v);\n\ta[v].n4 = a[v*2].n4 + a[v*2+1].n4;\n\ta[v].n7 = a[v*2].n7 + a[v*2+1].n7;\n\ta[v].n47 = max(a[v*2].n47 + a[v*2+1].n7, a[v*2].n4 + a[v*2+1].n47);\n\ta[v].n74 = max(a[v*2].n74 + a[v*2+1].n4, a[v*2].n7 + a[v*2+1].n74);\n}\n\nvoid build(int v, int l, int r)\n{\n\tif (l==r)\n\t{\n\t\tif (init[l]==4)\n\t\t\ta[v].n4 = 1;\n\t\telse\n\t\t\ta[v].n7 = 1;\n\t\ta[v].n47 = a[v].n74 = 1;\n\t}\n\telse\n\t{\n\t\tint mid = (l+r)/2;\n\t\tbuild(v*2,l,mid);\n\t\tbuild(v*2+1,mid+1,r);\n\t\tup(v);\n\t}\n}\n\nint cl,cr;\n\nvoid go(int v, int l, int r)\n{\n\tif (r < cl || cr < l) return;\n\tif (cl <= l && r <= cr)\n\t{\n\t\tchange(v);\n\t\treturn;\n\t}\n\tint mid = (l+r)/2;\n\tdown(v);\n\tgo(v*2,l,mid);\n\tgo(v*2+1,mid+1,r);\n\tup(v);\n}\n\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\tCLEAR(a);\n\tREP(i,n)\n\t{\n\t\tchar c;\n\t\tdo c = getc(stdin);\n\t\twhile (c!='4'&&c!='7');\n\t\tinit[i]=c-'0';\n\t}\n\n\t//REP(i,n) init[i]=i%2 ? 4 : 7;\n\n\tbuild(1,0,n-1);\n\tREP(i,m)\n\t{\n\t\tchar cmd[256];\n\t\tscanf(\"%s\",cmd);\n\t\t//if (i%2 == 0) strcpy(cmd,\"count\"); else cmd[0]=0;\n\t\tif (strcmp(cmd,\"count\")==0)\n\t\t\tprintf(\"%d\\n\",a[1].n47);\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d%d\",&cl,&cr);\n\t\t\t//cl = rand()%n+1; cr = rand()%n+1; if (cl>cr) swap(cl,cr);\n\t\t\t--cl,--cr;\n\t\t\tgo(1,0,n-1);\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Lucky Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/3746",
    "editorial": "To solve this problem you need to handle segment tree with following information:\n\nn4: number of 4-digits in node range.\nn7: number of 7-digits in node range.\nn47: maximum non-decreasing subsequence in range.\nn74: maximum non-increasing subsequence in range.\n\nWhen we reverse digits in some node we just swap(n4, n7), swap(n47, n74). When we update node we keep n4(father) = n4(left_son) + n4(right_son), n47(father) = max(n47(left_son) + n7(right_son), n4(left_son) + n47(right_son), n4(left_son) + n7(right_son)). Then for each count query result is n47.",
    "hint": []
}