{
    "link": "https://codeforces.com//contest/1824/problem/D",
    "problemId": "1909041",
    "problem_idx": "D",
    "shortId": "1824D",
    "contest_number": "1824",
    "problem_submissions": {
        "E": [
            205128571,
            205139739,
            205144104,
            205137280,
            205130495,
            205118718,
            205194940,
            205235861,
            205235298,
            205232550,
            205700234,
            205699976
        ],
        "D": [
            205099783,
            205099421,
            205104253,
            205142283,
            205135430,
            205107363,
            205103358,
            205109375,
            205130576,
            205106777,
            205111380,
            205108131,
            205113889,
            205109692,
            205110237,
            205111676,
            205111818,
            205116723,
            205113358,
            205116564,
            205115264,
            205122150
        ],
        "C": [
            205092605,
            205093858,
            205095306,
            205093905,
            205096370,
            205095737,
            205137755,
            205100625,
            205100857,
            205099284,
            205101290,
            205097496,
            205098177,
            205101207,
            205099752,
            205104989,
            205095505,
            205095555,
            205103206,
            205102161,
            205098628
        ],
        "B2": [
            205086508,
            205087676,
            205086929,
            205087663,
            205088713,
            205084760,
            205087488,
            205094809,
            205089113,
            205089568,
            205090318,
            205089714,
            205087793,
            205096844,
            205101610,
            205090439,
            205094629,
            205091373,
            205087601
        ],
        "B1": [
            205086422,
            205087787,
            205086792,
            205087589,
            205088569,
            205084970,
            205085855,
            205089877,
            205088994,
            205089640,
            205089081,
            205087696,
            205087867,
            205095794,
            205087977,
            205088492,
            205094450,
            205090371,
            205087429
        ],
        "A": [
            205083763,
            205085457,
            205082241,
            205082782,
            205083768,
            205088956,
            205081132,
            205083777,
            205081787,
            205082991,
            205086125,
            205082070,
            205083612,
            205083399,
            205081591,
            205083847,
            205088554,
            205081833,
            205083848
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/116328",
    "editorial": "Call a node special if there is a person in it.\n\nWhen k\n is odd, we find that there is only one node satisfying the conditions.\n\nProof.\n Assume distinct node x\n and node y\n are good nodes. Let x\n be the root of the tree. Define si\n as the number of special nodes in subtree i\n. Think about the process we move from x\n to y\n. If we try to move the chosen node from its father to i\n, the variation of cost is k?2si\n. When move from x\n to its son i\n which si\n is maximal, k?2si?0\n is held (Otherwise, x\n isn't a good node). And we can get k?2si>0\n further because k\n is odd and 2si\n is even. Since min1?j?nk?2sj=k?2si\n, we find k?2sj>0\n for all j\n. So y\n can't be good node.\n\nThen think about the situation that k\n is even. Choose a node as root arbitrarily. With the same method, we find that good nodes satisfy 2si=k\n. It's also sufficient. Define pi\n as the possibility that si=k2\n, then the answer is 1+?ni=1pi\n.\n\nDefine Si\n as the size of subtree i\n. When si=k2\n, there are k2\n special nodes in subtree i\n and k2\n in the other part. The number of ways to place special nodes is (nk)\n, and (Sik2)(n?Sik2)\n of them satisfying the condition. So pi=(Sik2)(n?Sik2)(nk)\n.",
    "name": "D. LuoTianyi and the Function",
    "statement": "LuoTianyi gives you an array a of n integers and the index begins from\r\n1.Define g(i,j) as follows: g(i,j) is the largest integer x that\r\nsatisfies\r\n{a_p:i\r\nle p\r\nle j\r\n}\r\nsubseteq\r\n{a_q:x\r\nle q\r\nle j\r\n} while i\r\nle j; and g(i,j)=0 while i>j. There are q queries. For each query you\r\nare given four integers l,r,x,y, you need to calculate\r\nsum\r\nlimits_{i=l}^{r}\r\nsum\r\nlimits_{j=x}^{y}g(i,j).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;template<class Info, class Tag>struct LazySegmentTree {    int n;    std::vector<Info> info;    std::vector<Tag> tag;    LazySegmentTree() : n(0) {}    LazySegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template<class T>    LazySegmentTree(std::vector<T> init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template<class T>    void init(std::vector<T> init_) {        n = init_.size();        info.assign(4 << std::__lg(n), Info());        tag.assign(4 << std::__lg(n), Tag());        std::function<void(int, int, int)> build = [&](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void apply(int p, const Tag &v) {        info[p].apply(v);        tag[p].apply(v);    }    void push(int p) {        apply(2 * p, tag[p]);        apply(2 * p + 1, tag[p]);        tag[p] = Tag();    }    void modify(int p, int l, int r, int x, const Info &v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        push(p);        if (x < m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l >= y || r <= x) {            return Info();        }        if (l >= x && r <= y) {            return info[p];        }        int m = (l + r) / 2;        push(p);        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {        if (l >= y || r <= x) {            return;        }        if (l >= x && r <= y) {            apply(p, v);            return;        }        int m = (l + r) / 2;        push(p);        rangeApply(2 * p, l, m, x, y, v);        rangeApply(2 * p + 1, m, r, x, y, v);        pull(p);    }    void rangeApply(int l, int r, const Tag &v) {        return rangeApply(1, 0, n, l, r, v);    }    template<class F>    int findFirst(int p, int l, int r, int x, int y, F pred) {        if (l >= y || r <= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        push(p);        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template<class F>    int findFirst(int l, int r, F pred) {        return findFirst(1, 0, n, l, r, pred);    }    template<class F>    int findLast(int p, int l, int r, int x, int y, F pred) {        if (l >= y || r <= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        push(p);        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template<class F>    int findLast(int l, int r, F pred) {        return findLast(1, 0, n, l, r, pred);    }};\u00a0struct Tag {    i64 a = 0;    i64 al = 0;    int x = -1;    void apply(Tag t) {        if (x == -1) {            a += t.a;        } else {            al += t.a * x;        }        al += t.al;        if (t.x != -1) {            x = t.x;        }    }};\u00a0struct Info {    int len = 0;    i64 sum = 0;    i64 hsum = 0;        void apply(Tag t) {        hsum += sum * t.a;        hsum += len * t.al;        if (t.x != -1) {            sum = 1LL * t.x * len;        }    }};\u00a0Info operator+(Info a, Info b) {    Info c;    c.len = a.len + b.len;    c.sum = a.sum + b.sum;    c.hsum = a.hsum + b.hsum;    return c;}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n, q;    std::cin >> n >> q;        std::vector<int> lst(n, -1), prev(n);    std::vector<int> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];        a[i]--;    }        for (int i = 0; i < n; i++) {        prev[i] = lst[a[i]];        lst[a[i]] = i;    }        std::vector<i64> ans(q);    std::vector<std::vector<std::tuple<int, int, int, int>>> qry(n);        for (int i = 0; i < q; i++) {        int l, r, x, y;        std::cin >> l >> r >> x >> y;        l--, x--;        qry[x].emplace_back(l, r, i, 1);        if (y < n) {            qry[y].emplace_back(l, r, i, -1);        }    }        LazySegmentTree<Info, Tag> seg(n, Info{1, 0, 0});    std::set<int> s{-1};        auto add = [&](int x) {        auto it = s.insert(x).first;        seg.rangeApply(*std::prev(it) + 1, x + 1, {0, 0, x + 1});    };        for (int i = 0; i < n; i++) {        if (lst[i] != -1) {            add(lst[i]);        }    }    for (int i = n - 1; i >= 0; i--) {        seg.rangeApply(0, n, {1, 0, -1});        for (auto [l, r, k, t] : qry[i]) {            ans[k] += t * seg.rangeQuery(l, r).hsum;        }        if (prev[i] != -1) {            add(prev[i]);        }        seg.rangeApply(i, i + 1, {0, 0, 0});    }        for (int i = 0; i < q; i++) {        std::cout << ans[i] << \"\\n\";    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. LuoTianyi and the Function.json"
}