{"link": "https://codeforces.com//contest/1218/problem/C", "problemId": "412335", "problem_idx": "C", "shortId": "1218C", "contest_number": "1218", "problem_submissions": {"D": [60648151, 60643203, 60647260, 60645392, 60642748], "H": [60644806, 60638524], "E": [60642127, 60641056, 60641513, 60643564, 60648498], "I": [60640334, 60639607, 60640474, 60637390, 60638678], "F": [60638215, 60637531, 60635942, 60636552, 60636479], "C": [60637983, 60674902, 60648025], "B": [60648802], "A": [60645770]}, "name": "C. Jumping Transformers", "statement": "You, the mighty Blackout, are standing in the upper-left (0,0) corner of\r\nNxM matrix. You must move either right or down each second. There are K\r\ntransformers jumping around the matrix in the following way. Each\r\ntransformer starts jumping from position (x,y), at time t, and jumps to\r\nthe next position each second. The x-axes grows downwards, and y-axes\r\ngrows to the right. The order of jumping positions is defined as\r\n{(x,y),(x+d,y-d),(x+d,y),(x,y+d)}, and is periodic. Before time t\r\ntransformer is not in the matrix.You want to arrive to the bottom-right\r\ncorner (N-1,M-1), while slaying transformers and losing the least\r\npossible amount of energy. When you meet the transformer (or more of\r\nthem) in the matrix field, you must kill them all, and you lose the sum\r\nof the energy amounts required to kill each transformer.After the\r\ntransformer is killed, he of course stops jumping, falls into the abyss\r\nand leaves the matrix world. Output minimum possible amount of energy\r\nwasted.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n#define x first\n#define y second\n\nconst int N = 505;\nconst ll INF = ll(1e18);\n\nint n, m, k;\nll d[N][N][2], a[N][N], hs[N], vs[N];\nvector<pii> va[N][N], vt[N];\nvector<pair<pii, int>> ht[N];\n\nint f(int x, int y, int t){\n    return (x + y >= t) && ((x + y - t) % 4 == 0);\n}\n\nint main(){ ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 0; i < k; i++){\n        int x, y, d, t, v;\n        cin >> x >> y >> d >> t >> v;\n        int ul = f(x, y, t);\n        int ur = f(x, y + d, t + 3);\n        int dl = f(x + d, y - d, t + 1);\n        int dr = f(x + d, y, t + 2);\n        if(ul) a[x][y] += v;\n        if(ur) a[x][y + d] += v;\n        if(dl) a[x + d][y - d] += v;\n        if(dr) a[x + d][y] += v;\n        if(ul && ur){\n            vt[x].emplace_back(y + d, v);\n            va[x][y].emplace_back(y + d, v);\n        }\n        if(ul && dr){\n            a[x + d][y] -= v;\n            ht[x].emplace_back(pii(x + d, y), v);\n        }\n        if(dl && dr){\n            vt[x + d].emplace_back(y, v);\n            va[x + d][y - d].emplace_back(y, v);\n        }\n    }\n    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++)\n        if(i + j) d[i][j][0] = d[i][j][1] = INF;\n    for(int i = 0; i < n; i++){\n        for(pii &t : vt[i]) a[i][t.x] -= t.y;\n        for(int j = 0; j < m; j++){\n            ll cs = 0;\n            for(int t = i + 1; t < n; t++){\n                cs += a[t][j];\n                d[t][j][0] = min(d[t][j][0], d[i][j][1] + cs);\n            }\n            cs = 0;\n            for(int t = j + 1; t < m; t++){\n                cs += a[i][t];\n                d[i][t][1] = min(d[i][t][1], d[i][j][0] + cs);\n            }\n            for(pii &t : va[i][j]) a[i][t.x] += t.y;\n        }\n        for(auto &t : ht[i]) a[t.x.x][t.x.y] += t.y;\n    }\n    cout << min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]) << '\\n';\n}"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2600", "interactive": false}