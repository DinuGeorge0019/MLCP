{
    "link": "https://codeforces.com//contest/1322/problem/E",
    "problemId": "555657",
    "problem_idx": "E",
    "shortId": "1322E",
    "contest_number": "1322",
    "problem_submissions": {
        "E": [
            72651847,
            72667619,
            72663863,
            81989702,
            73455963,
            72654927,
            72662345,
            72661386,
            72662000,
            72646344
        ],
        "D": [
            72644625,
            72640728,
            72645597,
            72646886,
            72650508,
            72648101,
            72647799,
            73117806,
            72646593,
            73115826,
            72647714,
            72648983,
            72649173,
            72652083,
            72650733,
            72645310,
            72649530,
            72653676,
            72654635,
            72652516
        ],
        "C": [
            72636777,
            72636963,
            72637518,
            72639394,
            72637388,
            72638096,
            72639734,
            73117801,
            72640343,
            72640613,
            72638032,
            72638943,
            72642117,
            72644813,
            72641527,
            72650551,
            72650396,
            72639973,
            72642914,
            72642962,
            72643894
        ],
        "B": [
            72630406,
            72634706,
            72633179,
            72634815,
            72634956,
            72641590,
            72633350,
            73117683,
            72635692,
            72635442,
            72633727,
            72635100,
            72639222,
            72636092,
            72637879,
            72655301,
            72636262,
            72636039,
            72637209,
            72638209,
            72636501
        ],
        "A": [
            72628149,
            72629253,
            72629705,
            72631540,
            72628375,
            72630668,
            72629135,
            73117511,
            72629708,
            72630674,
            72628794,
            72628291,
            72630330,
            72629133,
            72629728,
            72647587,
            72628383,
            72631203,
            72630004,
            72630007,
            72628407
        ],
        "F": [
            74191172,
            73465587,
            77378072,
            77728968
        ]
    },
    "name": "E. Median Mountain Range",
    "statement": "Berland is a huge country with diverse geography. One of the most famous\r\nnatural attractions of Berland is the \"Median mountain range\". This\r\nmountain range is n mountain peaks, located on one straight line and\r\nnumbered in order of 1 to n. The height of the i-th mountain top is a_i.\r\n\"Median mountain range\" is famous for the so called happening to it\r\nevery day. At the moment of alignment simultaneously for each mountain\r\nfrom 2 to n - 1 its height becomes equal to the median height among it\r\nand two neighboring mountains. Formally, if before the alignment the\r\nheights were equal b_i, then after the alignment new heights a_i are as\r\nfollows: a_1 = b_1, a_n = b_n and for all i from 2 to n - 1 a_i =\r\ntexttt{median}(b_{i-1}, b_i, b_{i+1}). The median of three integers is\r\nthe second largest number among them. For example,\r\ntexttt{median}(5,1,2) = 2, and\r\ntexttt{median}(4,2,4) = 4.Recently, Berland scientists have proved that\r\nwhatever are the current heights of the mountains, the alignment process\r\nwill stabilize sooner or later, i.e. at some point the altitude of the\r\nmountains won\u2019t changing after the alignment any more. The government of\r\nBerland wants to understand how soon it will happen, i.e. to find the\r\nvalue of c how many alignments will occur, which will change the height\r\nof at least one mountain. Also, the government of Berland needs to\r\ndetermine the heights of the mountains after c alignments, that is, find\r\nout what heights of the mountains stay forever. Help scientists solve\r\nthis important problem!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=500005;\nint n,a[N],b[N];\nvector<int> vec[N];\nset<pii> S;\n\nstruct node{\n\tint cl,cr,mx,vl,vr,v;\n\tnode(){}\n\tnode(int c){\n\t\tcl=cr=c;\n\t\tmx=vl=vr=v=1;\n\t}\n}t[N*4];\nnode operator +(node a,node b){\n\tnode ans;\n\tans.cl=a.cl; ans.cr=b.cr;\n\tans.mx=max(a.mx,b.mx);\n\tans.vl=a.vl; ans.vr=b.vr;\n\tans.v=a.v+b.v;\n\tif (a.cr^b.cl){\n\t\tans.mx=max(ans.mx,a.vr+b.vl);\n\t\tif (a.v==a.vl) ans.vl+=b.vl;\n\t\tif (b.v==b.vr) ans.vr+=a.vr;\n\t}\n\treturn ans;\n}\nvoid build(int k,int l,int r){\n\tif (l==r){\n\t\tt[k]=node(0);\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tbuild(k*2,l,mid);\n\tbuild(k*2+1,mid+1,r);\n\tt[k]=t[k*2]+t[k*2+1];\n}\nvoid change(int k,int l,int r,int p){\n\tif (l==r){\n\t\tt[k]=node(1);\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tif (p<=mid) change(k*2,l,mid,p);\n\telse change(k*2+1,mid+1,r,p);\n\tt[k]=t[k*2]+t[k*2+1];\n}\n\nstruct YYN{\n\tint t[N*4],nn;\n\tvoid build(int n){\n\t\tfor (nn=1;nn<=n;nn<<=1);\n\t\tFor(i,0,2*nn-1) t[i]=0;\n\t}\n\tvoid change(int x,int y,int v){\n\t\t//cout<<x<<' '<<y<<' '<<v<<endl;\n\t\tx+=nn-1; y+=nn+1;\n\t\tfor (;x^y^1;x>>=1,y>>=1){\n\t\t\tif (!(x&1)) t[x^1]=max(t[x^1],v);\n\t\t\tif (y&1) \tt[y^1]=max(t[y^1],v);\n\t\t}\n\t}\n\tvoid output(){\n\t\tFor(i,1,nn-1){\n\t\t\tt[i*2]=max(t[i*2],t[i]);\n\t\t\tt[i*2+1]=max(t[i*2+1],t[i]);\n\t\t}\n\t\tFor(i,1,n) printf(\"%d \",t[i+nn]);\n\t\tputs(\"\");\n\t}\n}RE;\nvoid flip(int x){\n\t//cout<<\"F \"<<x<<endl;\n\tassert(a[x]==0);\n\tif (x==1||a[x]==a[x-1]) S.erase(pii(x,a[x]));\n\tif (x==n||a[x]==a[x+1]) S.erase(pii(x+1,a[x]));\n\ta[x]^=1; change(1,1,n,x);\n\tif (x==1||a[x]==a[x-1]) S.insert(pii(x,a[x]));\n\tif (x==n||a[x]==a[x+1]) S.insert(pii(x+1,a[x]));\n}\n\nvoid updateee(int x,int v){\n\tauto it=S.lower_bound(pii(x,-1));\n\tauto pre=it,suf=it; pre--;\n\tif (pre->se==1&&suf->se==1) RE.change(pre->fi,suf->fi-1,v);\n\telse if (pre->se==1&&suf->se==0) RE.change(pre->fi,(pre->fi+suf->fi)/2-1,v);\n\telse if (pre->se==0&&suf->se==1) RE.change((pre->fi+suf->fi)/2,suf->fi-1,v);\n}\n/*\n110100\n*/\nvoid updatee(int x,int v){\n\tauto it=S.lower_bound(pii(x,-1));\n\tauto pre=it,suf=it;\n\t//cout<<it->fi<<' '<<it->se<<endl;\n\t//assert(it->se==1||it->fi==n+1);\n\tif (x!=1){\n\t\t--pre;\n\t\tif (pre->se==1) RE.change(pre->fi,it->fi-1,v);\n\t\telse RE.change((pre->fi+it->fi)/2,it->fi-1,v);\n\t}\n\tif (x!=n+1){\n\t\t++suf;\n\t\tif (suf->se==1) RE.change(it->fi,suf->fi-1,v);\n\t\telse RE.change(it->fi,(it->fi+suf->fi)/2-1,v);\n\t}\n}\nvoid update(int x,int v){\n\tif (x==1||a[x]==a[x-1]) updatee(x,v); else updateee(x,v);\n\tif (x==n||a[x]==a[x+1]) updatee(x+1,v); else updateee(x+1,v);\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) b[i]=a[i];\n\tsort(b+1,b+n+1);\n\t*b=unique(b+1,b+n+1)-b-1;\n\tFor(i,1,n){\n\t\ta[i]=lower_bound(b+1,b+*b+1,a[i])-b;\n\t\tvec[a[i]].PB(i);\n\t}\n\tmemset(a,0,sizeof(a));\n\tbuild(1,1,n);\n\tRE.build(n);\n\tFor(i,1,n+1) S.insert(pii(i,0));\n\tint ansT=0;\n\tRep(i,*b,1){\n\t\tfor (auto j:vec[i]) flip(j);\n\t\tfor (auto j:vec[i]) update(j,b[i]);\n\t\tansT=max(ansT,t[1].mx);\n\t\t//printf(\"%d\\n\",ansT);\n\t}\n\tprintf(\"%d\\n\",(ansT-1)/2);\n\tRE.output();\n}\n/*\n11010100 \n11101000\n11110000 \n\n1101010100 \n1110101000\n1111010000\n1111100000\n1111111111\n9->4\n8->3\n011\n\n110100\n\u79bb\u5176\u6700\u8fd1\u7684\u4e24\u4e2a\u76f8\u90bb\u6570\u5b57,\u82e5\u4e0d\u5b58\u5728\u4e3a0 \n\u76f8\u90bb\u4e24\u4e2a0\u7a33\u5b9a\n\u76f8\u90bb\u4e24\u4e2a1\u7a33\u5b9a \n*/ "
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Median Mountain Range.json",
    "editorial_link": "https://codeforces.com//blog/entry/74148",
    "editorial": "Let\u00e2\u0080\u0099s assume that . We can notice that if for some , than on -th and -th\r\npositions numbers will stay the same forever. So the only changes will\r\nhappen to segments of consecutive alternating and . Now let\u00e2\u0080\u0099s look what\r\nwill happen to such segments after first alignment of mountain peaks.\r\nThe beginning and end of segment will stay the same, and all\r\nintermediate number will change ( will change to and will change to ).\r\nSo the second number will be equal to first and pre last number will be\r\nequal to last. That means that lengths of all segments of consecutive\r\nalternating and will decrease by . So the number of alignments equals to\r\nlength of longest segment divided by , and for each segment its first\r\nhalf will be equal to beginning of segment, and its second half will be\r\nequal to the end of segment.Now let\u00e2\u0080\u0099s fix some number and create array ,\r\nwhere if and if . It can be observed, that if we will make alignment\r\nwith initial mountain heights and replace them with and the same way, we\r\nwill get array after first alignment. So if we will get array after\r\nstabilization, we will know that on positions where mountains will have\r\nheight less than , and on positions where the mountain heights after\r\nstabilization will be grater or equal than . So to get the number of\r\nalignments we will need to find the longest segment of consecutive\r\nalternating and for all possible .Now we need to get the final heights.\r\nLet\u00e2\u0080\u0099s assume that we know all positions where final heights will be\r\ngrater than . Let\u00e2\u0080\u0099s create array the same way as described above. Using\r\nthis array we can get positions where the mountain heights will be\r\ngrater or equal than after stabilization. As we know positions where the\r\nheights will be grater than , we can get positions where heights will be\r\nequal to . So if we will decrease from maximum value to , we can get the\r\nfinal heights of all mountains.To perform it quick enough, we can\r\nconsider only those , that equal to some of existing initial heights.\r\nThen we can decrease and in some set store all segments of consecutive\r\nalternating and in array for such . When the is decreased, on some\r\npositions can change to . The changes can happen only to the segments\r\nthat have such positions. (The segments can be splited by this position,\r\nor this position can be merged with neighbouring segment(s)) So in total\r\nthere will be changes to segments, and we can perform all of them in\r\ntime. Also we can store in set all positions, for which we do not know\r\nthe final heights, we for each new segment we can find positions where\r\nwill be in the end (it will be some segment of consecutive positions)\r\nand search free positions among them in the set. In total it will take\r\ntime.There also exists solution in time.\r\n"
}