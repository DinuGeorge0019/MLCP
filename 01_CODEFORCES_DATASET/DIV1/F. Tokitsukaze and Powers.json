{"link": "https://codeforces.com//contest/1190/problem/F", "problemId": "371228", "problem_idx": "F", "shortId": "1190F", "contest_number": "1190", "problem_submissions": {"F": [56941738, 56942014, 56928138, 56942516, 56950887, 58195417, 58195396], "E": [56917008, 56916854, 56935244, 57349641, 56979679, 56978421, 56932359, 56972779, 56934145, 56955262, 56955204, 56941608, 56941586, 56935542, 56933188, 57068903, 57330846, 57330794, 56942010], "D": [56905170, 56903117, 56915954, 56905847, 56909818, 56908766, 56917699, 56902041, 56905886, 56904524, 56906795, 56906965, 56900483, 56909139, 56909403, 56908905, 56906330, 56905643, 56915882, 56909382], "C": [56900650, 56922677, 56907961, 56915160, 56918774, 56933389, 56914144, 56911238, 56911841, 56914833, 56915809, 56917468, 56907600, 56903345, 56902197, 56904463, 56924310, 56918439, 56903054, 56913026], "B": [56894838, 56897380, 56899896, 56900500, 56902295, 56898363, 56894711, 56934531, 56896361, 56900397, 56898856, 56894889, 56895625, 56895683, 56897433, 56894846, 56898447, 56897871, 56896691, 56899788], "A": [56890891, 56891248, 56896475, 56892165, 56893900, 56891144, 56890604, 56893098, 56892007, 56891978, 56894387, 56896707, 56892771, 56890233, 56891624, 56891412, 56893655, 56892212, 56892634, 56891452]}, "name": "F. Tokitsukaze and Powers", "statement": "Tokitsukaze is playing a room escape game designed by SkywalkerT. In\r\nthis game, she needs to find out hidden clues in the room to reveal a\r\nway to escape.After a while, she realizes that the only way to run away\r\nis to open the digital door lock since she accidentally went into a\r\nsecret compartment and found some clues, which can be interpreted as:\r\nOnly when you enter n possible different passwords can you open the\r\ndoor; Passwords must be integers ranged from 0 to (m - 1); A password\r\ncannot be x (0\r\nleq x < m) if x and m are not (i.e. x and m have some common divisor\r\ngreater than 1); A password cannot be x (0\r\nleq x < m) if there exist integers e and k such that p^e = k m + x,\r\nwhere p is a secret integer; Any integer that doesn\u2019t break the above\r\nrules can be a password; Several integers are hidden in the room, but\r\nonly one of them can be p. Fortunately, she finds that n and m are\r\nrecorded in the lock. However, what makes Tokitsukaze frustrated is that\r\nshe doesn\u2019t do well in math. Now that she has found an integer that is\r\nsuspected to be p, she wants you to help her find out n possible\r\npasswords, or determine the integer cannot be p.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll INF = (ll)2e18;\nconst int B = 6;\nll mult(ll x, ll y, ll md) {\n\tif (y == 0) return 0;\n\treturn (mult((x * B) % md, y / B, md) + (x * (y % B))) % md;\n}\nll bin_pow(ll x, ll p, ll md) {\n\tif (p == 0) return 1 % md;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1, md), md);\n\treturn bin_pow(mult(x, x, md), p / 2, md);\n}\n\nconst int CC = (int)5e6;\n//const int CC = 0;\nbool used[CC + 1];\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nll F(ll x, ll m) {\n\tx = mult(x, x, m);\n\tx++;\n\tif (x == m) x -= m;\n\treturn x;\n}\nvector<ll> findDivs(ll m) {\n\tvector<ll> ans;\n\tfor (ll x = 2; x < CC; x++) {\n\t\tif (m % x) continue;\n\t\tans.push_back(x);\n\t\twhile(m % x == 0) m /= x;\n\t}\n\tif (m == 1) return ans;\n\t\n\t// pollard\n\tif (m < (ll)(CC - 2) * (CC - 2)) {\n\t\tans.push_back(m);\n\t\treturn ans;\n\t}\n\tfor (int it = 0; it < 5; it++) {\n\t\tll x = rng() % 100 + 1;\n\t\tll y = x;\n\t\tfor (int it2 = 0; it2 < 100000; it2++) {\n\t\t\tx = F(x, m);\n\t\t\ty = F(y, m);\n\t\t\ty = F(y, m);\n\t\t\tll d = gcd(abs(x - y), m);\n\t\t\tif (d != 1 && d != m) {\n\t\t\t\tans.push_back(d);\n\t\t\t\tans.push_back(m / d);\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\t}\n\tans.push_back(m);\n\treturn ans;\n}\n\nll getOrder(ll g, ll m, ll phi, vector<ll> divs) {\n//\tcerr << g << \" \" << m << \" \" << phi << endl;\n\tfor (ll x : divs) {\n\t\t//cerr << x << endl;\n\t\tll z = bin_pow(g, phi / x, m);\n//\t\tcerr << z << endl;\n\t\tif (z == 1)\n\t\t\treturn x;\n\t}\n\treturn 1;\n}\n\nll myPow(ll x, ll p) {\n\tll res = 1;\n\twhile(p--) {\n\t\tif ((double)res * x > INF) return INF;\n\t\tres *= x;\n\t}\n\treturn min(res, INF);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint n;\n\tll m, w;\n\tscanf(\"%d%lld%lld\", &n, &m, &w);\n\tll p = m;\n\tint t = 1;\n\tfor (int k = 2; k < 60; k++) {\n\t\tll z = (ll)(powl(m, 1. / k));\n\t\tif (z > 1) z--;\n\t\tz = max(z, 1LL);\n\t\twhile(myPow(z, k) > m) z--;\n\t\twhile(myPow(z, k) < m) z++;\n\t\tif (myPow(z, k) == m) {\n\t\t\tp = z;\n\t\t\tt = k;\n\t\t}\n\t}\n//\teprintf(\"%lld %d\\n\", p, t);\n\tif (m < CC) {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tused[i] = 0;\n\t\t}\n\t\tll x = 1;\n\t\twhile(true) {\n\t\t\tif (used[x]) break;\n\t\t\tused[x] = 1;\n\t\t\tx = (x * w) % m;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!used[i] && (i % p != 0)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\tif (res < n) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; n > 0 && i < m; i++) {\n\t\t\tif (!used[i] && (i % p != 0)) {\n\t\t\t\tprintf(\"%d \", i);\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tif (w % p == 0) {\n\t\tll res = (m / p) * (p - 1) - 1;\n\t\tif (res < n) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor (ll x = 2; n > 0; x++) {\n\t\t\tif (x % p == 0) continue;\n\t\t\tprintf(\"%lld \", x);\n\t\t\tn--;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tif (p == 2) {\n\t\tint x = 3;\n\t\twhile(w % 8 == x) x += 2;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%d \", 8 * i + x);\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tll phi = (m / p) * (p - 1);\n\tvector<ll> divs = findDivs(p - 1);\n\tif (t > 1) divs.push_back(p);\n\tll ord = getOrder(w, m, phi, divs);\n\tif (ord == 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tll g = 0;\n\twhile(true) {\n\t\tif (g % p == 0 || getOrder(g, m, phi, divs) != 1) {\n\t\t\tg = rng() % m;\n\t\t} else break;\n\t}\n\tll x = 1;\n\tfor (int i = 1; n > 0; i++) {\n\t\tx = mult(x, g, m);\n\t\tif (i % ord != 0) {\n\t\t\tprintf(\"%lld \", x);\n\t\t\tn--;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["number theory", "probabilities"], "dificulty": "3400", "interactive": false}