{
    "link": "https://codeforces.com//contest/1190/problem/F",
    "problemId": "371228",
    "problem_idx": "F",
    "shortId": "1190F",
    "contest_number": "1190",
    "problem_submissions": {
        "F": [
            56941738,
            56942014,
            56928138,
            56942516,
            56950887,
            58195417,
            58195396
        ],
        "E": [
            56917008,
            56916854,
            56935244,
            57349641,
            56979679,
            56978421,
            56932359,
            56972779,
            56934145,
            56955262,
            56955204,
            56941608,
            56941586,
            56935542,
            56933188,
            57068903,
            57330846,
            57330794,
            56942010
        ],
        "D": [
            56905170,
            56903117,
            56915954,
            56905847,
            56909818,
            56908766,
            56917699,
            56902041,
            56905886,
            56904524,
            56906795,
            56906965,
            56900483,
            56909139,
            56909403,
            56908905,
            56906330,
            56905643,
            56915882,
            56909382
        ],
        "C": [
            56900650,
            56922677,
            56907961,
            56915160,
            56918774,
            56933389,
            56914144,
            56911238,
            56911841,
            56914833,
            56915809,
            56917468,
            56907600,
            56903345,
            56902197,
            56904463,
            56924310,
            56918439,
            56903054,
            56913026
        ],
        "B": [
            56894838,
            56897380,
            56899896,
            56900500,
            56902295,
            56898363,
            56894711,
            56934531,
            56896361,
            56900397,
            56898856,
            56894889,
            56895625,
            56895683,
            56897433,
            56894846,
            56898447,
            56897871,
            56896691,
            56899788
        ],
        "A": [
            56890891,
            56891248,
            56896475,
            56892165,
            56893900,
            56891144,
            56890604,
            56893098,
            56892007,
            56891978,
            56894387,
            56896707,
            56892771,
            56890233,
            56891624,
            56891412,
            56893655,
            56892212,
            56892634,
            56891452
        ]
    },
    "name": "F. Tokitsukaze and Powers",
    "statement": "Tokitsukaze is playing a room escape game designed by SkywalkerT. In\r\nthis game, she needs to find out hidden clues in the room to reveal a\r\nway to escape.After a while, she realizes that the only way to run away\r\nis to open the digital door lock since she accidentally went into a\r\nsecret compartment and found some clues, which can be interpreted as:\r\nOnly when you enter n possible different passwords can you open the\r\ndoor; Passwords must be integers ranged from 0 to (m - 1); A password\r\ncannot be x (0\r\nleq x < m) if x and m are not (i.e. x and m have some common divisor\r\ngreater than 1); A password cannot be x (0\r\nleq x < m) if there exist integers e and k such that p^e = k m + x,\r\nwhere p is a secret integer; Any integer that doesn’t break the above\r\nrules can be a password; Several integers are hidden in the room, but\r\nonly one of them can be p. Fortunately, she finds that n and m are\r\nrecorded in the lock. However, what makes Tokitsukaze frustrated is that\r\nshe doesn’t do well in math. Now that she has found an integer that is\r\nsuspected to be p, she wants you to help her find out n possible\r\npasswords, or determine the integer cannot be p.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll INF = (ll)2e18;\nconst int B = 6;\nll mult(ll x, ll y, ll md) {\n\tif (y == 0) return 0;\n\treturn (mult((x * B) % md, y / B, md) + (x * (y % B))) % md;\n}\nll bin_pow(ll x, ll p, ll md) {\n\tif (p == 0) return 1 % md;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1, md), md);\n\treturn bin_pow(mult(x, x, md), p / 2, md);\n}\n\nconst int CC = (int)5e6;\n//const int CC = 0;\nbool used[CC + 1];\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nll F(ll x, ll m) {\n\tx = mult(x, x, m);\n\tx++;\n\tif (x == m) x -= m;\n\treturn x;\n}\nvector<ll> findDivs(ll m) {\n\tvector<ll> ans;\n\tfor (ll x = 2; x < CC; x++) {\n\t\tif (m % x) continue;\n\t\tans.push_back(x);\n\t\twhile(m % x == 0) m /= x;\n\t}\n\tif (m == 1) return ans;\n\t\n\t// pollard\n\tif (m < (ll)(CC - 2) * (CC - 2)) {\n\t\tans.push_back(m);\n\t\treturn ans;\n\t}\n\tfor (int it = 0; it < 5; it++) {\n\t\tll x = rng() % 100 + 1;\n\t\tll y = x;\n\t\tfor (int it2 = 0; it2 < 100000; it2++) {\n\t\t\tx = F(x, m);\n\t\t\ty = F(y, m);\n\t\t\ty = F(y, m);\n\t\t\tll d = gcd(abs(x - y), m);\n\t\t\tif (d != 1 && d != m) {\n\t\t\t\tans.push_back(d);\n\t\t\t\tans.push_back(m / d);\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\t}\n\tans.push_back(m);\n\treturn ans;\n}\n\nll getOrder(ll g, ll m, ll phi, vector<ll> divs) {\n//\tcerr << g << \" \" << m << \" \" << phi << endl;\n\tfor (ll x : divs) {\n\t\t//cerr << x << endl;\n\t\tll z = bin_pow(g, phi / x, m);\n//\t\tcerr << z << endl;\n\t\tif (z == 1)\n\t\t\treturn x;\n\t}\n\treturn 1;\n}\n\nll myPow(ll x, ll p) {\n\tll res = 1;\n\twhile(p--) {\n\t\tif ((double)res * x > INF) return INF;\n\t\tres *= x;\n\t}\n\treturn min(res, INF);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint n;\n\tll m, w;\n\tscanf(\"%d%lld%lld\", &n, &m, &w);\n\tll p = m;\n\tint t = 1;\n\tfor (int k = 2; k < 60; k++) {\n\t\tll z = (ll)(powl(m, 1. / k));\n\t\tif (z > 1) z--;\n\t\tz = max(z, 1LL);\n\t\twhile(myPow(z, k) > m) z--;\n\t\twhile(myPow(z, k) < m) z++;\n\t\tif (myPow(z, k) == m) {\n\t\t\tp = z;\n\t\t\tt = k;\n\t\t}\n\t}\n//\teprintf(\"%lld %d\\n\", p, t);\n\tif (m < CC) {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tused[i] = 0;\n\t\t}\n\t\tll x = 1;\n\t\twhile(true) {\n\t\t\tif (used[x]) break;\n\t\t\tused[x] = 1;\n\t\t\tx = (x * w) % m;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!used[i] && (i % p != 0)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\tif (res < n) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; n > 0 && i < m; i++) {\n\t\t\tif (!used[i] && (i % p != 0)) {\n\t\t\t\tprintf(\"%d \", i);\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tif (w % p == 0) {\n\t\tll res = (m / p) * (p - 1) - 1;\n\t\tif (res < n) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor (ll x = 2; n > 0; x++) {\n\t\t\tif (x % p == 0) continue;\n\t\t\tprintf(\"%lld \", x);\n\t\t\tn--;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tif (p == 2) {\n\t\tint x = 3;\n\t\twhile(w % 8 == x) x += 2;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%d \", 8 * i + x);\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tll phi = (m / p) * (p - 1);\n\tvector<ll> divs = findDivs(p - 1);\n\tif (t > 1) divs.push_back(p);\n\tll ord = getOrder(w, m, phi, divs);\n\tif (ord == 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tll g = 0;\n\twhile(true) {\n\t\tif (g % p == 0 || getOrder(g, m, phi, divs) != 1) {\n\t\t\tg = rng() % m;\n\t\t} else break;\n\t}\n\tll x = 1;\n\tfor (int i = 1; n > 0; i++) {\n\t\tx = mult(x, g, m);\n\t\tif (i % ord != 0) {\n\t\t\tprintf(\"%lld \", x);\n\t\t\tn--;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "number theory",
        "probabilities"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Tokitsukaze and Powers.json",
    "editorial_link": "https://codeforces.com/blog/entry/68314",
    "editorial": "TutorialFirstly, let me briefly review this problem for you. Given\r\nintegers , and (, , ), we denote and , where means the greatest common\r\ndivisor of and , and you are asked to pick up distinct integers from ,\r\nthe set of elements in but not in , or report that it is unachievable.\r\nBesides, there is an additional restriction, for a prime number and a\r\npositive integer .It is not difficult to show , the size of , equals to\r\n. When , there is only one element in which is coprime to , so in that\r\ncase, . To output a solution, you can just enumerate the smallest\r\nintegers and skip the integer and any multiples of . In this process,\r\nyou wonât need to enumerate more than integers, because .When , we can\r\nobserve that . Let be , and we may conclude from Eulerâs totient theorem\r\nthat , and even . When , there is no solution, so we need to calculate\r\nin order to determine the existence of solutions.To calculate , you can\r\njust enumerate all the divisors of and check them using Fast Power\r\nAlgorithm, because the number of divisors is not too large due to the\r\nrestrictions. Alternatively, you can do it more advanced and check more\r\nefficiently like the following. The above approach requires calls of\r\nFast Power Algorithm. It is used more regularly when searching a random\r\nprimitive root in modulo some integer.When implementing Fast Power\r\nAlgorithm, you may notice an issue that the modular multiplication may\r\nnot be easy to code, when the 128-bit integer operations are not\r\ndirectly provided on this platform. In a precise way, you can implement\r\nanother like Fast Multiplying Algorithm, though it is a bit slow. But if\r\nyou believe you are lucky enough and you prefer using C/C++, you can try\r\nthe following code in a convenient way. No matter what approach you\r\nused, the factorization of is inevitable, so the problem requires you to\r\nfactorize a relatively large number (less than ) a bit quickly. For\r\nexample, you can use Pollardâs Rho Algorithm with Miller-Rabin Primality\r\nTest. By Birthday Paradox, which is a heuristic claim, when is not a\r\nprime, Pollardâs Rho Algorithm can split into in iterations. By the way,\r\nyou can obtain from by enumerating possible from large to small, instead\r\nof factorization.Letâs go back to the case that and . When any solution\r\nexists, we can observe that , so there may exist some solutions based on\r\nrandom distribution. That is, if you are able to check whether an\r\ninteger is in or not, you can roughly pick integers in and check them.\r\nOne approach is like the mechanism built in the problem checker, but as\r\nspace is limited, I would not expend it at here. One thing you should be\r\naware of is that you canât pick them without checking, as the\r\nprobability of failure may be so large, like . Moreover, you canât use\r\nBaby-Step-Giant-Step algorithm since its time complexity is too slow.If\r\nthere exists at least one primitive root in modulo , then we can\r\nconstruct the output integers. Since a primitive root can represent as ,\r\nwe can reduce the problem into something about modular equation that\r\nonly concerns the exponents. As the number of primitive root in modulo\r\nis , if the root exists, we can get a random primitive root easily. Now\r\nletâs assume we find a primitive root and . An integer is in if and only\r\nif the equation has a solution of . It is easy to show, when , a\r\nsolution of always exists, so the construction is quite\r\nstraightforward.The only case we left is when no primitive root exists\r\nin modulo , which occurs when , . In this case, we cannot represent all\r\nthe elements in as non-negative integer powers of one specific number,\r\nbut we can find a pseudo-primitive root to use its powers to represent\r\nall the elements in the form of in (as the group , also known as , is\r\nisomorphic to a direct product of cyclic groups, ). Besides, can\r\nrepresent the rest numbers (in the form of ) in . As the product of two\r\nintegers in the form of is in the form of , we can discuss the parity of\r\nin expression and check if an integer is in , so the construction could\r\nwork after a little modification. By the way, there exist many different\r\nconstruction methods for this case.In summary, to solve this problem, we\r\nneed to factorize , calculate the order of in modulo , find a primitive\r\nroot (or a pseudo-primitive root ) in modulo and enumerate some small\r\nintegers (values or exponents) to construct a solution.Time complexity:\r\n, where means the cost of one multiplication modulo . Some slow\r\nsolutions are accepted as well.\r\n",
    "hint": []
}