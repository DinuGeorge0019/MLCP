{
    "link": "https://codeforces.com//contest/696/problem/E",
    "problemId": "65172",
    "problem_idx": "E",
    "shortId": "696E",
    "contest_number": "696",
    "problem_submissions": {
        "E": [
            20498917,
            19122817,
            19128171,
            19128416,
            19128548,
            19128551,
            19129321,
            142908498,
            19129056,
            19129065,
            19148528,
            19121431
        ],
        "A": [
            19119258,
            19112517,
            19113245,
            19130646,
            19113356,
            19114035,
            19112027,
            19112329,
            19113544,
            19115943,
            19114049,
            19111947,
            19112445,
            19112591,
            19113340,
            19112458,
            19127604,
            19113354,
            19112419,
            19122807
        ],
        "B": [
            19118714,
            19115949,
            19116617,
            19115367,
            19115254,
            19116922,
            19113777,
            19114248,
            19115893,
            19113611,
            19114745,
            19113499,
            19115275,
            19114851,
            19115798,
            19115867,
            19113047,
            19115983,
            19115146,
            19124178
        ],
        "D": [
            19117852,
            19121638,
            19123814,
            19122693,
            19131199,
            19131585,
            19120524,
            19123388,
            19122212,
            19124637,
            19122311,
            19124184,
            19125355,
            19124738,
            19124393,
            19125186,
            19123099,
            19124323,
            19124512,
            19154347
        ],
        "C": [
            19113058,
            19119301,
            19121245,
            19119819,
            19118377,
            19124627,
            19116332,
            19120250,
            19118573,
            19118620,
            19122282,
            19118411,
            19120542,
            19120806,
            19119142,
            19121243,
            19119728,
            19127751
        ],
        "F": [
            19223787,
            19134194
        ]
    },
    "name": "E. ...Wait for it...",
    "statement": "Barney is searching for his dream girl. He lives in NYC. NYC has\r\njunctions numbered from to and roads connecting them. We will consider\r\nthe NYC as a rooted tree with root being junction . girls live in NYC,\r\n-th of them lives along junction and her weight initially equals pounds.\r\nBarney consider a girl to be than a girl if and only if: girl has weight\r\nstrictly less than girl or girl and girl have equal weights and index of\r\ngirl living junction index is strictly less than girl living junction\r\nindex, i.e. . Thus for any two girls one of them is always better than\r\nanother one.For the next days, one event happens each day. There are two\r\ntypes of events: Barney goes from junction to junction . As a result he\r\npicks at most from junctions on his way and invites them to his house to\r\ntest if one of them is his dream girl. If there are less than not\r\ninvited girls on his path, he invites all of them. Girls living along\r\njunctions in subtree of junction (including itself) put on some weight.\r\nAs result, their weights increase by pounds. Your task is for each event\r\nof first type tell Barney the indices of girls he will invite to his\r\nhome in this event.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nconst ll inf=1ll<<60;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n \nconst int N=201000;\nint q[N],hs[N],hv[N],dep[N],id[N],l[N],r[N],bel[N],s[N],f[N],pos[N],vl[N];\nint n,m,Q,tot,u,v,k,ty;\nVI e[N],vec[N],ret;\npair<ll,PII> ind[N],z;\nstruct node {\n\tll fg;\n\tpair<ll,PII> s;\n}nd[4*N];\nvoid upd(int p) {\n\tnd[p].s=min(nd[p+p].s,nd[p+p+1].s);\n}\nvoid setf(int p,ll v) {\n\tnd[p].fg+=v; nd[p].s.fi+=v;\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tif (l==r) {\n\t\tnd[p].s=ind[l];\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nvoid push(int p) {\n\tif (nd[p].fg) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\npair<ll,PII> query(int p,int l,int r,int tl,int tr) {\n\tif (tl==l&&tr==r) return nd[p].s;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) return query(p+p,l,md,tl,tr);\n\t\telse if (tl>md) return query(p+p+1,md+1,r,tl,tr);\n\t\telse return min(query(p+p,l,md,tl,md),query(p+p+1,md+1,r,md+1,tr));\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,ll v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n \nvoid dfs(int u,int f) {\n\tid[l[u]=++tot]=u; ind[tot]=mp(inf,mp(0,0));\n\tfor (auto v:vec[u]) {\n\t\tind[++tot]=mp(v,mp(u,v));\n\t\tpos[v]=tot;\n\t}\n\tvl[u]=tot;\n\tdep[u]=dep[f]+1;\n\tif (hv[u]) dfs(hv[u],u);\n\trep(j,0,SZ(e[u])) if (e[u][j]!=f&&e[u][j]!=hv[u])\n\t\tdfs(e[u][j],u);\n\tr[u]=tot;\n}\nvoid HLDoT(int rt) {\n\tint t=1;\n\tq[0]=rt;\n\trep(i,0,n) {\n\t\tint u=q[i];\n\t\trep(j,0,SZ(e[u])) if (e[u][j]!=f[u])\n\t\t\tf[e[u][j]]=u,dep[q[t++]=e[u][j]]=dep[u]+1;\n\t}\n\tper(i,0,n) {\n\t\tint u=q[i],p=f[u];\n\t\ts[u]++,s[p]+=s[u];\n\t\tif (!l[u]) l[u]=1;\n\t\tif (hs[p]<s[u]) hs[p]=s[u],hv[p]=u,l[p]=l[u]+1;\n\t}\n\trep(i,0,n) {\n\t\tint u=q[i];\n\t\tif (!bel[u]) bel[u]=u;\n\t\tif (hv[u]) bel[hv[u]]=bel[u];\n\t}\n\tdfs(rt,0);\n}\nvoid query(int u,int v) {\n\twhile (1) {\n\t\tif (bel[u]==bel[v]) {\n\t\t\tif (dep[u]<dep[v]) swap(u,v);\n\t\t\tz=min(z,query(1,1,m,l[v],vl[u]));\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (dep[bel[u]]<dep[bel[v]]) swap(u,v);\n\t\t\tz=min(z,query(1,1,m,l[bel[u]],vl[u]));\n\t\t\tu=f[bel[u]];\n\t\t}\n\t}\n}\n \nint main() {\n\tscanf(\"%d%d%d\",&n,&m,&Q);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\trep(i,0,m) {\n\t\tscanf(\"%d\",&u);\n\t\tvec[u].pb(i+1);\n\t}\n\tHLDoT(1);\n\tm=tot;\n\tbuild(1,1,m);\n\trep(i,0,Q) {\n\t\tscanf(\"%d\",&ty);\n\t\tif (ty==1) {\n\t\t\tscanf(\"%d%d%d\",&u,&v,&k);\n\t\t\tret.clear();\n\t\t\twhile (k>0) {\n\t\t\t\tz=mp(inf,mp(0,0));\n\t\t\t\tquery(u,v);\n\t\t\t\tif (z.fi>=1ll<<50) break;\n\t\t\t\t--k;\n\t\t\t\tret.pb(z.se.se);\n\t\t\t\tmodify(1,1,m,pos[z.se.se],pos[z.se.se],inf);\n\t\t\t}\n\t\t\tprintf(\"%d\",SZ(ret));\n\t\t\tfor (auto u:ret) printf(\" %d\",u);\n\t\t\tputs(\"\");\n\t\t} else {\n\t\t\tscanf(\"%d%d\",&u,&k);\n\t\t\tmodify(1,1,m,l[u],r[u],k);\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. ...Wait for it....json",
    "editorial_link": "https://codeforces.com//blog/entry/46031",
    "editorial": "Build the prefix automaton of these strings (Aho-Corasick). In this automaton every state denotes a string which is prefix of one of given strings (and when we feed characters to it the current state is always the longest of these prefixes that is a suffix of the current string we have fed to it). Building this DFA can be done in various ways (fast and slow).\n\nSuppose these automaton has N states () and state v has edges outgoing to states in vector neigh[v] (if we define our DFA as a directed graph). Suppose state number 1 is the initial state (denoting an empty string).\n\nIf l was smaller we could use dp: suppose dp[l][v] is the maximum score of all strings with length equal to l ending in state v of our DFA when fed into it.\n\nIt's easy to show that dp[0][1]?=?0 and dp[1][v]???bv?+?dp[l?+?1][u] for u in neigh[v] and calculating dps can be done using this (here bv is sum of a of all strings that are a suffix of string related to state v).\n\n \n\nNow that l is large, let's use matrix exponential to calculate the dp. Now dp is not an array, but a column matrix. Finding a matrix to update the dp is not hard. Also we need to reform + and * operations. In matrix multiplying we should use + instead of * and max instead of + in normal multiplication.",
    "hint": []
}