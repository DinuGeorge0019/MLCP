{
    "link": "https://codeforces.com//contest/1852/problem/F",
    "problemId": "2099137",
    "problem_idx": "F",
    "shortId": "1852F",
    "contest_number": "1852",
    "problem_submissions": {
        "F": [
            215258181,
            215285692,
            217509901,
            217509714
        ],
        "E": [
            215240027,
            215239122,
            215243644,
            215243658,
            215248799,
            215245960,
            215237098,
            215240727,
            215296441,
            215327365,
            215336328,
            217901271,
            215247415
        ],
        "D": [
            215222100,
            215222081,
            215222261,
            215225730,
            215218775,
            215382147,
            215226776,
            215250750,
            215250174,
            215230611,
            215232642,
            215226731,
            215232589,
            215240152,
            215237043,
            215236182,
            215239579,
            215241752,
            215242725
        ],
        "C": [
            215209363,
            215208759,
            215214250,
            215220833,
            215208505,
            215217394,
            215219756,
            215218376,
            215205472,
            215208510,
            215213920,
            215221691,
            215216406,
            215223920,
            215226652,
            215216927,
            215221642,
            215210662,
            215212429
        ],
        "B": [
            215201282,
            215200579,
            215202726,
            215199335,
            215200474,
            215207713,
            215208166,
            215202505,
            215214027,
            215200003,
            215206319,
            215205331,
            215204344,
            215212727,
            215206313,
            215209315,
            215209426,
            215199777,
            215204560
        ],
        "A": [
            215201184,
            215192031,
            215194261,
            215194419,
            215219859,
            215194029,
            215260286,
            215197669,
            215196351,
            215192202,
            215192228,
            215192416,
            215194163,
            215196399,
            215195136,
            215198712,
            215191998,
            215201193,
            215192233,
            215195682
        ]
    },
    "name": "F. Panda Meetups",
    "statement": "The red pandas are in town to meet their relatives, the blue pandas! The\r\ntown is modeled by a number line.The pandas have already planned their\r\nmeetup, but the schedule keeps changing. You are given q updates of the\r\nform . If c < 0, it means |c| more pandas enter the number line at\r\nposition x and time t. Then, each unit of time, they can each\r\nindependently move one unit in either direction across the number line,\r\nor . If c > 0, it means that c more pandas check position x for red\r\npandas at time t. If a blue panda does not meet a red panda at that\r\nspecific location and time, they dejectedly leave the number line right\r\naway. If there is a red panda at a position at the same time a blue\r\npanda checks it, they form a friendship and leave the number line. Each\r\nred panda can form a friendship with blue panda and vice versa. The\r\nupdates will be given in order of x values. After each update, please\r\nprint the maximum number of friendships if the red pandas move in an\r\noptimal order based on all the updates given in the input above (and\r\nincluding) this update. The order in which a red panda moves can change\r\nbetween updates.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct Point {\n    i64 x;\n    int dir;\n};\n\nint cur = 0;\n\nbool operator<(Point a, Point b) {\n    auto posa = a.x + a.dir * cur;\n    auto posb = b.x + b.dir * cur;\n    if (posa != posb) {\n        return posa < posb;\n    }\n    return a.dir > b.dir;\n}\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n\nstruct Info {\n    int sum;\n    int mx;\n    Info(int x = 0) : sum{x}, mx{std::max(0, x)} {}\n};\n\nInfo operator+(Info a, Info b) {\n    Info c;\n    c.sum = a.sum + b.sum;\n    c.mx = std::max(a.mx, a.sum + b.mx);\n    return c;\n}\n\nstruct Node {\n    int w = rng();\n    Info info;\n    Info sum;\n    Point p;\n    Node *l = nullptr;\n    Node *r = nullptr;\n};\n\nvoid pull(Node *t) {\n    t->sum = t->info;\n    if (t->l) {\n        t->sum = t->l->sum + t->sum;\n    }\n    if (t->r) {\n        t->sum = t->sum + t->r->sum;\n    }\n}\n\nstd::pair<Node *, Node *> split(Node *t, Point p) {\n    if (!t) {\n        return {t, t};\n    }\n    if (p < t->p) {\n        auto [l, r] = split(t->l, p);\n        t->l = r;\n        pull(t);\n        return {l, t};\n    } else {\n        auto [l, r] = split(t->r, p);\n        t->r = l;\n        pull(t);\n        return {t, r};\n    }\n}\nvoid insert(Node *&t, Node *x) {\n    if (!t) {\n        t = x;\n        return;\n    }\n    if (x->w < t->w) {\n        auto [l, r] = split(t, x->p);\n        t = x;\n        t->l = l;\n        t->r = r;\n        pull(t);\n        return;\n    }\n    if (x->p < t->p) {\n        insert(t->l, x);\n    } else {\n        insert(t->r, x);\n    }\n    pull(t);\n}\nvoid add(Node *&t, Point p, int x) {\n    if (p < t->p) {\n        add(t->l, p, x);\n    } else if (t->p < p) {\n        add(t->r, p, x);\n    } else {\n        t->info = t->info.sum + x;\n    }\n    pull(t);\n}\n\nNode *merge(Node *a, Node *b) {\n    if (!a) {\n        return b;\n    }\n    if (!b) {\n        return a;\n    }\n    \n    if (a->w < b->w) {\n        a->r = merge(a->r, b);\n        pull(a);\n        return a;\n    } else {\n        b->l = merge(a, b->l);\n        pull(b);\n        return b;\n    }\n}\n\nvoid erase(Node *&t, Point p) {\n    if (!(t->p < p) && !(p < t->p)) {\n        t = merge(t->l, t->r);\n        return;\n    }\n    if (p < t->p) {\n        erase(t->l, p);\n    } else {\n        erase(t->r, p);\n    }\n    pull(t);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> x(n), t(n), c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> x[i] >> t[i] >> c[i];\n    }\n    \n    int sumb = 0;\n    \n    Node *tree = nullptr;\n    \n    std::map<Point, int> s;\n    std::set<std::pair<i64, Point>> d;\n    \n    auto check = [&](auto it) {\n        auto r = std::next(it);\n        if (it->first.dir > r->first.dir) {\n            d.emplace((r->first.x - it->first.x + 1) / 2, it->first);\n        }\n    };\n    auto check2 = [&](auto it) {\n        if (it != s.begin()) {\n            check(std::prev(it));\n        }\n        if (std::next(it) != s.end()) {\n            check(it);\n        }\n    };\n    for (int i = 0; i < n; i++) {\n        while (!d.empty() && d.begin()->first <= x[i]) {\n            auto [tm, p] = *d.begin();\n            d.erase(d.begin());\n            auto it = s.find(p);\n            if (it == s.end()) {\n                continue;\n            }\n            auto r = std::next(it);\n            if (r == s.end()) {\n                continue;\n            }\n            if (it->first.x + it->first.dir * x[i] >= r->first.x + r->first.dir * x[i]) {\n                if (it->second + r->second < 0) {\n                    it->second += r->second;\n                    add(tree, it->first, r->second);\n                    erase(tree, r->first);\n                    s.erase(r);\n                    check2(it);\n                } else {\n                    r->second += it->second;\n                    add(tree, r->first, it->second);\n                    erase(tree, it->first);\n                    s.erase(it);\n                    check2(r);\n                }\n            }\n        }\n        cur = x[i];\n        if (c[i] > 0) {\n            if (s.count({t[i] + cur, -1})) {\n                add(tree, {t[i] + cur, -1}, c[i]);\n            } else {\n                Node *v = new Node;\n                v->info = v->sum = c[i];\n                v->p = {t[i] + cur, -1};\n                insert(tree, v);\n            }\n            s[{t[i] + cur, -1}] += c[i];\n            auto it = s.find({t[i] + cur, -1});\n            check2(it);\n            sumb += c[i];\n        } else {\n            if (s.count({t[i] - cur, 1})) {\n                add(tree, {t[i] - cur, 1}, c[i]);\n            } else {\n                Node *v = new Node;\n                v->info = v->sum = c[i];\n                v->p = {t[i] - cur, 1};\n                insert(tree, v);\n            }\n            s[{t[i] - cur, 1}] += c[i];\n            auto it = s.find({t[i] - cur, 1});\n            check2(it);\n        }\n        std::cout << sumb - tree->sum.mx << \"\\n\";\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "flows"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Panda Meetups.json",
    "editorial_link": "https://codeforces.com//blog/entry/116940",
    "editorial": "Problem Credits: enq Analysis: enq, oursaco SolutionRead the hints to\r\nunderstand the solution better.We can answer the queries online. For\r\neach -coordinate , maintain a treap that stores for every -coordinate,\r\nthe minimum cut associated with a polyline satisfying the condition\r\nabove that starts at and ends at when only considering events with\r\n-coordinate at most . When transitioning from to to , we need to set for\r\nevery for every . To do this quickly, we maintain the values of where in\r\nincreasing order, of which there are at most . When increases by one,\r\neach value of increases or decreases by one, depending on the sign of ,\r\nand some of the values of merge, decreasing the size of our treap. As\r\nlong as we can process each merge in time, our solution will run in\r\ntotal time. When processing an event, we need to increase all values in\r\na suffix for red panda events, and all values in a prefix for blue panda\r\nevents. To answer a query, we just need to return the minimum prefix sum\r\nin our treap.\r\n",
    "hint": [
        "Hint 1 If we want to answer one of the questions (say, the question involving all the events) in polynomial time, how do we do it?",
        "Hint 2 Construct a network with edges from the source to each of the red panda events with capacities equal to the number of red pandas, edges from red panda events to blue panda events with innite capacities if the red pandas can catch the corresponding blue pandas, and edges from each of the blue panda events to the sink with capacities equal to the number of blue pandas.",
        "Hint 3 The next step is to use the max-flow min-cut theorem: the maximum flow is equal to the minimum number of red pandas plus blue pandas we need to remove from the graph such that no remaining red panda can reach any remaining blue panda. How do we go from here?",
        "Hint 4 For any cut, consider the region of the - plane reachable by the remaining red pandas. No remaining blue pandas can lie in this region, and its border is a polyline that intersects each vertical line in the - plane exactly once. Furthermore, the slope of every segment in this polyline has slope plus or minus . Conversely, we can associate every polyline satisfying this condition with a cut; we just need to remove every red panda lying below the polyline and every blue panda lying on or above the polyline. Now, figure out how to answer the queries online."
    ]
}