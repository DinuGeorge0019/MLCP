{
    "link": "https://codeforces.com//contest/949/problem/A",
    "problemId": "163628",
    "problem_idx": "A",
    "shortId": "949A",
    "contest_number": "949",
    "problem_submissions": {
        "E": [
            36105597,
            36104729,
            36107882,
            36106052,
            36109939,
            36109078,
            36111836,
            36112039,
            36111175,
            36106962,
            36109964,
            36110554,
            36111413,
            36109601,
            36111115,
            36110022,
            36110942,
            94270940,
            36111425,
            36106250,
            36109832
        ],
        "D": [
            36101360,
            36106649,
            36105542,
            36109215,
            36106017,
            36106726,
            36102230,
            36101449,
            36103104,
            36110228,
            36103260,
            36105066,
            36107080,
            36106355,
            36107442,
            36106210,
            36107773,
            36109010,
            36109232,
            36112599
        ],
        "C": [
            36097297,
            36099409,
            36097097,
            36099338,
            36100026,
            36100955,
            36098934,
            36097758,
            36099260,
            36100420,
            36101363,
            36101312,
            36100998,
            36103414,
            36103747,
            36102556,
            36101236,
            36102526,
            50661562,
            36100630,
            36101932
        ],
        "B": [
            36095300,
            36092787,
            36094621,
            36097341,
            36096959,
            36097302,
            36093518,
            36094892,
            36097014,
            36095796,
            36096835,
            36098669,
            36097021,
            36100952,
            36098276,
            36097313,
            36097889,
            36098939,
            36095872,
            36098787
        ],
        "A": [
            36093067,
            36095425,
            36093246,
            36094348,
            36092357,
            36093156,
            36095248,
            36092415,
            36092267,
            36097893,
            36093322,
            36092795,
            36093362,
            36093672,
            36096228,
            36095964,
            36093387,
            36095876,
            36127878,
            36094011
        ]
    },
    "name": "A. Zebras",
    "statement": "Oleg writes down the history of the days he lived. For each day he\r\ndecides if it was good or bad. Oleg calls a non-empty sequence of days a\r\n, if it starts with a bad day, ends with a bad day, and good and bad\r\ndays are alternating in it. Let us denote bad days as and good days as .\r\nThen, for example, sequences of days , , are zebras, while sequences , ,\r\nare not.Oleg tells you the story of days he lived in chronological order\r\nin form of string consisting of and . Now you are interested if it is\r\npossible to divide Oleg’s life history into several , each of which is a\r\nzebra, and the way it can be done. Each day must belong to exactly one\r\nof the subsequences. For each of the subsequences, days forming it must\r\nbe ordered chronologically. Note that subsequence does not have to be a\r\ngroup of consecutive days.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define Se second\n#define Fi first\n\nvector <int> Vp[2];\nchar in[200050];\n\nint prv[200050];\nint nxt[200050];\nbool dchk[200050];\nint main() {\n\tint N, i;\n\tscanf(\"%s\", in + 1);\n\tN = strlen(in + 1);\n\n\tfor (i = 1; i <= N; i++) Vp[in[i] - '0'].push_back(i);\n\tif (Vp[0].size() <= Vp[1].size()) return !printf(\"-1\\n\");\n\n\tfor (i = 0; i < Vp[1].size(); i++) {\n\t\tint t1 = Vp[0][i], t2 = Vp[1][i];\n\t\tif (t1 > t2) return !printf(\"-1\\n\");\n\n\t\tnxt[t1] = t2;\n\t}\n\tfor (i = 0; i < Vp[1].size(); i++) {\n\t\tint t1 = Vp[0][Vp[0].size() - Vp[1].size() + i], t2 = Vp[1][i];\n\t\tif (t1 < t2) return !printf(\"-1\\n\");\n\t\tnxt[t2] = t1;\n\t}\n\n\tvector <vector<int>> Va;\n\tfor (i = 1; i <= N; i++) {\n\t\tif (dchk[i]) continue;\n\n\t\tvector <int> Vu;\n\t\tVu.push_back(i);\n\t\twhile (nxt[Vu.back()]) Vu.push_back(nxt[Vu.back()]);\n\t\tVa.push_back(Vu);\n\t\tfor (auto it : Vu) dchk[it] = true;\n\t}\n\n\tprintf(\"%d\\n\", (int)Va.size());\n\tfor (auto it : Va) {\n\t\tprintf(\"%d \", (int)it.size());\n\t\tfor (auto it2 : it) printf(\"%d \", it2);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Zebras.json",
    "editorial_link": "https://codeforces.com//blog/entry/58291",
    "editorial": "Simple greedy works here. Letâs go from left to right and assign each\r\nelement to some subsequence. At each moment we have two types of already\r\nbuilt subsequences: zebras (\"0\", \"010\", \"01010\", ...) and \"almost\r\nzebras\" (\"01\", \"0101\", \"010101\"). If next element of the string is â1â\r\nwe should add it to some zebra making it \"almost zebra\". If there are no\r\nzebras at this moment itâs impossible to divide string into zebra\r\nsubsequences. If next element of the string is â0â we should add it so\r\nsome \"almost zebra\" making it simple zebra. If there are no \"almost\r\nzebra\"âs now just create new zebra consisting of this â0â.If there are\r\nno \"almost zebra\"âs at the end answer exists and built zebras satisfy\r\nall requirements otherwise there is no answer. Find answer minimizing\r\nlength of longest subsequence. Find answer minimizing number of\r\nsubsequences.\r\n",
    "hint": []
}