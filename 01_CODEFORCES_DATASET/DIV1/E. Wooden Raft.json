{
    "link": "https://codeforces.com//contest/1240/problem/E",
    "problemId": "432410",
    "problem_idx": "E",
    "shortId": "1240E",
    "contest_number": "1240",
    "problem_submissions": {
        "E": [
            62021022,
            62035875,
            62035850,
            62028210,
            62027934,
            62027922,
            62020968,
            62019492,
            62018107,
            62027376,
            62027344,
            62027323,
            62027283,
            62027247,
            62024590,
            62019193,
            62026365,
            62033510,
            66614259
        ],
        "F": [
            62015871,
            62023134,
            62022377,
            62098107,
            62038718,
            62038624,
            62038494,
            62038407,
            62038292,
            74689890,
            62022214
        ],
        "C": [
            62011492,
            62004160,
            62005302,
            62005113,
            62008834,
            61997769,
            62007006,
            62008153,
            62005139,
            62004806,
            62004551,
            62010900,
            62006495,
            62006440,
            62005717,
            62009451,
            62008088,
            62007344,
            62007020,
            62010351
        ],
        "D": [
            62009147,
            62009402,
            62014575,
            62037666,
            62037540,
            62037485,
            62037237,
            62030534,
            62030405,
            62030387,
            62030368,
            62030266,
            62027938,
            62013459,
            62012657,
            62006383,
            62007439,
            62012558,
            62014620,
            62005092,
            62013564,
            62012342,
            62013093,
            62013916,
            62013931,
            62014362,
            62014894
        ],
        "B": [
            61999051,
            61998153,
            62000446,
            61993443,
            62005202,
            62003856,
            62003729,
            61994391,
            61998951,
            61998615,
            61999693,
            62002895,
            62001444,
            62001486,
            61999611,
            62004268,
            62001331,
            62002370,
            62000744,
            61994760
        ],
        "A": [
            61993335,
            61995494,
            62011119,
            61998900,
            61995613,
            62001949,
            61995342,
            62005037,
            61996323,
            61994369,
            61994535,
            62007707,
            61995405,
            61994877,
            61995746,
            61997040,
            61995992,
            61997766,
            61995459,
            62004034
        ]
    },
    "name": "E. Wooden Raft",
    "statement": "Suppose you are stuck on a desert island. The only way to save yourself\r\nis to craft a wooden raft and go to the sea. Fortunately, you have a\r\nhand-made saw and a forest nearby. Moreover, you\u2019ve already cut several\r\ntrees and prepared it to the point that now you have n logs and the i-th\r\nlog has length a_i.The wooden raft you\u2019d like to build has the following\r\nstructure: 2 logs of length x and x logs of length y. Such raft would\r\nhave the area equal to x\r\ncdot y. Both since it\u2019s the only way you can measure the lengths while\r\nbeing on a desert island. And both since the raft that is one log wide\r\nis unstable.You can cut logs in pieces but you can\u2019t merge two logs in\r\none. What is the maximum area of the raft you can craft?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int M=500000;\nconst int N=501000;\n\nll dp[10],pd[10],s;\nint cnt[N],ord[N],x,cnt0[10],cnt1[10],n;\n\nbool check(ll x,int y) {\n\tVI z; z.pb(0); z.pb(y); z.pb(x%y); z.pb(2*x%y);\n\tsort(all(z)); z.erase(unique(all(z)),z.end());\n\tll cs=0;\n\trep(i,0,SZ(z)-1) cnt0[i]=cnt1[i]=0;\n\tfor (int val=0;val<=M;val+=y) {\n\t\tcs+=(ll)(cnt[min(val+y,M+1)]-cnt[val])*(val/y);\n\t\trep(i,0,SZ(z)-1) {\n\t\t\t// val+z[i], val+z[i+1]-1\n\t\t\tint pl=val+z[i],pr=val+z[i+1]-1;\n\t\t\tint zz=cnt[min(pr+1,M+1)]-cnt[min(pl,M+1)];\n\t\t\tif (pl>=x) {\n\t\t\t\tcnt0[i]+=zz;\n\t\t\t}\n\t\t\tif (pl>=2*x) {\n\t\t\t\tcnt1[i]+=zz;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0]=0; dp[1]=dp[2]=1ll<<60;\n\trep(i,0,SZ(z)-1) {\n\t\tint pl=z[i],pr=z[i+1]-1;\n\t\tll rg=(1ll<<40)*y+pl;\n\t\tll rd1=(rg/y)-(rg-x)/y;\n\t\tll rd2=(rg/y)-(rg-2*x)/y;\n\t\tcnt0[i]=min(cnt0[i],2);\n\t\tcnt1[i]=min(cnt1[i],1);\n\t\trep(j,1,3) pd[j]=dp[j];\n\t\trep(j,1,cnt0[i]+1) rep(k,j,3) dp[k]=min(dp[k],pd[k-j]+j*rd1);\n\t\trep(j,1,3) pd[j]=dp[j];\n\t\trep(j,1,cnt1[i]+1) rep(k,2*j,3) dp[k]=min(dp[k],pd[k-2*j]+j*rd2);\n\t}\n\treturn cs-dp[2]>=x;\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",&x),cnt[x+1]++,s+=x;\n\trep(i,1,M+2) cnt[i]+=cnt[i-1];\n\tll ans=0;\n\trep(i,1,M+1) ord[i]=i;\n\trandom_shuffle(ord+1,ord+M+1,rnd);\n\trep(i,1,M+1) {\n\t\tint y=ord[i];\n\t\tif (y==1) continue;\n\t\tll px=max((ans+y-1)/y,2ll);\n\t\tif (!check(px,y)) continue;\n\t\tll l=px,r=s/y+1;\n\t\twhile (l+1<r) {\n\t\t\tll md=(l+r)>>1;\n\t\t\tif (check(md,y)) l=md; else r=md;\n\t\t}\n\t\tans=max(ans,l*y);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Wooden Raft.json",
    "editorial_link": "https://codeforces.com/blog/entry/70358",
    "editorial": "Let's iterate y\n from 2\n to A\n, where A=max(ai)\n. And let's try to find the best answer for a fixed y\n in O(Ay)\n time.\n\nHow to do so? At first, we can quite easily calculate the total number of logs of length y\n we can acquire (denote it as cntY\n): since all ai?[ky,ky+y)\n give the same number of logs which is equal to k\n, then let's just count the number of ai\n in [ky,ky+y)\n for each k\n. We can do so using frequency array and prefix sums on it.\n\nThere are two cases in the problem: both logs of length x\n lies in the same log ai\n or from the different logs ai\n and aj\n. In the first case it's the same as finding one log of length 2x\n. But in both cases we will divide all possible values of x\n (2x\n) in segments [ky,ky+y)\n and check each segment in O(1)\n time.\n\nLet's suppose that 2x?[ky,ky+y)\n and there is ai\n such that ai?2x\n and (aimody)?(2xmody)\n. In that case it's optimal to cut 2x\n from ai\n and, moreover, it's optimal to increase 2x\n while we can. It leads us straight to the solution, let's keep max(aimody)\n over ai?ky\n and check only 2x=ky+max(aimody)\n (maybe minus one in case of wrong parity). We can maintain this max iterating k\n in descending order. And since max(aimody)\n for all ai?[ky,ky+y)\n is just a max(ai | ai<ky+y)\n. We can find such ai\n in O(1)\n using precalc. To check the chosen 2x\n is trivial: the number of remaining logs y\n is equal to cntY?k\n and the plot will have the area y?min(x,cntY?k)\n.\n\nThe case with cutting x\n-s from different ai\n and aj\n is based on the same idea, but we need to maintain two maximums mx1\n and mx2\n (mx1?mx2\n). But in this case x\n can be equal to both mx1\n or mx2\n.\n\nIf x=ky+mx2\n then everything is trivial: the number of logs y\n is cntY?2?k\n and so on. If x=ky+mx1\n then we need to additional check the existence of ai?x\n and aj?x\n. Remaining number of logs y\n will be equal to cntY?2?k?1\n and so on.\n\nIn result, for each y\n we can calculate the answer in O(Ay)\n, so the total time complexity is O(n+?Ay=2O(Ay))=O(n+AlogA)\n.\n\nP.S.: We decided to allow the O(Alog2A)\n solution which binary search x\n for each y\n to pass if it's carefully written."
}