{
    "link": "https://codeforces.com//contest/314/problem/C",
    "problemId": "3140",
    "problem_idx": "C",
    "shortId": "314C",
    "contest_number": "314",
    "problem_submissions": {
        "E": [
            30724544,
            3841662,
            3843754,
            3843819,
            3841502,
            3860384,
            3934694,
            3845808
        ],
        "D": [
            3838247,
            3837490,
            3833649,
            3839672,
            3836920,
            3843899,
            3843892,
            3843887,
            3839403,
            3837634,
            3841257,
            3841298,
            3842000,
            3842070,
            3840998,
            3841422,
            3840708,
            3840797,
            3839070,
            3842300,
            3841251
        ],
        "C": [
            3835839,
            3835172,
            3835831,
            3837510,
            3837765,
            3834791,
            3833737,
            3838762,
            3839170,
            3839102,
            3834408,
            3840072,
            3836332,
            3840999,
            3838170,
            3838751,
            3836736,
            3840325,
            3839207,
            3832923
        ],
        "B": [
            3832474,
            3833450,
            3837630,
            3835590,
            3835615,
            3836583,
            3840262,
            3835730,
            3832871,
            3835097,
            3839185,
            3834451,
            3840037,
            3832621,
            3841872,
            3837653,
            3838448,
            3841898,
            3834701
        ],
        "A": [
            3832264,
            3841936,
            3833100,
            3832334,
            3832542,
            3835485,
            3832690,
            3839877,
            3833260,
            3832812,
            3838983,
            3836728,
            3832398,
            3833247,
            3833000,
            3833823,
            3833650,
            3835970
        ]
    },
    "name": "C. Sereja and Subsequences",
    "statement": "Sereja has a sequence that consists of positive integers, . First Sereja\r\ntook a piece of squared paper and wrote all non-empty non-decreasing\r\nsubsequences of sequence . Then for each sequence written on the squared\r\npaper, Sereja wrote on a piece of lines paper all sequences that it.A\r\nsequence of positive integers doesn\u2019t exceed a sequence of positive\r\nintegers , if the following inequation holds: .Now Sereja wonders, how\r\nmany sequences are written on the lines piece of paper. Help Sereja,\r\nfind the required quantity modulo .\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <complex>\n#include <sstream>\nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n \n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SIZE(c) ((int)((c).size()))\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FOREACH(i,x) for (__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n#define ALL(v) (v).begin(), (v).end()\n \n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MOD = 1000000007;\nconst int M = 1<<18;\nint T[2 * M];\n\nvoid add(int v, LL k) {\n    v += M;\n    while (v) {\n        T[v] = (T[v] + k) % MOD;\n        v /= 2;\n    }\n}\n\nLL get(int a, int b) {\n    LL result = 0;\n    a += M, b += M;\n    if (a == b) return T[a];\n    \n    result = T[a] + T[b];\n    while (a / 2 != b / 2) {\n        if (a%2 == 0) result += T[a+1];\n        if (b%2 == 1) result += T[b-1];\n        \n        a /= 2;\n        b /= 2;\n    }\n\n    return result % MOD;\n}\n\nPII A[200000];\nint prev[200000];\n\nint main() {\n    int N;\n    scanf(\"%d\",&N);\n    REP(i,N) scanf(\"%d\",&A[i].st);\n    REP(i,N) A[i].nd = i;\n    map<int,int> Ma;\n    REP(i,N) {\n        prev[i] = Ma[A[i].st] - 1;\n        Ma[A[i].st] = i + 1;\n    }\n    sort(A,A+N);\n    \n    LL result = 0;\n    REP(i,N) {\n        int a = A[i].st;\n        int p = prev[A[i].nd];\n        LL tmp = get(max(p,0), A[i].nd);\n        if (p == -1) tmp += 1;\n        \n        tmp *= a;        \n        tmp %= MOD;\n        add(A[i].nd,tmp);\n        result += tmp;        \n    }\n    \n    printf(\"%d\\n\", (int)(result % MOD));\n}    "
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Sereja and Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/7905",
    "editorial": "It is clear that we need to calculate the sum of the products of elements of all the different non-decreasing subsequences of given sequence. Let's go through the sequence from left to right and maintain the array q[i]: what means the sum of all relevant sub-sequences, such that their last element is equal to i. Clearly, if the next number is x, then you need to put q[x] = sum (q[1] + q[2] + ... + q[x]) * x + x. The answer to the problem is the sum of q[i]. To find all the amounts you can use Fenwick tree."
}