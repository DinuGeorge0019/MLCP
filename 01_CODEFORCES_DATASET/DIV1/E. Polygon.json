{"link": "https://codeforces.com//contest/1572/problem/E", "problemId": "1113067", "problem_idx": "E", "shortId": "1572E", "contest_number": "1572", "problem_submissions": {"E": [129206504, 129205064, 129206146, 129186931, 129254910, 129870976, 129204851], "B": [129200222, 129195364, 129193573, 129181375, 129193456, 129190984, 129205791, 129198794, 129201998, 129193078, 129214920, 129184305, 129194122, 129185643, 129187972, 129190794, 129186099, 129191410, 129188216], "C": [129195835, 129191513, 129199311, 129193150, 129195181, 129198867, 129196979, 129259448, 129179785, 129722486, 129198454, 129198079, 129197696, 129199887, 129197773, 129211811, 129200276], "D": [129192769, 129199613, 129201627, 129206390, 129205002, 129205082, 129227304, 129328372, 129201185, 129870962, 129870944, 129203066, 129316237, 129316188, 136814393, 129429191], "A": [129167164, 129167977, 129198411, 129169285, 129180189, 129173821, 129177103, 129171630, 129176985, 129172424, 129196280, 129167530, 129169791, 129170025, 129173030, 129174006, 129171850, 129174559, 129177053], "F": [129209583, 129209541, 129208785, 129202453, 129198897, 129722539, 129216893, 129216152, 129193790, 129338264]}, "name": "E. Polygon", "statement": "You are given a strictly convex polygon with n vertices.You will make k\r\ncuts that meet the following conditions: each cut is a segment that\r\nconnects two different nonadjacent vertices; two cuts can intersect only\r\nat vertices of the polygon. Your task is to maximize the area of the\r\nsmallest region that will be formed by the polygon and those k cuts.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 18.09.2021 19:19:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nstruct TPoint {\n  T x;\n  T y;\n  int id;\n\n  TPoint() : x(0), y(0), id(-1) {}\n  TPoint(const T& x_, const T& y_) : x(x_), y(y_), id(-1) {}\n  TPoint(const T& x_, const T& y_, int id_) : x(x_), y(y_), id(id_) {}\n\n  static constexpr T eps = static_cast<T>(1e-9);\n\n  inline TPoint operator+(const TPoint& rhs) const { return TPoint(x + rhs.x, y + rhs.y); }\n  inline TPoint operator-(const TPoint& rhs) const { return TPoint(x - rhs.x, y - rhs.y); }\n  inline TPoint operator*(const T& rhs) const { return TPoint(x * rhs, y * rhs); }\n  inline TPoint operator/(const T& rhs) const { return TPoint(x / rhs, y / rhs); }\n\n  friend T smul(const TPoint& a, const TPoint& b) {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  friend T vmul(const TPoint& a, const TPoint& b) {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  inline T abs2() const {\n    return x * x + y * y;\n  }\n\n  inline bool operator<(const TPoint& rhs) const {\n    return (y < rhs.y || (y == rhs.y && x < rhs.x));\n  }\n\n  inline bool is_upper() const {\n    return (y > eps || (abs(y) <= eps && x > eps));\n  }\n\n  inline int cmp_polar(const TPoint& rhs) const {\n    assert(abs(x) > eps || abs(y) > eps);\n    assert(abs(rhs.x) > eps || abs(rhs.y) > eps);\n    bool a = is_upper();\n    bool b = rhs.is_upper();\n    if (a != b) {\n      return (a ? -1 : 1);\n    }\n    long long v = x * rhs.y - y * rhs.x;\n    return (v > eps ? -1 : (v < -eps ? 1 : 0));\n  }\n};\n\nusing Point = TPoint<long long>;\n//using Point = TPoint<long double>;\n\ntemplate <typename T>\nstring to_string(const TPoint<T>& p) {\n  return \"(\" + to_string(p.x) + \", \" + to_string(p.y) + \")\";\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<Point> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].x >> p[i].y;\n  }\n  vector<vector<long long>> area(n, vector<long long>(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (int k = 2; k <= n - 1; k++) {\n      int x = (i + k - 1) % n;\n      int y = (i + k) % n;\n      area[i][y] = area[i][x] + abs(vmul(p[x] - p[i], p[y] - p[i]));\n    }\n  }\n  debug(area);\n  if (k == 0) {\n    cout << area[0][n - 1] << '\\n';\n    return 0;\n  }\n  long long low = 0;\n  long long high = (long long) 4e18;\n  while (low < high) {\n    long long mid = (low + high + 1) >> 1;\n    const int inf = (int) 1e6;\n    vector<vector<int>> dp(n, vector<int>(n, -inf));\n    for (int len = 1; len <= n - 1; len++) {\n      for (int i = 0; i < n; i++) {\n        int j = (i + len) % n;\n        if (area[i][j] >= mid) {\n          dp[i][j] = 0;\n        }\n        for (int q = 2; q <= len - 2; q++) {\n          int u = (i + q) % n;\n          if (area[i][j] - area[i][u] - area[u][j] >= mid) {\n            dp[i][j] = max(dp[i][j], dp[i][u] + dp[u][j] + 2);\n          }\n        }\n        int p = 0;\n        for (int q = 0; q <= len - 2; q++) {\n          int u = (i + q) % n;\n          p = max(p, q);\n          while (p < len) {\n            int v = (i + p + 1) % n;\n            if (area[i][j] - area[u][v] >= mid) {\n              ++p;\n            } else {\n              break;\n            }\n          }\n          int v = (i + p) % n;\n          if (area[i][j] - area[u][v] >= mid) {\n            dp[i][j] = max(dp[i][j], dp[u][v] + 1);\n          }\n        }\n        debug(mid, i, j, dp[i][j]);\n      }\n    }\n    bool ok = false;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (dp[i][j] + dp[j][i] + 1 >= k) {\n          ok = true;\n          break;\n        }\n      }\n      if (ok) break;\n    }\n    if (ok) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  cout << low << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "dp", "geometry"], "dificulty": "3000", "interactive": false}