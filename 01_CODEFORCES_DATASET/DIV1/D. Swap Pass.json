{
    "link": "https://codeforces.com//contest/1508/problem/D",
    "problemId": "958784",
    "problem_idx": "D",
    "shortId": "1508D",
    "contest_number": "1508",
    "problem_submissions": {
        "D": [
            113258208,
            113225842,
            113232066,
            113242382,
            113242310,
            113248310,
            113252824,
            113256393,
            113240058,
            113236672,
            113233206,
            113240165,
            113242005,
            113242817,
            113243142
        ],
        "F": [
            113247954,
            113415583,
            113275748,
            113263512,
            113569093,
            113516939
        ],
        "C": [
            113237315,
            113213039,
            113214478,
            113213780,
            113212574,
            113213010,
            113224842,
            113226169,
            113232722,
            113215825,
            113215542,
            113224987,
            113223453,
            113228420,
            113228228,
            113217788,
            113226078,
            113229271,
            113230097
        ],
        "E": [
            113228353,
            113239041,
            113241831,
            113228851,
            113231701,
            113244425,
            113243109,
            113247201,
            113253919,
            113253035,
            113238610,
            113246155,
            113333091,
            113246539,
            113240797,
            113246922
        ],
        "A": [
            113201428,
            113189518,
            113189456,
            113190605,
            113198010,
            113192641,
            113194080,
            113204739,
            113207875,
            113194317,
            113200012,
            113222414,
            113194745,
            113195037,
            113199971,
            113199286,
            113193286,
            113195565,
            113191574,
            113194231
        ],
        "B": [
            113197951,
            113196658,
            113192904,
            113196665,
            113201215,
            113199153,
            113202442,
            113210198,
            113217372,
            113203624,
            113208530,
            113197629,
            113206458,
            113203987,
            113206383,
            113212945,
            113200476,
            113197819,
            113199529,
            113200558
        ]
    },
    "name": "D. Swap Pass",
    "statement": "You are given n points on the plane, no three of which are collinear.\r\nThe i-th point initially has a label a_i, in such a way that the labels\r\na_1, a_2,\r\ndots, a_n form a permutation of 1, 2,\r\ndots, n.You are allowed to modify the labels through the following\r\noperation: Choose two distinct integers i and j between 1 and n. Swap\r\nthe labels of points i and j, and finally Draw the segment between\r\npoints i and j. A sequence of operations is valid if after applying all\r\nof the operations in the sequence in order, the k-th point ends up\r\nhaving the label k for all k between 1 and n inclusive, and the drawn\r\nsegments don\u2019t intersect each other internally. Formally, if two of the\r\nsegments intersect, then they must do so at a common endpoint of both\r\nsegments.In particular, all drawn segments must be distinct.Find any\r\nvalid sequence of operations, or say that none exist.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\ntemplate <typename T> struct Point {\npublic:\n\tT x, y;\n\tPoint() : x(0), y(0) {}\n\tPoint(T x_, T y_) : x(x_), y(y_) {}\n\ttemplate <typename U> explicit Point(const Point<U>& p) : x(p.x), y(p.y) {}\n\tPoint(const std::pair<T, T>& p) : x(p.first), y(p.second) {}\n\tPoint(const std::complex<T>& p) : x(real(p)), y(imag(p)) {}\n\texplicit operator std::pair<T, T> () const { return std::pair<T, T>(x, y); }\n\texplicit operator std::complex<T> () const { return std::complex<T>(x, y); }\n\n\tfriend std::ostream& operator << (std::ostream& o, const Point& p) { return o << '(' << p.x << ',' << p.y << ')'; }\n\tfriend std::istream& operator >> (std::istream& i, Point& p) { return i >> p.x >> p.y; }\n\tfriend bool operator == (const Point& a, const Point& b) { return a.x == b.x && a.y == b.y; }\n\tfriend bool operator != (const Point& a, const Point& b) { return !(a==b); }\n\n\tPoint operator + () const { return Point(+x, +y); }\n\tPoint operator - () const { return Point(-x, -y); }\n\n\tPoint& operator += (const Point& p) { x += p.x, y += p.y; return *this; }\n\tPoint& operator -= (const Point& p) { x -= p.x, y -= p.y; return *this; }\n\tPoint& operator *= (const T& t) { x *= t, y *= t; return *this; }\n\tPoint& operator /= (const T& t) { x /= t, y /= t; return *this; }\n\n\tfriend Point operator + (const Point& a, const Point& b) { return Point(a.x+b.x, a.y+b.y); }\n\tfriend Point operator - (const Point& a, const Point& b) { return Point(a.x-b.x, a.y-b.y); }\n\tfriend Point operator * (const Point& a, const T& t) { return Point(a.x*t, a.y*t); }\n\tfriend Point operator * (const T& t ,const Point& a) { return Point(t*a.x, t*a.y); }\n\tfriend Point operator / (const Point& a, const T& t) { return Point(a.x/t, a.y/t); }\n\n\tT dist2() const { return x * x + y * y; }\n\tauto dist() const { return std::sqrt(dist2()); }\n\tPoint unit() const { return *this / this->dist(); }\n\tauto angle() const { return std::atan2(y, x); }\n\n\tT int_norm() const { return __gcd(x,y); }\n\tPoint int_unit() const { if (!x && !y) return *this; return *this / this->int_norm(); }\n\n\t// Convenient free-functions, mostly for generic interop\n\tfriend auto norm(const Point& a) { return a.dist2(); }\n\tfriend auto abs(const Point& a) { return a.dist(); }\n\tfriend auto unit(const Point& a) { return a.unit(); }\n\tfriend auto arg(const Point& a) { return a.angle(); }\n\tfriend auto int_norm(const Point& a) { return a.int_norm(); }\n\tfriend auto int_unit(const Point& a) { return a.int_unit(); }\n\n\tPoint perp_cw() const { return Point(y, -x); }\n\tPoint perp_ccw() const { return Point(-y, x); }\n\n\tfriend T dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n\tfriend T cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n\tfriend T cross3(const Point& a, const Point& b, const Point& c) { return cross(b-a, c-a); }\n\n\t// Complex numbers and rotation\n\tfriend Point conj(const Point& a) { return Point(a.x, -a.y); }\n\n\t// Returns conj(a) * b\n\tfriend Point dot_cross(const Point& a, const Point& b) { return Point(dot(a, b), cross(a, b)); }\n\tfriend Point cmul(const Point& a, const Point& b) { return dot_cross(conj(a), b); }\n\tfriend Point cdiv(const Point& a, const Point& b) { return dot_cross(b, a) / b.norm(); }\n\n\t// Must be a unit vector; otherwise multiplies the result by abs(u)\n\tPoint rotate(const Point& u) const { return dot_cross(conj(u), *this); }\n\tPoint unrotate(const Point& u) const { return dot_cross(u, *this); }\n\n\tfriend bool same_dir(const Point& a, const Point& b) { return cross(a,b) == 0 && dot(a,b) > 0; }\n\n\t// check if 180 <= s..t < 360\n\tfriend bool is_reflex(const Point& a, const Point& b) { auto c = cross(a,b); return c ? (c < 0) : (dot(a, b) < 0); }\n\n\t// operator < (s,t) for angles in [base,base+2pi)\n\tfriend bool angle_less(const Point& base, const Point& s, const Point& t) {\n\t\tint r = is_reflex(base, s) - is_reflex(base, t);\n\t\treturn r ? (r < 0) : (0 < cross(s, t));\n\t}\n\n\tfriend auto angle_cmp(const Point& base) {\n\t\treturn [base](const Point& s, const Point& t) { return angle_less(base, s, t); };\n\t}\n\tfriend auto angle_cmp_center(const Point& center, const Point& dir) {\n\t\treturn [center, dir](const Point& s, const Point& t) -> bool { return angle_less(dir, s-center, t-center); };\n\t}\n\n\t// is p in [s,t] taken ccw? 1/0/-1 for in/border/out\n\tfriend int angle_between(const Point& s, const Point& t, const Point& p) {\n\t\tif (same_dir(p, s) || same_dir(p, t)) return 0;\n\t\treturn angle_less(s, p, t) ? 1 : -1;\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tusing pt_t = Point<int64_t>;\n\n\tint N; cin >> N;\n\tvector<pt_t> P(N);\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> P[i] >> A[i]; A[i]--;\n\t}\n\n\tvector<array<int, 2>> ops; ops.reserve(3*N);\n\n\tauto solve = [&]() -> void {\n\t\tint st = -1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (A[i] == i) continue;\n\t\t\tif (st == -1 || make_pair(P[i].x, P[i].y) < make_pair(P[st].x, P[st].y)) {\n\t\t\t\tst = i;\n\t\t\t}\n\t\t}\n\t\tif (st == -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvector<int> par(N, -1);\n\t\tauto get_par = [&](int a) -> int {\n\t\t\twhile (par[a] >= 0) {\n\t\t\t\tif (par[par[a]] >= 0) par[a] = par[par[a]];\n\t\t\t\ta = par[a];\n\t\t\t}\n\t\t\treturn a;\n\t\t};\n\t\tauto merge = [&](int a, int b) -> bool {\n\t\t\ta = get_par(a), b = get_par(b);\n\t\t\tif (a == b) return false;\n\t\t\tif (par[a] > par[b]) swap(a, b);\n\t\t\tpar[a] += par[b];\n\t\t\tpar[b] = a;\n\t\t\treturn true;\n\t\t};\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tmerge(i, A[i]);\n\t\t}\n\n\t\tvector<pair<pt_t, int>> pts; pts.reserve(N-1);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (A[i] == i) continue;\n\t\t\tif (i == st) continue;\n\t\t\tpts.push_back({P[i] - P[st], i});\n\t\t}\n\t\tsort(pts.begin(), pts.end(), [&](const auto& a, const auto& b) -> bool { return angle_less(pt_t(-1, 0), a.first, b.first); });\n\t\tfor (int i = 0; i+1 < int(pts.size()); i++) {\n\t\t\tint x = pts[i].second, y = pts[i+1].second;\n\t\t\tif (merge(x, y)) {\n\t\t\t\tops.push_back({x, y});\n\t\t\t\tswap(A[x], A[y]);\n\t\t\t}\n\t\t}\n\t\twhile (A[st] != st) {\n\t\t\tint b = A[st];\n\t\t\tops.push_back({st, b});\n\t\t\tswap(A[st], A[b]);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tassert(A[i] == i);\n\t\t}\n\t};\n\tsolve();\n\n\tcout << ops.size() << '\\n';\n\tfor (auto it : ops) {\n\t\tcout << it[0]+1 << ' ' << it[1]+1 << '\\n';\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "geometry",
        "sortings"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Swap Pass.json",
    "editorial_link": "https://codeforces.com//blog/entry/89644",
    "editorial": "As it turns out, it is always possible to find the required sequence, no\r\nmatter the position of the points in the plane and the initial\r\npermutation.It turns out that it\u00e2\u0080\u0099s pretty hard to analyze even\r\nparticular positions of the points, and it will be more convenient to\r\nstart by analyzing particular permutations instead. To this effect, we\r\nwill begin by doing two things: Ignore every such that initially . Since\r\nwe\u00e2\u0080\u0099ll prove that the sequence exists for any configuration anyway, they\r\ncan\u00e2\u0080\u0099t ever matter. Draw an arrow from point to point for each . This\r\ndivides the points into a bunch of cycles. Now we can make the following\r\nobservation: If we have any cycle, we can get all the balls in that\r\ncycle to their correct position by choosing any member in the cycle, and\r\nrepeatedly swap passing between and , without generating any\r\nintersections.This allows us to solve the problem for any position of\r\nthe points as long as the permutation has a single cycle. However, this\r\nwill generally not be the case. We can hope to deal with this by making\r\na second observation. If we have any two distinct cycles and any two\r\nmembers and in those two cycles, then swap passing between and will\r\nmerge both cycles.By combining both observations we can come up with the\r\nfollowing general idea to solve any case: First, perform swaps between\r\ndistinct cycles until all of the cycles merge into a single one. Then,\r\nmove all the balls to their correct positions as described in the first\r\nobservation. Now we just have to figure out how to perform these moves\r\nwithout having intersections between segments. It might be helpful to\r\nthink about the case when the points are vertices of a convex polygon\r\nfirst since it simplifies the model without sacrificing too much of the\r\ngeometry. Either way, we will describe only the general case.Consider\r\nany point, which we will use as a \"pivot\" for the operations at the end.\r\nNow, sort all of the other points by the angle of the segment between\r\nthem and the pivot point. Call the segments that join two consecutive\r\npoints in the ordering , and the segments between the pivot and the\r\nother points . Now we will just merge all the cycles by using border\r\nsegments and then move all the balls to their intended position by using\r\ncentral segments, this solves the problem.However, there\u00e2\u0080\u0099s one small\r\nspecial case that we might have to deal with depending on how we\u00e2\u0080\u0099re\r\nthinking about the problem: If the pivot point we chose is on the convex\r\nhull of the set of points, then one of the border segments may actually\r\nintersect some other segments! Luckily, we can easily prove that this\r\ncan\u00e2\u0080\u0099t happen for more than one of the segments, so our plan still works.\r\nThere are many different ways to deal with this case. From simplest to\r\nmost complicated: Always choose the bottom-most and left-most point as a\r\npivot. This makes this potentially troublesome segment predictable, and\r\nalso allows us to slightly simplify the angular sorting code. Discard\r\nthe problematic segment by looking at which pair of consecutive points\r\nmakes a clockwise turn instead of a counter-clockwise turn. Discard the\r\nproblematic segment by brute-force intersecting each border segment with\r\neach central segment. This increases our complexity to , but this is\r\nstill fine. Intentionally choose a pivot that is not on the convex hull\r\nand do something slightly different if the points are the vertices of a\r\nconvex polygon. Regardless of how we choose to deal with it, we can now\r\nsolve the problem with approximately operations in the worst case, and a\r\ntime complexity of either or depending on how we implement the solution.\r\n"
}