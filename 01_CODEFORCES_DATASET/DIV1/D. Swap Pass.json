{"link": "https://codeforces.com//contest/1508/problem/D", "problemId": "958784", "problem_idx": "D", "shortId": "1508D", "contest_number": "1508", "problem_submissions": {"D": [113258208, 113225842, 113232066, 113242382, 113242310, 113248310, 113252824, 113256393, 113240058, 113236672, 113233206, 113240165, 113242005, 113242817, 113243142], "F": [113247954, 113415583, 113275748, 113263512, 113569093, 113516939], "C": [113237315, 113213039, 113214478, 113213780, 113212574, 113213010, 113224842, 113226169, 113232722, 113215825, 113215542, 113224987, 113223453, 113228420, 113228228, 113217788, 113226078, 113229271, 113230097], "E": [113228353, 113239041, 113241831, 113228851, 113231701, 113244425, 113243109, 113247201, 113253919, 113253035, 113238610, 113246155, 113333091, 113246539, 113240797, 113246922], "A": [113201428, 113189518, 113189456, 113190605, 113198010, 113192641, 113194080, 113204739, 113207875, 113194317, 113200012, 113222414, 113194745, 113195037, 113199971, 113199286, 113193286, 113195565, 113191574, 113194231], "B": [113197951, 113196658, 113192904, 113196665, 113201215, 113199153, 113202442, 113210198, 113217372, 113203624, 113208530, 113197629, 113206458, 113203987, 113206383, 113212945, 113200476, 113197819, 113199529, 113200558]}, "name": "D. Swap Pass", "statement": "You are given n points on the plane, no three of which are collinear.\r\nThe i-th point initially has a label a_i, in such a way that the labels\r\na_1, a_2,\r\ndots, a_n form a permutation of 1, 2,\r\ndots, n.You are allowed to modify the labels through the following\r\noperation: Choose two distinct integers i and j between 1 and n. Swap\r\nthe labels of points i and j, and finally Draw the segment between\r\npoints i and j. A sequence of operations is valid if after applying all\r\nof the operations in the sequence in order, the k-th point ends up\r\nhaving the label k for all k between 1 and n inclusive, and the drawn\r\nsegments don\u2019t intersect each other internally. Formally, if two of the\r\nsegments intersect, then they must do so at a common endpoint of both\r\nsegments.In particular, all drawn segments must be distinct.Find any\r\nvalid sequence of operations, or say that none exist.\r\n", "solutions": ["#include <bits/stdc++.h>\n\ntemplate <typename T> struct Point {\npublic:\n\tT x, y;\n\tPoint() : x(0), y(0) {}\n\tPoint(T x_, T y_) : x(x_), y(y_) {}\n\ttemplate <typename U> explicit Point(const Point<U>& p) : x(p.x), y(p.y) {}\n\tPoint(const std::pair<T, T>& p) : x(p.first), y(p.second) {}\n\tPoint(const std::complex<T>& p) : x(real(p)), y(imag(p)) {}\n\texplicit operator std::pair<T, T> () const { return std::pair<T, T>(x, y); }\n\texplicit operator std::complex<T> () const { return std::complex<T>(x, y); }\n\n\tfriend std::ostream& operator << (std::ostream& o, const Point& p) { return o << '(' << p.x << ',' << p.y << ')'; }\n\tfriend std::istream& operator >> (std::istream& i, Point& p) { return i >> p.x >> p.y; }\n\tfriend bool operator == (const Point& a, const Point& b) { return a.x == b.x && a.y == b.y; }\n\tfriend bool operator != (const Point& a, const Point& b) { return !(a==b); }\n\n\tPoint operator + () const { return Point(+x, +y); }\n\tPoint operator - () const { return Point(-x, -y); }\n\n\tPoint& operator += (const Point& p) { x += p.x, y += p.y; return *this; }\n\tPoint& operator -= (const Point& p) { x -= p.x, y -= p.y; return *this; }\n\tPoint& operator *= (const T& t) { x *= t, y *= t; return *this; }\n\tPoint& operator /= (const T& t) { x /= t, y /= t; return *this; }\n\n\tfriend Point operator + (const Point& a, const Point& b) { return Point(a.x+b.x, a.y+b.y); }\n\tfriend Point operator - (const Point& a, const Point& b) { return Point(a.x-b.x, a.y-b.y); }\n\tfriend Point operator * (const Point& a, const T& t) { return Point(a.x*t, a.y*t); }\n\tfriend Point operator * (const T& t ,const Point& a) { return Point(t*a.x, t*a.y); }\n\tfriend Point operator / (const Point& a, const T& t) { return Point(a.x/t, a.y/t); }\n\n\tT dist2() const { return x * x + y * y; }\n\tauto dist() const { return std::sqrt(dist2()); }\n\tPoint unit() const { return *this / this->dist(); }\n\tauto angle() const { return std::atan2(y, x); }\n\n\tT int_norm() const { return __gcd(x,y); }\n\tPoint int_unit() const { if (!x && !y) return *this; return *this / this->int_norm(); }\n\n\t// Convenient free-functions, mostly for generic interop\n\tfriend auto norm(const Point& a) { return a.dist2(); }\n\tfriend auto abs(const Point& a) { return a.dist(); }\n\tfriend auto unit(const Point& a) { return a.unit(); }\n\tfriend auto arg(const Point& a) { return a.angle(); }\n\tfriend auto int_norm(const Point& a) { return a.int_norm(); }\n\tfriend auto int_unit(const Point& a) { return a.int_unit(); }\n\n\tPoint perp_cw() const { return Point(y, -x); }\n\tPoint perp_ccw() const { return Point(-y, x); }\n\n\tfriend T dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n\tfriend T cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n\tfriend T cross3(const Point& a, const Point& b, const Point& c) { return cross(b-a, c-a); }\n\n\t// Complex numbers and rotation\n\tfriend Point conj(const Point& a) { return Point(a.x, -a.y); }\n\n\t// Returns conj(a) * b\n\tfriend Point dot_cross(const Point& a, const Point& b) { return Point(dot(a, b), cross(a, b)); }\n\tfriend Point cmul(const Point& a, const Point& b) { return dot_cross(conj(a), b); }\n\tfriend Point cdiv(const Point& a, const Point& b) { return dot_cross(b, a) / b.norm(); }\n\n\t// Must be a unit vector; otherwise multiplies the result by abs(u)\n\tPoint rotate(const Point& u) const { return dot_cross(conj(u), *this); }\n\tPoint unrotate(const Point& u) const { return dot_cross(u, *this); }\n\n\tfriend bool same_dir(const Point& a, const Point& b) { return cross(a,b) == 0 && dot(a,b) > 0; }\n\n\t// check if 180 <= s..t < 360\n\tfriend bool is_reflex(const Point& a, const Point& b) { auto c = cross(a,b); return c ? (c < 0) : (dot(a, b) < 0); }\n\n\t// operator < (s,t) for angles in [base,base+2pi)\n\tfriend bool angle_less(const Point& base, const Point& s, const Point& t) {\n\t\tint r = is_reflex(base, s) - is_reflex(base, t);\n\t\treturn r ? (r < 0) : (0 < cross(s, t));\n\t}\n\n\tfriend auto angle_cmp(const Point& base) {\n\t\treturn [base](const Point& s, const Point& t) { return angle_less(base, s, t); };\n\t}\n\tfriend auto angle_cmp_center(const Point& center, const Point& dir) {\n\t\treturn [center, dir](const Point& s, const Point& t) -> bool { return angle_less(dir, s-center, t-center); };\n\t}\n\n\t// is p in [s,t] taken ccw? 1/0/-1 for in/border/out\n\tfriend int angle_between(const Point& s, const Point& t, const Point& p) {\n\t\tif (same_dir(p, s) || same_dir(p, t)) return 0;\n\t\treturn angle_less(s, p, t) ? 1 : -1;\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tusing pt_t = Point<int64_t>;\n\n\tint N; cin >> N;\n\tvector<pt_t> P(N);\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> P[i] >> A[i]; A[i]--;\n\t}\n\n\tvector<array<int, 2>> ops; ops.reserve(3*N);\n\n\tauto solve = [&]() -> void {\n\t\tint st = -1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (A[i] == i) continue;\n\t\t\tif (st == -1 || make_pair(P[i].x, P[i].y) < make_pair(P[st].x, P[st].y)) {\n\t\t\t\tst = i;\n\t\t\t}\n\t\t}\n\t\tif (st == -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvector<int> par(N, -1);\n\t\tauto get_par = [&](int a) -> int {\n\t\t\twhile (par[a] >= 0) {\n\t\t\t\tif (par[par[a]] >= 0) par[a] = par[par[a]];\n\t\t\t\ta = par[a];\n\t\t\t}\n\t\t\treturn a;\n\t\t};\n\t\tauto merge = [&](int a, int b) -> bool {\n\t\t\ta = get_par(a), b = get_par(b);\n\t\t\tif (a == b) return false;\n\t\t\tif (par[a] > par[b]) swap(a, b);\n\t\t\tpar[a] += par[b];\n\t\t\tpar[b] = a;\n\t\t\treturn true;\n\t\t};\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tmerge(i, A[i]);\n\t\t}\n\n\t\tvector<pair<pt_t, int>> pts; pts.reserve(N-1);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (A[i] == i) continue;\n\t\t\tif (i == st) continue;\n\t\t\tpts.push_back({P[i] - P[st], i});\n\t\t}\n\t\tsort(pts.begin(), pts.end(), [&](const auto& a, const auto& b) -> bool { return angle_less(pt_t(-1, 0), a.first, b.first); });\n\t\tfor (int i = 0; i+1 < int(pts.size()); i++) {\n\t\t\tint x = pts[i].second, y = pts[i+1].second;\n\t\t\tif (merge(x, y)) {\n\t\t\t\tops.push_back({x, y});\n\t\t\t\tswap(A[x], A[y]);\n\t\t\t}\n\t\t}\n\t\twhile (A[st] != st) {\n\t\t\tint b = A[st];\n\t\t\tops.push_back({st, b});\n\t\t\tswap(A[st], A[b]);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tassert(A[i] == i);\n\t\t}\n\t};\n\tsolve();\n\n\tcout << ops.size() << '\\n';\n\tfor (auto it : ops) {\n\t\tcout << it[0]+1 << ' ' << it[1]+1 << '\\n';\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "geometry", "sortings"], "dificulty": "3000", "interactive": false}