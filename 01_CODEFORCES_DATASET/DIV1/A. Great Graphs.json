{
    "link": "https://codeforces.com//contest/1540/problem/A",
    "problemId": "1027086",
    "problem_idx": "A",
    "shortId": "1540A",
    "contest_number": "1540",
    "problem_submissions": {
        "E": [
            158665487,
            120671889,
            120671130,
            120611380
        ],
        "C2": [
            120605147,
            120568544,
            120579011,
            120588964,
            120605073,
            120569097,
            120574747,
            120608479,
            120579015,
            120598713,
            120577744,
            120597136,
            120595479,
            120616218,
            120596815,
            120598287
        ],
        "D": [
            120591057,
            120602670,
            120602293,
            120600949,
            120589579,
            120610881,
            120604354,
            120600348,
            120595403,
            120583946,
            120609085,
            120608380,
            120703598,
            120703586,
            120698836,
            120593678,
            120637556,
            120637415
        ],
        "C1": [
            120567535,
            120561594,
            120567326,
            120573306,
            120596169,
            120563211,
            120564500,
            120604433,
            120607536,
            120590343,
            120588571,
            120578785,
            120575407,
            120560194,
            120579656,
            120577149,
            120580975,
            120582010
        ],
        "B": [
            120551949,
            120542169,
            120552393,
            120556326,
            120559167,
            120545883,
            120578567,
            120557279,
            120559926,
            120559208,
            120581683,
            120555741,
            120556140,
            120587344,
            120581865,
            120550352,
            120557511,
            120561248,
            120559894
        ],
        "A": [
            120538111,
            120534681,
            120538291,
            120538440,
            120536907,
            120535163,
            120537026,
            120546671,
            120535419,
            120535827,
            120537631,
            120535887,
            120540241,
            120536295,
            120551816,
            120535724,
            120539352,
            120540330,
            120541623
        ]
    },
    "name": "A. Great Graphs",
    "statement": "Farmer John has a farm that consists of n pastures connected by\r\none-directional roads. Each road has a weight, representing the time it\r\ntakes to go from the start to the end of the road. The roads could have\r\nnegative weight, where the cows go so fast that they go back in time!\r\nHowever, Farmer John guarantees that it is impossible for the cows to\r\nget stuck in a time loop, where they can infinitely go back in time by\r\ntraveling across a sequence of roads. Also, each pair of pastures is\r\nconnected by at most one road in each direction.Unfortunately, Farmer\r\nJohn lost the map of the farm. All he remembers is an array d, where d_i\r\nis the smallest amount of time it took the cows to reach the i-th\r\npasture from pasture 1 using a sequence of roads. The cost of his farm\r\nis the sum of the weights of each of the roads, and Farmer John needs to\r\nknow the cost of a farm that is consistent with his memory.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//デバッグ実行でオーバーフローするとコアダンプしがち\n\nusing int128=__int128_t;\nusing uint128=unsigned __int128_t;\n\nistream& operator>>(istream&is,int128&res){\n\tres=0;\n\tstring s;is>>s;\n\tint head=0;\n\tint128 w=1;\n\tif(s[0]=='-'){\n\t\tw=-1;\n\t\thead++;\n\t}\n\twhile(head<int(s.size())){\n\t\tres=res*10+s[head++]-'0';\n\t}\n\tres*=w;\n\treturn is;\n}\nostream& operator<<(ostream&os,int128 i){\n\tif(i==0)\n\t\treturn os<<0;\n\tstatic char buf[100];\n\tif(i<0){\n\t\tos<<\"-\";\n\t\ti=-i;\n\t}\n\tint p=0;\n\twhile(i){\n\t\tbuf[p++]='0'+i%10;\n\t\ti/=10;\n\t}\n\treverse(buf,buf+p);\n\tbuf[p]=0;\n\treturn os<<buf;\n}\nint128 abs128(int128 a){\n\treturn a<0?-a:a;\n}\nint botbit(int128 a){\n\tconst int128 m=(int128(1)<<64)-1;\n\tif(a&m)return __builtin_ctzll(ll(a));\n\telse return __builtin_ctzll(ll(a>>64));\n}\nint128 gcd(int128 a,int128 b){\n\tif(a<0)a=-a;\n\tif(b<0)b=-b;\n\tif(a==0)return b;\n\tif(b==0)return a;\n\tint128 s=botbit(a|b);\n\ta>>=botbit(a);\n\tdo{\n\t\tb>>=botbit(b);\n\t\tif(a>b)swap(a,b);\n\t\tb-=a;\n\t}while(b);\n\treturn a<<s;\n}\nconst int128 inf128=int128(1)<<122;\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tsort(all(a));\n\tint128 ans=0;\n\t\n\tint sum=0;\n\trep(i,n){\n\t\tans+=a[i]*i-sum;\n\t\tsum+=a[i];\n\t}\n\tans-=a[n-1];\n\t\n\tcout<<-ans<<endl;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy",
        "shortest paths",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Great Graphs.json",
    "editorial_link": "https://codeforces.com//blog/entry/92199",
    "editorial": "Note that if there are two nodes and and you want to add an edge between\r\nthem, the value of the edge be . Otherwise, the cows could take a path\r\nto that goes through thatâs strictly less than . With this in mind,\r\nletâs add all edges with weight if and only if . All of these numbers\r\nare not positive, which means they canât make our answer worse. They\r\nalso donât change the shortest paths, from our first observation. Now,\r\nletâs call the node with the max node . You can add a single edge from\r\nnode to node with cost , and now the graph is good. This is because node\r\nis already connected to all other nodes, which means there is always a\r\nshortest path to some node with the right length by going from .\r\nHowever, naively looping through all pairs is too slow. Instead, you can\r\nsort and calculate the contribution of each node to the answer. The\r\ncomplexity is .\r\n",
    "hint": [
        "Hint What's the minimum value that an edge from to can be?",
        "Hint Use edges with negative value whenever you can.",
        "Hint The sum of the values of edges with positive weight must be the maximum value in the array."
    ]
}