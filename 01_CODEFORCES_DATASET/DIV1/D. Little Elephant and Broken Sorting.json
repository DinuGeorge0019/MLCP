{
    "link": "https://codeforces.com//contest/258/problem/D",
    "problemId": "2445",
    "problem_idx": "D",
    "shortId": "258D",
    "contest_number": "258",
    "problem_submissions": {
        "D": [
            2814736,
            2812430,
            2814871,
            2814961,
            2812733,
            2815597,
            2815735,
            3321861,
            2817362,
            2813664,
            2817783,
            2816087,
            2814924
        ],
        "E": [
            2813546,
            2815005,
            2813362,
            2813842,
            2813877,
            2813261,
            2811449,
            2814046,
            2814079,
            2814422,
            2814320,
            2814528,
            2814704,
            2817438,
            2817366,
            2817363,
            2817357,
            2817344,
            2817287,
            2817270,
            2814834
        ],
        "C": [
            2811749,
            2809654,
            2812462,
            2812301,
            2814561,
            2810964,
            2812259,
            2812879,
            2811632,
            2812613,
            2812711,
            2812609,
            2811716,
            2810788,
            2813202,
            2812348,
            2813127
        ],
        "B": [
            2809756,
            2813180,
            2810688,
            2811171,
            2811678,
            2809679,
            2814549,
            2809883,
            2810504,
            2810872,
            2811182,
            2813077,
            2812214,
            2811807,
            2810280,
            2810608
        ],
        "A": [
            2807475,
            2810109,
            2807417,
            2807993,
            2807422,
            2807498,
            2807514,
            2808316,
            2807507,
            2807423,
            2807995,
            2807416,
            2807421,
            2807426,
            2807559
        ]
    },
    "name": "D. Little Elephant and Broken Sorting",
    "statement": "The Little Elephant loves permutations of integers from to very much.\r\nBut most of all he loves sorting them. To sort a permutation, the Little\r\nElephant repeatedly swaps some elements. As a result, he must receive a\r\npermutation .This time the Little Elephant has permutation . Its sorting\r\nprogram needs to make exactly moves, during the -th move it swaps\r\nelements that are at that moment located at the -th and the -th\r\npositions. But the Little Elephant\u2019s sorting program happened to break\r\ndown and now on every step it can equiprobably either do nothing or swap\r\nthe required elements.Now the Little Elephant doesn\u2019t even hope that the\r\nprogram will sort the permutation, but he still wonders: if he runs the\r\nprogram and gets some permutation, how much will the result of sorting\r\nresemble the sorted one? For that help the Little Elephant find the\r\nmathematical expectation of the number of permutation inversions after\r\nall moves of the program are completed.We\u2019ll call a pair of integers an\r\nin permutatuon , if the following inequality holds: .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n\nconst int N = 1000;\n\nint n, m, p[N], a[N], b[N];\ndouble prob[N][N];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d\", p + i);\n    }\n    for (int i = 0; i < m; ++ i) {\n        scanf(\"%d%d\", a + i, b + i);\n        a[i] --;\n        b[i] --;\n    }\n    for (int i = 0; i < n; ++ i) {\n        for (int j = 0; j < n; ++ j) {\n            prob[i][j] = i < j ? 1.0 : 0.0;\n        }\n    }\n    for (int k = m - 1; k >= 0; -- k) {\n        int u = a[k];\n        int v = b[k];\n        for (int i = 0; i < n; ++ i) {\n            if (i != u && i != v) {\n                prob[i][u] = prob[i][v] = (prob[i][u] + prob[i][v]) / 2.0;\n                prob[u][i] = prob[v][i] = (prob[u][i] + prob[v][i]) / 2.0;\n            }\n        }\n        prob[u][v] = prob[v][u] = (prob[u][v] + prob[v][u]) / 2.0;\n    }\n    double answer = 0;\n    for (int i = 0; i < n; ++ i) {\n        for (int j = 0; j < n; ++ j) {\n            if (p[i] > p[j]) {\n                answer += prob[i][j];\n            }\n        }\n    }\n    printf(\"%.10f\\n\", answer);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Little Elephant and Broken Sorting.json",
    "editorial_link": "https://codeforces.com//blog/entry/6213",
    "editorial": "Very useful thing in this problem is ordering all vertices in DFS order (preorped). After that any subtree can be represented as a some sequence of continuous vertices. Consider that we have some fixed vertex v. Which vertices should be included in cv? Obviously, if in the path from the root to v is some non-empty vertex (i. e. such that has at least one integer in its list) than each vertex from substree v should be included in ci, but since we now working with preorder traversal of the tree, we consider that every vertex from some segment [lv,?rv] must be included to ci. More generally, let for each vertex keep some set of segments (lk;rk). If on the i-th operation we have two vertices a and b, we add segment (lb;rb) to vertex a, and (la;ra) to vertex b. Also for each vertex i (i?=?1..n) we add segment (li;ri), where (li;ri) is a segment in our preored traversal for subtree i. After that, you can see that, if we unite all segments from all vertices on the path from the root to some vertex v, we find the result for v, which will be the size of the resulting set.\n\nSo now we need some data structure that would support three operations: add(l, r), subtract(l, r), count(). The first one should add 1 to all positions from l to r, inclusive. The second should subtract 1 from all positions from l to r, inclusive. The last should count the number of non-zero element. This all can be done either with segment tree or sqrt-decomposition."
}