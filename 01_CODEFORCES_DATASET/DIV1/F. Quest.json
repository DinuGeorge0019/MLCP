{
    "link": "https://codeforces.com//contest/542/problem/F",
    "problemId": "27154",
    "problem_idx": "F",
    "shortId": "542F",
    "contest_number": "542",
    "problem_submissions": {
        "E": [
            10988594,
            10988662,
            10988040,
            10988519,
            10989472,
            10986646,
            10986386,
            10987525,
            10987889,
            10997446,
            10987208,
            10988323,
            10987814
        ],
        "A": [
            10988183,
            10988073,
            10988917,
            10988039,
            10988066,
            10988030,
            10988339,
            10987042,
            10988676,
            10988761,
            10989522,
            10985841,
            10987459,
            10994455
        ],
        "D": [
            10986695,
            10987150,
            10987152,
            10986150,
            10986231,
            10986943,
            10990837,
            10988365,
            10989849,
            10993982,
            11035792,
            11035777,
            11035767,
            11035727,
            10990386,
            10992159,
            10990340,
            10990120,
            10987703,
            10987627
        ],
        "F": [
            10986005,
            10986369,
            10987577,
            10990309,
            10986553,
            10985927,
            10987236,
            10985531,
            10987038,
            10986965,
            10986721,
            10986640,
            10986454,
            10985938,
            10985827,
            10985838,
            10986342,
            10986368
        ],
        "C": [
            10985518,
            10985721,
            10985435,
            10985462,
            10985406,
            10986200,
            10986782,
            10986530,
            10985521,
            10986222,
            10986134,
            10985353,
            10985405,
            10985560,
            10985649,
            10985787
        ],
        "B": [
            10996302,
            11060742,
            11054057
        ]
    },
    "name": "F. Quest",
    "statement": "Polycarp is making a quest for his friends. He has already made tasks,\r\nfor each task the boy evaluated how interesting it is as an integer ,\r\nand the time in minutes needed to complete the task. An interesting\r\nfeature of his quest is: each participant should get the task that is\r\nbest suited for him, depending on his preferences. The task is chosen\r\nbased on an interactive quiz that consists of some questions. The player\r\nshould answer these questions with \"yes\" or \"no\". Depending on the\r\nanswer to the question, the participant either moves to another question\r\nor goes to one of the tasks that are in the quest. In other words, the\r\nquest is a binary tree, its nodes contain questions and its leaves\r\ncontain tasks. We know that answering any of the questions that are\r\nasked before getting a task takes exactly one minute from the quest\r\nplayer. Polycarp knows that his friends are busy people and they can\u2019t\r\nparticipate in the quest for more than minutes. Polycarp wants to choose\r\nsome of the tasks he made, invent the corresponding set of questions for\r\nthem and use them to form an interactive quiz as a binary tree so that\r\nno matter how the player answers quiz questions, he spends at most\r\nminutes on completing the whole quest (that is, answering all the\r\nquestions and completing the task). Specifically, the quest can contain\r\nzero questions and go straight to the task. Each task can only be used\r\nonce (i.e., the people who give different answers to questions should\r\nget different tasks).Polycarp wants the total \"interest\" value of the\r\ntasks involved in the quest to be as large as possible. Help him\r\ndetermine the maximum possible total interest value of the task\r\nconsidering that the quest should be completed in minutes at any variant\r\nof answering questions.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1100;\n\nint N, T;\nvector <int> qposs[MAXN];\nint dp[MAXN];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    \n    cin >> N >> T;\n    for (int i = 0; i < N; i++)\n    {\n        int t, q;\n        cin >> t >> q;\n        qposs[t].push_back (q);\n    }\n    \n    for (int i = 0; i < MAXN; i++)\n        dp[i] = 0;\n    \n    for (int i = 0; i <= T; i++)\n    {\n        for (int j = 1; j <= N; j++)\n            if (j * 2 > N + 3)\n                dp[j] = 0;\n            else\n                dp[j] = max (dp[2*j-1], dp[2*j]);\n        \n        for (int j = 0; j < qposs[i].size(); j++)\n        {\n            int cval = qposs[i][j];\n            for (int k = N; k > 0; k--)\n                dp[k] = max (dp[k], dp[k-1] + cval);\n        }\n    }\n    \n    cout << max (0, dp[1]) << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Quest.json",
    "editorial_link": "https://codeforces.com//blog/entry/17697",
    "editorial": "This task can be solved in lot of ways. The most straightforward is DP.\r\nThe task can be seen in the following way. We want some set of vertices\r\nas leaves and for each potential leaf we know the upper bound for its\r\ndepth and its cost. Let\u00e2\u0080\u0099s sweep over the tree from down to up. Let\u00e2\u0080\u0099s\r\ncalculate the value that is the maximum possible cost that we can\r\nachieve if we stay on the level and have vertices on it. For transition\r\nlet\u00e2\u0080\u0099s fix how many leaves of the deepness exactly we will take (it\u00e2\u0080\u0099s\r\neasy to see that among them we should task several greatest). Suppose we\r\nwill take of them. Then from this state we can move to . The answer will\r\nbe located in because when we are on the level we should have the only\r\nvertex that is the root of the tree. The complexity of such solution is\r\n. Challenge Improve the solution above to and then to\r\n"
}