{
    "link": "https://codeforces.com//contest/1129/problem/E",
    "problemId": "303021",
    "problem_idx": "E",
    "shortId": "1129E",
    "contest_number": "1129",
    "problem_submissions": {
        "D": [
            50457140,
            50468228,
            50468213,
            50452551,
            50784588,
            50784524,
            50784516,
            50784486,
            50455866,
            50463030,
            50451241,
            50455843,
            50456518,
            50444260,
            50455126,
            50471374,
            50469822,
            50469757,
            50469734,
            50469338,
            50469151,
            50468662,
            50468322,
            50468273,
            50465415,
            50464634,
            50455747,
            50457843,
            50458250,
            50464059,
            50449299,
            50457330
        ],
        "E": [
            50451183,
            50458483,
            50460101,
            50455688,
            50458301,
            75936467,
            50458791
        ],
        "C": [
            50447279,
            50446245,
            50449561,
            50445538,
            50440385,
            50445043,
            50447738,
            50448032,
            50454787,
            50450606,
            50457517,
            58851047,
            58850895,
            50459942,
            50451465,
            50454057,
            50448457,
            50449663
        ],
        "B": [
            50443936,
            50443531,
            50442156,
            50441155,
            50445396,
            50439298,
            50442768,
            50443504,
            50459278,
            50443656,
            50448178,
            50451750,
            50447513,
            50459190,
            50456796,
            50442875,
            50451493
        ],
        "A1": [
            50438306,
            50436838,
            50435800,
            50454577,
            50434391,
            50434469,
            50436959,
            50437853,
            50449686,
            50439524,
            50436300,
            50436664,
            50460719,
            50444960,
            50438530,
            50438635,
            50437445
        ],
        "A2": [
            50438193,
            50437084,
            50435385,
            50454632,
            50434194,
            50434343,
            50437228,
            50438028,
            50449587,
            50439649,
            50436143,
            50436524,
            50460819,
            50444992,
            50438364,
            50437253,
            50437622
        ]
    },
    "name": "E. Legendary Tree",
    "statement": "A legendary tree rests deep in the forest. Legend has it that\r\nindividuals who realize this tree would eternally become a Legendary\r\nGrandmaster.To help you determine the tree, Mikaela the Goddess has\r\nrevealed to you that the tree contains n vertices, enumerated from 1\r\nthrough n. She also allows you to ask her some questions as follows. For\r\neach question, you should tell Mikaela some two non-empty sets of\r\nvertices S and T, along with any vertex v that you like. Then, Mikaela\r\nwill count and give you the number of pairs of vertices (s, t) where s\r\nin S and t\r\nin T such that the simple path from s to t contains v.Mikaela the\r\nGoddess is busy and will be available to answer at most 11\r\n,111 questions.This is your only chance. Your task is to determine the\r\ntree and report its edges.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint N;\n\nint Ask(VI S, VI T, int v) {\n  if (SZ(S) == 0 || SZ(T) == 0) { return 0; }\n\n  cout << SZ(S) << \"\\n\";\n  for (int x : S) { cout << x << \" \"; }\n  cout << \"\\n\";\n  cout << SZ(T) << \"\\n\";\n  for (int x : T) { cout << x << \" \"; }\n  cout << \"\\n\";\n  cout << v << endl;\n\n  int ans;\n  cin >> ans;\n  return ans;\n}\n\nint FindAnySub(int v, set<int> remaining_set) {\n  remaining_set.erase(v);\n\n  vector<int> remaining(ALL(remaining_set));\n  debug(v, remaining);\n  if (Ask(VI{1}, remaining, v) == 0) { return -1; }\n\n  function<int(int,int)> Rec = [&](int L, int R) {\n    if (L == R - 1) {\n      return L;\n    }\n\n    const int mid = (L + R) / 2;\n    if (Ask(VI{1}, VI(remaining.begin() + L, remaining.begin() + mid), v)) {\n      return Rec(L, mid);\n    } else {\n      return Rec(mid, R);\n    }\n  };\n\n  const int S = SZ(remaining);\n  return remaining[Rec(0, S)];\n}\n\nint32_t main() {\n  cin >> N;\n\n  vector<int> tree_sizes(N + 1);\n  VI without_1;\n  for (int v = 2; v <= N; ++v) { without_1.PB(v); }\n\n  tree_sizes[1] = N;\n  for (int v = 2; v <= N; ++v) {\n    tree_sizes[v] = Ask(VI{1}, without_1, v);\n  }\n\n  VI order = without_1;\n  order.PB(1);\n  sort(ALL(order), [&](int lhs, int rhs) {\n        return tree_sizes[lhs] < tree_sizes[rhs];\n      });\n\n  debug(tree_sizes, order);\n\n  vector<PII> answer;\n  set<int> unconnected_verts(ALL(without_1));\n  for (int v : order) {\n    if (tree_sizes[v] == 1) { continue; }\n\n    while (true) {\n      int s = FindAnySub(v, unconnected_verts);\n      if (s == -1) { break; }\n      answer.emplace_back(v, s);\n      debug(v, s);\n      unconnected_verts.erase(s);\n    }\n  }\n\n  cout << \"ANSWER\" << endl;\n  for (auto [u, v] : answer) { cout << u << \" \" << v << endl; }\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "interactive",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Legendary Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/65520",
    "editorial": "In this analysis, let be the set of all vertices. We will use tuples of\r\nthe form to represent queries. First, we will root the tree at vertex .\r\nThe size of each subtree can be found in queries by asking , for each\r\n.Suppose denotes the size of the subtree rooted at vertex . Let us sort\r\nthe vertices (and store the results in ) so that for each .We will find\r\nall children of each vertex in the ascending order of . While we do so,\r\nwe will maintain a set , initially containing only . It will store the\r\nprocessed-so-far vertices whose parents have not been found.Namely, for\r\neach : Let . This is the number of direct children that has. Let be the\r\nvertices in in an arbitrary order. For times: binary search to find the\r\nsmallest such that querying returns a non-zero result and remove from .\r\nFor each such , we know that there is an edge . Add to . This solution\r\nasks at most queries.Time complexity:\r\n"
}