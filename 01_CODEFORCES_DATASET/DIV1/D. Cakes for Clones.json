{"link": "https://codeforces.com//contest/1456/problem/D", "problemId": "814139", "problem_idx": "D", "shortId": "1456D", "contest_number": "1456", "problem_submissions": {"E": [99945782, 99945769, 99943961, 99943904, 99943880, 99873391, 99943557, 99954051], "D": [99891549, 99889664, 99863279, 99878437, 99869286, 99874783, 99874448, 100422602, 99869392, 99876033, 99880017, 99873016, 99879341, 99881425, 99901920, 99901451, 99880281, 99883086, 99883614, 99883199, 99862733, 99895776, 99881158, 99886907], "C": [99848424, 99849677, 99857483, 99857864, 99851459, 99859071, 100422587, 99858400, 99858652, 99852406, 99861212, 99863136, 99859584, 99860765, 99858493, 99859743, 99856324, 99876682, 99869205, 99867241], "B": [99844017, 99851835, 99850170, 99846295, 99847821, 99846905, 100422569, 99849394, 99851833, 99847449, 99854585, 99849459, 99854424, 99841592, 99848884, 99849963, 99842794, 99879792, 99851060, 99853174], "A": [99840628, 99840575, 99844401, 99841761, 100523512, 99844053, 99842901, 100422550, 99843639, 99845108, 99841813, 99849319, 99843116, 99843583, 99849152, 99843890, 99842869, 99850296, 99867700, 99845589, 99842066]}, "name": "D. Cakes for Clones", "statement": "You live on a number line. You are initially (at time moment t = 0)\r\nlocated at point x = 0. There are n events of the following type: at\r\ntime t_i a small cake appears at coordinate x_i. To collect this cake,\r\nyou have to be at this coordinate at this point, otherwise the cake\r\nspoils immediately. No two cakes appear at the same time and no two\r\ncakes appear at the same coordinate.You can move with the speed of 1\r\nlength unit per one time unit. Also, at any moment you can create a\r\nclone of yourself at the same point where you are located. The clone\r\ncan\u2019t move, but it will collect the cakes appearing at this position for\r\nyou. The clone when you create another clone. If the new clone is\r\ncreated at time moment t, the old clone can collect the cakes that\r\nappear before or at the time moment t, and the new clone can collect the\r\ncakes that appear at or after time moment t.Can you collect all the\r\ncakes (by yourself or with the help of clones)?\r\n", "solutions": ["#include <bits/stdc++.h>\n\ntemplate <typename T, int NDIMS> struct tensor_view {\n\tstatic_assert(NDIMS >= 0, \"NDIMS must be nonnegative\");\n\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tT* data;\n\n\ttensor_view(std::array<int, NDIMS> shape_, std::array<int, NDIMS> strides_, T* data_) : shape(shape_), strides(strides_), data(data_) {}\n\npublic:\n\ttensor_view() : shape{0}, strides{0}, data(nullptr) {}\n\nprotected:\n\tint flatten_index(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) { res += idx[i] * strides[i]; }\n\t\treturn res;\n\t}\n\tint flatten_index_checked(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) {\n\t\t\tassert(0 <= idx[i] && idx[i] < shape[i]);\n\t\t\tres += idx[i] * strides[i];\n\t\t}\n\t\treturn res;\n\t}\n\npublic:\n\tT& operator[] (std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index(idx)];\n\t}\n\tT& at(std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index_checked(idx)];\n\t}\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<T, NDIMS-1>>::type operator[] (int idx) const {\n\t\tstd::array<int, NDIMS-1> nshape; std::copy(shape.begin()+1, shape.end(), nshape.begin());\n\t\tstd::array<int, NDIMS-1> nstrides; std::copy(strides.begin()+1, strides.end(), nstrides.begin());\n\t\tT* ndata = data + (strides[0] * idx);\n\t\treturn tensor_view<T, NDIMS-1>(nshape, nstrides, ndata);\n\t}\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<T, NDIMS-1>>::type at(int idx) const {\n\t\tassert(0 <= idx && idx < shape[0]);\n\t\treturn operator[](idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 == D), T&>::type operator * () const {\n\t\treturn *data;\n\t}\n\n\ttemplate <typename U, int D> friend struct tensor_view;\n\ttemplate <typename U, int D> friend struct tensor;\n};\n\ntemplate <typename T, int NDIMS> struct tensor {\n\tstatic_assert(NDIMS >= 0, \"NDIMS must be nonnegative\");\n\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tint len;\n\tT* data;\n\npublic:\n\ttensor() : shape{0}, strides{0}, len(0), data(nullptr) {}\n\n\texplicit tensor(std::array<int, NDIMS> shape_, const T& t = T()) {\n\t\tshape = shape_;\n\t\tstrides[NDIMS-1] = 1;\n\t\tfor (int i = NDIMS-1; i > 0; i--) {\n\t\t\tstrides[i-1] = strides[i] * shape[i];\n\t\t}\n\t\tlen = strides[0] * shape[0];\n\t\tdata = new T[len];\n\t\tstd::fill(data, data + len, t);\n\t}\n\n\ttensor(const tensor& o) : shape(o.shape), strides(o.strides), len(o.len), data(new T[len]) {\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tdata[i] = o.data[i];\n\t\t}\n\t}\n\n\ttensor& operator=(tensor&& o) noexcept {\n\t\tusing std::swap;\n\t\tswap(shape, o.shape);\n\t\tswap(strides, o.strides);\n\t\tswap(len, o.len);\n\t\tswap(data, o.data);\n\t\treturn *this;\n\t}\n\ttensor(tensor&& o) : tensor() {\n\t\t*this = std::move(o);\n\t}\n\ttensor& operator=(const tensor& o) {\n\t\treturn *this = tensor(o);\n\t}\n\t~tensor() { delete[] data; }\n\n\tusing view_t = tensor_view<T, NDIMS>;\n\tview_t view() {\n\t\treturn tensor_view<T, NDIMS>(shape, strides, data);\n\t}\n\toperator view_t() {\n\t\treturn view();\n\t}\n\n\tusing const_view_t = tensor_view<const T, NDIMS>;\n\tconst_view_t view() const {\n\t\treturn tensor_view<const T, NDIMS>(shape, strides, data);\n\t}\n\toperator const_view_t() const {\n\t\treturn view();\n\t}\n\n\tT& operator[] (std::array<int, NDIMS> idx) { return view()[idx]; }\n\tT& at(std::array<int, NDIMS> idx) { return view().at(idx); }\n\tconst T& operator[] (std::array<int, NDIMS> idx) const { return view()[idx]; }\n\tconst T& at(std::array<int, NDIMS> idx) const { return view().at(idx); }\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<T, NDIMS-1>>::type operator[] (int idx) {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<T, NDIMS-1>>::type at(int idx) {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<const T, NDIMS-1>>::type operator[] (int idx) const {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<const T, NDIMS-1>>::type at(int idx) const {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 == D), T&>::type operator * () {\n\t\treturn *view();\n\t}\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 == D), const T&>::type operator * () const {\n\t\treturn *view();\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N; cin >> N; N++;\n\tvector<array<int64_t, 2>> cakes(N+1);\n\tcakes[0] = {0,0};\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> cakes[i][0] >> cakes[i][1];\n\t}\n\n\tconst int INF = int(1e9) + 200;\n\t// earliest you can put a clone at i after having finished 0..i-1\n\tvector<int64_t> clone_time(N, INF);\n\tclone_time[0] = 0;\n\n\t// can you reach i with a clone at j (j > i)\n\ttensor<bool, 2> can_reach({N, N}, false);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (clone_time[i] <= cakes[i][0]) {\n\t\t\t// where do we go next? put a clone somewhere\n\t\t\tif (i == N-1) {\n\t\t\t\tcout << \"YES\" << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\t// clone the next guy\n\t\t\tclone_time[i+1] = min(clone_time[i+1], max(cakes[i][0], clone_time[i] + abs(cakes[i][1] - cakes[i+1][1])));\n\t\t\tfor (int j = i+2; j < N; j++) {\n\t\t\t\tif (max(cakes[i][0], clone_time[i] + abs(cakes[i][1] - cakes[j][1])) + abs(cakes[j][1] - cakes[i+1][1]) <= cakes[i+1][0]) {\n\t\t\t\t\tcan_reach[{i+1, j}] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = i+1; j < N; j++) {\n\t\t\tif (!can_reach[{i,j}]) continue;\n\t\t\tif (j == i+1) {\n\t\t\t\tif (j == N-1) {\n\t\t\t\t\tcout << \"YES\" << '\\n';\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\t// clone the next guy\n\t\t\t\tclone_time[i+2] = min(clone_time[i+2], max(cakes[j][0], cakes[i][0] + abs(cakes[i][1] - cakes[i+2][1])));\n\t\t\t\tfor (int k = i+3; k < N; k++) {\n\t\t\t\t\tif (max(cakes[j][0], cakes[i][0] + abs(cakes[i][1] - cakes[k][1])) + abs(cakes[k][1] - cakes[i+2][1]) <= cakes[i+2][0]) {\n\t\t\t\t\t\tcan_reach[{i+2, k}] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cakes[i][0] + abs(cakes[i][1] - cakes[i+1][1]) <= cakes[i+1][0]) {\n\t\t\t\t\tcan_reach[{i+1,j}] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NO\" << '\\n';\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "greedy"], "dificulty": "2900", "interactive": false}