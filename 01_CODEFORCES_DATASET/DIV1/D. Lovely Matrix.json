{
    "link": "https://codeforces.com//contest/274/problem/D",
    "problemId": "2644",
    "problem_idx": "D",
    "shortId": "274D",
    "contest_number": "274",
    "problem_submissions": {
        "C": [
            3158978,
            3161367,
            3160459,
            3161088,
            3162848,
            3162836,
            3165392,
            3165808
        ],
        "D": [
            3157146,
            3154578,
            3158626,
            3159674,
            3155066,
            3154610,
            3154494,
            3162878,
            3155274,
            3154799,
            3156202,
            3154900,
            3156390,
            3156684,
            3157059,
            3155641,
            3157406,
            3158027,
            3156972,
            3156358
        ],
        "B": [
            3152846,
            3152029,
            3153572,
            3152338,
            3153369,
            3152405,
            3153123,
            3152132,
            3152478,
            3153001,
            3152618,
            3151871,
            3152600,
            3152514,
            3153029,
            3154367,
            3152641,
            3154376,
            3154181
        ],
        "A": [
            3151000,
            3150976,
            3151370,
            3151011,
            3151226,
            3150986,
            3151237,
            3151023,
            3151171,
            3151002,
            3150999,
            3152680,
            3151235,
            3150991,
            3151625,
            3151251,
            3169649,
            3151050,
            3151668,
            3151075
        ],
        "E": [
            3179779,
            3170504,
            3166357,
            3166349
        ]
    },
    "name": "D. Lovely Matrix",
    "statement": "Lenny had an matrix of positive integers. He loved the matrix so much,\r\nbecause each row of the matrix was sorted in non-decreasing order. For\r\nthe same reason he calls such matrices of integers .One day when Lenny\r\nwas at school his little brother was playing with Lenny’s matrix in his\r\nroom. He erased some of the entries of the matrix and changed the order\r\nof some of its columns. When Lenny got back home he was very upset. Now\r\nLenny wants to recover his matrix.Help him to find an order for the\r\ncolumns of the matrix so that it’s possible to fill in the erased\r\nentries of the matrix to achieve a lovely matrix again. Note, that you\r\ncan fill the erased entries of the matrix with any integers.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint N,K;\nvector <vector <int> > v;\nset <pair <int, int> > smallest[100010]; // (size K) number, pos\nint bad[100010];\nset <pair <int, int> > s; // bad, id\n\nint ans[100010];\n\nvoid update(int id){\n    s.erase(make_pair(bad[id], id));\n    bad[id]--;\n    s.insert(make_pair(bad[id], id));\n}\n\nint main(void){\n    int step,i,j;\n    \n    cin >> K >> N;\n    v.resize(N);\n    REP(i,K) REP(j,N){\n        int x;\n        scanf(\"%d\", &x);\n        v[j].push_back(x);\n    }\n    \n    REP(i,N) REP(j,K) if(v[i][j] != -1) smallest[j].insert(make_pair(v[i][j], i));\n    REP(j,K){\n        int small = -1;\n        if(!smallest[j].empty()) small = ((smallest[j].begin())->first);\n        REP(i,N) if(v[i][j] != -1 && v[i][j] != small) bad[i]++;\n    }\n    REP(i,N) s.insert(make_pair(bad[i], i));\n    \n    REP(step,N){\n        int x = (s.begin()->second);\n        if(bad[x] != 0) break;\n        ans[step] = x;\n        s.erase(s.begin());\n        \n        // update smallest\n        REP(i,K) if(v[x][i] != -1){\n            if(smallest[i].erase(make_pair(v[x][i], x)));\n            if(!smallest[i].empty()){\n                int next = (smallest[i].begin()->first);\n                if(next != v[x][i]){\n                    snuke(smallest[i],itr){\n                        int id = (itr->second);\n                        int val = (itr->first);\n                        if(val != next) break;\n                        update(id);\n                    }\n                }\n            }\n        }\n    }\n    \n    if(step != N){\n        cout << -1 << endl;\n        return 0;\n    }\n    \n    REP(i,N){\n        printf(\"%d\", ans[i]+1);\n        if(i == N-1) printf(\"\\n\"); else printf(\" \");\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Lovely Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/6759",
    "editorial": "The naïve solution for this problem would be to make a graph were each vertex represents a column of the grid. Then for each two not erased integers x and y in the same row where x?<?y we can add an edge from the column of x to the column of y in our graph. Then topological sorting on the built graph would give us the sought order of the rows. But there can be as much as O(m^2) edges in our graph and thus a O(nm2) solution wont pass the time limit.\n\nBut still the idea to solve this problem is to implement topological sort in a such way that the graph we make has less edges or to make less processing to find the topological sort. Here I present two solutions which use topological sorting. One implements topological sorting explicitly in a graph of columns as its vertices with some extra vertices but fewer edges. The other one does some kind of topological sorting without building the graph and by deciding which column can come as the first column of our ordering, and doing the same thing until all columns come in order.\n\nThe first solution relies on decreasing the number of edges we used in the graph of our naïve solution. Consider the numbers of a row sorted. We insert an extra vertex between each pair of adjacent different numbers. Then each column gets connected to the next extra vertex and each extra vertex gets connected to the columns before the next extra vertex. In this way the sorted order of this row would be preserved in topological sorting. We do the same thing for each row, so topological sort on the final graph would give us the sought ordering of columns. This can be implemented in O(nmlgm).\n\nIn the second solution for each row we color all the minimum not erased elements of that row. The first column in the output permutation should be a column where all of its non erased elements are colored. So we put this column as the first column. Now the rest of the columns can be ordered by the same way. If at some point we cant find a suitable column then theres no solution. This also can be implemented in O(nmlgm).\n\nIt seems the problem was easier than a usual D problem, but before the contest I didnt think so. I myself found the idea to solve this problem after some time, so I thought it wouldnt be suitable for a C. Any ideas on how to measure the hardness of a problem better for next times? Because it doesnt feel so good not to see the problems solved according to the foreseen difficulty level! :D",
    "hint": []
}