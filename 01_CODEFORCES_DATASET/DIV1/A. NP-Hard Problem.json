{
    "link": "https://codeforces.com//contest/687/problem/A",
    "problemId": "63910",
    "problem_idx": "A",
    "shortId": "687A",
    "contest_number": "687",
    "problem_submissions": {
        "E": [
            18802309,
            18806260,
            18805246,
            18803372,
            18799334,
            18807280,
            18805272,
            18806337,
            18807252,
            18806390,
            18807620,
            18803706,
            18810595,
            18816088,
            18805681
        ],
        "D": [
            18793799,
            18802718,
            18796900,
            18797754,
            18807683,
            18798362,
            18797604,
            18800141,
            18800702,
            18803058,
            18801619,
            18800190,
            18801266,
            18807597,
            18797518,
            18800453,
            18798281
        ],
        "A": [
            18790806,
            18786960,
            18787408,
            18787163,
            18787741,
            18788893,
            18788129,
            18787797,
            18786842,
            18788168,
            18789518,
            18787023,
            18787148,
            18787130,
            18787967,
            18788569,
            18787232,
            18787389
        ],
        "C": [
            18788685,
            18790045,
            18790813,
            18791514,
            18792644,
            18791092,
            18793279,
            18795089,
            18793603,
            18792159,
            18795767,
            18790356,
            18792828,
            18792310,
            18792853,
            18794074,
            18789915,
            18792958
        ],
        "B": [
            18786970,
            18788540,
            18789247,
            18789185,
            18796167,
            18786909,
            18790772,
            18789737,
            20295221,
            20295216,
            20295180,
            20295158,
            20295119,
            20295105,
            18790246,
            18790367,
            18793463,
            18789273,
            20295043,
            20295033,
            20295023,
            20295001,
            20294990,
            20292826,
            18789797,
            18790852,
            18792280,
            18796842,
            18789369
        ]
    },
    "name": "A. NP-Hard Problem",
    "statement": "Recently, Pari and Arya did some research about NP-Hard problems and\r\nthey found the problem very interesting.Suppose the graph is given.\r\nSubset of its vertices is called a of this graph, if for each edge there\r\nis at least one endpoint of it in this set, i.e. or (or both).Pari and\r\nArya have won a great undirected graph as an award in a team contest.\r\nNow they have to split it in two parts, but both of them want their\r\nparts of the graph to be a vertex cover.They have agreed to give you\r\ntheir graph and you need to find two subsets of its vertices and , such\r\nthat both and are vertex cover or claim it\u2019s impossible. Each vertex\r\nshould be given to no more than one of the friends (or you can even keep\r\nit for yourself).\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\n\nint n,m,u,v,col[N];\nVI e[N],vec[10];\nvoid dfs(int u) {\n\tfor (auto v:e[u]) {\n\t\tif (col[v]==0) {\n\t\t\tcol[v]=3-col[u];\n\t\t\tdfs(v);\n\t\t} else if (col[u]+col[v]!=3) {\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\trep(i,1,n+1) if (col[i]==0) {\n\t\tcol[i]=1;\n\t\tdfs(i);\n\t}\n\trep(i,1,n+1) vec[col[i]].pb(i);\n\tprintf(\"%d\\n\",SZ(vec[1]));\n\tfor (auto p:vec[1]) printf(\"%d \",p);\n\tputs(\"\");\n\tprintf(\"%d\\n\",SZ(vec[2]));\n\tfor (auto p:vec[2]) printf(\"%d \",p);\n\tputs(\"\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. NP-Hard Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/45770",
    "editorial": "Hint\nTry to use all of the vertices. Then look at the two vertex covers together in the graph and see how it looks like.\n\nSolution\nLooking at the two vertex covers in the graph, you see there must be no edge uv that u and v are in the same vertex cover. So the two vertex covers form a bipartition of the graph, so the graph have to be bipartite. And being bipartite is also sufficient, you can use each part as a vertex cover. Bipartition can be found using your favorite graph traversing algorithm(BFS or DFS). Here is a tutorial for bipartition of undirected graphs."
}