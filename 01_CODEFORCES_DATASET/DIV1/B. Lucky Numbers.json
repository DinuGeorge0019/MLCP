{
    "link": "https://codeforces.com//contest/95/problem/B",
    "problemId": "498",
    "problem_idx": "B",
    "shortId": "95B",
    "contest_number": "95",
    "problem_submissions": {
        "E": [
            535779,
            536171,
            535576,
            534631,
            535449,
            537379,
            535935,
            538215,
            538206,
            535203,
            543889,
            535690,
            536003,
            536745,
            536509,
            549025
        ],
        "B": [
            535031,
            532607,
            533801,
            533350,
            537169,
            534776,
            532824,
            533550,
            533473,
            533499,
            533085,
            534188,
            533285,
            537343,
            537019,
            533757
        ],
        "D": [
            534913,
            535339,
            534808,
            950906,
            535637,
            535740,
            536719,
            535872,
            536920,
            536227,
            537633
        ],
        "C": [
            534317,
            533819,
            536411,
            534119,
            533891,
            533661,
            534495,
            534743,
            534102,
            533774,
            534164,
            535462,
            533913,
            536894,
            535197,
            535469,
            534630,
            534725
        ],
        "A": [
            533274,
            536622,
            537207,
            536153,
            533227,
            532424,
            532796,
            532812,
            532729,
            532727,
            533283,
            534618,
            532955,
            532983,
            533855,
            532880
        ]
    },
    "name": "B. Lucky Numbers",
    "statement": "Petya loves lucky numbers. Everybody knows that positive integers are if\r\ntheir decimal representation doesn’t contain digits other than and . For\r\nexample, numbers , , are lucky and , , are not.Lucky number is if it’s\r\ndecimal representation contains equal amount of digits and . For\r\nexample, numbers , , are super lucky and , , are not.One day Petya came\r\nacross a positive integer . Help him to find the least super lucky\r\nnumber which is not less than .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int maxn=200000+10;\nchar st[maxn];\nint res[maxn];\nint need[maxn];\nint n;\n\nint main()\n{\n\tscanf(\"%s\",st+1);\n\tn=strlen(st+1);\n\n\tfor (int i=n;i;i--)\n\tif (st[i]<'4') need[i]=0;else\n\tif (st[i]=='4') need[i]=min(1,need[i+1]);else\n\tif (st[i]<'7') need[i]=1;else\n\tif (st[i]=='7') need[i]=need[i+1]+1;\n\telse need[i]=1000000000;\n\n\tif (n%2==0)\n\t{\n\t\tbool ok=1;\n\t\tint a=0,b=0,c=4,flag=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\tif (flag)\n\t\t{\n\t\t\tif (a+1<=n/2) res[i]=4,a++;\n\t\t\telse res[i]=7,b++;\n\t\t} else\n\t\t{\n\t\t\tif (st[i]<'4' && a+1<=n/2) res[i]=4,a++,flag=1;else\n\t\t\tif (st[i]=='4' && a+1<=n/2 && need[i+1]<=n/2-b)res[i]=4,a++;else\n\t\t\tif (st[i]<'7' && b+1<=n/2) res[i]=7,b++,flag=1;else\n\t\t\tif (st[i]=='7' && b+1<=n/2) res[i]=7,b++;\n\t\t\telse ok=0;\n\t\t}\n\t\tif (ok)\n\t\t{\n\t\t\tfor (int i=1;i<=n;i++) printf(\"%d\",res[i]);\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tn+=2;\n\t} else n+=1;\n\tfor (int i=1;i<=n/2;i++) printf(\"4\");\n\tfor (int i=1;i<=n/2;i++) printf(\"7\");\n\tprintf(\"\\n\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Lucky Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/2257",
    "editorial": "Notice, that answer will looks like this: to some position result will be equal with input string (that part must be lucky), next digit well be greater, the rest of digits are not important. That guarantees us that result will be greater than or equal to N. As rightest this position will be as number will be lesser. Some of the positions may not be ok to us. Let chosen position is i. Left part must be lucky. If S[i] < 4, we can assign S[i] = 4, then fill minimally right part. If S[i] < 7, we can assign 7 to it, like in prevision case. Call position i ok, if absolute different between number of 4 and 7 in part from 0 to i, inclusive is not more than n-i-1. If we chose some rightmost position, which is ok, now we must fill right part. How to do it? If we can assign to some position (we will fill them from left to right) 4 and this position is still ok, then we place 4,  else we assign 7. If there is no ok positions at all, resulting number will looks like this: 44447777, when number of digits 4 = number of digits 7 = (|N|+2)/2.",
    "hint": []
}