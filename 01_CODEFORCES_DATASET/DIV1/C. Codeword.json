{
    "link": "https://codeforces.com//contest/666/problem/C",
    "problemId": "57415",
    "problem_idx": "C",
    "shortId": "666C",
    "contest_number": "666",
    "problem_submissions": {
        "E": [
            17594948,
            17581972,
            17586090,
            59816920,
            60238846
        ],
        "D": [
            17582206,
            17581333,
            17682266,
            17585111,
            17578532,
            17682483,
            17593764,
            17580882
        ],
        "C": [
            17576782,
            17576849,
            17576800,
            17578215,
            17578937,
            17578155,
            17577254,
            17578057,
            17578881,
            17579042,
            17579726,
            17577922,
            17578916,
            17579778,
            17580460,
            17580072
        ],
        "B": [
            17573525,
            17573061,
            17576637,
            17573442,
            17574093,
            17572951,
            17573669,
            17574447,
            17576416,
            17574060,
            17574231,
            17575134,
            17573766,
            17575544,
            17576709,
            17573819,
            17575438,
            17575919,
            17575656
        ],
        "A": [
            17569955,
            17569857,
            17570262,
            17570541,
            17570429,
            17570371,
            17570641,
            17570192,
            17570791,
            17570963,
            17571866,
            17570753,
            17570879,
            17571604,
            17570261,
            17571058,
            17570440,
            17570884,
            17570485
        ]
    },
    "name": "C. Codeword",
    "statement": "The famous sculptor Cicasso is a Reberlandian spy!These is breaking news\r\nin Berlandian papers today. And now the sculptor is hiding. This time\r\nyou give the shelter to the maestro. You have a protected bunker and you\r\nprovide it to your friend. You set the security system in such way that\r\nonly you can open the bunker. To open it one should solve the problem\r\nwhich is hard for others but is simple for you.Every day the bunker\r\ngenerates a codeword . Every time someone wants to enter the bunker,\r\ninteger appears on the screen. As the answer one should enter another\r\ninteger the residue modulo of the number of strings of length that\r\nconsist only of lowercase English letters and contain the string as the\r\n.The subsequence of string is a string that can be derived from the\r\nstring by removing some symbols from it (maybe none or all of them). In\r\nparticular any string is the subsequence of itself. For example, the\r\nstring \"\" is the subsequence of the string \"\".You haven\u2019t implemented\r\nthe algorithm that calculates the correct answers yet and you should do\r\nthat ASAP.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\n#define MOD 1000000007ll\n\nusing namespace std;\n\ntypedef long long ll;\nll f[100005];\nll vf[100005];\n\nll pw(ll a, ll b) {\n    ll r = 1;\n    while (b) {\n        if (b&1) r = (r*a)%MOD;\n        a = (a*a)%MOD;\n        b /= 2;\n    }\n    return r;\n}\n\nchar buf[100005];\nint m, l;\nvector<tuple<int,int,int> > qu;\nll s[100005];\nll p25[100005];\n\nll c(int n, int k) {\n    return f[n] * vf[k] % MOD * vf[n-k] % MOD;\n}\n\nvoid pc(int nl) {\n    l = nl;\n    FO(i,0,l) s[i] = 0;\n    FO(i,l,100005) {\n        s[i] = s[i-1]*26 + c(i-1,l-1) * p25[i-l];\n        s[i] %= MOD;\n        //printf(\"%d:s[%d]=%lld\\n\", l, i, s[i]);\n    }\n}\n\nint main() {\n    f[0] = 1;\n    FO(i,1,100005) f[i] = i*f[i-1]%MOD;\n    vf[100004] = pw(f[100004], MOD-2);\n    for (int i = 100003; i >= 0; i--) vf[i] = vf[i+1]*(i+1)%MOD;\n    p25[0] = 1;\n    FO(i,1,100005) p25[i] = p25[i-1]*25%MOD;\n\n    scanf(\"%d\", &m);\n    scanf(\" %s\", buf); l = strlen(buf);\n    FO(z,0,m) {\n        int t; scanf(\"%d\", &t);\n        if (t == 1) {\n            scanf(\" %s\", buf);\n            l = strlen(buf);\n        } else {\n            int n; scanf(\"%d\", &n);\n            qu.emplace_back(l, n, z);\n        }\n    }\n\n    sort(qu.begin(),qu.end());\n    l = -1;\n    vector<pair<int,ll> > ans;\n    for (auto q : qu) {\n        int nl, n, z; tie(nl,n,z) = q;\n        if (nl != l) {\n            pc(nl);\n        }\n        ans.emplace_back(z,s[n]);\n    }\n    sort(ans.begin(),ans.end());\n    for (auto a : ans) printf(\"%lld\\n\", a.second);\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "strings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Codeword.json",
    "editorial_link": "https://codeforces.com//blog/entry/44622",
    "editorial": "The first thing to notice: string itself does not matter, only its\r\nlength does. In each sequence of length containing a fixed subsequence\r\nwe can select \u00e2\u0080\u0099s lexicographically minimal occurance, let it be . No\r\ncharacter may occur between and , because otherwise the occurence is not\r\nlex-min. On the other hand, if there is an occurence which satsfies this\r\ncriterion than it is lex-min. Given this definition we can count number\r\nof strings containing given string as a subsequence. At first select\r\npositions of the lex-min occurance; there are ways to do it. Next, you\r\ncan use any of characters at first intervals between , and any of at the\r\nend of the string. (Here, denotes alphabet size). Looping through the\r\nposition of last character in in the lex-min occurence, we can count\r\nthat there are exactly strings containing as a subsequence. So, having\r\nfixed, answer for each could be computed in linear time. A final detail:\r\ninput strings can have at most different lengths. Thus simply applying\r\nthe overmentioned formula we get a solution, which was the expected one.\r\n"
}