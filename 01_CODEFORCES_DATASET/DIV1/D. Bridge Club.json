{
    "link": "https://codeforces.com//contest/1572/problem/D",
    "problemId": "1113066",
    "problem_idx": "D",
    "shortId": "1572D",
    "contest_number": "1572",
    "problem_submissions": {
        "E": [
            129206504,
            129205064,
            129206146,
            129186931,
            129254910,
            129870976,
            129204851
        ],
        "B": [
            129200222,
            129195364,
            129193573,
            129181375,
            129193456,
            129190984,
            129205791,
            129198794,
            129201998,
            129193078,
            129214920,
            129184305,
            129194122,
            129185643,
            129187972,
            129190794,
            129186099,
            129191410,
            129188216
        ],
        "C": [
            129195835,
            129191513,
            129199311,
            129193150,
            129195181,
            129198867,
            129196979,
            129259448,
            129179785,
            129722486,
            129198454,
            129198079,
            129197696,
            129199887,
            129197773,
            129211811,
            129200276
        ],
        "D": [
            129192769,
            129199613,
            129201627,
            129206390,
            129205002,
            129205082,
            129227304,
            129328372,
            129201185,
            129870962,
            129870944,
            129203066,
            129316237,
            129316188,
            136814393,
            129429191
        ],
        "A": [
            129167164,
            129167977,
            129198411,
            129169285,
            129180189,
            129173821,
            129177103,
            129171630,
            129176985,
            129172424,
            129196280,
            129167530,
            129169791,
            129170025,
            129173030,
            129174006,
            129171850,
            129174559,
            129177053
        ],
        "F": [
            129209583,
            129209541,
            129208785,
            129202453,
            129198897,
            129722539,
            129216893,
            129216152,
            129193790,
            129338264
        ]
    },
    "name": "D. Bridge Club",
    "statement": "There are currently n hot topics numbered from 0 to n-1 at your local\r\nbridge club and 2^n players numbered from 0 to 2^n-1. Each player holds\r\na different set of views on those n topics, more specifically, the i-th\r\nplayer holds a positive view on the j-th topic if i\r\n&\r\n2^j > 0, and a negative view otherwise. Here\r\n& denotes the bitwise AND operation.You are going to organize a bridge\r\ntournament capable of accommodating at most k pairs of players (bridge\r\nis played in teams of two people). You can select teams arbitrarily\r\nwhile each player is in at most one team, but there is one catch: two\r\nplayers cannot be in the same pair if they disagree on 2 or more of\r\nthose n topics, as they would argue too much during the play.You know\r\nthat the i-th player will pay you a_i dollars if they play in this\r\ntournament. Compute the maximum amount of money that you can earn if you\r\npair the players in your club optimally.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 18.09.2021 18:04:02       \n**/\n#undef _GLIBCXX_DEBUG\n\n#undef LOCAL\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nnamespace radix {\n\nvector<int> p(65537);\n\ntemplate<typename T>\nvoid SortShift(vector<T>& a, vector<T>& new_a, int shift) {\n  assert(a.size() == new_a.size());\n  int n = static_cast<int>(a.size());\n  fill(p.begin(), p.end(), 0);\n  for (int i = 0; i < n; i++) p[1 + ((a[i] >> shift) & 0xffff)]++;\n  for (int i = 1; i <= 65536; i++) p[i] += p[i - 1];\n  for (int i = 0; i < n; i++) new_a[p[(a[i] >> shift) & 0xffff]++] = a[i];\n}\n\nvoid Sort(vector<int32_t>& a) {\n  constexpr int32_t flip = static_cast<int32_t>(1) << 31;\n  for (auto& aa : a) aa ^= flip;\n  vector<int32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  for (auto& aa : a) aa ^= flip;\n}\n\nvoid Sort(vector<uint32_t>& a) {\n  vector<uint32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n}\n\nvoid Sort(vector<int64_t>& a) {\n  constexpr int64_t flip = static_cast<int64_t>(1) << 63;\n  for (auto& aa : a) aa ^= flip;\n  vector<int64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n  for (auto& aa : a) aa ^= flip;\n}\n\nvoid Sort(vector<uint64_t>& a) {\n  vector<uint64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n}\n\n}  // namespace radix\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    cin >> a[i];\n  }\n  vector<int> kb(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    kb[i] = (__builtin_popcount(i));\n  }\n  vector<int> side(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    side[i] = (kb[i] % 2);\n  }\n  vector<int64_t> all((1 << (n - 1)) * n);\n  int ptr = 0;\n  for (int i = 0; i < (1 << n); i++) {\n    if (side[i] == 0) {\n      for (int j = 0; j < n; j++) {\n        int ni = i ^ (1 << j);\n        all[ptr] = ((long long) (a[i] + a[ni])) << (2 * n);\n        all[ptr] += ((long long) i) << n;\n        all[ptr] += ni;\n        ptr += 1;\n      }\n    }\n  }\n  assert(ptr == (int) all.size());\n  radix::Sort(all);\n  reverse(all.begin(), all.end());\n  k = min(k, (1 << (n - 1)));\n  vector<int> used(1 << n, 0);\n  vector<pair<int, int>> es;\n  vector<int> vs;\n  int ans = 0;\n  ptr = 0;\n  for (int iter = 0; iter < k; iter++) {\n    int pi = -1, pj = -1;\n    while (ptr < (int) all.size()) {\n      int i = (int) ((all[ptr] >> n) & ((1 << n) - 1));\n      int j = (int) (all[ptr] & ((1 << n) - 1));\n      if (!used[i] && !used[j]) {\n        pi = i;\n        pj = j;\n        break;\n      }\n      ptr += 1;\n    }\n    sort(vs.begin(), vs.end());\n    int sz = (int) vs.size();\n    vector<vector<int>> g(sz, vector<int>(sz, 0));\n    for (int i = 0; i < sz; i++) {\n      if (side[vs[i]] == 0) {\n        for (int j = 0; j < sz; j++) {\n          if (side[vs[j]] == 1 && kb[vs[i] ^ vs[j]] == 1) {\n            g[i][j] = 1;\n          }\n        }\n      }\n    }\n    for (auto& e : es) {\n      int x = (int) (lower_bound(vs.begin(), vs.end(), e.first) - vs.begin());\n      int y = (int) (lower_bound(vs.begin(), vs.end(), e.second) - vs.begin());\n      g[x][y] ^= 1;\n      g[y][x] ^= 1;\n    }\n    vector<int> opt(sz, -1);\n    vector<int> who(sz, -1);\n    for (int i = 0; i < sz; i++) {\n      for (int bit = 0; bit < n; bit++) {\n        int j = vs[i] ^ (1 << bit);\n        if (!used[j] && a[j] > opt[i]) {\n          opt[i] = a[j];\n          who[i] = j;\n        }\n      }\n    }\n    debug(vs, es, g);\n    vector<int> pr(sz, -1);\n    vector<int> que(sz);\n    int mi = -1, mj = -1, mx = -1;\n    for (int start = 0; start < sz; start++) {\n      if (side[vs[start]] == 1 && opt[start] >= 0) {\n        fill(pr.begin(), pr.end(), -1);\n        pr[start] = -2;\n        int qIt = 0;\n        int qSz = 1;\n        que[0] = start;\n        while (qIt < qSz) {\n          int i = que[qIt++];\n          for (int j = 0; j < sz; j++) {\n            debug(i, j, pr, g[i][j]);\n            if (g[i][j] && pr[j] == -1) {\n              que[qSz++] = j;\n              pr[j] = i;\n            }\n          }\n        }\n        for (int j = 0; j < sz; j++) {\n          if (side[vs[j]] == 0 && pr[j] != -1 && opt[j] >= 0) {\n            if (opt[start] + opt[j] > mx) {\n              mx = opt[start] + opt[j];\n              mi = start;\n              mj = j;\n            }\n          }\n        }\n      }\n    }\n    if (pi == -1 || mx > a[pi] + a[pj]) {\n      assert(mx >= 0);\n      int start = mi;\n      fill(pr.begin(), pr.end(), -1);\n      pr[start] = -2;\n      int qIt = 0;\n      int qSz = 1;\n      que[0] = start;\n      while (qIt < qSz) {\n        int i = que[qIt++];\n        for (int j = 0; j < sz; j++) {\n          if (g[i][j] && pr[j] == -1) {\n            que[qSz++] = j;\n            pr[j] = i;\n          }\n        }\n      }\n      debug(pr);\n      auto Flip = [&](pair<int, int> p) {\n        auto it = find(es.begin(), es.end(), p);\n        if (it == es.end()) {\n          es.push_back(p);\n        } else {\n          *it = es.back();\n          es.pop_back();\n        }\n      };\n      int at = mj;\n      while (at != mi) {\n        int x = vs[at];\n        int y = vs[pr[at]];\n        assert(side[x] != side[y]);\n        if (side[x] == 1) {\n          swap(x, y);\n        }\n        Flip(make_pair(x, y));\n        at = pr[at];\n      }\n      es.emplace_back(who[mi], vs[mi]);\n      es.emplace_back(vs[mj], who[mj]);\n      used[who[mi]] = 1;\n      used[who[mj]] = 1;\n      vs.push_back(who[mi]);\n      vs.push_back(who[mj]);\n      ans += mx;\n    } else {\n      used[pi] = 1;\n      used[pj] = 1;\n      vs.push_back(pi);\n      vs.push_back(pj);\n      es.emplace_back(pi, pj);\n      ans += a[pi] + a[pj];\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graph matchings",
        "graphs",
        "greedy"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Bridge Club.json",
    "editorial_link": "https://codeforces.com//blog/entry/95086",
    "editorial": "Letâs make a graph in which the vertices are the players and there is an\r\nedge of weight between the -th and the -th player if they can play\r\ntogether. We can notice that the problem can then be solved by finding a\r\nmatching of size at most with the biggest sum of weights in this\r\ngraph.To solve this problem efficiently we can make the following\r\nobservations:1. The graph is bipartite.This stands from the fact that if\r\ntwo players disagree at exactly topic then the numbers of positive views\r\nthat they hold have different parities.2. We can limit ourselves to\r\nconsidering only the edges with the biggest weights.We can prove this\r\nwith a proof by contradiction. Firstly, we can notice that if we use a\r\nparticular edge in the matching then we prohibit ourselves from using at\r\nmost other edges with each of the matched vertices being incident to\r\nexactly of those edges, because each vertex has degree in this graph.\r\nNow we can see that if we were to use an edge thatâs not one of those\r\nbest ones, then we can just replace it with one of those best ones,\r\nbecause we know that at least one of them will not be\r\nprohibited.Combining those two observations we are left with a bipartite\r\ngraph with edges and vertices in which we can find a matching with\r\nmaximum cost and size at most with for example one of the standard min\r\ncost max flow algorithms (we can look for a matching of size because all\r\nedges have non-negative weights).The only problem thatâs left for us to\r\nsolve is efficiently selecting those best edges. Because there are edges\r\nin total we cannot use a standard sorting algorithm as that would run in\r\n. Instead we can for example use the quick select algorithm which solves\r\nthis problem in .Our final time complexity is then .\r\n",
    "hint": []
}