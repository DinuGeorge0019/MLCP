{"link": "https://codeforces.com//contest/1572/problem/D", "problemId": "1113066", "problem_idx": "D", "shortId": "1572D", "contest_number": "1572", "problem_submissions": {"E": [129206504, 129205064, 129206146, 129186931, 129254910, 129870976, 129204851], "B": [129200222, 129195364, 129193573, 129181375, 129193456, 129190984, 129205791, 129198794, 129201998, 129193078, 129214920, 129184305, 129194122, 129185643, 129187972, 129190794, 129186099, 129191410, 129188216], "C": [129195835, 129191513, 129199311, 129193150, 129195181, 129198867, 129196979, 129259448, 129179785, 129722486, 129198454, 129198079, 129197696, 129199887, 129197773, 129211811, 129200276], "D": [129192769, 129199613, 129201627, 129206390, 129205002, 129205082, 129227304, 129328372, 129201185, 129870962, 129870944, 129203066, 129316237, 129316188, 136814393, 129429191], "A": [129167164, 129167977, 129198411, 129169285, 129180189, 129173821, 129177103, 129171630, 129176985, 129172424, 129196280, 129167530, 129169791, 129170025, 129173030, 129174006, 129171850, 129174559, 129177053], "F": [129209583, 129209541, 129208785, 129202453, 129198897, 129722539, 129216893, 129216152, 129193790, 129338264]}, "name": "D. Bridge Club", "statement": "There are currently n hot topics numbered from 0 to n-1 at your local\r\nbridge club and 2^n players numbered from 0 to 2^n-1. Each player holds\r\na different set of views on those n topics, more specifically, the i-th\r\nplayer holds a positive view on the j-th topic if i\r\n&\r\n2^j > 0, and a negative view otherwise. Here\r\n& denotes the bitwise AND operation.You are going to organize a bridge\r\ntournament capable of accommodating at most k pairs of players (bridge\r\nis played in teams of two people). You can select teams arbitrarily\r\nwhile each player is in at most one team, but there is one catch: two\r\nplayers cannot be in the same pair if they disagree on 2 or more of\r\nthose n topics, as they would argue too much during the play.You know\r\nthat the i-th player will pay you a_i dollars if they play in this\r\ntournament. Compute the maximum amount of money that you can earn if you\r\npair the players in your club optimally.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 18.09.2021 18:04:02       \n**/\n#undef _GLIBCXX_DEBUG\n\n#undef LOCAL\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nnamespace radix {\n\nvector<int> p(65537);\n\ntemplate<typename T>\nvoid SortShift(vector<T>& a, vector<T>& new_a, int shift) {\n  assert(a.size() == new_a.size());\n  int n = static_cast<int>(a.size());\n  fill(p.begin(), p.end(), 0);\n  for (int i = 0; i < n; i++) p[1 + ((a[i] >> shift) & 0xffff)]++;\n  for (int i = 1; i <= 65536; i++) p[i] += p[i - 1];\n  for (int i = 0; i < n; i++) new_a[p[(a[i] >> shift) & 0xffff]++] = a[i];\n}\n\nvoid Sort(vector<int32_t>& a) {\n  constexpr int32_t flip = static_cast<int32_t>(1) << 31;\n  for (auto& aa : a) aa ^= flip;\n  vector<int32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  for (auto& aa : a) aa ^= flip;\n}\n\nvoid Sort(vector<uint32_t>& a) {\n  vector<uint32_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n}\n\nvoid Sort(vector<int64_t>& a) {\n  constexpr int64_t flip = static_cast<int64_t>(1) << 63;\n  for (auto& aa : a) aa ^= flip;\n  vector<int64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n  for (auto& aa : a) aa ^= flip;\n}\n\nvoid Sort(vector<uint64_t>& a) {\n  vector<uint64_t> b(a.size());\n  SortShift(a, b, 0);\n  SortShift(b, a, 16);\n  SortShift(a, b, 32);\n  SortShift(b, a, 48);\n}\n\n}  // namespace radix\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    cin >> a[i];\n  }\n  vector<int> kb(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    kb[i] = (__builtin_popcount(i));\n  }\n  vector<int> side(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    side[i] = (kb[i] % 2);\n  }\n  vector<int64_t> all((1 << (n - 1)) * n);\n  int ptr = 0;\n  for (int i = 0; i < (1 << n); i++) {\n    if (side[i] == 0) {\n      for (int j = 0; j < n; j++) {\n        int ni = i ^ (1 << j);\n        all[ptr] = ((long long) (a[i] + a[ni])) << (2 * n);\n        all[ptr] += ((long long) i) << n;\n        all[ptr] += ni;\n        ptr += 1;\n      }\n    }\n  }\n  assert(ptr == (int) all.size());\n  radix::Sort(all);\n  reverse(all.begin(), all.end());\n  k = min(k, (1 << (n - 1)));\n  vector<int> used(1 << n, 0);\n  vector<pair<int, int>> es;\n  vector<int> vs;\n  int ans = 0;\n  ptr = 0;\n  for (int iter = 0; iter < k; iter++) {\n    int pi = -1, pj = -1;\n    while (ptr < (int) all.size()) {\n      int i = (int) ((all[ptr] >> n) & ((1 << n) - 1));\n      int j = (int) (all[ptr] & ((1 << n) - 1));\n      if (!used[i] && !used[j]) {\n        pi = i;\n        pj = j;\n        break;\n      }\n      ptr += 1;\n    }\n    sort(vs.begin(), vs.end());\n    int sz = (int) vs.size();\n    vector<vector<int>> g(sz, vector<int>(sz, 0));\n    for (int i = 0; i < sz; i++) {\n      if (side[vs[i]] == 0) {\n        for (int j = 0; j < sz; j++) {\n          if (side[vs[j]] == 1 && kb[vs[i] ^ vs[j]] == 1) {\n            g[i][j] = 1;\n          }\n        }\n      }\n    }\n    for (auto& e : es) {\n      int x = (int) (lower_bound(vs.begin(), vs.end(), e.first) - vs.begin());\n      int y = (int) (lower_bound(vs.begin(), vs.end(), e.second) - vs.begin());\n      g[x][y] ^= 1;\n      g[y][x] ^= 1;\n    }\n    vector<int> opt(sz, -1);\n    vector<int> who(sz, -1);\n    for (int i = 0; i < sz; i++) {\n      for (int bit = 0; bit < n; bit++) {\n        int j = vs[i] ^ (1 << bit);\n        if (!used[j] && a[j] > opt[i]) {\n          opt[i] = a[j];\n          who[i] = j;\n        }\n      }\n    }\n    debug(vs, es, g);\n    vector<int> pr(sz, -1);\n    vector<int> que(sz);\n    int mi = -1, mj = -1, mx = -1;\n    for (int start = 0; start < sz; start++) {\n      if (side[vs[start]] == 1 && opt[start] >= 0) {\n        fill(pr.begin(), pr.end(), -1);\n        pr[start] = -2;\n        int qIt = 0;\n        int qSz = 1;\n        que[0] = start;\n        while (qIt < qSz) {\n          int i = que[qIt++];\n          for (int j = 0; j < sz; j++) {\n            debug(i, j, pr, g[i][j]);\n            if (g[i][j] && pr[j] == -1) {\n              que[qSz++] = j;\n              pr[j] = i;\n            }\n          }\n        }\n        for (int j = 0; j < sz; j++) {\n          if (side[vs[j]] == 0 && pr[j] != -1 && opt[j] >= 0) {\n            if (opt[start] + opt[j] > mx) {\n              mx = opt[start] + opt[j];\n              mi = start;\n              mj = j;\n            }\n          }\n        }\n      }\n    }\n    if (pi == -1 || mx > a[pi] + a[pj]) {\n      assert(mx >= 0);\n      int start = mi;\n      fill(pr.begin(), pr.end(), -1);\n      pr[start] = -2;\n      int qIt = 0;\n      int qSz = 1;\n      que[0] = start;\n      while (qIt < qSz) {\n        int i = que[qIt++];\n        for (int j = 0; j < sz; j++) {\n          if (g[i][j] && pr[j] == -1) {\n            que[qSz++] = j;\n            pr[j] = i;\n          }\n        }\n      }\n      debug(pr);\n      auto Flip = [&](pair<int, int> p) {\n        auto it = find(es.begin(), es.end(), p);\n        if (it == es.end()) {\n          es.push_back(p);\n        } else {\n          *it = es.back();\n          es.pop_back();\n        }\n      };\n      int at = mj;\n      while (at != mi) {\n        int x = vs[at];\n        int y = vs[pr[at]];\n        assert(side[x] != side[y]);\n        if (side[x] == 1) {\n          swap(x, y);\n        }\n        Flip(make_pair(x, y));\n        at = pr[at];\n      }\n      es.emplace_back(who[mi], vs[mi]);\n      es.emplace_back(vs[mj], who[mj]);\n      used[who[mi]] = 1;\n      used[who[mj]] = 1;\n      vs.push_back(who[mi]);\n      vs.push_back(who[mj]);\n      ans += mx;\n    } else {\n      used[pi] = 1;\n      used[pj] = 1;\n      vs.push_back(pi);\n      vs.push_back(pj);\n      es.emplace_back(pi, pj);\n      ans += a[pi] + a[pj];\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["flows", "graph matchings", "graphs", "greedy"], "dificulty": "2800", "interactive": false}