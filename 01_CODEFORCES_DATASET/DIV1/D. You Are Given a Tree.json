{"link": "https://codeforces.com//contest/1039/problem/D", "problemId": "215703", "problem_idx": "D", "shortId": "1039D", "contest_number": "1039", "problem_submissions": {"D": [42513714, 42511510, 42520062, 42506634, 42517597, 42520159, 42521567, 42523747, 42518726, 42517947, 42522840, 42517334, 42557382, 42552709, 42522292, 42521116, 42593278, 42593192, 42592919, 42592856, 42529738, 42525570, 42594801, 42594517, 42530840], "C": [42506498, 42504177, 42507968, 42513002, 42512024, 42513641, 42514946, 42508788, 42515591, 42512122, 42511727, 42516665, 42510178, 42514370, 42513831, 42505887, 42506202], "A": [42503958, 42503367, 42516900, 42503286, 42504774, 42503703, 42517670, 42510165, 42507659, 42503441, 42509759, 42530985, 42509802, 42525002, 42513799, 42511865], "B": [42501109, 42507268, 42505627, 42509001, 42507388, 42508900, 42510540, 42503816, 42504282, 42519348, 42522856, 42514032, 42504233, 42511724, 42514814, 42501808], "E": [44360079, 42649854, 42649543, 42648847, 42648674, 42648023, 42621125, 42617681, 42617609, 42617300]}, "name": "D. You Are Given a Tree", "statement": "A tree is an undirected graph with exactly one simple path between each\r\npair of vertices. We call a set of simple paths k-valid if each vertex\r\nof the tree belongs to no more than one of these paths (including\r\nendpoints) and each path consists of exactly k vertices.You are given a\r\ntree with n vertices. For each k from 1 to n inclusive find what is the\r\nmaximum possible size of a k-valid set of simple paths.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int B = 1000;\n//const int B = 1;\nconst int N = 100100;\nvector<int> g[N];\nvector<int> a[N];\nint t[N];\nint T;\nint dp[N][3];\nint ans[N];\nbool used[N];\nint n;\n\nvoid dfs(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v])\n\t\tif (!used[u])\n\t\t\tdfs(u);\n\tt[v] = T++;\n}\n\nint solve(int k) {\n\tfor (int v = 0; v < n; v++) {\n\t\tdp[v][0] = dp[v][1] = dp[v][2] = 0;\n\t\tfor (int u : a[v]) {\n\t\t\tdp[v][0] += dp[u][0];\n\t\t\tint x = dp[u][1];\n\t\t\tfor (int i = 1; i < 3; i++) {\n\t\t\t\tif (x > dp[v][i])\n\t\t\t\t\tswap(x, dp[v][i]);\n\t\t\t}\n\t\t}\n\t\tif (dp[v][1] + dp[v][2] >= k - 1) {\n\t\t\tdp[v][0]++;\n\t\t\tdp[v][1] = dp[v][2] = 0;\n\t\t} else {\n\t\t\tdp[v][1]++;\n\t\t\tdp[v][2]++;\n\t\t}\n\t}\n\treturn dp[n - 1][0];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0);\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int u : g[v]) {\n\t\t\tint vv = t[v], uu = t[u];\n\t\t\tif (vv < uu) continue;\n\t\t\ta[vv].push_back(uu);\n\t\t}\n\tfor (int k = 1; k <= min(n, B); k++)\n\t\tans[k] = solve(k);\n\tif (n > B) {\n\t\tint lst = B + 1;\n\t\tfor (int res = ans[B]; res > 0; res--) {\n\t\t\tint l = lst - 1, r = n + 1;\n\t\t\twhile(r - l > 1) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (solve(m) < res)\n\t\t\t\t\tr = m;\n\t\t\t\telse\n\t\t\t\t\tl = m;\n\t\t\t}\n\t\t\twhile(lst < r) ans[lst++] = res;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tprintf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "trees"], "dificulty": "2800", "interactive": false}