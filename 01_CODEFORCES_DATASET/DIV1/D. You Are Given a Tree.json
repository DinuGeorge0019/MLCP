{
    "link": "https://codeforces.com//contest/1039/problem/D",
    "problemId": "215703",
    "problem_idx": "D",
    "shortId": "1039D",
    "contest_number": "1039",
    "problem_submissions": {
        "D": [
            42513714,
            42511510,
            42520062,
            42506634,
            42517597,
            42520159,
            42521567,
            42523747,
            42518726,
            42517947,
            42522840,
            42517334,
            42557382,
            42552709,
            42522292,
            42521116,
            42593278,
            42593192,
            42592919,
            42592856,
            42529738,
            42525570,
            42594801,
            42594517,
            42530840
        ],
        "C": [
            42506498,
            42504177,
            42507968,
            42513002,
            42512024,
            42513641,
            42514946,
            42508788,
            42515591,
            42512122,
            42511727,
            42516665,
            42510178,
            42514370,
            42513831,
            42505887,
            42506202
        ],
        "A": [
            42503958,
            42503367,
            42516900,
            42503286,
            42504774,
            42503703,
            42517670,
            42510165,
            42507659,
            42503441,
            42509759,
            42530985,
            42509802,
            42525002,
            42513799,
            42511865
        ],
        "B": [
            42501109,
            42507268,
            42505627,
            42509001,
            42507388,
            42508900,
            42510540,
            42503816,
            42504282,
            42519348,
            42522856,
            42514032,
            42504233,
            42511724,
            42514814,
            42501808
        ],
        "E": [
            44360079,
            42649854,
            42649543,
            42648847,
            42648674,
            42648023,
            42621125,
            42617681,
            42617609,
            42617300
        ]
    },
    "name": "D. You Are Given a Tree",
    "statement": "A tree is an undirected graph with exactly one simple path between each\r\npair of vertices. We call a set of simple paths k-valid if each vertex\r\nof the tree belongs to no more than one of these paths (including\r\nendpoints) and each path consists of exactly k vertices.You are given a\r\ntree with n vertices. For each k from 1 to n inclusive find what is the\r\nmaximum possible size of a k-valid set of simple paths.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int B = 1000;\n//const int B = 1;\nconst int N = 100100;\nvector<int> g[N];\nvector<int> a[N];\nint t[N];\nint T;\nint dp[N][3];\nint ans[N];\nbool used[N];\nint n;\n\nvoid dfs(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v])\n\t\tif (!used[u])\n\t\t\tdfs(u);\n\tt[v] = T++;\n}\n\nint solve(int k) {\n\tfor (int v = 0; v < n; v++) {\n\t\tdp[v][0] = dp[v][1] = dp[v][2] = 0;\n\t\tfor (int u : a[v]) {\n\t\t\tdp[v][0] += dp[u][0];\n\t\t\tint x = dp[u][1];\n\t\t\tfor (int i = 1; i < 3; i++) {\n\t\t\t\tif (x > dp[v][i])\n\t\t\t\t\tswap(x, dp[v][i]);\n\t\t\t}\n\t\t}\n\t\tif (dp[v][1] + dp[v][2] >= k - 1) {\n\t\t\tdp[v][0]++;\n\t\t\tdp[v][1] = dp[v][2] = 0;\n\t\t} else {\n\t\t\tdp[v][1]++;\n\t\t\tdp[v][2]++;\n\t\t}\n\t}\n\treturn dp[n - 1][0];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0);\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int u : g[v]) {\n\t\t\tint vv = t[v], uu = t[u];\n\t\t\tif (vv < uu) continue;\n\t\t\ta[vv].push_back(uu);\n\t\t}\n\tfor (int k = 1; k <= min(n, B); k++)\n\t\tans[k] = solve(k);\n\tif (n > B) {\n\t\tint lst = B + 1;\n\t\tfor (int res = ans[B]; res > 0; res--) {\n\t\t\tint l = lst - 1, r = n + 1;\n\t\t\twhile(r - l > 1) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (solve(m) < res)\n\t\t\t\t\tr = m;\n\t\t\t\telse\n\t\t\t\t\tl = m;\n\t\t\t}\n\t\t\twhile(lst < r) ans[lst++] = res;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tprintf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. You Are Given a Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/61668",
    "editorial": "Letâs examine a solution in first.Introudce a dynamic programming on\r\nsubtree, the dp of the vertex is the number of paths, which can be taken\r\nfrom the subtree and the maximum length of incomplete path, which ends\r\nexactly in vertex v.Notice that this dp can be maximised as pair the\r\nmore of complete paths than better, and if the number of complete paths\r\ncoincides, then itâs better to have the incomplete path as long as\r\npossible.This dp allows to get an answer in for a single How to\r\ncalculate this dp for a vertex? We need to sum the number of complete\r\npaths over all children and also either take one of the incomplete path\r\nof children and attach the current vertex to it or try to form a new\r\npath from two longest incomplete paths of children.It is possible to use\r\nsolution to get solution.Notice, that . From this we get, that takes no\r\nmore than values. Indeed, there are values and for all .To find the\r\ncorresponding bounds we can use binary search this way we get solution\r\nin .This is already enough to get Accepted on codeforces, however I want\r\nto share some more insights about faster, solution, it wasnât required\r\nto get OK, mostly because we found out that writing this solution is\r\nreally complicated and making it work faster then sqrt-log solution is\r\neven more harder.The funny thing is that we can do a dynamic programming\r\nfor all from to simultaneously.In fact, we will use cartesian tree (more\r\nprecisely, it is better to have segment tree for efficiency).We will\r\nreturn from subtree of vertex structure of size , containing the dp\r\nvalues for all from to , where it the size of the subtree.So we need to\r\nbe able to merge results from subtrees. In particular, from the subtree\r\ndpâs of sizes () we want to get .Letâs take the result corresponding to\r\nas a basis, new-borned end can be appended naively. Also, more or less\r\nnaively we can make the merge of prefix part of length (because this\r\nwork \"is paid\" by the fact that we will not return the dp structure of\r\nsize ).So we have to deal with a part from to .In the structure we store\r\npairs of numbers how much complete paths, and the length of the\r\nincomplete path. Note that there are two types of relaxation when we\r\nincrease the number of complete paths and when we simply relax the\r\nlength of incomplete path.Notice, that , and hence . This way the number\r\nof transitions of first type is small and we can perform them naively,\r\nwe just need to find all such transitions fast. We can maintain in the\r\nabove mentioned data structure maximums on the segments and fast pull\r\nall such transitions.Other transitions can be handled with on a suffix\r\nand on the whole data structure, the latter we store together with the\r\ninstance of data structures and handle them when we merge one data\r\nstructure into the other.The overall complexity is .\r\n",
    "hint": []
}