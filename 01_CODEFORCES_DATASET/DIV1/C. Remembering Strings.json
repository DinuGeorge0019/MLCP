{"link": "https://codeforces.com//contest/543/problem/C", "problemId": "27502", "problem_idx": "C", "shortId": "543C", "contest_number": "543", "problem_submissions": {"C": [11031273, 11032297, 11028921, 11027662, 11035224, 11032105, 11026578, 11030569, 11027731, 11030889, 11031150, 11032259, 11039311, 11029744, 11031844, 11033030, 11027751, 11027833, 11030513], "D": [11026961, 11027152, 11029036, 11027586, 11028656, 11027275, 11031263, 11026257, 11029360, 11029505, 11032424, 11028940, 11031163, 11035849, 11028432], "B": [11024775, 11024536, 11030599, 11035262, 11024794, 11024869, 11025321, 11028836, 11028474, 11031647, 11025986, 11024625, 11027272, 11029817, 11024295, 11024309], "A": [11022855, 11023048, 11023174, 11022792, 11022796, 11023075, 11030178, 11022790, 11023930, 11023772, 11022768, 11023607, 11023159, 11022742, 11022813, 11022885]}, "name": "C. Remembering Strings", "statement": "You have multiset of strings of the same length, consisting of lowercase\r\nEnglish letters. We will say that those strings are easy to remember if\r\nfor each string there is some position and some letter of the English\r\nalphabet, such that this string is the only string in the multiset that\r\nhas letter in position .For example, a multiset of strings {\"abc\",\r\n\"aba\", \"adc\", \"ada\"} are not easy to remember. And multiset {\"abc\",\r\n\"ada\", \"ssa\"} is easy to remember because: the first string is the only\r\nstring that has character in position ; the second string is the only\r\nstring that has character in position ; the third string is the only\r\nstring that has character in position . You want to change your multiset\r\na little so that it is easy to remember. For coins, you can change\r\ncharacter in the -th position of the -th string into any other lowercase\r\nletter of the English alphabet. Find what is the minimum sum you should\r\npay in order to make the multiset of strings easy to remember.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n\n#ifdef _WIN32\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n\ntypedef long double ld;\n\nlong long rdtsc() {\n  long long tmp;\n  asm(\"rdtsc\" : \"=A\"(tmp));\n  return tmp;\n}\n\ninline int myrand() {\n  return abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n  return myrand() % x;\n}\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME \"text\"\n\nconst int INF = (int)1e9 + 1;\nconst ld EPS = 1e-9;\n\nvoid precalc() {\n}\n\nconst int maxn = 20;\nchar s[maxn + 5][maxn + 5];\nint a[maxn + 5][maxn + 5];\nint n, m;\n\nbool read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%s\", s[i]);\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      scanf(\"%d\", &a[i][j]);\n    }\n  }\n  return 1;\n}\n\nconst int maxc = 26;\n\npair<int, int> masks[maxn * maxn + maxn + 5];\n\nint d[1 << maxn];\n\nvoid solve() {\n  int cnt = 0;\n  for (int c = 0; c < m; ++c) {\n    for (int ch = 0; ch < maxc; ++ch) {\n      int mx = -1;\n      int sum = 0;\n      int mask = 0;\n      for (int r = 0; r < n; ++r) {\n        if (s[r][c] != ch + 'a') {\n          continue;\n        }\n        mask ^= (1 << r);\n        sum += a[r][c];\n        mx = max(mx, a[r][c]);\n      }\n      if (mask) {\n        masks[cnt++] = mp(sum - mx, mask);\n        //eprintf(\"c = %d, ch = %c, (%d, %d)\\n\", c, ch + 'a', masks[cnt - 1].first, masks[cnt - 1].second);\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    int mn = INF;\n    for (int j = 0; j < m; ++j) {\n      mn = min(mn, a[i][j]);\n    }\n    masks[cnt++] = mp(mn, 1 << i);\n  }\n  sort(masks, masks + cnt);\n\n  int mask0 = 0;\n  int l = 0;\n  for (; l < cnt && masks[l].first == 0; ++l) {\n    mask0 |= masks[l].second;\n  }\n\n  for (int i = 0; i < (1 << n); ++i) {\n    d[i] = INF;\n  }\n  d[mask0] = 0;\n  for (; l < cnt; ++l) {\n    int mask = masks[l].second, price = masks[l].first;\n    for (int m = mask0; m < (1 << n); ++m) {\n      int nm = (m | mask);\n      int nprice = d[m] + price;\n      if (nm == m || d[nm] <= nprice) {\n        continue;\n      }\n      d[nm] = nprice;\n    }\n  }\n  printf(\"%d\\n\", d[(1 << n) - 1]);\n}\n\nint main() {\n  srand(rdtsc());\n#ifdef DEBUG\n  freopen(TASKNAME\".out\", \"w\", stdout);\n  assert(freopen(TASKNAME\".in\", \"r\", stdin));\n#endif\n\n  precalc();\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"%.18lf\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp"], "dificulty": "2500", "interactive": false}