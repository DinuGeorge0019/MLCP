{
    "link": "https://codeforces.com//contest/1924/problem/D",
    "problemId": "2447860",
    "problem_idx": "D",
    "shortId": "1924D",
    "contest_number": "1924",
    "problem_submissions": {
        "E": [
            243630255,
            243625417,
            243831471,
            243819146,
            243638029,
            243635094,
            243635575,
            243643653,
            243641448,
            243654047,
            243642725,
            243655474,
            243640193,
            243642282,
            243738773,
            243738280,
            243737868,
            243737472,
            243736583,
            243647040,
            243643392,
            243656506,
            243623598,
            243647525,
            243642926
        ],
        "D": [
            243610539,
            243613703,
            243615017,
            243615468,
            243616484,
            243609433,
            243612607,
            243604919,
            243590030,
            243626983,
            243620249,
            243611671,
            243630742,
            243627184,
            243647496,
            243637086,
            243615081
        ],
        "C": [
            243600996,
            243608465,
            243605004,
            243605423,
            243609031,
            243624334,
            243598851,
            243618516,
            243614897,
            243607146,
            243609954,
            243605925,
            243615697,
            243614877,
            243629728,
            243619721,
            243625857
        ],
        "B": [
            243576284,
            243596345,
            243574522,
            243584076,
            243591802,
            243608792,
            243595388,
            243582812,
            243591583,
            243581060,
            243590774,
            243588502,
            243614602,
            243593249,
            243586709,
            243594966,
            243581169,
            243586114
        ],
        "A": [
            243557786,
            243557461,
            243557951,
            243558389,
            243559700,
            243571068,
            243569238,
            243556739,
            243561136,
            243559764,
            243556383,
            243563507,
            243559787,
            243566206,
            243566244,
            243561059,
            243558400,
            243589028
        ],
        "F": [
            243674865,
            243667546,
            243888054,
            243737554,
            246427685
        ]
    },
    "name": "D. Balanced Subsequences",
    "statement": "A sequence of brackets is called balanced if one can turn it into a\r\nvalid math expression by adding characters and . For example, sequences\r\nand are balanced, while and are not.A subsequence is a sequence that can\r\nbe derived from the given sequence by deleting zero or more elements\r\nwithout changing the order of the remaining elements.You are given three\r\nintegers n, m and k. Find the number of sequences consisting of n and m\r\n, such that the longest balanced subsequence is of length 2\r\ncdot k. Since the answer can be large calculate it modulo 1\r\n,000\r\n,000\r\n,007 (10^9 + 7).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 1000000007;\nusing Z = MInt<P>;\n\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        m = std::min(m, Z::getMod() - 1);\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nZ get(int n, int m) {\n    return comb.binom(n + m, m) - comb.binom(n + m, m - 1);\n}\n\nZ get1(int n, int m) {\n    if (n + m == 0) {\n        return 1;\n    }\n    if (n == m) {\n        return 0;\n    }\n    return get(n - 1, m);\n}\n\nvoid solve() {\n    int n, m, k;\n    std::cin >> n >> m >> k;\n    \n    if (k > n || k > m) {\n        std::cout << 0 << \"\\n\";\n        return;\n    }\n    \n    Z ans = 0;\n    for (int i = 0; i <= k; i++) {\n        ans += get(i + n - k, i) * get1(k - i + m - k, k - i);\n    }\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Balanced Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/125137",
    "editorial": "Tutorial Now to compute , we can consider the following cases: Case 1:\nHere, the answer is , since none of the strings can have a subsequence\nof length greater than . Case 2: Here we can write since all strings\nwill either start with:a) \u00e2\u0080\u0099)\u00e2\u0080\u0099 Here, count is equal to .b) \u00e2\u0080\u0099(\u00e2\u0080\u0099 Here,\ncount is equal to , the first opening bracket will always add to the\noptimal subsequence length because all strings where each of the \u00e2\u0080\u0099)\u00e2\u0080\u0099 is\npaired to some \u00e2\u0080\u0099(\u00e2\u0080\u0099 don\u00e2\u0080\u0099t contribute to the count since . After this\nrecurrence relation we have 2 base cases: Here, count is which can also\nbe written as . Here, count is (as proved in Case 1) which can also be\nwritten as . Now using induction we can prove that the value of for Case\n2 is .\n"
}