{"link": "https://codeforces.com//contest/1423/problem/I", "problemId": "749089", "problem_idx": "I", "shortId": "1423I", "contest_number": "1423", "problem_submissions": {"J": [95462948, 95462931, 95462795, 95462776, 95462759, 95462752, 95462749, 95445856, 95445842, 95445741, 95445735, 95445720, 95436077, 95435983, 94779119, 94773285, 94770663, 94778562], "C": [94789081], "I": [94786050], "F": [94784528, 94776365, 94779778, 94781062], "H": [94781814, 94783650, 94777878, 94784871], "L": [94780014, 94780685, 94786643, 94773659], "B": [94771096, 94770153, 94772426, 94771466], "K": [94770723, 94771588, 94773427, 94774938], "A": [], "D": [], "E": [], "G": []}, "name": "I. Lookup Tables", "statement": "John has Q closed intervals of consecutive 2K-bit numbers [l_i, r_i] and\r\none 16-bit value v_i for each interval. (0\r\nleq i < Q)John wants to implement a function F that maps 2K-bit numbers\r\nto 16-bit numbers in such a way that inputs from each interval are\r\nmapped to that interval\u2019s value. In other words: F(x) = v_i,\r\n;\r\ntextrm{for every } 0\r\nleq i < Q\r\n;\r\ntextrm{, and every } x\r\nin [l_i, r_i] The output of F for other inputs is unimportant.John wants\r\nto make his implementation of F fast so he has decided to use lookup\r\ntables. A single 2K-bit lookup table would be too large to fit in\r\nmemory, so instead John plans to use two K-bit lookup tables, LSBTable\r\nand MSBTable. His implementation will look like this: F(x) =\r\ntextrm{LSBTable}[\r\ntextrm{lowKBits}(x)]\r\n;\r\n&\r\n;\r\ntextrm{MSBTable}[\r\ntextrm{highKBits}(x)] In other words it returns the \"bitwise and\" of\r\nresults of looking up the K least significant bits in LSBTable and the K\r\nmost significant bits in MSBTable.John needs your help. Given K, Q and Q\r\nintervals [l_i, r_i] and values v_i, find any two lookup tables which\r\ncan implement F or report that such tables don\u2019t exist.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 05.10.2020 16:46:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    int val = 0;\n    int put = 0;\n\n    void apply(int l, int r, int v) {\n      val |= v;\n      put |= v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.val = a.val | b.val;\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].put != 0) {\n      tree[x + 1].apply(l, y, tree[x].put);\n      tree[z].apply(y + 1, r, tree[x].put);\n      tree[x].put = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int k, q;\n  cin >> k >> q;\n  vector<long long> l(q);\n  vector<long long> r(q);\n  vector<int> v(q);\n  for (int i = 0; i < q; i++) {\n    cin >> l[i] >> r[i] >> v[i];\n  }\n  segtree msb(1 << k);\n  segtree lsb(1 << k);\n  for (int i = 0; i < q; i++) {\n    {\n      int from = l[i] >> k;\n      int to = r[i] >> k;\n      msb.modify(from, to, v[i]);\n    }\n    {\n      if (r[i] - l[i] + 1 >= (1 << k)) {\n        lsb.modify(0, (1 << k) - 1, v[i]);\n      } else {\n        int from = l[i] & ((1 << k) - 1);\n        int to = r[i] & ((1 << k) - 1);\n        if (from <= to) {\n          lsb.modify(from, to, v[i]);\n        } else {\n          lsb.modify(from, (1 << k) - 1, v[i]);\n          lsb.modify(0, to, v[i]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < q; i++) {\n    long long x = l[i];\n    long long y = r[i];\n    while (x <= y) {\n      if ((x & ((1 << k) - 1)) == 0 && y - x + 1 >= (1 << k)) {\n        int full = (y - x + 1) >> k;\n        int a = msb.get(x >> k, (x >> k) + full - 1).val;\n        int b = lsb.get(0, (1 << k) - 1).val;\n        if ((a & b) != v[i]) {\n          cout << \"impossible\" << '\\n';\n          return 0;\n        }\n        x += ((long long) full) << k;\n        continue;\n      }\n      long long z = min(y, x | ((1 << k) - 1));\n      int a = msb.get(x >> k, x >> k).val;\n      int b = lsb.get(x & ((1 << k) - 1), z & ((1 << k) - 1)).val;\n      if ((a & b) != v[i]) {\n        cout << \"impossible\" << '\\n';\n        return 0;\n      }\n      x = z + 1;\n    }\n  }\n  cout << \"possible\" << '\\n';\n  for (int i = 0; i < (1 << k); i++) {\n    cout << lsb.get(i, i).val << '\\n';\n  }\n  for (int i = 0; i < (1 << k); i++) {\n    cout << msb.get(i, i).val << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks"], "dificulty": "3000", "interactive": false}