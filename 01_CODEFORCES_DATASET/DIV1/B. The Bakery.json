{
    "link": "https://codeforces.com//contest/833/problem/B",
    "problemId": "116220",
    "problem_idx": "B",
    "shortId": "833B",
    "contest_number": "833",
    "problem_submissions": {
        "E": [
            29083224,
            29083091
        ],
        "D": [
            29016770,
            29016294,
            29011617,
            29013958,
            29009345,
            29244474,
            29205082,
            29015261,
            29017136,
            29012336,
            29008041,
            29014134,
            29019073
        ],
        "C": [
            29008615,
            29008359,
            29015249,
            29038532,
            29038473,
            29013146,
            29010690,
            29004990,
            29014257,
            29023306,
            29012381,
            29014235,
            29007517,
            29015632,
            29016681
        ],
        "B": [
            29000858,
            28999434,
            29001150,
            29001528,
            29002115,
            29002974,
            29016798,
            29017661,
            29016482,
            29001800,
            29005534,
            29010788,
            29005299,
            29004648,
            29003078,
            29002266,
            29014197,
            29004174,
            28997722
        ],
        "A": [
            28994520,
            28994190,
            28994134,
            28993034,
            28994420,
            28995369,
            28994393,
            28997116,
            29011489,
            28992915,
            28994389,
            28993845,
            28993595,
            28996557,
            28993837,
            28993225,
            28994120,
            28993719,
            28995865,
            28994510
        ]
    },
    "name": "B. The Bakery",
    "statement": "Some time ago Slastyona the Sweetmaid decided to open her own bakery!\r\nShe bought required ingredients and a wonder-oven which can bake several\r\ntypes of cakes, and opened the bakery.Soon the expenses started to\r\novercome the income, so Slastyona decided to study the sweets market.\r\nShe learned it\u2019s profitable to pack cakes in boxes, and that the more\r\ncake types a box contains (let\u2019s denote this number as the of the box),\r\nthe higher price it has.She needs to change the production technology!\r\nThe problem is that the oven chooses the cake types on its own and\r\nSlastyona can\u2019t affect it. However, she knows the types and order of\r\ncakes the oven is going to bake today. Slastyona has to pack exactly\r\nboxes with cakes today, and she has to put in each box several (at least\r\none) cakes the oven produced one (in other words, she has to put in a\r\nbox a continuous segment of cakes).Slastyona wants to maximize the total\r\nvalue of all boxes with cakes. Help her determine this maximum possible\r\ntotal value.\r\n",
    "solutions": [
        "//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJ\u015aCIE I WYJ\u015aCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=200*1007;\nconst int kax=57;\nconst int n1=(2<<16);\n\nint n, k;\n\nint tab[nax];\n\nint dp[kax][nax];\n\nint narz[nax];\nint drzewo[nax];\n\npair <int,int> prze[nax];\n\ninline void update(int v)\n{\n\tdrzewo[v]=max(drzewo[(v<<1)]+narz[(v<<1)], drzewo[(v<<1)^1]+narz[(v<<1)^1]);\n}\n\nvoid pisz(int v, int a, int b, int graa, int grab, int w)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\tnarz[v]+=w;\n\t\treturn;\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn;\n\t}\n\tpisz((v<<1), a, (a+b)>>1, graa, grab, w);\n\tpisz((v<<1)^1, (a+b+2)>>1, b, graa, grab, w);\n\tupdate(v);\n}\n\nint czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\treturn narz[v]+drzewo[v];\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn -nax;\n\t}\n\treturn max(\n\tczyt((v<<1), a, (a+b)>>1, graa, grab),\n\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab))+narz[v];\n}\n\nvoid czys()\n{\n\tfor (int i=0; i<nax; i++)\n\t\tdrzewo[i]=narz[i]=0;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\tfor(int h=1; h<=k; h++)\n\t{\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tprze[i]={0,0};\n\t\tczys();\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\t//debug() << imie(dp[h-1][i-1]);\n\t\t\tpisz(1, 1, n1, i, i, dp[h-1][i-1]);\n\t\t\tint x=tab[i];\n\t\t\t//pisz(1, 1, n1, prze[x].first, prze[x].second, -1);\n\t\t\tprze[x].first=prze[x].second+1;\n\t\t\tprze[x].second=i;\n\t\t\tpisz(1, 1, n1, prze[x].first, prze[x].second, 1);\n\t\t\t\n\t\t\tdp[h][i]=czyt(1, 1, n1, 1, i);\n\t\t}\n\t\tdebug() << range(dp[h]+1, dp[h]+1+n);\n\t}\n\tprintf(\"%d\\n\", dp[k][n]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dp",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. The Bakery.json",
    "editorial_link": "https://codeforces.com//blog/entry/53567",
    "editorial": "let\u00e2\u0080\u0099s calculate the maximum cost we can obtain if we assign the\nfirst cakes to boxes.For the answer is equal to the number of distinct\nvalues on a prefix.For the answer can be deduced as follows (here\ndenotes the number of distinct elements in range ): There are two\npossible approaches.Imagine we\u00e2\u0080\u0099re trying to compute the -th dp layer and\nour currect position is , maintaining a max segment tree with the sum in\n-th cell where . The answer for is just a prefix query.How do we move\nthe right? Let\u00e2\u0080\u0099s denote -th cake type as . Notice that the transition\nincreases the segment tree values for all cells such that there\u00e2\u0080\u0099s no in\nrange by one (since we\u00e2\u0080\u0099ve added a new distinct element).More formal, we\nincrease all \u00e2\u0080\u0099s between the previous position of plus one (or the\nbeginning of the array if we haven\u00e2\u0080\u0099t marked before) to . Hence we got a\nlazy update segment tree and a simple precalc. There\u00e2\u0080\u0099s a single for both\nupdating and computing a single and a total complexity of .Many tried\nthis approach and failed. Albeit we didn\u00e2\u0080\u0099t focus on cutting this\nsolution much, it still required several optimizations to pass.Let\u00e2\u0080\u0099s\ndenote the leftmost such that gives the optimal answer for as . We claim\nthat (this one is a left as an exercise to the reader). With with\nassumption it is the right time for applying divide & conquer dp\noptimization (here persistent segment tree is used for counting the\nnumber of distinct cakes in a range, which is a well-known application\nof it; the divide and conquer technique is described here, for example:\ncodeforces.com/blog/entry/8219).There are relaxes in a single dp layer,\neach of those is processed in . With a total of layers we get the\noverall complexity of .\n"
}