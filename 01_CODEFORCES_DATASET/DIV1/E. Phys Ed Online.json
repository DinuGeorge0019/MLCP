{"link": "https://codeforces.com//contest/1601/problem/E", "problemId": "1157781", "problem_idx": "E", "shortId": "1601E", "contest_number": "1601", "problem_submissions": {"F": [133036741, 133030850, 133053471, 133036776, 136096402, 133146246], "E": [133012503, 133009950, 133010165, 133012509, 133023042, 133010446, 133029069, 133020546, 133026708, 133026848, 133096129, 133096027, 133009106, 133031363, 133005130, 133031540, 133037221, 133324190, 133128643, 133007675, 133037406], "D": [133003986, 133005946, 133003145, 133019481, 133007804, 133008410, 133020273, 133009176, 133009157, 133008849, 133009299, 133026582, 133008809, 133014147, 133008199, 133009583, 133010326, 133056419, 133004546, 133008768], "C": [132999482, 132998781, 132997710, 132998487, 133003047, 133002651, 133001118, 133000071, 133003217, 132998126, 133000279, 133000540, 133004698, 133023294, 133006018, 133000684, 132998660, 133001622, 133009000, 133004643], "B": [132991406, 132991376, 132992870, 132992842, 132992304, 132995590, 132995226, 132992037, 132995055, 132990916, 132993158, 132995079, 132994798, 132993699, 132996347, 133113107, 132993962, 132993893, 132997201, 132995373, 132994895], "A": [132984771, 132984572, 132985020, 132988648, 132985081, 132985096, 132984905, 132984874, 132986113, 132984658, 132986695, 132985767, 132986320, 132985605, 132985251, 132987796, 132985532, 132985036, 132986108, 132986609]}, "name": "E. Phys Ed Online", "statement": "Students of one unknown college don\u2019t have PE courses. That\u2019s why q of\r\nthem decided to visit a gym nearby by themselves. The gym is open for n\r\ndays and has a ticket system. At the i-th day, the cost of one ticket is\r\nequal to a_i. You are free to buy more than one ticket per day.You can\r\nactivate a ticket purchased at day i either at day i or any day later.\r\nEach activated ticket is valid only for k days. In other words, if you\r\nactivate ticket at day t, it will be valid only at days t, t + 1,\r\ndots, t + k - 1. You know that the j-th student wants to visit the gym\r\nat each day from l_j to r_j inclusive. Each student will use the\r\nfollowing strategy of visiting the gym at any day i (l_j\r\nle i\r\nle r_j): person comes to a desk selling tickets placed near the entrance\r\nand buy several tickets with cost a_i apiece (possibly, zero tickets);\r\nif the person has at least one activated and still valid ticket, they\r\njust go in. Otherwise, they activate one of tickets purchased today or\r\nearlier and go in. Note that each student will visit gym only starting\r\nl_j, so each student has to buy at least one ticket at day l_j.Help\r\nstudents to calculate the minimum amount of money they have to spend in\r\norder to go to the gym.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, q, k, a[300005], ak[300005], ql[300005], qr[300005];\nLL ans[300005];\nvector<int> qy[300005];\n\nstruct fwt\n{\n\tint B;\n\tLL dat[300005], sum;\n\tvoid clear()\n\t{\n\t\tB = n / k + 2; sum = 0;\n\t\tfor(int i = B; i >= 0; i --) dat[i] = 0;\n\t}\n\tvoid add(int id, LL val)\n\t{\n\t\tsum += val;\n\t\tfor(; id <= B; id += id & -id) dat[id] += val;\n\t}\n\tLL query(int id)\n\t{\n\t\tLL ret = 0;\n\t\tfor(; id > 0; id -= id & -id) ret += dat[id];\n\t\treturn ret;\n\t}\n}t0, t1;\nvoid add_t(int r, LL val)\n{\n\tif(r == 0) return;\n\tt0.add(r, val); t1.add(r, 1LL * r * val);\n}\nLL query_t(int r)\n{\n\tif(r == 0) return 0;\n\treturn 1LL * r * (t0.sum - t0.query(r)) + t1.query(r);\n}\nvoid add_t(int l, int r, LL val)\n{\n\tadd_t(l, -val); add_t(r + 1, val);\n}\nLL query_t(int l, int r)\n{\n\treturn query_t(r + 1) - query_t(l);\n}\n\nPII sta[300005];\nint siz;\ndeque<PII> que;\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &q, &k);\n\trep1(i, n) scanf(\"%d\", &a[i]);\n\trep(i, q) scanf(\"%d%d\", &ql[i], &qr[i]);\n\t\n\tfor(int i = n; i >= 1; i --) {\n\t\tif(!que.empty() && que.front().second == i + k) que.pop_front();\n\t\twhile(!que.empty() && que.back().first >= a[i]) que.pop_back();\n\t\tque.push_back(MP(a[i], i));\n\t\tak[i] = que.front().first;\n\t}\n\t\n\trep(i, q) {\n\t\tans[i] = a[ql[i]];\n\t\tqr[i] = (qr[i] - ql[i]) / k;\n\t\tqy[ql[i] + 1].push_back(i);\n\t}\n\t\n\tfor(int i = n; i > n - k; i --) {\n\t\tt0.clear(); t1.clear();\n\t\tsiz = 1; sta[0] = MP(-1, i / k + 1);\n\t\tfor(int j = i; j >= 1; j -= k) {\n\t\t\twhile(sta[siz - 1].first >= ak[j]) {\n\t\t\t\tadd_t(sta[siz - 1].second, sta[siz - 2].second - 1, ak[j] - sta[siz - 1].first);\n\t\t\t\tsiz --;\n\t\t\t}\n\t\t\tint cj = j / k;\n\t\t\tsta[siz ++] = MP(ak[j], cj);\n\t\t\tadd_t(cj, cj, ak[j]);\n\t\t\trep(iq, qy[j].size()) {\n\t\t\t\tint cq = qy[j][iq], cv = a[j - 1];\n\t\t\t\tint cpos = lower_bound(sta, sta + siz, MP(cv, -1)) - sta - 1;\n\t\t\t\tif(cj + qr[cq] <= sta[cpos].second) ans[cq] += 1LL * cv * qr[cq];\n\t\t\t\telse ans[cq] += 1LL * cv * (sta[cpos].second - cj) + query_t(sta[cpos].second, cj + qr[cq] - 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, q) printf(\"%lld\\n\", ans[i]);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dp", "greedy"], "dificulty": "2900", "interactive": false}