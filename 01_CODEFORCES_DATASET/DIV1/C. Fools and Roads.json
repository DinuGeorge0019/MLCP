{"link": "https://codeforces.com//contest/191/problem/C", "problemId": "1352", "problem_idx": "C", "shortId": "191C", "contest_number": "191", "problem_submissions": {"D": [1730940, 1730058, 1732061, 1732109, 1732464], "E": [1728781, 1730615, 1727981, 1728842, 1729175, 1728797, 1729393, 1729602, 1729222, 1729975, 1730220, 1730326, 1729991, 1730136, 1729526, 1730229, 1730018, 1730441, 1730472], "C": [1727557, 1727971, 1727279, 1727922, 1728193, 1726763, 1727330, 1728312, 1727749, 1728454, 1728335, 1728217, 1728234, 1728828, 1727958, 1728318, 1727470, 1728758, 1727987], "B": [1726383, 1726744, 1729343, 1727040, 1726927, 1730397, 1728304, 1726935, 1728912, 1727207, 1727504, 1727317, 1729119, 1727295, 1728990, 1727070, 1729275, 1727129, 1729072], "A": [1725547, 1725524, 1725641, 1725909, 1725741, 1725703, 1725714, 1725752, 1725615, 1725779, 1725777, 1725532, 1726185, 1725907, 1725443, 1725690, 1725534, 1725596, 1727248]}, "name": "C. Fools and Roads", "statement": "They say that Berland has exactly two problems, fools and roads.\r\nBesides, Berland has cities, populated by the fools and connected by the\r\nroads. All Berland roads are bidirectional. As there are many fools in\r\nBerland, between each pair of cities there is a path (or else the fools\r\nwould get upset). Also, between each pair of cities there is no more\r\nthan one simple path (or else the fools would get lost). But that is not\r\nthe end of Berland\u2019s special features. In this country fools sometimes\r\nvisit each other and thus spoil the roads. The fools aren\u2019t very smart,\r\nso they always use only the simple paths. is the path which goes through\r\nevery Berland city not more than once.The Berland government knows the\r\npaths which the fools use. Help the government count for each road, how\r\nmany distinct fools can go on it.Note how the fools\u2019 paths are given in\r\nthe input.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME \"std\"\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nclass Dsu {\n  vi par, ss, ans;\n  \n  int get(int x) { return par[x] == x ? x : par[x] = get(par[x]); }\n  public:\n  Dsu(int n = 0) : par(n), ss(n, 1), ans(n) {\n    for (int i = 0; i < n; i++)\n      par[i] = ans[i] = i;\n  }\n  int getAns(int x) { return ans[get(x)]; }\n  void mergeTo(int a, int b) {\n    a = get(a); b = get(b);\n    if (a == b) return;\n\n    int nv = ans[b];\n    if (ss[a] > ss[b]) swap(a, b);\n    par[a] = b;\n    ss[b] += ss[a];\n    ans[b] = nv;\n  }\n};\n\nvb was;\nvvi es, esid;\n\nvvi rqs, rqids;\nvi rans;\n\nDsu dsu;\n\nvoid dfs(int v) {\n  was[v] = true;\n  for (int i = 0; i < sz(rqs[v]); i++) {\n    int b = rqs[v][i];\n    if (!was[b]) continue;\n    \n    int id = rqids[v][i];\n    assert(rans[id] < 0);\n    rans[id] = dsu.getAns(b);\n  }\n  \n  for (int i = 0; i < sz(es[v]); i++) {\n    int b = es[v][i];\n    if (was[b]) continue;\n    dfs(b);\n    dsu.mergeTo(b, v);\n  }\n}\n\nvi eans;\nvi ds;\nint dfs2(int v) {\n  was[v] = true;\n  int res = ds[v];\n  for (int i = 0; i < sz(es[v]); i++) {\n    int b = es[v][i];\n    if (was[b]) continue;\n    int cres = dfs2(b);\n    eans[esid[v][i]] = cres;\n    res += cres;\n  }\n  return res;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME \".in\", \"r\", stdin);\n  freopen(TASKNAME \".out\", \"w\", stdout);\n  #endif\n  \n  int n;\n  while (scanf(\"%d\", &n) >= 1) {\n    es = vvi(n); esid = vvi(n);\n    for (int i = 0; i < n - 1; i++) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b), a--, b--;\n      es[a].pb(b); esid[a].pb(i);\n      es[b].pb(a); esid[b].pb(i);\n    }\n    \n    int k;\n    scanf(\"%d\", &k);\n    rqs = vvi(n);\n    rqids = vvi(n);\n    \n    vector<pii> rls;\n    for (int i = 0; i < k; i++) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b), a--, b--;\n      rls.pb(mp(a, b));\n      rqs[a].pb(b); rqids[a].pb(i);\n      if (a != b) {\n        rqs[b].pb(a); rqids[b].pb(i);\n      }\n    }\n    \n    was = vb(n, false);\n    rans = vi(k, -1);\n    dsu = Dsu(n);\n    dfs(0);\n    \n    ds = vi(n, 0);\n    for (int i = 0; i < k; i++) {\n      ds[rls[i].first]++;\n      ds[rls[i].second]++;\n      ds[rans[i]] -= 2;\n    }\n    \n    eans = vi(n - 1, 0);\n    was = vb(n, false);\n    dfs2(0);\n    for (int i = 0; i <  n - 1; i++)\n      printf(\"%d%c\", eans[i], \"\\n \"[i + 1 < n - 1]);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "trees"], "dificulty": "1900", "interactive": false}