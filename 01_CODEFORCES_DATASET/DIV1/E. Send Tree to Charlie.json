{"link": "https://codeforces.com//contest/1254/problem/E", "problemId": "475574", "problem_idx": "E", "shortId": "1254E", "contest_number": "1254", "problem_submissions": {"E": [65385076, 65389059, 65387406, 65386461, 65391860, 65388358, 65363435, 65898589, 65898484, 65394164, 65399861, 66201727, 65511222, 65387985, 65459118, 65393939, 65393500, 65393329], "D": [65367776, 65371157, 65363228, 65371547, 65376523, 65913436, 65376504, 65392793, 65392745, 65392458, 65378396, 65374788, 65374479, 65375973, 72224123, 72224118, 72222073, 66201641, 66201609, 65765881, 65505837, 65498656, 65498523, 65498350, 65448275, 65421529, 65421428, 65420506, 65420496, 65420340, 65420220, 65419939, 65419809, 65419466, 65419306, 65410495, 65410139, 65394253, 65394071, 65393989, 65393862, 65393694, 65393607, 65393012, 65391960, 65391551, 65372156, 65379236, 65379295, 65458244, 65380498, 65379619, 65398630, 65392892, 65392821, 65392515, 65379510, 65376362, 65378466, 65385723], "C": [65362906, 65363606, 65372750, 65364742, 65368283, 65376926, 65364286, 65368353, 65366513, 65367352, 65362577, 65365184, 65369353, 65366181, 65364840, 65369974, 65366318, 65369506], "B1": [65358065, 65358880, 65365540, 65357743, 65359033, 65368715, 65359200, 65362593, 65360678, 65362903, 65376471, 65360693, 65359085, 65359111, 65357280, 65361721, 65360645, 65360620, 65355048], "B2": [65357919, 65358760, 65365394, 65357802, 65363382, 65368676, 65359261, 65362680, 65360774, 65362731, 65376512, 65360901, 65359018, 65358907, 65360708, 65398529, 65398522, 65398389, 65398370, 65398329, 65398291, 65398212, 65361653, 65360607, 65360509, 65354503], "A": [65355800, 65355044, 65354936, 65355999, 65356253, 65372457, 65355826, 65357065, 65357334, 65359043, 65356279, 65357553, 65355832, 65355374, 65354099, 65354766, 65367155, 65356549, 65357393]}, "name": "E. Send Tree to Charlie", "statement": "Christmas was knocking on the door, and our protagonist, Bob, was\r\npreparing a spectacular present for his long-time second best friend\r\nCharlie. As chocolate boxes are lame, he decided to decorate a tree\r\ninstead. Bob\u2019s tree can be represented as an undirected connected graph\r\nwith n nodes (numbered 1 to n) and n-1 edges. Initially, Bob placed a\r\ndecoration with label i on node i, for each 1\r\nle i\r\nle n. However, as such a simple arrangement is lame, he decided to\r\nshuffle the decorations a bit. Formally, Bob did the following steps:\r\nFirst, he listed the n-1 edges in some order. Then, he considered the\r\nedges one by one in that order. For each edge (u, v), he swapped the\r\ndecorations of node u with the one of node v.After finishing, Bob seemed\r\nsatisfied with the arrangement, so he went to sleep.The next morning,\r\nBob wakes up only to find out that his beautiful arrangement has been\r\nruined! Last night, Bob\u2019s younger brother Bobo dropped some of the\r\ndecorations on the floor while he was playing with the tree.\r\nFortunately, no decorations were lost, so Bob can repair the tree in no\r\ntime. However, he completely forgets how the tree looked like yesterday.\r\nTherefore, given the labels of the decorations still on the tree, Bob\r\nwants to know the number of possible configurations of the tree. As the\r\nresult can be quite large, Bob will be happy if you can output the\r\nresult modulo 1000000007 (10^9+7). Note that, it is possible that there\r\nexists no possible configurations.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=1000*1000*1000+7;\n\nint n;\nvi graf[nax];\n\nint pre[nax];\nint post[nax];\nint czas;\n\nint tab[nax];\n\nint ojc[nax];\n\nvector <pii> pary[nax];\n\nll wyn=1;\n\nvoid nope()\n{\n\tprintf(\"0\\n\");\n\texit(0);\n}\n\nvoid dfs1(int v, int o)\n{\n\tczas++;\n\tpre[v]=czas;\n\tojc[v]=o;\n\tfor (int &i : graf[v])\n\t{\n\t\tif (i==ojc[v])\n\t\t{\n\t\t\tswap(i, graf[v].back());\n\t\t\tgraf[v].pop_back();\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i : graf[v])\n\t\tdfs1(i, v);\n\tpost[v]=czas;\n}\n\nint oper;\n\nint lca(int a, int b)\n{\n\twhile(a!=b)\n\t{\n\t\tif (pre[a]<pre[b])\n\t\t\tswap(a, b);\n\t\toper++;\n\t\ta=ojc[a];\n\t}\n\tif (oper>5*1000*1000)\n\t\tnope();\n\treturn a;\n}\n\nvi sci(int a, int b)\n{\n\tvi ret{a};\n\twhile(a!=b)\n\t{\n\t\ta=ojc[a];\n\t\tret.push_back(a);\n\t}\n\treturn ret;\n}\n\nvoid rob(int v)\n{\n\tint w=lca(v, tab[v]);\n\tif (w==v)\n\t{\n\t\tvi wez=sci(tab[v], v);\n\t\tint r=wez.size();\n\t\tpary[v].push_back({v, wez[r-2]});\n\t\tfor (int i=r-2; i>0; i--)\n\t\t\tpary[wez[i]].push_back({0, wez[i-1]});\n\t\tpary[tab[v]].push_back({0, tab[v]});\n\t\treturn;\n\t}\n\tif (w==tab[v])\n\t{\n\t\tvi wez=sci(v, tab[v]);\n\t\tint r=wez.size();\n\t\tpary[tab[v]].push_back({wez[r-2], tab[v]});\n\t\tfor (int i=r-2; i>0; i--)\n\t\t\tpary[wez[i]].push_back({wez[i-1], 0});\n\t\tpary[v].push_back({v, 0});\n\t\treturn;\n\t}\n\tvi raz=sci(v, w);\n\tvi dwa=sci(tab[v], w);\n\t\n\t\n\tfor (int i=((int)dwa.size())-2; i>0; i--)\n\t\tpary[dwa[i]].push_back({0, dwa[i-1]});\n\t\t\n\tfor (int i=((int)raz.size())-2; i>0; i--)\n\t\tpary[raz[i]].push_back({raz[i-1], 0});\n\t\t\n\tpary[v].push_back({v, 0});\n\tpary[tab[v]].push_back({0, tab[v]});\n\t\n\tint rr=raz.size();\n\tint rd=dwa.size();\n\t\n\tpary[w].push_back({raz[rr-2], dwa[rd-2]});\n}\n\nint foj[nax];\n\nint in[nax];\nint out[nax];\n\nint fin(int v)\n{\n\tif (v!=foj[v])\n\t\tfoj[v]=fin(foj[v]);\n\treturn foj[v];\n}\n\nvoid uni(int a, int b)\n{\n\tfoj[fin(a)]=fin(b);\n}\n\nvoid solve(int v)\n{\n\tsort(pary[v].begin(), pary[v].end());\n\tpary[v].resize(unique(pary[v].begin(), pary[v].end())-pary[v].begin());\n\tvi wie{v};\n\tif (v>1)\n\t\twie.push_back(0);\n\tfor (int i : graf[v])\n\t\twie.push_back(i);\n\tint r=wie.size();\n\tfor (int i : wie)\n\t{\n\t\tfoj[i]=i;\n\t\tin[i]=0;\n\t\tout[i]=0;\n\t}\n\tfor (pii i : pary[v])\n\t{\n\t\tout[i.first]++;\n\t\tin[i.second]++;\n\t}\n\tfor (int i : wie)\n\t{\n\t\tif (in[i]>1 || out[i]>1)\n\t\t\tnope();\n\t}\n\tint lacz=0;\n\tfor (pii i : pary[v])\n\t{\n\t\tint a=i.first;\n\t\tint b=i.second;\n\t\tif (fin(a)==fin(b))\n\t\t{\n\t\t\tlacz++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuni(a, b);\n\t\t}\n\t}\n\tint spo=0;\n\tfor (int i : wie)\n\t\tspo+=(foj[i]==i);\n\tif (lacz && spo>1)\n\t\tnope();\n\t//~ if (v==1)\n\t\t//~ spo--;\n\t//~ debug() << imie(v) << \" \" << imie(spo);\n\tfor (int i=1; i<spo; i++)\n\t\twyn=(wyn*i)%mod;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\tdfs1(1, 0);\n\t//~ pary[1].push_back({0, 1});\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (!tab[i])\n\t\t\tcontinue;\n\t\tif (tab[i]==i)\n\t\t\tnope();\n\t\trob(i);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tdebug() << i << \" \" << pary[i];\n\tfor (int i=1; i<=n; i++)\n\t\tsolve(i);\n\t//~ debug() << \"dod\";\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dfs and similar", "dsu", "trees"], "dificulty": "3300", "interactive": false}