{"link": "https://codeforces.com//contest/1943/problem/F", "problemId": "2535046", "problem_idx": "F", "shortId": "1943F", "contest_number": "1943", "problem_submissions": {"E2": [251755986, 251774166, 251721110, 251772938, 251976046, 251850394, 251783692, 252482559, 251768795, 251806219, 251801786, 251784602, 251808955, 251786442, 251790915, 251791945, 252167133, 254017076, 252396752, 251948632], "E1": [251743400, 251761808, 251720570, 251764606, 251765135, 251768616, 251774247, 251768081, 251767041, 251779764, 251763055, 251770682, 251776382, 251772657, 253458372, 251772270, 251777192, 251779122, 251781255], "D2": [251730537, 251743841, 251769783, 251827860, 251827638, 251812685, 251750876, 251749250, 251743677, 251754133, 251758370, 251752785, 251846892, 251763163, 251753145, 251743858, 251746564, 251754334, 251790796, 253458316, 251757628, 251757687, 251759092, 251761488], "D1": [251727886, 251730644, 251753185, 251730641, 251733326, 251727921, 251742335, 251739558, 251743910, 251737861, 251737457, 251736749, 251746112, 251745451, 251785836, 252959932, 251749532, 251743349, 251754372, 251751101], "C": [251715534, 251721073, 251747865, 251720444, 251722988, 251756982, 251730923, 251730217, 251735041, 251727939, 251724586, 251722879, 251721249, 251735499, 251732028, 252959913, 251731321, 251736408, 251741233, 251741283], "B": [251709195, 251712754, 251737904, 251712353, 251714193, 252482757, 251715199, 251720530, 251721280, 251721320, 251719084, 251718139, 251714047, 251713923, 251720644, 251719922, 252531274, 251717454, 251716526, 251722194, 252064777, 251726935], "A": [251701793, 251702717, 251723885, 251701730, 251702780, 251702880, 251702623, 251701902, 251707932, 251702391, 251707705, 251702309, 251701731, 251703701, 251706521, 252531268, 251732626, 251703091, 251704741, 251703882], "F": [251801182, 252436931, 251845260, 251783880]}, "name": "F. Minimum Hamming Distance", "statement": "You are given a binary string^\r\ndagger s of length n.A binary string p of the same length n is called if\r\nfor every i (1\r\nleq i\r\nleq n), there exist indices l and r such that: 1\r\nleq l\r\nleq i\r\nleq r\r\nleq n s_i is a mode^\r\nddagger of the string p_lp_{l+1}\r\nldots p_r You are given another binary string t of length n. Find the\r\nminimum Hamming distance^\r\nS between t and any string g.^\r\ndagger A binary string is a string that only consists of characters\r\nmathtt{0} and\r\nmathtt{1}.^\r\nddagger Character c is a mode of string p of length m if the number of\r\noccurrences of c in p is at least\r\nlceil\r\nfrac{m}{2}\r\nrceil. For example,\r\nmathtt{0} is a mode of\r\nmathtt{010},\r\nmathtt{1} is not a mode of\r\nmathtt{010}, and both\r\nmathtt{0} and\r\nmathtt{1} are modes of\r\nmathtt{011010}.^\r\nS The Hamming distance of strings a and b of length m is the number of\r\nindices i such that 1\r\nleq i\r\nleq m and a_i\r\nneq b_i.\r\n", "solutions": ["#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n#define sz(x) int(size(x))\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(const V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(const V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? \",\" : \"\"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n'\n\t\t                                                             : ' ';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << '{';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << '}';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << '(';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << ')';\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << \"\\033[0;31m\";\n\t\tImpl(t);\n\t\tif (debug) os << \"\\033[0m\";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << '\\n'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep(\" | \", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep(\" | \", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m\"\n\t     << \" | \"\n\t     << \"\\u001b[34m\" << func << \"\\033[0m\"\n\t     << \":\"\n\t     << \"\\u001b[34m\" << line << \"\\033[0m\"\n\t     << \" - \"\n\t     << \"[\" << args << \"] = \";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\n}\n}  // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nint sgn(char c) { return c == '1' ? 1 : -1; }\n\nvoid solve(int tc) {\n\tdef(int, N);\n\tstr S, T;\n\tre(S, T);\n\t// assume end with at least as many ones as zeros\n\t// only 0s might be unsat\n\tif (count(all(T), '0') > count(all(T), '1')) {\n\t\teach(c, S) c ^= '0' ^ '1';\n\t\teach(c, T) c ^= '0' ^ '1';\n\t}\n\tV<vi> dp(N + 1);\n\tF0R(i, N + 1) dp[i].rsz(i + 1, N);\n\tdp.at(0).at(0) = 0;\n\tvi cum{0};\n\tfor (char c : T) cum.pb(cum.bk + sgn(c));\n\tassert(cum.bk >= 0);\n\tV<vi> balance(N + 1, vi(N + 1));\n\t// dbg(\"BEGIN BALANCE\");\n\tFOR(r, 1, N + 1) F0R(num_change, N + 1) {\n\t\tif (num_change == 0 || T.at(r - 1) == '0') {\n\t\t\tbalance.at(r).at(num_change) =\n\t\t\t    max(balance.at(r - 1).at(num_change) - sgn(T.at(r - 1)), 0);\n\t\t} else {  // change 1 to 0\n\t\t\tbalance.at(r).at(num_change) =\n\t\t\t    balance.at(r - 1).at(num_change - 1) + 1;\n\t\t}\n\t}\n\t// dbg(\"END BALANCE\");\n\tF0R(i, N) F0R(j, i + 1) {\n\t\t// dbg(i, j, dp.at(i).at(j));\n\t\tif (T.at(i) == '0') {\n\t\t\tckmin(dp.at(i + 1).at(j + 1), dp.at(i).at(j));\n\t\t\tcontinue;\n\t\t}\n\t\tckmin(dp.at(i + 1).at(j + 1),\n\t\t      dp.at(i).at(j) + 1);  // use 0\n\t\tif (j || S.at(i) == '1') {  // use 1\n\t\t\tckmin(dp.at(i + 1).at(max(j - 1, 0)), dp.at(i).at(j));\n\t\t} else {\n\t\t\t// use 1 but return to same place eventually\n\t\t\tfor (int r = i + 2; r <= N; r += 2)\n\t\t\t\tif (cum.at(r) >= cum.at(i)) {\n\t\t\t\t\tint num_change = (cum.at(r) - cum.at(i)) / 2;\n\t\t\t\t\tckmin(dp.at(r).at(balance.at(r).at(num_change)),\n\t\t\t\t\t      dp.at(i).at(j) + num_change);\n\t\t\t\t}\n\t\t}\n\t}\n\tps(*min_element(all(dp.bk)));\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON'T GET STUCK ON ONE APPROACH\n */\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "3500", "interactive": false}