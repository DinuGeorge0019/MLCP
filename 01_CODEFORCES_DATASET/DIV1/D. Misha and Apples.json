{
    "link": "https://codeforces.com//contest/1819/problem/D",
    "problemId": "1880621",
    "problem_idx": "D",
    "shortId": "1819D",
    "contest_number": "1819",
    "problem_submissions": {
        "E": [
            202225318,
            202223532,
            202223484,
            202225560,
            202308964,
            202224265,
            202225112,
            202221853,
            202253482,
            202237435,
            203635743,
            203096948,
            202225859,
            202369794
        ],
        "D": [
            202209352,
            202212141,
            202205538,
            202220831,
            202198559,
            202210822,
            202236119,
            202239190,
            202212242,
            202208889,
            202205391,
            202216800,
            203995136,
            202197649,
            202216978,
            202217768,
            202220492,
            202220964,
            202225376,
            202219172
        ],
        "C": [
            202201042,
            202203020,
            202193305,
            202202657,
            202190230,
            202199701,
            202199472,
            202200745,
            202199789,
            202199523,
            208251329,
            202218422,
            202204297,
            202216624,
            202204671,
            202205053,
            202201997,
            202201056,
            202198992
        ],
        "B": [
            202193365,
            202195322,
            202214813,
            202196120,
            202186520,
            202187817,
            202188682,
            202193750,
            202186708,
            202188527,
            202188957,
            202183110,
            202191595,
            202187157,
            202193385,
            202195604,
            202188109,
            202186084,
            202189411
        ],
        "A": [
            202182367,
            202180872,
            202181217,
            202181093,
            202180590,
            202180859,
            202181832,
            202181960,
            202180690,
            202180596,
            202180602,
            202180463,
            202182678,
            202180651,
            202182633,
            202181119,
            202181593,
            202180899,
            202180615
        ],
        "F": [
            202939012,
            206043011
        ]
    },
    "name": "D. Misha and Apples",
    "statement": "Schoolboy Misha got tired of doing sports programming, so he decided to\r\nquit everything and go to the magical forest to sell magic apples.His\r\nfriend Danya came to the magical forest to visit Misha. What was his\r\nsurprise when he found out that Misha found a lot of friends there, the\r\nsame former sports programmers. And all of them, like Misha, have their\r\nown shop where they sell magic apples. To support his friends, who have\r\nchanged their lives so drastically, he decided to buy up their entire\r\nassortment.The buying process works as follows: in total there are n\r\nstalls, numbered with integers from 1 to n, and m kinds of magic apples,\r\nnumbered with integers from 1 to m. Each shop sells some number of kinds\r\nof apples. Danya visits all the shops in order of increasing number,\r\nstarting with the first one. Upon entering the shop he buys one magic\r\napple of each kind sold in that shop and puts them in his\r\nbackpack.However, magical apples wouldn\u2019t be magical if they were all\r\nright. The point is that when two apples of the same type end up\r\ntogether in the backpack, all of the apples in it magically disappear.\r\nImportantly, the disappearance happens after Danya has put the apples in\r\nthe backpack and left the shop.Upon returning home, Danya realized that\r\nsomewhere in the forest he had managed to lose his backpack.\r\nUnfortunately, for some shops Danya had forgotten what assortment of\r\napples there was. Remembering only for some shops, what kinds of magical\r\napples were sold in them, he wants to know what is the maximum number of\r\napples he could have in his backpack after all his purchases at best.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n\n#define ll long long\n#define int ll\n#define ull unsigned ll\n#define ld long double\n#define rep(a) rep1(i,a)\n#define rep1(i,a) rep2(i,0,a)\n#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)\n#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)\n#define chkmin(a,b) (a=min(a,b))\n#define chkmax(a,b) (a=max(a,b))\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int>\n#define pb push_back\n#define eb emplace_back\n#define sort_unique(a) sort(all(a)),a.resize(unique(all(a))-a.begin())\n//#define inf 1010000000\n#define inf 4000000000000000000\n#define eps 1e-9\n#define sz(a) ((int)a.size())\n#define pow2(x) (1ll<<(x))\n#define ceiling(a,b) (((a)+(b)-1)/(b))\n#define print0(a) cout << (a) << ' '\n#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#ifdef i_am_noob\n#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)\ntemplate<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(T && x) {cerr << x << endl;}\ntemplate<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}\n#else\n#define bug(...) 777771449\n#endif\ntemplate<typename T> void print(T && x) {cout << x << \"\\n\";}\ntemplate<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\n\nconst int Mod=1000000007,Mod2=998244353;\nconst int MOD=Mod2;\ntemplate <int mod>\nstruct Modint{\n    int val;\n    Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}\n    Modint operator +(const Modint& o) const {\n        Modint res;\n        res.val=val+o.val;\n        if(res.val>=mod) res.val-=mod;\n        return res;\n    }\n    Modint operator +(const int& o) const {return Modint(val+o);}\n    Modint operator -() const {\n        Modint res;\n        res.val=-val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const Modint& o) const {\n        Modint res;\n        res.val=val-o.val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const int& o) const {return Modint(val-o);}\n    Modint operator *(const Modint& o) const {return Modint(val*o.val);}\n    Modint operator *(const int& o) const {return Modint(val*(o%mod));}\n    Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}\n    Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}\n    Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}\n    Modint Pow(int b) const {\n        Modint tmp(val),ret(1);\n        while(b){\n            if(b&1) ret*=tmp;\n            b>>=1;tmp*=tmp;\n        }\n        return ret;\n    }\n    Modint Pow(const Modint& a, int b) const {return a.Pow(b);}\n    inline Modint inv() const {return (*this).Pow(mod-2);}\n    Modint operator /(const Modint& o) const {return *this*o.inv();}\n    Modint operator /(const int& o) const {return *this*Modint(o).inv();}\n    bool operator ==(const Modint& o) const {return val==o.val;}\n};\ntemplate<int mod>\nostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}\ntemplate<int mod>\nModint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}\ntemplate<int mod>\nModint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}\ntemplate<int mod>\nModint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}\n#define modint Modint<MOD>\nvector<modint> inv,fac,invfac;\nvoid init_comb(int N){\n    inv.resize(N),fac.resize(N),invfac.resize(N);\n    inv[1]=1,fac[0]=1,invfac[0]=1;\n    rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);\n    rep2(i,1,N) fac[i]=fac[i-1]*i;\n    rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];\n}\ninline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}\ninline modint H(int n, int m){return C(n+m-1,n);}\n\ntemplate<typename T, T(*op)(T,T), T(*e)(), signed N>\nstruct segtree{\n    static const signed maxn=1<<__lg(N-1)+1;\n    T val[maxn<<1];\n    segtree(){rep(maxn<<1) val[i]=e();}\n    void pull(signed k){val[k]=op(val[k<<1],val[k<<1|1]);}\n    void modify(signed p, T x){\n        p+=maxn;\n        val[p]=x;\n        for(p>>=1; p; p>>=1) pull(p);\n    }\n    T query(signed l, signed r){\n        T resl=e(),resr=e();\n        l+=maxn,r+=maxn+1;\n        while(l<r){\n            if(l&1) resl=op(resl,val[l++]);\n            if(r&1) resr=op(val[--r],resr);\n            l>>=1,r>>=1;\n        }\n        return op(resl,resr);\n    }\n    signed first_true(bool(*f)(T)){\n        if(f(e())) return -1;\n        signed cur=1;\n        T curval=e();\n        while(cur<maxn){\n            if(!f(op(curval,val[cur*2]))) curval=op(curval,val[cur*2]),cur=cur*2+1;\n            else cur*=2;\n        }\n        curval=op(curval,val[cur]);\n        if(!f(curval)) return maxn;\n        return cur-maxn;\n    }\n};\n\nconst int maxn=200005,maxm=pow2(17),maxk=7777714;\n\n//i_am_noob\n#define wiwihorz  \nvoid balbitorz(){}\nint n,m,nxt[maxn],dp[maxn],lst[maxn];\nvector<int> a[maxn];\nint op(int x, int y){return max(x,y);}\nint e(){return -inf;}\nsegtree<int,op,e,maxn> tree;\n\nvoid orzck(){\n    cin >> n >> m;\n    rep(n){\n        int k; cin >> k;\n        a[i].resize(k);\n        for(auto& j: a[i]) cin >> j,j--,lst[j]=-1;\n    }\n    rep(n) nxt[i]=n;\n    rep(n){\n        for(auto& j: a[i]){\n            if(lst[j]>=0) chkmin(nxt[lst[j]],i);\n            lst[j]=i;\n        }\n    }\n    rep3(i,n-2,0) chkmin(nxt[i],nxt[i+1]);\n    int res=0,de=n;\n    rep(n+1) tree.modify(i,e());\n    int tmp=0;\n    dp[n]=0;\n    tree.modify(n,dp[n]);\n    rep3(i,n-1,0){\n        if(sz(a[i])==0) de=i;\n        tmp+=sz(a[i]);\n        if(nxt[i]==n){\n            if(de==n) dp[i]=tmp;\n            else dp[i]=m;\n        }\n        else{\n            int l=max(i+1,de),r=nxt[i];\n            chkmin(l,r);\n            dp[i]=tree.query(l+1,r+1);\n        }\n        tree.modify(i,dp[i]);\n        bug(i,dp[i]);\n    }\n    print(dp[0]);\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    // #ifdef i_am_noob\n    // freopen(\"input1.txt\",\"r\",stdin);\n    // freopen(\"output1.txt\",\"w\",stdout);\n    // freopen(\"output2.txt\",\"w\",stderr);\n    // #endif\n    cout << fixed << setprecision(15);\n    ld start=clock();\n    balbitorz();\n    int t;\n    #ifdef wiwihorz\n    cin >> t;\n    #else\n    t=1;\n    #endif\n    while(t--) orzck();\n    bug((clock()-start)/CLOCKS_PER_SEC);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "two pointers"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Misha and Apples.json",
    "editorial_link": "https://codeforces.com//blog/entry/115133",
    "editorial": "In this problem, we need to choose which types of apples will be sold in\r\nstores with . Let\u00e2\u0080\u0099s fix some arrangement of apples and consider the last\r\nmoment in it when the apples disappeared from the backpack. All the\r\napples that we took after this moment will go into the final answer, and\r\nif there was also a store with among these stores, then the answer is\r\nequal to .Depending on the arrangement of apples, the moments of the\r\nlast zeroing may change, so let\u00e2\u0080\u0099s find all such moments of time after\r\nwhich disappearance may occur, and for all such moments, let\u00e2\u0080\u0099s check if\r\nwe can reach the end without zeroing, and if we can, then what is the\r\nmaximum number of apples we can collect after that.Formally, let\u00e2\u0080\u0099s\r\ncalculate for all , equal to 1 if there is such an arrangement of apples\r\nthat after purchases in stores on the segment , the backpack will be\r\nempty, and 0 otherwise, with . Also, let\u00e2\u0080\u0099s calculate for all , equal to\r\n0 if after passing on the segment with an initially empty backpack, we\r\nare guaranteed to empty the backpack at least once, otherwise equal to\r\nif there is a store with on this segment, otherwise equal to the total\r\nnumber of apples on this segment, with .The second array is easily\r\ncalculated by definition. Let\u00e2\u0080\u0099s consider one of the ways to build the\r\nfirst array. We will build it from left to right. If , then we can\r\nguarantee that the backpack will be empty after this store, so the value\r\nof for such is 1. Otherwise, consider all the apples in this store.\r\nAfter the -th store, the apples will disappear if one of these apples\r\nwas already in the backpack before. Let\u00e2\u0080\u0099s find the maximum such that the\r\nstore contains one of the apples in the store , or . Now let\u00e2\u0080\u0099s find the\r\nmaximum such that . Then we check that there will be no disappearances\r\non the segment . In this case, , otherwise it is equal to 0.Then the\r\nanswer will be .Time complexity: .\r\n"
}