{
    "link": "https://codeforces.com//contest/547/problem/E",
    "problemId": "28333",
    "problem_idx": "E",
    "shortId": "547E",
    "contest_number": "547",
    "problem_submissions": {
        "A": [
            11306176,
            11281663,
            11286152,
            11283154,
            11300410,
            11282966,
            11282839,
            11284240,
            11282987,
            11283935,
            11284453,
            11283105,
            11302976,
            11296402,
            11304989
        ],
        "E": [
            11300374,
            11295900,
            11296096,
            11332517,
            11332504,
            11301614,
            11329764,
            11329670,
            11329557,
            11302402,
            11296504,
            11303628,
            11310167,
            11310570,
            11335792,
            11334862,
            11310094,
            11298023,
            11289647
        ],
        "D": [
            11290397,
            11311418,
            11289189,
            11307197,
            11288244,
            11306223,
            11292199,
            11318433,
            11338617,
            11294617,
            11298075,
            11296934,
            11291997,
            11293528,
            11292331,
            11330482
        ],
        "C": [
            11288602,
            11286288,
            11282036,
            11285135,
            11284518,
            11286983,
            11288810,
            11287248,
            11292291,
            11290371,
            11293842,
            11290787,
            11289508,
            11302378,
            11289341,
            11290547,
            11300174
        ],
        "B": [
            11284410,
            11282963,
            11283861,
            11287519,
            11281935,
            11284503,
            11284754,
            11285157,
            11286946,
            11285798,
            11286796,
            11285456,
            11285604,
            11286200,
            11285607,
            11286328,
            11292395
        ]
    },
    "name": "E. Mike and Friends",
    "statement": "What-The-Fatherland is a strange country! All phone numbers there are\r\nstrings consisting of lowercase English letters. What is double strange\r\nthat a phone number can be associated with several bears!In that country\r\nthere is a rock band called CF consisting of bears (including Mike)\r\nnumbered from to . Phone number of -th member of CF is . May 17th is a\r\nholiday named Phone Calls day. In the last Phone Calls day, everyone\r\ncalled all the numbers that are substrings of his/her number (one may\r\ncall some number several times). In particular, everyone called himself\r\n(that was really strange country).Denote as the number of times that -th\r\nmember of CF called the -th member of CF. The geek Mike has questions\r\nthat he wants to ask you. In each question he gives you numbers and and\r\nyou should tell him the number\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 4e5+10;\n// template end here\n\nconst int MAXLEN = (int)4e5 + 5;\n\nchar s[MAXLEN];\nint SA[MAXLEN], cnt[MAXLEN], ary1[MAXLEN], ary2[MAXLEN];\nint *Rank, *Height;\n\n\ninline bool cmp(int *r, int a, int b, int l) {\n    return r[a] == r[b] && r[a + l] == r[b + l];\n}\n\nvoid make_suffix_array(int MSIZE, int len) {\n    int p, *x, *y, *tmp, i, j, k;\n    x = ary1; y = ary2;\n    memset(cnt, 0, sizeof(int) * MSIZE);\n    for (i = 0; i < len; i++) cnt[x[i] = s[i]]++;\n    for (i = 1; i < MSIZE; i++) cnt[i] += cnt[i - 1];\n    for (i = len - 1; i >= 0; i--) SA[--cnt[x[i]]] = i;\n    for (j = p = 1; p < len; j <<= 1, MSIZE = p) {\n        for (p = 0, i = len - j; i < len; i++) y[p++] = i;\n        for (i = 0; i < len; i++) {\n            if (SA[i] >= j) y[p++] = SA[i] - j;\n        }\n        memset(cnt, 0, sizeof(int) * MSIZE);\n        for (i = 0; i < len; i++) cnt[x[y[i]]]++;\n        for (i = 1; i < MSIZE; i++) cnt[i] += cnt[i - 1];\n        for (i = len - 1; i >= 0; i--) SA[--cnt[x[y[i]]]] = y[i];\n        tmp = x; x = y; y = tmp;\n        x[SA[0]] = 0;\n        for (i = p = 1; i < len; i++) {\n            x[SA[i]] = cmp(y, SA[i - 1], SA[i], j) ? p - 1 : p++;\n        }\n    }\n    Rank = x;\n    Height = y;\n    for (i = k = 0; i < len - 1; i++) {\n        if (k > 0) k--;\n        j = SA[Rank[i] - 1];\n        while (s[i + k] == s[j + k]) k++;\n        Height[Rank[i]] = k;\n    }\n}\nint st[SIZE],len[SIZE],from[SIZE],two[SIZE];\nint ma[19][SIZE];\nint rmq(int L,int R){\n    int lv=two[R-L+1];\n    return min(ma[lv][L],ma[lv][R-(1<<lv)+1]);\n}\nint L[SIZE],R[SIZE];\nint BIT[SIZE];\nint an[500001];\nvoid ins(int x){\n    x++;\n    for(;x<SIZE;x+=x&-x)BIT[x]++;\n}\nint qq(int x){\n    x++;\n    int res=0;\n    for(;x;x-=x&-x)res+=BIT[x];\n    return res;\n}\nVPII ker[SIZE];\nint main(){\n    for(int i=2;i<SIZE;i++)two[i]=two[i>>1]+1;\n    MS1(from);\n    DRII(n,q);\n    int now=0;\n    REP(i,n){\n        RS(s+now);\n        st[i]=now;\n        from[now]=i;\n        len[i]=strlen(s+now);\n        now+=len[i];\n        s[now]='a'-1;\n        now++;\n    }\n    s[now-1]=0;\n    make_suffix_array(128,now);\n    REP(i,now)ma[0][i]=Height[i];\n    REPP(i,1,19){\n        REP(j,now){\n            if(j+(1<<i)<=now)ma[i][j]=min(ma[i-1][j],ma[i-1][j+(1<<(i-1))]);\n        }\n    }\n    REP(i,n){\n        int me=Rank[st[i]];\n        int ll=0,rr=me+1;\n        while(ll<rr){\n            int mm=(ll+rr)>>1;\n            if(rmq(mm,me)>=len[i])rr=mm;\n            else ll=mm+1;\n        }\n        L[i]=ll-1;\n        ll=me;\n        rr=now-1;\n        while(ll<rr){\n            int mm=(ll+rr+1)>>1;\n            if(rmq(me+1,mm)>=len[i])ll=mm;\n            else rr=mm-1;\n        }\n        R[i]=ll;\n    }\n    REP(i,q){\n        DRIII(x,y,z);\n        x--;y--;z--;\n        ker[R[z]].PB(MP(st[y]+len[y]-1,i+1));\n        ker[R[z]].PB(MP(st[x]-1,-i));\n        if(L[z]){\n            ker[L[z]-1].PB(MP(st[y]+len[y]-1,-i));\n            ker[L[z]-1].PB(MP(st[x]-1,i+1));\n        }\n    }\n    REP(i,now){\n        ins(SA[i]);\n        REP(j,SZ(ker[i])){\n            int id,ty;\n            if(ker[i][j].S>0){\n                id=ker[i][j].S-1;\n                ty=1;\n            }\n            else{\n                id=-ker[i][j].S;\n                ty=-1;\n            }\n            an[id]+=qq(ker[i][j].F)*ty;\n        }\n    }\n    REP(i,q)printf(\"%d\\n\",an[i]);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "string suffix structures",
        "strings",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Mike and Friends.json",
    "editorial_link": "https://codeforces.com/blog/entry/18126",
    "editorial": "which is the number of occurrences of in . Concatenate all strings\r\ntogether in order (an put null character between them) and call it\r\nstring . We know that . Consider . Consider Consider for each , ().\r\nAlso, for character of which is not a null character, consider it\r\nbelongs to . Calculate the suffix array of in and show it by (we show\r\neach suffix by the index of its beginning). For each query, we want to\r\nknow the number of occurrences of in . For this propose, we can use this\r\nsuffix array. Consider that we show suffix of starting from index by .\r\nAlso, for each , calculate totally in and show it by . For each query,\r\nconsider , also find minimum number and maximum number (using binary\r\nsearch and sparse table on sequence ) such that and and . Finally answer\r\nof this query is the number of elements in that are in the interval .\r\nThis problem is just like KQUERY. You can read my offline approach for\r\nKQUERY here. It uses segment tree, but you can also use Fenwick instead\r\nof segment tree. This wasnât my main approach. My main approach uses\r\naho-corasick and a data structure I invented and named it C-Tree. Time\r\ncomplexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()\r\nC++ Code by Haghani (Suffix array construction in and the rest in ) Java\r\nCode by Zlobober If thereâs any suggestion or error let me know.\r\n",
    "hint": []
}