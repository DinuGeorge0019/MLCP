{
    "link": "https://codeforces.com//contest/696/problem/D",
    "problemId": "65171",
    "problem_idx": "D",
    "shortId": "696D",
    "contest_number": "696",
    "problem_submissions": {
        "E": [
            20498917,
            19122817,
            19128171,
            19128416,
            19128548,
            19128551,
            19129321,
            142908498,
            19129056,
            19129065,
            19148528,
            19121431
        ],
        "A": [
            19119258,
            19112517,
            19113245,
            19130646,
            19113356,
            19114035,
            19112027,
            19112329,
            19113544,
            19115943,
            19114049,
            19111947,
            19112445,
            19112591,
            19113340,
            19112458,
            19127604,
            19113354,
            19112419,
            19122807
        ],
        "B": [
            19118714,
            19115949,
            19116617,
            19115367,
            19115254,
            19116922,
            19113777,
            19114248,
            19115893,
            19113611,
            19114745,
            19113499,
            19115275,
            19114851,
            19115798,
            19115867,
            19113047,
            19115983,
            19115146,
            19124178
        ],
        "D": [
            19117852,
            19121638,
            19123814,
            19122693,
            19131199,
            19131585,
            19120524,
            19123388,
            19122212,
            19124637,
            19122311,
            19124184,
            19125355,
            19124738,
            19124393,
            19125186,
            19123099,
            19124323,
            19124512,
            19154347
        ],
        "C": [
            19113058,
            19119301,
            19121245,
            19119819,
            19118377,
            19124627,
            19116332,
            19120250,
            19118573,
            19118620,
            19122282,
            19118411,
            19120542,
            19120806,
            19119142,
            19121243,
            19119728,
            19127751
        ],
        "F": [
            19223787,
            19134194
        ]
    },
    "name": "D. Legen...",
    "statement": "Barney was hanging out with Nora for a while and now he thinks he may\r\nhave feelings for her. Barney wants to send her a cheesy text message\r\nand wants to make her as happy as possible. Initially, happiness level\r\nof Nora is . Nora loves some pickup lines like \"I’m falling for you\" and\r\nstuff. Totally, she knows pickup lines, each consisting only of\r\nlowercase English letters, also some of them may be equal (in writing,\r\nbut different in pronouncing or meaning though). Every time Nora sees\r\n-th pickup line as a of Barney’s text message her happiness level\r\nincreases by . These substrings may overlap, for example, Nora will see\r\nthe pickup line twice and the pickup line once in text message .Due to\r\ntexting app limits, Barney’s text may have up to characters.Barney asked\r\nyou to help him make Nora as much happy as possible, it’s gonna be\r\nlegen...\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=210;\nconst ll inf=1ll<<60;\nint n,a[N],m;\nll l;\ntypedef long long matrix[N][N];\n\nmatrix ret,tmp,base;\n\nvoid mul(matrix &a,matrix &b) {\n\trep(i,0,m) rep(j,0,m) tmp[i][j]=(i==j)?0:-inf;\n\trep(i,0,m) rep(j,0,m) {\n\t\trep(k,0,m) tmp[i][j]=max(tmp[i][j],a[i][k]+b[k][j]);\n\t}\n\trep(i,0,m) rep(j,0,m) a[i][j]=tmp[i][j];\n}\nvoid powmod(ll b) {\n\trep(i,0,m) rep(j,0,m) ret[i][j]=(i==j)?0:-inf;\n\tfor(;b;b>>=1) {\n\t\tif (b&1) mul(ret,base);\n\t\tmul(base,base);\n\t}\n}\n\n\nconst int AC_SIGMA=26,AC_V=29,AC_N=210;\nstruct AC_automaton {\n\tstruct node {\n\t\tnode *go[AC_V],*fail,*f;\n\t\tint fg,id;\n\t}pool[AC_N],*cur,*root,*q[AC_N];\n\tnode* newnode() {\n\t\tnode *p=cur++;\n\t\tmemset(p->go,0,sizeof(p->go));\n\t\tp->fail=p->f=NULL; p->fg=0;\n\t\treturn p;\n\t}\n\tvoid init() { cur=pool; root=newnode();}\n\tnode* append(node *p,int w) {\n\t\tif (!p->go[w]) p->go[w]=newnode(),p->go[w]->f=p;\n\t\treturn p=p->go[w];\n\t}\n\tvoid build() {\n\t\tint t=1;\n\t\tq[0]=root;\n\t\trep(i,0,t) rep(j,0,AC_SIGMA) if (q[i]->go[j]) {\n\t\t\tnode *v=q[i]->go[j],*p=v->f->fail;\n\t\t\twhile (p&&!p->go[j]) p=p->fail;\n\t\t\tif (p) v->fail=p->go[j]; else v->fail=root;\n\t\t\tq[t++]=q[i]->go[j];\n\t\t}\n\t\trep(i,0,t) {\n\t\t\tif (q[i]->fail) q[i]->fg+=q[i]->fail->fg;\n\t\t}\n\t\trep(i,0,t) rep(j,0,AC_SIGMA) if (!q[i]->go[j]) {\n\t\t\tnode *p=q[i]->fail;\n\t\t\twhile (p&&!p->go[j]) p=p->fail;\n\t\t\tif (p) q[i]->go[j]=p->go[j]; else q[i]->go[j]=root;\n\t\t}\n\t\trep(i,0,t) rep(j,0,t) base[i][j]=-inf;\n\t\trep(i,0,t) rep(j,0,AC_SIGMA) {\n\t\t\tbase[q[i]-pool][q[i]->go[j]-pool]=max(base[q[i]-pool][q[i]->go[j]-pool],(ll)q[i]->go[j]->fg);\n\t\t}\n\t\tm=t;\n\t}\n}T;\ntypedef AC_automaton::node ACnode;\n\nchar s[N];\nint main() {\n\tscanf(\"%d%lld\",&n,&l);\n\trep(i,0,n) {\n\t\tscanf(\"%d\",a+i);\n\t}\n\tT.init();\n\trep(i,0,n) {\n\t\tscanf(\"%s\",s);\n\t\tACnode *p=T.root;\n\t\tint m=strlen(s);\n\t\trep(j,0,m) {\n\t\t\tp=T.append(p,s[j]-'a');\n\t\t}\n\t\tp->fg+=a[i];\n\t}\n\tT.build();\n\tpowmod(l);\n\tll res=0;\n\trep(i,0,m) res=max(res,ret[0][i]);\n\tprintf(\"%lld\\n\",res);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "matrices",
        "strings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Legen....json",
    "editorial_link": "https://codeforces.com//blog/entry/46031",
    "editorial": "Build the prefix automaton of these strings (Aho-Corasick). In this automaton every state denotes a string which is prefix of one of given strings (and when we feed characters to it the current state is always the longest of these prefixes that is a suffix of the current string we have fed to it). Building this DFA can be done in various ways (fast and slow).\n\nSuppose these automaton has N states () and state v has edges outgoing to states in vector neigh[v] (if we define our DFA as a directed graph). Suppose state number 1 is the initial state (denoting an empty string).\n\nIf l was smaller we could use dp: suppose dp[l][v] is the maximum score of all strings with length equal to l ending in state v of our DFA when fed into it.\n\nIt's easy to show that dp[0][1]?=?0 and dp[1][v]???bv?+?dp[l?+?1][u] for u in neigh[v] and calculating dps can be done using this (here bv is sum of a of all strings that are a suffix of string related to state v).\n\n \n\nNow that l is large, let's use matrix exponential to calculate the dp. Now dp is not an array, but a column matrix. Finding a matrix to update the dp is not hard. Also we need to reform + and * operations. In matrix multiplying we should use + instead of * and max instead of + in normal multiplication.",
    "hint": []
}