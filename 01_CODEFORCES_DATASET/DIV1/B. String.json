{"link": "https://codeforces.com//contest/128/problem/B", "problemId": "673", "problem_idx": "B", "shortId": "128B", "contest_number": "128", "problem_submissions": {"B": [868631, 867052, 866131, 868093, 864920, 867712, 867635, 868241, 868954, 866973, 868225, 869082, 869329, 868786], "C": [867417, 865854, 866628, 866135, 867141, 866532, 866167, 866639, 866961, 867655, 868770, 866966, 867088, 867033], "D": [865898, 866482, 867528, 866945, 868692, 868382, 868718, 867247, 867493, 868514, 866507, 867640, 867746, 867494], "A": [865243, 865123, 865205, 865177, 867354, 866061, 865379, 868310, 865524, 866301, 865222, 865534, 865830, 866105]}, "name": "B. String", "statement": "One day in the IT lesson Anna and Maria learned about the lexicographic\r\norder.String is lexicographically less than string , if either is a\r\nprefix of (and ), or there exists such (), that , and for any () . Here\r\ndenotes the length of the string . The lexicographic comparison of\r\nstrings is implemented by operator < in modern programming languages\r\n.The teacher gave Anna and Maria homework. She gave them a string of\r\nlength . They should write out all substrings of the given string,\r\nincluding the whole initial string, and the equal substrings (for\r\nexample, one should write out the following substrings from the string\r\n\"\": \"\", \"\", \"\", \"\", \"\", \"\"). The resulting strings should be sorted in\r\nthe lexicographical order. The cunning teacher doesn\u2019t want to check all\r\nthese strings. That\u2019s why she said to find only the -th string from the\r\nlist. Help Anna and Maria do the homework.\r\n", "solutions": ["#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long double real;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf (stderr, __VA_ARGS__)\n#else\n#define eprintf(...) assert (true)\n#endif\n\n#ifdef WIN32\n#define INT64 \"%I64d\"\n#else\n#define INT64 \"%lld\"\n#endif\n\nusing namespace std;\n\nconst int MaxN = 100005, NA = -1, MaxC = 0x3F3F3F3F;\n\nchar s [MaxN];\nbool b [MaxN];\nint k, n;\n\nvoid solve (vector <int> v)\n{\n int i, j;\n int64 p, q;\n char c;\n\n vector <int> w;\n for (c = 'a'; c <= 'z'; c++)\n {\n  p = q = 0;\n  w.clear ();\n  for (j = 0; j < (int) v.size (); j++)\n  {\n   i = v[j];\n   if (s[i] == c)\n   {\n    w.push_back (i + 1);\n    p++;\n    q += n - i;\n   }\n  }\n  if (k < q)\n   break;\n  k -= q;\n }\n assert (c <= 'z');\n\n putchar (c);\n if (k < p)\n  return;\n k -= p;\n solve (w);\n}\n\nint main (void)\n{\n int i;\n\n while (scanf (\" %s %d\", s, &k) != EOF)\n {\n  n = (int) strlen (s);\n  if (k > ((((int64) n) * (int64) (n + 1)) >> 1LL))\n  {\n   printf (\"No such line.\\n\");\n   continue;\n  }\n  k--;\n\n  vector <int> v;\n  for (i = 0; i < n; i++)\n   v.push_back (i);\n  solve (v);\n  putchar ('\\n');\n }\n return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "hashing", "implementation", "string suffix structures", "strings"], "dificulty": "2100", "interactive": false}