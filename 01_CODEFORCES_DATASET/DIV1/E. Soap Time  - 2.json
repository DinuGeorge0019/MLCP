{"link": "https://codeforces.com//contest/185/problem/E", "problemId": "1299", "problem_idx": "E", "shortId": "185E", "contest_number": "185", "problem_submissions": {"D": [1656258, 1657906, 1659029, 1659582, 1660143, 1660140, 1660650, 1660397, 1660794, 1660341, 1662000, 1661960, 1662031], "B": [1654760, 1653010, 1654904, 1655366, 1655062, 1655668, 1653656, 1655096, 1656068, 1655208, 1655477, 1655121, 1654374, 1656299, 1655431, 1655895], "A": [1652795, 1653595, 1652830, 1652854, 1654056, 1653415, 1652909, 1653006, 1653418, 1653729, 1653004, 1653330, 1652743, 1653797, 1652848, 1652763], "E": [1660675, 140398754], "C": []}, "name": "E. Soap Time  - 2", "statement": "Imagine the Cartesian coordinate system. There are different points\r\ncontaining subway stations. One can get from any subway station to any\r\none instantly. That is, the duration of the transfer between any two\r\nsubway stations can be considered equal to zero. You are allowed to\r\ntravel only between subway stations, that is, you are not allowed to\r\nleave the subway somewhere in the middle of your path, in-between the\r\nstations. There are dwarves, they are represented by their coordinates\r\non the plane. The dwarves want to come together and watch a soap opera\r\nat some integer point on the plane. For that, they choose the gathering\r\npoint and start moving towards it simultaneously. In one second a dwarf\r\ncan move from point to one of the following points: , , , . Besides, the\r\ndwarves can use the subway as many times as they want (the subway\r\ntransfers the dwarves instantly). The dwarves do not interfere with each\r\nother as they move (that is, the dwarves move simultaneously and\r\nindependently from each other). Help the dwarves and find the minimum\r\ntime they need to gather at one point.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst ll INFLL = 1e18;\nclass fenv_tree {\n  vll xs;\n  vector<pair<ll, int> > tr;\n  static int f(int x) { return x ^ (x & (x - 1)); }\n\n  public:\n  fenv_tree(const vll &_xs) : xs(_xs), tr(sz(xs) + 1, mp(INFLL, -1)) {}\n  void relax(ll x, const pair<ll, int> &val) {\n    x = lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n    x++;\n    assert(0 < x && x < sz(tr));\n    for (; x > 0; x -= f(x))\n      tr[x] = min(tr[x], val);\n  }\n  pair<ll, int> get(ll x) {\n    x = lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n    x++;\n    assert(0 <= x && x < sz(tr));\n    pair<ll, int> res(INFLL, -1);\n    for (; x < sz(tr); x += f(x))\n      res = min(res, tr[x]);\n    return res;\n  }\n};\n\nstruct pt {\n  ll x, y;\n  pt(ll _x = 0, ll _y = 0) : x(_x), y(_y) {}\n  bool operator<(const pt &p2) const { return y != p2.y ? y < p2.y : x < p2.x; }\n};\n\nclass segm_tree2 {\n  vector<vll> tr;\n  int off;\n  vll ys;\n\n  bool get(const vll &t, ll x1, ll x2) {\n    int i = lower_bound(t.begin(), t.end(), x1) - t.begin();\n    return i < sz(t) && t[i] <= x2;\n  }\n\n  public:\n  segm_tree2() {}\n  segm_tree2(const vector<pt> &pts) : ys(sz(pts)) {\n    for (int i = 0; i < sz(pts); i++)\n      ys[i] = pts[i].y;\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    off = 1; while (off <= sz(ys)) off <<= 1;\n    tr = vector<vll>(2 * off);\n\n    for (int i = 0; i < sz(pts); i++) {\n      int v = lower_bound(ys.begin(), ys.end(), pts[i].y) - ys.begin();\n      tr[off + v].pb(pts[i].x);\n    }\n    for (int i = off; i < sz(tr); i++) {\n      sort(tr[i].begin(), tr[i].end());\n      tr[i].erase(unique(tr[i].begin(), tr[i].end()), tr[i].end());\n    }\n    for (int i = off - 1; i >= 1; i--) {\n      const vll &l = tr[2 * i], &r = tr[2 * i + 1];\n      tr[i].resize(sz(l) + sz(r));\n      merge(l.begin(), l.end(), r.begin(), r.end(), tr[i].begin());\n      tr[i].erase(unique(tr[i].begin(), tr[i].end()), tr[i].end());\n    }\n  }\n  bool get(ll x1, ll x2, ll y1, ll y2) {\n    y1 = lower_bound(ys.begin(), ys.end(), y1) - ys.begin();\n    y2 = upper_bound(ys.begin(), ys.end(), y2) - ys.begin() - 1;\n\n    y1 += off; y2 += off;\n    while (y1 <= y2) {\n      if (y1 & 1) if (get(tr[y1++], x1, x2)) return true;\n      if (!(y2 & 1)) if (get(tr[y2--], x1, x2)) return true;\n      y1 >>= 1;\n      y2 >>= 1;\n    }\n    return false;\n  }\n};\n\nstruct Ev {\n  int ty;\n  ll x, y;\n  int  id;\n  Ev(int _ty, ll _x, ll _y, int _id) : ty(_ty), x(_x), y(_y), id(_id) {}\n  bool operator<(const Ev &e2) const {\n    if (y != e2.y) return y > e2.y;\n    if (x != e2.x) return x > e2.x;\n    return ty > e2.ty;\n  }\n};\n\nll maxt;\nvoid cross(ll &mix, ll &mxx, ll &miy, ll &mxy, const pt &p) {\n  mix = max(mix, p.x - maxt);\n  miy = max(miy, p.y - maxt);\n  mxx = min(mxx, p.x + maxt);\n  mxy = min(mxy, p.y + maxt);\n}\n\nvector<pt> subs;\nsegm_tree2 str;\n\n#ifdef DEBUG\nbool _findSubway(ll x1, ll x2, ll y1, ll y2) {\n  for (int i = 0; i < sz(subs); i++)\n    if (x1 <= subs[i].x && subs[i].x <= x2)\n    if (y1 <= subs[i].y && subs[i].y <= y2)\n      return true;\n  return false;\n}\n#endif\nbool findSubway(ll x1, ll x2, ll y1, ll y2)  {\n//  eprintf(\"%d\\n\", _findSubway(x1, x2, y1, y2));\n  #ifdef DEBUG\n  assert(str.get(x1, x2, y1, y2) == _findSubway(x1, x2, y1, y2));\n  #endif\n  return str.get(x1, x2, y1, y2);\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\"std.in\", \"r\", stdin);\n  freopen(\"std.out\", \"w\", stdout);\n  #endif\n\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) >= 1) {\n    vector<pt> pts(n);\n    subs.resize(m);\n    for (int i = 0; i < n; i++)\n      scanf(\"%I64d%I64d\", &pts[i].x, &pts[i].y);\n    for (int i = 0; i < m; i++)\n      scanf(\"%I64d%I64d\", &subs[i].x, &subs[i].y);\n\n    vi nearest(n, -1);\n    vll ndist(n, INFLL);\n    for (int step = 0; step < 4; step++) {\n      vll xs;\n      for (int i = 0; i < n; i++) xs.pb(pts[i].x);\n      for (int i = 0; i < m; i++) xs.pb(subs[i].x);\n      sort(xs.begin(), xs.end());\n      xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n      fenv_tree tr(xs);\n      vector<Ev> evs;\n      for (int i = 0; i < n; i++)\n        evs.pb(Ev(0, pts[i].x, pts[i].y, i));\n      for (int i = 0; i < m; i++)\n        evs.pb(Ev(1, subs[i].x, subs[i].y, i));\n      sort(evs.begin(), evs.end());\n\n      for (int i = 0; i < sz(evs); i++) {\n        if (evs[i].ty == 1) {\n          tr.relax(evs[i].x, mp(evs[i].x + evs[i].y, evs[i].id));\n        } else {\n          pair<ll, int> cd = tr.get(evs[i].x);\n          if (cd.second >= 0) {\n            ll ncand = cd.first - evs[i].x - evs[i].y;\n            if (ndist[evs[i].id] > ncand) {\n              ndist[evs[i].id] = ncand;\n              nearest[evs[i].id] = cd.second;\n            }\n          }\n        }\n      }\n\n      if ((step & 1) == 0) {\n        for (int i = 0; i < n; i++) pts[i].x = -pts[i].x;\n        for (int i = 0; i < m; i++) subs[i].x = -subs[i].x;\n      } else {\n        for (int i = 0; i < n; i++) pts[i].y = -pts[i].y;\n        for (int i = 0; i < m; i++) subs[i].y = -subs[i].y;\n      }\n    }\n\n/*    #ifdef DEBUG\n    for (int a = 0; a < n; a++) {\n      ll bd = INFLL;\n      for (int b = 0; b < m; b++)\n        bd = min(bd, abs(pts[a].x - subs[b].x) + abs(pts[a].y - subs[b].y));\n      assert(bd == ndist[a]);\n      if (nearest[a] >= 0) {\n        int b = nearest[a];\n        assert(bd == abs(pts[a].x - subs[b].x) + abs(pts[a].y - subs[b].y));\n      }\n    }\n    #endif*/\n\n    vector<pair<ll, int> > ord(n);\n    for (int i = 0; i < n; i++)\n      ord[i] = mp(ndist[i], i);\n    sort(ord.begin(), ord.end());\n\n    for (int i = 0; i < n; i++) {\n      pts[i] = pt(pts[i].x + pts[i].y, pts[i].x - pts[i].y);\n    }\n    for (int i = 0; i < m; i++) {\n      subs[i] = pt(subs[i].x + subs[i].y, subs[i].x - subs[i].y);\n    }\n    sort(subs.begin(), subs.end());\n    str = segm_tree2(subs);\n\n    eprintf(\"go\\n\");\n    ll L = -1, R = ord[n - 1].first;\n    while (L + 1 < R) {\n      maxt = (L + R) / 2;\n\n      ll mix = -INFLL, miy = -INFLL;\n      ll mxx = INFLL, mxy = INFLL;\n      int ptr = n - 1;\n      for (; ptr >= 0 && ord[ptr].first > maxt; ptr--) {\n        cross(mix, mxx, miy, mxy, pts[ord[ptr].second]);\n      }\n\n      for (; ptr >= 0 && mix <= mxx && miy <= mxy; ptr--) {\n        ll remt = maxt - ord[ptr].first;\n        assert(remt >= 0);\n        if (findSubway(mix - remt, mxx + remt, miy - remt, mxy + remt)) {\n          break;\n        } else {\n          cross(mix, mxx, miy, mxy, pts[ord[ptr].second]);\n        }\n      }\n      if (mix <= mxx && miy <= mxy) {\n        R = maxt;\n      } else\n        L = maxt;\n    }\n    printf(\"%I64d\\n\", R);\n  }\n  return 0;\n}\n\n"], "input": "", "output": "", "tags": ["binary search", "data structures"], "dificulty": "3000", "interactive": false}