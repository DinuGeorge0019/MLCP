{
    "link": "https://codeforces.com//contest/1495/problem/B",
    "problemId": "920575",
    "problem_idx": "B",
    "shortId": "1495B",
    "contest_number": "1495",
    "problem_submissions": {
        "F": [
            109612449,
            109607835,
            109606482,
            109609150,
            109620903,
            109726650,
            109627363,
            109621999
        ],
        "E": [
            109601349,
            109614588,
            109615437,
            109622017,
            109595998,
            109609900,
            109608272,
            109611154,
            109618626,
            109616350,
            109613793,
            109616566,
            109663705,
            109745948
        ],
        "D": [
            109585527,
            109580228,
            109579316,
            109589541,
            109578458,
            109566916,
            109575841,
            109594019,
            109596254,
            109599839,
            109603208,
            109598498,
            109595100,
            109579185,
            109589312,
            109591284,
            109598520,
            109583665,
            109585365
        ],
        "C": [
            109580634,
            109591405,
            109587970,
            109577744,
            109586320,
            109593422,
            109611088,
            109582953,
            109580883,
            109580583,
            109587448,
            109605186,
            109581328,
            109584227,
            109579041,
            109577709,
            109589629,
            109602493
        ],
        "B": [
            109568471,
            109565101,
            109584053,
            109566115,
            109569156,
            109574304,
            109563074,
            109573615,
            109567542,
            109575207,
            109571021,
            109587658,
            109567505,
            109566798,
            109566339,
            109589966,
            109570284,
            109566248
        ],
        "A": [
            109557502,
            109557307,
            109557290,
            109557352,
            109558084,
            109569473,
            109557547,
            109559952,
            109558698,
            109558154,
            109557812,
            109558270,
            109557945,
            109558879,
            109557971,
            109558445,
            109560880,
            109558343,
            109559119
        ]
    },
    "name": "B. Let s Go Hiking",
    "statement": "On a weekend, Qingshan suggests that she and her friend Daniel go\r\nhiking. Unfortunately, they are busy high school students, so they can\r\nonly go hiking on scratch paper.A permutation p is written from left to\r\nright on the paper. First Qingshan chooses an integer index x (1\r\nle x\r\nle n) and tells it to Daniel. After that, Daniel chooses another integer\r\nindex y (1\r\nle y\r\nle n, y\r\nne x).The game progresses turn by turn and as usual, Qingshan moves\r\nfirst. The rules follow: If it is Qingshan\u2019s turn, Qingshan must change\r\nx to such an index x\u2019 that 1\r\nle x\u2019\r\nle n, |x\u2019-x|=1, x\u2019\r\nne y, and p_{x\u2019}<p_x at the same time. If it is Daniel\u2019s turn, Daniel\r\nmust change y to such an index y\u2019 that 1\r\nle y\u2019\r\nle n, |y\u2019-y|=1, y\u2019\r\nne x, and p_{y\u2019}>p_y at the same time. The person who can\u2019t make her or\r\nhis move loses, and the other wins. You, as Qingshan\u2019s fan, are asked to\r\ncalculate the number of possible x to make Qingshan win in the case both\r\nplayers play optimally.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nint lew[nax];\nint pra[nax];\n\nint lewo[nax];\nint prao[nax];\n\nint wyn;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &tab[i]);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (tab[i]>tab[i-1])\n\t\t\tlew[i]=lew[i-1];\n\t\tlew[i]++;\n\t\t\n\t\tif (tab[i]<tab[i-1])\n\t\t\tlewo[i]=lewo[i-1];\n\t\tlewo[i]++;\n\t}\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (tab[i]>tab[i+1])\n\t\t\tpra[i]=pra[i+1];\n\t\tpra[i]++;\n\t\t\n\t\tif (tab[i]<tab[i+1])\n\t\t\tprao[i]=prao[i+1];\n\t\tprao[i]++;\n\t}\n\tint naj=0;\n\tvi wek;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tnaj=max(naj, max(lew[i], pra[i]));\n\t\twek.push_back(max(lew[i], pra[i]));\n\t}\n\tsort(wek.begin(), wek.end());\n\treverse(wek.begin(), wek.end());\n\tdebug() << wek;\n\tif (wek[0]==wek[1] || !(naj&1))\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tdebug() << \"no\";\n\tfor (int i=1; i<=n; i++)\n\t\twyn+=(lew[i]==naj && pra[i]==naj);\n\tprintf(\"%d\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Let s Go Hiking.json",
    "editorial_link": "https://codeforces.com//blog/entry/88533",
    "editorial": "Let\u00e2\u0080\u0099s consider that the -th turn is Qingshan\u00e2\u0080\u0099s and the -th turn is\r\nDaniel\u00e2\u0080\u0099s.If Qingshan chooses satisfying or , then Daniel can choose to\r\nmake Qingshan can\u00e2\u0080\u0099t move in the first turn. The case that or is the\r\nsame. So Qingshan must choose satisfying and at first.Let be the length\r\nof the longest monotone segments and be the number of the longest\r\nmonotone segments. and are always true.It is obvious that Qingshan can\u00e2\u0080\u0099t\r\nwin when because wherever Qingshan chooses, Daniel can always find a\r\nplace that he can move times while Qingshan can move times at most.When\r\n, Qingshan will also lose. If the only longest monotone segment is and\r\nit\u00e2\u0080\u0099s increasing(if it\u00e2\u0080\u0099s decreasing, the discussion is almost the same).\r\nQingshan must choose at first. The discussion follows: If , Daniel can\r\nchoose at first. After the -th turn(Qingshan\u00e2\u0080\u0099s turn), and After the -th\r\nturn(Daniel\u00e2\u0080\u0099s turn), . The next turn is Qingshan\u00e2\u0080\u0099s and Qingshan loses.\r\nIf , Daniel can choose at first. Pay attention that Qingshan can\u00e2\u0080\u0099t\r\nchange to in the first turn because Daniel can move times while Qingshan\r\ncan move times at most if she change to in the first turn. After the -th\r\nturn(Qingshan\u00e2\u0080\u0099s turn), and After the -th turn(Daniel\u00e2\u0080\u0099s turn), . The next\r\nturn is Qingshan\u00e2\u0080\u0099s and Qingshan loses. When , the only two longest\r\nmonotone segments must be like . (Otherwise Qingshan will lose.) In that\r\ncase Qingshan will lose if because Daniel can choose at first and\r\nwhatever Qingshan\u00e2\u0080\u0099s first move is, Qingshan will lose(just like the\r\ndiscussion above). If , Qingshan is the winner. It is not hard to check\r\nit in .The overall time complexity is .\r\n"
}