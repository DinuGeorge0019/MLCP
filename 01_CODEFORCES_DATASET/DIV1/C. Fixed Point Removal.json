{"link": "https://codeforces.com//contest/1404/problem/C", "problemId": "718463", "problem_idx": "C", "shortId": "1404C", "contest_number": "1404", "problem_submissions": {"D": [92054708, 92052158, 92068012, 92035788, 92064459, 92065822, 92054867, 92062050, 92059537, 92069600, 92065308, 92064419, 92678119, 92059471, 92066519, 92058523, 92073497, 92059060, 92052830, 92062741], "E": [92047893, 92058796, 92034966, 92060195, 92054088, 92055746, 92059735, 92056203, 92048655, 92056326, 92057900, 92058612, 92678137, 92064937, 92060062, 92063614, 92088039, 92051483, 92069623, 92058299, 92069210], "C": [92043774, 92041285, 92054338, 92054493, 92055420, 92044472, 92045777, 92047843, 92049348, 92054237, 92046120, 92049505, 92048234, 92678067, 92045429, 92049783, 92049154, 92048569, 92049406, 92065327, 92047261], "B": [92036978, 92033130, 92045800, 92048542, 92038249, 92036852, 92044012, 92035789, 92064168, 92038925, 92038994, 92035913, 92678047, 92035132, 92035598, 92039096, 92040418, 92033158, 92055911, 92034078], "A": [92024360, 92023992, 92037661, 92039271, 92026103, 92027740, 92024181, 92023800, 92023879, 92029391, 92028274, 92025652, 92678042, 92026279, 92026582, 92024999, 92023858, 92026444, 92025837, 92024282]}, "name": "C. Fixed Point Removal", "statement": "Let a_1,\r\nldots, a_n be an array of n positive integers. In one operation, you can\r\nchoose an index i such that a_i = i, and remove a_i from the array\r\n(after the removal, the remaining parts are concatenated).The weight of\r\na is defined as the maximum number of elements you can remove.You must\r\nanswer q independent queries (x, y): after replacing the x first\r\nelements of a and the y last elements of a by n+1 (making them\r\nimpossible to remove), what would be the weight of a?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.assign(s=n,0);}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,q;cin>>n>>q;\n\tvi a=readvi(n,-1);\n\tvvc<pi> qs(n);\n\trep(i,q){\n\t\tint x,y;cin>>x>>y;\n\t\tqs[n-1-y].eb(x,i);\n\t}\n\tvi ans(q);\n\tvi dp(n,-1);\n\tBIT<int> bit(n);\n\tint tot=0;\n\trep(i,n){\n\t\tint v=i-a[i];\n\t\tif(v>=0){\n\t\t\tif(v<=tot){\n\t\t\t\tint pos=bit.kth(tot-v);\n\t\t\t\tchmin(pos,i);\n\t\t\t\tdmp2(i,pos);\n\t\t\t\tbit.add(pos,1);\n\t\t\t\ttot++;\n\t\t\t}\n\t\t}\n\t\tfor(auto w:qs[i]){\n\t\t\tans[w.b]=bit.sum(w.a,n);\n\t\t}\n\t}\n\tfor(auto v:ans)print(v);\n}\n"], "input": "", "output": "", "tags": ["binary search", "constructive algorithms", "data structures", "greedy", "two pointers"], "dificulty": "2300", "interactive": false}