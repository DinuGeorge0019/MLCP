{
    "link": "https://codeforces.com//contest/2006/problem/E",
    "problemId": "2845534",
    "problem_idx": "E",
    "shortId": "2006E",
    "contest_number": "2006",
    "problem_submissions": {
        "F": [
            278838627,
            278834885,
            278839605,
            278842896,
            283040284,
            278849665,
            279479840,
            279030892,
            278872889
        ],
        "E": [
            278816205,
            278815039,
            278825195,
            278819088,
            278823646,
            278824405,
            278834146,
            278833851,
            278836845,
            278834660,
            278831348,
            278835070,
            278824284,
            278835798,
            278834079,
            278836349,
            278834150,
            278840676,
            278837721,
            278840281
        ],
        "D": [
            278802409,
            278805803,
            278813224,
            278825476,
            278809587,
            278813203,
            278814738,
            278815896,
            278817434,
            278818422,
            278823248,
            278822269,
            278830412,
            278825693,
            278818908,
            278819966,
            278823289,
            278817077,
            278823950,
            278818832
        ],
        "C": [
            278788793,
            278798461,
            278801097,
            278797423,
            278800136,
            278800438,
            278797097,
            278802996,
            278798370,
            278802119,
            278807042,
            278803250,
            278809464,
            278800483,
            278808112,
            278808529,
            278813687,
            278799260,
            278808716,
            278807375
        ],
        "B": [
            278783201,
            278791628,
            278792112,
            278787764,
            278787151,
            278789090,
            278788997,
            278795304,
            278790397,
            278793228,
            278796651,
            278795483,
            278796854,
            278787538,
            278797112,
            278796560,
            278796305,
            278792796,
            278798821,
            278792242
        ],
        "A": [
            278774854,
            278780780,
            278783421,
            278777635,
            278777703,
            278778768,
            278777654,
            278780623,
            278781426,
            278784680,
            278779860,
            278783271,
            278779619,
            278776511,
            278786116,
            278783656,
            278783630,
            278778742,
            278777793,
            278783717
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133382",
    "editorial": "Hereâre two lemmas that will be used in the solution.Lemma 1: Among all\r\nthe points on a tree with the greatest distance from a certain point,\r\none of which must be one of the two endpoints of a certain\r\ndiameter.Lemma 2: After merging two trees, at least one new diameter is\r\ngenerated at the four endpoints of two certain diameters.Obviously, we\r\nconsider a subtree composed of the first points, which corresponds to a\r\nfully binary tree with a depth of , and must have only one node with the\r\nsmallest depth (otherwise it would not be connected). If the depth of\r\nthe node with the smallest depth is greater than , then we can reduce\r\nthe depth of all nodes by . It is easy to see that this will not cause\r\nconflicts, and should be reduced by .In this case, we obtain:Conclusion\r\n1: There must be a node corresponding to the root of a fully binary\r\ntree.Meanwhile, due to the degrees of the nodes of a full binary tree,\r\nit is obtained that:Conclusion 2: The node corresponding to the root\r\nshould have a degree ; if there is a node with a degree , then all\r\nsubsequent queries should be .We can consider the case where each point\r\nis the root, and due to the Lemma, we can obtain as the maximum distance\r\nfrom that point to the endpoints of two diameters, then plus . Finally,\r\nselect the point with degree that minimizes this maximum value as the\r\nroot.Brute practices can achieve time. Consider optimization.According\r\nto Lemma 2, each time a point is added, the diameter length either\r\nremains unchanged or increases by . In the case of adding , as mentioned\r\nearlier, we investigate the maximum distance of all points (temporarily\r\nignoring their degrees).If we consider real-time maintenance of its\r\nchanges, it is obvious that if the new diameter distance is even, it is\r\nequivalent to a maximum distance of for all points except for a subtree\r\nat the midpoint of the new diameter; otherwise, it is equivalent to a\r\nmaximum distance of for all points of the subtree at the midpoint of the\r\noriginal diameter. Pay attention to the subtrees mentioned, where the\r\nroots of the entire tree are variable, but this is not very important.We\r\ncan traverse and number all nodes in the DFS order, so that the subtree\r\nof each node is within an interval in such order. Therefore, an\r\nindefinite rooted subtree can also be represented by intervals. You can\r\nuse a segment tree to facilitate the maintenance of the operations.In\r\naddition, considering the impact of degrees, we just need to increase\r\nthe maximum distance of a -degreed node by . Ultimately, at the end of\r\neach operation, we need only the global minimum value.The time\r\ncomplexity is .\r\n",
    "name": "E. Iris s Full Binary Tree",
    "statement": "Iris likes full binary trees.Let’s define the depth of a rooted tree as\r\nthe maximum number of on the simple paths from some vertex to the root.\r\nA full binary tree of depth d is a binary tree of depth d with exactly\r\n2^d - 1 vertices.Iris calls a tree a tree if some vertices and edges can\r\nbe to it to make it a full binary tree of depth d. Note that can be\r\nchosen as the root of a full binary tree.Since performing operations on\r\nlarge trees is difficult, she defines the of a tree as the minimum d\r\nsatisfying that the tree is d-binary. Specifically, if there is no\r\ninteger d\r\nge 1 such that the tree is d-binary, the binary depth of the tree is\r\n-1.Iris now has a tree consisting of only vertex 1. She wants to add n -\r\n1 more vertices to form a larger tree. She will add the vertices one by\r\none. When she adds vertex i (2\r\nleq i\r\nleq n), she’ll give you an integer p_i (1\r\nleq p_i < i), and add a new edge connecting vertices i and p_i.Iris\r\nwants to ask you the binary depth of the tree formed by the first i\r\nvertices for each 1\r\nle i\r\nle n. Can you tell her the answer?\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 30.08.2024 08:21:04**/#include <bits/stdc++.h> using namespace std; #ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif template <typename T>class graph { public:  struct edge {    int from;    int to;    T cost;  };   vector<edge> edges;  vector<vector<int>> g;  int n;   graph(int _n) : n(_n) {    g.resize(n);  }   virtual int add(int from, int to, T cost) = 0;}; template <typename T>class forest : public graph<T> { public:  using graph<T>::edges;  using graph<T>::g;  using graph<T>::n;   forest(int _n) : graph<T>(_n) {  }   int add(int from, int to, T cost = 1) {    assert(0 <= from && from < n && 0 <= to && to < n);    int id = (int) edges.size();    assert(id < n - 1);    g[from].push_back(id);    g[to].push_back(id);    edges.push_back({from, to, cost});    return id;  }}; template <typename T>class dfs_forest : public forest<T> { public:  using forest<T>::edges;  using forest<T>::g;  using forest<T>::n;   vector<int> pv;  vector<int> pe;  vector<int> order;  vector<int> pos;  vector<int> end;  vector<int> sz;  vector<int> root;  vector<int> depth;  vector<T> dist;   dfs_forest(int _n) : forest<T>(_n) {  }   void init() {    pv = vector<int>(n, -1);    pe = vector<int>(n, -1);    order.clear();    pos = vector<int>(n, -1);    end = vector<int>(n, -1);    sz = vector<int>(n, 0);    root = vector<int>(n, -1);    depth = vector<int>(n, -1);    dist = vector<T>(n);  }   void clear() {    pv.clear();    pe.clear();    order.clear();    pos.clear();    end.clear();    sz.clear();    root.clear();    depth.clear();    dist.clear();  }  private:  void do_dfs(int v) {    pos[v] = (int) order.size();    order.push_back(v);    sz[v] = 1;    for (int id : g[v]) {      if (id == pe[v]) {        continue;      }      auto &e = edges[id];      int to = e.from ^ e.to ^ v;      depth[to] = depth[v] + 1;      dist[to] = dist[v] + e.cost;      pv[to] = v;      pe[to] = id;      root[to] = (root[v] != -1 ? root[v] : to);      do_dfs(to);      sz[v] += sz[to];    }    end[v] = (int) order.size() - 1;  }   void do_dfs_from(int v) {    depth[v] = 0;    dist[v] = T{};    root[v] = v;    pv[v] = pe[v] = -1;    do_dfs(v);  }  public:  void dfs(int v, bool clear_order = true) {    if (pv.empty()) {      init();    } else {      if (clear_order) {        order.clear();      }    }    do_dfs_from(v);  }   void dfs_all() {    init();    for (int v = 0; v < n; v++) {      if (depth[v] == -1) {        do_dfs_from(v);      }    }    assert((int) order.size() == n);  }}; template <typename T>class hld_forest : public dfs_forest<T> { public:  using dfs_forest<T>::edges;  using dfs_forest<T>::g;  using dfs_forest<T>::n;  using dfs_forest<T>::pv;  using dfs_forest<T>::sz;  using dfs_forest<T>::root;  using dfs_forest<T>::pos;  using dfs_forest<T>::end;  using dfs_forest<T>::order;  using dfs_forest<T>::depth;  using dfs_forest<T>::dfs;  using dfs_forest<T>::dfs_all;   vector<int> head;  vector<int> visited;   hld_forest(int _n) : dfs_forest<T>(_n) {    visited.resize(n);  }   void build_hld(const vector<int> &vs) {    for (int tries = 0; tries < 2; tries++) {      if (vs.empty()) {        dfs_all();      } else {        order.clear();        for (int v : vs) {          dfs(v, false);        }        assert((int) order.size() == n);      }      if (tries == 1) {        break;      }      for (int i = 0; i < n; i++) {        if (g[i].empty()) {          continue;        }        int best = -1, bid = 0;        for (int j = 0; j < (int) g[i].size(); j++) {          int id = g[i][j];          int v = edges[id].from ^ edges[id].to ^ i;          if (pv[v] != i) {            continue;          }          if (sz[v] > best) {            best = sz[v];            bid = j;          }        }        swap(g[i][0], g[i][bid]);      }    }    head.resize(n);    for (int i = 0; i < n; i++) {      head[i] = i;    }    for (int i = 0; i < n - 1; i++) {      int x = order[i];      int y = order[i + 1];      if (pv[y] == x) {        head[y] = head[x];      }    }  }   void build_hld(int v) {    build_hld(vector<int>(1, v));  }   void build_hld_all() {    build_hld(vector<int>());  }   bool apply_on_path(int x, int y, bool with_lca, function<void(int,int,bool)> f) {    // f(x, y, up): up -- whether this part of the path goes up    assert(!head.empty());    int z = lca(x, y);    if (z == -1) {      return false;    }    {      int v = x;      while (v != z) {        if (depth[head[v]] <= depth[z]) {          f(pos[z] + 1, pos[v], true);          break;        }        f(pos[head[v]], pos[v], true);        v = pv[head[v]];      }    }    if (with_lca) {      f(pos[z], pos[z], false);    }    {      int v = y;      int cnt_visited = 0;      while (v != z) {        if (depth[head[v]] <= depth[z]) {          f(pos[z] + 1, pos[v], false);          break;        }        visited[cnt_visited++] = v;        v = pv[head[v]];      }      for (int at = cnt_visited - 1; at >= 0; at--) {        v = visited[at];        f(pos[head[v]], pos[v], false);      }    }    return true;  }   inline bool anc(int x, int y) {    return (pos[x] <= pos[y] && end[y] <= end[x]);  }   inline int go_up(int x, int up) {    int target = depth[x] - up;    if (target < 0) {      return -1;    }    while (depth[head[x]] > target) {      x = pv[head[x]];    }    return order[pos[x] - depth[x] + target];  }   inline int lca(int x, int y) {    if (root[x] != root[y]) {      return -1;    }    while (head[x] != head[y]) {      if (depth[head[x]] > depth[head[y]]) {        x = pv[head[x]];      } else {        y = pv[head[y]];      }    }    return depth[x] < depth[y] ? x : y;  }}; namespace seg_tree { // Floor of log_2(a); index of highest 1-bitinline int floor_log_2(int a) {  return a ? bit_width(unsigned(a)) - 1 : -1;} struct point {  int a;  point() : a(0) {}  explicit point(int a_) : a(a_) { assert(a >= -1); }   explicit operator bool () { return bool(a); }   // This is useful so you can directly do array indices  /* implicit */ operator int() const { return a; }   point c(bool z) const {    return point((a << 1) | z);  }   point operator [] (bool z) const {    return c(z);  }   point p() const {    return point(a >> 1);  }   friend std::ostream& operator << (std::ostream& o, const point& p) { return o << int(p); }   template <typename F> void for_each(F f) const {    for (int v = a; v > 0; v >>= 1) {      f(point(v));    }  }   template <typename F> void for_parents_down(F f) const {    // strictly greater than 0    for (int L = floor_log_2(a); L > 0; L--) {      f(point(a >> L));    }  }   template <typename F> void for_parents_up(F f) const {    for (int v = a >> 1; v > 0; v >>= 1) {      f(point(v));    }  }   point& operator ++ () { ++a; return *this; }  point operator ++ (int) { return point(a++); }  point& operator -- () { --a; return *this; }  point operator -- (int) { return point(a--); }}; struct range {  int a, b;  range() : a(1), b(1) {}  range(int a_, int b_) : a(a_), b(b_) {    assert(1 <= a && a <= b && b <= 2 * a);  }  explicit range(std::array<int, 2> r) : range(r[0], r[1]) {}   explicit operator std::array<int, 2>() const {    return {a, b};  }   const int& operator[] (bool z) const {    return z ? b : a;  }   friend std::ostream& operator << (std::ostream& o, const range& r) { return o << \"[\" << r.a << \"..\" << r.b << \")\"; }   // Iterate over the range from outside-in.  //   Calls f(point a)  template <typename F> void for_each(F f) const {    for (int x = a, y = b; x < y; x >>= 1, y >>= 1) {      if (x & 1) f(point(x++));      if (y & 1) f(point(--y));    }  }   // Iterate over the range from outside-in.  //   Calls f(point a, bool is_right)  template <typename F> void for_each_with_side(F f) const {    for (int x = a, y = b; x < y; x >>= 1, y >>= 1) {      if (x & 1) f(point(x++), false);      if (y & 1) f(point(--y), true);    }  }   // Iterate over the range from left to right.  //    Calls f(point)  template <typename F> void for_each_l_to_r(F f) const {    int anc_depth = floor_log_2((a - 1) ^ b);    int anc_msk = (1 << anc_depth) - 1;    for (int v = (-a) & anc_msk; v; v &= v - 1) {      int i = countr_zero(unsigned(v));      f(point(((a - 1) >> i) + 1));    }    for (int v = b & anc_msk; v; ) {      int i = floor_log_2(v);      f(point((b >> i) - 1));      v ^= (1 << i);    }  }   // Iterate over the range from right to left.  //    Calls f(point)  template <typename F> void for_each_r_to_l(F f) const {    int anc_depth = floor_log_2((a - 1) ^ b);    int anc_msk = (1 << anc_depth) - 1;    for (int v = b & anc_msk; v; v &= v - 1) {      int i = countr_zero(unsigned(v));      f(point((b >> i) - 1));    }    for (int v = (-a) & anc_msk; v; ) {      int i = floor_log_2(v);      f(point(((a - 1) >> i) + 1));      v ^= (1 << i);    }  }   template <typename F> void for_parents_down(F f) const {    int x = a, y = b;    if ((x ^ y) > x) { x <<= 1, std::swap(x, y); }    int dx = countr_zero(unsigned(x));    int dy = countr_zero(unsigned(y));    int anc_depth = floor_log_2((x - 1) ^ y);    for (int i = floor_log_2(x); i > dx; i--) {      f(point(x >> i));    }    for (int i = anc_depth; i > dy; i--) {      f(point(y >> i));    }  }   template <typename F> void for_parents_up(F f) const {    int x = a, y = b;    if ((x ^ y) > x) { x <<= 1, std::swap(x, y); }    int dx = countr_zero(unsigned(x));    int dy = countr_zero(unsigned(y));    int anc_depth = floor_log_2((x - 1) ^ y);    for (int i = dx + 1; i <= anc_depth; i++) {      f(point(x >> i));    }    for (int v = y >> (dy + 1); v; v >>= 1) {      f(point(v));    }  }}; struct in_order_layout {  // Alias them in for convenience  using point = seg_tree::point;  using range = seg_tree::range;   int n, s;  in_order_layout() : n(0), s(0) {}  in_order_layout(int n_) : n(n_), s(n ? bit_ceil(unsigned(n)) : 0) {}   point get_point(int a) const {    assert(0 <= a && a < n);    a += s;    return point(a >= 2 * n ? a - n : a);  }   range get_range(int a, int b) const {    assert(0 <= a && a <= b && b <= n);    if (n == 0) return range();    a += s, b += s;    return range((a >= 2 * n ? 2 * (a - n) : a), (b >= 2 * n ? 2 * (b - n) : b));  }   range get_range(std::array<int, 2> p) const {    return get_range(p[0], p[1]);  }   int get_leaf_index(point pt) const {    int a = int(pt);    assert(n <= a && a < 2 * n);    return (a < s ? a + n : a) - s;  }   std::array<int, 2> get_node_bounds(point pt) const {    int a = int(pt);    assert(1 <= a && a < 2 * n);    int l = countl_zero(unsigned(a)) - countl_zero(unsigned(2 * n - 1));    int x = a << l, y = (a + 1) << l;    assert(s <= x && x < y && y <= 2 * s);    return {(x >= 2 * n ? (x >> 1) + n : x) - s, (y >= 2 * n ? (y >> 1) + n : y) - s};  }   int get_node_split(point pt) const {    int a = int(pt);    assert(1 <= a && a < n);    int l = countl_zero(unsigned(2 * a + 1)) - countl_zero(unsigned(2 * n - 1));    int x = (2 * a + 1) << l;    assert(s <= x && x < 2 * s);    return (x >= 2 * n ? (x >> 1) + n : x) - s;  }   int get_node_size(point pt) const {    auto bounds = get_node_bounds(pt);    return bounds[1] - bounds[0];  }}; struct circular_layout {  // Alias them in for convenience  using point = seg_tree::point;  using range = seg_tree::range;   int n;  circular_layout() : n(0) {}  circular_layout(int n_) : n(n_) {}   point get_point(int a) const {    assert(0 <= a && a < n);    return point(n + a);  }   range get_range(int a, int b) const {    assert(0 <= a && a <= b && b <= n);    if (n == 0) return range();    return range(n + a, n + b);  }   range get_range(std::array<int, 2> p) const {    return get_range(p[0], p[1]);  }   int get_leaf_index(point pt) const {    int a = int(pt);    assert(n <= a && a < 2 * n);    return a - n;  }   // Returns {x,y} so that 0 <= x < n and 1 <= y <= n  // If the point is non-wrapping, then 0 <= x < y <= n  std::array<int, 2> get_node_bounds(point pt) const {    int a = int(pt);    assert(1 <= a && a < 2 * n);    int l = countl_zero(unsigned(a)) - countl_zero(unsigned(2 * n - 1));    int s = bit_ceil(unsigned(n));    int x = a << l, y = (a + 1) << l;    assert(s <= x && x < y && y <= 2 * s);    return {(x >= 2 * n ? x >> 1 : x) - n, (y > 2 * n ? y >> 1 : y) - n};  }   // Returns the split point of the node, such that 1 <= s <= n.  int get_node_split(point pt) const {    int a = int(pt);    assert(1 <= a && a < n);    return get_node_bounds(pt.c(0))[1];  }   int get_node_size(point pt) const {    auto bounds = get_node_bounds(pt);    int r = bounds[1] - bounds[0];    return r > 0 ? r : r + n;  }}; } // namespace seg_tree template <typename Info, typename Tag>class LazySegmentTree { public:  int n;  vector<Info> infos;  vector<Tag> tags;  seg_tree::in_order_layout layout;   void Apply(seg_tree::point a, const Tag& t) {    auto [l, r] = layout.get_node_bounds(a);    if (!t.ApplyTo(infos[a], l, r)) {      assert(a < n);      DowndateNode(a);      Apply(a.c(0), t);      Apply(a.c(1), t);      UpdateNode(a);      return;    }    if (a < n) {      t.ApplyTo(tags[a]);    }  }   void DowndateNode(seg_tree::point a) {    if (!tags[a].Empty()) {      Apply(a.c(0), tags[a]);      Apply(a.c(1), tags[a]);      tags[a] = Tag();    }  }   void UpdateNode(seg_tree::point a) {    infos[a] = infos[a.c(0)].Unite(infos[a.c(1)]);  }   LazySegmentTree() : LazySegmentTree(0) {}  LazySegmentTree(int n_) : LazySegmentTree(vector<Info>(n_)) {}  LazySegmentTree(const vector<Info>& a) : n(int(a.size())) {    infos.resize(2 * n);    tags.resize(n);    layout = seg_tree::in_order_layout(n);    for (int i = 0; i < n; i++) {      infos[layout.get_point(i)] = a[i];    }    for (int i = n - 1; i >= 1; i--) {      UpdateNode(seg_tree::point(i));    }  }   void Modify(int l, int r, const Tag& t) {    auto rng = layout.get_range(l, r);    rng.for_parents_down([&](seg_tree::point a) {      DowndateNode(a);    });    rng.for_each([&](seg_tree::point a) {      Apply(a, t);    });    rng.for_parents_up([&](seg_tree::point a) {      UpdateNode(a);    });  }   void Set(int p, const Info& v) {    auto pt = layout.get_point(p);    pt.for_parents_down([&](seg_tree::point a) {      DowndateNode(a);    });    infos[pt] = v;    pt.for_parents_up([&](seg_tree::point a) {      UpdateNode(a);    });  }   Info Query(int l, int r) {    auto rng = layout.get_range(l, r);    rng.for_parents_down([&](seg_tree::point a) {      DowndateNode(a);    });    Info res;    rng.for_each_l_to_r([&](seg_tree::point a) {      res = res.Unite(infos[a]);    });    return res;  }   Info Get(int p) {    auto pt = layout.get_point(p);    pt.for_parents_down([&](seg_tree::point a) {      DowndateNode(a);    });    return infos[pt];  }   template<typename F>  int MaxRight(int l, F f) {    auto rng = layout.get_range(l, n);    rng.for_parents_down([&](seg_tree::point a) {      DowndateNode(a);    });    int res = n;    Info sum;    rng.for_each_l_to_r([&](seg_tree::point a) {      if (res != n) {        return;      }      auto new_sum = sum.Unite(infos[a]);      if (f(new_sum)) {        sum = new_sum;        return;      }      while (a < n) {        DowndateNode(a);        new_sum = sum.Unite(infos[a.c(0)]);        if (f(new_sum)) {          sum = new_sum;          a = a.c(1);        } else {          a = a.c(0);        }      }      res = layout.get_node_bounds(a)[0];    });    return res;  }   template<typename F>  int MinLeft(int r, F f) {    auto rng = layout.get_range(0, r);    rng.for_parents_down([&](seg_tree::point a) {      DowndateNode(a);    });    int res = 0;    Info sum;    rng.for_each_r_to_l([&](seg_tree::point a) {      if (res != 0) {        return;      }      auto new_sum = infos[a].Unite(sum);      if (f(new_sum)) {        sum = new_sum;        return;      }      while (a < n) {        DowndateNode(a);        new_sum = infos[a.c(1)].Unite(sum);        if (f(new_sum)) {          sum = new_sum;          a = a.c(0);        } else {          a = a.c(1);        }      }      res = layout.get_node_bounds(a)[1];    });    return res;  }}; const int inf = int(1e9); struct Info {  int mn = inf;   Info Unite(const Info& b) const {    Info res;    res.mn = min(mn, b.mn);    return res;  }   static Info GetDefault([[maybe_unused]] int l, [[maybe_unused]] int r) {    return Info();  }}; struct Tag {  int add = 0;   bool ApplyTo(Info& a, [[maybe_unused]] int l, [[maybe_unused]] int r) const {    a.mn += add;    return true;  }   void ApplyTo(Tag& t) const {    t.add += add;  }   bool Empty() const {    return add == 0;  }}; int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int n;    cin >> n;    vector<int> p(2 * n - 1);    p[0] = -1;    for (int i = 2; i < 2 * n - 1; i += 2) {      cin >> p[i - 1];      --p[i - 1];      p[i - 1] *= 2;      p[i] = i - 1;    }    hld_forest<int> g(2 * n - 1);    for (int i = 1; i < 2 * n - 1; i++) {      g.add(i, p[i]);    }    g.build_hld(0);    auto Dist = [&](int x, int y) {      int u = g.lca(x, y);      return g.depth[x] + g.depth[y] - 2 * g.depth[u];    };    vector<int> deg(2 * n - 1, 0);    int x = 0, y = 0, diam = 0;    int c = 0;    bool fail = false;    LazySegmentTree<Info, Tag> st(2 * n - 1);    st.Set(g.pos[0], {0});    int delta = 0;    cout << 1;    for (int i = 2; i < 2 * n - 1; i += 2) {      int j = p[i - 1];      deg[i] += 1;      deg[j] += 1;      assert(deg[i] == 1);      if (deg[j] >= 4) {        fail = true;      }      if (!fail && deg[j] == 3) {        st.Set(g.pos[j], {inf});      }      int res = -1;      if (!fail) {        st.Set(g.pos[i], {Dist(i, c) - delta});        int dxi = Dist(x, i);        int dyi = Dist(y, i);        if (max(dxi, dyi) > diam) {          diam = max(dxi, dyi);          if (dxi > dyi) {            y = i;          } else {            x = i;          }          int new_c;          if (g.depth[x] > g.depth[y]) {            new_c = g.go_up(x, diam / 2);          } else {            new_c = g.go_up(y, diam / 2);          }          assert(p[c] == new_c || p[new_c] == c);          if (p[c] == new_c) {            delta -= 1;            st.Modify(g.pos[c], g.end[c] + 1, {+2});          } else {            delta += 1;            st.Modify(g.pos[new_c], g.end[new_c] + 1, {-2});          }          c = new_c;        }        assert(diam % 2 == 0);        int got = st.Query(0, 2 * n - 1).mn;        res = (got + delta + diam / 2) / 2 + 1;        // debug(x, y, diam, c, got, delta, res);      }      cout << \" \" << res;    }    cout << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Iris s Full Binary Tree.json",
    "hint": [
        "Hint1 Consider the degress of vertices in a binary tree. What can you observe? Answer The root has degree , the non-leaf nodes different from the root have degree , the leaf nodes have degree . The degree of every node is not greater than .",
        "Hint2 Choose a root. It should have degree . Is it always possible to build a binary tree on the initial tree if all nodes have degree ? What will be the depth of the binary tree with the given root? Answer It's always possible to build the binary tree, and the depth of the tree is the maximum distance from the root to any nodes in the tree.",
        "Hint3 Consider the binary depth of the full tree. We should to go over every possible root, but how to find the maximum distance from the root to other nodes? Are there any special nodes?",
        "Hint4 Diameter.",
        "Hint5 Is it possible to maintain the answer for all the roots when adding a leaf to the tree?"
    ]
}