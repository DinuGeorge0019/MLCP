{
    "link": "https://codeforces.com//contest/715/problem/A",
    "problemId": "71750",
    "problem_idx": "A",
    "shortId": "715A",
    "contest_number": "715",
    "problem_submissions": {
        "C": [
            20696388,
            20695004,
            21061298,
            20699940,
            20701250,
            20701868,
            20701116,
            20702792,
            20705491,
            20706113,
            20706200,
            20706281,
            20707436,
            24089587,
            24089381,
            24088919,
            20705717,
            20710613,
            20711318,
            20708989,
            20702215
        ],
        "B": [
            20690967,
            20701021,
            20694773,
            20689928,
            20695175,
            20694958,
            20694279,
            20691617,
            20695201,
            20696087,
            20696649,
            20697145,
            20700774,
            20699191,
            20696353,
            20693835,
            20699900,
            20710746
        ],
        "A": [
            20686008,
            20686996,
            20686577,
            20686363,
            20687890,
            20687984,
            20686198,
            20687360,
            20686283,
            20689813,
            20687583,
            20686153,
            20687354,
            20704067,
            20689971,
            20689194,
            20690664,
            20687863,
            20690670,
            20692537
        ],
        "D": [
            20709863,
            20712963,
            20746777,
            20704223,
            20700524
        ]
    },
    "name": "A. Plus and Square Root",
    "statement": "ZS the Coder is playing a game. There is a number displayed on the\r\nscreen and there are two buttons, \u201d (plus) and \u201d (square root).\r\nInitially, the number is displayed on the screen. There are levels in\r\nthe game and ZS the Coder start at the level .When ZS the Coder is at\r\nlevel , he can : . This increases the number on the screen by exactly .\r\nSo, if the number on the screen was , it becomes . . Let the number on\r\nthe screen be . After pressing this button, the number becomes . After\r\nthat, ZS the Coder levels up, so his current level becomes . This button\r\ncan only be pressed when is a , i.e. for some positive integer .\r\nAdditionally, after each move, if ZS the Coder is at level , and the\r\nnumber on the screen is , then . Note that this condition is only\r\nchecked after performing the press. For example, if ZS the Coder is at\r\nlevel and current number is , he presses the \u201d button and the number\r\nturns into . Note that at this moment, is not divisible by , but this\r\npress is still valid, because after it, ZS the Coder is at level , and\r\nis divisible by .ZS the Coder needs your help in beating the game he\r\nwants to reach level . In other words, he needs to press the \u201d button\r\ntimes. Help him determine the number of times he should press the \u201d\r\nbutton before pressing the \u201d button at each level. Please note that ZS\r\nthe Coder wants to find just any sequence of presses allowing him to\r\nreach level , but not necessarily a sequence minimizing the number of\r\npresses.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n;\nint main() {\n\tscanf(\"%d\",&n);\n\tputs(\"2\");\n\tfor (ll k=2;k<=n;k++) printf(\"%lld\\n\",k*(k+1)*(k+1)-(k-1));\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Plus and Square Root.json",
    "editorial_link": "https://codeforces.com//blog/entry/47169",
    "editorial": "Prerequisites : None Firstly, let be the number on the screen before we\r\nlevel up from level to . Thus, we require all the s to be perfect square\r\nand additionally to reach the next via pressing the plus button, we\r\nrequire and for all . Additionally, we also require to be a multiple of\r\n. Thus, we just need to construct a sequence of such integers so that\r\nthe output numbers does not exceed the limit . There are many ways to do\r\nthis. The third sample actually gave a large hint on my approach. If you\r\nwere to find the values of from the second sample, you\u00e2\u0080\u0099ll realize that\r\nit is equal to . You can try to find the pattern from here. My approach\r\nis to use . Clearly, it is a perfect square for all and when , the\r\noutput values can be checked to be less than Unable to parse markup\r\n[type=CF_TEX] The constraints must be a multiple of was added to make\r\nthe problem easier for Div. 1 A. Time Complexity : Code (O(n))\r\n"
}