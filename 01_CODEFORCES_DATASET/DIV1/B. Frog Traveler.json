{
    "link": "https://codeforces.com//contest/1601/problem/B",
    "problemId": "1157778",
    "problem_idx": "B",
    "shortId": "1601B",
    "contest_number": "1601",
    "problem_submissions": {
        "F": [
            133036741,
            133030850,
            133053471,
            133036776,
            136096402,
            133146246
        ],
        "E": [
            133012503,
            133009950,
            133010165,
            133012509,
            133023042,
            133010446,
            133029069,
            133020546,
            133026708,
            133026848,
            133096129,
            133096027,
            133009106,
            133031363,
            133005130,
            133031540,
            133037221,
            133324190,
            133128643,
            133007675,
            133037406
        ],
        "D": [
            133003986,
            133005946,
            133003145,
            133019481,
            133007804,
            133008410,
            133020273,
            133009176,
            133009157,
            133008849,
            133009299,
            133026582,
            133008809,
            133014147,
            133008199,
            133009583,
            133010326,
            133056419,
            133004546,
            133008768
        ],
        "C": [
            132999482,
            132998781,
            132997710,
            132998487,
            133003047,
            133002651,
            133001118,
            133000071,
            133003217,
            132998126,
            133000279,
            133000540,
            133004698,
            133023294,
            133006018,
            133000684,
            132998660,
            133001622,
            133009000,
            133004643
        ],
        "B": [
            132991406,
            132991376,
            132992870,
            132992842,
            132992304,
            132995590,
            132995226,
            132992037,
            132995055,
            132990916,
            132993158,
            132995079,
            132994798,
            132993699,
            132996347,
            133113107,
            132993962,
            132993893,
            132997201,
            132995373,
            132994895
        ],
        "A": [
            132984771,
            132984572,
            132985020,
            132988648,
            132985081,
            132985096,
            132984905,
            132984874,
            132986113,
            132984658,
            132986695,
            132985767,
            132986320,
            132985605,
            132985251,
            132987796,
            132985532,
            132985036,
            132986108,
            132986609
        ]
    },
    "name": "B. Frog Traveler",
    "statement": "Frog Gorf is traveling through Swamp kingdom. Unfortunately, after a\r\npoor jump, he fell into a well of n meters depth. Now Gorf is on the\r\nbottom of the well and has a long way up.The surface of the well\u2019s walls\r\nvary in quality: somewhere they are slippery, but somewhere have\r\nconvenient ledges. In other words, if Gorf is on x meters below ground\r\nlevel, then in one jump he can go up on any integer distance from 0 to\r\na_x meters inclusive. (Note that Gorf can\u2019t jump down, only\r\nup).Unfortunately, Gorf has to take a break after each jump (including\r\njump on 0 meters). And after jumping up to position x meters below\r\nground level, he\u2019ll slip exactly b_x meters down while resting.Calculate\r\nthe minimum number of jumps Gorf needs to reach ground level.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, a[300005], b[300005];\nint dp[300005], pre[300005], pv[300005];\nset<int> R;\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep1(i, n) {\n\t\tscanf(\"%d\", &a[i]); a[i] = i - a[i];\n\t}\n\trep1(i, n) {\n\t\tscanf(\"%d\", &b[i]); b[i] += i;\n\t}\n\t\n\trep(i, n) dp[i] = -1;\n\tdp[n] = 0;\n\tque.push(n);\n\trep(i, n) R.insert(i);\n\twhile(!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\twhile(true) {\n\t\t\tset<int>::iterator it = R.lower_bound(a[v]);\n\t\t\tif(it == R.end() || *it > v) break;\n\t\t\tif(dp[b[*it]] == -1) {\n\t\t\t\tpre[b[*it]] = v; pv[b[*it]] = *it;\n\t\t\t\tdp[b[*it]] = dp[v] + 1; que.push(b[*it]);\n\t\t\t}\n\t\t\tR.erase(it);\n\t\t}\n\t}\n\t\n\tif(dp[0] == -1) printf(\"-1\\n\");\n\telse {\n\t\tprintf(\"%d\\n\", dp[0]);\n\t\tvector<int> ans;\n\t\tfor(int i = 0; i != n; i = pre[i]) ans.push_back(pv[i]);\n\t\tfor(int i = (int)ans.size() - 1; i >= 0; i --) printf(\"%d \", ans[i]);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "graphs",
        "shortest paths",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Frog Traveler.json",
    "editorial_link": "https://codeforces.com//blog/entry/95865",
    "editorial": "Let\u00e2\u0080\u0099s denote sequence of moves as .We will use minimal number of moves\r\nneeded to travel from to .It can be calculated , with . We expected\r\ncalculations to use bfs-style order. So, if there is a jump to , is . If\r\nthere is no jump to , but there is a jump to position with , then is ,\r\nand so on.What happens, when we know all dp\u00e2\u0080\u0099s with values from to ?\r\nWe\u00e2\u0080\u0099ll take position () and all with condition . Then all that has we\r\nknow for sure . For every we will save in minimum segment tree value .\r\nSo, all \u00e2\u0080\u0099s are just elements from a suffix with value not greater than\r\n.We can iterate through all \u00e2\u0080\u0099s, because every of them is used only once\r\nright after we know , we can use any neutral value (infinity in our\r\ncase).Time complexity is Try to solve it in linear time :)\r\n"
}