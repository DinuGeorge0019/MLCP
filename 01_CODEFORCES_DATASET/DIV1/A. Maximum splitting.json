{
    "link": "https://codeforces.com//contest/871/problem/A",
    "problemId": "128426",
    "problem_idx": "A",
    "shortId": "871A",
    "contest_number": "871",
    "problem_submissions": {
        "D": [
            31355895,
            31362333,
            31356242,
            31355369,
            31353137,
            31356572,
            31350479,
            31349876,
            31357261,
            31360056,
            31358528,
            31351384,
            31359864,
            31356104,
            31350689,
            31354294,
            31357470
        ],
        "C": [
            31344782,
            31345046,
            31354747,
            31341122,
            31347757,
            31339514,
            31345476,
            31343571,
            31352939,
            31343640,
            31347078,
            31353076,
            31354366,
            31357931,
            31352546,
            31348044,
            31356324,
            31348388,
            31344111,
            31340976
        ],
        "B": [
            31340037,
            31339973,
            31340246,
            31344130,
            31345296,
            31350867,
            31351902,
            31348642,
            31355117,
            31356940,
            31344400,
            31347404,
            31350125,
            31355555,
            31345128,
            31496128,
            31350503
        ],
        "A": [
            31334951,
            31334542,
            31334472,
            31334988,
            31334223,
            31337899,
            42189225,
            37478044,
            37460318,
            31335310,
            31335726,
            31334028,
            31336751,
            31333319,
            31341866,
            31334833,
            31352270,
            31340759,
            31335206,
            31350845,
            31354568,
            31333534,
            31334865
        ],
        "E": [
            31356130,
            31349981,
            31355349,
            31497224
        ]
    },
    "name": "A. Maximum splitting",
    "statement": "You are given several queries. In the -th query you are given a single\r\npositive integer . You are to represent as a sum of maximum possible\r\nnumber of composite summands and print this maximum number, or print ,\r\nif there are no such splittings.An integer greater than is composite, if\r\nit is not prime, i.e. if it has positive divisors not equal to and the\r\ninteger itself.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n - 1); i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << ' ';\\\n    cerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nint solve(int x) {\n    if (x % 2 == 0) {\n        if (x == 2) return -1;\n        else return x / 4;\n    }\n    if (x < 9) return -1;\n    int y = solve(x - 9);\n    if (y == -1) return -1;\n    else return 1 + y;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); \n    srand((unsigned)chrono::high_resolution_clock::now().time_since_epoch().count());\n    int q;\n    cin >> q;\n    while (q--) {\n        int x;\n        cin >> x;\n        cout << solve(x) << '\\n';\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Maximum splitting.json",
    "editorial_link": "https://codeforces.com//blog/entry/55200",
    "editorial": "Note that minimal composite number is equal to 4. So it is quite logical that there will be a lot of 4 in splitting of big numbers. Let's write for small numbers (1???M???n) dpn   number of composite summands in splitting of n.\n\nIf our query n is small number let's print dpn. Else let's find minimal number k such that n?-?4·k is small number. Then print k?+?dpn?-?4·k.\n\nWe can find dpn in O(M2) or any other reasonable complexity. We even can find all dpn by hands if we set M to 15 or something like that (it will be proved later that 15 is enough).\n\nSo now we have right solution but it is not obvious why this solution works.\n\nProof (not very beautiful but such thoughts can lead to correct solution):\n\nLet's find answer for all numbers from 1 to 15. Several observations:\n\n1) Only 4, 6, 9 occurs in optimal splittings.\n\n2) It is not beneficial to use 6 or 9 more than once because 6?+?6?=?4?+?4?+?4, 9?+?9?=?6?+?6?+?6.\n\n3) 12, 13, 14, 15 have valid splittings.\n\nLet's prove that all numbers that are greater than 15 will have 4 in optimal splitting. Let's guess that it is incorrect. If minimal number in splitting is neither 4 nor 6 nor 9 than this number will have some non-trivial splitting by induction.\n\nIf this number either 6 or 9 and we will decrease query by this number then we will sooner or later get some small number (which is less or equal than 15). There is no splitting of small numbers or it contains 4 in splitting (and it contradicts with minimality of the first number) or it contains 6 and 9. So we have contradiction in all cases.\n\nWe can subtract 4 from any big query and our solution is correct.",
    "hint": []
}