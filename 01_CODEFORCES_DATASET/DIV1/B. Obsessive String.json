{"link": "https://codeforces.com//contest/494/problem/B", "problemId": "19365", "problem_idx": "B", "shortId": "494B", "contest_number": "494", "problem_submissions": {"D": [9118626, 9110497, 9186603, 9121795, 9113766, 9135685, 9135672, 9135646, 9135644, 9118440, 9118021, 9114872], "C": [9115660, 9117032, 9115729, 9112157, 9113416, 9118088, 9112989, 9113678, 9114840, 9114457, 9115024, 9116699, 9114578, 9115874, 9153533], "E": [9112090, 9123061, 9123029, 9114944, 9811638], "B": [9104681, 9106022, 9107594, 9107713, 9107377, 9105960, 9107410, 9107902, 9108808, 9108302, 9109468, 9108127, 9106911, 9107132, 9108038, 9109018], "A": [9103881, 9104046, 9103935, 9104128, 9103929, 9104036, 9104015, 9104004, 9104614, 9104250, 9104342, 9104831, 9104167, 9104248, 9104541, 9104804]}, "name": "B. Obsessive String", "statement": "Hamed has recently found a string and suddenly became quite fond of it.\r\nHe spent several days trying to find all occurrences of in other strings\r\nhe had. Finally he became tired and started thinking about the following\r\nproblem. Given a string how many ways are there to extract\r\nnon-overlapping substrings from it such that each of them contains\r\nstring as a substring? More formally, you need to calculate the number\r\nof ways to choose two sequences and satisfying the following\r\nrequirements: is a substring of string (string is considered as\r\n-indexed). As the number of ways can be rather large print it modulo .\r\n", "solutions": ["#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long)a * b % md;\n}\n\nconst int N = 500010;\n\nchar s[N], t[N];\nint f[N], value[N];\nbool into[N];\nint p[N];\nint jump[N];\n\nint main() {\n  scanf(\"%s\", s + 1);\n  scanf(\"%s\", t + 1);\n  int n = strlen(s + 1);\n  int m = strlen(t + 1);\n  int k = 0;\n  p[1] = 0;\n  for (int i = 2; i <= m; i++) {\n    while (k > 0 && t[i] != t[k + 1]) k = p[k];\n    if (t[i] == t[k + 1]) k++;\n    p[i] = k;\n  }\n  k = 0;\n  for (int i = 1; i <= n; i++) {\n    while (k > 0 && s[i] != t[k + 1]) k = p[k];\n    if (s[i] == t[k + 1]) k++;\n    into[i] = (k == m);\n  }\n  jump[n] = n + 1;\n  for (int i = n - 1; i >= 0; i--) {\n    jump[i] = jump[i + 1];\n    if (i + m <= n && into[i + m]) {\n      jump[i] = i + m;\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    value[i] = 0;\n    f[i] = 0;\n  }\n  f[0] = 1;\n  int sum = 0;\n  for (int i = 0; i <= n; i++) {\n    add(sum, value[i]);\n    add(f[i], sum);\n    add(f[i + 1], f[i]);\n    add(value[jump[i]], f[i]);\n  }\n  add(f[n], md - 1);\n  printf(\"%d\\n\", f[n]);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "strings"], "dificulty": "2000", "interactive": false}