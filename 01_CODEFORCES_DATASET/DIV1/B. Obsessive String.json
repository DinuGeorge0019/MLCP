{
    "link": "https://codeforces.com//contest/494/problem/B",
    "problemId": "19365",
    "problem_idx": "B",
    "shortId": "494B",
    "contest_number": "494",
    "problem_submissions": {
        "D": [
            9118626,
            9110497,
            9186603,
            9121795,
            9113766,
            9135685,
            9135672,
            9135646,
            9135644,
            9118440,
            9118021,
            9114872
        ],
        "C": [
            9115660,
            9117032,
            9115729,
            9112157,
            9113416,
            9118088,
            9112989,
            9113678,
            9114840,
            9114457,
            9115024,
            9116699,
            9114578,
            9115874,
            9153533
        ],
        "E": [
            9112090,
            9123061,
            9123029,
            9114944,
            9811638
        ],
        "B": [
            9104681,
            9106022,
            9107594,
            9107713,
            9107377,
            9105960,
            9107410,
            9107902,
            9108808,
            9108302,
            9109468,
            9108127,
            9106911,
            9107132,
            9108038,
            9109018
        ],
        "A": [
            9103881,
            9104046,
            9103935,
            9104128,
            9103929,
            9104036,
            9104015,
            9104004,
            9104614,
            9104250,
            9104342,
            9104831,
            9104167,
            9104248,
            9104541,
            9104804
        ]
    },
    "name": "B. Obsessive String",
    "statement": "Hamed has recently found a string and suddenly became quite fond of it.\r\nHe spent several days trying to find all occurrences of in other strings\r\nhe had. Finally he became tired and started thinking about the following\r\nproblem. Given a string how many ways are there to extract\r\nnon-overlapping substrings from it such that each of them contains\r\nstring as a substring? More formally, you need to calculate the number\r\nof ways to choose two sequences and satisfying the following\r\nrequirements: is a substring of string (string is considered as\r\n-indexed). As the number of ways can be rather large print it modulo .\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long)a * b % md;\n}\n\nconst int N = 500010;\n\nchar s[N], t[N];\nint f[N], value[N];\nbool into[N];\nint p[N];\nint jump[N];\n\nint main() {\n  scanf(\"%s\", s + 1);\n  scanf(\"%s\", t + 1);\n  int n = strlen(s + 1);\n  int m = strlen(t + 1);\n  int k = 0;\n  p[1] = 0;\n  for (int i = 2; i <= m; i++) {\n    while (k > 0 && t[i] != t[k + 1]) k = p[k];\n    if (t[i] == t[k + 1]) k++;\n    p[i] = k;\n  }\n  k = 0;\n  for (int i = 1; i <= n; i++) {\n    while (k > 0 && s[i] != t[k + 1]) k = p[k];\n    if (s[i] == t[k + 1]) k++;\n    into[i] = (k == m);\n  }\n  jump[n] = n + 1;\n  for (int i = n - 1; i >= 0; i--) {\n    jump[i] = jump[i + 1];\n    if (i + m <= n && into[i + m]) {\n      jump[i] = i + m;\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    value[i] = 0;\n    f[i] = 0;\n  }\n  f[0] = 1;\n  int sum = 0;\n  for (int i = 0; i <= n; i++) {\n    add(sum, value[i]);\n    add(f[i], sum);\n    add(f[i + 1], f[i]);\n    add(value[jump[i]], f[i]);\n  }\n  add(f[n], md - 1);\n  printf(\"%d\\n\", f[n]);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Obsessive String.json",
    "editorial_link": "https://codeforces.com/blog/entry/15148",
    "editorial": "We call an index good if equals . To find all good indexes letâs define\r\nas the length of longest prefix of which is a suffix of . A good index\r\nis an index with . Calculating can be done using Knuth-Morris-Pratt\r\nalgorithm. Letâs define as the number of ways to choose some(at least\r\none) non-overlapping substrings of the prefix of with length () so is a\r\nsubstring of each one of them and is in one the chosen substrings(So it\r\nmust actually be the last character of last chosen substring). Then the\r\nanswer will be . Also letâs define two additional sequence and which\r\nwill help us in calculating . The sequence can then be calculated in as\r\ndescribed below: If is not a good index since in each way counted in the\r\nsubstring containing also contains so for each of these ways removing\r\nfrom the substring containing it leads to a way counted in and\r\nvice-versa thus these two numbers are equal. If is a good index then .\r\nTo prove this letâs consider a way of choosing substring counted in . We\r\ncall such a way valid. The substring containing can be any of the\r\nsubstrings . There are valid ways in which this substring is the only\r\nsubstring weâve chosen. Number of valid ways in which substring\r\ncontaining starts at equals to . So the total number of valid ways in\r\nwhich weâve chosen at least two substrings are equal to which is equal\r\nto . So .\r\n",
    "hint": []
}