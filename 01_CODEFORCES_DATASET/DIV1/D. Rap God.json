{"link": "https://codeforces.com//contest/786/problem/D", "problemId": "99630", "problem_idx": "D", "shortId": "786D", "contest_number": "786", "problem_submissions": {"E": [25753975, 25749618, 25751063, 25750167, 25750928, 25751180, 26105577, 25800132], "D": [25746644, 25778480], "C": [25742197, 25745538, 25743345, 25745842, 25739155, 25745929, 25742960, 25745796, 25744579, 25746028, 25746972, 25743401, 25747247, 25747535, 25746531, 25744441, 25746633, 25742165, 25747374, 25744720], "B": [25740468, 25741179, 25741185, 25743380, 25745478, 25745982, 25742716, 25741370, 25741364, 25742235, 25746446, 25742809, 25743016, 25744432, 25748452, 25743844, 25745002, 25744286, 25740598], "A": [25737862, 25737692, 25737872, 25738672, 25742192, 25738355, 25739309, 25738230, 25737832, 25738120, 25738474, 25738969, 25738916, 25738225, 25737834, 25738628, 25738638, 25747228, 25739393, 25749219]}, "name": "D. Rap God", "statement": "Rick is in love with Unity. But Mr. Meeseeks also love Unity, so Rick\r\nand Mr. Meeseeks are \"love rivals\". Unity loves rap, so it decided that\r\nthey have to compete in a rap game (battle) in order to choose the best.\r\nRick is too nerds, so instead he\u2019s gonna make his verse with running his\r\noriginal algorithm on lyrics \"Rap God\" song. His algorithm is a little\r\nbit complicated. He\u2019s made a tree with vertices numbered from to and\r\nthere\u2019s a lowercase english letter written on each edge. He denotes to\r\nbe the string made by writing characters on edges on the shortest path\r\nfrom to one by one (a string of length equal to distance of to ). Note\r\nthat is reverse of and is empty. In order to make the best verse he can,\r\nhe needs to answer some queries, but he\u2019s not a computer scientist and\r\nis not able to answer those queries, so he asked you to help him. Each\r\nquery is characterized by two vertices and (). Answer to this query is\r\nthe number of vertices like such that and is lexicographically larger\r\nthan .String is lexicographically larger than string , if either and ,\r\nor exists such number , that and . Characters are compared like their\r\nASCII codes (or alphabetic order).Help Rick get the girl (or whatever\r\ngender Unity has).\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=40100;\nint T,p[N],c[N],dep[N],ch[N],vis[N],st[N],q,ret[N],cp[N];\nint n,u,v;\nchar s[10];\n\nvector<PII> e[N],Q[N];\nvoid dfs(int u,int f) {\n\tfor (auto v:e[u]) if (v.fi!=f) {\n\t\tdfs(v.fi,u); p[v.fi]=u; c[v.fi]=v.se;\n\t}\n}\nint gao(int u,int v) {\n\tT++;\n\tint r=v,tot=0; dep[v]=n;\n\tint ret=-1;\n\twhile (r!=u) {\n\t\tch[dep[r]]=c[r];\n\t\tvis[r]=T;\n\t\tcp[r]=1;\n\t\tdep[p[r]]=dep[r]-1;\n\t\tr=p[r];\n\t\tret++;\n\t}\n\tvis[u]=T; cp[u]=1;\n\trep(j,1,n+1) if (vis[j]!=T) {\n\t\tint top=0,r=j;\n\t\twhile (vis[r]!=T) st[top++]=r,r=p[r];\n\t\tper(i,0,top) {\n\t\t\tint r=st[i];\n\t\t\tdep[r]=dep[p[r]]+1;\n\t\t\tvis[r]=T;\n\t\t\tif (cp[p[r]]!=1) cp[r]=cp[p[r]];\n\t\t\telse if (ch[dep[r]]>c[r]) cp[r]=0;\n\t\t\telse if (ch[dep[r]]==c[r]) cp[r]=1; else cp[r]=2;\n\t\t\tret+=(cp[r]==0)||(cp[r]==1&&dep[r]<dep[v]);\n\t\t}\n\t}\n\treturn ret;\n}\nvoid solve(int u,int f) {\n\tfor (auto v:Q[u]) ret[v.se]=gao(u,v.fi);\n\tint pr=c[u];\n\tfor (auto v:e[u]) if (v.fi!=f) {\n\t\tp[u]=v.fi; c[u]=v.se;\n\t\tsolve(v.fi,u);\n\t}\n\tc[u]=pr; p[u]=f;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&q);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d%s\",&u,&v,s);\n\t\te[u].pb(mp(v,s[0])); e[v].pb(mp(u,s[0]));\n\t}\n\tdfs(1,0);\n\trep(i,0,q) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tQ[u].pb(mp(v,i));\n\t}\n\tsolve(1,0);\n\trep(i,0,q) printf(\"%d\\n\",ret[i]);\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "hashing", "strings", "trees"], "dificulty": "3400", "interactive": false}