{
    "link": "https://codeforces.com//contest/786/problem/D",
    "problemId": "99630",
    "problem_idx": "D",
    "shortId": "786D",
    "contest_number": "786",
    "problem_submissions": {
        "E": [
            25753975,
            25749618,
            25751063,
            25750167,
            25750928,
            25751180,
            26105577,
            25800132
        ],
        "D": [
            25746644,
            25778480
        ],
        "C": [
            25742197,
            25745538,
            25743345,
            25745842,
            25739155,
            25745929,
            25742960,
            25745796,
            25744579,
            25746028,
            25746972,
            25743401,
            25747247,
            25747535,
            25746531,
            25744441,
            25746633,
            25742165,
            25747374,
            25744720
        ],
        "B": [
            25740468,
            25741179,
            25741185,
            25743380,
            25745478,
            25745982,
            25742716,
            25741370,
            25741364,
            25742235,
            25746446,
            25742809,
            25743016,
            25744432,
            25748452,
            25743844,
            25745002,
            25744286,
            25740598
        ],
        "A": [
            25737862,
            25737692,
            25737872,
            25738672,
            25742192,
            25738355,
            25739309,
            25738230,
            25737832,
            25738120,
            25738474,
            25738969,
            25738916,
            25738225,
            25737834,
            25738628,
            25738638,
            25747228,
            25739393,
            25749219
        ]
    },
    "name": "D. Rap God",
    "statement": "Rick is in love with Unity. But Mr. Meeseeks also love Unity, so Rick\r\nand Mr. Meeseeks are \"love rivals\". Unity loves rap, so it decided that\r\nthey have to compete in a rap game (battle) in order to choose the best.\r\nRick is too nerds, so instead he’s gonna make his verse with running his\r\noriginal algorithm on lyrics \"Rap God\" song. His algorithm is a little\r\nbit complicated. He’s made a tree with vertices numbered from to and\r\nthere’s a lowercase english letter written on each edge. He denotes to\r\nbe the string made by writing characters on edges on the shortest path\r\nfrom to one by one (a string of length equal to distance of to ). Note\r\nthat is reverse of and is empty. In order to make the best verse he can,\r\nhe needs to answer some queries, but he’s not a computer scientist and\r\nis not able to answer those queries, so he asked you to help him. Each\r\nquery is characterized by two vertices and (). Answer to this query is\r\nthe number of vertices like such that and is lexicographically larger\r\nthan .String is lexicographically larger than string , if either and ,\r\nor exists such number , that and . Characters are compared like their\r\nASCII codes (or alphabetic order).Help Rick get the girl (or whatever\r\ngender Unity has).\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=40100;\nint T,p[N],c[N],dep[N],ch[N],vis[N],st[N],q,ret[N],cp[N];\nint n,u,v;\nchar s[10];\n\nvector<PII> e[N],Q[N];\nvoid dfs(int u,int f) {\n\tfor (auto v:e[u]) if (v.fi!=f) {\n\t\tdfs(v.fi,u); p[v.fi]=u; c[v.fi]=v.se;\n\t}\n}\nint gao(int u,int v) {\n\tT++;\n\tint r=v,tot=0; dep[v]=n;\n\tint ret=-1;\n\twhile (r!=u) {\n\t\tch[dep[r]]=c[r];\n\t\tvis[r]=T;\n\t\tcp[r]=1;\n\t\tdep[p[r]]=dep[r]-1;\n\t\tr=p[r];\n\t\tret++;\n\t}\n\tvis[u]=T; cp[u]=1;\n\trep(j,1,n+1) if (vis[j]!=T) {\n\t\tint top=0,r=j;\n\t\twhile (vis[r]!=T) st[top++]=r,r=p[r];\n\t\tper(i,0,top) {\n\t\t\tint r=st[i];\n\t\t\tdep[r]=dep[p[r]]+1;\n\t\t\tvis[r]=T;\n\t\t\tif (cp[p[r]]!=1) cp[r]=cp[p[r]];\n\t\t\telse if (ch[dep[r]]>c[r]) cp[r]=0;\n\t\t\telse if (ch[dep[r]]==c[r]) cp[r]=1; else cp[r]=2;\n\t\t\tret+=(cp[r]==0)||(cp[r]==1&&dep[r]<dep[v]);\n\t\t}\n\t}\n\treturn ret;\n}\nvoid solve(int u,int f) {\n\tfor (auto v:Q[u]) ret[v.se]=gao(u,v.fi);\n\tint pr=c[u];\n\tfor (auto v:e[u]) if (v.fi!=f) {\n\t\tp[u]=v.fi; c[u]=v.se;\n\t\tsolve(v.fi,u);\n\t}\n\tc[u]=pr; p[u]=f;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&q);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d%s\",&u,&v,s);\n\t\te[u].pb(mp(v,s[0])); e[v].pb(mp(u,s[0]));\n\t}\n\tdfs(1,0);\n\trep(i,0,q) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tQ[u].pb(mp(v,i));\n\t}\n\tsolve(1,0);\n\trep(i,0,q) printf(\"%d\\n\",ret[i]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "hashing",
        "strings",
        "trees"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Rap God.json",
    "editorial_link": "https://codeforces.com//blog/entry/51163",
    "editorial": "Use centroid-decomposition. In each decomposition: Assume is centroid of\r\ncurrent subtree. Then for each vertex in current subtree, we want to\r\nfind some part of answer for each query with . More precisely, for each\r\nquery that is in the current subtree (in the decomposition), we want to\r\nfind the number of vertices like such that is also in the subtree, if we\r\nremove the centroid from the tree and will be disconnected (centroid\r\nitself satisfies this condition) and .. So for each query first compare\r\nwith . Comparing two paths ( and ) can be done using hash (for each and\r\n, keep hash of and its reverse) and using binary search for finding LCP\r\nof two strings. Based on result of comparison: If , then thereâs no such\r\nin current subtree. If and is not a prefix of , then all vertices like\r\nthat satisfy the first two conditions (from the three conditions above)\r\nare counted. Otherwise thereâs a vertex on path from to such that .\r\nBecause and , then you have to count such that satisfy the first two\r\nconditions and . For the third case, you need to count vertices like\r\nthat . For this purpose, using a single DFS construct trie of all and\r\nthen for each query find the position of in the trie (using hashes and\r\nbinary search). More precisely, you need to find LCP of and strings in\r\nthe trie to determine how many strings in the trie are less than .All of\r\nthis can be done in And thereâs an additional for\r\ncentroid-decomposition, so:Total time complexity:\r\n",
    "hint": []
}