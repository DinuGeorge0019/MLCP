{"link": "https://codeforces.com//contest/1198/problem/E", "problemId": "380939", "problem_idx": "E", "shortId": "1198E", "contest_number": "1198", "problem_submissions": {"F": [58070272, 58050274, 58050240, 58050207, 58050120, 58050094, 58050069, 58050046, 58050006, 58049923, 58049860, 58049749, 58019601, 58020980, 58023606, 58025464, 58030444, 58024358, 58026672, 58028904, 58162403, 58161986, 58161687, 58161301, 58039796, 58039793, 58039362, 58039355, 58039125, 58039123, 58038995, 58038994, 58038812, 58038810, 58038134, 58038133, 58037905, 58037904, 58037582, 58037581, 58037164, 58036882, 58036679, 58032989, 58029905, 58028352, 58028560, 58031397, 58032467, 58052909, 58052897, 58051859, 58036577, 58036553], "D": [58009170, 58008663, 58011717, 58013706, 58003645, 58007012, 58019265, 58015153, 58015508, 58008652, 58007749, 58009878, 58015548, 58020689, 58012149, 58011680, 58013790, 58004635], "E": [58005211, 58006936, 58007024, 58005225, 58009765, 58014251, 58015403, 58012193, 58011483, 58014790, 58013911, 58010339, 58023389, 58007572, 58008131, 57999112, 58014046], "C": [58001259, 57997749, 58001059, 58007271, 58013728, 58018717, 58005961, 58006629, 58048331, 58006607, 57998153, 58003794, 58001508, 58001992, 58002563, 58001272, 58004043, 57999919], "B": [57998572, 58004780, 57994973, 58001340, 57998225, 58001182, 57997197, 58002237, 57998507, 58005059, 58000720, 57998812, 57999975, 57997709, 58009338, 57997300], "A": [57995047, 57995575, 57997676, 57995156, 57995500, 57997301, 57995357, 57998877, 57995263, 58002849, 58004383, 58026838, 57997108, 57995572, 58007187, 57995267]}, "name": "E. Rectangle Painting 2", "statement": "There is a square grid of size n\r\ntimes n. Some cells are colored in black, all others are colored in\r\nwhite. In one operation you can select some rectangle and color all its\r\ncells in white. It costs\r\nmin(h, w) to color a rectangle of size h\r\ntimes w. You are to make all cells white for minimum total cost.The\r\nsquare is large, so we give it to you in a compressed way. The set of\r\nblack cells is the union of m rectangles.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int inf=1e9;\n\nusing T = int;\nstruct Flow {\n  struct E {\n    int dest;\n    T orig, *lim, *rev;\n  };\n  int zr, uj, n = 0;\n  vector<unique_ptr<T>> ts;\n  vector<vector<E>> graf;\n  vector<int> ptr, odl;\n  void vert(int v) {\n    n = max(n, v + 1);\n    graf.resize(n);\n    ptr.resize(n);\n    odl.resize(n);\n  }\n  bool iszero(T v) {\n    return !v; // Zmieni\u0107 dla doubli.\n  }\n  void bfs() {\n    fill(odl.begin(), odl.end(), 0);\n    vector<int> kol = {zr};\n    odl[zr] = 1;\n    for (int i = 0; i < (int) kol.size(); i++) {\n      for (E& e : graf[kol[i]]) {\n        if (!odl[e.dest] and !iszero(*e.lim)) {\n          odl[e.dest] = odl[kol[i]] + 1;\n          kol.push_back(e.dest);\n        }\n      }\n    }\n  }\n  T dfs(int v, T lim) {\n    if (v == uj) return lim;\n    T ret = 0, wez;\n    for (int& i = ptr[v]; i < (int) graf[v].size(); i++) {\n      E& e = graf[v][i];\n      if (odl[e.dest] == odl[v] + 1 and !iszero(*e.lim) and\n          !iszero(wez = dfs(e.dest, min(*e.lim, lim)))) {\n        ret += wez;\n        *e.lim -= wez;\n        *e.rev += wez;\n        lim -= wez;\n        if (iszero(lim)) break;\n      }\n    }\n    return ret;\n  }\n  void add_edge(int u, int v, T lim, bool bi = false /* bidirectional? */) {\n    vert(max(u, v));\n    T *a = new T(lim), *b = new T(lim * bi);\n    ts.emplace_back(a);\n    ts.emplace_back(b);\n    graf[u].push_back(E{v, lim,      a, b});\n    graf[v].push_back(E{u, lim * bi, b, a});\n  }\n  T dinic(int zr_, int uj_) {\n    zr = zr_; uj = uj_;\n    vert(max(zr, uj));\n    T ret = 0;\n    while (true) {\n      bfs();\n      fill(ptr.begin(), ptr.end(), 0);\n      const T sta = dfs(zr, numeric_limits<T>::max());  // Dla doubli mo\u017cna da\u0107\n      if (iszero(sta)) break;                           // infinity() zamiast\n      ret += sta;                                       // max().\n    }\n    return ret;\n  }\n  vector<int> cut() {\n    vector<int> ret;\n    bfs();\n    for (int i = 0; i < n; i++)\n      if (odl[i])\n        ret.push_back(i);\n    return ret;\n  }\n  map<pair<int, int>, T> get_flowing() {  // Tam gdzie plynie 0 mo\u017ce nie by\u0107\n    map<pair<int, int>, T> ret;           // kraw\u0119dzi.\n    for (int i = 0; i < n; i++)\n      for (E& e : graf[i])\n        if (*e.lim < e.orig)\n          ret[make_pair(i, e.dest)] += e.orig - *e.lim;\n    for (auto& i : ret) {\n      const pair<int, int> rev{i.first.second, i.first.first};\n      const T x = min(i.second, ret[rev]);\n      i.second -= x;\n      ret[rev] -= x;\n    }\n    return ret;\n  }\n};\n\nint n, m;\n\npii x[nax];\npii y[nax];\n\nvi tx, ty;\nint k;\nint kx[nax];\nint ky[nax];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tscanf(\"%d%d%d%d\", &x[i].first, &y[i].first, &x[i].second, &y[i].second);\n\t\ttx.push_back(x[i].second);\n\t\ttx.push_back(x[i].first-1);\n\t\tty.push_back(y[i].second);\n\t\tty.push_back(y[i].first-1);\n\t}\n\ttx.push_back(0);\n\tty.push_back(0);\n\ttx.push_back(n);\n\tty.push_back(n);\n\tsort(tx.begin(), tx.end());\n\tsort(ty.begin(), ty.end());\n\ttx.resize(unique(tx.begin(), tx.end())-tx.begin());\n\tty.resize(unique(ty.begin(), ty.end())-ty.begin());\n\tFlow janusz;\n\tfor (int i=1; i<(int)tx.size(); i++)\n\t{\n\t\tk++;\n\t\tkx[i]=k;\n\t\tjanusz.add_edge(0, k, tx[i]-tx[i-1]);\n\t}\n\tfor (int i=1; i<(int)ty.size(); i++)\n\t{\n\t\tk++;\n\t\tky[i]=k;\n\t}\n\tk++;\n\tfor (int i=1; i<(int)ty.size(); i++)\n\t{\n\t\tjanusz.add_edge(ky[i], k, ty[i]-ty[i-1]);\n\t}\n\tdebug() << tx;\n\tdebug() << ty;\n\tdebug() << imie(k);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tfor (int a=1; a<(int)tx.size(); a++)\n\t\t{\n\t\t\tfor (int b=1; b<(int)ty.size(); b++)\n\t\t\t{\n\t\t\t\tif (tx[a]<=x[i].second && tx[a]>=x[i].first && ty[b]<=y[i].second && ty[b]>=y[i].first)\n\t\t\t\t\tjanusz.add_edge(kx[a], ky[b], inf);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", janusz.dinic(0, k));\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["flows", "graph matchings", "graphs"], "dificulty": "2500", "interactive": false}