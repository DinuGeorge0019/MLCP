{"link": "https://codeforces.com//contest/1404/problem/E", "problemId": "718465", "problem_idx": "E", "shortId": "1404E", "contest_number": "1404", "problem_submissions": {"D": [92054708, 92052158, 92068012, 92035788, 92064459, 92065822, 92054867, 92062050, 92059537, 92069600, 92065308, 92064419, 92678119, 92059471, 92066519, 92058523, 92073497, 92059060, 92052830, 92062741], "E": [92047893, 92058796, 92034966, 92060195, 92054088, 92055746, 92059735, 92056203, 92048655, 92056326, 92057900, 92058612, 92678137, 92064937, 92060062, 92063614, 92088039, 92051483, 92069623, 92058299, 92069210], "C": [92043774, 92041285, 92054338, 92054493, 92055420, 92044472, 92045777, 92047843, 92049348, 92054237, 92046120, 92049505, 92048234, 92678067, 92045429, 92049783, 92049154, 92048569, 92049406, 92065327, 92047261], "B": [92036978, 92033130, 92045800, 92048542, 92038249, 92036852, 92044012, 92035789, 92064168, 92038925, 92038994, 92035913, 92678047, 92035132, 92035598, 92039096, 92040418, 92033158, 92055911, 92034078], "A": [92024360, 92023992, 92037661, 92039271, 92026103, 92027740, 92024181, 92023800, 92023879, 92029391, 92028274, 92025652, 92678042, 92026279, 92026582, 92024999, 92023858, 92026444, 92025837, 92024282]}, "name": "E. Bricks", "statement": "A brick is defined as a rectangle with integer side lengths with either\r\nwidth 1 or height 1 (or both).There is an n\r\ntimes m grid, and each cell is colored either black or white. A tiling\r\nis a way to place bricks onto the grid such that each black cell is\r\ncovered by exactly one brick, and each white cell is not covered by any\r\nbrick. In other words, bricks are placed on black cells only, cover all\r\nblack cells, and . An example tiling of the first test case using 5\r\nbricks. It is possible to do better, using only 4 bricks. What is the\r\nminimum number of bricks required to make a valid tiling?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class d>\nstruct maxflow{\n\tstruct E{\n\t\tint to,rev;\n\t\td cap;\n\t};\n\tvvc<E> g;\n\tvi itr,lv,q;\n\tmaxflow(int n):g(n),itr(n),lv(n),q(n){}\n\tint ae(int s,int t,d c){\n\t\tg[s].pb({t,(int)g[t].size(),c});\n\t\tg[t].pb({s,(int)g[s].size()-1,0});\n\t\treturn si(g[s])-1;\n\t}\n\tvoid bfs(int s){\n\t\tfill(all(lv),-1);\n\t\tlv[s]=0;\n\t\tint l=0,r=0;\n\t\tq[r++]=s;\n\t\twhile(l<r){\n\t\t\tint v=q[l++];\n\t\t\tfor(auto e:g[v])if(e.cap>0&&lv[e.to]==-1){\n\t\t\t\tlv[e.to]=lv[v]+1;\n\t\t\t\tq[r++]=e.to;\n\t\t\t}\n\t\t}\n\t}\n\td dfs(int v,int t,d f){\n\t\tif(v==t)return f;\n\t\td res=0;\n\t\tfor(int&i=itr[v];i<(int)g[v].size();i++){\n\t\t\tE& e=g[v][i];\n\t\t\tif(e.cap>0&&lv[e.to]==lv[v]+1){\n\t\t\t\td a=dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(a>0){\n\t\t\t\t\te.cap-=a;\n\t\t\t\t\tg[e.to][e.rev].cap+=a;\n\t\t\t\t\tres+=a;\n\t\t\t\t\tf-=a;\n\t\t\t\t\tif(f<=0)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\td calc(int s,int t,d mx=inf){\n\t\td f=0;\n\t\twhile(f<mx){\n\t\t\tbfs(s);\n\t\t\tif(lv[t]==-1)\n\t\t\t\treturn f;\n\t\t\tfill(all(itr),0);\n\t\t\tf+=dfs(s,t,mx-f);\n\t\t}\n\t\treturn f;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,m;cin>>n>>m;\n\tvc<string> str(n);\n\trep(i,n)cin>>str[i];\n\tvvc<int> idx(n,vi(m,-1));\n\tint s=1;\n\tint tot=0;\n\trep(i,n)rep(j,m)if(str[i][j]=='#'){\n\t\tidx[i][j]=s++;\n\t\ttot++;\n\t}\n\tmaxflow<int> mf(++s);\n\tint ans=0;\n\trep(i,n-1)rep(j,m)if(idx[i][j]!=-1&&idx[i+1][j]!=-1){\n\t\tans+=2;\n\t\tmf.ae(0,idx[i][j],1);\n\t\tmf.ae(0,idx[i+1][j],1);\n\t\tmf.ae(idx[i][j],idx[i+1][j],1);\n\t\tmf.ae(idx[i+1][j],idx[i][j],1);\n\t}\n\trep(i,n)rep(j,m-1)if(idx[i][j]!=-1&&idx[i][j+1]!=-1){\n\t\tans+=2;\n\t\tmf.ae(idx[i][j],s-1,1);\n\t\tmf.ae(idx[i][j+1],s-1,1);\n\t\tmf.ae(idx[i][j],idx[i][j+1],1);\n\t\tmf.ae(idx[i][j+1],idx[i][j],1);\n\t}\n\tans-=mf.calc(0,s-1);\n\tprint(tot-ans/2);\n}\n"], "input": "", "output": "", "tags": ["flows", "graph matchings", "graphs"], "dificulty": "2800", "interactive": false}