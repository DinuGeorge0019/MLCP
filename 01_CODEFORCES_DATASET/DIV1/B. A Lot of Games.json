{
    "link": "https://codeforces.com//contest/455/problem/B",
    "problemId": "12118",
    "problem_idx": "B",
    "shortId": "455B",
    "contest_number": "455",
    "problem_submissions": {
        "E": [
            7394351,
            7390143,
            7393335,
            7395556,
            15950366,
            7394387,
            7394798
        ],
        "D": [
            7390969,
            7390195,
            7391117,
            7392248,
            7394913,
            7394348,
            7389780,
            7389657,
            7393511,
            7427462,
            7392513,
            7396567
        ],
        "C": [
            7383856,
            7385374,
            7383929,
            7385253,
            7385742,
            7386825,
            7385353,
            7386072,
            7389234,
            7384477,
            7386261,
            7393242,
            7386556,
            148174431,
            7387128,
            7390044,
            7381535,
            7386375,
            7388516,
            7385462
        ],
        "B": [
            7380394,
            7383005,
            7381184,
            7382059,
            7379729,
            7383546,
            7382905,
            7382344,
            7384255,
            7398378,
            7387760,
            7396316,
            7385727,
            7384109,
            7413972,
            7384883,
            7405728,
            7405656,
            7398462,
            7398419,
            7381057
        ],
        "A": [
            7377249,
            7377722,
            7377369,
            7377768,
            7390843,
            7377960,
            7377218,
            7378095,
            7377940,
            7377402,
            7377315,
            7378476,
            7377536,
            7377288,
            7378601,
            7384879,
            7385848,
            7377439,
            7377794
        ]
    },
    "name": "B. A Lot of Games",
    "statement": "Andrew, Fedor and Alex are inventive guys. Now they invent the game with\r\nstrings for two players.Given a group of non-empty strings. During the\r\ngame two players build the word together, initially the word is empty.\r\nThe players move in turns. On his step player must add a single letter\r\nin the end of the word, the resulting word must be prefix of at least\r\none string from the group. A player loses if he cannot move.Andrew and\r\nAlex decided to play this game times. The player who is the loser of the\r\n-th game makes the first move in the -th game. Guys decided that the\r\nwinner of all games is the player who wins the last (-th) game. Andrew\r\nand Alex already started the game. Fedor wants to know who wins the game\r\nif both players will play optimally. Help him.\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 200010;\n\nint a[N][26];\n\nchar foo[N];\n\nbool can_win[N], can_lose[N];\n\nint main() {\n  int nnn, k;\n  scanf(\"%d %d\", &nnn, &k);\n  memset(a, 0, sizeof(a));\n  int n = 1;\n  for (int i = 0; i < nnn; i++) {\n    scanf(\"%s\", foo);\n    int t = 1;\n    for (int j = 0; foo[j]; j++) {\n      int p = foo[j] - 'a';\n      if (a[t][p] == 0) {\n        n++;\n        a[t][p] = n;\n      }\n      t = a[t][p];\n    }\n  }\n  for (int i = n; i >= 1; i--) {\n    bool mv = false;\n    for (int j = 0; j < 26; j++) {\n      if (a[i][j] != 0) {\n        mv = true;\n        break;\n      }\n    }\n    if (!mv) {\n      can_win[i] = false;\n      can_lose[i] = true;\n      continue;\n    }\n    can_win[i] = false;\n    can_lose[i] = false;\n    for (int j = 0; j < 26; j++) {\n      if (a[i][j] != 0) {\n        if (!can_win[a[i][j]]) {\n          can_win[i] = true;\n        }\n        if (!can_lose[a[i][j]]) {\n          can_lose[i] = true;\n        }\n      }\n    }\n  }\n  if (!can_win[1]) {\n    puts(\"Second\");\n    return 0;\n  }\n  if (can_lose[1]) {\n    puts(\"First\");\n    return 0;\n  }\n  // can_win && !can_lose\n  puts((k % 2 == 1) ? \"First\" : \"Second\");\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "games",
        "implementation",
        "strings",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. A Lot of Games.json",
    "editorial_link": "https://codeforces.com//blog/entry/13336",
    "editorial": "To solve this problem we need the prefix\ntree(trie), which will have all the strings from the group. Next we will\ncalculate the two DP: win[v] Can player win if he makes a move now\n(players have word equal to prefix in the prefix tree(trie)). lose[v]\nCan player lose if he makes a move now (players have word equal to\nprefix in the prefix tree(trie)). if is leaf of trie, then win[v] =\nfalse; lose[v] = true; Else ; , such children of vertex . Let\u00e2\u0080\u0099s look at\na few cases: If , then second player win (first player lose all games).\nIf , then first player win (he can change the state of the game in his\nfavor). If and , then if , then first player win, else second player\nwin. Asymptotics .\n"
}