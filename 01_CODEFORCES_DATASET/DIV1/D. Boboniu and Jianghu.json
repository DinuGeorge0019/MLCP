{"link": "https://codeforces.com//contest/1394/problem/D", "problemId": "697387", "problem_idx": "D", "shortId": "1394D", "contest_number": "1394", "problem_submissions": {"E": [89738268, 89751614, 89751306, 89748113, 92138216, 90294852], "C": [89732445, 89683758, 89696028, 89683626, 89694594, 89712053, 89693715, 89701612, 89697873, 89702287, 89692727, 89701355, 89703625, 90289383, 89700363, 89706177, 89705251, 89703716, 89721405, 89690071, 89703493, 89708013], "D": [89693191, 89704513, 89710792, 89709417, 89804436, 89704286, 89710073, 89710943, 89707637, 89713733, 89713912, 89711885, 89714265, 90289402, 89722481, 89717905, 89719820, 89719453, 89709166, 89707845, 89725892, 89720000], "B": [89670028, 89681474, 89694856, 89677267, 89803448, 89803280, 89758188, 89757972, 89693039, 89682124, 89685684, 89674007, 89686030, 89674213, 89680671, 89691474, 90289363, 89685315, 89684531, 89683358, 89689040, 89677823, 89676540, 89686855, 89686732], "A": [89662871, 89663327, 89661651, 89662462, 89662370, 89664124, 89666251, 89712037, 89661542, 89665502, 89668072, 89669720, 90289341, 89661258, 89665118, 89665097, 89669384, 89661494, 89728914, 89662580, 89663285]}, "name": "D. Boboniu and Jianghu", "statement": "Since Boboniu finished building his Jianghu, he has been doing Kungfu on\r\nthese mountains every day. Boboniu designs a map for his n mountains. He\r\nuses n-1 roads to connect all n mountains. Every pair of mountains is\r\nconnected via roads.For the i-th mountain, Boboniu estimated the\r\ntiredness of doing Kungfu on the top of it as t_i. He also estimated the\r\nheight of each mountain as h_i.A is a sequence of mountains M such that\r\nfor each i (1\r\nle i < |M|), there exists a road between M_i and M_{i+1}. Boboniu would\r\nregard the as a if for each i (1\r\nle i<|M|), h_{M_i}\r\nle h_{M_{i+1}}.Boboniu wants to divide n-1 roads into several . Note\r\nthat each road must appear in challenge, but a mountain may appear in\r\nseveral challenges. Boboniu wants to minimize the total tiredness to do\r\nall the . The tiredness of a M is the sum of tiredness of all mountains\r\nin it, i.e.\r\nsum_{i=1}^{|M|}t_{M_i}. He asked you to find the minimum total\r\ntiredness. As a reward for your work, you\u2019ll become a guardian in his\r\nJianghu.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<bool> vb; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint n;\nll H[MX], T[MX];\nvi adj[MX];\nll dp[MX][2];\n\nvoid dfs(int x, int y) { // 0 -> up, 1 -> down\n\t// max(zeroes, ones)\n\tll sum = 0;\n\tvl dif;\n\tint in = 0, out = 0;\n\ttrav(t,adj[x]) if (t != y) {\n\t\tdfs(t,x);\n\t\tif (H[t] < H[x]) {\n\t\t\tin ++;\n\t\t\tsum += dp[t][0];\n\t\t} else if (H[t] > H[x]) {\n\t\t\tout ++;\n\t\t\tsum += dp[t][1];\n\t\t} else {\n\t\t\tsum += dp[t][0]; // default: in\n\t\t\tdif.pb(dp[t][1]-dp[t][0]);\n\t\t}\n\t}\n\tsort(all(dif));\n\tauto get = [&](int z) {\n\t\tll res = INF, cur = sum;\n\t\tF0R(i,sz(dif)+1) {\n\t\t\tif (i) cur += dif[i-1];\n\t\t\tint IN = in+sz(dif)-i, OUT = out+i;\n\t\t\tif (z == 0) IN ++;\n\t\t\tif (z == 1) OUT ++;\n\t\t\tckmin(res,cur+max(IN,OUT)*T[x]);\n\t\t}\n\t\treturn res;\n\t};\n\tif (y) {\n\t\tdp[x][0] = get(1);\n\t\tdp[x][1] = get(0);\n\t} else {\n\t\tps(get(-1));\n\t}\n}\n\nint main() {\n\tsetIO(); re(n); \n\tFOR(i,1,n+1) re(T[i]);\n\tFOR(i,1,n+1) re(H[i]);\n\tF0R(i,n-1) {\n\t\tint u,v; re(u,v);\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tdfs(1,0);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"], "input": "", "output": "", "tags": ["dp", "greedy", "sortings", "trees"], "dificulty": "2800", "interactive": false}