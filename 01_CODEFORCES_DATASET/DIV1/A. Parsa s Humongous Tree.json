{
    "link": "https://codeforces.com//contest/1528/problem/A",
    "problemId": "994162",
    "problem_idx": "A",
    "shortId": "1528A",
    "contest_number": "1528",
    "problem_submissions": {
        "F": [
            117241784,
            117237625,
            117249711,
            117251014,
            117237719,
            117247531,
            117250487,
            117296792,
            117362083
        ],
        "C": [
            117229826,
            117199788,
            117206577,
            117201851,
            117204674,
            117206245,
            117218212,
            117196904,
            117210131,
            117210736,
            117206890,
            117212730,
            117208145,
            117211669,
            117203428,
            117211467,
            117203007,
            117206081,
            117210746,
            117210824
        ],
        "E": [
            117212844,
            117230561,
            117222959,
            117226469,
            117224989,
            117238353,
            117239558,
            117216115,
            117234224,
            117239827,
            117237600,
            117238423,
            117244129,
            117238121,
            117240390,
            117239904,
            117240349,
            117240625,
            117238487,
            117240173
        ],
        "D": [
            117201259,
            117208270,
            117212623,
            117211738,
            117242708,
            117216479,
            117225362,
            117203170,
            117222650,
            117216984,
            117223735,
            117223429,
            117215498,
            117223732,
            117224661,
            117222534,
            117223454,
            117224387,
            117255573,
            117255349,
            117255220,
            117226605,
            117221662
        ],
        "B": [
            117190972,
            117190286,
            117191599,
            117193984,
            117197139,
            117198582,
            117200082,
            117188842,
            117200429,
            117191737,
            117195913,
            117196829,
            117195712,
            117199801,
            117193006,
            117201359,
            117211353,
            117194542,
            117198721,
            117194778
        ],
        "A": [
            117185385,
            117182301,
            117183363,
            117182330,
            117185042,
            117182254,
            117192623,
            117181878,
            117188021,
            117186007,
            117186714,
            117183913,
            117183194,
            117189883,
            117184967,
            117183486,
            117187212,
            117183227,
            117187339,
            117198905
        ]
    },
    "name": "A. Parsa s Humongous Tree",
    "statement": "Parsa has a humongous tree on n vertices.On each vertex v he has written\r\ntwo integers l_v and r_v.To make Parsa\u2019s tree look even more majestic,\r\nNima wants to assign a number a_v (l_v\r\nle a_v\r\nle r_v) to each vertex v such that the beauty of Parsa\u2019s tree is\r\nmaximized.Nima\u2019s sense of the beauty is rather bizarre. He defines the\r\nbeauty of the tree as the sum of |a_u - a_v| over all edges (u, v) of\r\nthe tree.Since Parsa\u2019s tree is too large, Nima can\u2019t maximize its beauty\r\non his own. Your task is to find the possible beauty for Parsa\u2019s tree.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nusing ll = int64_t;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<vector<int> > edges(n);\n\tvector<ll> l(n), r(n);\n\tfor(int i = 0; i < n; i++) cin >> l[i] >> r[i];\n\tfor(int i = 0; i < n-1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tpair<ll, ll> res = y_combinator(\n\t\t[&](auto self, int v, int p) -> pair<ll, ll> {\n\t\t\tll lcost = 0;\n\t\t\tll rcost = 0;\n\t\t\tfor(int w : edges[v]){\n\t\t\t\tif(w == p) continue;\n\t\t\t\tauto [a, b] = self(w, v);\n\t\t\t\tlcost += max(abs(l[v] - l[w]) + a, abs(l[v] - r[w]) + b);\n\t\t\t\trcost += max(abs(r[v] - l[w]) + a, abs(r[v] - r[w]) + b);\n\t\t\t}\n\t\t\treturn {lcost, rcost};\n\t\t}\n\t)(0, -1);\n\tcout << max(res.first, res.second) << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "divide and conquer",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Parsa s Humongous Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/91058",
    "editorial": "The solution is based on the fact that an optimal assignment for exists\r\nsuch that for each vertex , .Proving this fact isn\u00e2\u0080\u0099t hard, pick any\r\nassignment for . Assume is a vertex in this assignment such that .Let be\r\nthe number of vertices adjacent to such that . Let be the number of\r\nvertices adjacent to such that .Consider the following cases: : In this\r\ncase we can decrease to and get a better result. : In this case we can\r\nincrease to and get a better result. : In this case changing to or will\r\neither increase or not change the beauty of the tree.Based on this fact,\r\nwe can use dynamic programming to find the answer.Define as the maximum\r\nbeauty of \u00e2\u0080\u0099s subtree if is equal to .Similarly, define as the maximum\r\nbeauty of \u00e2\u0080\u0099s subtree if is equal to . is calculated based on \u00e2\u0080\u0099s\r\nchildren, for each of \u00e2\u0080\u0099s children such as , we add \u00e2\u0080\u0099s contribution to\r\n.The transitions are: It\u00e2\u0080\u0099s clear that the answer is equal to\r\n.complexity:\r\n"
}