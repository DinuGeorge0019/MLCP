{"link": "https://codeforces.com//contest/698/problem/C", "problemId": "65778", "problem_idx": "C", "shortId": "698C", "contest_number": "698", "problem_submissions": {"A": [19255240, 19238333, 19233487, 19233309, 19234715, 19232234, 19232460, 19232250, 19232256, 19233295, 19249652, 19232146, 19232208, 19232154, 19232533], "B": [19254561, 19237012, 19237862, 19236769, 19233173, 19239263, 19235681, 19237484, 19241788, 19236331, 19248894, 19236580, 19234441, 19235605, 19239046], "D": [19253572, 19249527, 19248444, 19246796, 19251047, 19251739], "C": [19248258, 19234132, 19243267, 19241700, 19248574, 19235387, 19239629, 19241130, 19239485, 19252239, 19235095, 19245084, 19242311, 19243465, 19252785], "F": [19242723, 19251904, 19301612, 19253678, 19251067, 19249915, 19278249, 19257429, 19255248], "E": [19254153, 19262072, 19250384, 19249636]}, "name": "C. LRU", "statement": "While creating high loaded systems one should pay a special attention to\r\ncaching. This problem will be about one of the most popular caching\r\nalgorithms called LRU (Least Recently Used).Suppose the cache may store\r\nno more than objects. At the beginning of the workflow the cache is\r\nempty. When some object is queried we check if it is present in the\r\ncache and move it here if it\u2019s not. If there are more than objects in\r\nthe cache after this, the least recently used one should be removed. In\r\nother words, we remove the object that has the smallest time of the last\r\nquery.Consider there are videos being stored on the server, all of the\r\nsame size. Cache can store no more than videos and caching algorithm\r\ndescribed above is applied. We know that any time a user enters the\r\nserver he pick the video with probability . The choice of the video is\r\nindependent to any events before.The goal of this problem is to count\r\nfor each of the videos the probability it will be present in the cache\r\nafter queries.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,k;\ndouble p[100],ff[100];\ndouble dp[(1<<20)+10];\nvoid gao(double pr,int i) {\n\tif (fabs(pr)<=1e-9) {\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tdp[0]=pr;\n\trep(i,0,n) ff[i]=0; ff[0]=pr;\n\trep(S,1,(1<<n)) if ((S&(1<<i))==0){\n\t\tdp[S]=0;\n\t\tdouble prob=1;\n\t\trep(j,0,n) if ((S&(1<<j))!=0){\n\t\t\tprob-=p[j];\n\t\t\tdp[S]+=dp[S^(1<<j)]*p[j];\n\t\t}\n\t\tdp[S]/=prob;\n\t\tff[__builtin_popcount(S)]+=dp[S];\n\t}\n\tdouble v=0;\n\trep(i,0,k) v+=ff[i];\n\tprintf(\"%.10f\\n\",v);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,0,n) scanf(\"%lf\",p+i);\n\trep(i,0,n) {\n\t\tgao(p[i],i);\n\t}\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp", "math", "probabilities"], "dificulty": "2400", "interactive": false}