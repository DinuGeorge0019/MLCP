{"link": "https://codeforces.com//contest/800/problem/B", "problemId": "103096", "problem_idx": "B", "shortId": "800B", "contest_number": "800", "problem_submissions": {"A": [26437824, 26437413, 26424399, 26417348, 26417549, 26416882, 26417345, 26417672, 26417220, 26417679, 26421663, 26417804, 26418603, 26418392, 26418074, 26417524, 26460923, 26420581, 26435242, 26677047, 26429059], "E": [26433415, 26477309, 26437062, 26436411], "D": [26430216, 26421580, 26427879, 26424854, 26429250, 26431239, 26427030, 26429935, 26430978, 26427918, 26431811, 26431775, 26432322, 26483339, 26483333, 26483260, 26429237, 26433768, 26460903, 26434200, 26431466, 26431322, 26427768], "C": [26426299, 26426474, 26424315, 26429087, 26424916, 26425781, 26430517, 26426280, 26425889, 26430194, 26427437, 26427899, 26428225, 26431339, 26426820, 26427120, 26426356, 26426998, 26421900], "B": [26421783, 26423033, 26420771, 26420198, 26421833, 26421342, 26421711, 26421555, 26422110, 26423813, 26422982, 26422079, 26421473, 26421858, 26421532, 26422706, 26418487, 26420698, 26435223, 26435196, 26435077]}, "name": "B. Volatile Kite", "statement": "You are given a convex polygon with distinct vertices . Vertex has\r\ncoordinates in the 2D plane. These vertices are listed in clockwise\r\norder.You can choose a real number and move each vertex of the polygon a\r\ndistance of at most from their original positions.Find the maximum value\r\nof such that no matter how you move the vertices, the polygon does not\r\nintersect itself and stays convex.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\ntypedef pa<ld, ld> pt;\n#define x first\n#define y second\n\npt operator - (const pt &a, const pt &b) {\n\treturn pt(a.x - b.x, a.y - b.y);\n}\n\nld operator * (const pt &a, const pt &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nld operator ^ (const pt &a, const pt &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nconst int N = 1000;\n\nstruct Input {\n\tint n;\n\tpt a[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\ta[i] = pt(x, y);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tld ans;\n\t\n\tvoid write () {\n\t\tcout << ans << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\t\n\t\tld calc (const pt &a1, const pt &a2, const pt &a3) {\n\t\t\treturn fabs((a2 - a1) ^ (a3 - a1)) / sqrt((a3 - a2) * (a3 - a2));\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tans = 1e18l;\n\t\t\tforn (i, n) {\n\t\t\t\tpt a1 = a[(i + 0) % n];\n\t\t\t\tpt a2 = a[(i + 1) % n];\n\t\t\t\tpt a3 = a[(i + 2) % n];\n\t\t\t\tumn(ans, calc(a1, a2, a3));\n\t\t\t\tumn(ans, calc(a2, a3, a1));\n\t\t\t\tumn(ans, calc(a3, a1, a2));\n\t\t\t}\n\t\t\tans /= 2;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["geometry"], "dificulty": "1800", "interactive": false}