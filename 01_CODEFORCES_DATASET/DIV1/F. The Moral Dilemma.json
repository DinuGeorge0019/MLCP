{
    "link": "https://codeforces.com//contest/993/problem/F",
    "problemId": "190658",
    "problem_idx": "F",
    "shortId": "993F",
    "contest_number": "993",
    "problem_submissions": {
        "F": [
            39315278,
            39320695,
            39316458,
            39677099
        ],
        "E": [
            39303954,
            44679848,
            44679803,
            39298654,
            39318832,
            39301524,
            39298924,
            39298197,
            39302275,
            39302298,
            39298229,
            39298156,
            39300839,
            39300092,
            39352453,
            39352393,
            39352354,
            39303455,
            39304019,
            39307250,
            39300445,
            39304215,
            39295908,
            39310154
        ],
        "D": [
            39301603,
            39306272,
            39305543,
            39303758,
            39301872,
            39306720,
            39307619,
            39312577,
            39306349,
            39308036,
            39310122,
            39446648,
            39311312,
            39310199,
            39311258,
            39311908,
            39309211,
            39312503,
            41629328,
            39305033
        ],
        "C": [
            39298935,
            39297300,
            39298508,
            39300315,
            39304660,
            39297439,
            39298052,
            39296218,
            39303022,
            39303419,
            39304668,
            39300073,
            39299818,
            39298805,
            39302281,
            39300110,
            39306526,
            39299493
        ],
        "B": [
            39297062,
            39295065,
            39295700,
            39296902,
            39295145,
            39299299,
            39296202,
            39294546,
            39301730,
            39301559,
            39302344,
            39295884,
            39296798,
            39301508,
            39306228,
            39297394,
            39303701,
            39296320
        ],
        "A": [
            39295010,
            39292992,
            39292988,
            39294233,
            39305393,
            39293507,
            39294073,
            39292365,
            39300142,
            39294094,
            39296117,
            39292842,
            39294818,
            39295302,
            39304183,
            39295611,
            39298852,
            39293790
        ]
    },
    "name": "F. The Moral Dilemma",
    "statement": "Hibiki and Dita are in love with each other, but belong to communities\r\nthat are in a long lasting conflict. Hibiki is deeply concerned with the\r\nstate of affairs, and wants to figure out if his relationship with Dita\r\nis an act of love or an act of treason. Hibiki prepared several binary\r\nfeatures his decision will depend on, and built a three layer logical\r\ncircuit on top of them, each layer consisting of one or more logic\r\ngates. Each gate in the circuit is either \"\", \"\", \"\" (not or) or \"\" (not\r\nand). Each gate in the first layer is connected to exactly two features.\r\nEach gate in the second layer is connected to exactly two gates in the\r\nfirst layer. The third layer has only one \"\" gate, which is connected to\r\nall the gates in the second layer (in other words, the entire circuit\r\nproduces 1 if and only if at least one gate in the second layer produces\r\n1).The problem is, Hibiki knows very well that when the person is in\r\nlove, his ability to think logically degrades drastically. In\r\nparticular, it is well known that when a person in love evaluates a\r\nlogical circuit in his mind, every gate evaluates to a value that is the\r\nopposite of what it was supposed to evaluate to. For example, \"\" gates\r\nreturn 1 if and only if both inputs are zero, \"t{nand}\" gates produce 1\r\nif and only if both inputs are one etc.In particular, the \"\" gate in the\r\nlast layer also produces opposite results, and as such if Hibiki is in\r\nlove, the entire circuit produces 1 if and only if all the gates on the\r\nsecond layer produced 0.Hibiki can t allow love to affect his decision.\r\nHe wants to know what is the smallest number of gates that needs to be\r\nremoved from the second layer so that the output of the circuit for all\r\npossible inputs doesn’t depend on whether Hibiki is in love or not.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int AND = 0;\nconst int OR = 1;\nconst int NAND = 2;\nconst int NOR = 3;\n\nconst int N = 111;\n\nint n, m, k;\nstring s;\nint a[N][3];\nint b[N][3];\nvector<int> g[N];\nbool st[N];\nint ord[N];\nint ordSz;\nint col[N];\nint C;\nbool used[N];\nbool oldUsed[N];\nll G[N];\n\nint readType() {\n\tcin >> s;\n\tif (s == \"and\") return AND;\n\tif (s == \"or\") return OR;\n\tif (s == \"nand\") return NAND;\n\tif (s == \"nor\") return NOR;\n\tthrow;\n}\n\nvoid read() {\n\tcin >> n >> m >> k;\n\tfor (int i = 0; i < m; i++) {\n\t\ta[i][0] = readType();\n\t\tcin >> s;\n\t\tint p = 1;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (s[j] == 'x') {\n\t\t\t\ta[i][p++] = j;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tb[i][0] = readType();\n\t\tcin >> s;\n\t\tint p = 1;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (s[j] == 'x') {\n\t\t\t\tb[i][p++] = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid addEdge(int v, int u) {\n\tg[v ^ 1].push_back(u);\n\tg[u ^ 1].push_back(v);\n}\n\nvoid addGraph(int v, int tp) {\n\ttp = a[v][0] ^ (tp << 1);\n\tif (tp == 0) {\n\t\tst[2 * a[v][1] + 1] = 1;\n\t\tst[2 * a[v][2] + 1] = 1;\n\t} else if (tp == 1) {\n\t\taddEdge(2 * a[v][1] + 1, 2 * a[v][2] + 1);\n\t} else if (tp == 2) {\n\t\taddEdge(2 * a[v][1], 2 * a[v][2]);\n\t} else if (tp == 3) {\n\t\tst[2 * a[v][1]] = 1;\n\t\tst[2 * a[v][2]] = 1;\n\t}\n}\n\nvoid dfsMark(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v]) {\n\t\tif (!used[u])\n\t\t\tdfsMark(u);\n\t}\n}\n\nbool checkUsed() {\n\tfor (int i = 0; i < n; i++)\n\t\tif (used[2 * i] && used[2 * i + 1])\n\t\t\treturn false;\n\treturn true;\n}\nbool checkSAT(ll MASK) {\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tg[i].clear();\n\t\tst[i] = 0;\n\t\tused[i] = 0;\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tif (((MASK >> i) & 1) == 0) continue;\n\t\tfor (int j = 1; j < 3; j++)\n\t\t\taddGraph(b[i][j], (int)(b[i][0] < 2));\n\t}\n\tfor (int i = 0; i < 2 * n; i++)\n\t\tif (st[i])\n\t\t\tdfsMark(i);\n\tif (!checkUsed()) return false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[2 * i] || used[2 * i + 1]) continue;\n\t\tfor (int j = 0; j < 2 * n; j++)\n\t\t\toldUsed[j] = used[j];\n\t\tdfsMark(2 * i);\n\t\tif (checkUsed()) continue;\n\t\tfor (int j = 0; j < 2 * n; j++)\n\t\t\tused[j] = oldUsed[j];\n\t\tdfsMark(2 * i + 1);\n\t\tif (!checkUsed()) return false;\n\t}\n\treturn checkUsed();\n}\n\nint intVar[10];\nint cntVar;\n\nbool oper(int t, bool v1, bool v2) {\n\tbool res = 0;\n\tif (t >= 2) {\n\t\tt ^= 2;\n\t\tres ^= 1;\n\t}\n\tif (t == AND)\n\t\treturn res ^ (v1 && v2);\n\telse\n\t\treturn res ^ (v1 || v2);\n}\nbool getValConst(int v, int MASK) {\n\tfor (int i = 0; i < cntVar; i++) {\n\t\tif (intVar[i] == v) {\n\t\t\treturn (MASK >> i) & 1;\n\t\t}\n\t}\n\tthrow;\n}\nbool getValA1(int v, int MASK) {\n\treturn oper(a[v][0], getValConst(a[v][1], MASK), getValConst(a[v][2], MASK));\n}\nbool getValA2(int v, int MASK) {\n\treturn oper(a[v][0] ^ 2, getValConst(a[v][1], MASK), getValConst(a[v][2], MASK));\n}\nbool getValB1(int v, int MASK) {\n\treturn oper(b[v][0], getValA1(b[v][1], MASK), getValA1(b[v][2], MASK));\n}\nbool getValB2(int v, int MASK) {\n\treturn oper(b[v][0] ^ 2, getValA2(b[v][1], MASK), getValA2(b[v][2], MASK));\n}\n\nbool solve(int id1, int id2) {\n//\tcerr << \"SOLVE \" << id1 << \" \" << id2 << endl;\n\tcntVar = 0;\n\tfor (int i = 1; i < 3; i++)\n\t\tfor (int j = 1; j < 3; j++) {\n\t\t\tintVar[cntVar++] = a[b[id1][i]][j];\n\t\t\tintVar[cntVar++] = a[b[id2][i]][j];\n\t\t}\n\tsort(intVar, intVar + cntVar);\n\tcntVar = unique(intVar, intVar + cntVar) - intVar;\n\t/*\n\tfor (int i = 0; i < cntVar; i++)\n\t\tcerr << intVar[i] << \" \";\n\tcerr << endl;\n\t*/\n\tfor (int MASK = 0; MASK < (1 << cntVar); MASK++) {\n//\t\tcerr << MASK << \" \" << getValB1(id1, MASK) << \" \" << getValB2(id2, MASK) << endl;\n\t\tif (getValB1(id1, MASK) && getValB2(id2, MASK))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool isGoodMask(ll MASK) {\n\treturn !checkSAT(MASK);\n}\n\nvoid eraseFromG(int v, int u) {\n\tif ((G[v] >> u) & 1)\n\t\tG[v] ^= 1LL << u;\n}\n\nint ANS = 0;\n\nvoid brute(int curAns, ll curMask, ll cand, ll already) {\n\tif (cand == 0) {\n\t\tif (isGoodMask(curMask))\n\t\t\tANS = max(ANS, curAns);\n\t\treturn;\n\t}\n\tbool ok = true;\n\tfor (int i = 0; ok && i < k; i++) {\n\t\tif (((already >> i) & 1) == 0) continue;\n\t\tif ((G[i] & cand) == cand) ok = false;\n\t}\n\tif (!ok) return;\n\tfor (int v = 0; (1LL << v) <= cand; v++) {\n\t\tif (((cand >> v) & 1) == 0) continue;\n\t\tbrute(curAns + 1, curMask | (1LL << v), (cand & G[v]) ^ (1LL << v), already & G[v]);\n\t\talready |= 1LL << v;\n\t\tcand ^= 1LL << v;\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tread();\n/*\n\tfor (int i = 0; i < m; i++) {\n\t\tcerr << a[i][0] << \" \" << a[i][1] << \" \" << a[i][2] << endl;\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tcerr << b[i][0] << \" \" << b[i][1] << \" \" << b[i][2] << endl;\n\t}\n\n\tcerr << \"read OK\" << endl;\n\n\tif (checkSAT()) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tcerr << \"SAT OK\" << endl;\n*/\n\tfor (int i = 0; i < k; i++)\n\t\tG[i] = (1LL << k) - 1;\n\n\tfor (int i = 0; i < k; i++)\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tif (solve(i, j)) {\n//\t\t\t\tcerr << \"erase \" << i << \" \" << j << endl;\n\t\t\t\teraseFromG(i, j);\n\t\t\t\teraseFromG(j, i);\n\t\t\t}\n\t\t}\n\tll all = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tif (((G[i] >> i) & 1) == 0) continue;\n\t\tall |= 1LL << i;\n\t}\n\tbrute(0, 0, all, 0);\n\tif (ANS == 0)\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << k - ANS << endl;\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. The Moral Dilemma.json",
    "editorial_link": "https://codeforces.com//blog/entry/60047",
    "editorial": "First lets observe that for the original and the inverted circuit to\r\nreturn the same value for each input, for each possible input one of the\r\ntwo conditions must be met: either in the original circuit all the gates\r\nin the second layer return 0, or in the inverted circuit all the gates\r\nin the second layer return 0.This in turn means, that for each input\r\n*each* gate in the second layer must return zero in either original or\r\ninverted circuit. Since its output only depends on at most two gates in\r\nthe first layer, and at most four inputs, we can iterate over all\r\npossible configurations of gates in the first layer, gate in the second\r\nlayer, and connections to the inputs to find all configurations that\r\nmeet this criteria.All these configurations will share an important\r\nproperty: for a gate to return zero for each input in either the\r\noriginal or inverted circuit, it must either return zero in the original\r\ncircuit for all inputs, or return zero in the inverted circuit for all\r\ninputs.Some of these configurations (e.g. ) always return 0 in one\r\ncircuit, and 1 in the opposite circuit. Other configurations (e.g. )\r\nreturn 0 in one circuit, and something depending on the input in\r\nanother, but critically 0 for the case of all inputs equal to 1.For a\r\ncircuit to meet the condition in the problem, it needs to have gates\r\nsuch that all of them return zero in either original or inverted\r\ncircuit, and at least one of them to return one in the other circuit.\r\nWLOG let’s consider the case of all gates returning zero in the original\r\nconfiguration, and at least one returning zero in the inverted\r\nconfiguration. Such circuit has two properties:1. The circuit only\r\ncontains the following gates in the second layer: , , , , , . The first\r\nfour of them in the inverted graph will always return 1, and the last\r\ntwo will return something depending on the input. 2. The circuit\r\ncontains at least one of the first four gate kinds, and having at least\r\none such gate is sufficient for the circuit to meet the condition from\r\nthe problem. The latter is easy to show: since each of the first four\r\ngate kinds always returns 1 in the inverted mode, having it is\r\nsufficient to have at least one gate return 1 in the second layer. To\r\nshow the former, remember that the last two gates return zero in the\r\ninverted mode when all three inputs are ones. It means that no matter\r\nhow many of last two kinds of gates we have, and no matter how they are\r\nwired with the inputs, if all the inputs are equal to 1, all such gates\r\nwill return 0, and at least one gate of the first four kinds will be\r\nnecessary to have at least one gate to return 1.From here the solution\r\nis trivial: to find the largest subset of the gates in the second layer\r\nthat would all return 0 in the original circuit, and at least one return\r\n1 in the inverted, we choose the largest set of gates that belong to the\r\nabovementioned set, for as long as at least one of them belongs to the\r\nfirst four kinds. If no gate in the second layer belongs to the first\r\nfour kinds, the desired subset doesn’t exist.Solution for the case when\r\nthe inverted circuit has all gates in the second layer always return\r\nzero and original has at least one that returns one is solved similarly.\r\n"
}