{
    "link": "https://codeforces.com//contest/1314/problem/E",
    "problemId": "547040",
    "problem_idx": "E",
    "shortId": "1314E",
    "contest_number": "1314",
    "problem_submissions": {
        "F": [
            71726158,
            71718843,
            74749593,
            74749152,
            72292726,
            72292697,
            72292343,
            72291510,
            71844196,
            71723876,
            71715422
        ],
        "B": [
            71718479,
            71829904,
            71711385,
            71709524,
            71707913,
            71711558,
            71720310,
            71713846,
            71720222,
            71715032,
            71716531,
            71717545,
            71717755,
            71716805,
            71725696,
            71868147
        ],
        "D": [
            71714124,
            71712892,
            71733906,
            71707801,
            71745171,
            71710988,
            71712453,
            71713369,
            71709321,
            71710231,
            71720852,
            71726797,
            71713255,
            71704334,
            71710718,
            71710921,
            71711996,
            71765821,
            71712181,
            71712148,
            71712872,
            71716965,
            71711644
        ],
        "C": [
            71711319,
            71864827,
            71714264,
            71722928,
            71716523,
            71714295,
            71721162,
            71720891,
            71720482,
            71720726,
            71723585,
            71724431,
            71726919,
            71725565,
            71714331
        ],
        "A": [
            71703192,
            71704610,
            71703253,
            71706188,
            71703791,
            71704145,
            71707166,
            71705278,
            71704520,
            71703175,
            71715214,
            71703215,
            71703413,
            71707725,
            71704018,
            71704745,
            71703715,
            71704666,
            71704097
        ],
        "E": [
            71722513,
            71724911,
            71718902,
            71725474,
            71727007,
            71717687,
            71725550,
            71726599,
            71726820,
            71859582,
            71935297,
            71720287,
            71723370
        ]
    },
    "name": "E. Strange Function",
    "statement": "Let’s define the function f of multiset a as the multiset of number of\r\noccurences of every number, that is present in a.E.g., f(\r\n{5, 5, 1, 2, 5, 2, 3, 3, 9, 5\r\n}) =\r\n{1, 1, 2, 2, 4\r\n}.Let’s define f^k(a), as applying f to array a k times: f^k(a) =\r\nf(f^{k-1}(a)), f^0(a) = a. E.g., f^2(\r\n{5, 5, 1, 2, 5, 2, 3, 3, 9, 5\r\n}) =\r\n{1, 2, 2\r\n}.You are given integers n, k and you are asked how many different\r\nvalues the function f^k(a) can have, where a is arbitrary non-empty\r\narray with numbers of size no more than n. Print the answer modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4025,M=998244353;\nint n,k,dp[N][N],ans;\nvector<int> v;\nint check(const vector<int>&v,int k){\n\tint sum=0;\n\tfor (int i:v)sum+=i;\n\tif (sum>n)return 0;\n\tif (k<=1)return 1;\n\tvector<int> New;\n\tfor (int i=v.size()-1;i>=0;i--)\n\t\tfor (int j=0;j<v[i];j++)New.push_back(v.size()-i);\n\treturn check(New,k-1);\n}\nvoid dfs(int x){\n\tfor (int i=x;i;i++){\n\t\tv.push_back(i);\n\t\tif (check(v,k))ans++,dfs(i);\n\t\telse {\n\t\t\tv.pop_back();\n\t\t\treturn;\n\t\t}\n\t\tv.pop_back();\n\t}\n}\nint g[N][N];\ninline int f(int n,int k) {\n\tif(~g[n][k]) return g[n][k];\n\tif(n > k * (k + 1) / 2) {\n\t\treturn g[n][k] = (f(n - k * (k + 1) / 2, k) + f(n, k + 1)) % M;\n\t} else {\n\t\treturn g[n][k] = n == k * (k + 1) / 2;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1){\n\t\tdp[1][1]=1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tif (i<j)dp[i][j]=dp[i][i];\n\t\t\t\telse if (i==j)dp[i][j]=(dp[i][j-1]+1)%M;\n\t\t\t\telse dp[i][j]=(dp[i][j-1]+dp[i-j][j])%M;\n\t\tint ans=0;\n\t\tfor (int i=1;i<=n;i++)(ans+=dp[i][i])%=M;\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(k == 2) {\n\t\tmemset(g, -1, sizeof g);\n\t\tint ans = 0;\n\t\tfor(int i = 1;i <= n;++i) {\n\t\t\tans = (ans + f(i, 1)) % M;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\tif (k>2){\n\t\tdfs(1);\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Strange Function.json",
    "editorial_link": "https://codeforces.com//blog/entry/74214",
    "editorial": "The solution of the task consists of three cases:\n\nk=1\n. For fixed n\n f(a)\n can be equal to any partition of n\n. We need to count the number of arrays b1,b2,,bm\n, such that b1?b2??bm\n and ?i=1mbi?n\n. This can be done by simple dp in O(n2)\n (or even faster, much faster).\nk=2\n. When the array b1?b2??bm\n can be equal to value of f2(a)\n for some |a|?n\n? When there exists some array c1,,cl\n such that ?i=1lci?n\n, and f(c)=b\n. The values of b\n are the numbers of occurences of numbers in c\n, so we need to minimize ?i=1mbivi\n, where vi\n  the unique numbers in c\n.\nTo minimize this sum we should take v1=1,,vm=m\n, so we need ?i=1mbii?n\n. This can be done by simple dp: dp[val][j][sum]\n  the number of prefixes of b\n such that we already took j\n elements to b\n, all elements on prefix are greater than or equal to val\n, and the ?i=1jbii=sum\n.\n\nThis dp can look like it is O(n3)\n, but it is actually O(n2logn)\n, because there is a limitation val?j?n\n, and there are O(nlogn)\n such pairs. There is also a subquadratic solution.\n\nk?3\n. We can notice that in the array f2(a)\n there are at most O(2n???)\n elements. We can use this fact to bruteforce all possible answers  candidates for the answer are the partitions of numbers not exceeding 2n???=64\n, there are few millions of them.\nHow to check if the array b1?b2??bm\n can be the falue of fk(a)\n? It happens that we can make k?2\n iterations of the unfolding algorithm from case k=2\n and get the «minimal» possible array a\n, and check, if it contains no more than n\n elements. This part works in O(P(2n???))\n.",
    "hint": []
}