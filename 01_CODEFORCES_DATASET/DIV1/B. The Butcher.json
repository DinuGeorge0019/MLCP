{
    "link": "https://codeforces.com//contest/1819/problem/B",
    "problemId": "1880619",
    "problem_idx": "B",
    "shortId": "1819B",
    "contest_number": "1819",
    "problem_submissions": {
        "E": [
            202225318,
            202223532,
            202223484,
            202225560,
            202308964,
            202224265,
            202225112,
            202221853,
            202253482,
            202237435,
            203635743,
            203096948,
            202225859,
            202369794
        ],
        "D": [
            202209352,
            202212141,
            202205538,
            202220831,
            202198559,
            202210822,
            202236119,
            202239190,
            202212242,
            202208889,
            202205391,
            202216800,
            203995136,
            202197649,
            202216978,
            202217768,
            202220492,
            202220964,
            202225376,
            202219172
        ],
        "C": [
            202201042,
            202203020,
            202193305,
            202202657,
            202190230,
            202199701,
            202199472,
            202200745,
            202199789,
            202199523,
            208251329,
            202218422,
            202204297,
            202216624,
            202204671,
            202205053,
            202201997,
            202201056,
            202198992
        ],
        "B": [
            202193365,
            202195322,
            202214813,
            202196120,
            202186520,
            202187817,
            202188682,
            202193750,
            202186708,
            202188527,
            202188957,
            202183110,
            202191595,
            202187157,
            202193385,
            202195604,
            202188109,
            202186084,
            202189411
        ],
        "A": [
            202182367,
            202180872,
            202181217,
            202181093,
            202180590,
            202180859,
            202181832,
            202181960,
            202180690,
            202180596,
            202180602,
            202180463,
            202182678,
            202180651,
            202182633,
            202181119,
            202181593,
            202180899,
            202180615
        ],
        "F": [
            202939012,
            206043011
        ]
    },
    "name": "B. The Butcher",
    "statement": "Anton plays his favorite game \"Defense of The Ancients 2\" for his\r\nfavorite hero The Butcher. Now he wants to make his own dinner. To do\r\nthis he will take a rectangle of height h and width w, then make a\r\nvertical or horizontal cut so that both resulting parts have integer\r\nsides. After that, he will put one of the parts in the box and cut the\r\nother again, and so on.More formally, a rectangle of size h\r\ntimes w can be cut into two parts of sizes x\r\ntimes w and (h - x)\r\ntimes w, where x is an integer from 1 to (h - 1), or into two parts of\r\nsizes h\r\ntimes y and h\r\ntimes (w - y), where y is an integer from 1 to (w - 1).He will repeat\r\nthis operation n - 1 times, and then put the remaining rectangle into\r\nthe box too. Thus, the box will contain n rectangles, of which n - 1\r\nrectangles were put in the box as a result of the cuts, and the n-th\r\nrectangle is the one that the Butcher has left after all n - 1\r\ncuts.Unfortunately, Butcher forgot the numbers h and w, but he still has\r\nn rectangles mixed in random order. Note that Butcher , but only\r\nshuffled them. Now he wants to know all possible pairs (h, w) from which\r\nthis set of rectangles can be obtained. And you have to help him do\r\nit!It is guaranteed that there exists at least one pair (h, w) from\r\nwhich this set of rectangles can be obtained.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n\n#define ll long long\n#define int ll\n#define ull unsigned ll\n#define ld long double\n#define rep(a) rep1(i,a)\n#define rep1(i,a) rep2(i,0,a)\n#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)\n#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)\n#define chkmin(a,b) (a=min(a,b))\n#define chkmax(a,b) (a=max(a,b))\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int>\n#define pb push_back\n#define eb emplace_back\n#define sort_unique(a) sort(all(a)),a.resize(unique(all(a))-a.begin())\n//#define inf 1010000000\n#define inf 4000000000000000000\n#define eps 1e-9\n#define sz(a) ((int)a.size())\n#define pow2(x) (1ll<<(x))\n#define ceiling(a,b) (((a)+(b)-1)/(b))\n#define print0(a) cout << (a) << ' '\n#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#ifdef i_am_noob\n#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)\ntemplate<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}\ntemplate<typename T> void _do(T && x) {cerr << x << endl;}\ntemplate<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}\n#else\n#define bug(...) 777771449\n#endif\ntemplate<typename T> void print(T && x) {cout << x << \"\\n\";}\ntemplate<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\n\nconst int Mod=1000000007,Mod2=998244353;\nconst int MOD=Mod2;\ntemplate <int mod>\nstruct Modint{\n    int val;\n    Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}\n    Modint operator +(const Modint& o) const {\n        Modint res;\n        res.val=val+o.val;\n        if(res.val>=mod) res.val-=mod;\n        return res;\n    }\n    Modint operator +(const int& o) const {return Modint(val+o);}\n    Modint operator -() const {\n        Modint res;\n        res.val=-val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const Modint& o) const {\n        Modint res;\n        res.val=val-o.val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const int& o) const {return Modint(val-o);}\n    Modint operator *(const Modint& o) const {return Modint(val*o.val);}\n    Modint operator *(const int& o) const {return Modint(val*(o%mod));}\n    Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}\n    Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}\n    Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}\n    Modint Pow(int b) const {\n        Modint tmp(val),ret(1);\n        while(b){\n            if(b&1) ret*=tmp;\n            b>>=1;tmp*=tmp;\n        }\n        return ret;\n    }\n    Modint Pow(const Modint& a, int b) const {return a.Pow(b);}\n    inline Modint inv() const {return (*this).Pow(mod-2);}\n    Modint operator /(const Modint& o) const {return *this*o.inv();}\n    Modint operator /(const int& o) const {return *this*Modint(o).inv();}\n    bool operator ==(const Modint& o) const {return val==o.val;}\n};\ntemplate<int mod>\nostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}\ntemplate<int mod>\nModint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}\ntemplate<int mod>\nModint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}\ntemplate<int mod>\nModint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}\n#define modint Modint<MOD>\nvector<modint> inv,fac,invfac;\nvoid init_comb(int N){\n    inv.resize(N),fac.resize(N),invfac.resize(N);\n    inv[1]=1,fac[0]=1,invfac[0]=1;\n    rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);\n    rep2(i,1,N) fac[i]=fac[i-1]*i;\n    rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];\n}\ninline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}\ninline modint H(int n, int m){return C(n+m-1,n);}\n\nconst int maxn=200005,maxm=pow2(17),maxk=7777714;\n\n//i_am_noob\n#define wiwihorz  \nvoid balbitorz(){}\nint n,a[maxn],b[maxn];\nbool vis[maxn];\n\nvector<pii> res;\n\nbool solve(int r, int c, bool de){\n    bool flag=de;\n    priority_queue<pii> pqr,pqc;\n    rep(n) pqr.push({a[i],i}),pqc.push({b[i],i}),vis[i]=0;\n    int cur=0;\n    //bug(r,c);\n    while(cur<n){\n        if(flag){\n            while(vis[pqr.top().second]) pqr.pop();\n            if(pqr.top().first!=r) return 0;\n            while(sz(pqr)&&pqr.top().first==r){\n                int i=pqr.top().second;\n                if(!vis[i]){\n                    c-=b[i];\n                    vis[i]=1;\n                    cur++;\n                    //bug(i,cur);\n                }\n                pqr.pop();\n            }\n        }\n        else{\n            while(vis[pqc.top().second]) pqc.pop();\n            if(pqc.top().first!=c) return 0;\n            while(sz(pqc)&&pqc.top().first==c){\n                int i=pqc.top().second;\n                if(!vis[i]){\n                    r-=a[i];\n                    vis[i]=1;\n                    cur++;\n                }\n                pqc.pop();\n            }\n        }\n        //bug(cur);\n        flag^=1;\n    }\n    if(r*c!=0) return 0;\n    return 1;\n}\n\nvoid orzck(){\n    cin >> n;\n    rep(n) cin >> a[i] >> b[i];\n    int area=0;\n    rep(n) area+=a[i]*b[i];\n    int maxr=*max_element(a,a+n),maxc=*max_element(b,b+n);\n    res.clear();\n    if(area%maxr==0){\n        if(solve(maxr,area/maxr,1)) res.pb({maxr,area/maxr});\n    }\n    if(area%maxc==0){\n        if(solve(area/maxc,maxc,0)) res.pb({area/maxc,maxc});\n    }\n    if(sz(res)>=2&&res[0]==res[1]) res.pop_back();\n    assert(sz(res));\n    print(sz(res));\n    for(auto [x,y]: res) print(x,y);\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    // #ifdef i_am_noob\n    // freopen(\"input1.txt\",\"r\",stdin);\n    // freopen(\"output1.txt\",\"w\",stdout);\n    // freopen(\"output2.txt\",\"w\",stderr);\n    // #endif\n    cout << fixed << setprecision(15);\n    ld start=clock();\n    balbitorz();\n    int t;\n    #ifdef wiwihorz\n    cin >> t;\n    #else\n    t=1;\n    #endif\n    while(t--) orzck();\n    bug((clock()-start)/CLOCKS_PER_SEC);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "greedy",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. The Butcher.json",
    "editorial_link": "https://codeforces.com//blog/entry/115133",
    "editorial": "Note that we know the area of the original rectangle. This value can be\r\ncalculated as the sum of the areas of the given rectangles. Now let\u00e2\u0080\u0099s\r\nconsider two similar cases: the first cut was horizontal or the first\r\ncut was vertical. We will present the solution for the first case, the\r\nsecond one is considered similarly.If the first cut was horizontal, then\r\nthere exists a rectangle which width is equal to the width of the entire\r\noriginal rectangle. Moreover, it\u00e2\u0080\u0099s easy to notice that this is a\r\nrectangle with the maximum width. Knowing the width and area, we also\r\nknow the height of the rectangle we need. The only thing left is to come\r\nup with an algorithm that, for given and , tells us whether it is\r\npossible to construct a rectangle with such dimensions.We will perform\r\nthe following procedure: let us have a rectangle for which or holds, and\r\ncut off our current rectangle with the rectangle . Formally, if , we\r\nwill make , if , we will make . Note that this greedy algorithm is\r\ncorrect, since at each iteration we performed either a horizontal cut or\r\na vertical cut. Thus, at each iteration of our algorithm, we should have\r\nonly one option: to remove some rectangle corresponding to a vertical\r\ncut or to remove a rectangle corresponding to a horizontal cut. We can\r\nchoose any of these rectangles.Having performed this algorithm in the\r\ncase where the first cut was vertical and in the case where the first\r\ncut was horizontal, we will check both potential answers.Time\r\ncomplexity: .\r\n"
}