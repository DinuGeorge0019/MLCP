{"link": "https://codeforces.com//contest/115/problem/E", "problemId": "611", "problem_idx": "E", "shortId": "115E", "contest_number": "115", "problem_submissions": {"D": [700677, 709440, 703439, 700783], "E": [699985, 700148, 699895, 700886, 700709, 699935, 700481, 704109, 702223, 702118, 701045, 699830, 700560], "C": [698491, 698807, 698911, 698386, 699374, 701004, 698059, 699204, 699619, 699661, 702059], "B": [697429, 697289, 697881, 697365, 697647, 697668, 699366, 697349, 697691, 697537, 697907, 698287, 699705], "A": [696588, 696258, 695843, 695844, 696704, 696136, 696907, 695911, 696007, 696195, 695937, 696483, 695990]}, "name": "E. Linear Kingdom Races", "statement": "You are a car race organizer and would like to arrange some races in\r\nLinear Kingdom.Linear Kingdom has consecutive roads spanning from left\r\nto right. The roads are numbered from to from left to right, thus the\r\nroads follow in the order of their numbers\u2019 increasing. There will be\r\nseveral races that may be held on these roads. Each race will use a\r\nsubset of these roads. Also, each race will pay some amount of money to\r\nyou if this race is held. No races overlap in time, so some roads can be\r\nused in several races.Unfortunately, some of the roads are in a bad\r\ncondition and they need repair. Each road has repair costs associated\r\nwith it, you are required to pay this cost to repair the road. A race\r\ncan only take place if all the roads used in the race are renovated.\r\nYour task is to repair such roads (possibly all or none) that will\r\nmaximize your profit. Your profit is defined as the total money you get\r\nfrom the races that are held minus the total money you spent to repair\r\nthe roads. Note that you may decide not to repair any road and gain zero\r\nprofit.Print the maximum profit you can gain.\r\n", "solutions": ["#include <vector>\n#include <cstring>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <stdlib.h>\n#include <ctime>\n#include <string>\n#include <complex>\n#ifdef __ASD__\n#include <windows.h>\n#endif\nusing namespace std;\n#define all(a) a.begin(),a.end()\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define fornn(i,n) for(i=0;i<(n);++i)\n#define lng long long\n#define SQ(a) ((a)*(a))\n#define forv(i,v) for(int i=0;i<(int)v.size();++i)\n#define mp make_pair\n#define pb push_back\n#define ABS(a) ((a)<0?-(a):(a))\n#define iinf 1000000000\n#define linf 1000000000000000000LL\n#define dinf 1e200\n#define left asdleft\n#define prev asdprev\n#define eps 1e-12\n#define y1 asdy1\n#define y2 asdy2\n#define EQ(a,b) abs((a)-(b))<eps\n#define PI 3.1415926535897932384626433832795\n#define DEG2RAD PI/180\n#define ulng unsigned lng\n#define next asdnext\n#define prev asdprev\nvoid mytimer(string task){\n#ifdef __ASD__\n        static LARGE_INTEGER prev;      LARGE_INTEGER cur,freq; QueryPerformanceCounter(&cur);  QueryPerformanceFrequency(&freq);       if(task!=\"\")            cout<<task<<\" took \"<<(cur.QuadPart-prev.QuadPart)*1.0/freq.QuadPart<<endl;     prev=cur;\n#endif\n}\nvoid ext(int c){\n#ifdef __ASD__\n        exit(c);\n#endif\n}\n\nconst int lim=1000000;\nlng tree[lim];\nlng delta[lim];\n\nvoid add(int l,int r,lng v,int a,int b,int k){\n    if(l==a&&r==b){\n        delta[k]+=v;\n        tree[k]+=v;\n        return;\n    }\n    int c=(a+b)/2;\n    if(r<=c)\n        add(l,r,v,a,c,k*2+1);\n    else if(l>=c)\n        add(l,r,v,c,b,k*2+2);\n    else{\n        add(l,c,v,a,c,k*2+1);\n        add(c,r,v,c,b,k*2+2);\n    }\n    tree[k]=max(tree[k*2+1],tree[k*2+2])+delta[k];\n}\n\nvector<pair<int,int> > *starts = new vector<pair<int,int> >[210000];\nint cost[210000];\nint n;\n\n#define taska \"burai\"\nint main(){\n#ifdef __ASD__\n    freopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout);\n#else\n    //freopen(taska\".in\",\"r\",stdin);freopen(taska\".out\",\"w\",stdout);\n#endif\n\n    ios_base::sync_with_stdio(false);\n\n    int m;\n    cin>>n>>m;\n    forn(i,n)\n        cin>>cost[i];\n    forn(i,m){\n        int a,b,c;\n        cin>>a>>b>>c;\n        --a;--b;\n        starts[b].pb(mp(a,c));\n    }\n\n    forn(k,n){\n        add(k+1,k+2,tree[0],0,n+1,0);\n        add(0,k+1,-cost[k],0,n+1,0);\n        forv(i,starts[k])\n            add(0,starts[k][i].first+1,starts[k][i].second,0,n+1,0);\n    }\n\n    cout<<tree[0];\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp"], "dificulty": "2400", "interactive": false}