{
    "link": "https://codeforces.com//contest/2023/problem/D",
    "problemId": "2964367",
    "problem_idx": "D",
    "shortId": "2023D",
    "contest_number": "2023",
    "problem_submissions": {
        "F": [
            287014608,
            287072234,
            299830672,
            287085195,
            287027962,
            287042299,
            287238133,
            287043650
        ],
        "E": [
            286990891,
            287003441,
            287204391,
            287202274,
            287014470,
            287010378,
            287009293,
            287034992,
            287190288,
            287004818,
            287142133
        ],
        "D": [
            286943910,
            286985197,
            287179114,
            287178062,
            286983477,
            286986708,
            286993474,
            286930212,
            286984453,
            286985894,
            286983025,
            286981875,
            287091406,
            286988866,
            286991623,
            286991730,
            286972363,
            290388826,
            290388744,
            286996161,
            286993279,
            287000155,
            287068676,
            287061033,
            286997472,
            287003784
        ],
        "C": [
            286925333,
            287063584,
            286928411,
            286930839,
            286944563,
            286945303,
            286973941,
            286936797,
            286923792,
            286935049,
            286934113,
            286960906,
            286944493,
            286935726,
            286931426,
            286988231,
            286961072,
            286929444,
            286959433,
            286973882,
            286960461
        ],
        "B": [
            286913842,
            286912400,
            286915696,
            286920706,
            286917936,
            286918820,
            286920898,
            286929873,
            286915247,
            286917134,
            286915488,
            286916176,
            286919025,
            286919305,
            286914068,
            286921817,
            286912738,
            286921828,
            286922164,
            286920262
        ],
        "A": [
            286905356,
            286905575,
            286907414,
            286907460,
            286908014,
            286911602,
            286910636,
            286905107,
            286906378,
            286906055,
            286906420,
            286919318,
            286909880,
            286905489,
            286910067,
            286910062,
            286905533,
            286909956,
            286907288,
            286911621
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "Claim 1: Suppose we took at least one item with . Then it is claimed\r\nthat the sum over all taken elements is . To prove this, letâs assume\r\nthe opposite and try to remove any element with from the taken set,\r\ndenoting .The answer was , but it became . The answer increased if ,\r\nthat is, , which is true if . This is true since , while .Letâs isolate\r\nall items with . If their sum is , then we know the answer; otherwise,\r\nfor each weight sum, we will find the maximum probability with which\r\nsuch weight can be obtained using a dynamic programming approach similar\r\nto the knapsack problem.To do this quickly, we will reduce the number of\r\nconsidered items. For each , answer will contain some prefix of elements\r\nwith that , sorted in descending order by . If in the optimal answer\r\nthere are elements with , then ; otherwise, the smallest element can\r\ndefinitely be removed. Rewriting the inequality gives us , which means .\r\nThus, among the elements with a given , it is sufficient to keep for\r\nconsideration the top best items, or about (i.e., ) items across all .In\r\nthe end, it is enough to go through the dynamic programming and find the\r\ncell with the highest answer.The total running time is .\r\n",
    "name": "D. Many Games",
    "statement": "Recently, you received a rare ticket to the only casino in the world\r\nwhere you can actually earn something, and you want to take full\r\nadvantage of this opportunity.The conditions in this casino are as\r\nfollows: There are a total of n games in the casino. You can play each\r\ngame . Each game is characterized by two parameters: p_i (1\r\nle p_i\r\nle 100) and w_i the probability of winning the game in percentage and\r\nthe winnings for a win. If you lose in any game you decide to play, you\r\nwill receive nothing at all (even for the games you won). You need to\r\nchoose a set of games in advance that you will play in such a way as to\r\nmaximize the expected value of your winnings.In this case, if you choose\r\nto play the games with indices i_1 < i_2 <\r\nldots < i_k, you will win in all of them with a probability of\r\nprod\r\nlimits_{j=1}^k\r\nfrac{p_{i_j}}{100}, and in that case, your winnings will be equal to\r\nsum\r\nlimits_{j=1}^k w_{i_j}.That is, the expected value of your winnings will\r\nbe\r\nleft(\r\nprod\r\nlimits_{j=1}^k\r\nfrac{p_{i_j}}{100}\r\nright)\r\ncdot\r\nleft(\r\nsum\r\nlimits_{j=1}^k w_{i_j}\r\nright).To avoid going bankrupt, the casino owners have limited the\r\nexpected value of winnings for each individual game. Thus, for all i (1\r\nle i\r\nle n), it holds that w_i\r\ncdot p_i\r\nle 2\r\ncdot 10^5.Your task is to find the maximum expected value of winnings\r\nthat can be obtained by choosing some set of games in the casino.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long; constexpr int C = 210000; int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        std::cout << std::fixed << std::setprecision(10);     int n;    std::cin >> n;        std::vector<int> a[100];    i64 sum = 0;        for (int i = 0; i < n; i++) {        int p, w;        std::cin >> p >> w;        if (p == 100) {            sum += w;        } else {            a[p].push_back(w);        }    }        std::vector<double> dp(C);    dp[0] = 1;        for (int p = 1; p < 100; p++) {        std::sort(a[p].begin(), a[p].end(), std::greater());        for (int i = 0; i < a[p].size() && i < 100 / (100 - p); i++) {            int w = a[p][i];            for (int j = C - 1; j >= w; j--) {                dp[j] = std::max(dp[j], dp[j - w] * (p / 100.0));            }        }    }        double ans = 0;    for (int i = 0; i < C; i++) {        ans = std::max(ans, (i + sum) * dp[i]);    }    std::cout << ans << \"\\n\";     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "math",
        "probabilities"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Many Games.json",
    "hint": []
}