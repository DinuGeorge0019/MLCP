{
    "link": "https://codeforces.com//contest/1718/problem/B",
    "problemId": "1509965",
    "problem_idx": "B",
    "shortId": "1718B",
    "contest_number": "1718",
    "problem_submissions": {
        "F": [
            168597010,
            168624668,
            173812548,
            173812098,
            168599096
        ],
        "D": [
            168565469,
            168586026,
            168571061,
            168581216,
            168578771,
            168572736,
            168587794,
            168591318,
            168592506,
            168597359,
            168590948,
            168600506,
            168597231,
            168582453,
            168687986
        ],
        "C": [
            168541281,
            168543939,
            168544627,
            168545043,
            168549826,
            168553177,
            168540235,
            168546151,
            168543268,
            168562740,
            168541559,
            168562194,
            168567397,
            168609760,
            168609209,
            168608717,
            168567701,
            168606687,
            168620286,
            168547337,
            168546667,
            168553348,
            168556898,
            168552397
        ],
        "B": [
            168533942,
            168529866,
            168534830,
            168535200,
            168537223,
            168547085,
            168528202,
            168537852,
            168530917,
            168805783,
            168550097,
            168530349,
            168548672,
            168547336,
            168549427,
            168545357,
            168535673,
            168532763,
            168537259,
            168542957,
            168536570
        ],
        "A2": [
            168516853,
            168520403,
            168525192,
            168517279,
            168521825,
            168526171,
            168517695,
            168521659,
            168518863,
            168529215,
            168520755,
            168523804,
            168536216,
            168521669,
            168523926,
            168522044,
            168518219,
            168525244,
            168524582,
            168517935
        ],
        "A1": [
            168516745,
            168520669,
            168524305,
            168517111,
            168521468,
            168525366,
            168517892,
            168521859,
            168518553,
            168529389,
            168520943,
            168523566,
            168536034,
            168521371,
            168523798,
            168521699,
            168516764,
            168524985,
            168524317,
            168517770
        ],
        "E": [
            168650929,
            168598643,
            168610266,
            173790812
        ]
    },
    "name": "B. Fibonacci Strings",
    "statement": "In all schools in Buryatia, in the 1 class, everyone is told the theory\r\nof Fibonacci strings.\"A is a subsegment of a string where all the\r\nletters are the same and are bounded on the left and right by the ends\r\nof the string or by letters other than the letters in the block. A\r\nstring is called a string if, when it is divided into blocks, their\r\nlengths in the order they appear in the string form the Fibonacci\r\nsequence (f_0 = f_1 = 1, f_i = f_{i-2} + f_{i-1}), starting from the\r\nzeroth member of this sequence. A string is called if it possible to\r\nreorder its letters to get a string.\"Burenka decided to enter the Buryat\r\nState University, but at the entrance exam she was given a difficult\r\ntask. She was given a string consisting of the letters of the Buryat\r\nalphabet (which contains exactly k letters), and was asked if the given\r\nstring is . The string can be very long, so instead of the string, she\r\nwas given the number of appearances of each letter (c_i for the i-th\r\nletter) in that string. Unfortunately, Burenka no longer remembers the\r\ntheory of Fibonacci strings, so without your help she will not pass the\r\nexam.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.08.2022 17:39:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<long long> f = {1, 1};\n  while (f.back() < (int) 1e9) {\n    auto nxt = f.back() + f[f.size() - 2];\n    f.push_back(nxt);\n  }\n  int sz = (int) f.size();\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      sum += a[i];\n    }\n    long long pref = 0;\n    int len = -1;\n    for (int i = 0; i < sz; i++) {\n      pref += f[i];\n      if (pref == sum) {\n        len = i + 1;\n        break;\n      }\n    }\n    if (len == -1) {\n      cout << \"NO\" << '\\n';\n      continue;\n    }\n    int last = -1;\n    bool ok = true;\n    for (int i = len - 1; i >= 0; i--) {\n      long long mx = *max_element(a.begin(), a.end());\n      if (mx < f[i]) {\n        ok = false;\n        break;\n      }\n      int nxt = -1;\n      for (int j = 0; j < n; j++) {\n        if (a[j] == mx && j != last) {\n          nxt = j;\n          break;\n        }\n      }\n      if (nxt == -1) {\n        ok = false;\n        break;\n      }\n      a[nxt] -= f[i];\n      last = nxt;\n    }\n    cout << (ok ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Fibonacci Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/106049",
    "editorial": "At the beginning, let's check that the number n\n (the sum of all ci\n) is representable as the sum of some prefix of Fibonacci numbers, otherwise we will output the answer NO.\n\nLet's try to type the answer greedily, going from large Fibonacci numbers to smaller ones. For the next Fibonacci number, let's take the letter with the largest number of occurrences in the string from among those that are not equal to the previous letter taken (to avoid the appearance of two adjacent blocks from the same letter, which cannot be). If there are fewer occurrences of this letter than this number, then the answer is NO. Otherwise, we will put the letter on this Fibonacci number and subtract it from the number of occurrences of this letter.If we were able to dial all the Fibonacci numbers, then the answer is YES.\n\nWhy does the greedy solution work? Suppose at this step you need to take Fi\n (I will say take a number from ct\n, this will mean taking Fi\n letters t\n from string), let's look at the maximum cx\n now, if it cannot be represented as the sum of Fibonacci numbers up to Fi\n among which there are no neighbors, then the answer is no. It can be proved that if cx>Fi+1\n, then it is impossible to represent cx\n.\n\nIf there is exactly one number greater than or equal to Fi\n at the step, then there is only one option to take a number, so the greedy solution works.\n\nIf there are two such numbers and they are equal, then the option to take a number is exactly one, up to the permutation of letters. the greedy solution works again.\n\nIf there are cj?Fi,cx?Fi,j?x\n, then we note that the larger of the numbers cj,cx\n will be greater than Fi\n, if we don't take it, then at the next step this number will be greater than Fi+1\n (i\n will be 1 less), according to the above proven answer will not be, so, taking the larger of the numbers is always optimal.\n\nThe complexity of the solution is O(klog(n)log(k))\n.",
    "hint": []
}