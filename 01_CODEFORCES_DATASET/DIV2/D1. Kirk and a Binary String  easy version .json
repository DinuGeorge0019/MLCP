{"link": "https://codeforces.com//contest/1204/problem/D1", "problemId": "392654", "problem_idx": "D1", "shortId": "1204D1", "contest_number": "1204", "problem_submissions": {"D2": [59171473, 59176959, 59165503, 59172424, 59176173, 59167492, 59164905, 59176155, 59178992, 59169931, 59176960, 59169864, 59178242, 59178029, 59169582, 59172809, 59169123, 59168999, 59171305, 59170057], "D1": [59169891, 59176544, 59165271, 59172261, 59176126, 59167259, 59164656, 59176100, 59163490, 59168508, 59176724, 59170026, 59178274, 59177894, 59169407, 59172673, 59169296, 59168747, 59167871, 59169828], "E": [59165621, 59159508, 59171204, 59167827, 59161848, 59176920, 59177089, 59166777, 59176127, 59177175, 59172161, 59177722, 59170117, 59171712, 59177233, 59179201, 59180220, 59178891, 59180477, 59178723], "C": [59151501, 59163669, 59158012, 59149471, 59166332, 59152299, 59160440, 59156718, 59160290, 59156826, 59162942, 59160646, 59158205, 59161710, 59162530, 59157292, 59158762, 59160352, 59157314, 59162180], "B": [59144349, 59150576, 59146764, 59144554, 59146379, 59145028, 59149730, 59146608, 59146122, 59145946, 59147391, 59146291, 59146819, 59146767, 59151379, 59145774, 59147183, 59147977, 59149695, 59149226], "A": [59141665, 59142146, 59141563, 59142710, 59143581, 59145777, 59144224, 59142379, 59143868, 59142387, 59143522, 59143089, 59147328, 59153631, 59142559, 59141790, 59142894, 59147085, 59146105]}, "name": "D1. Kirk and a Binary String  easy version ", "statement": "Kirk has a binary string s (a string which consists of zeroes and ones)\r\nof length n and he is asking you to find a binary string t of the same\r\nlength which satisfies the following conditions: For any l and r (1\r\nleq l\r\nleq r\r\nleq n) the length of the longest non-decreasing subsequence of the\r\nsubstring s_{l}s_{l+1}\r\nldots s_{r} is equal to the length of the longest non-decreasing\r\nsubsequence of the substring t_{l}t_{l+1}\r\nldots t_{r}; The number of zeroes in t is the maximum possible.A\r\nnon-decreasing subsequence of a string p is a sequence of indices i_1,\r\ni_2,\r\nldots, i_k such that i_1 < i_2 <\r\nldots < i_k and p_{i_1}\r\nleq p_{i_2}\r\nleq\r\nldots\r\nleq p_{i_k}. The length of the subsequence is k.If there are multiple\r\nsubstrings which satisfy the conditions, output any.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nbool arr[2005];\nbool change[2005];\nint val[2005];\nint val2[2005];\nint ones1, ones2;\n\nvoid input();\n\nint main(){\n    input();\n\n    for(int i=n; i>=1; i--){\n        int max1 = 1, max2 = 1;\n        if(!arr[i]){\n            for(int j=i+1; j<=n; j++) max1 = max(max1, val[j]+1);\n        }\n        else max1 = ones1+1;\n        for(int j=i+1; j<=n; j++) max2 = max(max2, val[j]+1);\n\n        if(arr[i] && max1 == max2) change[i] = 1;\n\n        val[i] = ones1+1, val2[i] = ones2+1;\n\n        if(arr[i]){\n            ones1++;\n            if(!change[i]) ones2++;\n        }\n        else{\n            for(int j=i+1; j<=n; j++) val[j]++;\n        }\n\n        if(!arr[i] || change[i]){\n            for(int j=i+1; j<=n; j++) val2[j]++;\n        }\n        else{\n            ones2++;\n        }\n    }\n\n    for(int i=1; i<=n; i++){\n        printf(\"%d\", arr[i] && !change[i]);\n    }\n}\n\nvoid input(){\n    string s;\n    cin >> s;\n    n = (int)s.size();\n    for(int i=1; i<=n; i++) arr[i] = (s[i-1] == '1');\n}\n"], "input": "", "output": "", "tags": ["brute force", "greedy", "strings"], "dificulty": "2000", "interactive": false}