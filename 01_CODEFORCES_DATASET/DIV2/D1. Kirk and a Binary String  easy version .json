{
    "link": "https://codeforces.com//contest/1204/problem/D1",
    "problemId": "392654",
    "problem_idx": "D1",
    "shortId": "1204D1",
    "contest_number": "1204",
    "problem_submissions": {
        "D2": [
            59171473,
            59176959,
            59165503,
            59172424,
            59176173,
            59167492,
            59164905,
            59176155,
            59178992,
            59169931,
            59176960,
            59169864,
            59178242,
            59178029,
            59169582,
            59172809,
            59169123,
            59168999,
            59171305,
            59170057
        ],
        "D1": [
            59169891,
            59176544,
            59165271,
            59172261,
            59176126,
            59167259,
            59164656,
            59176100,
            59163490,
            59168508,
            59176724,
            59170026,
            59178274,
            59177894,
            59169407,
            59172673,
            59169296,
            59168747,
            59167871,
            59169828
        ],
        "E": [
            59165621,
            59159508,
            59171204,
            59167827,
            59161848,
            59176920,
            59177089,
            59166777,
            59176127,
            59177175,
            59172161,
            59177722,
            59170117,
            59171712,
            59177233,
            59179201,
            59180220,
            59178891,
            59180477,
            59178723
        ],
        "C": [
            59151501,
            59163669,
            59158012,
            59149471,
            59166332,
            59152299,
            59160440,
            59156718,
            59160290,
            59156826,
            59162942,
            59160646,
            59158205,
            59161710,
            59162530,
            59157292,
            59158762,
            59160352,
            59157314,
            59162180
        ],
        "B": [
            59144349,
            59150576,
            59146764,
            59144554,
            59146379,
            59145028,
            59149730,
            59146608,
            59146122,
            59145946,
            59147391,
            59146291,
            59146819,
            59146767,
            59151379,
            59145774,
            59147183,
            59147977,
            59149695,
            59149226
        ],
        "A": [
            59141665,
            59142146,
            59141563,
            59142710,
            59143581,
            59145777,
            59144224,
            59142379,
            59143868,
            59142387,
            59143522,
            59143089,
            59147328,
            59153631,
            59142559,
            59141790,
            59142894,
            59147085,
            59146105
        ]
    },
    "name": "D1. Kirk and a Binary String  easy version ",
    "statement": "Kirk has a binary string s (a string which consists of zeroes and ones)\r\nof length n and he is asking you to find a binary string t of the same\r\nlength which satisfies the following conditions: For any l and r (1\r\nleq l\r\nleq r\r\nleq n) the length of the longest non-decreasing subsequence of the\r\nsubstring s_{l}s_{l+1}\r\nldots s_{r} is equal to the length of the longest non-decreasing\r\nsubsequence of the substring t_{l}t_{l+1}\r\nldots t_{r}; The number of zeroes in t is the maximum possible.A\r\nnon-decreasing subsequence of a string p is a sequence of indices i_1,\r\ni_2,\r\nldots, i_k such that i_1 < i_2 <\r\nldots < i_k and p_{i_1}\r\nleq p_{i_2}\r\nleq\r\nldots\r\nleq p_{i_k}. The length of the subsequence is k.If there are multiple\r\nsubstrings which satisfy the conditions, output any.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nbool arr[2005];\nbool change[2005];\nint val[2005];\nint val2[2005];\nint ones1, ones2;\n\nvoid input();\n\nint main(){\n    input();\n\n    for(int i=n; i>=1; i--){\n        int max1 = 1, max2 = 1;\n        if(!arr[i]){\n            for(int j=i+1; j<=n; j++) max1 = max(max1, val[j]+1);\n        }\n        else max1 = ones1+1;\n        for(int j=i+1; j<=n; j++) max2 = max(max2, val[j]+1);\n\n        if(arr[i] && max1 == max2) change[i] = 1;\n\n        val[i] = ones1+1, val2[i] = ones2+1;\n\n        if(arr[i]){\n            ones1++;\n            if(!change[i]) ones2++;\n        }\n        else{\n            for(int j=i+1; j<=n; j++) val[j]++;\n        }\n\n        if(!arr[i] || change[i]){\n            for(int j=i+1; j<=n; j++) val2[j]++;\n        }\n        else{\n            ones2++;\n        }\n    }\n\n    for(int i=1; i<=n; i++){\n        printf(\"%d\", arr[i] && !change[i]);\n    }\n}\n\nvoid input(){\n    string s;\n    cin >> s;\n    n = (int)s.size();\n    for(int i=1; i<=n; i++) arr[i] = (s[i-1] == '1');\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Kirk and a Binary String  easy version .json",
    "editorial_link": "https://codeforces.com/blog/entry/69244",
    "editorial": "Solution 1: Let's call a string p\n fixed if there isn't another string t\n of the same length which satisfies the first condition of the statement (it was about the same lengths of the longest nondecreasing subsequences on substrings). The following statements are obivous:\n\nstring 10\n is fixed;\nif strings p\n and q\n are fixed, then their concatenation pq\n is fixed;\nif a string p\n is fixed, then the string 1p0\n is fixed;\neach fixed string contains the same number of ones and zeroes;\nthe length of the longest nondecreasing subsequence for any fixed string is equal to the half of its length, which can be obtained by taking all zeroes or all ones;\nSo if we erase all fixed strings from the given string, the remaining parts consists of zeroes at prefix and ones at suffix; it is obvious that we can change all these ones to zeroes and the string still satisfies the condition.\n\nSolution 2: If we change any 1\n to 0\n and the longest nondecreasing sequence of the whole string remains the same, then we are able to change it to 0\n. To count the longest nondecreasing sequence of a new string, store and maintain following arrays: dppi\n  the longest nondecreasing sequence of the substring s1i\n; zeroi\n  number of zeroes in the substring s1i\n; dpsi\n  the longest nondecreasing sequence of the substring sin\n and onesi\n  number of ones in the substring sin\n; now, if we change 1\n to 0\n at a position i\n, then the length of the longest nondecreasing sequence of a new string is max(dppi?1+onesi+1,zeroi?1+1+dpsi+1)\n.",
    "hint": []
}