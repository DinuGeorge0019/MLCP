{
    "link": "https://codeforces.com//contest/432/problem/E",
    "problemId": "9482",
    "problem_idx": "E",
    "shortId": "432E",
    "contest_number": "432",
    "problem_submissions": {
        "E": [
            6629542,
            6629685,
            6787172,
            6630011,
            12011414
        ],
        "D": [
            6626923,
            6625069,
            6624242,
            6625615,
            6626784,
            6627500,
            6627213,
            6627749,
            6627433,
            6627095,
            6625919,
            6626790,
            6628329,
            6627888,
            6627861,
            6629346,
            6627908,
            6626789,
            6628335
        ],
        "C": [
            6625922,
            6627708,
            6628444,
            6625084,
            6625495,
            6625430,
            6626041,
            6625379,
            6626502,
            6627502,
            6628640,
            6628030,
            6625935,
            6625367,
            6626856,
            6633716,
            6626069,
            6624111,
            6627225,
            6629433,
            6627012
        ],
        "B": [
            6622630,
            6623369,
            6622464,
            6622520,
            6623124,
            6622829,
            6622983,
            6623645,
            6623780,
            6622660,
            6624201,
            6623167,
            6623125,
            6623134,
            6623267,
            6625795,
            6625412,
            6624139,
            6623117,
            6624747
        ],
        "A": [
            6621909,
            6622385,
            6621900,
            6621957,
            6622065,
            6621901,
            6621989,
            6622108,
            6622047,
            6623481,
            6622838,
            6622310,
            6621964,
            6622183,
            6624704,
            6623532,
            6624976,
            6622988,
            6621991,
            6621961
        ]
    },
    "name": "E. Square Tiling",
    "statement": "You have an rectangle table, its cells are not initially painted. Your\r\ntask is to paint all cells of the table. The resulting picture should be\r\na tiling of the table with squares. More formally: each cell must be\r\npainted some color (the colors are marked by uppercase Latin letters);\r\nwe will assume that two cells of the table are connected if they are of\r\nthe same color and share a side; each connected region of the table must\r\nform a square. Given and , find lexicographically minimum coloring of\r\nthe table that meets the described properties.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint a, b, c;\nchar m[200][200];\nint color[256];\n\nvoid fill(int x, int y, int s){\n  for(int i = 0; i  < 256; ++i) color[i] = 0;\n  for(int i = x; i < x + s; ++i)\n    color[m[i][y - 1]]++, color[m[i][y + s]]++;\n  for(int i = y; i < y + s; ++i)\n    color[m[x - 1][i]]++, color[m[x + s][i]]++;\n  int n = 0;\n  for(int i = 'A'; i <= 'Z'; ++i)\n    if(n == 0 && color[i] == 0) n = i;\n  for(int i = x; i < x + s; ++i)\n    for(int q = y; q < y + s; ++q)\n      m[i][q] = n;\n}\n\nint tryf(int x, int y, int s){\n  for(int i = 0; i  < 256; ++i) color[i] = 0;\n  for(int i = x; i < x + s; ++i){\n    color[m[i][y - 1]]++, color[m[i][y + s]]++;\n    if(m[i][y] != ' ') return -1;\n  }\n  for(int i = y; i < y + s; ++i){\n    color[m[x - 1][i]]++, color[m[x + s][i]]++;\n    if(m[x][i] != ' ') return -1;\n  }\n  int n = 0;\n  for(int i = 'A'; i <= 'Z'; ++i)\n    if(n == 0 && color[i] == 0) n = i;\n  return n;\n}\n\nint main(){\n    cin >> a >> b;\n    for(int i = 0; i < 200; ++i)\n      for(int q = 0; q < 200; ++q)\n\tm[i][q] = ' ';\n    for(int i = 1; i <= a; ++i)\n      for(int q = 1; q <= b; ++q)\n\tif(m[i][q] == ' '){\n\t  int tmp = tryf(i, q, 1);\n\t  int l = 2;\n\t  while(i + l <= a + 1 && q + l <= b + 1 && tryf(i, q, l) == tmp && tryf(i, q + l - 1, 1) >= tmp) ++l;\n\t  fill(i, q, l - 1);\n\t}\n    for(int i = 1; i <= a; ++i){\n\tfor(int q = 1; q <= b; ++q)\n\t  cout << m[i][q];\n\tcout << \"\\n\";\n    }\n  \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Square Tiling.json",
    "editorial_link": "https://codeforces.com//blog/entry/12310",
    "editorial": "This is popular test 6 :) The problem could be solved in a standard way\r\ntry to fill the table from the first cell to the last and try to put the\r\nmiminum letter. Consider the first row. Obviously it begins from some\r\nletters A (to be exact letters A). When we put some letters A in the\r\nfirst row, we should put several letters A in some next rows to make a\r\nsquare. The next letter could be only B. Describe the solution in\r\ngeneral. Assume that we have already considered some rows. Consider row\r\n. Some cells in this row could be already painted. Consider unpainted\r\ncells from left to the right. For every such cell consider its color\r\nfrom A to Z. Two cases should be considered: Put in this cell the\r\nminimum possible letter (neighbours have no such letter) If the previous\r\ncell in this row was not painted at the beginning of considering row ,\r\nnow it is already painted. We should try to merge the current cell with\r\nthe square of the previous cell. Choose the best case from these cases.\r\nTry to get the answer on test to understand the algorithm better.\r\n"
}