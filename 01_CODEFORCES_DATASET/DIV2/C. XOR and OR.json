{
    "link": "https://codeforces.com//contest/282/problem/C",
    "problemId": "2737",
    "problem_idx": "C",
    "shortId": "282C",
    "contest_number": "282",
    "problem_submissions": {
        "C": [
            3308394,
            3301282,
            3301694,
            3302705,
            3302330,
            3303854,
            3303503,
            3306330,
            3302565,
            3304172,
            3301827,
            3306234,
            3301968,
            3303126,
            3305787,
            3304106,
            3308992,
            3303892
        ],
        "D": [
            3307917,
            3308314,
            3313040,
            3309690,
            3307151,
            3308890,
            3310469,
            3310597,
            3306177,
            3313465
        ],
        "E": [
            3306165,
            3309048,
            3304983,
            3304322,
            3304461,
            3306265,
            3306082,
            3304910,
            3308043,
            3302292,
            3312468,
            3305728,
            3309782,
            3317587,
            3317543,
            3317532,
            3317526,
            3317498,
            3310431
        ],
        "B": [
            3304464,
            3302327,
            3303236,
            3304724,
            3301374,
            3302658,
            3301911,
            3307835,
            3301590,
            3300782,
            3305075,
            3301928,
            3306464,
            3306058,
            3305193,
            3305485,
            3307741,
            3307907
        ],
        "A": [
            3299445,
            3300629,
            3299774,
            3299328,
            3299424,
            3300897,
            3299676,
            3309023,
            3299658,
            3299312,
            3299355,
            3299414,
            3299685,
            3300098,
            3300893,
            3301113,
            3299923,
            3300635
        ]
    },
    "name": "C. XOR and OR",
    "statement": "The Bitlandians are quite weird people. They do everything differently.\r\nThey have a different alphabet so they have a different definition for a\r\nstring.A Bitlandish string is a string made only of characters \"\" and\r\n\"\".BitHaval (the mayor of Bitland) loves to play with Bitlandish\r\nstrings. He takes some Bitlandish string , and applies several (possibly\r\nzero) operations to it. In one operation the mayor may take any two\r\nadjacent characters of a string, define one of them as and the other one\r\nas . Then he calculates two values and : , . Then he replaces one of the\r\ntwo taken characters by and the other one by .The operation means the\r\nbitwise excluding OR operation. The operation is the bitwise OR\r\noperation.So for example one operation can transform string to string or\r\nto string . String cannot be transformed into any other string.Youâ€™ve\r\ngot two Bitlandish strings and . Your task is to check if it is possible\r\nfor BitHaval to transform string to string in several (possibly zero)\r\ndescribed operations.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <string>\nusing namespace std;\n#define LL long long\n#define maxn 200100\n#define maxe 210000\n\nchar s1[1010000];\nchar s2[1010000];\nint main()\n{\n\tscanf(\"%s\",s1);\n\tscanf(\"%s\",s2);\n\tint len1,len2,i,j;\n\tlen1=strlen(s1);\n\tlen2=strlen(s2);\n\tint ans;\n\tif(len1-len2)\n\t\tans=0;\n\telse if(len1==1)\n\t{\n\t\tif(s1[0]==s2[0])\n\t\t\tans=1;\n\t\telse\n\t\t\tans=0;\n\t}\n\telse\n\t{\n\t\tif(strcmp(s1,s2)==0)\n\t\t\tans=1;\n\t\telse\n\t\t{\n\t\t\tint j1,j2;\n\t\t\tj1=j2=0;\n\t\t\tfor(i=0;s1[i];i++)if(s1[i]=='1')\n\t\t\t\tj1=1;\n\t\t\tfor(i=0;s2[i];i++)if(s2[i]=='1')\n\t\t\t\tj2++;\n\t\t\tif(j1&&j2)\n\t\t\t\tans=1;\n\t\t\telse\n\t\t\t\tans=0;\n\t\t}\n\t}\n\tif(ans)puts(\"YES\");\n\telse\n\t\tputs(\"NO\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. XOR and OR.json",
    "editorial_link": "https://codeforces.com//blog/entry/6999",
    "editorial": "First of all, check the length of the two strings to be equal. Then with a little try and guess, you can find out that the zero string (00...0) can't be converted to anything else and nothing else can be converted to zero. All other conversions are possible.",
    "hint": []
}