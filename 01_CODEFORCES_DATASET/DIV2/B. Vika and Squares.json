{
    "link": "https://codeforces.com//contest/610/problem/B",
    "problemId": "44283",
    "problem_idx": "B",
    "shortId": "610B",
    "contest_number": "610",
    "problem_submissions": {
        "E": [
            15053499,
            15051695,
            15055517,
            15468537,
            15054746,
            15092595
        ],
        "B": [
            15050877,
            15053921,
            27182434,
            15047165,
            15045211,
            15044820,
            15045928,
            15046116,
            15045542,
            15045130,
            15046665,
            15047371,
            15044370,
            15046773,
            15045049,
            15044516,
            15052695,
            15046983,
            15047646,
            15044510,
            15045948
        ],
        "D": [
            15049809,
            15046533,
            15053385,
            15053873,
            15049276,
            15049759,
            15052914,
            15052461,
            15053191,
            15053905,
            15053030,
            15054321,
            15054255,
            15054811,
            15051818,
            15053392,
            15053677,
            15054046,
            15054704
        ],
        "A": [
            15049788,
            15052508,
            15043466,
            15042823,
            15042879,
            15042700,
            15043682,
            15043766,
            15042783,
            15042798,
            15043007,
            15042601,
            15043336,
            15042897,
            15042861,
            15043393,
            15043051,
            15042935,
            15042657,
            15043356
        ],
        "C": [
            15043384,
            15054209,
            15050445,
            15052911,
            15053221,
            15051863,
            15048319,
            15049540,
            15049193,
            15049080,
            15050593,
            15048004,
            15048429,
            15051082,
            15049084,
            15050509,
            15050531,
            15050981,
            15051132,
            15048269
        ]
    },
    "name": "B. Vika and Squares",
    "statement": "Vika has jars with paints of distinct colors. All the jars are numbered\r\nfrom to and the -th jar contains liters of paint of color .Vika also has\r\nan infinitely long rectangular piece of paper of width , consisting of\r\nsquares of size . Squares are numbered , , and so on. Vika decided that\r\nshe will start painting squares one by one from left to right, starting\r\nfrom the square number and some arbitrary color. If the square was\r\npainted in color , then the next square will be painted in color . In\r\ncase of , next square is painted in color . If there is no more paint of\r\nthe color Vika wants to use now, then she stops.Square is always painted\r\nin only one color, and it takes exactly liter of paint. Your task is to\r\ncalculate the maximum number of squares that might be painted, if Vika\r\nchooses right color to paint the first square.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cassert>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#define cl(a) memset(a,0,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862;\nvoid gn(int &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nvoid gn(ll &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nint mo=1000000007;\nint inf=1061109567;\ndb eps=1e-6;\n//ll inf=1000000000000000000ll;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n#define x1 x192837465\n#define x2 x123456789\n#define y1 y192837465\n#define y2 y123456789\n\n\nint n;\nint a[422222];\nint main()\n{\n    gn(n);\n    int mi=inf;\n    for (int i=1;i<=n;i++){\n        gn(a[i]);\n        mi=min(mi,a[i]);\n    }\n    for (int i=n+1;i<=2*n;i++)a[i]=a[i-n];\n    int ma=0;\n    for (int i=1;i<=2*n;i++)if(a[i]>=mi+1 && a[i-1]<mi+1){\n        int j=i;\n        for (;j<=2*n && a[j]>=mi+1;j++);\n        ma=max(ma,j-i);\n    }\n    cout<<1ll*mi*n+ma<<endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Vika and Squares.json",
    "editorial_link": "https://codeforces.com//blog/entry/22341",
    "editorial": "At first let's find the minimum in the given array and store it in the variable minimum. It is easy to understand, that we always can paint n?*?minimum squares. So we need to find such a minimum in the array before which staying the most number of elements, which more than the minimum. In the other words we need to find 2 minimums in the array which are farthest from each other (do not forget about cyclical of the array). If there is only one minumum we need to start paint from the color which stay in the array exactly after the minimum (do not forget about cyclical of the array too). It can be done with help of iterations from the left to the right. We need to store the position of the nearest minimum in the variable and update her and the answer when we meet the element which equals to minimum.\n"
}