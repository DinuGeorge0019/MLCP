{"link": "https://codeforces.com//contest/989/problem/D", "problemId": "189261", "problem_idx": "D", "shortId": "989D", "contest_number": "989", "problem_submissions": {"D": [39163269, 39163112, 39165857, 39164842, 39165262, 39167503, 39166865, 39167541, 39164863, 39166255, 39166513, 40225602, 39224097], "B": [39154764, 39151093, 39155556, 39151132, 39151653, 39153849, 39153122, 39159658, 39153374, 39150884, 39150337, 39152210, 39152914, 39153499, 39150661], "C": [39153682, 39156523, 39156042, 39159828, 39156893, 39155516, 39158583, 39155306, 39156082, 39158096, 39162808, 39159449, 39155362, 39156561, 39157709, 39159630], "A": [39148137, 39147995, 39148129, 39148199, 39148053, 39152704, 39150073, 39152107, 39149919, 39149579, 39158576, 39147965, 39148111, 39149222, 39149475, 39148105], "E": [39193583, 39193088]}, "name": "D. A Shade of Moonlight", "statement": "The sky can be seen as a one-dimensional axis. The moon is at the origin\r\nwhose coordinate is 0.There are n clouds floating in the sky. Each cloud\r\nhas the same length l. The i-th initially covers the range of (x_i,\r\nx_i + l) (). Initially, it moves at a velocity of v_i, which equals\r\neither 1 or -1.Furthermore, no pair of clouds intersect initially, that\r\nis, for all 1\r\nleq i\r\nlt j\r\nleq n,\r\nlvert x_i - x_j\r\nrvert\r\ngeq l.With a wind velocity of w, the velocity of the i-th cloud becomes\r\nv_i + w. That is, its coordinate increases by v_i + w during each unit\r\nof time. Note that the wind can be strong and clouds can change their\r\ndirection.You are to help Mino count the number of pairs (i, j) (i < j),\r\nsuch that with a proper choice of wind velocity w not exceeding w_\r\nmathrm{max} in absolute value (possibly negative and/or fractional), the\r\ni-th and j-th clouds both cover the moon at the same future moment. This\r\nw doesn\u2019t need to be the same across different pairs.\r\n", "solutions": ["#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-9;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K;\n\tvector<long double>l;\n\tvector<long double>r;\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tif (b == 1) {\n\t\t\tr.push_back(a);\n\t\t}\n\t\telse l.push_back(a);\n\t}\n\tsort(l.begin(), l.end());\n\tsort(r.begin(), r.end());\n\tint lindex = 0;\n\tlong long int ans = 0;\n\tfor (auto i : r) {\n\t\twhile (1) {\n\t\t\tif (lindex == l.size()) {\n\t\t\t\tcout << ans << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (i > l[lindex]) {\n\t\t\t\tlindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l[lindex] < 0 && l[lindex] + M>0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlong double dis = l[lindex] + M;\n\t\t\tlong double t = (l[lindex] + M - i) / 2;\n\t\t\t//cout << dis / t << endl;\n\t\t\tif (abs(dis / t - 1) + EPS > K) {\n\t\t\t\tlindex++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tans += l.size() - lindex;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "geometry", "math", "sortings", "two pointers"], "dificulty": "2500", "interactive": false}