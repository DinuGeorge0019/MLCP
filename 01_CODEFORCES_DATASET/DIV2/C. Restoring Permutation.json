{
    "link": "https://codeforces.com//contest/1315/problem/C",
    "problemId": "547044",
    "problem_idx": "C",
    "shortId": "1315C",
    "contest_number": "1315",
    "problem_submissions": {
        "E": [
            71717972,
            71722121,
            71723928,
            71729230,
            71974152,
            72008868,
            72008805
        ],
        "B": [
            71712835,
            71705609,
            71705328,
            71705471,
            71703387,
            71704005,
            71704127,
            71704155,
            71704023,
            71705610,
            71706151,
            71706053,
            71706193,
            71704779,
            71704406,
            71705432,
            71705176,
            71707656,
            71704939
        ],
        "A": [
            71711680,
            71703327,
            71702875,
            71702517,
            71702293,
            71702355,
            71702415,
            71702704,
            71703705,
            71703020,
            71702906,
            71703383,
            71703894,
            71702683,
            71702739,
            71702868,
            71702438,
            71703823,
            71702490
        ],
        "D": [
            71705281,
            71711782,
            71710689,
            71709097,
            71706684,
            71712045,
            71709367,
            71709685,
            71709559,
            71709699,
            71712591,
            71718977,
            71710420,
            71711447,
            71712487,
            71711123,
            71711486,
            71711635,
            71712415
        ],
        "C": [
            71703583,
            71708130,
            71708191,
            71706924,
            71704462,
            71705381,
            71706364,
            71706633,
            71705353,
            71706839,
            71709056,
            71708876,
            71707615,
            71706977,
            71706123,
            71708378,
            71708224,
            71705852,
            71707083
        ],
        "F": [
            71735158,
            71754645,
            71744524,
            71744441
        ]
    },
    "name": "C. Restoring Permutation",
    "statement": "You are given a sequence b_1, b_2,\r\nldots, b_n. Find the lexicographically minimal permutation a_1, a_2,\r\nldots, a_{2n} such that b_i =\r\nmin(a_{2i-1}, a_{2i}), or determine that it is impossible.\r\n",
    "solutions": [
        "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define R(i,a,b) for (int i=(a);i<(b);i++)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define N 500055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,vis[N],a[N],b[N];\nsigned main(){\n\tfor (int ci=read();ci;ci--){\n\t\tn=read();\n\t\tF(i,1,n*2) vis[i]=b[i]=0;\n\t\tF(i,1,n) a[i]=read();\n\t\tF(i,1,n) b[i*2-1]=a[i],vis[a[i]]=1;\n\t\tF(i,1,n*2){\n\t\t\tif (b[i]) continue;\n\t\t\tF(j,1,n*2) if (vis[j]==0&&j>b[i-1]){\n\t\t\t\tb[i]=j;vis[j]=1;break;\n\t\t\t}\n\t\t} \n\t\tint pd=0;\n\t\tF(i,1,n*2) if (b[i]==0) pd=1;\n\t\tif (pd) puts(\"-1\");\n\t\telse{\n\t\t\tF(i,1,n*2) wri(b[i]);\n\t\t\tput;\n\t\t}\n\t} \n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Restoring Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/74214",
    "editorial": "This problem has a greedy solution. As you know the , which is equal to\r\n, then one of should be equal to . Which one? Of course, , because we\r\nwant to get the lexicographically minimal answer, and we want to place a\r\nsmaller number before the larger number.So, we know that , , , and so\r\non, so we know all elements of the permutation with odd indices. What\r\nnumber should be placed at ? We know that (as , and ). So, letâs take\r\nthe for minimal possible such that and . If there is no such (if all\r\nnumbers greater than are already used), there is no appropriate\r\npermutation. Otherwise, we should take and resume the process.The\r\nquestion is, why do we can place the minimal not used integer each time?\r\nSuppose there is another optimal answer , and we get or we didnât get\r\nany permutation by our greedy algorithm. As these two sequences are\r\ndifferent, there is the first such that . As we tried to take the\r\nminimal possible , there are two options: . This is impossible as we\r\ntried to take the minimal possible , contradiction; . As is optimal\r\ncorrect answer, we didnât finish our sequence . Letâs see, where is the\r\nnumber in the sequence . It should be on some position , where (as is\r\nthe first difference between the sequences). But we can swap and and get\r\nsmaller, but still correct sequence , so is not optimal. Contradiction.\r\n",
    "hint": []
}