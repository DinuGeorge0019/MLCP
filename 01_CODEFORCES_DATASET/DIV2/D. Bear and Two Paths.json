{
    "link": "https://codeforces.com//contest/673/problem/D",
    "problemId": "59809",
    "problem_idx": "D",
    "shortId": "673D",
    "contest_number": "673",
    "problem_submissions": {
        "E": [
            17790544,
            17790298,
            17792643,
            17795142,
            17797198,
            17796072,
            17796678,
            17794290,
            17802948,
            18498821,
            18454059,
            18453934,
            18453804,
            27208468,
            17814502,
            17814492,
            17810486
        ],
        "A": [
            17785371,
            17780028,
            17783006,
            17781229,
            17780841,
            17781392,
            17781436,
            17783310,
            17780077,
            17780098,
            17783943,
            17780241,
            17780697,
            17780142,
            17780713,
            17780906,
            17780033,
            17782963,
            17780095,
            17780488
        ],
        "D": [
            17784968,
            17784163,
            17787638,
            17787311,
            17788261,
            17790516,
            17791783,
            17788147,
            17787202,
            17788591,
            17787856,
            17787228,
            17787665,
            17788331,
            17788505,
            17790808,
            17791801,
            17789992,
            17788978,
            17790173
        ],
        "B": [
            17783887,
            17780728,
            17785147,
            17782968,
            17783327,
            17784516,
            17785052,
            17786520,
            17783375,
            17784877,
            17782865,
            17784125,
            17784706,
            17782517,
            17784194,
            17786784,
            17781561,
            17784108,
            17784745,
            17783935
        ],
        "C": [
            17780670,
            17782033,
            17785575,
            17788307,
            17784829,
            17786955,
            17787316,
            17789788,
            17784945,
            17782021,
            17781157,
            17785332,
            17782835,
            17785106,
            17786557,
            17783986,
            17790134,
            17785539,
            17783083,
            17786914
        ],
        "F": [
            17799743
        ]
    },
    "name": "D. Bear and Two Paths",
    "statement": "Bearland has cities, numbered through . Cities are connected via\r\nbidirectional roads. Each road connects two distinct cities. No two\r\nroads connect the same pair of cities.Bear Limak was once in a city and\r\nhe wanted to go to a city . There was no direct connection so he decided\r\nto take a long walk, visiting each city . Formally: There is no road\r\nbetween and . There exists a sequence (path) of distinct cities that ,\r\nand there is a road between and for . On the other day, the similar\r\nthing happened. Limak wanted to travel between a city and a city . There\r\nis no road between them but there exists a sequence of distinct cities\r\nthat , and there is a road between and for .Also, Limak thinks that\r\nthere are at most roads in Bearland. He wonders whether he remembers\r\neverything correctly.Given , and four distinct cities , , , , can you\r\nfind possible paths and to satisfy all the given conditions? Find any\r\nsolution or print if it’s impossible.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <vector>\n#include <numeric>\n#include <deque>\n#include <utility>\n#include <bitset>\n#include <limits.h>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long llu;\ntypedef double lf;\ntypedef unsigned int uint;\ntypedef long double llf;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N_ = 100500;\nconst int M_ = 100500;\n\nint N, K, A, B, C, D;\n\nint main() {\n\tscanf(\"%d%d%d%d%d%d\", &N, &K, &A, &B, &C, &D);\n\tif(N == 4 || K <= N) return 0 & puts(\"-1\");\n\n\tprintf(\"%d %d \", A, C);\n\tfor(int i = 1; i <= N; i++) {\n\t\tif(i != A && i != B && i != C && i != D) \n\t\t\tprintf(\"%d \", i);\n\t}\n\tprintf(\"%d %d\\n\", D, B);\n\n\tprintf(\"%d %d \", C, A);\n\tfor(int i = 1; i <= N; i++) {\n\t\tif(i != A && i != B && i != C && i != D) \n\t\t\tprintf(\"%d \", i);\n\t}\n\tprintf(\"%d %d\\n\", B, D);\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Bear and Two Paths.json",
    "editorial_link": "https://codeforces.com//blog/entry/44754",
    "editorial": "There is no solution if or . But for and you can\nconstruct the following graph: Here, cities denote other cities in any\norder you choose (cities different than ). You should print in the first\nline, and in the second line. Two not very hard challenges for you. Are\nyou able to prove that the answer doesnât exist for ? Can you solve the\nproblem if the four given cities donât have to be distinct but itâs\nguaranteed that and ? 18286683 (invented by Radewoosh) When we repeat\nsomething and each time we have probability to succeed then the expected\nnumber or tries is , till we succeed. How to calculate the expected time\nfor one region ? For each in some moment we will try to beat this level\nand then there will be tokens in the bag, including tokens allowing us\nto beat this new level. The probability to succeed is , so the expected\ntime is . So, in total we should sum up values for . Ok, we managed to\nunderstand the actual problem. You can now stop and try to find a slow\nsolution in . Hint: use the dynamic programming. Now letâs write formula\nfor , as the minimum over denoting the end of the previous region: So we\ncan use convex hull trick to calculate it in . You should also get AC\nwith a bit slower divide&conquer trick, if itâs implemented carefully.\n18286696 (invented by Radewoosh) Letâs say that every company has one\nparent (a company it follows). Also, every copmany has some (maybe\nempty) set of children. Itâs crucial that sets of children are disjoint.\nFor each company letâs keep (and always update) one value, equal to the\nsum of: It turns out that after each query only the above sum changes\nonly for a few values. If starts to follows then you should care about .\nAnd maybe and if you want to be sure. You can stop reading now for a\nmoment and analyze that indeed other companies will keep the same sum,\ndescribed above. Ok, but so far we donât count the income coming from\nparentâs fanpage. But, for each company we can store all its children in\none set. All children have the same \"income from parentâs fanpage\"\nbecause they have the same parent. So, in set you can keep children\nsorted by the sum described above. Then, we should always puts the\nextreme elements from sets in one global set. In the global set you care\nabout the total income, equal to the sum described above and this new\n\"income from parent\". Check codes for details. The complexity should be\n, with big constant factor. 18286747 (invented by Errichto) Let denote\nthe probability that subtree (if attacked now) would have height at most\n. The first observation is that we donât care about big because itâs\nvery unlikely that a path with e.g. 100 edges will survive. Letâs later\ntalk about choosing and now letâs say that itâs enough to consider up to\n. When we should answer a query for subtree then we should sum up to get\nthe answer. The other query is harder. Letâs say that a new vertex is\nattached to vertex . Then, among only changes (other values stay the\nsame). Also, one value changes, and so does and so on. You should\niterate over vertices (each time going to parent) and update the\ncorresponding value. TODO puts here come formula for updating value. The\ncomplexity is . You may think that is enough because is small enough.\nUnfortunately, there exist malicious tests. Consider a tree with paths\nfrom root, each with length . Now, we talk about the probability of\nmagnitude: which is more than for .\nhttp://www.wolframalpha.com/input/?i=1+-+(1-(1\n",
    "hint": []
}