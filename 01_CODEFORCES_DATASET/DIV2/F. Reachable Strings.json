{
    "link": "https://codeforces.com//contest/1321/problem/F",
    "problemId": "551765",
    "problem_idx": "F",
    "shortId": "1321F",
    "contest_number": "1321",
    "problem_submissions": {
        "F": [
            72202118,
            72198416
        ],
        "C": [
            72190499,
            72170310,
            72171527,
            72174502,
            72175483,
            72175401,
            72175000,
            72176189,
            72171238,
            72175883,
            72177727,
            72183189,
            72179214,
            72177328,
            72279003,
            72174053,
            72178214,
            72178070,
            72179504,
            72179152,
            72178320
        ],
        "D": [
            72183268,
            72175184,
            72177797,
            72179168,
            72180779,
            72181426,
            72180644,
            72182068,
            72185885,
            72181701,
            72186041,
            72179938,
            72186063,
            72181326,
            72178168,
            72183258,
            72185462,
            72184740,
            72187220,
            72184221
        ],
        "E": [
            72180529,
            72186287,
            72184508,
            72188609,
            72188377,
            72190998,
            72191625,
            72192736,
            72180513,
            72191278,
            72214882,
            72192856,
            72193973,
            72192866,
            72196349,
            72194892,
            72194887,
            72194595,
            72195594,
            72195787
        ],
        "A": [
            72173172,
            72167016,
            72167934,
            72167935,
            72169001,
            72167363,
            72167505,
            72167646,
            72189321,
            72167844,
            72168400,
            72167413,
            72168727,
            72167365,
            72278985,
            72168080,
            72169683,
            72169011,
            72168321,
            72167972,
            72167569
        ],
        "B": [
            72168656,
            72168025,
            72169238,
            72170413,
            72171089,
            72169057,
            72169880,
            72170679,
            72187620,
            72171095,
            72171827,
            72169625,
            72172515,
            72169721,
            72170650,
            72172323,
            72173484,
            72170425,
            72174186,
            72171595
        ]
    },
    "name": "F. Reachable Strings",
    "statement": "In this problem, we will deal with binary strings. Each character of a\r\nbinary string is either a or a . We will also deal with substrings;\r\nrecall that a substring is a contiguous subsequence of a string. We\r\ndenote the substring of string s starting from the l-th character and\r\nending with the r-th character as s[l\r\ndots r]. The characters of each string are numbered from 1.We can\r\nperform several operations on the strings we consider. Each operation is\r\nto choose a substring of our string and replace it with another string.\r\nThere are two possible types of operations: replace with , or replace\r\nwith . For example, if we apply exactly one operation to the string , it\r\ncan be transformed into , , or .Binary string a is considered from\r\nbinary string b if there exists a sequence s_1, s_2, ..., s_k such that\r\ns_1 = a, s_k = b, and for every i\r\nin [1, k - 1], s_i can be transformed into s_{i + 1} using exactly one\r\noperation. Note that k can be equal to 1, i. e., .You are given a string\r\nt and q queries to it. Each query consists of three integers l_1, l_2\r\nand len. To answer each query, you have to determine whether t[l_1\r\ndots l_1 + len - 1] is reachable from t[l_2\r\ndots l_2 + len - 1].\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';n?-x:x;})\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r){return l+rng()%(r-l+1);}\n#define fasty ios_base::sync_with_stdio(0),cin.tie(0);\n#define forinc(a,b,c) for(int a=b,_c=c;a<=_c;++a)\n#define fordec(a,b,c) for(int a=b,_c=c;a>=_c;--a)\n#define forv(a,b) for(auto&a:b)\n#define fi first\n#define se second\n#define pb push_back\n#define ii pair<int,int>\n#define mt make_tuple\n#define aint(a) a.begin(),a.end()\n#define reset(f, x) memset(f, x, sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define on(x,i) (x|(1int<<(i-1)))\n#define off(x,i) (x&~(1<<(i-1)))\n#define gg exit(0);\n\nconst int N=200010,\n          M=1000000007,\n          M2=1000000009;\n\nint n;\nint a[N],mot[N],lf[N],rt[N],h[N],pw[N],V[N];\nint pw2[N],h2[N];\nvector<ii> v;\n\nint sum(int u,int v){\n    return mot[v]-mot[u-1];\n}\nint get1(int u,int v){\n    return u<=v ? (h[v]-h[u-1]*pw[v-u+1]%M+M)%M : 0;\n}\nint get2(int u,int v){\n    return u<=v ? (h2[v]-h2[u-1]*pw2[v-u+1]%M2+M2)%M2 : 0;\n}\nint que1(int u,int v){\n    int x=V[rt[u]], y=V[lf[v]];\n    if(x <= y && x && y){\n        int ret=(sum(u,rt[u])%2 + 1) * pw[y-x]%M;\n        ret=(ret+get1(x+1,y))%M;\n        return ret;\n    }\n    return -1;\n}\nint que2(int u,int v){\n    int x=V[rt[u]], y=V[lf[v]];\n    if(x <= y && x && y){\n        int ret=(sum(u,rt[u])%2 + 1) * pw2[y-x]%M2;\n        ret=(ret+get2(x+1,y))%M2;\n        return ret;\n    }\n    return -1;\n}\n\nmain(){\n    #define task \"TASK\"\n    //freopen(task\".inp\",\"r\",stdin);\n    //freopen(task\".out\",\"w\",stdout);\n\n    n=in;\n    forinc(i,1,n){\n        char ch; while(!isdigit(ch=getchar()));\n        mot[i]=mot[i-1]+(a[i]=ch=='1');\n    }\n    v.pb({0,0});\n    forinc(i,1,n) if(!a[i]){\n        V[i]=v.size();\n        v.pb({i,sum(v.back().fi+1,i)%2});\n    }\n    pw[0]=pw2[0]=1;\n    forinc(i,1,v.size()){\n        pw[i]=pw[i-1]*19937%M;\n        pw2[i]=pw2[i-1]*47%M2;\n        h[i]=(h[i-1]*19937+v[i].se+1)%M;\n        h2[i]=(h2[i-1]*47%M2+(v[i].se+1))%M2;\n    }\n    forinc(i,1,n) lf[i]=a[i] ? lf[i-1] : i;\n    fordec(i,n,1) rt[i]=a[i] ? rt[i+1] : i;\n\n    forinc(q,1,in){\n        int u=in,v=in,len=in,suc=1;\n        if(sum(u,u+len-1)!=sum(v,v+len-1))\n            suc=0;\n        if(que1(u,u+len-1)!=que1(v,v+len-1))\n            suc=0;\n        if(que2(u,u+len-1)!=que2(v,v+len-1))\n            suc=0;\n        cout<<(suc ? \"Yes\\n\" : \"No\\n\") ;\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "hashing",
        "strings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Reachable Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/74431",
    "editorial": "How to determine if two strings can be transformed into each other? Obviously, the number of ones in both strings should be the same. Also the following invariant holds: if all pairs of consecutive ones are deleted, the positions of remaining ones are not affected by any operations.\n\nWe can prove that these conditions are sufficient: if we move all pairs of ones to the end of the string, the strings are the same if the positions of ones are the same and the number of characters is the same (moving all pairs of ones to the end of the string is almost the same as deleting them).\n\nOne of the possible solutions is the following Â— build a segment tree, where each vertex should maintain:\n\nthe number of deleted pairs of ones;\nthe hash of positions of the remaining ones;\nthe characters at the ends of the corresponding segment (we need these to delete pairs of consecutive ones, if they appear as a result of merging the segments).\nWhen merging a pair of vertices, we check if we have to delete a pair of consecutive ones and rebuild the hash for the new vertex.\n\nThere are lots of other approaches, including a deterministic one (which uses suffix structures).",
    "hint": []
}