{
    "link": "https://codeforces.com//contest/1890/problem/A",
    "problemId": "2253926",
    "problem_idx": "A",
    "shortId": "1890A",
    "contest_number": "1890",
    "problem_submissions": {
        "E2": [
            230243672,
            230240480,
            230297470,
            230254767,
            230258587,
            230244180,
            230254845,
            230249864,
            230263075,
            230246186
        ],
        "E1": [
            230239375,
            230240649,
            230254904,
            230258446,
            230244551,
            230252707,
            230254758,
            230249708,
            230262781,
            230215711,
            230246708,
            230241675,
            230236999,
            230227194,
            230225604,
            230238862,
            230234772,
            230232052,
            230239219
        ],
        "C": [
            230215281,
            230206393,
            230208934,
            230208092,
            230206406,
            230204020,
            230204003,
            230208271,
            230220692,
            230199138,
            230200556,
            230196035,
            230205630,
            230204581,
            230205712,
            230207645,
            230206074,
            230200943
        ],
        "D": [
            230200794,
            230211914,
            230214420,
            230213956,
            230250838,
            230215130,
            230243357,
            230434274,
            230253613,
            230238740,
            230207739,
            230228283,
            230207522,
            230211617,
            230214234,
            230212438,
            230213769,
            230217205,
            230221587,
            230210557
        ],
        "B": [
            230187228,
            230188639,
            230191975,
            230193314,
            230189140,
            230192487,
            230190081,
            230430791,
            230190255,
            230203446,
            230188113,
            230219697,
            230186542,
            230187036,
            230191039,
            230188308,
            230187745,
            230188740,
            230190731,
            230189120
        ],
        "A": [
            230183445,
            230183838,
            230195995,
            230187748,
            230183292,
            230186367,
            230183250,
            230430735,
            230183529,
            230188990,
            230184115,
            230213790,
            230183853,
            230183272,
            230185989,
            230183632,
            230183856,
            230183304,
            230184663,
            230511197,
            230183134
        ],
        "F": [
            230416243,
            230223460,
            232061512,
            232061382,
            232061156,
            230258558,
            230434262,
            230438215
        ]
    },
    "name": "A. Doremy s Paint 3",
    "statement": "An array b_1, b_2,\r\nldots, b_n of positive integers is good if all the sums of two adjacent\r\nelements are equal to the same value. More formally, the array is good\r\nif there exists a k such that b_1 + b_2 = b_2 + b_3 =\r\nldots = b_{n-1} + b_n = k.Doremy has an array a of length n. Now Doremy\r\ncan permute its elements (change their order) however she wants.\r\nDetermine if she can make the array good.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define il inline\nusing namespace std;\nconst int maxn=100010;\nil int read(){\n\tint x=0;\n\tchar c=getchar();\n\tfor(;!(c>='0'&&c<='9');c=getchar());\n\tfor(;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\treturn x;\n}\nint T,n;\nint a[maxn];\nbool vis[maxn];\nint tap[maxn];\nint st[maxn],top;\nint main(){\n\tT=read();\n\twhile(T--){\n\t\tn=read(); int cnt=0; top=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\ta[i]=read();\n\t\tfor(int i=1;i<=n;tap[a[i]]++,i++)\n\t\t\tif(!vis[a[i]]) vis[a[i]]=1,st[++top]=a[i];\n\t\tif(top==1) printf(\"Yes\\n\");\n\t\telse if(top==2&&abs(tap[st[1]]-tap[st[2]])<=1) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t\tfor(int i=1;i<=n;i++) vis[a[i]]=tap[a[i]]=0;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Doremy s Paint 3.json",
    "editorial_link": "https://codeforces.com//blog/entry/121813",
    "editorial": "Statement says . Let\u00e2\u0080\u0099s write it as . This is just , which means the\r\npositions with the same parity should contain same value.We know that\r\nthere are odd numbers and even numbers in . Therefore, if and only if we\r\ncan find same numbers, and the remaining are also the same numbers, the\r\nanswer is . All cases can be classified into these categories: All\r\nnumbers are the same, like . The answer is . There are two different\r\nnumbers, like . The answer is if and only if one of the number appears\r\nexactly times. For example and are while and is . There are three or\r\nmore different numbers, like . The answer is . Time complexity .\r\n"
}