{
    "link": "https://codeforces.com//contest/586/problem/D",
    "problemId": "37961",
    "problem_idx": "D",
    "shortId": "586D",
    "contest_number": "586",
    "problem_submissions": {
        "E": [
            13567845,
            13568877,
            13567853,
            13571593,
            13562355,
            13570559,
            13579749,
            13567129,
            13570139
        ],
        "D": [
            13563971,
            13564646,
            13563820,
            13563849,
            13568951,
            13565926,
            13563286,
            13563128,
            13565918,
            13569000,
            13562593,
            13568454,
            13565954,
            13567393,
            13563819,
            13565909,
            13564075,
            13560941,
            13564537
        ],
        "B": [
            13561164,
            13559370,
            13561077,
            13558098,
            13558769,
            13558957,
            13558122,
            13557083,
            13558517,
            13557741,
            13558248,
            13560292,
            13558220,
            13559476,
            13561469,
            13562240,
            13557548,
            13564661,
            13557987
        ],
        "C": [
            13559947,
            13561510,
            13560077,
            13560242,
            13565430,
            13561001,
            13561323,
            13561803,
            13560466,
            13563719,
            13560353,
            13561394,
            13595712,
            13558752,
            13585345,
            13584852
        ],
        "A": [
            13555951,
            13556306,
            13555953,
            13556124,
            13556417,
            13555955,
            13556118,
            13555916,
            13556066,
            13556106,
            13556370,
            13556409,
            13556782,
            13556040,
            13560781,
            13556168,
            13565723,
            13556286
        ],
        "F": [
            13577881,
            13572057,
            13572184,
            13570880,
            13588219,
            13595048,
            13570334,
            13571136,
            13601061
        ]
    },
    "name": "D. Phillip and Trains",
    "statement": "The mobile application store has a new game called \"Subway Roller\".The\r\nprotagonist of the game Philip is located in one end of the tunnel and\r\nwants to get out of the other one. The tunnel is a rectangular field\r\nconsisting of three rows and columns. At the beginning of the game the\r\nhero is in some cell of the leftmost column. Some number of trains rides\r\ntowards the hero. Each train consists of two or more neighbouring cells\r\nin some row of the field.All trains are moving from right to left at a\r\nspeed of two cells per second, and the hero runs from left to right at\r\nthe speed of one cell per second. For simplicity, the game is\r\nimplemented so that the hero and the trains move in turns. First, the\r\nhero moves one cell to the right, then one square up or down, or stays\r\nidle. Then all the trains move twice simultaneously one cell to the\r\nleft. Thus, in one move, Philip definitely makes a move to the right and\r\ncan move up or down. If at any point, Philip is in the same cell with a\r\ntrain, he loses. If the train reaches the left column, it continues to\r\nmove as before, leaving the tunnel.Your task is to answer the question\r\nwhether there is a sequence of movements of Philip, such that he would\r\nbe able to get to the rightmost column.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 201;\n\nint T, n, k;\nbool dp[MAXN][4];\nchar map[4][MAXN];\n\nint main() {\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tscanf(\"%d%d\", &n, &k);\n\t\tfor (int i = 1; i <= 3; i++) scanf(\"%s\", map[i] + 1);\n\t\tfor (int i = n + 1; i <= n + 3; i++) {\n\t\t\tmap[1][i] = map[2][i] = map[3][i] = '.';\n\t\t}\n\t\tfor (int y = 1; y <= n + 3; y++)\n\t\t\tfor (int x = 1; x <= 3; x++)\n\t\t\t\tdp[y][x] = false;\n\t\tfor (int x = 1; x <= 3; x++)\n\t\t\tif (map[x][1] == 's') {\n\t\t\t\tdp[1][x] = true;\n\t\t\t}\n\t\tfor (int y = 1; y <= n; y++)\n\t\t\tfor (int x = 1; x <= 3; x++) {\n\t\t\t\tif (!dp[y][x]) continue;\n\t\t\t\t// Up\n\t\t\t\tif (x > 1 && map[x][y + 1] == '.' && map[x - 1][y + 1] == '.' && \n\t\t\t\t    map[x - 1][y + 2] == '.' && map[x - 1][y + 3] == '.') {\n\t\t\t\t    dp[y + 3][x - 1] = true;\n\t\t\t\t}\n\t\t\t\t// Pause\n\t\t\t\tif (map[x][y + 1] == '.' && map[x][y + 2] == '.' && map[x][y + 3] == '.') {\n\t\t\t\t\tdp[y + 3][x] = true;\n\t\t\t\t}\n\t\t\t\tif (x < 3 && map[x][y + 1] == '.' && map[x + 1][y + 1] == '.' && \n\t\t\t\t    map[x + 1][y + 2] == '.' && map[x + 1][y + 3] == '.') {\n\t\t\t\t    dp[y + 3][x + 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\tbool answer = false;\n\t\tfor (int y = n + 1; y <= n + 3; y++)\n\t\t\tfor (int x = 1; x <= 3; x++)\n\t\t\t\tanswer |= dp[y][x];\n\t\tprintf(\"%s\\n\", answer ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Phillip and Trains.json",
    "editorial_link": "https://codeforces.com//blog/entry/20898",
    "editorial": "One could consider a graph with vertices corresponding to every (x,?y) position. I should notice that train positions for each Phillip position are fully restorable from his y coordinate. Edge between vertices u and v means that we could get from position corresponding to u to position corresponding by v in one turn without moving onto a train cell or moving in a cell which will be occupied by some train before the next turn. All we need next is to find whether any finishing position is reachable from the only starting position (using BFS or DFS, or, as soon as graph is a DAG, dynamic programming).",
    "hint": []
}