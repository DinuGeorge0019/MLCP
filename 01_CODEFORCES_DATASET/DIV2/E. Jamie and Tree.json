{
    "link": "https://codeforces.com//contest/916/problem/E",
    "problemId": "148028",
    "problem_idx": "E",
    "shortId": "916E",
    "contest_number": "916",
    "problem_submissions": {
        "D": [
            34326007,
            34322565,
            34563169,
            34324237,
            34325530,
            34324573,
            34324098,
            34325922,
            34326213
        ],
        "E": [
            34322258,
            34325502,
            34323285,
            34321851,
            34318358,
            34324148,
            34325404,
            34326324
        ],
        "C": [
            34310995,
            34313571,
            34311523,
            34309797,
            34318416,
            34314936,
            34314832,
            34312668,
            34312494,
            34311976,
            34311906,
            34316835,
            34313644,
            34314417,
            34316195,
            34307237,
            34308290,
            34307428,
            34311584,
            34315270
        ],
        "A": [
            34305522,
            34305848,
            34306019,
            34311849,
            34318455,
            34305611,
            34307081,
            34305645,
            34305601,
            34305829,
            34305615,
            34306758,
            34307093,
            34306724,
            34305983,
            34307982,
            34313895,
            34310913,
            34305897,
            34305681
        ],
        "B": [
            34321729,
            34337379,
            34311562,
            34312817,
            34317165,
            34316891,
            34316674
        ]
    },
    "name": "E. Jamie and Tree",
    "statement": "Jamie has given you a tree with vertices, numbered from to . Initially,\r\nthe root of the tree is the vertex with number . Also, each vertex has a\r\nvalue on it.Jamie also gives you three types of queries on the tree:\r\nChange the tree’s root to vertex with number . For each vertex in the\r\nsubtree of smallest size that contains and , add to its value. Find sum\r\nof values of vertices in the subtree of vertex with number .A subtree of\r\nvertex is a set of vertices such that lies on shortest path from this\r\nvertex to root of the tree. Pay attention that subtree of a vertex can\r\nchange after changing the tree’s root.Show your strength in programming\r\nto Jamie by performing the queries accurately!\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <vector>\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long Lint;\nconst int maxn = 1e5 + 20;\n\nint a, q, root, n;\nvector<int> w[maxn];\n\nint ar[maxn];\nLint segment[maxn*3], lazy[maxn*3], sz[maxn*3];\n\nint push( int k ) {\n    if( lazy[k] ) {\n        if( k < n ) {\n            lazy[k+k] += lazy[k];\n            lazy[k+k+1] += lazy[k];\n        }\n        segment[k] += sz[k] * lazy[k];\n        lazy[k]= 0;\n    }\n}\n\nLint find( int k, int b, int s, int x, int y ) {\n    push( k );\n    if( x > s || b > y ) return 0;\n    if( x <= b && s <= y ) return segment[k];\n    return find( k+k, b, (b+s)/2, x, y ) + find( k+k+1, (b+s)/2+1, s, x, y );\n}\n\nvoid up( int k, int b, int s, int x, int y, int m ) {\n    push( k );\n    if( x > s || b > y ) return;\n    if( x <= b && s <= y ) {\n        lazy[k] += m;\n        push( k );\n        return;\n    }\n    up( k+k, b, (b+s)/2, x, y, m );\n    up( k+k+1, (b+s)/2+1, s, x, y, m );\n    segment[k] = segment[k+k] + segment[k+k+1];\n}\n\nint beg[maxn], en[maxn], dad[maxn][20], cnt, der[maxn];\n\nvoid dfs( int n, int back, int s ) {\n    der[n] = s;\n    dad[n][0] = back;\n    beg[n] = ++cnt;\n    for(int i=1;(1<<i)<=s;i++)\n        dad[n][i] = dad[ dad[n][i-1] ][i-1];\n    for(int i=0;i<w[n].size();i++)\n        if( w[n][i] != back ) dfs( w[n][i], n, s + 1 );\n    en[n] = cnt;\n}\n\nint lca( int x, int y ) {\n    if( der[x] < der[y] ) swap( x, y );\n    for(int k=18;k>=0;k--)\n        if( (1<<k) <= der[x] && der[dad[x][k]] > der[y] ) x = dad[x][k];\n    if( der[x] != der[y] ) x = dad[x][0];\n    for(int k=18;k>=0;k--)\n        if( (1<<k) <= der[x] && dad[x][k] != dad[y][k] ) x = dad[x][k], y = dad[y][k];\n    if( x != y ) x = dad[x][0];\n    return x;\n}\n\nint go( int x, int y ) {\n    for(int k=19;k>=0;k--)\n        if( (1<<k) <= der[x] && der[dad[x][k]] > der[y] ) x = dad[x][k];\n    return x;\n}\n\nint main() {\n\n    scanf(\"%d %d\",&a,&q);\n\n    n = 1;\n    while( n < a ) n <<= 1;\n\n    for(int i=1;i<=n;i++) sz[i+n-1] = 1;\n    for(int i=n-1;i>=1;i--) sz[i] = sz[i+i] + sz[i+i+1];\n\n\n    for(int i=1;i<=a;i++) scanf(\"%d\",&ar[i]);\n\n    for(int i=1,j,k;i<a;i++) {\n        scanf(\"%d %d\",&j,&k);\n        w[j].pb( k );\n        w[k].pb( j );\n    }\n\n    dfs( 1, 0, 0 );\n\n    for(int i=1;i<=a;i++) segment[beg[i]+n-1] = ar[ i ];\n    for(int i=n-1;i>=1;i--)\n        segment[i] = segment[i+i] + segment[i+i+1];\n\n    root = 1;\n    while( q-- ) {\n        int tp, x, y, t;\n        scanf(\"%d\",&tp);\n\n        if( tp == 1 ) {\n            scanf(\"%d\",&x);\n            root = x;\n        } else if( tp == 2 ) {\n            scanf(\"%d %d %d\",&x,&y,&t);\n            int l = lca( x, y );\n            if( beg[l] <= beg[root] && beg[root] <= en[l] ) {\n                int h = lca( root, x );\n                int h2 = lca( root, y );\n                if( der[h2] > der[h] ) l = h2;\n                else l = h;\n                if( l == root ) {\n                    up( 1, 1, n, 1, a, t );\n                } else {\n                    l = go( root, l );\n                    up( 1, 1, n, 1, beg[l]-1, t );\n                    up( 1, 1, n, en[l]+1, a, t );\n                }\n            } else {\n                up( 1, 1, n, beg[l], en[l], t );\n            }\n        } else {\n            scanf(\"%d\",&x);\n            if( x == root ) {\n                printf(\"%lld\\n\",find(1,1,n,1,a));\n                continue;\n            }\n            Lint ans = 0;\n            if( beg[x] <= beg[root] && beg[root] <= en[x] ) {\n                int h = go( root, x );\n                ans = find( 1, 1, n, 1, beg[h]-1 ) + find( 1, 1, n, en[h]+1, a );\n            } else {\n                ans = find( 1, 1, n, beg[x], en[x] );\n            }\n            printf(\"%lld\\n\",ans);\n        }\n        //for(int i=1;i<=a;i++) printf(\"%lld \",find(1,1,n,beg[i],beg[i])); printf(\"\\n\");\n\n    }\n\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Jamie and Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/57223",
    "editorial": "Letâs solve the problem\nwithout operation 1 first. That means the subtree of a vertex does not\nchange. For operation 2, the subtree of smallest size that contains and\nmeans the lowest common ancestor () of and , and we update the subtree\nof . For operation 3, we query the sum of the subtree rooted at the\ngiven vertex. To do this, we can flatten a tree into an one dimensional\narray by considering the DFS order of the vertices starting from vertex\n. If a vertex has DFS order and its subtree has size , then the\nupdate/query range is . This can be done by standard data structures,\nsuch as binary indexed tree with range update function, or segment tree\nwith lazy propagation. Things get more complicated when the root of the\ntree changes. One should notice that in order to reduce time complexity,\nwe should not recalculate everything when changes. We just need to keep\na variable storing the current root. Now letâs discuss the two main\nproblems we face (In the following context, subtree of a vertex is\ndefined according to vertex unless otherwise stated): How to find the\nLCA of and using the precomputed LCA table that assumes the root is\nvertex ? Letâs separate the situation into several cases. If both and\nare in the subtree of , then query the LCA directly is fine. If exactly\none of and is in the subtree of , the LCA must be . If none of and is in\nthe subtree of , we can first find the lowest nodes and such that is an\nancestor of both and , and is an ancestor of both and . If and are\ndifferent, we choose the deeper one. If they are the same, then we query\nthe LCA directly. Combining the above cases, one may find the LCA is the\nlowest vertex among . After we have found the origin of update (for\nquery, it is given), how to identify the subtree of a vertex and carry\nout updates/queries on it? Again, separate the situation into several\ncases. If , update/query the whole tree. If is in the subtree of , or\nisnât an ancestor of , update/query the subtree of . Otherwise,\nupdate/query the whole tree, then undo update/exclude the results of the\nsubtree of , such that is a child of and the subtree of contains . The\nabove ideas can be verified by working with small trees on paper.\nlonghuenchanâs implementation: 34352491 We are glad to see some more\nelegant implementations by the contestants. Feel free to discuss the\nproblems below. I am happy to listen to feedback and answer questions\nfrom you guys. :)\n",
    "hint": []
}