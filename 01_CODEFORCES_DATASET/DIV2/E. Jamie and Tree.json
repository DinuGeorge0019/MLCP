{"link": "https://codeforces.com//contest/916/problem/E", "problemId": "148028", "problem_idx": "E", "shortId": "916E", "contest_number": "916", "problem_submissions": {"D": [34326007, 34322565, 34563169, 34324237, 34325530, 34324573, 34324098, 34325922, 34326213], "E": [34322258, 34325502, 34323285, 34321851, 34318358, 34324148, 34325404, 34326324], "C": [34310995, 34313571, 34311523, 34309797, 34318416, 34314936, 34314832, 34312668, 34312494, 34311976, 34311906, 34316835, 34313644, 34314417, 34316195, 34307237, 34308290, 34307428, 34311584, 34315270], "A": [34305522, 34305848, 34306019, 34311849, 34318455, 34305611, 34307081, 34305645, 34305601, 34305829, 34305615, 34306758, 34307093, 34306724, 34305983, 34307982, 34313895, 34310913, 34305897, 34305681], "B": [34321729, 34337379, 34311562, 34312817, 34317165, 34316891, 34316674]}, "name": "E. Jamie and Tree", "statement": "Jamie has given you a tree with vertices, numbered from to . Initially,\r\nthe root of the tree is the vertex with number . Also, each vertex has a\r\nvalue on it.Jamie also gives you three types of queries on the tree:\r\nChange the tree\u2019s root to vertex with number . For each vertex in the\r\nsubtree of smallest size that contains and , add to its value. Find sum\r\nof values of vertices in the subtree of vertex with number .A subtree of\r\nvertex is a set of vertices such that lies on shortest path from this\r\nvertex to root of the tree. Pay attention that subtree of a vertex can\r\nchange after changing the tree\u2019s root.Show your strength in programming\r\nto Jamie by performing the queries accurately!\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <vector>\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long Lint;\nconst int maxn = 1e5 + 20;\n\nint a, q, root, n;\nvector<int> w[maxn];\n\nint ar[maxn];\nLint segment[maxn*3], lazy[maxn*3], sz[maxn*3];\n\nint push( int k ) {\n    if( lazy[k] ) {\n        if( k < n ) {\n            lazy[k+k] += lazy[k];\n            lazy[k+k+1] += lazy[k];\n        }\n        segment[k] += sz[k] * lazy[k];\n        lazy[k]= 0;\n    }\n}\n\nLint find( int k, int b, int s, int x, int y ) {\n    push( k );\n    if( x > s || b > y ) return 0;\n    if( x <= b && s <= y ) return segment[k];\n    return find( k+k, b, (b+s)/2, x, y ) + find( k+k+1, (b+s)/2+1, s, x, y );\n}\n\nvoid up( int k, int b, int s, int x, int y, int m ) {\n    push( k );\n    if( x > s || b > y ) return;\n    if( x <= b && s <= y ) {\n        lazy[k] += m;\n        push( k );\n        return;\n    }\n    up( k+k, b, (b+s)/2, x, y, m );\n    up( k+k+1, (b+s)/2+1, s, x, y, m );\n    segment[k] = segment[k+k] + segment[k+k+1];\n}\n\nint beg[maxn], en[maxn], dad[maxn][20], cnt, der[maxn];\n\nvoid dfs( int n, int back, int s ) {\n    der[n] = s;\n    dad[n][0] = back;\n    beg[n] = ++cnt;\n    for(int i=1;(1<<i)<=s;i++)\n        dad[n][i] = dad[ dad[n][i-1] ][i-1];\n    for(int i=0;i<w[n].size();i++)\n        if( w[n][i] != back ) dfs( w[n][i], n, s + 1 );\n    en[n] = cnt;\n}\n\nint lca( int x, int y ) {\n    if( der[x] < der[y] ) swap( x, y );\n    for(int k=18;k>=0;k--)\n        if( (1<<k) <= der[x] && der[dad[x][k]] > der[y] ) x = dad[x][k];\n    if( der[x] != der[y] ) x = dad[x][0];\n    for(int k=18;k>=0;k--)\n        if( (1<<k) <= der[x] && dad[x][k] != dad[y][k] ) x = dad[x][k], y = dad[y][k];\n    if( x != y ) x = dad[x][0];\n    return x;\n}\n\nint go( int x, int y ) {\n    for(int k=19;k>=0;k--)\n        if( (1<<k) <= der[x] && der[dad[x][k]] > der[y] ) x = dad[x][k];\n    return x;\n}\n\nint main() {\n\n    scanf(\"%d %d\",&a,&q);\n\n    n = 1;\n    while( n < a ) n <<= 1;\n\n    for(int i=1;i<=n;i++) sz[i+n-1] = 1;\n    for(int i=n-1;i>=1;i--) sz[i] = sz[i+i] + sz[i+i+1];\n\n\n    for(int i=1;i<=a;i++) scanf(\"%d\",&ar[i]);\n\n    for(int i=1,j,k;i<a;i++) {\n        scanf(\"%d %d\",&j,&k);\n        w[j].pb( k );\n        w[k].pb( j );\n    }\n\n    dfs( 1, 0, 0 );\n\n    for(int i=1;i<=a;i++) segment[beg[i]+n-1] = ar[ i ];\n    for(int i=n-1;i>=1;i--)\n        segment[i] = segment[i+i] + segment[i+i+1];\n\n    root = 1;\n    while( q-- ) {\n        int tp, x, y, t;\n        scanf(\"%d\",&tp);\n\n        if( tp == 1 ) {\n            scanf(\"%d\",&x);\n            root = x;\n        } else if( tp == 2 ) {\n            scanf(\"%d %d %d\",&x,&y,&t);\n            int l = lca( x, y );\n            if( beg[l] <= beg[root] && beg[root] <= en[l] ) {\n                int h = lca( root, x );\n                int h2 = lca( root, y );\n                if( der[h2] > der[h] ) l = h2;\n                else l = h;\n                if( l == root ) {\n                    up( 1, 1, n, 1, a, t );\n                } else {\n                    l = go( root, l );\n                    up( 1, 1, n, 1, beg[l]-1, t );\n                    up( 1, 1, n, en[l]+1, a, t );\n                }\n            } else {\n                up( 1, 1, n, beg[l], en[l], t );\n            }\n        } else {\n            scanf(\"%d\",&x);\n            if( x == root ) {\n                printf(\"%lld\\n\",find(1,1,n,1,a));\n                continue;\n            }\n            Lint ans = 0;\n            if( beg[x] <= beg[root] && beg[root] <= en[x] ) {\n                int h = go( root, x );\n                ans = find( 1, 1, n, 1, beg[h]-1 ) + find( 1, 1, n, en[h]+1, a );\n            } else {\n                ans = find( 1, 1, n, beg[x], en[x] );\n            }\n            printf(\"%lld\\n\",ans);\n        }\n        //for(int i=1;i<=a;i++) printf(\"%lld \",find(1,1,n,beg[i],beg[i])); printf(\"\\n\");\n\n    }\n\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "trees"], "dificulty": "2400", "interactive": false}