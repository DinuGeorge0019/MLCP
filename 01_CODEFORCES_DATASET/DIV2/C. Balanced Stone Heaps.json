{
    "link": "https://codeforces.com//contest/1623/problem/C",
    "problemId": "1243267",
    "problem_idx": "C",
    "shortId": "1623C",
    "contest_number": "1623",
    "problem_submissions": {
        "E": [
            140927316,
            140928588,
            140930913,
            140931529,
            140930666,
            140933308,
            140932491,
            140927816,
            140937929,
            140940400,
            140934079,
            140940202,
            140928211,
            140936652,
            140911137,
            140938749,
            140941503,
            140941228,
            140938408,
            140940310
        ],
        "D": [
            140917013,
            140919394,
            140925084,
            140922860,
            140922841,
            140918471,
            140924963,
            140923599,
            140924181,
            140925202,
            140925220,
            140928107,
            140933937,
            140922988,
            140926612,
            140931586,
            140929916,
            140930490,
            140925401,
            140923945
        ],
        "A": [
            140906789,
            140901830,
            140902316,
            140901965,
            140901890,
            140902105,
            140901764,
            140909860,
            140901988,
            140902630,
            140901845,
            140901878,
            140902576,
            140902335,
            140902196,
            140902015,
            140902189,
            140902188,
            140903240
        ],
        "C": [
            140904718,
            140907986,
            140909100,
            140911556,
            140909513,
            140908941,
            140916100,
            140929063,
            140914447,
            140912787,
            140914401,
            140913485,
            140929704,
            140924697,
            140932081,
            140917741,
            140907191,
            140910390,
            140913379,
            140914345
        ],
        "B": [
            140902082,
            140904432,
            140906305,
            140905274,
            140903910,
            140903807,
            140906896,
            140906851,
            140906344,
            140908551,
            140906181,
            140906829,
            140906183,
            140905516,
            140935513,
            140912560,
            140903639,
            140905940,
            140907051,
            140906596
        ]
    },
    "name": "C. Balanced Stone Heaps",
    "statement": "There are n heaps of stone. The i-th heap has h_i stones. You want to\r\nchange the number of stones in the heap by performing the following\r\nprocess once: You go through the heaps from the 3-rd heap to the n-th\r\nheap, in this order. Let i be the number of the current heap. You can\r\nchoose a number d (0\r\nle 3\r\ncdot d\r\nle h_i), move d stones from the i-th heap to the (i - 1)-th heap, and 2\r\ncdot d stones from the i-th heap to the (i - 2)-th heap. So after that\r\nh_i is decreased by 3\r\ncdot d, h_{i - 1} is increased by d, and h_{i - 2} is increased by 2\r\ncdot d. You can choose different or same d for different operations.\r\nSome heaps may become empty, but they still count as heaps. What is the\r\nmaximum number of stones in the smallest heap after the process?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n; cin >> n;\n\t\tvector<int> a(n), b(n);\n\t\tfor (int i = 0; i < n; i++) cin >> a[i];\n\t\tint l = 0, r = 1e9, ans = 0;\n\t\twhile (l <= r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tfor (int i = 0; i < n; i++) b[i] = 0;\n\t\t\tint ok = 1;\n\t\t\tfor (int i = n - 1; i >= 2; i--) {\n\t\t\t\tif (a[i] + b[i] < mid) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint can = min(a[i] / 3, (a[i] + b[i] - mid) / 3);\n\t\t\t\tb[i - 2] += can * 2; b[i - 1] += can;\n\t\t\t}\n\t\t\tif (ok && a[0] + b[0] >= mid && a[1] + b[1] >= mid) ans = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Balanced Stone Heaps.json",
    "editorial_link": "https://codeforces.com//blog/entry/98463",
    "editorial": "The answer can be binary searched. That is, we can find the biggest\r\nnumber , such that we can make all heap having at least stones. So our\r\njob here is to check if we can satisfy the said condition with a number\r\n.Letâs consider a problem: we go from to , pick a number (), move and\r\nstones from the -th heap to the heap and -th heap respectively. In this\r\nproblem, we can greedily move the stones: since is the minimum required\r\nstones, if at some moment, we have , then we can not satisfy the\r\ncondition for anymore. Otherwise, it is always the best to use as many\r\nstones as we can, that is, choose , and move and stones to the and heaps\r\nrespectively. In the end, if all the heap are not less than , we can\r\nconclude that we can make all heaps having not less than stones with\r\nthis process.Going back to our original problem, it seems like we can\r\nsolve it by doing the process in the reversed order, as discussed above.\r\nBut there is a catch! The number of stones that can be moved the number\r\nof the stones in the original heap! So, if we call the original heap\r\nsize, and the current modified heap size, then the number of stones that\r\nwe should move is at each step.\r\n",
    "hint": []
}