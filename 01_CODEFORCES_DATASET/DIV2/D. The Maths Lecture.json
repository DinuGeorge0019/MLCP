{
    "link": "https://codeforces.com//contest/507/problem/D",
    "problemId": "21017",
    "problem_idx": "D",
    "shortId": "507D",
    "contest_number": "507",
    "problem_submissions": {
        "E": [
            9526622,
            9522874,
            9528248,
            9522738,
            9519732,
            9522241,
            9524358,
            9526324,
            9526094,
            9526850,
            9526275,
            9527839,
            9524894,
            9533260,
            9526956,
            9526355,
            9527254,
            9534539,
            9527572,
            9528068,
            9528656
        ],
        "D": [
            9524452,
            9527107,
            9526768,
            9524593,
            10558273,
            10558123,
            10558122,
            9525066
        ],
        "C": [
            9521275,
            9525428,
            9521898,
            9519042,
            9523598,
            9520087,
            9521484,
            9522923,
            9523120,
            9521243,
            9521401,
            9526151,
            9520501,
            9521807,
            9523054,
            9522069,
            9522518,
            9521325,
            9520982
        ],
        "B": [
            9517387,
            9516026,
            9517698,
            9515711,
            9521710,
            9519733,
            9518855,
            9517565,
            9516742,
            9518683,
            9519009,
            9516196,
            9517854,
            9518052,
            9516626,
            9518923,
            9517641,
            9516929,
            9517425
        ],
        "A": [
            9515320,
            9514942,
            9515025,
            9514972,
            9520386,
            9520232,
            9514912,
            9515204,
            9515151,
            9515163,
            9515214,
            9515096,
            9514948,
            9515853,
            9515067,
            9517288,
            9515310,
            9515279,
            9516279
        ]
    },
    "name": "D. The Maths Lecture",
    "statement": "Amr doesn\u2019t like Maths as he finds it really boring, so he usually\r\nsleeps in Maths lectures. But one day the teacher suspected that Amr is\r\nsleeping and asked him a question to make sure he wasn\u2019t.First he gave\r\nAmr two positive integers and . Then he asked Amr, how many integer\r\nnumbers exist such that: Decimal representation of (without leading\r\nzeroes) consists of exactly digits; There exists some integer such that:\r\n; decimal representation of is a of decimal representation of . As the\r\nanswer to this question may be pretty huge the teacher asked Amr to\r\noutput only its remainder modulo a number .Can you help Amr escape this\r\nembarrassing situation?\r\n",
    "solutions": [
        "#include <cstdio>\nusing namespace std;\n\nint dp[1010][110], pw[1010];\n\nint main() {\n    int n, K, m;\n    scanf(\"%d%d%d\", &n, &K, &m);\n    pw[0] = 1;\n    for (int i = 1; i <= 1000; i ++) {\n        pw[i] = (long long)pw[i - 1] * 10 % K;\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i < n; i ++) {\n        int down = (i == n - 1 ? 1 : 0);\n        for (int j = down; j < 10; j ++) {\n            int st = (i == 0 ? 0 : 1);\n            for (int k = st; k <= K; k ++) {\n                int to = (k + pw[i] * j) % K;\n                if (to == 0 && j == 0) {\n                    to = K;\n                }\n                dp[i + 1][to] += dp[i][k];\n                if (dp[i + 1][to] >= m) {\n                    dp[i + 1][to] -= m;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i ++) {\n        int pre = 1;\n        for (int j = n; j > i; j --) {\n            if (j == n) {\n                pre = (long long)pre * 9 % m;\n            } else {\n                pre = (long long)pre * 10 % m;\n            }\n        }\n        ans += (long long)pre * dp[i][0] % m;\n        if (ans >= m) {\n            ans -= m;\n        }\n    }\n    printf(\"%d\\n\", ans % m);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. The Maths Lecture.json",
    "editorial_link": "https://codeforces.com/blog/entry/15975",
    "editorial": "Hint: Dynamic programming problem. To handle repetitions we have to\r\nconstruct the number from right to the left and calculate the answer\r\nwhen we reach a number equivalent to modulo . Solution: Let\u00e2\u0080\u0099s define as\r\na recursive functions calculates the number of numbers consisting of\r\ndigits satisfying the conditions of the problem and with a specific\r\nsuffix of length such that . We want to avoid repetition so by\r\nconstructing the number from the right to the left when we reach a state\r\nwith with suffix we return the answer immediately so any other suffix\r\nthat contains this suffix won\u00e2\u0080\u0099t b calculated. So the base cases are , .\r\nSo state transitions will be (We add a digit to the left). And we can\r\nhandle case coming from a zero suffix easily with a boolean variable we\r\nset to true when we use a digit in constructing the number. Time\r\ncomplexity: Implementation: 9529210\r\n"
}