{
    "link": "https://codeforces.com//contest/1516/problem/D",
    "problemId": "963909",
    "problem_idx": "D",
    "shortId": "1516D",
    "contest_number": "1516",
    "problem_submissions": {
        "D": [
            113744317,
            113734893,
            113732174,
            113735658,
            113736689,
            113753948,
            113752217,
            113742709,
            113733277,
            113772079,
            113758509,
            113765675,
            113749541,
            113745751,
            113782529,
            113747411,
            113750921,
            113756461
        ],
        "B": [
            113738828,
            113716225,
            113717222,
            113722044,
            113718441,
            113730595,
            113730731,
            113724024,
            113714979,
            113731503,
            113722149,
            113770715,
            113734481,
            113725894,
            113728293,
            113726022,
            113720823,
            113721935
        ],
        "A": [
            113731086,
            113713802,
            113713787,
            113716079,
            113713803,
            113733865,
            113718261,
            113723529,
            113713794,
            113715315,
            113715862,
            113721754,
            113725712,
            113721388,
            113714099,
            113715023,
            113714544
        ],
        "C": [
            113728258,
            113723880,
            113721257,
            113726835,
            113726539,
            113723017,
            113756433,
            113727327,
            113747091,
            113766829,
            113742469,
            113777547,
            113761975,
            113734529,
            113746406,
            113736795,
            113734065,
            113734539
        ],
        "E": [
            113723992,
            113762256,
            113769222,
            113761842,
            113767857,
            113776100,
            113769406,
            113784620,
            113781943,
            113761572,
            113785543,
            113747187,
            113860370,
            113784367,
            113787186,
            113776311,
            113821800
        ]
    },
    "name": "D. Cut",
    "statement": "This time Baby Ehab will only cut and not stick. He starts with a piece\r\nof paper with an array a of length n written on it, and then he does the\r\nfollowing: he picks a range (l, r) and cuts the subsegment a_l, a_{l +\r\n1},\r\nldots, a_r out, removing the rest of the array. he then cuts this range\r\ninto multiple subranges. to add a number theory spice to it, he requires\r\nthat the elements of every subrange must have their product equal to\r\ntheir least common multiple (LCM). Formally, he partitions the elements\r\nof a_l, a_{l + 1},\r\nldots, a_r into contiguous subarrays such that the product of every\r\nsubarray is equal to its LCM. Now, for q independent ranges (l, r), tell\r\nBaby Ehab the minimum number of subarrays he needs.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<'0')v=getchar();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint n,lst[100002],q,a[100002],f[100002],g[22][100002];\nint main(){\n\tn=read(),q=read();\n\tfor(re int i=1;i<=n;++i)a[i]=read();\n\tfor(re int i=1;i<=n;++i){\n\t\tf[i]=f[i-1];\n\t\tfor(re int j=2;j*j<=a[i];++j)\n\t\t\tif(a[i]%j==0){\n\t\t\t\tf[i]=max(f[i],lst[j]);\n\t\t\t\tlst[j]=i;\n\t\t\t\twhile(a[i]%j==0)a[i]/=j;\n\t\t\t}\n\t\tif(a[i]^1){\n\t\t\tf[i]=max(f[i],lst[a[i]]);\n\t\t\tlst[a[i]]=i;\n\t\t}\n\t}\n\tfor(re int i=1;i<=n;++i)g[0][i]=f[i];\n\tfor(re int i=1;i<=20;++i)for(re int j=1;j<=n;++j)g[i][j]=g[i-1][g[i-1][j]];\n\twhile(q--){\n\t\tre int l=read(),r=read(),x=0;\n\t\tfor(re int i=20;~i;--i)if(g[i][r]>=l)x+=1<<i,r=g[i][r];\n\t\tprintf(\"%d\\n\",x+1);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "graphs",
        "number theory",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Cut.json",
    "editorial_link": "https://codeforces.com//blog/entry/89846",
    "editorial": "Letâs understand what \"product=LCM\" means. Letâs look at any prime .\r\nThen, the product operation adds up its exponent in all the numbers,\r\nwhile the LCM operation takes the maximum exponent. Hence, the only way\r\ntheyâre equal is if every prime divides at most one number in the range.\r\nAnother way to think about it is that every pair of numbers is coprime.\r\nNow, we have the following greedy algorithm: suppose we start at index ;\r\nweâll keep extending our first subrange while the condition (every pair\r\nof numbers is coprime) is satisfied. We clearly donât gain anything by\r\nstopping when we can extend, since every new element just comes with new\r\nrestrictions. Once weâre unable to extend our subrange, weâll start a\r\nnew subrange, until we reach index . Now, for every index , letâs define\r\nto be the first index that will make the condition break when we add it\r\nto the subrange. Then, our algorithm is equivalent to starting with an\r\nindex , then replacing with until we exceed index . The number of steps\r\nit takes is our answer. We now have subproblems to solve:\r\n",
    "hint": []
}