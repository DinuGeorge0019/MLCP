{
    "link": "https://codeforces.com//contest/1715/problem/C",
    "problemId": "1513951",
    "problem_idx": "C",
    "shortId": "1715C",
    "contest_number": "1715",
    "problem_submissions": {
        "F": [
            169148274,
            169155365,
            169130889,
            169155985,
            169108945,
            169574810,
            169163231,
            169141940,
            169196708
        ],
        "E": [
            169127780,
            169131038,
            169118368,
            169119601,
            169121517,
            169134266,
            169131152,
            169132329,
            169132606,
            169133682,
            169162968,
            169135131,
            169132730,
            169135556,
            169141593,
            169136787,
            169114950,
            169142196,
            169141933,
            169141598
        ],
        "D": [
            169113859,
            169112143,
            169123073,
            169198160,
            169109801,
            169126906,
            169218994,
            169116160,
            169193819,
            169119863,
            169123507,
            169122322,
            169117695,
            169108158,
            169121681,
            169123192,
            169123408,
            169275333,
            169121118,
            169125621,
            169118823,
            169120372,
            169123621,
            169124629
        ],
        "C": [
            169107451,
            169103179,
            169137078,
            169101370,
            169129288,
            169102686,
            169112899,
            169107306,
            169108346,
            169113649,
            169121461,
            169112477,
            169108680,
            169197238,
            169116719,
            169112431,
            169195068,
            169118011,
            169144372,
            169114599,
            169111934,
            169113718
        ],
        "B": [
            169102135,
            169098162,
            169135707,
            169097670,
            169093858,
            169101514,
            169098876,
            169101987,
            169101035,
            169096282,
            169099222,
            169103628,
            169099009,
            169100124,
            169100205,
            169104726,
            169103909,
            169104946,
            169099294
        ],
        "A": [
            169092934,
            169092062,
            169134952,
            169093933,
            169091995,
            169093151,
            169092986,
            169094481,
            169092501,
            169092283,
            169092715,
            169094922,
            169093338,
            169093831,
            169094306,
            169125908,
            169096348,
            169096156,
            169094226
        ]
    },
    "name": "C. Monoblock",
    "statement": "Stanley has decided to buy a new desktop PC made by the company\r\n\"Monoblock\", and to solve captcha on their website, he needs to solve\r\nthe following task.The of an array is the minimum number of blocks of\r\nconsecutive identical numbers in which the array could be split. For\r\nexample, the awesomeness of an array [1, 1, 1] is 1; [5, 7] is 2, as it\r\ncould be split into blocks [5] and [7]; [1, 7, 7, 7, 7, 7, 7, 7, 9, 9,\r\n9, 9, 9, 9, 9, 9, 9] is 3, as it could be split into blocks [1], [7, 7,\r\n7, 7, 7, 7, 7], and [9, 9, 9, 9, 9, 9, 9, 9, 9]. You are given an array\r\na of length n. There are m queries of two integers i, x. A query i, x\r\nmeans that from now on the i-th element of the array a is equal to\r\nx.After each query print the sum of awesomeness values among all\r\nsubsegments of array a. In other words, after each query you need to\r\ncalculate\r\nsum\r\nlimits_{l = 1}^n\r\nsum\r\nlimits_{r = l}^n g(l, r), where g(l, r) is the awesomeness of the array\r\nb = [a_l, a_{l + 1},\r\nldots, a_r].\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n\tint x;\n\tscanf(\"%d\",&x);\n\treturn x;\n}\ntypedef long long ll;\nconst int N=1e6+5;\nint n,m;\nint a[N];\nll ans;\nvoid upd(int p,int v){\n\tif(p<1)return;\n\tll val=0;\n\tif(a[p]==a[p+1])val=(ll)p*(n-p);\n\tif(v==1)ans-=val;\n\telse ans+=val;\n}\nint main(){\n\tn=in(),m=in();\n\tfor(int i=1;i<=n;i++)a[i]=in();\n\tfor(int i=1;i<=n;i++)ans+=(ll)i*(n-i+1);\n\tfor(int i=1;i<n;i++)upd(i,1);\n\twhile(m--){\n\t\tint p=in(),v=in();\n\t\tupd(p-1,-1),upd(p,-1);\n\t\ta[p]=v;\n\t\tupd(p-1,1),upd(p,1);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "implementation",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Monoblock.json",
    "editorial_link": "https://codeforces.com//blog/entry/104261",
    "editorial": "Let us introduce another definition for the beauty beauty of the array\r\nis a number of such positions (indexes) , that , plus . Letâs call\r\n\"joints\" places where two adjacent different numbers exist in the\r\narray.Now consider the problem from the angle of these joints: if is\r\nequal to the number of segments, that overlap this joint, then the sum\r\nof beauty over all subsegments is equal to the sum of over all joints.\r\nTo get a clearer understanding, consider the following : (\"\" is\r\nbasically a joint). There are 5 segments, which contain first joint (),\r\nand there are 9 such for the second joint (), in total. After adding the\r\nnumber of subsegments, we get the answer: .From this the solution is\r\nderived, apart from change requests: iterate over the array, find\r\n\"joints\", comparing adjacent numbers, if is different from , that we\r\nmust add to the answer, that is how many possible beginnings of\r\nsubsegments from the left multiplied by the number of possible ends from\r\nthe right.How we should apply changes? In fact, itâs worth just checking\r\nif there are any neighboring joints for the position of the changing\r\nnumber, subtracting the number of subsegments, that overlap these\r\njoints, and then doing similar operations after setting a new value for\r\nthe number.For a better understanding and more details, we suggest you\r\nlook over the authorsâ solutions.\r\n",
    "hint": [
        "Hint #1 Look from the perspective of joints between blocks",
        "Hint #2 For each pair of adjacent different numbers, calculate how many subsegments contain them.",
        "Hint #3 To apply the changes, neighboring numbers and the position of the changing number are all we need to know."
    ]
}