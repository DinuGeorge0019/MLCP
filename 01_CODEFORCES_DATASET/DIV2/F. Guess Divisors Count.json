{
    "link": "https://codeforces.com//contest/1355/problem/F",
    "problemId": "621796",
    "problem_idx": "F",
    "shortId": "1355F",
    "contest_number": "1355",
    "problem_submissions": {
        "F": [
            80362643,
            80361142,
            80371199,
            80375388,
            80371644,
            80361246,
            80376315,
            80364923,
            80451552,
            80451301,
            82486662,
            80381916,
            80385112,
            80379306
        ],
        "E": [
            80342772,
            80347661,
            80342876,
            80352205,
            80343534,
            80366285,
            80351380,
            80344639,
            80337870,
            80337107,
            80341941,
            80338367,
            80340360,
            80336736,
            80314570,
            80337962,
            80336156,
            80334884,
            80344718
        ],
        "D": [
            80330173,
            80325918,
            80331675,
            80332445,
            80331125,
            80343460,
            80342008,
            80323259,
            80328043,
            80317161,
            80320497,
            80327650,
            80330129,
            80331474,
            80325643,
            80327968,
            80338287,
            80328760
        ],
        "C": [
            80320115,
            80322649,
            80326557,
            80321616,
            80325868,
            80336946,
            80347623,
            80329416,
            80318213,
            80323733,
            80324197,
            80332049,
            80321990,
            80325577,
            80334728,
            80333064,
            80322766,
            80319462,
            80324120
        ],
        "B": [
            80313084,
            80311263,
            80314204,
            80313526,
            80315674,
            80318605,
            80310517,
            80315225,
            80313004,
            80311116,
            80311816,
            80310369,
            80314982,
            80317625,
            80337817,
            80312634,
            80317719,
            80311591,
            80311875
        ],
        "A": [
            80310641,
            80315080,
            80310450,
            80310461,
            80311650,
            80314001,
            80355749,
            80319520,
            80310211,
            80310180,
            80310418,
            80311667,
            80311224,
            80310372,
            80321351,
            80310345,
            80316111,
            80324974,
            80310515
        ]
    },
    "name": "F. Guess Divisors Count",
    "statement": "We have hidden an integer 1\r\nle X\r\nle 10^{9}. You guess this number. You have to of this number, and you :\r\nyour answer will be considered correct if its absolute error is not\r\ngreater than 7 its relative error is not greater than 0.5. More\r\nformally, let your answer be ans and the number of divisors of X be d,\r\nthen your answer will be considered correct if of the two following\r\nconditions is true: | ans - d |\r\nle 7;\r\nfrac{1}{2}\r\nle\r\nfrac{ans}{d}\r\nle 2.You can make at most 22 queries. One query consists of one integer\r\n1\r\nle Q\r\nle 10^{18}. In response, you will get gcd(X, Q) the greatest common\r\ndivisor of X and Q.The number X is fixed before all queries. In other\r\nwords, .Let\u2019s call the process of guessing the number of divisors of\r\nnumber X a . In one test you will have to play T independent games, that\r\nis, guess the number of divisors T times for T independent values of X.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ld long double\n#define endl \"\\n\"\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb(x) push_back(x)\n#define mp(a,b) make_pair(a,b)\n#define ms(v,x) memset(v,x,sizeof(v))\n#define all(v) v.begin(),v.end()\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n//#define per(i, a, b) for(int i = b-1; i>=a ; i--)\n#define trav(a, x) for(auto& a : x)\n#define allin(a , x) for(auto a : x)\n#define td(v) v.begin(),v.end()\n#define sz(v) (int)v.size()\n//#define M   1000000007 // 1e9 + 7\n#define int long long\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ninline ll mod(ll n, ll m ){ ll ret = n%m; if(ret < 0) ret += m; return ret; }\nll gcd(ll a, ll b){return (b == 0LL ? a : gcd(b, a%b));}\n\nll exp(ll a,ll b,ll m){\n    if(b==0LL) return 1LL;\n    if(b==1LL) return mod(a,m);\n    ll k = mod(exp(a,b/2,m),m);\n    if(b&1LL){\n        return mod(a*mod(k*k,m),m);\n    }\n    else return mod(k*k,m);\n}\n\nconst int N = 2e6 + 10;\n  vector<int> p;\n  int mark[N];\n  int small[N];\nvoid crivo(){\n\n  for(int i=1;i<N;i++)small[i] = i;\n  for(int i=2;i<N;i++){\n    if(!mark[i]){\n      p.pb(i);\n      for(int j=2*i;j<N;j+=i){\n        mark[j] = 1;\n        if(small[j]==j)small[j] = i;\n      }\n    }\n  }\n\n\n}\n\nint Q[23];\nvector<ll> inter[23];\n\nvoid precalc(){\n\n  int id=0;\n  for(int i=1;i<=22;i++){\n    ll prod = p[id];\n    inter[i].pb(p[id]);\n    id++;\n    while(prod < 1e18/p[id]){\n      prod*=p[id];\n      inter[i].pb(p[id]);\n      id++;\n    } \n    Q[i] = prod;\n  \n //   cout << Q[i] <<\" \";\n  }\n\n}\n\nll ask(ll x){\n  cout<<\"? \"<<x<<endl;\n  cout.flush();\n  ll g;\n  cin>>g;\n  return g;\n}\n\nint cnt(int pp){\n  ll P = pp;\n  while(P < 1e18 / pp){\n    P*=pp;\n  }\n  ll g = ask(P);\n  int k=0;\n  while(g%pp==0){\n    k++;\n    g/=pp;\n  }\n  return k;\n}\n\nvoid solve(){\n  ll ans = 1;\n  int foi=0;\n  int i = 1;\n  while(foi<22){\n    ll g = ask(Q[i]);\n    foi ++ ;\n    i++;\n    vector<int> primes;\n   for(ll P : inter[i-1]){\n      if(g%P==0)primes.pb(P);\n   }\n\n    int id=0;\n    while(foi<22 and id  < primes.size()){\n      foi++;\n      int x = cnt(primes[id]);\n      ans=1LL*ans*(x+1);\n      \n      id++;\n    }\n    while(id<primes.size()){\n      ans*=2LL;\n      id++;\n    }\n\n  }\n  ans=max(ans*2LL,ans + 7);\n  cout <<\"! \"<< ans << endl;\n  cout.flush();\n}\n\n\nint32_t main(){\n  fastio;\n  crivo();\n  precalc();\n\n  int t;\n  cin >> t;\n  while(t--){\n    solve();\n  }\n  // Math -> gcd it all\n  // Did u check N=1? Did you switch N,M?\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive",
        "number theory"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Guess Divisors Count.json",
    "editorial_link": "https://codeforces.com//blog/entry/77491",
    "editorial": "If X = p_{1}^{\r\nalpha_{1}}\r\ncdot p_{2}^{\r\nalpha_{2}}\r\ncdot\r\nldots\r\ncdot p_{k}^{\r\nalpha_{k}} then d(X) = (\r\nalpha_{1} + 1)\r\ncdot (\r\nalpha_{2} + 1)\r\ncdot\r\nldots\r\ncdot (\r\nalpha_{k} + 1).If X has prime p in power\r\nalpha and Q has p in power\r\nbeta then gcd(X, Q) will have p in power\r\ngamma =\r\nmin (\r\nalpha,\r\nbeta). If\r\ngamma <\r\nbeta then\r\nalpha =\r\ngamma, otherwise\r\ngamma =\r\nbeta and\r\nalpha\r\nge\r\ngamma. We don\u00e2\u0080\u0099t know X, but we can choose Q. If we\u00e2\u0080\u0099ll choose Q with\r\nknown prime factorization then we\u00e2\u0080\u0099ll be able to extract all the\r\ninformation from query fast (in O(\r\nlog Q)).After all the queries for each prime p we\u00e2\u0080\u0099ll know either the\r\nexact power in which X has it, or lower bound for it. We can get upper\r\nbound from the fact that X\r\nle 10^{9}.It is clear that we cannot get information about all primes\r\nthere are too many of them and too few queries. We want to somehow use\r\nthe fact that we don\u00e2\u0080\u0099t have to find the exact answer...Suppose we have\r\nfigured out that X = X_{1}\r\ncdot X_{2} where we know X_{1} exactly and we also know that X_{2} has\r\nno more than t prime factors (including multiplicity). Then d(X_{1})\r\nle d(X)\r\nle d(X_{1})\r\ncdot d(X_{2})\r\nle d(X_{1})\r\ncdot 2^{t}. If t\r\nle 1 then our answer will have relative error no more than 0.5...One of\r\nthe ways to guarantee that X_{2} has few prime factors is to show that\r\nit cannot have small prime factors. That means that we have to calculate\r\nthe exact power for all small primes. This gives an overall idea for the\r\nsolution: let\u00e2\u0080\u0099s make a query Q=p^{\r\nbeta} for all primes p\r\nle B (for some bound B) where\r\nbeta is chosen in such a way that p^{\r\nbeta} > 10^{9}. This allows us to know the exact power in which X has\r\np.This basic idea can be improved in several ways: X has no more than 9\r\ndifferent prime factors, so for most primes its power is 0. If we could\r\nexclude these redundant primes fast it could speed up the solution\r\nsignificantly. And there is a way: we could make a query Q = p_{1} p_{2}\r\nldots p_{s} for s different primes, after that we will know which of\r\nthem are factors of X;\r\nbeta can be chosen such that p^{\r\nbeta + 1} > 10^{9}, because even if\r\ngamma =\r\nbeta and\r\nalpha\r\nge\r\ngamma =\r\nbeta we will know that\r\nalpha\r\nle\r\nbeta since otherwise X > 10^{9}; From the previous point follows that we\r\ncan find the exact power for two primes simultaneously, just make a\r\nquery with a product of two respective numbers.How to choose B?\r\nApparently we want B^{2} > 10^{9}. But actually t\r\nle 2 is ok for us: if we know that L\r\nle d(X)\r\nle 4L then we can answer 2L and the relative error will be no more than\r\n0.5. That means we want B^{3} > 10^{9} or B = 1001.We are close: there\r\nare 168 primes less than 1001, we can check 6 primes (for being a factor\r\nof X) in one query since 1000^{6}\r\nle 10^{18}, so we need 28 queries.Let\u00e2\u0080\u0099s note that if we have found some\r\nprime factors of X (let\u00e2\u0080\u0099s say their product is X_{1}) then X_{2}\r\nle\r\nfrac{10^{9}}{X_{1}}. Suppose we have checked all the primes not greater\r\nthan p and X_{1}\r\ncdot p^{3} > 10^{9}. That means that X_{2} has no more than 2 prime\r\ndivisors and we are good.What is left is to use our right to have\r\nabsolute error: if X_{1}\r\nle 3 we can just print 8! Either X_{1}\r\nle 3 and we are fine with X_{2} having 3 prime factors, or X_{1}\r\nge 4 and we have to check all primes up to\r\nsqrt[3]{10^{9} / 4} < 630. There are 114 such primes, so we need only 19\r\nqueries.We will also need some queries to find out the exact power for\r\nthose small prime factors of X we have found. If we have found no more\r\nthan 2 prime factors, we\u00e2\u0080\u0099ll need 1 query, otherwise we\u00e2\u0080\u0099ll have to check\r\nprimes only up to\r\nsqrt[3]{10^{9} / (2\r\ncdot 3\r\ncdot 5)} < 330, of which there are only 66 so the first part of the\r\nsolution spends no more than 11 queries.So we have shown that the\r\nsolution spends no more than 20 queries. We did some rough estimations,\r\nthe actual bound for this solution is 17 queries.\r\n"
}