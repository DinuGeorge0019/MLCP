{
    "link": "https://codeforces.com//contest/1713/problem/A",
    "problemId": "1496884",
    "problem_idx": "A",
    "shortId": "1713A",
    "contest_number": "1713",
    "problem_submissions": {
        "E": [
            167272157,
            167275947,
            167255255,
            167280552,
            167277532,
            167281915,
            167286271,
            167295534,
            167291747,
            167285691,
            167290110,
            167289826,
            167289470,
            167288114,
            167295399,
            167293392,
            167292517,
            167288991,
            167292413,
            167295616
        ],
        "D": [
            167262934,
            167264444,
            167275938,
            167266127,
            167264903,
            167407463,
            167265717,
            167269013,
            167270800,
            167270098,
            167276487,
            167270258,
            167267741,
            167270166,
            167269509,
            167261936,
            167272225,
            167242557,
            167276667,
            167276744,
            167278772
        ],
        "C": [
            167243257,
            167245150,
            167266251,
            167242115,
            167251589,
            167255369,
            167252792,
            167244013,
            167251870,
            167263156,
            167253225,
            167255260,
            167254692,
            167249536,
            167241452,
            167251627,
            167255063,
            167259927,
            167257077,
            167247512
        ],
        "B": [
            167234078,
            167234734,
            167230438,
            167233192,
            167236986,
            167243546,
            167240561,
            167234594,
            167236064,
            167235869,
            167233392,
            167241862,
            167238018,
            167234909,
            167233503,
            167237613,
            167277571,
            167236123,
            167238131,
            167235652
        ],
        "A": [
            167230129,
            167230356,
            167231376,
            167230475,
            167230244,
            167239741,
            167232628,
            167231141,
            167231690,
            167230947,
            167230261,
            167230810,
            167230984,
            167230721,
            167230524,
            167233664,
            167273402,
            167231481,
            167232153,
            167230801
        ],
        "F": [
            167345887,
            167645094,
            167481610
        ]
    },
    "name": "A. Traveling Salesman Problem",
    "statement": "You are living on an infinite plane with the Cartesian coordinate system\r\non it. In one move you can go to any of the four adjacent points (left,\r\nright, up, down).More formally, if you are standing at the point (x, y),\r\nyou can: go left, and move to (x - 1, y), or go right, and move to (x +\r\n1, y), or go up, and move to (x, y + 1), or go down, and move to (x, y -\r\n1). There are n boxes on this plane. The i-th box has coordinates\r\n(x_i,y_i). It is guaranteed that the boxes are either on the x-axis or\r\nthe y-axis. That is, either x_i=0 or y_i=0.You can collect a box if you\r\nand the box are at the same point. Find the minimum number of moves you\r\nhave to perform to collect all of these boxes if you have to at the\r\npoint (0,0).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\n\nbool solve(int caseN) {\n    int n;\n    cin >> n;\n\n    int minX = 0, maxX = 0, minY = 0, maxY = 0;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        minX = min(minX, x);\n        maxX = max(maxX, x);\n        minY = min(minY, y);\n        maxY = max(maxY, y);\n    }\n    cout << 2*(maxX-minX+maxY-minY) << \"\\n\";\n\n    return false;\n}\n\n\nint main() {\n    // freopen(\"complexity.in\", \"r\", stdin);\n    // freopen(\"complexity.out\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(i); /*\n    for (int i = 1; solve(i); i++); /**/\n    cout.flush();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "greedy",
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Traveling Salesman Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/105419",
    "editorial": "Suppose we only have boxes on the axis, then the optimal strategy is\r\ngoing in the following way: . There is no way to do in less than moves.\r\nWhat if we have boxes on two axis? Letâs assume it is , suppose we have\r\na strategy to go in the following way: . In this case it is optimal to\r\nfill the three dots with , which is just solving each axis\r\nindependently. Therefore, the number of axis does not matters. For each\r\naxis that has at least one box, go from to the farthest one, then come\r\nback to . Time complexity: Solution\r\n",
    "hint": [
        "Hint 1 Do we actually need to go off the axis?",
        "Hint 2 How to avoid visiting an axis more than once?"
    ]
}