{
    "link": "https://codeforces.com//contest/1355/problem/A",
    "problemId": "621791",
    "problem_idx": "A",
    "shortId": "1355A",
    "contest_number": "1355",
    "problem_submissions": {
        "F": [
            80362643,
            80361142,
            80371199,
            80375388,
            80371644,
            80361246,
            80376315,
            80364923,
            80451552,
            80451301,
            82486662,
            80381916,
            80385112,
            80379306
        ],
        "E": [
            80342772,
            80347661,
            80342876,
            80352205,
            80343534,
            80366285,
            80351380,
            80344639,
            80337870,
            80337107,
            80341941,
            80338367,
            80340360,
            80336736,
            80314570,
            80337962,
            80336156,
            80334884,
            80344718
        ],
        "D": [
            80330173,
            80325918,
            80331675,
            80332445,
            80331125,
            80343460,
            80342008,
            80323259,
            80328043,
            80317161,
            80320497,
            80327650,
            80330129,
            80331474,
            80325643,
            80327968,
            80338287,
            80328760
        ],
        "C": [
            80320115,
            80322649,
            80326557,
            80321616,
            80325868,
            80336946,
            80347623,
            80329416,
            80318213,
            80323733,
            80324197,
            80332049,
            80321990,
            80325577,
            80334728,
            80333064,
            80322766,
            80319462,
            80324120
        ],
        "B": [
            80313084,
            80311263,
            80314204,
            80313526,
            80315674,
            80318605,
            80310517,
            80315225,
            80313004,
            80311116,
            80311816,
            80310369,
            80314982,
            80317625,
            80337817,
            80312634,
            80317719,
            80311591,
            80311875
        ],
        "A": [
            80310641,
            80315080,
            80310450,
            80310461,
            80311650,
            80314001,
            80355749,
            80319520,
            80310211,
            80310180,
            80310418,
            80311667,
            80311224,
            80310372,
            80321351,
            80310345,
            80316111,
            80324974,
            80310515
        ]
    },
    "name": "A. Sequence with Digits",
    "statement": "Let’s define the following recurrence: a_{n+1} = a_{n} + minDigit(a_{n})\r\ncdot maxDigit(a_{n}).Here minDigit(x) and maxDigit(x) are the minimal\r\nand maximal digits in the decimal representation of x without leading\r\nzeroes. For examples refer to notes.Your task is calculate a_{K} for\r\ngiven a_{1} and K.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ld long double\n#define endl \"\\n\"\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb(x) push_back(x)\n#define mp(a,b) make_pair(a,b)\n#define ms(v,x) memset(v,x,sizeof(v))\n#define all(v) v.begin(),v.end()\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n//#define per(i, a, b) for(int i = b-1; i>=a ; i--)\n#define trav(a, x) for(auto& a : x)\n#define allin(a , x) for(auto a : x)\n#define td(v) v.begin(),v.end()\n#define sz(v) (int)v.size()\n//#define M   1000000007 // 1e9 + 7\n#define int long long\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ninline ll mod(ll n, ll m ){ ll ret = n%m; if(ret < 0) ret += m; return ret; }\nll gcd(ll a, ll b){return (b == 0LL ? a : gcd(b, a%b));}\n\nll exp(ll a,ll b,ll m){\n    if(b==0LL) return 1LL;\n    if(b==1LL) return mod(a,m);\n    ll k = mod(exp(a,b/2,m),m);\n    if(b&1LL){\n        return mod(a*mod(k*k,m),m);\n    }\n    else return mod(k*k,m);\n}\n\npii get(ll n){\n  vector<int> v;\n  while(n>0){\n    v.pb(n%10);\n    n/=10;\n  }\n  int mn = 1e9,mx = -1e9;\n  for(int x : v){\n    mn = min(x,mn);\n    mx = max(x,mx);\n  }\n  return pii(mn,mx);\n}\n\n\nvoid solve(){\n  ll n,k;\n  cin>>n>>k;\n  k--;\n  while(k--){\n    pii p = get(n);\n   int mn =  p.ff;\n   int mx = p.ss;\n   if(mn==0)break;\n   n = n + mn*mx;\n  }\n  cout << n << endl;\n}\n\nint32_t main(){\n  fastio;\n  int t=1;\n  cin>>t;\n  while(t--){\n    solve();\n  }\n  // Math -> gcd it all\n  // Did u check N=1? Did you switch N,M?\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Sequence with Digits.json",
    "editorial_link": "https://codeforces.com//blog/entry/77491",
    "editorial": "Letâs calculate the sequence for fixed a_{1} = 1: 1, 2, 6, 42, 50, 50,\r\n50,\r\nldotsWe got lucky and the minimal digit has become 0, after that the\r\nelement has stopped changing because we always add 0.Actually it is not\r\nluck and that will always happen. Note that we add no more than 9\r\ncdot 9 = 81 every time, so the difference between two consecutive\r\nelements of the sequence is bounded by 81. Assume that we will never\r\nhave minimal digit equal to 0. Then the sequence will go to infinity.\r\nLetâs take X = 1000(\r\nlfloor\r\nfrac{a_{1}}{1000}\r\nrfloor + 1). All the numbers on segment [X;X+99] have 0 in hundreds\r\ndigit, so none of them can be element of our sequence. But our sequence\r\nshould have numbers greater than X. Letâs take the smallest of them, it\r\nshould be at least X + 100. But then the previous number in the sequence\r\nis at least (X + 100) - 81 = X + 19. It is greater than X but smaller\r\nthan the minimal of such numbers. Contradiction.In the previous\r\nparagraph we have actually shown that we have no numbers greater than\r\nX + 100 in our sequence and we will see the number with 0 among first\r\n1001 elements.That means that we can build the sequence till we find the\r\nfirst number with 0 and then it will repeat forever.In reality the\r\nmaximal index of the first elements with 0 is 54 and minimal a_{1} for\r\nthat to happen is 28217.\r\n",
    "hint": []
}