{"link": "https://codeforces.com//contest/1348/problem/F", "problemId": "609093", "problem_idx": "F", "shortId": "1348F", "contest_number": "1348", "problem_submissions": {"F": [78730137, 78732956, 78738021, 78735188, 78738507, 78734079, 78753080, 78717089, 78727355, 78727368, 78773476, 78740376], "E": [78711148, 78713291, 78707898, 78710381, 78719540, 78713433, 78709333, 79466363, 78772738, 78713600, 78699633, 78717322, 78717382, 78717153, 78728870, 78722408, 78722025, 78727426, 78728940], "C": [78694419, 78693419, 78696011, 78687630, 78679892, 78697771, 78685191, 78681524, 78686378, 78693929, 78687938, 78717342, 78689661, 78687381, 78689833, 78687589, 78685601, 78687639, 78687038], "D": [78686862, 78702906, 78690856, 78698132, 78702134, 78701001, 78706132, 78701735, 78701924, 78711443, 78693858, 78706550, 78704171, 78707502, 78702198, 78714055, 78702526, 78697601, 78708853, 78702351], "B": [78677169, 78673852, 78668555, 78675102, 78668889, 78672084, 78671272, 78669645, 79465649, 78671217, 78677254, 78667586, 78673648, 78677181, 78676314, 78695320, 78673038, 78670148, 78674360, 78670529, 78675058], "A": [78669591, 78665336, 78662907, 78664918, 78662747, 78662442, 78662941, 78662589, 78662555, 78665985, 78662547, 78662641, 78669435, 78666111, 78662690, 78662462, 78663929, 78669719, 78662632, 78663426]}, "name": "F. Phoenix and Memory", "statement": "Phoenix is trying to take a photo of his n friends with labels 1, 2,\r\ndots, n who are lined up in a row in a special order. But before he can\r\ntake the photo, his friends get distracted by a duck and mess up their\r\norder.Now, Phoenix must restore the order but he doesn\u2019t remember\r\ncompletely! He only remembers that the i-th friend from the left had a\r\nlabel between a_i and b_i inclusive. Does there exist a unique way to\r\norder his friends based of his memory?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200010;\nstruct P {\n\tint l,r,id;\n}p[MAXN];\nstruct cmp {\n\tbool operator () (P a,P b) {return a.r>b.r;}\n};\nint n,a[MAXN],b[MAXN],xl[MAXN],xr[MAXN],rev[MAXN];\nbool cmp1 (P a,P b) {return a.l<b.l;}\nbool cmp2 (P a,P b) {return a.r>b.r;}\npriority_queue <P,vector<P>,cmp> q,q2;\nmultiset <int> ms;\nint main () {\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%d%d\",&p[i].l,&p[i].r);\n\t\tp[i].id=i;\n\t}\n\tmultiset<int>::iterator it;\n\tsort(p+1,p+n+1,cmp1);\n\tint cur=1,flg=0;\n\tfor (int i=1;i<=n;i++) {\n\t\twhile (cur<=n&&p[cur].l<=i) {\n\t\t\tq.push(p[cur]);\n\t\t\tcur++;\n\t\t}\n\t\tP tmp=q.top();\n\t\tq.pop();\n\t\ta[tmp.id]=b[tmp.id]=i,xl[tmp.id]=tmp.l,xr[tmp.id]=tmp.r,rev[i]=tmp.id;\n\t\tq2.push(tmp);\n\t\twhile (!q2.empty()&&q2.top().r<i) {\n\t\t\tP tmp2=q2.top();\n\t\t\tq2.pop();\n\t\t\tit=ms.find(a[tmp2.id]);\n\t\t\tms.erase(it);\n\t\t}\n\t\tif (!ms.empty()&&!flg) {\n\t\t\tit=ms.end();\n\t\t\tit--;\n\t\t\tif (*it>=tmp.l) {\n\t\t\t\tflg=1;\n\t\t\t\tswap(b[tmp.id],b[rev[*it]]);\n\t\t\t}\n\t\t}\n\t\tms.insert(i);\n\t}\n\tif (flg) {\n\t\tprintf(\"NO\\n\");\n\t\tfor (int i=1;i<=n;i++) {printf(\"%d \",a[i]);}\n\t\tprintf(\"\\n\");\n\t\tfor (int i=1;i<=n;i++) {printf(\"%d \",b[i]);}\n\t\tprintf(\"\\n\");\n\t} else {\n\t\tprintf(\"YES\\n\");\n\t\tfor (int i=1;i<=n;i++) {printf(\"%d \",a[i]);}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "graphs", "greedy"], "dificulty": "2600", "interactive": false}