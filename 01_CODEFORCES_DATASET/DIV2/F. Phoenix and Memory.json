{
    "link": "https://codeforces.com//contest/1348/problem/F",
    "problemId": "609093",
    "problem_idx": "F",
    "shortId": "1348F",
    "contest_number": "1348",
    "problem_submissions": {
        "F": [
            78730137,
            78732956,
            78738021,
            78735188,
            78738507,
            78734079,
            78753080,
            78717089,
            78727355,
            78727368,
            78773476,
            78740376
        ],
        "E": [
            78711148,
            78713291,
            78707898,
            78710381,
            78719540,
            78713433,
            78709333,
            79466363,
            78772738,
            78713600,
            78699633,
            78717322,
            78717382,
            78717153,
            78728870,
            78722408,
            78722025,
            78727426,
            78728940
        ],
        "C": [
            78694419,
            78693419,
            78696011,
            78687630,
            78679892,
            78697771,
            78685191,
            78681524,
            78686378,
            78693929,
            78687938,
            78717342,
            78689661,
            78687381,
            78689833,
            78687589,
            78685601,
            78687639,
            78687038
        ],
        "D": [
            78686862,
            78702906,
            78690856,
            78698132,
            78702134,
            78701001,
            78706132,
            78701735,
            78701924,
            78711443,
            78693858,
            78706550,
            78704171,
            78707502,
            78702198,
            78714055,
            78702526,
            78697601,
            78708853,
            78702351
        ],
        "B": [
            78677169,
            78673852,
            78668555,
            78675102,
            78668889,
            78672084,
            78671272,
            78669645,
            79465649,
            78671217,
            78677254,
            78667586,
            78673648,
            78677181,
            78676314,
            78695320,
            78673038,
            78670148,
            78674360,
            78670529,
            78675058
        ],
        "A": [
            78669591,
            78665336,
            78662907,
            78664918,
            78662747,
            78662442,
            78662941,
            78662589,
            78662555,
            78665985,
            78662547,
            78662641,
            78669435,
            78666111,
            78662690,
            78662462,
            78663929,
            78669719,
            78662632,
            78663426
        ]
    },
    "name": "F. Phoenix and Memory",
    "statement": "Phoenix is trying to take a photo of his n friends with labels 1, 2,\r\ndots, n who are lined up in a row in a special order. But before he can\r\ntake the photo, his friends get distracted by a duck and mess up their\r\norder.Now, Phoenix must restore the order but he doesn\u2019t remember\r\ncompletely! He only remembers that the i-th friend from the left had a\r\nlabel between a_i and b_i inclusive. Does there exist a unique way to\r\norder his friends based of his memory?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200010;\nstruct P {\n\tint l,r,id;\n}p[MAXN];\nstruct cmp {\n\tbool operator () (P a,P b) {return a.r>b.r;}\n};\nint n,a[MAXN],b[MAXN],xl[MAXN],xr[MAXN],rev[MAXN];\nbool cmp1 (P a,P b) {return a.l<b.l;}\nbool cmp2 (P a,P b) {return a.r>b.r;}\npriority_queue <P,vector<P>,cmp> q,q2;\nmultiset <int> ms;\nint main () {\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%d%d\",&p[i].l,&p[i].r);\n\t\tp[i].id=i;\n\t}\n\tmultiset<int>::iterator it;\n\tsort(p+1,p+n+1,cmp1);\n\tint cur=1,flg=0;\n\tfor (int i=1;i<=n;i++) {\n\t\twhile (cur<=n&&p[cur].l<=i) {\n\t\t\tq.push(p[cur]);\n\t\t\tcur++;\n\t\t}\n\t\tP tmp=q.top();\n\t\tq.pop();\n\t\ta[tmp.id]=b[tmp.id]=i,xl[tmp.id]=tmp.l,xr[tmp.id]=tmp.r,rev[i]=tmp.id;\n\t\tq2.push(tmp);\n\t\twhile (!q2.empty()&&q2.top().r<i) {\n\t\t\tP tmp2=q2.top();\n\t\t\tq2.pop();\n\t\t\tit=ms.find(a[tmp2.id]);\n\t\t\tms.erase(it);\n\t\t}\n\t\tif (!ms.empty()&&!flg) {\n\t\t\tit=ms.end();\n\t\t\tit--;\n\t\t\tif (*it>=tmp.l) {\n\t\t\t\tflg=1;\n\t\t\t\tswap(b[tmp.id],b[rev[*it]]);\n\t\t\t}\n\t\t}\n\t\tms.insert(i);\n\t}\n\tif (flg) {\n\t\tprintf(\"NO\\n\");\n\t\tfor (int i=1;i<=n;i++) {printf(\"%d \",a[i]);}\n\t\tprintf(\"\\n\");\n\t\tfor (int i=1;i<=n;i++) {printf(\"%d \",b[i]);}\n\t\tprintf(\"\\n\");\n\t} else {\n\t\tprintf(\"YES\\n\");\n\t\tfor (int i=1;i<=n;i++) {printf(\"%d \",a[i]);}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Phoenix and Memory.json",
    "editorial_link": "https://codeforces.com//blog/entry/76555",
    "editorial": "There are many many many solutions to this problem (which is cool!). I\r\ndescribe two of them below.Both solutions first find an arbitrary valid\r\nordering. This can be done in with a greedy algorithm. We can sort the\r\nintervals and sweep from left to right. To see which position that we\r\ncan assign friend to, we process all intervals with and insert into a\r\nmultiset (or similar) structure. We match friend to the interval with\r\nminimal .We prove that if there exists more than one valid ordering, we\r\ncan transform one into another by swapping two friends.Proof:In our\r\nvalid ordering, each friend is assigned a position. We can think of this\r\nas a point being assigned to an interval (Friend - point, position -\r\ninterval). We will prove there exists a cycle of length or there exists\r\nno cycle at all.Suppose we have a cycle: each point is on its interval\r\nand its predecessor\u00e2\u0080\u0099s interval. Let\u00e2\u0080\u0099s take the shortest cycle of length\r\nat least two. Let be the leftmost point, be \u00e2\u0080\u0099s predecessor, and be \u00e2\u0080\u0099s\r\nsuccessor.Case : \u00e2\u0080\u0099s interval\u00e2\u0080\u0099s right endpoint is to the right of . and\r\nform a cycle of length . Case : \u00e2\u0080\u0099s interval\u00e2\u0080\u0099s right endpoint is to the\r\nleft of . must be between and . So, we can remove and get a shorter\r\ncycle. This is a contradiction. Denote as the position that friend is\r\nassigned to in our arbitrary ordering. Now, we are interested whether or\r\nnot there exists a friend such that there also exists some friend with\r\nsuch that and . If there does, we can swap friends and to make another\r\nvalid ordering. This can be done with a segment tree (build it with\r\nvalues ).Time Complexity: The problem is equivalent to checking if there\r\nis a unique perfect matching in the following bipartite graph:The\r\nvertices on the left correspond to position. The vertices on the right\r\ncorrespond to labels of the friends. A directed edge from a position\r\nnode to a label node exists iff the friend with that label can be at\r\nthat position.Find a perfect matching (corresponding to finding any\r\nvalid assignment) as described above. The matching is unique iff\r\ncontracting the edges (merging nodes connected by edges from our perfect\r\nmatching into one node) in the perfect matching creates a DAG. The\r\nreasoning is as follows:Consider a simpler graph, with only nodes\r\nrepresenting positions. We draw a directed edge from node to node if the\r\nfriend currently assigned at position (from our greedy) can also be\r\nassigned to position . So, if there exists any cycle, we can shift the\r\nfriends around the cycle to create another valid ordering. In other\r\nwords, if our graph is a DAG, the perfect matching is unique.Now,\r\nreturning back to the bipartite graph, we see that it is essentially the\r\nsame. By contracting edges, all position nodes are equivalent to the\r\nfriend node that is assigned to them (from the greedy). So, following an\r\nedge from the left side (position) to the right side (friend) puts us\r\nback on the left side (position), and this graph corresponds to the\r\nsimpler version I explained above.So, this can be done by DFS in , but\r\nthis is too slow. We can speed it up by storing a set of unvisited\r\nvertices and only iterating across those (by binary search on set-like\r\nstructure). Binary search works because every position corresponds to a\r\nrange of friends.Time Complexity:\r\n"
}