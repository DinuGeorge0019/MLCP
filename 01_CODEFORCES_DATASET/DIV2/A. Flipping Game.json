{
    "link": "https://codeforces.com//contest/327/problem/A",
    "problemId": "3283",
    "problem_idx": "A",
    "shortId": "327A",
    "contest_number": "327",
    "problem_submissions": {
        "E": [
            4017313,
            4017507,
            4018772,
            4017910,
            4019268,
            4023331,
            4015900,
            4017838,
            4016759,
            4027441,
            4022024,
            4019276
        ],
        "C": [
            4014970,
            4014797,
            4014725,
            4014945,
            4015808,
            4013334,
            4014670,
            4013527,
            4014594,
            4014368,
            4014192,
            4014033,
            4014334,
            4014505,
            4015890,
            4015156,
            4015704
        ],
        "D": [
            4014693,
            4016265,
            4015556,
            4017918,
            4018611,
            4017193,
            4015911,
            4016489,
            4016642,
            4016033,
            4016317,
            4016734,
            4016607,
            4017683,
            4017510
        ],
        "A": [
            4012718,
            4011428,
            4014213,
            4012212,
            4011845,
            4011264,
            4011546,
            4011299,
            4011577,
            4011527,
            4011323,
            4011508,
            4011858,
            4011904,
            4011582,
            4012111,
            4011772
        ],
        "B": [
            4011621,
            4012593,
            4012805,
            4012674,
            4012463,
            4011873,
            4012480,
            4011682,
            4012186,
            4012474,
            4011938,
            4011986,
            4012535,
            4012626,
            4012279,
            4012988,
            4012431
        ]
    },
    "name": "A. Flipping Game",
    "statement": "Iahub got bored, so he invented a game to be played on paper. He writes\r\nintegers . Each of those integers can be either 0 or 1. Heâ€™s allowed to\r\ndo exactly one move: he chooses two indices and () and flips all values\r\nfor which their positions are in range (that is ). Flip the value of\r\nmeans to apply operation - .The goal of the game is that after one move\r\nto obtain the maximum number of ones. Write a program to solve the\r\nlittle game of Iahub.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define rep(i,a,b) for (int i=a;i<=b;i++)\nint n, ans, a[105];\nint main()\n{\n    scanf(\"%d\", &n);\n    rep(i, 1, n) scanf(\"%d\", a + i);\n    rep(i, 1, n) rep(j, i, n)\n    {\n        int cnt = 0;\n        rep(k, i, j) a[k] ^= 1;\n        rep(k, 1, n) cnt += a[k];\n        if (cnt > ans) ans = cnt;\n        rep(k, i, j) a[k] ^= 1;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "implementation"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Flipping Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/8274",
    "editorial": "I ll present here the O(N ^ 3) algorithm, which is enough to solve this\r\ntask. Then, for those interested, I ll show a method to achieve O(N)\r\ncomplexity. O(N ^ 3) method: The first thing to observe is that\r\nconstrains are slow enough to allow a brute force algorithm. Using brute\r\nforce, I can calculate for each possible single move the number of 1s\r\nresulting after applying it and take maximum. For consider each move, I\r\ncan just generate with 2 FOR loops all indices i, j such as i <= j. So\r\nfar we have O(N ^ 2) complexity. Suppose I have now 2 fixed vaIues i and\r\nj. I need to calculate variable cnt (initially 0) representing the\r\nnumber of ones if I do the move. For do this, I choose another indice k\r\nto go in a[] array (taking O(N) time, making the total of O(N ^ 3)\r\ncomplexity). We have two cases: either k is in range [i, j] (this means\r\ni <= k AND k <= j) or not (if that condition is not met). If it s in\r\nrange, then it gets flipped, so we add to count variable 1 a[k] (observe\r\nthat it makes 0 to 1 and 1 to 0). If it s not in range, we simply add to\r\ncnt variable a[k]. The answer is maximum of all cnt obtained. O(N)\r\nmethod: For achieve this complexity, we need to make an observation.\r\nSuppose I flip an interval (it does not matter what interval, it can be\r\nany interval). Also suppose that S is the number of ones before flipiing\r\nit. What happens? Every time I flip a 0 value, S increases by 1 (I get a\r\nnew 1 value). Every time I flip a 1 value, S decreases by 1 (I loose a 1\r\nvalue). What would be the gain from a flip? I consider winning +1 when I\r\nget a 0 value and -1 when I get a 1 value. The gain would be simply a\r\nsum of +1 and -1. This gives us idea to make another vector b[]. B[i] is\r\n1 if A[i] is 0 and B[i] is -1 if A[i] is 1. We want to maximize S +\r\ngain_after_one_move sum. As S is constant, I want to maximize\r\ngain_after_one_move. In other words, I want to find a subsequence in b[]\r\nwhich gives the maximal sum. If I flip it, I get maximal number of 1s\r\ntoo. This can be founded trivially in O(N ^ 2). How to get O(N)? A\r\nrelative experienced programmer in dynamic programming will immediately\r\nrecognize it as a classical problem subsequence of maximal sum . If you\r\nnever heard about it, come back to this approach after you learn it.\r\n",
    "hint": []
}