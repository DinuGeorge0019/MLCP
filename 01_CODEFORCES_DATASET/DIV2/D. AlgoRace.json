{"link": "https://codeforces.com//contest/189/problem/D", "problemId": "1319", "problem_idx": "D", "shortId": "189D", "contest_number": "189", "problem_submissions": {"E": [1678506, 1678460, 1678211, 1678693, 1677477, 1677700, 1680381, 1677887, 1678428, 1681566], "D": [1676682, 1676035, 1677096, 1677898, 1674240, 1680791, 1676256, 1676755, 1676792, 1677405, 1676745, 1676612, 1677482, 1677225, 1676566], "C": [1674208, 1675081, 1675273, 1676086, 1673529, 1673748, 1674530, 1675036, 1674970, 1674691, 1674910, 1675504, 1675160, 1673957, 1675084, 1674909], "B": [1673360, 1673410, 1674214, 1674813, 1672769, 1673156, 1673373, 1673917, 1674026, 1673370, 1673358, 1672790, 1673649, 1674219, 1672936, 1673608, 1675358], "A": [1672718, 1672777, 1673274, 1672957, 1672602, 1672581, 1672722, 1673173, 1673083, 1672709, 1672650, 1672579, 1672834, 1672816, 1674499, 1672796, 1672817]}, "name": "D. AlgoRace", "statement": "PMP is getting a warrior. He is practicing a lot, but the results are\r\nnot acceptable yet. This time instead of programming contests, he\r\ndecided to compete in a car racing to increase the spirit of victory. He\r\ndecides to choose a competition that also exhibits algorithmic\r\nfeatures.AlgoRace is a special league of car racing where different\r\nteams compete in a country of cities. Cities are numbered through .\r\nEvery two distinct cities in the country are connected with one\r\nbidirectional road. Each competing team should introduce one driver and\r\na set of cars.The competition is held in rounds. In -th round, drivers\r\nwill start at city and finish at city . Drivers are allowed to change\r\ntheir cars at most times. Changing cars can take place in any city in no\r\ntime. One car can be used multiple times in one round, but total number\r\nof changes should not exceed . Drivers can freely choose their path to\r\ndestination.PMP has prepared type of purpose-built cars. Beside for PMP\r\ns driving skills, depending on properties of the car and the road, a car\r\ntraverses each road in each direction in different times. PMP Warriors\r\nwants to devise best strategies of choosing car and roads in each round\r\nto maximize the chance of winning the cup. For each round they want to\r\nfind the minimum time required to finish it.\r\n", "solutions": ["/*\n * Author: code6\n * Created Time:  2012/5/11 0:01:24\n * File Name: D.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n#define out(v) cerr << #v << \": \" << (v) << endl\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntypedef long long ll;\nconst double PI=acos(-1.0);\nconst double eps=1e-11;\n\nint n, m, t;\nint d[65][65][65];\nint ans[65][65][65];\n\nvoid process(int cur)\n{\n    int i, j, k;\n    for (k = 0; k < n; k++) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                    if (i == j || j == k || i == k) {\n                        continue;\n                    }\n                    d[i][j][cur] = min(d[i][j][cur], d[i][k][cur] + d[k][j][cur]);\n                }\n            }\n    }\n}\n\nvoid get_min_all()\n{\n    int i, j, k;\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            int v = d[i][j][0];\n            for (k = 0; k < m; k++) {\n                v = min(v, d[i][j][k]);\n            }\n            ans[i][j][0] = v;\n        }\n    }\n    \n    for (int pass = 1; pass <= n; pass++) {\n        \n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                ans[i][j][pass] = ans[i][j][pass - 1];\n            }\n        }\n        \n        for (k = 0; k < n; k++) {\n            for (i = 0; i < n; i++) {\n                for (j = 0; j < n; j++) {\n                    if (i == j || j == k || i == k) {\n                        continue;\n                    }\n                    if (ans[i][j][pass] > ans[i][k][pass - 1] + ans[k][j][0]) {\n                        ans[i][j][pass] = ans[i][k][pass - 1] + ans[k][j][0];\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &t);\n    int i, j, k;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            for (k = 0; k < n; k++) {\n                scanf(\"%d\", &d[j][k][i]);\n            }\n        }\n        process(i);\n    }\n    \n    get_min_all();\n    \n    int u, v, w;\n    for (i = 0; i < t; i++) {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        u --;\n        v --;\n        w = min(w, n);\n        printf(\"%d\\n\", ans[u][v][w]);\n    }\n    \n    return 0;\n}\n\n"], "input": "", "output": "", "tags": ["dp", "shortest paths"], "dificulty": "1800", "interactive": false}