{"link": "https://codeforces.com//contest/994/problem/F", "problemId": "190664", "problem_idx": "F", "shortId": "994F", "contest_number": "994", "problem_submissions": {"F": [39313692, 39315581, 95930723, 39333904], "D": [39298471, 39300217, 39307900, 39306172, 39303222, 39306617, 39330421, 39308869, 39310792, 39309655, 39306797, 39316533, 39305772, 39310407, 39314015, 39300951, 39309805, 39302653, 39303950, 39306436], "B": [39294915, 39295275, 39295676, 39295849, 39296984, 39296665, 39296958, 39296174, 39296249, 39295589, 39295750, 39299723, 39296783, 39298775, 39295093, 39296348, 39296369, 39296067, 39296627], "A": [39292025, 39292170, 39292210, 39296891, 39292448, 39292868, 39293213, 39292353, 39294071, 39292079, 39292190, 39292131, 39292850, 39293045, 39292213, 39293330, 39292422, 39292084], "C": [39312207, 39297429, 39302694, 39300203, 39302994, 39301715, 39301431, 39300472, 39302324, 39299468, 39310028, 39306138, 39303929, 39297727, 39301261, 39298603, 39300542], "E": [39305109, 39304789, 39310854, 39313649, 39313461, 39330509, 39311502, 39313415, 39314951, 39309721, 39313040, 39314741, 39315937, 39307951]}, "name": "F. Compute Power", "statement": "You need to execute several tasks, each associated with number of\r\nprocessors it needs, and the compute power it will consume.You have\r\nsufficient number of analog computers, each with enough processors for\r\nany task. Each computer can execute up to one task at a time, and no\r\nmore than two tasks total. The first task can be any, the second task on\r\neach computer must use strictly less power than the first. You will\r\nassign between 1 and 2 tasks to each computer. You will then first\r\nexecute the first task on each computer, wait for all of them to\r\ncomplete, and then execute the second task on each computer that has two\r\ntasks assigned.If the average compute power per utilized processor (the\r\nsum of all consumed powers for all tasks presently running divided by\r\nthe number of utilized processors) across all computers exceeds some\r\nunknown threshold during the execution of the first tasks, the entire\r\nsystem will blow up. There is no restriction on the second tasks\r\nexecution. Find the lowest threshold for which it is possible.Due to the\r\nspecifics of the task, you need to print the answer multiplied by 1000\r\nand rounded up.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int MAX = 100005;\n\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint a[MAX];\nint b[MAX];\nll dp1 [5005][55];\nll dp2 [5005][55]; \nconst ll INF = 1000000000000000000;\n// index, # of processors, wiggle room\nmap<int, vector<int> > m;\nmain() {\n\t// freopen(\"a.in\", \"r\", stdin);\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tfor (int i=0; i<n; i++) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i=0; i<n; i++) {\n\t\tcin >> b[i];\n\t}\n\tfor (int i=0; i<n; i++) {\n\t\tm[a[i]].push_back(b[i]); \n\t}\n\tvector<int>xd;\n\tfor (auto i=m.begin(); i!=m.end(); i++) {\n\t\txd.push_back(i->first); \n\t\tsort(m[i->first].rbegin(), m[i->first].rend());\n\t}\n\n\n\tfor (int i=0; i<5005; i++) {\n\t\tfor (int j=0; j<55; j++) {\n\t\t\tdp1[i][j] = dp2[i][j] = INF;\n\t\t}\n\t}\n\tdp1[0][0] = dp2[0][0] = 0;\n\tfor (int i=xd.size()-1; ~i; i--) {\n\t\tint power = xd[i]; \n\t\tvector <int> processors = m[power];\n\t\tvector <ll> pref; \n\t\tpref.push_back(0); \n\t\tfor (int j=0; j<processors.size(); j++){\n\t\t\tif (pref.size()==0) pref.push_back(processors[j]); \n\t\t\telse pref.push_back(pref.back()+processors[j]); \n\t\t}\n\t\tfor (int j=0; j<5005; j++) {\n\t\t\tfor (int z=0; z<55; z++) {\n\t\t\t\tdp2[j][z] = dp1[j][z];\n\t\t\t\tdp1[j][z] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int j=0; j<5005; j++) {\n\t\t\tfor (int z=0; z<55; z++) {\n\t\t\t\tfor (int k=0; k<=processors.size(); k++) {\n\t\t\t\t\t// using k \n\t\t\t\t\tint frees = processors.size() - k;\n\n\t\t\t\t\tll newsum = dp2[j][z] + power * k; // new power sum\n\t\t\t\t\tll newden = j + pref[k]; // new # of procs\n\t\t\t\t\tif (frees > z) { continue; }\n\t\t\t\t\tif (newden > 5000) { continue; }\n\t\t\t\t\tdp1[newden][z+k-frees] = min(dp1[newden][z+k-frees], newsum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = INF; \n\tfor (int i=1; i<5005; i++){\n\t\tfor (int j=0; j<55; j++) {\n\t\t\t\n\t\t\tans = min(ans, dp1[i][j]/(double)i);\n\t\t}\n\t}\n\tcout << fixed << setprecision(0) << ceil(1000*ans) << '\\n'; \n\treturn 0; \n}"], "input": "", "output": "", "tags": ["binary search", "dp"], "dificulty": "2500", "interactive": false}