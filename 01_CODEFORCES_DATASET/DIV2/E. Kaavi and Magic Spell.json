{
    "link": "https://codeforces.com//contest/1337/problem/E",
    "problemId": "594577",
    "problem_idx": "E",
    "shortId": "1337E",
    "contest_number": "1337",
    "problem_submissions": {
        "E": [
            76842870,
            76845509,
            76848463,
            76855120,
            76871772,
            76871576,
            76867010,
            76867076,
            76874436,
            76870671,
            76867604,
            76876698,
            76882617,
            76882550,
            76889050,
            76884760,
            76930491,
            76887431,
            76876593,
            76885516
        ],
        "D": [
            76829839,
            76837363,
            76835449,
            76841174,
            76843833,
            76850412,
            76855631,
            76849402,
            76850850,
            76854483,
            76859745,
            76849751,
            76850303,
            76854768,
            76849549,
            76853724,
            76852989,
            76862421,
            76861609
        ],
        "C": [
            76820484,
            76822812,
            76829351,
            76827518,
            76827629,
            76824463,
            76825343,
            76819564,
            76838456,
            76834820,
            76841486,
            76838012,
            76828806,
            76837386,
            76833609,
            76841320,
            76834504,
            76846500,
            76838445
        ],
        "B": [
            76811181,
            76812533,
            76809888,
            76812317,
            76817367,
            76813548,
            76832505,
            76825951,
            76816251,
            76822230,
            76831299,
            76814459,
            76817110,
            76822249,
            76830068,
            76818198,
            76823690,
            76820084
        ],
        "A": [
            76806546,
            76809169,
            76807699,
            76807193,
            76811060,
            76806430,
            76827568,
            76829567,
            76809786,
            76816500,
            76807750,
            76806611,
            76807034,
            76815382,
            76825211,
            76811951,
            76814300,
            76809280
        ],
        "F": [
            77132223
        ]
    },
    "name": "E. Kaavi and Magic Spell",
    "statement": "Kaavi, the mysterious fortune teller, deeply believes that one\u2019s fate is\r\ninevitable and unavoidable. Of course, she makes her living by\r\npredicting others\u2019 future. While doing divination, Kaavi believes that\r\nmagic spells can provide great power for her to see the future. Kaavi\r\nhas a string T of length m and all the strings with the prefix T are\r\nmagic spells. Kaavi also has a string S of length n and an empty string\r\nA.During the divination, Kaavi needs to perform a sequence of\r\noperations. There are two different operations: Delete the first\r\ncharacter of S and add it at the of A. Delete the first character of S\r\nand add it at the of A.Kaavi can perform n operations. To finish the\r\ndivination, she wants to know the number of different operation\r\nsequences to make A a magic spell (i.e. with the prefix T). As her\r\nassistant, can you help her? The answer might be huge, so Kaavi only\r\nneeds to know the answer modulo 998\r\n,244\r\n,353.Two operation sequences are considered different if they are\r\ndifferent in length or there exists an i that their i-th operation is\r\ndifferent. A substring is a contiguous sequence of characters within a\r\nstring. A prefix of a string S is a substring of S that occurs at the\r\nbeginning of S.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3007;\nconst int M = 998244353;\n\nint n, m, dp[N][N];\nstring s, t;\n\nbool matches(int i, char c)\n{\n    if(i > m)\n        return true;\n    else\n        return t[i - 1] == c;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> s >> t;\n    n = s.size();\n    m = t.size();\n\n    for(int i = 1; i <= n + 1; i++)\n        dp[i][i - 1] = 1;\n    for(int d = 1; d <= n; d++)\n    {\n        char c = s[d - 1];\n        for(int i = 1, j = d; j <= n; i++, j++)\n        {\n            if(matches(i, c))\n            {\n                dp[i][j] = (dp[i][j] + dp[i + 1][j]) % M;\n            }\n            if(matches(j, c))\n            {\n                dp[i][j] = (dp[i][j] + dp[i][j - 1]) % M;\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = m; i <= n; i++)\n    {\n        ans = (ans + dp[1][i]) % M;\n    }\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Kaavi and Magic Spell.json",
    "editorial_link": "https://codeforces.com//blog/entry/76099",
    "editorial": "We can use DP to solve this problem.\n\nLet fi,j\n be the answer when S[0..i?1]\n has already been used and the current A[0..min(i?1,m?1?j)]\n will be in the position [j..min(i+j?1,m?1)]\n after all operations are finished. Specially, fi,m\n means that all characters in the current A\n won't be in the position [j..min(i+j?1,m?1)]\n after all operations are finished.\n\nBy definition, fn,0=1\n and fn,j=0(j?1)\n.\n\nThe state transition:\n\nj=0\nIf i?m\n, A\n has already had the prefix T\n, so you can stop performing operations at any position, there are n?i+1\n positions in total.\n\nOtherwise, only when S[i]=T[i]\n, you can add S[i]\n at the back of A\n, there are fi+1,0\n different operation sequences in this situation.\n\n1?j?m?1\nIf i+j?m\n or S[i]=T[i+j]\n, you can add S[i]\n at the back of A\n, there are fi+1,j\n different operation sequences in this situation.\n\nIf S[i]=T[j?1]\n, you can add S[i]\n at the front of A\n, there are fi+1,j?1\n different operation sequences in this situation.\n\nj=m\nYou can always add S[i]\n at the front/back of A\n in this situation (2fi+1,m\n different operation sequences). However, if S[i]=T[m?1]\n, you can let S[i]\n to match T[m?1]\n (fi+1,m?1\n different operation sequences).\n\nSo, if S[i]=T[m?1]\n, fi,m=2fi+1,m+fi+1,m?1\n. Otherwise, fi,m=2fi+1,m\n.\n\nThe answer is 2(f1,m+?T[i]=S[0]f1,i)\n."
}