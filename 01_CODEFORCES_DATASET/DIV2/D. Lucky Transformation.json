{
    "link": "https://codeforces.com//contest/122/problem/D",
    "problemId": "641",
    "problem_idx": "D",
    "shortId": "122D",
    "contest_number": "122",
    "problem_submissions": {
        "E": [
            804119,
            810208,
            803742,
            804906,
            805053,
            805535,
            805395,
            806278,
            806048,
            805630,
            806062,
            806110,
            807439,
            805646,
            806935,
            805348,
            805292,
            807148,
            803308
        ],
        "D": [
            802482,
            810206,
            802395,
            802956,
            803158,
            802902,
            802962,
            803118,
            803510,
            803885,
            803728,
            803980,
            803776,
            806452,
            804671,
            807608,
            806313,
            807465,
            804059,
            807952
        ],
        "C": [
            800923,
            810203,
            801356,
            801235,
            801284,
            802077,
            801764,
            801779,
            801639,
            801891,
            801899,
            801697,
            801979,
            801645,
            801654,
            802889,
            808508,
            803366,
            802586,
            801728
        ],
        "B": [
            799762,
            810199,
            799636,
            800167,
            799922,
            800682,
            800298,
            799652,
            799602,
            800265,
            800137,
            800018,
            800096,
            799947,
            799741,
            801185,
            801074,
            799786,
            801520
        ],
        "A": [
            799077,
            810197,
            799191,
            799050,
            799146,
            799438,
            799389,
            799108,
            799052,
            799014,
            799373,
            799207,
            799220,
            799284,
            799168,
            799106,
            799481,
            799192,
            799054
        ]
    },
    "name": "D. Lucky Transformation",
    "statement": "Petya has a number consisting of digits without leading zeroes. He\r\nrepresented it as an array of digits without leading zeroes. Let’s call\r\nit . The numeration starts with , starting from the most significant\r\ndigit. Petya wants to perform the following times: find the minimum such\r\nthat and , if is odd, then to assign , otherwise to assign . Note that\r\nif no was found, then the operation counts as completed and the array\r\ndoesn’t change at all.You are given the initial number as an array of\r\ndigits and the number . Help Petya find the result of completing\r\noperations.\r\n",
    "solutions": [
        "#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <int> vi;\ntypedef vector <string> vs;\ntypedef istringstream iss;\ntypedef ostringstream oss;\n\nconst int INF = (int) 1E9 + 5;\nconst ll LINF = (ll) 4E18 + 5;\n\nconst ld PI = acos(-1.0);\nconst ld E = 2.718281828459045L;\n\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, a) for (int i = 0; i < (a); i++)\n#define REPD(i, a) for (int i = ((a) - 1); i >= 0; i--)\n#define FIT(it, v) for (typeof((v).begin())it = (v).begin(); it != (v).end(); ++it)\n#define FITD(it, v) for (typeof((v).rbegin())it = (v).rbegin(); it != (v).rend(); ++it)\n\n#define VAR(a, b) typeof(b) a(b)\n#define ALL(v) (v).begin(), (v).end()\n#define SET(a, x) memset((a), (x), sizeof(a))\n#define SIZE(a) ((int)(a).size())\n\n#define EXIST(a, b) (find(ALL(a), (b)) != (a).end())\n#define SORT(x) sort(ALL(x))\n#define GSORT(x) sort(ALL(x), greater<typeof(*((x).begin()))>())\n#define UNIQUE(v) SORT(v); (v).resize(unique(ALL(v)) - (v).begin())\n#define ENUM(v) FIT(it, (v)) cout << *it << \" \"; cout << endl\n\n#define PF push_front\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n\ntemplate<typename T> T gcd(T a, T b) { return (b == 0) ? abs(a) : gcd(b, a % b); }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<typename T> inline T mod(T a, T b) { return (a % b + b) % b; }\ntemplate<typename T> inline T sqr(T x) { return x * x; }\n\ntemplate<typename T> inline string toString(const T& x) { oss os; os << x; return os.str(); }\ninline ll toInt(const string& s) { iss is(s); ll x; is >> x; return x; }\ninline ld toDouble(const string& s) { iss is(s); ld x; is >> x; return x; }\ninline string toLower(string s) { FIT(it, s) *it = tolower(*it); return s; }\ninline string toUpper(string s) { FIT(it, s) *it = toupper(*it); return s; }\n\nconst char DEBUG_PARAM[] = \"__LOCAL_TESTING\";\n\nconst char IN[] = \"_.in\";\nconst char OUT[] = \"_.out\";\n\ninline void init();\ninline void run();\n\nint ntest = 0, test;\n\nint main(int argc, char* argv[]) {\n\tif (argc > 1 && strcmp(argv[1], DEBUG_PARAM) == 0) {\n\t\tfreopen(IN, \"r\", stdin);\n\t\t//freopen(OUT, \"w\", stdout);\n\t}\n\tinit();\n\tif (ntest == 0) { puts(\"ntest = ?\"); return 0; }\n\tfor (test = 1; test <= ntest; test++) {\n\t\trun();\n\t}\n\treturn 0;\n}\n\ninline void stop() {\n\tntest = test - 1;\n}\n\n/* IMPLEMENTATION */\n\nconst int dx[] = { -1, 0, 0, 1 };\nconst int dy[] = { 0, -1, 1, 0 };\n\nconst ld EPS = 1E-9;\nconst ll MODULE = 1000000007LL;\n\ninline void init() {\n\tntest = 1;\n}\n\nint n, k;\nstring s;\n\ninline void run() {\n\tscanf(\"%d%d\\n\", &n, &k);\n\tgetline(cin, s);\n\ts = \".\" + s;\n\tint i = 0;\n\twhile (1) {\n\t\ti++;\n\t\tif (i > n || k <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (i < n - 1 && (i & 1)) {\n\t\t\tstring a = s.substr(i, 3);\n\t\t\tif (a == \"447\" || a == \"477\") {\n\t\t\t\tif (k & 1) {\n\t\t\t\t\ts[i + 1] = '4' + '7' - s[i + 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i < n && s.substr(i, 2) == \"47\") {\n\t\t\tif (i & 1) {\n\t\t\t\ts[i] = s[i + 1] = '4';\n\t\t\t} else {\n\t\t\t\ts[i] = s[i + 1] = '7';\n\t\t\t}\n\t\t\tk--;\n\t\t}\n\t}\n\ts.erase(0, 1);\n\tputs(s.c_str());\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Lucky Transformation.json",
    "editorial_link": "https://codeforces.com//blog/entry/2956",
    "editorial": "Notice, that if there exits such i that i mod 2 = 0 and di?=?4 and di?+?1?=?7 and di?-?1?=?4 then after that operation there will be a loop. So, let we simple do all operation from left ro right, and, when we will win our loop, just return a rusult (which variates by k mod 2 (k is one that leaves after operation from left side).",
    "hint": []
}