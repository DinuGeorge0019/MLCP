{
    "link": "https://codeforces.com//contest/1372/problem/F",
    "problemId": "665587",
    "problem_idx": "F",
    "shortId": "1372F",
    "contest_number": "1372",
    "problem_submissions": {
        "F": [
            86587331,
            86592445
        ],
        "D": [
            86567204,
            86579473,
            86577327,
            86535735,
            86539756,
            86541547,
            86541810,
            86544261,
            86545902,
            86544858,
            86551552,
            86549456,
            86551379,
            86554398,
            86555103,
            86559228,
            86553301
        ],
        "C": [
            86542450,
            86550447,
            86544146,
            86549498,
            86526578,
            86530081,
            86532018,
            86527267,
            86533550,
            86528779,
            86532078,
            86534770,
            86530142,
            86536030,
            86548674,
            86533586,
            86533762,
            86528487,
            86532205
        ],
        "B": [
            86530649,
            86544843,
            86528066,
            86586370,
            86518220,
            86520050,
            86527028,
            86521440,
            86521451,
            86520560,
            86523901,
            86522899,
            86522046,
            86527358,
            86530942,
            86526972,
            86524542,
            86517410,
            86521410
        ],
        "A": [
            86513990,
            86538518,
            86515960,
            86516941,
            86513491,
            86515289,
            86513521,
            86514849,
            86514076,
            86513724,
            86514041,
            86514826,
            86513853,
            86514635,
            86523362,
            86514036,
            86514079,
            86513422,
            86513617
        ],
        "E": [
            86584231,
            86531273,
            86583888,
            86618428,
            86570603
        ]
    },
    "name": "F. Omkar and Modes",
    "statement": "Ray lost his array and needs to find it by asking Omkar. Omkar is\r\nwilling to disclose that the array has the following qualities: The\r\narray has n (1\r\nle n\r\nle 2\r\ncdot 10^5) elements. Every element in the array a_i is an integer in the\r\nrange 1\r\nle a_i\r\nle 10^9. The array is sorted in nondecreasing order. Ray is allowed to\r\nsend Omkar a series of queries. A query consists of two integers, l and\r\nr such that 1\r\nle l\r\nle r\r\nle n. Omkar will respond with two integers, x and f. x is the mode of\r\nthe subarray from index l to index r inclusive. The mode of an array is\r\ndefined by the number that appears the most frequently. If there are\r\nmultiple numbers that appear the most number of times, the smallest such\r\nnumber is considered to be the mode. f is the amount of times that x\r\nappears in the queried subarray.The array has k (1\r\nle k\r\nle\r\nmin(25000,n)) distinct elements. However, due to Ray’s sins, Omkar will\r\nnot tell Ray what k is. Ray is allowed to send at most 4k queries.Help\r\nRay find his lost array.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef pair<int ,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef double rl;\n\ntypedef pii int2;\ntypedef tuple<int, int, int>           int3;\ntypedef tuple<int, int, int, int>      int4;\ntypedef tuple<int, int, int, int, int> int5;\n\ntypedef pll ll2;\ntypedef tuple<ll, ll, ll>         ll3;\ntypedef tuple<ll, ll, ll, ll>     ll4;\ntypedef tuple<ll, ll, ll, ll, ll> ll5;\n\n#define g0(x) get<0>(x)\n#define g1(x) get<1>(x)\n#define g2(x) get<2>(x)\n#define g3(x) get<3>(x)\n#define g4(x) get<4>(x)\n\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<ll> vll;\ntypedef vector<pll> vll_ll;\ntypedef vector<vi> vvi;\ntypedef vector<vii> vvii;\ntypedef vector<vll> vvll;\ntypedef vector<vll_ll> vvll_ll;\n\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define xx first\n#define yy second\n\n#define FOR(i,N) for(int i=0; i<N; i++)\n\n#define popc __builtin_popcountll\n// #define popc __builtin_popcount\n\ntemplate<typename A>\nstring to_string(A* ptr)\n{\n    stringstream ss; ss << \"0x\" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr;\n    return ss.str();\n}\n\nstring to_string(char c)\n{\n    return ((string)\"'\"+c)+ \"'\";\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#if !ONLINE_JUDGE && 1\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n\nint n;\npii query(int l, int r)\n{\n    cout << \"? \" << l << ' ' << r << '\\n';\n    cout.flush();\n\n    int x, f;\n    cin >> x >> f;\n    return {x, f};\n}\n\nconst int MX=2e5+99;\nint a[MX];\nconst int DUNNO=-1;\nconst int BOUND=1'000'000'000;\n\nvoid guess()\n{\n    cout << \"! \";\n    for(int i=1; i<=n; i++)\n    {\n        assert(1<=a[i] && a[i]<=BOUND);\n        cout << a[i] << ' ';\n    }\n    cout << '\\n';\n    cout.flush();\n}\n\nvoid solve(int L, int R)\n{\n    //dbg(L, R);\n    int aL=a[L], aR=a[R];\n\n    if(aL==aR)\n    {\n        for(int i=L+1; i<R; i++) a[i]=aL;\n        return;\n    }\n\n    if(L+1 == R) return;\n\n    auto [x, f]=query(L, R);\n    if(x==aL)\n    {\n        for(int i=1; i<f; i++) a[L+i]=aL;\n        if(L+f<R)\n        {\n            a[L+f]=query(L+f, L+f).xx;\n            solve(L+f, R);\n        }\n    }\n    else if(x==aR)\n    {\n        for(int i=1; i<f; i++) a[R-i]=aR;\n        if(L<R-f)\n        {\n            a[R-f]=query(R-f, R-f).xx;\n            solve(L, R-f);\n        }\n    }\n    else\n    {\n        //TODO;\n        a[L+f-1]=query(L+f-1, L+f-1).xx;\n        solve(L, L+f-1);\n        solve(L+f-1, R);\n    }\n}\n\nvoid solve()\n{\n    for(int i=1; i<=n; i++) a[i]=DUNNO;\n    a[1]=query(1,1).xx;\n    a[n]=query(n,n).xx;\n\n    solve(1, n);\n\n    guess();\n}\n\nint main()\n{\n#if !ONLINE_JUDGE && 0\n    freopen(\"F.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n#if 0\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n#endif\n\n    //int TT;\n#if 0\n    cin >> TT;\n#else\n    //TT=1;\n#endif\n    /*\n    for(int ttt=0; ttt<TT; ttt++)\n    {\n\n    }\n    */\n    cin >> n;\n    solve();\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "divide and conquer",
        "interactive"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Omkar and Modes.json",
    "editorial_link": "https://codeforces.com//blog/entry/79974",
    "editorial": "For both solutions, we must first make the critical observation that\r\nbecause the array is sorted, all occurrences of a value occur as a\r\nsingle contiguous block.We will define a recursive function which will\r\nuse queries to determine the array. We will also store an auxiliary list\r\nof previously returned query values not the queries themselves, but only\r\nthe values returned, so that we know that if is in the list then some\r\nprevious query revealed that there were instances of in some query, and\r\nthat we havenât already determined exactly where in the array those\r\ninstances of are.The execution of will proceed as follows: first, query\r\nthe interval , and let the result be . If there exists some previous\r\nquery result in our auxiliary list, then we will guarantee by details\r\nyet to be explained of that the interval that produced that result\r\ncontained and that no part of those occurrences of occurred to the left\r\nof . This allows us to exactly determine the location of those\r\noccurrences of . We mark these occurrences in our answer, and then\r\nremove from our auxiliary list and add . If is not entirely composed of\r\noccurrences of , then the remaineder of the interval must be for some ,\r\nand in that case we then call .If there does not exist some previous\r\nquery result in our auxiliary list, then we add to the list and do as\r\nfollows: while the exact locations of those occurrences of have not been\r\ndetermined, call , where is the leftmost index in which has not yet been\r\ndetermined. Once those locations have been determined, call .To\r\ndetermine the entire array we simply call . It is clear that this will\r\ncorrectly determine the array. We can see that it uses at most queries\r\nas follows: for each block of integers of the same value represented by\r\na query result that we add to our auxiliary list, we use queries to\r\ndetermine the exact location of those integers: one when added to the\r\nlist, and one when removing from the list. This does not guarantee that\r\nthe algorithm uses queries because some calls of can split a block of\r\nintegers of the same value into two blocks. However, we can show that\r\nany blocks formed by splitting a single block into two cannot be further\r\nsplit as they occur either at the beginning or end of a queried interval\r\n(the full proof is left as an exercise to the reader), so each distinct\r\nvalue in the array will produce at most blocks, each of which will be\r\ndetermined in queries, meaning that the algorithm uses at most\r\nqueries.Side note: you can in fact further show that the algorithm\r\nalways uses at most queries and that there exists an array for all which\r\nforces the algorithm to use queries.Again, we will define a recursive\r\nfunction , but this time we will only additionally maintain the\r\ncurrently known values in the answer.The execution of will proceed as\r\nfollows: first, query the interval and let the result be . Then, find\r\nthe largest integer such that and then for all in that are multiples of\r\n, determine the value located at index , either by querying or by using\r\nalready known values.By the definition of , there will be either one or\r\ntwo such indexes such that the values at those indexes are equal to .If\r\nthere is only one such index, let this index be . Make two queries and\r\nand let the results of these queries be and respectively. We can show\r\nthat at least one of and must be equal to . If , then we see that the\r\noccurrences of must be precisely the interval . If , then we see that\r\nthe occurrences of must be precisely the interval .If there are two such\r\nindexes, let these indexes be and so that . Note that it must be true\r\nthat . Make a single query and let the result be . We can show that must\r\nbe equal to , so we can then conclude that the occurrences fo must be\r\nprecisely the interval .After the interval containing the occurrences of\r\nhas been determined, mark these occurrences in our answer and then call\r\non the remaining not-fully-determined interval to the left if it exists\r\nand the remaining not-fully-determined interval to the right if it\r\nexists.To determine the entire array we simply call . It is clear that\r\nthis will correctly determine the array. We can see that it uses at most\r\nqueries as follows: Each call to finds all occurrences of a distinct\r\nvalue . We will refer to the queries of single indexes that were\r\nmultiples of some as -queries. For each , we perform the following\r\nqueries other than -queries: the first query in , and then either two\r\nadditional queries if only one -query was found to equal , or a single\r\nadditional query if two -queries were found to equal . This means that\r\nif we group each -query with the value that it equaled, then we will\r\nhave performed exactly queries for each , and so the algorithm must\r\ntherefore use exactly queries.\r\n",
    "hint": []
}