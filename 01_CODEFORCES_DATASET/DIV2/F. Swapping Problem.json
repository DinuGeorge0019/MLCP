{
    "link": "https://codeforces.com//contest/1513/problem/F",
    "problemId": "954483",
    "problem_idx": "F",
    "shortId": "1513F",
    "contest_number": "1513",
    "problem_submissions": {
        "F": [
            112704242,
            112708449,
            112692430,
            112693367,
            112715319,
            112703491,
            112694811,
            127489679,
            112714894,
            112706130
        ],
        "E": [
            112694829,
            112692532,
            112741611,
            112740521,
            112688817,
            112693970,
            112694924,
            112695544,
            112697383,
            112699670,
            112696818,
            112699923,
            112700793
        ],
        "D": [
            112684276,
            112682550,
            112679745,
            112679949,
            112677500,
            112683697,
            112682474,
            112682520,
            113011471,
            113011359,
            113011120,
            113011016,
            113009370,
            112680944,
            112706307,
            112684078,
            112683480,
            112687888,
            112686211,
            112688484,
            112694241
        ],
        "C": [
            112675074,
            112673956,
            112673377,
            112672093,
            112671463,
            112675182,
            112671664,
            112676030,
            112671692,
            112674449,
            112673953,
            112672990,
            112673437,
            112678260,
            112672998,
            112674969
        ],
        "B": [
            112671476,
            112670228,
            112670172,
            112670205,
            112668144,
            112670061,
            112665513,
            112670183,
            112667846,
            112669295,
            112667797,
            112667641,
            112669249,
            112668199,
            112668800,
            112667109
        ],
        "A": [
            112663904,
            112665049,
            112664695,
            112668785,
            112662814,
            112664430,
            112662730,
            112664013,
            112662970,
            112664151,
            112662873,
            112663063,
            112663560,
            112664683,
            112663477,
            112662816
        ]
    },
    "name": "F. Swapping Problem",
    "statement": "You are given 2 arrays a and b, both of size n. You can swap two\r\nelements in b at most (or leave it as it is), and you are required to\r\nminimize the value\r\nsum_{i}|a_{i}-b_{i}|.Find the minimum possible value of this sum.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int N = 200010;\nconst int M = 200010;\nconst int mod = 1e9 + 7;\n\n\n\nint a[N], b[N];\nvoid solve() {\n    int n;\n    scanf(\"%d\", &n);\n    long long sum = 0;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &a[i]);\n    }\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &b[i]);\n        sum += abs(a[i] - b[i]);\n    }\n    vector<pii> v1, v2;\n    for (int i = 0; i < n; ++i) {\n        if (a[i] < b[i]) v1.emplace_back(a[i], b[i]);\n        if (a[i] > b[i]) v2.emplace_back(b[i], a[i]);\n    }\n    sort(v1.begin(), v1.end());\n    sort(v2.begin(), v2.end());\n    long long ans = sum;\n    int j = 0, mx = 0;\n    for (int i = 0; i < v1.size(); ++i) {\n        while (j < v2.size() && v2[j].first <= v1[i].first) {\n            mx = max(mx, v2[j].second);\n            j++;\n        }\n        if (mx) ans = min(ans, sum + 2 * v1[i].first - 2 * min(mx, v1[i].second));\n    }\n    j = 0;\n    mx = 0;\n    for (int i = 0; i < v2.size(); ++i) {\n        while (j < v1.size() && v1[j].first <= v2[i].first) {\n            mx = max(mx, v1[j].second);\n            j++;\n        }\n        if (mx) ans = min(ans, sum + 2 * v2[i].first - 2 * min(mx, v2[i].second));\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n#ifdef FLOWMASTER\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Swapping Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/89550",
    "editorial": "Let\u00e2\u0080\u0099s form 2 sets and . contains those indices such that < and contains\r\nthose indices such that > . We call a segment , as and Let break this\r\nQuestion into a series of observation: The answer will reduce by\r\nswapping two indexes and in only if: If an index belongs to X and\r\nbelongs to Y. Segment and overlap. Based on previous observation, we are\r\nnow left with only a few cases. WLOG we can fix and , and see where our\r\nindex be located. and and and and We can see that, in each of the cases\r\nour final answer changes by, So, the algorithm would like this: where is\r\na member of X. where is a member of Y. gives the maximum value of such\r\nthat , where is a member of . can be implemented using a map, segment\r\ntree, or two-pointer approach.The overall complexity of the solution\r\nwould be O(n*lg(n))\r\n"
}