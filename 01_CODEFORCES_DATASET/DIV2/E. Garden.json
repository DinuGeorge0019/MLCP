{
    "link": "https://codeforces.com//contest/152/problem/E",
    "problemId": "943",
    "problem_idx": "E",
    "shortId": "152E",
    "contest_number": "152",
    "problem_submissions": {
        "B": [
            1212565,
            1207677,
            1207042,
            1206882,
            1206900,
            1207302,
            1207825,
            1206753,
            1207786,
            1206733,
            1206745,
            1206774,
            1207750,
            1206760,
            1207729,
            1208102,
            1207969,
            1207121
        ],
        "D": [
            1211886,
            1212861,
            1219761,
            1213345,
            1213307,
            1213255
        ],
        "E": [
            1211066,
            1211301,
            1211747,
            1212613,
            1212600,
            1217294
        ],
        "C": [
            1206348,
            1207801,
            1207657,
            1206181,
            1206349,
            1208424,
            1207196,
            1206520,
            1207288,
            1207467,
            1207400,
            1207032,
            1207706,
            1207030,
            1206886,
            1207024,
            1207629
        ],
        "A": [
            1205923,
            1205987,
            1205997,
            1205917,
            1205971,
            1205996,
            1206021,
            1205974,
            1206016,
            1205930,
            1205981,
            1205912,
            1205927,
            1206449,
            1206138,
            1206011,
            1205963
        ]
    },
    "name": "E. Garden",
    "statement": "Vasya has a very beautiful country garden that can be represented as an\r\nrectangular field divided into squares. One beautiful day Vasya\r\nremembered that he needs to pave roads between important squares that\r\ncontain buildings. To pave a road, he can cover some squares of his\r\ngarden with concrete.For each garden square we know number that\r\nrepresents the number of flowers that grow in the square with\r\ncoordinates . When a square is covered with concrete, all flowers that\r\ngrow in the square die.Vasya wants to cover some squares with concrete\r\nso that the following conditions were fulfilled: all important squares\r\nshould necessarily be covered with concrete from each important square\r\nthere should be a way to any other important square. The way should go\r\nbe paved with concrete-covered squares considering that neighboring\r\nsquares are squares that have a common side the total number of dead\r\nplants should be minimum As Vasya has a rather large garden, he asks you\r\nto help him.\r\n",
    "solutions": [
        "#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\nstring s[110];\nconst int mod=1000000007;\n\nint n, m, k;\n\nPII pre[1<<7][220];\nint dp[1<<7][220];\n\nint val[220][220];\n\nint id[220][220];\nPII p[220];\n\nqueue<int> q;\nbool inq[1<<7][220];\n\nvoid update(int a, int b, int val, int pa, int pb){\n\tif( dp[a][b]<=val ) return;\n\tdp[a][b]=val;\n\tpre[a][b]=MP(pa, pb);\n\tif( inq[a][b]==false ){\n\t\tinq[a][b]=true;\n\t\tq.push(a);\n\t\tq.push(b);\n\t}\n}\nint dir[4][2]={0,1, 1,0, 0,-1, -1,0};\nbool ill(int i, int j){\n\treturn i>=0 && i<n && j>=0 && j<m;\n}\n\nchar mat[220][220];\nbool vst[1<<7][220];\nvoid dfs(int a, int b){\n\t\n\tif( vst[a][b] ) return;\n\tvst[a][b]=true;\n\tint x=p[b].ff, y=p[b].ss;\n\tmat[x][y]='X';\n\tint pa=pre[a][b].ff, pb=pre[a][b].ss;\n\t\n\t//printf(\"a=%d b=%d x=%d y=%d pa=%d pb=%d\\n\", a, b, x, y, pa, pb);\n\tif( pb<0 ) return;\n\tif( pb==b ){\n\t\tdfs(pa, pb);\n\t\tdfs(a-pa, pb);\n\t}else{\n\t\tdfs(pa, pb);\n\t}\n}\n\nint main(){\n\t//cout<<(1LL<<31)*1000000000<<endl;\n\twhile( scanf(\"%d %d %d\", &n, &m, &k)!=EOF ){\n\t\tint cnt=0;\n\t\trep(i, 0, n) rep(j, 0, m){\n\t\t\tscanf(\"%d\", val[i]+j);\n\t\t\tid[i][j]=cnt;\n\t\t\tp[cnt++]=MP(i, j);\n\t\t}\n\t\tclr(dp, 0x3f);\n\t\tclr(inq, false);\n\t\trep(i, 0, k){\n\t\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\t\tx--; y--;\n\t\t\tupdate(1<<i, id[x][y], val[x][y], -1, -1);\n\t\t}\n\t\twhile( !q.empty() ){\n\t\t\tint a=q.front(); q.pop();\n\t\t\tint b=q.front(); q.pop();\n\t\t\tinq[a][b]=false;\n\t\t\t//chu kou\n\t\t\trep(in, 0, 4){\n\t\t\t\tint tx=p[b].ff+dir[in][0];\n\t\t\t\tint ty=p[b].ss+dir[in][1];\n\t\t\t\tif( ill(tx, ty)==false ) continue;\n\t\t\t\tupdate(a, id[tx][ty], dp[a][b]+val[tx][ty], a, b);\n\t\t\t}\n\t\t\tint tt=(1<<k)-1 - a;\n\t\t\tfor(int s=tt;s;s=(s-1)&tt){\n\t\t\t\tupdate(a|s, b, dp[a][b]+dp[s][b]-val[ p[b].ff ][ p[b].ss ], a, b);\n\t\t\t}\n\t\t}\n\t\tint mi=1<<30;\n\t\tint b;\n\t\trep(j, 0, cnt) {\n\t\t\tif( dp[(1<<k)-1][j]<mi ){\n\t\t\t\tmi=dp[(1<<k)-1][j];\n\t\t\t\tb=j;\n\t\t\t} \n\t\t}\n\t\tprintf(\"%d\\n\", mi);\n\t\tclr(vst, false);\n\t\tclr(mat, '.');\n\t\tdfs((1<<k)-1, b);\n\t\trep(i, 0, n) {\n\t\t\trep(j, 0, m) putchar(mat[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t}\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Garden.json",
    "editorial_link": "https://codeforces.com//blog/entry/3926",
    "editorial": "The solution of this problem is based on dynamic programming. the value\r\nof the minimum correct concrete cover, if we consider as important\r\nelements only elements of the mask , and there are additionally covered\r\nthe vertex of the field. There are two types of transfers. First of all\r\nwe can, as if to cut coverage on the vertex . Then you need to go\r\nthrough subpattern of vertex , which will go to the left coverage and\r\nmake an optimizing transfer. Update with the value . Second, perhaps in\r\nthe vertex in the optimal coverage mask , which covers the vertex , you\r\ncan not make the cut separating the set of vertices. In this case, this\r\nvertex forms something a kind of <>. And there a vertex exists, on which\r\nwe can make the cut, with the whole shortest path from a vertex to\r\nbelongs to the optimal coverage. Let\u00e2\u0080\u0099s precalculate the shortest paths\r\nbetween all pairs of cells. Now to make this transition, we should count\r\nthe value of dynamics for all vertices only on the basis of the first\r\ntransition. Now you can make the second transition. For all , , update\r\nthe value of . Let\u00e2\u0080\u0099s process separately state in which exactly one bit\r\nin the mask, and the vertex which corresponding to this bit is equal to\r\n. In this case the answer is equal to , of course. Thus, each solution\r\nis obtained for the .\r\n"
}