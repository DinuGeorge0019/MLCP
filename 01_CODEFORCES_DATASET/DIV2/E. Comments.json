{
    "link": "https://codeforces.com//contest/747/problem/E",
    "problemId": "85396",
    "problem_idx": "E",
    "shortId": "747E",
    "contest_number": "747",
    "problem_submissions": {
        "F": [
            23126704,
            23217267,
            52339523,
            52339464,
            23341357,
            23340816,
            23578865
        ],
        "E": [
            23125674,
            23121557,
            23122370,
            23123161,
            23124718,
            23124657,
            23124656,
            23123981,
            23122979,
            23122492,
            23124234,
            23124489,
            23124720,
            23123438,
            23122625,
            23124699,
            23124636,
            23124788
        ],
        "C": [
            23123534,
            23119516,
            23119605,
            23119464,
            23119789,
            23119774,
            23120245,
            23120834,
            23119880,
            23120172,
            23121050,
            23121104,
            23120094,
            23119293,
            23120587,
            23121256,
            23120349,
            23120870
        ],
        "D": [
            23122972,
            23121671,
            23121446,
            23122129,
            23122827,
            23122607,
            23123052,
            23122954,
            23121673,
            23124427,
            23123104,
            23123270,
            23123828,
            23121861,
            23124873,
            23123416,
            23123688,
            23123414
        ],
        "B": [
            23118814,
            23120201,
            23118777,
            23118662,
            23118893,
            23118919,
            23119154,
            23119419,
            23124358,
            23119396,
            23119237,
            23119831,
            23119076,
            23124567,
            23119518,
            23119781,
            23119199,
            23119454
        ],
        "A": [
            23117745,
            23119565,
            23117723,
            23117761,
            23117767,
            23117895,
            23117920,
            23118535,
            23123976,
            23117977,
            23119603,
            23118496,
            23117834,
            23123993,
            23117965,
            23119512,
            23118198,
            23118178
        ]
    },
    "name": "E. Comments",
    "statement": "A rare article in the Internet is posted without a possibility to\r\ncomment it. On a Polycarp’s website each article has comments feed.Each\r\ncomment on Polycarp’s website is a non-empty string consisting of\r\nuppercase and lowercase letters of English alphabet. Comments have\r\ntree-like structure, that means each comment except root comments\r\n(comments of the highest level) has exactly one parent comment.When\r\nPolycarp wants to save comments to his hard drive he uses the following\r\nformat. Each comment he writes in the following format: at first, the\r\ntext of the comment is written; after that the number of comments is\r\nwritten, for which this comment is a parent comment (i. e. the number of\r\nthe replies to this comments); after that the comments for which this\r\ncomment is a parent comment are written (the writing of these comments\r\nuses the same algorithm). All elements in this format are separated by\r\nsingle comma. Similarly, the comments of the first level are separated\r\nby comma.For example, if the comments look like: then the first comment\r\nis written as \"\", the second is written as \"\", the third comment is\r\nwritten as \"\". The whole comments feed is written as: \"\". For a given\r\ncomments feed in the format specified above print the comments in a\r\ndifferent format: at first, print a integer the maximum depth of nesting\r\ncomments; after that print lines, the -th of them corresponds to nesting\r\nlevel ; for the -th row print comments of nesting level in the order of\r\ntheir appearance in the Policarp’s comments feed, separated by space.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define ff first\n#define ss second\nusing namespace std;\nconst int N=2000005;\nconst int inf=1e9+7;\ntypedef long long ll;\ntypedef long double lb;\ninline void read(int &x){x=0; char ch=getchar();while(ch<'0') ch=getchar();while(ch>='0'){x=x*10+ch-48; ch=getchar();}}\n//------------------------------------------head---------------------------------------------------//\nchar s[N];\nstring ot;\nstring ans[N];\nint to[N],head[N],nxt[N],e,dep[N],vt[N];\npair<int,int> st[N];\nint top;\nstring ap[N];\ninline void init()\n{\n\tmemset(head,-1,sizeof(head));\n\te=0;\n}\nint aaa;\nvoid dfs(int x,int d)\n{\n\tdep[x]=d; aaa=max(aaa,d);\n\tfor(int i=head[x];i+1;i=nxt[i]) dfs(to[i],d+1);\n}\ninline void add_edge(int x,int y){to[e]=y; nxt[e]=head[x]; head[x]=e++;}\nint main()\n{\n\tscanf(\"%s\",s); init();\n\tios::sync_with_stdio(false);\n\tint len=strlen(s);\n\tint n=0;\n\trep(i,0,len-1)\n\t{\n\t\tint j=i; while(s[j]!=',') j++;\n\t\tn++; ans[n]=\"\"; rep(k,i,j-1) ans[n]+=s[k];\n\t\tj++; int rp=0; while(s[j]!=',' && j<len)\n\t\t{\n\t\t\trp=rp*10+s[j]-'0';\n\t\t\tj++;\n\t\t}\n\t\tif(top)\n\t\t{\n\t\t\tst[top].ff--;\n\t\t\tadd_edge(st[top].ss,n); vt[n]=1;\n\t\t\tif(!st[top].ff) top--;\n\t\t}\n\t\tif(rp) st[++top]=make_pair(rp,n);\n\t\ti=j;// printf(\"Case 0:%d %d\\n\",i,rp);\n\t}\n\trep(i,1,n)if(!vt[i]) dfs(i,1);\n\trep(i,1,n)\n\t{\n\t\tap[dep[i]]+=\" \";\n\t\tap[dep[i]]+=ans[i];\n\t}\n\tcout<<aaa<<endl;\n\trep(i,1,aaa)\n\t{\n\t\tint lp=ap[i].length(); ot=\"\";\n\t\trep(j,1,lp-1) ot+=ap[i][j];\n\t\tcout<<ot<<endl;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "expression parsing",
        "implementation",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Comments.json",
    "editorial_link": "https://codeforces.com//blog/entry/49171",
    "editorial": "Let is a global variable equals to the current position in the given\r\nstring. To solve we can use recursive function , means that in the\r\ncurrent moment we are on the level of replies and there is comments on\r\nthis level. Than we need iterate by from 1 to and on each iteration we\r\nwill make the following: read from the position comment, add this\r\ncomment to the answer for level and than read the number of it children\r\n. After that will in the beginning of the first child of this comment\r\nand we need to run . For the higher level we can put in big number and\r\nreturn from the function in the moment when will become equals to the\r\nlength of the given string.\r\n",
    "hint": []
}