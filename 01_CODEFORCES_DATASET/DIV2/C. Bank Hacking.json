{
    "link": "https://codeforces.com//contest/796/problem/C",
    "problemId": "102474",
    "problem_idx": "C",
    "shortId": "796C",
    "contest_number": "796",
    "problem_submissions": {
        "D": [
            26270676,
            26268879,
            26272464,
            26267846,
            26271244,
            26271502,
            26279976,
            26280757,
            26270905,
            26273570,
            26272084,
            26278210,
            26277165,
            26274914,
            26273555,
            26270674,
            26274828,
            26272225,
            26276256,
            26275870
        ],
        "C": [
            26266928,
            26275839,
            26289710,
            26263867,
            26268031,
            26268145,
            26268959,
            26275805,
            26276716,
            26267202,
            26282722,
            26266268,
            26273046,
            26271604,
            26307139,
            26307124,
            26307117,
            26306972,
            26268576,
            26276501,
            26270809,
            26275985,
            26270211,
            26272901
        ],
        "B": [
            26260444,
            26260714,
            26260928,
            26268179,
            26259754,
            26260202,
            26259813,
            26260983,
            26261840,
            26260679,
            26259761,
            26261074,
            26260940,
            26259972,
            26266557,
            26259771,
            26262157,
            26259891,
            26263590,
            26260396
        ],
        "A": [
            26258377,
            26258938,
            26258411,
            26258195,
            26258231,
            26258560,
            26258094,
            26258499,
            26258460,
            26258203,
            26258087,
            26258420,
            26258693,
            26258275,
            26258381,
            26258161,
            26258669,
            26258379,
            26260347,
            26258265
        ],
        "E": [
            26280397,
            26347598,
            26308967,
            26308953
        ],
        "F": [
            58542353
        ]
    },
    "name": "C. Bank Hacking",
    "statement": "Although Inzane successfully found his beloved bone, Zane, his owner,\r\nhas yet to return. To search for Zane, he would need a lot of money, of\r\nwhich he sadly has none. To deal with the problem, he has decided to\r\nhack the banks. There are banks, numbered from to . There are also wires\r\nconnecting the banks. All banks are initially . Each bank also has its\r\ninitial strength: bank has initial strength .Let us define some keywords\r\nbefore we proceed. Bank and bank are if and only if there exists a wire\r\ndirectly connecting them. Bank and bank are if and only if there exists\r\nan bank such that bank and bank are and bank and bank are .When a bank\r\nis hacked, it becomes (and no longer ), and other banks that are or to\r\nit have their strengths increased by .To start his plan, Inzane will\r\nchoose a bank to hack first. Indeed, the strength of such bank must not\r\nexceed the strength of his computer. After this, he will repeatedly\r\nchoose some bank to hack next until all the banks are hacked, but he can\r\ncontinue to hack bank if and only if all these conditions are met: Bank\r\nis . That is, bank is not hacked yet. Bank is to some bank. The strength\r\nof bank is less than or equal to the strength of Inzane\u2019s computer.\r\nDetermine the minimum strength of the computer Inzane needs to hack all\r\nthe banks.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a[300020];\nint b[300020];\nint c1[300020], cnt1;\nint c2[300020], cnt2;\nint n, x, y;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tint ans = b[1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tans = max(ans, b[i]);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tint shabi = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (ans == b[i]) {\n\t\t\tc1[i]++;\n\t\t\tfor (int j: a[i]) {\n\t\t\t\tc1[j]++;\n\t\t\t}\n\t\t\tcnt1++;\n\t\t\tshabi = i;\n\t\t}\n\t\tif (ans == b[i] + 1) {\n\t\t\tc2[i]++;\n\t\t\tfor (int j: a[i]) {\n\t\t\t\tc2[j]++;\n\t\t\t}\n\t\t\tcnt2++;\n\t\t}\n\t}\n\tint m1 = 0;\n\tint m2 = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tm1 = max(m1, c1[i]);\n\t\tm2 = max(m2, c2[i]);\n\t}\n\tif (cnt1 == 1 && c2[shabi] == cnt2) {\n\t\tprintf(\"%d\\n\", ans);\n\t} else if (m1 == cnt1) {\n\t\tprintf(\"%d\\n\", ans + 1);\n\t} else {\n\t\tprintf(\"%d\\n\", ans + 2);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dp",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Bank Hacking.json",
    "editorial_link": "https://codeforces.com/blog/entry/51527",
    "editorial": "First, note that the input graph is a tree.Let be the greatest value of\r\n(that is, ). Observe that the answer can be , , or only.Why? It is\r\nbecause each bank s strength can be increased at most twice, once by a\r\nneighboring bank, and once by a semi-neighboring bank. So the strength\r\nrequired to hack bank is at most , regardless of the sequence of banks\r\nyou choose to hack.Now, suppose is the first bank we would hack first.\r\nWe would need a computer with strength at least to hack it. Let the\r\nneighboring banks of be . We would need a computer with strength at\r\nleast to hack those banks. And for each bank not yet hacked, we can hack\r\nthem with a computer with strength at least .For simplicity, add to all\r\nthe banks strengths. Let s maintain a map data structure to keep track\r\nof number of times some value of strength occurs. Again, suppose we\r\nwould start by hacking bank . Now, we would need a computer with\r\nstrength at least to hack it. For the neighboring banks , it would be .\r\nFor other banks , it would be . For a fixed bank , you can iterate\r\nthrough its neighboring banks, and update the map data structure\r\naccordingly. Keep track of the maximum value that occurs, and update the\r\nanswer.We can simply iterate through banks to start with, and get the\r\nfinal answer.But wait. Won t it work in or something like that?No. Let s\r\nanalyze the runtime carefully. (You can skip this if you know why. This\r\nis for beginners.)Suppose we choose bank to start with. We have to\r\niterate through its neighboring banks. The number of the banks\r\nneighboring to is equal to the degree of bank . We would need operations\r\nfor bank .By iterating through all possible from to , we will perform\r\noperations. You can see that if there are edges in a graph, the degrees\r\nof all nodes sum to . Trees have edges, so . Therefore, we need to\r\nperform only operations. However, each operation involves the map data\r\nstructure, so the overall runtime is . Be aware that the use of hash map\r\ncould bring the runtime to .Looking more closely, we can also keep track\r\nof the occurrences of only and , and no other values. So, although not\r\nrequired to get AC, we can get rid of the map data structure, and\r\ntherefore eliminate the logarithmic factor.The official solution\r\nprovided here runs in .\r\n"
}