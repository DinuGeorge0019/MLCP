{"link": "https://codeforces.com//contest/796/problem/C", "problemId": "102474", "problem_idx": "C", "shortId": "796C", "contest_number": "796", "problem_submissions": {"D": [26270676, 26268879, 26272464, 26267846, 26271244, 26271502, 26279976, 26280757, 26270905, 26273570, 26272084, 26278210, 26277165, 26274914, 26273555, 26270674, 26274828, 26272225, 26276256, 26275870], "C": [26266928, 26275839, 26289710, 26263867, 26268031, 26268145, 26268959, 26275805, 26276716, 26267202, 26282722, 26266268, 26273046, 26271604, 26307139, 26307124, 26307117, 26306972, 26268576, 26276501, 26270809, 26275985, 26270211, 26272901], "B": [26260444, 26260714, 26260928, 26268179, 26259754, 26260202, 26259813, 26260983, 26261840, 26260679, 26259761, 26261074, 26260940, 26259972, 26266557, 26259771, 26262157, 26259891, 26263590, 26260396], "A": [26258377, 26258938, 26258411, 26258195, 26258231, 26258560, 26258094, 26258499, 26258460, 26258203, 26258087, 26258420, 26258693, 26258275, 26258381, 26258161, 26258669, 26258379, 26260347, 26258265], "E": [26280397, 26347598, 26308967, 26308953], "F": [58542353]}, "name": "C. Bank Hacking", "statement": "Although Inzane successfully found his beloved bone, Zane, his owner,\r\nhas yet to return. To search for Zane, he would need a lot of money, of\r\nwhich he sadly has none. To deal with the problem, he has decided to\r\nhack the banks. There are banks, numbered from to . There are also wires\r\nconnecting the banks. All banks are initially . Each bank also has its\r\ninitial strength: bank has initial strength .Let us define some keywords\r\nbefore we proceed. Bank and bank are if and only if there exists a wire\r\ndirectly connecting them. Bank and bank are if and only if there exists\r\nan bank such that bank and bank are and bank and bank are .When a bank\r\nis hacked, it becomes (and no longer ), and other banks that are or to\r\nit have their strengths increased by .To start his plan, Inzane will\r\nchoose a bank to hack first. Indeed, the strength of such bank must not\r\nexceed the strength of his computer. After this, he will repeatedly\r\nchoose some bank to hack next until all the banks are hacked, but he can\r\ncontinue to hack bank if and only if all these conditions are met: Bank\r\nis . That is, bank is not hacked yet. Bank is to some bank. The strength\r\nof bank is less than or equal to the strength of Inzane\u2019s computer.\r\nDetermine the minimum strength of the computer Inzane needs to hack all\r\nthe banks.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a[300020];\nint b[300020];\nint c1[300020], cnt1;\nint c2[300020], cnt2;\nint n, x, y;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tint ans = b[1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tans = max(ans, b[i]);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tint shabi = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (ans == b[i]) {\n\t\t\tc1[i]++;\n\t\t\tfor (int j: a[i]) {\n\t\t\t\tc1[j]++;\n\t\t\t}\n\t\t\tcnt1++;\n\t\t\tshabi = i;\n\t\t}\n\t\tif (ans == b[i] + 1) {\n\t\t\tc2[i]++;\n\t\t\tfor (int j: a[i]) {\n\t\t\t\tc2[j]++;\n\t\t\t}\n\t\t\tcnt2++;\n\t\t}\n\t}\n\tint m1 = 0;\n\tint m2 = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tm1 = max(m1, c1[i]);\n\t\tm2 = max(m2, c2[i]);\n\t}\n\tif (cnt1 == 1 && c2[shabi] == cnt2) {\n\t\tprintf(\"%d\\n\", ans);\n\t} else if (m1 == cnt1) {\n\t\tprintf(\"%d\\n\", ans + 1);\n\t} else {\n\t\tprintf(\"%d\\n\", ans + 2);\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "dp", "trees"], "dificulty": "1900", "interactive": false}