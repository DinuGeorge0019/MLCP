{
    "link": "https://codeforces.com//contest/1719/problem/F",
    "problemId": "1509976",
    "problem_idx": "F",
    "shortId": "1719F",
    "contest_number": "1719",
    "problem_submissions": {
        "B": [
            168566227,
            168520938,
            168532485,
            168523483,
            168546606,
            168527651,
            168529090,
            168521682,
            168524157,
            168525651,
            168544350,
            168524093,
            168532781,
            168524676,
            168524799,
            168528931,
            168523245,
            168535265,
            168542247,
            168526151
        ],
        "C": [
            168564590,
            168527055,
            168563913,
            168534688,
            168554638,
            168544738,
            168548686,
            168548105,
            168536891,
            168541394,
            168530142,
            168539695,
            168544769,
            168539081,
            168537531,
            168544593,
            168539888,
            168546396,
            168551142,
            168534597
        ],
        "D1": [
            168558558,
            168542679,
            168557284,
            168554279,
            168564803,
            171062245,
            168563518,
            168568656,
            168554712,
            168565935,
            168563890,
            168565575,
            168554859,
            168570422,
            168552272,
            168561513,
            168560338,
            168564995,
            168562859,
            168577517
        ],
        "D2": [
            168558497,
            168553599,
            168557602,
            168553982,
            168564623,
            171062226,
            168563176,
            168568769,
            168554473,
            168565713,
            168570996,
            168565418,
            168574779,
            168570083,
            168576109,
            168574448,
            168567511,
            168565085,
            168562615,
            168586718
        ],
        "E": [
            168554365,
            168598287,
            168578854,
            168574119,
            168542245,
            168581099,
            168583743,
            168579840,
            168595833,
            168593319,
            168587676,
            168594973,
            168588543,
            168587843,
            168593966,
            168594751,
            168583071,
            168590461,
            168594089
        ],
        "F": [
            168534987,
            168577836,
            168600287,
            168607443,
            168579023,
            168704091,
            168637926,
            168609385,
            168607981,
            168607715,
            168585958
        ],
        "A": [
            168519209,
            168515375,
            168527134,
            168516968,
            168548303,
            168516013,
            168516695,
            168515925,
            168516176,
            168516243,
            168534710,
            168515665,
            168518019,
            168515902,
            168516007,
            168515846,
            168515950,
            168515461,
            168516618,
            168515960
        ]
    },
    "name": "F. Tonya and Burenka-179",
    "statement": "Tonya was given an array of a of length n written on a postcard for his\r\nbirthday. For some reason, the postcard turned out to be a , so the\r\nindex of the element located strictly to the right of the n-th is 1.\r\nTonya wanted to study it better, so he bought a robot \"Burenka-179\".A\r\nprogram for Burenka is a pair of numbers (s, k), where 1\r\nleq s\r\nleq n, 1\r\nleq k\r\nleq n-1. Note that k be equal to n. Initially, Tonya puts the robot in\r\nthe position of the array s. After that, Burenka makes n steps through\r\nthe array. If at the beginning of a step Burenka stands in the position\r\ni, then the following happens: The number a_{i} is added to the of the\r\nprogram. \"Burenka\" moves k positions to the right (i := i + k is\r\nexecuted, if i becomes greater than n, then i := i - n). Help Tonya find\r\nthe maximum possible of a program for \"Burenka\" if the initial\r\nusefulness of any program is 0.Also, Tonyâ€™s friend Ilyusha asks him to\r\nchange the array q times. Each time he wants to assign a_p := x for a\r\ngiven index p and a value x. You need to find the maximum possible of\r\nthe program after each of these changes.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2\")\n#include<bits/stdc++.h>\n#define int long long\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nnamespace fastio{\n    char in[100000];\n    int itr=0,llen=0;\n    char get(){\n        if(itr==llen)llen=fread(in,1,100000,stdin),itr=0;\n        if(llen==0)return EOF;\n        return in[itr++];\n    }\n    char out[100000];\n    int itr2=0;\n    void put(char c){\n        out[itr2++]=c;\n        if(itr2==100000){\n            fwrite(out,1,100000,stdout);\n            itr2=0;\n        }\n    }\n    int clear(){\n        fwrite(out,1,itr2,stdout);\n        itr2=0;\n        return 0;\n    }\n    int getint(){\n        int ret=0;char ch=get();\n        if(ch=='-')return -getint();\n        while (ch<'0'||ch>'9'){\n            ch=get();if(ch=='-')return -getint();\n        }\n        while ('0'<=ch&&ch<='9'){\n            ret=ret*10-48+ch;\n            ch=get();\n        }\n        return ret;\n    }\n    string getstr(){\n        string ret=\"\";\n        char ch=get();\n        while(isspace(ch))ch=get();\n        while(!isspace(ch))ret.push_back(ch),ch=get();\n        return ret;\n    }\n    void putstr(string s){\n        for(int i=0;i<s.size();i++)put(s[i]);\n    }\n    template<class T>void putint(T x){\n        if(x<0){\n            put('-');\n            putint(-x);\n            return;\n        }\n        if(x==0){\n            put('0');put(' ');\n            return;\n        }\n        char c[40];int pos=0;\n        while(x){\n            c[pos++]='0'+x%10;\n            x/=10;\n        }\n        for(int i=pos-1;i>=0;i--)put(c[i]);\n        put(' ');\n    }\n    template<class T>void putln(T x){\n        if(x<0){\n            put('-');\n            putln(-x);\n            return;\n        }\n        if(x==0){\n            put('0');put('\\n');\n            return;\n        }\n        char c[40];int pos=0;\n        while(x){\n            c[pos++]='0'+x%10;\n            x/=10;\n        }\n        for(int i=pos-1;i>=0;i--)put(c[i]);\n        put('\\n');\n    }\n\tstruct Flusher_ {\n\t\t~Flusher_(){clear();}\n\t}io_flusher_;\n}\nusing namespace fastio;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1e9+7;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint T,n,q,a[200005];\nvector<int>fac;\nint cnt[20][200005];\nmultiset<int>val[20];\nvoid eval(){\n\tint ans=0;\n\tfor(int i=0;i<fac.size();i++){\n\t\tans=max(ans,*val[i].rbegin()*fac[i]);\n\t}\n\tputln(ans);\n}\nsigned main(){\n\tT=getint();\n\twhile(T--){\n\t\tn=getint();q=getint();\n\t\tint tmp=n;fac.clear();\n\t\tfor(int i=2;i<=n;i++)if(tmp%i==0){\n\t\t\tfac.push_back(n/i);while(tmp%i==0)tmp/=i;\n\t\t}\n\t\tfor(int i=0;i<fac.size();i++)val[i].clear();\n\t\tfor(int i=0;i<fac.size();i++)for(int j=0;j<fac[i];j++)cnt[i][j]=0;\n\t\tfor(int i=1;i<=n;i++)a[i]=getint();\n\t\tfor(int i=0;i<fac.size();i++){\n\t\t\tfor(int j=1;j<=n;j++)cnt[i][j%fac[i]]+=a[j];\n\t\t\tfor(int j=0;j<fac[i];j++)val[i].insert(cnt[i][j]);\n\t\t}\n\t\teval();\n\t\twhile(q--){\n\t\t\tint x=getint(),y=getint();\n\t\t\tfor(int i=0;i<fac.size();i++){\n\t\t\t\tval[i].erase(val[i].find(cnt[i][x%fac[i]]));\n\t\t\t\tcnt[i][x%fac[i]]-=a[x]-y;\n\t\t\t\tval[i].insert(cnt[i][x%fac[i]]);\n\t\t\t}\n\t\t\ta[x]=y;\n\t\t\teval();\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "math",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Tonya and Burenka-179.json",
    "editorial_link": "https://codeforces.com//blog/entry/106049",
    "editorial": "Let's note that the answer for k=x\n and k=gcd(x,n)\n is the same.\n\nIndeed, for the number k\n, we will visit numbers with indices s+ikmodn\n for i\n from 0\n to n?1\n inclusive, from this we can see that the index of the i\n-th number coincides with the index of i+ngcd(k,n)\n, and if we look at two indexes, the difference between which is l\n and l<ngcd(k,n)\n, then they are different, since k?lmodn?0\n, therefore, the answer is (the sum of numbers with indices s+ikmodn\n for i\n from 0\n to ngcd(k,n)?1\n) ?gcd(k,n)\n.\n\nNow let's prove that the first gcd(k,n)\n numbers are the same for (s,x)\n and (s,gcd(x,n))\n, note that only those indices that have the same remainder as s\n when divided by gcd(x,n)\n are suitable, but there are only ngcd(k,n)\n of such indices, and we proved that we should have ngcd(k,n)\n of different indices, so they are all represented once, therefore the answer for k=x\n and k=gcd(x,n)\n is the same, because the sum consists of the same numbers.\n\nSo, we need to consider only k\n being divisors of n\n, this is already passes tests if we write, for example, a segment tree, but we don't want to write a segment tree, so we go further, prove that for k1=x\n, the answer is less or equal than for k2=x?y\n if k1\n and k2\n are divisors of n\n, why is this so?\n\nNote that for the number k\n, the answer beats for gcd(k,n)\n groups of numbers, so that in each group there is exactly ngcd(k,n)\n and each number is in exactly one group, and for different s\n the answer will be (the sum in the group that s\n belongs to) ?gcd(k,n)\n.\n\nLet's look at the answer for the optimal s\n for k1\n, let's call the set at which it is reached t\n, note that in k2\n for different s\n there are m\n independent sets that are subsets of t\n. Let mi\n be the sum in the i\n-th set. Now note that we need to prove max(m1,m2,Â…,my)?y?m1+m2+Â…my\n this is true for any mi\n, easy to see.\n\nSo you need to iterate the divisors which equals to np\n where p\n is prime, now it can be passed with a set. Hurray!\n\nFor the divisor d\n, it is proposed to store answers for all pairs (s,d)\n, where s?nd\n and the maximum among them, they can be counted initially for O(nlogn)\n for one d\n, each request is changing one of the values, this can be done for O(logn)\n.\n\nThe complexity of the author's solution is O(6?nlog(n))\n, where 6 is the maximum number of different prime divisors of the number n\n.",
    "hint": []
}