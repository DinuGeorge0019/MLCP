{"link": "https://codeforces.com//contest/801/problem/D", "problemId": "103103", "problem_idx": "D", "shortId": "801D", "contest_number": "801", "problem_submissions": {"E": [26431268, 26432380, 26476783, 26433724, 26434229, 26480642, 26480548, 26480348, 26494890, 26761813, 26448700, 26891853], "D": [26425044, 26425418, 26424442, 26425844, 26427999, 26423648, 26424386, 26426466, 26425527, 26426325, 26426061, 26426569, 26423135, 26426063, 26426145, 26426707, 26427444, 26427659, 26427813, 26428417], "C": [26421077, 26426753, 26422126, 26422964, 26424591, 26421294, 26422383, 26423910, 26421299, 26422965, 26423300, 26464547, 26464488, 26464472, 26462113, 26461839, 26423489, 26427796, 26421258, 26423212, 26423423, 26423078, 26423800, 26424484, 26424083], "B": [26417032, 26418855, 26417051, 26418098, 26418064, 26417323, 26417757, 26418046, 26417670, 26419595, 26417736, 26418294, 26418039, 26417940, 26419935, 26419134, 26418085, 26419132, 26418680, 26417887], "A": [26416465, 26416667, 26416492, 26416663, 26416642, 26416740, 26416470, 26416681, 26416514, 26418065, 26416666, 26417060, 26416564, 26416805, 26418618, 26417312, 26416869, 26417305, 26416921, 26416811]}, "name": "D. Volatile Kite", "statement": "You are given a convex polygon with distinct vertices . Vertex has\r\ncoordinates in the 2D plane. These vertices are listed in clockwise\r\norder.You can choose a real number and move each vertex of the polygon a\r\ndistance of at most from their original positions.Find the maximum value\r\nof such that no matter how you move the vertices, the polygon does not\r\nintersect itself and stays convex.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst double pi = acos(-1);\nconst double eps = 1e-6;\nstruct point{\n    double x,y;\n    point(double x=0.0,double y=0.0): x(x), y(y) {}\n    point operator + (const point& TMP) const{\n        return point(x + TMP.x, y + TMP.y);\n    }\n    point operator - (const point& TMP) const{\n        return point(x - TMP.x, y - TMP.y);\n    }\n    point& operator += (const point& TMP){\n        x += TMP.x;\n        y += TMP.y;\n        return *this;\n    }\n    point& operator -= (const point& TMP){\n        x -= TMP.x;\n        y -= TMP.y;\n        return *this;\n    }\n    void in(){\n        cin >> x >> y;\n    }\n    double angle(point ROOT = point(0,0)){\n        double res = atan2(y-ROOT.y,x-ROOT.x);\n        if (res < 0) res += 2.0*pi;\n        return res;\n    }\n};\nstruct line{\n    double a,b,c;\n    point head,end;\n    line(double a=0.0,double b=0.0,double c=0.0): a(a), b(b), c(c) {}\n    void init_have_point(){\n        if (abs(head.x - end.x) < eps){\n            a = 1.0;\n            b = 0.0;\n            c = - head.x;\n        }\n        else if (abs(head.y - end.y) < eps){\n            a = 0.0;\n            b = 1.0;\n            c = - head.y;\n        }\n        else{\n            a = (head.y - end.y) / (head.x - end.x);\n            b = -1.0;\n            c = head.y - a * head.x;\n        }\n        return;\n    }\n    void in1(){\n        cin >> a >> b >> c;\n    }\n    void in2(){\n        head.in(); end.in();\n    }\n};\nnamespace geometry{\n    point point_rotate(point X, double val, point ROOTz = point(0,0)){\n        point TMP = X - ROOTz;\n        X.x = TMP.x * cos(val) - TMP.y * sin(val);\n        X.y = TMP.x * sin(val) + TMP.y * cos(val);\n        return X + ROOTz;\n    }\n    point point_to_line(point X,line P){\n        return point((P.b * (P.b * X.x - P.a * X.y) - P.a * P.c) / (P.a*P.a + P.b*P.b),\n                     (P.a * (-P.b * X.x + P.a * X.y) - P.b *P.c) / (P.a*P.a + P.b*P.b));\n    }\n    line bisector(point Y,point X,point Z){\n        // compute bisector - phan giac cua goc YXZ\n        line res;\n        Y -= X;\n        Z -= X;\n        double val = (Y.angle() - Z.angle())/ 2.0;\n        res.head = point_rotate(Y, - val) + X;\n        res.end = X;\n        res.init_have_point();\n        return res;\n    }\n    double dis(point X,point Y){\n        return sqrt((X.x - Y.x) * (X.x - Y.x) + (X.y - Y.y)*(X.y - Y.y));\n    }\n    double dis(point X,line P){\n        return abs(P.a*X.x + P.b*X.y + P.c) / sqrt(P.a*P.a + P.b * P.b);\n    }\n}\nint n;\npoint a[1005];\nint main(){\n   iostream::sync_with_stdio(0);\n   cin >> n;\n   for(int i=0;i<n;i++)\n      a[i].in();\n   double ans = 1e10;\n   for(int i=0;i<n;i++){\n      int p0 = (i+n-1)%n;\n      int p1 = (i+1)%n;\n      line tmp;\n      tmp.head = a[p0];\n      tmp.end = a[p1];\n      tmp.init_have_point();\n      ans = min(ans, geometry::dis(a[i], tmp));\n   }\n   cout << setprecision(10) << ans/2;\n}\n"], "input": "", "output": "", "tags": ["brute force", "geometry", "greedy"], "dificulty": "1800", "interactive": false}