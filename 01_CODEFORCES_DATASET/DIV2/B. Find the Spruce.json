{
    "link": "https://codeforces.com//contest/1461/problem/B",
    "problemId": "829207",
    "problem_idx": "B",
    "shortId": "1461B",
    "contest_number": "1461",
    "problem_submissions": {
        "E": [
            100932966,
            100936269,
            100990346,
            100969491,
            100936672,
            100935997,
            100939174,
            100940524,
            100941594,
            101253968,
            100980986,
            100938127,
            100939775,
            100939746,
            100939282,
            100946150,
            100942054,
            100947167,
            100942687,
            100943260,
            100946250,
            100984712,
            100939780
        ],
        "D": [
            100927713,
            100927975,
            100930388,
            100930108,
            100929403,
            100928752,
            100927167,
            101253940,
            100929699,
            100925599,
            100929844,
            100930435,
            100928868,
            100927280,
            100929168,
            100927059,
            100928373,
            100929241,
            100929027,
            100931581
        ],
        "C": [
            100924332,
            100922434,
            100924379,
            100925587,
            100923163,
            100923132,
            100922302,
            101253910,
            100924116,
            100920852,
            100924402,
            100925009,
            100923233,
            100921503,
            100923858,
            100922215,
            100922547,
            100922569,
            100922801,
            100924266
        ],
        "B": [
            100920627,
            100919068,
            100920131,
            100923667,
            100919688,
            100918122,
            100916912,
            101253882,
            100919837,
            100916872,
            100919874,
            100921340,
            100919650,
            100918083,
            100918896,
            100918448,
            100932425,
            100918174,
            100919207,
            100918935
        ],
        "A": [
            100911403,
            100911220,
            100912022,
            100911829,
            100911757,
            100911131,
            100911094,
            101253862,
            100911574,
            100910965,
            100911506,
            100912093,
            100912000,
            100911450,
            100911077,
            100911732,
            100912598,
            100910886,
            100911279,
            100911559
        ],
        "F": [
            101254013,
            101253423,
            100951392,
            101467849,
            126697052
        ]
    },
    "name": "B. Find the Spruce",
    "statement": "Holidays are coming up really soon. Rick realized that it’s time to\r\nthink about buying a traditional spruce tree. But Rick doesn’t want real\r\ntrees to get hurt so he decided to find some in an n\r\ntimes m matrix consisting of \"\" and \"\". To find every spruce first let’s\r\ndefine what a spruce in the matrix is. A set of matrix cells is called a\r\nspruce of height k with origin at point (x, y) if: All cells in the set\r\ncontain an \"\". For each 1\r\nle i\r\nle k all cells with the row number x+i-1 and columns in range [y - i +\r\n1, y + i - 1] must be a part of the set. All other cells cannot belong\r\nto the set. Examples of correct and incorrect spruce trees: Now Rick\r\nwants to know how many spruces his n\r\ntimes m matrix contains. Help Rick solve this problem.\r\n",
    "solutions": [
        "//clear adj and visited vector declared globally after each test case\n//check for long long overflow\n//while adding and subs check if mod becomes -ve\n//while using an integer directly in a builtin function add ll\n//Mod wale question mein last mein if dalo ie. Ans<0 then ans+=mod;\n//Dont keep array name as size or any other key word\n//Incase of close mle change language to c++17 or c++14 \n\n#include <bits/stdc++.h>  \n#include <ext/pb_ds/assoc_container.hpp>\n#define int long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);cout.precision(dbl::max_digits10);\n#define pb push_back\n#define mod 1000000007ll //998244353ll\n#define lld long double\n#define mii map<int, int>\n#define mci map<char, int>\n#define msi map<string, int>\n#define pii pair<int, int>\n#define ff first\n#define ss second \n#define all(x) (x).begin(), (x).end()\n#define rep(i,x,y) for(int i=x; i<y; i++)    \n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define setbits(x) __builtin_popcountll(x)\n#define print2d(dp,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cout<<dp[i][j]<<\" \";cout<<\"\\n\";}\ntypedef std::numeric_limits< double > dbl;\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\nconst long long N=200005, INF=2000000000000000000;\nlld pi=3.1415926535897932;\nint lcm(int a, int b)\n{\n    int g=__gcd(a, b);\n    return a/g*b;\n}\nint power(int a, int b, int p)\n    {\n        if(a==0)\n        return 0;\n        int res=1;\n        a%=p;\n        while(b>0)\n        {\n            if(b&1)\n            res=(res*a)%p;\n            b>>=1;\n            a=(a*a)%p;\n        }\n        return res;\n    }\n\nint32_t main()\n{\n    IOS;\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        int n, m;\n        cin>>n>>m;\n        string s[n];\n        for(int i=0;i<n;i++)\n        cin>>s[i];\n        int dp[n+1][m+1];\n        fill(dp, 0);\n        int r[n+1][m+2], l[n+1][m+1];\n        fill(r, 0);\n        fill(l, 0);\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                if(s[i-1][j-1]=='*')\n                l[i][j]=l[i][j-1]+1;\n            }\n        }\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=m;j>0;j--)\n            {\n                if(s[i-1][j-1]=='*')\n                r[i][j]=r[i][j+1]+1;\n            }\n        } \n        int ans=0;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                dp[i][j]=min({dp[i-1][j], l[i][j]-1, r[i][j]-1})+1;\n                ans+=dp[i][j];\n            }\n        }   \n        //print2d(dp,n,m);\n        cout<<ans<<\"\\n\";        \n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Find the Spruce.json",
    "editorial_link": "https://codeforces.com//blog/entry/85491",
    "editorial": "Letâs iterate over the top of the spruce. When we meet the symbol \"*\",\r\nwe will start iterating over the height of the current spruce. If for\r\nthe current height for each all cells with the row number and columns in\r\nrange are \"*\", then we increase the value of the answer. Otherwise, we\r\nstop the increment hight.\r\n",
    "hint": []
}