{"link": "https://codeforces.com//contest/1277/problem/C", "problemId": "495583", "problem_idx": "C", "shortId": "1277C", "contest_number": "1277", "problem_submissions": {"F": [66866628, 66860664, 66862829, 66860439, 66977841, 66899469, 66863808, 92979782, 92978994, 92978960, 92978865, 66891528, 66889235, 66866269, 67019482], "D": [66856749, 66864218, 66854207, 66847715, 66844420, 66847306, 66854098, 66848610, 66848065, 66848280, 66844474, 66849217, 66848886, 66864076, 66847735], "E": [66850123, 66849554, 66847076, 66854313, 66848191, 66853241, 66855295, 66853466, 66848425, 66855580, 66855848, 66853292, 66856132, 92977693, 66856983, 66854785, 125051093, 66850783, 66861075], "C": [66841382, 66842457, 66841119, 66845741, 66837706, 66839907, 66838468, 66840457, 66839782, 66840815, 66841610, 66843424, 66846378, 66837428, 66844848, 66841436, 66840246, 66839763], "B": [66837718, 66838330, 66834438, 66842100, 66834455, 66836147, 66833752, 66836537, 66835874, 66836673, 66837137, 66837196, 66974853, 66841617, 66834535, 66838161, 66835795, 66834507, 66836405], "A": [66834598, 66836237, 66833655, 66838372, 66833757, 66834211, 66833507, 66833800, 66834296, 66834715, 66834270, 66834723, 66974834, 66839401, 66833706, 66836909, 66833653, 66833594, 66833715]}, "name": "C. As Simple as One and Two", "statement": "You are given a non-empty string s=s_1s_2\r\ndots s_n, which consists only of lowercase Latin letters. Polycarp does\r\nnot like a string if it contains at least one string \"\" or at least one\r\nstring \"\" (or both at the same time) as a . In other words, Polycarp\r\ndoes not like the string s if there is an integer j (1\r\nle j\r\nle n-2), that s_{j}s_{j+1}s_{j+2}=\"\" or s_{j}s_{j+1}s_{j+2}=\"\".For\r\nexample: Polycarp does not like strings \"\", \"\", \"\" and \"\" (they all have\r\nat least one substring \"\" or \"\"), Polycarp likes strings \"\", \"\" and \"\"\r\n(they have no substrings \"\" and \"\"). Polycarp wants to select a certain\r\nset of indices (positions) and remove all letters on these positions.\r\nAll removals are made at the same time.For example, if the string looks\r\nlike s=\"\", then if Polycarp selects two indices 3 and 6, then \"\" will be\r\nselected and the result is \"\".What is the minimum number of indices\r\n(positions) that Polycarp needs to select to make the string liked? What\r\nshould these positions be?\r\n", "solutions": ["#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0\u500b\u306e\u4e38\u3068-1\u500b\u306e\u68d2\u307f\u305f\u3044\u306a\u6642\u306b\u6642\u306b\u52b9\u304f\uff1f\u4e0d\u5b89.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  int t;cin>>t;\n  rep(hoge,t){\n    string s;\n    cin>>s;\n    s += \"xxxxxx\";\n    ll ans = 0;\n    vector<ll> pos;\n    rep(si,s.size()-5){\n      if(s[si] == 'o' && s[si+1] == 'n' && s[si+2] == 'e'){\n        s[si+1] = 'x';\n        pos.push_back(si+1+1);\n        ans++;\n        si--;\n        continue;\n      }\n      if(s[si] == 't' && s[si+1] == 'w' && s[si+2] == 'o' && s[si+3] == 'n' && s[si+4] == 'e'){\n        s[si+2] = 'x';\n        pos.push_back(si+2+1);\n        ans++;\n        si--;\n        continue;\n      }\n      if(s[si] == 't' && s[si+1] == 'w' && s[si+2] == 'o'){\n        s[si+1] = 'x';\n        pos.push_back(si+1+1);\n        ans++;\n        si--;\n        continue;\n      }\n    }\n    cout<<ans<<endl;\n    rep(i,pos.size()){\n      cout<<pos[i]<<\" \";\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "greedy"], "dificulty": "1400", "interactive": false}