{
    "link": "https://codeforces.com//contest/1869/problem/D1",
    "problemId": "2184994",
    "problem_idx": "D1",
    "shortId": "1869D1",
    "contest_number": "1869",
    "problem_submissions": {
        "E": [
            222790733,
            222755919,
            223014703,
            222844888,
            222822436,
            222820168
        ],
        "D2": [
            222751076,
            222765748,
            222762229,
            222767685,
            222770713,
            222771349,
            222774390,
            222781618,
            222778821,
            222788639,
            222773236,
            222775336,
            222775900,
            222778257,
            222775220,
            222773627,
            222771492
        ],
        "D1": [
            222743411,
            222768273,
            222754309,
            222754872,
            222757370,
            222757211,
            222762465,
            222761473,
            222755833,
            222757091,
            222752420,
            222764925,
            222765023,
            222761868,
            222761450,
            222761828,
            222765878,
            222760854
        ],
        "C": [
            222734213,
            222799024,
            222739072,
            222743933,
            222748797,
            222742198,
            222748357,
            222740791,
            222743470,
            222743624,
            222737636,
            222744668,
            222749662,
            222742346,
            222741675,
            222752222,
            222753724,
            222751049
        ],
        "B": [
            222728831,
            222759638,
            222728679,
            222733793,
            222732869,
            222730403,
            222734827,
            222731660,
            222733775,
            222732224,
            222728510,
            222735540,
            222734578,
            222733639,
            222729850,
            222736886,
            222733662,
            222738397
        ],
        "A": [
            222725390,
            222757999,
            222725599,
            222726282,
            222727750,
            222725856,
            222726824,
            222727514,
            222730110,
            222726868,
            222725449,
            222728462,
            222727639,
            222725642,
            222725871,
            222727421,
            222725878,
            222731354
        ],
        "F": [
            223418170
        ]
    },
    "name": "D1. Candy Party  Easy Version ",
    "statement": "After Zhongkao examination, Daniel and his friends are going to have a\r\nparty. Everyone will come with some candies.There will be n people at\r\nthe party. Initially, the i-th person has a_i candies. During the party,\r\nthey will swap their candies. To do this, they will line up and everyone\r\nwill do the following : Choose an integer p (1\r\nle p\r\nle n) and a integer x, then give his 2^{x} candies to the p-th person.\r\nNote that one give more candies than currently he has (he might receive\r\ncandies from someone else before) and he give candies to himself. Daniel\r\nlikes fairness, so he will be happy if and only if everyone receives\r\ncandies from . Meanwhile, his friend Tom likes average, so he will be\r\nhappy if and only if all the people have the same number of candies\r\nafter all swaps.Determine whether there exists a way to swap candies, so\r\nthat both Daniel and Tom will be happy after the swaps.\r\n",
    "solutions": [
        "// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2\")\n#include <bits/stdc++.h>\n#define int long long\n#define i64 long long\n#define pii pair <int, int> \nusing namespace std;\ninline int read(void) {\n    int x=0,sgn=1; char ch=getchar();\n    while(ch<48||57<ch) {if(ch==45)sgn=0;ch=getchar();}\n    while(47<ch&&ch<58) {x=x*10+ch-48;   ch=getchar();}\n    return sgn? x:-x;\n}\nvoid write(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\n#define lowbit(x) (x&(-x))\nint n,sum,avg;\nint a[200005];\nmap <int,int> cnt;\ninline void work() {\n    n=read(); cnt.clear(); sum=0;\n    for(int i=1; i<=n; ++i) sum+=(a[i]=read());\n    if(sum%n) return puts(\"No\"),void();\n    avg=sum/n;\n    for(int i=1; i<=n; ++i) {\n        int del=abs(a[i]-avg);\n        int cur=del+lowbit(del);\n        if(lowbit(cur)!=cur) return puts(\"No\"),void();\n        if(a[i]<avg) cnt[cur]++,cnt[lowbit(del)]--;\n        else cnt[lowbit(del)]++,cnt[cur]--;\n    }\n    for(auto x : cnt) if(x.second!=0) return puts(\"No\"),void();\n    return puts(\"Yes\"),void();\n}\nsigned main() {\n    int T=read();\n    while(T--) work();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "graphs",
        "implementation",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Candy Party  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/116642",
    "editorial": "Denote s\n as 1n?ni=1ai\n. If s\n is not an integer, then it will be impossible to make all people have the same number of candies, so the answer is \"No\".\n\nSince a person gives candies to and receives candies from exactly one person, suppose he gives away 2x\n candies and receives 2y\n candies, then we get this equation:\n\nai?2xi+2yi=s.\n\nIf s=ai\n, there is an infinite set of solutions: xi=yi\n.\n\nOtherwise, s?ai\n, then we have ai?s=2xi?2yi\n. For different pairs (x,y)\n (x?y\n), the values of 2x?2y\n are pairwise different, so there will be at most 1\n solution to this equation.\n\nThus, if there exists a possible solution, the number of candies each person receives and gives away is determined for ai?s\n. If an equation has no solution, then obviously the answer is \"No\".\n\nOtherwise, let's maintain two multisets S\n and T\n. For each person, let's add xi\n to S\n and yi\n to T\n. Omitting the condition \"one cannot give more candies than currently he has\" (1)\n, we can claim that the answer is \"Yes\" if and only if S=T\n. The proof is left to readers as an exercise. :)\n\nNow let's think about the condition (1)\n. Build a directed graph with n\n nodes. For two persons i\n and j\n, if person i\n gives x>0\n candies to person j\n, then we add an edge from node i\n to node j\n with weight x\n. All nodes with ai?s\n must have exactly 1\n in degree and 1\n out degree. So the graph must consist of several cycles.\n\nLet's prove that we can always choose a starting point properly for any cycle, so that the condition (1)\n is satisfied.\n\nPick the largest ai\n in the cycle, and we must have ai>s\n. Suppose the i\n-th person gives candies to the j\n-th person (1?aj?ai\n, xi?xj\n), then we have:\n\nai?2xi+2yi=s,(2)\naj?2xj+2xi=s,(3)\n\nSuppose ai<2xi\n, then we must have yi<xi\n, so 2yi?2xi/2\n. If xi<xj\n, that is, 2?2xi?2xj\n:\n\n(2)?(3)?ai?aj?2xi+2xj+2yi?2xi=0?ai?aj+(2xj?2?2xi)+2yi??????????????????????>0=0?ai<aj,\n\nSimilarly we can prove that when xi>xj\n, aj<0\n. In both cases the condition 1?aj?ai\n has been violated. So we proved that ai?2xi>0\n.\n\nThus, we proved the the claim. And we can easily add those nodes with ai=s\n into cycles: suppose the node is p\n, if there is an edge a?b\n with weight w\n, we add two edge a?p\n and p?b\n, both weights are w\n, and delect the original edge a?b\n.\n\nSo we can solve this problem by simply maintaining S\n and T\n, which can be done in O(nlogV)\n. O(nlog2V)\n solutions can fit in the TL well, too."
}