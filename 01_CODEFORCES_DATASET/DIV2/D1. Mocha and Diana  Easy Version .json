{
    "link": "https://codeforces.com//contest/1559/problem/D1",
    "problemId": "1078715",
    "problem_idx": "D1",
    "shortId": "1559D1",
    "contest_number": "1559",
    "problem_submissions": {
        "D2": [
            125995494,
            126036275,
            125997805,
            126009493,
            126011074,
            126008472,
            126038189,
            126005034,
            126002626,
            125999937,
            126005467,
            126005672,
            126010740,
            126006398,
            126010473,
            126011364,
            126008532,
            126039421,
            126011147,
            126008772,
            126009477,
            126012187,
            126015439
        ],
        "E": [
            125974477,
            125957083,
            125970146,
            125961617,
            125979742,
            125976394,
            125982640,
            125984935,
            125974866,
            125973356,
            125969825,
            125970524,
            125976580,
            125988330,
            125973822,
            126039403,
            125988355,
            125979721,
            125979087,
            125993147,
            125980201
        ],
        "D1": [
            125944192,
            125969277,
            125954678,
            125967980,
            125953790,
            125959046,
            125952547,
            125954032,
            125984889,
            125979313,
            125972340,
            125951958,
            125981117,
            125956127,
            125979601,
            125965087,
            125984172,
            125984989,
            125957742,
            125959852
        ],
        "C": [
            125940467,
            125947734,
            125943938,
            125945955,
            125945435,
            125954449,
            125957788,
            125959041,
            125956677,
            125953215,
            125950646,
            125956630,
            125949058,
            125946362,
            125956010,
            125954414,
            125947800,
            125952498,
            125949073,
            125951269
        ],
        "B": [
            125938532,
            125941057,
            125937911,
            125940291,
            125940964,
            125944375,
            125941668,
            125940207,
            125948124,
            125946366,
            125951888,
            125939403,
            125942974,
            125940405,
            125941485,
            125941898,
            125941189,
            125945855,
            125940756,
            125941646
        ],
        "A": [
            125934889,
            125935929,
            125934894,
            125936023,
            125936520,
            125944189,
            125936005,
            125935279,
            125938830,
            125941957,
            125944772,
            125935138,
            125938909,
            125935398,
            125941621,
            125935239,
            125935795,
            125938400,
            125934867,
            125935241
        ]
    },
    "name": "D1. Mocha and Diana  Easy Version ",
    "statement": "A forest is an undirected graph without cycles (not necessarily\r\nconnected).Mocha and Diana are friends in Zhijiang, both of them have a\r\nforest with nodes numbered from 1 to n, and they would like to add edges\r\nto their forests such that: After adding edges, both of their graphs are\r\nstill forests. They add the same edges. That is, if an edge (u, v) is\r\nadded to Mocha’s forest, then an edge (u, v) is added to Diana’s forest,\r\nand vice versa. Mocha and Diana want to know the maximum number of edges\r\nthey can add, and which edges to add.\r\n",
    "solutions": [
        "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,ssse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\n//#define int long long\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define dwn(i, a, b) for(int i = a; i >= b; i--)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nconst int INF = 0x3f3f3f3f;\nconst int NINF = -INF - 1;\nconst int N = 1e3 + 10;\nconst int mod = 1e9+7;\nint n, m1, m2, fa[2][N];\nvoid init(int m) { rep(i, 1, m) fa[0][i] = fa[1][i] = i; }\nint get(int i, int x) { return fa[i][x] == x ? x : fa[i][x] = get(i, fa[i][x]); }\nint solve() {\n    std::vector< std::pair<int, int> > ans;\n    rep(i, 1, n) {\n        rep(j, i+1, n) {\n            if(get(0, i) != get(0, j) && get(1, i) != get(1, j)) {\n                fa[0][get(0, i)] = get(0, j);\n                fa[1][get(1, i)] = get(1, j);\n                ans.eb(i, j);\n            }\n        }\n    }\n    std::cout << ans.size() <<std::endl;\n    for(auto x : ans) std::cout << x.fi << \" \" << x.se << std::endl;\n    return 0;\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin >> n >> m1 >> m2;\n    init(n);\n    rep(i, 1, m1) {\n        int u, v; std::cin >> u >> v;\n        fa[0][get(0, u)] = get(0, v);\n    }\n    rep(i, 1, m2) {\n        int u, v; std::cin >> u >> v;\n        fa[1][get(1, u)] = get(1, v);\n    }\n    return solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dsu",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Mocha and Diana  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/93898",
    "editorial": "In the final situation, if one forest has more than one tree, we choose\r\ntwo trees from it, such as tree and tree . Then we consider node in and\r\nnode in , they must be connected in another forest. We can easily find\r\nnode is connected with all the nodes in and node is connected with all\r\nthe nodes in . So nodes in and are in the same tree in another forest.\r\nIf we consider other trees, we can get the same conclusion. Hence nodes\r\nin another forest form only one tree.So we can enumerate every pair and\r\ncheck if this edge can be added. When the edge can be added, we can just\r\nadd it. This can be done in the complexity of .\r\n",
    "hint": []
}