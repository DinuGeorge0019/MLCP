{
    "link": "https://codeforces.com//contest/137/problem/E",
    "problemId": "725",
    "problem_idx": "E",
    "shortId": "137E",
    "contest_number": "137",
    "problem_submissions": {
        "D": [
            960005,
            960083,
            960407,
            960822,
            960978,
            959728,
            959647,
            960244,
            961785,
            961204,
            960009,
            960173,
            960331,
            960318,
            961322,
            961503,
            960958,
            959450,
            961108
        ],
        "E": [
            959375,
            960769,
            959788,
            959842,
            960438,
            960606,
            961308,
            961259,
            960542,
            960298,
            961524,
            961740,
            961358,
            961405,
            960518,
            960604,
            961543,
            962797,
            961827
        ],
        "A": [
            958154,
            958315,
            957467,
            957359,
            957636,
            957482,
            957504,
            957682,
            957763,
            958206,
            957614,
            957505,
            957814,
            957699,
            957800,
            958834,
            957616,
            957354,
            958655
        ],
        "B": [
            957805,
            957908,
            957895,
            957576,
            958020,
            957753,
            957706,
            958045,
            958039,
            958890,
            957997,
            957845,
            958326,
            958171,
            958572,
            959109,
            958403,
            957499,
            958442
        ],
        "C": [
            957396,
            957611,
            958395,
            958193,
            958567,
            958319,
            958191,
            958994,
            962691,
            962687,
            958717,
            959395,
            958900,
            958213,
            959117,
            959359,
            959315,
            960063,
            959720,
            957783,
            958064
        ]
    },
    "name": "E. Last Chance",
    "statement": "Having read half of the book called \"Storm and Calm\" on the IT lesson,\r\nInnocentius was absolutely determined to finish the book on the maths\r\nlessons. All was fine until the math teacher Ms. Watkins saw Innocentius\r\nreading fiction books instead of solving equations of the fifth degree.\r\nAs during the last maths class Innocentius suggested the algorithm of\r\nsolving equations of the fifth degree in the general case, Ms. Watkins\r\nhad no other choice but to give him a new task.The teacher asked to\r\nwrite consecutively (without spaces) all words from the \"Storm and Calm\"\r\nin one long string . She thought that a string is good if the number of\r\nvowels in the string is no more than twice more than the number of\r\nconsonants. That is, the string with vowels and consonants is good if\r\nand only if .The task Innocentius had to solve turned out to be rather\r\nsimple: he should find the number of the longest good substrings of the\r\nstring .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nchar vow[128],s[200005];\nint a[200005];\n\nint main(){\n    vow['a']=vow['e']=vow['i']=vow['o']=vow['u']=1;\n    vow['A']=vow['E']=vow['I']=vow['O']=vow['U']=1;\n    int n=strlen(gets(s+1)),ans=0,cnt=0;\n    for(int i=1;i<=n;i++) s[i]=vow[s[i]];\n    for(int i=1;i<=n;i++) a[i]=a[i-1]+(s[i]?-1:2);\n    vector<int> u={0};\n    for(int i=1;i<=n;i++){\n        if(a[i]-a[u.back()]>=0){\n            int lo=0,hi=u.size()-1;\n            while(lo<hi){\n                int m=(lo+hi)/2;\n                if(a[i]-a[u[m]]>=0) hi=m; else lo=m+1;\n            }\n            ans=max(ans,i-u[lo]);\n        }\n        if(a[i]<a[u.back()]) u.push_back(i);\n    }\n    if(!ans) return printf(\"No solution\")&0;\n    for(int i=ans;i<=n;i++) if(a[i]-a[i-ans]>=0) cnt++;\n    printf(\"%d %d\\n\",ans,cnt);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Last Chance.json",
    "editorial_link": "https://codeforces.com//blog/entry/3318",
    "editorial": "Letâs replace all vowels by -1 and all consonants by +2. Obviously\r\nsubstring from position i to j is good if sum in the substring [i, j] is\r\nnonnegative. Denote this sum by sum[i][j]. Obviously sum[i][j] = p[j +\r\n1] - p[i], where p[i] is the sum of first i elements. Now for all i we\r\nwant to find maximal j such that j >= i and sum[i][j] >= 0. For this\r\nletâs sort the array of (p[i], i) and build segment tree on this array\r\nby i. Letâs iterate over all p[i] in nondescending order. Obsiously for\r\nfixed i we have that j = max(index[i]), where index[i] is the index of\r\ni-th partial sum in nondescending order and i from range [x, n], where x\r\nis the position of the first partial sum with value p[i] in sorted\r\narray. Than we must update position i by value of negative infinity and\r\nupdate answer by j - i. The complexity is O(n logn).\r\n",
    "hint": []
}