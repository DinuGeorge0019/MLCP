{"link": "https://codeforces.com//contest/1688/problem/F", "problemId": "1419364", "problem_idx": "F", "shortId": "1688F", "contest_number": "1688", "problem_submissions": {"F": [159410825, 159527472, 159472113], "C": [159404501, 159365159, 159366341, 159373586, 159362776, 159370629, 159370154, 159369677, 159381261, 159374462, 159381251, 159381152, 159372318, 159366961, 159376004, 159380988, 159381329, 159386074], "E": [159391189, 159380776, 159384621, 159398500, 159397765, 159404212, 159394358, 159393997, 159399468, 159392431, 159395743, 159400327, 159402238, 159399827, 159395270, 159393471, 159393150, 159396147], "B": [159388484, 159355530, 159354509, 159357638, 159355802, 159358715, 159358570, 159355775, 159357680, 159365471, 159355946, 159360943, 159358134, 159356079, 159356249, 159358267, 159364146, 159357603], "D": [159372838, 159371621, 159377503, 159382209, 159381068, 159378580, 159379984, 159378382, 159374943, 159383837, 159371975, 159370185, 159380593, 159384944, 159388687, 159386205, 159385205, 159378922], "A": [159357586, 159352248, 159352639, 159352936, 159353828, 159354431, 159354424, 159352341, 159352633, 159353673, 159352511, 159354887, 159354866, 159352629, 159352715, 159358063, 159357871, 159353570]}, "name": "F. Sanae and Giant Robot", "statement": "Is it really?! The robot only existing in my imagination?! The Colossal\r\nWalking Robot?!! Kochiya Sanae Sanae made a giant robot Hisoutensoku,\r\nbut something is wrong with it. To make matters worse, Sanae can not\r\nfigure out how to stop it, and she is forced to fix it on-the-fly.The\r\nstate of a robot can be represented by an array of integers of length n.\r\nInitially, the robot is at state a. She wishes to turn it into state b.\r\nAs a great programmer, Sanae knows the art of copy-and-paste. In one\r\noperation, she can choose some segment from given segments, copy the\r\nsegment from b and paste it into of the robot, replacing the original\r\nstate there. However, she has to ensure that the sum of a after each\r\ncopy operation in case the robot go haywire. Formally, Sanae can choose\r\nsegment [l,r] and assign a_i = b_i (l\r\nle i\r\nle r) if\r\nsum\r\nlimits_{i=1}^n a_i does not change after the operation.Determine whether\r\nit is possible for Sanae to successfully turn the robot from the initial\r\nstate a to the desired state b with any (possibly, zero) operations.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconstexpr int inf = 1e18;\nconstexpr int maxn = 2e5 + 5;\nconstexpr int mod = 998244353;\n\nstruct dsu\n{\n  vector<int> fa, sz;\n\n  dsu(int n) : fa(n), sz(n, 1) { iota(fa.begin(), fa.end(), 0); } // 0 ~ n-1\u7684\u521d\u59cb\u5316\n  int find(int x)\n  {\n    while (x != fa[x])\n      x = fa[x] = fa[fa[x]];\n    return x;\n  }                                                      // \u8def\u5f84\u538b\u7f29\n  bool same(int x, int y) { return find(x) == find(y); } // \u5224\u65ad\u7956\u5b97\u8282\u70b9\u662f\u5426\u4e00\u81f4\n  bool merge(int x, int y)                               // \u5e26\u5224\u65ad\u7684\u6309\u79e9\u5408\u5e76\n  {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return false;\n    sz[x] += sz[y];\n    fa[y] = x;\n    return true;\n  }\n  int size(int x) { return sz[find(x)]; } // \u8054\u901a\u8282\u70b9\u4e2a\u6570\n};\n\ninline void solve()\n{\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n + 1), b(n + 1);\n  for (int i = 1; i <= n; i ++)\n    cin >> a[i];\n  for (int i = 1; i <= n; i ++)\n    cin >> b[i];\n  vector<int> tot(m, 2);\n  vector<pair<int, int>> t(m);\n  vector p(n + 1, vector<int>());\n  for (int i = 0; i < m; i ++)\n  {\n    auto &[x, y] = t[i];\n    cin >> x >> y;\n    x--;\n    p[x].emplace_back(i);\n    p[y].emplace_back(i);\n  }\n  dsu d(n + 2);\n\n  function<void(int)> dfs = [&](int x)\n  {\n    if (d.find(x) != x)\n      return;\n    d.fa[x] = d.find(x + 1);\n    for (int X : p[x])\n    {\n      -- tot[X];\n      if (!tot[X])\n      {\n        int y = d.find(t[X].first);\n        while (y < t[X].second)\n        {\n          dfs(y);\n          y = d.find(y);\n        }\n      }\n    }\n  };\n  dfs(0);\n\n  for (int i = 1; i <= n; i ++)\n  {\n    a[i] += a[i - 1];\n    b[i] += b[i - 1];\n    if (a[i] == b[i])\n      dfs(i);\n  }\n  if (d.find(0) == n + 1)\n    cout << \"YES\\n\";\n  else\n    cout << \"NO\\n\";\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T;\n  cin >> T;\n  while (T--)\n    solve();\n  return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "data structures", "dsu"], "dificulty": "2500", "interactive": false}