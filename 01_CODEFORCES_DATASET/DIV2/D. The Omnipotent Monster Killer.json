{
    "link": "https://codeforces.com//contest/1988/problem/D",
    "problemId": "2755742",
    "problem_idx": "D",
    "shortId": "1988D",
    "contest_number": "1988",
    "problem_submissions": {
        "E": [
            270685050,
            270705019,
            270700025,
            272334496,
            270690864,
            270707787,
            270701276,
            270700901,
            270718018,
            270707694,
            270712456,
            270717955,
            270717609,
            270717396,
            270722279,
            270721777,
            270713323,
            270726034,
            270728933,
            270723571,
            270713049
        ],
        "D": [
            270667414,
            270666131,
            270678688,
            270697022,
            270684902,
            270684329,
            270689879,
            270679010,
            270680404,
            270690647,
            270675498,
            270681957,
            270688264,
            270682354,
            270685580,
            270691868,
            270688997,
            270685310,
            270682871,
            270686949
        ],
        "A": [
            270656934,
            270657283,
            270646313,
            270648673,
            270647770,
            270646255,
            270646226,
            270646704,
            270646496,
            270646875,
            270646230,
            270646537,
            270649042,
            270647239,
            270646832,
            270647970,
            270646816,
            270646403,
            270647818,
            270690835
        ],
        "B": [
            270653903,
            270658113,
            270648318,
            270659660,
            270651609,
            270649653,
            270649456,
            270651315,
            270648898,
            270652028,
            270649680,
            270649413,
            270659881,
            270651090,
            270653561,
            270652761,
            270651998,
            270650038,
            270651450,
            270654441
        ],
        "C": [
            270647243,
            270657923,
            270653896,
            270669456,
            270664152,
            270658071,
            270658378,
            270659641,
            270660679,
            270663455,
            270660051,
            270666865,
            270671029,
            270662305,
            270672676,
            270661337,
            270662076,
            270660202,
            270665229,
            270662007
        ],
        "F": [
            276883705,
            276879542,
            270840778
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131581",
    "editorial": "Suppose monster i\n is killed in round bi\n. Then, the total health decrement is the sum of ai×bi\n. The \"independent set\" constraint means that for adjacent vertices, their b\n-s must be different.\n\nObservation: bi\n does not exceed ?log2n?+1\n. In this problem, bi?19\n always holds for at least one optimal ai\n.\n\nProof\nBy dp, we can find the answer in O(nlogn)\n or O(nlog2n)\n, depending on whether you use prefix/suffix maximums to optimize the taking max part.\n\nBonus: Find a counterexample for bi?18\n when n=300000\n. (Pretest 2 is one case)\n",
    "name": "D. The Omnipotent Monster Killer",
    "statement": "You, the monster killer, want to kill a group of monsters. The monsters\r\nare on a tree with n vertices. On vertex with number i (1\r\nle i\r\nle n), there is a monster with a_i attack points. You want to battle\r\nwith monsters for 10^{100} rounds. In each round, the following happens\r\nin order: All living monsters attack you. Your health decreases by the\r\nsum of attack points of all living monsters. You select some (possibly\r\nall or none) monsters and kill them. After being killed, the monster\r\nwill not be able to do any attacks in the future. There is a\r\nrestriction: in one round, you cannot kill two monsters that are\r\ndirectly connected by an edge.If you choose what monsters to attack\r\noptimally, what is the smallest health decrement you can have after all\r\nrounds?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}const int N=300005,D=50;vi v[N];int n,a[N];struct cx{\tint cs[D];\tcx(int x=0){rep(i,D)cs[i]=(i+1)*x;}\tvoid merg(cx y){\t\tint mi=INF,lmi=INF,p=-1;\t\trep(i,D){\t\t\tif(mi>y.cs[i])swap(mi,y.cs[i]),p=i;\t\t\tif(lmi>y.cs[i])swap(lmi,y.cs[i]);\t\t}\t\trep(i,D){\t\t\tif(i!=p)cs[i]+=mi;\t\t\telse cs[i]+=lmi;\t\t}\t}};cx dfs(int u,int p){\tcx cur(a[u]);\tfor(int i:v[u])if(i!=p)\t\tcur.merg(dfs(i,u));\tre cur;}void run(){\tint n;\tcin>>n;\trep(i,n)cin>>a[i];\trep(i,n)v[i].clear();\trep(i,n-1){\t\tint x,y;\t\tcin>>x>>y;\t\tx--;y--;\t\tv[x].pb(y);\t\tv[y].pb(x);\t}\tcx x=dfs(0,-1);\tint s=INF;\trep(i,D)Mi(s,x.cs[i]);\tcout<<s<<\"\\n\";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. The Omnipotent Monster Killer.json",
    "hint": []
}