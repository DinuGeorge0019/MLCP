{"link": "https://codeforces.com//contest/1668/problem/D", "problemId": "1373077", "problem_idx": "D", "shortId": "1668D", "contest_number": "1668", "problem_submissions": {"E": [154123739, 154125336, 154119851, 154113083, 154126230, 154111025, 154118734, 154118893, 154116518], "D": [154102065, 154111480, 154109461, 154112828, 154127256, 154120568, 154199100, 154098507, 154101292, 154104775, 154103929, 154095552, 154104771, 154104638], "C": [154084164, 154089822, 154082750, 154086924, 154096669, 154097603, 154087733, 154089704, 154084845, 154091220, 154093921, 154082051, 154082528, 154089420, 154085834, 154089820, 154100489, 154080049, 154081283], "B": [154081285, 154084224, 154085663, 154082020, 154152941, 154084489, 154090124, 154084331, 154085985, 154081983, 154085223, 154085348, 154095598, 154087105, 154085147, 154082318, 154081788, 154081908, 154090843, 154084167], "A": [154079113, 154080383, 154079244, 154078891, 154152929, 154079977, 154085842, 154079717, 154081051, 154079292, 154081689, 154080381, 154089065, 154090204, 154080866, 154080201, 154079483, 154080405, 154087751, 154079358], "F": [154125193, 154162167, 154110277, 154120657]}, "name": "D. Optimal Partition", "statement": "You are given an array a consisting of n integers. You should divide a\r\ninto continuous non-empty subarrays (there are 2^{n-1} ways to do\r\nthat).Let s=a_l+a_{l+1}+\r\nldots+a_r. The value of a subarray a_l, a_{l+1},\r\nldots, a_r is: (r-l+1) if s>0, 0 if s=0, -(r-l+1) if s<0. What is the\r\nmaximum sum of values you can get with a partition?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nint i,j,k,n,m,t;\nll mp[500500],g[500500],f[500500],f2[500500],a[500500];\nvoid add(ll x,ll y,ll f[]){\n\tfor(;x<=n+5;x+=(-x&x)){f[x]=max(f[x],y);}\n}\nll get(ll x,ll f[],ll y=-1e18){\n\tfor(;x;x-=(-x&x)){y=max(f[x],y);}return y;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);cout.tie(0);\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n;\n\t\ta[0]=g[0]=0;\n\t\tfor(i=1;i<=n+50;i++){\n\t\t\tf[i]=-1e18;\n\t\t\tf2[i]=-1e18;\n\t\t\tg[i]=-1e18;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a[i];\n\t\t\ta[i]+=a[i-1];\n\t\t\tmp[i]=a[i];\n\t\t}\n\t\tmp[n+1]=0;\n\t\tsort(mp+1,mp+n+2);\n\t\tunique(mp+1,mp+n+2);\n\t\t\n\t\tfor(i=0;i<=n;i++){\n\t\t\ta[i]=lower_bound(mp+1,mp+n+2,a[i])-mp;\n\t\t}\n\t\t\n\t\tfor(i=0;i<=n;i++){\n\t\t\tif(!i){\n\t\t\t\tadd(a[i],0,f);\n\t\t\t\tadd(a[i],0,f2);continue;\n\t\t\t}\n\t\t\tg[i]=g[i-1]-1;\n\t\t\tg[i]=max(g[i],i+get(a[i]-1,f));\n\t\t\tg[i]=max(g[i],get(a[i],f2));\n\t\t\t\n\t\t\tadd(a[i],g[i]-i,f);\n\t\t\tadd(a[i],g[i],f2);\n\t\t}\n\t\t\n\t\tcout<<g[n]<<'\\n';\n\t}\n}"], "input": "", "output": "", "tags": ["data structures", "dp"], "dificulty": "2100", "interactive": false}