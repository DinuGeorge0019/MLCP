{"link": "https://codeforces.com//contest/534/problem/F", "problemId": "25995", "problem_idx": "F", "shortId": "534F", "contest_number": "534", "problem_submissions": {"E": [10683933, 10683934], "D": [10678175, 10678621, 10677106, 10675536, 10676106, 10674810, 10677903, 10677747, 10679006, 10677924, 10680207, 10678552, 10679589, 10680738, 10678781, 10678817, 10680761], "C": [10671852, 10674805, 10673233, 10673070, 10671645, 10677139, 10673078, 10674877, 10676809, 10674952, 10672887, 10676606, 10670002, 10674948, 10676024, 10676008, 10674748], "B": [10669948, 10673036, 10671795, 10670663, 10670379, 10671586, 10670885, 10672541, 10673957, 10673051, 10670344, 10673862, 10674029, 10669586, 10673422, 10671966, 10672486], "A": [10669180, 10670286, 10669409, 10669242, 10669361, 10670184, 10669504, 10669859, 10671143, 10670792, 10669355, 10669710, 10671717, 10669137, 10670714, 10672627, 10669808], "F": [10688186, 10766570]}, "name": "F. Simplified Nonogram", "statement": "In this task you have to write a program dealing with nonograms on\r\nfields no larger than .Simplified nonogram is a task where you have to\r\nbuild such field (each cell is either white or black) that satisfies the\r\ngiven information about rows and columns. For each row and each column\r\nthe number of contiguous black segments is specified. For example if\r\nsize of the field is , nd numbers of contiguous black segments in rows\r\nare: and in columns are: then the solution may look like: It is\r\nguaranteed that on each test in the testset there exists at least one\r\nsolution.\r\n", "solutions": ["#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nset<long long> seen;\n\nvoid display(vector<vector<bool>> potsol)\n{\n    if (potsol.size() > 0)\n    {\n        for (int i = 0; i < potsol[0].size(); ++i)\n        {\n            for (int j = 0; j < potsol.size(); ++j)\n            {\n                cout << ((potsol[j][i]) ? \"*\" : \".\");\n            }\n            cout << endl;\n        }\n        cout << endl;\n    }\n    else\n    {\n        cout << \"Empty\" << endl << endl;\n    }\n}\n\nvector<vector<bool>> possibles(int x, int n)\n{\n    vector<vector<bool>> ret;\n    for (int i = 0; i < (1 << n); ++i)\n    {\n        int y = i;\n        int cnt = 0;\n        bool on = false;\n        vector<bool> p;\n        for (int j = 0; j < n; ++j)\n        {\n            if (y&1)\n            {\n                if (!on)\n                {\n                    ++cnt;\n                }\n                on = true;\n            }\n            else\n            {\n                on = false;\n            }\n            p.push_back(y&1);\n            y>>=1;\n        }\n        if (cnt == x)\n        {\n            ret.push_back(p);\n        }\n    }\n    return ret;\n}\n\nbool dfs(vector<vector<bool>> &potsol, vector<int> &cnts, vector<bool> &ons, vector<int> &a, vector<vector<vector<bool>>> &ps)\n{\n    if (potsol.size() == ps.size())\n    {\n        for (int i = 0; i < a.size(); ++i)\n        {\n            if (cnts[i] != a[i])\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    else\n    {\n        long long hash = potsol.size();\n        for (int i = 0; i < a.size(); ++i)\n        {\n            hash = 32*hash + cnts[i];\n        }\n        for (int i = 0; i < a.size(); ++i)\n        {\n            hash = 2*hash+ons[i];\n        }\n        if (seen.find(hash) != seen.end())\n        {\n            return false;\n        }\n        seen.insert(hash);\n        for (int i = 0; i < a.size(); ++i)\n        {\n            if (cnts[i] > a[i])\n            {\n                return false;\n            }\n            if ((a[i] - cnts[i]) > (((ps.size() - potsol.size()) + 1)/2))\n            {\n                return false;\n            }\n        }\n        \n        for (int i = ps[potsol.size()].size()-1; i >= 0; --i)\n        {\n            vector<vector<bool>> pst = potsol;\n            vector<int> ct = cnts;\n            vector<bool> ot = ons;\n            potsol.push_back(ps[potsol.size()][i]);\n            for (int j = 0; j < a.size(); ++j)\n            {\n                if (potsol.back()[j])\n                {\n                    if (!ons[j])\n                    {\n                        ++cnts[j];\n                    }\n                    ons[j] = true;\n                }\n                else\n                {\n                    ons[j] = false;\n                }\n            }\n            if (dfs(potsol,cnts,ons,a,ps))\n            {\n                return true;\n            }\n            else\n            {\n                potsol = pst;\n                cnts = ct;\n                ons = ot;\n            }\n        }\n        return false;\n    }\n}\n\nint main(int argc, const char * argv[])\n{\n    int m,n;\n    cin >> n >> m;\n    vector<int> a(n,0);\n    vector<int> b(m,0);\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i < m; ++i)\n    {\n        cin >> b[i];\n    }\n    \n    vector<vector<vector<bool>>> ps;\n    for (int i = 0; i < m; ++i)\n    {\n        ps.push_back(possibles(b[i], n));\n    }\n    vector<vector<bool>> potsol;\n    vector<int> cnts(a.size(),0);\n    vector<bool> ons(a.size(), false);\n    dfs(potsol,cnts,ons,a,ps);\n    display(potsol);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp", "hashing", "meet-in-the-middle"], "dificulty": "2400", "interactive": false}