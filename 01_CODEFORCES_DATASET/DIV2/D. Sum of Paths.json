{
    "link": "https://codeforces.com//contest/1467/problem/D",
    "problemId": "858755",
    "problem_idx": "D",
    "shortId": "1467D",
    "contest_number": "1467",
    "problem_submissions": {
        "A": [
            103781028,
            103732975,
            103789355,
            103727649,
            103776107,
            103728134,
            103733285,
            103731503,
            103734108,
            103745618,
            103776057,
            103728589,
            103737241,
            103730063,
            103728536,
            103782858,
            103740519,
            103780744,
            103730125,
            103733429
        ],
        "B": [
            103776223,
            103763378,
            103735716,
            103743111,
            103753392,
            103747731,
            103744698,
            103825399,
            103745451,
            103752738,
            103745778,
            103769242,
            103752112,
            103747036,
            103750474,
            103751826,
            103737251,
            103751660,
            103806893,
            103752900,
            103749089
        ],
        "C": [
            103771486,
            103780246,
            103746693,
            103766971,
            103761062,
            103800886,
            103767932,
            103776708,
            103770869,
            103762101,
            103786323,
            103768958,
            103786670,
            103776678,
            103772104,
            103785995,
            103773040,
            103799284,
            103805177,
            103785884
        ],
        "D": [
            103764796,
            103781468,
            103759529,
            103758056,
            103768367,
            103763856,
            103774343,
            103763817,
            103781960,
            103777881,
            103743423,
            103779264,
            103772933,
            103764332,
            103785499,
            103746072,
            103785798,
            103785854,
            103759639,
            103785071
        ],
        "E": [
            103749029,
            103758281,
            103840304,
            103785768,
            103786917,
            103785220,
            103779762,
            103798134,
            103802685,
            103796217,
            103804930,
            103797788,
            103804889,
            103803175,
            103801192,
            103810505,
            103804335,
            103855637,
            103803060,
            103803658,
            103762986,
            103795272,
            103809021
        ]
    },
    "name": "D. Sum of Paths",
    "statement": "There are n cells, numbered 1,2,\r\ndots, n from left to right. You have to place a robot at any cell\r\ninitially. The robot must make k moves.In one move, the robot must move\r\none cell to the left or right, provided that it doesn\u2019t move out of\r\nbounds. In other words, if the robot was in the cell i, it must move to\r\neither the cell i-1 or the cell i+1, as long as it lies between 1 and n\r\n(endpoints inclusive). The cells, in the order they are visited\r\n(including the cell the robot is placed), together make a .Each cell i\r\nhas a value a_i associated with it. Let c_0, c_1,\r\ndots, c_k be the sequence of cells in a in the order they are visited\r\n(c_0 is the cell robot is initially placed, c_1 is the cell where the\r\nrobot is after its first move, and so on; more formally, c_i is the cell\r\nthat the robot is at after i moves). Then the value of the path is\r\ncalculated as a_{c_0} + a_{c_1} +\r\ndots + a_{c_k}.Your task is to calculate the sum of values over all\r\npossible . Since this number can be very large, output it modulo 10^9 +\r\n7. Two are considered different if the starting cell differs or there\r\nexists an integer i\r\nin [1, k] such that the current cell of the robot after exactly i moves\r\nis different in those paths.You must process q updates to a and print\r\nthe updated sum each time. Each update changes the value of exactly one\r\ncell. See the input format and the sample input-output for more details.\r\n",
    "solutions": [
        "// author: xay5421\n// created: Fri Jan  8 23:00:15 2021\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=5005,P=1e9+7;\nint n,K,Q,f[N][N],g[N],a[N];\nint main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d\",&n,&K,&Q);\n\trep(i,1,n)scanf(\"%d\",&a[i]);\n\trep(i,1,n)f[i][0]=1;\n\trep(j,1,K){\n\t\trep(i,1,n){\n\t\t\tf[i][j]=(f[i-1][j-1]+f[i+1][j-1])%P;\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,0,K){\n\t\t\t(g[i]+=1LL*f[i][j]*f[i][K-j]%P)%=P;\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,1,n)(ans+=1LL*g[i]*a[i]%P)%=P;\n\trep(i,1,Q){\n\t\tint k1,k2;\n\t\tscanf(\"%d%d\",&k1,&k2);\n\t\t(ans+=P-1LL*g[k1]*a[k1]%P)%=P;\n\t\ta[k1]=k2;\n\t\t(ans+=1LL*g[k1]*a[k1]%P)%=P;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Sum of Paths.json",
    "editorial_link": "https://codeforces.com//blog/entry/86566",
    "editorial": "The main idea of the problem is to calculate the contribution of each\r\ncell to the answer.Let denote the sum of the number of times cell\r\nappears in all good paths of length . Then the answer is equal to . We\r\nshall use dynamic programming to calculate these values.Let denote the\r\nnumber of good paths of length that end at cell . Then, for all such\r\nthat . Further, for all such that and for all such that , can be\r\ncalculated as because we can move to cell from either cell or cell .\r\nHandle the cases where and separately to avoid out-of-bounds\r\nerror.Observe that is also equal to the number of good paths of length\r\nthat start at cell .Let denote the number of times cell appears after\r\nexactly moves in all valid paths of length . Well because we can split a\r\npath of length into two paths of length and length , with the first path\r\nending at cell and the second path starting at cell .Since denotes the\r\nsum of the number of times cell appears in all good path of length ,\r\ncell can appear after exactly moves. This means that .Extending the\r\nsolution to account for updates is easy once we have calculated these\r\nvalues.\r\n"
}