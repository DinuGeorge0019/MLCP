{
    "link": "https://codeforces.com//contest/1075/problem/E",
    "problemId": "249096",
    "problem_idx": "E",
    "shortId": "1075E",
    "contest_number": "1075",
    "problem_submissions": {
        "E": [
            45299888,
            45297843,
            45298056,
            45296633,
            45301081,
            45300957,
            45302422,
            45302929,
            45304409,
            45302659,
            45300790,
            45303365,
            45303877,
            45302733
        ],
        "F": [
            45298415,
            45299656,
            45299363,
            45302076,
            45302275,
            45461749,
            45308311
        ],
        "D": [
            45294336,
            45295894,
            45295657,
            45296846,
            45300767,
            45296827,
            45297943,
            45298533,
            45298945,
            45296351,
            45298646,
            45300089,
            45299323,
            45303594,
            45300962,
            45300486,
            45300898
        ],
        "C": [
            45292132,
            45292865,
            45293959,
            45292758,
            45292492,
            45294033,
            45294912,
            45294846,
            45293224,
            45293567,
            45294312,
            45292544,
            45295364,
            45296384,
            45295997,
            45298611,
            45297798
        ],
        "B": [
            45290077,
            45290576,
            45289458,
            45290287,
            45290460,
            106466381,
            45291592,
            45291593,
            45291426,
            45290169,
            45291447,
            45291908,
            45290506,
            45291957,
            45290127,
            45292064,
            45294213,
            45290472
        ],
        "A": [
            45288469,
            45288515,
            45288420,
            45288453,
            45288440,
            45288973,
            45289044,
            45288964,
            45288524,
            45289234,
            45289586,
            45288591,
            45289499,
            45288557,
            45289581,
            45288705,
            45288541
        ]
    },
    "name": "E. Optimal Polygon Perimeter",
    "statement": "You are given n points on the plane. The polygon formed from all the n\r\npoints is , that is, the polygon is convex, and there are no three\r\ncollinear points (i.e. lying in the same straight line). The points are\r\nnumbered from 1 to n, in clockwise order.We define the distance between\r\ntwo points p_1 = (x_1, y_1) and p_2 = (x_2, y_2) as their Manhattan\r\ndistance: d(p_1, p_2) = |x_1 - x_2| + |y_1 - y_2|.Furthermore, we define\r\nthe perimeter of a polygon, as the sum of Manhattan distances between\r\nall adjacent pairs of points on it; if the points on the polygon are\r\nordered as p_1, p_2,\r\nldots, p_k (k\r\ngeq 3), then the perimeter of the polygon is d(p_1, p_2) + d(p_2, p_3) +\r\nldots + d(p_k, p_1).For some parameter k, let’s consider all the\r\npolygons that can be formed from the given set of points, having k\r\nvertices, such that the polygon is self-intersecting. For each such\r\npolygon, let’s consider its perimeter. Over all such perimeters, we\r\ndefine f(k) to be the maximal perimeter.Please note, when checking\r\nwhether a polygon is self-intersecting, that the edges of a polygon are\r\nstill drawn as straight lines. For instance, in the following pictures:\r\nIn the middle polygon, the order of points (p_1, p_3, p_2, p_4) is not\r\nvalid, since it is a self-intersecting polygon. The right polygon (whose\r\nedges resemble the Manhattan distance) has the same order and is not\r\nself-intersecting, but we consider edges as straight lines. The correct\r\nway to draw this polygon is (p_1, p_2, p_3, p_4), which is the left\r\npolygon.Your task is to compute f(3), f(4),\r\nldots, f(n). In other words, find the maximum possible perimeter for\r\neach possible number of points (i.e. 3 to n).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define szv(V) ((int)(V).size())\n#define allv(V) (V).begin(), (V).end()\n#define sortv(V) sort(allv(V))\n#define uniquev(V) (V).erase(unique(allv(V)), (V).end())\n#define compv(V) sortv(V), uniquev(V)\n#define fs first\n#define se second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int mod = 1e9 + 7;\nconst ll inf = 4e18 + 5;\n\nll gcd(ll x, ll y) { while (y) x %= y, swap(x, y); return x; }\npll operator+(pll a, pll b) { return pll(a.fs + b.fs, a.se + b.se); }\npll operator-(pll a, pll b) { return pll(a.fs - b.fs, a.se - b.se); }\nll operator*(pll a, pll b) { return a.fs * b.se - a.se * b.fs; }\ntemplate <class T> int sign(T x) { return x < 0 ? -1 : x > 0 ? 1 : 0; }\nint ccw(pll a, pll b, pll c) { return sign((b - a) * (c - b)); }\ntemplate <class T> void setmin(T &x, T y) { if (x > y) x = y; }\ntemplate <class T> void setmax(T &x, T y) { if (x < y) x = y; }\ntemplate <class T> void addval(T &x, T y) { x += y; x %= mod; }\n\nint n;\npii ps[300005];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    int Fmx = -mod, Fmn = mod, Smx = -mod, Smn = mod;\n    for (int i = 1; i <= n; i++) {\n        cin >> ps[i].fs >> ps[i].se;\n        setmax(Fmx, ps[i].fs);\n        setmin(Fmn, ps[i].fs);\n        setmax(Smx, ps[i].se);\n        setmin(Smn, ps[i].se);\n    }\n    int ans4 = (Fmx + Smx - Fmn - Smn) * 2;\n    int ans3 = 0;\n    for (int i = 1; i <= n; i++) {\n        int F, S;\n        tie(F, S) = ps[i];\n        setmax(ans3, Fmx - F + Smx - S);\n        setmax(ans3, Fmx - F + S - Smn);\n        setmax(ans3, F - Fmn + Smx - S);\n        setmax(ans3, F - Fmn + S - Smn);\n    }\n    ans3 *= 2;\n    cout << ans3;\n    for (int i = 4; i <= n; i++) cout << ' ' << ans4;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "geometry"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Optimal Polygon Perimeter.json",
    "editorial_link": "https://codeforces.com/blog/entry/62985",
    "editorial": "I will show 2 solutions, both of which work in O(n)\n time. First, it is not hard to notice that we can only consider polygons that are convex.\n\nObservation: For a convex polygon, the given definition of \"polygon perimeter\" is equivalent to the perimeter of the bounding rectangle (aligned with the axis), of our polygon. If we look at some convex polygon, and 4 values maxx,minx,maxy,miny\n representing the maximal x\n coordinate of a point, minimal x\n, maximal and minimal y\n, then the perimeter of the bounding rectangle is simply 2?(maxx?minx+maxy?miny)\n.\n\nThis simple rephrase gives us a bonus, and crucial observation: It is enough for us to take 4 points from the input, such that the perimeter of their polygon is the maximal possible (and is equal to the perimeter of the polygon formed from n\n points). We will consider these the extreme points. Note that after taking the extreme points, it does not matter which other points we take. So, this solves all f(4),,f(n)\n.\n\nWe are left with f(3)\n to compute (maximal triangle perimeter). Following are 2 solutions to do it:\n\nSolution 1: Let's show that the optimal triangle uses at least 2 of the extreme points. Imagine some optimal triangle, and its bounding rectangle. Notice that since each edge of the bounding rectangle must touch some vertex of the triangle (it is bounding after all), and we have 4 edges and 3 vertices, then there must be some vertex of the triangle that touches 2 edges of the rectangle (so it coincides with a rectangle vertex). If this is the case, we know that in comparison with the 2 other vertices, this vertex has \"extremal\" X and Y coordinates (minimal/maximal X, and minimal/maximal Y). Without loss of generality, assume this vertex has maximum X and Y. Then to optimize the perimeter, the other two vertices should have smallest possible X and smallest possible Y. We can pick these 2 vertices to be 2 of the extreme points (one with minimal X and one with minimal Y). So, this shows we just need to iterate over every adjacent pair of extreme vertices, and over all other points as the last vertex. This takes O(n)\n.\n\nSolution 2: This solution is more general, and is an extension of the problem to find the 2 most distant points (manhattan distance). The triangle perimeter is an expression with 6 terms: |x1?x2|+|y1?y2|++|y3?y1|\n. We wish the maximize this expression, but the absolute value is troubling us. For each term, there are 2 cases: either it is positive, so the absolute value does nothing, or it is negative, so the absolute value negates it. In total, for the 6 terms we have 26=64\n options to place signs between them. We will call such option a setting.\n\nFor any setting, the advantage now is that we can accumulate terms: For example the setting ++???+\n, evaluates the expression to:\n\n(2x1+0y1)+(?2x2?2y2)+(0x3+2y3)\nWe solve every setting by its own, and over all settings we take the maximal answer.\n\nPlease note, that this strategy only works to find the maximal value of the expression, not minimal. The proof of this is left as an exercise to the reader :) (I promise it is not difficult).\n\nGiven 6 constants c1,c2,...,c6\n, we want to find 3 indicies i<j<k\n to maximize: c1?xi+c2?yi+...+c6?yk\n. We define 3 arrays:\n\nPi=c1?xi+c2?yi\nQi=c3?xi+c4?yi\nRi=c5?xi+c6?yi\nAnd so we want to maximize Pi+Qj+Rk\n. This can be done in O(n)\n with simple dynamic programming.\nSo this whole solution is O(n)\n, with a constant of 64. In general, to compute f(k)\n this solution takes O(n?4k?k)\n time, without any observations.",
    "hint": []
}