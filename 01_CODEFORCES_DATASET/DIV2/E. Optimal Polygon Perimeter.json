{"link": "https://codeforces.com//contest/1075/problem/E", "problemId": "249096", "problem_idx": "E", "shortId": "1075E", "contest_number": "1075", "problem_submissions": {"E": [45299888, 45297843, 45298056, 45296633, 45301081, 45300957, 45302422, 45302929, 45304409, 45302659, 45300790, 45303365, 45303877, 45302733], "F": [45298415, 45299656, 45299363, 45302076, 45302275, 45461749, 45308311], "D": [45294336, 45295894, 45295657, 45296846, 45300767, 45296827, 45297943, 45298533, 45298945, 45296351, 45298646, 45300089, 45299323, 45303594, 45300962, 45300486, 45300898], "C": [45292132, 45292865, 45293959, 45292758, 45292492, 45294033, 45294912, 45294846, 45293224, 45293567, 45294312, 45292544, 45295364, 45296384, 45295997, 45298611, 45297798], "B": [45290077, 45290576, 45289458, 45290287, 45290460, 106466381, 45291592, 45291593, 45291426, 45290169, 45291447, 45291908, 45290506, 45291957, 45290127, 45292064, 45294213, 45290472], "A": [45288469, 45288515, 45288420, 45288453, 45288440, 45288973, 45289044, 45288964, 45288524, 45289234, 45289586, 45288591, 45289499, 45288557, 45289581, 45288705, 45288541]}, "name": "E. Optimal Polygon Perimeter", "statement": "You are given n points on the plane. The polygon formed from all the n\r\npoints is , that is, the polygon is convex, and there are no three\r\ncollinear points (i.e. lying in the same straight line). The points are\r\nnumbered from 1 to n, in clockwise order.We define the distance between\r\ntwo points p_1 = (x_1, y_1) and p_2 = (x_2, y_2) as their Manhattan\r\ndistance: d(p_1, p_2) = |x_1 - x_2| + |y_1 - y_2|.Furthermore, we define\r\nthe perimeter of a polygon, as the sum of Manhattan distances between\r\nall adjacent pairs of points on it; if the points on the polygon are\r\nordered as p_1, p_2,\r\nldots, p_k (k\r\ngeq 3), then the perimeter of the polygon is d(p_1, p_2) + d(p_2, p_3) +\r\nldots + d(p_k, p_1).For some parameter k, let\u2019s consider all the\r\npolygons that can be formed from the given set of points, having k\r\nvertices, such that the polygon is self-intersecting. For each such\r\npolygon, let\u2019s consider its perimeter. Over all such perimeters, we\r\ndefine f(k) to be the maximal perimeter.Please note, when checking\r\nwhether a polygon is self-intersecting, that the edges of a polygon are\r\nstill drawn as straight lines. For instance, in the following pictures:\r\nIn the middle polygon, the order of points (p_1, p_3, p_2, p_4) is not\r\nvalid, since it is a self-intersecting polygon. The right polygon (whose\r\nedges resemble the Manhattan distance) has the same order and is not\r\nself-intersecting, but we consider edges as straight lines. The correct\r\nway to draw this polygon is (p_1, p_2, p_3, p_4), which is the left\r\npolygon.Your task is to compute f(3), f(4),\r\nldots, f(n). In other words, find the maximum possible perimeter for\r\neach possible number of points (i.e. 3 to n).\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define szv(V) ((int)(V).size())\n#define allv(V) (V).begin(), (V).end()\n#define sortv(V) sort(allv(V))\n#define uniquev(V) (V).erase(unique(allv(V)), (V).end())\n#define compv(V) sortv(V), uniquev(V)\n#define fs first\n#define se second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int mod = 1e9 + 7;\nconst ll inf = 4e18 + 5;\n\nll gcd(ll x, ll y) { while (y) x %= y, swap(x, y); return x; }\npll operator+(pll a, pll b) { return pll(a.fs + b.fs, a.se + b.se); }\npll operator-(pll a, pll b) { return pll(a.fs - b.fs, a.se - b.se); }\nll operator*(pll a, pll b) { return a.fs * b.se - a.se * b.fs; }\ntemplate <class T> int sign(T x) { return x < 0 ? -1 : x > 0 ? 1 : 0; }\nint ccw(pll a, pll b, pll c) { return sign((b - a) * (c - b)); }\ntemplate <class T> void setmin(T &x, T y) { if (x > y) x = y; }\ntemplate <class T> void setmax(T &x, T y) { if (x < y) x = y; }\ntemplate <class T> void addval(T &x, T y) { x += y; x %= mod; }\n\nint n;\npii ps[300005];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    int Fmx = -mod, Fmn = mod, Smx = -mod, Smn = mod;\n    for (int i = 1; i <= n; i++) {\n        cin >> ps[i].fs >> ps[i].se;\n        setmax(Fmx, ps[i].fs);\n        setmin(Fmn, ps[i].fs);\n        setmax(Smx, ps[i].se);\n        setmin(Smn, ps[i].se);\n    }\n    int ans4 = (Fmx + Smx - Fmn - Smn) * 2;\n    int ans3 = 0;\n    for (int i = 1; i <= n; i++) {\n        int F, S;\n        tie(F, S) = ps[i];\n        setmax(ans3, Fmx - F + Smx - S);\n        setmax(ans3, Fmx - F + S - Smn);\n        setmax(ans3, F - Fmn + Smx - S);\n        setmax(ans3, F - Fmn + S - Smn);\n    }\n    ans3 *= 2;\n    cout << ans3;\n    for (int i = 4; i <= n; i++) cout << ' ' << ans4;\n    return 0;\n}"], "input": "", "output": "", "tags": ["dp", "geometry"], "dificulty": "2100", "interactive": false}