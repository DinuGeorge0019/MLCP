{
    "link": "https://codeforces.com//contest/1853/problem/D",
    "problemId": "2099142",
    "problem_idx": "D",
    "shortId": "1853D",
    "contest_number": "1853",
    "problem_submissions": {
        "E": [
            215240531,
            215240313,
            215246116,
            215249458,
            215251653,
            215250635,
            216838871,
            215350430,
            215284663,
            215314853,
            215261254
        ],
        "D": [
            215214411,
            215220885,
            215224382,
            215226640,
            215227143,
            215237178,
            215219268,
            215220212,
            216838036,
            215216388,
            215222732,
            215221541,
            215222391,
            215228057,
            215226498,
            215216178,
            215232515,
            215230797,
            215230860,
            215230625,
            215227427
        ],
        "C": [
            215208066,
            215209029,
            215218445,
            215213557,
            215221549,
            215215979,
            215208850,
            215209462,
            216838362,
            215211675,
            215212482,
            215215977,
            215215848,
            215207971,
            215220425,
            215219406,
            215210968,
            215214808,
            215215587,
            215214690,
            215214191
        ],
        "B": [
            215201834,
            215199354,
            215203429,
            215207887,
            215208000,
            215209486,
            215199874,
            215202601,
            216837998,
            215205609,
            215206019,
            215207012,
            215203260,
            215203474,
            215206199,
            215210556,
            215204325,
            215206260,
            216063043,
            216062841,
            215207209,
            215210173,
            215204057
        ],
        "A": [
            215192467,
            215191692,
            215193758,
            215193193,
            215193397,
            215196782,
            215192166,
            215194407,
            216837978,
            215192246,
            215196759,
            215192559,
            215192820,
            215193114,
            215192996,
            215192748,
            215192883,
            215192440,
            216062816,
            215194635,
            215194796,
            215192776
        ],
        "F": [
            225845923
        ]
    },
    "name": "D. Imbalanced Arrays",
    "statement": "Ntarsis has come up with an array a of n non-negative integers.Call an\r\narray b of n integers if it satisfies the following: -n\r\nle b_i\r\nle n, b_i\r\nne 0, there are no two indices (i, j) (1\r\nle i, j\r\nle n) such that b_i + b_j = 0, for each 1\r\nleq i\r\nleq n, there are a_i indices j (1\r\nle j\r\nle n) such that b_i+b_j>0, where i and j are not necessarily distinct.\r\nGiven the array a, Ntarsis wants you to construct some imbalanced array.\r\nHelp him solve this task, or determine it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 110000;\nint ans[maxN];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint T;\n\tfor (cin >> T; T; T--) {\n\t\tint n; cin >> n;\n\t\tset<pair<int, int>> s;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x; cin >> x;\n\t\t\ts.insert({x, i});\n\t\t}\n\t\tint ct = 0;\n\t\tbool ok = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tauto p = *s.begin();\n\t\t\tif (p.first == ct) {\n\t\t\t\tans[p.second] = i - n;\n\t\t\t\ts.erase(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto f = s.lower_bound({ct + n - i, 0});\n\t\t\t\tif (f != s.end() && f->first == ct + n - i) {\n\t\t\t\t\tans[f->second] = n - i;\n\t\t\t\t\tct++;\n\t\t\t\t\ts.erase(f);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tcout << \"YES\\n\";\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tcout << ans[i] << \" \\n\"[i == n - 1];\n\t\t}\n\t\telse cout << \"NO\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Imbalanced Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/116940",
    "editorial": "At the start, let x\n be an index such that bx\n has the greatest absolute value. If bx\n is negative, we have ax=0\n, and else ax=n\n. Moreover, we can't have ay=0,az=n\n for any indices y\n and z\n, because that implies by+bz\n is both positive and negative, contradiction. Hence, the necessary and sufficient condition to check if we can determine an element in array b\n with maximum absolute value is (there exists an element of array a\n equal to 0\n) xor (there exists an element of array a\n equal to n\n). Then, we can remove that element and re-calculate the a\n array, leading to an O(n2)\n solution. If the check fails at any moment, there is no valid solution.\n\nTo optimize it further, note that we can sort array a\n at the start and keep track of them in a deque-like structure. We only need to check the front and end of the deque to see if our key condition holds. Finally, we can use a variable to record the number of positive elements deleted so far and subtract it from the front and end of the deque when checking our condition, so that each check is O(1)\n. The overall complexity becomes O(nlogn)\n due to sorting.",
    "hint": []
}