{"link": "https://codeforces.com//contest/912/problem/E", "problemId": "144443", "problem_idx": "E", "shortId": "912E", "contest_number": "912", "problem_submissions": {"C": [33939960, 33939332], "E": [33937258, 33933701, 33945198, 33942310, 33943413, 33944965, 33944500, 33944708, 33947180, 33947146, 76791617, 33941858, 33941491], "D": [33929983, 33936192, 33941962, 33932459, 33932813, 33939373, 33937374, 33934352, 33940764, 33937493, 33943638, 33931105, 33939804, 33934462, 33942378, 33953796, 33937778, 33936199], "B": [33924135, 33925821, 33925186, 33924566, 33925991, 33928269, 33929796, 33936643, 33929453, 33927572, 33926977, 33926561, 33926317, 33935518, 33928188, 33928933, 33930630, 33931743], "A": [33923797, 33924106, 33923840, 33926847, 33924254, 33926307, 33927750, 33935324, 33926290, 33928561, 33923877, 33925336, 33924071, 33924047, 33923947, 33924293, 33926054, 33925244, 33930321]}, "name": "E. Prime Gift", "statement": "Opposite to Grisha\u2019s nice behavior, Oleg, though he has an entire year\r\nat his disposal, didn\u2019t manage to learn how to solve number theory\r\nproblems in the past year. That\u2019s why instead of Ded Moroz he was\r\nvisited by his teammate Andrew, who solemnly presented him with a set of\r\nnumbers alongside with a simple task: Oleg is to find the -th smallest\r\ninteger, such that its prime divisors are in this set.\r\n", "solutions": ["#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, w[16];\nlong long K, M;\nvector<long long>V1;\nvector<long long>V2;\nvoid DFS(int b, int e, vector<long long> &t, long long cur) {\n\tint i;\n\tif (b == e) {\n\t\tt.push_back(cur);\n\t\treturn;\n\t}\n\tDFS(b + 1, e, t, cur);\n\twhile (cur <= M / w[b]) {\n\t\tcur *= w[b];\n\t\tDFS(b + 1, e, t, cur);\n\t}\n}\nlong long Count(long long a) {\n\tint i, pv = V2.size()-1;\n\tlong long r = 0;\n\tfor (i = 0; i < V1.size(); i++) {\n\t\twhile (pv >= 0 && V2[pv] > a / V1[i])pv--;\n\t\tr += pv + 1;\n\t}\n\treturn r;\n}\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tsort(w, w + n);\n\tscanf(\"%lld\", &K);\n\tM = 1e18;\n\tDFS(0, min(n, 6), V1, 1);\n\tif (n >= 6) {\n\t\tDFS(6, n, V2, 1);\n\t}\n\telse V2.push_back(1);\n\tsort(V1.begin(), V1.end());\n\tsort(V2.begin(), V2.end());\n\tlong long b = 1, e = M, mid, r = 0;\n\twhile (b <= e) {\n\t\tmid = (b + e) >> 1;\n\t\tif (Count(mid) >= K) {\n\t\t\tr = mid;\n\t\t\te = mid - 1;\n\t\t}\n\t\telse b = mid + 1;\n\t}\n\tprintf(\"%lld\\n\", r);\n}"], "input": "", "output": "", "tags": ["binary search", "dfs and similar", "math", "meet-in-the-middle", "number theory", "two pointers"], "dificulty": "2400", "interactive": false}