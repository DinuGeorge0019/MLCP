{
    "link": "https://codeforces.com//contest/1291/problem/B",
    "problemId": "529284",
    "problem_idx": "B",
    "shortId": "1291B",
    "contest_number": "1291",
    "problem_submissions": {
        "C": [
            70078816,
            70050816,
            70042724,
            70053069,
            70052206,
            70072135,
            70047080,
            70047671,
            70049982,
            70049792,
            70044975,
            70045731,
            70049590,
            70046807,
            70050141,
            70048797,
            70051840,
            70043410,
            70051189
        ],
        "A": [
            70076588,
            70035649,
            70051615,
            70038788,
            71191554,
            70042526,
            70040855,
            70040409,
            70037322,
            70324047,
            70036128,
            70035755,
            70036486,
            70036001,
            70040165,
            70037128,
            70036301,
            70037522,
            70037345,
            70036992,
            70038646
        ],
        "B": [
            70075656,
            70037850,
            70048322,
            70046041,
            71191579,
            70045451,
            70044084,
            70040507,
            70041207,
            70039061,
            70042662,
            70039800,
            70040502,
            70042950,
            70040497,
            70040646,
            70041566,
            70042682,
            70047909,
            70043816
        ],
        "D": [
            70074507,
            70056625,
            70066825,
            70066273,
            70065758,
            70080888,
            70054873,
            70061627,
            70061405,
            70061792,
            70060518,
            70061003,
            70060842,
            70058946,
            70066151,
            70062202,
            70062779,
            70063466,
            70066431
        ],
        "E": [
            70059567,
            70078936,
            70081396,
            70066368,
            70109259,
            144418642,
            70793684
        ],
        "F": [
            70045991,
            70079097,
            70083257,
            150010321,
            70714928
        ]
    },
    "name": "B. Array Sharpening",
    "statement": "You’re given an array a_1,\r\nldots, a_n of n non-negative integers.Let’s call it if and only if there\r\nexists an integer 1\r\nle k\r\nle n such that a_1 < a_2 <\r\nldots < a_k and a_k > a_{k+1} >\r\nldots > a_n. In particular, any strictly increasing or strictly\r\ndecreasing array is . For example: The arrays [4], [0, 1], [12, 10, 8]\r\nand [3, 11, 15, 9, 7, 4] are sharpened; The arrays [2, 8, 2, 8, 6, 5],\r\n[0, 1, 1, 0] and [2, 5, 6, 9, 8, 8] are sharpened. You can do the\r\nfollowing operation as many times as you want: choose any element of the\r\narray, and decrease it by one. Formally, you can choose any i (1\r\nle i\r\nle n) such that a_i>0 and assign a_i := a_i - 1.Tell if it’s possible to\r\nmake the given array using some number (possibly zero) of these\r\noperations.\r\n",
    "solutions": [
        "/*\nIZ*ONE\n\nLa vie en Rose\n2018.10.29\n\nVioleta\n2019.04.01\n\nFiesta\n2020.02.17\n*/\n\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\nusing namespace std;\n\nint n, w[301000];\n\nvoid Process() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tint Mn = 1e9;\n\tint Mx = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tif (w[i] < i - 1)Mn = min(Mn, i);\n\t\tif (w[i] < n - i)Mx = max(Mx, i);\n\t}\n\tif (Mx + 1 <= Mn - 1) {\n\t\tputs(\"Yes\");\n\t}\n\telse puts(\"No\");\n}\n\nint main() {\n\tint Tcase;\n\tscanf(\"%d\", &Tcase);\n\twhile (Tcase--) {\n\t\tProcess();\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Array Sharpening.json",
    "editorial_link": "https://codeforces.com//blog/entry/73563",
    "editorial": "How to know if we can make the prefix strictly increasing? We just have\r\nto consider the following simple greedy solution: take down values to\r\n(minimal possible values). Itâs possible if and only if holds in the\r\nwhole prefix.Similarly, the suffix can be made strictly decreasing if\r\nand only if holds in the whole suffix.Using these simple facts, we can\r\ncompute the longest prefix we can make strictly increasing, and the\r\nlongest suffix we can make strictly decreasing in . Then, we just have\r\nto check that their intersection is non-empty.\r\n",
    "hint": []
}