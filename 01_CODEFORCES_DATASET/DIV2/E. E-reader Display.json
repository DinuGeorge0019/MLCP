{
    "link": "https://codeforces.com//contest/127/problem/E",
    "problemId": "671",
    "problem_idx": "E",
    "shortId": "127E",
    "contest_number": "127",
    "problem_submissions": {
        "C": [
            850036,
            853243,
            846749,
            850308,
            846400,
            846988,
            845889,
            846983,
            848328,
            847795,
            850207,
            848393,
            852965,
            852478
        ],
        "E": [
            847897,
            853236,
            852099,
            849554,
            849938,
            852088,
            847325,
            849147,
            850677,
            850641,
            851469,
            847732,
            853167,
            848319
        ],
        "D": [
            846279,
            853241,
            847740,
            846696,
            846866,
            848133,
            848630,
            6502633,
            848689,
            855255,
            848044,
            852652,
            849109,
            849008,
            849880,
            850099
        ],
        "B": [
            844434,
            853246,
            843634,
            844201,
            843671,
            852802,
            849355,
            844696,
            844897,
            844537,
            843982,
            844433,
            845330,
            844159,
            844315,
            844292,
            844410,
            844073
        ],
        "A": [
            843764,
            853248,
            844472,
            843689,
            844407,
            843900,
            849942,
            843939,
            843940,
            843968,
            843625,
            843834,
            844583,
            843676,
            843729,
            843791,
            844024,
            843613
        ]
    },
    "name": "E. E-reader Display",
    "statement": "After years of hard work scientists invented an absolutely new e-reader\r\ndisplay. The new display has a larger resolution, consumes less energy\r\nand its production is cheaper. And besides, one can bend it. The only\r\ninconvenience is highly unusual management. For that very reason the\r\ndevelopers decided to leave the e-readers\u2019 software to programmers.The\r\ndisplay is represented by square of pixels, each of which can be either\r\nblack or white. The display rows are numbered with integers from to\r\nupside down, the columns are numbered with integers from to from the\r\nleft to the right. The display can perform commands like \"\". When a\r\ntraditional display fulfills such command, it simply inverts a color of\r\n, where is the row number and is the column number. But in our new\r\ndisplay every pixel that belongs to at least one of the segments and\r\n(both ends of both segments are included) inverts a color.For example,\r\nif initially a display in size is absolutely white, then the sequence of\r\ncommands , , , leads to the following changes: You are an e-reader\r\nsoftware programmer and you should calculate minimal number of commands\r\nneeded to display the picture. You can regard all display pixels as\r\ninitially white.\r\n",
    "solutions": [
        "// Friendship is Magic\n#pragma comment(linker, \"/STACK:32000000\")\n\n#include <memory.h>\n#include <string.h>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define maxn 2005\n\nint n;\nchar s[maxn];\nint a[maxn][maxn];\nint invx[maxn], invy[maxn], invx2[maxn], invy2[maxn];\n\nvoid do_solve() {\n    scanf(\"%d\", &n);        \n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", s);\n        for (int j = 0; j < n; j++) a[i][j] = s[j] - '0';\n    }\n    int res = 0;\n    for (int x0 = 0; x0 + 1 < n; x0++)\n        for (int y = n-1, x = x0; x >= 0; y--, x--)\n        {\n            if (a[x][y] ^ invx[x] ^ invy[y])\n            {\n                res++;\n                invx[x] = 1 - invx[x];\n                invy[y] = 1 - invy[y];\n            }\n        }\n\n    for (int x0 = n-1; x0 > 0; x0--)\n        for (int x = x0, y = 0; x < n; x++, y++)\n        {\n            if (a[x][y] ^ invx2[x] ^ invy2[y])\n            {\n                res++;\n                invx2[x] = 1 - invx2[x];\n                invy2[y] = 1 - invy2[y];\n            }\n        }\n\n    for (int i = 0; i < n; i++)\n        if (a[i][i] ^ invx[i] ^ invy[i] ^ invx2[i] ^ invy2[i])\n            res++;\n    \n    cout << res;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    do_solve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. E-reader Display.json",
    "editorial_link": "https://codeforces.com//blog/entry/3140",
    "editorial": "You can see that every command i,?j you should do no more than once. Also order of commands doesn't matter. Actually, sequence of command you can represent as boolean matrix A with size n?\u00d7?n, where aij?=?1 mean that you do the command i,?j, and aij?=?0 mean that you don't do it.\n\nLet us describe one way to construct the matrix.\n\nLet the starting image is boolean matrix G. A boolean matrix B of size n?\u00d7?n stores intermediate image that you will recieve during process of doing commands.\n\nFor the upper half of matrix G without main diagonal you should move line by line from the up to the down. For every line you should move from the right to the left. You can see that for every positions all nonconsidered positions do not affect the current position. So, if you see that values for position  i,?j in the matrices G and B are different, you should do command i,?j: set in the matrix A aij?=?1, and change segments (i,?i)?-?(i,?j) and (j,?j)?-?(i,?j) in the matrix B.\n\nFor the lower half of the matrix G without main diagonal you should do it absolutely symmetric. At the end you should iterate over main diagonal. Here it should be clear.\n\nWell, for matrix G you always can build matrix A and do it by exactly one way. It mean that this way requires minimum number of commands. So, you can get answer for problem by following way: you can build the matrix A from the matrix G and output number of ones in the matrix A.\n\nThere is only one problem that you should solve. Algorithm that you can see above works in O(n3), that doesn't fit into time limits. Let's speed up it to O(n2). Consider in the matrix B the upper half without main diagonal. During doing commands all columns of cells that placed below current position will have same values. Values above current position are not matter for us. Therefore instead of the matrix B you can use only one array that stores values of columns. It allows you do every command in O(1) instead of O(n). This optimization gives a solution that works in O(n2)."
}