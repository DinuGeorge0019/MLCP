{
    "link": "https://codeforces.com//contest/545/problem/C",
    "problemId": "28036",
    "problem_idx": "C",
    "shortId": "545C",
    "contest_number": "545",
    "problem_submissions": {
        "E": [
            11152908,
            11157700,
            11157522,
            11156542,
            11161300,
            11156960,
            11158926,
            11159332,
            11158333,
            11161026,
            11158857,
            11159720,
            11174097,
            11173935,
            11160858,
            11161651,
            11159778,
            11161054,
            11160310,
            11161820,
            11163252
        ],
        "C": [
            11150440,
            11147958,
            11150824,
            11150276,
            11148970,
            11148884,
            11153300,
            11153422,
            11152117,
            11151008,
            11151654,
            11153299,
            11155654,
            11152365,
            11152087,
            11153750,
            11154873,
            11151525,
            11151659
        ],
        "D": [
            11148301,
            11149439,
            11148692,
            11151407,
            11150444,
            11147349,
            11150296,
            11170906,
            11151431,
            11154441,
            11153203,
            11155014,
            11154361,
            11150015,
            11154687,
            11154652,
            11154830,
            11154199,
            11153829,
            11150376
        ],
        "B": [
            11147493,
            11152440,
            11147604,
            11147721,
            11147256,
            11149962,
            11148762,
            11149882,
            11149290,
            11148961,
            11148519,
            11150280,
            11148361,
            11149006,
            11149406,
            11151773,
            11147710,
            11148107,
            11147713
        ],
        "A": [
            11146984,
            11151375,
            11147061,
            11147027,
            11146977,
            11151139,
            11147222,
            11147723,
            11147389,
            11147403,
            11160745,
            11149107,
            11147430,
            11147598,
            11148409,
            11148792,
            11148668,
            11147021,
            11147024
        ]
    },
    "name": "C. Woodcutters",
    "statement": "Little Susie listens to fairy tales before bed every day. Today\u2019s fairy\r\ntale was about wood cutters and the little girl immediately started\r\nimagining the choppers cutting wood. She imagined the situation that is\r\ndescribed below.There are trees located along the road at points with\r\ncoordinates . Each tree has its height . Woodcutters can cut down a tree\r\nand fell it to the left or to the right. After that it occupies one of\r\nthe segments or . The tree that is not cut down occupies a single point\r\nwith coordinate . Woodcutters can fell a tree if the segment to be\r\noccupied by the fallen tree doesn\u2019t contain any occupied point. The\r\nwoodcutters want to process as many trees as possible, so Susie wonders,\r\nwhat is the maximum number of trees to fell.\r\n",
    "solutions": [
        "//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 1e6 + 9;\npair<int,int> sweep[Maxn];\nint x[Maxn],h[Maxn];\nint main(){\n\tios_base::sync_with_stdio(0);\n\tint n;\n\tcin >> n;\n\tint last = -1e9 - 10;\n\tint ans = 0,ed = 0;\n\tfor(int i = 0; i < n;i++){\n\t\tcin >> x[i] >> h[i];\n\t}\n\tfor(int i = 0; i < n;i++){\n\t\tif(i == n - 1 || x[i+1] > x[i] + h[i]){\n\t\t\tsweep[ed++] = make_pair(x[i]+h[i],x[i]);\n\t\t}\n\t\tif(!i || x[i - 1] < x[i] - h[i]) sweep[ed++] = make_pair(x[i],x[i] - h[i]);\n\t}\n\tsort(sweep,sweep + ed);\n\tfor(int i = 0; i < ed;i++){\n\t\tint r = sweep[i].first,l = sweep[i].second;\n\t\tif(l > last) {\n\t\t\tans++;\n\t\t\tlast = r;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Woodcutters.json",
    "editorial_link": "https://codeforces.com//blog/entry/17982",
    "editorial": "One can solve this problem using dynamic programming or greedy\r\nalgorithm. Start with DP solution. Define , and as maximal count of\r\ntrees that woodcutters can fell, if only trees with number from to\r\nexist, and -th tree isn\u00e2\u0080\u0099t cutted down, -th tree is cutted down and\r\nfallen left, -th tree is cutted down and fallen right correspondingly.\r\nNow we can compute this values for each from to by time because for each\r\nnext we need only two previous value. Answer is maximum of , , . Also\r\nthis problem can be solved by the next greedy algoritm. Let\u00e2\u0080\u0099s fell\r\nleftmost tree to the left (it always doesn\u00e2\u0080\u0099t make an answer worse).\r\nAfter that, try to fell the next tree. If we can fell it to the left,\r\nlet\u00e2\u0080\u0099s do it (because it also always doesn\u00e2\u0080\u0099t make an answer worse). If we\r\ncan\u00e2\u0080\u0099t, then try to fell it to the right. If it is possible, let\u00e2\u0080\u0099s do it.\r\nLast step is correct because felling some tree to the right may only\r\nprevent the next tree\u00e2\u0080\u0099s fallen. So we may \"exchange\" one tree to another\r\nwithout worsing an answer. Time complexity .\r\n"
}