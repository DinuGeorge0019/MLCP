{
    "link": "https://codeforces.com//contest/1836/problem/E",
    "problemId": "1971177",
    "problem_idx": "E",
    "shortId": "1836E",
    "contest_number": "1836",
    "problem_submissions": {
        "E": [
            210147681,
            210156192,
            210163487,
            210136429,
            210157213,
            210315010,
            210158073,
            210164123,
            210155192,
            210164163,
            210159525
        ],
        "C": [
            210130232,
            210131057,
            210124529,
            210133873,
            210151231,
            210126284,
            210133931,
            210138158,
            210136673,
            210132463,
            210128133,
            210140056,
            210148028,
            210143853,
            210137711,
            210137608,
            210128551,
            210120166,
            210126121
        ],
        "B": [
            210123440,
            210126296,
            210116405,
            210125585,
            210144712,
            210122722,
            210125845,
            210141461,
            210122883,
            210123468,
            210120670,
            210126915,
            210118094,
            210134923,
            210163701,
            210137111,
            210115730,
            210115790
        ],
        "A": [
            210111620,
            210110060,
            210110623,
            210116661,
            210139143,
            210111484,
            210110034,
            210110353,
            210111957,
            210118244,
            210112250,
            210110488,
            210111107,
            210115218,
            210110094,
            210110963,
            210112266,
            210116067,
            210110124
        ],
        "D": [
            210158558,
            210154147,
            210162752,
            210191544,
            210162490,
            210160449,
            210160513,
            210163603
        ]
    },
    "name": "E. Twin Clusters",
    "statement": "Famous worldwide astrophysicist Mleil waGrasse Tysok recently read about\r\nthe existence of . Before he shares this knowledge with the broader\r\naudience in his podcast called , he wants to prove their presence on his\r\nown. Mleil is aware that the vastness of the universe is astounding\r\n(almost as astounding as his observation skills) and decides to try his\r\nluck and find some new pair of twin clusters.To do so, he used his\r\nTLEscope to observe a part of the night sky that was not yet examined by\r\nhumanity in which there are exactly 2^{k + 1} galaxies in a row. i-th of\r\nthem consist of exactly 0\r\nle g_i < 4^k stars.A galaxy cluster is any non-empty contiguous segment\r\nof galaxies. Moreover, its\u2019 is said to be equal to the bitwise XOR of\r\nall values g_i within this range.Two galaxy clusters are considered\r\ntwins if and only if they have the same traits and their corresponding\r\nsegments are .Write a program that, for many scenarios, will read a\r\ndescription of a night sky part observed by Mleil and outputs a location\r\nof two intervals belonging to some twin clusters pair, or a single value\r\n-1 if no such pair exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ninline bool good(int& l1, int& r1, int& l2, int& r2){\n\tif (l1 > l2){\n\t\tswap(l1, l2);\n\t\tswap(r1, r2);\n\t}\n\t\n\t//l1 <= l2\n\tif (r1 < l2) return true;\n\tint r1_new = l2 - 1;\n\tint l2_new = r1 + 1;\n\tr1 = r1_new;\n\tl2 = l2_new;\n\treturn l1 <= r1 && l2 <= r2;\n}\n\nvector<int> solve(int k, int sz, const vector<long long>& g){\n\tmap<long long, pair<int, int>> memo;\n\tvector<long long> s(sz);\n\ts[0] = g[0];\n\tfor(int i = 1; i < sz; ++i){\n\t\ts[i] = s[i - 1] ^ g[i];\n\t}\n\t\n\tint it = 0;\n\twhile(true){\n\t\tit++;\n\t\tint r = rng() % sz;\n\t\tint l = rng() % (r + 1);\n\t\tlong long value = s[r] ^ (l == 0 ? 0 : s[l - 1]);\n\t\tif (memo.count(value)){\n\t\t\tint l2 = memo[value].first;\n\t\t\tint r2 = memo[value].second;\n\t\t\tint l1 = l, r1 = r;\n\t\t\tif (good(l1, r1, l2, r2)){\n\t\t\t\treturn {l1, r1, l2, r2};\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo[value] = {l, r};\n\t}\n}\n\nint main(){\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tint k; \n\t\tcin >> k;\n\t\tint sz = 1 << (k + 1);\n\t\tvector<long long> g(sz);\n\t\tfor(int i = 0; i < sz; ++i){\n\t\t\tcin >> g[i];\n\t\t}\n\t\t\n\t\tvector<int> result = solve(k, sz, g);\n\t\tfor(int i: result){\n\t\t\tcout << i + 1 << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "meet-in-the-middle",
        "probabilities"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Twin Clusters.json",
    "editorial_link": "https://codeforces.com//blog/entry/117394",
    "editorial": "Deterministic solution:Let us first look for segments that zeros first\r\n(out of ) bits. Since we have , then we have prefix xors of the array\r\n(along with en empty prefix). Let us look at the xor prefix modulo .\r\nEach time we have a prefix xor that has already occurred before let us\r\nmatch it with this previous occurrence. We will find at least such\r\nsegments. Note that segments have pairwise different ends and pairwise\r\ndifferent beginnings.Each of those segments generates some kind of xor\r\nvalue on the other bits. Since there is only different possible values,\r\ndue to pigeon principle there will be two segments that generate same\r\nxor. We select those two intervals. If they are disjoint then we already\r\nfound the answer. Otherwise the final answer will be the xor of those\r\ntwo segments (values that are covered only by one of them). It can be\r\nshowed that we will obtain two disjoint, non-empty\r\nsegments.Nondeterministic solution:If there are any duplicates in the\r\narray, then we can take two one-element arrays and obtain answer. From\r\nnow on we will assume that no duplicates occur in the array.Let us\r\nobserve that number of valid segments is equal to which is over twice\r\nlarger than all possible xor values for a segment which is . This\r\nsuggest, that chances of collision of two random segments is quite high.\r\nFor simplicity let us assume there is exactly segments. Let us look at\r\nthe final distribution over the xors used by segments. It can be showed\r\nby exchange argument, that the the distribution that needs the most\r\nrandom tosses to obtain collision is the one in which every xor value is\r\nused by exactly two segments. Since we choose segments randomly, by\r\nbirthday paradox the expected time of obtaining a collision is around\r\n2^k. Now there is a chance, that we will toss the same segment twice,\r\nbut if we multiply the number of tossing by then chance that we find two\r\ndifferent segments is very high (in reality even less random choices are\r\nnecessary).There is another issue, even if we find two different\r\nsegments with the same xor values. They can use common elements. But\r\nthen we can simply take only the elements that belong to the exactly one\r\nof them.Still if the segments had common end one of the obtained\r\nsegments would be empty. To omit this issue let us see that the second\r\nobtained segment would have xor equal to . So now we can take any prefix\r\nand corresponding suffix as an answer. Unfortunately this segment can\r\nhave length . But in this case the only element in the segment has to be\r\nequal to .There must be at most one number in the array, so we can\r\nsimply get rid of it (shorten the array by one). The analysis still\r\nholds (with some slight modifications).\r\n"
}