{
    "link": "https://codeforces.com//contest/919/problem/E",
    "problemId": "152091",
    "problem_idx": "E",
    "shortId": "919E",
    "contest_number": "919",
    "problem_submissions": {
        "E": [
            34759854,
            34759008,
            34755530,
            34755071,
            34767384,
            34769825,
            34762286,
            34765859,
            34757902,
            34756808,
            34754350,
            34754906,
            34754485,
            34764184,
            34764060,
            34765778,
            34765644,
            34766112,
            34770806,
            34758487
        ],
        "D": [
            34759692,
            34756182,
            34766669,
            34747857,
            34750540,
            34761944,
            34744086,
            34755286,
            34747306,
            34747805,
            34758206,
            34746635,
            34748995,
            34743941,
            34750352,
            34751132,
            34754972,
            34756086,
            34749125,
            34751985
        ],
        "F": [
            34756268,
            34770726,
            34767209,
            34940216,
            34940205,
            34940167,
            34768110
        ],
        "C": [
            34755543,
            34745303,
            34743775,
            34749427,
            34742058,
            34751454,
            34747057,
            34746048,
            34744189,
            34743121,
            34786015,
            34743288,
            34741969,
            34754924,
            34754196,
            34743195,
            34748307,
            34749924,
            34748253,
            34744412
        ],
        "A": [
            34741202,
            34738877,
            34738230,
            34738207,
            34743521,
            34740387,
            34738030,
            34738271,
            34738995,
            34738099,
            34737984,
            34739113,
            34738625,
            34738247,
            34738122,
            34738762,
            34738024,
            34737950,
            34738747
        ],
        "B": [
            34740191,
            34740735,
            34740551,
            34773488,
            34738696,
            34749487,
            34740570,
            34740622,
            34740449,
            34739728,
            34741488,
            34740826,
            34738595,
            34739371,
            34739374,
            34739976,
            34741055,
            34741170,
            34739403,
            34740674
        ]
    },
    "name": "E. Congruence Equation",
    "statement": "Given an integer x. Your task is to find out how many positive integers\r\nn (1\r\nleq n\r\nleq x) satisfy n\r\ncdot a^n\r\nequiv b\r\nquad (\r\ntextrm{mod}\r\n;p), where a, b, p are all known constants.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef long long LL;\n\nint a,b,p,cnt;\nLL x,tmp,r,P,ans;\n\ninline LL Pow(LL a,int b)\n{\n    LL ans=1;\n    for(;b;b>>=1,a=a*a%p)if(b&1)ans=ans*a%p;\n    return ans;\n}\n\nsigned main()\n{\n    scanf(\"%d%d%d%lld\",&a,&b,&p,&x);\n    P=(LL)p*(p-1);\n    for(int i=1;i<p;i++)\n    {\n        tmp=Pow(a,i);\n        tmp=b*Pow(tmp,p-2)%p;\n        r=((LL)p*i+(LL)(p-1)*(p-1)%P*tmp)%P;\n        ans+=x/P+(x%P>=r);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "chinese remainder theorem",
        "math",
        "number theory"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Congruence Equation.json",
    "editorial_link": "https://codeforces.com//blog/entry/57462",
    "editorial": "Trying all integers from to is too slow to solve this problem. So we\r\nneed to find out some features of that given equation.Because we have\r\nwhen is a prime, it is obvious that falls into a loop and the looping\r\nsection is . Also, has a looping section . We can try to list a chart to\r\nshow what is with some specific . (In the chart shown below, is equal to\r\n) For a certain , we can see that And itâs not hard for us to prove that\r\nhas a looping section . So we donât need to list .Therefore, we can\r\nenumerate from to and calculate . Letâs say the result is , then we have\r\n(You can refer to the chart shown above to see if it is). So for a\r\ncertain , the possible can only be . Then we can calculate how many\r\npossible answers in this situation (i.e. decide the minimum and maximum\r\npossible using the given lower bound and upper bound ). Finally we add\r\nthem together and get the answer. or depending on how you calculate .By\r\nthe way, you can also try to solve this problem.\r\n",
    "hint": []
}