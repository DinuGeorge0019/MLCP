{"link": "https://codeforces.com//contest/1561/problem/F", "problemId": "1088962", "problem_idx": "F", "shortId": "1561F", "contest_number": "1561", "problem_submissions": {"F": [126904536, 126901655, 126903407, 126897889, 126905462, 126895857, 126909746, 126868411], "E": [126872829, 126873450, 126873472, 126876837, 126887119, 126925237, 126873365, 126880329, 126880730, 126881569, 126878334, 126883106, 126884943, 126885452, 126887344, 126884906, 126885650, 126888199, 126863450], "C": [126869012, 126865542, 126864086, 126863127, 126863122, 126861060, 126868974, 126853568, 126857674, 126857569, 126854957, 126857844, 126858666, 126860889, 126860513, 126857734, 126864125, 126867660, 126866693], "D1": [126861759, 126863688, 126864717, 126869692, 126872900, 126868199, 126862491, 126866683, 126868762, 126864055, 126863339, 126863270, 126867571, 126865653, 126863522, 126870959, 126872615, 126860538, 126862556], "D2": [126861568, 126863750, 126868373, 126869562, 126876457, 126868351, 126862413, 126873746, 126868674, 126867473, 126864201, 126863508, 126868989, 126866379, 126880112, 126871782, 126872752, 126861102, 126877754], "B": [126856962, 126852931, 126853927, 126857335, 126862047, 126855473, 126854073, 126848963, 126854204, 126852816, 126866896, 126854673, 126855023, 126857298, 126855876, 126863677, 126859086, 126871391, 126876744], "A": [126847903, 126848403, 126847412, 126849843, 126849112, 126848036, 126848332, 126847281, 126847584, 126847566, 126847516, 126847717, 126847410, 126847430, 126850448, 126848322, 126849200, 126856163, 126853136]}, "name": "F. Top-Notch Insertions", "statement": "Consider the insertion sort algorithm used to sort an integer sequence\r\n[a_1, a_2,\r\nldots, a_n] of length n in non-decreasing order.For each i in order from\r\n2 to n, do the following. If a_i\r\nge a_{i-1}, do nothing and move on to the next value of i. Otherwise,\r\nfind the smallest j such that a_i < a_j, shift the elements on positions\r\nfrom j to i-1 by one position to the right, and write down the initial\r\nvalue of a_i to position j. In this case we\u2019ll say that we performed an\r\nof an element from position i to position j.It can be noticed that after\r\nprocessing any i, the prefix of the sequence [a_1, a_2,\r\nldots, a_i] is sorted in non-decreasing order, therefore, the algorithm\r\nindeed sorts any sequence.For example, sorting [4, 5, 3, 1, 3] proceeds\r\nas follows: i = 2: a_2\r\nge a_1, do nothing; i = 3: j = 1, insert from position 3 to position 1:\r\n[3, 4, 5, 1, 3]; i = 4: j = 1, insert from position 4 to position 1: [1,\r\n3, 4, 5, 3]; i = 5: j = 3, insert from position 5 to position 3: [1, 3,\r\n3, 4, 5]. You are given an integer n and a list of m integer pairs (x_i,\r\ny_i). We are interested in sequences such that if you sort them using\r\nthe above algorithm, exactly m insertions will be performed: first from\r\nposition x_1 to position y_1, then from position x_2 to position y_2,\r\n..., finally, from position x_m to position y_m.How many sequences of\r\nlength n consisting of (not necessarily distinct) integers between 1 and\r\nn, inclusive, satisfy the above condition? Print this number modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include<bits/stdc++.h>\n#include<ext/rope>\nusing namespace std;\nusing namespace __gnu_cxx;\ntypedef long long LL;\nconst LL MOD=998244353;\nLL QuickPow(LL x,LL p)\n{\n\tLL ans=1,base=x;\n\twhile(p)\n\t{\n\t\tif(p&1)\tans=ans*base%MOD;\n\t\tbase=base*base%MOD;\n\t\tp>>=1;\n\t}\n\treturn ans;\n}\nLL fac[500005],ifac[500005];\nLL C(LL n,LL m){return (n<m || m<0)?0:fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;}\nint cnt;\nstruct fhqTreap{\n\tint root;\n\tstruct node{\n\t\tint ch[2],siz,val,tag,key;\n\t}fhq[500005];\n\t#define lc fhq[now].ch[0]\n\t#define rc fhq[now].ch[1]\n\tint newnode(int val){\n\treturn ++cnt,\n\tfhq[cnt].ch[0]=fhq[cnt].ch[1]=fhq[cnt].tag=0,\n\tfhq[cnt].siz=1,fhq[cnt].val=val,\n\tfhq[cnt].key=rand(),\n\tcnt;}\n\tvoid push_down(int now)\n\t{\n\t\tif(!now)\treturn ;\n\t\tif(fhq[now].tag)\n\t\t{\n\t\t\tif(lc)\tfhq[lc].val+=fhq[now].tag,fhq[lc].tag+=fhq[now].tag;\n\t\t\tif(rc)\tfhq[rc].val+=fhq[now].tag,fhq[rc].tag+=fhq[now].tag;\n\t\t\tfhq[now].tag=0;\n\t\t}\n\t}\n\tvoid push_up(int now){if(now)\tfhq[now].siz=fhq[lc].siz+fhq[rc].siz+1;}\n\tvoid split(int now,int val,int &x,int &y)\n\t{\n\t\tif(!now)\tx=y=0;\n\t\telse\n\t\t{\n\t\t\tpush_down(now);\n\t\t\tif(val>=fhq[now].val)\n\t\t\t{\n\t\t\t\tx=now;\n\t\t\t\tsplit(rc,val,rc,y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty=now;\n\t\t\t\tsplit(lc,val,x,lc);\n\t\t\t}\n\t\t\tpush_up(now);\n\t\t}\n\t}\n\tint merge(int x,int y)\n\t{\n\t\tif(!x || !y)\treturn x+y;\n\t\tif(fhq[x].key>fhq[y].key)\n\t\t{\n\t\t\tpush_down(x);\n\t\t\tfhq[x].ch[1]=merge(fhq[x].ch[1],y);\n\t\t\tpush_up(x);\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpush_down(y);\n\t\t\tfhq[y].ch[0]=merge(x,fhq[y].ch[0]);\n\t\t\tpush_up(y);\n\t\t\treturn y;\n\t\t}\n\t}\n\tbool check(int val,int now)\n\t{\n\t\tif(!now)\treturn false;\n\t\tif(fhq[now].val==val)\treturn true;\n\t\tpush_down(now);\n\t\tif(val<fhq[now].val)\treturn check(val,lc);\n\t\treturn check(val,rc);\n\t}\n}tr;\nint n,m,x[500005],y[500005];\nvoid Solve()\n{\n\tscanf(\"%d %d\",&n,&m);\n\ttr.root=cnt=0;\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\tint tx,ty;\n\t\tbool st=tr.check(y[i],tr.root);\n\t\ttr.split(tr.root,y[i]-1,tx,ty);\n\t\tif(ty)\t++tr.fhq[ty].val,++tr.fhq[ty].tag;\n\t\tif(st)\ttr.root=tr.merge(tx,ty);\n\t\telse\ttr.root=tr.merge(tr.merge(tx,tr.newnode(y[i]+1)),ty);\n\t}\n\tprintf(\"%lld\\n\",C(2*n-cnt-1,n));\n}\nint main(){\n\tsrand(time(NULL));\n\tfac[0]=1;\n\tfor(LL i=1;i<=400000;++i)\tfac[i]=fac[i-1]*i%MOD;\n\tifac[400000]=QuickPow(fac[400000],MOD-2);\n\tfor(LL i=399999;~i;--i)\tifac[i]=ifac[i+1]*(i+1)%MOD;\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0)\tSolve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "data structures"], "dificulty": "2600", "interactive": false}