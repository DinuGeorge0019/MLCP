{
    "link": "https://codeforces.com//contest/102/problem/D",
    "problemId": "540",
    "problem_idx": "D",
    "shortId": "102D",
    "contest_number": "102",
    "problem_submissions": {
        "E": [
            580263,
            580953,
            581308,
            581985,
            581758
        ],
        "C": [
            578820,
            579173,
            578007,
            579151,
            579764,
            578919,
            578681,
            578983,
            583837,
            578965,
            579464,
            579436,
            579733,
            579841,
            579762,
            579738,
            579303,
            578048
        ],
        "B": [
            578201,
            578415,
            579224,
            578432,
            578792,
            578223,
            578036,
            578319,
            578556,
            578163,
            578498,
            578132,
            578865,
            578924,
            578861,
            578456,
            578451,
            578242
        ],
        "A": [
            577939,
            577968,
            579499,
            577995,
            578148,
            577931,
            577913,
            577937,
            578260,
            584365,
            584355,
            577896,
            578026,
            577924,
            578123,
            578309,
            578318,
            577999,
            578177,
            582576
        ],
        "D": [
            586480,
            579333,
            580247,
            583101,
            580679,
            580477,
            580526,
            581021,
            580832,
            580959,
            581123,
            580916,
            580982,
            581055,
            580866,
            579880
        ]
    },
    "name": "D. Buses",
    "statement": "Little boy Gerald studies at school which is quite far from his house.\r\nThat’s why he has to go there by bus every day. The way from home to\r\nschool is represented by a segment of a straight line; the segment\r\ncontains exactly bus stops. All of them are numbered with integers from\r\nto in the order in which they follow from Gerald’s home. The bus stop by\r\nGerald’s home has number and the bus stop by the school has number\r\n.There are buses running between the house and the school: the -th bus\r\ngoes from stop to (), visiting all the intermediate stops in the order\r\nin which they follow on the segment. Besides, Gerald’s no idiot and he\r\nwouldn’t get off the bus until it is still possible to ride on it closer\r\nto the school (obviously, getting off would be completely pointless). In\r\nother words, Gerald can get on the -th bus on any stop numbered from to\r\ninclusive, but he can get off the -th bus only on the bus stop .Gerald\r\ncan’t walk between the bus stops and he also can’t move in the direction\r\nfrom the school to the house.Gerald wants to know how many ways he has\r\nto get from home to school. Tell him this number. Two ways are\r\nconsidered different if Gerald crosses some segment between the stops on\r\ndifferent buses. As the number of ways can be too much, find the\r\nremainder of a division of this number by ().\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <stdlib.h>\n\nstruct pr{int num, v, fl;} pp[200005], pp2[200005];\nint s[100005], f[100005], n, m, top;\nlong long num_f[200005], v[200005];\n\nint cmp(const void *c1, const void *c2)\n{return ((pr*)c1)->v-((pr*)c2)->v;}\n\nint max(int a, int b) {return a>b? a: b;}\n\nint main()\n{\n    int i, j, a, b, f1;\n    long long d=1000000007, tmp;\n    scanf(\"%d %d\", &n, &m);\n    for(i=0; i<m; i++)\n    {\n        scanf(\"%d %d\", &a, &b);\n        pp[2*i].v=a; pp[2*i+1].v=b;\n        pp[2*i].fl=0; pp[2*i+1].fl=1; \n        pp[2*i].num=pp[2*i+1].num=i;\n    }\n    qsort(pp, 2*m, sizeof(pr), cmp);\n    if (pp[0].v>0) {printf(\"0\"); return 0;}\n    if (pp[2*m-1].v<n) {printf(\"0\"); return 0;}\n    for(i=0; i<2*m; i++) pp2[i]=pp[i];\n    for(i=1; i<2*m; i++)\n        if (pp[i].v==pp[i-1].v) pp2[i].v=pp2[i-1].v;\n        else pp2[i].v=pp2[i-1].v+1;\n    top=pp2[2*m-1].v+1;\n    for(i=0; i<2*m; i++)\n        if (pp2[i].fl) f[pp2[i].num]=pp2[i].v;\n        else s[pp2[i].num]=pp2[i].v;\n    for(i=0; i<m; i++)\n        num_f[f[i]]++;\n    j=1; v[0]=1;\n    for(i=0; i<2*m; i++)\n        if (pp2[i].fl) \n        {\n            for(; j<pp2[i].v; j++) v[j]=(v[j]+v[j-1])%d;\n            if (s[pp2[i].num]-1<0) tmp=0;\n            else tmp=v[s[pp2[i].num]-1];\n            v[pp2[i].v]=(d+v[pp2[i].v]+v[pp2[i].v-1]-tmp)%d;\n        }\n    printf(\"%lld\", v[top-1]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Buses.json",
    "editorial_link": "https://codeforces.com//blog/entry/2393",
    "editorial": "For every slop from 0 to n lets calculate kx - number of ways come to them. Consider the i-th bus. Number of ways come to stop ti applied i-th bus is uqual to number of way to embus to i-th bus.\nOne can embus to i-th bus on the stops si,?si?+?1,?...,?ti?-?1. Thus number of ways come to stop ti in the i bus is equal to sum ksi?+?ksi?+?1?+?...?+?kti?-?1. Finally, lets note that overall number of way to come to stop ti is the sum of numbers of ways to come to stop ti on every bus.\nIt's remained two problems. First problem: 0???n???109. Therefore all kx not climb in memory limit. But we need to know only non-zero kx. For instance, one can gripe coordinates: create list of all occured stops (and also stops 0 and n), sort this list, delete the repeated stops and replace all numbers of stops they indexes in this list. After this operations all number of stops not exceed 200001, and all kx are climb to the memory.\nSecond problem: if we will use loop \"for\" for counting sum ksi?+?ksi?+?1?+?...?+?kti?-?1, asymptotic of time of working will be O(m^2). There is an easy way to solve this problem: one can create and update array sum[], such that sum[i]?=?k[0]?+?k[1]?+?...?+?k[i?-?1], by another words, sum[0]?=?0,?sum[i?+?1]?=?sum[i]?+?k[i].\nThen munber of ways to come to stop ti using bus i is equal to sum[ti]?-?sum[si].\nSo time complexity is O(m \\cdot log(m)), memory complexity is O(m).",
    "hint": []
}