{"link": "https://codeforces.com//contest/160/problem/D", "problemId": "977", "problem_idx": "D", "shortId": "160D", "contest_number": "160", "problem_submissions": {"E": [1302014, 1301400, 1301723, 1307282, 1307281], "C": [1300399, 1296100, 1297834, 1296838, 1295835, 1299587, 1298372, 1299856, 1297589, 1298396, 1305413, 1299188, 1297999, 1298453, 1300558, 1297702], "D": [1298476, 1301798, 1300820, 1302679, 1303700, 1303100, 1312626, 1301986, 1302012], "B": [1295207, 1297802, 1295947, 1295135, 1302419, 1297089, 1295596, 1298115, 1295467, 1296000, 1296940, 1295692, 1296028, 1296085, 1296588, 1295245], "A": [1294660, 1294871, 1294936, 1294584, 1302018, 1295798, 1294840, 1294601, 1294792, 1295753, 1294780, 1294924, 1351569, 1294961, 1294857, 1295932]}, "name": "D. Edges in MST", "statement": "You are given a connected weighted undirected graph without any loops\r\nand multiple edges. Let us remind you that a graph\u2019s is defined as an\r\nacyclic connected subgraph of the given graph that includes all of the\r\ngraph\u2019s vertexes. The of a tree is defined as the sum of weights of the\r\nedges that the given tree contains. The () of a graph is defined as the\r\ngraph\u2019s spanning tree having the minimum possible weight. For any\r\nconnected graph obviously exists the minimum spanning tree, but in the\r\ngeneral case, a graph\u2019s minimum spanning tree is not unique.Your task is\r\nto determine the following for each edge of the given graph: whether it\r\nis either included in MST, or included MST, or MST.\r\n", "solutions": ["/*\n * d.cpp\n *\n *  Created on: 2012-3-6\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_N = 100000 + 10;\n\nint n, m;\n\nstruct Edge {\n\tint a, b, w;\n\tint id;\n\tvoid read() {\n\t\tscanf(\"%d%d%d\", &a, &b, &w);\n\t\t--a, --b;\n\t}\n\tbool operator<(const Edge&e) const {\n\t\treturn w < e.w;\n\t}\n};\n\nEdge es[MAX_N];\n\nint F[MAX_N];\n\nint fd(int x) {\n\treturn F[x] == x ? x : F[x] = fd(F[x]);\n}\n\nstring ans[MAX_N];\n\nvector<pair<int, int> > E[MAX_N];\n\nint ord[MAX_N], low[MAX_N];\nint mark[MAX_N];\nint cur, pt;\n\nvoid dfs(int u, int pid) {\n\tord[u] = low[u] = pt++;\n\tmark[u] = cur;\n\n\tfor (vector<pair<int, int> >::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tint t = e->first, id = e->second;\n\t\tif (id == pid)\n\t\t\tcontinue;\n\t\tif (mark[t] != cur) {\n\t\t\tdfs(t, id);\n\t\t\tlow[u] = min(low[u], low[t]);\n\t\t} else {\n\t\t\tlow[u] = min(low[u], ord[t]);\n\t\t}\n\t}\n\n\tif (pid != -1) {\n\t\tif (low[u] == ord[u]) {\n\t\t\tans[pid] = \"any\";\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tes[i].read();\n\t\tes[i].id = i;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tF[i] = i;\n\t}\n\n\tsort(es, es + m);\n\n\tfor (int i = 0, j; i < m; i = j) {\n\t\tfor (j = i; j < m && es[j].w == es[i].w; ++j)\n\t\t\t;\n\n\t\tfor (int k = i; k < j; ++k) {\n\t\t\tEdge&e = es[k];\n\t\t\tif (fd(e.a) == fd(e.b))\n\t\t\t\tans[e.id] = \"none\";\n\t\t\telse\n\t\t\t\tans[e.id] = \"at least one\";\n\t\t\tE[fd(e.a)].clear();\n\t\t\tE[fd(e.b)].clear();\n\t\t}\n\n\t\tfor (int k = i; k < j; ++k) {\n\t\t\tEdge&e = es[k];\n\t\t\tint a = fd(e.a), b = fd(e.b);\n\t\t\tif (a != b) {\n\t\t\t\tE[a].push_back(make_pair(b, e.id));\n\t\t\t\tE[b].push_back(make_pair(a, e.id));\n\t\t\t}\n\t\t}\n\n\t\t++cur;\n\n\t\tpt = 0;\n\n\t\tfor (int k = i; k < j; ++k) {\n\t\t\tEdge&e = es[k];\n\t\t\tint a = fd(e.a), b = fd(e.b);\n\t\t\tif (a != b) {\n\t\t\t\tif (mark[a] != cur) {\n\t\t\t\t\tdfs(a, -1);\n\t\t\t\t}\n\t\t\t\tif (mark[b] != cur) {\n\t\t\t\t\tdfs(b, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = i; k < j; ++k) {\n\t\t\tEdge&e = es[k];\n\t\t\tint a = fd(e.a), b = fd(e.b);\n\t\t\tF[a] = b;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tputs(ans[i].c_str());\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dsu", "graphs", "sortings"], "dificulty": "2300", "interactive": false}