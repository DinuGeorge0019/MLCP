{
    "link": "https://codeforces.com//contest/404/problem/D",
    "problemId": "7291",
    "problem_idx": "D",
    "shortId": "404D",
    "contest_number": "404",
    "problem_submissions": {
        "B": [
            6081380,
            6071583,
            6070927,
            6071339,
            6070454,
            6070614,
            6072572,
            6071620,
            6071224,
            6072980,
            6072201,
            6072080,
            6071625,
            6070557,
            6072898,
            6071106,
            6072617,
            6072939
        ],
        "A": [
            6081009,
            6068298,
            6068430,
            6069127,
            6068593,
            6068443,
            6069041,
            6068506,
            6069739,
            6068994,
            6068641,
            6068845,
            6068699,
            6071140,
            6069542,
            6069802,
            6068288
        ],
        "E": [
            6077708,
            6078243,
            6080273,
            6089004,
            6098326,
            6095224,
            6104347
        ],
        "D": [
            6074157,
            6076415,
            6075648,
            6078211,
            6077330,
            6077784,
            6078940,
            6079076,
            6079336,
            6078890,
            6080135,
            6077817,
            6078043,
            6080355,
            6079190,
            6077371
        ],
        "C": [
            6072624,
            6074366,
            6073677,
            6073792,
            6072756,
            6073958,
            6074499,
            6073931,
            6073038,
            6075180,
            6075460,
            6076470,
            6074776,
            6073618,
            6075857,
            6074780,
            6076291,
            6078785
        ]
    },
    "name": "D. Minesweeper 1D",
    "statement": "Game \"Minesweeper 1D\" is played on a line of squares, the line\u2019s height\r\nis 1 square, the line\u2019s width is squares. Some of the squares contain\r\nbombs. If a square doesn\u2019t contain a bomb, then it contains a number\r\nfrom 0 to 2 the total number of bombs in adjacent squares.For example,\r\nthe correct field to play looks like that: . The cells that are marked\r\nwith \"\" contain bombs. Note that on the correct field the numbers\r\nrepresent the number of bombs in adjacent cells. For example, field is\r\nnot correct, because cell with value 2 must have two adjacent cells with\r\nbombs.Valera wants to make a correct field to play \"Minesweeper 1D\". He\r\nhas already painted a squared field with width of cells, put several\r\nbombs on the field and wrote numbers into some cells. Now he wonders how\r\nmany ways to fill the remaining cells with bombs and numbers are there\r\nif we should get a correct field in the end.\r\n",
    "solutions": [
        "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define lx x + x\n#define rx lx + 1\n#define ly y + y\n#define ry ly + 1\ntypedef long long LL;\n\nconst int N = 1000005;\nconst int M = 1005;\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-6;\ntypedef double DB;\n\nLL f[N][3];\nchar s[N];\nint main(){\n    scanf(\"%s\", s + 1);\n    int n = strlen(s + 1);\n    s[0] = '0';\n    f[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        if (s[i] == '0'){\n            f[i][0] += f[i - 1][0];\n        }else if (s[i] == '1'){\n            f[i][1] += f[i - 1][0];\n            f[i][0] += f[i - 1][2];\n        }else if (s[i] == '2'){\n            f[i][1] += f[i - 1][2];\n        }else if (s[i] == '*'){\n            if (i == 1) f[i][2] = 1;\n            else{\n                f[i][2] += f[i - 1][1];\n                f[i][2] += f[i - 1][2];\n            }\n        }else{\n            //0\n            f[i][0] += f[i - 1][0];\n\n            //1\n            f[i][1] += f[i - 1][0];\n            f[i][0] += f[i - 1][2];\n            //2\n            f[i][1] += f[i - 1][2];\n            //*\n            if (i == 1) f[i][2] = 1;\n            else{\n                f[i][2] += f[i - 1][1];\n                f[i][2] += f[i - 1][2];\n            }\n        }\n        for (int j = 0; j < 3; j++) f[i][j] %= MOD;\n    }\n    cout << (f[n][0] + f[n][2]) % MOD << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Minesweeper 1D.json",
    "editorial_link": "https://codeforces.com/blog/entry/11095",
    "editorial": "This problem can be solved by using dynamic programming. Let\u00e2\u0080\u0099s calculate\r\nthe number of correct ways to fill the prefix of length so that the last\r\nfilled cell has one of the types. These types are the following: the\r\ncell contains \"0\" the cell contains \"1\" and the cell to the left of it\r\ncontains bomb the cell contains \"1\" and the cell to the left of it\r\ndoesn\u00e2\u0080\u0099t contain bomb the cell contains \"2\" the cell contains bomb When\r\nwe try to fill next cell we check two conditions. Firstly value of the\r\nfilled cell in given string must be equal to either what we want to\r\nwrite or \"?\". Secondly new prefix must remain filled correct. For\r\nexample, if we are in state (it means that the cell contains \"0\") then\r\nwe can fill next cell by \"0\" and go to the state or fill next cell by\r\n\"1\" and go to the state . We cannot write \"2\" because both neighbours of\r\nthe cell with \"2\" must contain bomb. Obvious, we cannot place bomb after\r\n\"0\". Note that, when we place \"1\" after \"0\" we go to the state , but\r\nwhen we place \"1\" after bomb we go to the state . You can consider other\r\nways of going from one state to another in the same manner.\r\n"
}