{
    "link": "https://codeforces.com//contest/357/problem/C",
    "problemId": "3673",
    "problem_idx": "C",
    "shortId": "357C",
    "contest_number": "357",
    "problem_submissions": {
        "B": [
            4793165,
            4790671,
            4790250,
            4790732,
            4789966,
            4794384,
            4790483,
            4793777,
            4791105,
            4794251,
            4792633,
            4794265,
            4797403,
            4791961,
            4791308,
            4792766,
            4792762,
            4791518,
            4791534
        ],
        "E": [
            4792740,
            4796981,
            4794905,
            4795563,
            8133292,
            4797281,
            4797117,
            4797714,
            4818355,
            4795453,
            4815512
        ],
        "D": [
            4791194,
            4792398,
            4796019,
            13876397,
            4795091,
            4792720,
            4795403,
            4795251,
            4795347,
            4800965,
            4793015,
            4793047,
            4795738,
            4797292,
            4797189,
            4796792,
            4797421,
            4797480
        ],
        "C": [
            4790335,
            4793550,
            4792714,
            4792177,
            4790608,
            4790052,
            4791853,
            4802081,
            4793017,
            4791896,
            4793793,
            4795727,
            4790582,
            4793993,
            4792800,
            4792706,
            4792267,
            4794284,
            4793834,
            4794365
        ],
        "A": [
            4789474,
            4789484,
            4789445,
            4789522,
            4789426,
            4794710,
            4789436,
            4789534,
            4789500,
            4789425,
            4790008,
            4790549,
            4798002,
            4790618,
            4789465,
            10909387,
            4789460,
            4789552,
            4789833
        ]
    },
    "name": "C. Knight Tournament",
    "statement": "Hooray! Berl II, the king of Berland is making a knight tournament. The\r\nking has already sent the message to all knights in the kingdom and they\r\nin turn agreed to participate in this grand event.As for you, you’re\r\njust a simple peasant. There’s no surprise that you slept in this\r\nmorning and were late for the tournament (it was a weekend, after all).\r\nNow you are really curious about the results of the tournament. This\r\ntime the tournament in Berland went as follows: There are knights\r\nparticipating in the tournament. Each knight was assigned his unique\r\nnumber an integer from 1 to . The tournament consisted of fights, in the\r\n-th fight the knights that were still in the game with numbers at least\r\nand at most have fought for the right to continue taking part in the\r\ntournament. After the -th fight among all participants of the fight only\r\none knight won the knight number , he continued participating in the\r\ntournament. Other knights left the tournament. The winner of the last\r\n(the -th) fight (the knight number ) became the winner of the\r\ntournament. You fished out all the information about the fights from\r\nyour friends. Now for each knight you want to know the name of the\r\nknight he was conquered by. We think that the knight number was\r\nconquered by the knight number , if there was a fight with both of these\r\nknights present and the winner was the knight number .Write the code\r\nthat calculates for each knight, the name of the knight that beat him.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int V=300100;\nint r[V],ret[V];\nint find(int x)\n{\n    if(x!=r[x])r[x]=find(r[x]);\n    return r[x];\n}\nint n,m,L,R,x;\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        for(int i=1;i<=n+1;i++)r[i]=i;\n        memset(ret,0,sizeof(ret));\n        while(m--)\n        {\n            scanf(\"%d%d%d\",&L,&R,&x);\n            int u;\n            u=find(L);\n            while(1)\n            {\n                if(u>=x)break;\n                ret[u]=x;\n                r[u]=u+1;\n                u=find(u);\n            }\n            u=find(x+1);\n            while(1)\n            {\n                if(u>R)break;\n                ret[u]=x;\n                r[u]=u+1;\n                u=find(u);\n            }\n        }\n        for(int i=1;i<=n;i++)\n        printf(\"%d \",ret[i]);puts(\"\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Knight Tournament.json",
    "editorial_link": "https://codeforces.com//blog/entry/9210",
    "editorial": "Let's the current fight (l,?r,?x) consists of K knights fighting. Then all we have to do is to find all these knights in time O(K) or O(KlogN). There are several ways to do that, let's consider some of them.\n\nThe first way is to store the numbers of all alive knights in std::set (C++) or TreeSet (Java). Then in C++ we can use lower_bound method to find the first knight in the fight that is alive, and to iterate over this set, each time moving to the next alive knight. In Java we should use subSet method.",
    "hint": []
}