{"link": "https://codeforces.com//contest/879/problem/C", "problemId": "130664", "problem_idx": "C", "shortId": "879C", "contest_number": "879", "problem_submissions": {"B": [31786634, 31744953, 31748945, 31742935, 31751951, 31745920, 31746158, 31746124, 31745152, 31764273, 31744717, 31744550, 31745384, 31763271, 31741598, 31746257, 31743148], "A": [31786593, 31741274, 31744372, 31740794, 31748255, 31750502, 31742905, 31741390, 31742237, 31742563, 31740788, 31746610, 31740545, 31741102, 31761806, 31740453, 31741697, 31740818], "D": [31759010, 31759775, 31758676, 31760218, 31759988, 31764440, 31763303, 31762884, 31765337, 31764418, 31762268, 31761524, 31759749], "C": [31750102, 31754233, 31749363, 31750196, 31754099, 31751776, 31751991, 31753220, 31750527, 31755686, 31753418, 31760006, 31750929, 31761404, 31749686, 31756675, 31751331], "E": [31870640, 31870635, 31869262, 31868808]}, "name": "C. Short Program", "statement": "Petya learned a new programming language CALPAS. A program in this\r\nlanguage always takes one non-negative integer and returns one\r\nnon-negative integer as well.In the language, there are only three\r\ncommands: apply a bitwise operation AND, OR or XOR with a given constant\r\nto the current integer. A program can contain an arbitrary sequence of\r\nthese operations with arbitrary constants from to . When the program is\r\nrun, all operations are applied (in the given order) to the argument and\r\nin the end the result integer is returned.Petya wrote a program in this\r\nlanguage, but it turned out to be too long. Write a program in CALPAS\r\nthat does the same thing as the Petya\u2019s program, and consists of no more\r\nthan lines. Your program should return the same integer as Petya\u2019s\r\nprogram for all arguments from to .\r\n", "solutions": ["#include <algorithm>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FORE(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nconst int N = 510000, B=10;\nint n;\nint bits0[B],bits1[B];\n\nint operation(int b, int vb, char c) {\n  if (c == '|') { return b | vb; }\n  else if (c == '^') { return b ^ vb; }\n  else if (c == '&') { return b & vb; }\n  assert(0);\n}\n\nint main() {\n  scanf(\"%d\",&n);\n  REP(i,B) { bits0[i] = 0; bits1[i] = 1; }\n  REP(i,n) {\n    char c; int val;\n    scanf(\" %c%d\",&c,&val);\n    REP(i,B) {\n      int vb = !!(val & 1<<i);\n      bits0[i] = operation(bits0[i], vb, c);\n      bits1[i] = operation(bits1[i], vb, c);\n    }\n  }\n\n  int valor = 0, valxor = 0, valand = (1<<B)-1;\n\n  REP(i,B) {\n    int b = 1<<i;\n    if (bits0[i] == 1 && bits1[i] == 1) { valor |= b; }\n    else if (bits0[i] == 0 && bits1[i] == 0) { valand &= ~b; }\n    else if (bits0[i] == 1 && bits1[i] == 0) { valxor |= b; }\n  }\n\n  printf(\"3\\n\");\n  printf(\"| %d\\n\", valor);\n  printf(\"^ %d\\n\", valxor);\n  printf(\"& %d\\n\", valand);\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "graph matchings"], "dificulty": "1600", "interactive": false}