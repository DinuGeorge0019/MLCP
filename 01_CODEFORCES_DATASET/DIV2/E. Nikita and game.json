{"link": "https://codeforces.com//contest/842/problem/E", "problemId": "120316", "problem_idx": "E", "shortId": "842E", "contest_number": "842", "problem_submissions": {"E": [29892175, 29896709, 29892728], "C": [29876363, 29876870, 29881263, 29880716, 29891701, 29882766, 29881217, 29877383, 29881389, 29887847, 29882055, 29876553, 29885327, 29897484, 29879763, 29887443, 29895634, 29895199, 29916549, 29916532, 29916152, 29891176, 29895609], "D": [29875168, 29881874, 29886504, 29883941, 29879589, 29886046, 29872999, 29882468, 29887643, 29882954, 29887687, 29889517, 29890953, 29888540, 29891985, 29892689, 29883468, 29883460, 29887258, 29886746], "B": [29874014, 29874407, 29872985, 29872379, 29886135, 38859573, 29873183, 29883006, 29876642, 29873270, 29874068, 29874064, 29886058, 29876537, 29878343, 29881672, 29872806, 29873575, 29872847, 29873445, 29873104], "A": [29870801, 29869133, 29887434, 29870152, 29882916, 29869760, 29883576, 29869196, 29869793, 29870793, 29869617, 29869267, 29869102, 29871125, 29882379, 29869173, 29870818, 29869360, 29870433, 29869454]}, "name": "E. Nikita and game", "statement": "Nikita plays a new computer game. There are levels in this game. In the\r\nbeginning of each level a new class appears in the game; this class is a\r\nchild-class of the class (and is called parent-class for this new\r\nclass). Thus, the classes form a tree. Initially there is only one class\r\nwith index .Changing the class to its neighbour (child-class or\r\nparent-class) in the tree costs coin. You can not change the class back.\r\nThe cost of changing the class to the class is equal to the total cost\r\nof class changes on the path from to in the class tree.Suppose that at\r\n-th level the maximum cost of changing one class to another is . For\r\neach level output the number of classes such that for each of these\r\nclasses there exists some other class , and the distance from this class\r\nto is exactly .\r\n", "solutions": ["#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#define INF 0x3FFFFFFF\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n#define MN 600000\n#define K 20\n#define L (k<<1)\n#define R (k<<1|1)\nstruct edge{int nx,t;}e[MN*2+5];\nint h[MN+5],en,l[MN+5],r[MN+5],cnt,d[MN+5],fa[K][MN+5];\ninline void ins(int x,int y)\n{\n\te[++en]=(edge){h[x],y};h[x]=en;\n\te[++en]=(edge){h[y],x};h[y]=en;\n}\nvoid dfs(int x)\n{\n\tl[x]=++cnt;\n\tfor(int i=h[x];i;i=e[i].nx)if(e[i].t!=fa[0][x])\n\t\tfa[0][e[i].t]=x,d[e[i].t]=d[x]+1,dfs(e[i].t);\n\tr[x]=cnt;\n}\nint dis(int x,int y)\n{\n\tif(d[x]<d[y])swap(x,y);\n\tint res=d[x]-d[y],i,dx=d[x]-d[y];\n\tfor(i=0;dx;++i,dx>>=1)if(dx&1)x=fa[i][x];\n\tif(x==y)return res;\n\tfor(i=K;i--;)if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y],res+=1<<i+1;\n\treturn res+2;\n}\nstruct node{int l,r,s,mk;}t[MN*4+5];\ninline void up(int k){t[k].s=t[L].s+t[R].s;}\ninline void mark(int k){t[k].s=0;t[k].mk=1;}\ninline void down(int k){if(t[k].mk)mark(L),mark(R),t[k].mk=0;}\nvoid build(int k,int l,int r)\n{\n\tif((t[k].l=l)==(t[k].r=r))return;\n\tint mid=l+r>>1;\n\tbuild(L,l,mid);build(R,mid+1,r);\n}\nvoid add(int k,int x)\n{\n\tif(++t[k].s,t[k].l==t[k].r)return;\n\tdown(k);add(x>(t[k].l+t[k].r>>1)?R:L,x);\n}\nvoid mark(int k,int l,int r)\n{\n\tif(t[k].l==l&&t[k].r==r){mark(k);return;}\n\tint mid=t[k].l+t[k].r>>1;down(k);\n\tif(r<=mid)mark(L,l,r);\n\telse if(l>mid)mark(R,l,r);\n\telse mark(L,l,mid),mark(R,mid+1,r);up(k);\n}\nint main()\n{\n\tint n=read()+1,i,j,k,x,s=1,ds=0;\n\tfor(i=2;i<=n;++i)ins(read(),n+i-1),ins(n+i-1,i);\n\tdfs(1);\n\tfor(i=1;i<K;++i)for(j=1;j<n*2;++j)fa[i][j]=fa[i-1][fa[i-1][j]];\n\tbuild(1,1,n*2-1);add(1,1);\n\tfor(i=2;i<=n;++i)\n\t{\n\t\tif((j=dis(i,s))>ds)\n\t\t{\n\t\t\tif(j==d[i]-d[s])\n\t\t\t{\n\t\t\t\tfor(x=i,k=K;k--;)if(d[fa[k][x]]>d[s])x=fa[k][x];\n\t\t\t\ts=x;\n\t\t\t\tmark(1,l[s],r[s]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(l[s]>1)mark(1,1,l[s]-1);\n\t\t\t\tif(r[s]<n*2-1)mark(1,r[s]+1,n*2-1);\n\t\t\t\ts=fa[0][s];\n\t\t\t}\n\t\t\tj=ds=dis(i,s);\n\t\t}\n\t\tif(j==ds)add(1,l[i]);\n\t\tprintf(\"%d\\n\",t[1].s);\n\t}\n}"], "input": "", "output": "", "tags": ["binary search", "dfs and similar", "divide and conquer", "graphs", "trees"], "dificulty": "2800", "interactive": false}