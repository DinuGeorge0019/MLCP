{
    "link": "https://codeforces.com//contest/1350/problem/E",
    "problemId": "619075",
    "problem_idx": "E",
    "shortId": "1350E",
    "contest_number": "1350",
    "problem_submissions": {
        "E": [
            79855181,
            79866892,
            79867578,
            79860431,
            79865664,
            79871653,
            79862377,
            79873286,
            79855797,
            79870095,
            79877566,
            79875250,
            79879082,
            79877229,
            79874099,
            79876185,
            79865098,
            79874891,
            79878375
        ],
        "D": [
            79841799,
            79863715,
            79838223,
            79843636,
            79845619,
            79851762,
            79859376,
            79851422,
            79856645,
            79867069,
            79852959,
            79854133,
            79862270,
            79854555,
            79857955,
            79860745,
            79863550,
            79877253,
            79858065,
            79853653
        ],
        "C": [
            79826908,
            79832989,
            79819179,
            79836044,
            79829980,
            79835199,
            79827905,
            79823236,
            79839284,
            79843003,
            79842971,
            79842595,
            79842398,
            79842899,
            79841428,
            79836029,
            79843846,
            79828517,
            79847123,
            79843527
        ],
        "B": [
            79820647,
            79822816,
            79842662,
            79823960,
            79824033,
            79823709,
            79822810,
            79820992,
            244797086,
            79824014,
            79827065,
            79834456,
            79825730,
            79829712,
            79832808,
            79831732,
            79824775,
            79833342,
            79819486,
            79827690,
            79827705
        ],
        "A": [
            79816852,
            79817819,
            79835688,
            79816825,
            79817311,
            79817807,
            79817556,
            79817787,
            79817609,
            79823750,
            79829915,
            79816664,
            79822342,
            79821478,
            79817922,
            79818871,
            79819448,
            79816826,
            79818898,
            79816798
        ],
        "F": [
            79877945
        ]
    },
    "name": "E. Orac and Game of Life",
    "statement": "Orac likes games. Recently he came up with the new game, \"\".You should\r\nplay this game on a black and white grid with n rows and m columns. Each\r\ncell is either black or white.For each iteration of the game (the\r\ninitial iteration is 0), the color of each cell will change under the\r\nfollowing rules: If there are no adjacent cells with the same color as\r\nthis cell on the current iteration, the color of it on the next\r\niteration will be the same. Otherwise, the color of the cell on the next\r\niteration will be different.Two cells are adjacent if they have a mutual\r\nedge.Now Orac has set an initial situation, and he wants to know for the\r\ncell (i,j) (in i-th row and j-th column), what will be its color at the\r\niteration p. He may ask you these questions several times.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define INF 2e18\n#define N 1010\n#define mr make_pair\nusing namespace std;\nint m,n,t,a[N][N],x,y;\nll m1[N][N],m2[N][N],m3[N][N],m4[N][N],z;\nbool vi[N][N];\nbool ch(int x,int y){if (x<1||x>n||y<1||y>m||vi[x][y]==0)return 0;return 1;}\nvoid bfs(int x,int y,int z){\n\tvi[x][y]=0;\n\tint so=0;\n\tif (a[x-1][y]==a[x][y]&&ch(x-1,y)){so++;bfs(x-1,y,1);}\n\tif (a[x+1][y]==a[x][y]&&ch(x+1,y)){so++;bfs(x+1,y,1);}\n\tif (a[x][y-1]==a[x][y]&&ch(x,y-1)){so++;bfs(x,y-1,1);}\n\tif (a[x][y+1]==a[x][y]&&ch(x,y+1)){so++;bfs(x,y+1,1);}\n\tif (so==0&&z==0)m1[x][y]=m2[x][y]=m3[x][y]=m4[x][y]=INF;\n}\nint main(){\n\tcin>>n>>m>>t;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tchar ch=getchar();\n\t\t\twhile (ch!='0'&&ch!='1')ch=getchar();\n\t\t\ta[i][j]=ch-'0';\n\t\t\tvi[i][j]=1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tif (vi[i][j])bfs(i,j,0);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=2;j<=m;j++)m1[i][j]=min(m1[i][j-1]+1,m1[i][j]),m2[i][j]=min(m2[i][j-1]+1,m2[i][j]);\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=m-1;j>=1;j--)m3[i][j]=min(m3[i][j+1]+1,m3[i][j]),m4[i][j]=min(m4[i][j+1]+1,m4[i][j]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tfor (int j=2;j<=n;j++)m1[j][i]=min(m1[j-1][i]+1,m1[j][i]),m3[j][i]=min(m3[j-1][i]+1,m3[j][i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tfor (int j=n-1;j>=1;j--)m2[j][i]=min(m2[j][i],m2[j+1][i]+1),m4[j][i]=min(m4[j][i],m4[j+1][i]+1);\n\t}\n\twhile (t--){\n\t\tcin>>x>>y>>z;\n\t\tll p=min(m1[x][y],min(m2[x][y],min(m3[x][y],m4[x][y])));\n\t\tif (p>=z)p=0;else p=(z-p)%2;\n\t\tcout<<(a[x][y]^p)<<'\\n';\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "implementation",
        "math",
        "shortest paths"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Orac and Game of Life.json",
    "editorial_link": "https://codeforces.com//blog/entry/77284",
    "editorial": "A cell (i,j)\n is said to be good if and only if there is a cell (i?,j?)\n adjacent to (i,j)\n which has the same color to (i,j)\n . If a cell (i,j)\n is not good, it is said to be bad. Therefore, the color of a cell changes after a turn if and only if the cell is good.\n\nAccording to the definition, any cell never changes its color if every cell is bad. Also, a good cell (i,j)\n would never turn into a bad cell .\n\nFor a bad cell (i,j)\n, if there is a good cell (i?,j?)\n adjacent to (i,j)\n, (i,j)\n will turn into a good cell after a turn because (i?,j?)\n currently has a different color from (i,j)\n and the color of (i?,j?)\n will change after a turn but the color of (i,j)\n won't change; otherwise, after a turn, the color of (i,j)\n and cells adjacent to (i,j)\n stays the same, so (i,j)\n is still bad.\n\nFor a cell (i,j)\n, let fi,j\n be the number of turns needed for that (i,j)\n becomes a good cell. According to the paragraph above, fi,j\n equals to the minimal Manhattan distance from (i,j)\n to a good cell. Therefore, fi,j\n can be figured out by BFS.\n\nNotice that for k?fi,j\n , the color of (i,j)\n stays the same after the k\n-th turn; for k>fi,j\n , the color of (i,j)\n changes after the k\n-th turn. Therefore, each query can be processed with O(1)\n time complexity. The total time complexity is O(nm+t)\n ."
}