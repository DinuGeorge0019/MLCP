{
    "link": "https://codeforces.com//contest/1891/problem/D",
    "problemId": "2296091",
    "problem_idx": "D",
    "shortId": "1891D",
    "contest_number": "1891",
    "problem_submissions": {
        "E": [
            230546323,
            230549698,
            230546568,
            230560113,
            230535473,
            230555886,
            230556588,
            230572665,
            230562765,
            230571525,
            230577549,
            230577437,
            230577312,
            230576387,
            230568654,
            230542621,
            230562980,
            230569462,
            230570942,
            230569058,
            230570276,
            230567059,
            230568509,
            230570393
        ],
        "D": [
            230534861,
            230532955,
            230530542,
            230539370,
            230549040,
            230536739,
            230534616,
            230532674,
            230544623,
            230533495,
            230543589,
            230549007,
            230547762,
            230544535,
            230536524,
            230537913,
            230537614,
            230536080,
            230540544,
            230539494
        ],
        "F": [
            230528098,
            230541255,
            230552010,
            230529998,
            230540710,
            230542715,
            230590093,
            230590013,
            230545702,
            230538147,
            251594037,
            230535448,
            230545719,
            230533122,
            230519163,
            230533480,
            230536870,
            230548382,
            230551293,
            230550179,
            230543750,
            230553764,
            230541029
        ],
        "C": [
            230517325,
            230519256,
            230521040,
            230519508,
            230552157,
            230529446,
            230519957,
            230521645,
            230529295,
            230521526,
            230527664,
            230555714,
            230523852,
            230528582,
            230522749,
            230531812,
            230530352,
            230518984,
            230520316,
            230536742
        ],
        "A": [
            230515478,
            230512076,
            230512426,
            230512477,
            230513749,
            230513572,
            230511745,
            230511922,
            230513704,
            230511875,
            230512212,
            230559679,
            230512242,
            230513480,
            230512561,
            230512123,
            230512943,
            230547595,
            230512205,
            230518051
        ],
        "B": [
            230513054,
            230513705,
            230515902,
            230515002,
            230527506,
            230517573,
            230513080,
            230513453,
            230518089,
            230513986,
            230515796,
            230558558,
            230539558,
            230516521,
            230515634,
            230516319,
            230517013,
            230552749,
            230513951,
            230522884
        ]
    },
    "name": "D. Suspicious logarithms",
    "statement": "Let f(x) be the floor of the binary logarithm of x. In other words, f(x)\r\nis largest non-negative integer y, such that 2^y does not exceed x.Let\r\ng(x) be the floor of the logarithm of x with base f(x). In other words,\r\ng(x) is the largest non-negative integer z, such that {f(x)}^{z} does\r\nnot exceed x.You are given q queries. The i-th query consists of two\r\nintegers l_i and r_i. The answer to the query is the sum of g(k) across\r\nall integers k, such that l_i\r\nleq k\r\nleq r_i. Since the answers might be large, print them modulo {10^9 + 7}.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define int __int128\nusing namespace std;\nint read(){\n\tint w=0,h=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')h=-h;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){w=w*10+ch-'0';ch=getchar();}\n\treturn w*h;\n}\nvoid write(int x){\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n}\nvoid writeln(int x){write(x);puts(\"\");}\nvoid writech(int x){write(x);putchar(' ');}\nconst int mod=1e9+7;\nint calc(int x){\n\tif(x<4)return 0;\n\tint ans=0;\n\tfor(int i=2;i<=60;i++){\n\t\tint l=(1ll<<i),r=min(x,(int)(1ll<<(i+1))-1);\n\t\t//writech(l);writeln(r);\n\t\tif(l>x)break;\n\t\tfor(int p=1,bs=i;p<=60;p++,bs=bs*i){\n\t\t\tif(bs*i<l)continue;\n\t\t    if(bs>r)break;\n\t\t\tint L=max(l,bs),R=min(r,bs*i-1);\n\t\t\tif(L<=R)(ans+=(R-L+1)%mod*p)%=mod;\n\t\t\t//writech(i);writech(p);writech(bs);writech(L);writeln(R);\n\t\t\tif(bs*p>1000000000000000000)break;\n\t\t}\n\t}\n\treturn ans;\n}\nvoid solve(){int l=read(),r=read();writeln((calc(r)-calc(l-1)+mod)%mod);}\nsigned main(){\n\tint T=read();while(T--)solve();\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Suspicious logarithms.json",
    "editorial_link": "https://codeforces.com//blog/entry/121876",
    "editorial": "First, let us estimate the number of such that . This can happen if ,\r\nbut it happens rarely (about times). And if f(i) is equal, we can see\r\nthat for any , and on a segment with equal transitions will be , where\r\nis the length of the segment. That is, there are segments with equal ,\r\nand on each segment there are at most transitions. Then there are a\r\ntotal of transitions, where is the maximum value of in the problem. In\r\nfact, in reality, there are even fewer transitions - something like .\r\nNow we can suppose all such that , and by passing over them we can\r\nconsider the sum of for all . Or you can write a binary search and read\r\nthe answer even faster.\r\n"
}