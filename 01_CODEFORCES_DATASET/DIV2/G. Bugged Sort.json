{
    "link": "https://codeforces.com//contest/2060/problem/G",
    "problemId": "3147476",
    "problem_idx": "G",
    "shortId": "2060G",
    "contest_number": "2060",
    "problem_submissions": {
        "G": [
            301873530,
            301859046,
            301852803,
            301886996,
            301829945,
            301884074,
            301865362,
            301944483,
            301877663
        ],
        "F": [
            301809977,
            301827952,
            301788384,
            301831904,
            301878286,
            301872767,
            301850953,
            301874252,
            301811774,
            301816800,
            301831940,
            301815743,
            301889712,
            301854030,
            301836262,
            301832755,
            301848647,
            301843962,
            301841616,
            301902407
        ],
        "E": [
            301780977,
            301790293,
            301841004,
            301786821,
            301854824,
            301815095,
            301816295,
            301758990,
            301799665,
            301795284,
            301801086,
            301920235,
            301889573,
            301794741,
            301799175,
            301804483,
            301807413,
            301794652,
            301768541
        ],
        "D": [
            301771562,
            301772155,
            301822748,
            301775745,
            301785461,
            301801939,
            301852011,
            301776457,
            301782878,
            301769755,
            301787487,
            301917787,
            301889434,
            301776569,
            301786371,
            301790878,
            301764610,
            301773754,
            301756989
        ],
        "C": [
            301748633,
            301761322,
            301773736,
            301772188,
            301769620,
            301776760,
            301770890,
            301782439,
            301749719,
            301754417,
            301759048,
            301774305,
            301916945,
            301889316,
            301755362,
            301775118,
            301772704,
            301748352,
            301760800,
            301753236
        ],
        "B": [
            301746021,
            301755202,
            301761527,
            301755925,
            301795537,
            301759408,
            301745641,
            301745397,
            301750029,
            301750098,
            301915984,
            301888995,
            301750358,
            301751304,
            301755984,
            301781169,
            301750274,
            301748735
        ],
        "A": [
            301739564,
            301739279,
            301761253,
            301738865,
            301749974,
            301743163,
            301743222,
            301739250,
            301739375,
            301743095,
            301739024,
            301915381,
            301888689,
            301739666,
            301739726,
            301746215,
            301745343,
            301738637,
            301738767
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/138342",
    "editorial": "Key observation:\n\nIn the final solution, the pairs must be sorted in increasing order of min(ai,bi)\n. We prove this by contradiction. Suppose there exists a pair (ai,bi)\n, where ai<bi\n and ai\n is smaller than the minimum element in the previous pair. In this case, it becomes impossible to place this pair after the previous one, as ai\n would always be smaller than the preceding element, regardless of orientation.\n\nSince all ai\n and bi\n are distinct, there is exactly one valid final ordering of the pairs. Moreover, this ordering is always reachable because we previously proved that any two pairs can be swapped without flipping their elements. Since swapping any two items in an array an arbitrary number of times allows for sorting by definition, we can sort the pairs in this order. Thus, the solution is to initially sort the pairs based on min(ai,bi)\n.\n\nSolution:\n\nThe problem simplifies to determining whether flipping pairs allows sorting. We can solve this using dynamic programming (DP), defined as follows:\n\ndp[1][i]=1\n if it's possible to sort up and including pair i\n using an even number of flips, where pair i\n is not flipped.\ndp[2][i]=1\n if it's possible to sort up and including pair i\n using an even number of flips, where pair i\n is flipped.\ndp[3][i]=1\n if it's possible to sort up and including pair i\n using an odd number of flips, where pair i\n is not flipped.\ndp[4][i]=1\n if it's possible to sort up and including pair i\n using an odd number of flips, where pair i\n is flipped.\n\nThe base cases are as follows:\n\ndp[1][1]=1\n, because this represents the state where the first pair is not flipped, resulting in zero flips (which is even)\ndp[4][1]=1\n, because this represents the state where the first pair is flipped, resulting in one flip (which is odd).\n\nThere are eight possible transitions, as you can reach each of the four states from two previous states: you either choose to flip the current element or you don't.\n\nThe final answer is dp[1][n]\n OR\n dp[2][n]\n, because by Hints 3 and 4, we can only reach states where an even number of pairs are flipped from the starting position.",
    "name": "G. Bugged Sort",
    "statement": "Today, Alice has given Bob arrays for him to sort in increasing order\r\nagain! At this point, no one really knows how many times she has done\r\nthis.Bob is given two sequences a and b, both of length n. All integers\r\nin the range from 1 to 2n appear exactly once in either a or b. In other\r\nwords, the concatenated^{\r\ntext{ }} sequence a+b is a permutation^{\r\ntext{ }} of length 2n.Bob must sort in increasing order using Alice\u2019s\r\nfunction. Alice\u2019s function is implemented as follows: Given two indices\r\ni and j (i\r\nneq j), it swaps a_i with b_j, and swaps b_i with a_j. Given sequences a\r\nand b, please determine if both sequences can be sorted in increasing\r\norder simultaneously after using Alice\u2019s function any number of times.^{\r\ntext{ }}The concatenated sequence a+b denotes the sequence [a_1, a_2,\r\na_3,\r\nldots , b_1, b_2, b_3,\r\nldots].^{\r\ntext{ }}A permutation of length m contains all integers from 1 to m in\r\nsome order.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0static const long long maxn = -1;\u00a0int main(){\tios::sync_with_stdio(false);\tcin.tie(nullptr);\u00a0\tint t; cin >> t;\twhile(t--){\t\tint n; cin >> n;\t\tvector<long long> a(n), b(n);\t\tfor(int i=0;i<n;i++){\t\t\tcin >> a[i];\t\t}\t\tfor(int i=0;i<n;i++){\t\t\tcin >> b[i];\t\t}\t\tstruct P { long long c,d; int f; };\t\tvector<P> aa(n);\t\tfor(int i=0; i<n; i++){\t\t\tlong long mi = std::min(a[i], b[i]);\t\t\tlong long mx = std::max(a[i], b[i]);\t\t\tint flag = 0;\t\t\tif( a[i]==mx && b[i]==mi ){\t\t\t\tflag = 1;\t\t\t}\t\t\taa[i] = {mi, mx, flag};\t\t}\t\tsort(aa.begin(), aa.end(), [](auto &p1, auto &p2){\t\t\tif(p1.c != p2.c) return p1.c < p2.c;\t\t\treturn p1.d < p2.d;\t\t});\u00a0\t\tvector<vector<long long>> dp1(2, vector<long long>(2, maxn));\t\tvector<vector<long long>> dp2(2, vector<long long>(2, maxn));\t\tauto &p0 = aa[0];\t\t{\t\t\tint pt = (p0.f ^ 0);\t\t\tdp1[0][pt] = p0.d;\t\t\tif(p0.d > p0.c){\t\t\t\tint pt1 = (p0.f ^ 1);\t\t\t\tdp1[1][pt1] = p0.c; // last y = c\t\t\t}\t\t\telse {\t\t\t\tint pt1 = (p0.f ^ 1);\t\t\t\tdp1[1][pt1] = p0.c;\t\t\t}\t\t}\t\tfor(int i=2; i<=n; i++){\t\t\tif(i==2){\t\t\t} else {\t\t\t\tdp1 = dp2;\t\t\t}\t\t\tfor(int j=0;j<2;j++){\t\t\t\tfor(int p=0;p<2;p++){\t\t\t\t\tdp2[j][p] = maxn;\t\t\t\t}\t\t\t}\t\t\tauto &pcurr = aa[i-1];\t\t\tauto &pprev = aa[i-2];\t\t\tlong long xprv0 = pprev.c, yprev0 = pprev.d;\t\t\tlong long xprv1 = pprev.d, yprev1 = pprev.c;\u00a0\t\t\tfor(int k=0;k<2;k++){\t\t\t\tfor(int i=0; i<2; i++){\t\t\t\t\tlong long ly = dp1[k][i];\t\t\t\t\tif(ly == maxn) continue;\t\t\t\t\tlong long xprv = (k==0 ? xprv0 : xprv1);\t\t\t\t\tlong long xc0 = pcurr.c, yc0 = pcurr.d;\t\t\t\t\tif(xc0 > xprv && yc0 > ly){\t\t\t\t\t\tint newp = i ^ (pcurr.f ^ 0);\t\t\t\t\t\tlong long &ref = dp2[0][newp];\t\t\t\t\t\tif(ref == maxn) ref = yc0;\t\t\t\t\t\telse ref = min(ref, yc0);\t\t\t\t\t}\t\t\t\t\tlong long xc1 = pcurr.d, yc1 = pcurr.c;\t\t\t\t\tif(xc1 > xprv && yc1 > ly){\t\t\t\t\t\tint newp = i ^ (pcurr.f ^ 1);\t\t\t\t\t\tlong long &ref = dp2[1][newp];\t\t\t\t\t\tif(ref == maxn) ref = yc1;\t\t\t\t\t\telse ref = min(ref, yc1);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tbool ok = false;\t\tif(dp2[0][0] != maxn) ok = true;\t\tif(dp2[1][0] != maxn) ok = true;\u00a0\t\tcout<<(ok? \"YES\\n\":\"NO\\n\");\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Bugged Sort.json"
}