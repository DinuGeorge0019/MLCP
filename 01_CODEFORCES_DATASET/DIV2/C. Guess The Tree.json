{
    "link": "https://codeforces.com//contest/2001/problem/C",
    "problemId": "2825892",
    "problem_idx": "C",
    "shortId": "2001C",
    "contest_number": "2001",
    "problem_submissions": {
        "B": [
            277398710,
            277337688,
            277333922,
            277337722,
            277337555,
            277331647,
            277331395,
            277333468,
            277348528,
            277341588,
            277340363,
            277333951,
            277333359,
            277338651,
            277333253,
            277332470,
            277333025,
            277335874,
            277338084,
            277338047
        ],
        "A": [
            277396358,
            277332606,
            277324069,
            277328881,
            277324101,
            277323710,
            277325572,
            277324708,
            277342273,
            277324601,
            277327125,
            277324363,
            277324076,
            277325983,
            277324668,
            277323640,
            277324308,
            277324085,
            277329437,
            277324734
        ],
        "C": [
            277393929,
            277349647,
            277343837,
            277347819,
            277349047,
            277345424,
            277478575,
            277341657,
            277342745,
            277358874,
            277352973,
            277356317,
            277345054,
            277358657,
            277349482,
            277354577,
            277354478,
            277341600,
            277373032,
            277357702,
            277354144
        ],
        "D": [
            277386516,
            277362274,
            277363417,
            277423990,
            277364589,
            277362182,
            277363264,
            277481384,
            277378655,
            277372682,
            277373441,
            277372083,
            277373799,
            277371029,
            277376602,
            277374746,
            277374825,
            277383133,
            277374017,
            277362123,
            277383713,
            277376041
        ],
        "E2": [
            277373545,
            283086293,
            277423307,
            278251315,
            278253470
        ],
        "E1": [
            277335505,
            277376073,
            277395747,
            277388497,
            277391499,
            277398952,
            277393530,
            277401516,
            277389370,
            277393752,
            277394666,
            277405095,
            277396023,
            277402006,
            277399147,
            277397663,
            277407033,
            278257931,
            277717643,
            277717625,
            277717605,
            277717578,
            277403586,
            277396025,
            277402066
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132942",
    "editorial": "Itâs easy to verify that\nquerying a and b will return the midpoint of the path between a and b.\nIn case the path has odd length, the node closer to a of the two central\nnodes will be returned.We will now construct the tree by expanding a\nconnected component. Let A =\n{1\n} and B =\n{2,\nldots,n\n}. While B is not empty, choose any b\nin B and a\nin A. Let P be the path between a and b. By construction, P will consist\nof a prefix contained in A and a suffix contained in B. We can binary\nsearch for the first i such that P_i\nin B.This will take at most\nlceil log(|P|)\nrceil + 2 queries. Then, (P_{i-1}, P_i) will be an edge of the tree, so\nwe will set A = A\ncup {P_i} and B = B\nbackslash {P_i}.The total number of queries will be smaller than n\nlceil log(n)\nrceil + 2n = 12000.\n",
    "name": "C. Guess The Tree",
    "statement": "Misuki has chosen a secret tree with n nodes, indexed from 1 to n, and\r\nasked you to guess it by using queries of the following type: Misuki\r\nwill tell you which node x minimizes |d(a,x) - d(b,x)|, where d(x,y) is\r\nthe distance between nodes x and y. If more than one such node exists,\r\nMisuki will tell you the one which minimizes d(a,x). Find out the\r\nstructure of Misuki’s secret tree using at most 15n queries!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}int qry(int x,int y){\tcout<<\"? \"<<x+1<<\" \"<<y+1<<endl;\tint z;\tcin>>z;\tre z-1;}const int N=1005;int n,ff[N],ok[N],te[N];void run(){\tint n;\tcin>>n;\trep(i,n){\t\tok[i]=0;\t\tff[i]=-1;\t\tte[i]=0;\t}\tok[0]=1;\twhile(1){\t\tint fl=0;\t\trep(i,n)if(!ok[i]&&ok[te[i]]){\t\t\tint rv=qry(te[i],i);\t\t\tif(rv==te[i]){\t\t\t\tff[i]=te[i];\t\t\t\tok[i]=1;\t\t\t}\t\t\telse te[i]=rv;\t\t\tfl=1;\t\t}\t\tif(!fl)break;\t}\trep(i,n)assert(ok[i]);\tcout<<\"! \";\trept(i,1,n)cout<<ff[i]+1<<\" \"<<i+1<<\" \";\tcout<<endl;}signed main(){//\tios::sync_with_stdio(0);//\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dfs and similar",
        "divide and conquer",
        "dsu",
        "greedy",
        "interactive",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Guess The Tree.json",
    "hint": []
}