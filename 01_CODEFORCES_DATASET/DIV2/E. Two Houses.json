{"link": "https://codeforces.com//contest/1498/problem/E", "problemId": "939726", "problem_idx": "E", "shortId": "1498E", "contest_number": "1498", "problem_submissions": {"F": [111387402, 111392757, 111390775, 111403691, 111584572, 111473088, 111426854, 111399920, 111425764, 111390588, 111477247, 111409684], "E": [111380663, 111380198, 111394052, 111391669, 111387992, 111389314, 111390832, 111389181, 111394144, 111392605, 111394352, 111387457, 111380754, 111393900, 111397027, 111441836, 111441307, 111400155, 111385873, 111395643], "D": [111375931, 111387383, 111378758, 111377203, 111379613, 111383007, 111378160, 111383542, 111383036, 111382698, 111387981, 111395336, 111398482, 111384225, 111554241, 111398142, 111389221], "C": [111364680, 111369793, 111370806, 111367823, 111370857, 111369057, 111366879, 111378226, 111375527, 111375807, 111372267, 111374177, 111372378, 111369667, 111372541, 111380311, 111372933, 111374210], "B": [111358809, 111373602, 111364638, 111359716, 111363279, 111361795, 111359400, 111362980, 111362321, 111366507, 111367101, 111362617, 111361122, 111360963, 111365072, 111367219, 111360331, 111363745], "A": [111356336, 111356639, 111356331, 111356474, 111357691, 111356258, 111356269, 111358101, 111357535, 111358945, 111356500, 111356580, 111356352, 111356349, 111359311, 111357626, 111356520, 111357210]}, "name": "E. Two Houses", "statement": "You may use in C++, in Java, in Python or in Pascal to flush the output.\r\nIf you use some other programming language, consult its documentation.\r\nYou may also refer to the guide on interactive problems:\r\nhttps://codeforces.com/blog/entry/45307.There is a city in which Dixit\r\nlives. In the city, there are n houses. There is For example, consider\r\ntwo houses A and B, then there is a directed road either from A to B or\r\nfrom B to A but not both. The number of roads leading to the i-th house\r\nis k_i.Two houses A and B are if A is reachable from B B is reachable\r\nfrom A. We say that house B is reachable from house A when there is a\r\npath from house A to house B.Dixit wants to buy two houses in the city,\r\nthat is, one for living and one for studying. Of course, he would like\r\nto travel from one house to another. So, he wants to find a pair of\r\nbi-reachable houses A and B. Among all such pairs, he wants to choose\r\none with the maximum value of |k_A - k_B|, where k_i is the number of\r\nroads leading to the house i. If more than one optimal pair exists, any\r\nof them is suitable.Since Dixit is busy preparing CodeCraft, can you\r\nhelp him find the desired pair of houses, or tell him that no such\r\nhouses exist?In the problem input, you are given the direction of each\r\nroad. You are given for each house only the number of incoming roads to\r\nthat house (k_i).You are allowed to ask only one type of query from the\r\njudge: give two houses A and B, and the judge answers whether B is\r\nreachable from A. There is . But, Also, you cannot ask the same query\r\ntwice.Once you have exhausted all your queries (or the judge responds \"\"\r\nto any of your queries), your program must output its guess for the two\r\nhouses and quit.See the Interaction section below for more details.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<'0')v=getchar();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\ninline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}\ninline int ksm(re int x,re int y){\n\tre int s=1;\n\twhile(y){\n\t\tif(y&1)s=1ll*s*x%M;\n\t\tx=1ll*x*x%M,y>>=1;\n\t}\n\treturn s;\n}\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002];\nstruct node{\n\tint x,y;\n\tbool operator <(const node s)const{return a[y]-a[x]==a[s.y]-a[s.x]?y>s.y:a[y]-a[x]>a[s.y]-a[s.x];}\n}p[500002];\nchar s[100002];\nsigned main(){\n\tn=read();\n\tfor(re int i=1;i<=n;++i)a[i]=read();\n\tfor(re int i=1;i<=n;++i)for(re int j=i+1;j<=n;++j)p[++cnt]=(node){i,j};\n\tfor(re int i=1;i<=cnt;++i)if(a[p[i].x]>a[p[i].y])swap(p[i].x,p[i].y);\n\tsort(p+1,p+cnt+1);\n\tfor(re int i=1;i<=cnt;++i){\n\t\tprintf(\"? %d %d\\n\",p[i].y,p[i].x);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\",s+1);\n\t\tif(s[1]=='Y'){\n\t\t\tprintf(\"! %d %d\\n\",p[i].x,p[i].y);\n\t\tfflush(stdout);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\t\tprintf(\"! %d %d\\n\",0,0);\n\t\tfflush(stdout);\n\t\t\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "graphs", "greedy", "interactive", "sortings"], "dificulty": "2200", "interactive": false}