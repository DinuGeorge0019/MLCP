{
    "link": "https://codeforces.com//contest/1905/problem/F",
    "problemId": "2384305",
    "problem_idx": "F",
    "shortId": "1905F",
    "contest_number": "1905",
    "problem_submissions": {
        "F": [
            237519503,
            237518706,
            237482920,
            237522705,
            237524131,
            237602806,
            237553489,
            237539816,
            237539559,
            237531355,
            238226356,
            238226333
        ],
        "E": [
            237505954,
            237497832,
            237495453,
            237512642,
            237513385,
            237508924,
            237511733,
            237515516,
            237508774,
            237502235,
            237513715,
            237519547,
            237522468,
            237711000,
            237515591,
            237507153,
            237518502,
            237520768,
            237516891,
            237516610
        ],
        "D": [
            237492749,
            237504330,
            237509326,
            237501351,
            237508164,
            237500145,
            237500325,
            237496593,
            237501654,
            237512862,
            237494885,
            237497599,
            237495760,
            237710975,
            237503073,
            237516000,
            237505850,
            237496346,
            237504183,
            237504223
        ],
        "C": [
            237484859,
            237486387,
            237514010,
            237484118,
            237485834,
            237477056,
            237481640,
            237480170,
            237483989,
            237484101,
            237482806,
            237484400,
            237487254,
            237710962,
            237490113,
            237487402,
            237483252,
            237485864,
            237495090,
            237491635
        ],
        "B": [
            237476673,
            237478416,
            237514764,
            237473227,
            237475996,
            237480677,
            237471243,
            237471572,
            237474579,
            237471819,
            237473855,
            237474076,
            237478005,
            237710941,
            237481035,
            237481302,
            237473092,
            237475685,
            237477792,
            237477297
        ],
        "A": [
            237470661,
            237474004,
            237515478,
            237470037,
            237470853,
            237487781,
            237469382,
            237469477,
            237471099,
            237469459,
            237470679,
            237470317,
            237471411,
            237710923,
            237474857,
            237474763,
            237469530,
            237469890,
            237472488,
            237474669
        ]
    },
    "name": "F. Field Should Not Be Empty",
    "statement": "You are given a permutation^{\r\ndagger} p of length n.We call index x if for all y < x it holds that p_y\r\n< p_x and for all y > x it holds that p_y > p_x. We call f(p) the number\r\nof good indices in p. You can perform the following operation: pick 2\r\nindices i and j and swap elements p_i and p_j. Find the maximum value of\r\nf(p) after applying the aforementioned operation .^{\r\ndagger}A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "// Problem: F. Field Should Not Be Empty\n// Contest: Codeforces Round 915 (Div. 2)\n// URL: https://codeforces.com/contest/1905/problem/F\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#pragma GCC optimize(\"Ofast,inline,unroll-loops\")\n// #define _GLIBCXX_DEBUG //\u4ea4\u9898\u524d\u8bb0\u5f97\u6ce8\u91ca\u6389\u4e0d\u7136\u5bb9\u6613T\u3002\n#include<bits/stdc++.h>\n#define File(s) freopen(#s\".in\",\"r\",stdin),freopen(#s\".out\",\"w\",stdout)\n#ifdef GTRAKIOI\n#define defrog(...) fprintf(stderr,__VA_ARGS__)\n#define deb(x) (std::cerr<<#x<<\"@\"<<__LINE__<<\"=\"<<(x)<<'\\n')\n#else\n#define defrog(...) 1\n#define deb(x) 1\n#endif\n#define defrogf(...) defrog(__VA_ARGS__)\n#if __cplusplus>=201703L\n#define rg\n#else\n#define rg register\n#endif\n#define ri rg int\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int>pii;\ntypedef std::vector<int>vi;\ntypedef std::vector<ll>vll;\ntypedef std::vector<pii>vpii;\ntypedef std::vector<vi >vvi;\ntypedef long double ld;\ntypedef __int128 i128;\ntypedef __uint128_t u128;\n#define Tp template<typename T>\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define all(cont) cont.begin(),cont.end()\n\nchar ibuf[1<<15],*p1,*p2;\n#define getchar() (p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,1<<15,stdin),p1==p2)?EOF:*p1++)\nstruct FastIO{\n\t/*inline void ou128(u128 x){\n\t\tu128 y=1;\n\t\twhile(y<=x/10)y*=10;\n\t\tdo putchar(x/y|48),x%=y,y/=10;while(y);\n\t}*/\n\tinline int rint(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c=='-';ri unsigned a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n\tinline ll rll(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c=='-';rg ull a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n//\tinline operator int(){return rint();}\n\tinline operator ll(){return rll();}\n\tinline char rchar(){rg char c;while(!isgraph(c=getchar()));return c;}\n\tinline int rstr(char*s){rg char c;while(!isgraph(c=getchar()));int cnt=-1;do s[++cnt]=c;while(isgraph(c=getchar()));s[++cnt]=0;return cnt;}\n}g90;\n\ntemplate<typename T=int>std::vector<T>rvec(std::size_t n,std::size_t start=0) {\n\tstd::vector<T>res(start+n);\n\tfor(std::size_t i=start;i<start+n;++i)res[i]=g90;\n\treturn res;\n}\n\nstd::mt19937 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int rnd(const int&a,const int&b){\n\treturn std::uniform_int_distribution<int>(a,b)(rng);\n}\ninline ld rnd(const ld&a,const ld&b){\n\treturn std::uniform_real_distribution<ld>(a,b)(rng);\n}\nnamespace MY_STD{\n\tTp inline T abs(const T&a){return a<0?-a:a;}\n}\n\nstruct DSU{//unweighted\n\tusing key_type=int;\n\n\tstd::vector<key_type>fa,size;\n\tinline DSU(key_type n):fa(n),size(n,1){std::iota(fa.begin(),fa.end(),0);}\n\tinline key_type& getFa(key_type x){\n\t\twhile(x^fa[x])x=fa[x]=fa[fa[x]];\n\t\treturn fa[x];\n\t}\n\tinline key_type& operator[](const key_type&x){return getFa(x);}\n\tinline auto canMerge(const key_type&u,const key_type&v){return getFa(u)!=getFa(v);}\n\tinline bool merge(key_type u,key_type v){\n\t\tu=getFa(u),v=getFa(v);\n\t\treturn (u)!=(v)&&(size[u]<size[v]&&(std::swap(u,v),1),fa[v]=u,size[u]+=size[v],size[v]=0,true);\n\t}\n\n};\n\nconstexpr int N=233333,M=1000000007;\ninline int qpow(ll a,ll b){ri res=1;for(;b;a=a*a%M,b>>=1)if(b&1)res=res*a%M;return res;}\n// #define pow qpow\nnamespace SegTree{\n\tstruct Node;\n\tusing Tree=Node*;\n\tusing CTree=const Node*;\n\tstruct Info{\n\t\tint res,max;\n\t};\n\tstruct Node{\n\t\tInfo info;\n\t\tTree ls,rs;\n\t}pool[N<<1];\n\tTree pptr=pool;\n\tvoid clear(){\n\t\tpptr=pool;\n\t}\n\tint search(const CTree&a,const CTree&b){\n\t\tif(b->ls==nullptr)return a->info.max<b->info.max?b->info.res:0;\n\t\tif(a->info.max<b->ls->info.max)return search(a,b->ls)+b->info.res-b->ls->info.res;\n\t\treturn search(a,b->rs);\n\t}\n\tInfo operator+(const Node&a,const Node&b){\n\t\treturn {a.info.res+search(&a,&b),std::max(a.info.max,b.info.max)};\n\t}\n\t#define lchild id->ls,l,mid\n\t#define rchild id->rs,mid+1,r\n\tvoid build(Tree&id,int l,int r){\n\t\tid=new(pptr++)Node{0,-M,nullptr,nullptr};\n\t\tif(l==r){\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tbuild(lchild);\n\t\tbuild(rchild);\n\t\t// std::cerr<<id<<' '<<l<<' '<<r<<' '<<id->ls<<' '<<id->rs<<'\\n';\n\t\tid->info=*(id->ls)+*(id->rs);\n\t}\n\tvoid modify(int pos,const int&x,int flag,Tree id,int l,int r){\n\t\t// std::cerr<<pos<<' '<<id<<' '<<l<<' '<<r<<'\\n';\n\t\tif(l==r){\n\t\t\tid->info.res=flag;\n\t\t\tid->info.max=x;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tif(pos<=mid)modify(pos,x,flag,lchild);\n\t\telse modify(pos,x,flag,rchild);\n\t\t\n\t\tid->info=*(id->ls)+*(id->rs);\n\t}\n}\n\nsigned main(){\n\tusing namespace SegTree;\n\t// int n=g90,m=g90;\n\t// Tree rt;\n\t// build(rt,0,n);\n\t// // std::cerr<<rt<<' '<<rt->ls<<' '<<rt->rs<<'\\n';\n\t// for(;m--;){\n\t\t// int x=g90,y=g90;\n\t\t// modify(x,Frac(y,x),rt,0,n);\n\t\t// printf(\"%d\\n\",rt->info.res-1);\n\t// }\n\tTree rt;\n\tint T=1;\n\tT=g90;\n\tfor(;T--;)[&]{\n\t\tint n=g90;\n\t\tclear();\n\t\tbuild(rt,0,n);\n\t\tvi p=rvec(n,1);\n\t\tfor(int x=1;x<=n;++x){\n\t\t\tmodify(x,p[x],p[x]==x,rt,0,n);\n\t\t}\n\t\tint ans=0;\n\t\t// deb(rt->info.res);\n\t\tauto op=[&](int x,int y){\n\t\t\tassert(x!=y);\n\t\t\tmodify(x,p[y],p[y]==x,rt,0,n);\n\t\t\tmodify(y,p[x],p[x]==y,rt,0,n);\n\t\t\t// std::cerr<<x<<' '<<y<<' '<<rt->info.res<<'\\n';\n\t\t\tans=std::max(ans,rt->info.res);\n\t\t\tmodify(x,p[x],p[x]==x,rt,0,n);\n\t\t\tmodify(y,p[y],p[y]==y,rt,0,n);\n\t\t};\n\t\t\n\t\tvi pmx(n+2),smn(n+2);\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tpmx[i]=(!pmx[i-1]||p[pmx[i-1]]<p[i]?i:pmx[i-1]);\n\t\t}\n\t\tfor(int i=n;i;--i){\n\t\t\tsmn[i]=(!smn[i+1]||p[smn[i+1]]>p[i]?i:smn[i+1]);\n\t\t}\n\t\tfor(int i=1;i<n;++i){\n\t\t\top(pmx[i],smn[i+1]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "divide and conquer"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Field Should Not Be Empty.json",
    "editorial_link": "https://codeforces.com//blog/entry/123384",
    "editorial": "SolutionThe key observation to this problem is that most swaps are\r\nuseless. In fact, we can find that only swaps can increase our initial\r\ncost: The first type of meaningful swaps is For each , consider and such\r\nthat and . The second type is . The reason why this is true is because\r\nthe first type of swap can create a new good index ( since every good\r\nindex must be a fixed point ) and the second type of swap can fix an\r\nalready good index. It\u00e2\u0080\u0099s obvious that if a swap does neither of the\r\nabove, it can\u00e2\u0080\u0099t increase our current cost.Calculating after each swap\r\ncan be done with a segment tree. Consider adding one on the ranges . Now\r\nan index is good if and only if its value is , which is also the minimum\r\nvalue an index can have. Thus our segment tree has to find the number of\r\nminimums while performing range additions which can be easily maintained\r\nby lazy propagation.This solution works in time complexity.\r\n"
}