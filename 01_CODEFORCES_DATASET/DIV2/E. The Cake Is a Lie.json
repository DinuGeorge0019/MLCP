{
    "link": "https://codeforces.com//contest/1282/problem/E",
    "problemId": "502550",
    "problem_idx": "E",
    "shortId": "1282E",
    "contest_number": "1282",
    "problem_submissions": {
        "E": [
            67546320,
            67540524,
            67541446,
            67546303,
            67546008,
            67555357,
            67546940,
            67554692,
            67554152,
            67544350,
            67536466,
            67548692,
            67540027,
            67545669,
            67549313,
            67547161,
            67559435,
            67546463
        ],
        "D": [
            67539652,
            67544407,
            67549747,
            67552213,
            67545569,
            67553744,
            67546954,
            67547692,
            67559514,
            67555818,
            67556694,
            67549779,
            67598315,
            67547666,
            67544808,
            67560465,
            67548234,
            67564097,
            67563835,
            67550417,
            67558326
        ],
        "C": [
            67534787,
            67533541,
            67536568,
            67540389,
            67537852,
            67536983,
            67539275,
            67539714,
            67541087,
            67545744,
            67547743,
            67539703,
            67555448,
            67535851,
            67539752,
            67537500,
            67540009,
            67540608,
            67537965,
            67542806
        ],
        "B1": [
            67530651,
            67528820,
            67529188,
            67532639,
            67529290,
            67531855,
            67532183,
            67532128,
            67536143,
            67531195,
            67544224,
            67536607,
            67547534,
            67532778,
            67535678,
            67530911,
            67533223,
            67529828,
            67532257,
            67532690
        ],
        "B2": [
            67530568,
            67528747,
            67529121,
            67532572,
            67529220,
            67531772,
            67532043,
            67532055,
            67536010,
            67535218,
            67544175,
            67536559,
            67747743,
            67553996,
            67532837,
            67535576,
            67530786,
            67533144,
            67529811,
            67532146,
            67532632
        ],
        "A": [
            67527639,
            67527588,
            67527631,
            67528416,
            67527601,
            67528381,
            67527986,
            67528304,
            67530259,
            67527611,
            67537517,
            67551469,
            67529352,
            67527672,
            67527752,
            67527928,
            67529147,
            67527871,
            67528083
        ]
    },
    "name": "E. The Cake Is a Lie",
    "statement": "It is known that the cake was originally a regular n-sided polygon, each\r\nvertex of which had a unique number from 1 to n. The vertices were\r\nnumbered in random order.Each piece of the cake is a triangle. The cake\r\nwas cut into n - 2 pieces as follows: each time one cut was made with a\r\nknife (from one vertex to another) such that exactly one triangular\r\npiece was separated from the current cake, and the rest continued to be\r\na convex polygon. In other words, each time three consecutive vertices\r\nof the polygon were selected and the corresponding triangle was cut\r\noff.A possible process of cutting the cake is presented in the picture\r\nbelow. You are given a set of n-2 triangular pieces in random order. The\r\nvertices of each piece are given in random order clockwise or\r\ncounterclockwise. Each piece is defined by three numbers the numbers of\r\nthe corresponding n-sided cake vertices.For example, for the situation\r\nin the picture above, you could be given a set of pieces: [3, 6, 5], [5,\r\n2, 4], [5, 4, 6], [6, 3, 1].You are interested in two questions. What\r\nwas the enumeration of the n-sided cake vertices? In what order were the\r\npieces cut? Formally, you have to find two permutations p_1, p_2,\r\ndots, p_n (1\r\nle p_i\r\nle n) and q_1, q_2,\r\ndots, q_{n - 2} (1\r\nle q_i\r\nle n - 2) such that if the cake vertices are numbered with the numbers\r\np_1, p_2,\r\ndots, p_n in order clockwise or counterclockwise, then when cutting\r\npieces of the cake in the order q_1, q_2,\r\ndots, q_{n - 2} always cuts off a triangular piece so that the remaining\r\npart forms one convex polygon.For example, in the picture above the\r\nanswer permutations could be: p=[2, 4, 6, 1, 3, 5] (or any of its cyclic\r\nshifts, or its reversal and after that any cyclic shift) and q=[2, 4, 1,\r\n3].Write a program that, based on the given triangular pieces, finds any\r\nsuitable permutations p and q.\r\n",
    "solutions": [
        "#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <stdint.h>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 200500\n#define MOD 998244353\n#define OFF 2001\nll n, x, k, z, m, pos, q, ans_v, y;\nll x1, p1, x2;\nset<pii> f;\nset<vector<ll> > g[205000];\nvector<ll> ff;\nvector<vector<ll> > ans;\nmap<vector<ll>, ll> num;\nvector<ll> ans1;\nll p[MAXN], nt[MAXN];\nvoid solve() {\n    f.clear();\n    num.clear();\n    ans.clear();\n    ans1.clear();\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        g[i].clear();\n    }\n    for (int i = 0; i < n - 2; i++) {\n        ll x;\n        ff.clear();\n        for (int j = 0; j < 3; j++) {\n            cin >> x;\n            ff.push_back(x);\n        }\n\n        sort(ff.begin(), ff.end());\n        num[ff] = i + 1;\n        for (int j = 0; j < 3; j++) {\n            g[ff[j]].insert(ff);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        f.insert(mp((ll)g[i].size(), i));\n    }\n    while (!f.empty()) {\n        auto it = f.begin();\n        if (it->X == 0) {\n            f.erase(it);\n            continue;\n        }\n        ll v = it->Y;\n        f.erase(it);\n        auto it2 = g[v].begin();\n        ff.clear();\n        for (auto x : *it2) {\n            ff.push_back(x);\n        }\n        for (auto x : ff) {\n            f.erase(mp((ll)g[x].size(), x));\n            g[x].erase(ff);\n            if (!g[x].empty()) {\n                f.insert(mp((ll)g[x].size(), x));\n            }\n        }\n        ans1.push_back(num[ff]);\n        for (int j = 0; j < 3; j++) {\n            if (ff[j] == v) {\n                swap(ff[j], ff[1]);\n                break;\n            }\n        }\n        ans.push_back(ff);\n    }\n    reverse(ans.begin(), ans.end());\n    for (int i = 1; i <= n; i++) {\n        p[i] = i;\n    }\n    p[ans[0][0]] = nt[ans[0][0]] = ans[0][2];\n    p[ans[0][2]] = nt[ans[0][2]] = ans[0][0];\n    for (int i = 0; i < n-2; i++) {\n        ll mid = ans[i][1];\n        ll l = ans[i][0];\n        ll r = ans[i][2];\n        if (nt[l] != r) {\n            swap(l, r);\n        }\n        nt[l] = mid;\n        nt[mid] = r;\n    }\n    ll x = 1;\n    do {\n        cout << x << \" \";\n        x = nt[x];\n    } while (x != 1);\n    cout << \"\\n\";\n    for (auto x : ans1) {\n        cout << x << \" \";\n    }\n    cout << \"\\n\";\n\n}\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n\n\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The Cake Is a Lie.json",
    "editorial_link": "https://codeforces.com/blog/entry/72461?locale=en",
    "editorial": "The problem can be solved in different ways: one can independently find\r\nboth permutations, or use one to find another.Firstly, let\u00e2\u0080\u0099s find the\r\norder of cutting cake pieces. Let\u00e2\u0080\u0099s take a look at the edges of the\r\nfirst piece. This triangle has a common side with no more than one other\r\npiece. If it has no common sides with other triangles there is only one\r\ntriangle, the answer is trivial. So we consider that the first triangle\r\nis adjacent to exactly one other triangle. After cutting off this\r\ntriangle, we have a similar problem for a ()-sided cake. Let the first\r\ntriangle be any triangle adjacent only to another triangle, cut it off,\r\nsolve the problem recursively. This can be done by building for the\r\npolygon dual graph.The remaining problem is to find the permutation :\r\nLet\u00e2\u0080\u0099s use to find . Reverse to get the order of adding triangles to\r\nobtain the desired polygon. This can be done by adding to the\r\ndoubly-linked list a triangle vertex, that wasn\u00e2\u0080\u0099t in the list before,\r\nbetween two existing ones. Let\u00e2\u0080\u0099s note that each side of the cake is\r\nfound exactly once in the input, the other edges are found twice. So we\r\nhave to find these sides of the polygon, then we get a doubly-linked\r\nlist, which represents .\r\n"
}