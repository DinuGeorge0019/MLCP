{
    "link": "https://codeforces.com//contest/1100/problem/F",
    "problemId": "281744",
    "problem_idx": "F",
    "shortId": "1100F",
    "contest_number": "1100",
    "problem_submissions": {
        "D": [
            48353320,
            48357025,
            48358665,
            48352439,
            48485627,
            48356511,
            48354584,
            48367255,
            48355872,
            48356938,
            48418676,
            48367598,
            48366911,
            48360912
        ],
        "E": [
            48350143,
            48346134,
            48343035,
            48344468,
            48345510,
            48344044,
            48355215,
            48356334,
            48347647,
            48367496,
            48345429,
            48350647,
            48345628,
            48345908,
            48337155,
            48369088,
            48368217,
            48368175,
            48346637
        ],
        "F": [
            48345973,
            48351415,
            48352189,
            48350710,
            48349016,
            48346778,
            48348725,
            48353766,
            48349571,
            58874033,
            48356957,
            48346827,
            48367535,
            48349001
        ],
        "C": [
            48336896,
            48335321,
            48334130,
            48334390,
            48335310,
            48344018,
            48335734,
            48342199,
            48338272,
            48337047,
            48341951,
            48335611,
            48336047,
            48332446,
            48337175,
            48367539,
            48338679,
            48338717
        ],
        "B": [
            48334048,
            48332782,
            48332647,
            48331840,
            48351673,
            48332494,
            48337726,
            48333602,
            48340544,
            48335461,
            48333231,
            48335841,
            48335239,
            48333836,
            48331660,
            48334686,
            48373723,
            48367780,
            48340073,
            48333386
        ],
        "A": [
            48332192,
            48331699,
            48331636,
            48331355,
            48331447,
            48334124,
            48331785,
            48335827,
            48332710,
            48331483,
            48333294,
            48331582,
            48332077,
            48331359,
            48331604,
            48367585,
            48333354,
            48331926
        ]
    },
    "name": "F. Ivan and Burgers",
    "statement": "Ivan loves burgers and spending money. There are n burger joints on the\r\nstreet where Ivan lives. Ivan has q friends, and the i-th friend\r\nsuggested to meet at the joint l_i and walk to the joint r_i (l_i\r\nleq r_i). While strolling with the i-th friend Ivan can visit all joints\r\nx which satisfy l_i\r\nleq x\r\nleq r_i.For each joint Ivan knows the cost of the most expensive burger\r\nin it, it costs c_i burles. Ivan wants to visit some subset of joints on\r\nhis way, in each of them he will buy the most expensive burger and spend\r\nthe most money. But there is a small issue: his card broke and instead\r\nof charging him for purchases, the amount of money on it changes as\r\nfollows.If Ivan had d burles before the purchase and he spent c burles\r\nat the joint, then after the purchase he would have d\r\noplus c burles, where\r\noplus denotes the bitwise XOR operation.Currently Ivan has 2^{2^{100}} -\r\n1 burles and he wants to go out for a walk. Help him to determine the\r\nmaximal amount of burles he can spend if he goes for a walk with the\r\nfriend i. The amount of burles he spends is defined as the difference\r\nbetween the initial amount on his account and the final account.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define MAXN 500005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,q,a[MAXN],ans[MAXN],bas[40],pos[40];\nvector<P> eve[MAXN];\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    scanf(\"%d\",&q);\n    for(int i=0;i<q;i++)\n    {\n        int l,r;scanf(\"%d%d\",&l,&r);\n        eve[r].push_back(P(l,i));\n    }\n    for(int i=1;i<=n;i++)\n    {\n        int x=a[i],p=i;\n        for(int j=20;j>=0;j--)\n        {\n            if(x&(1<<j))\n            {\n                if(!bas[j])\n                {\n                    bas[j]=x;pos[j]=p;\n                    break;\n                }\n                if(pos[j]<p) swap(bas[j],x),swap(pos[j],p);\n                x^=bas[j];\n            }\n        }\n        for(auto p:eve[i])\n            for(int j=20;j>=0;j--)\n                if(pos[j]>=p.F) ans[p.S]=max(ans[p.S],ans[p.S]^bas[j]);\n    }\n    for(int i=0;i<q;i++) printf(\"%d\\n\",ans[i]);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "greedy",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Ivan and Burgers.json",
    "editorial_link": "https://codeforces.com//blog/entry/64545",
    "editorial": "Note that to answer on a segment, it is enough to know the basis of this\r\nsegment, that is, the minimum set of numbers, with which you can\r\nrepresent all the numbers that are representable on this segment. Since\r\n, then the basis will be no more than . To find the maximum number, run\r\nthe Gauss algorithm for the basis so that there is no pair of numbers in\r\nthe basis for which the maximum bit is the same. Then the maximum\r\nrepresentable number can be obtained by the following algorithm: we will\r\nconsider the numbers starting from the maximum, and add them to the\r\nanswer if they increase the current answer.The complete problem can be\r\nsolved using the \"divide and conquer\" method: if we split the segment in\r\nhalf, then all requests on it either completely lie into one of the\r\nsegments, or lieinto both. For requests that completely lie in one of\r\nthe segments, we respond recursively. For queries that fall in both\r\nsegments, we combine two linear hulls and . All linear hulls of the form\r\nand can be obtained by adding vectors sequentially from right to left\r\n(on the right segment from left to right).An alternative solution was\r\nproposed at the contest. Note that a query on a segment is a suffix of\r\nsome array prefix. We will gradually increase the array prefix and\r\nmaintain the \"maximally right\" array basis (if for the current prefix we\r\ngo right through to the left, then the \"maximally right\" basis is the\r\ngreedily typed basis of array values). When adding an element, it can\r\neither not be presented in the current basis, then it must be added to\r\nthe current basis. If we can represent the element, then it is necessary\r\nto find the left-most element whose removal does not change the linear\r\nhull. This can be done by simulating Gauss algorithm from right to left:\r\nthe first representable element must be removed from the basis. Since\r\nthe basis is small, this operation can be done with each addition of a\r\nvector. We can get the answer to the problem, since for the fixed right\r\nelement, we know at what point the basis changes as the left border\r\nmoves from right to left.Complexity is or .\r\n"
}