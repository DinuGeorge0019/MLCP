{
    "link": "https://codeforces.com//contest/1638/problem/B",
    "problemId": "1297616",
    "problem_idx": "B",
    "shortId": "1638B",
    "contest_number": "1638",
    "problem_submissions": {
        "E": [
            146394309,
            146388037,
            146392264,
            146392799,
            146383148,
            146391230,
            146412303,
            146401025,
            146403078,
            146402136,
            179550421,
            146406748,
            146402980,
            146407733,
            146480267,
            146392395,
            146416198,
            146408751,
            146407567,
            146399245,
            146416242,
            146413814
        ],
        "D": [
            146373961,
            146380846,
            146385038,
            146375477,
            146392500,
            146381733,
            146401310,
            146378870,
            146384454,
            146387386,
            146387880,
            146390053,
            146382176,
            146480222,
            146406431,
            146388651,
            146388267,
            146392625,
            146412206,
            146374640,
            146389515
        ],
        "C": [
            146366299,
            146372352,
            146371729,
            146367670,
            146366106,
            146373666,
            146370507,
            146365761,
            146370642,
            146376834,
            146376510,
            146371594,
            146370051,
            146480186,
            146375503,
            146369319,
            146374946,
            146378437,
            146373206,
            146367076,
            146373277
        ],
        "B": [
            146362311,
            146363442,
            146362707,
            146365725,
            146364605,
            146363885,
            146366228,
            146383066,
            146364746,
            146368584,
            146368423,
            146367380,
            146366091,
            146480117,
            146369102,
            146364936,
            146367883,
            146370547,
            146366764,
            146364119,
            146368017
        ],
        "A": [
            146361810,
            146361860,
            146361937,
            146362725,
            146362534,
            146362379,
            146363944,
            146381318,
            146362119,
            146362820,
            146362493,
            146479991,
            146363108,
            146363259,
            146480100,
            146363531,
            146362617,
            146363968,
            146362163,
            146363256,
            146362105,
            146365613
        ],
        "F": [
            154464206,
            146479912,
            146613983,
            146474726,
            146640126
        ]
    },
    "name": "B. Odd Swap Sort",
    "statement": "You are given an array a_1, a_2,\r\ndots, a_n. You can perform operations on the array. In each operation\r\nyou can choose an integer i (1\r\nle i < n), and swap elements a_i and a_{i+1} of the array, if a_i +\r\na_{i+1} is odd.Determine whether it can be sorted in non-decreasing\r\norder using this operation any number of times.\r\n",
    "solutions": [
        "// Author: wlzhouzhuan\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(!isdigit(ch))f|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\ntemplate<typename T>void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n\tprint(x),putchar(ch);\n}\n\nconst int N=1000005;\n\nint n;\n\nvoid solve(){\n\tn=read();\n\tvector<int> a,b;\n\trep(i,1,n){\n\t\tint x=read();\n\t\tif(x&1)a.pb(x);\n\t\telse b.pb(x);\n\t}\n\tputs(is_sorted(a.begin(),a.end())&&is_sorted(b.begin(),b.end())?\"Yes\":\"No\");\n}\n\nint main(){\n\tint T=read();\n\twhile(T--)solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math",
        "sortings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Odd Swap Sort.json",
    "editorial_link": "https://codeforces.com//blog/entry/99942",
    "editorial": "The key idea is to start merging from the beginning using a stack.\r\nAssume that the connected components are always segments in the\r\npermutation (this solution also proves this by induction).We will\r\niterate the prefix and maintain in our stack the minimum/maximum element\r\nof all the segments in order. When we increase the prefix adding the\r\nnext position , we add to the top of the stack. Then, we merge the top\r\ntwo segments while we are able to. If the top two segments have their\r\nminimum/maximum elements and , in this order from the top, we will merge\r\nthem only if , because this means that an edge exist between the\r\ntwo.When we reach the end, our stack contains all connected components.\r\nNote that merging two adjacent intervals forms a new interval, so we\r\nhave proven by induction that our first assumption is correct.Time\r\ncomplexity: .\r\n",
    "hint": [
        "Hint 1 Replace the condition \" is odd\" with something easier to work with.",
        "Hint 2 The condition means that we only swap elements of different parity. Now, make some observations.",
        "Hint 3 What happens if there are some elements and ( ) of the same parity, such that ?",
        "Hint 4 If such pair exists, the answer is \"NO\". Now consider the array to be a merge between two increasing arrays (one with odd elements, one with even elements). Try to prove that the answer is always \"YES\" in this case.",
        "Hint 5 What does the Bubble Sort algorithm do here? Does it ever do an illegal swap?"
    ]
}