{"link": "https://codeforces.com//contest/180/problem/D", "problemId": "1263", "problem_idx": "D", "shortId": "180D", "contest_number": "180", "problem_submissions": {"A": [1612011, 1611035, 1611491, 1610423, 1608646, 1612209, 1610289, 1609636, 1609133, 1612193, 1612229, 1611072, 1612163, 1611991, 1610400, 1612436, 1617622], "E": [1610692, 1609351, 1609009, 1613114, 1609269, 1610641, 1610622, 1610904, 1610311, 1609559, 1609099, 1609957, 1610472, 1610971, 1609912, 1608828], "D": [1610104, 1610284, 1610538, 1611279, 1611479, 1611395, 1611538, 1611063, 1611009, 1611925, 1611800, 1650220], "B": [1609708, 1612372, 1611456, 1610499], "F": [1608611, 1608642, 1608360, 1608443, 1609619, 1608802, 1608911, 1609865, 1608836, 1608333, 1608944, 1608579, 1608822, 1608381], "C": [1608408, 1608345, 1608245, 1608291, 1608998, 1608357, 1608524, 1609626, 1608493, 1608501, 1608480, 1609176, 1608550, 1608260]}, "name": "D. Name", "statement": "Everything got unclear to us in a far away constellation Tau Ceti.\r\nSpecifically, the Taucetians choose names to their children in a very\r\npeculiar manner.Two young parents and think what name to give to their\r\nfirst-born child. They decided that the name will be the permutation of\r\nletters of string . To keep up with the neighbours, they decided to call\r\nthe baby so that the name was lexicographically strictly larger than the\r\nneighbour\u2019s son\u2019s name .On the other hand, they suspect that a name tax\r\nwill be introduced shortly. According to it, the Taucetians with\r\nlexicographically names will pay taxes. That\u2019s the reason and want to\r\ncall the newborn so that the name was lexicographically strictly larger\r\nthan name and lexicographically minimum at that.The lexicographical\r\norder of strings is the order we are all used to, the \"dictionary\"\r\norder. Such comparison is used in all modern programming languages to\r\ncompare strings. Formally, a string of length is lexicographically less\r\nthan string of length , if one of the two statements is correct: , and\r\nis the beginning (prefix) of string (for example, \"\" is less than string\r\n\"\"), , , ..., , for some (), here characters in strings are numbered\r\nstarting from 1. Write a program that, given string and the heighbours\u2019\r\nchild\u2019s name determines the string that is the result of permutation of\r\nletters in . The string should be lexicographically strictly more than\r\nand also, lexicographically minimum.\r\n", "solutions": ["#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint ntest = 0, test = 0;\ninline void init();\ninline void run();\ninline void stop() {\n\tntest = test - 1;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input\", \"r\", stdin);\n//\tfreopen(\"output\", \"w\", stdout);\n#endif\n\tinit();\n\twhile (++test <= ntest) {\n\t\trun();\n\t}\n\treturn 0;\n}\n\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, a) for (int i = 0; i < (a); i++)\n#define FIT(it, v) for (typeof((v).begin())it = (v).begin(); it != (v).end(); it++)\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define SET(a, x) memset((a), (x), sizeof(a))\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<typeof(*(v).begin())>())\n#define UNIQUE(v) SORT(v); (v).resize(unique(ALL(v)) - (v).begin())\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = (int) 1E9 + 5;\nconst double EPS = 1E-11;\nconst ll MOD = (ll) 1E9 + 7;\n\nconst int dx[] = { -1, 0, 0, 1 };\nconst int dy[] = { 0, -1, 1, 0 };\n\ninline void init() {\n\tntest = 1;\n}\n\nstring s, t;\nint cnt[300];\nchar ret[5005];\n\nbool doDfs(int level, bool larger) {\n\tif (level >= SZ(s)) {\n\t\tif (larger) {\n\t\t\tREP(i, SZ(s)) {\n\t\t\t\tprintf(\"%c\", ret[i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint MIN = 'a';\n\tif (!larger && SZ(t) > level) {\n\t\tMIN = t[level];\n\t}\n\tFOR(ch, MIN, 'z') {\n\t\tif (cnt[ch] <= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcnt[ch]--;\n\t\tret[level] = ch;\n\t\tif (!larger) {\n\t\t\tif (SZ(t) > level) {\n\t\t\t\tif (doDfs(level + 1, ch > t[level])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (doDfs(level + 1, true)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (doDfs(level + 1, true)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcnt[ch]++;\n\t}\n\n\treturn false;\n}\n\ninline void run() {\n\tgetline(cin, s);\n\tgetline(cin, t);\n\n\tFIT(it, s) {\n\t\tcnt[*it]++;\n\t}\n\n\tif (!doDfs(0, false)) {\n\t\tputs(\"-1\");\n\t}\n}\n"], "input": "", "output": "", "tags": ["greedy", "strings"], "dificulty": "1900", "interactive": false}