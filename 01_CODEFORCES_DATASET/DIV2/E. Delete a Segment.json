{"link": "https://codeforces.com//contest/1285/problem/E", "problemId": "512930", "problem_idx": "E", "shortId": "1285E", "contest_number": "1285", "problem_submissions": {"F": [68545833, 68535522, 68573334, 96999211, 96999146, 68573161, 69098509, 68626658, 68682994], "E": [68524941, 68518417, 68530554, 68529308, 68531407, 68531344, 68531615, 68534357, 68534051, 68529832, 68540790, 68535869, 68541711, 68538608, 68538163, 68537974, 68541963, 68539842, 68536496, 68538129], "D": [68507082, 68557516, 68506902, 68508017, 68510947, 68510777, 68514189, 68853550, 68517438, 68515728, 68517316, 68510494, 68517322, 68513984, 68513219, 68519377, 68516492, 68513650, 68514808, 68520824, 68521323], "C": [68504523, 68504942, 68504769, 68508581, 68506887, 68517568, 68507055, 68509904, 68509741, 68512066, 68504310, 68506343, 68505577, 68506877, 68502537, 68507690, 68510042, 68506486, 68506105, 68511726], "B": [68502726, 68503606, 68501596, 68503575, 68503622, 68503646, 68503039, 68505606, 68503233, 68506583, 68503941, 68502210, 68503653, 68503110, 68508414, 68502653, 68505318, 68503675, 68512385, 68505519], "A": [68497804, 68499469, 68497513, 68497595, 68499958, 68498702, 68497961, 68500159, 68498048, 68499346, 68497975, 68497626, 68497817, 68498423, 68498520, 68497604, 68497745, 68497829, 68499449, 68499473]}, "name": "E. Delete a Segment", "statement": "There are n segments on a Ox axis [l_1, r_1], [l_2, r_2], ..., [l_n,\r\nr_n]. Segment [l, r] covers all points from l to r inclusive, so all x\r\nsuch that l\r\nle x\r\nle r.Segments can be placed be inside each other, coincide and so on.\r\nSegments can degenerate into points, that is l_i=r_i is possible. of the\r\nset of segments is such a set of segments which covers exactly the same\r\nset of points as the original set. For example: if n=3 and there are\r\nsegments [3, 6], [100, 100], [5, 8] then their union is 2 segments: [3,\r\n8] and [100, 100]; if n=5 and there are segments [1, 2], [2, 3], [4, 5],\r\n[4, 6], [6, 6] then their union is 2 segments: [1, 3] and [4, 6].\r\nObviously, a union is a set of pairwise non-intersecting segments.You\r\nare asked to erase exactly one segment of the given n so that the number\r\nof segments in the union of the rest n-1 segments is maximum\r\npossible.For example, if n=4 and there are segments [1, 4], [2, 3], [3,\r\n6], [5, 7], then: erasing the first segment will lead to [2, 3], [3, 6],\r\n[5, 7] remaining, which have 1 segment in their union; erasing the\r\nsecond segment will lead to [1, 4], [3, 6], [5, 7] remaining, which have\r\n1 segment in their union; erasing the third segment will lead to [1, 4],\r\n[2, 3], [5, 7] remaining, which have 2 segments in their union; erasing\r\nthe fourth segment will lead to [1, 4], [2, 3], [3, 6] remaining, which\r\nhave 1 segment in their union. Thus, you are required to erase the third\r\nsegment to get answer 2.Write a program that will find the maximum\r\nnumber of segments in the union of n-1 segments if you erase any of the\r\ngiven n segments.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nconst int maxn = 800400;\nstruct node {\n\tint pl, pr, cn;\n\tnode(){\n\t\tpl = pr = cn = 0;\n\t}\n\tnode(int pl, int pr, int cn): pl(pl), pr(pr), cn(cn){}\n};\nnode operator + (node a, node b){\n\tint cn = a.cn + b.cn;\n\tif(a.pr && b.pl) cn--;\n\treturn (node){a.pl, b.pr, cn};\n}\nnode tr[maxn<<2];\nvoid upd(int id, int l, int r, int p){\n\tif(l == r) tr[id] = (node){1, 1, 1};\n\telse {\n\t\tint mid = (l + r)>>1;\n\t\tif(p <= mid) upd(id<<1, l, mid, p);\n\t\telse upd(id<<1|1, mid + 1, r, p);\n\t\ttr[id] = tr[id<<1] + tr[id<<1|1];\n\t}\n}\nvoid rst(int id, int l, int r, int p){\n\tif(l == r) tr[id] = (node){0, 0, 0};\n\telse {\n\t\tint mid = (l + r)>>1;\n\t\tif(p <= mid) rst(id<<1, l, mid, p);\n\t\telse rst(id<<1|1, mid + 1, r, p);\n\t\ttr[id] = tr[id<<1] + tr[id<<1|1];\n\t}\n}\nnode get(int id, int l, int r, int x, int y){\n\tif(l > y || r < x) return (node){0, 0, 0};\n\tif(x <= l && r <= y) return tr[id];\n\tint mid = (l + r)>>1;\n\tif(y <= mid) return get(id<<1, l, mid, x, y);\n\tif(x > mid) return get(id<<1|1, mid + 1, r, x, y);\n\treturn get(id<<1, l, mid, x, y) + get(id<<1|1, mid + 1, r, x, y);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint t; cin >> t;\n\twhile(t--){\n\t\tint n; cin >> n;\n\t\tvector<pair<int,int>> all(n);\n\t\tvector<int> pts;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> all[i].first >> all[i].second;\n\t\t\tall[i].first *= 2;\n\t\t\tall[i].second *= 2;\n\t\t\tpts.push_back(all[i].first - 1);\n\t\t\tpts.push_back(all[i].first);\n\t\t\tpts.push_back(all[i].second);\n\t\t\tpts.push_back(all[i].second + 1);\n\t\t}\n\t\tconst int inf = INT_MAX - 30;\n\t\tpts.push_back(-inf);\n\t\tpts.push_back(inf);\n\t\tsort(pts.begin(), pts.end());\n\t\tpts.erase(unique(pts.begin(), pts.end()), pts.end());\n\t\tint len = pts.size();\n\t\tvector<int> acc(2 * len, 0);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint pl = lower_bound(pts.begin(), pts.end(), all[i].first) - pts.begin();\n\t\t\tint pr = lower_bound(pts.begin(), pts.end(), all[i].second) - pts.begin();\n\t\t\tacc[pl]++;\n\t\t\tacc[pr+1]--;\n\t\t}\n\t\tfor(int i = 1; i < len; i++){\n\t\t\tacc[i] += acc[i - 1];\n\t\t}\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tif(acc[i] == 1){\n\t\t\t\tupd(1, 0, len, i);\n\t\t\t}\n\t\t}\n\t\tint tot = 0;\n\t\tfor(int i = 0, j = 0; i < len; i = j){\n\t\t\twhile(j < len && acc[j] == 0) j++;\n\t\t\tif(acc[i]){\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\ttot++;\n\t\t\t}\n\t\t}\n\t\ttot -= 2;\n\t\tint best = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint pl = lower_bound(pts.begin(), pts.end(), all[i].first) - pts.begin();\n\t\t\tint pr = lower_bound(pts.begin(), pts.end(), all[i].second) - pts.begin();\n\t\t\tnode at = get(1, 0, len, pl, pr);\n\t\t\tint here = tot + at.cn;\n\t\t\tif(acc[pl - 1] == 0 && at.pl) here--;\n\t\t\tif(acc[pr + 1] == 0 && at.pr) here--;\n\t\t\tbest = max(best, here + 1);\n\t\t}\n\t\tfor(int i = 0; i <= len; i++){\n\t\t\trst(1, 0, len, i);\n\t\t}\n\t\tcout << best << '\\n';\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "data structures", "dp", "graphs", "sortings", "trees", "two pointers"], "dificulty": "2300", "interactive": false}