{
    "link": "https://codeforces.com//contest/948/problem/D",
    "problemId": "164146",
    "problem_idx": "D",
    "shortId": "948D",
    "contest_number": "948",
    "problem_submissions": {
        "E": [
            36168620,
            36172204,
            36251405,
            36251326,
            36173384,
            36169252,
            36404487,
            36183304
        ],
        "D": [
            36163433,
            36167670,
            36167120,
            36164480,
            36164445,
            36162609,
            36165068,
            36162200,
            36164897,
            36162927,
            36164670,
            36161208,
            36169789,
            36165340,
            36163154,
            36157640,
            36165228,
            36165543,
            36161744,
            36165169
        ],
        "B": [
            36163096,
            36159675,
            36159702,
            36174211,
            36158845,
            36165864,
            36161702,
            36167381,
            36159372,
            36164193,
            36184907,
            36158822,
            36161863,
            36169531,
            36169227,
            36162688,
            36159710,
            36169741,
            36162780
        ],
        "C": [
            36159863,
            36162632,
            36162843,
            36159971,
            36160946,
            36158478,
            36159665,
            36159515,
            36161458,
            36161320,
            36162443,
            36163093,
            36159021,
            36158894,
            36174132,
            36201237,
            36164405,
            36159793,
            36161953,
            36158807,
            36162111
        ],
        "A": [
            36156394,
            36155837,
            36155755,
            36155535,
            36178220,
            36155392,
            36158997,
            36155227,
            36155148,
            36155311,
            36155229,
            36155259,
            36162558,
            36155502,
            36155114,
            36170875,
            36158967,
            36155326,
            36155358,
            36163726,
            36155813
        ]
    },
    "name": "D. Perfect Security",
    "statement": "Alice has a very important message consisting of some non-negative\r\nintegers that she wants to keep secret from Eve. Alice knows that the\r\nonly theoretically secure cipher is one-time pad. Alice generates a\r\nrandom key of the length equal to the message’s length. Alice computes\r\nthe bitwise xor of each element of the message and the key (, where\r\ndenotes the bitwise XOR operation) and stores this encrypted message .\r\nAlice is smart. Be like Alice.For example, Alice may have wanted to\r\nstore a message . She generated a key . The encrypted message is thus\r\n.Alice realised that she cannot store the key with the encrypted\r\nmessage. Alice sent her key to Bob and deleted her own copy. Alice is\r\nsmart. Really, be like Alice.Bob realised that the encrypted message is\r\nonly secure as long as the key is secret. Bob thus randomly permuted the\r\nkey before storing it. Bob thinks that this way, even if Eve gets both\r\nthe encrypted message and the key, she will not be able to read the\r\nmessage. Bob is not smart. Don’t be like Bob.In the above example, Bob\r\nmay have, for instance, selected a permutation and stored the permuted\r\nkey .One year has passed and Alice wants to decrypt her message. Only\r\nnow Bob has realised that this is impossible. As he has permuted the key\r\nrandomly, the message is lost forever. Did we mention that Bob isn’t\r\nsmart?Bob wants to salvage at least some information from the message.\r\nSince he is not so smart, he asks for your help. You know the encrypted\r\nmessage and the permuted key . What is the lexicographically smallest\r\nmessage that could have resulted in the given encrypted text?More\r\nprecisely, for given and , find the lexicographically smallest message ,\r\nfor which there exists a permutation such that for every .Note that the\r\nsequence is lexicographically smaller than the sequence , if there is an\r\nindex such that and for all the condition holds.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 300005;\nconst int MX = 1073741824;\n\nstruct NOD {\n\tNOD(int d = 0) : l(NULL), r(NULL), dt(d) {}\n\tNOD *l, *r;\n\tint dt;\n};\n\nNOD *seg;\n\nint A[MAXN], B[MAXN];\n\nint N;\n\nvoid upd(NOD *nw, int S, int E, int X) {\n\t(nw -> dt)++; if(S == E) return;\n\tint M = (ll(S) + E)/2;\n\tif(X <= M) {\n\t\tif(NULL == (nw -> l)) nw -> l = new NOD();\n\t\tupd(nw -> l, S, M, X);\n\t} else {\n\t\tif(NULL == (nw -> r)) nw -> r = new NOD();\n\t\tupd(nw -> r, M+1, E, X);\n\t}\n}\nvoid rmv(NOD *nw, int S, int E, int X) {\n\t//printf(\"rmv %d %d %d : %d\\n\", S, E, X, nw -> dt);\n\t(nw -> dt)--; if(S == E) return;\n\tint M = (ll(S) + E)/2;\n\tif(X <= M) {\n\t\trmv(nw -> l, S, M, X);\n\t} else {\n\t\trmv(nw -> r, M+1, E, X);\n\t}\n}\nint get(NOD *nw, int S, int E, int X) {\n\tif(S == E) return S;\n\tint M = (ll(S) + E) / 2;\n\t//printf(\"%d %d %d %d :: %d %d\\n\", S, E, X, M, (nw -> l) ? nw -> l -> dt : 0, (nw -> r) ? nw -> r -> dt : 0);\n\tif(((NULL == (nw -> r)) || ((nw -> r -> dt) < 1)) || ((S^X) < ((M+1)^X) && (NULL != (nw -> l)) && 0 < (nw -> l -> dt))) {\n\t\treturn get(nw -> l, S, M, X);\n\t} else {\n\t\treturn get(nw -> r, M+1, E, X);\n\t}\n}\n\nint main() {\n\tseg = new NOD();\n\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d\", &A[i]);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d\", &B[i]);\n\n\tfor(int i = 1; i <= N; i++) upd(seg, 0, MX-1, B[i]);\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tint x = A[i];\n\t\tint r = get(seg, 0, MX-1, x);\n\t\t//cout << x << \" \" << r << endl;\n\t\trmv(seg, 0, MX-1, r);\n\t\tprintf(\"%d \", x ^ r);\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "strings",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Perfect Security.json",
    "editorial_link": "https://codeforces.com//blog/entry/58286",
    "editorial": "We decrypt the message greedily, one number at a time. Note that  is a bijection on non-negative integers. For that reason, there is always a unique number from the key that lexicographically minimises the string. We can always pick and remove that number, output its xor with the current number from the encrypted text.\n\nIt remains to show how to do the above faster than . We build a trie on the numbers from the key, more precisely on their binary representation, starting from the most significant bit. To find the number Kj that minimises , one can simply search for Ai, bit by bit. That is, if the k-th most significant bit of Ai is 1, we try to follow the edge labelled 1, and 0 otherwise. If we always succeed in that, we have found Ai in the key multiset, and hence , which is clearly minimal. If at some bit, we do not succeed, we select the other branch (that is, if k-th bit of Ai is 1, but there is no such number in the key set, we pick 0 instead and continue. This solution uses  time, where W is the number of bits (here it is 30).\n\nThe same approach can be also implemented using multiset, which is probably faster to write, but has an extra  multiplicative factor, which may or may not fit into TL.",
    "hint": []
}