{
    "link": "https://codeforces.com//contest/1820/problem/F",
    "problemId": "1880614",
    "problem_idx": "F",
    "shortId": "1820F",
    "contest_number": "1820",
    "problem_submissions": {
        "E": [
            202221495,
            202224197,
            202223650,
            202221055,
            202211278,
            202210773,
            202210525,
            202392193,
            202234544,
            202241741
        ],
        "D": [
            202204493,
            202203834,
            202204941,
            202200357,
            202224521,
            202196714,
            202201649,
            202201288,
            202205548,
            202208808,
            202207552,
            202206152,
            202208768,
            202210206,
            202204088,
            202209173,
            202204193,
            202208143
        ],
        "C": [
            202188210,
            202190438,
            202191871,
            202204067,
            202186370,
            202194680,
            202193928,
            202184998,
            202190422,
            202190852,
            202188780,
            202191686,
            202189589,
            202189497,
            202191313,
            202189933,
            202193203,
            202191781,
            202192559,
            202193037
        ],
        "B": [
            202184059,
            202186314,
            202188694,
            202185290,
            202181971,
            202185877,
            202195824,
            202184988,
            202186184,
            202184424,
            202184282,
            202185384,
            202184368,
            202185406,
            202183611,
            202187273,
            202187259,
            202188101,
            202186319
        ],
        "A": [
            202181070,
            202181088,
            202184573,
            202180673,
            202180868,
            202181103,
            202180754,
            202181157,
            202181299,
            202180503,
            202180966,
            202180804,
            202180777,
            202180572,
            202180527,
            202180589,
            202182901,
            202184035,
            202181508
        ],
        "F": [
            202489739,
            202420015
        ]
    },
    "name": "F. Misha and Apples",
    "statement": "Schoolboy Misha got tired of doing sports programming, so he decided to\r\nquit everything and go to the magical forest to sell magic apples.His\r\nfriend Danya came to the magical forest to visit Misha. What was his\r\nsurprise when he found out that Misha found a lot of friends there, the\r\nsame former sports programmers. And all of them, like Misha, have their\r\nown shop where they sell magic apples. To support his friends, who have\r\nchanged their lives so drastically, he decided to buy up their entire\r\nassortment.The buying process works as follows: in total there are n\r\nstalls, numbered with integers from 1 to n, and m kinds of magic apples,\r\nnumbered with integers from 1 to m. Each shop sells some number of kinds\r\nof apples. Danya visits all the shops in order of increasing number,\r\nstarting with the first one. Upon entering the shop he buys one magic\r\napple of each kind sold in that shop and puts them in his\r\nbackpack.However, magical apples wouldn\u2019t be magical if they were all\r\nright. The point is that when two apples of the same type end up\r\ntogether in the backpack, all of the apples in it magically disappear.\r\nImportantly, the disappearance happens after Danya has put the apples in\r\nthe backpack and left the shop.Upon returning home, Danya realized that\r\nsomewhere in the forest he had managed to lose his backpack.\r\nUnfortunately, for some shops Danya had forgotten what assortment of\r\napples there was. Remembering only for some shops, what kinds of magical\r\napples were sold in them, he wants to know what is the maximum number of\r\napples he could have in his backpack after all his purchases at best.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MUSTGO 0\n#define MUSTSTAY 2\n#define ANYEVENT 1\n\nstruct Freq\n{\n    int fr[200100];\n    int nr1 = 0, nr2 = 0;\n    int st = 1, dr = 0;\n    int freeShops = 0;\n    void increment(int poz)\n    {\n        fr[poz]++;\n        if (fr[poz] == 1) {\n            nr1++;\n        }\n        else if (fr[poz] == 2) {\n            nr1--;\n            nr2++;\n        }\n    }\n    void decrement(int poz)\n    {\n        fr[poz]--;\n        if (fr[poz] == 1) {\n            nr2--;\n            nr1++;\n        }\n        else if (fr[poz] == 0) {\n            nr1--;\n        }\n    }\n    void extend(int repeat);\n    void retract(int repeat);\n    void retractToPoz(int poz);\n};\n\nint t, n, m, i, j, k, x;\nint ev[200100];\nvector<int> apples[200100];\nint lastGo, lastStay, lastAny;\nFreq smallfr, bigfr;\n\nvoid Freq::extend(int repeat)\n{\n    while (repeat--) {\n        dr++;\n        if (apples[dr].size() == 0)\n            freeShops++;\n        for (auto x : apples[dr]) {\n            this->increment(x);\n        }\n    }\n}\n\nvoid Freq::retract(int repeat)\n{\n    while (repeat--) {\n        if (apples[st].size() == 0)\n            freeShops--;\n        for (auto x : apples[st]) {\n            this->decrement(x);\n        }\n        st++;\n    }\n}\n\nvoid Freq::retractToPoz(int poz)\n{\n    while (st < poz) {\n        this->retract(1);\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> t;\n    while (t--) {\n        cin >> n >> m;\n        for (i = 1; i <= n; i++) {\n            cin >> k;\n            for (j = 1; j <= k; j++) {\n                cin >> x;\n                apples[i].push_back(x);\n            }\n        }\n        smallfr.st = bigfr.st = 1;\n        smallfr.dr = bigfr.dr = 0;\n        smallfr.extend(1);\n        bigfr.extend(1);\n        ev[1] = MUSTSTAY;\n        lastGo = 0;\n        lastStay = 1;\n        lastAny = 0;\n        for (i = 2; i <= n; i++) {\n            smallfr.extend(1);\n            bigfr.extend(1);\n            if (apples[i].size() == 0) {\n                if (ev[i-1] == MUSTGO) {\n                    ev[i] = MUSTSTAY;\n                }\n                else {\n                    ev[i] = ANYEVENT;\n                }\n            }\n            else {\n                if (ev[i-1] == MUSTGO) {\n                    ev[i] = MUSTSTAY;\n                }\n                else {\n                    if (smallfr.nr2) {\n                        ev[i] = MUSTGO;\n                    }\n                    else {\n                        if (bigfr.nr2 || bigfr.freeShops) {\n                            ev[i] = ANYEVENT;\n                        }\n                        else {\n                            ev[i] = MUSTSTAY;\n                        }\n                    }\n                }\n            }\n\n            if (ev[i] == MUSTGO) {\n                lastGo = i;\n            }\n            else if (ev[i] == MUSTSTAY) {\n                lastStay = i;\n            }\n            else if (ev[i] == ANYEVENT) {\n                lastAny = i;\n            }\n            smallfr.retractToPoz(max(lastGo, lastAny)+1);\n            bigfr.retractToPoz(lastGo+1);\n            if (bigfr.nr2) {\n                while (bigfr.nr2)\n                    bigfr.retract(1);\n                while (ev[bigfr.st-1] == MUSTSTAY) {\n                    bigfr.retract(1);\n                }\n            }\n        }\n        if (!bigfr.freeShops) {\n            cout << bigfr.nr1;\n        }\n        else {\n            cout << m;\n        }\n        cout << '\\n';\n        smallfr.retractToPoz(n+1);\n        bigfr.retractToPoz(n+1);\n        smallfr.st = bigfr.st = 1;\n        smallfr.dr = bigfr.dr = 0;\n        for (i = 1; i <= n; i++) {\n            apples[i].clear();\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Misha and Apples.json",
    "editorial_link": "https://codeforces.com//blog/entry/115133",
    "editorial": "In this problem, we need to choose which types of apples will be sold in stores with ki=0\n. Let's fix some arrangement of apples and consider the last moment in it when the apples disappeared from the backpack. All the apples that we took after this moment will go into the final answer, and if there was also a store with ki=0\n among these stores, then the answer is equal to m\n.\n\nDepending on the arrangement of apples, the moments of the last zeroing may change, so let's find all such moments of time after which disappearance may occur, and for all such moments, let's check if we can reach the end without zeroing, and if we can, then what is the maximum number of apples we can collect after that.\n\nFormally, let's calculate canZeroi\n for all 0?i?n\n, equal to 1 if there is such an arrangement of apples that after purchases in stores on the segment [1,i]\n, the backpack will be empty, and 0 otherwise, with canZero0=1\n. Also, let's calculate maxRemaini\n for all 0?i?n\n, equal to 0 if after passing on the segment [i+1,n]\n with an initially empty backpack, we are guaranteed to empty the backpack at least once, otherwise equal to m\n if there is a store with ki=0\n on this segment, otherwise equal to the total number of apples on this segment, with maxRemainn=0\n.\n\nThe second array is easily calculated by definition. Let's consider one of the ways to build the first array. We will build it from left to right. If ki=0\n, then we can guarantee that the backpack will be empty after this store, so the value of canZeroi\n for such i\n is 1. Otherwise, consider all the apples in this store. After the i\n-th store, the apples will disappear if one of these apples was already in the backpack before. Let's find the maximum such j<i\n that the store j\n contains one of the apples in the store i\n, or kj=0\n. Now let's find the maximum such s<j\n that canZeros=1\n. Then we check that there will be no disappearances on the segment [s+1,i?1]\n. In this case, canZeroi=1\n, otherwise it is equal to 0.\n\nThen the answer will be maxcanZeroi=1maxRemaini\n.\n\nTime complexity: O(n)\n."
}