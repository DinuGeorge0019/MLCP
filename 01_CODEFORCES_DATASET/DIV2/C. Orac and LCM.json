{
    "link": "https://codeforces.com//contest/1350/problem/C",
    "problemId": "619073",
    "problem_idx": "C",
    "shortId": "1350C",
    "contest_number": "1350",
    "problem_submissions": {
        "E": [
            79855181,
            79866892,
            79867578,
            79860431,
            79865664,
            79871653,
            79862377,
            79873286,
            79855797,
            79870095,
            79877566,
            79875250,
            79879082,
            79877229,
            79874099,
            79876185,
            79865098,
            79874891,
            79878375
        ],
        "D": [
            79841799,
            79863715,
            79838223,
            79843636,
            79845619,
            79851762,
            79859376,
            79851422,
            79856645,
            79867069,
            79852959,
            79854133,
            79862270,
            79854555,
            79857955,
            79860745,
            79863550,
            79877253,
            79858065,
            79853653
        ],
        "C": [
            79826908,
            79832989,
            79819179,
            79836044,
            79829980,
            79835199,
            79827905,
            79823236,
            79839284,
            79843003,
            79842971,
            79842595,
            79842398,
            79842899,
            79841428,
            79836029,
            79843846,
            79828517,
            79847123,
            79843527
        ],
        "B": [
            79820647,
            79822816,
            79842662,
            79823960,
            79824033,
            79823709,
            79822810,
            79820992,
            244797086,
            79824014,
            79827065,
            79834456,
            79825730,
            79829712,
            79832808,
            79831732,
            79824775,
            79833342,
            79819486,
            79827690,
            79827705
        ],
        "A": [
            79816852,
            79817819,
            79835688,
            79816825,
            79817311,
            79817807,
            79817556,
            79817787,
            79817609,
            79823750,
            79829915,
            79816664,
            79822342,
            79821478,
            79817922,
            79818871,
            79819448,
            79816826,
            79818898,
            79816798
        ],
        "F": [
            79877945
        ]
    },
    "name": "C. Orac and LCM",
    "statement": "For the multiset of positive integers s=\r\n{s_1,s_2,\r\ndots,s_k\r\n}, define the Greatest Common Divisor (GCD) and Least Common Multiple\r\n(LCM) of s as follow:\r\ngcd(s) is the maximum positive integer x, such that all integers in s\r\nare divisible on x.\r\ntextrm{lcm}(s) is the minimum positive integer x, that divisible on all\r\nintegers from s.For example,\r\ngcd(\r\n{8,12\r\n})=4,\r\ngcd(\r\n{12,18,6\r\n})=6 and\r\ntextrm{lcm}(\r\n{4,6\r\n})=12. Note that for any positive integer x,\r\ngcd(\r\n{x\r\n})=\r\ntextrm{lcm}(\r\n{x\r\n})=x.Orac has a sequence a with length n. He come up with the multiset\r\nt=\r\n{\r\ntextrm{lcm}(\r\n{a_i,a_j\r\n})\r\n|\r\ni<j\r\n}, and asked you to find the value of\r\ngcd(t) for him. In other words, you need to calculate the GCD of LCMs of\r\nall pairs of elements in the given sequence.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define N 200010\n#define ll long long\n#define INF 1000000000\nusing namespace std;\nint n,m1[N],m2[N],m3[N],x,su[N],ns,mi[N];\nll ans=1;\nvoid fen(int x){\n\twhile (x!=1){\n\t\tint j=mi[x],k=0;m3[j]++;\n\t\twhile (x%j==0){x/=j,k++;}\n\t\tif (k<m1[j]){m2[j]=m1[j],m1[j]=k;}\n\t\telse{if (k<m2[j])m2[j]=k;}\n\t}\n}\nint main(){\n\tcin>>n;\n\tfor (int j=2;j<=N-10;j++){\n\t\tm1[j]=INF,m2[j]=INF;\n\t\tif (mi[j]==0){mi[j]=j;su[++ns]=j;}\n\t\tfor (int i=1;i<=ns&&su[i]*j<=N-10;i++)mi[su[i]*j]=su[i];\n\t}\n\tfor (int i=1;i<=n;i++){cin>>x;fen(x);}\n\tfor (int j=2;j<=N-10;j++){\n\t\tif (m3[j]==n)for (int k=1;k<=m2[j];k++)ans=ans*j;\n\t\tif (m3[j]==n-1)for (int k=1;k<=m1[j];k++)ans=ans*j;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Orac and LCM.json",
    "editorial_link": "https://codeforces.com//blog/entry/77284",
    "editorial": "A cell (i,j)\n is said to be good if and only if there is a cell (i?,j?)\n adjacent to (i,j)\n which has the same color to (i,j)\n . If a cell (i,j)\n is not good, it is said to be bad. Therefore, the color of a cell changes after a turn if and only if the cell is good.\n\nAccording to the definition, any cell never changes its color if every cell is bad. Also, a good cell (i,j)\n would never turn into a bad cell .\n\nFor a bad cell (i,j)\n, if there is a good cell (i?,j?)\n adjacent to (i,j)\n, (i,j)\n will turn into a good cell after a turn because (i?,j?)\n currently has a different color from (i,j)\n and the color of (i?,j?)\n will change after a turn but the color of (i,j)\n won't change; otherwise, after a turn, the color of (i,j)\n and cells adjacent to (i,j)\n stays the same, so (i,j)\n is still bad.\n\nFor a cell (i,j)\n, let fi,j\n be the number of turns needed for that (i,j)\n becomes a good cell. According to the paragraph above, fi,j\n equals to the minimal Manhattan distance from (i,j)\n to a good cell. Therefore, fi,j\n can be figured out by BFS.\n\nNotice that for k?fi,j\n , the color of (i,j)\n stays the same after the k\n-th turn; for k>fi,j\n , the color of (i,j)\n changes after the k\n-th turn. Therefore, each query can be processed with O(1)\n time complexity. The total time complexity is O(nm+t)\n ."
}