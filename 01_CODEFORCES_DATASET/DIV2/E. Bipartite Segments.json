{
    "link": "https://codeforces.com//contest/902/problem/E",
    "problemId": "139721",
    "problem_idx": "E",
    "shortId": "902E",
    "contest_number": "902",
    "problem_submissions": {
        "E": [
            33432769,
            33432692,
            33431724,
            33432880,
            33433143,
            33425800,
            33479713,
            33434507
        ],
        "C": [
            33418857,
            33421216,
            33418092,
            33421721,
            33425094,
            33420634,
            33423702,
            33423018,
            33420334,
            33420303,
            33419836,
            33430662,
            33420269,
            33422420,
            33422328,
            33423548,
            33420458,
            33425360
        ],
        "B": [
            33414393,
            33416891,
            33413564,
            33416982,
            33418778,
            33415144,
            33420150,
            33416950,
            33420947,
            33415271,
            33415194,
            33431642,
            33414521,
            33417866,
            33416627,
            33417427,
            33416186,
            33419760
        ],
        "A": [
            33412979,
            33413298,
            33412683,
            33414789,
            33412988,
            33412835,
            33415972,
            33412736,
            33422119,
            33413143,
            33413263,
            33432089,
            33412738,
            33412994,
            33413252,
            33413078,
            33413621,
            33413563
        ],
        "D": [
            33425081,
            33422286,
            33426122,
            33429053,
            33429776,
            33430153,
            33430663,
            33428168,
            33429601,
            33428402,
            33429733
        ]
    },
    "name": "E. Bipartite Segments",
    "statement": "You are given an undirected graph with vertices. There are no\r\nedge-simple cycles with the even length in it. In other words, there are\r\nno cycles of even length that pass each edge at most once. Let\u2019s\r\nenumerate vertices from to . You have to answer queries. Each query is\r\ndescribed by a segment of vertices , and you have to count the number of\r\nits subsegments (), such that if we delete all vertices except the\r\nsegment of vertices (including and ) and edges between them, the\r\nresulting graph is bipartite.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\n\ntemplate <class T>\nvoid upd(T&a,T b) {\n    a = max(a,b);\n}\n\n\n\ntemplate<int maxn>\nstruct dsu{\n    int f[maxn];\n    dsu(){\n        init();\n    }\n    void init(){\n        REP(i,0,maxn)f[i] = i;\n    }\n    int fa(int c){\n        if(c==f[c])return c;\n        return f[c]=fa(f[c]);\n    }\n    void merge(int a,int b){\n        a = fa(a);b = fa(b);\n        if(a == b)return;\n        f[fa(a)] = fa(b);\n    }\n    bool same(int a,int b){\n        return fa(a) == fa(b);\n    }\n};\nconst int maxn = 300010;\nint n,m;\nvector<int>adj[maxn];\n\n\nint tot = 1;\nint dfn[maxn],low[maxn];\ndsu<maxn>bcj;\nvoid tarjan(int cur,int fa){\n    dfn[cur] = low[cur] = tot++;\n    for(auto i:adj[cur]){\n        if(i != fa){\n            if(!dfn[i]){\n                tarjan(i, cur);\n                low[cur] = min(low[cur],low[i]);\n                if(low[i] <= dfn[cur])bcj.merge(cur, i);\n            }else{\n                low[cur] = min(low[cur],dfn[i]);\n                bcj.merge(cur, i);\n            }\n        }\n    }\n}\n\n\nvoid read(){\n    in(n,m);\n    REP(i,0,m){\n        int u,v;in(u,v);\n        adj[u].PB(v);\n        adj[v].PB(u);\n    }\n}\n\nvector<int>groups[maxn];\nint rmo[maxn];\nvoid work(){\n    REP(i,1,n+1){\n        if(!dfn[i])tarjan(i, 0);\n    }\n    REP(i,1,n+1)groups[bcj.fa(i)].PB(i);\n    REP(i,1,n+1)rmo[i] = n;\n    REP(i,1,n+1){\n        if(sz(groups[i]) >= 2){\n            rmo[groups[i][0]] = groups[i].back()-1;\n        }\n    }\n    RREP(i,n-1,1){\n        rmo[i] = min(rmo[i],rmo[i+1]);\n    }\n}\n\nll answer[maxn];\nstruct query{\n    int l,r,id;\n    bool operator<(const query&o)const{\n        return r<o.r;\n    }\n};\nquery qs[maxn];\n\n\nstruct SegTree{\n    static const int maxn = 300010;\n    \n    struct node{\n        int l,r;\n        ll sum,lazy;\n        ll get_sum(){\n            return sum+lazy*(r-l+1);\n        }\n    };\n    \n    node no[maxn*4];\n    \n    void push_up(int ind){\n        no[ind].sum = no[lson].get_sum()+no[rson].get_sum();\n    }\n    void push_down(int ind){\n        no[lson].lazy+=no[ind].lazy;\n        no[rson].lazy+=no[ind].lazy;\n        no[ind].lazy = 0;\n    }\n    void build(int l,int r,int ind){\n        no[ind].l = l;\n        no[ind].r = r;\n        if(l == r){\n            no[ind].lazy  = no[ind].sum = 0;\n        }else{\n            int mid = (l+r)/2;\n            build(l,mid,lson);\n            build(mid+1,r,rson);\n            push_up(ind);\n        }\n    }\n    void update(int l,int r,int ind,int val){\n        if(l>no[ind].r || r<no[ind].l)return;\n        if(l<=no[ind].l && no[ind].r <= r){\n            no[ind].lazy+=val;\n        }else{\n            push_down(ind);\n            update(l,r,lson,val);\n            update(l,r,rson,val);\n            push_up(ind);\n        }\n    }\n    void query(int l,int r,int ind,ll& ans){\n        if(l>no[ind].r || r<no[ind].l)return;\n        if(l<=no[ind].l && no[ind].r <= r){\n            ans+=no[ind].get_sum();\n        }else{\n            push_down(ind);\n            query(l,r,lson,ans);\n            query(l,r,rson,ans);\n            push_up(ind);\n            \n        }\n    }\n};\n\nSegTree tree;\n\n\nvoid solve(){\n    tree.build(1, n, 1);\n    int cnt = 0;in(cnt);\n    REP(i,0,cnt)in(qs[i].l,qs[i].r);\n    REP(i,0,cnt)qs[i].id = i;\n    sort(qs,qs+cnt);\n    int l = 1,r = 1;\n    tree.update(1, 1, 1, 1);\n    REP(i,0,cnt){\n        while(r<qs[i].r){\n            r++;\n            while(rmo[l] < r)l++;\n            tree.update(l, r, 1, 1);\n        }\n        answer[qs[i].id] = 0;\n        tree.query(qs[i].l,qs[i].r, 1, answer[qs[i].id]);\n    }\n//    REP(i,1,4){\n//        ll ym = 0;\n//        tree.query(i,i, 1, ym);\n//        dbg(ym);\n//    }\n    REP(i,0,cnt)lout(answer[i]);\n}\n\nint main(){\n    read();\n    work();\n//    REP(i,1,n+1)dbg(rmo[i]);\n//    REP(i,1,n+1)dbg(low[i]);\n//    REP(i,1,n+1)dbg(bcj.fa(i));\n    solve();\n    return 0;\n}\n//\n//6 6\n//1 2\n//2 3\n//3 1\n//4 5\n//5 6\n//6 4\n//3\n//1 3\n//4 6\n//1 6\n\n\n//\n//6 6\n//1 2\n//2 3\n//3 1\n//4 5\n//5 6\n//6 4\n//1\n//1 3\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Bipartite Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/56478",
    "editorial": "If two cycles of odd length intersect, then they can be bypassed so as to obtain an edge-simple cycle of even length.\n\nIt follows that the given graph is a vertex cactus, with cycles of odd length, then the vertex segment is good - if there is no loop, that the vertex with the minimum number from this cycle is present on this segment and the vertex with the maximum number from this cycle is present on this segment. Then we can select all the cycles, and now we work with the segments.\n\nLet us find for each vertex a maximal right boundary such that the interval [i..mxi] is a bipartite graph.\n\nThen mxi is equal to the minimal right boundary of the segment, which was opened later i.\n\nThis can be considered a minimum on the suffix, initially setting for all cycles mx[minimum on the cycle] = maximum on the cycle\n\nTo answer the query, we need to take the sum over mxi?-?i?+?1 for those who have mxi???r and the sum over r?-?i?+?1 for those who have mxi???r\n\nthen we note that mxi increases and we simply need to find the first moment when mxi becomes ???r (we can do it with binary search)\n\nAnd take two prefix sums - sum of (mxi?-?i?+?1) and sum of i."
}