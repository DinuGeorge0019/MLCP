{"link": "https://codeforces.com//contest/1802/problem/F", "problemId": "1817559", "problem_idx": "F", "shortId": "1802F", "contest_number": "1802", "problem_submissions": {"F": [196663888, 196625008, 196625749, 196635602, 196634743, 196643091, 196651329, 196656599, 196633915, 196648089, 196652202, 196632881, 196638320, 196651695, 196637871, 196638608, 196644590, 196711680], "G": [196633429, 196750849], "A": [196608625, 196601765, 196601430, 196604403, 196601551, 196601415, 196601637, 196621554, 197609656, 196604338, 196602290, 196601755, 196624562, 196602593, 196601829, 196602885, 196603556, 196602800, 196601750, 196602859, 196601468], "C": [196603858, 196634826, 196613689, 196616450, 196615629, 196606590, 196615213, 196643285, 196614451, 196642605, 196612216, 196636938, 196666118, 196610483, 196616792, 196626477, 196610562, 196619309, 196615002, 196608792], "D": [196603459, 196611669, 196611547, 196620657, 196623482, 196612856, 196623750, 196629627, 197067794, 196623474, 196620294, 196724558, 196619887, 196617809, 196618077, 196620127, 196622956, 196623094, 196616226], "B": [196601817, 196604589, 196605912, 196607950, 196604989, 196602908, 196605368, 196624195, 197609716, 196611451, 196608455, 196605092, 196630916, 196608589, 196607012, 196607509, 196609282, 196615569, 196605751, 196607659, 196606374], "E": [196616155, 196623146, 196626388, 196631009, 196622442, 196634549, 196631368, 196632011, 196635287, 196622016, 196653867, 196631106, 196668550, 196632178, 196624422, 196629837, 196626927, 196632190, 196635404]}, "name": "F. The way home", "statement": "The famous magician Borya Budini traveled through the country X, which\r\nconsists of n cities. However, an accident happened, and he was robbed\r\nin the city number 1. Now Budini will have a hard way home to the city\r\nnumber n.He\u2019s going to get there by plane. In total, there are m flights\r\nin the country, i-th flies from city a_i to city b_i and costs s_i\r\ncoins. Note that the i-th flight is one-way, so it can\u2019t be used to get\r\nfrom city b_i to city a_i. To use it, Borya must be in the city a_i and\r\nhave at least s_i coins (which he will spend on the flight). After the\r\nrobbery, he has only p coins left, but he does not despair! Being in the\r\ncity i, he can organize performances every day, each performance will\r\nbring him w_i coins. Help the magician find out if he will be able to\r\nget home, and what is the minimum number of performances he will have to\r\norganize.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = i64(1e18);\nint N, M, order[1010]; i64 P;\nvector<pair<int,i64>> adj[1010];\ni64 dis[1010][1010], W[1010];\npair<i64,i64> dp[1010];\nvoid dij(int s) {\n\tfor (int i = 0; i <= N; i++) dis[s][i] = INF;\n\tpriority_queue<pair<i64,int>, vector<pair<i64,int>>, greater<pair<i64,int>>> pq;\n\tpq.emplace(dis[s][s] = 0, s);\n\twhile (pq.size()) {\n\t\tauto [d, u] = pq.top(); pq.pop();\n\t\t// cerr << \"pop \" << d << \" \" << u << '\\n';\n\t\tif (d != dis[s][u]) continue;\n\t\tfor (auto [v, w] : adj[u]) if (dis[s][v] > dis[s][u] + w) {\n\t\t\tdis[s][v] = dis[s][u] + w;\n\t\t\tpq.emplace(dis[s][v], v);\n\t\t}\n\t}\n}\nvoid solve() {\n\tcin >> N >> M >> P;\n\tfor (int i = 1; i <= N; i++) cin >> W[i];\n\tfor (int i = 1; i <= N; i++) adj[i].clear();\n\tfor (int i = 1; i <= M; i++) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tadj[a].emplace_back(b, c);\n\t}\n\tfor (int i = 1; i <= N; i++) dij(i);\n\tiota(order+1, order+N+1, 1);\n\tsort(order+2, order+N+1, [&](int i, int j) { return W[i] < W[j]; });\n\tfor (int i = 0; i <= N; i++) dp[i] = {INF, 0};\n\tdp[1] = {0, -P};\n\tif (dis[1][N] > INF/2) {\n\t\tcout << \"-1\\n\";\n\t\treturn;\n\t}\n\tfor (int it = 1; it <= 2; it++) {\n\t\tfor (int z = 2; z <= N; z++) {\n\t\t\tint u = order[z];\n\t\t\tfor (int zz = 1; zz < (u == N ? N+1 : z); zz++) {\n\t\t\t\tint v = order[zz];\n\t\t\t\t// cerr << v << \" -> \" << u << \" \" << dis[v][u] << '\\n';\n\t\t\t\tif (dis[v][u] > INF/2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ti64 tim = dp[v].first, cur = -dp[v].second, need = dis[v][u];\n\t\t\t\tif (cur >= need) dp[u] = min(dp[u], {tim, - (cur - need)});\n\t\t\t\telse {\n\t\t\t\t\ti64 cost = (need - cur - 1) / W[v] + 1;\n\t\t\t\t\tdp[u] = min(dp[u], {tim + cost, - (cur + cost * W[v] - need)});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[N].first > INF/2 ? -1 : dp[N].first) << '\\n';\n}\nint main() {\n\tios::sync_with_stdio(false), cin.tie(nullptr);\n\tint T; cin >> T;\n\twhile (T--) solve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dp", "graphs", "greedy", "shortest paths"], "dificulty": "2100", "interactive": false}