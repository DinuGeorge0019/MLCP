{
    "link": "https://codeforces.com//contest/964/problem/E",
    "problemId": "175445",
    "problem_idx": "E",
    "shortId": "964E",
    "contest_number": "964",
    "problem_submissions": {
        "E": [
            37409419,
            37412882,
            37412551,
            37537258
        ],
        "D": [
            37405314,
            37405406,
            37407186,
            37404280,
            37404169,
            37408650,
            37406709,
            37408309,
            37407949,
            37409754,
            37405372,
            37408312,
            37409242,
            37407775,
            37408039,
            37410204,
            37408800,
            37409358,
            37410244,
            37411197
        ],
        "C": [
            37403398,
            37403877,
            37404364,
            37401413,
            37406057,
            37403278,
            37403765,
            37403218,
            37404076,
            37402918,
            37409929,
            37404535,
            37403561,
            37404289,
            37406113,
            37406564,
            37405628,
            37403427,
            37405874,
            37402908
        ],
        "B": [
            37401124,
            37399470,
            37399569,
            37398293,
            37401006,
            37399516,
            37400304,
            37400317,
            37401519,
            37403572,
            37400503,
            37400997,
            37400932,
            37399240,
            37399448,
            37399083,
            37401068,
            37406879,
            37401310,
            37399198
        ],
        "A": [
            37400130,
            37398594,
            37414688,
            37397760,
            37399494,
            37397960,
            37399304,
            37398291,
            37400088,
            37398209,
            37398067,
            37399344,
            37399606,
            37397801,
            37398329,
            37398304,
            37399455,
            37398145,
            37398241,
            37397856
        ]
    },
    "name": "E. Cutting Rectangle",
    "statement": "A rectangle with sides A and B is cut into rectangles with cuts parallel\r\nto its sides. For example, if p horizontal and q vertical cuts were\r\nmade, (p + 1)\r\ncdot (q + 1) rectangles were left after the cutting. After the cutting,\r\nrectangles were of n different types. Two rectangles are different if at\r\nleast one side of one rectangle isn’t equal to the corresponding side of\r\nthe other. Note that the rectangle can’t be rotated, this means that\r\nrectangles a\r\ntimes b and b\r\ntimes a are considered different if a\r\nneq b.For each type of rectangles, lengths of the sides of rectangles\r\nare given along with the amount of the rectangles of this type that were\r\nleft after cutting the initial rectangle.Calculate the amount of pairs\r\n(A; B) such as the given rectangles could be created by cutting the\r\nrectangle with sides of lengths A and B. Note that pairs (A; B) and (B;\r\nA) are considered different when A\r\nneq B.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\n\nstruct Tnode {\n\tlong long w, h, c;\n} d[maxn];\n\nbool cmp(const Tnode &a, const Tnode &b) {\n\tif (a.w == b.w) return a.h < b.h;\n\treturn a.w < b.w;\n}\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tint n;\n\tscanf(\"%lld\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld%lld%lld\", &d[i].w, &d[i].h, &d[i].c);\n\t}\n\tsort(d + 1, d + n + 1, cmp);\n\t\n\tint tail = 0;\n\tfor (int i = 1; i <= n; i++) \n\t\tif (i == 1 || d[i].w != d[i - 1].w || d[i].h != d[i - 1].h) d[++tail] = d[i];\n\t\telse d[tail].c += d[i].c;\n\tn = tail;\n\t/*if (d[1].w == d[n].w) {\n\t\tint cur = d[1].c;\n\t\tfor (int i = 2; i <= n; i++) cur = __gcd(cur, d[i].c);\n\t\tprintf(\"%d\\n\", calc(cur));\n\t\treturn 0;\n\t}*/\n\tint k = n;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (d[i].w != d[i - 1].w) {\n\t\t\tk = i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (k != 1) {\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\tif (i % k != 1 && d[i].w != d[i - 1].w) {\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n\t\n\tfor (int i = k + 1; i <= n; i++) \n\t\tif (d[i].h != d[i - k].h) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (int i = 1; i + k <= n; i += k) {\n\t\tfor (int j = 0; j < k; j++) \n\t\t\tif ((long long)d[i].c * d[i + k + j].c != (long long)d[i + j].c * d[i + k].c) {\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n\t\n\tlong long cur = d[1].c;\n\tfor (int i = 1; i <= n; i++) cur = __gcd(cur, d[i].c);\n\t\n/*\tlong long lcm = d[1].c;\n\tfor (int i = k + 1; i <= n; i += k) {\n\t\tlcm = lcm * d[i].c / __gcd(lcm, d[i].c);\n\t}\n\tlcm /= d[1].c;*/\n\t\n\tint ans = 0;\n\tfor (long long i = 1; i * i <= cur; i++)\n\t\tif (cur % i == 0) {\n\t\t\tans++;\n\t\t\tif (i * i != cur) ans++;\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Cutting Rectangle.json",
    "editorial_link": "https://codeforces.com//blog/entry/58991",
    "editorial": "There are a lot of ways to solve this problem.\n\nLet ai\n occurs in input cntai\n (sum of c\n) times ?nd aj\n occurs cntaj\n. Then on a side of initial rectangle number of times ai\n occurs /\n number of times aj\n occurs is a ratio (cntai:cntaj)\n. Analogically for b\n.\n\nLet's build the smallest rectangle which satisfies this ratio and call him the base one. Then initial rectangle should consist of it.\n\nThe last step is to check that initial rectangle consists of base ones. To do this we'll iterate over all types of rectangles in input and if we find a mistake - print 0. In this way we will check no more than n+1\n types of recktangles.\n\nAn answer for this task is number of divisors of ratio between the initial rectangle and the base one (it's not hard to see that this ratio equals to GCD\n of all ci\n)",
    "hint": []
}