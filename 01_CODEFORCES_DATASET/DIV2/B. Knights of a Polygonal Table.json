{"link": "https://codeforces.com//contest/994/problem/B", "problemId": "190660", "problem_idx": "B", "shortId": "994B", "contest_number": "994", "problem_submissions": {"F": [39313692, 39315581, 95930723, 39333904], "D": [39298471, 39300217, 39307900, 39306172, 39303222, 39306617, 39330421, 39308869, 39310792, 39309655, 39306797, 39316533, 39305772, 39310407, 39314015, 39300951, 39309805, 39302653, 39303950, 39306436], "B": [39294915, 39295275, 39295676, 39295849, 39296984, 39296665, 39296958, 39296174, 39296249, 39295589, 39295750, 39299723, 39296783, 39298775, 39295093, 39296348, 39296369, 39296067, 39296627], "A": [39292025, 39292170, 39292210, 39296891, 39292448, 39292868, 39293213, 39292353, 39294071, 39292079, 39292190, 39292131, 39292850, 39293045, 39292213, 39293330, 39292422, 39292084], "C": [39312207, 39297429, 39302694, 39300203, 39302994, 39301715, 39301431, 39300472, 39302324, 39299468, 39310028, 39306138, 39303929, 39297727, 39301261, 39298603, 39300542], "E": [39305109, 39304789, 39310854, 39313649, 39313461, 39330509, 39311502, 39313415, 39314951, 39309721, 39313040, 39314741, 39315937, 39307951]}, "name": "B. Knights of a Polygonal Table", "statement": "Unlike Knights of a Round Table, Knights of a Polygonal Table deprived\r\nof nobility and happy to kill each other. But each knight has some power\r\nand a knight can kill another knight if and only if his power is greater\r\nthan the power of victim. However, even such a knight will torment his\r\nconscience, so he can kill no more than k other knights. Also, each\r\nknight has some number of coins. After a kill, a knight can pick up all\r\nvictim\u2019s coins.Now each knight ponders: how many coins he can have if\r\nonly he kills other knights?You should answer this question for each\r\nknight.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair <int, int> pii; \ntypedef pair <pair <int, int>, int> piii; \nint answers [200005];\nmain(){\n    ios_base::sync_with_stdio(0);\n    int a, b; cin >> a >> b; \n    vector <int> x, y; \n    vector <piii> den; \n    for (int i=0; i<a; i++){\n        int r; cin >> r; x.push_back(r); \n    }\n    for (int i=0; i<a; i++){\n        int r; cin >> r; y.push_back(r); \n        den.push_back(piii(pii(x[i], y[i]), i)); \n    }\n    sort(den.begin(), den.end()); \n    multiset <int> xk; \n    \n    for (int i=0; i<den.size(); i++){\n        int rz = 0; \n        int ans = den[i].first.second; \n        if (xk.size() > 0){\n            auto rf = --xk.end(); \n            while (rz < b){\n                rz+=1; \n                ans+=(*rf); \n                if (rf == xk.begin()) break; \n                --rf; \n            }\n        }\n        answers[den[i].second] = ans; \n        xk.insert(den[i].first.second);\n    }\n    for (int i=0; i<a; i++) cout << answers[i] << '\\n';\n    return 0;\n}"], "input": "", "output": "", "tags": ["greedy", "implementation", "sortings"], "dificulty": "1400", "interactive": false}