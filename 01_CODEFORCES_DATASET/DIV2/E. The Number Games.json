{
    "link": "https://codeforces.com//contest/980/problem/E",
    "problemId": "181718",
    "problem_idx": "E",
    "shortId": "980E",
    "contest_number": "980",
    "problem_submissions": {
        "E": [
            38038539,
            38045785,
            38060701,
            38046614,
            38041883,
            38044896,
            38156095,
            38156078,
            38156061,
            38156040,
            38072066,
            38047353,
            38038047,
            38043388,
            38111608,
            38111590,
            38045284,
            38042270,
            38038266,
            38035504,
            38040125,
            38049313,
            38049169,
            38042734,
            38048647,
            38040602,
            38042070,
            38043155
        ],
        "D": [
            38033907,
            38032813,
            38038724,
            38038674,
            38041057,
            38038837,
            38034371,
            38046473,
            38049113,
            38037846,
            38051369,
            38051240,
            38044218,
            38039452,
            38054307,
            38079043,
            38079024,
            38043863,
            38813838
        ],
        "C": [
            38031306,
            38038468,
            38034397,
            38032152,
            38033603,
            38033400,
            38059857,
            38035211,
            38035303,
            38033154,
            38031809,
            38032840,
            38031754,
            38036211,
            38036608,
            38032601,
            38035163,
            38031869,
            38035397,
            38029282
        ],
        "B": [
            38028530,
            38048301,
            38030919,
            38029470,
            38030897,
            38030105,
            38029818,
            38031146,
            38060661,
            38028845,
            38030045,
            38037463,
            38028546,
            38038973,
            38029430,
            38050585,
            38032687,
            38031932
        ],
        "A": [
            38024341,
            38025152,
            38027637,
            38026879,
            38024463,
            38025009,
            38024567,
            38024355,
            38024220,
            38024988,
            38024959,
            38024227,
            38024460,
            38024685,
            38024924,
            38024456,
            38024718,
            38025274,
            38024545
        ],
        "F": [
            138375213
        ]
    },
    "name": "E. The Number Games",
    "statement": "The nation of Panel holds an annual show called The Number Games, where\r\neach district in the nation will be represented by one contestant.The\r\nnation has n districts numbered from 1 to n, each district has exactly\r\none path connecting it to every other district. The number of fans of a\r\ncontestant from district i is equal to 2^i.This year, the president\r\ndecided to reduce the costs. He wants to remove k contestants from the\r\ngames. However, the districts of the removed contestants will be furious\r\nand will not allow anyone to cross through their districts. The\r\npresident wants to ensure that all remaining contestants are from\r\ndistricts that can be reached from one another. He also wishes to\r\nmaximize the total number of fans of the participating contestants.Which\r\ncontestants should the president remove?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 1007681537;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 1e6 + 5;\nconst int logn = 20;\nint n, k;\nvi adj[maxn];\nint lev[maxn];\nint par[logn][maxn];\n\nvoid dfs(int u, int dad) {\n    FOR(i, 1, logn) {\n        par[i][u] = par[i - 1][par[i - 1][u]];\n    }\n    for (int v : adj[u]) {\n        if (v != dad) {\n            lev[v] = lev[u] + 1;\n            par[0][v] = u;\n            dfs(v, u);\n        }\n    }\n}\n\nvoid phongthan() {\n    cin >> n >> k;\n    FOR(i, 0, n - 1) {\n        int u, v; cin >> u >> v; u--, v--;\n        adj[u].pb(v), adj[v].pb(u);\n    }\n    static int f[maxn];\n    FOR(i, 0, logn) par[i][n - 1] = n - 1;\n    dfs(n - 1, -1);\n    f[n - 1] = 1;\n    int st = n - 2, tot = 1;\n    FOR(it, 0, n - k - 1) {\n        while (1) {\n            if (f[st]) {\n                st--;\n                break;\n            }\n            int u = st;\n            FORd(i, logn, 0) {\n                int nu = par[i][u];\n                if (!f[nu]) {\n                    u = nu;\n                }\n            }\n            if (tot + lev[st] - lev[u] + 1 <= n - k) {\n                int u = st;\n                while (!f[u]) {\n                    f[u] = 1;\n                    tot++;\n                    u = par[0][u];\n                }\n                st--;\n                break;\n            }\n            else {\n                st--;\n            }\n        }\n    }\n    vi res;\n    FOR(i, 0, n) if (!f[i]) res.pb(i);\n    FOR(i, 0, sz(res)) cout << res[i] + 1 << \" \\n\"[i == sz(res) - 1];\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    phongthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n} \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The Number Games.json",
    "editorial_link": "https://codeforces.com//blog/entry/59350",
    "editorial": "As the final set of remaining districts need to be reachable from each\r\nother, this means that the resulting tree is a sub-graph of the original\r\none.Now, looking at the number of fans in each district, district has\r\nfans. This means that if we had a choice of including a district in our\r\nsolution and discarding all the districts with indices less than then\r\nitâd be better than discarding district and including all the others, as\r\n.This leads us to the following greedy solution:Letâs try to find which\r\ndistricts to keep instead of which to discard, letâs first root the tree\r\nat district , as we can always keep it, and go through the remaining\r\ndistricts by the order of decreasing index. Now at each step, if we can\r\ninclude district into our solution by taking it and all of the nodes on\r\nthe path connecting it to our current sub-graph, then we should surely\r\ndo so, otherwise we can just ignore it and move on to the next\r\ndistrict.This can be implemented by building a parent sparse-table and\r\nusing Binary Lifting at each district to find the first of its ancestors\r\nthat has been already included in our sub-graph. The distance to this\r\nancestor represents the number of districts that need to be included in\r\nthe games to have district included. So if we can still include that\r\nmany districts in our sub-graph then we will traverse through the path\r\nand mark them as included.Solution Complexity:\r\n",
    "hint": []
}