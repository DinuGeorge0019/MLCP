{
    "link": "https://codeforces.com//contest/1139/problem/D",
    "problemId": "317129",
    "problem_idx": "D",
    "shortId": "1139D",
    "contest_number": "1139",
    "problem_submissions": {
        "F": [
            51641186,
            51646762,
            109435140,
            51647787,
            51858420,
            51784923,
            51643584,
            51652352
        ],
        "E": [
            51636168,
            51644116,
            51640560,
            51642622,
            51644323,
            51644757,
            51643892,
            51845610,
            51647025,
            51647374,
            51647485,
            51647776,
            51635005,
            51638235,
            51639153,
            51639250,
            51638517,
            72001197,
            51662877
        ],
        "D": [
            51642032,
            51635420,
            51636603,
            51637368,
            51636440,
            51639381,
            51643782,
            51845601,
            51642527,
            51640197,
            51643918,
            51642858,
            51827413,
            51649480,
            51908875,
            51638589,
            51637429
        ],
        "C": [
            51630148,
            51629252,
            51628342,
            51628293,
            51633819,
            51633228,
            51629514,
            51845597,
            51631001,
            51631632,
            51635078,
            51636507,
            51631091,
            51631860,
            51631510,
            51630390,
            51632287,
            51636060,
            51629126,
            51630229
        ],
        "B": [
            51627583,
            51626711,
            51625352,
            51626461,
            51626658,
            51627929,
            51626015,
            51845593,
            51628451,
            51628233,
            51627332,
            51628138,
            51627935,
            51626813,
            51626814,
            51626137,
            51629187,
            51627498,
            51626295,
            51627320
        ],
        "A": [
            51623887,
            51624025,
            51623702,
            51623814,
            51624826,
            51624571,
            51623799,
            51845581,
            51625089,
            51624357,
            51625210,
            51626607,
            51624278,
            51623873,
            51625020,
            51624141,
            51624276,
            51623680,
            51624248,
            51623966
        ]
    },
    "name": "D. Steps to One",
    "statement": "Vivek initially has an empty array a and some integer constant m.He\r\nperforms the following algorithm: Select a random integer x uniformly in\r\nrange from 1 to m and append it to the end of a. Compute the greatest\r\ncommon divisor of integers in a. In case it equals to 1, break\r\nOtherwise, return to step 1. Find the expected length of a. It can be\r\nshown that it can be represented as\r\nfrac{P}{Q} where P and Q are coprime integers and Q\r\nneq 0\r\npmod{10^9+7}. Print the value of P\r\ncdot Q^{-1}\r\npmod{10^9+7}.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long llong;\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\n\nint pw(int x, int p) {\n    int r = 1;\n    while (p) {\n        if (p & 1) r = (llong)r * x % mod;\n        x = (llong)x * x % mod;\n        p >>= 1;\n    }\n    return r;\n}\n\nint popcount(int x) {\n    int ret = 0;\n    while (x) {\n        ret += x & 1;\n        x >>= 1;\n    }\n    return ret;\n}\n\nint m;\nint dp[100001];\nvector<int> di[100001];\nvector<pii> pr[100001];\nint prs[100001];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> m;\n    if (m == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n    for (int i = 1; i <= m; ++i) {\n        for (int j = i; j <= m; j += i) di[j].push_back(i);\n        if (di[i].size() == 2) {\n            for (int j = i; j <= m; j += i) {\n                int k = j;\n                pr[j].emplace_back(i, 0);\n                while (k % i == 0) ++pr[j].back().second, k /= i;\n            }\n        }\n    }\n    dp[1] = 1;\n    for (int i = 2; i <= m; ++i) {\n        int ci, rhs = m;\n        for (int j : di[i]) {\n            for (pii k : pr[j]) prs[k.first] = k.second;\n            vector<int> ps;\n            int rm = m;\n            for (pii k : pr[i]) {\n                for (int l = prs[k.first]; l--; ) rm /= k.first;\n                if (prs[k.first] < k.second) ps.push_back(k.first);\n            }\n            for (pii k : pr[j]) prs[k.first] = 0;\n            int sum = 0;\n            for (int k = 0; k < (1 << ps.size()); ++k) {\n                int sign = popcount(k) & 1;\n                sign = 1 - sign - sign;\n                int nm = rm;\n                for (int l = 0; l < ps.size(); ++l) if ((k >> l) & 1) nm /= ps[l];\n                sum += sign * nm;\n            }\n            if (j == i) ci = m - sum;\n            else rhs += (llong)sum * dp[j] % mod, rhs %= mod;\n        }\n        dp[i] = (llong)rhs * pw(ci, mod - 2) % mod;\n    }\n    int ans = 0;\n    for (int i = 1; i <= m; ++i) ans += dp[i], ans %= mod;\n    ans = (llong)ans * pw(m, mod - 2) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "number theory",
        "probabilities"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Steps to One.json",
    "editorial_link": "https://codeforces.com//blog/entry/66101",
    "editorial": "Let be the expected number of additional steps to get a gcd of 1 if the\r\ngcd of the current array is .Suppose the current gcd of the array is ,\r\nafter the next iteration of the algorithm, we would append some randomly\r\nchosen with a probability , and move to state and since the length\r\nincreases by on appending, we will make steps for this .So the\r\nrecurrence is : I recommend this Expectation tutorial to get more\r\nunderstanding of the basics.We can group together all terms having the\r\nsame , move terms having to the left side of the equation and use that\r\nto calculate .This is an solution.Here we notice that is a factor of ,So\r\nthe recurrence could be modified as : where is the count of integers ,\r\nsuch that Lets express , and where , are positive integers,So we want to\r\nfind the number of âs where , , such that , i.e. we want to find number\r\nof where such that .Lets find factorization of , so must not be\r\ndivisible by any of the prime factors of .We can find number of such\r\nthat it isnât divisible by some set of primes by inclusion\r\nexclusion.Since there are at most primes, we have complexity: For an\r\nalternate solution using mobius function, refer code 2.\r\n",
    "hint": []
}