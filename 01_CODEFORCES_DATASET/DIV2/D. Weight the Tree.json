{
    "link": "https://codeforces.com//contest/1646/problem/D",
    "problemId": "1316355",
    "problem_idx": "D",
    "shortId": "1646D",
    "contest_number": "1646",
    "problem_submissions": {
        "F": [
            148377331,
            148376552,
            148380191,
            148408003,
            148407985,
            148407958,
            148625107,
            148397512,
            148614447,
            148385636
        ],
        "E": [
            148347130,
            148358632,
            148360488,
            148333996,
            148354021,
            148353992,
            148359437,
            148353904,
            148361106,
            148406239,
            148363543,
            148355954,
            148360552,
            148359820,
            148358320,
            148361452,
            148368263,
            148351309,
            148353801,
            148370230,
            148352778
        ],
        "D": [
            148336483,
            148341281,
            148366316,
            148319892,
            148345041,
            148346482,
            148342901,
            148349102,
            148343090,
            148339630,
            148343423,
            148345651,
            148350280,
            148350345,
            148349930,
            148341422,
            148364204,
            148362633,
            148344691,
            148349044
        ],
        "C": [
            148310953,
            148326110,
            148330270,
            148306601,
            148323665,
            148325840,
            148321586,
            148311486,
            148322407,
            148317336,
            148321327,
            148327478,
            148321394,
            148325846,
            148315684,
            148317105,
            148328227,
            148404981,
            148319824,
            148313542,
            148332408
        ],
        "B": [
            148304866,
            148306819,
            148315665,
            148302178,
            148310613,
            148314947,
            148310473,
            148304347,
            148306865,
            148309180,
            148307122,
            148311855,
            148309145,
            148315243,
            148304621,
            148305987,
            148317489,
            148404248,
            148306430,
            148304810,
            148327258
        ],
        "A": [
            148300689,
            148300631,
            148308492,
            148300540,
            148301834,
            148303727,
            148301684,
            148300721,
            148300698,
            148302427,
            148311861,
            148301382,
            148301011,
            148301721,
            148300651,
            148301177,
            148301822,
            148404175,
            148300747,
            148300552,
            148302531
        ]
    },
    "name": "D. Weight the Tree",
    "statement": "You are given a tree of n vertices numbered from 1 to n. A tree is a\r\nconnected undirected graph without cycles. For each i=1,2,\r\nldots, n, let w_i be the weight of the i-th vertex. A vertex is called\r\nif its weight is equal to the sum of the weights of all its\r\nneighbors.Initially, the weights of all nodes are unassigned. Assign\r\npositive integer weights to each vertex of the tree, such that the\r\nnumber of good vertices in the tree is maximized. If there are multiple\r\nways to do it, you have to find one that minimizes the sum of weights of\r\nall vertices in the tree.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int n;\n    cin >> n;\n    if (n == 2) {\n        cout << \"2 2\\n1 1\";\n        return 0;\n    }\n    vector<vector<int>> G(n + 1);\n    for (int i = 1, u, v; i < n; i += 1) {\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    vector<pair<int, int>> f(n + 1), g(n + 1);\n    function<void(int, int)> DFS = [&](int u, int p) {\n        for (int v : G[u])\n            if (v != p) {\n                DFS(v, u);\n                auto pr = min(f[v], g[v]);\n                g[u].first += pr.first;\n                g[u].second += pr.second;\n                f[u].first += g[v].first;\n                f[u].second += g[v].second;\n            }\n        f[u].first -= 1;\n        f[u].second += G[u].size() - 1;\n    };\n    DFS(1, 0);\n    auto pr = min(f[1], g[1]);\n    cout << -pr.first << \" \" << pr.second + n << \"\\n\";\n    vector<int> ans(n + 1, 1);\n    function<void(int, int, int)> DFS2 = [&](int u, int p, int cf) {\n        if (cf) ans[u] = G[u].size();\n        for (int v : G[u])\n            if (v != p) {\n                if (cf) DFS2(v, u, 0);\n                else DFS2(v, u, f[v] < g[v]);\n            }\n        f[u].first -= 1;\n        f[u].second += G[u].size() - 1;\n    };\n    DFS2(1, 0, f[1] < g[1]);\n    for (int i = 1; i <= n; i += 1) cout << ans[i] << \" \";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "implementation",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Weight the Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/100584",
    "editorial": "If , we can assign and and there is no way to get a better answer\r\nbecause all vertices are good and the sum of weights cannot be smaller\r\nbecause the weights have to be positive.If , two vertices sharing an\r\nedge cannot be both good. To prove this, we are going to analyze two\r\ncases. If the two vertices have distinct weights, then the one with a\r\nsmaller weight cannot be good, because the one with a larger weight is\r\nits neighbor. Otherwise, if both vertices have the same weight, then\r\nnone of them can have another neighbor, as that would increase the sum\r\nof their neighbors by at least . So, the only way this could happen is\r\nif , but we are assuming that .Thus, the set of good vertices must be an\r\nindependent set. We will see that for each independent set of vertices\r\nin the tree, there is an assignment of weights where all the vertices\r\nfrom this set are good. We can assign a weight of to each vertex that is\r\nnot in the set, and assign its degree to each vertex in the set. Because\r\nall neighbors of a vertex in the set are not in the set, then all of\r\nthem have a weight of and this vertex is good.Therefore, the maximum\r\nnumber of good vertices is the same as the maximum size of an\r\nindependent set in this tree. For a fixed independent set of the maximum\r\nsize, the construction above leads to a configuration with the minimum\r\nsum of weights. This is because all vertices must have a weight of at\r\nleast , and the vertices in the set must have a weight of at least its\r\ndegree.So, to solve the problem it is enough to root the tree in an\r\narbitrary vertex and solve a tree dp. Let\u00e2\u0080\u0099s call to the pair , where is\r\nthe maximum number of good vertices in the subtree of vertex assuming\r\nthat is good (if ) or that it is not good (if ), and is the minimum sum\r\nof weights for that value .The values of can be computed with a dp,\r\nusing the values of in the children of node . If , then for each child\r\nyou must sum . If , for each child you can choose the best answer\r\nbetween and . The answer to the problem will be the best between and To\r\nconstruct the assignment of weights, you can do it recursively\r\nconsidering for each vertex if it has to be good or not, in order to\r\nkeep the current value of the answer. In case both options (making it\r\ngood or not) work, you have to choose to not make it good, as you do not\r\nknow if its father was good or not.Intended complexity:\r\n"
}