{"link": "https://codeforces.com//contest/879/problem/D", "problemId": "130665", "problem_idx": "D", "shortId": "879D", "contest_number": "879", "problem_submissions": {"B": [31786634, 31744953, 31748945, 31742935, 31751951, 31745920, 31746158, 31746124, 31745152, 31764273, 31744717, 31744550, 31745384, 31763271, 31741598, 31746257, 31743148], "A": [31786593, 31741274, 31744372, 31740794, 31748255, 31750502, 31742905, 31741390, 31742237, 31742563, 31740788, 31746610, 31740545, 31741102, 31761806, 31740453, 31741697, 31740818], "D": [31759010, 31759775, 31758676, 31760218, 31759988, 31764440, 31763303, 31762884, 31765337, 31764418, 31762268, 31761524, 31759749], "C": [31750102, 31754233, 31749363, 31750196, 31754099, 31751776, 31751991, 31753220, 31750527, 31755686, 31753418, 31760006, 31750929, 31761404, 31749686, 31756675, 31751331], "E": [31870640, 31870635, 31869262, 31868808]}, "name": "D. Teams Formation", "statement": "This time the Berland Team Olympiad in Informatics is held in a remote\r\ncity that can only be reached by one small bus. Bus has passenger seats,\r\nseat can be occupied only by a participant from the city .Today the bus\r\nhas completed trips, each time bringing participants. The participants\r\nwere then aligned in one line in the order they arrived, with people\r\nfrom the same bus standing in the order of their seats (i. e. if we\r\nwrite down the cities where the participants came from, we get the\r\nsequence repeated times).After that some teams were formed, each\r\nconsisting of participants form the same city standing next to each\r\nother in the line. Once formed, teams left the line. The teams were\r\nformed until there were no neighboring participants from the same\r\ncity.Help the organizers determine how many participants have left in\r\nthe line after that process ended. We can prove that answer doesn\u2019t\r\ndepend on the order in which teams were selected.\r\n", "solutions": ["#include <algorithm>\n#include <cstdio>\n#include <deque>\n#include <cassert>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FORE(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef long long ll;\n\nint n,k,m;\n\nint main() {\n  scanf(\"%d%d%d\",&n,&k,&m);\n  deque<int> vals;\n  deque<int> cnts;\n  REP(i,n) {\n    int a;\n    scanf(\"%d\",&a);\n    if (vals.empty() || vals.back() != a) {\n      vals.push_back(a);\n      cnts.push_back(1);\n    } else {\n      cnts.back()++;\n      if (cnts.back() == k) {\n        vals.pop_back();\n        cnts.pop_back();\n      }\n    }\n  }\n\n  //FORE(i,vals) printf(\"%d \",*i); printf(\"\\n\");\n\n  if (vals.size() == 1) {\n    ll cnt = ll(cnts.front()) * m;\n    printf(\"%I64d\\n\", cnt % k);\n    return 0;\n  }\n\n  if (m == 1) {\n    ll cnt = 0;\n    FORE(i,cnts) cnt += *i;\n    printf(\"%I64d\\n\", cnt);\n    return 0;\n  }\n\n  deque<int> vals_beg = vals, vals_end = vals;\n  deque<int> cnts_beg = cnts, cnts_end = cnts;\n\n  while (vals.size() >= 2 && vals.front() == vals.back() && cnts.front() + cnts.back() >= k) {\n    if ((cnts.front() + cnts.back()) % k == 0) {\n      vals.pop_back(); cnts.pop_back();\n      vals.pop_front(); cnts.pop_front();\n      vals_beg.pop_back(); cnts_beg.pop_back();\n      vals_end.pop_front(); cnts_end.pop_front();\n    } else {\n      int last = (cnts.front() + cnts.back()) % k;\n      vals.pop_back(); cnts.pop_back();\n      cnts.front() = last;\n      vals_beg.pop_back(); cnts_beg.pop_back();\n      cnts_end.front() = last;\n    }\n  }\n\n#define SHOW() \\\n  REP(i,int(vals_beg.size())) fprintf(stderr, \"%d|%d \",vals_beg[i],cnts_beg[i]); fprintf(stderr,\"\\n\"); \\\n  REP(i,int(vals.size())) fprintf(stderr, \"%d|%d \",vals[i],cnts[i]); fprintf(stderr,\"\\n\"); \\\n  REP(i,int(vals_end.size())) fprintf(stderr, \"%d|%d \",vals_end[i],cnts_end[i]); fprintf(stderr,\"\\n\"); \\\n\n  if (vals.size() == 1) {\n    //fprintf(stderr, \"HERE\\n\");\n    //SHOW();\n    int val = vals.front();\n    ll cnt = ll(cnts.front()) * (m-2);\n    if (vals_beg.back() == val) { cnt += cnts_beg.back(); vals_beg.pop_back(); cnts_beg.pop_back(); }\n    if (vals_end.front() == val) { cnt += cnts_end.front(); vals_end.pop_front(); cnts_end.pop_front(); }\n    cnt %= k;\n\n    if (cnt == 0) {\n      while (!vals_beg.empty() && !vals_end.empty() && vals_beg.back() == vals_end.front()\n          && cnts_beg.back() + cnts_end.front() >= k) {\n        if ((cnts_beg.back() + cnts_end.front()) % k == 0) {\n          vals_beg.pop_back(); cnts_beg.pop_back();\n          vals_end.pop_front(); cnts_end.pop_front();\n        } else {\n          int last = (cnts_beg.back() + cnts_end.front()) % k;\n          vals_beg.pop_back(); cnts_beg.pop_back();\n          cnts_end.front() = last;\n        }\n      }\n    }\n    //SHOW();\n\n    FORE(i,cnts_beg) cnt += *i;\n    FORE(i,cnts_end) cnt += *i;\n    printf(\"%I64d\\n\", cnt);\n    return 0;\n  }\n\n  ll cnt = 0;\n  FORE(i,cnts_beg) cnt += *i;\n  FORE(i,cnts_end) cnt += *i;\n  FORE(i,cnts) cnt += ll(*i) * (m-2);\n  printf(\"%I64d\\n\", cnt);\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2300", "interactive": false}