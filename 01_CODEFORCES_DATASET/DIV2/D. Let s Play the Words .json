{
    "link": "https://codeforces.com//contest/1277/problem/D",
    "problemId": "495584",
    "problem_idx": "D",
    "shortId": "1277D",
    "contest_number": "1277",
    "problem_submissions": {
        "F": [
            66866628,
            66860664,
            66862829,
            66860439,
            66977841,
            66899469,
            66863808,
            92979782,
            92978994,
            92978960,
            92978865,
            66891528,
            66889235,
            66866269,
            67019482
        ],
        "D": [
            66856749,
            66864218,
            66854207,
            66847715,
            66844420,
            66847306,
            66854098,
            66848610,
            66848065,
            66848280,
            66844474,
            66849217,
            66848886,
            66864076,
            66847735
        ],
        "E": [
            66850123,
            66849554,
            66847076,
            66854313,
            66848191,
            66853241,
            66855295,
            66853466,
            66848425,
            66855580,
            66855848,
            66853292,
            66856132,
            92977693,
            66856983,
            66854785,
            125051093,
            66850783,
            66861075
        ],
        "C": [
            66841382,
            66842457,
            66841119,
            66845741,
            66837706,
            66839907,
            66838468,
            66840457,
            66839782,
            66840815,
            66841610,
            66843424,
            66846378,
            66837428,
            66844848,
            66841436,
            66840246,
            66839763
        ],
        "B": [
            66837718,
            66838330,
            66834438,
            66842100,
            66834455,
            66836147,
            66833752,
            66836537,
            66835874,
            66836673,
            66837137,
            66837196,
            66974853,
            66841617,
            66834535,
            66838161,
            66835795,
            66834507,
            66836405
        ],
        "A": [
            66834598,
            66836237,
            66833655,
            66838372,
            66833757,
            66834211,
            66833507,
            66833800,
            66834296,
            66834715,
            66834270,
            66834723,
            66974834,
            66839401,
            66833706,
            66836909,
            66833653,
            66833594,
            66833715
        ]
    },
    "name": "D. Let s Play the Words ",
    "statement": "Polycarp has n binary words. A word called binary if it contains only\r\ncharacters ” and ”. For example, these words are binary: \"\", \"\", \"\" and\r\n\"\".Polycarp wants to offer his set of n binary words to play a game\r\n\"words\". In this game, players name words and each next word (starting\r\nfrom the second) must start with the last character of the previous\r\nword. The first word can be any. For example, these sequence of words\r\ncan be named during the game: \"\", \"\", \"\", \"\", \"\".Word reversal is the\r\noperation of reversing the order of the characters. For example, the\r\nword \"\" after the reversal becomes \"\", the word \"\" after the reversal\r\nbecomes \"\".Probably, Polycarp has such a set of words that there is no\r\nway to put them in the order correspondent to the game rules. In this\r\nsituation, he wants to reverse some words from his set so that: the\r\nfinal set of n words still contains words (i.e. all words are unique);\r\nthere is a way to put all words of the final set of words in the order\r\nso that the final sequence of n words is consistent with the game rules.\r\nPolycarp wants to reverse minimal number of words. Please, help him.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  int t;cin>>t;\n  rep(t_, t){\n    int n;cin>>n;\n    vector<int> n01,n00,n10,n11;\n    vector<string> s01,s10;\n    reps(i,n){\n      string s;\n      cin>>s;\n      if(s[0] == '0'){\n        if(s[s.size()-1] == '0'){\n          n00.push_back(i);\n        }else{\n          n01.push_back(i);\n          s01.push_back(s);\n        }\n      }else{\n        if(s[s.size()-1] == '0'){\n          n10.push_back(i);\n          s10.push_back(s);\n        }else{\n          n11.push_back(i);\n        }\n      }\n    }\n    if(n01.size() == 0 && n10.size() == 0 && n00.size() > 0 && n11.size() > 0){\n      cout<<-1<<endl;\n      continue;\n    }\n    if(n01.size() > n10.size()){\n      vector<int> tmp = n01;\n      n01 = n10;\n      n10 = tmp;\n      vector<string> tmps = s01;\n      s01 = s10;\n      s10 = tmps;\n    }\n    set<string> used;\n    rep(i, n01.size()){\n      reverse(all(s01[i]));\n      used.insert(s01[i]);\n    }\n    cout<<(n10.size() - n01.size())/2<<endl;\n    int count = 0;\n    int i = 0;\n    while(count < (n10.size() - n01.size())/2){\n      if(used.count(s10[i]) > 0){\n        i++;\n        continue;\n      }\n      cout<<n10[i]<<\" \";\n      count++;\n      i++;\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "hashing",
        "implementation",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Let s Play the Words .json",
    "editorial_link": "https://codeforces.com//blog/entry/72239",
    "editorial": "For a concrete set of words, it's not hard to find a criteria for checking if there is a correct order of arrangement of words for playing a game. Let's call such sets of words correct. Firstly the set of words is correct if the number of words like 0...1 and the number of words like 1...0 differ by no more than 1\n. Secondly it's correct if the number of words like 0...0 or like 1...1 is zero, because they have the same characters at the beginning and at the ending, and we can insert them in any position. And finally if words of both kinds 0...0 and 1...1 are present and there is at least one word like 0...1 or 1...0.\n\nIt can be easily proved if we note that this problem is equivalent to the Euler traversal of a directed graph with two nodes. But let's prove it without resorting to graph theory:\n\nif there are words of both kinds 0...0 and 1...1, but there is no words of kinds 0...1 and 1...0, starting from a word of one kind you can't go to a word of another kind. Consequently, if words of both kinds 0...0 and 1...1 are present, there should be at least one word like 0...1 or 1...0  is a necessary condition of the problem;\nif the number of words like 0...1 and the number of words like 1...0 differ by no more than 1\n, we can call them alternately starting with a kind that is larger. If these numbers are equal, we can start with any kind. And we can insert words of kind 0...0 and 1...1 at any suitable moment.\nReversals only affect the mutual number of lines of the kind 0...1 and 1...0. Therefore, immediately while reading the input data, we can check the necessary condition (first item above).\n\nWithout loss of generality we may assume that the number of words like 0...1 equals n01\n and like 1...0 equals n10\n. Also we assume that n01>n10+1\n. Remember that all words in the current set are unique. Let's prove that we can always choose some words of kind 0...1 and reverse them so that n01=n10+1\n (and at the result all words would still be unique).\n\nIn fact, the set of words of kind n10\n has no more than n10\n such words that after the reversing, the word will turn into an existing one (because it will become of type 1...0 and there are only n10\n such words). And it means that there is no less than n01?n10\n words which we can reverse and get still unique word. So, we can choose any n01?n10?1\n of them.\n\nThus, after checking of the necessary condition (first item above), we need to reverse just n01?n10?1\n words of kind that is larger, which reversals aren't duplicates.",
    "hint": []
}