{"link": "https://codeforces.com//contest/1277/problem/D", "problemId": "495584", "problem_idx": "D", "shortId": "1277D", "contest_number": "1277", "problem_submissions": {"F": [66866628, 66860664, 66862829, 66860439, 66977841, 66899469, 66863808, 92979782, 92978994, 92978960, 92978865, 66891528, 66889235, 66866269, 67019482], "D": [66856749, 66864218, 66854207, 66847715, 66844420, 66847306, 66854098, 66848610, 66848065, 66848280, 66844474, 66849217, 66848886, 66864076, 66847735], "E": [66850123, 66849554, 66847076, 66854313, 66848191, 66853241, 66855295, 66853466, 66848425, 66855580, 66855848, 66853292, 66856132, 92977693, 66856983, 66854785, 125051093, 66850783, 66861075], "C": [66841382, 66842457, 66841119, 66845741, 66837706, 66839907, 66838468, 66840457, 66839782, 66840815, 66841610, 66843424, 66846378, 66837428, 66844848, 66841436, 66840246, 66839763], "B": [66837718, 66838330, 66834438, 66842100, 66834455, 66836147, 66833752, 66836537, 66835874, 66836673, 66837137, 66837196, 66974853, 66841617, 66834535, 66838161, 66835795, 66834507, 66836405], "A": [66834598, 66836237, 66833655, 66838372, 66833757, 66834211, 66833507, 66833800, 66834296, 66834715, 66834270, 66834723, 66974834, 66839401, 66833706, 66836909, 66833653, 66833594, 66833715]}, "name": "D. Let s Play the Words ", "statement": "Polycarp has n binary words. A word called binary if it contains only\r\ncharacters \u201d and \u201d. For example, these words are binary: \"\", \"\", \"\" and\r\n\"\".Polycarp wants to offer his set of n binary words to play a game\r\n\"words\". In this game, players name words and each next word (starting\r\nfrom the second) must start with the last character of the previous\r\nword. The first word can be any. For example, these sequence of words\r\ncan be named during the game: \"\", \"\", \"\", \"\", \"\".Word reversal is the\r\noperation of reversing the order of the characters. For example, the\r\nword \"\" after the reversal becomes \"\", the word \"\" after the reversal\r\nbecomes \"\".Probably, Polycarp has such a set of words that there is no\r\nway to put them in the order correspondent to the game rules. In this\r\nsituation, he wants to reverse some words from his set so that: the\r\nfinal set of n words still contains words (i.e. all words are unique);\r\nthere is a way to put all words of the final set of words in the order\r\nso that the final sequence of n words is consistent with the game rules.\r\nPolycarp wants to reverse minimal number of words. Please, help him.\r\n", "solutions": ["#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0\u500b\u306e\u4e38\u3068-1\u500b\u306e\u68d2\u307f\u305f\u3044\u306a\u6642\u306b\u6642\u306b\u52b9\u304f\uff1f\u4e0d\u5b89.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  int t;cin>>t;\n  rep(t_, t){\n    int n;cin>>n;\n    vector<int> n01,n00,n10,n11;\n    vector<string> s01,s10;\n    reps(i,n){\n      string s;\n      cin>>s;\n      if(s[0] == '0'){\n        if(s[s.size()-1] == '0'){\n          n00.push_back(i);\n        }else{\n          n01.push_back(i);\n          s01.push_back(s);\n        }\n      }else{\n        if(s[s.size()-1] == '0'){\n          n10.push_back(i);\n          s10.push_back(s);\n        }else{\n          n11.push_back(i);\n        }\n      }\n    }\n    if(n01.size() == 0 && n10.size() == 0 && n00.size() > 0 && n11.size() > 0){\n      cout<<-1<<endl;\n      continue;\n    }\n    if(n01.size() > n10.size()){\n      vector<int> tmp = n01;\n      n01 = n10;\n      n10 = tmp;\n      vector<string> tmps = s01;\n      s01 = s10;\n      s10 = tmps;\n    }\n    set<string> used;\n    rep(i, n01.size()){\n      reverse(all(s01[i]));\n      used.insert(s01[i]);\n    }\n    cout<<(n10.size() - n01.size())/2<<endl;\n    int count = 0;\n    int i = 0;\n    while(count < (n10.size() - n01.size())/2){\n      if(used.count(s10[i]) > 0){\n        i++;\n        continue;\n      }\n      cout<<n10[i]<<\" \";\n      count++;\n      i++;\n    }\n    cout<<endl;\n\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "hashing", "implementation", "math"], "dificulty": "1900", "interactive": false}