{
    "link": "https://codeforces.com//contest/1369/problem/E",
    "problemId": "651259",
    "problem_idx": "E",
    "shortId": "1369E",
    "contest_number": "1369",
    "problem_submissions": {
        "F": [
            84805615,
            84815422,
            84821788,
            84848209,
            84808586,
            84845078,
            84819664,
            84809525
        ],
        "E": [
            84783653,
            84794541,
            84777094,
            84792178,
            84796407,
            84799473,
            84847985,
            84794191,
            84802657,
            84799608,
            84843231,
            84798901,
            84802992,
            84803891,
            84799522,
            84803293,
            84803734,
            84801605
        ],
        "D": [
            84774757,
            84783341,
            84767385,
            84777566,
            84781335,
            84780403,
            84783178,
            84780507,
            84786495,
            84784013,
            84784219,
            84785925,
            84784946,
            84790889,
            84787139,
            84785887,
            84796956,
            84790843
        ],
        "C": [
            84764211,
            84776491,
            85764231,
            85764174,
            84784880,
            84769031,
            84773069,
            84769214,
            84772926,
            84766954,
            84773427,
            84767072,
            84773264,
            84775000,
            84772759,
            84772359,
            84919485,
            84776351,
            84771759,
            84772941,
            84776880
        ],
        "B": [
            84758680,
            84760470,
            84777367,
            84762433,
            84762003,
            84761770,
            84766923,
            84760439,
            84763340,
            84761080,
            84766453,
            84765969,
            84767231,
            84765006,
            84759974,
            84762031,
            84767553,
            84769489
        ],
        "A": [
            84750967,
            84766185,
            84750778,
            84752543,
            84752490,
            84752217,
            84767956,
            84750544,
            84755659,
            84751856,
            84756195,
            84753655,
            84751015,
            84749918,
            84749358,
            84749254,
            84751162,
            84756777
        ]
    },
    "name": "E. DeadLee",
    "statement": "There are n different types of food and m Lee\u2019s best friends. Lee has\r\nw_i plates of the i-th type of food and each friend has two different\r\nfavorite types of food: the i-th friend\u2019s favorite types of food are x_i\r\nand y_i (x_i\r\nne y_i).Lee will start calling his friends one by one. Whoever is called\r\nwill go to the kitchen and will try to eat . Each of the friends will go\r\nto the kitchen exactly once.The only problem is the following: if a\r\nfriend will eat at least one plate of food (in total) then he will be\r\nharmless. But if there is nothing left for him to eat (neither x_i nor\r\ny_i), he will eat Lee instead\r\ntimes\r\n_\r\ntimes.Lee can choose the order of friends to call, so he\u2019d like to\r\ndetermine if he can survive dinner or not. Also, he\u2019d like to know the\r\norder itself.\r\n",
    "solutions": [
        "// You may love a girl deeply\n// but you can't express in it more than 7-8 inches...\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(ass) ass.begin(), ass.end()\nusing namespace std;\n\ntypedef long long ll;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007;\nconst ll N = 2e5 + 85;\nconst ll Inf = 1e18;\nconst ll Log = 69;\n\nvector<ll> G[N];\nll deg[N];\nvector<ll> V, A;\nll mk[N], w[N], u[N], v[N];\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll n, m;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> w[i];\n\t}\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> u[i] >> v[i];\n\t\tG[u[i]].pb(i);\n\t\tG[v[i]].pb(i);\n\t\tdeg[u[i]] ++;\n\t\tdeg[v[i]] ++;\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tif(deg[i] <= w[i]){\n\t\t\tfor(auto x : G[i]){\n\t\t\t\tif(!mk[x]){\n\t\t\t\t\tmk[x] = 1;\n\t\t\t\t\tV.pb(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint p = 0;\n\twhile(p < V.size()){\n\t\tA.pb(V[p]);\n\t\tint fd = u[V[p]];\n\t\tdeg[fd] --;\n\t\tif(deg[fd] == w[fd]){\n\t\t\tfor(auto x : G[fd]){\n\t\t\t\tif(!mk[x]){\n\t\t\t\t\tmk[x] = 1;\n\t\t\t\t\tV.pb(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfd = v[V[p]];\n\t\tdeg[fd] --;\n\t\tif(deg[fd] == w[fd]){\n\t\t\tfor(auto x : G[fd]){\n\t\t\t\tif(!mk[x]){\n\t\t\t\t\tmk[x] = 1;\n\t\t\t\t\tV.pb(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp ++;\n\t}\n\tif(V.size() != m){\n\t\tcout << \"DEAD\\n\";\n\t\treturn 0;\n\t}\n\treverse(all(A));\n\tcout << \"ALIVE\\n\";\n\tfor(auto x : A) cout << x << ' ';\n\tcout << '\\n';\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. DeadLee.json",
    "editorial_link": "https://codeforces.com//blog/entry/79235",
    "editorial": ":Define equal to the number of friends who likes food . We want to proof\r\nthat if then no answer exist, it can be proved easily by contradiction,\r\njust look at the last friend in any suitable permutation, he will eat\r\nLee as there is no food for him.So if it was the case, then print and\r\nterminate, otherwise place all the guys who likes food in the end of the\r\npermutation, they wont eat Lee as they can always eat food , also it\u00e2\u0080\u0099s\r\nalways better to place them in the end, as if we place them in the end,\r\nthen they wont eat two plates. Continue the process until no friends\r\nexist or no exist such that .Note that when we erase the friends, we\r\nhave to update , also if we should erase food from the set of foods.\r\n:Instead of erasing friends/foods, just remember if a friend/food is\r\nerased or not using another array. Also updating should not be that much\r\nhard(when marking -th friend, decrease and by one, if there exist any),\r\nalso you can have the food with maximum with a priority queue, or any\r\nother data structure in .The whole solution will work in time, you can\r\nalso try achieving and then show-off it in the comment section ^_^.\r\n"
}