{
    "link": "https://codeforces.com//contest/814/problem/A",
    "problemId": "108813",
    "problem_idx": "A",
    "shortId": "814A",
    "contest_number": "814",
    "problem_submissions": {
        "D": [
            27647493,
            27672108,
            27640106,
            27643923,
            27641961,
            27641720,
            27642103,
            27641350,
            27644262,
            27643542,
            27643790,
            27645753,
            27644413,
            27642630,
            27644185,
            27644064,
            27644363,
            27643194,
            27644293,
            27646026
        ],
        "C": [
            27645217,
            27635551,
            27636661,
            27634217,
            27636436,
            27636571,
            27637453,
            27638720,
            27637173,
            27637214,
            27639563,
            27637118,
            27638741,
            27639783,
            27640321,
            27639165,
            27639941,
            27659642,
            27639358,
            27640727,
            27637633
        ],
        "A": [
            27642326,
            27632216,
            27632277,
            27632196,
            27632419,
            27632275,
            27632342,
            27633234,
            27632333,
            27632408,
            27632471,
            27632235,
            27632967,
            27632675,
            27632317,
            27633643,
            27632625,
            27632707,
            27632622,
            27632717
        ],
        "E": [
            27641600,
            27647168,
            27666856,
            27661378,
            27652552,
            27730170,
            27729667,
            27669973,
            27692659
        ],
        "B": [
            27634262,
            27635046,
            27632554,
            27634627,
            27634088,
            27635201,
            27635429,
            27634469,
            27634865,
            27635554,
            27634700,
            27635414,
            27636492,
            27635586,
            27636132,
            27636741,
            27636455,
            27636685,
            27634894
        ]
    },
    "name": "A. An abandoned sentiment from past",
    "statement": "A few years ago, Hitagi encountered a giant crab, who stole the whole of\r\nher body weight. Ever since, she tried to avoid contact with others, for\r\nfear that this secret might be noticed.To get rid of the oddity and\r\nrecover her weight, a special integer sequence is needed. Hitagi’s\r\nsequence has been broken for a long time, but now Kaiki provides an\r\nopportunity.Hitagi’s sequence has a length of . Lost elements in it are\r\ndenoted by zeros. Kaiki provides another sequence , whose length equals\r\nthe number of lost elements in (i.e. the number of zeros). Hitagi is to\r\nreplace each zero in with an element from so that . Hitagi knows,\r\nhowever, that, If the resulting sequence is an increasing sequence, then\r\nit has the power to recover Hitagi from the oddity. You are to determine\r\nwhether this is possible, or Kaiki’s sequence is just another fake. In\r\nother words, you should detect whether it is possible to replace each\r\nzero in with an integer from so that each integer from is used exactly\r\nonce, and the resulting sequence is increasing.\r\n",
    "solutions": [
        "/*\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nint n, k;\n\nint a[maxn];\n\nint pos;\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(\"a.in\");\n    ofstream cout(\"a.out\");\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n >> k;\n    if (k > 1){\n        cout << \"Yes\";\n        return 0;\n    }\n    for (int i = 0; i < n; i++){\n        cin >> a[i];\n        if (a[i] == 0)\n            pos = i;\n        if (i > 0 && a[i] < a[i - 1] && a[i] != 0){\n            cout << \"Yes\";\n            return 0;\n        }\n    }\n    int x;\n    cin >> x;\n    if ((pos == 0 || a[pos - 1] < x) && (pos == n - 1 || a[pos + 1] > x))\n        cout << \"No\";\n    else\n        cout << \"Yes\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. An abandoned sentiment from past.json",
    "editorial_link": "https://codeforces.com//blog/entry/52449",
    "editorial": "The statement laid emphasis on the constraint that the elements are\r\npairwise distinct. How is this important?In fact, this implies that if\r\nthe resulting sequence is increasing, then swapping any two of its\r\nelements will result in another sequence which is not increasing.And\r\nweâre able to perform a swap on any resulting sequence if and only if .\r\nThus if , the answer would always be \"Yes\". For cases where , we replace\r\nthe only zero in sequence with the only element in , and check the whole\r\nsequence. Hackable solutions include those only checking the replaced\r\nelement and its neighbours, and those missing the replaced element.\r\nFigure out why solution 2 is not hackable.\r\n",
    "hint": []
}