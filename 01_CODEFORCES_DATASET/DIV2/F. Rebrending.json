{
    "link": "https://codeforces.com//contest/1793/problem/F",
    "problemId": "1779692",
    "problem_idx": "F",
    "shortId": "1793F",
    "contest_number": "1793",
    "problem_submissions": {
        "E": [
            193303068,
            193410509,
            193318182,
            193317664,
            193321898,
            193321819,
            195118865,
            193320360,
            193323873,
            193322184,
            193312387,
            193317745,
            193328336,
            193326548,
            193325450,
            193417270,
            193326710,
            193328225,
            193330842,
            193347782,
            193325695,
            193407475
        ],
        "F": [
            193294668,
            193432445,
            193283485,
            193302193,
            193292394,
            193301208,
            193303400,
            193301778,
            193305649,
            193314414,
            193303519,
            193297557,
            193311968,
            193311201,
            193435668,
            193417130,
            193298340,
            193305239,
            193316596,
            193292430,
            193291733,
            193298678,
            193285006
        ],
        "D": [
            193289297,
            193410468,
            193298851,
            193295249,
            193301162,
            193294370,
            195118553,
            193297347,
            193290499,
            193299884,
            193294597,
            193310876,
            193307621,
            193292591,
            193294931,
            193417683,
            193309769,
            193297566,
            193311269,
            193290315,
            193298522,
            193315173,
            193303157
        ],
        "C": [
            193282896,
            193410484,
            193410436,
            193291983,
            193285787,
            193287901,
            193282042,
            195118522,
            193288500,
            193283243,
            193287291,
            193286808,
            193292453,
            193283068,
            193285096,
            193286514,
            193417697,
            193294800,
            193285233,
            193294514,
            193283977,
            193285615,
            193312185,
            193282557
        ],
        "B": [
            193281488,
            193410417,
            193303429,
            193282163,
            193284281,
            193285830,
            195118463,
            193284739,
            193293047,
            193283557,
            193283997,
            193294754,
            193288469,
            193298342,
            193284337,
            193417706,
            193311244,
            193287539,
            193288050,
            193280259,
            193283801,
            193322565,
            193294257
        ],
        "A": [
            193280157,
            193410319,
            193280181,
            193280331,
            193281160,
            193280045,
            195118430,
            193280519,
            193280318,
            193279986,
            193280684,
            193280733,
            193280459,
            193280266,
            193280563,
            193417721,
            193281601,
            193308502,
            193281932,
            193295057,
            193280019,
            193319646,
            193290909
        ]
    },
    "name": "F. Rebrending",
    "statement": "Kostya and Zhenya the creators of the band \"Paper\" after the release of\r\nthe legendary album decided to create a new band \"Day movers\", for this\r\nthey need to find two new people.They invited n people to the casting.\r\nThe casting will last q days. On the ith of the days, Kostya and Zhenya\r\nwant to find two people on the segment from l_i to r_i who are most\r\nsuitable for their band. Since \"Day movers\" are doing a modern art,\r\nmusical skills are not important to them and they look only at other\r\nsigns: they want the height difference between two people to be as small\r\nas possible.Help them, and for each day, find the minimum difference in\r\nthe growth of people from the casting on this segment!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\n#define ll long long\n#define ull unsigned long long\n#define fi first\n#define se second\n#define mkp make_pair\n#define pb push_back\n#define gc getchar\n#define pc putchar\n#define pii pair<int,int>\n#define pil pair<int,long long>\n#define pli pair<long long,int>\n#define pll pair<long long,long long>\n#define For(i,l,r) for(int i=(l);i<=(r);i++)\n#define IFor(i,r,l) for(int i=(r);i>=(l);i--)\n#define for_son(u) for(int e=head[u];e;e=nxt[e])\n#define eps (1e-8)\n#define INF 0x3f3f3f3f\n#define N 1000010\n//#define m\n#define all 0x3f3f3f3f\n#define mid ((l+r)>>1)\n#define lowbit(x) (x&(-x))\n\nnamespace IO\n{\n//    const int SIZ=1<<20;\n//    char ibuf[SIZ],*p1,*p2,obuf[SIZ],*p3=obuf;\n//  #define gc() (p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,SIZ,stdin),p1==p2)?EOF:*p1++)\n//  void pc(const char &c)\n//  {\n//      if(p3-obuf==SIZ) fwrite(obuf,1,SIZ,stdout),p3=obuf;\n//      *p3++=c;\n//  }\n\tint rd()\n\t{\n\t\tint x=0,f=1;\n\t\tchar ch=gc();\n\t\twhile(!isdigit(ch)) {\n\t\t\tif(ch=='-') f=-1;\n\t\t\tch=gc();\n\t\t}\n\t\twhile(isdigit(ch)) {\n\t\t\tx=x*10+ch-'0';\n\t\t\tch=gc();\n\t\t}\n\t\treturn x*f;\n\t}\n\tvoid wr(int x,char ch)\n\t{\n\t\tif(x<0) x=-x,pc('-');\n\t\tstatic char st[12];\n\t\tint top=0;\n\t\tdo {\n\t\t\tst[top++]=x%10+'0',x/=10;\n\t\t} while(x);\n\t\twhile(top) pc(st[--top]);\n\t\tpc(ch);\n\t}\n\tll ll_rd()\n\t{\n\t\tll x=0;\n\t\tint f=1;\n\t\tchar ch=gc();\n\t\twhile(!isdigit(ch)) {\n\t\t\tif(ch=='-') f=-1;\n\t\t\tch=gc();\n\t\t}\n\t\twhile(isdigit(ch)) {\n\t\t\tx=x*10+ch-'0';\n\t\t\tch=gc();\n\t\t}\n\t\treturn x*f;\n\t}\n\tvoid ll_wr(ll x,char ch)\n\t{\n\t\tif(x<0) x=-x,pc('-');\n\t\tstatic char st[22];\n\t\tint top=0;\n\t\tdo {\n\t\t\tst[top++]=x%10+'0',x/=10;\n\t\t} while(x);\n\t\twhile(top) pc(st[--top]);\n\t\tpc(ch);\n\t}\n}\n\nusing namespace IO;\n\nconst int mod=0;\n\nnamespace tem\n{\n//  void add_edge(int u,int v){nxt[++cnt]=head[u],to[cnt]=v,head[u]=cnt;}\n\tint qpow(int a,int b,int p)\n\t{\n\t\ta%=p;\n\t\tint res=1;\n\t\twhile(b) {\n\t\t\tif(b&1) res=1ll*res*a%p;\n\t\t\ta=1ll*a*a%p;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tint get_inv(int x)\n\t{\n\t\treturn qpow(x,mod-2,mod);\n\t}\n//\tint lowbit(int x){return x&(-x);}\n\tvoid add(int &x,const int y)\n\t{\n\t\tx=(x+y>=mod?x+y-mod:x+y);\n\t}\n//  int get(int x) {return fa[x]==x?x:fa[x]=get(fa[x])};\n\tint gcd(int a,int b)\n\t{\n\t\treturn b?gcd(b,a%b):a;\n\t}\n\tint lcm(int a,int b)\n\t{\n\t\treturn a/gcd(a,b)*b;\n\t}\n}\n\nusing namespace std;\n\ntemplate<typename T> inline void read(T &x)\n{\n\tx=0;\n\tchar c=getchar();\n\tbool flag=false;\n\twhile(!isdigit(c)) {\n\t\tif(c=='-')flag=true;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c)) {\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=getchar();\n\t}\n\tif(flag)x=-x;\n}\n\nint a[N],ans[N],t[N],ls[N<<2],rs[N<<2],mx[N<<2];\nint n,m,tot,root;\n\nvector<pii> ve[N];\nvoid update(int x,int v)\n{\n\twhile(x) t[x]=min(t[x],v),x-=lowbit(x);\n}\nint ask(int x)\n{\n\tint v=all;\n\twhile(x<=n) v=min(v,t[x]),x+=lowbit(x);\n\treturn v;\n}\n\nvoid change(int l,int r,int pos,int v,int &cur)\n{\n\tif(!cur) cur=++tot;\n\tmx[cur]=max(mx[cur],v);\n\tif(l==r) return;\n\tif(pos<=mid) change(l,mid,pos,v,ls[cur]);\n\telse change(mid+1,r,pos,v,rs[cur]);\n}\n\nint ask(int L,int R,int l,int r,int cur)\n{\n\tif(!cur) return 0;\n\tif(L<=l&&R>=r) return mx[cur];\n\tint v=0;\n\tif(L<=mid) v=max(v,ask(L,R,l,mid,ls[cur]));\n\tif(R>mid) v=max(v,ask(L,R,mid+1,r,rs[cur]));\n\treturn v;\n}\nvoid clr()\n{\n\tFor(i,1,n) t[i]=all;\n\tfor(int i=1; i<=tot; ++i) ls[i]=rs[i]=mx[i]=0;\n\ttot=root=0;\n}\nvoid work()\n{\n\tclr();\n\tFor(i,1,n) {\n\t\tint pos=ask(a[i],all,0,all,root);\n\t\twhile(pos) {\n\t\t\tupdate(pos,a[pos]-a[i]);\n\t\t\tpos=ask(a[i],(a[i]+a[pos])/2-(~(a[i]+a[pos])&1),0,all,root);\n\t\t}\n\t\tchange(0,all,a[i],i,root);\n\t\tfor(int j=0; j<(int)ve[i].size(); ++j)\n\t\t\tans[ve[i][j].second]=min(ans[ve[i][j].second],ask(ve[i][j].first));\n\t}\n}\n\nsigned main()\n{\n\tread(n);\n\tread(m);\n\tFor(i,1,n) read(a[i]);\n\tFor(i,1,m) {\n\t\tint l,r;\n\t\tread(l),read(r),ans[i]=all;\n\t\tve[r].push_back({l,i});\n\t}\n\t\n\twork();\n\tFor(i,1,n) a[i]=all-a[i];\n\twork();\n\tFor(i,1,m) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "divide and conquer",
        "implementation"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Rebrending.json",
    "editorial_link": "https://codeforces.com//blog/entry/112723",
    "editorial": "Let\u00e2\u0080\u0099s go through all the elements from left to right. The main task will\r\nbe to support the current version of \u00e2\u0080\u0093 the minimum difference of with\r\nthe elements to the right of it that we managed to consider. Let us\r\ncorrectly calculate for the first elements. Let\u00e2\u0080\u0099s move on to . Let\u00e2\u0080\u0099s\r\nshow how to update the answer for all , such that . For , such that is\r\nsolved similarly. Let\u00e2\u0080\u0099s take the first element to the left of , such\r\nthat . Note that if there is such that , then we will not update for it,\r\nbecause . Also, we will not update the answer for such that , that is,\r\nif . Therefore, further we will be interested only in the numbers from\r\nthe segment . Let\u00e2\u0080\u0099s note that we have reduced the length of the segment\r\nby times. That is, there will be no more such iterations than . You can\r\nfind the rightmost number belonging to a segment using the segment tree.\r\nThe answer for the segment will be at the moment . This can also be\r\nefficiently found using the segment tree. The final asymptotics of the\r\nsolution is . There is also a solution for that passes all the tests.\r\nCode\r\n"
}