{"link": "https://codeforces.com//contest/41/problem/D", "problemId": "216", "problem_idx": "D", "shortId": "41D", "contest_number": "41", "problem_submissions": {"E": [187709, 187786, 188013, 188055, 187720, 188400, 187514, 188819, 188191, 188320, 187947, 187986, 188068, 187475, 188102, 188249, 188098], "D": [187451, 188035, 187556, 187294, 187606, 188558, 188821, 187849, 187246, 187712], "C": [186912, 186684, 186917, 187641, 186883, 186553, 188818, 186598, 186899, 188654, 186712, 186971, 187041, 187211, 187296, 187151, 187405], "B": [186796, 186260, 186544, 186516, 188464, 186708, 186215, 188816, 186320, 188632, 186180, 186422, 186551, 186670, 188213, 186455, 186499], "A": [185992, 186549, 186066, 186169, 186054, 186446, 186002, 188814, 186063, 186094, 185993, 186104, 186145, 185988, 186586, 185990, 186130]}, "name": "D. Pawn", "statement": "On some square in the lowest row of a chessboard a stands a pawn. It has\r\nonly two variants of moving: upwards and leftwards or upwards and\r\nrightwards. The pawn can choose from which square of the lowest row it\r\ncan start its journey. On each square lay from 0 to 9 peas. The pawn\r\nwants to reach the uppermost row having collected as many peas as\r\npossible. As there it will have to divide the peas between itself and\r\nits brothers, the number of peas must be divisible by . Find the maximal\r\nnumber of peas it will be able to collect and which moves it should make\r\nto do it.The pawn cannot throw peas away or leave the board. When a pawn\r\nappears in some square of the board (including the first and last square\r\nof the way), it necessarily takes all the peas.\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<list>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<utility>\n#include<sstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I=(A);I<=(B);I++)\n#define REP(I,N) for(int I=0;I<(N);I++)\n#define ALL(X) (X).begin(),(X).end()\n#define VAR(A,B) __typeof(B) A=B\n#define FORE(I,X) for(VAR(I,(X).begin());I!=(X).end();I++)\n#define F first\n#define S second\n#define INF 1000000007\n#define PB push_back\n#define MP make_pair\ntypedef pair<int,int> PII;\ntypedef long long LL;\nint n,m,k;\nbool ins(int x,int y){\n\tif (x<0 || y<0 || x>=m || y>=n) return false;\n\treturn true;\n}\nint dp[107][107][11]; //z - do ilu ma przystawac modulo k+1\nint md(int x){\n\treturn (((x%(k+1))+k+1)%(k+1));\n}\nbool found[107][107][11],lewo[107][107][11];\nchar tab[107][107];\nint wart(int x,int y,int mod){\n\tif (!ins(x,y)) return -1;\n\tif (!y){\n\t\tif (md(tab[x][y])==mod){\n\t\t\tfound[x][y][mod]=true;\n\t\t\tdp[x][y][mod]=tab[x][y];\n//\t\t\tprintf(\"Cos\\n\");\n//\t\t\tprintf(\"dp[%d][%d][%d]=%d\\n\",x,y,mod,tab[x][y]);\n\t\t\treturn tab[x][y];\n\t\t}\n\t\telse {\n\t\t\tfound[x][y][mod]=true;\n\t\t\tdp[x][y][mod]=-1;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (found[x][y][mod]) return dp[x][y][mod];\n\tfound[x][y][mod]=true;\n\tdp[x][y][mod]=-1;\n\tif (wart(x-1,y-1,md(mod-tab[x][y]))>wart(x+1,y-1,md(mod-tab[x][y])))\n\t\tlewo[x][y][mod]=true;\n\telse lewo[x][y][mod]=false;\n\tdp[x][y][mod]=max(wart(x-1,y-1,md(mod-tab[x][y])),wart(x+1,y-1,md(mod-tab[x][y])));\n//\tprintf(\"dp[%d][%d][%d]=%d\\n\",x,y,mod,dp[x][y][mod]);\n\tif (dp[x][y][mod]!=-1) dp[x][y][mod]+=tab[x][y];\n\treturn dp[x][y][mod];\n}\nint najw,gdzie,itx,ity,itm;\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tREP(y,n) REP(x,m){\n\t\tscanf(\" %c\",&tab[x][y]);\n\t\ttab[x][y]-='0';\n\t}\n//\tREP(y,n){ REP(x,m) printf(\"%d\",tab[x][y]); printf(\"\\n\"); }\n\tnajw=-1;\n\tREP(i,m){\n\t\tif (wart(i,n-1,0)>najw){\n\t\t\tnajw=wart(i,n-1,0);\n\t\t\tgdzie=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",najw);\n\tif (najw!=-1){\n\t\tprintf(\"%d\\n\",gdzie+1);\n\t\titx=gdzie; ity=n-1; itm=0;\n\t\twhile(ity){\n\t\t\tif (lewo[itx][ity][itm]){\n\t\t\t\tprintf(\"L\");\n\t\t\t\titm=md(itm-tab[itx][ity]);\n\t\t\t\tity--;\n\t\t\t\titx--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"R\");\n\t\t\t\titm=md(itm-tab[itx][ity]);\n\t\t\t\tity--;\n\t\t\t\titx++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "1900", "interactive": false}