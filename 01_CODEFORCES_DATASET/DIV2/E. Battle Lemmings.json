{"link": "https://codeforces.com//contest/1420/problem/E", "problemId": "735854", "problem_idx": "E", "shortId": "1420E", "contest_number": "1420", "problem_submissions": {"E": [93699813, 93707260, 93695968, 93707648, 93705681, 93709151, 93715432, 93730964, 93708580, 93714548, 93716147, 93715550, 93736542, 93717442, 93710855, 93715981, 93697763, 93711132, 93762507], "D": [93676952, 93680084, 93692950, 93670877, 93690670, 93693136, 93730971, 93710781, 93702357, 93681953, 93695104, 93691378, 93699248, 93698024, 93665582, 93680861, 93671056, 93667892, 93675623], "C2": [93674880, 93671167, 93692067, 93741708, 93681627, 93659881, 93679255, 93686831, 93676610, 93670869, 93669089, 93684016, 93707465, 93690589, 93710188, 93716769, 93662876, 93683514, 93665601], "C1": [93658399, 93663408, 93681461, 93660059, 93679792, 93666232, 93663489, 93671318, 93669597, 93684191, 93665522, 93690460, 93659663, 93716842, 93670252, 93662639, 93658224, 93665421], "B": [93652358, 93659482, 93658665, 93669626, 93664158, 93660524, 93657692, 93655021, 93655235, 93677044, 93656189, 93674995, 93653603, 93704106, 93656350, 93653174, 93653888, 93653561], "A": [93651966, 93651886, 93654562, 93660205, 93652727, 93651674, 93651632, 93674907, 93652710, 93659767, 93651617, 93706046, 93651985, 93651435, 93651489, 93651367]}, "name": "E. Battle Lemmings", "statement": "A lighthouse keeper Peter commands an army of n battle lemmings. He\r\nordered his army to stand in a line and numbered the lemmings from 1 to\r\nn from left to right. Some of the lemmings hold shields. Each lemming\r\ncannot hold more than one shield.The more protected Peter\u2019s army is, the\r\nbetter. To calculate the of the army, he finds the number of protected\r\npairs of lemmings, that is such pairs that both lemmings in the pair\r\ndon\u2019t hold a shield, but there is a lemming with a shield between\r\nthem.Now it\u2019s time to prepare for defence and increase the protection of\r\nthe army. To do this, Peter can give orders. He chooses a lemming with a\r\nshield and gives him one of the two orders: give the shield to the left\r\nneighbor if it exists and doesn\u2019t have a shield; give the shield to the\r\nright neighbor if it exists and doesn\u2019t have a shield. In one second\r\nPeter can give exactly one order.It\u2019s not clear how much time Peter has\r\nbefore the defence. So he decided to determine the maximal value of army\r\nprotection for each k from 0 to\r\nfrac{n(n-1)}2, if he gives no more that k orders. Help Peter to\r\ncalculate it!\r\n", "solutions": ["#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reverse_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 80;\nint f[mxN+3][mxN*mxN/2ll+3][mxN+3],ans[mxN+3];\nint a[mxN+3],b[mxN+3];\nint n,m;\n\nvoid updmax(int &x,int y) {x = max(x,y);}\n\nint main()\n{\n\tn = read(); for(int i=1; i<=n; i++) {a[i] = read(); if(a[i]==1) b[++m] = i;}\n\tmemset(f,-1,sizeof(f)); f[0][0][0] = 0;\n\tfor(int i=0; i<m; i++)\n\t{\n\t\tfor(int j=0; j<=i*(n-i); j++)\n\t\t{\n\t\t\tfor(int k=i; k<=n; k++) if(f[i][j][k]>=0)\n\t\t\t{\n\t\t\t\tfor(int l=k+1; l<=n; l++)\n\t\t\t\t{\n\t\t\t\t\tupdmax(f[i+1][j+abs(l-b[i+1])][l],f[i][j][k]+(l-k-1)*(k-i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n*(n-1)/2; i++)\n\t{\n\t\tif(i>0) {ans[i] = ans[i-1];}\n\t\tfor(int j=m; j<=n; j++) if(f[m][i][j]>=0) {ans[i] = max(ans[i],f[m][i][j]+(n-j)*(j-m));}\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dp", "greedy"], "dificulty": "2500", "interactive": false}