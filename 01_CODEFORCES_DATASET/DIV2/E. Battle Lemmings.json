{
    "link": "https://codeforces.com//contest/1420/problem/E",
    "problemId": "735854",
    "problem_idx": "E",
    "shortId": "1420E",
    "contest_number": "1420",
    "problem_submissions": {
        "E": [
            93699813,
            93707260,
            93695968,
            93707648,
            93705681,
            93709151,
            93715432,
            93730964,
            93708580,
            93714548,
            93716147,
            93715550,
            93736542,
            93717442,
            93710855,
            93715981,
            93697763,
            93711132,
            93762507
        ],
        "D": [
            93676952,
            93680084,
            93692950,
            93670877,
            93690670,
            93693136,
            93730971,
            93710781,
            93702357,
            93681953,
            93695104,
            93691378,
            93699248,
            93698024,
            93665582,
            93680861,
            93671056,
            93667892,
            93675623
        ],
        "C2": [
            93674880,
            93671167,
            93692067,
            93741708,
            93681627,
            93659881,
            93679255,
            93686831,
            93676610,
            93670869,
            93669089,
            93684016,
            93707465,
            93690589,
            93710188,
            93716769,
            93662876,
            93683514,
            93665601
        ],
        "C1": [
            93658399,
            93663408,
            93681461,
            93660059,
            93679792,
            93666232,
            93663489,
            93671318,
            93669597,
            93684191,
            93665522,
            93690460,
            93659663,
            93716842,
            93670252,
            93662639,
            93658224,
            93665421
        ],
        "B": [
            93652358,
            93659482,
            93658665,
            93669626,
            93664158,
            93660524,
            93657692,
            93655021,
            93655235,
            93677044,
            93656189,
            93674995,
            93653603,
            93704106,
            93656350,
            93653174,
            93653888,
            93653561
        ],
        "A": [
            93651966,
            93651886,
            93654562,
            93660205,
            93652727,
            93651674,
            93651632,
            93674907,
            93652710,
            93659767,
            93651617,
            93706046,
            93651985,
            93651435,
            93651489,
            93651367
        ]
    },
    "name": "E. Battle Lemmings",
    "statement": "A lighthouse keeper Peter commands an army of n battle lemmings. He\r\nordered his army to stand in a line and numbered the lemmings from 1 to\r\nn from left to right. Some of the lemmings hold shields. Each lemming\r\ncannot hold more than one shield.The more protected Peter\u2019s army is, the\r\nbetter. To calculate the of the army, he finds the number of protected\r\npairs of lemmings, that is such pairs that both lemmings in the pair\r\ndon\u2019t hold a shield, but there is a lemming with a shield between\r\nthem.Now it\u2019s time to prepare for defence and increase the protection of\r\nthe army. To do this, Peter can give orders. He chooses a lemming with a\r\nshield and gives him one of the two orders: give the shield to the left\r\nneighbor if it exists and doesn\u2019t have a shield; give the shield to the\r\nright neighbor if it exists and doesn\u2019t have a shield. In one second\r\nPeter can give exactly one order.It\u2019s not clear how much time Peter has\r\nbefore the defence. So he decided to determine the maximal value of army\r\nprotection for each k from 0 to\r\nfrac{n(n-1)}2, if he gives no more that k orders. Help Peter to\r\ncalculate it!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reverse_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 80;\nint f[mxN+3][mxN*mxN/2ll+3][mxN+3],ans[mxN+3];\nint a[mxN+3],b[mxN+3];\nint n,m;\n\nvoid updmax(int &x,int y) {x = max(x,y);}\n\nint main()\n{\n\tn = read(); for(int i=1; i<=n; i++) {a[i] = read(); if(a[i]==1) b[++m] = i;}\n\tmemset(f,-1,sizeof(f)); f[0][0][0] = 0;\n\tfor(int i=0; i<m; i++)\n\t{\n\t\tfor(int j=0; j<=i*(n-i); j++)\n\t\t{\n\t\t\tfor(int k=i; k<=n; k++) if(f[i][j][k]>=0)\n\t\t\t{\n\t\t\t\tfor(int l=k+1; l<=n; l++)\n\t\t\t\t{\n\t\t\t\t\tupdmax(f[i+1][j+abs(l-b[i+1])][l],f[i][j][k]+(l-k-1)*(k-i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n*(n-1)/2; i++)\n\t{\n\t\tif(i>0) {ans[i] = ans[i-1];}\n\t\tfor(int j=m; j<=n; j++) if(f[m][i][j]>=0) {ans[i] = max(ans[i],f[m][i][j]+(n-j)*(j-m));}\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Battle Lemmings.json",
    "editorial_link": "https://codeforces.com//blog/entry/82978",
    "editorial": "First, let us denote as a conversion of the original sequence of . In\r\nthe beginning, we will write down the number of zeros before the the\r\nfirst one. Then, we write down the number of zeros standing between the\r\nfirst and second ones, then between the second and third ones, and so\r\non. For example, , because there is one zero before the first one, there\r\nare no zeros between the first and second ones, there are three zeros\r\nbetween the second and third ones, etc. d. It is not difficult to see\r\nthat the original sequence can be unambiguously recovered with .Now, let\r\nus consider how will change if we change two different adjacent elements\r\nin the original sequence. In this case, two neighboring numbers will\r\nchange in , one of which will decrease by one and the other will\r\nincrease by one. The reversed statement is also true: if we choose two\r\nneighboring numbers in , one of them will increase by one, and the other\r\nwill decrease by one so that they both remain non-negative, this\r\noperation will correspond to an exchange of two neighboring elements in\r\n. Let us name this operation (choosing two neighboring numbers,\r\nincreasing one of them by one and reducing the other by one). .Let us\r\nconsider such a task. We have two arrays and . We have to calculate the\r\nminimum amount of pouring operations we can turn into . (Obviously, the\r\nsum of the numbers in and in must be the same.) To solve this, let\u00e2\u0080\u0099s try\r\nto split the array into two \"barriers\", standing after -th position.\r\nThen, the array is split into two parts: the left (elements from to )\r\nand the right (elements from to ). For the left part of the array to\r\nhave the same number of elements as in , you need pouring operations\r\ninvolving and elements. To sum up the number of necessary pouring\r\noperations for each pair of neighboring elements, you have to sum for\r\nall from to . It can be shown that the sum obtained will be the required\r\nnumber of pouring operations, because since it is equal to zero only in\r\ncase of equal arrays, and each pouring operation will reduce it by no\r\nmore than (and there is always a transfusion that reduces this sum by\r\n).So, this subtask has been sorted out, let\u00e2\u0080\u0099s move on. We have to learn\r\nhow to read security for the sequence , knowing . It is not difficult to\r\nsee that it is equal to We already know the value of : it is equal to\r\nthe number of zeroes in . So, we have to minimize .Now we can finally\r\nget down to the task. To do this, let\u00e2\u0080\u0099s try to build an optimal sequence\r\nof by applying no more than of transfusions. Of course, we need to use\r\nthe dynamic programming of . This means that we have looked at the first\r\nelements in and done with pouring operations so that equals . The DP\r\nitself will store the minimum possible value of .To get the answer we\r\nneed to refer to where is the number of zeros in the original sequence.\r\nAnd to recalculate the dynamics of we have to go through what will be as\r\na result. Let it be . Then, the answer recovery happens in the following\r\nway:Here denotes in the original sequence .The total asymptotic is in\r\ntime and in memory, although with a correct implementation the constant\r\nis very small (the author\u00e2\u0080\u0099s solution works for ). In this task, there\r\nare solutions for , but I will not describe them here.\r\n"
}