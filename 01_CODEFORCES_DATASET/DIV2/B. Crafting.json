{
    "link": "https://codeforces.com//contest/2055/problem/B",
    "problemId": "3141115",
    "problem_idx": "B",
    "shortId": "2055B",
    "contest_number": "2055",
    "problem_submissions": {
        "E": [
            300746486,
            300849536,
            300761124
        ],
        "D": [
            300696033,
            300705238,
            300701008,
            300702007,
            300702452,
            300703784,
            300699187,
            300704114,
            300709175,
            300707029,
            300707549,
            300710969,
            300708967,
            300711888,
            300708148,
            300708052,
            300708173,
            300705738
        ],
        "C": [
            300672652,
            300668358,
            300677522,
            300677196,
            300683675,
            300681011,
            300678376,
            300681393,
            300678777,
            300680600,
            300678839,
            300677980,
            300671004,
            300679220,
            300687159,
            300684321,
            300687531,
            300683543
        ],
        "B": [
            300657881,
            300656820,
            300666935,
            300663382,
            300655553,
            300662689,
            300671074,
            300665092,
            300657486,
            300665581,
            300668563,
            300655341,
            300661161,
            300658795,
            300659826,
            300665475,
            300658513,
            300662771
        ],
        "A": [
            300651053,
            300651601,
            300652364,
            300654430,
            300651022,
            300652195,
            300652888,
            300655299,
            300650941,
            300654319,
            300652932,
            300651006,
            300651149,
            300651992,
            300652147,
            300652006,
            300652172,
            300650990
        ],
        "F": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/138343",
    "editorial": "SolutionThe key observation is that we will never use the operation to\r\ncraft two different types of materials . This is because if we were to\r\ncombine the net change in resources from these two operations, we would\r\nlose two units each of every material , and receive a net zero change in\r\nour amounts of materials . Therefore, we will only ever use the\r\noperation on one type of material .An immediate corollary of this\r\nobservation is that we can only be deficient in at most one type of\r\nmaterial, i.e. at most one index at which . If no such index exists, the\r\nmaterial is craftable using our starting resources. Otherwise, applying\r\nthe operation times transforms our array to i.e. increasing element by\r\nand decreasing all other elements by . We must have to satisfy the\r\nrequirement on material type . However, there is also no point in making\r\nany larger, as by then we already have enough of type , and further\r\noperations cause us to start losing materials from other types that we\r\ncould potentially need to craft the artifact. Therefore, our condition\r\nin this case is just to check that i.e. we are deficient in type by at\r\nmost as many units as our smallest surplus in all other material types .\r\nThis gives an solution.\r\n",
    "name": "B. Crafting",
    "statement": "There are n different types of magical materials, numbered from 1 to n.\r\nInitially, you have a_i units of material i for each i from 1 to n. You\r\nare allowed to perform the following operation: Select a material i\r\n(where 1\r\nle i\r\nle n). Then, spend 1 unit of other material j (in other words, j\r\nneq i) to gain 1 unit of material i. More formally, after selecting\r\nmaterial i, update array a as follows: a_i := a_i + 1, and a_j := a_j -\r\n1 for all j where j\r\nneq i and 1\r\nle j\r\nle n. Note that all a_j must remain non-negative, i.e. you cannot spend\r\nresources you do not have. You are trying to craft an artifact using\r\nthese materials. To successfully craft the artifact, you must have at\r\nleast b_i units of material i for each i from 1 to n. Determine if it is\r\npossible to craft the artifact by performing the operation any number of\r\ntimes (including zero).\r\n",
    "solutions": [
        "#include <algorithm>#include <array>#include <bitset>#include <cassert>#include <chrono>#include <cmath>#include <complex>#include <cstring>#include <functional>#include <iomanip>#include <iostream>#include <map>#include <numeric>#include <queue>#include <random>#include <set>#include <vector>#include <climits>using namespace std;using ll=long long;using db=long double;using pi=pair<int,int>;using pl=pair<ll,ll>;using vi=vector<int>;using vl=vector<ll>;using vpi=vector<pi>;using vpl=vector<pl>;#define mp make_pair#define eb emplace_back#define pb push_back#define x first#define y second#define sz(x)int((x).size())#define bg(x) begin(x)#define all(x)(x).begin(),(x).end()#define rall(x) x.rbegin(), x.rend() #define rep(i,a,b)for(int i=(a);i<(b);i++)#define per(i,a,b)for(int i=(b)-1;i>=(a);i--)#define ft front()#define bk back()#define rsz resize#define ins insert#define each(a,x)for(auto&a:x)bool ckmin(auto&a,auto b){return b<a?a=b,1:0;}bool ckmax(auto&a,auto b){return b>a?a=b,1:0;}#ifdef LOCALtemplate<class A, class B>ostream&operator<<(ostream&o,pair<A,B>p){return o<<\"(\"<<p.x<<\", \"<<p.y<<\")\";}template<class A, class B, class C>ostream&operator<<(ostream&o,tuple<A,B,C>t){    return o<<\"(\"<<get<0>(t)<<\", \"<<get<1>(t)<<\", \"<<get<2>(t)<<\", \"<<\")\";}auto operator<<(auto&o,auto x)->decltype(x.end(),o){    o<<\"{\";int i=0;for(auto&e:x)o<<\",\"+!i++<<e;return o<<\"}\";}#define debug(X...)cerr<<\"[\"#X\"]: \",[](auto...$){((cerr<<$<<\"; \"),...)<<endl;}(X);#else#define debug(...){}#endif const pi MOVES[] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}}; // #include <ext/pb_ds/assoc_container.hpp>// #include <ext/pb_ds/tree_policy.hpp>// using namespace __gnu_pbds;// template<class T>// using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; template<int MOD, int RT> struct mint {    static const int mod = MOD;    static constexpr mint rt() { return RT; }    int v; explicit operator int() const { return v; }    mint() : v(0) {}    mint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);        if (v < 0) v += MOD; }    bool operator==(const mint& o) const {        return v == o.v; }    friend bool operator!=(const mint& a, const mint& b) {         return !(a == b); }    friend bool operator<(const mint& a, const mint& b) {         return a.v < b.v; }     mint& operator+=(const mint& o) {         if ((v += o.v) >= MOD) v -= MOD;         return *this; }    mint& operator-=(const mint& o) {         if ((v -= o.v) < 0) v += MOD;         return *this; }    mint& operator*=(const mint& o) {         v = int((ll)v*o.v%MOD); return *this; }    mint& operator/=(const mint& o) { return (*this) *= inv(o); }    friend mint pow(mint a, ll p) {        mint ans = 1; assert(p >= 0);        for (; p; p /= 2, a *= a) if (p&1) ans *= a;        return ans; }    friend mint inv(const mint& a) { assert(a.v != 0);         return pow(a,MOD-2); }            mint operator-() const { return mint(-v); }    mint& operator++() { return *this += 1; }    mint& operator--() { return *this -= 1; }    friend mint operator+(mint a, const mint& b) { return a += b; }    friend mint operator-(mint a, const mint& b) { return a -= b; }    friend mint operator*(mint a, const mint& b) { return a *= b; }    friend mint operator/(mint a, const mint& b) { return a /= b; }    friend ostream& operator<<(ostream& o, const mint& a) { return o << a.v; }    friend istream& operator>>(istream& i, mint& a) {        ll x; i >> x; a = x;        return i;    }}; const int MOD = 998244353;using mi = mint<MOD,5>;using vmi = vector<mi>;using pmi = pair<mi,mi>;using vpmi = vector<pmi>; const int INF = 1e9+2137; void solve() {    int n;    cin >> n;    vi a(n);    rep(i,0,n) cin >> a[i];    vi b(n);    rep(i,0,n) cin >> b[i];    int cnt_less = 0;    rep(i,0,n) cnt_less += a[i] < b[i];    if (cnt_less == 0) {        cout << \"YES\\n\";        return;    }    if (cnt_less > 1)  {        cout << \"NO\\n\";        return;    }    int can = INF;    int need = 0;    rep(i,0,n){        if (a[i] < b[i]) need = b[i] - a[i];        else ckmin(can, a[i] - b[i]);    }    cout << (can >= need ? \"YES\\n\" : \"NO\\n\");} signed main() {    cin.tie(0)->sync_with_stdio(0);     int t;    cin >> t;    while (t--) solve();     return 0;} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "sortings"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Crafting.json"
}