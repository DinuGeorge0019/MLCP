{
    "link": "https://codeforces.com//contest/437/problem/B",
    "problemId": "9959",
    "problem_idx": "B",
    "shortId": "437B",
    "contest_number": "437",
    "problem_submissions": {
        "D": [
            6768714,
            6769219,
            6770597,
            6770872,
            6770582,
            6781618,
            6771775,
            6770670,
            6770715,
            6769181,
            6771878,
            6771390,
            6772290,
            6772185,
            6772074,
            6773126,
            6775142,
            6772502,
            6772965
        ],
        "C": [
            6767394,
            6768027,
            6768255,
            6768551,
            6769557,
            6781619,
            6767953,
            6767610,
            6769516,
            6767838,
            6769685,
            6768603,
            6768216,
            6769376,
            6770139,
            6769862,
            6768685,
            6770746
        ],
        "B": [
            6766890,
            6767081,
            6767380,
            6767693,
            6768412,
            6781613,
            6767171,
            6768398,
            6767388,
            6767578,
            6769683,
            6769218,
            6768117,
            6768608,
            6767962,
            6770162,
            6769331
        ],
        "A": [
            6765797,
            6766130,
            6766338,
            6766075,
            6766175,
            6781609,
            6766174,
            6768415,
            6766417,
            6774089,
            6765946,
            6766895,
            6767187,
            6766894,
            6767293,
            6771080,
            6766764,
            6766124
        ],
        "E": [
            6781616
        ]
    },
    "name": "B. The Child and Set",
    "statement": "At the children\u2019s day, the child came to Picks\u2019s house, and messed his\r\nhouse up. Picks was angry at him. A lot of important things were lost,\r\nin particular the favorite set of Picks.Fortunately, Picks remembers\r\nsomething about his set : its elements were distinct integers from to ;\r\nthe value of was equal to ; here equals where is the position of the\r\nfirst one in the binary representation of . For example, (binary\r\nrepresentation). Can you help Picks and find any set , that satisfies\r\nall the above conditions?\r\n",
    "solutions": [
        "#include <cstdio>\n#include <string>\n#include <cstdlib>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#define rep(i, a, b) for (int i = a; i < b; ++i)\n#define dep(i, a, b) for (int i = a; i > b; --i)\n#define N 200005\nusing namespace std;\n\nint init[N], cnt[N];\nint n, m, ans;\n\nint lowbit(int x)\n{\n\treturn x & -x;\n}\nbool find(int p)  {\n\tif (cnt[p])\n\t{\n\t\tcnt[p]--;\n\t\t++ans;\n\t\treturn 1;\n\t}\n\tif (p == 1) return 0;\n\tif (find(p >> 1) == 0) return 0;\n\tif (find(p >> 1) == 0) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\trep(i, 0, m)\n\t{\n\t\tint val = lowbit(i+1);\n\t\tinit[val]++;\n\t\tcnt[val]++;\n\t}\n\tfor (int i = 20; i >= 0; --i)\n\t\tif ((n >> i) & 1)\n\t\t{\n\t\t\tif (find(1 << i) == 0)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\trep(i, 0, m)\n\t{\n\t\tint val = lowbit(i+1);\n\t\tif (cnt[val] != init[val])\n\t\t{\n\t\t\tprintf(\"%d \", i+1);\n\t\t\tcnt[val]++;\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. The Child and Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/12513",
    "editorial": "We could deal with this by digits. Because is taking out the lowest of\r\nthe number , we can enumerate the number of the lowest zero. Then, if we\r\nenumerate as the number of zero, we enumerate as well, which is no more\r\nthan and is odd. We can find out that . In this order, we would find out\r\nthat the we are considering is monotonically decresing. Because for\r\nevery two number , is a divisor of or is a divisor of . We can solve it\r\nby greedy. When we enumerate by descending order, we check whether is no\r\nmore than , and check whether there is such . We minus from if and\r\nexist. If at last is not equal to 0, then it must be an impossible test.\r\nWhy? Because if we don\u00e2\u0080\u0099t choose a number whose , then we shouldn\u00e2\u0080\u0099t\r\nchoose two numbers whose . (Otherwise we can replace these two numbers\r\nwith one number) If we choose one number whose , then we can choose at\r\nmost one number whose , at most one number whose and so on. So the total\r\nsum of them is less than and we can\u00e2\u0080\u0099t merge them into . If we don\u00e2\u0080\u0099t\r\nchoose one number whose , then it\u00e2\u0080\u0099s just the same as we don\u00e2\u0080\u0099t choose one\r\nnumber whose . So the total time complexity is .\r\n"
}