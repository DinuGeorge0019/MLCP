{
    "link": "https://codeforces.com//contest/1705/problem/E",
    "problemId": "1463492",
    "problem_idx": "E",
    "shortId": "1705E",
    "contest_number": "1705",
    "problem_submissions": {
        "E": [
            164313678,
            164283877,
            164322922,
            164296635,
            164328190,
            164330200,
            182244316,
            164662858,
            164301911,
            164382357,
            164307832,
            164311215,
            164877717,
            164877334,
            164877248,
            164876250,
            164876123,
            164311471,
            164312217,
            164309954,
            164307210,
            164313972,
            164313748
        ],
        "F": [
            164297533,
            164313413,
            164317453,
            164328892,
            164293393,
            164327045,
            164284621,
            164284133,
            164291743,
            164302194,
            165132539,
            164348710,
            164323281,
            164391921
        ],
        "D": [
            164286707,
            164304717,
            164280506,
            164282817,
            164306344,
            164300946,
            164312628,
            164317244,
            164662848,
            164319640,
            164284384,
            164325926,
            164285658,
            164285757,
            164290551,
            164293318,
            164291394,
            164299908,
            164293093,
            164301425,
            164291705
        ],
        "C": [
            164281860,
            164296877,
            164275420,
            164273360,
            164295006,
            164295319,
            164301269,
            164662833,
            164288918,
            164274715,
            164280149,
            164277014,
            164275688,
            165102447,
            164283971,
            164282615,
            164282594,
            164274835,
            164277444,
            164285515,
            164285435
        ],
        "B": [
            164273413,
            164289760,
            164270705,
            164266717,
            164276123,
            164275997,
            164276303,
            164274236,
            164662822,
            164269128,
            164268180,
            164273865,
            164270610,
            164270505,
            164271837,
            164271931,
            164276822,
            164279085,
            164272358,
            164272892,
            164272828
        ],
        "A": [
            164266986,
            164279867,
            164266709,
            164265172,
            164267444,
            164266906,
            164267475,
            164265741,
            164662806,
            164278230,
            164265167,
            164265698,
            164265336,
            164266101,
            164266312,
            164265878,
            164265963,
            164265319,
            164267659,
            164267039,
            164266626
        ]
    },
    "name": "E. Mark and Professor Koro",
    "statement": "After watching a certain anime before going to sleep, Mark dreams of\r\nstanding in an old classroom with a blackboard that has a sequence of n\r\npositive integers a_1, a_2,\r\ndots,a_n on it.Then, professor Koro comes in. He can perform the\r\nfollowing operation: select an integer x that appears at least 2 times\r\non the board, erase those 2 appearances, and write x+1 on the board.\r\nProfessor Koro then asks Mark the question, \"what is the maximum\r\npossible number that could appear on the board after some\r\noperations?\"Mark quickly solves this question, but he is still slower\r\nthan professor Koro. Thus, professor Koro decides to give Mark\r\nadditional challenges. He will update the initial sequence of integers q\r\ntimes. Each time, he will choose positive integers k and l, then change\r\na_k to l. After each update, he will ask Mark the same question\r\nagain.Help Mark answer these questions faster than Professor Koro!Note\r\nthat the updates are persistent. Changes made to the sequence a will\r\napply when processing future updates.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define N 220020\ntypedef long long ll;\nint n,Q,a[N];\nclass Segment_Tree{\n\tint Len;\n\tstruct node{\n\t\tint sum,cov,len;\n\t\tnode(){cov=-1;}\n\t\tvoid Cover(int d){\n\t\t\tcov=d;\n\t\t\tsum=len*d;\n\t\t}\n\t}t[N<<2];\n\t#define ls u<<1\n\t#define rs u<<1|1\n\tinline void update(int u){\n\t\tt[u].sum=t[ls].sum+t[rs].sum;\n\t}\n\tinline void pushdown(int u){\n\t\tif(~t[u].cov){\n\t\t\tt[ls].Cover(t[u].cov);\n\t\t\tt[rs].Cover(t[u].cov);\n\t\t\tt[u].cov=-1;\n\t\t}\n\t}\n\tvoid build(int u,int L,int R){\n\t\tt[u].len=R-L+1;\n\t\tif(L==R)return;\n\t\tint mid=(L+R)>>1;\n\t\tbuild(ls,L,mid);\n\t\tbuild(rs,mid+1,R);\n\t}\n\tvoid _cover(int u,int L,int R,int l,int r,int d){\n\t\tif(L>=l&&R<=r){\n\t\t\tt[u].Cover(d);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(l<=mid)_cover(ls,L,mid,l,r,d);\n\t\tif(r>mid)_cover(rs,mid+1,R,l,r,d);\n\t\tupdate(u);\n\t}\n\tvector<tuple<int,int,int> > a;\n\tvoid _get(int u,int L,int R,int l,int r){\n\t\tif(L>=l&&R<=r){\n\t\t\ta.emplace_back(u,L,R);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(l<=mid)_get(ls,L,mid,l,r);\n\t\tif(r>mid)_get(rs,mid+1,R,l,r);\n\t}\n\tint _find_0(int u,int L,int R){\n\t\tif(t[u].sum==t[u].len)return -1;\n\t\tif(L==R)return L;\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(t[ls].len!=t[ls].sum)return _find_0(ls,L,mid);\n\t\treturn _find_0(rs,mid+1,R);\n\t}\n\tint _find_1(int u,int L,int R){\n\t\tif(0==t[u].sum)return -1;\n\t\tif(L==R)return L;\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(0!=t[ls].sum)return _find_1(ls,L,mid);\n\t\treturn _find_1(rs,mid+1,R);\n\t}\n\tint _gg(int u,int L,int R){\n\t\tif(0==t[u].len)return -1;\n\t\tif(L==R)return L;\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(0!=t[rs].sum)return _gg(rs,mid+1,R);\n\t\treturn _gg(ls,L,mid);\n\t}\npublic:\n\tvoid init(int _n){\n\t\tLen=_n;\n\t\tbuild(1,1,Len);\n\t}\n\tint Find_0(int lim){\n\t\ta.clear();\n\t\t_get(1,1,Len,lim,Len);\n\t\tfor(auto [u,L,R]:a){\n\t\t\tint z=_find_0(u,L,R);\n\t\t\tif(~z)return z;\n\t\t}\n\t\tassert(false);\n\t}\n\tint Find_1(int lim){\n\t\ta.clear();\n\t\t_get(1,1,Len,lim,Len);\n\t\tfor(auto [u,L,R]:a){\n\t\t\tint z=_find_1(u,L,R);\n\t\t\tif(~z)return z;\n\t\t}\n\t\tassert(false);\n\t}\n\tvoid Add(int x){\n\t\tint y=Find_0(x);\n\t\tif(y>x)_cover(1,1,Len,x,y-1,0);\n\t\t_cover(1,1,Len,y,y,1);\n\t}\n\tvoid Del(int x){\n\t\tint y=Find_1(x);\n\t\tif(y>x)_cover(1,1,Len,x,y-1,1);\n\t\t_cover(1,1,Len,y,y,0);\n\t}\n\tint get_ans(){\n\t\treturn _gg(1,1,Len);\n\t}\n}T;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tT.init(200200);\n\tcin>>n>>Q;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tT.Add(a[i]);\n\t}\n\twhile(Q--){\n\t\tint x;\n\t\tcin>>x;\n\t\tT.Del(a[x]);\n\t\tcin>>a[x];\n\t\tT.Add(a[x]);\n\t\tcout<<T.get_ans()<<'\\n';\n\t}\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "combinatorics",
        "data structures",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Mark and Professor Koro.json",
    "editorial_link": "https://codeforces.com//blog/entry/104881",
    "editorial": "TutorialThe key observation is the following.Claim: The answer is Proof:\r\nThe upper bound is pretty clear, as the operation doesnât change the .\r\nMoreover, the sum must be at least , giving the result.For the\r\nconstruction, let Mark keep performing the operation until he cannot. At\r\nthis point, all numbers must be distinct, and the is unchanged. Let the\r\ncurrent numbers on the board be . Then, Thus, Mark can make the final\r\nnumber be as desired. Finally, we need a data structure to maintain the\r\nand simulate base 2 addition. There are many ways to proceed, including\r\nthe following: Using bitsets, partition the bits into many chunks of\r\nbits ( between and is fine). This gives complexity, but its low constant\r\nfactor makes it enough to pass comfortably. Use lazy segment augmented\r\nwith binary search. For each bit added, find where the longest streak of\r\nâs to the left of that bit ends, and update accordingly. Similarly, for\r\neach bit subtracted, find where the longest streak of âs to the left of\r\nthat bit ends, and update accordingly. The total complexity is .\r\n",
    "hint": [
        "Hint 1 Find a concise description of the answer first.",
        "Hint 2 Think about power of two.",
        "Hint 3 The sum is constant. Show that the answer must be the most significant bit of that.",
        "Hint 4 Use either bitset or lazy segment tree to simulate the addition/subtraction."
    ]
}