{"link": "https://codeforces.com//contest/1705/problem/E", "problemId": "1463492", "problem_idx": "E", "shortId": "1705E", "contest_number": "1705", "problem_submissions": {"E": [164313678, 164283877, 164322922, 164296635, 164328190, 164330200, 182244316, 164662858, 164301911, 164382357, 164307832, 164311215, 164877717, 164877334, 164877248, 164876250, 164876123, 164311471, 164312217, 164309954, 164307210, 164313972, 164313748], "F": [164297533, 164313413, 164317453, 164328892, 164293393, 164327045, 164284621, 164284133, 164291743, 164302194, 165132539, 164348710, 164323281, 164391921], "D": [164286707, 164304717, 164280506, 164282817, 164306344, 164300946, 164312628, 164317244, 164662848, 164319640, 164284384, 164325926, 164285658, 164285757, 164290551, 164293318, 164291394, 164299908, 164293093, 164301425, 164291705], "C": [164281860, 164296877, 164275420, 164273360, 164295006, 164295319, 164301269, 164662833, 164288918, 164274715, 164280149, 164277014, 164275688, 165102447, 164283971, 164282615, 164282594, 164274835, 164277444, 164285515, 164285435], "B": [164273413, 164289760, 164270705, 164266717, 164276123, 164275997, 164276303, 164274236, 164662822, 164269128, 164268180, 164273865, 164270610, 164270505, 164271837, 164271931, 164276822, 164279085, 164272358, 164272892, 164272828], "A": [164266986, 164279867, 164266709, 164265172, 164267444, 164266906, 164267475, 164265741, 164662806, 164278230, 164265167, 164265698, 164265336, 164266101, 164266312, 164265878, 164265963, 164265319, 164267659, 164267039, 164266626]}, "name": "E. Mark and Professor Koro", "statement": "After watching a certain anime before going to sleep, Mark dreams of\r\nstanding in an old classroom with a blackboard that has a sequence of n\r\npositive integers a_1, a_2,\r\ndots,a_n on it.Then, professor Koro comes in. He can perform the\r\nfollowing operation: select an integer x that appears at least 2 times\r\non the board, erase those 2 appearances, and write x+1 on the board.\r\nProfessor Koro then asks Mark the question, \"what is the maximum\r\npossible number that could appear on the board after some\r\noperations?\"Mark quickly solves this question, but he is still slower\r\nthan professor Koro. Thus, professor Koro decides to give Mark\r\nadditional challenges. He will update the initial sequence of integers q\r\ntimes. Each time, he will choose positive integers k and l, then change\r\na_k to l. After each update, he will ask Mark the same question\r\nagain.Help Mark answer these questions faster than Professor Koro!Note\r\nthat the updates are persistent. Changes made to the sequence a will\r\napply when processing future updates.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define N 220020\ntypedef long long ll;\nint n,Q,a[N];\nclass Segment_Tree{\n\tint Len;\n\tstruct node{\n\t\tint sum,cov,len;\n\t\tnode(){cov=-1;}\n\t\tvoid Cover(int d){\n\t\t\tcov=d;\n\t\t\tsum=len*d;\n\t\t}\n\t}t[N<<2];\n\t#define ls u<<1\n\t#define rs u<<1|1\n\tinline void update(int u){\n\t\tt[u].sum=t[ls].sum+t[rs].sum;\n\t}\n\tinline void pushdown(int u){\n\t\tif(~t[u].cov){\n\t\t\tt[ls].Cover(t[u].cov);\n\t\t\tt[rs].Cover(t[u].cov);\n\t\t\tt[u].cov=-1;\n\t\t}\n\t}\n\tvoid build(int u,int L,int R){\n\t\tt[u].len=R-L+1;\n\t\tif(L==R)return;\n\t\tint mid=(L+R)>>1;\n\t\tbuild(ls,L,mid);\n\t\tbuild(rs,mid+1,R);\n\t}\n\tvoid _cover(int u,int L,int R,int l,int r,int d){\n\t\tif(L>=l&&R<=r){\n\t\t\tt[u].Cover(d);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(l<=mid)_cover(ls,L,mid,l,r,d);\n\t\tif(r>mid)_cover(rs,mid+1,R,l,r,d);\n\t\tupdate(u);\n\t}\n\tvector<tuple<int,int,int> > a;\n\tvoid _get(int u,int L,int R,int l,int r){\n\t\tif(L>=l&&R<=r){\n\t\t\ta.emplace_back(u,L,R);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(l<=mid)_get(ls,L,mid,l,r);\n\t\tif(r>mid)_get(rs,mid+1,R,l,r);\n\t}\n\tint _find_0(int u,int L,int R){\n\t\tif(t[u].sum==t[u].len)return -1;\n\t\tif(L==R)return L;\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(t[ls].len!=t[ls].sum)return _find_0(ls,L,mid);\n\t\treturn _find_0(rs,mid+1,R);\n\t}\n\tint _find_1(int u,int L,int R){\n\t\tif(0==t[u].sum)return -1;\n\t\tif(L==R)return L;\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(0!=t[ls].sum)return _find_1(ls,L,mid);\n\t\treturn _find_1(rs,mid+1,R);\n\t}\n\tint _gg(int u,int L,int R){\n\t\tif(0==t[u].len)return -1;\n\t\tif(L==R)return L;\n\t\tpushdown(u);\n\t\tint mid=(L+R)>>1;\n\t\tif(0!=t[rs].sum)return _gg(rs,mid+1,R);\n\t\treturn _gg(ls,L,mid);\n\t}\npublic:\n\tvoid init(int _n){\n\t\tLen=_n;\n\t\tbuild(1,1,Len);\n\t}\n\tint Find_0(int lim){\n\t\ta.clear();\n\t\t_get(1,1,Len,lim,Len);\n\t\tfor(auto [u,L,R]:a){\n\t\t\tint z=_find_0(u,L,R);\n\t\t\tif(~z)return z;\n\t\t}\n\t\tassert(false);\n\t}\n\tint Find_1(int lim){\n\t\ta.clear();\n\t\t_get(1,1,Len,lim,Len);\n\t\tfor(auto [u,L,R]:a){\n\t\t\tint z=_find_1(u,L,R);\n\t\t\tif(~z)return z;\n\t\t}\n\t\tassert(false);\n\t}\n\tvoid Add(int x){\n\t\tint y=Find_0(x);\n\t\tif(y>x)_cover(1,1,Len,x,y-1,0);\n\t\t_cover(1,1,Len,y,y,1);\n\t}\n\tvoid Del(int x){\n\t\tint y=Find_1(x);\n\t\tif(y>x)_cover(1,1,Len,x,y-1,1);\n\t\t_cover(1,1,Len,y,y,0);\n\t}\n\tint get_ans(){\n\t\treturn _gg(1,1,Len);\n\t}\n}T;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tT.init(200200);\n\tcin>>n>>Q;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tT.Add(a[i]);\n\t}\n\twhile(Q--){\n\t\tint x;\n\t\tcin>>x;\n\t\tT.Del(a[x]);\n\t\tcin>>a[x];\n\t\tT.Add(a[x]);\n\t\tcout<<T.get_ans()<<'\\n';\n\t}\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["binary search", "bitmasks", "brute force", "combinatorics", "data structures", "greedy"], "dificulty": "2300", "interactive": false}