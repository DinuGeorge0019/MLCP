{
    "link": "https://codeforces.com//contest/939/problem/E",
    "problemId": "157444",
    "problem_idx": "E",
    "shortId": "939E",
    "contest_number": "939",
    "problem_submissions": {
        "F": [
            35407164,
            35404527,
            35409631,
            35413577,
            35411662,
            35419439,
            35414187,
            35411618,
            35431888,
            35412467,
            35419660,
            35433583
        ],
        "E": [
            35398600,
            35400617,
            35396384,
            35401251,
            35402353,
            35398722,
            35401205,
            35397543,
            35398502,
            35402734,
            35403103,
            35414533,
            35403422,
            35401372,
            35401626,
            35461044,
            35403396,
            35403015,
            35403923,
            35405332,
            35405603
        ],
        "D": [
            35396133,
            35397568,
            35397994,
            35395417,
            35401286,
            35396814,
            35398696,
            35395034,
            35395649,
            35399214,
            35400903,
            35404198,
            35396354,
            35399157,
            35398522,
            35399419,
            35400286,
            35400477,
            35399060,
            35399994
        ],
        "C": [
            35393837,
            35395958,
            35393508,
            35393769,
            35396360,
            35392577,
            35412731,
            35392757,
            35393879,
            35395902,
            35398127,
            35403086,
            35394045,
            35395387,
            35396026,
            35395295,
            35396730,
            35397951,
            35394874,
            35395895
        ],
        "B": [
            35389969,
            35392883,
            35389759,
            35389629,
            35391873,
            35393694,
            35390537,
            35390126,
            35390538,
            35390605,
            35392335,
            35394074,
            35390549,
            35391091,
            35397165,
            35390254,
            35391051,
            35391212,
            35391979,
            35390583
        ],
        "A": [
            35388647,
            35391478,
            35388695,
            35388656,
            35389475,
            35394633,
            35388859,
            35388665,
            35388816,
            35388903,
            35389256,
            35400980,
            35388685,
            35388755,
            35389214,
            35388752,
            35389036,
            35388963,
            35390469,
            35388756
        ]
    },
    "name": "E. Maximize ",
    "statement": "You are given a multiset consisting of positive integers (initially\r\nempty). There are two kind of queries: Add a positive integer to , the\r\nnewly added integer is not less than any number in it. Find a subset of\r\nthe set such that the value is maximum possible. Here means maximum\r\nvalue of elements in , the average value of numbers in . Output this\r\nmaximum possible value of .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef long double ld;\n\n#define F first\n#define S second\n\nconst int MAXN = 5e5 + 10;\n\nint n, q;\nll p[MAXN], a[MAXN];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(12);\n\tcin >> q;\n\twhile (q--){\n\t\tint t; cin >> t;\n\t\tif (t == 1){\n\t\t\tint x; cin >> x;\n\t\t\ta[n++] = x;\n\t\t\tp[n] = p[n-1] + a[n-1];\n\t\t}\n\t\telse{\n\t\t\tint lo = -1, hi = n-1;\n\t\t\twhile (hi-lo>1){\n\t\t\t\tint mid = hi+lo>>1;\n\t\t\t\tif ((a[n-1] + p[mid]) * (mid + 2) > (a[n-1] + p[mid+1]) * (mid + 1))\n\t\t\t\t\tlo = mid;\n\t\t\t\telse\n\t\t\t\t\thi = mid;\n\t\t\t}\n\t\t\tcout << a[n-1] - (a[n-1] + p[hi])/ ld(hi + 1) << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "ternary search",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Maximize .json",
    "editorial_link": "https://codeforces.com//blog/entry/57892",
    "editorial": "Letâs first prove some lemmas we will use in the solution. Let be\r\nintegers that are at the current moment in , sorted in increasing order.\r\nLemma 1. Let the maximum element in optimal be . Then the rest of the\r\nelements in form a prefix of .Proof: let it be wrong. Letâs consider the\r\nfirst element of , that is not in . We know that in some element is\r\npresented . Letâs replace in with , the average will not increase,\r\nbecause , will not change, so will not decrease.Lemma 2. Let the value\r\nthat we want to maximize in case of consisting of , and a prefix of of\r\nlength , i. e. elements . A claim: , where denotes the sign of .Proof: .\r\nBecause the denominator is always , then .Lemma 3. Letâs denote for a\r\nfixed . is non-decreasing for increasing .Proof: . , because is sorted.\r\nThen , i. e. , this means that does not decrease when increases.Letâs\r\nsolve the problem now. Letâs keep the current answer for the query of\r\ntype , let it be . When a new operation of type comes, letâs update it\r\nwith the optimal value of in case , where is the newly added element. To\r\nfind this optimal value, letâs do binary search for and find the minimum\r\nvalue of , such that . Lemmas prove us that this prefix of length is\r\noptimal for fixed . Now update the value of with the value . To compute\r\nthe values fast, we should maintain the array of prefix sums in one more\r\nelement is added to this array each time a query of type comes.\r\n",
    "hint": []
}