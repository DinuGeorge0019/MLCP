{
    "link": "https://codeforces.com//contest/745/problem/B",
    "problemId": "85235",
    "problem_idx": "B",
    "shortId": "745B",
    "contest_number": "745",
    "problem_submissions": {
        "D": [
            23063628,
            23061434,
            23062278,
            23062946,
            23063952,
            23062953,
            23063684,
            23065227,
            23067508,
            23064054,
            23066325,
            23064778,
            23065417,
            23065640,
            23065940,
            23064035,
            23066189,
            23064933,
            23065850
        ],
        "C": [
            23058754,
            23056208,
            23058146,
            23057537,
            23056194,
            23058075,
            23057431,
            23056700,
            23056696,
            23059037,
            23057208,
            23057100,
            23059888,
            23057785,
            23058711,
            23057786,
            23057804,
            23058775,
            23060465,
            23060269
        ],
        "B": [
            23054534,
            23053936,
            23055906,
            23053616,
            23057561,
            59539483,
            23055581,
            23054327,
            23058797,
            23055722,
            23054071,
            23052962,
            23055965,
            23054973,
            23055010,
            23060679,
            23060284,
            23055704,
            23055472,
            23055306
        ],
        "A": [
            23052643,
            23052117,
            23054108,
            23052198,
            23052470,
            23052835,
            23052386,
            23052148,
            23052356,
            23052891,
            23052103,
            23052050,
            23052345,
            23052453,
            23052723,
            23054138,
            23052447,
            23052434
        ],
        "E": [
            23177019,
            25241753,
            23067030,
            23140409
        ]
    },
    "name": "B. Hongcow Solves A Puzzle",
    "statement": "Hongcow likes solving puzzles.One day, Hongcow finds two identical\r\npuzzle pieces, with the instructions \"make a rectangle\" next to them.\r\nThe pieces can be described by an by grid of characters, where the\r\ncharacter \u201d denotes a part of the puzzle and \u201d denotes an empty part of\r\nthe grid. It is guaranteed that the puzzle pieces are one 4-connected\r\npiece. See the input format and samples for the exact details on how a\r\njigsaw piece will be specified.The puzzle pieces are very heavy, so\r\nHongcow the puzzle pieces. However, he is allowed to move them in any\r\ndirections. The puzzle pieces also .You are given as input the\r\ndescription of one of the pieces. Determine if it is possible to make a\r\nrectangle from two identical copies of the given input. The rectangle\r\nshould be solid, i.e. there should be no empty holes inside it or on its\r\nborder. Keep in mind that Hongcow is not allowed to flip or rotate\r\npieces and they cannot overlap, i.e. no two \u201d from different pieces can\r\nshare the same position.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n#define FOR(i,n) for(int i=0;i<(n);++i)\n#define FORU(i,j,k) for(int i=(j);i<=(k);++i)\n#define FORD(i,j,k) for(int i=(j);i>=(k);--i)\n\nusing namespace std;\n\nusing lli = long long int;\nusing pll = pair<lli, lli>;\n\nconst long long int oo = 1000*1000*1000;\n\nstruct Coord\n{\n\tint x, y;\n\tCoord(int x = 0, int y = 0) : x(x), y(y) {}\n\tCoord operator + (const Coord& droite) const\n\t{\n\t\treturn Coord(x + droite.x, y + droite.y);\n\t}\n};\n\nbool grid[1000][1000];\nint minX = 1000, minY = 1000;\nint maxX, maxY;\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tFOR(i, n)\n\t\tFOR(j, m)\n\t\t{\n\t\t\tchar tmp;\n\t\t\tscanf(\" %c\", &tmp);\n\t\t\tgrid[i][j] = tmp == 'X';\n\t\t\tif(grid[i][j])\n\t\t\t{\n\t\t\t\tminX = min(minX, i);\n\t\t\t\tmaxX = max(maxX, i);\n\t\t\t\tminY = min(minY, j);\n\t\t\t\tmaxY = max(maxY, j);\n\t\t\t}\n\t\t}\n\tFORU(i, minX, maxX)\n\t\tFORU(j, minY, maxY)\n\t\t\tif(!grid[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Hongcow Solves A Puzzle.json",
    "editorial_link": "https://codeforces.com//blog/entry/49126",
    "editorial": "I really apologize for the ambiguity of this problem. We worked hard to\r\nmake it concise and accurate, but we left out too many details.\r\nBasically, the idea is we want to overlay two of these pieces together\r\nso that no square has more than 1 X, and the region of X\u00e2\u0080\u0099s forms a\r\nrectangle. Now for the solution: First, let\u00e2\u0080\u0099s look at it backwards. I\r\nhave a rectangle, and I cut it in two pieces. These two pieces have the\r\nsame exact shape. What shapes can I form? A necessary and sufficient\r\ncondition is that the piece itself is a rectangle itself! There are a\r\nfew ways to check this. One is, find the min/max x/y coordinates, and\r\nmake sure the number of X\u00e2\u0080\u0099s match the bounding box of all the points.\r\ncode\r\n"
}