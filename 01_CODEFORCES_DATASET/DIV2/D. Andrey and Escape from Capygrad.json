{
    "link": "https://codeforces.com//contest/1859/problem/D",
    "problemId": "2156544",
    "problem_idx": "D",
    "shortId": "1859D",
    "contest_number": "1859",
    "problem_submissions": {
        "F": [
            218569170,
            218581836,
            218617250,
            218736861,
            218605159
        ],
        "D": [
            218563678,
            218527706,
            218524461,
            218541850,
            218525597,
            218533314,
            218548787,
            218533112,
            218538546,
            218539655,
            218537786,
            218535818,
            218553386,
            218535886,
            218533896,
            218537893,
            218542381,
            218547154,
            218542928,
            218544612
        ],
        "C": [
            218525956,
            218512705,
            218513334,
            218516401,
            218517178,
            218520064,
            218534501,
            218519799,
            218514853,
            218522631,
            218518290,
            218523903,
            218538315,
            218515860,
            218520699,
            218536075,
            218518723,
            218526393,
            218525882,
            218528439
        ],
        "B": [
            218515214,
            218505180,
            218504011,
            218503415,
            218502676,
            218525570,
            218527334,
            218505003,
            218504876,
            218514112,
            218504039,
            218506274,
            218520756,
            218506233,
            218506628,
            218509261,
            218509278,
            218510852,
            218512080,
            218508258
        ],
        "E": [
            218512348,
            218540759,
            218543571,
            218531440,
            218546842,
            218542828,
            218514089,
            218548356,
            218551376,
            218551561,
            218551316,
            218556871,
            218531000,
            218554570,
            218561645,
            218555675,
            218563500,
            218560618,
            218560551,
            218559090
        ],
        "A": [
            218503604,
            218499919,
            218498316,
            218498529,
            218498173,
            218498480,
            218520556,
            218498189,
            218499252,
            218502725,
            218498470,
            218499540,
            218499799,
            218500335,
            218498354,
            218508385,
            218499358,
            218498918,
            218499379,
            218503053
        ]
    },
    "name": "D. Andrey and Escape from Capygrad",
    "statement": "An incident occurred in Capygrad, the capital of Tyagoland, where all\r\nthe capybaras in the city went crazy and started throwing mandarins.\r\nAndrey was forced to escape from the city as far as possible, using\r\nportals.Tyagoland is represented by a number line, and the city of\r\nCapygrad is located at point 0. There are n portals all over Tyagoland,\r\neach of which is characterised by four integers l_i, r_i, a_i and b_i (1\r\nle l_i\r\nle a_i\r\nle b_i\r\nle r_i\r\nle 10^9). Note that the segment [a_i, b_i] in the segment [l_i, r_i].If\r\nAndrey is on the segment [l_i, r_i], then the portal can teleport him to\r\nany point on the segment [a_i, b_i]. Andrey has a pass that allows him\r\nto use the portals an unlimited number of times.Andrey thinks that the\r\npoint x is on the segment [l, r] if the inequality l\r\nle x\r\nle r is satisfied.Andrey has q options for where to start his escape,\r\neach option is characterized by a single integer x_i the starting\r\nposition of the escape. He wants to escape from Capygrad as far as\r\npossible (to the point with the maximum possible coordinate). Help\r\nAndrey determine how far he could escape from Capygrad, starting at each\r\nof the q positions.\r\n",
    "solutions": [
        "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt\")\n#if defined(LOCAL) or not defined(LUOGU)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL\n#include\"dbg.h\"\n#define dbgu(...) dbg(__VA_ARGS__)\n#else\n#define dbg(...) (__VA_ARGS__)\n#define dbgu(...)\n#endif\nnamespace Fread{const int SIZE=1<<16;char buf[SIZE],*S,*T;inline char getchar(){if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return'\\n';}return *S++;}}namespace Fwrite{const int SIZE=1<<16;char buf[SIZE],*S=buf,*T=buf+SIZE;inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}inline void putchar(char c){*S++=c;if(S==T)flush();}struct NTR{~NTR(){flush();}}ztr;}\n#define getchar Fread::getchar\n#define putchar Fwrite::putchar\n#define Setprecision 15\n#define between '\\n'\ntemplate<typename T>struct is_char{static constexpr bool value=(std::is_same<T,char>::value||std::is_same<T,signed char>::value||std::is_same<T,unsigned char>::value);};template<typename T>struct is_integral_ex{static constexpr bool value=(std::is_integral<T>::value||std::is_same<T,__int128>::value)&&!is_char<T>::value;};template<typename T>struct is_floating_point_ex{static constexpr bool value=std::is_floating_point<T>::value||std::is_same<T,__float128>::value;};namespace Fastio{struct Reader{template<typename T>typename std::enable_if_t<std::is_class<T>::value,Reader&>operator>>(T&x){for(auto &y:x)*this>>y;return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1;while(c<'0'||c>'9'){if(c=='-')f*=-1;c=getchar();}x=0;while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x*=f;return *this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1,s=0;x=0;T t=0;while((c<'0'||c>'9')&&c!='-'&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else return x*=f,*this;while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Reader&>operator>>(T&c){c=getchar();while(c=='\\n'||c==' '||c=='\\r')c=getchar();return *this;}Reader&operator>>(char*str){int len=0;char c=getchar();while(c=='\\n'||c==' '||c=='\\r')c=getchar();while(c!='\\n'&&c!=' '&&c!='\\r')str[len++]=c,c=getchar();str[len]='\\0';return*this;}Reader&operator>>(std::string&str){char c=getchar();while(c=='\\n'||c==' '||c=='\\r')c=getchar();while(c!='\\n'&&c!=' '&&c!='\\r')str.push_back(c),c=getchar();return*this;}Reader(){}}cin;const char endl='\\n';struct Writer{typedef __int128 mxdouble;template<typename T>typename std::enable_if_t<std::is_class<T>::value,Writer&>operator<<(T x){for(auto &y:x)*this<<y<<between;*this<<'\\n';return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Writer&>operator<<(T x){if(x==0)return putchar('0'),*this;if(x<0)putchar('-'),x=-x;static int sta[45];int top=0;while(x)sta[++top]=x%10,x/=10;while(top)putchar(sta[top]+'0'),--top;return*this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Writer&>operator<<(T x){if(x<0)putchar('-'),x=-x;mxdouble _=x;x-=(T)_;static int sta[45];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar('0');while(top)putchar(sta[top]+'0'),--top;putchar('.');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar('0');while(top)putchar(sta[top]+'0'),--top;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Writer&>operator<<(T c){putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])putchar(str[cur++]);return *this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(std::string str){int st=0,ed=str.size();while(st<ed)putchar(str[st++]);return*this;}Writer(){}}cout;}\n#define cin Fastio::cin\n#define cout Fastio::cout\n#define endl Fastio::endl\n#define int long long\nstruct node\n{\n\tint l,r,a,b;\n};\nbool cmp(node a,node b)\n{\n\treturn a.a<b.a;\n}\nbool cmp2(node a,node b)\n{\n\treturn a.l<b.l;\n}\nmain()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>ss;\n\t\tvector<node>a(n);\n\t\tfor(int x=0;x<n;x++)\n\t\t\tcin>>a[x].l>>a[x].r>>a[x].a>>a[x].b,ss.push_back(a[x].l),ss.push_back(a[x].r),ss.push_back(a[x].a),ss.push_back(a[x].b);\n\t\tint q;\n\t\tcin>>q;\n\t\tvector<int>ques(q);\n\t\tfor(int x=0;x<q;x++)\n\t\t\tcin>>ques[x],ss.push_back(ques[x]);\n\t\tsort(a.begin(),a.end(),cmp);\n\t\tvector<node>b;\n\t\tfor(int x=0;x<n;x++)\n\t\t\tif(b.empty()||a[x].a>b.back().b)b.push_back(a[x]);\n\t\t\telse b.back().b=max(b.back().b,a[x].b),b.back().l=min(b.back().l,a[x].l),b.back().r=max(b.back().r,a[x].r);\n\t\treverse(b.begin(),b.end());\n\t\tmultiset<int>st;\n\t\tpriority_queue<pair<int,int>>pq;\n\t\tset<pair<int,int>>ans;\n\t\tans.insert({-10000000000,-10000000000});\n\t\tfor(auto q:b)\n\t\t{\n\t\t\twhile(!pq.empty()&&pq.top().first>q.b)st.erase(st.find(pq.top().second)),pq.pop();\n\t\t\tint res=q.b;\n\t\t\tif(!st.empty())res=max(res,*st.rbegin());\n\t\t\tst.insert(res);\n\t\t\tpq.push({q.l,res});\n\t\t\tans.insert({q.l,res});\n\t\t}\n\t\tfor(auto q:ques)\n\t\t\tcout<<max(q,prev(ans.upper_bound({q,10000000000}))->second)<<' ';cout<<endl;\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "dsu",
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Andrey and Escape from Capygrad.json",
    "editorial_link": "https://codeforces.com//blog/entry/119287",
    "editorial": " It is always beneficial to teleport to point .Proof:\nLet\u00e2\u0080\u0099s assume that we were able to teleport from point to the right of ,\nbut not from . Then we used some segment that covers point , but does\nnot cover point , and ends to the right of . This is a contradiction.Let\nbe the maximum coordinate we can reach while being on segment , and let\nbe the answer to the -th query. Then we notice that the answer to query\n.We will use the scanline method from the end. Events: , , , .We notice\nthat events of type are not important to us when scanning from the end\n(according to statement number 1). It is important for us that we\nprocess events of type first, then events of type , and then events of\ntype (closing the segment in the scanline).We will go through the events\nof the scanline, processing them in the order of , then events of type ,\nand then events of type .We assume that there is a data structure that\nallows us to add elements, remove elements, and quickly output the\nmaximum. For each event of type , update the value of take the maximum\nvalue of of all open segments from the structure. For each event of type\n, update the value of take the maximum value of of all open segments\nfrom the structure, as well as . For each event of type , remove from\nthe structure. We notice that to solve this problem, we can use the\nstd::multiset} container, which automatically sorts elements in\nascending order. We can store in of all open segments. And then, when\nprocessing events, extract the maximum from , all operations are\nperformed in . This allows us to solve the problem in time and memory.\n"
}