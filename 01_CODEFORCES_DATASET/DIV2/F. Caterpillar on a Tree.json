{"link": "https://codeforces.com//contest/1918/problem/F", "problemId": "2452576", "problem_idx": "F", "shortId": "1918F", "contest_number": "1918", "problem_submissions": {"G": [244132893, 245985475, 244948797, 244948670], "F": [244120772, 244125092, 244126848, 244126771, 244130168, 244131697, 244138260, 244138344, 244139263, 244138435, 244141669, 244144124, 244142227, 244122678, 244157073, 244156595, 244332251, 244124771, 244360495, 244129898], "D": [244109167, 244099156, 244092966, 244101787, 244100881, 244108481, 244101721, 244106486, 244109529, 244104916, 244106995, 244113590, 244113865, 244099423, 244110295, 244096244, 244108027, 244103663, 244360463, 244108155], "E": [244103507, 244108050, 244110113, 244110472, 244112287, 244124161, 244125655, 244123391, 244119446, 244125406, 244135128, 244134725, 244128795, 244112679, 244118320, 244116217, 244928601, 244928561], "C": [244091247, 244087599, 244079342, 244087694, 244092782, 244089213, 244094187, 244089808, 244094684, 244096501, 244097023, 244099017, 244107490, 244085730, 244089866, 244086764, 244094953, 244095107, 244360406, 244091142], "B": [244083801, 244076050, 244075794, 244073267, 244075602, 244075619, 244082026, 244079074, 244080512, 244082819, 244079063, 244082004, 244078089, 244075054, 244078156, 244075906, 244081851, 244083244, 244360342, 244080338], "A": [244083099, 244071431, 244072186, 244071210, 244070855, 244071315, 244075506, 244071630, 244072257, 244074358, 244071939, 244071253, 244071114, 244071560, 244071154, 244071990, 244074495, 244089579, 244360312, 244073174]}, "name": "F. Caterpillar on a Tree", "statement": "The caterpillar decided to visit every node of the tree. Initially, it\r\nis sitting at the root.The tree is represented as a rooted tree with the\r\nroot at the node 1. Each crawl to a neighboring node takes 1 minute for\r\nthe caterpillar. And there is a trampoline under the tree. If the\r\ncaterpillar detaches from the tree and falls onto the trampoline, it\r\nwill end up at the root of the tree in 0 seconds. But the trampoline is\r\nold and can withstand no more than k caterpillar\u2019s falls.What is the\r\nminimum time the caterpillar can take to visit all the nodes of the\r\ntree?More formally, we need to find the minimum time required to visit\r\nall the nodes of the tree, if the caterpillar starts at the root\r\n(node 1) and moves using two methods. Crawl along an edge to one of the\r\nneighboring nodes: takes 1 minute. Teleport to the root: takes no time,\r\nno new nodes become visited. The second method (teleportation) can be\r\nused at most k times. The caterpillar can finish the journey at any\r\nnode.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define endl '\\n'\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, k, ans;\nint fa[N];\nint tot, dfn[N], rev[N], sz[N];\nbool vis[N];\nvector<int> e[N];\nvoid dfs(int u){\n\tsz[u] = 1;\n\trev[dfn[u] = ++tot] = u;\n\tfor (int v : e[u]){\n\t\tdfs(v);\n\t\tsz[u] += sz[v];\n\t}\n}\nstruct tree{\n#define mid ((l + r) >> 1)\n#define ls (now << 1)\n#define rs (now << 1 | 1)\n\tint a[N << 2], tag[N << 2];\n\tvoid up(int now){\n\t\ta[now] = min(a[ls], a[rs]);\n\t}\n\tvoid update(int now, int k){\n\t\ta[now] += k;\n\t\ttag[now] += k;\n\t}\n\tvoid down(int now){\n\t\tif (tag[now] == 0) return;\n\t\tupdate(ls, tag[now]);\n\t\tupdate(rs, tag[now]);\n\t\ttag[now] = 0;\n\t}\n\tvoid add(int now, int l, int r, int s, int t, int k){\n\t\tif (s <= l && r <= t)\n\t\t\treturn update(now, k);\n\t\tdown(now);\n\t\tif (s <= mid) add(ls, l, mid, s, t, k);\n\t\tif (t > mid) add(rs, mid + 1, r, s, t, k);\n\t\tup(now);\n\t}\n\tpair<int, int> askmn(int now, int l, int r){\n\t\tif (l == r) return {l, a[now]};\n\t\tdown(now);\n\t\tif (a[ls] == a[now]) return askmn(ls, l, mid);\n\t\telse return askmn(rs, mid + 1, r);\n\t}\n}T;\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out2.txt\", \"w\", stdout);\n\tcin >> n >> k;\n\tans = 2 * (n - 1);\n\tk++;\n\tfor (int i = 2; i <= n; i++){\n\t\tcin >> fa[i];\n\t\te[fa[i]].push_back(i);\n\t}\n\tdfs(1);\n\tfor (int i = 2; i <= n; i++)\n\t\tT.add(1, 1, n, dfn[i], dfn[i] + sz[i] - 1, -1);\n\tvis[1] = 1;\n\twhile (k--){\n\t\tauto [u, delta] = T.askmn(1, 1, n);\n\t\tans += delta;\n\t\tu = rev[u];\n\t\tif (vis[u]) break;\n\t\tfor (; !vis[u]; u = fa[u]){\n\t\t\tT.add(1, 1, n, dfn[u], dfn[u] + sz[u] - 1, 2);\n\t\t\tvis[u] = 1;\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "greedy", "implementation", "sortings", "trees"], "dificulty": "2500", "interactive": false}