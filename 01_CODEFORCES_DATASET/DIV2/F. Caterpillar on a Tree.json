{
    "link": "https://codeforces.com//contest/1918/problem/F",
    "problemId": "2452576",
    "problem_idx": "F",
    "shortId": "1918F",
    "contest_number": "1918",
    "problem_submissions": {
        "G": [
            244132893,
            245985475,
            244948797,
            244948670
        ],
        "F": [
            244120772,
            244125092,
            244126848,
            244126771,
            244130168,
            244131697,
            244138260,
            244138344,
            244139263,
            244138435,
            244141669,
            244144124,
            244142227,
            244122678,
            244157073,
            244156595,
            244332251,
            244124771,
            244360495,
            244129898
        ],
        "D": [
            244109167,
            244099156,
            244092966,
            244101787,
            244100881,
            244108481,
            244101721,
            244106486,
            244109529,
            244104916,
            244106995,
            244113590,
            244113865,
            244099423,
            244110295,
            244096244,
            244108027,
            244103663,
            244360463,
            244108155
        ],
        "E": [
            244103507,
            244108050,
            244110113,
            244110472,
            244112287,
            244124161,
            244125655,
            244123391,
            244119446,
            244125406,
            244135128,
            244134725,
            244128795,
            244112679,
            244118320,
            244116217,
            244928601,
            244928561
        ],
        "C": [
            244091247,
            244087599,
            244079342,
            244087694,
            244092782,
            244089213,
            244094187,
            244089808,
            244094684,
            244096501,
            244097023,
            244099017,
            244107490,
            244085730,
            244089866,
            244086764,
            244094953,
            244095107,
            244360406,
            244091142
        ],
        "B": [
            244083801,
            244076050,
            244075794,
            244073267,
            244075602,
            244075619,
            244082026,
            244079074,
            244080512,
            244082819,
            244079063,
            244082004,
            244078089,
            244075054,
            244078156,
            244075906,
            244081851,
            244083244,
            244360342,
            244080338
        ],
        "A": [
            244083099,
            244071431,
            244072186,
            244071210,
            244070855,
            244071315,
            244075506,
            244071630,
            244072257,
            244074358,
            244071939,
            244071253,
            244071114,
            244071560,
            244071154,
            244071990,
            244074495,
            244089579,
            244360312,
            244073174
        ]
    },
    "name": "F. Caterpillar on a Tree",
    "statement": "The caterpillar decided to visit every node of the tree. Initially, it\r\nis sitting at the root.The tree is represented as a rooted tree with the\r\nroot at the node 1. Each crawl to a neighboring node takes 1 minute for\r\nthe caterpillar. And there is a trampoline under the tree. If the\r\ncaterpillar detaches from the tree and falls onto the trampoline, it\r\nwill end up at the root of the tree in 0 seconds. But the trampoline is\r\nold and can withstand no more than k caterpillar’s falls.What is the\r\nminimum time the caterpillar can take to visit all the nodes of the\r\ntree?More formally, we need to find the minimum time required to visit\r\nall the nodes of the tree, if the caterpillar starts at the root\r\n(node 1) and moves using two methods. Crawl along an edge to one of the\r\nneighboring nodes: takes 1 minute. Teleport to the root: takes no time,\r\nno new nodes become visited. The second method (teleportation) can be\r\nused at most k times. The caterpillar can finish the journey at any\r\nnode.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define endl '\\n'\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, k, ans;\nint fa[N];\nint tot, dfn[N], rev[N], sz[N];\nbool vis[N];\nvector<int> e[N];\nvoid dfs(int u){\n\tsz[u] = 1;\n\trev[dfn[u] = ++tot] = u;\n\tfor (int v : e[u]){\n\t\tdfs(v);\n\t\tsz[u] += sz[v];\n\t}\n}\nstruct tree{\n#define mid ((l + r) >> 1)\n#define ls (now << 1)\n#define rs (now << 1 | 1)\n\tint a[N << 2], tag[N << 2];\n\tvoid up(int now){\n\t\ta[now] = min(a[ls], a[rs]);\n\t}\n\tvoid update(int now, int k){\n\t\ta[now] += k;\n\t\ttag[now] += k;\n\t}\n\tvoid down(int now){\n\t\tif (tag[now] == 0) return;\n\t\tupdate(ls, tag[now]);\n\t\tupdate(rs, tag[now]);\n\t\ttag[now] = 0;\n\t}\n\tvoid add(int now, int l, int r, int s, int t, int k){\n\t\tif (s <= l && r <= t)\n\t\t\treturn update(now, k);\n\t\tdown(now);\n\t\tif (s <= mid) add(ls, l, mid, s, t, k);\n\t\tif (t > mid) add(rs, mid + 1, r, s, t, k);\n\t\tup(now);\n\t}\n\tpair<int, int> askmn(int now, int l, int r){\n\t\tif (l == r) return {l, a[now]};\n\t\tdown(now);\n\t\tif (a[ls] == a[now]) return askmn(ls, l, mid);\n\t\telse return askmn(rs, mid + 1, r);\n\t}\n}T;\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out2.txt\", \"w\", stdout);\n\tcin >> n >> k;\n\tans = 2 * (n - 1);\n\tk++;\n\tfor (int i = 2; i <= n; i++){\n\t\tcin >> fa[i];\n\t\te[fa[i]].push_back(i);\n\t}\n\tdfs(1);\n\tfor (int i = 2; i <= n; i++)\n\t\tT.add(1, 1, n, dfn[i], dfn[i] + sz[i] - 1, -1);\n\tvis[1] = 1;\n\twhile (k--){\n\t\tauto [u, delta] = T.askmn(1, 1, n);\n\t\tans += delta;\n\t\tu = rev[u];\n\t\tif (vis[u]) break;\n\t\tfor (; !vis[u]; u = fa[u]){\n\t\t\tT.add(1, 1, n, dfn[u], dfn[u] + sz[u] - 1, 2);\n\t\t\tvis[u] = 1;\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy",
        "implementation",
        "sortings",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Caterpillar on a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/125300",
    "editorial": "TutorialFirst, it can be noticed that it is enough to visit all the\r\nleaves of the tree. After all, if the caterpillar skips some internal\r\nnode, then it will not be able to reach the subtree of this node and\r\nvisit the leaves in it. Therefore, it makes no sense to teleport to the\r\nroot from a non-leaf (otherwise it would be more profitable to move to\r\nthe root earlier, and all the leaves would remain visited).The optimal\r\npath of the caterpillar on the tree can be divided into movements from\r\nthe root to a leaf, movements from one leaf to another, and\r\nteleportations from a leaf to the root. Let the order of visiting the\r\nleaves in the optimal path be fixed. Then it makes no sense to teleport\r\nfrom the last leaf, as all the leaves have already been visited. In\r\naddition, it is not profitable to move not along the shortest path in\r\nthe sections of transition from the root to a leaf without visiting\r\nother leaves, or in movements from one leaf to another without visiting\r\nother leaves. If the leaf is visited after the leaf , then teleporting\r\nfrom saves time of transition from to minus the time of moving to from\r\nthe root. It is possible to choose leaves, without the last visited\r\nleaf, which give the maximum savings (if there are fewer leaves in the\r\ntree, or the savings become negative, then take fewer than leaves), and\r\nteleport from them. Thus, if the order of visiting the leaves is known,\r\nthe optimal time can be found.It turns out that if you take the tree and\r\nsort the children of each node in ascending (not descending) order of\r\nthe depth of the subtree, and then write down all the leaves from left\r\nto right (in depth-first order), then this will be one of the optimal\r\nleaf orders. This order of sorting the tree and its leaves will be\r\ncalled the order of sorting by the subtree depth.The tree can be sorted\r\nin this way in one depth-first traversal. For each leaf, it is possible\r\nto calculate how much time teleporting from it saves. To do this, it is\r\nenough to move from this leaf to the root until the first node, for\r\nwhich the previous node is not the rightmost child. Then the savings are\r\nthe length of the path traveled minus the remaining distance to the\r\nroot. Such paths for different leaves do not intersect along the edges,\r\nand the remaining distance to the root can be precalculated in a\r\ndepth-first search for all nodes at once. Therefore, the algorithm works\r\nin time, where the logarithm arises from sorting the children of each\r\nnode by the depth of the subtree.Theorem.There exists a shortest route\r\nfor the caterpillar, in which the leaves are visited in the order of\r\nsorting the children of each node by the depth of the subtree. ProofLet\r\nbe all the leaves of the tree in the order that will result if the\r\nchildren of each node are sorted in ascending order of the depth of the\r\nsubtree. Consider the shortest route of the caterpillar visiting all the\r\nnodes of the tree. Let be the leaves of the tree, in the order of\r\nvisiting in this route. Consider the maximum prefix of leaves that\r\ncoincides with the order of sorting by the depth of the subtree: . If ,\r\nthen the theorem is proven. Now, letâs assume that the next leaf is the\r\nincorrect leaf .The goal is to change the route in such a way that the\r\ntime of traversing the tree does not increase, so that the first visited\r\nleaves do not change and remain in the same order, and so that the leaf\r\nis encountered earlier in the route than before the change. Then it is\r\npossible to move the leaf to its (iâ+â1)s place, while maintaining the\r\norder of the first visited leaves. Then, in the same way, one can put\r\nall the leaves in their places one by one and get the shortest route of\r\nthe caterpillar with the desired order of visiting leaves.Lemma.Let the\r\nnode be the ancestor of the node . Let the caterpillar in the shortest\r\nroute on the tree crawl from to . Then the caterpillar enters the\r\nsubtree of the node only once, traverses this subtree depth-first, and\r\nreturns to .Proof of the lemma.If the caterpillar crawls from to only\r\nonce, then it cannot leave the subtree of until all the nodes in this\r\nsubtree are visited, and it cannot jump on a trampoline, as it still\r\nneeds to move from to . All this cannot be done faster than the number\r\nof steps equal to twice the number of nodes in the subtree of , because\r\nthe caterpillar needs to reach each node via an edge from the ancestor\r\nand to return to the ancestor. And any route without teleportations,\r\nwhich uses each edge twice, is one of the depth-first traversals.If the\r\ncaterpillar crawls from to two or more times, then the route can be\r\nshortened, as shown in figure.The lemma is proven.At the moment, the\r\nleaf lies in the order of visiting the leaves in the optimal route of\r\nthe caterpillar in the place of the leaf . The goal is to move the leaf\r\ncloser to the beginning of the route, without changing the first visited\r\nleaves: .Let be the least common ancestor of the leaves and , let be the\r\nchild of , in the subtree of which the node is located, and be the child\r\nof , in the subtree of which the node is located, as shown in figure. To\r\nmove the leaf closer to the beginning of the route, let us consider\r\ncases.Case 1: The caterpillar in the current version of the optimal\r\nroute crawls from to .In this case, according to the lemma, the\r\ncaterpillar enters the subtree of vertex only once, and traverses it in\r\nthe depth-first manner before returning to . There are no leaves in the\r\nsubtree of , because all the leaves of the subtree of are visited\r\nconsecutively during the depth-first traversal, and the leaf not from\r\nthe subtree of is visited after , but before . Then the route can be\r\nchanged as follows: the cycle is cut out from where it is located, and\r\ninserted at the moment of the first visit to after the visit to the leaf\r\n. The leaf is not in the subtree of the node , because the subtree of\r\nhas a smaller depth ( is earlier in the desired leaf order than ), and\r\nthere are still unvisited leaves in it. Then, before entering , the\r\ncaterpillar will have to come from the leaf to the node , and at that\r\nmoment a depth-first traversal of the subtree of with the visit to the\r\nleaf will occur. This traversal was moved to an earlier time, before\r\nvisiting , which means that in the order of visiting the leaves in the\r\ncaterpillarâs route, the leaf has been moved closer to the\r\nbeginning.Case 2: The caterpillar in the current version of the optimal\r\nroute does not crawl from to , but crawls from to .Then the entire\r\nsubtree of is traversed in a depth-first traversal. Since the leaf is\r\nearlier in the desired order than , the subtree of is deeper than the\r\nsubtree of , and in the desired order all the leaves of come after .\r\nMoreover, since the caterpillar does not crawl from to , it is\r\nimpossible to leave the subtree of except by teleporting to the root.\r\nThe last jump on the trampoline from the subtree of the node is\r\nconsidered (or stopping at the end of the route). At this moment, all\r\nthe leaves of the subtree of are visited. The route can be changed as\r\nfollows: cut out the depth-first traversal of the subtree of , cancel\r\nthe last jump or stop in the subtree of , descend from there to ,\r\nperform a depth-first traversal of the subtree of in such a way that the\r\ndeepest node of this subtree is visited last, and teleport to the root\r\n(or stop at the end of the route). This will not be longer, because a\r\nsection of transition from a leaf in the subtree of to has been added,\r\nand a section of movement from the deepest leaf in the subtree of to has\r\ndisappeared, here it is important that the subtree of is deeper than the\r\nsubtree of . And the node has become closer to the beginning of the list\r\nof visited leaves, because all the leaves of the subtree of , including\r\n, have moved somewhere after all the leaves of the subtree of .Case 3:\r\nThe caterpillar in the current version of the optimal route does not\r\ncrawl either from to , nor from to .Then all the sections of the route\r\nthat move into the subtrees of the nodes and do not leave these subtrees\r\nand end with teleportation to the root or stopping at the end of the\r\nroute. Among them, there is a section that starts with a step from to ,\r\nin which the leaf is visited, and a section that starts with a step from\r\nto , in which the leaf is visited. In the current route, the section\r\nwith comes earlier. The route can be changed very simply: swap the\r\nsection visiting the leaf and the section visiting the leaf . If both\r\nsections end with teleportations, then a correct caterpillar route will\r\nresult. If the caterpillar stopped at the end of the section visiting ,\r\nand teleported to the root from the section with , then now it will\r\nteleport after completing the section with and stop at the end of the\r\nsection with . The positions of the leaves in the route will not change:\r\nthey are not in the subtree of , and they are not in the section with ,\r\nvisited after . And the leaf will get a place closer to the beginning in\r\nthe order of visiting the leaves, because the section with its visit now\r\noccurs earlier in the route.In all cases, it was possible to move the\r\nleaf in the optimal route of the caterpillar closer to the beginning,\r\nwhile maintaining the order of the first visited leaves, which means\r\nthat there exists an optimal route of the caterpillar in which the\r\nleaves are visited in the order of sorting the subtrees of the tree by\r\ndepth. The theorem is proven.\r\n",
    "hint": []
}