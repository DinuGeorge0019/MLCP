{
    "link": "https://codeforces.com//contest/9/problem/D",
    "problemId": "40",
    "problem_idx": "D",
    "shortId": "9D",
    "contest_number": "9",
    "problem_submissions": {
        "E": [
            39868,
            40035,
            40397,
            39920,
            40525,
            40255,
            40364,
            40918,
            40916,
            40907,
            40905,
            40903,
            40902,
            40887,
            40883,
            40881
        ],
        "B": [
            39322,
            39157,
            39182,
            39065,
            39109,
            39103,
            39519,
            39212,
            39094,
            39095,
            39125,
            39498,
            39287
        ],
        "D": [
            39225,
            39357,
            39494,
            39241,
            39384,
            39662,
            39771,
            39508,
            39555,
            39543,
            2827312,
            39714,
            38998,
            39881
        ],
        "C": [
            38999,
            38924,
            39161,
            38963,
            38893,
            38846,
            39594,
            38953,
            38868,
            38709,
            38839,
            39133,
            38862
        ],
        "A": [
            38708,
            38736,
            38719,
            38706,
            38745,
            38722,
            39296,
            38845,
            38717,
            38803,
            38714,
            39067,
            38711
        ]
    },
    "name": "D. How many trees ",
    "statement": "In one very old text file there was written Great Wisdom. This Wisdom\r\nwas so Great that nobody could decipher it, even Phong the oldest among\r\nthe inhabitants of Mainframe. But still he managed to get some\r\ninformation from there. For example, he managed to learn that User\r\nlaunches games for pleasure and then terrible Game Cubes fall down on\r\nthe city, bringing death to those modules, who cannot win the game...For\r\nsure, as guard Bob appeared in Mainframe many modules stopped fearing\r\nGame Cubes. Because Bob (as he is alive yet) has never been defeated by\r\nUser, and he always meddles with Game Cubes, because he is programmed to\r\nthis.However, unpleasant situations can happen, when a Game Cube falls\r\ndown on Lost Angles. Because there lives a nasty virus Hexadecimal, who\r\nis... mmm... very strange. And she likes to play very much. So,\r\nwilly-nilly, Bob has to play with her first, and then with User.This\r\ntime Hexadecimal invented the following entertainment: Bob has to leap\r\nover binary search trees with nodes. We should remind you that a binary\r\nsearch tree is a binary tree, each node has a distinct key, for each\r\nnode the following is true: the left sub-tree of a node contains only\r\nnodes with keys less than the node’s key, the right sub-tree of a node\r\ncontains only nodes with keys greater than the node’s key. All the keys\r\nare different positive integer numbers from to . Each node of such a\r\ntree can have up to two children, or have no children at all (in the\r\ncase when a node is a leaf).In Hexadecimal’s game all the trees are\r\ndifferent, but the height of each is not lower than . In this problem\r\nheight stands for the maximum amount of nodes on the way from the root\r\nto the remotest leaf, the root node and the leaf itself included. When\r\nBob leaps over a tree, it disappears. Bob gets the access to a Cube,\r\nwhen there are no trees left. He knows how many trees he will have to\r\nleap over in the worst case. And you?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n//\tfreopen(\"\", \"rt\", stdin);\n//\tfreopen(\"\", \"wt\", stdout);\n\tlong long ans[40][40] = {0};\n\tint n, h;\n\tcin >> n >> h;\n\tfor (int i = 0; i <= n; ++i)\n\t\tans[0][i] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t{\n\t\t\tfor (int n1 = 0; n1 < i; ++n1)\n\t\t\t\tans[i][j] += ans[n1][j-1] * ans[i - n1 - 1][j-1];\n//\t\t\tcout << ans[i][j] << ' ';\n\t\t}\n//\t\tcout << '\\n';\n\t}\n\tcout << ans[n][n] - ans[n][h-1];\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. How many trees .json",
    "editorial_link": "https://codeforces.com//blog/entry/283",
    "editorial": "Denote by tnh the number of binary search trees on n nodes with height equal to h. We will derive a recurrent formula for tnh. For the base case note that t00?=?1 (empty tree), and ti0?=?t0i?=?0 if i>0.\n\nNow take any binary search tree on n nodes with height equal to h. Let m be the number written at its root, 1???m???n. The left subtree is a binary search tree on m-1 nodes, and the right subtree is a binary search tree on n-m nodes. The maximal of their heights must be equal to h-1. Consider 2 subcases:\n1. The height of the left subtree is equal to h-1. There are tm?-?1,?h?-?1 such trees. The right subtree can have any height from 0 to h-1, so there are  such trees. Since we can choose left and right subtrees independently, we have  variants in this case.\n2. The height of the left subtree is less than h-1. There are  such trees, and the right subtree must have height exactly h-1, which gives us totally  variants.\nSo the recurrent formula is the following: .\n\nAll the values tnh can be calculated by dynamic programming. The answer, then, is .",
    "hint": []
}