{
    "link": "https://codeforces.com//contest/518/problem/C",
    "problemId": "22988",
    "problem_idx": "C",
    "shortId": "518C",
    "contest_number": "518",
    "problem_submissions": {
        "C": [
            9988883,
            9986333,
            9990862,
            9987399,
            9998129,
            9989956,
            9985416,
            9991301,
            9988773,
            9987777,
            9986792,
            9990874,
            9996855,
            9993083,
            9991646,
            9993492,
            9989796
        ],
        "B": [
            9986603,
            9991969,
            9985412,
            9984010,
            9991935,
            9983836,
            9985675,
            9984464,
            9984814,
            9987730,
            9987512,
            9987182,
            9990867,
            9988157,
            9985156,
            9986048
        ],
        "D": [
            9984146,
            9987656,
            9983589,
            9996581,
            9988389,
            9983991,
            10019512,
            9994388,
            9990798,
            9998733,
            9989910,
            9992602,
            9994055,
            9988668,
            9997395,
            9994329,
            10003029
        ],
        "A": [
            9982691,
            9984919,
            9983532,
            9982857,
            9984890,
            9982599,
            9983377,
            9983139,
            9982876,
            10006211,
            9984273,
            10016035,
            9996459,
            9986695,
            9983905
        ],
        "F": [
            9995207,
            10007934
        ],
        "E": [
            10000287,
            10002761,
            10005947,
            10001378,
            9999399,
            10002023,
            10011774
        ]
    },
    "name": "C. Anya and Smartphone",
    "statement": "Anya has bought a new smartphone that uses operating system. The\r\nsmartphone menu has exactly applications, each application has its own\r\nicon. The icons are located on different screens, one screen contains\r\nicons. The icons from the first to the -th one are located on the first\r\nscreen, from the -th to the -th ones are on the second screen and so on\r\n(the last screen may be partially empty).Initially the smartphone menu\r\nis showing the screen number . To launch the application with the icon\r\nlocated on the screen , Anya needs to make the following gestures: first\r\nshe scrolls to the required screen number , by making gestures (if the\r\nicon is on the screen ), and then make another gesture press the icon of\r\nthe required application exactly once to launch it.After the application\r\nis launched, the menu returns to the first screen. That is, to launch\r\nthe next application you need to scroll through the menu again starting\r\nfrom the screen number .All applications are numbered from to . We know\r\na certain order in which the icons of the applications are located in\r\nthe menu at the beginning, but it changes as long as you use the\r\noperating system. is intelligent system, so it changes the order of the\r\nicons by moving the more frequently used icons to the beginning of the\r\nlist. Formally, right after an application is launched, Berdroid swaps\r\nthe application icon and the icon of a preceding application (that is,\r\nthe icon of an application on the position that is smaller by one in the\r\norder of menu). The preceding icon may possibly be located on the\r\nadjacent screen. The only exception is when the icon of the launched\r\napplication already occupies the first place, in this case the icon\r\narrangement doesn\u2019t change.Anya has planned the order in which she will\r\nlaunch applications. How many gestures should Anya make to launch the\r\napplications in the planned order? Note that one application may be\r\nlaunched multiple times.\r\n",
    "solutions": [
        "#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nint a[111111],p[111111];\nint main()\n{\n    int i,j,k;\n    int n,m,d;\n    cin>>n>>m>>d;\n    for (i=0;i<n;i++)\n    {\n        cin>>a[i];\n        p[a[i]]=i;\n    }\n    ll ans=0;\n    for (i=0;i<m;i++)\n    {\n        int c;\n        cin>>c;\n        ans+=(ll)((p[c]/d)+1);\n        if (p[c]==0)continue;\n        int x=a[p[c]],y=a[p[c]-1];\n        //p[7]=6  a[6]=7 a[6-1]=a[5]=6\n        //a[5]=7 a[6]=6\n        //p[7]=5 p[6]=6\n        swap(a[p[c]],a[p[c]-1]);\n        swap(p[x],p[y]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n            "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Anya and Smartphone.json",
    "editorial_link": "https://codeforces.com//blog/entry/16598",
    "editorial": "To solve this problem we will store two arrays \u0097 a[] and pos[]. In array a[] will store current order of icons, i. e. in a[i] store number of application, icon which stay on position i. In array pos[] will store on which place in list stays icons, i. e. in pos[i] store in which position of array a[] stay icon of application number i. We will count answer in variable ans.\n\nLet's iterate on applications which we need to open. Let current application has number num. Then to ans we need add (pos[num]?/?k?+?1). Now, if icon of application number num doesn't stay on first position in list of applications, we make the following \u0097 swap a[pos[num]] and a[pos[num]?-?1] and update values in array pos[] for indexes of two icons which numbers a[pos[num]] and a[pos[num]?-?1] ."
}