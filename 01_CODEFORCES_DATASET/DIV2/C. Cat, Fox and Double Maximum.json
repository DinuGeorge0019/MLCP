{
    "link": "https://codeforces.com//contest/1973/problem/C",
    "problemId": "2652012",
    "problem_idx": "C",
    "shortId": "1973C",
    "contest_number": "1973",
    "problem_submissions": {
        "F": [
            261463251,
            261436494,
            261787514
        ],
        "D": [
            261394881,
            261402242,
            261380949,
            261382024,
            261382530,
            261387010,
            261390196,
            261382271,
            261387986,
            261384447,
            261402787,
            261386421,
            261427816,
            261407792,
            261395337,
            261376975,
            261379252,
            261380684,
            261382950
        ],
        "E": [
            261381347,
            261382046,
            261401618,
            261402013,
            261401999,
            261406109,
            261402299,
            261407866,
            261402896,
            261405986,
            261394102,
            261405366,
            261389878,
            261408472,
            261404774,
            261590660
        ],
        "C": [
            261360567,
            261360988,
            261363426,
            261364691,
            261354543,
            261360787,
            261363933,
            261369573,
            261365792,
            261367077,
            261359236,
            261367488,
            261357141,
            261374894,
            261387975,
            261359851,
            261363374,
            261357155
        ],
        "B": [
            261348324,
            261350288,
            261353838,
            261351331,
            261349040,
            261350145,
            261349881,
            261347862,
            261350513,
            261350776,
            261350235,
            261356753,
            261350384,
            261354721,
            261390204,
            261350344,
            261351974,
            261347066
        ],
        "A": [
            261346207,
            261346661,
            261348023,
            288952169,
            261346140,
            261346181,
            261346010,
            261346089,
            261345101,
            261344789,
            261344990,
            261346630,
            261346138,
            261346691,
            261348987,
            261391373,
            261346139,
            261346040,
            261349777
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129556",
    "editorial": "Solution:We can easily prove that the sequence can have at most local\r\nmaximums, because the corner elements can\u00e2\u0080\u0099t be the local maximums and no\r\ntwo consecutive elements can be local maximums. Let\u00e2\u0080\u0099s see how we can\r\nachieve this upper bound.Let\u00e2\u0080\u0099s consider the case when is at odd position\r\nin the original array first. We will construct a permutation such that\r\nthe resulting array will have local maximums at all the odd positions\r\nexcept the first one. We can do this by placing the numbers at the odd\r\nindexes in , giving the bigger numbers to the indexes with smaller , and\r\nplacing the numbers at the even indexes in , giving the smaller numbers\r\nto the indexes with bigger . Then since belongs to an odd index, the for\r\neach odd will be at least while the for each even will be at most . So\r\nevery element of at odd position, except for the corner, will be a local\r\nmaximum. This means we will have local maximums, which is optimal, as we\r\nnoitced above.We can get the solution for the case when is at even\r\nposition analogously. For example, by reversing the permutation ,\r\ncalculating the right permutation , reversing them again and printing\r\nthis as the answer.Time complexity: because of sorting. Actually, since\r\nyou are sorting a permutation, you can do it in just but it\u00e2\u0080\u0099s not\r\nnecessary.Implementation in C++: 261999352\r\n",
    "name": "C. Cat, Fox and Double Maximum",
    "statement": "You are given an positive integer n and a permutation^\r\ndagger p of length n. The score of another permutation q of length n is\r\nthe number of in the array a of length n, where a_i = p_i + q_i for all\r\ni (1\r\nle i\r\nle n). In other words, the score of q is the number of i such that 1 < i\r\n< n (note the inequalities), a_{i-1} < a_i, and a_i > a_{i+1} (once\r\nagain, note the strict inequalities). Find the permutation q that\r\nachieves the maximum score for given n and p. If there exist multiple\r\nsuch permutations, you can pick any of them.^\r\ndagger A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;int n,p[200100],q[200100];#define pb push_backvoid sol(){    scanf(\"%d\",&n);int w=0;    for(int i=1;i<=n;i++){        q[i]=0;        scanf(\"%d\",&p[i]);        if(p[i]==1)w=i;    }    if(w&1){        //\u8b93\u5076\u6578\u4e0a        vector<int>po;        for(int i=2;i<n;i+=2)po.pb(i);        sort(po.begin(),po.end(),[&](int x,int y){return p[x]<p[y];});        int l=1,r=n;        for(int x:po)q[x]=r--;po.clear();        for(int i=1;i<n;i+=2)po.pb(i);        sort(po.begin(),po.end(),[&](int x,int y){return p[x]>p[y];});        for(int x:po)q[x]=l++;        for(int i=1;i<=n;i++)if(!q[i])q[i]=l++;    }    else{        vector<int>po;        for(int i=3;i<n;i+=2)po.pb(i);        sort(po.begin(),po.end(),[&](int x,int y){return p[x]<p[y];});        int l=1,r=n;        for(int x:po)q[x]=r--;po.clear();        for(int i=2;i<=n;i+=2)po.pb(i);        sort(po.begin(),po.end(),[&](int x,int y){return p[x]>p[y];});        for(int x:po)q[x]=l++;        for(int i=1;i<=n;i++)if(!q[i])q[i]=l++;    }    for(int i=1;i<=n;i++)printf(\"%d \",q[i]);puts(\"\");}int main(){    int T;scanf(\"%d\",&T);while(T--)sol();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Cat, Fox and Double Maximum.json"
}