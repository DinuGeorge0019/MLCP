{
    "link": "https://codeforces.com//contest/1325/problem/C",
    "problemId": "561455",
    "problem_idx": "C",
    "shortId": "1325C",
    "contest_number": "1325",
    "problem_submissions": {
        "E": [
            73269401,
            73332152,
            73299753,
            73395378,
            73360091,
            73360008
        ],
        "F": [
            73248978,
            73251409,
            73254927,
            73256076,
            73255610,
            73257423,
            73262364,
            73259512,
            73356282,
            73356144,
            73263300,
            73263158,
            73261258,
            73265350,
            73262400,
            73265312,
            73263991,
            73268889,
            73270937
        ],
        "D": [
            73244100,
            73243574,
            73240330,
            73242761,
            73241884,
            73241409,
            73246071,
            73252259,
            73251009,
            73248948,
            73245139,
            73243278,
            73250903,
            73243449,
            73248645,
            73246841,
            73242067
        ],
        "C": [
            73236055,
            73236410,
            73233326,
            73229143,
            73233805,
            73246561,
            73234913,
            73236946,
            73236155,
            73241716,
            73237967,
            73239330,
            73240506,
            73236929,
            73231917,
            73233819,
            73237479
        ],
        "B": [
            73227966,
            73225855,
            73227806,
            73223000,
            73224291,
            73227411,
            73226586,
            73225151,
            73229505,
            73230477,
            73228144,
            73229165,
            73230081,
            73251563,
            73223597,
            73227071,
            73225379
        ],
        "A": [
            73222798,
            73222976,
            73224188,
            73222275,
            73222466,
            73223833,
            73222584,
            73222533,
            73226908,
            73225662,
            73224126,
            73224793,
            73228118,
            73227876,
            73225812,
            73222400,
            73222615
        ]
    },
    "name": "C. Ehab and Path-etic MEXs",
    "statement": "You are given a tree consisting of n nodes. You want to write some\r\nlabels on the tree’s edges such that the following conditions hold:\r\nEvery label is an integer between 0 and n-2 inclusive. All the written\r\nlabels are distinct. The largest value among MEX(u,v) over all pairs of\r\nnodes (u,v) is as small as possible. Here, MEX(u,v) denotes the smallest\r\nnon-negative integer that isn’t written on any edge on the unique simple\r\npath from node u to node v.\r\n",
    "solutions": [
        "///BE NAME KHODA\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define S second\n#define F first\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxn = 3e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nint n, m;\nint a[maxn];\nvector<int> g[maxn];\nvector<pair<int,int>> edge;\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n;\n    fill(a,a+maxn,-1);\n    for(int i = 1, u , v; i < n; i++)\n    {\n        cin>> u >> v;\n        g[u].push_back(i);\n        g[v].push_back(i);\n        edge.push_back({u,v});\n    }\n\n    int last = 0;\n    for(int i = 1; i <= n; i++)\n        if(g[i].size() >= 3)\n        {\n            for(auto u : g[i])\n                if(a[u] == -1)\n                {\n                    a[u] = last; last++;}\n        }\n\n    for(int i = 1; i < n; i++)\n        if(a[i] == -1)\n        {cout<< last <<\"\\n\"; last++;}\n        else\n            cout<< a[i] <<\"\\n\";\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Ehab and Path-etic MEXs.json",
    "editorial_link": "https://codeforces.com//blog/entry/74235",
    "editorial": "Notice that there will be a path that passes through the edge labeled\r\nand the edge labeled no matter how you label the edges, so thereâs\r\nalways a path with or more. If any node has degree 3 or more, you can\r\ndistribute the labels , , and to edges incident to this node and\r\ndistribute the rest of the labels arbitrarily. Otherwise, the tree is a\r\nbamboo, and it doesnât actually matter how you label the edges, since\r\nthere will be a path with anyway. Code link:\r\nhttps://pastebin.com/u4H7Dtbd First AC: vintage_Vlad_Makeev\r\n",
    "hint": []
}