{
    "link": "https://codeforces.com//contest/520/problem/B",
    "problemId": "23434",
    "problem_idx": "B",
    "shortId": "520B",
    "contest_number": "520",
    "problem_submissions": {
        "D": [
            10119858,
            10114121,
            10111852,
            10111632,
            10111622,
            10170455,
            10121530,
            10118171,
            10118084,
            10122862,
            10134966
        ],
        "E": [
            10114178,
            10113899,
            10113814,
            10152648,
            10109379,
            10113966
        ],
        "C": [
            10108152,
            10109805,
            10109410,
            10108517,
            10109427,
            10114253,
            10113273,
            10113527,
            10112592,
            10107996,
            10108589,
            10108504,
            10107807,
            10108758,
            10108493,
            10109002,
            10108917,
            10110247,
            10109125
        ],
        "B": [
            10106931,
            10107333,
            10110028,
            10106418,
            10116733,
            10106156,
            10110029,
            10112900,
            10113188,
            10106429,
            10105522,
            10105854,
            10105873,
            10105925,
            10106498,
            10106225,
            10106816,
            10106938
        ],
        "A": [
            10105356,
            10105380,
            10105204,
            10104484,
            10110338,
            10105073,
            10105335,
            10111915,
            10112806,
            10104426,
            10104489,
            10104959,
            10104609,
            10104534,
            10104623,
            10104731,
            10104535,
            10105461
        ]
    },
    "name": "B. Two Buttons",
    "statement": "Vasya has found a strange device. On the front panel of a device there\r\nare: a red button, a blue button and a display showing some positive\r\ninteger. After clicking the red button, device multiplies the displayed\r\nnumber by two. After clicking the blue button, device subtracts one from\r\nthe number on the display. If at some point the number stops being\r\npositive, the device breaks down. The display can show arbitrarily large\r\nnumbers. Initially, the display shows number .Bob wants to get number on\r\nthe display. What minimum number of clicks he has to make in order to\r\nachieve this result?\r\n",
    "solutions": [
        "#include<stdio.h>\nusing namespace std;\nstruct node\n{\n\tint x,t;\n}q[100005];\nint i,j,k,l,s,m,n,vis[1000005];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint gt=m-n;\n\tint l=0,r=1;\n\tq[1].x=n;\n\tq[1].t=0;\n\tvis[n]=1;\n\twhile (l<r)\n\t{\n\t\tint k=q[++l].x;\n\t\tif (k==m)\n\t\t{\n\t\t\tprintf(\"%d\\n\",q[l].t);\n\t\t\treturn 0;\n\t\t}\n\t\tif (k<m)\n\t\t{\n\t\t\tif (!vis[k*2])\n\t\t\t{\n\t\t\t\tq[++r].x=k*2,vis[k*2]=1;\n\t\t\t\t\n\t\t\t\tq[r].t=q[l].t+1;\n\t\t\t}\n\t\t\tif (!vis[k-1]&&k-1>0)\n\t\t\t{\n\t\t\t\tq[++r].x=k-1;\n\t\t\t\tq[r].t=q[l].t+1;\n\t\t\t\tvis[k-1]=1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!vis[k-1])\n\t\t\t{\n\t\t\t\tq[++r].x=k-1;q[r].t=q[l].t+1;\n\t\t\t\tvis[k-1]=1;\n\t\t\t}\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy",
        "implementation",
        "math",
        "shortest paths"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Two Buttons.json",
    "editorial_link": "https://codeforces.com//blog/entry/16736",
    "editorial": "The simplest solution is simply doing a breadth-first search. Construct a graph with numbers as vertices and edges leading from one number to another if an operation can be made to change one number to the other. We may note that it is never reasonable to make the number larger than 2m, so under provided limitations the graph will contain at most 2\u00b7104 vertices and 4\u00b7104 edges, and the BFS should work real fast.\n\nThere is, however, an even faster solution. The problem can be reversed as follows: we should get the number n starting from m using the operations \"add 1 to the number\" and \"divide the number by 2 if it is even\".\n\nSuppose that at some point we perform two operations of type 1 and then one operation of type 2; but in this case one operation of type 2 and one operation of type 1 would lead to the same result, and the sequence would contain less operations then before. That reasoning implies that in an optimal answer more than one consecutive operation of type 1 is possible only if no operations of type 2 follow, that is, the only situation where it makes sense is when n is smaller than m and we just need to make it large enough. Under this constraint, there is the only correct sequence of moves: if n is smaller than m, we just add 1 until they become equal; else we divide n by 2 if it is even, or add 1 and then divide by 2 if it is odd. The length of this sequence can be found in ."
}