{"link": "https://codeforces.com//contest/31/problem/D", "problemId": "147", "problem_idx": "D", "shortId": "31D", "contest_number": "31", "problem_submissions": {"E": [134876, 134644, 134848, 134248, 135579], "D": [134485, 133596, 134295, 134196, 134946, 134425, 134440, 134597, 134581, 134770, 134731, 134788, 134711, 135223, 134329, 136009, 136008, 135064], "C": [134168, 134002, 133803, 133545, 134363, 133957, 133783, 133977, 134075, 133915, 134271, 134272, 134280, 134218, 133534, 134400], "B": [133252, 133258, 133180, 135478, 133631, 133324, 133519, 133415, 134235, 133789, 133861, 134099, 133348, 133444], "A": [132701, 132899, 132718, 132766, 132790, 133118, 132713, 132712, 132770, 953988, 757270, 132738, 133121, 133401, 133529, 132807, 132719, 132830]}, "name": "D. Chocolate", "statement": "Bob has a rectangular chocolate bar of the size . He introduced a\r\ncartesian coordinate system so that the point corresponds to the\r\nlower-left corner of the bar, and the point corresponds to the\r\nupper-right corner. Bob decided to split the bar into pieces by breaking\r\nit. Each break is a segment parallel to one of the coordinate axes,\r\nwhich connects the edges of the bar. More formally, each break goes\r\nalong the line or , where and are integers. It should divide one part of\r\nthe bar into two non-empty parts. After Bob breaks some part into two\r\nparts, he breaks the resulting parts . Also he doesn\u2019t move the parts of\r\nthe bar. Bob made breaks and wrote them down in his notebook in\r\narbitrary order. At the end he got parts. Now he wants to calculate\r\ntheir areas. Bob is lazy, so he asks you to do this task.\r\n", "solutions": ["#include <cstdio>\n#include <set>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass Point {\npublic:\n\tint x, y;\n\n\tPoint() {}\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tinline void init() {\n\t\tscanf(\"%d%d\", &x, &y);\n\t}\n\n\tinline bool operator < (const Point & other) const {\n\t\treturn x < other.x || (x == other.x && y <= other.y);\n\t}\n};\n\nconst int MAXN = 110 + 1;\n\nset < pair <Point, Point> > ch;\nPoint s[MAXN], t[MAXN];\nbool tag[MAXN];\nint W, H, n, area[MAXN];\n\nint main() {\n\tscanf(\"%d%d%d\", &W, &H, &n);\n\tch.insert(make_pair(Point(0, 0), Point(W, H)));\n\tfor (int i = 0; i < n; i++) {\n\t\ts[i].init();\n\t\tt[i].init();\n\t}\n\tfor (int o = 0; o < n; o++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (tag[i]) continue;\n\t\t\tfor (set < pair <Point, Point> >::iterator iter = ch.begin(); iter != ch.end(); iter++) {\n\t\t\t\tPoint ss = iter->first, tt = iter->second;\n\t\t\t\tif (s[i].x == t[i].x && ss.x <= s[i].x && t[i].x <= tt.x && s[i].y == ss.y && t[i].y == tt.y) {\n\t\t\t\t\ttag[i] = true;\n\t\t\t\t\tch.erase(iter);\n\t\t\t\t\tch.insert(make_pair(ss, t[i]));\n\t\t\t\t\tch.insert(make_pair(s[i], tt));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (s[i].y == t[i].y && ss.y <= s[i].y && t[i].y <= tt.y && s[i].x == ss.x && t[i].x == tt.x) {\n\t\t\t\t\ttag[i] = true;\n\t\t\t\t\tch.erase(iter);\n\t\t\t\t\tch.insert(make_pair(ss, t[i]));\n\t\t\t\t\tch.insert(make_pair(s[i], tt));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tag[i]) break;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (set < pair <Point, Point> >::iterator iter = ch.begin(); iter != ch.end(); iter++) {\n\t\tarea[cnt++] = (iter->second.y - iter->first.y) * (iter->second.x - iter->first.x);\n\t}\n\tsort(area, area + n + 1);\n\tfor (int i = 0; i <= n; i++) printf(\"%d \", area[i]);\n\tputchar('\\n');\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "implementation"], "dificulty": "2000", "interactive": false}