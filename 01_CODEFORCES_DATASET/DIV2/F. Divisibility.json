{
    "link": "https://codeforces.com//contest/922/problem/F",
    "problemId": "154243",
    "problem_idx": "F",
    "shortId": "922F",
    "contest_number": "922",
    "problem_submissions": {
        "F": [
            35024389,
            35030878,
            35066050
        ],
        "E": [
            35021772,
            35023531,
            35025088,
            35031161,
            35025975,
            35029014,
            35026988,
            35021941,
            35026997,
            35064591,
            35064474,
            35026191,
            35037602,
            35037396,
            35027845
        ],
        "A": [
            35014429,
            35006326,
            35014914,
            35006731,
            35022340,
            35006627,
            35016513,
            35027286,
            35015985,
            35019424,
            35007052,
            35007949,
            35037576,
            35006680
        ],
        "C": [
            35013242,
            35014688,
            35008675,
            35009771,
            35021848,
            35009735,
            35022809,
            35015286,
            35020018,
            35017726,
            35013353,
            35014808,
            35011448,
            35018270,
            35015187,
            35037555,
            35037421,
            35021338,
            35014321
        ],
        "D": [
            35011345,
            35017477,
            35010376,
            35021949,
            35015604,
            35013771,
            35027504,
            35020183,
            35031518,
            35015008,
            35019185,
            35023414,
            35018029,
            35028830,
            35018141,
            35037411,
            35026479,
            35021278
        ],
        "B": [
            35007623,
            35008516,
            35007719,
            35008074,
            35008746,
            35007399,
            35009873,
            35009915,
            35012055,
            35007990,
            35009015,
            35007912,
            35008304,
            35009458,
            35010175,
            35037430,
            35007761,
            35008509
        ]
    },
    "name": "F. Divisibility",
    "statement": "Imp is really pleased that you helped him. But it you solve the last\r\nproblem, his gladness would raise even more. Let’s define for some set\r\nof integers as the number of pairs , in , such that: is than ; without a\r\nremainder. You are to find such a set , which is a subset of (the set\r\nthat contains all positive integers not greater than ), that .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\nconst int MAXN = 3e5 + 10;\nint cnt[MAXN];\nll ps[MAXN];\nvoid prep(){\n    for(int i=1; i<MAXN; i++)\n        for(int j=i*2; j<MAXN; j+=i)\n            cnt[j]++;\n    for(int i=1; i<MAXN; i++)\n        ps[i] = ps[i - 1] + cnt[i];\n}\nbool mark[MAXN];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, k;\n    prep();\n    //cout << ps[300000] << endl;\n    cin >> n >> k;\n    int l = -1;\n    for(int i=n; i>=1; i--){\n        if(ps[i] >= k) l = i;\n    }\n    if(l == -1){\n        cout << \"No\" << endl;\n        return 0;\n    }\n    n = l;\n    int ez = ps[n] - k;\n    vector<pii> v;\n    for(int i=n; i*2>n; i--)\n        v.push_back({cnt[i], i});\n    sort(v.begin(), v.end(), greater<pii>());\n    for(auto t : v){\n        int c = t.F, ind = t.S;\n        if(ez >= c) mark[ind] = 1, ez -= c;\n    }\n    if(ez) assert(0);\n    vector<int> ans;\n    for(int i=1; i<=n; i++)\n        if(!mark[i]) ans.push_back(i);\n\n    cout << \"Yes\" << endl;\n    cout << ans.size() << endl;\n    for(int i : ans)\n        cout << i << \" \";\n    cout << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Divisibility.json",
    "editorial_link": "https://codeforces.com//blog/entry/57605",
    "editorial": "Let the sought pairs be the edges in a graph with vertices. Then the\r\nproblem is reduced to finding such a vertex subset that the induced\r\ngraph contains exactly edges.Let be the number of edges in the graph on\r\nand be the number of divisors of (strictly less than ).We claim that the\r\nanswer always exists if (otherwise itâs obviously NO). Letâs enlighten\r\nit a bit.Letâs find the minimum possible such that and try to paraphrase\r\nthe problem: we have to throw away some vertices from the graph on\r\nvertices to leave exactly edges. Note that the degree of vertex is equal\r\nto : hence the most interesting numbers for us are primes strictly\r\nlarger than since their degree is equal to .Now itâs time to expose the\r\nmost important fact of the day: we claim that . At the same time the\r\nnumber of primes greater than , is about . Quite intuitive that\r\nasymptotically itâs almost enough to throw only them away (there are\r\nonly possible counters and they all appear with which could be solved\r\nmanually). This observation is sufficient to get AC.You couldâve chosen\r\nthe parallel way and note that vertices greater than do not share edges,\r\ntherefore they can be thrown away independently (adding the statement\r\nfrom the previous paragraph, greedy approach will do). You couldâve even\r\nwritten recursive bruteforce :D Summarizing the aforementioned, it works\r\nwell. .\r\n",
    "hint": []
}