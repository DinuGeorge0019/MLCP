{
    "link": "https://codeforces.com//contest/785/problem/D",
    "problemId": "98356",
    "problem_idx": "D",
    "shortId": "785D",
    "contest_number": "785",
    "problem_submissions": {
        "E": [
            25535913,
            25520701,
            25521367,
            25524258,
            25516770,
            25518668,
            25525495,
            25517389,
            25526683,
            25519510,
            25510315,
            25516733,
            25699539,
            25521276,
            25540389,
            25540369,
            25522122,
            25560171,
            25522262
        ],
        "D": [
            25514969,
            25516920,
            25517547,
            25523665,
            25527515,
            25519834,
            25527742,
            25518744,
            25524873,
            25653943,
            25515800,
            25517945,
            25515992,
            25518919,
            25517044,
            25522041
        ],
        "C": [
            25509527,
            25508471,
            25509773,
            25536741,
            25508063,
            25509604,
            25510288,
            25520657,
            25513296,
            25522523,
            25517091,
            25519490,
            25510828,
            25511108,
            25511948,
            25512218,
            25511493,
            25510575,
            25511287,
            25511649,
            25508687
        ],
        "B": [
            25505453,
            25505566,
            25506791,
            25505538,
            25504971,
            25506495,
            25505802,
            25505209,
            25507435,
            25512598,
            25507000,
            25506314,
            25505276,
            25506234,
            25507471,
            25504662,
            25505140,
            25505996,
            25505311,
            25505921
        ],
        "A": [
            25502237,
            25502308,
            25504008,
            25502246,
            25501830,
            25501715,
            25502679,
            25501866,
            25503109,
            25511198,
            25501880,
            25502005,
            25502194,
            25502627,
            25503151,
            25502062,
            25501702,
            25506739,
            25501679,
            25502337
        ]
    },
    "name": "D. Anton and School - 2",
    "statement": "As you probably know, Anton goes to school. One of the school subjects\r\nthat Anton studies is Bracketology. On the Bracketology lessons students\r\nusually learn different sequences that consist of round brackets\r\n(characters \"\" and \"\" (without quotes)).On the last lesson Anton learned\r\nabout the regular simple bracket sequences (RSBS). A bracket sequence of\r\nlength is an RSBS if the following conditions are met: It is not empty\r\n(that is ). The length of the sequence is even. First charactes of the\r\nsequence are equal to \"\". Last charactes of the sequence are equal to\r\n\"\". For example, the sequence \"\" is an RSBS but the sequences \"\" and \"\"\r\nare not RSBS.Elena Ivanovna, Anton\u2019s teacher, gave him the following\r\ntask as a homework. Given a bracket sequence . Find the number of its\r\ndistinct subsequences such that they are RSBS. Note that a subsequence\r\nof is a string that can be obtained from by deleting some of its\r\nelements. Two subsequences are considered distinct if distinct sets of\r\npositions are deleted.Because the answer can be very big and Anton\u2019s\r\nteacher doesn\u2019t like big numbers, she asks Anton to find the answer\r\nmodulo .Anton thought of this task for a very long time, but he still\r\ndoesn\u2019t know how to solve it. Help Anton to solve this task and write a\r\nprogram that finds the answer for it!\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long LL;\nconst LL md=1000000007LL;\nconst int MX=400111;\nLL fac[MX],facinv[MX],inv[MX];\ninline LL C(LL x,LL y){\n\treturn fac[x]*facinv[y]%md*facinv[x-y]%md;\n}\nvoid ini(){\n\tfac[0]=1LL,facinv[0]=1LL;\n\tinv[1]=1LL;\n\tfor(LL i=2;i<=400000;i++)inv[i]=(md-md/i)*inv[md%i]%md;\n\tfor(LL i=1;i<=400000;i++)fac[i]=fac[i-1]*i%md;\n\tfor(LL i=1;i<=400000;i++)facinv[i]=facinv[i-1]*inv[i]%md;\n}\nchar s[MX];\nint n;LL lc,rc;\nint main(){\n\tini();\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tfor(int i=0;i<n;i++)if(s[i]=='(')lc++;else rc++;\n\tLL tx=0LL,ty=rc,ans=0LL;\n\tfor(LL i=0;i<n;i++){\n\t\tif(!ty)break;\n\t\tif(s[i]=='('){\n\t\t\ttx++;ans=(ans+C(tx+ty-1,ty-1))%md;\n\t\t}else ty--;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Anton and School - 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/50996",
    "editorial": "At first, let\u00e2\u0080\u0099s simplify the problem: let our string consists of\r\ncharacters, begins with characters \"\" and ends with characters \"\". How\r\nto find the number of RSBS in such string?Let\u00e2\u0080\u0099s prove that this number\r\nis equal to . It\u00e2\u0080\u0099s easy to observe that this formula also means the\r\nnumber of ways to match the string with the sequence of zeros and ones\r\nof the same length, which contains exactly ones. Now prove that for\r\nevery such sequence of zeros and ones we can find an RSBS subsequence.\r\nHow can we do it? Let\u00e2\u0080\u0099s consider it on the example of the following\r\nstring: Let\u00e2\u0080\u0099s include to our subsequence all the opening brackets that\r\nmatch zeros and all the closing brackets that match ones. In our\r\nexample, we include brackets number , , and , so we get the subsequence\r\n\"\", which is an RSBS.Why every sequence we got in this way is an RSBS?\r\nLet the number of ones that match closing brackets is equal to . So ones\r\nmatch opening brackets (because we have ones, as we remember) and,\r\ntherefore, zeros match opening brackets. So the number of opening\r\nbrackets is equal to the number of closing brackets in our subsequence.\r\nAlso opening brackets appear earlier than closing brackers. So such\r\nsubsequence is always an RSBS, and the statement above is proved.Now we\r\nmust understand how to solve the entire problem. Let\u00e2\u0080\u0099s iterate over an\r\nopening bracket that is the last opening bracket in our subsequence. Now\r\nobserve that only opening brackets may come before this bracket, and\r\nonly closing brackets may come after this bracket. The rest of the\r\nbrackets will definitely not appear in the subsequence. Let\u00e2\u0080\u0099s count the\r\nnumber of opening brackets before the iterated one, incluing the\r\niterated one (let this number is equal to ), and also the number of\r\nclosing brackets after the iterated one (let this number is equal to ).\r\nTo calculate these numbers, we can precalc them for all the positions in\r\nusing prefix sums.Now, we have reduced our problem to the already\r\nsolved, because we have opening brackets and then closing brackets. But\r\nwe also have an additional condition: we must necessarily take the last\r\nopening bracket. So the answer is equal to , not , because on the\r\nposition with the last opening bracket we must put a zero. So we must\r\nput ones on positions instead of positions.Time complexity is (logarithm\r\nis to divide by modulo, that is necessary to calculate the number of\r\ncombinations).\r\n"
}