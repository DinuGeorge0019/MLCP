{
    "link": "https://codeforces.com//contest/387/problem/D",
    "problemId": "6209",
    "problem_idx": "D",
    "shortId": "387D",
    "contest_number": "387",
    "problem_submissions": {
        "C": [
            27999099,
            5844874,
            5841061,
            5847589,
            5843566,
            5843851,
            5849910,
            5846186,
            5847507,
            5847850,
            5846546,
            5848509,
            5848776,
            5843425,
            5843791,
            5843206,
            5842568,
            5843393
        ],
        "B": [
            27998713,
            5840894,
            5845641,
            5840512,
            5841082,
            5840804,
            5840526,
            5841204,
            5841355,
            5848318,
            5840963,
            5842246,
            5843788,
            5839620,
            5840413,
            5840368,
            5840193,
            5840883
        ],
        "A": [
            27997874,
            5839643,
            5839445,
            5839653,
            5839813,
            5839532,
            5840047,
            5839968,
            5848701,
            5839527,
            5840349,
            5840457,
            5839510,
            5839440,
            5839451,
            5839441,
            5839465
        ],
        "E": [
            5844573,
            5844315,
            5853477,
            5849230,
            5849007,
            5850779,
            5846373,
            5849357,
            5848789,
            5849640,
            5846140,
            5851142,
            5849993,
            5849270,
            5851283,
            5851268,
            5851181,
            5850678
        ],
        "D": [
            5843391,
            5847525,
            5847251,
            5847489,
            5848775,
            5866620,
            5866616
        ]
    },
    "name": "D. George and Interesting Graph",
    "statement": "George loves graphs. Most of all, he loves interesting graphs. We will\r\nassume that a directed graph is , if it meets the following criteria:\r\nThe graph doesn\u2019t contain any multiple arcs; There is vertex (we\u2019ll call\r\nher the ), such that for any vertex of graph , the graph contains arcs\r\nand . Please note that the graph also contains loop . The outdegree of\r\nall vertexes except for the equals two and the indegree of all vertexes\r\nexcept for the equals two. The outdegree of vertex is the number of arcs\r\nthat go out of , the indegree of vertex is the number of arcs that go in\r\n. Please note that the graph can contain loops. However, not\r\neverything\u2019s that simple. George got a directed graph of vertices and\r\narcs as a present. The graph didn\u2019t have any multiple arcs. As George\r\nloves interesting graphs, he wants to slightly alter the presented graph\r\nand transform it into an interesting one. In one alteration he can\r\neither remove an arbitrary existing arc from the graph or add an\r\narbitrary arc to the graph. George wonders: what is the minimum number\r\nof changes that he needs to obtain an interesting graph from the graph\r\nhe\u2019s got as a present? Help George and find the answer to the question.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <stdio.h>\n#include <memory.h>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string.h>\n#include <string>\n#include <ctype.h>\n\nusing namespace std;\n\ntypedef long long INT;\ntypedef pair<int, int> pii;\n\n#define beyond(r, c) (r<0 || c<0 || r>=R || c>=C)\n#define NN 510\n\nint ii, n, m, adj[NN][NN], deg[NN], con[NN][NN], vst[NN], mL[NN], flag;\n\nint Find(int u) {\n    int i, v;\n    for (i=0; i<deg[u]; i++) {\n        v=adj[u][i];\n        if (ii==v) continue;\n        if (mL[v]==-1) return mL[v]=u, 1;\n    }\n    for (i=0; i<deg[u]; i++) {\n        v=adj[u][i];\n        if (ii==v) continue;\n        if (vst[v]==flag) continue;\n        vst[v]=flag;\n        if (mL[v]==-1 || Find(mL[v])) return mL[v]=u, 1; \n    }\n    return 0;\n}\n\nint main() {\n\n    int i, u, v, res, tmp, j, k;\n    \n    scanf(\"%d%d\", &n, &m);\n    memset(deg, 0, sizeof(deg));\n    memset(con, 0, sizeof(con));\n    for (i=0; i<m; i++) {\n        scanf(\"%d%d\", &u, &v);\n        u--; v--;\n        adj[u][deg[u]++]=v;\n        con[u][v]=1;\n    }\n    res=1000000000;\n    for (i=0; i<n; i++) {\n        tmp=0; ii=i;\n        for (j=0; j<n; j++) {\n            if (!con[i][j]) tmp++;\n            if (j!=i && !con[j][i]) tmp++;\n            mL[j]=-1;\n        }\n        for (k=j=0; j<n; j++) {\n            if (j==i) continue;\n            flag++;\n            k+=Find(j);\n        }\n        res=min(res, tmp+n-1-k+(m-k-(2*n-1-tmp)));\n    }\n    printf(\"%d\\n\", res);\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graph matchings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. George and Interesting Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/10583",
    "editorial": "To solve this problem you should know about bipartite matching. Let\u00e2\u0080\u0099s\r\nconsider the center of graph . After that let\u00e2\u0080\u0099s remove arcs that have\r\nform or . Let\u00e2\u0080\u0099s there are arcs of such type. Let\u00e2\u0080\u0099s number of other arcs.\r\nAfter that we should found maximal bipartite matching on the bipartite\r\ngraph. This graph has following idea: left part of this graph is\r\nindegrees of all vertexes except vertex , right part of this graph is\r\noutdegrees of all vertexes except vertex . Also if there an arc in our\r\ngraph then in our bipartite graph there an arc , where vertex from left\r\npart, vertex from the right part. Let\u00e2\u0080\u0099s size of bipartite matching on\r\nthe bipartite graph equals to . Then answer for the current vertex\r\nequals to . After that you should update global answer. Why it is\r\ncorrect? It is simple to understand that if we will found bipartite\r\nmatching on the bipartite graph we will cover maximal number of\r\nrequirements on in/out degrees. Because of that, we will remove all\r\nother arcs, except of maximal matching, and after that we will add this\r\nmaximal matching to full matching by adding arcs. Note, it is important,\r\nthat self-loops are not forbidden. Withoud self-loops problem is very\r\nhard, I think. The complexity is: time / memory. 5850946\r\n"
}