{
    "link": "https://codeforces.com//contest/131/problem/B",
    "problemId": "693",
    "problem_idx": "B",
    "shortId": "131B",
    "contest_number": "131",
    "problem_submissions": {
        "F": [
            904424,
            898451,
            898852,
            898665,
            899656,
            42410750,
            900665,
            900877,
            900384,
            899648,
            900915,
            901359,
            897034,
            901848,
            900975,
            901375,
            897608,
            902336,
            895558,
            901701
        ],
        "E": [
            904422,
            896838,
            895727,
            896630,
            897281,
            42410343,
            898660,
            899049,
            899074,
            898552,
            899102,
            899404,
            899253,
            899170,
            899607,
            899696,
            899911,
            897321,
            900186,
            897365
        ],
        "D": [
            904420,
            894775,
            894348,
            894881,
            894791,
            896588,
            897021,
            897370,
            896846,
            897407,
            896897,
            908176,
            904628,
            901525,
            897622,
            897737,
            898418,
            894267,
            898476,
            898021,
            898664,
            894931
        ],
        "C": [
            904417,
            892960,
            891836,
            893412,
            892695,
            893493,
            894746,
            897077,
            895187,
            893806,
            894995,
            895988,
            896203,
            894856,
            902951,
            896937,
            892903
        ],
        "B": [
            904413,
            892343,
            898130,
            892434,
            891977,
            893039,
            892628,
            893632,
            891827,
            892784,
            894062,
            892290,
            894254,
            895376,
            891900,
            893592,
            894329,
            896307,
            891485
        ],
        "A": [
            904410,
            891551,
            891494,
            891758,
            891408,
            891725,
            892258,
            891411,
            891856,
            891608,
            892187,
            891595,
            893365,
            893186,
            891415,
            891922,
            891657,
            895179,
            892042
        ]
    },
    "name": "B. Opposites Attract",
    "statement": "Everybody knows that opposites attract. That is the key principle of the\r\n\"Perfect Matching\" dating agency. The \"Perfect Matching\" matchmakers\r\nhave classified each registered customer by his interests and assigned\r\nto the -th client number (). Of course, one number can be assigned to\r\nany number of customers.\"Perfect Matching\" wants to advertise its\r\nservices and publish the number of opposite couples, that is, the\r\ncouples who have opposite values of . Each couple consists of exactly\r\ntwo clients. The customer can be included in a couple an arbitrary\r\nnumber of times. Help the agency and write the program that will find\r\nthe sought number by the given sequence . For example, if , then any two\r\nelements and form a couple if and have different parity. Consequently,\r\nin this case the sought number equals 4.Of course, a client canâ€™t form a\r\ncouple with him/herself.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nmap <int,int> a;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++)\n    {\n        int x=0;\n        scanf(\"%d\",&x);\n        a[x]++;\n    }\n    ll ans=0;\n    for (int i=1;i<=10;i++)\n        ans+=ll(a[i])*a[-i];\n    ans+=ll(a[0])*(a[0]-1)/2;\n    printf(\"%I64d\\n\",ans);\n    return(0);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Opposites Attract.json",
    "editorial_link": "https://codeforces.com//blog/entry/3256",
    "editorial": "First, let count(i) be the numbers of occurrences of the number i in the input,\n    for -10 <= i <= 10. Remember that there may be negative numbers in the input, so one can use an offset to store these values (use an 21-sized array C and store count(i) in C[i+10]). Except for 0, possible matching are pairs (i,-i), for 1 <= i <= 10. It's easy to see that there will be exactly count(i)*count(-i) valid matching for each i, so just sum them all.\n\nSince 0 \"is opposite to itself\", but \"a client can't form a couple with\nhim/herself\", the number of valid pairs (0,0) will be (count(0) 2). Just sum\nthis value to the previous computed sum and print.\nUse 64 bits-types to do the math.",
    "hint": []
}