{
    "link": "https://codeforces.com//contest/370/problem/C",
    "problemId": "4145",
    "problem_idx": "C",
    "shortId": "370C",
    "contest_number": "370",
    "problem_submissions": {
        "C": [
            5370412,
            5368730,
            5371522,
            5371990,
            5370195,
            5370131,
            5371258,
            5371358,
            5372807,
            5379034,
            5368672
        ],
        "D": [
            5369264,
            5370401,
            5370565,
            5371357,
            5372982,
            5372779,
            5373131,
            5372520,
            5372523,
            5370570,
            5370366,
            5371915,
            5371128,
            5372843,
            5372383,
            5373802
        ],
        "B": [
            5367928,
            5367560,
            5367818,
            5367866,
            5367916,
            5368321,
            5372838,
            5370234,
            5369841,
            5368420,
            5367832,
            5368440,
            5368950,
            5372070,
            5368698,
            5369739,
            5367644
        ],
        "A": [
            5367394,
            5369807,
            5367525,
            5367450,
            5367389,
            5367654,
            5369021,
            5369042,
            5374280,
            5368909,
            5367810,
            5367376,
            5367612,
            5368269,
            5373074,
            5367757,
            5368835,
            5367393
        ],
        "E": [
            5372646,
            5370095
        ]
    },
    "name": "C. Mittens",
    "statement": "A Christmas party in city S. had children. All children came in mittens.\r\nThe mittens can be of different colors, but each child had the left and\r\nthe right mitten of the same color. Let’s say that the colors of the\r\nmittens are numbered with integers from 1 to , and the children are\r\nnumbered from 1 to . Then the -th child has both mittens of color .The\r\nParty had Santa Claus (’Father Frost’ in Russian), his granddaughter\r\nSnow Girl, the children danced around the richly decorated Christmas\r\ntree. In fact, everything was so bright and diverse that the children\r\nwanted to wear mittens of distinct colors. The children decided to swap\r\nthe mittens so that each of them got one left and one right mitten in\r\nthe end, and these two mittens were of distinct colors. All mittens are\r\nof the same size and fit all the children.The children started\r\nexchanging the mittens haphazardly, but they couldn’t reach the\r\nsituation when each child has a pair of mittens of distinct colors.\r\nVasily Petrov, the dad of one of the children, noted that in the general\r\ncase the children’s idea may turn out impossible. Besides, he is a\r\nmathematician and he came up with such scheme of distributing mittens\r\nthat the number of children that have distinct-colored mittens was\r\nmaximum. You task is to repeat his discovery. Note that the left and\r\nright mittens are different: each child must end up with one left and\r\none right mitten.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ld eps = 1e-12;\nconst int inf = 1e9;\n#define pb push_back\n#define pob pop_back\n#define i1 first\n#define i2 second\n#define mp make_pair\n\n#define file \"\"\n#define N 100500\n\nstruct edge;\nstruct vert\n{\n    edge *e, *r;\n    bool was;\n    int d;\n};\nstruct edge\n{\n    edge *e, *r;\n    vert *v;\n    int f, m;\n};\n\nvert V[N];\nedge E[N];\nint es;\n\nint c1[N];\nint cnt1[N], cnt2[N];\n\nvoid add(int u, int v, int f)\n{\n    E[es].e = V[u].e;\n    V[u].e = E + es;\n    E[es].v = V + v;\n    E[es].m = f;\n    E[es].r = E + es + 1;\n    es++;\n    E[es].e = V[v].e;\n    V[v].e = E + es;\n    E[es].v = V + u;\n    E[es].m = 0;\n    E[es].r = E + es - 1;\n    es++;\n}\n\nint nn;\n\nvert* q[N];\nint qs, qe;\n\nint flow(int s, int e)\n{\n    int f = 0;\n    while (1)\n    {\n        for (int i = 0; i < nn; i++)\n            V[i].was = 0, V[i].d = inf;\n        qs = qe = 0;\n        q[qs++] = V + s, V[s].was = 1, V[s].d = 0;\n        while (qs != qe)\n        {\n            vert *v = q[qe++];\n            for (edge *e = v->e; e; e = e->e)\n                if (e->f < e->m && e->v->d == inf)\n                {\n                    e->v->d = v->d + 1;\n                    e->v->was = 1;\n                    e->v->r = e->r;\n                    q[qs++] = e->v;\n                }\n        }\n        if (!V[e].was) break;\n        int dflow = inf;\n        for (vert *v = V + e; v != V + s; v = v->r->v)\n            dflow = min(dflow, v->r->r->m - v->r->r->f);\n        f += dflow;\n        for (vert *v = V + e; v != V + s; v = v->r->v)\n        {\n            v->r->r->f += dflow;\n            v->r->f -= dflow;\n        }\n    }\n    return f;\n}\n       \nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    nn = m * 2 + 2;\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &c1[i]), c1[i]--; \n    for (int i = 0; i < n; i++)\n        cnt1[c1[i]]++, cnt2[c1[i]]++;\n    for (int i = 0; i < m; i++)\n        add(0, i + 1, cnt1[i]);\n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < m; j++)\n            if (i != j) add(i + 1, j + m + 1, inf);\n    for (int i = 0; i < m; i++)\n        add(i + m + 1, m * 2 + 1, cnt2[i]);\n    cout << flow(0, m * 2 + 1) << endl;\n    for (int i = 0; i < m; i++)\n        for (edge *e = V[i + 1].e; e != 0; e = e->e)\n            for (int j = 0; j < e->f; j++)\n                printf(\"%d %d\\n\", i + 1, (e->v - V) - m);\n    for (edge *e = V[0].e; e; e = e->e)\n        for (int j = 0; j < e->m - e->f; j++)\n            printf(\"%d %d\\n\", (e->v - V), (e->v - V));\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Mittens.json",
    "editorial_link": "https://codeforces.com//blog/entry/9866",
    "editorial": "Let s show that if the most frequent color appears not more than times,\r\nthan all children can get mittens of distinct colors. One way to\r\nconstruct such solution is to sort all left mittens in the order of\r\ndecreasing frequency of their colors: for the input 1 2 1 2 3 1 3 3 1 we\r\nget 1 1 1 1 3 3 3 2 2. To obtain the sequence of right mittens, rotate\r\nthe sequence of left mittens to the left by the maximum color frequency\r\n(in the example it is 4, so we get the sequence 3 3 3 2 2 1 1 1 1). Then\r\njust match the sequences (1 3, 1 3, 1 3, 1 2, 3 2, 3 1, 3 1, 2 1, 2 1).\r\nIt can be easily shown that all pairs consist of distinct colors. OK,\r\nbut what to do if there is a dominating color that appears more than\r\nhalf times? Use exactly the same algorithm! It will maximize the number\r\nof pairs of distinct colors.\r\n",
    "hint": []
}