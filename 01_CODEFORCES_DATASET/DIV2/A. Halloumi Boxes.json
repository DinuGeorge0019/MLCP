{
    "link": "https://codeforces.com//contest/1903/problem/A",
    "problemId": "2355502",
    "problem_idx": "A",
    "shortId": "1903A",
    "contest_number": "1903",
    "problem_submissions": {
        "D2": [
            235128331,
            235435764,
            235183865,
            235116126,
            235121557,
            235122165,
            236143935,
            235115553,
            235129873,
            235119268
        ],
        "F": [
            235111543,
            235102179,
            235105725,
            235099949,
            235124718,
            235126382,
            235187626,
            235129442,
            235218441,
            235126934,
            235133564,
            235146171,
            235141771,
            235179210
        ],
        "E": [
            235106076,
            235104135,
            235115833,
            235114935,
            235102473,
            235112204,
            235107850,
            235103854,
            235111843,
            235109842,
            235115868,
            235124408,
            235114753,
            235126753,
            235108387,
            235107433,
            235107971,
            235105219,
            235108510,
            235108333
        ],
        "D1": [
            235093312,
            235109270,
            235095674,
            235117999,
            235091603,
            235099696,
            235100348,
            235094032,
            235098578,
            235098148,
            235119995,
            235115692,
            235105537,
            235119353,
            235094232,
            235095613,
            235096813,
            235097844,
            235096074,
            235099176
        ],
        "C": [
            235088892,
            235089084,
            235089891,
            235103743,
            235087836,
            235093791,
            235088528,
            235088785,
            235092085,
            235091882,
            235086000,
            235089517,
            235099201,
            235093455,
            235087482,
            235090537,
            235090823,
            235091561,
            235089639,
            235091936
        ],
        "B": [
            235086528,
            235084790,
            235086716,
            235102627,
            235086465,
            235090208,
            235086073,
            235088901,
            235087776,
            235087683,
            235089557,
            235084538,
            235096155,
            235090241,
            235085240,
            235087001,
            235086944,
            235087486,
            235086654,
            235088684
        ],
        "A": [
            235083574,
            235084421,
            235082280,
            235100671,
            235083954,
            235085469,
            235082350,
            235089029,
            235082379,
            235083014,
            235084518,
            235090802,
            235083842,
            235083352,
            235082144,
            235082627,
            235082396,
            235082150,
            235082134,
            235082717
        ]
    },
    "name": "A. Halloumi Boxes",
    "statement": "Theofanis is busy after his last contest, as now, he has to deliver many\r\nhalloumis all over the world. He stored them inside n boxes and each of\r\nwhich has some number a_i written on it. He wants to sort them in\r\nnon-decreasing order based on their number, however, his machine works\r\nin a strange way. It can only reverse any subarray^{\r\ndagger} of boxes with length k.Find if itâ€™s possible to sort the boxes\r\nusing .^{\r\ndagger} Reversing a subarray means choosing two indices i and j (where 1\r\nle i\r\nle j\r\nle n) and changing the array a_1, a_2,\r\nldots, a_n to a_1, a_2,\r\nldots, a_{i-1},\r\n; a_j, a_{j-1},\r\nldots, a_i,\r\n; a_{j+1},\r\nldots, a_{n-1}, a_n. The length of the subarray is then j - i + 1.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector <int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        if (k == 1 && !is_sorted(a.begin(), a.end())) {\n            cout << \"No\\n\";\n        } else {\n            cout << \"Yes\\n\";\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Halloumi Boxes.json",
    "editorial_link": "https://codeforces.com//blog/entry/122820",
    "editorial": "If the array is already sorted or then there is always a way (reverse of\r\nsize swap consecutive elements). Else it is not possible since when the\r\narray remains the same.\r\n",
    "hint": [
        "Hint If is greater or equal to you can always swap adjacent elements."
    ]
}