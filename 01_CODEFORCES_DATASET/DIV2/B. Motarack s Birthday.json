{
    "link": "https://codeforces.com//contest/1301/problem/B",
    "problemId": "538755",
    "problem_idx": "B",
    "shortId": "1301B",
    "contest_number": "1301",
    "problem_submissions": {
        "F": [
            71000973,
            71002227,
            71047404,
            71220694,
            70998932,
            71051995,
            71028699,
            71013382,
            71013182,
            71012775,
            71025862,
            71001305
        ],
        "E": [
            70990356,
            70991049,
            70989982,
            70995000,
            71228853,
            70994471,
            70996484,
            70997616,
            70993985,
            71001983,
            71006041,
            71000752,
            71000762,
            71000295,
            71036031,
            71006895,
            71006710,
            71008245,
            71004278,
            71001868,
            71010122
        ],
        "D": [
            70978990,
            70984686,
            70977541,
            70983758,
            70979628,
            70981590,
            70982372,
            70984362,
            70996505,
            70984162,
            70979443,
            70993040,
            70987583,
            70989615,
            70984290,
            70988249,
            70992550,
            70989175,
            70990934,
            70988497
        ],
        "C": [
            70971830,
            70973831,
            70972391,
            70970695,
            70971864,
            70969581,
            70970083,
            70974438,
            70974283,
            70973307,
            70972668,
            70972796,
            70978912,
            70982981,
            70973415,
            70972561,
            70970139,
            70973814,
            70975653,
            70976409
        ],
        "B": [
            70968569,
            70967678,
            70969977,
            70968275,
            70967585,
            70973366,
            70967417,
            70968730,
            70968327,
            70969402,
            70969851,
            70968467,
            70975325,
            70966853,
            70969894,
            70969422,
            70967771,
            70969867,
            70971492,
            70969502
        ],
        "A": [
            70962789,
            70962641,
            70962787,
            70964181,
            70962880,
            70962945,
            70962791,
            70962672,
            70962738,
            70962693,
            70965581,
            70963729,
            70962976,
            70962686,
            70963227,
            70964391,
            70962619,
            70962496,
            70966796,
            70962378
        ]
    },
    "name": "B. Motarack s Birthday",
    "statement": "Dark is going to attend Motarack’s birthday. Dark decided that the gift\r\nhe is going to give to Motarack is an array a of n non-negative\r\nintegers.Dark created that array 1000 years ago, so some elements in\r\nthat array disappeared. Dark knows that Motarack hates to see an array\r\nthat has two adjacent elements with a high absolute difference between\r\nthem. He doesn’t have much time so he wants to choose an integer k (0\r\nleq k\r\nleq 10^{9}) and replaces all missing elements in the array a with k.Let\r\nm be the maximum absolute difference between all adjacent elements (i.e.\r\nthe maximum value of |a_i - a_{i+1}| for all 1\r\nleq i\r\nleq n - 1) in the array a after Dark replaces all missing elements with\r\nk.Dark should choose an integer k so that m is minimized. Can you help\r\nhim?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\ninline int read() {\n    char c, _c; int x; for (c = _c = getchar(); !isdigit(c); c = getchar()) { _c = c; }\n    for (x = 0; isdigit(c); c = getchar()) { x = x * 10 + c - '0'; } return _c == '-' ? -x : x;\n}\n\nconst int N = 1e6 + 5;\n\nint n, l, r, k, ans, max, a[N];\n\nint main() {\n    for (int T = read(); T; T--) {\n        n = read(); max = 0;\n        for (int i = 0; i < n; i++) { a[i] = read(); }\n        l = 2e9; r = -2e9;\n        for (int i = 1; i < n; i++) {\n            if (a[i - 1] == -1 && a[i] != -1) {\n                l = std::min(l, a[i]);\n                r = std::max(r, a[i]);\n            }\n            if (a[i - 1] != -1 && a[i] == -1) {\n                l = std::min(l, a[i - 1]);\n                r = std::max(r, a[i - 1]);\n            }\n            if (a[i - 1] != -1 && a[i] != -1) {\n                max = std::max(max, std::abs(a[i] - a[i - 1]));\n            }\n        }\n        if (l > 1e9) {\n            printf(\"%d %d\\n\", max, 0);\n        } else if (l == r) {\n            printf(\"%d %d\\n\", max, l);\n        } else {\n            k = (l + r) / 2;\n            ans = std::max(r - k, k - l);\n            ans = std::max(ans, max);\n            printf(\"%d %d\\n\", ans, k);\n        }\n    }    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "ternary search"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Motarack s Birthday.json",
    "editorial_link": "https://codeforces.com//blog/entry/73877",
    "editorial": "Letâs take all non missing elements that are adjacent to at least one\r\nmissing element, we need to find a value that minimises the maximum\r\nabsolute difference between and these values. The best is equal to\r\n(minimum value + maximum value) / 2.Then we find the maximum absolute\r\ndifference between all adjacent pairs.Complexity is\r\n.code:https://ideone.com/79k8oT\r\n",
    "hint": []
}