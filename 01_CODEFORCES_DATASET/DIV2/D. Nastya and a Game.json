{
    "link": "https://codeforces.com//contest/992/problem/D",
    "problemId": "191474",
    "problem_idx": "D",
    "shortId": "992D",
    "contest_number": "992",
    "problem_submissions": {
        "E": [
            39379971,
            39367354,
            39383435,
            39383874,
            39377809,
            39387889,
            39394476,
            39394446,
            39415001,
            39392776
        ],
        "D": [
            39367228,
            39375773,
            39372594,
            39378835,
            39367744,
            39373260,
            39369394,
            39372029,
            39372974,
            39365892,
            39371246,
            39373661,
            39373903,
            39372053,
            39374817,
            39372239,
            39375168,
            39375159,
            39373219
        ],
        "C": [
            39364165,
            39377468,
            39374599,
            39369673,
            39390179,
            39368182,
            39365924,
            39366169,
            39367079,
            39370888,
            39367372,
            39369592,
            39366923,
            39366841,
            39366909,
            39368981,
            39367582
        ],
        "B": [
            39362525,
            39369978,
            39364265,
            39363783,
            39364539,
            39390973,
            39364179,
            39363741,
            39364940,
            39371207,
            39363548,
            39366410,
            39364261,
            39363633,
            39364663,
            39364278,
            39364004,
            39364073,
            39364080
        ],
        "A": [
            39360959,
            39367984,
            39361000,
            39360904,
            39364171,
            39360934,
            39362882,
            39361086,
            39361354,
            39361964,
            39363683,
            39362014,
            39362194,
            39360828,
            39362485,
            39364246,
            39462075,
            39360847,
            39362002,
            39361147
        ]
    },
    "name": "D. Nastya and a Game",
    "statement": "Nastya received one more array on her birthday, this array can be used\r\nto play a traditional Byteland game on it. However, to play the game the\r\nplayers should first select such a subsegment of the array that , where\r\nis the product of all integers on the given array, is their sum, and is\r\na given constant for all subsegments. Nastya wonders how many\r\nsubsegments of the array fit the described conditions. A subsegment of\r\nan array is several consecutive integers of the array.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nint a[200005];\nint r[200005];\n\ntypedef long long ll;\n\nconst ll INF = 3123123123123123123ll;\n\nll sm(ll x, ll y) {\n\tif (x * 1.0 * y > INF * 0.99)\n\t\treturn INF;\n\treturn x * y;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tcin >> n >> k;\n\tfor (int i=1; i<=n; i++)\n\t\tcin >> a[i];\n\n\tr[n+1] = -1;\n\tfor (int i=n; i>=1; i--) {\n\t\tif (a[i] > 1)\n\t\t\tr[i] = i;\n\t\telse\n\t\t\tr[i] = r[i+1];\n\t}\n\n\tll c = 0;\n\n\tfor (int i=1; i<=n; i++) {\n\t\tint j = i;\n\t\tll p = a[i], s = a[i];\n\t\tif (p == k*s)\n\t\t\tc++;\n\n\t\twhile (1) {\n\t\t\t// vidi gde je sledeca\n\t\t\tint z = r[j+1];\n\t\t\tif (z == -1)\n\t\t\t\tz = n+1;\n\t\t\tif (z != j+1) {\n\t\t\t\t// kecevi? ima \n\t\t\t\tint kec = z - j - 1;\n\t\t\t\tif (p != INF && p % k == 0 && 1 <= p/k-s && p/k-s <= kec) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z == n+1)\n\t\t\t\tbreak;\n\t\t\tp = sm(p, a[z]);\n\t\t\ts += a[z] + z - j - 1;\n\t\t\tif (p == k*s)\n\t\t\t\tc++;\n\t\t\tif (p == INF)\n\t\t\t\tbreak;\n\t\t\tj = z;\n\t\t}\n\t}\n\n\tcout << c << '\\n';\n\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Nastya and a Game.json",
    "editorial_link": "https://codeforces.com/blog/entry/60083",
    "editorial": "Letâs call numbers which are more than 1 as . Notice the following\r\nfact:Indeed, letâs assume that a subsegment contains more than 60\r\nnumbers. In this subsegment . At the same time, as , and , there is .\r\nTherefore, this subsegment canât be suitable due to .Letâs keep all\r\npositions of numbers in a sorted array. We sort out possible left border\r\nof a subsegment and then with binary search we find the next number to\r\nthe right of this left border. Then letâs iterate from this found number\r\nto the right by the numbers(that is we sort out the rightmost number in\r\na subsegment), until product of all numbers in the subsegment becomes\r\nmore than (itâs flag which shows us, that product is too big for a\r\nsuitable subsgment and we need to finish to iterate). We have shown\r\nabove the number of iterations isnât more than 60. Now for sorted out\r\nthe left border and the rightmost number we only need to know the number\r\nof 1âs which needs to be added to the right of the rightmost number, as\r\nwe can easily maintain sum and product in the subsegment during\r\niterating. Then we need to check whether found number of 1âs exists to\r\nthe right of the rightmost number. It can be checked if we look at the\r\nnext numberâs position.Complexity is .In order to check that is more\r\nthan , you shouldnât calculate multiply by , due to overflow. You must\r\nonly check that .\r\n",
    "hint": []
}