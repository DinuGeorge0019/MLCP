{"link": "https://codeforces.com//contest/1486/problem/F", "problemId": "897795", "problem_idx": "F", "shortId": "1486F", "contest_number": "1486", "problem_submissions": {"F": [107822308, 107853234, 107892513, 107856479, 107858609, 107818883, 107863062, 107864151, 107861898, 107852447], "C2": [107807571, 107798543, 107798512, 107824454, 107833215, 107807829, 107808299, 107893894, 107831280, 107798206, 107803513, 107805796, 107796329, 107802055, 107801594, 107810753, 107807623, 107804366, 107800246, 107794787], "C1": [107807442, 107798262, 107798783, 107806766, 107826187, 107799740, 107808102, 107806459, 107804345, 107798724, 107803748, 107805504, 107796790, 107802993, 107801883, 107810564, 107806537, 107804166, 107800475, 107795337], "E": [107800531, 107809228, 107835383, 107836319, 107858202, 107831953, 107841935, 107828250, 107866676, 107815626, 107818145, 107822115, 107819777, 107823506, 107819582, 107793061, 107821827, 107818526, 107827724, 107835623], "D": [107794075, 107802130, 107818757, 107810014, 107838771, 107823356, 107812461, 107800692, 107835785, 107804842, 107809012, 107812317, 107808246, 107810696, 107812569, 107833103, 107812854, 107810102, 107818249, 107811436], "B": [107789021, 107789484, 107787615, 107791480, 107795217, 107789100, 107788278, 107793717, 107792766, 107788662, 107787061, 107791923, 107801559, 107790818, 107784811, 107802492, 107792788, 107796149, 107790292, 107785066], "A": [107783058, 107787485, 107782747, 107783451, 107784857, 107784942, 107784010, 107783293, 107785695, 107784794, 107783365, 107784072, 107790054, 107785033, 107793025, 107799971, 107782733, 107782509, 107783469, 107782641]}, "name": "F. Pairs of Paths", "statement": "You are given a tree consisting of n vertices, and m simple vertex\r\npaths. Your task is to find how many pairs of those paths intersect at\r\nexactly one vertex. More formally you have to find the number of pairs\r\n(i, j) (1\r\nleq i < j\r\nleq m) such that path_i and path_j have exactly one vertex in common.\r\n", "solutions": ["//#pragma GCC target(\"avx,avx2\")\t\n#include<bits/stdc++.h>\n//#include<immintrin.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define rep0(i,l,r) for(int i=l;i<r;++i)\n#define gc (c=getchar())\nchar readc()\n{\n\tchar c;\n\twhile(isspace(gc));\n\treturn c;\n}\nint read()\n{\n\tchar c;\n\twhile(gc<'-');\n\tif(c=='-')\n\t{\n\t\tint x=gc-'0';\n\t\twhile(gc>='0')x=x*10+c-'0';\n\t\treturn -x;\n\t}\n\tint x=c-'0';\n\twhile(gc>='0')x=x*10+c-'0';\n\treturn x;\n}\n#undef gc\n\nconst int N=3e5+5;\nvector<int>lk[N];\nvector<pii>lk_q[N];\nint fa[N],sz[N],dep[N],son[N],top[N];\nint s[N],cnt[N];\n\nnamespace BING\n{\nint fa[N];\nint find(int x)\n{\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n\t}\t\n};\n\nvoid dfs(int x,int fr)\n{\n\tsz[x]=1;\n\tdep[x]=dep[fr]+1;\n\tfa[x]=fr;\n\tfor(auto y:lk[x])\n\tif(y!=fr)\n\t{\n\t\tdfs(y,x);\n\t\tsz[x]+=sz[y];\n\t\tif(sz[y]>sz[son[x]])son[x]=y;\n\t}\n}\nint get_lca(int x,int y)\n{\n\twhile(top[x]!=top[y])\n\tif(dep[top[x]]>dep[top[y]])x=fa[top[x]];else y=fa[top[y]];\n\treturn dep[x]<dep[y]?x:y;\n}\ns64 ans;\nvoid work(int x)\n{\n\tfor(auto y:lk[x])\n\tif(y!=fa[x])\n\t{\n\t\twork(y);\n\t\ts[x]+=s[y];\n\t}\n\tmap<pii,int>c;int tot=0;\n\tfor(auto p:lk_q[x])\n\t{\n\t\tint x1,y1;\n\t\ttie(x1,y1)=p;\n\t\tx1=BING::find(x1);\n\t\ty1=BING::find(y1);\n\t\tif(x1==x)x1=0;\n\t\telse --s[x1];\n\t\tif(y1==x)y1=0;\n\t\telse --s[y1];\n\t\tif(x1>y1)swap(x1,y1);\n\t\t\n\t\tif(x1)\n\t\t\tans+=tot-cnt[x1]-cnt[y1]+c[pii(x1,y1)];\n\t\telse \n\t\tif(y1)\n\t\t\tans+=tot-cnt[y1];\n\t\telse \n\t\t\tans+=tot;\n\t\t\n\t\t++tot;\n\t\t++c[pii(x1,y1)];\n\t\t++cnt[x1];++cnt[y1];\n\t}\n\tans+=s64(s[x])*tot;\n\t\n\tfor(auto y:lk[x])\n\tif(y!=fa[x])\n\t{\n\t\tBING::fa[y]=x;\n\t\tans+=s64(s[y])*(-cnt[y]);\n\t}\n}\n\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"1.in\",\"r\",stdin);//freopen(\"1.out\",\"w\",stdout);\n#endif\t\n\tint n=read();\n\trep(i,1,n)BING::fa[i]=i;\n\trep(i,1,n-1)\n\t{\n\t\tint x=read(),y=read();\n\t\tlk[x].push_back(y);\n\t\tlk[y].push_back(x);\n\t}\n\tdfs(1,0);\n\trep(x,1,n)\n\tif(x!=son[fa[x]])\n\t\tfor(int y=x;y;y=son[y])top[y]=x;\n\tint m=read();\n\trep(i,1,m)\n\t{\n\t\tint x=read(),y=read();\n\t\tint lca=get_lca(x,y);\n\t\t++s[x];++s[y];\n\t\ts[lca]-=2;\n\t\tlk_q[lca].push_back({x,y});\n\t}\n\twork(1);\n\tcout<<ans<<endl;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "data structures", "dfs and similar", "dp", "trees"], "dificulty": "2600", "interactive": false}