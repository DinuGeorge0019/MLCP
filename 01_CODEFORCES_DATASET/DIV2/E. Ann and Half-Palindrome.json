{"link": "https://codeforces.com//contest/557/problem/E", "problemId": "30557", "problem_idx": "E", "shortId": "557E", "contest_number": "557", "problem_submissions": {"E": [11869387, 11865728, 11877714, 11864888, 11889151, 11866470], "D": [11859147, 11860748, 11861182, 11862277, 11863181, 11865161, 11863844, 11864866, 11861291, 11865190, 11866413, 11860722, 11865833, 11866312, 11923092, 11859036, 11864665, 11862418, 11864374], "C": [11856407, 11858913, 11855729, 11859389, 11860110, 11858947, 11859067, 11857533, 11865562, 11859501, 11860468, 11865942, 11862380, 11854539, 11861657, 11909827, 11857135, 11858056, 11856524], "B": [11852804, 11852275, 11853400, 11856628, 11854078, 11854825, 11852839, 11853621, 11854966, 11854901, 11855996, 11862048, 11854417, 11862769, 11867200, 11867503], "A": [11852067, 11853135, 11852127, 11855787, 11852575, 11852315, 11854321, 11852415, 11852433, 11853058, 11852340, 11861439, 11852247, 11857225, 11853713, 11864195, 11852181, 11852458, 11852065]}, "name": "E. Ann and Half-Palindrome", "statement": "Tomorrow Ann takes the hardest exam of programming where she should get\r\nan excellent mark. On the last theoretical class the teacher introduced\r\nthe notion of a . String is a , if for all the odd positions () the\r\nfollowing condition is held: , where is the length of string if\r\npositions are indexed from . For example, strings \"\", \"\", \"\", \"\" are\r\nhalf-palindromes and strings \"\", \"\" and \"\" are not.Ann knows that on the\r\nexam she will get string , consisting only of letters and , and number .\r\nTo get an excellent mark she has to find the -th in the lexicographical\r\norder string among all substrings of that are half-palyndromes. Note\r\nthat each substring in this order is considered as many times as many\r\ntimes it occurs in .The teachers guarantees that the given number\r\ndoesn\u2019t exceed the number of substrings of the given string that are\r\nhalf-palindromes.Can you cope with this problem?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9+9; \nlong long hasht [5005][5005]; \nint ishalf [5005][5005]; \nint pref [5005][5005]; \nchar ans [5005]; \nlong long pow29 [5005]; \nstring a; \nlong long counter = 0; \nint main()\n{\n    ios_base::sync_with_stdio(0);\n    pow29[0]=1; \n    for (long long g=1; g<=5000; g++)\n    {\n        pow29[g]=(1LL*29*pow29[g-1])%mod; \n    }\n    cin >> a; \n    long long k; cin >> k; \n    for (long long g=0; g<a.length(); g++)\n    {\n        ishalf[g][g]=1; \n    }\n    for (long long g=2; g<=a.length(); g++)\n    {\n        for (long long y=0; y<=a.length()-g; y++)\n        {\n            long long start = y, end = y+g-1; \n            if (a[start]==a[end])\n            {\n                if (ishalf[start+2][end-2] || start+2>=end-2)\n                {\n                    ishalf[start][end]=1; \n                }\n            }\n        }\n    }\n    for (long long g=0; g<a.length(); g++)\n    {\n        for (long long y=a.length()-1; y>=g; y--)\n        {\n            pref[g][y]=ishalf[g][y]+pref[g][y+1];\n        }\n    }\n    for (long long g=0; g<a.length(); g++)\n    {\n        for (long long y=g; y<a.length(); y++)\n        {\n            hasht[g][y]=hasht[g][y-1]+(pow29[y-g]*(a[y]-'a'+1)); \n            if (hasht[g][y]>=mod) hasht[g][y]-=mod; \n            if (hasht[g][y]>=mod) hasht[g][y]-=mod; \n        }\n    }\n    long long curhash = 0; \n    while (k)\n    {\n        long long storehash1 = curhash + pow29[counter];\n        if (storehash1>=mod) storehash1-=mod; \n        long long storehash2 = storehash1 + pow29[counter]; \n        if (storehash2>=mod) storehash2-=mod; \n        long long checker = 0, exactsame1=0, exactsame2=0;      \n        for (long long g=0; g+counter<a.length(); g++)\n        {\n            if (hasht[g][g+counter]==storehash1)\n            {\n                checker+=pref[g][g+counter]; \n                if (ishalf[g][g+counter])\n                exactsame1++; \n            }\n            if (ishalf[g][g+counter]==1 && hasht[g][g+counter]==storehash2) exactsame2++;\n        }\n        /*\n        if (counter==1)\n        {\n            cout << exactsame1 << ' ' << checker << '\\n';break;\n        }\n        */\n        if (checker>=k)\n        {\n            if (exactsame1>=k)\n            {\n                ans[counter]='a'; counter++; break; \n            }\n            checker-=exactsame1; \n            k-=exactsame1; \n            ans[counter]='a'; \n            curhash=storehash1; \n        }\n        else\n        {\n            k-=checker; \n            if (exactsame2>=k)\n            {\n                ans[counter]='b'; counter++; break; \n            }\n            k-=exactsame2; \n            ans[counter]='b'; \n            curhash=storehash2;\n        }\n        counter++; \n    }\n    for (long long g=0; g<counter; g++) cout << ans[g]; \n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dp", "graphs", "string suffix structures", "strings", "trees"], "dificulty": "2300", "interactive": false}