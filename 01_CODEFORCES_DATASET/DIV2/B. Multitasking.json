{
    "link": "https://codeforces.com//contest/384/problem/B",
    "problemId": "5718",
    "problem_idx": "B",
    "shortId": "384B",
    "contest_number": "384",
    "problem_submissions": {
        "E": [
            5754820,
            5756457,
            5757218,
            5768768,
            5754973,
            5757082,
            5757773,
            5753824,
            5757669,
            5759993,
            5759984,
            5759937
        ],
        "C": [
            5752253,
            5751497,
            5752881,
            5756887,
            5754090,
            5753464,
            5757534,
            5753590,
            5750204,
            5750062,
            5751623,
            5750722,
            5749880,
            5751415,
            5751385,
            5750837,
            5751269,
            5751529,
            5751672,
            5751983
        ],
        "B": [
            5748010,
            5749890,
            5748064,
            5751405,
            5751229,
            5751814,
            5754578,
            5753247,
            5749239,
            5750952,
            5748962,
            5749250,
            5750859,
            5749807,
            5750164,
            5749512,
            5750591,
            5750157,
            5750184,
            5749558
        ],
        "A": [
            5747255,
            5747392,
            5747271,
            5747721,
            5748251,
            5749148,
            5747297,
            5749334,
            5748038,
            5747882,
            5747312,
            5747613,
            5747325,
            5747593,
            5747897,
            5747709,
            5747419,
            5747633,
            5747362,
            5747257
        ],
        "D": [
            5759668,
            5766263
        ]
    },
    "name": "B. Multitasking",
    "statement": "Iahub wants to enhance his multitasking abilities. In order to do this,\r\nhe wants to sort arrays simultaneously, each array consisting of\r\nintegers.Iahub can choose a pair of distinct indices and . Then in each\r\narray the values at positions and are swapped only if the value at\r\nposition is strictly greater than the value at position .Iahub wants to\r\nfind an array of pairs of distinct indices that, chosen in order, sort\r\nall of the arrays in ascending or descending order (the particular order\r\nis given in input). The size of the array can be at most (at most\r\npairs). Help Iahub, find any suitable array.\r\n",
    "solutions": [
        "//Solution by Zhusupov Nurlan\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef map<string , int> MSI;\ntypedef vector<int> VI;\n\n#define pb(x) push_back(x)\n#define sqr(x) ((x) * (x))\n#define F first\n#define S second\n#define SZ(t) ((int) t.size())\n#define len(t) ((int) t.length())\n#define base 10\n#define fname \"\"\n#define sz 1000 * 1000\n#define EPS (1e-8)\n#define INF ((int)1e9 + 9)\n#define write(xx) printf(\"%d\" , xx);\n#define readln(xx) getline(cin , xx)\n#define read(xx) scanf(\"%d\" , &xx)\n#define for(xx1 , yy1 , zz1) for(int zz1 = xx1 ; zz1 <= yy1 ; zz1++)\n#define mp make_pair\nconst double PI  = acos(-1.0);\n\nint n, m, k;\n\nint main(){\n\t//freopen(fname\"in\", \"r\", stdin);\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << \"\\n\";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << \" \" << j << \"\\n\";\n    \t\telse\t\n    \t\t\tcout << j << \" \" << i << \"\\n\";\n    \t\t\n    \treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Multitasking.json",
    "editorial_link": "https://codeforces.com//blog/entry/10476",
    "editorial": "Let s start by saying when array A[] is sorted: 1/ is sorted in\r\nascending order when i < j and A[i] <= A[j]. It is NOT sorted when i < j\r\nand A[i] > A[j]. 2/ is sorted in descending order when i > j and A[i] <=\r\nA[j]. It is NOT sorted when i > j and A[i] > A[j]. Iahub can choose 2\r\nindices i, j and swap values when A[i] > A[j]. If A[i] <= A[j], he ll\r\nignore operation. Hence, if he wants to sort all arrays in ascending\r\norder, he chooses indices i, j when i < j and perform operation.\r\nOtherwise, in all his operations he uses indices i, j such as i > j. A\r\ngood operation is when choosing indices i < j for ascending order\r\nsorting and i > j for descending order sorting. By doing only good\r\noperations, after an array is sorted, it will stay sorted forever (for a\r\nsorted array, all good operations will be ignored). From here we get our\r\nfirst idea: use any sorting algorithm you know and sort each array\r\nindividually. When print swaps done by sorting algorithm chosen, print\r\nthem as good operations. However, sorting each array individually can\r\ncause exceeding M * (M 1) / 2 operations limit. Another possible\r\nsolution would be, after you did an operation to an array, to update the\r\noperation to all arrays (you printed it, so it counts to M * (M 1) / 2\r\noperations limit; making it to all arrays will help sometimes and in\r\nworst case it won t change anything). However, you need to code it very\r\ncareful in order to make this algorithm pass the time limit. Doing this\r\nin a contest is not the best idea, especially when implementation could\r\nbe complicated and you have no guarantee it will pass time limit. So\r\nwhat else can we do? We can think out of box. Instead of sorting\r\nspecific N arrays, you can sort all possible arrays of length M. Find a\r\nsequence of good operations such as, anyhow I d choose an array of size\r\nM, it will get sorted ascending / descending. I ll show firstly how to\r\ndo for ascending sorting. At position 1 it needs to be minimal element.\r\nCan we bring minimal element there using good operations? Yes. Just do 1\r\n2 1 3 1 4 ... 1 M . It basically compares element from position 1 to any\r\nother element from array. When other element has smaller value, swap is\r\ndone. After comparing with all M elements, minimal value will be at\r\nposition 1. By now on I ll ignore position 1 and move to position 2.\r\nSuppose array starts from position 2. It also needs minimal value from\r\narray, except value from position 1 (which is no longer in array). Hence\r\ndoing 2 3 2 4 2 5 ... 2 M is enough, by similar reasons. For a position\r\ni, I need minimal value from array, except positions 1, 2, ..., i 1. I\r\nsimply do i i+1 i i+2 ... i M-1 i M . By arriving at position i, array\r\nwill be sorted ascending. The algorithm is simply: for (int i = 1; i <\r\nM; ++i) for (int j = i + 1; j <= M; ++j) cout << i << << j <<\r\nn ; This algorithm does exactly M * (M 1) / 2 moves. Can you find out\r\nhow to sort array in descending order? Try to think yourself, then if\r\nyou don t get it read next. At first position of a descending array it\r\nneeds to be maximal value. Similarly to ascending order, we can do 2 1 3\r\n1 4 1 ... M 1 . When I m at a position i and I compare its value to\r\nvalue from position 1, doing operation i 1 checks if A[i] > A[1]. If so,\r\nit swaps A[i] and A[1], so position 1 will contain now the maximum value\r\nso far. Similarly to logic from ascending order, when I m at position i,\r\nI need maximum value from array except positions 1, 2, ..., i 1, so I do\r\ni+1 i i+2 i ... M i . Algorithm is: for (int i = 1; i < M; ++i) for (int\r\nj = i + 1; j <= M; ++j) cout << j << << i <<\r\nn ; Obviously, this does as well M * (M 1) / 2 operations worst case.\r\nAll algorithm is about 10 lines of code, much better than other\r\nsolution, which requires two manually sorts and also has a chance to\r\nexceed TL. Code: http://pastie.org/8651809 A good strategy to approach\r\nthis problem is to think how optimal ordering should look like. For\r\nthis, let s calculate for each 2 different cows i and j if cow i needs\r\nto be milked before or after cow j. As we ll show, having this\r\ninformation will be enough to build optimal ordering. It is enough to\r\nconsider only cases when i < j, case when i > j is exactly the opposite\r\nof case i < j. For formality, I ll call the optimal ordering permutation\r\nand lost milk the cost of permutation. So, for an optimal permutation P\r\nlet s take 2 numbers i < j and see in which cases i should appear before\r\nj in permutation (i is before j if P[pos1] = i, P[pos2] = j and pos1 <\r\npos2; otherwise we ll call i is after j). We have 4 possible cases: 1/\r\nA[i] = 0 and A[j] = 0 If we put i before j, no additional cost will be\r\nadded. Since j is in right of i and i only adds cost when it finds\r\nelements in left of i, j won t be affected when processing i. When\r\nprocessing j, i will be already deleted so it won t affect the cost\r\neither. Hence, we can put i before j and no cost will be added. 2/ A[i]\r\n= 0 and A[j] = 1 Here, i and j can appear in arbitrary order in\r\npermutation (i can be before or after j). No matter how we choose them,\r\nthey won t affect each other and cost will remain the same. 3/ A[i] = 1\r\nand A[j] = 0 As well, here i and j can appear in arbitrary order. If we\r\nchoose i first, j will be in right of it, so cost of permutation will\r\nincrease by one. If we choose j first, i will be in left of it so cost\r\nof permutation will increase as well. No matter what we do, in this case\r\ncost of permutation increases by 1. 4/ A[i] = 1 and A[j] = 1 Here, i\r\nneeds to be after j. This adds 0 cost. Taking i before j will add 1 cost\r\nto permutation (since j is in right of i). Those 4 cases show us how a\r\nminimal cost permutation should look. In a permutation like this, only\r\ncase 3/ contributes to final cost, so we need to count number of indices\r\ni, j such as i < j and A[i] = 1 and A[j] = 0 (*). If we show a\r\npermutation following all rules exists, task reduces to (*). By cases 2/\r\nand 3/ it follows that in an optimal permutation, it only matters order\r\nof elements having same value in A[]. We can put firstly all elements\r\nhaving value 0 in A[], then all elements having value 1 in A[]. We can\r\norder elements having value 0 by case 1/ and elements having value 1 by\r\ncase 4/. More exactly, suppose i1 < i2 < ... < im and (A[i1] = A[i2] =\r\n... = A[im] = 0) and j1 > j2 > ... > jn (A[j1] = A[j2] = ... = A[jn] =\r\n1). Then, a permutation following all rules is {i1, i2, ..., im, j1, j2,\r\n..., jn}. This permutation can always be built. Hence, task reduces to\r\n(*): count number of indices i, j such as i < j and A[i] = 1 and A[j] =\r\n0. We can achieve easily an O(N) algorithm to do this. Let s build an\r\narray cnt[j] = number of 0s in range {j, j + 1, ..., N} from array A. We\r\ncan easily implement it by going backwards from N to 1. The result is\r\nsum of cnt[i], when A[i] = 1. Code: http://pastie.org/8651813 Our first\r\nobservation is that if there is a path from (1, 1) to (N, N), then the\r\nlength of path is 2 * N 2. Since all paths have length 2 * N 2, it\r\nfollows that if there is at least one path, the answer is 2 * N 2 and if\r\nthere isn t, the answer is -1. How to prove it? Every path from (1, 1)\r\nto (N, N) has exactly N 1 down directions and exactly N 1 right\r\ndirections. So, total length for each path is N 1 + N 1 = 2 * N 2. So we\r\nreduced our problem to determine if there is at least one path from\r\n(1, 1) to (N, N). This is the challenging part of this task, considering\r\nthat N <= 10 ^ 9. How would you do it for a decently small N, let s say\r\nN <= 10^3 . One possible approach would be, for each row, keep a set of\r\nreachable columns. We could easily solve this one by doing this: if (i,\r\nj) denotes element from ith row and jth column, then (i, j) is (is not)\r\nreachable if: if (i, j) contains a volcano, then (i, j) is not\r\nreachable. Otherwise, if at least one of (i 1, j) and (i, j 1) is\r\nreachable, then (i, j) is reachable. Otherwise, (i, j) is not reachable.\r\nWhat s the main problem of this approach? It needs to keep track of 10^9\r\nlines and in worst case, each of those lines can have 10^9 reachable\r\nelements. So, worst case we need 10^9 * 10^9 = 10^18 operations and\r\nmemory. Can we optimize it? We can note for beginning that we don t need\r\nto keep track of 10^9 lines, only m lines are really necessarily. We\r\nneed only lines containing at least one obstacle (in worst case when\r\neach line contains only one obstacle, we need m lines). How to solve it\r\nthis way? Suppose line number x contains some obstacles and lines x + 1,\r\nx + 2, x + 3 do not contain any obstacle. Suppose we calculated set S =\r\n{y | cell (x, y) is reachable}. How would look S1, S2, S3 corresponding\r\nto lines x + 1, x + 2, x + 3? For S1, we can reach cell (x + 1, ymin),\r\nwhere ymin is minimal value from set S. Then, we can also reach {ymin +\r\n1, ymin + 2, ..., N}, by moving right from (x + 1, ymin). So S1 = {ymin,\r\nymin + 1, ..., N}. How do S2 and S3 look? It s easy to see that they ll\r\nbe as well {ymin, ymin + 1, ..., N}. So we get following optimization:\r\nsuppose set of lines containing at least one obstacle is {L1, L2, ...,\r\nLk}. We need to run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3,\r\nL3 + 1, ..., Lk, Lk + 1. It looks like we didn t make anything with this\r\noptimization. Even if we calculate for m lines, each line can still have\r\n10^9 reachable positions. So worst case we perform 10^14 operations. We\r\nneed something better for managing information from a line. You can note\r\nthat for a given line y, there are a lot of positions having consecutive\r\nvalues. There are a lot of positions (x, y) and (x, y + 1) both\r\nreachable. This should give us following idea: what if instead of\r\nkeeping reachable positions, we keep reachable ranges? That is, for each\r\nline x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <=\r\nk <= b are reachable}. How many ranges can it be for a line? If the line\r\ncontains m obstacles, there are m + 1 ranges. Suppose for line x all\r\ncells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x +\r\n1, N 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4,\r\n4], [6, N 2] and [N, N]. By now, we get worst case m lines and worst\r\ncase each line having m elements, so in worst case we d have to handle\r\nm * m = 10 ^ 10 events. This may still look too much, but happily this\r\nbound is over estimated. If a line has o obstacles, there can be at most\r\no + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles,\r\nthere ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... +\r\nok = m and also k is at most m (proved above why we re interested in at\r\nmost m lines), so in worst case we get m + m = 2 * m ranges. Yaay,\r\nfinally a decent number of states for this problem :) So, we iterate\r\neach line we re interested in. Let s find set of ranges for this line,\r\nthinking that all cells from line above are reachable. This is easy to\r\ndo. After we get our ranges like all cells from above can be visited,\r\nlet s think how having obstacles above can influence current ranges.\r\nAfter adding ranges from above, current ranges can t increase\r\n(obviously), they can only decrease, remain the same or some of them can\r\nbecome empty. So, let s take each range [a, b] from current line and see\r\nhow it will transform after adding ranges from previous line. Given\r\nrange [a, b], it can transform only in [a , b] with a >= a. If a > b,\r\nthen obviously range is empty. Why second number of range keeps\r\nconstant? Let a smallest reachable column from current line which is in\r\nrange [a, b]. It s enough to check a >= a, as if a > b, range will be\r\nempty. It s obviously why we need to keep a smallest value possible >=\r\na: we re interested to keep range as big as possible and as less as we\r\ncut from left, as big it is. Once we ve found a in range [a, b] (or a >\r\nb if range is empty) all cells {a + 1, a + 2, ..., b} are reachable as\r\nwell by going right from a , so if interval is not empty, then second\r\nnumber defining it remains b. Next question is how to find a fast\r\nenough. In order a point a to be reachable on current range, it also\r\nneeds to exist a range on previous line containing it. If the range from\r\nprevious line is [pa, pb] then a needs to follow 3 conditions: a minimal\r\nsuch as pa <= a <= pb a >= a What if instead of finding a we find [pa,\r\npb]? Then a is max(pa, a). In order a to be as small as possible, since\r\na is constant, pa needs to be as small as possible. So we reduced it to:\r\npa minimal pb >= a >= a <=> pb >= a Intervals from previous line are\r\ndisjoint, no 2 intervals cross each other. It means that if pb is\r\nminimal, than pa is minimal too (if we increase pb, then pa will\r\nincrease too, so it won t be minimal). Hence, you need to find an\r\ninterval [pa, pb] such as pb is minimal and pb >= a. Then, a is max(a,\r\npa). This is easy to do if we sort all intervals from previous line\r\nincreasing by second value (pb), then we binary search for value a.\r\nFinally, after running algorithm for all lines, last range from last\r\nline has second number N (assuming ranges are sorted increasing by\r\nsecond value), then there exist a path, otherwise there does not exist.\r\nThis algorithm should run O(m * logm) worst case, good enough to pass.\r\nCode: http://pastie.org/8651817 This is kind of task that needs to be\r\nbreak into smaller subproblems that you can solve independently, then\r\nput them together and get solution. Let s define level of a node the\r\nnumber of edges in the path from root to the node. Root (node 1) is at\r\nlevel 0, sons of root are at level 1, sons of sons of root are at level\r\n2 and so on. Now suppose you want to do an operation of type 1 to a node\r\nx. What nodes from subtree of x will be added +val (a positive value)?\r\nObviously, x will be first, being located at level L. Sons of x, located\r\nat level L + 1 will be added val. Sons of sons, located at level L + 2,\r\nwill be added value +val again. So, nodes from subtree of x located at\r\nlevels L, L + 2, L + 4, ... will be added a +val, and nodes located at\r\nlevels L + 1, L + 3, L + 5 will be added a val. Let s take those values\r\nof L modulo 2. All nodes having remainder L modulo 2 will be added a\r\n+val, and nodes having reminder (L + 1) modulo 2 will be added val. In\r\nother words, for a fixed x, at a level L, let y a node from subtree of\r\nx, at level L2. If L and L2 have same parity, +val will be added to y.\r\nOtherwise, -val will be added to y. From here we have the idea to split\r\nnodes of tree in 2 sets those being located at even level and those\r\nbeing located at odd level. What still makes the problem hard to solve?\r\nThe fact that we have a tree. If nodes from a subtree would be a\r\ncontiguous sequence instead of some nodes from a tree, problem would be\r\nsimpler: the problem would reduce to add / subtract values to all\r\nelements of a subarray and query about a current value of an element of\r\narray. So, how can we transform tree to an array, such as for a node x,\r\nall nodes from subtree of x to be a subarray of array? The answer is\r\nyes. We can do this by properties of DFS search. Before reading on, make\r\nsure that you know what is discovery time and finish time in a DFS\r\nsearch. Let s build 3 arrays now discover[], representing nodes in order\r\nof their discover times (a node is as before in discover as it has a\r\nsmall discover time), begin[] = for a node, in which time it was\r\ndiscovered and end[] = what s last time of a discovered node before this\r\nnode finishes. For a subtree of x, all nodes in the subtree are nodes in\r\ndiscover from position begin[x] to end[x]. Example: suppose you have\r\ntree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3 Discover is {1, 5, 6, 7, 4, 2, 3}.\r\nbegin is {1, 6, 7, 5, 2, 3, 4}. end is {7, 6, 7, 7, 2, 7, 4}. What s\r\nsubtree of node 6? elements of discover from position begin[6] to\r\nend[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can\r\nsee it s correct and take more examples if you want :) Now, we reduced\r\nproblem to: you re given an array A. you can perform 2 operations: 1/\r\nincrease all elements from a range [x, y] to a value val (val can be\r\nnegative, to treat subtractions) 2/ what s current value of an element\r\nfrom position pos. Those who solved Iahub and Xors from my last round,\r\nCF 198, should probably say they saw something similar before. If you\r\ndidn t solve problem before, I encourage you to do it after you solve\r\nthis one, it uses a similar idea to what will follow now. Also, if you\r\ndon t know Fenwick trees, please read them before moving on. An\r\nalternative would be for this task using segment trees with lazy update,\r\nbut I see this one more complicated than needed. I ll use now a not so\r\ncommon approach when dealing with data structures. Instead of keeping in\r\na node the result, like you usually do, I ll keep just an auxiliary\r\ninformation. So what algorithm proposed does: Let A an array, initially\r\nwith all elements 0. When you need to update range [x, y] with value\r\nval, you simply do A[x] += val and A[y + 1] -= val. When you need to\r\nanswer a query about position pos, you output A[1] + A[2] + ... +\r\nA[pos]. Implemented brute force, you get O(1) per update and O(N) per\r\nquery. However, these both are operations supported by a Fenwick tree,\r\nso you can get O(logN) per operation. It may not be very clear why this\r\nalgorithm works. Let s take a closer look: an update needs to add value\r\nval only to range [x, y]. When you query a position pos, let s see if\r\nalgorithm handles it correctly: 1/ pos < x. In this case, result must\r\nnot be affected by my update. Since pos < x and I only updated 2 values\r\nwith indices >= x, when doing A[1] + A[2] + ... + A[pos] it won t matter\r\nat all I did that update at least not for this query. 2/ x <= pos <= y.\r\nHere, for a pos, I need to add value val only once. We add it only at\r\nA[x] in this way it will be counted once, and it will be considered for\r\neach elements from range [x, y] (since an element at position p from\r\nrange [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I ll have to\r\nconsider A[x]). 3/ pos > y. Here I don t have to consider the query. But\r\nit would be considered when processing A[x]. But if I add to A[y + 1]\r\nvalue val I ll just cancel the value previously added. Code (actually we\r\nuse just one Fenwick tree instead of 2, can you think why it works? :) )\r\n: http://pastie.org/8651824\r\n",
    "hint": []
}