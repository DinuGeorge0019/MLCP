{
    "link": "https://codeforces.com//contest/1977/problem/D",
    "problemId": "2665944",
    "problem_idx": "D",
    "shortId": "1977D",
    "contest_number": "1977",
    "problem_submissions": {
        "E": [
            262753822,
            262767302,
            262773066,
            262777674,
            262770623,
            263031771,
            262879241,
            264157721,
            262777678,
            262818461
        ],
        "D": [
            262746020,
            262752021,
            262759316,
            262764901,
            262755194,
            262759469,
            262754791,
            262756257,
            262756747,
            262758299,
            262756876,
            262759489,
            262764620,
            263176565,
            262763419,
            262766760,
            262758943,
            262862798,
            262762983
        ],
        "C": [
            262738877,
            262741499,
            262749383,
            262755959,
            262751324,
            262744765,
            262746576,
            262745225,
            262746869,
            262742949,
            262746742,
            262750727,
            262747283,
            262749635,
            262746257,
            262754822,
            262746319,
            262748048
        ],
        "B": [
            262726958,
            262730863,
            262733935,
            262745603,
            262761343,
            262730294,
            262743622,
            262733897,
            262738963,
            262733871,
            262744047,
            262734098,
            262734002,
            262729823,
            262734056,
            262744847,
            262730762,
            262734650
        ],
        "A": [
            262718457,
            262717434,
            262719669,
            262733443,
            262738974,
            262717708,
            262717306,
            262718538,
            262718880,
            262733522,
            262717623,
            262718056,
            262717973,
            262720675,
            262720426,
            262717331,
            262720010,
            262725818
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129858",
    "editorial": "Let's assume that the value in the i\n-th row and j\n-th column is strictly one and it is the only one in the column.\n\nThen the entire table is uniquely determined, as well as the XORificator. For each possible state of the XORificator that constructs the required table,\n\nLet's maintain a counter. Then the state that maximizes the number of columns with exactly one 1 has the maximum counter.\n\nTo efficiently maintain the counter, it is necessary to maintain the hash of the XORificator and quickly recalculate it when moving to the next row.\n\nThe answer can be easily reconstructed by traversing the table again and counting the hash. If the desired hash is obtained, simply output the state of the XORificator.\n\nThe final time complexity is O(nmlog(nm))\n or O(nm)\n if a hash map is used.",
    "name": "D. XORificator",
    "statement": "You are given a binary (consisting only of s and s) n\r\ntimes m matrix. You are also given a XORificator, using which you can\r\ninvert all the values in a chosen row (i.e. replace with and with ).A\r\ncolumn in the matrix is considered if it contains exactly one . Your\r\ntask is to find the maximum number of columns that can be made at the\r\nsame time, and the set of rows the XORificator should be used on to\r\nachieve that.\r\n",
    "solutions": [
        "// Problem: D. XORificator// Contest: Codeforces - Codeforces Round 948 (Div. 2)// URL: https://mirror.codeforces.com/contest/1977/problem/D// Memory Limit: 256 MB// Time Limit: 2000 ms// // Powered by CP Editor (https://cpeditor.org) // Author: EnucAI#include <bits/stdc++.h> #ifdef LOCAL#include \"debug.h\"#else#define D(...) ((void)0)#endif using ll = long long;using ull = unsigned long long;using ld = long double;using vi = std::vector<int>;using pii = std::pair<int, int>; constexpr int inf = std::numeric_limits<int>::max() / 2;constexpr ll infll = std::numeric_limits<ll>::max() / 2;constexpr ld eps = 1e-8l; #define all(x) (x).begin(), (x).end()#define sz(x) ((int)((x).size()))#define rep(i, j, k) for (int i = (j); i <= (k); i++)#define per(i, j, k) for (int i = (j); i >= (k); i--)#define fi first#define se second#define mp std::make_pair#define pb push_back#define ppb pop_back#define eb emplace_back template <class X, class Y> void chkmax(X &x, const Y &y) { if (x < y) x = y; }template <class X, class Y> void chkmin(X &x, const Y &y) { if (x > y) x = y; } std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count()); constexpr int maxn = 3e5 + 5; int n, m;vi a[maxn];ull val[maxn], pre[maxn], suf[maxn];std::map<ull, int> cnt; void work() {  std::cin >> n >> m;  rep(i, 1, n) a[i].resize(m + 1);  rep(i, 1, n) rep(j, 1, m) {    char c;    std::cin >> c;    a[i][j] = c - '0';  }  rep(i, 1, n) val[i] = rng();  cnt.clear();  rep(j, 1, m) {    ull bas = 0;    rep(i, 1, n) if (a[i][j]) bas ^= val[i];    rep(i, 1, n) cnt[bas ^ val[i]]++;  }  auto ans = mp(0, mp(1, 1));  rep(j, 1, m) {    pre[0] = suf[n + 1] = 0;    rep(i, 1, n) pre[i] = pre[i - 1] ^ (a[i][j] ? val[i] : 0);    per(i, n, 1) suf[i] = suf[i + 1] ^ (a[i][j] ? val[i] : 0);    rep(i, 1, n) {      ull cur = pre[i - 1] ^ suf[i + 1] ^ (a[i][j] ? 0 : val[i]);      chkmax(ans, mp(cnt[cur], mp(i, j)));    }  }  std::cout << ans.fi << '\\n';  rep(i, 1, n) std::cout << (a[i][ans.se.se] != (i == ans.se.fi));  std::cout << '\\n';} int main() {  std::cin.tie(nullptr)->sync_with_stdio(false);  int t;  std::cin >> t;  while (t--) work();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "greedy",
        "hashing"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. XORificator.json",
    "hint": []
}