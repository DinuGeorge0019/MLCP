{
    "link": "https://codeforces.com//contest/1825/problem/E",
    "problemId": "1909757",
    "problem_idx": "E",
    "shortId": "1825E",
    "contest_number": "1825",
    "problem_submissions": {
        "D1": [
            205098688,
            205101217,
            205100501,
            205098085,
            205105358,
            205106691,
            205097320,
            205101458,
            205101211,
            205102125,
            205103728,
            205102249,
            205106340,
            205105928,
            205101924,
            205105249,
            205105719,
            205103742,
            205103072,
            205109754
        ],
        "D2": [
            205098621,
            205101261,
            205100547,
            205107217,
            205105435,
            205173465,
            205106414,
            205109037,
            205107008,
            205108684,
            205105267,
            205107641,
            205106928,
            205108946,
            205109909,
            213433020,
            205105391,
            205107707,
            205184919,
            205108051,
            205106347,
            205107832,
            205114205
        ],
        "C": [
            205096242,
            205095032,
            205091245,
            205092408,
            205094374,
            205094650,
            205092981,
            205094950,
            205095388,
            205097859,
            205092688,
            205095415,
            205092193,
            205097135,
            205097614,
            205099450,
            205098808,
            205088004,
            205106824,
            205095380
        ],
        "B": [
            205093377,
            205085123,
            205089166,
            205085761,
            205087791,
            205086427,
            205087169,
            205088420,
            205087106,
            205087675,
            205085814,
            205086933,
            205087152,
            205089093,
            205086378,
            205083686,
            205091949,
            205097416,
            205089403,
            205087179
        ],
        "A": [
            205081314,
            205078338,
            205079019,
            205079835,
            205080709,
            205079855,
            205080562,
            205080265,
            205078425,
            205081350,
            205081019,
            205079877,
            205079523,
            205078495,
            213433083,
            205079154,
            205079009,
            205079859,
            205091489,
            205080325,
            205079396
        ],
        "E": [
            205276652,
            205175537,
            205175154
        ]
    },
    "name": "E. LuoTianyi and XOR-Tree",
    "statement": "LuoTianyi gives you a tree with values in its vertices, and the root of\r\nthe tree is vertex 1.In one operation, you can change the value in one\r\nvertex to any non-negative integer.Now you need to find the minimum\r\nnumber of operations you need to perform to make each path from the root\r\nto leaf^{\r\ndagger} has a bitwise XOR value of zero.^{\r\ndagger}A leaf in a rooted tree is a vertex that has exactly one neighbor\r\nand is not a root.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,a[N],Xor[N],f[N],siz[N],son[N];\nvector<int>G[N];\nset<int>st[N];\nvoid dfs0(int x,int p){\n\tsiz[x]=1;if(p)a[x]^=a[p];\n\tfor(int y:G[x])if(y^p){\n\t\tdfs0(y,x);\n\t\tsiz[x]+=siz[y];\n\t\tif(siz[y]>siz[son[x]])son[x]=y;\n\t}\n}\nvoid dfs(int x,int p){\n\tif(son[x])dfs(son[x],x),swap(st[x],st[son[x]]),f[x]+=f[son[x]];\n\telse {\n\t\tst[x].insert(a[x]);\n\t\tf[x]=1;\n\t\treturn;\n\t}\n\tmap<int,int>mp;\n\tfor(int y:G[x])if(y!=p&&y!=son[x]){\n\t\tdfs(y,x);\n\t\tf[x]+=f[y];\n\t\tfor(int i:st[y])mp[i]++;\n\t}\n\tint mx=0;\n\tfor(auto i:mp)mx=max(mx,(int)st[x].count(i.first)+i.second);\n\tvector<int>vec;for(auto i:mp)if(i.second+st[x].count(i.first)==mx)vec.emplace_back(i.first);\n\tif(mx>1)f[x]-=mx-1,st[x].clear();\n\tfor(int i:vec)st[x].insert(i);\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(int i=1,u,v;i<n;i++){\n\t\tcin>>u>>v;\n\t\tG[u].emplace_back(v),G[v].emplace_back(u);\n\t}\n\tdfs0(1,0);\n\tdfs(1,0);\n\tcout<<f[1]-st[1].count(0)<<'\\n';\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "dsu",
        "greedy",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. LuoTianyi and XOR-Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/116328",
    "editorial": "Hint: Consider a brute force dynamic programming solution and try to optimize it.\n\nDenote the minimum number of operations needed to make every path from a leaf inside the subtree of u\n to the root have the xor value of w\n as fu,w\n. Observe that for every u\n, there are only 2\n possible different values for fu,w\n. This is because if fu,w1?fu,w2>1\n, we can use an operation of xor-ing au\n with w1 xor w2\n to make all the xor values from w2\n to w1\n, which takes fu,w2+1\n steps instead of fu,w1\n.\n\nNow we only need to calculate minnu=minfu,w\n, and the set Su\n of w\n that makes fu,w\n minimum. We have minnv=0\n and Sv=the xor value from root to v\n for leaf v\n. It's trivial to calculate minnu\n.\n\nNote that Su\n contains of the numbers appearing the most times in the sets of u\n's son. We can maintain Su\n using a map and merging it heuristically. Consider when merging sets into a new set S?\n. If every element of S?\n appears only once in the original sets, then we keep S?\n as the result, otherwise, brute force the whole set S?\n and find the elements appearing the most times. For the second situation, every element's count of appearance is at least halved(those appearing once have 0\n and others have 1\n afterwards), so the number of brute force checking operations is O(nlogn)\n."
}