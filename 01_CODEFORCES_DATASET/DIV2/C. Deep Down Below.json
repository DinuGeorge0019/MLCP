{
    "link": "https://codeforces.com//contest/1561/problem/C",
    "problemId": "1088957",
    "problem_idx": "C",
    "shortId": "1561C",
    "contest_number": "1561",
    "problem_submissions": {
        "F": [
            126904536,
            126901655,
            126903407,
            126897889,
            126905462,
            126895857,
            126909746,
            126868411
        ],
        "E": [
            126872829,
            126873450,
            126873472,
            126876837,
            126887119,
            126925237,
            126873365,
            126880329,
            126880730,
            126881569,
            126878334,
            126883106,
            126884943,
            126885452,
            126887344,
            126884906,
            126885650,
            126888199,
            126863450
        ],
        "C": [
            126869012,
            126865542,
            126864086,
            126863127,
            126863122,
            126861060,
            126868974,
            126853568,
            126857674,
            126857569,
            126854957,
            126857844,
            126858666,
            126860889,
            126860513,
            126857734,
            126864125,
            126867660,
            126866693
        ],
        "D1": [
            126861759,
            126863688,
            126864717,
            126869692,
            126872900,
            126868199,
            126862491,
            126866683,
            126868762,
            126864055,
            126863339,
            126863270,
            126867571,
            126865653,
            126863522,
            126870959,
            126872615,
            126860538,
            126862556
        ],
        "D2": [
            126861568,
            126863750,
            126868373,
            126869562,
            126876457,
            126868351,
            126862413,
            126873746,
            126868674,
            126867473,
            126864201,
            126863508,
            126868989,
            126866379,
            126880112,
            126871782,
            126872752,
            126861102,
            126877754
        ],
        "B": [
            126856962,
            126852931,
            126853927,
            126857335,
            126862047,
            126855473,
            126854073,
            126848963,
            126854204,
            126852816,
            126866896,
            126854673,
            126855023,
            126857298,
            126855876,
            126863677,
            126859086,
            126871391,
            126876744
        ],
        "A": [
            126847903,
            126848403,
            126847412,
            126849843,
            126849112,
            126848036,
            126848332,
            126847281,
            126847584,
            126847566,
            126847516,
            126847717,
            126847410,
            126847430,
            126850448,
            126848322,
            126849200,
            126856163,
            126853136
        ]
    },
    "name": "C. Deep Down Below",
    "statement": "In a certain video game, the player controls a hero characterized by a\r\nsingle integer value: . The hero will have to beat monsters that are\r\nalso characterized by a single integer value: .On the current level, the\r\nhero is facing n caves. To pass the level, the hero must enter all the\r\ncaves in some order, each cave exactly once, and exit every cave safe\r\nand sound. When the hero enters cave i, he will have to fight k_i\r\nmonsters in a row: first a monster with armor a_{i, 1}, then a monster\r\nwith armor a_{i, 2} and so on, finally, a monster with armor a_{i,\r\nk_i}.The hero can beat a monster if and only if the hero’s power is\r\nstrictly greater than the monster’s armor. If the hero can’t beat the\r\nmonster he’s fighting, the game ends and the player loses. Note that\r\nonce the hero enters a cave, he can’t exit it before he fights all the\r\nmonsters in it, strictly in the given order.Each time the hero beats a\r\nmonster, the hero’s power increases by 1.Find the smallest possible\r\npower the hero must start the level with to be able to enter all the\r\ncaves in some order and beat all the monsters.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nstruct cave{\n\tLL siz,val;\n\tcave(){}\n\tcave(LL S,LL V){siz=S,val=V;}\n\tbool operator < (cave ano) const {return val<ano.val || (val==ano.val && siz>ano.siz);}\n}a[100005];\nLL n;\nvoid Solve()\n{\n\tscanf(\"%lld\",&n);\n\tfor(LL i=1;i<=n;++i)\n\t{\n\t\tLL siz;\n\t\tscanf(\"%lld\",&siz);\n\t\tLL val=0;\n\t\tfor(LL j=1;j<=siz;++j)\n\t\t{\n\t\t\tLL s;\n\t\t\tscanf(\"%lld\",&s);\n\t\t\tval=max(val,s-j+2);\n\t\t}\n\t\ta[i]=cave(siz,val);\n\t}\n\tsort(a+1,a+1+n);\n\tLL ans=a[1].val,pos=a[1].val+a[1].siz;\n\tfor(LL i=2;i<=n;++i)\n\t{\n\t\tif(pos>a[i].val)\tpos+=a[i].siz;\n\t\telse\tans+=a[i].val-pos,pos=a[i].val+a[i].siz;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\tLL T;\n\tscanf(\"%lld\",&T);\n\twhile(T-->0)\tSolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Deep Down Below.json",
    "editorial_link": "https://codeforces.com//blog/entry/94216",
    "editorial": "Consider a single cave . Suppose that the hero enters the cave with\r\npower . To beat the first monster, has to be greater than . After that,\r\nthe heroâs power will increase to , and to beat the second monster, has\r\nto be greater than . Continuing this reasoning, we can write down\r\ninequalities: ; ; ; ... . Let . The system of inequalities above is\r\nequivalent to a single inequality: .Thus, the hero can enter cave with\r\npower if and only if , and the heroâs power will increase by .Armed with\r\nthis knowledge, can we determine the best order to visit the caves for\r\nthe hero?It turns out itâs always best to enter the caves in\r\nnon-decreasing order of . Indeed, if the hero can enter cave , he should\r\nalways do that because entering a cave never makes things worse. If the\r\nhero enters a cave with greater right before a cave with smaller , he\r\nmight enter these caves in reverse order as well.Letâs sort the caves\r\naccordingly and assume . What is the smallest power the hero can start\r\nthe level with?We can use the same reasoning that we used for a single\r\ncave.Suppose the hero starts the level with power . To enter the first\r\ncave, has to be greater than . After that, the heroâs power will\r\nincrease to , and to enter the second cave, has to be greater than .\r\nContinuing this reasoning, we can write down inequalities: ; ; ; ... .\r\nLet . The system of inequalities above is equivalent to a single\r\ninequality: . Thus, the answer to the problem is .Alternatively, instead\r\nof solving the inequalities, one can use binary search on .\r\n",
    "hint": [
        "Hint 1 Consider solving the problem when the given sequence, instead of being a permutation, consists of only 0 and 1.",
        "Hint 2 The number of steps necessary to sort the permutation is equal to the maximum of these values: the number of steps needed to make the rightmost element of the sequence the number of steps needed to make and the two rightmost elements of the sequence (not necessarily in this order) the number of steps needed to make , and the three rightmost elements of the sequence (not necessarily in this order) and so on. Finding any one of these values is equivalent to the 0-1 sequence problem mentioned earlier. Thus, the original problem is reduced to copies of the new problem, with one 0 changed to an 1 each time.",
        "Hint 3 To solve the 0-1 sequence problem, compute, from right to left and for each 1, after how many steps will that 1 have no zeros to the right of it. Call this function .",
        "Hint 4 By considering whether each 1 will \"collide\" with the 1 immediately to the right of it after some steps, turns out there is a not-too-complicated formula for that depends on the value of the 1 immediately after the current 1.",
        "Hint 5 A segment tree works for quickly computing this function as the 0-1 sequence is updated."
    ]
}