{"link": "https://codeforces.com//contest/1917/problem/D", "problemId": "2396146", "problem_idx": "D", "shortId": "1917D", "contest_number": "1917", "problem_submissions": {"F": [238733616, 238732449, 238722650, 238747708, 238719236, 238789557, 238737024, 238776133, 238801763, 238731647, 239022549, 238871907, 238842440, 239033126, 238722153, 238742411], "E": [238721862, 238726116, 238727431, 238737036, 238700760, 238738779, 238770928, 238719511, 238730269, 238724820, 238713406, 238730340, 238732710, 238724485, 238737682], "D": [238707805, 238694785, 238712512, 238715225, 238727535, 238700990, 238706030, 238714969, 238715935, 238715986, 238715678, 238715941, 238738577, 238719803, 238709527, 238707807], "C": [238697529, 238700737, 238690241, 238696341, 238701325, 238711284, 238686628, 238710402, 238697578, 238703582, 238693431, 238697956, 238702600, 238708773, 238700119, 238694618, 238692698, 238693118], "B": [238682533, 238681807, 238679080, 238680525, 238688332, 238704922, 238688891, 238681860, 238681830, 238685486, 238678116, 238683453, 238695119, 238690853, 238683129, 238686944, 238685014, 238679989], "A": [238678969, 238676634, 238676579, 238676658, 238681375, 238702133, 238676697, 238677114, 238676598, 238677433, 238676559, 238676795, 238690754, 238695279, 238676668, 238682718, 238676593, 238676877]}, "name": "D. Yet Another Inversions Problem", "statement": "You are given a permutation p_0, p_1,\r\nldots, p_{n-1} of odd integers from 1 to 2n-1 and a permutation q_0,\r\nq_1,\r\nldots, q_{k-1} of integers from 0 to k-1.An array a_0, a_1,\r\nldots, a_{nk-1} of length nk is defined as follows: a_{i\r\ncdot k+j}=p_i\r\ncdot 2^{q_j} for all 0\r\nle i < n and all 0\r\nle j < k For example, if p = [3, 5, 1] and q = [0, 1], then a = [3, 6,\r\n5, 10, 1, 2].Note that all arrays in the statement are zero-indexed.\r\nNote that each element of the array a is uniquely determined.Find the\r\nnumber of inversions in the array a. Since this number can be very\r\nlarge, you should find only its remainder modulo 998\r\n,244\r\n,353.An inversion in array a is a pair (i, j) (0\r\nle i < j < nk) such that a_i > a_j.\r\n", "solutions": ["#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<random>\n#include<ctime>\nusing namespace std;\nconst int maxn=200005;\nconst int mod=998244353;\nint T,n,m,p1[maxn],p2[maxn];\nint lowbit(int x){return x&-x;}\nstruct tl_s{\n\tint mx,data[maxn*2];\n\tvoid clear(int x){\n\t\tfor(int i=1;i<=mx;++i)data[i]=0;\n\t\tmx=x;\n\t}\n\tint add(int x){\n\t\tfor(;x<=mx;x+=lowbit(x))data[x]++;\n\t}\n\tint ask(int x){\n\t\tint res=0;\n\t\tfor(;x;x-=lowbit(x))res+=data[x];\n\t\treturn res;\n\t}\n}t1;\nsigned main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>T;\n\twhile(T--){\n\t\tint ans=0;\n\t\tcin>>n>>m;\n\t\tfor(int i=1;i<=n;++i)cin>>p1[i];\n\t\tfor(int i=1;i<=m;++i)cin>>p2[i],p2[i]++;\n\t\tt1.clear(m);\n\t\tfor(int i=m;i>=1;--i){\n\t\t\tans=(ans+(long long)n*t1.ask(p2[i]))%mod;\n\t\t\tt1.add(p2[i]);\n\t\t}\n\t\tt1.clear(2*n-1);\n\t\tfor(int i=n;i>=1;--i){\n\t\t\tfor(int j=0,tmp=p1[i];j<m;++j,tmp*=2){\n\t\t\t\tif(tmp>2*n-1){\n\t\t\t\t\tans=(ans+(long long)(m-j)*(m-j+1)/2%mod*(n-i))%mod;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans=(ans+(long long)t1.ask(tmp)*(m-j))%mod;\n\t\t\t}\n\t\t\tfor(int j=0,tmp=p1[i];tmp&&j<m;++j,tmp/=2){\n\t\t\t\tif(j)ans=(ans+(long long)t1.ask(tmp)*(m-j))%mod;\n\t\t\t}\n\t\t\tt1.add(p1[i]);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "data structures", "dp", "implementation", "math", "number theory"], "dificulty": "2300", "interactive": false}