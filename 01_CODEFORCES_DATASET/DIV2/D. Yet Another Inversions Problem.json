{
    "link": "https://codeforces.com//contest/1917/problem/D",
    "problemId": "2396146",
    "problem_idx": "D",
    "shortId": "1917D",
    "contest_number": "1917",
    "problem_submissions": {
        "F": [
            238733616,
            238732449,
            238722650,
            238747708,
            238719236,
            238789557,
            238737024,
            238776133,
            238801763,
            238731647,
            239022549,
            238871907,
            238842440,
            239033126,
            238722153,
            238742411
        ],
        "E": [
            238721862,
            238726116,
            238727431,
            238737036,
            238700760,
            238738779,
            238770928,
            238719511,
            238730269,
            238724820,
            238713406,
            238730340,
            238732710,
            238724485,
            238737682
        ],
        "D": [
            238707805,
            238694785,
            238712512,
            238715225,
            238727535,
            238700990,
            238706030,
            238714969,
            238715935,
            238715986,
            238715678,
            238715941,
            238738577,
            238719803,
            238709527,
            238707807
        ],
        "C": [
            238697529,
            238700737,
            238690241,
            238696341,
            238701325,
            238711284,
            238686628,
            238710402,
            238697578,
            238703582,
            238693431,
            238697956,
            238702600,
            238708773,
            238700119,
            238694618,
            238692698,
            238693118
        ],
        "B": [
            238682533,
            238681807,
            238679080,
            238680525,
            238688332,
            238704922,
            238688891,
            238681860,
            238681830,
            238685486,
            238678116,
            238683453,
            238695119,
            238690853,
            238683129,
            238686944,
            238685014,
            238679989
        ],
        "A": [
            238678969,
            238676634,
            238676579,
            238676658,
            238681375,
            238702133,
            238676697,
            238677114,
            238676598,
            238677433,
            238676559,
            238676795,
            238690754,
            238695279,
            238676668,
            238682718,
            238676593,
            238676877
        ]
    },
    "name": "D. Yet Another Inversions Problem",
    "statement": "You are given a permutation p_0, p_1,\r\nldots, p_{n-1} of odd integers from 1 to 2n-1 and a permutation q_0,\r\nq_1,\r\nldots, q_{k-1} of integers from 0 to k-1.An array a_0, a_1,\r\nldots, a_{nk-1} of length nk is defined as follows: a_{i\r\ncdot k+j}=p_i\r\ncdot 2^{q_j} for all 0\r\nle i < n and all 0\r\nle j < k For example, if p = [3, 5, 1] and q = [0, 1], then a = [3, 6,\r\n5, 10, 1, 2].Note that all arrays in the statement are zero-indexed.\r\nNote that each element of the array a is uniquely determined.Find the\r\nnumber of inversions in the array a. Since this number can be very\r\nlarge, you should find only its remainder modulo 998\r\n,244\r\n,353.An inversion in array a is a pair (i, j) (0\r\nle i < j < nk) such that a_i > a_j.\r\n",
    "solutions": [
        "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<random>\n#include<ctime>\nusing namespace std;\nconst int maxn=200005;\nconst int mod=998244353;\nint T,n,m,p1[maxn],p2[maxn];\nint lowbit(int x){return x&-x;}\nstruct tl_s{\n\tint mx,data[maxn*2];\n\tvoid clear(int x){\n\t\tfor(int i=1;i<=mx;++i)data[i]=0;\n\t\tmx=x;\n\t}\n\tint add(int x){\n\t\tfor(;x<=mx;x+=lowbit(x))data[x]++;\n\t}\n\tint ask(int x){\n\t\tint res=0;\n\t\tfor(;x;x-=lowbit(x))res+=data[x];\n\t\treturn res;\n\t}\n}t1;\nsigned main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>T;\n\twhile(T--){\n\t\tint ans=0;\n\t\tcin>>n>>m;\n\t\tfor(int i=1;i<=n;++i)cin>>p1[i];\n\t\tfor(int i=1;i<=m;++i)cin>>p2[i],p2[i]++;\n\t\tt1.clear(m);\n\t\tfor(int i=m;i>=1;--i){\n\t\t\tans=(ans+(long long)n*t1.ask(p2[i]))%mod;\n\t\t\tt1.add(p2[i]);\n\t\t}\n\t\tt1.clear(2*n-1);\n\t\tfor(int i=n;i>=1;--i){\n\t\t\tfor(int j=0,tmp=p1[i];j<m;++j,tmp*=2){\n\t\t\t\tif(tmp>2*n-1){\n\t\t\t\t\tans=(ans+(long long)(m-j)*(m-j+1)/2%mod*(n-i))%mod;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans=(ans+(long long)t1.ask(tmp)*(m-j))%mod;\n\t\t\t}\n\t\t\tfor(int j=0,tmp=p1[i];tmp&&j<m;++j,tmp/=2){\n\t\t\t\tif(j)ans=(ans+(long long)t1.ask(tmp)*(m-j))%mod;\n\t\t\t}\n\t\t\tt1.add(p1[i]);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dp",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Yet Another Inversions Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/123721",
    "editorial": "Letâs split the array into subarrays of the length . The\nrelative order of the elements in each of them is the same (as in\npermutation ), so the number of inversions is the same, too. You can\nfind the number of invesions in one of them as described in the hint .\nBy multiplying this number by , you count all the in-block\ninversions.All the remaining inversions are formed by pairs of elements\nfrom the distinct blocks. You may assume that now for simplicity: it\nwonât change the number of such inversions.Letâs fix two elements and of\nand count the number of inversions such that and for some and . It is\nequivalent to counting the number of inversions in the array .Consider\nmerging two arrays and with ( and are odd) into one sorted subarray: if\n, then the resulting array would look like ; if , then the resulting\narray would look like ; if , then the resulting array would look like ;\n... You can see several blue elements in the beginning, followed by\nalternating blue and red elements, which are followed by several red\nelements. The number of blue elements in the beginning is equal to the\nnumber of red elements in the end and equal to the largest such that .\nFurthermore, this is also limited by because and are both positive\nintegers less than .If the situation is similar, but the order of colors\nis reversed.Going back to inversions, we have some array . Inversions\nare formed by a large blue element and a small red element. if , then\nthere are inversions; if , the there are inversions; if , the there are\ninversions; ... For the situation is similar, but we will start with\ninversions for and we will add terms instead of substracting them.Well,\nnow we can solve this problem in : enumerate pairs , find and add some\nvalue to the answer.Now letâs add the inversion counting algorithm to\nsolve this problem. Again, letâs solve the problem for first. Letâs\nenumerate the value of from to . the -s on the right of should not be\ncounted in now; each of the -s on the left of such that adds to the\nanswer; each of the -s on the left of such that adds to the answer; each\nof the -s on the left of such that adds to the answer; ... We can\nmaintain a segment tree to compute the sum of the values we should sum\nup. To update this segment tree letâs additionally maintain pointers\nthat maintain the largest such that for each from to .The solution is\nsimilar for pairs.You should be careful when implementing this, because\nfor small at some moment there becomes elements in the alternating\nsegment of the blue-red array and you shouldnât substract anything\nfurther.\n",
    "hint": [
        "Hint 1 How to count the number of inversions in the permutation of length in ?",
        "Hint 2 Consider two arrays and for some positive . How does the number of inversions in one of them correspond to the number of inversions in the other of them?",
        "Hint 3 Consider splitting array into subarrays of the length .",
        "Hint 4 Let's say you have two arrays and of the same length. How many inversions are there in their concatenation ?",
        "Hint 5 Consider the merging process of arrays and into the sorted array (as in the merge sort).",
        "Hint 6 What if the first elements of the arrays you concatenate are not and but some odd positive integers and ? Merging processes for some pairs look quite similar.",
        "Hint 7 The number of inversions in the array depends only on and . You don't need to think about rounding of because and are odd in this problem. Also, is the same for all merges.",
        "Hint 8 Consider the following algorithm to find the number of inversions in the permutation: make a segment tree corresponding to this permutation and fill it with zeroes. For all from to find such that , increase the -th element of this segment tree by and add the sum of elements on the right of the -th element to the number of inversions. Improve this algorithm to count the number of inversions in array assuming .",
        "Hint 9 The problem can be solved in . The order of elements in matters only on the inversions inside the blocks of length you chosen in the hint ."
    ]
}