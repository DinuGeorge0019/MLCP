{
    "link": "https://codeforces.com//contest/1248/problem/B",
    "problemId": "445264",
    "problem_idx": "B",
    "shortId": "1248B",
    "contest_number": "1248",
    "problem_submissions": {
        "D1": [
            62994883,
            62993569,
            62992994,
            62997000,
            62994405,
            62997123,
            62999879,
            62995062,
            63003271,
            63000150,
            62999671,
            62994350,
            62998586,
            63000530,
            62992886,
            63075982,
            63072868,
            62991824,
            63006771
        ],
        "F": [
            62993845,
            62998618,
            63004376,
            63001516,
            63005145,
            63007254,
            63006725,
            63065814,
            63007421,
            63002656,
            63007898,
            63005627,
            63007696,
            63008967,
            63006462,
            63004460,
            63011504,
            63004125,
            63006964
        ],
        "E": [
            62985708,
            63073739,
            63003347,
            63018519,
            63004851
        ],
        "B": [
            62982231,
            62980110,
            62981055,
            62979292,
            62979961,
            62980992,
            62979799,
            62981220,
            62982692,
            62978096,
            62982064,
            62982362,
            62978497,
            62981072,
            62981976,
            62984594,
            63075956,
            62980955,
            62980611,
            62983563,
            62990769
        ],
        "A": [
            62979317,
            62977969,
            62978225,
            62977588,
            62977692,
            62977600,
            62977679,
            62978301,
            62980908,
            62977684,
            62981014,
            62982770,
            62977469,
            62977721,
            62977859,
            62979794,
            63075933,
            62977868,
            62980509,
            62980376,
            62988720
        ],
        "C": [
            62977501,
            62984679,
            62987113,
            62992373,
            62990888,
            62990326,
            62991798,
            62987434,
            62987346,
            62987305,
            62995225,
            62994509,
            63000614,
            62991483,
            62996125,
            63009114,
            62993964,
            62985766,
            62994340,
            62987126
        ],
        "D2": [
            63072452,
            63005552
        ]
    },
    "name": "B. Grow The Tree",
    "statement": "Gardener Alexey teaches competitive programming to high school students.\r\nTo congratulate Alexey on the Teacher\u2019s Day, the students have gifted\r\nhim a collection of wooden sticks, where every stick has an integer\r\nlength. Now Alexey wants to grow a tree from them.The tree looks like a\r\npolyline on the plane, consisting of all sticks. The polyline starts at\r\nthe point (0, 0). While constructing the polyline, Alexey will attach\r\nsticks to it one by one in arbitrary order. Each stick must be either\r\nvertical or horizontal (that is, parallel to OX or OY axis). It is not\r\nallowed for two consecutive sticks to be aligned simultaneously\r\nhorizontally or simultaneously vertically. See the images below for\r\nclarification.Alexey wants to make a polyline in such a way that its end\r\nis as far as possible from (0, 0). Please help him to grow the tree this\r\nway.Note that the polyline defining the form of the tree may have\r\nself-intersections and self-touches, but it can be proved that the\r\noptimal answer does not contain any self-intersections or self-touches.\r\n",
    "solutions": [
        "// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC optimize(\"Ofast,no-stack-protector\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define debug(x) std::cerr << (#x) << \":\\t\" << (x) << std::endl;\n#define fastIO std::ios_base::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nstd::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst double PI = atan2(0., -1.);\nconst int INF = 0x3f3f3f3f;\nconst int N = 100100;\n\nint a[N];\n\nint main(void) {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tll s1 = 0, s2 = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (i < n / 2) {\n\t\t\ts1 += a[i];\n\t\t} else {\n\t\t\ts2 += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", s1 * s1 + s2 * s2);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Grow The Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/70720",
    "editorial": "At first, let\u00e2\u0080\u0099s do some maths. Consider having an expression which we\r\nhave to maximize, while , where is some constant. Let\u00e2\u0080\u0099s proof that the\r\nmaximum is achieved when or is maximum possible.At first let or be about\r\nthe same, while . Let\u00e2\u0080\u0099s see what happens when we add to and subtract\r\nfrom . . Since , this expression is greater than . It means that we\r\nshould maximize (or , doing the same steps) in order to achieve the\r\nmaximum of .Notice that we should always grow the tree in one direction.\r\nFor definiteness, let horizontal sticks go from left to right and\r\nvertical from down to top. Now, answer equals to square of the sum of\r\nlengths of horizontal sticks plus square of the sum of lengths of\r\nvertical sticks. As we proved earlier, to maximize this expression, we\r\nshould maximize one of the numbers under the squares.Let\u00e2\u0080\u0099s sort sticks\r\nby order and orient the half (and medium element if there\u00e2\u0080\u0099s an odd\r\namount of sticks) with the greater length vertically, and the other half\r\nhorizontally.Work time: Bonus: can you solve this problem in ?\r\n"
}