{
    "link": "https://codeforces.com//contest/777/problem/B",
    "problemId": "95270",
    "problem_idx": "B",
    "shortId": "777B",
    "contest_number": "777",
    "problem_submissions": {
        "A": [
            24966990,
            24969452,
            24968363,
            24961059,
            24970780,
            24961457,
            24961212,
            24964368,
            24961021,
            24961075,
            24961276,
            24968207,
            24961160,
            24961145,
            24961597,
            24961088,
            24961260,
            24961357,
            24961505
        ],
        "E": [
            24964879,
            24966304,
            24963804,
            24968582,
            24963318,
            24970420,
            24969486,
            24969542,
            24970873,
            24970390,
            24974213,
            24970580,
            24968519,
            24973982,
            24970975,
            24971187,
            24963290,
            24970842,
            24971523
        ],
        "B": [
            24964009,
            24967778,
            24967683,
            24963456,
            24969920,
            24963117,
            24963334,
            24963518,
            24962640,
            24962082,
            24964002,
            24966808,
            24963703,
            24964670,
            24963319,
            24962925,
            24965213,
            24963141,
            24964096
        ],
        "D": [
            24963351,
            24963866,
            24965089,
            24966596,
            24965947,
            24966910,
            24968904,
            24967595,
            24967923,
            24969584,
            24969186,
            24965258,
            24970085,
            24968109,
            24969127,
            24967832,
            24973541,
            24967166,
            24969092
        ],
        "C": [
            24962594,
            24962120,
            24965927,
            24965332,
            24967533,
            24965029,
            24965533,
            24961512,
            24966207,
            24962969,
            24966524,
            24962408,
            24965583,
            24963130,
            24965668,
            24964725,
            24967206,
            24965425,
            24966427
        ]
    },
    "name": "B. Game of Credit Cards",
    "statement": "After the fourth season Sherlock and Moriary have realized the whole\r\nfoolishness of the battle between them and decided to continue their\r\ncompetitions in peaceful game of Credit Cards.Rules of this game are\r\nsimple: each player bring his favourite -digit credit card. Then both\r\nplayers name the digits written on their cards one by one. If two digits\r\nare not equal, then the player, whose digit is smaller gets a flick\r\n(knock in the forehead usually made with a forefinger) from the other\r\nplayer. For example, if , Sherlock’s card is and Moriarty’s card has\r\nnumber , first Sherlock names and Moriarty names so Sherlock gets a\r\nflick. Then they both digit so no one gets a flick. Finally, Sherlock\r\nnames , while Moriarty names and gets a flick.Of course, Sherlock will\r\nplay honestly naming digits one by one in the order they are given,\r\nwhile Moriary, as a true villain, plans to cheat. He is going to name\r\nhis digits in some other order (however, he is not going to change the\r\noverall number of occurences of each digit). For example, in case above\r\nMoriarty could name , , and get no flicks at all, or he can name , and\r\nto give Sherlock two flicks.Your goal is to find out the minimum\r\npossible number of flicks Moriarty will get (no one likes flicks) and\r\nthe maximum possible number of flicks Sherlock can get from Moriarty.\r\nNote, that these two goals are different and the optimal result may be\r\nobtained by using different strategies.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define REP(i, a, b) for (register int i = a; i <= b; ++i)\n#define PER(i, a, b) for (register int i = a; i >= b; --i)\n#define RVC(i, S) for (int i = 0; i < S.size(); ++i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\n\ninline LL read() {\n\tLL x = 0; int ch = getchar(), f = 1;\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n\treturn x * f;\n}\n\nint n, cnts[10], cntm[10], ta[10], tb[10];\nstring s;\nint main(){\n\tcin >> n;\n\tcin >> s;\n\tREP(i, 0, n - 1) cnts[s[i] - '0']++;\n\tcin >> s;\n\tREP(i, 0, n - 1) cntm[s[i] - '0']++;\n\t\n\tmemcpy(ta, cnts, sizeof cnts);\n\tmemcpy(tb, cntm, sizeof cntm);\n\n\tint j = 0, ans1 = 0;\n\tREP(i, 0, 9){\n\t\tj = i;\n\t\twhile (ta[i]){\n\t\t\tint dt = min(ta[i], tb[j]);\n\t\t\tta[i] -= dt; tb[j] -= dt;\n\t\t\tif (j == 9 && tb[j] == 0) break;\n\t\t\tif (tb[j] == 0) ++j;\n\t\t}\n\t\tans1 += ta[i];\n\t}\n\n\tmemcpy(ta, cnts, sizeof cnts);\n\tmemcpy(tb, cntm, sizeof cntm);\n\t\n\tint ans2 = 0;\n\tREP(i, 0, 9){\n\t\tj = i + 1;\n\t\twhile (j <= 9 && ta[i]){\n\t\t\tint dt = min(ta[i], tb[j]);\n\t\t\tta[i] -= dt; tb[j] -= dt;\n\t\t\tans2 += dt;\n\t\t\tif (j == 9 && tb[j] == 0) break;\n\t\t\tif (tb[j] == 0) ++j;\n\t\t}\n\t}\n\n\tcout << ans1 << endl << ans2 << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Game of Credit Cards.json",
    "editorial_link": "https://codeforces.com//blog/entry/50670",
    "editorial": "First we want to consider a strategy that minimizes the amount of flicks\r\nMoriarty will receive from Sherlock. This is similar to loosing as few\r\nrounds as possible. He can use digit can be used to not loose against\r\ndigit , digit to not loose against digits and and so on. Thus, Moriarty\r\nshould try all digits from to and greedily apply them to Sherlockâs\r\ndigits they can beat. If the maximum number of rounds Moriarty can not\r\nloose is the answer for the first question is .For the second question\r\nwe need to count the maximum number of rounds Moriarty can win. Now\r\ndigit is useless, digit wins against digit , digit wins against digits\r\nand , and so on. Thus, Moriarty should consider his digits from to and\r\ngreedily use them to digits they can beat.\r\n",
    "hint": []
}