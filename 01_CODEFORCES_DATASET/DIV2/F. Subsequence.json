{
    "link": "https://codeforces.com//contest/1581/problem/F",
    "problemId": "1125263",
    "problem_idx": "F",
    "shortId": "1581F",
    "contest_number": "1581",
    "problem_submissions": {
        "E": [
            130358132,
            130358184,
            130357795,
            130357396,
            130363906,
            130366616,
            130380883,
            130364377,
            130368000,
            130362620,
            130366569,
            130368794,
            130369661,
            130369712,
            130368935,
            130369593
        ],
        "C": [
            130344859,
            130342831,
            130347382,
            130345373,
            130344614,
            130353134,
            130351174,
            130350702,
            130351743,
            130352941,
            130352739,
            130356445,
            130357169,
            130351772,
            130355715,
            130362975,
            130356919,
            130369384,
            130361864
        ],
        "B": [
            130340369,
            130340723,
            130340571,
            130339802,
            130369559,
            130359629,
            130340447,
            130931058,
            130343832,
            130341175,
            130342532,
            130359618,
            130341192,
            130359579,
            130352120,
            130344927,
            130346716,
            130361490
        ],
        "A": [
            130338529,
            130338446,
            130338430,
            130342422,
            130338506,
            130341004,
            130338410,
            130340505,
            130339368,
            130338352,
            130339712,
            130339153,
            130338540,
            130338470,
            130338894,
            130339891,
            130340851,
            130340222,
            130339139
        ],
        "D": [
            130369924,
            130441595,
            130369549,
            130356147
        ],
        "F": [
            130356873,
            130360044,
            130368525,
            130369827,
            130370044
        ]
    },
    "name": "F. Subsequence",
    "statement": "Alice has an integer sequence a of length n and . She will choose a\r\nsubsequence of a of length m, and defines the value of a subsequence\r\na_{b_1},a_{b_2},\r\nldots,a_{b_m} as\r\nsum_{i = 1}^m (m\r\ncdot a_{b_i}) -\r\nsum_{i = 1}^m\r\nsum_{j = 1}^m f(\r\nmin(b_i, b_j),\r\nmax(b_i, b_j)), where f(i, j) denotes\r\nmin(a_i, a_{i + 1},\r\nldots, a_j).Alice wants you to help her to maximize the value of the\r\nsubsequence she choose.A sequence s is a subsequence of a sequence t if\r\ns can be obtained from t by deletion of several (possibly, zero or all)\r\nelements.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define reg register\n#define ll long long\nusing namespace std;\nconst int mxn=4004;\n\nconst int maxn=10005;\nchar buffer[maxn],*S,*T;\ninline char Get_Char(){\n    if(S==T){\n        T=(S=buffer)+fread(buffer,1,maxn,stdin);\n        if(S==T)return EOF;\n    }\n    return *S++;\n}\n \ninline int read(){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;\n    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();\n    if(f)return -re;\n    return re;\n}\n \ninline void read(int&x){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;\n    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\ninline void read(ll&x){\n    reg char c;\n    reg ll re=0,f=0;\n    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;\n    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\n#define int ll\nint ls[mxn],rs[mxn],n,m,a[mxn],sta[mxn];\nll dp[mxn][mxn];//dp[i][j]表示考虑到以i为根的子树中选j个的最大代价\nll sz[mxn];\ninline void go(int x){\n\tdp[x][0]=0;\n\tsz[x]=1;\n\tdp[x][1]=(m-1)*a[x];\n\tif(!ls[x] and !rs[x]){\n\t\tsz[x]=1;\n\t\treturn; \n\t}\n\tif(ls[x] and !rs[x]){\n\t\tgo(ls[x]);\n\t\tsz[x]=sz[ls[x]]+1;\n\t\tfor(int i=0;i<=sz[ls[x]];++i){\n\t\t\tdp[x][i]=max(dp[x][i],dp[ls[x]][i]);\n\t\t\tdp[x][i+1]=max(dp[x][i+1],dp[ls[x]][i]+m*a[x]-(2ll*(i+1)-1)*a[x]);\n\t\t}\n\t\treturn;\n\t}\n\tif(rs[x] and !ls[x]){\n\t\tgo(rs[x]);\n\t\tsz[x]=sz[rs[x]]+1;\n\t\tfor(int i=0;i<=sz[rs[x]];++i){\n\t\t\tdp[x][i]=max(dp[x][i],dp[rs[x]][i]);\n\t\t\tdp[x][i+1]=max(dp[x][i+1],dp[rs[x]][i]+m*a[x]-(2ll*(i+1)-1)*a[x]);\n\t\t}\n\t\treturn;\n\t}\n\t{\n\t\tgo(ls[x]);\n\t\tgo(rs[x]);\n\t\tsz[x]=sz[ls[x]]+sz[rs[x]]+1;\n\t\tfor(int i=0;i<=sz[ls[x]];++i){\n\t\t\tfor(int j=0;j<=sz[rs[x]];++j){\n\t\t\t\tif(i+j>m)break;\n\t\t\t\tdp[x][i+j]=max(dp[x][i+j],dp[ls[x]][i]+dp[rs[x]][j]-2ll*(i)*(j)*a[x]);\n\t\t\t\tdp[x][i+j+1]=max(dp[x][i+j+1],dp[ls[x]][i]+dp[rs[x]][j]+m*a[x]-(2ll*(i+1)*(j+1)-1)*a[x]);\n\t\t\t}\n\t\t}\n\t}\n}\nint root;\nint inr[mxn];\nsigned main(){\n\treg int top=0,pos=0;\n\tread(n),read(m);\n\tfor(reg int i=1;i<=n;++i){\n\t\tread(a[i]);\n\t\tpos=top;\n\t\twhile(pos and a[sta[pos]]>a[i])--pos;\n\t\tif(rs[sta[pos]])ls[i]=rs[sta[pos]];\n\t\trs[sta[pos]]=i;\n\t\tsta[++pos]=i;\n\t\ttop=pos;\n\t}\n\tfor(int i=1;i<=n;++i)inr[ls[i]]=1,inr[rs[i]]=1;\n//\tfor(int i=1;i<=n;++i)cerr<<ls[i]<<' '<<rs[i]<<'\\n'; \n\tfor(int i=1;i<=n;++i)if(!inr[i]){\n\t\troot=i;\n\t\tbreak;\n\t}\n\tmemset(dp,-63,sizeof(dp));\n\tgo(root);//cerr<<root<<'\\n';\n\tcout<<dp[root][m]<<'\\n';\n//\tfor(int i=1;i<=n;++i){\n//\t\tcerr<<\"SZ: \"<<sz[i]<<\" | \";\n//\t\tfor(int j=0;j<=m;++j)cerr<<dp[i][j]<<' ';cerr<<'\\n'; \n//\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/95477",
    "editorial": "First we can change the way we calculate the value of a subsequence. We can easily see the value of a subsequence ab1,ab2,,abm\n is also ?mi=1?mj=i+1abi+abj?2×f(bi,bj)\n, which is very similar to the distance of two node on a tree. Thus we can build the cartesian tree of the sequence, and set the weight of a edge between node i\n and j\n as |ai?aj|\n. Then we can see what we are going to calculate turns into follows : choosing m\n nodes, maximize the total distance between every two nodes. Thus we can solve this task using dynamic programming with the time complexity O(n2)\n.",
    "hint": []
}