{"link": "https://codeforces.com//contest/1649/problem/F", "problemId": "1318588", "problem_idx": "F", "shortId": "1649F", "contest_number": "1649", "problem_submissions": {"E": [148570405, 148567587, 148573812, 148564341, 148576426, 148573557, 148575813, 148579228, 148575906, 148578716, 148579271, 148582328, 148662355, 148583368, 148578883, 148582802, 148585418, 148586818, 148585982, 148581078, 148612161, 148588539], "D": [148557933, 148560820, 148562956, 148546618, 148566533, 148563719, 148566682, 148565430, 148568037, 148566184, 148563368, 148567438, 148563519, 148569228, 148568798, 148555841, 148568207, 148564278, 148570230, 148612195, 148612000, 148565213], "C": [148552699, 148553185, 148557085, 148565920, 148554169, 148559874, 148558298, 148559324, 148560060, 148552010, 148557966, 148557845, 148558319, 148563597, 148559134, 148551291, 148559957, 148557540, 148559934, 148557341], "B": [148549340, 148547930, 148551996, 148570058, 148544445, 148556309, 148549430, 148554177, 148555299, 148555535, 148553000, 148547200, 148552578, 148554529, 148552354, 148559155, 148554077, 149225497, 148573979, 148552460, 148550780], "A": [148541954, 148570044, 148542065, 148571095, 148541611, 148544925, 148541660, 148544973, 148544958, 148558109, 148541535, 148542135, 148541834, 148556570, 148541907, 148561936, 148542732, 149225451, 148543259, 148541552, 148544161], "F": [148802496, 148696109, 148694405]}, "name": "F. Serious Business", "statement": "Dima is taking part in a show organized by his friend Peter. In this\r\nshow Dima is required to cross a 3\r\ntimes n rectangular field. Rows are numbered from 1 to 3 and columns are\r\nnumbered from 1 to n.The cell in the intersection of the i-th row and\r\nthe j-th column of the field contains an integer a_{i,j}. Initially\r\nDima\u2019s score equals zero, and whenever Dima reaches a cell in the row i\r\nand the column j, his score changes by a_{i,j}. Note that the score can\r\nbecome negative.Initially all cells in the first and the third row are\r\nmarked as available, and all cells in the second row are marked as\r\nunavailable. However, Peter offered Dima some help: there are q special\r\noffers in the show, the i-th special offer allows Dima to mark cells in\r\nthe second row between l_i and r_i as available, though Dima\u2019s score\r\nreduces by k_i whenever he accepts a special offer. Dima is allowed to\r\nuse as many special offers as he wants, and might mark the same cell as\r\navailable multiple times.Dima starts his journey in the cell (1, 1) and\r\nwould like to reach the cell (3, n). He can move either down to the next\r\nrow or right to the next column (meaning he could increase the current\r\nrow or column by 1), thus making n + 1 moves in total, out of which\r\nexactly n - 1 would be horizontal and 2 would be vertical.Peter promised\r\nDima to pay him based on his final score, so the sum of all numbers of\r\nall visited cells minus the cost of all special offers used. Please help\r\nDima to maximize his final score.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define rt 1,0,n\n#define lc 2*k\n#define rc 2*k+1\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define ll long long\nusing namespace std;\nconst int N=5e5+10;\nconst ll inf=1e17;//chkhere!!!\nint n,m,a[4][N];\nll dp[N],pre[N],suf[N],sum[N];\nstruct node\n{\n\tint l,r,w;\n}b[N];\nvoid chkmax(ll &x,ll y) {if(x<y) x=y;}\nbool cmp(node x,node y) {return x.r<y.r;}\nnamespace SEG1\n{\n\tll tr[N<<2];\n\tvoid build(int k,int l,int r)\n\t{\n\t\tif(l==r) {tr[k]=-inf;return;}\n\t\tint mid=l+r>>1;\n\t\tbuild(ls);build(rs);\n\t\ttr[k]=max(tr[lc],tr[rc]);\n\t}\n\tvoid update(int k,int l,int r,int x,ll v)\n\t{\n\t\tif(l==r) {chkmax(tr[k],v);return;}\n\t\tint mid=l+r>>1;\n\t\tif(x<=mid) update(ls,x,v);\n\t\telse update(rs,x,v);\n\t\ttr[k]=max(tr[lc],tr[rc]);\n\t}\n\tll query(int k,int l,int r,int ql,int qr)\n\t{\n\t\tif(qr<l||ql>r) return -inf;\n\t\tif(ql<=l&&qr>=r) return tr[k];\n\t\tint mid=l+r>>1;\n\t\treturn max(query(ls,ql,qr),query(rs,ql,qr));\n\t}\n}\nnamespace SEG2\n{\n\tstruct data\n\t{\n\t\tll max_dp,max_suf,max_ans;\n\t}tr[N<<2];\n\tdata operator + (data x,data y)\n\t{\n\t\tdata res;\n\t\tres.max_ans=max(x.max_ans,y.max_ans);\n\t\tchkmax(res.max_ans,x.max_dp+y.max_suf);\n\t\tres.max_dp=max(x.max_dp,y.max_dp);\n\t\tres.max_suf=max(x.max_suf,y.max_suf);\n\t\treturn res;\n\t}\n\tvoid build(int k,int l,int r)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\ttr[k].max_ans=-inf;\n\t\t\ttr[k].max_dp=dp[l];\n\t\t\ttr[k].max_suf=sum[l]+suf[l];\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tbuild(ls);build(rs);\n\t\ttr[k]=tr[lc]+tr[rc];\n\t}\n\tdata query(int k,int l,int r,int ql,int qr)\n\t{\n\t\tif(ql<=l&&qr>=r) return tr[k];\n\t\tint mid=l+r>>1;\n\t\tif(qr<=mid) return query(ls,ql,qr);\n\t\telse if(ql>mid) return query(rs,ql,qr);\n\t\treturn query(ls,ql,qr)+query(rs,ql,qr);\n\t}\n}\nnamespace RMQ\n{\n\tll maxn[N][19];int getlog[N];\n\tvoid init()\n\t{\n\t\tfor(int i=2;i<=n;i++) getlog[i]=getlog[i>>1]+1;\n\t\tfor(int i=1;i<=n;i++) maxn[i][0]=pre[i]-sum[i-1];\n\t\tfor(int j=1;j<=18;j++) for(int i=1;i+(1<<j)-1<=n;i++)\n\t\t\tmaxn[i][j]=max(maxn[i][j-1],maxn[i+(1<<j-1)][j-1]);\n\t}\n\tll query(int l,int r)\n\t{\n\t\tint k=getlog[r-l+1];\n\t\treturn max(maxn[l][k],maxn[r-(1<<k)+1][k]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=3;i++) for(int j=1;j<=n;j++) scanf(\"%d\",&a[i][j]);\n\tfor(int i=1;i<=n;i++) pre[i]=pre[i-1]+a[1][i];\n\tfor(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[2][i];\n\tfor(int i=n;i;i--) suf[i]=suf[i+1]+a[3][i];\n\tfor(int i=1;i<=m;i++) scanf(\"%d%d%d\",&b[i].l,&b[i].r,&b[i].w);\n\tsort(b+1,b+m+1,cmp);\n\tRMQ::init();\n\tfor(int i=0;i<=n;i++) dp[i]=-inf;\n\tSEG1::build(rt);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l=b[i].l,r=b[i].r,w=b[i].w;\n\t\tchkmax(dp[r],max(SEG1::query(rt,l-1,r)-w,RMQ::query(l,r)-w));\n\t\tSEG1::update(rt,r,dp[r]);\n\t}\n//\tfor(int i=1;i<=n;i++) printf(\"%lld \",dp[i]);puts(\"\");\n\tll ans=-inf;\n\tfor(int i=0;i<=n;i++) chkmax(dp[i],pre[i+1]-sum[i]);\n\tSEG2::build(rt);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l=b[i].l,r=b[i].r,w=b[i].w;\n\t\tchkmax(ans,SEG2::query(rt,l-1,r).max_ans-w);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "dp"], "dificulty": "2800", "interactive": false}