{
    "link": "https://codeforces.com//contest/366/problem/E",
    "problemId": "4076",
    "problem_idx": "E",
    "shortId": "366E",
    "contest_number": "366",
    "problem_submissions": {
        "E": [
            5223414,
            5232960,
            5224601,
            5224400,
            5224222,
            5217176,
            5224737,
            5224278,
            5226537,
            5218732,
            5224501,
            5240243,
            5224536,
            5228081,
            5226578
        ],
        "D": [
            5217035,
            5218139,
            5218798,
            5218839,
            5218268,
            5218550,
            5226120,
            5224735,
            5218888,
            5218628,
            5223995,
            5223329,
            5223776,
            5223645,
            5224564
        ],
        "C": [
            5215635,
            5215143,
            5216612,
            5216695,
            5224015,
            5217024,
            5216364,
            5232085,
            5225511,
            5216977,
            5216046,
            5215965,
            5216961,
            5216956,
            5217291,
            5216898,
            5216929,
            5218407,
            5225537,
            5223478
        ],
        "B": [
            5214230,
            5213966,
            5214711,
            5214981,
            5223546,
            5215334,
            5214481,
            5217130,
            5214153,
            5214206,
            5214371,
            5214882,
            5214468,
            5215543,
            5215465,
            5214916,
            5214805,
            5214477,
            5216227
        ],
        "A": [
            5213681,
            5213698,
            5213944,
            5214040,
            5218937,
            5214367,
            5213790,
            5214070,
            5213688,
            5213707,
            5213756,
            5213768,
            5214087,
            5213881,
            5214073,
            5213855,
            5213865,
            5213727
        ]
    },
    "name": "E. Dima and Magic Guitar",
    "statement": "Dima loves Inna very much. He decided to write a song for her. Dima has\r\na magic guitar with strings and frets. Dima makes the guitar produce\r\nsounds like that: to play a note, he needs to hold one of the strings on\r\none of the frets and then pull the string. When Dima pulls the -th\r\nstring holding it on the -th fret the guitar produces a note, let’s\r\ndenote it as . We know that Dima’s guitar can produce distinct notes. It\r\nis possible that some notes can be produced in multiple ways. In other\r\nwords, it is possible that at .Dima has already written a song a\r\nsequence of notes. In order to play the song, you need to consecutively\r\nproduce the notes from the song on the guitar. You can produce each note\r\nin any available way. Dima understood that there are many ways to play a\r\nsong and he wants to play it so as to make the song look as complicated\r\nas possible (try to act like Cobein).We’ll represent a way to play a\r\nsong as a sequence of pairs , such that the -th string on the -th fret\r\nproduces the -th note from the song. The complexity of moving between\r\npairs and equals + . The complexity of a way to play a song is the\r\nmaximum of complexities of moving between adjacent pairs.Help Dima\r\ndetermine the maximum complexity of the way to play his song! The guy’s\r\ngotta look cool!\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2300, K = 11, S = int(2e5), inf = ~0u >> 2;\n\nint leftmost[K][N], rightmost[K][N], maxD[K][N][2], maxU[K][N][2], dis[K][K];\nint n, m, kcnt, s, Q[S];\n\ninline int solve (int i, int j, int nk)\n{\n\tif (j < 1 || j > m)\n\t\treturn 0;\n\treturn max(max(i + j + maxD[nk][i][0], i - j + maxD[nk][i][1]),\n\t\t\t   max(-i + j + maxU[nk][i][0], -i - j + maxU[nk][i][1]));\n}\n\nint main ()\n{\n\tscanf(\"%d%d%d%d\", &n, &m, &kcnt, &s);\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 1; j <= kcnt; ++j)\n\t\t{\n\t\t\tleftmost[j][i] = inf;\n\t\t\trightmost[j][i] = -inf;\n\t\t}\n\t\tfor (int j = 1, k; j <= m; ++j)\n\t\t{\n\t\t\tscanf(\"%d\", &k);\n\t\t\tleftmost[k][i] = min(leftmost[k][i], j);\n\t\t\trightmost[k][i] = max(rightmost[k][i], j);\n\t\t}\n\t}\n\n\tfor (int k = 1; k <= kcnt; ++k)\n\t{\n\t\tmaxD[k][0][0] = maxD[k][0][1] = -inf;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tmaxD[k][i][0] = max(maxD[k][i - 1][0], -i - leftmost[k][i]);\n\t\t\tmaxD[k][i][1] = max(maxD[k][i - 1][1], -i + rightmost[k][i]);\n\t\t}\n\t\tmaxU[k][n + 1][0] = maxU[k][n + 1][1] = -inf;\n\t\tfor (int i = n; i >= 1; --i)\n\t\t{\n\t\t\tmaxU[k][i][0] = max(maxU[k][i + 1][0], i - leftmost[k][i]);\n\t\t\tmaxU[k][i][1] = max(maxU[k][i + 1][1], i + rightmost[k][i]);\n\t\t}\n\t}\n\t\n\tfor (int a = 1; a <= kcnt; ++a)\n\t\tfor (int b = 1; b <= kcnt; ++b)\n\t\t{\n\t\t\tdis[a][b] = 0;\n\t\t\tfor (int i = 1; i <= n; ++i)\n\t\t\t{\n\t\t\t\tint cur = max(solve(i, leftmost[a][i], b), solve(i, rightmost[a][i], b));\n\t\t\t\tdis[a][b] = max(dis[a][b], cur);\n\t\t\t}\n\t\t}\n\n\tint res = 0;\n\tfor (int i = 1; i <= s; ++i)\n\t{\n\t\tscanf(\"%d\", &Q[i]);\n\t\tif (i > 1)\n\t\t\tres = max(res, dis[Q[i - 1]][Q[i]]);\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Dima and Magic Guitar.json",
    "editorial_link": "https://codeforces.com//blog/entry/9704",
    "editorial": "There are many solutions for this task. I will describe my, you can deal\r\nwith other by looking participants code. To find the answer we should\r\ncalculate , where maximal complexity from note to note . Now we should\r\nonly iterate the song updating answer for each pair of adjacent notes.\r\nLetâs think how we can calculate the matrix. For each place on the\r\nguitar letâs iterate pairs with . If distance will be . So we should\r\nfind minimal in submatrix from to . If distance will be . So we should\r\nfind maximal in submatrix from . We will calculate this values for each\r\nnote. We need too much memory so we should memorize only one previous\r\nrow for each note. For each place we will update dinamics for both\r\nvariants according to already calculated and for our own note (which is\r\nin this cell) we will also compare or with current value in the cell.\r\nComplexity\r\n",
    "hint": []
}