{"link": "https://codeforces.com//contest/1694/problem/D", "problemId": "1430897", "problem_idx": "D", "shortId": "1694D", "contest_number": "1694", "problem_submissions": {"E": [160856186, 160866174, 160873008, 160869335, 160868951, 160877330, 160898676, 160877174, 160875442, 160876502, 160879470, 160875237, 160876355, 160882396, 160879879, 160879629, 160876481, 160881373, 160884964, 160881275], "D": [160848272, 160842517, 160849905, 160853063, 160857057, 160853921, 160854624, 160847127, 160845187, 160855341, 160850688, 160860686, 160857001, 160853657, 160862452, 160862852, 160864038, 160855376, 160858063], "C": [160836570, 160829494, 160839678, 160844593, 160847177, 160836731, 160843728, 160843693, 160838092, 160845965, 160845179, 160854286, 160843446, 160844276, 160856430, 160857207, 160844960, 160846963, 160849978], "B": [160832238, 160835941, 160831844, 160834416, 160835663, 160829339, 160834030, 160840102, 160851072, 160836730, 160864814, 160845534, 160830377, 160835010, 160833897, 160845509, 160927414, 160837907, 160860824, 160841779], "A": [160832046, 160833611, 160826245, 160824355, 160825264, 160825514, 160825648, 160826360, 160852110, 160825530, 160855429, 160829525, 160824626, 160825478, 160825695, 160824627, 160922182, 160921765, 160830254, 160825318, 160825557], "F": [160914915]}, "name": "D. Fake Plastic Trees", "statement": "We are given a rooted tree consisting of n vertices numbered from 1 to\r\nn. The root of the tree is the vertex 1 and the parent of the vertex v\r\nis p_v.There is a number written on each vertex, initially all numbers\r\nare equal to 0. Let\u2019s denote the number written on the vertex v as\r\na_v.For each v, we want a_v to be between l_v and r_v (l_v\r\nleq a_v\r\nleq r_v).In a single operation we do the following: Choose some vertex\r\nv. Let b_1, b_2,\r\nldots, b_k be vertices on the path from the vertex 1 to vertex v\r\n(meaning b_1 = 1, b_k = v and b_i = p_{b_{i + 1}}). Choose a\r\nnon-decreasing array c of length k of nonnegative integers: 0\r\nleq c_1\r\nleq c_2\r\nleq\r\nldots\r\nleq c_k. For each i (1\r\nleq i\r\nleq k), increase a_{b_i} by c_i. What\u2019s the minimum number of operations\r\nneeded to achieve our goal?\r\n", "solutions": ["#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\ntemplate <typename Fun>\nstruct y_combinator {\n    const Fun fun;\n\n    explicit y_combinator(const Fun&& fun) : fun(std::forward<const Fun>(fun)) {}\n\n    template <typename... Args>\n    auto operator()(Args&&... args) const {\n        return fun(std::ref(*this), std::forward<Args>(args)...);\n    }\n};\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> p(n);\n    for (int i = 1; i < n; ++i) {\n        cin >> p[i];\n        p[i]--;\n    }\n    vector<int> l(n), r(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> l[i] >> r[i];\n    }\n    vector<int> add(n);\n    int ans = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        if (add[i] < l[i]) {\n            ans++;\n            add[i] = r[i];\n        } else {\n            add[i] = min(add[i], r[i]);\n        }\n        if (i != 0) {\n            add[p[i]] += add[i];\n        }\n    }\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "greedy", "trees"], "dificulty": "1700", "interactive": false}