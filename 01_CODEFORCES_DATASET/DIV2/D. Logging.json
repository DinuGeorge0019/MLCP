{"link": "https://codeforces.com//contest/16/problem/D", "problemId": "75", "problem_idx": "D", "shortId": "16D", "contest_number": "16", "problem_submissions": {"E": [70472, 70287, 71317, 71555, 71009, 2823445, 70557, 71514, 71526, 71256, 71545, 71259, 70518, 71999, 73011], "D": [70195, 70680, 70666, 70921, 71632, 2869290, 71074, 70915, 71037, 71486, 70532, 71544, 71595, 70760], "C": [69769, 69933, 69973, 70337, 70580, 70313, 70299, 72753, 70416, 70325, 69894, 70966, 71276, 70125], "B": [69600, 69688, 69697, 69888, 69866, 69936, 69851, 69883, 69690, 70057, 69594, 70701, 69726, 69706], "A": [69453, 69471, 69475, 69541, 69630, 69660, 69596, 69456, 69746, 69452, 71841, 69827, 69528, 69489]}, "name": "D. Logging", "statement": "The main server of Gomble company received a log of one top-secret\r\nprocess, the name of which can\u2019t be revealed. The log was written in the\r\nfollowing format: , where for each value existed not more than 10 lines.\r\nAll the files were encoded in a very complicated manner, and only one\r\nprogrammer Alex managed to decode them. The code was so complicated that\r\nAlex needed four weeks to decode it. Right after the decoding process\r\nwas finished, all the files were deleted. But after the files deletion,\r\nAlex noticed that he saved the recordings in format . So, information\r\nabout the dates was lost. However, as the lines were added into the log\r\nin chronological order, it\u2019s not difficult to say if the recordings\r\ncould appear during one day or not. It is possible also to find the\r\nminimum amount of days during which the log was written.So, to make up\r\nfor his mistake Alex has to find the minimum amount of days covered by\r\nthe log. Note that Alex doesn\u2019t have to find the minimum amount of days\r\nbetween the beginning and the end of the logging, he has to find the\r\nminimum amount of dates in which records could be done. (See Sample test\r\n2 for further clarifications).We should remind you that the process made\r\nnot more than 10 recordings in a minute. Consider that a midnight\r\nbelongs to coming day.\r\n", "solutions": ["#include <algorithm> \n#include <iostream> \n#include <sstream> \n#include <string> \n#include <vector> \n#include <queue> \n#include <set> \n#include <map> \n#include <cstdio> \n#include <cstdlib> \n#include <cctype> \n#include <cmath> \n#include <list> \nusing namespace std; \n\n#define PB push_back \n#define MP make_pair \n#define SZ(v) ((int)(v).size()) \n#define FOR(i,a,b) for(int i=(a);i<(b);++i) \n#define REP(i,n) FOR(i,0,n) \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i) \n#define REPE(i,n) FORE(i,0,n) \n#define FORSZ(i,a,v) FOR(i,a,SZ(v)) \n#define REPSZ(i,v) REP(i,SZ(v)) \ntypedef long long ll; \n\nchar buff[1000];\n\nvoid run() {\n\tgets(buff); int nlines; sscanf(buff,\"%d\",&nlines);\n\tvector<int> tt;\n\tREP(i,nlines) {\n\t\tgets(buff);\n\t\tint h=(buff[1]-'0')*10+(buff[2]-'0'); if(h==12) h=0;\n\t\tint m=(buff[4]-'0')*10+(buff[5]-'0');\n\t\tbool ispm=buff[7]=='p';\n\t\ttt.PB(h*60+m+(ispm?12*60:0));\n\t}\n\tint ret=0,last=10000,cnt=0;\n\tREPSZ(i,tt) {\n\t\tint t=tt[i];\n\t\tif(t>last) last=t,cnt=1;\n\t\telse if(t==last&&cnt<10) ++cnt;\n\t\telse { ++ret; last=t; cnt=1; }\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["implementation", "strings"], "dificulty": "1900", "interactive": false}