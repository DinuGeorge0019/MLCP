{
    "link": "https://codeforces.com//contest/1802/problem/D",
    "problemId": "1817557",
    "problem_idx": "D",
    "shortId": "1802D",
    "contest_number": "1802",
    "problem_submissions": {
        "F": [
            196663888,
            196625008,
            196625749,
            196635602,
            196634743,
            196643091,
            196651329,
            196656599,
            196633915,
            196648089,
            196652202,
            196632881,
            196638320,
            196651695,
            196637871,
            196638608,
            196644590,
            196711680
        ],
        "G": [
            196633429,
            196750849
        ],
        "A": [
            196608625,
            196601765,
            196601430,
            196604403,
            196601551,
            196601415,
            196601637,
            196621554,
            197609656,
            196604338,
            196602290,
            196601755,
            196624562,
            196602593,
            196601829,
            196602885,
            196603556,
            196602800,
            196601750,
            196602859,
            196601468
        ],
        "C": [
            196603858,
            196634826,
            196613689,
            196616450,
            196615629,
            196606590,
            196615213,
            196643285,
            196614451,
            196642605,
            196612216,
            196636938,
            196666118,
            196610483,
            196616792,
            196626477,
            196610562,
            196619309,
            196615002,
            196608792
        ],
        "D": [
            196603459,
            196611669,
            196611547,
            196620657,
            196623482,
            196612856,
            196623750,
            196629627,
            197067794,
            196623474,
            196620294,
            196724558,
            196619887,
            196617809,
            196618077,
            196620127,
            196622956,
            196623094,
            196616226
        ],
        "B": [
            196601817,
            196604589,
            196605912,
            196607950,
            196604989,
            196602908,
            196605368,
            196624195,
            197609716,
            196611451,
            196608455,
            196605092,
            196630916,
            196608589,
            196607012,
            196607509,
            196609282,
            196615569,
            196605751,
            196607659,
            196606374
        ],
        "E": [
            196616155,
            196623146,
            196626388,
            196631009,
            196622442,
            196634549,
            196631368,
            196632011,
            196635287,
            196622016,
            196653867,
            196631106,
            196668550,
            196632178,
            196624422,
            196629837,
            196626927,
            196632190,
            196635404
        ]
    },
    "name": "D. Buying gifts",
    "statement": "Little Sasha has two friends, whom he wants to please with gifts on the\r\nEighth of March. To do this, he went to the largest shopping center in\r\nthe city.There are n departments in the mall, each of which has exactly\r\ntwo stores. For convenience, we number the departments with integers\r\nfrom 1 to n. It is known that gifts in the first store of the i\r\ndepartment cost a_i rubles, and in the second store of the i department\r\nb_i rubles.Entering the mall, Sasha will visit each of the n departments\r\nof the mall, and in each department, he will enter exactly one store.\r\nWhen Sasha gets into the i-th department, he will perform exactly one of\r\ntwo actions: Buy a gift for the first friend, spending a_i rubles on it.\r\nBuy a gift for the second friend, spending b_i rubles on it. Sasha is\r\ngoing to buy at least one gift for each friend. Moreover, he wants to\r\npick up gifts in such a way that the price difference of the most\r\nexpensive gifts bought for friends is as small as possible so that no\r\none is offended.More formally: let m_1 be the maximum price of a gift\r\nbought to the first friend, and m_2 be the maximum price of a gift\r\nbought to the second friend. Sasha wants to choose gifts in such a way\r\nas to minimize the value of\r\nlvert m_1 - m_2\r\nrvert.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#ifndef use_ios11\n#define use_ios11\nusing namespace std;\n#define log(a) cerr << \"\\033[32m[DEBUG] \" << #a << '=' << (a) << \" @ line \" << __LINE__ << \"\\033[0m\" << endl\ntypedef long long ll;\n#define pb push_back\ntypedef pair<int, int> pii;\n\n#define mem(p) memset(&p, 0, sizeof(p))\ntypedef pair<long long, long long> pll;\n#define ir(x) \\\n    int x;    \\\n    yin >> x\n#define foor(action, actionx2, actionx4, width)         \\\n    do                                                  \\\n    {                                                   \\\n        unsigned long __width = (unsigned long)(width); \\\n        unsigned long __increment = __width >> 2;       \\\n        for (; __increment > 0; __increment--)          \\\n        {                                               \\\n            actionx4;                                   \\\n        }                                               \\\n        switch (__width & 3)                            \\\n        {                                               \\\n        case 2:                                         \\\n            actionx2;                                   \\\n            break;                                      \\\n        case 3:                                         \\\n            actionx2;                                   \\\n        case 1:                                         \\\n            action;                                     \\\n            break;                                      \\\n        }                                               \\\n    } while (0)\nstruct ins\n{\n    int ans;\n    ins()\n    {\n        ans = 1;\n    }\n#define endl '\\n'\n    void read()\n    {\n    }\n    void read1(char &s)\n    {\n        char c = getchar();\n        for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar())\n            ;\n        s = c;\n        if (c == EOF)\n            ans = 0;\n    }\n    void read1(string &s)\n    {\n        s = \"\";\n        char c = getchar();\n        for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar())\n            ;\n        for (; isprint(c) && c != ' ' && c != '\\n' && c != '\\t'; c = getchar())\n            s += c;\n        if (c == EOF)\n            ans = 0;\n    }\n    void read1(char *s)\n    {\n        char c = getchar();\n        int tt = 0;\n        for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar())\n            ;\n        for (; isprint(c) && c != ' ' && c != '\\n' && c != '\\t'; c = getchar())\n            s[tt++] = c;\n        s[tt] = '\\0';\n        if (c == EOF)\n            ans = 0;\n    }\n\n    template <typename T>\n    void read1(T &n)\n    {\n        T x = 0;\n        int f = 1;\n        char c = getchar();\n        for (; !isdigit(c); c = getchar())\n        {\n            if (c == '-')\n                f = -1;\n            if (c == EOF)\n            {\n                ans = 0;\n                return;\n            }\n        }\n        for (; isdigit(c); c = getchar())\n            x = x * 10 + c - 48;\n        n = x * f;\n        if (c == EOF)\n            ans = 0;\n        if (c != '.')\n            return;\n        T l = 0.1;\n        while ((c = getchar()) <= '9' && c >= '0')\n            x = x + (c & 15) * l, l *= 0.1;\n        n = x * f;\n        if (c == EOF)\n            ans = 0;\n    }\n    void write() {}\n    void write1(string s)\n    {\n        int n = s.size();\n        for (int i = 0; i < n; i++)\n            putchar(s[i]);\n    }\n    void write1(const char *s)\n    {\n        int n = strlen(s);\n        for (int i = 0; i < n; i++)\n            putchar(s[i]);\n    }\n    void write1(char *s)\n    {\n        int n = strlen(s);\n        for (int i = 0; i < n; i++)\n            putchar(s[i]);\n    }\n\n    void write1(char s)\n    {\n        putchar(s);\n    }\n    void write1(float s, int x = 6)\n    {\n        char y[10001];\n        sprintf(y, \"%%.%df\", x);\n        printf(y, s);\n    }\n    void write1(double s, int x = 6)\n    {\n        char y[10001];\n        sprintf(y, \"%%.%dlf\", x);\n        printf(y, s);\n    }\n    void write1(long double s, int x = 6)\n    {\n        char y[10001];\n        sprintf(y, \"%%.%dLf\", x);\n        printf(y, s);\n    }\n    template <typename T>\n    void write1(T n)\n    {\n        if (n < 0)\n            n = -n, putchar('-');\n        if (n > 9)\n            write1(n / 10);\n        putchar('0' + n % 10);\n    }\n    friend ins operator>>(ins x, char *n);\n    template <typename T>\n    friend ins operator>>(ins x, T &n);\n    template <typename T>\n    friend ins operator<<(ins x, T n);\n    operator bool()\n    {\n        return ans;\n    }\n};\n\nins operator>>(ins x, char *n)\n{\n    if (!x.ans)\n        return x;\n    x.read1(n);\n    return x;\n}\n\ntemplate <typename T>\nins operator>>(ins x, T &n)\n{\n    if (!x.ans)\n        return x;\n    x.read1(n);\n    return x;\n}\ntemplate <typename T>\nins operator<<(ins x, T n)\n{\n    x.write1(n);\n    return x;\n}\nins yin;\nins yout;\n#endif\nconst int maxn = 5e5 + 10;\nint n, a[maxn], b[maxn];\nint mx[maxn];\nint id[maxn];\nint chk(int x)\n{\n    mx[n + 1] = 0;\n    for (int i = n; i >= 1; i--)\n        mx[i] = max(mx[i + 1], b[id[i]]);\n    // cerr << a[id[1]] << \" \" << a[id[2]] << \" \" << b[id[1]] << \" \" << b[id[2]] << endl;\n    set<ll> s;\n    ll ans = LLONG_MAX;\n    for (int i = 1; i <= n; i++)\n    {\n        // cerr << mx[i + 1] << \" \" << a[id[i]] << endl;\n        if (i != n)\n            ans = min(ans, (ll)abs(a[id[i]] - mx[i + 1]));\n        if (a[id[i]] > mx[i + 1] || i == n)\n        {\n            auto x = s.lower_bound(a[id[i]]);\n            if (x != s.end())\n                ans = min(ans, *x - a[id[i]]);\n            if (x != s.begin())\n            {\n                --x;\n                ans = min(ans, a[id[i]] - *x);\n            }\n        }\n        s.insert(b[id[i]]);\n    }\n    return ans;\n}\nint main()\n{\n    int TTT;\n    yin >> TTT;\n    while (TTT--)\n    {\n        yin >> n;\n        for (int i = 1; i <= n; i++)\n        {\n            yin >> a[i] >> b[i];\n        }\n        for (int i = 1; i <= n; i++)\n            id[i] = i;\n        sort(id + 1, id + n + 1, [&](int x, int y) { return a[x] < a[y]; });\n        // cerr << id[1] << \" \" << id[2] << endl;\n        int l = 0, r = 1e9, ans;\n        yout << chk(0) << endl;\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Buying gifts.json",
    "editorial_link": "https://codeforces.com//blog/entry/113857",
    "editorial": "To begin with, let's sort all departments in descending order bi\n (and if ~--- is equal, in ascending order ai\n). Now let's go through the i\n department, in which the most expensive gift for the second girlfriend will be bought. Note that in all departments with numbers j<i\n, Sasha must buy a gift for the first girlfriend, otherwise the gift i\n will not have the maximum value among the gifts bought for the second girlfriend. Therefore, we will immediately find the value of m=maxj<iaj\n. Thus, we can already get the answer |m?bi|\n.\n\nIn all departments with numbers j>i\n, for which aj?m\n, Sasha can buy a gift for any of her friends, and this will not affect the answer in any way. Now consider all departments with numbers j>i\n for which aj>m\n. If you buy a gift for your first girlfriend in some of these departments, the value of m\n will increase, which means the answer may improve. Therefore, let's iterate through all these departments and update the response with the value |aj?bi|\n.\n\nTime O(n2)\n.\n\nLet's optimize this solution. To begin with, instead of calculating the value of m\n anew at each iteration, we will maintain its value in some variable. Then, when moving from department i?1\n to department i\n, we will update the value of m\n as follows: m:=max(m,ai)\n.\n\nIt remains to learn how to quickly find the optimal department number j\n, such that j>i\n, aj>m\n, as well as |aj?bi|\n is minimal. Let's choose on the suffix of the array the minimum aj\n, such that aj?bi\n, and also the maximum aj\n, such that aj?bi\n. You can notice that the optimal aj\n is one of the two selected numbers (you also need to remember to check the condition aj>m\n). Therefore, it is enough to update the answer only with the help of them.\n\nYou can search for these two elements using the \\texttt{set} data structure. We will support in the set all aj\n located on the suffix. Then you can find the necessary two elements for O(logn)\n. When moving from department i?1\n to department i\n, you need to remove the value ai?1\n from the data structure."
}