{"link": "https://codeforces.com//contest/1713/problem/D", "problemId": "1496887", "problem_idx": "D", "shortId": "1713D", "contest_number": "1713", "problem_submissions": {"E": [167272157, 167275947, 167255255, 167280552, 167277532, 167281915, 167286271, 167295534, 167291747, 167285691, 167290110, 167289826, 167289470, 167288114, 167295399, 167293392, 167292517, 167288991, 167292413, 167295616], "D": [167262934, 167264444, 167275938, 167266127, 167264903, 167407463, 167265717, 167269013, 167270800, 167270098, 167276487, 167270258, 167267741, 167270166, 167269509, 167261936, 167272225, 167242557, 167276667, 167276744, 167278772], "C": [167243257, 167245150, 167266251, 167242115, 167251589, 167255369, 167252792, 167244013, 167251870, 167263156, 167253225, 167255260, 167254692, 167249536, 167241452, 167251627, 167255063, 167259927, 167257077, 167247512], "B": [167234078, 167234734, 167230438, 167233192, 167236986, 167243546, 167240561, 167234594, 167236064, 167235869, 167233392, 167241862, 167238018, 167234909, 167233503, 167237613, 167277571, 167236123, 167238131, 167235652], "A": [167230129, 167230356, 167231376, 167230475, 167230244, 167239741, 167232628, 167231141, 167231690, 167230947, 167230261, 167230810, 167230984, 167230721, 167230524, 167233664, 167273402, 167231481, 167232153, 167230801], "F": [167345887, 167645094, 167481610]}, "name": "D. Tournament Countdown", "statement": "There was a tournament consisting of 2^n contestants. The 1-st\r\ncontestant competed with the 2-nd, the 3-rd competed with the 4-th, and\r\nso on. After that, the winner of the first match competed with the\r\nwinner of second match, etc. The tournament ended when there was only\r\none contestant left, who was declared the winner of the tournament. Such\r\na tournament scheme is known as the single-elimination tournament.You\r\ndon\u2019t know the results, but you want to find the winner of the\r\ntournament. In one query, you select two integers a and b, which are the\r\nindices of two contestants. The jury will return 1 if a won more matches\r\nthan b, 2 if b won more matches than a, or 0 if their number of wins was\r\nequal.Find the winner in no more than\r\nleft\r\nlceil\r\nfrac{1}{3}\r\ncdot 2^{n + 1}\r\nright\r\nrceil queries. Here\r\nlceil x\r\nrceil denotes the value of x rounded up to the nearest integer.Note that\r\nthe tournament is long over, meaning that the results are fixed and do\r\nnot depend on your queries.\r\n", "solutions": ["#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    vi arr(1<<n);\n    iota(all(arr), 1);\n\n    while (sz(arr) > 2) {\n        vi next;\n\n        for (int i = 0; i < sz(arr); i += 4) {\n            cout << \"? \" << arr[i] << \" \" << arr[i+2] << endl;\n            int res;\n            cin >> res;\n\n            if (res == 0) {\n                next.pb(arr[i+1]);\n                next.pb(arr[i+3]);\n            }\n            else if (res == 1) {\n                next.pb(arr[i]);\n                next.pb(arr[i+3]);\n            }\n            else {\n                next.pb(arr[i+2]);\n                next.pb(arr[i+1]);\n            }\n        }\n        arr = next;\n    }\n    cout << \"? \" << arr[0] << ' ' << arr[1] << endl;\n    int res;\n    cin >> res;\n    if (res == 1) {\n        cout << \"! \" << arr[0] << endl;\n    }\n    else {\n        cout << \"! \" << arr[1] << endl;\n    }\n\n    return false;\n}\n\n\nint main() {\n    // freopen(\"input.in\", \"r\", stdin);\n    // freopen(\"input.out\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "interactive", "number theory", "probabilities"], "dificulty": "1800", "interactive": false}