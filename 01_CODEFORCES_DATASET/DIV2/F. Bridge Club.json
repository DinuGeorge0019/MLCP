{
    "link": "https://codeforces.com//contest/1573/problem/F",
    "problemId": "1113074",
    "problem_idx": "F",
    "shortId": "1573F",
    "contest_number": "1573",
    "problem_submissions": {
        "D": [
            129211729,
            129206759,
            129197164,
            129194726,
            129186807,
            129296553,
            129201143,
            129198553,
            129200951,
            129204017,
            129203484,
            129203960,
            129200720,
            129203477,
            129203437,
            129205853
        ],
        "E": [
            129195381,
            129194363,
            129199429,
            129179637,
            129197397,
            129196652
        ],
        "C": [
            129184190,
            129188576,
            129188704,
            129201501,
            129185674,
            129198766,
            129196140,
            129200201,
            129228180,
            129201620,
            129186651,
            129189132,
            129188899,
            129187320,
            129192678,
            129192241,
            129184572,
            129199512,
            129191618,
            129190718
        ],
        "B": [
            129172862,
            129196906,
            129176190,
            129203844,
            129172298,
            129171523,
            129174991,
            129187627,
            129183320,
            129178269,
            129185994,
            129182784,
            129179822,
            129174918,
            129183834,
            129199069,
            129172947,
            129197456,
            129180823
        ],
        "A": [
            129167486,
            129167526,
            129168431,
            129168344,
            129167107,
            129167895,
            129167756,
            129167152,
            129174946,
            129168601,
            129168318,
            129169357,
            129170825,
            129173901,
            129168162,
            129170465,
            129167770,
            129167307,
            129177822,
            129167367
        ],
        "F": [
            132459885
        ]
    },
    "name": "F. Bridge Club",
    "statement": "There are currently n hot topics numbered from 0 to n-1 at your local\r\nbridge club and 2^n players numbered from 0 to 2^n-1. Each player holds\r\na different set of views on those n topics, more specifically, the i-th\r\nplayer holds a positive view on the j-th topic if i\r\n&\r\n2^j > 0, and a negative view otherwise. Here\r\n& denotes the bitwise AND operation.You are going to organize a bridge\r\ntournament capable of accommodating at most k pairs of players (bridge\r\nis played in teams of two people). You can select teams arbitrarily\r\nwhile each player is in at most one team, but there is one catch: two\r\nplayers cannot be in the same pair if they disagree on 2 or more of\r\nthose n topics, as they would argue too much during the play.You know\r\nthat the i-th player will pay you a_i dollars if they play in this\r\ntournament. Compute the maximum amount of money that you can earn if you\r\npair the players in your club optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct Edge {\n  int from, to, capacity, cost;\n};\n\nvector<vector<int>> adj;\nvector<map<int, int>> cost, capacity;\n\nconst int INF = 1e9;\n\nvoid shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\n  d.assign(n, INF);\n  d[v0] = 0;\n  vector<bool> inq(n, false);\n  queue<int> q;\n  q.push(v0);\n  p.assign(n, -1);\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    inq[u] = false;\n    for (int v : adj[u]) {\n      if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\n        d[v] = d[u] + cost[u][v];\n        p[v] = u;\n        if (!inq[v]) {\n          inq[v] = true;\n          q.push(v);\n        }\n      }\n    }\n  }\n}\n\nbool compare(const Edge& x, const Edge& y) {return x.cost < y.cost;}\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  int n, k;\n  cin >> n >> k;\n  const int p = 1 << n;\n  vector<int> payments(p);\n  vector<bool> leftside(p, 0);\n  for (int j = 0; j < n; j++) {\n    for (int i = 0; i < (1 << j); i++) {\n      leftside[i+(1<<j)] = 1-leftside[i];\n    }\n  }\n\n  const int num_edges = (2*n-1)*(k-1)+1;\n  vector<Edge> edges;\n  for (int i = 0; i < p; i++) {\n    cin >> payments[i];\n  }\n  for (int i = 0; i < p; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i & (1 << j)) {\n        int other = i^(1<<j);\n        if (leftside[i]) {\n          edges.push_back(Edge({i, other, 1, -payments[i]-payments[other]}));\n        }\n        else {\n          edges.push_back(Edge({other, i, 1, -payments[i]-payments[other]}));\n        }\n      }\n      if (edges.size() > 1e5) {\n        nth_element(edges.begin(), edges.begin()+num_edges-1, edges.end(), compare);\n        edges.resize(num_edges);\n        edges.shrink_to_fit();\n      }\n    }\n  }\n  nth_element(edges.begin(), edges.begin()+num_edges-1, edges.end(), compare);\n  edges.resize(num_edges);\n  sort(edges.begin(), edges.end(), compare);\n\n  int players = 0;\n  set<int> used_players;\n  map<int, int> relabel;\n  vector<int> leftlabels;\n  vector<int> rightlabels;\n  for (Edge e: edges) {\n    if (!used_players.count(e.from)) {\n      used_players.insert(e.from);\n      relabel[e.from] = players+1;\n      leftlabels.push_back(players+1);\n      players++;\n    }\n    if (!used_players.count(e.to)) {\n      used_players.insert(e.to);\n      relabel[e.to] = players+1;\n      rightlabels.push_back(players+1);\n      players++;\n    }\n  }\n  int N = players + 2; // s = 0, t = players+1\n\n  adj.assign(N, vector<int>());\n  cost.assign(N, map<int, int>());\n  capacity.assign(N, map<int, int>());\n  for (Edge e : edges) {\n    adj[relabel[e.from]].push_back(relabel[e.to]);\n    adj[relabel[e.to]].push_back(relabel[e.from]);\n    cost[relabel[e.from]][relabel[e.to]] = e.cost;\n    cost[relabel[e.to]][relabel[e.from]] = -e.cost;\n    capacity[relabel[e.from]][relabel[e.to]] = e.capacity;\n  }\n  for (int i: leftlabels) {\n    adj[0].push_back(i);\n    adj[i].push_back(0);\n    capacity[0][i] = 1;\n  }\n  for (int i: rightlabels) {\n    adj[N-1].push_back(i);\n    adj[i].push_back(N-1);\n    capacity[i][N-1] = 1;\n  }\n\n  int flow = 0;\n  int cost = 0;\n  vector<int> d, q;\n  while (flow < k) {\n    shortest_paths(N, 0, d, q);\n    if (d[N-1] == INF)\n      break;\n\n    // find max flow on that path\n    int f = k - flow;\n    int cur = N-1;\n    while (cur != 0) {\n      f = min(f, capacity[q[cur]][cur]);\n      cur = q[cur];\n    }\n\n    // apply flow\n    flow += f;\n    cost += f * d[N-1];\n    cur = N-1;\n    while (cur != 0) {\n      capacity[q[cur]][cur] -= f;\n      capacity[cur][q[cur]] += f;\n      cur = q[cur];\n    }\n  }\n\n  cout << -cost << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graphs",
        "greedy"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Bridge Club.json",
    "editorial_link": "https://codeforces.com//blog/entry/95086",
    "editorial": "Let's make a graph in which the vertices are the players and there is an edge of weight ai+aj\n between the i\n-th and the j\n-th player if they can play together. We can notice that the problem can then be solved by finding a matching of size at most k\n with the biggest sum of weights in this graph.\n\nTo solve this problem efficiently we can make the following observations:\n\n1. The graph is bipartite.\n\nThis stands from the fact that if two players disagree at exactly 1\n topic then the numbers of positive views that they hold have different parities.\n\n2. We can limit ourselves to considering only the (2n?1)(k?1)+1\n edges with the biggest weights.\n\nWe can prove this with a proof by contradiction. Firstly, we can notice that if we use a particular edge in the matching then we prohibit ourselves from using at most 2(n?1)\n other edges with each of the matched vertices being incident to exactly n?1\n of those edges, because each vertex has degree n\n in this graph. Now we can see that if we were to use an edge that's not one of those (2n?1)(k?1)+1\n best ones, then we can just replace it with one of those best ones, because we know that at least one of them will not be prohibited.\n\nCombining those two observations we are left with a bipartite graph with O(nk)\n edges and O(nk)\n vertices in which we can find a matching with maximum cost and size at most k\n with for example one of the standard min cost max flow algorithms (we can look for a matching of size k\n because all edges have non-negative weights).\n\nThe only problem that's left for us to solve is efficiently selecting those best edges. Because there are O(n2n)\n edges in total we cannot use a standard sorting algorithm as that would run in O(n22n)\n. Instead we can for example use the quick select algorithm which solves this problem in O(n2n)\n.\n\nOur final time complexity is then O(n2n+nk2log(kn))\n.",
    "hint": []
}