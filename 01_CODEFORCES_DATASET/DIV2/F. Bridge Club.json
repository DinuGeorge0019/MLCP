{"link": "https://codeforces.com//contest/1573/problem/F", "problemId": "1113074", "problem_idx": "F", "shortId": "1573F", "contest_number": "1573", "problem_submissions": {"D": [129211729, 129206759, 129197164, 129194726, 129186807, 129296553, 129201143, 129198553, 129200951, 129204017, 129203484, 129203960, 129200720, 129203477, 129203437, 129205853], "E": [129195381, 129194363, 129199429, 129179637, 129197397, 129196652], "C": [129184190, 129188576, 129188704, 129201501, 129185674, 129198766, 129196140, 129200201, 129228180, 129201620, 129186651, 129189132, 129188899, 129187320, 129192678, 129192241, 129184572, 129199512, 129191618, 129190718], "B": [129172862, 129196906, 129176190, 129203844, 129172298, 129171523, 129174991, 129187627, 129183320, 129178269, 129185994, 129182784, 129179822, 129174918, 129183834, 129199069, 129172947, 129197456, 129180823], "A": [129167486, 129167526, 129168431, 129168344, 129167107, 129167895, 129167756, 129167152, 129174946, 129168601, 129168318, 129169357, 129170825, 129173901, 129168162, 129170465, 129167770, 129167307, 129177822, 129167367], "F": [132459885]}, "name": "F. Bridge Club", "statement": "There are currently n hot topics numbered from 0 to n-1 at your local\r\nbridge club and 2^n players numbered from 0 to 2^n-1. Each player holds\r\na different set of views on those n topics, more specifically, the i-th\r\nplayer holds a positive view on the j-th topic if i\r\n&\r\n2^j > 0, and a negative view otherwise. Here\r\n& denotes the bitwise AND operation.You are going to organize a bridge\r\ntournament capable of accommodating at most k pairs of players (bridge\r\nis played in teams of two people). You can select teams arbitrarily\r\nwhile each player is in at most one team, but there is one catch: two\r\nplayers cannot be in the same pair if they disagree on 2 or more of\r\nthose n topics, as they would argue too much during the play.You know\r\nthat the i-th player will pay you a_i dollars if they play in this\r\ntournament. Compute the maximum amount of money that you can earn if you\r\npair the players in your club optimally.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct Edge {\n  int from, to, capacity, cost;\n};\n\nvector<vector<int>> adj;\nvector<map<int, int>> cost, capacity;\n\nconst int INF = 1e9;\n\nvoid shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\n  d.assign(n, INF);\n  d[v0] = 0;\n  vector<bool> inq(n, false);\n  queue<int> q;\n  q.push(v0);\n  p.assign(n, -1);\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    inq[u] = false;\n    for (int v : adj[u]) {\n      if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\n        d[v] = d[u] + cost[u][v];\n        p[v] = u;\n        if (!inq[v]) {\n          inq[v] = true;\n          q.push(v);\n        }\n      }\n    }\n  }\n}\n\nbool compare(const Edge& x, const Edge& y) {return x.cost < y.cost;}\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  int n, k;\n  cin >> n >> k;\n  const int p = 1 << n;\n  vector<int> payments(p);\n  vector<bool> leftside(p, 0);\n  for (int j = 0; j < n; j++) {\n    for (int i = 0; i < (1 << j); i++) {\n      leftside[i+(1<<j)] = 1-leftside[i];\n    }\n  }\n\n  const int num_edges = (2*n-1)*(k-1)+1;\n  vector<Edge> edges;\n  for (int i = 0; i < p; i++) {\n    cin >> payments[i];\n  }\n  for (int i = 0; i < p; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i & (1 << j)) {\n        int other = i^(1<<j);\n        if (leftside[i]) {\n          edges.push_back(Edge({i, other, 1, -payments[i]-payments[other]}));\n        }\n        else {\n          edges.push_back(Edge({other, i, 1, -payments[i]-payments[other]}));\n        }\n      }\n      if (edges.size() > 1e5) {\n        nth_element(edges.begin(), edges.begin()+num_edges-1, edges.end(), compare);\n        edges.resize(num_edges);\n        edges.shrink_to_fit();\n      }\n    }\n  }\n  nth_element(edges.begin(), edges.begin()+num_edges-1, edges.end(), compare);\n  edges.resize(num_edges);\n  sort(edges.begin(), edges.end(), compare);\n\n  int players = 0;\n  set<int> used_players;\n  map<int, int> relabel;\n  vector<int> leftlabels;\n  vector<int> rightlabels;\n  for (Edge e: edges) {\n    if (!used_players.count(e.from)) {\n      used_players.insert(e.from);\n      relabel[e.from] = players+1;\n      leftlabels.push_back(players+1);\n      players++;\n    }\n    if (!used_players.count(e.to)) {\n      used_players.insert(e.to);\n      relabel[e.to] = players+1;\n      rightlabels.push_back(players+1);\n      players++;\n    }\n  }\n  int N = players + 2; // s = 0, t = players+1\n\n  adj.assign(N, vector<int>());\n  cost.assign(N, map<int, int>());\n  capacity.assign(N, map<int, int>());\n  for (Edge e : edges) {\n    adj[relabel[e.from]].push_back(relabel[e.to]);\n    adj[relabel[e.to]].push_back(relabel[e.from]);\n    cost[relabel[e.from]][relabel[e.to]] = e.cost;\n    cost[relabel[e.to]][relabel[e.from]] = -e.cost;\n    capacity[relabel[e.from]][relabel[e.to]] = e.capacity;\n  }\n  for (int i: leftlabels) {\n    adj[0].push_back(i);\n    adj[i].push_back(0);\n    capacity[0][i] = 1;\n  }\n  for (int i: rightlabels) {\n    adj[N-1].push_back(i);\n    adj[i].push_back(N-1);\n    capacity[i][N-1] = 1;\n  }\n\n  int flow = 0;\n  int cost = 0;\n  vector<int> d, q;\n  while (flow < k) {\n    shortest_paths(N, 0, d, q);\n    if (d[N-1] == INF)\n      break;\n\n    // find max flow on that path\n    int f = k - flow;\n    int cur = N-1;\n    while (cur != 0) {\n      f = min(f, capacity[q[cur]][cur]);\n      cur = q[cur];\n    }\n\n    // apply flow\n    flow += f;\n    cost += f * d[N-1];\n    cur = N-1;\n    while (cur != 0) {\n      capacity[q[cur]][cur] -= f;\n      capacity[cur][q[cur]] += f;\n      cur = q[cur];\n    }\n  }\n\n  cout << -cost << endl;\n}\n"], "input": "", "output": "", "tags": ["flows", "graphs", "greedy"], "dificulty": "2800", "interactive": false}