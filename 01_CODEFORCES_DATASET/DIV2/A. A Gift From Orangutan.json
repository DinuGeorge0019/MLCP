{
    "link": "https://codeforces.com//contest/2030/problem/A",
    "problemId": "2962988",
    "problem_idx": "A",
    "shortId": "2030A",
    "contest_number": "2030",
    "problem_submissions": {
        "D": [
            286870605,
            286870097,
            286766067,
            286743790,
            286749704,
            286752517,
            286743540,
            286763694,
            286769489,
            286762215,
            286755968,
            286807582,
            286774479,
            286755264,
            286748829,
            286762354,
            286767397,
            286766307,
            286775817,
            286773805,
            286867460,
            286806694,
            286757030
        ],
        "C": [
            286860734,
            286764785,
            286775512,
            286732737,
            286735870,
            286731279,
            286736529,
            286759035,
            286741312,
            286740209,
            286770332,
            286732276,
            286730948,
            286749099,
            286748589,
            286737019,
            286738816,
            286732618,
            286746919,
            286735952,
            286744382
        ],
        "B": [
            286858184,
            286726117,
            286721582,
            286722000,
            286722997,
            286722179,
            286731090,
            286742656,
            286728669,
            286721456,
            286721616,
            286722634,
            286723485,
            286723817,
            286722712,
            286723090,
            286725291,
            286719819,
            286727047,
            286721215,
            286722880
        ],
        "A": [
            286857205,
            286716570,
            286716508,
            286717068,
            286716187,
            286716722,
            286727391,
            286716522,
            286715165,
            286715628,
            286715445,
            286716659,
            286717260,
            286715083,
            286717340,
            286715258,
            286718621,
            286715888,
            286722488,
            286715834,
            286716388
        ],
        "G1": [
            286855127,
            286854605,
            287072911,
            286866647
        ],
        "F": [
            286768609,
            286793091,
            286802410,
            286804764,
            286807723,
            286808203,
            286799478,
            286806636,
            286814242,
            286786481,
            286811066,
            286813827,
            286813676,
            286816754,
            286814190,
            286813606,
            286813682,
            286795825,
            286808765,
            286817519
        ],
        "E": [
            286766337,
            286759349,
            286779444,
            286786742,
            286788454,
            286791781,
            286783999,
            286800776,
            286780259,
            286764648,
            286793854,
            286792948,
            286789703,
            286779768,
            286799721,
            286794191,
            286791806,
            286816988,
            286786381,
            286789315
        ],
        "G2": [
            287138384
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135218",
    "editorial": "Problem Credits: Proof_by_QED Analysis: Proof_by_QED Solution First,\r\nwhat is the maximum possible value of for any ? Since is the maximum\r\nelement of some subset of and is the minimum element of some subset of ,\r\nthe maximum possible value of is .Also note that for any reordering of .\r\nBy reordering such that the largest element of appears first and the\r\nsmallest element of appears second, the maximum possible value of the\r\nscore is achieved. This results in a score of .\r\n",
    "name": "A. A Gift From Orangutan",
    "statement": "The orangutan has gifted you an array a of length n. Using a, you will\r\nconstruct two arrays b and c, both containing n elements, in the\r\nfollowing manner: b_i =\r\nmin(a_1, a_2,\r\nldots, a_i) for each 1\r\nleq i\r\nleq n. c_i =\r\nmax(a_1, a_2,\r\nldots, a_i) for each 1\r\nleq i\r\nleq n. Define the of a as\r\nsum_{i=1}^n c_i - b_i (i.e. the sum of c_i - b_i over all 1\r\nleq i\r\nleq n). Before you calculate the , you can the elements of a however you\r\nwant.Find the maximum that you can get if you shuffle the elements of a\r\noptimally.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"using namespace std;using ll = long long;using vi = vector<int>;\u00a0#define endl '\\n'#define pb emplace_back#define sz(x) (int)(x).size()#define all(x) (x).begin(), (x).end()#define make_unique(x) sort(all(x)), x.resize(unique(all(x)) - begin(x))#define debug(x) cerr << \"[\" << __LINE__ << \"] \"#x\" = \" << (x) << endl\u00a0int a[1005];\u00a0void solve() {\t\tint n, mx = -1, mn = 1005;\t\tcin >> n;\tfor (int i = 0 ; i < n; i ++) {\t\tcin >> a[i];\t\tmx = max(mx, a[i]);\t\tmn = min(mn, a[i]);\t}\t\tif (n == 0) cout  << 0 << endl;\telse  {\t\tcout << 1LL * (mx - mn) * (n - 1) << endl;\t\t}\u00a0\treturn;\t}int main() {#ifndef ONLINE_JUDGE\tfreopen(\"in.txt\", \"r\", stdin);//\tfreopen(\"out.txt\", \"w\", stdout);#endif\u00a0\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\u00a0\tint tc = 1;\tcin >> tc;\twhile (tc --) solve();\u00a0\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. A Gift From Orangutan.json"
}