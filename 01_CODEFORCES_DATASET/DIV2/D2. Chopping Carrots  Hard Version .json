{
    "link": "https://codeforces.com//contest/1706/problem/D2",
    "problemId": "1466355",
    "problem_idx": "D2",
    "shortId": "1706D2",
    "contest_number": "1706",
    "problem_submissions": {
        "D2": [
            164755947,
            164771403,
            164762268,
            164830322,
            164783821,
            164762155,
            164763660,
            167727726,
            164763512,
            164771385,
            164768987,
            164786591,
            165109549,
            164774482,
            164772244,
            164787948,
            164789501,
            164767866,
            164774049,
            164768972,
            164786019,
            164781366
        ],
        "D1": [
            164755812,
            164767814,
            164760721,
            164830311,
            164764715,
            164761873,
            164763978,
            167106725,
            164760911,
            164771592,
            164764309,
            164755426,
            164758751,
            164758461,
            164759026,
            164768432,
            164762506,
            164771653,
            164768895,
            164754659,
            164780135
        ],
        "E": [
            164750123,
            164754977,
            164771776,
            164830331,
            164760396,
            164775552,
            164750599,
            167106869,
            164780737,
            164776992,
            164776365,
            164769697,
            165109519,
            164782832,
            164784446,
            164777832,
            164745185,
            164783769,
            164782907,
            164785318,
            164774423,
            164765688
        ],
        "C": [
            164743602,
            164744687,
            164740571,
            164830300,
            164745917,
            164752415,
            164768743,
            167106646,
            167106607,
            164749531,
            164746963,
            164750898,
            164748957,
            164751304,
            164751822,
            164752230,
            164762906,
            164749665,
            164747043,
            164749516,
            164747945,
            164752780
        ],
        "B": [
            164740418,
            164739248,
            164748883,
            164830286,
            164740306,
            164748574,
            164773017,
            167106480,
            164740862,
            164740238,
            164743331,
            164741485,
            164741615,
            164739143,
            164740378,
            164753096,
            164741049,
            164740372,
            164742312,
            164741022,
            164745456
        ],
        "A": [
            164734517,
            164734482,
            164750605,
            164830274,
            164734645,
            164734321,
            164774887,
            167106382,
            164735301,
            164734871,
            164734669,
            164735191,
            164734536,
            164734449,
            164734493,
            164748128,
            164735346,
            164734733,
            164735598,
            164734982,
            164735759
        ]
    },
    "name": "D2. Chopping Carrots  Hard Version ",
    "statement": "You are given an array of integers a_1, a_2,\r\nldots, a_n of length n, and an integer k.The of an array of integers\r\np_1, p_2,\r\nldots, p_n of length n is\r\nmax\r\nlimits_{1\r\nle i\r\nle n}\r\nleft(\r\nleft\r\nlfloor\r\nfrac{a_i}{p_i}\r\nright\r\nrfloor\r\nright) -\r\nmin\r\nlimits_{1\r\nle i\r\nle n}\r\nleft(\r\nleft\r\nlfloor\r\nfrac{a_i}{p_i}\r\nright\r\nrfloor\r\nright).Here,\r\nlfloor\r\nfrac{x}{y}\r\nrfloor denotes the integer part of the division of x by y. Find the\r\nminimum cost of an array p such that 1\r\nle p_i\r\nle k for all 1\r\nle i\r\nle n.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < '-')\n\t\t;\n\tif (c == '-') {\n\t\tint x = gc - '0';\n\t\twhile (gc >= '0') x = x * 10 + c - '0';\n\t\treturn -x;\n\t}\n\tint x = c - '0';\n\twhile (gc >= '0') x = x * 10 + c - '0';\n\treturn x;\n}\n#undef gc\n\nconst int N = 1e5 + 5;\n\nint a[N], mx[N], seq[N];\nint T, n, k;\n\nint main() {\n#ifdef local\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tmemset(mx, 0, sizeof(mx));\n\t\tn = read();\n\t\tk = read();\n\t\tint maxn = 0;\n\t\trep(i, 1, n) {\n\t\t\ta[i] = read();\n\t\t\tint len = 0;\n\t\t\tfor (int l = 1, r; l <= min(a[i], k); l = r + 1) {\n\t\t\t\tr = a[i] / (a[i] / l);\n\t\t\t\tseq[++len] = a[i] / l;\n\t\t\t}\n\t\t\tif (k > a[i]) seq[++len] = 0;\n\t\t\treverse(seq + 1, seq + len + 1);\n\t\t\tmaxn = max(maxn, seq[1]);\n\t\t\tseq[len + 1] = 1e9;\n\t\t\trep(j, 1, len) {\n\t\t\t\tmx[seq[j]] = max(mx[seq[j]], seq[j + 1]);\n\t\t\t}\n\t\t}\n\t\tint ans = 1e5;\n\t\trep(i, 0, 100000) {\n\t\t\tans = min(ans, maxn - i);\n\t\t\tmaxn = max(maxn, mx[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "dp",
        "greedy",
        "math",
        "number theory",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. Chopping Carrots  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/105008",
    "editorial": "Let\u00e2\u0080\u0099s fix , the minimum value of . Then, for all , we find the maximum\r\nvalue such that and .For some minimum value , let\u00e2\u0080\u0099s call the array\r\ndescribed above , and let\u00e2\u0080\u0099s define . We can find the answer by taking\r\nthe minimum of across all , giving a solution.To speed it up, let\u00e2\u0080\u0099s\r\nconsider how some element will affect the values of .First, notice that\r\n(where ) can take on at most distinct values. Let\u00e2\u0080\u0099s denote these values\r\n(in increasing order) . Consider what happens when . Then, must be at\r\nleast . What about when ? Then, must be at least . And so on, until ,\r\nwhere must be at least .This way, we can get lower bounds on value of .\r\nIt is easy to see that the highest of these bounds is achievable.Let\u00e2\u0080\u0099s\r\niterate over array . Let (here, is an array of length ) be the highest\r\nof lower bounds on we already found. Initially, for all . When we are\r\ndealing with we want to do the following: For all , we want to update\r\nfor all (for convenience we define ). Since , this can be done without\r\nany fancy data structures instead of updating all these ranges directly,\r\nwe can set , so that will be equal to . Then, once is computed, we can\r\nsweep through to find all values of in with prefix maxes.Once we have\r\ncomputed, we can find for all in linear time. This gives a solution per\r\ntest case, with total memory across all tests.Now, let\u00e2\u0080\u0099s fix as the\r\nvalue of . We now want to maximize the minimum value of .Let\u00e2\u0080\u0099s now\r\nconsider all elements that satisfy . For these elements, it will be\r\noptimal to set , since we want to maximize them.How about elements\r\nsatisfying ? We need to have , so for these elements, we must have . At\r\nthe same time, we want to maximize them so it will be optimal to set all\r\nthese .Continuing this logic, for all integers , we should check the\r\nelements satisfying , and set all these .How can we determine the\r\nminimum value of from this? For a fixed , the minimum will come from the\r\nminimum . So if we can determine the minimum such that , and calculate\r\nthese values across all , then we will get the answer.To help us, let\u00e2\u0080\u0099s\r\nprecompute an array . will store the minimum value of such that . Now,\r\nfor a fixed , we can check . If this value is less than or equal to , it\r\nwill be the minimum that we divide by .Two important details: If there\r\nexists some , then it is impossible to have the max element as , and we\r\nshould skip it. For some value , we only need to check such that . Using\r\nthis second detail, the solution runs in time per test case. The memory\r\nusage is across all tests.\r\n"
}