{
    "link": "https://codeforces.com//contest/902/problem/C",
    "problemId": "139719",
    "problem_idx": "C",
    "shortId": "902C",
    "contest_number": "902",
    "problem_submissions": {
        "E": [
            33432769,
            33432692,
            33431724,
            33432880,
            33433143,
            33425800,
            33479713,
            33434507
        ],
        "C": [
            33418857,
            33421216,
            33418092,
            33421721,
            33425094,
            33420634,
            33423702,
            33423018,
            33420334,
            33420303,
            33419836,
            33430662,
            33420269,
            33422420,
            33422328,
            33423548,
            33420458,
            33425360
        ],
        "B": [
            33414393,
            33416891,
            33413564,
            33416982,
            33418778,
            33415144,
            33420150,
            33416950,
            33420947,
            33415271,
            33415194,
            33431642,
            33414521,
            33417866,
            33416627,
            33417427,
            33416186,
            33419760
        ],
        "A": [
            33412979,
            33413298,
            33412683,
            33414789,
            33412988,
            33412835,
            33415972,
            33412736,
            33422119,
            33413143,
            33413263,
            33432089,
            33412738,
            33412994,
            33413252,
            33413078,
            33413621,
            33413563
        ],
        "D": [
            33425081,
            33422286,
            33426122,
            33429053,
            33429776,
            33430153,
            33430663,
            33428168,
            33429601,
            33428402,
            33429733
        ]
    },
    "name": "C. Hashing Trees",
    "statement": "Sasha is taking part in a programming competition. In one of the\r\nproblems she should check if some rooted trees are isomorphic or not.\r\nShe has never seen this problem before, but, being an experienced\r\nparticipant, she guessed that she should match trees to some sequences\r\nand then compare these sequences instead of trees. Sasha wants to match\r\neach tree with a sequence , where is the height of the tree, and equals\r\nto the number of vertices that are at distance of edges from root.\r\nUnfortunately, this time Sashaâ€™s intuition was wrong, and there could be\r\nseveral trees matching the same sequence. To show it, you need to write\r\na program that, given the sequence , builds two non-isomorphic rooted\r\ntrees that match that sequence, or determines that there is only one\r\nsuch tree.Two rooted trees are isomorphic, if you can reenumerate the\r\nvertices of the first one in such a way, that the index of the root\r\nbecomes equal the index of the root of the second tree, and these two\r\ntrees become equal.The height of a rooted tree is the maximum number of\r\nedges on a path from the root to any other vertex.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\n\n\n\n\ntemplate <class T>\nvoid upd(T&a,T b) {\n    a = max(a,b);\n}\n\nint h;\nint a[100010];\nint par[100010];\nbool amb = 0;\nvector<PII>no[100010];\nint main(){\n    in(h);\n    REP(i,0,h+1)in(a[i]);\n    REP(i,1,h+1){\n        if(a[i]>=2 && a[i-1]>=2){\n            cout<<\"ambiguous\"<<endl;\n            amb = 1;\n            break;\n        }\n    }\n    if(!amb){\n        cout<<\"perfect\"<<endl;\n        return 0;\n    }\n    int cur = 1;\n    bool gao = 0;\n    REP(i,0,h+1){\n        if(i>0 && a[i]>=2 && a[i-1]>=2&& gao == false){\n            gao = true;\n            no[i].PB(MP(no[i-1][0].se,cur++));\n            no[i].PB(MP(no[i-1][1].se,cur++));\n            REP(j,0,a[i]-2){\n                no[i].PB(MP(no[i-1][0].se,cur++));\n            }\n\n        }else{\n            if(i == 0){\n                no[i].PB(MP(0,cur++));\n            }else{\n                REP(j,0,a[i]){\n                    no[i].PB(MP(no[i-1][0].se,cur++));\n                }\n            }\n        }\n    }\n    REP(i,0,h+1){\n        for(auto node:no[i]){\n            cout<<node.fi<<\" \";\n        }\n    }\n    REP(i,0,h+1)no[i].clear();\n    cout<<endl;\n    gao = 0;\n    cur = 1;\n    REP(i,0,h+1){\n        if(false){\n            gao = true;\n            no[i].PB(MP(no[i-1][0].se,cur++));\n            no[i].PB(MP(no[i-1][1].se,cur++));\n            REP(j,0,a[i]-2){\n                no[i].PB(MP(no[i-1][0].se,cur++));\n            }\n            \n        }else{\n            if(i == 0){\n                no[i].PB(MP(0,cur++));\n            }else{\n                REP(j,0,a[i]){\n                    no[i].PB(MP(no[i-1][0].se,cur++));\n                }\n            }\n        }\n    }\n    REP(i,0,h+1){\n        for(auto node:no[i]){\n            cout<<node.fi<<\" \";\n        }\n    }\n    cout<<endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Hashing Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/56478",
    "editorial": "There are many ways to solve the problem. First of all you should build any single tree. To do this, you first build the longest path from the root and then attach remained vertices on proper heights. Thus each vertex is either on the longest path or has parent on this path. To build the second tree you should use different vertices from previous levels during construction to make it different from first tree. This is always possible if there are two consecutive ai?>?1. Otherwise the tree is determined uniquely by ai sequence.\n",
    "hint": []
}