{
    "link": "https://codeforces.com//contest/1831/problem/C",
    "problemId": "1942563",
    "problem_idx": "C",
    "shortId": "1831C",
    "contest_number": "1831",
    "problem_submissions": {
        "F": [
            208138276,
            207709337
        ],
        "E": [
            208138261,
            207648682,
            207658220,
            207656838,
            207666357,
            207774368,
            207656515,
            207695977,
            207710932,
            207657876,
            208163887,
            207670786,
            207664348,
            207669868,
            207660228
        ],
        "D": [
            208138229,
            207624019,
            207622747,
            207707096,
            207639773,
            207642056,
            207665762,
            207606856,
            207612471,
            207613443,
            207614547,
            207617717,
            207621891,
            207622928,
            207622371,
            207623544,
            207626326,
            207683940,
            207628627
        ],
        "C": [
            208138202,
            207603654,
            207591133,
            207610375,
            207604106,
            207604842,
            207591198,
            207597318,
            207602578,
            207595759,
            207597417,
            207600531,
            207601702,
            207596236,
            207598453,
            207596408,
            207607400,
            207594213,
            207608501,
            207603207
        ],
        "B": [
            207933759,
            207587309,
            207585317,
            207591044,
            207597740,
            207626518,
            207586353,
            207592366,
            207588011,
            207586628,
            207590623,
            207592643,
            207591011,
            207586905,
            209739181,
            207587547,
            207588237,
            207602435,
            207588035,
            207591775,
            207591535
        ],
        "A": [
            207933729,
            207580780,
            207580051,
            207582133,
            207593347,
            207580551,
            207581151,
            207591960,
            207580225,
            207581009,
            207582654,
            207583238,
            207580711,
            207581264,
            209739158,
            207580917,
            207581616,
            207598296,
            207580446,
            207582701,
            207581592
        ]
    },
    "name": "C. Copil Copac Draws Trees",
    "statement": "Copil Copac is given a list of n-1 edges describing a tree of n\r\nvertices. He decides to draw it using the following algorithm: Step 0:\r\nDraws the first vertex (vertex 1). Go to step 1. Step 1: For every edge\r\nin the input, in order: if the edge connects an already drawn vertex u\r\nto an undrawn vertex v, he will draw the undrawn vertex v and the edge.\r\nAfter checking every edge, go to step 2. Step 2: If all the vertices are\r\ndrawn, terminate the algorithm. Else, go to step 1. The number of\r\nreadings is defined as the number of times Copil Copac performs step\r\n1.Find the number of readings needed by Copil Copac to draw the tree.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate < typename T >\ninline const void read(T &x)\n{\n\tbool flg = x = 0;\n\tchar c;\n\twhile ((c = getchar()) < 48 || c > 57)\n\t\tflg |= c == '-';\n\tdo\n\t\tx = (x << 1) + (x << 3) + (c ^ 48);\n\twhile ((c = getchar()) > 47 && c < 58);\n\tif (flg) x = -x;\n}\n\nint OUTPUT[45];\n\ntemplate < typename T >\ninline const void write(T x)\n{\n\tif (x < 0)\n\t{\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tint len = 0;\n\tdo\n\t{\n\t\tOUTPUT[++len] = x % 10 | 48;\n\t\tx /= 10;\n\t}while (x);\n\twhile (len)\n\t\tputchar(OUTPUT[len--]);\n}\n\ntemplate < typename T >\ninline const void writesp(const T x)\n{\n\twrite(x);\n\tputchar(32);\n}\n\ntemplate < typename T >\ninline const void writeln(const T x)\n{\n\twrite(x);\n\tputchar(10);\n}\n\nconst int N = 2e5 + 5;\nint T, n/*, dep[N], fa[N]*/, f[N];\nvector < pair < int, int > > G[N];\npair < int, int > e[N];\n/*\nvoid Init(int x, int pre)\n{\n\tfor (auto i : G[x])\n\t\tif (i.second != pre)\n\t\t{\n\t\t\tfa[i.second] = x;\n\t\t\tInit(i.second, x);\n\t\t}\n}*/\n\nvoid dfs(int x, int fa, int lst)\n{\n\tfor (auto i : G[x])\n\t\tif (i.second != fa)\n\t\t{\n\t\t\tif (i.first > lst) f[i.second] = f[x];\n\t\t\telse f[i.second] = f[x] + 1;\n\t\t\tdfs(i.second, x, i.first);\n\t\t}\n}\n\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tread(T);\n\twhile (T--)\n\t{\n\t\tread(n);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tG[i].erase(G[i].begin(), G[i].end());\n\t\tfor (int i = 1; i < n; ++i)\n\t\t{\n\t\t\tread(e[i].first);\n\t\t\tread(e[i].second);\n\t\t\tG[e[i].first].emplace_back(i, e[i].second);\n\t\t\tG[e[i].second].emplace_back(i, e[i].first);\n\t\t}\n//\t\tfa[1] = 0;\n//\t\tInit(1, 0);\n\t\tf[1] = 1;\n\t\tdfs(1, 0, 0);\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tans = max(ans, f[i]);\n\t\twriteln(ans);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Copil Copac Draws Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/116527",
    "editorial": "This problem can be solved via dynamic programming. From here on out, step 1\n from the statement will be called a \"scan\".\n\nLet dp[i]\n be the number of scans needed to activate node i\n, and id[i]\n be the index (in the order from the input) of the edge which activated node i\n.\n\nIntially, since only 1\n is active, dp[1]=1\n and id[1]=0\n.\n\nWe will perform a dfs traversal starting from node 1\n. When we process an edge (u,v)\n, one of the following two cases can happen:\n\nIf index((u,v))?id[u]\n, we can visit v\n in the same scan as u\n:\ndp[v]=dp[u]\n, id[v]=index((u,v))\nIf index((u,v))<id[u]\n, v\n will be visited in the next scan after dp[u]\n:\ndp[v]=dp[u]+1\n, id[v]=index((u,v))\nThe answer is maxni=1(dp[i])\n.\n\nTime complexity per test case: O(n)",
    "hint": []
}