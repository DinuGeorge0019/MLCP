{"link": "https://codeforces.com//contest/366/problem/D", "problemId": "4075", "problem_idx": "D", "shortId": "366D", "contest_number": "366", "problem_submissions": {"E": [5223414, 5232960, 5224601, 5224400, 5224222, 5217176, 5224737, 5224278, 5226537, 5218732, 5224501, 5240243, 5224536, 5228081, 5226578], "D": [5217035, 5218139, 5218798, 5218839, 5218268, 5218550, 5226120, 5224735, 5218888, 5218628, 5223995, 5223329, 5223776, 5223645, 5224564], "C": [5215635, 5215143, 5216612, 5216695, 5224015, 5217024, 5216364, 5232085, 5225511, 5216977, 5216046, 5215965, 5216961, 5216956, 5217291, 5216898, 5216929, 5218407, 5225537, 5223478], "B": [5214230, 5213966, 5214711, 5214981, 5223546, 5215334, 5214481, 5217130, 5214153, 5214206, 5214371, 5214882, 5214468, 5215543, 5215465, 5214916, 5214805, 5214477, 5216227], "A": [5213681, 5213698, 5213944, 5214040, 5218937, 5214367, 5213790, 5214070, 5213688, 5213707, 5213756, 5213768, 5214087, 5213881, 5214073, 5213855, 5213865, 5213727]}, "name": "D. Dima and Trap Graph", "statement": "Dima and Inna love spending time together. The problem is, Seryozha\r\nisn\u2019t too enthusiastic to leave his room for some reason. But Dima and\r\nInna love each other so much that they decided to get criminal...Dima\r\nconstructed a trap graph. He shouted: \"Hey Seryozha, have a look at my\r\ncool graph!\" to get his roommate interested and kicked him into the\r\nfirst node.A trap graph is an undirected graph consisting of nodes and\r\nedges. For edge number , Dima denoted a range of integers from to . In\r\norder to get out of the trap graph, Seryozha initially (before starting\r\nhis movements) should pick some integer (let\u2019s call it ), then Seryozha\r\nmust go some way from the starting node with number to the final node\r\nwith number . At that, Seryozha can go along edge only if .Seryozha is a\r\nmathematician. He defined the of some path from the -st node to the -th\r\none as the number of integers , such that if he initially chooses one of\r\nthem, he passes the whole path. Help Seryozha find the path of maximum\r\nloyalty and return to his room as quickly as possible!\r\n", "solutions": ["#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 5000, M = 10000;\n\nstruct edge { int t, l, r; edge *n; } ebf[M], *ec = ebf, *e[N];\n\ninline void add_edge (int s, int t, int l, int r)\n{\n\t*ec = (edge){t, l, r, e[s]}; e[s] = ec++;\n\t*ec = (edge){s, l, r, e[t]}; e[t] = ec++;\n}\n\nint vis[N], n, m;\nqueue<int> que;\ninline bool check (int l, int r)\n{\n\tfill(vis, vis + 1 + n, 0);\n\tvis[1] = true;\n\twhile (! que.empty()) que.pop();\n\tque.push(1);\n\twhile (! que.empty())\n\t{\n\t\tint x = que.front(); que.pop();\n\t\tfor (edge *i = e[x]; i; i = i->n)\n\t\t\tif (i->l <= l && r <= i->r && !vis[i->t])\n\t\t\t{\n\t\t\t\tvis[i->t] = true;\n\t\t\t\tque.push(i->t);\n\t\t\t}\n\t}\n\treturn vis[n];\n}\n\nint axis[N * 2], acnt;\n\nint main ()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint a, b, l, r;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &l, &r);\n\t\tadd_edge(a, b, l, r);\n\t\taxis[++acnt] = l;\n\t\taxis[++acnt] = r;\n\t}\n\tsort(axis + 1, axis + 1 + acnt);\n\tacnt = unique(axis + 1, axis + 1 + acnt) - (axis + 1);\n\taxis[0] = -1;\n\taxis[acnt + 1] = axis[acnt] + 1;\n\tint res = -1;\n\tfor (int lID = 1; lID <= acnt; ++lID)\n\t{\n\t\tif (! check(axis[lID], axis[lID]))\n\t\t\tcontinue;\n\t\tint lo = lID, hi = acnt + 1; // [lo, hi)\n\t\twhile (lo + 1 != hi)\n\t\t{\n\t\t\tint mi = (lo + hi) >> 1;\n\t\t\tif (check(axis[lID], axis[mi]))\n\t\t\t\tlo = mi;\n\t\t\telse\n\t\t\t\thi = mi;\n\t\t}\n\t\tres = max(res, axis[lo] - axis[lID] + 1);\n\t}\n\tif (res == -1) printf(\"Nice work, Dima!\\n\");\n\telse printf(\"%d\\n\", res);\n}\n\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "dfs and similar", "dsu", "shortest paths", "two pointers"], "dificulty": "2000", "interactive": false}