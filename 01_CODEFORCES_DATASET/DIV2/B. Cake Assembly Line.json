{
    "link": "https://codeforces.com//contest/1786/problem/B",
    "problemId": "1767292",
    "problem_idx": "B",
    "shortId": "1786B",
    "contest_number": "1786",
    "problem_submissions": {
        "E": [
            192342570,
            192306394,
            192404273,
            192327524,
            192339032,
            192311189,
            192325805,
            192320065,
            192441626,
            192343977,
            192328171,
            192315469,
            192316636,
            192338226,
            192342670,
            192339784,
            192342778
        ],
        "D": [
            192320379,
            192313768,
            192307277,
            192318549,
            192309409,
            192292999,
            192316314,
            192320950,
            192332305,
            192309612,
            192327595,
            192325214,
            192325223,
            192311769,
            192310059,
            192313834,
            192316588,
            192327743
        ],
        "F": [
            192310858,
            192336618,
            192349130,
            192348404,
            192333052,
            192339600,
            192329659,
            192334176,
            192328243,
            192307751,
            192340487,
            192363526,
            192345318
        ],
        "C": [
            192293366,
            192290648,
            192294881,
            192293245,
            192293510,
            192290179,
            192292716,
            192294689,
            192305954,
            192310133,
            192289535,
            192298071,
            192296223,
            192302623,
            192296901,
            192292106,
            192294116,
            192300798,
            192295593,
            192301556
        ],
        "B": [
            192288687,
            192344141,
            192291360,
            192289646,
            192340206,
            192287135,
            192290672,
            192302280,
            192292700,
            192296847,
            192294213,
            192293367,
            192300808,
            192292539,
            192288767,
            192289750,
            192293496,
            192292722,
            192296815
        ],
        "A2": [
            192287082,
            192284625,
            192286145,
            192285724,
            192290142,
            192283788,
            192286284,
            192297549,
            192284597,
            192306985,
            192286345,
            192288530,
            192296607,
            192287030,
            192284519,
            192284365,
            192288011,
            192288312,
            192289376
        ],
        "A1": [
            192287049,
            192283178,
            192286410,
            192283361,
            192283338,
            192284177,
            192283764,
            192296237,
            192283279,
            192307201,
            192286846,
            192283729,
            192297100,
            192283762,
            192283137,
            192282950,
            192288217,
            192285269,
            192287405
        ]
    },
    "name": "B. Cake Assembly Line",
    "statement": "A cake assembly line in a bakery was once again optimized, and now n\r\ncakes are made at a time! In the last step, each of the n cakes should\r\nbe covered with chocolate.Consider a side view on the conveyor belt, let\r\nit be a number line. The i-th cake occupies the segment [a_i - w, a_i +\r\nw] on this line, each pair of these segments does not have common\r\npoints. Above the conveyor, there are n dispensers, and when a common\r\nbutton is pressed, chocolate from the i-th dispenser will cover the\r\nconveyor segment [b_i - h, b_i + h]. Each pair of these segments also\r\ndoes not have common points. The calibration of this conveyor belt part\r\nhas not yet been performed, so you are to make it. Determine if it’s\r\npossible to shift the conveyor so that each cake has some chocolate on\r\nit, and there is no chocolate outside the cakes. You can assume that the\r\nconveyour is long enough, so the cakes never fall. Also note that the\r\nbutton can only be pressed once.\r\n",
    "solutions": [
        "// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, 1e5 + 5)\n\nint n, w, h;\nint a[N], b[N];\nint da[N], db[N];\n\nvoid solve() {\n\tqread(n, w, h);\n\tint gp = 2 * (w - h);\n\trep(i, 1, n) qread(a[i]), da[i] = a[i] - a[i - 1];\n\trep(i, 1, n) qread(b[i]), db[i] = b[i] - b[i - 1];\n\tint nw = 0, nmax = 0, nmin = 0;\n\trep(i, 2, n) {\n\t\tnw += da[i] - db[i];\n\t\tTo_max(nmax, nw);\n\t\tTo_min(nmin, nw);\n\t}\n\tif(nmax - nmin <= gp) cout << \"YES\\n\";\n\telse cout << \"NO\\n\";\n}\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\twhile(T--) solve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Cake Assembly Line.json",
    "editorial_link": "https://codeforces.com//blog/entry/112875",
    "editorial": "Obviously, the -th cake should be below the -th dispenser. The leftmost\r\npossible position of the cake is when the chocolate would touch the\r\nright border. If is the new position of the cakeâs center, then in this\r\ncase . The rightmost possible position is, similarly, when . Thus, the\r\nnew position of the center should be between and .This means that the\r\n-th cake should be shifted by any length between and . Since all cakes\r\non the conveyor move at the same time, the shift should satisfy for all\r\nat the same time. This is possible if and only if a value exists such\r\nthat which in turn is possible when Thus, it is enough to find the\r\nmaximum and minimum values of the formulas above and compare them. The\r\ntime complexity is linear.\r\n",
    "hint": []
}