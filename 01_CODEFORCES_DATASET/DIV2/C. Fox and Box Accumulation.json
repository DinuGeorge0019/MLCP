{"link": "https://codeforces.com//contest/389/problem/C", "problemId": "6402", "problem_idx": "C", "shortId": "389C", "contest_number": "389", "problem_submissions": {"E": [5882910, 5882969, 5882623, 5886206, 5886237, 5881359, 5883942, 5881790, 5884306, 5884558, 5884891, 5884833, 5884246, 5880945, 5884605, 5886580, 5885214], "D": [5882237, 5881458, 5884902, 5885057, 5884493, 5888919, 5897772, 5897726, 49394197, 5884093], "C": [5876164, 5877416, 5877602, 5880188, 5879512, 5878436, 5876090, 5875802, 5879892, 5879347, 5879938, 5880138, 5877698, 5882032, 5878167, 5879899, 5881858, 5880866, 5879314], "B": [5874987, 5875378, 5875703, 5877586, 5879904, 5875848, 5877618, 5882807, 5877301, 5876662, 5877573, 5877789, 5875543, 5877904, 5887635, 5878765, 5877214, 5882962], "A": [5874673, 5874703, 5875132, 5876405, 5874775, 5878441, 5882215, 5875954, 5875157, 5875352, 5876029, 5874692, 5875210, 5881846, 5875551, 5874698, 5879937]}, "name": "C. Fox and Box Accumulation", "statement": "Fox Ciel has boxes in her room. They have the same size and weight, but\r\nthey might have different strength. The -th box can hold at most boxes\r\non its top (we\u2019ll call the strength of the box). Since all the boxes\r\nhave the same size, Ciel cannot put more than one box directly on the\r\ntop of some box. For example, imagine Ciel has three boxes: the first\r\nhas strength 2, the second has strength 1 and the third has strength 1.\r\nShe cannot put the second and the third box simultaneously directly on\r\nthe top of the first one. But she can put the second box directly on the\r\ntop of the first one, and then the third box directly on the top of the\r\nsecond one. We will call such a construction of boxes a .Fox Ciel wants\r\nto construct piles from all the boxes. Each pile will contain some boxes\r\nfrom top to bottom, and there cannot be more than boxes on the top of\r\n-th box. What is the minimal number of piles she needs to construct?\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)\n\n#define DEBUG(x) { cout << #x << \" = \"; cout << x << endl; }\n#define PR(a,n) { cout << #a << \" = \"; FOR(_,1,n) cout << a[_] << ' '; cout << endl; }\n#define PR0(a,n) { cout << #a << \" = \"; REP(_,n) cout << a[_] << ' '; cout << endl; }\nusing namespace std;\n\nint a[111];\nint nPile, piles[111];\n\nint main() {\n    ios :: sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        FOR(i,1,n) cin >> a[i];\n        sort(a+1, a+n+1);\n\n        nPile = 0;\n        FOR(i,1,n) {\n            if (nPile == 0) {\n                piles[++nPile] = 1;\n            }\n            else {\n                if (piles[1] <= a[i]) ++piles[1];\n                else piles[++nPile] = 1;\n            }\n            sort(piles+1, piles+nPile+1);\n        }\n        cout << nPile << endl;\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "dp", "greedy"], "dificulty": "1400", "interactive": false}