{
    "link": "https://codeforces.com//contest/350/problem/E",
    "problemId": "3566",
    "problem_idx": "E",
    "shortId": "350E",
    "contest_number": "350",
    "problem_submissions": {
        "E": [
            4631521,
            4627481,
            4627736,
            4628109,
            4628919,
            4627306,
            4629552,
            4630396,
            4630738,
            4630557,
            4631036,
            4630307,
            4628626,
            4630765,
            4631090,
            4631222,
            4631307
        ],
        "D": [
            4631384,
            4632639,
            4630471
        ],
        "C": [
            4623828,
            4624599,
            4624536,
            4622933,
            4624699,
            4624176,
            4626336,
            4621951,
            4625656,
            4625740,
            4626157,
            4624456,
            4625990,
            4625202,
            4624685,
            4626744,
            4623856,
            4627186
        ],
        "B": [
            4622942,
            4623430,
            4623053,
            4625927,
            4623752,
            4628716,
            4624114,
            4623578,
            4624072,
            4624239,
            4624594,
            4626727,
            4624251,
            4624259,
            4627379,
            4623391,
            4627529,
            4625315
        ],
        "A": [
            4621532,
            4621502,
            4623629,
            4621549,
            4621709,
            4622086,
            4622630,
            4621567,
            4621446,
            4621939,
            4622148,
            4623843,
            4622109,
            4621409,
            4622118,
            4621840
        ]
    },
    "name": "E. Wrong Floyd",
    "statement": "Valera conducts experiments with algorithms that search for shortest\r\npaths. He has recently studied the Floyd\u2019s algorithm, so it\u2019s time to\r\nwork with it.Valera\u2019s already written the code that counts the shortest\r\ndistance between any pair of vertexes in a from vertexes and edges,\r\ncontaining no loops and multiple edges. Besides, Valera\u2019s decided to\r\nmark part of the vertexes. He\u2019s marked exactly vertexes .Valera\u2019s code\r\nis given below.ans[i][j] // the shortest distance for a pair of vertexes\r\na[i] // vertexes, marked by Valerafor(i = 1; i <= n; i++) { for(j = 1; j\r\n<= n; j++) { if (i == j) ans[i][j] = 0; else ans[i][j] = INF; //INF is a\r\nvery large number }} for(i = 1; i <= m; i++) { read a pair of vertexes\r\nu, v that have a non-directed edge between them; ans[u][v] = 1;\r\nans[v][u] = 1;}for (i = 1; i <= k; i++) { v = a[i]; for(j = 1; j <= n;\r\nj++) for(r = 1; r <= n; r++) ans[j][r] = min(ans[j][r], ans[j][v] +\r\nans[v][r]);}Valera has seen that his code is wrong. Help the boy. Given\r\nthe set of marked vertexes , find such , consisting of vertexes and\r\nedges, for which Valera\u2019s code counts the wrong shortest distance for at\r\nleast one pair of vertexes . Valera is really keen to get a graph\r\nwithout any loops and multiple edges. If no such graph exists, print -1.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int NMax=300;\nint N,M,K;\nint A[NMax],label[NMax],used[NMax];\nint main()\n{\n    scanf(\"%d%d%d\",&N,&M,&K);\n    for (int i=0;i<K;i++){\n        scanf(\"%d\",A+i);\n        A[i]--;\n    }\n    if (K==N || M>(N-1)*(N-2)/2+(N-K)){\n        printf(\"-1\\n\");\n    }else{\n        for (int i=0;i<N;i++)\n            used[i]=0;\n        for (int i=0;i<K;i++)\n            used[A[i]]=1;\n        int t=0;\n        for (int i=0;i<N;i++)\n            if (used[i])\n                label[t++]=i+1;\n        for (int i=0;i<N;i++)\n            if (!used[i])\n                label[t++]=i+1;\n        for (int i=1;i<N-1;i++)\n            printf(\"%d %d\\n\",label[i],label[i+1]);\n        printf(\"%d %d\\n\",label[0],label[N-1]);\n        int left=M-(N-1);\n        for (int i=1;i<N;i++)\n            for (int j=i+2;j<N;j++)\n                if (left){\n                    printf(\"%d %d\\n\",label[i],label[j]);\n                    left--;\n                }\n        for (int i=K;i<N-1;i++)\n            if (left){\n                printf(\"%d %d\\n\",label[0],label[i]);\n                left--;\n            }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Wrong Floyd.json",
    "editorial_link": "https://codeforces.com//blog/entry/9042",
    "editorial": "Let\u00e2\u0080\u0099s do the following: construct the graph with the maximum possible\r\nnumber of edges and then remove the excess. First of all, you can notice\r\nthat if answer is . Else let\u00e2\u0080\u0099s fix some marked vertex, for example .\r\nLet\u00e2\u0080\u0099s put in our graph all edges except edges beetween and , where an\r\nanother marked vertex. So, why this algorithm is correct? If Valera\u00e2\u0080\u0099s\r\nalgorithm is wrong, then there are a \u00e2\u0080\u009dbad\u00e2\u0080\u009d pair of vertexes (i, j).\r\n\u00e2\u0080\u009cBad\u00e2\u0080\u009d pair is a pair for that Valera\u00e2\u0080\u0099s algorithm works wrong. So, there\r\nare not marked vertex on the shortest path from i to j, and , and .\r\nWithout loss of generality, we can assume, that distance beetween and\r\nequals to 2, but Valera\u00e2\u0080\u0099s algorithm gives greater answer. There are some\r\ncases, that depends on the type of vertexes , . But we can look only at\r\nthe case where are marked vertexes. First, add to the graph all edges\r\nbeetween not fixed () vertexes. Second, add to the graph edges beetween\r\nsome fixed vertex ( or ) and some not marked vertex. Third, add to the\r\ngraph edges beetween and some marked vertex , where . It\u00e2\u0080\u0099s simple to\r\nunderstand, that if we add some another edge, the Valera\u00e2\u0080\u0099s algorithm\r\nwill work correctly. Total amount of edges is . BONUS Simple bonus. For\r\nsame contrains (, , ) can you build a graph, where Valera\u00e2\u0080\u0099s code works\r\ncorrectly? : 4632600\r\n"
}