{
    "link": "https://codeforces.com//contest/1918/problem/B",
    "problemId": "2452572",
    "problem_idx": "B",
    "shortId": "1918B",
    "contest_number": "1918",
    "problem_submissions": {
        "G": [
            244132893,
            245985475,
            244948797,
            244948670
        ],
        "F": [
            244120772,
            244125092,
            244126848,
            244126771,
            244130168,
            244131697,
            244138260,
            244138344,
            244139263,
            244138435,
            244141669,
            244144124,
            244142227,
            244122678,
            244157073,
            244156595,
            244332251,
            244124771,
            244360495,
            244129898
        ],
        "D": [
            244109167,
            244099156,
            244092966,
            244101787,
            244100881,
            244108481,
            244101721,
            244106486,
            244109529,
            244104916,
            244106995,
            244113590,
            244113865,
            244099423,
            244110295,
            244096244,
            244108027,
            244103663,
            244360463,
            244108155
        ],
        "E": [
            244103507,
            244108050,
            244110113,
            244110472,
            244112287,
            244124161,
            244125655,
            244123391,
            244119446,
            244125406,
            244135128,
            244134725,
            244128795,
            244112679,
            244118320,
            244116217,
            244928601,
            244928561
        ],
        "C": [
            244091247,
            244087599,
            244079342,
            244087694,
            244092782,
            244089213,
            244094187,
            244089808,
            244094684,
            244096501,
            244097023,
            244099017,
            244107490,
            244085730,
            244089866,
            244086764,
            244094953,
            244095107,
            244360406,
            244091142
        ],
        "B": [
            244083801,
            244076050,
            244075794,
            244073267,
            244075602,
            244075619,
            244082026,
            244079074,
            244080512,
            244082819,
            244079063,
            244082004,
            244078089,
            244075054,
            244078156,
            244075906,
            244081851,
            244083244,
            244360342,
            244080338
        ],
        "A": [
            244083099,
            244071431,
            244072186,
            244071210,
            244070855,
            244071315,
            244075506,
            244071630,
            244072257,
            244074358,
            244071939,
            244071253,
            244071114,
            244071560,
            244071154,
            244071990,
            244074495,
            244089579,
            244360312,
            244073174
        ]
    },
    "name": "B. Minimize Inversions",
    "statement": "You are given two permutations a and b of length n. A permutation is an\r\narray of n elements from 1 to n where all elements are distinct. For\r\nexample, an array [2,1,3] is a permutation, but [0,1] and [1,3,1]\r\naren’t.You can (as many times as you want) choose two indices i and j,\r\nthen swap a_i with a_j and b_i with b_j simultaneously. You hate\r\ninversions, so you want to minimize the total number of inversions in\r\nboth permutations.An inversion in a permutation p is a pair of indices\r\n(i, j) such that i < j and p_i > p_j. For example, if p=[3,1,4,2,5] then\r\nthere are 3 inversions in it (the pairs of indices are (1,2), (1,4) and\r\n(3,4)).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define N 200005\n#define P 1000000007\n#define INF 1061109567\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> PII;\ntypedef unsigned long long ull;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline ll read(){\n\tll x=0,f=1;char ch=GC;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=GC;}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=GC;}\n\treturn x*f;\n}\nint n;\nPII a[N];\nvoid Solve(){\n\tn=read();\n\tfor(int i=1;i<=n;i++)a[i].first=read();\n\tfor(int i=1;i<=n;i++)a[i].second=read();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)printf(\"%d \",a[i].first);\n\tprintf(\"\\n\");\n\tfor(int i=1;i<=n;i++)printf(\"%d \",a[i].second);\n\tprintf(\"\\n\");\n}\nint main(){\n\tfor(int T=read();T--;)Solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Minimize Inversions.json",
    "editorial_link": "https://codeforces.com//blog/entry/125300",
    "editorial": "TutorialNotice that by performing operations of the form: swap with and\r\nwith simultaneously, we can rearrange the array how we want, but the\r\nsame will correspond to the same (because we are changing both and at\r\nthe same time). Letâs sort the array using these operations. Then the\r\nsum of the number of inversions in and will be the number of inversions\r\nin , since is sorted. It is claimed that this is the minimum sum that\r\ncan be achieved.Proof: Consider two pairs of elements with and with ( <\r\n). In each of these pairs, there can be either or inversions, so among\r\nthe two pairs, there can be , , or inversions. If there were inversions\r\nbefore the operation, then there will be after the operation; if there\r\nwas , then there will still be ; if there were , then it will become .\r\nIf the permutation is sorted, then in each pair of indices and there\r\nwill be a maximum of 1 inversion, so any pair of indices will give no\r\nmore inversions than if they were swapped. Since the number of\r\ninversions in each pair is the minimum possible, the total number of\r\ninversions is also the minimum possible.Time complexity: per test case.\r\n",
    "hint": []
}