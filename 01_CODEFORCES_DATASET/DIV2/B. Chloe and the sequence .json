{"link": "https://codeforces.com//contest/743/problem/B", "problemId": "84652", "problem_idx": "B", "shortId": "743B", "contest_number": "743", "problem_submissions": {"C": [22970568, 22954819, 22955931, 22959540, 22960803, 22954630, 22967024, 22964712, 22959281, 22956710, 22956672, 22954587, 22959020, 22956501, 22953944, 22955848, 22960168, 22960967], "E": [22965880, 22967434, 22967306, 22968969, 22967268, 22973387, 22967640, 22968707, 22974150, 22967996, 22970034, 22971822, 22987515, 22975131, 41741833, 22975215, 22975586, 22974342], "B": [22955029, 22952524, 22952071, 22953395, 22954814, 22952559, 22951675, 22954634, 22953589, 22953782, 22953874, 22953034, 22954309, 22952189, 22955346, 22951377, 22952875, 22956475, 22953744], "D": [22953950, 22961837, 22961932, 22962256, 22961186, 22961360, 22956645, 22961156, 22963404, 22962979, 22963931, 22963003, 22964853, 22959856, 22961283, 22968732, 22964847, 22966379, 22964407], "A": [22950683, 22950781, 22950661, 22966387, 22969695, 22950835, 22950658, 22952400, 22951347, 22956844, 22951276, 22950972, 22951766, 22950741, 22951008, 22953378, 22951284]}, "name": "B. Chloe and the sequence ", "statement": "Chloe, the same as Vladik, is a competitive programmer. She didn\u2019t have\r\nany problems to get to the olympiad like Vladik, but she was confused by\r\nthe task proposed on the olympiad.Let\u2019s consider the following algorithm\r\nof generating a sequence of integers. Initially we have a sequence\r\nconsisting of a single element equal to . Then we perform steps. On each\r\nstep we take the sequence we\u2019ve got on the previous step, append it to\r\nthe end of itself and insert in the middle the minimum positive integer\r\nwe haven\u2019t used before. For example, we get the sequence after the first\r\nstep, the sequence after the second step.The task is to find the value\r\nof the element with index (the elements are numbered from ) in the\r\nobtained sequence, i. e. after steps.Please help Chloe to solve the\r\nproblem!\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long n,k;\n\nlong long get(long long n, long long k) {\n    long long length=(1ll<<n)-1;\n    if(length/2+1==k) return n;\n    else if(k<=length/2) return get(n-1,k);\n    else return get(n-1,k-length/2-1);\n}\n\nint main() {\n    scanf(\"%lld %lld\", &n, &k);\n    printf(\"%lld\\n\", get(n,k));\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "bitmasks", "constructive algorithms", "implementation"], "dificulty": "1200", "interactive": false}