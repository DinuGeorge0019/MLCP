{
    "link": "https://codeforces.com//contest/421/problem/C",
    "problemId": "8695",
    "problem_idx": "C",
    "shortId": "421C",
    "contest_number": "421",
    "problem_submissions": {
        "D": [
            6443401,
            6444205,
            6444726,
            6446063,
            6446478,
            6446284,
            6446050,
            6444829,
            6454312,
            6446753,
            6445453,
            6450944,
            6450576,
            6450561,
            6443659,
            6449123,
            6444238,
            6451898,
            6452897,
            6444608
        ],
        "E": [
            6445907,
            6454320,
            6451461,
            6451356
        ],
        "B": [
            6441973,
            6441563,
            6441704,
            6441641,
            6441800,
            6442174,
            6441468,
            6441877,
            6442830,
            6440426,
            6441645,
            6441812,
            6441558,
            6441555,
            6441997,
            6441532,
            6442176,
            6442193
        ],
        "A": [
            6440466,
            6440550,
            6440945,
            6440732,
            6440837,
            6440790,
            6440596,
            6440584,
            6445521,
            6440258,
            6440321,
            6440470,
            6440634,
            6440611,
            6440374,
            6440525,
            6440392,
            6440664
        ],
        "C": [
            6445332,
            6444054,
            6443650,
            6444031,
            6444561,
            6446258,
            6444406,
            6445050,
            6443582,
            6444686,
            6444343,
            6444298,
            6443933,
            6444277,
            6449346
        ]
    },
    "name": "C. Online Meeting",
    "statement": "Nearly each project of the F company has a whole team of developers\r\nworking on it. They often are in different rooms of the office in\r\ndifferent cities and even countries. To keep in touch and track the\r\nresults of the project, the F company conducts shared online meetings in\r\na Spyke chat.One day the director of the F company got hold of the\r\nrecords of a part of an online meeting of one successful team. The\r\ndirector watched the record and wanted to talk to the team leader. But\r\nhow can he tell who the leader is? The director logically supposed that\r\nthe leader is the person who is present at any conversation during a\r\nchat meeting. In other words, if at some moment of time at least one\r\nperson is present on the meeting, then the leader is present on the\r\nmeeting.You are the assistant director. Given the \u2019user logged on\u2019/\u2019user\r\nlogged off\u2019 messages of the meeting in the chronological order, help the\r\ndirector determine who can be the leader. Note that the director has the\r\nrecord of only a continuous part of the meeting (probably, it\u2019s not the\r\nwhole meeting).\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint n,m,i,j,a[100001],zf,b[100001],ans[100001],ans1;\nchar s[100001][2];\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (i=1;i<=m;i++)\n        scanf(\"%s %d\",s[i],&b[i]);\n    for (i=1;i<=m;i++)\n    {\n        if (!a[b[i]]&&s[i][0]=='-') zf++;\n        a[b[i]]++;\n    }\n    if (m>1)\n    {\n    for (i=1;i<=m-1;i++)\n    {\n        if (s[i][0]=='+') \n        {\n            if ((b[i-1]!=0&&b[i-1]!=b[i])||zf) ans[b[i]]=1;\n            zf++;\n        }else\n        {\n            if (b[i+1]!=b[i]) ans[b[i]]=1;\n            zf--;\n        }\n    }\n    if (s[m][0]=='+') {if (zf||b[m-1]!=b[m]) ans[b[m]]=1;}\n    else {if (zf>1) ans[b[m]]=1;}\n     \n    }\n    for (i=1;i<=n;i++)\n        if (!ans[i]) ans1++;\n    printf(\"%d\\n\",ans1);\n    for (i=1;i<=n;i++)\n        if (!ans[i]) printf(\"%d \",i);\n}\n            \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Online Meeting.json",
    "editorial_link": "https://codeforces.com//blog/entry/11871",
    "editorial": "Firstly lets add to the answer all the persons, that didn't appear in the log messages. Then we should consider two cases:\n\n1) If there is a person (with number i), that the first log message with him is in form ?-?i. We will call such persons X-persons.\n\nConsider all X-persons. Pick the one from them that has the last first occurrence in the sequence of messages. This person can be a leader, all others cannot be. Now we should check if the picked person is a leader or not. For that reason we will use the algorithm that is described below. This algorithm works fine only on special sequences of messages. So, we need to add all the X-persons to the beginning of the our list in the order they appear in input (in the resulting sequence the picked person should be the first).\n\n2) There is no X-persons.\n\nThat case only the first person from the list can be a leader. Others cannot be. Check that person with the algorithm described below.\n\nThe Algorithm of check:\n\nThe algorithm is very simple. Just to iterate throughout the sequence of messages and maintain set-structure for the persons that are currently on the meeting. If we consider log-on message, add the person to the set, if we consider log-off message, erase the person from the set. Each time we perform an operation with set, we should check: either the set is empty or the leader is in set.\n"
}