{
    "link": "https://codeforces.com//contest/1206/problem/E",
    "problemId": "390607",
    "problem_idx": "E",
    "shortId": "1206E",
    "contest_number": "1206",
    "problem_submissions": {
        "E": [
            59039805,
            59036400,
            59045379,
            59047524,
            59061157,
            59038336,
            59098032
        ],
        "D": [
            59025954,
            59041661,
            59045740,
            59034406,
            59022167,
            59028235,
            59026731,
            59020676,
            59024989,
            59028222,
            59026919,
            59119609,
            59027379,
            59028274,
            59026956,
            59027397,
            59024272,
            59026921,
            59027483,
            59030980
        ],
        "C": [
            59011466,
            59030604,
            59014696,
            59020664,
            59011212,
            59015302,
            59007726,
            59013014,
            59014421,
            59011545,
            59013350,
            59012812,
            59015649,
            59015519,
            59018230,
            59019306,
            59015315,
            59013410,
            59013599,
            59015972
        ],
        "B": [
            59004708,
            59042916,
            59007475,
            59009856,
            59005675,
            59005365,
            59003891,
            59005761,
            59008869,
            59005044,
            59005517,
            59007045,
            59004938,
            59005819,
            59066728,
            59009485,
            59006550,
            59008990,
            59005654,
            59005940,
            59006088
        ],
        "A": [
            59001296,
            59043245,
            59001405,
            59010625,
            59001679,
            59001121,
            59001149,
            59003026,
            59003048,
            59001270,
            59001447,
            59001759,
            59001966,
            59002120,
            59066711,
            59002946,
            59001221,
            59005963,
            59002062,
            59004823,
            59001151
        ],
        "F": [
            59027482,
            59114990,
            59100319
        ]
    },
    "name": "E. Palindromic Paths",
    "statement": "You are given a grid n\r\ntimes n, where n is . Rows are enumerated from 1 to n from up to down,\r\ncolumns are enumerated from 1 to n from left to right. Cell, standing on\r\nthe intersection of row x and column y, is denoted by (x, y).Every cell\r\ncontains 0 or 1. It is known that the top-left cell contains 1, and the\r\nbottom-right cell contains 0.We want to know numbers in all cells of the\r\ngrid. To do so we can ask the following questions: \"\", where 1\r\nle x_1\r\nle x_2\r\nle n, 1\r\nle y_1\r\nle y_2\r\nle n, and x_1 + y_1 + 2\r\nle x_2 + y_2. In other words, we output two different cells (x_1, y_1),\r\n(x_2, y_2) of the grid such that we can get from the first to the second\r\nby moving only to the right and down, and they arenâ€™t adjacent.As a\r\nresponse to such question you will be told if there exists a path\r\nbetween (x_1, y_1) and (x_2, y_2), going only to the right or down,\r\nnumbers in cells of which form a palindrome.For example, paths, shown in\r\ngreen, are palindromic, so answer for \"\" and \"\" would be that there\r\nexists such path. However, there is no palindromic path between (1, 1)\r\nand (3, 1). Determine all cells of the grid by asking not more than n^2\r\nquestions. It can be shown that the answer always exists.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nbool Query(int x1,int y1,int x2,int y2){\n\tprintf(\"? %d %d %d %d\\n\",x1,y1,x2,y2);\n\tfflush(stdout);\n\tint x; scanf(\"%d\",&x);\n\treturn x;\n}\nint a[100][100],n;\nbool f[55][55][55][55];\nint main(){\n\tscanf(\"%d\",&n);\n\tmemset(a,255,sizeof(a));\n\ta[1][1]=1; a[n][n]=0;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if ((i+j)%2==0){\n\t\tif ((i==1 && j==1) || (i==n && j==n)) continue;\n\t\tif (j>2){\n\t\t\ta[i][j]=Query(i,j-2,i,j)^a[i][j-2]^1;\n\t\t}else if (i>2){\n\t\t\ta[i][j]=Query(i-2,j,i,j)^a[i-2][j]^1;\n\t\t}else a[i][j]=Query(i-1,j-1,i,j)^a[i-1][j-1]^1;\n\t}\n\ta[1][2]=1;\n\tfor (int i=1;i<=n;++i) for (int j=2;j<=n;++j) if ((i+j)%2==1){\n\t\tif ((i==1 && j==2)) continue;\n\t\tif (j>3){\n\t\t\ta[i][j]=Query(i,j-2,i,j)^a[i][j-2]^1;\n\t\t}else if (i>2){\n\t\t\ta[i][j]=Query(i-2,j,i,j)^a[i-2][j]^1;\n\t\t}else a[i][j]=Query(i-1,j-1,i,j)^a[i-1][j-1]^1;\n\t}\n\tfor (int i=2;i<=n;i+=2)\n\t\ta[i][1]=Query(i,1,i,3)^a[i][3]^1;\n\t\n\tint wx0=-1,wy0,wx1,wy1;\n\t\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) f[i][j][i][j]=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if (i+1<=n && a[i][j]==a[i+1][j]) f[i][j][i+1][j]=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if (j+1<=n && a[i][j]==a[i][j+1]) f[i][j][i][j+1]=1;\n\tfor (int l=3;l<=2*n-1;++l) for (int i=1;i<=n;++i) for (int j=1;j<=n;++j) for (int i1=i;i1<=n;++i1){\n\t\tint j1=i+j+l-1-i1;\n\t\tif (j1<j || j1>n) continue;\n\t\tif (a[i][j]!=a[i1][j1]) continue;\n\t\tf[i][j][i1][j1]=f[i+1][j][i1-1][j1]|f[i+1][j][i1][j1-1]|f[i][j+1][i1-1][j1]|f[i][j+1][i1][j1-1];\n\t\tif (l%2==0 && f[i][j][i1][j1]) wx0=i,wy0=j,wx1=i1,wy1=j1;\n\t}\n\t\n\tif (wx0!=-1){\n\t\tif (!Query(wx0,wy0,wx1,wy1))\n\t\t\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if ((i+j)%2==1) a[i][j]^=1;\n\t\tputs(\"!\");\n\t\tfor (int i=1;i<=n;++i,puts(\"\")) for (int j=1;j<=n;++j) printf(\"%d\",a[i][j]);\n\t\treturn 0;\n\t}\n\t\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if ((i+j)%2==1) a[i][j]^=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) f[i][j][i][j]=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if (i+1<=n && a[i][j]==a[i+1][j]) f[i][j][i+1][j]=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if (j+1<=n && a[i][j]==a[i][j+1]) f[i][j][i][j+1]=1;\n\tfor (int l=3;l<=2*n-1;++l) for (int i=1;i<=n;++i) for (int j=1;j<=n;++j) for (int i1=i;i1<=n;++i1){\n\t\tint j1=i+j+l-1-i1;\n\t\tif (j1<j || j1>n) continue;\n\t\tif (a[i][j]!=a[i1][j1]) continue;\n\t\tf[i][j][i1][j1]=f[i+1][j][i1-1][j1]|f[i+1][j][i1][j1-1]|f[i][j+1][i1-1][j1]|f[i][j+1][i1][j1-1];\n\t\tif (l%2==0 && f[i][j][i1][j1]) wx0=i,wy0=j,wx1=i1,wy1=j1;\n\t}\n\t\n\tif (wx0!=-1){\n\t\tif (!Query(wx0,wy0,wx1,wy1))\n\t\t\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if ((i+j)%2==1) a[i][j]^=1;\n\t\tputs(\"!\");\n\t\tfor (int i=1;i<=n;++i,puts(\"\")) for (int j=1;j<=n;++j) printf(\"%d\",a[i][j]);\n\t\treturn 0;\n\t}\n\tassert(false);\n\t\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "interactive"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Palindromic Paths.json",
    "editorial_link": "https://codeforces.com//blog/entry/69158",
    "editorial": "Denote ask((x1,y1),(x2,y2))=1\n if there is a palindromic path between them, and 0\n otherwise. We also denote by grid[i][j]\n the number written in the cell (i,j)\n.\n\nFirstly, make an observation: if the Manhattan distance is |x2?x1|+|y2?y1|=\n 2, then ask((x1,y1),(x2,y2))=1?board[x1][y1]=board[x2][y2]\n. In fact, the path between the cells (x1,y1)\n and (x2,y2)\n has a length of 3\n, and therefore it is palindromic if and only if board[x1][y1]=board[x2][y2]\n.\n\nConsider a chessboard coloring such that the upper left unit is painted white. Then, using the observation described above, we can restore the numbers in all white cells. In a similar way, if we fix a certain number in a black cell, then all other numbers in black cells will be restored uniquely. Thus, we only have two options for arranging numbers on the board, which differ in the fact that in the second option, the numbers in the black cells are opposite to those in the first option. In the figure below, green pairs of white cells are connected, about which we can ask questions to find out all the values in them, and red - pairs of black cells.\n\n\nNow there are two approaches. First: for each option, calculate ask((x1,y1),(x2,y2))\n for each pair of suitable cells, find where they differ, and ask a question about these two cells. This way we can uniquely identify the board option. It is possible to determine ask((x1,y1),(x2,y2)\n using dynamic programming: the answer is 1\n only when grid[x1][y1]=grid[x2][y2]\n and there is a path -palindrome between a pair of (x1+1,y1),(x1,y1+1)\n and (x2?1,y2),(x2,y2?1)\n.\n\nThe second approach is a little more interesting, and it also shows why there is such a pair of cells for which the two options give different answers. Consider any path with a length of 4\n cells, denote the numbers in its cells as c1,c2,c3,c4\n. Then two of the cells of the path are black, and two are white. We know the relation between c1,c3\n, as well as between c2,c4\n (by the relation we mean that we know are numbers in them same, or different). Suppose that the relation between c1,c3\n is the same as between c2,c4\n. Then ask(c1,c4)\n will make it possible to uniquely determine all the numbers! Indeed, if c1=c4\n, then c2=c3\n, and therefore the path will be palindromic. Otherwise, no path between c1\n and c4\n will be palindromic. Thus, we will be able to establish a relation between some white and some black cell, which will be enough to solve the problem.\n\nSuppose that for any path of four cells c1,c2,c3,c4\n, the relation between c1,c3\n is different from the relation between c2,c4\n. This is equivalent to c1?c2?c3?c4=1\n. Suppose that for any path of four cells ?\n of numbers in them is equal to 1\n. Then we consider any path from the cell (1,1)\n to the cell (n,n)\n of length 2n?1\n. If the xor of each 4\n of neighboring cells in it is 1\n, then the line is periodic with a period of 4\n, but the numbers in the first and last cell in it are different from the condition! Thus, the algorithm is as follows: choose any path between (1,1)\n and (4,4)\n, find on it four cells with a xor of numbers equal to 0\n, and ask a question about it.\n\nAsymptotics O(n2)\n.",
    "hint": []
}