{"link": "https://codeforces.com//contest/1206/problem/E", "problemId": "390607", "problem_idx": "E", "shortId": "1206E", "contest_number": "1206", "problem_submissions": {"E": [59039805, 59036400, 59045379, 59047524, 59061157, 59038336, 59098032], "D": [59025954, 59041661, 59045740, 59034406, 59022167, 59028235, 59026731, 59020676, 59024989, 59028222, 59026919, 59119609, 59027379, 59028274, 59026956, 59027397, 59024272, 59026921, 59027483, 59030980], "C": [59011466, 59030604, 59014696, 59020664, 59011212, 59015302, 59007726, 59013014, 59014421, 59011545, 59013350, 59012812, 59015649, 59015519, 59018230, 59019306, 59015315, 59013410, 59013599, 59015972], "B": [59004708, 59042916, 59007475, 59009856, 59005675, 59005365, 59003891, 59005761, 59008869, 59005044, 59005517, 59007045, 59004938, 59005819, 59066728, 59009485, 59006550, 59008990, 59005654, 59005940, 59006088], "A": [59001296, 59043245, 59001405, 59010625, 59001679, 59001121, 59001149, 59003026, 59003048, 59001270, 59001447, 59001759, 59001966, 59002120, 59066711, 59002946, 59001221, 59005963, 59002062, 59004823, 59001151], "F": [59027482, 59114990, 59100319]}, "name": "E. Palindromic Paths", "statement": "You are given a grid n\r\ntimes n, where n is . Rows are enumerated from 1 to n from up to down,\r\ncolumns are enumerated from 1 to n from left to right. Cell, standing on\r\nthe intersection of row x and column y, is denoted by (x, y).Every cell\r\ncontains 0 or 1. It is known that the top-left cell contains 1, and the\r\nbottom-right cell contains 0.We want to know numbers in all cells of the\r\ngrid. To do so we can ask the following questions: \"\", where 1\r\nle x_1\r\nle x_2\r\nle n, 1\r\nle y_1\r\nle y_2\r\nle n, and x_1 + y_1 + 2\r\nle x_2 + y_2. In other words, we output two different cells (x_1, y_1),\r\n(x_2, y_2) of the grid such that we can get from the first to the second\r\nby moving only to the right and down, and they aren\u2019t adjacent.As a\r\nresponse to such question you will be told if there exists a path\r\nbetween (x_1, y_1) and (x_2, y_2), going only to the right or down,\r\nnumbers in cells of which form a palindrome.For example, paths, shown in\r\ngreen, are palindromic, so answer for \"\" and \"\" would be that there\r\nexists such path. However, there is no palindromic path between (1, 1)\r\nand (3, 1). Determine all cells of the grid by asking not more than n^2\r\nquestions. It can be shown that the answer always exists.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nbool Query(int x1,int y1,int x2,int y2){\n\tprintf(\"? %d %d %d %d\\n\",x1,y1,x2,y2);\n\tfflush(stdout);\n\tint x; scanf(\"%d\",&x);\n\treturn x;\n}\nint a[100][100],n;\nbool f[55][55][55][55];\nint main(){\n\tscanf(\"%d\",&n);\n\tmemset(a,255,sizeof(a));\n\ta[1][1]=1; a[n][n]=0;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if ((i+j)%2==0){\n\t\tif ((i==1 && j==1) || (i==n && j==n)) continue;\n\t\tif (j>2){\n\t\t\ta[i][j]=Query(i,j-2,i,j)^a[i][j-2]^1;\n\t\t}else if (i>2){\n\t\t\ta[i][j]=Query(i-2,j,i,j)^a[i-2][j]^1;\n\t\t}else a[i][j]=Query(i-1,j-1,i,j)^a[i-1][j-1]^1;\n\t}\n\ta[1][2]=1;\n\tfor (int i=1;i<=n;++i) for (int j=2;j<=n;++j) if ((i+j)%2==1){\n\t\tif ((i==1 && j==2)) continue;\n\t\tif (j>3){\n\t\t\ta[i][j]=Query(i,j-2,i,j)^a[i][j-2]^1;\n\t\t}else if (i>2){\n\t\t\ta[i][j]=Query(i-2,j,i,j)^a[i-2][j]^1;\n\t\t}else a[i][j]=Query(i-1,j-1,i,j)^a[i-1][j-1]^1;\n\t}\n\tfor (int i=2;i<=n;i+=2)\n\t\ta[i][1]=Query(i,1,i,3)^a[i][3]^1;\n\t\n\tint wx0=-1,wy0,wx1,wy1;\n\t\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) f[i][j][i][j]=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if (i+1<=n && a[i][j]==a[i+1][j]) f[i][j][i+1][j]=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if (j+1<=n && a[i][j]==a[i][j+1]) f[i][j][i][j+1]=1;\n\tfor (int l=3;l<=2*n-1;++l) for (int i=1;i<=n;++i) for (int j=1;j<=n;++j) for (int i1=i;i1<=n;++i1){\n\t\tint j1=i+j+l-1-i1;\n\t\tif (j1<j || j1>n) continue;\n\t\tif (a[i][j]!=a[i1][j1]) continue;\n\t\tf[i][j][i1][j1]=f[i+1][j][i1-1][j1]|f[i+1][j][i1][j1-1]|f[i][j+1][i1-1][j1]|f[i][j+1][i1][j1-1];\n\t\tif (l%2==0 && f[i][j][i1][j1]) wx0=i,wy0=j,wx1=i1,wy1=j1;\n\t}\n\t\n\tif (wx0!=-1){\n\t\tif (!Query(wx0,wy0,wx1,wy1))\n\t\t\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if ((i+j)%2==1) a[i][j]^=1;\n\t\tputs(\"!\");\n\t\tfor (int i=1;i<=n;++i,puts(\"\")) for (int j=1;j<=n;++j) printf(\"%d\",a[i][j]);\n\t\treturn 0;\n\t}\n\t\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if ((i+j)%2==1) a[i][j]^=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) f[i][j][i][j]=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if (i+1<=n && a[i][j]==a[i+1][j]) f[i][j][i+1][j]=1;\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if (j+1<=n && a[i][j]==a[i][j+1]) f[i][j][i][j+1]=1;\n\tfor (int l=3;l<=2*n-1;++l) for (int i=1;i<=n;++i) for (int j=1;j<=n;++j) for (int i1=i;i1<=n;++i1){\n\t\tint j1=i+j+l-1-i1;\n\t\tif (j1<j || j1>n) continue;\n\t\tif (a[i][j]!=a[i1][j1]) continue;\n\t\tf[i][j][i1][j1]=f[i+1][j][i1-1][j1]|f[i+1][j][i1][j1-1]|f[i][j+1][i1-1][j1]|f[i][j+1][i1][j1-1];\n\t\tif (l%2==0 && f[i][j][i1][j1]) wx0=i,wy0=j,wx1=i1,wy1=j1;\n\t}\n\t\n\tif (wx0!=-1){\n\t\tif (!Query(wx0,wy0,wx1,wy1))\n\t\t\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) if ((i+j)%2==1) a[i][j]^=1;\n\t\tputs(\"!\");\n\t\tfor (int i=1;i<=n;++i,puts(\"\")) for (int j=1;j<=n;++j) printf(\"%d\",a[i][j]);\n\t\treturn 0;\n\t}\n\tassert(false);\n\t\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "implementation", "interactive"], "dificulty": "2400", "interactive": false}