{
    "link": "https://codeforces.com//contest/1867/problem/E1",
    "problemId": "2204235",
    "problem_idx": "E1",
    "shortId": "1867E1",
    "contest_number": "1867",
    "problem_submissions": {
        "F": [
            222974823,
            222969528,
            222982087,
            222982811,
            222942381,
            222981865,
            222970849,
            223263369,
            222992160,
            222992118,
            222990610,
            223293875
        ],
        "E2": [
            222941139,
            222944891,
            222954532,
            222948444,
            222972148,
            222927706,
            222951442,
            222943457,
            222956697,
            222956351,
            222957299,
            222965859,
            222961624,
            222958308,
            222959237,
            222958461,
            222947616,
            222951450,
            222971686,
            222965055
        ],
        "E1": [
            222935951,
            222944650,
            222944932,
            222948245,
            222972552,
            222928046,
            222951818,
            222940287,
            222956433,
            222950145,
            222954065,
            222953208,
            222961246,
            222954058,
            222958971,
            222958084,
            222946896,
            222951047,
            222957812,
            222965382
        ],
        "D": [
            222929659,
            222935565,
            222933136,
            222933725,
            222959573,
            222947841,
            222976215,
            222934664,
            222934515,
            222943779,
            222942901,
            222940224,
            222926502,
            222939367,
            222939032,
            222944642,
            222964473,
            222961543,
            222946848,
            222932024
        ],
        "C": [
            222924786,
            222923447,
            222923495,
            222924317,
            222955570,
            222955063,
            222981892,
            222921233,
            222922345,
            222926941,
            222929128,
            222930091,
            222943796,
            222929098,
            222924664,
            222933035,
            222926807,
            222929365,
            222928181,
            222930087
        ],
        "B": [
            222916375,
            222917063,
            222916284,
            222918254,
            222947890,
            222958388,
            222980080,
            222916704,
            222917105,
            222917987,
            222920819,
            222919702,
            222916186,
            222917789,
            222919342,
            222922163,
            222919191,
            222921766,
            222918135,
            222919076
        ],
        "A": [
            222912165,
            222912569,
            222912487,
            222914168,
            222945721,
            222961169,
            222912375,
            222913097,
            222912526,
            222913140,
            222913385,
            222912716,
            222912425,
            222912955,
            222912750,
            222914115,
            222913574,
            222915575,
            222912204,
            222918270
        ]
    },
    "name": "E1. Salyg1n and Array  simple version ",
    "statement": "salyg1n has given you a positive integer k and wants to play a game with\r\nyou. He has chosen an array of n integers a_1, a_2,\r\nldots, a_n (1\r\nleq a_i\r\nleq 10^9). You must print a_1\r\noplus a_2\r\noplus\r\nldots\r\noplus a_n, where\r\noplus denotes the bitwise XOR operation. You can make queries of the\r\nfollowing type: ? i: in response to this query, you will receive a_i\r\noplus a_{i + 1}\r\noplus\r\nldots\r\noplus a_{i + k - 1}. Also, after this query, the subarray a_i, a_{i +\r\n1},\r\nldots, a_{i + k - 1} will be reversed, i.e., the chosen array a will\r\nbecome: a_1, a_2,\r\nldots a_{i - 1}, a_{i + k - 1}, a_{i + k - 2},\r\nldots, a_{i + 1}, a_i, a_{i + k},\r\nldots, a_n. You can make no more than 100 queries to answer the problem.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\n#define x first\n#define y second\n#define pb push_back\nusing namespace std;\nusing pii=pair <int,int>;\nusing tii=pair <pii,int>;\nvoid solve(){\n    int n,k;\n    cin>>n>>k;\n    int ans=0;\n    for (int i=1; i+k-1<=n; i+=k){\n        cout<<\"? \"<<i<<endl;\n        int t; cin>>t; ans^=t;\n    }\n    if (n%k==0){\n        cout<<\"! \"<<ans<<endl;\n        return;\n    }\n    for (int i=n/k*k-k+2; i+k-1<=n; i++){\n        cout<<\"? \"<<i<<endl;\n        int t; cin>>t; ans^=t;\n    }\n    cout<<\"! \"<<ans<<endl;\n}\nsigned main(){\n\t//ios_base::sync_with_stdio(0); cin.tie(0);\n\tint t=1;\n\tcin>>t;\n\twhile (t--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Salyg1n and Array  simple version .json",
    "editorial_link": "https://codeforces.com//blog/entry/120353",
    "editorial": "TutorialLetâs make queries to subarrays starting at positions , , , , as\r\nlong as these queries are valid, meaning their right boundary does not\r\nexceed . Letâs save the of all the answers to these queries. We will\r\ncall these queries primary.Now, we will shift the last subarray of the\r\nquery one unit to the right and make a new query, as long as the right\r\nboundary does not exceed . We will call these queries secondary. It is\r\nclaimed that the of the entire array will be equal to the of all the\r\nqueries. Letâs prove this.Let be the position at which the first\r\nsecondary query starts. Notice that after this query, the subarray [i; ]\r\nwill turn into the subarray [; ] and reverse. After the next query, the\r\nsame thing will happen, the subarray will shift one unit to the right\r\nand reverse. Therefore, the prefixes of length of each secondary query\r\nwill be the same, up to the reversal, which does not affect the . Since\r\nthe number of secondary queries is equal to , which is an even number,\r\nthe of these prefixes will not affect the of all the secondary queries,\r\nwhich will therefore be equal to the of the elements [a_({)iâ+âk1};\r\na_(n)], that is, all the elements that we did not consider in the\r\nprimary queries.The number of primary queries is equal to , since .The\r\nnumber of secondary queries is equal to , since .The total number of\r\nqueries does not exceed .\r\n",
    "hint": []
}