{
    "link": "https://codeforces.com//contest/738/problem/E",
    "problemId": "81059",
    "problem_idx": "E",
    "shortId": "738E",
    "contest_number": "738",
    "problem_submissions": {
        "E": [
            22355357,
            22354524,
            22368260,
            22349644,
            22355331,
            22356088,
            22356163,
            22356096,
            22357408,
            22351061,
            22356973,
            22355298,
            22358187,
            22357834,
            22357953,
            22357991,
            22358891,
            22358107,
            22359096,
            22358176,
            22359681
        ],
        "D": [
            22352887,
            22353039,
            22402501,
            22352355,
            22352815,
            22351941,
            22352850,
            22352916,
            22350647,
            22353806,
            22348566,
            22353986,
            22349405,
            22355113,
            22351157,
            22350006,
            22354616,
            22352089,
            22346385,
            22351808,
            22354557
        ],
        "C": [
            22348617,
            22348545,
            22351859,
            22348840,
            22349718,
            22349641,
            22349601,
            22352863,
            22355987,
            22353264,
            22351200,
            22353844,
            22349294,
            22354485,
            22353883,
            22349940,
            22349844,
            22371503,
            22354418,
            22355326,
            22351271
        ],
        "B": [
            22345078,
            22345223,
            22347131,
            22345520,
            22345422,
            22345771,
            22345810,
            22346401,
            22348268,
            22345003,
            22348061,
            22346211,
            22344435,
            22345892,
            22345784,
            22345313,
            22344813,
            22347694,
            22347099,
            22346201
        ],
        "A": [
            22343882,
            22343979,
            22345882,
            22343953,
            22344058,
            22344097,
            22344370,
            22344195,
            22346397,
            22343753,
            22346250,
            22343907,
            22343833,
            22344008,
            22343904,
            22343686,
            22344348,
            22345077
        ],
        "F": [
            22415691,
            22576726,
            22658711,
            22371212,
            22371207,
            22371193,
            22371178,
            22371166,
            22368114,
            22469249,
            22468405,
            22458802
        ]
    },
    "name": "E. Subordinates",
    "statement": "There are workers in a company, each of them has a unique id from to .\r\none of them is a chief, his id is . Each worker except the chief has\r\nexactly one immediate superior.There was a request to each of the\r\nworkers to tell how how many superiors (not only immediate). Worker’s\r\nsuperiors are his immediate superior, the immediate superior of the his\r\nimmediate superior, and so on. For example, if there are three workers\r\nin the company, from which the first is the chief, the second worker’s\r\nimmediate superior is the first, the third worker’s immediate superior\r\nis the second, then the third worker has two superiors, one of them is\r\nimmediate and one not immediate. The chief is a superior to all the\r\nworkers except himself.Some of the workers were in a hurry and made a\r\nmistake. You are to find the minimum number of workers that could make a\r\nmistake.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <unordered_map>\nusing namespace std;\n\nint n, g;\nvector <int> ch;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin >> n >> g;\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        int pr;\n        cin >> pr;\n        if (i == g && pr > 0)\n        {\n            ans = 1;\n            pr = 0;\n        } else\n        if (i != g && pr == 0)\n        {\n            pr = 1e9;\n        }\n\n        ch.push_back(pr);\n    }\n\n    sort(ch.begin(), ch.end());\n    int r = ch.size();\n    int cr = 1;\n    for (int i = 1; i < r; cr++)\n    {\n        int dp = ch[i];\n        if (cr != ch[i])\n        {\n            ans++;\n            r--;\n        } else\n        while (ch[i] == cr)\n        {\n            i++;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Subordinates.json",
    "editorial_link": "https://codeforces.com//blog/entry/48501",
    "editorial": "At first if the chief reported that he has one or more superiors let's change as in zero. If there are workers who do not chiefs but reported that they have no superiors let assume that they reported a number which more than the other workers, for example, number n.\n\nIt is necessarily that there must be the worker which has exactly one superior. If there is no such worker let's take the worker who reported the maximum number and change this number on 1. Then we need to make the same algorithm for numbers 2, 3, and etc. while there are workers, which have not yet considered.\n\nAfter we considered all workers the answer is the number of workers which reported numbers were changed.",
    "hint": []
}