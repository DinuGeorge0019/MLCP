{
    "link": "https://codeforces.com//contest/1793/problem/E",
    "problemId": "1779691",
    "problem_idx": "E",
    "shortId": "1793E",
    "contest_number": "1793",
    "problem_submissions": {
        "E": [
            193303068,
            193410509,
            193318182,
            193317664,
            193321898,
            193321819,
            195118865,
            193320360,
            193323873,
            193322184,
            193312387,
            193317745,
            193328336,
            193326548,
            193325450,
            193417270,
            193326710,
            193328225,
            193330842,
            193347782,
            193325695,
            193407475
        ],
        "F": [
            193294668,
            193432445,
            193283485,
            193302193,
            193292394,
            193301208,
            193303400,
            193301778,
            193305649,
            193314414,
            193303519,
            193297557,
            193311968,
            193311201,
            193435668,
            193417130,
            193298340,
            193305239,
            193316596,
            193292430,
            193291733,
            193298678,
            193285006
        ],
        "D": [
            193289297,
            193410468,
            193298851,
            193295249,
            193301162,
            193294370,
            195118553,
            193297347,
            193290499,
            193299884,
            193294597,
            193310876,
            193307621,
            193292591,
            193294931,
            193417683,
            193309769,
            193297566,
            193311269,
            193290315,
            193298522,
            193315173,
            193303157
        ],
        "C": [
            193282896,
            193410484,
            193410436,
            193291983,
            193285787,
            193287901,
            193282042,
            195118522,
            193288500,
            193283243,
            193287291,
            193286808,
            193292453,
            193283068,
            193285096,
            193286514,
            193417697,
            193294800,
            193285233,
            193294514,
            193283977,
            193285615,
            193312185,
            193282557
        ],
        "B": [
            193281488,
            193410417,
            193303429,
            193282163,
            193284281,
            193285830,
            195118463,
            193284739,
            193293047,
            193283557,
            193283997,
            193294754,
            193288469,
            193298342,
            193284337,
            193417706,
            193311244,
            193287539,
            193288050,
            193280259,
            193283801,
            193322565,
            193294257
        ],
        "A": [
            193280157,
            193410319,
            193280181,
            193280331,
            193281160,
            193280045,
            195118430,
            193280519,
            193280318,
            193279986,
            193280684,
            193280733,
            193280459,
            193280266,
            193280563,
            193417721,
            193281601,
            193308502,
            193281932,
            193295057,
            193280019,
            193319646,
            193290909
        ]
    },
    "name": "E. Velepin and Marketing",
    "statement": "The famous writer Velepin is very productive. Recently, he signed a\r\ncontract with a well-known publication and now he needs to write k_i\r\nbooks for i-th year. This is not a problem for him at all, he can write\r\nas much as he wants about samurai, space, emptiness, insects and\r\nwerewolves.He has n regular readers, each of whom in the i-th year will\r\nread one of the k_i books published by Velepin. Readers are very fond of\r\ndiscussing books, so the j-th of them will be satisfied within a year if\r\nat least a_j persons read the same book as him ().Velepin has obvious\r\nproblems with marketing, so he turned to you! A well-known book reading\r\nservice can control what each of Velepin’s regular readers will read,\r\nbut he does not want books to be wasted, so . And so they turned to you\r\nwith a request to tell you what the maximum number of regular readers\r\ncan be made satisfied during each of the years, if you can choose each\r\nperson the book he will read.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint n,q,a[300003];\nint f[300003],ans[300003],pre[300003];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=i)\n\t\t\tf[i]=max(f[i],pre[i-a[i]]+1);\n\t\tpre[i]=max(pre[i-1],f[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[i])\n\t\t\tans[f[i]+n-i]=i;\n\t\telse\n\t\t\tans[n-a[i]+1]=i;\n\tfor(int i=n;i>0;i--)\n\t\tans[i]=max(ans[i],ans[i+1]);\n\tcin>>q;\n\twhile(q--){\n\t\tint x;\n\t\tcin>>x;\n\t\tcout<<ans[x]<<'\\n';\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Velepin and Marketing.json",
    "editorial_link": "https://codeforces.com//blog/entry/112723",
    "editorial": "Letâs sort people by their group size requirement. Suppose we have such\r\na person that he is not satisfied, and we have a person who is\r\nsatisfied. Then we can replace person in his group with and the answer\r\nfor us will not be worse. It follows that for a particular the answer is\r\nsome prefix of the people we can make satisfied. Let us also prove that\r\nthere exists some arrangement of groups that covers the same prefix, and\r\nthat each group is a continuous segment. Letâs take some correct\r\npartitioning into groups. Then each group will be a set of unconnected\r\nsegments. Letâs take the leftmost such segment. Note that we can swap it\r\nto the nearest segment of the same group to the right without breaking\r\nanything. Thus we obtained that we can look for a solution in the form\r\nof partitioning each prefix into valid groups, which are segments. We\r\nwill solve this problem using dynamic programming. Let â the maximum\r\nnumber of groups into which th prefix can be partitioned, so that\r\neveryone is satisfied (and no elements beyond the prefix can be used).\r\nDynamics base: (empty prefix maximum can be divided into 0 groups).\r\nTransition: for th person his group must have size at least , so the\r\ntransition looks like this . But what if ? Then we canât dial the th\r\nprefix. Then we put . This dynamics can be calculated using prefix\r\nmaximums. This part of the solution works for . Earlier we said that the\r\nanswer would be some prefix of people who would be satisfied. If we can\r\npartition the prefix into some number of groups, then that answer can be\r\nthe prefix for all . (we partition our prefix into , and the rest of the\r\npeople one by one into the group) If we canât make the whole prefix\r\nsatisfied (), then we need to add people from outside. Thus, the maximum\r\nnumber of groups we can split into if th prefix is completely satisfied\r\nis . Note that if by some prefix we can score , then we can also score\r\n(combining two groups into one). Then we need to find the largest prefix\r\nthat fits the given in the query. This can be done by an array of suffix\r\nmaximums over total. The final asymptotic of the solution is . Code\r\n",
    "hint": []
}