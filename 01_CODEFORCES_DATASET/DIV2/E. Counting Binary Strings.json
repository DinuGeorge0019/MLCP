{
    "link": "https://codeforces.com//contest/1920/problem/E",
    "problemId": "2424504",
    "problem_idx": "E",
    "shortId": "1920E",
    "contest_number": "1920",
    "problem_submissions": {
        "F2": [
            241519708,
            242461640,
            241499605,
            241499150,
            241499121,
            241526798,
            241677520,
            242000469
        ],
        "F1": [
            241460299,
            241470662,
            241472660,
            241471905,
            241452735,
            241475361,
            241451154,
            241473438,
            241479153,
            241478315,
            241484928,
            241465563,
            241477422,
            241477811,
            241688562,
            241479348,
            241481887,
            241485652,
            241484576,
            241481175
        ],
        "E": [
            241449808,
            241450749,
            250647629,
            250647603,
            250646809,
            241453536,
            241456702,
            241468503,
            241457240,
            241473848,
            241459615,
            241448891,
            241462905,
            241455611,
            241473828,
            241462340,
            241463447,
            241688611,
            241464804,
            241470317,
            241459879,
            241463678,
            241464099
        ],
        "D": [
            241440349,
            241444733,
            241443927,
            241444084,
            241461216,
            241445290,
            241465918,
            241452364,
            241443025,
            241445939,
            241448263,
            241452666,
            241453380,
            241452851,
            241446075,
            241446900,
            241450746,
            241452656,
            241457511
        ],
        "C": [
            241424760,
            241434849,
            241435347,
            241432571,
            241426106,
            241430363,
            241433735,
            241436246,
            241435590,
            241433210,
            241428829,
            241435049,
            241436115,
            241439877,
            241436063,
            241433607,
            241435067,
            241438107,
            241435335
        ],
        "B": [
            241420376,
            241425242,
            241428830,
            241429674,
            241419228,
            241425601,
            241423672,
            241427964,
            241426457,
            241429604,
            241423387,
            241427147,
            241430484,
            241428576,
            241428228,
            241423313,
            241427602,
            241429162,
            241430149
        ],
        "A": [
            241418935,
            241420574,
            241419051,
            241419262,
            241421587,
            241419112,
            241419031,
            241419259,
            241421308,
            241419216,
            241419840,
            241421070,
            241419328,
            241428462,
            241421467,
            241419238,
            241420328,
            241420339,
            241423810
        ]
    },
    "name": "E. Counting Binary Strings",
    "statement": "Patrick calls a substring^\r\ndagger of a binary string^\r\nddagger if this substring contains exactly one . Help Patrick count the\r\nnumber of binary strings s such that s contains exactly n good\r\nsubstrings and has no good substring of length strictly greater than k.\r\nNote that substrings are differentiated by their location in the string,\r\nso if s = you should count both occurrences of .^\r\ndagger A string a is a substring of a string b if a can be obtained from\r\nb by the deletion of several (possibly, zero or all) characters from the\r\nbeginning and several (possibly, zero or all) characters from the end.^\r\nddagger A binary string is a string that only contains the characters\r\nand .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define isz(x) ((int)x.size())\n#define sumof(x) accumulate(all(x), 0ll)\n\nconst int N=2510, mod=998244353;\nint f[N][N], n, k;\n\nvoid add(int &x, int y){\n   x=x+y>=mod?x+y-mod:x+y;\n}\n\nvoid solve(){\n   cin >> n >> k;\n   for (int i=0; i<=n; ++i) f[0][i]=1;\n   for (int i=1; i<=n; ++i){\n      for (int j=0; j<=i; ++j){\n         for (int t=0; t<=n; ++t){\n            int d=i-(j+1)*(t+1);\n            if (d<0 || j+t+1>k) break;\n            add(f[i][j], f[d][t]);\n         }\n      }\n   }\n   int ans=0;\n   for (int i=0; i<=n; ++i) add(ans, f[n][i]);\n   cout << ans << '\\n';\n   for (int i=0; i<=n; ++i) for (int j=0; j<=n; ++j) f[i][j]=0;\n}\n\nint32_t main(){\n   ios_base::sync_with_stdio(false);\n   cin.tie(nullptr);\n   int ntests=1;\n   cin >> ntests;\n   for (int i=1; i<=ntests; ++i) solve();\n   return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Counting Binary Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/122560",
    "editorial": "Let's first solve the problem where we are given some string s\n and must count the number of good substrings. To do this we use the technique of counting contributions. For every 1\n in s\n, we find the number of good substrings containing that 1\n. Consider the following example:\n\n00001??????a10001??????a200000001????????????a30001??????a4000????a5\nThe number of good substrings in this example is a1a2+a2a3+a3a4+a4a5\n. We can create such array for any string s\n and the number of good substrings of s\n is the sum of the products of adjacent elements of the array.\n\nThis motivates us to reformulate the problem. Instead, we count the number of arrays a1,a2,...,am\n such that every element is positive and the sum of the products of adjacent elements is exactly equal to n\n. Furthermore, every pair of adjacent elements should have sum minus 1\n be less than or equal to k\n. We can solve this with dynamic programming.\n\ndpi,j=number of arrays with sum i and last element j\ndpi,j=?p=1min(?ij?,k?j+1)dpi?j?p,p\nThe key observation is that we only have to iterate p\n up to ?ij?\n (since if p\n is any greater, j?p\n will exceed i\n). At j=1\n, we will iterate over at most ?i1?\n values of p\n. At j=2\n, we will iterate over at most ?i2?\n values of p\n. In total, at each i\n, we will iterate over at most ?i1?+?i2?+?+?ii??ilogi\n values of p\n. Thus, the time complexity of our solution is O(nklogn)\n."
}