{
    "link": "https://codeforces.com//contest/1248/problem/E",
    "problemId": "445267",
    "problem_idx": "E",
    "shortId": "1248E",
    "contest_number": "1248",
    "problem_submissions": {
        "D1": [
            62994883,
            62993569,
            62992994,
            62997000,
            62994405,
            62997123,
            62999879,
            62995062,
            63003271,
            63000150,
            62999671,
            62994350,
            62998586,
            63000530,
            62992886,
            63075982,
            63072868,
            62991824,
            63006771
        ],
        "F": [
            62993845,
            62998618,
            63004376,
            63001516,
            63005145,
            63007254,
            63006725,
            63065814,
            63007421,
            63002656,
            63007898,
            63005627,
            63007696,
            63008967,
            63006462,
            63004460,
            63011504,
            63004125,
            63006964
        ],
        "E": [
            62985708,
            63073739,
            63003347,
            63018519,
            63004851
        ],
        "B": [
            62982231,
            62980110,
            62981055,
            62979292,
            62979961,
            62980992,
            62979799,
            62981220,
            62982692,
            62978096,
            62982064,
            62982362,
            62978497,
            62981072,
            62981976,
            62984594,
            63075956,
            62980955,
            62980611,
            62983563,
            62990769
        ],
        "A": [
            62979317,
            62977969,
            62978225,
            62977588,
            62977692,
            62977600,
            62977679,
            62978301,
            62980908,
            62977684,
            62981014,
            62982770,
            62977469,
            62977721,
            62977859,
            62979794,
            63075933,
            62977868,
            62980509,
            62980376,
            62988720
        ],
        "C": [
            62977501,
            62984679,
            62987113,
            62992373,
            62990888,
            62990326,
            62991798,
            62987434,
            62987346,
            62987305,
            62995225,
            62994509,
            63000614,
            62991483,
            62996125,
            63009114,
            62993964,
            62985766,
            62994340,
            62987126
        ],
        "D2": [
            63072452,
            63005552
        ]
    },
    "name": "E. Queue in the Train",
    "statement": "There are n seats in the train\u2019s car and there is exactly one passenger\r\noccupying every seat. The seats are numbered from 1 to n from left to\r\nright. The trip is long, so each passenger will become hungry at some\r\nmoment of time and will go to take boiled water for his noodles. The\r\nperson at seat i (1\r\nleq i\r\nleq n) will decide to go for boiled water at minute t_i.Tank with a\r\nboiled water is located to the left of the 1-st seat. In case too many\r\npassengers will go for boiled water simultaneously, they will form a\r\nqueue, since there can be only one passenger using the tank at each\r\nparticular moment of time. Each passenger uses the tank for exactly p\r\nminutes. We assume that the time it takes passengers to go from their\r\nseat to the tank is negligibly small. Nobody likes to stand in a queue.\r\nSo when the passenger occupying the i-th seat wants to go for a boiled\r\nwater, he will first take a look on all seats from 1 to i - 1. In case\r\nat least one of those seats is empty, he assumes that those people are\r\nstanding in a queue right now, so he would be better seating for the\r\ntime being. However, at the very first moment he observes that all seats\r\nwith numbers smaller than i are busy, he will go to the tank.There is an\r\nunspoken rule, that in case at some moment several people can go to the\r\ntank, than only the leftmost of them (that is, seating on the seat with\r\nsmallest number) will go to the tank, while all others will wait for the\r\nnext moment.Your goal is to find for each passenger, when he will\r\nreceive the boiled water for his noodles.\r\n",
    "solutions": [
        "// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC optimize(\"Ofast,no-stack-protector\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define debug(x) std::cerr << (#x) << \":\\t\" << (x) << std::endl;\n#define fastIO std::ios_base::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nstd::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst double PI = atan2(0., -1.);\nconst int INF = 0x3f3f3f3f;\nconst int N = 100100;\n\n// 0 - unused\n// 1 - used\n\nclass Event {\npublic:\n\tint type;\n\tll time;\n\tint index;\n\n\tEvent() = default;\n\n\tEvent(int type, ll time, int index) : type(type), time(time), index(index) {}\n\n\tbool operator<(const Event& other) const {\n\t\treturn time < other.time || (time == other.time && type < other.type)\n\t\t\t\t\t\t\t\t || (time == other.time && type == other.type && index < other.index);\n\t}\n};\n\nll t[N];\nll ans[N];\n\nint main(void) {\n\tint n;\n\tll p;\n\tscanf(\"%d%lld\", &n, &p);\n\n\tstd::set<Event> setik;\n\tstd::set<int> queue;\n\tstd::set<int> ready;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lld\", &t[i]);\n\n\t\tsetik.insert(Event(0, t[i], i));\n\t}\n\n\tll timer = 0;\n\n\twhile (!setik.empty()) {\n\t\tint type = setik.begin()->type;\n\t\tll time = setik.begin()->time;\n\t\tint index = setik.begin()->index;\n\n\t\tsetik.erase(setik.begin());\n\n\t\tif (type == 0) {\n\t\t\tif (queue.empty() || *queue.begin() > index) {\n\t\t\t\tqueue.insert(index);\n\t\t\t\tsetik.insert(Event(1, std::max(timer, t[index]) + p, index));\n\t\t\t\ttimer = std::max(timer, t[index]) + p;\n\t\t\t} else {\n\t\t\t\tready.insert(index);\n\t\t\t}\n\t\t} else {\n\t\t\tans[index] = time;\n\t\t\tqueue.erase(index);\n\n\t\t\twhile (!ready.empty() && (queue.empty() || *queue.begin() > *ready.begin())) {\n\t\t\t\tint index = *ready.begin();\n\t\t\t\tready.erase(ready.begin());\n\n\t\t\t\tqueue.insert(index);\n\t\t\t\tsetik.insert(Event(1, std::max(timer, t[index]) + p, index));\n\t\t\t\ttimer = std::max(timer, t[index]) + p;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tprintf(\"%lld \", ans[i]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Queue in the Train.json",
    "editorial_link": "https://codeforces.com//blog/entry/70720",
    "editorial": "The problem can be solved easily with an abstraction of \"events\". Let's define an \"event\" as a tuple of variables (time,type,index)\n, where index\n is the index of the passenger (1?index?n)\n, time\n is the time when the event will happen, type\n is either 0\n (the passenger exits the queue) or 1\n (the passenger wants to enter the queue).\n\nTo simulate the activity described in the problem it's necessary to handle events in sorted order. At the start there are n\n events (ti,1,i)\n, where 1?i?n\n. While there are any unprocessed events, we take the \"smallest\" event and process it. Event (a,b,c)\n is \"smaller\" than event (d,e,f)\n either if (a<d)\n or (a=d and b<e)\n or (a=d and b=e and c<f)\n.\n\nLet's define a few sets: want\n (the set of passengers who want to enter the queue), in_queue\n (the set of passengers who are in the queue); and a few integer variables: queue_time\n (the time when the queue becomes empty, to help calculate the time when a new passenger will exit the queue if he enters now), cur_time\n (time of the last processed event).\n\nSuppose that we're processing an event. If the type\n of the event is 1\n, then we add index\n to want\n, otherwise we remove index\n from in_queue\n. After processing an event we ought to check if there is a passenger who can enter the queue. Let x\n be the smallest element of want\n, and if in_queue\n either is empty or x\n is smaller than the smallest element of in_queue\n, then x\n immediately enters the queue, therefore creating a new event (max(cur_time,queue_time)+p,0,x)\n.\n\nThe complexity of the solution is O(nlogn)\n, because we need to use sorted data structures (for example, std::set of std::priority_queue)."
}