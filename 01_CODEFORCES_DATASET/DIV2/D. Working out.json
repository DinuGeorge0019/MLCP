{
    "link": "https://codeforces.com//contest/430/problem/D",
    "problemId": "9400",
    "problem_idx": "D",
    "shortId": "430D",
    "contest_number": "430",
    "problem_submissions": {
        "E": [
            6596209,
            6601239,
            6595457,
            6596869,
            6611998
        ],
        "C": [
            6593903,
            6589689,
            6590185,
            6591146,
            6594509,
            6591043,
            6594881,
            6592145,
            6591439,
            6590916,
            6592010,
            6592041,
            6592596,
            6592644,
            6593233,
            6592230,
            6592515,
            6591488,
            6591864
        ],
        "D": [
            6592681,
            6591086,
            6597590,
            6592274,
            6591820,
            6594037,
            6592628,
            6594400,
            6599564,
            6594397,
            6596203,
            6595708,
            6594744,
            6595014,
            6595972,
            6596088,
            6594380,
            6593712,
            6595433
        ],
        "B": [
            6591917,
            6588904,
            6589347,
            6590112,
            6589136,
            6589725,
            6590062,
            6590923,
            6589922,
            6588990,
            6590100,
            6590128,
            6591019,
            6591186,
            6590471,
            6590715,
            6590194,
            6589294,
            6593720
        ],
        "A": [
            6588412,
            6588136,
            6588222,
            6588465,
            6590072,
            6588672,
            6588238,
            6589003,
            6588856,
            6595945,
            6588333,
            6588427,
            6589419,
            6589285,
            6588864,
            6589371,
            6595841,
            6600698,
            6589758
        ]
    },
    "name": "D. Working out",
    "statement": "Summer is coming! It’s time for Iahub and Iahubina to work out, as they\r\nboth want to look hot at the beach. The gym where they go is a matrix\r\nwith lines and columns. Let number represents the calories burned by\r\nperforming workout at the cell of gym in the -th line and the -th\r\ncolumn.Iahub starts with workout located at line and column . He needs\r\nto finish with workout . After finishing workout , he can go to workout\r\nor . Similarly, Iahubina starts with workout and she needs to finish\r\nwith workout . After finishing workout from cell , she goes to either or\r\n. There is one additional condition for their training. They have to\r\nmeet in exactly one cell of gym. At that cell, none of them will work\r\nout. They will talk about fast exponentiation (pretty odd small talk)\r\nand then both of them will move to the next workout.If a workout was\r\ndone by either Iahub or Iahubina, it counts as total gain. Please plan a\r\nworkout for Iahub and Iahubina such as total gain to be as big as\r\npossible. Note, that Iahub and Iahubina can perform workouts with\r\ndifferent speed, so the number of cells that they use to reach meet cell\r\nmay differs.\r\n",
    "solutions": [
        "/**************************************************\n *        Problem:  Codeforces #245 Div.2 Problem D\n *         Author:  clavichord93\n *          State:  \n **************************************************/\n\n/**************************************************\n * Header\n **************************************************/\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <limits>\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Copy(a, b) memcpy(a, b, sizeof(b))\n#define NPOS string::npos\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define rrep(i, a, b) for (int i = a; i >= b; i--)\n#define erep(j, a) for (Edge *j = a; j; j = j->next)\n#define irep(i, a) for (__typeof(a.begin()) i = a.begin(); i != a.end(); i++)\n#define srep(sub, s) for (int sub = s & (s - 1); sub; sub = (sub - 1) & s)\n#define sqr(a) ((a) * (a))\n#define R(x) scanf(\"%d\", &x)\n#define SS(a, b) scanf(\"%d %d\", &a, &b)\n#define SSS(a, b, c) scanf(\"%d %d %d\", &a, &b, &c)\n#define O(x) pf(\"%d\\n\", x)\n#define TEST int T;scanf(\"%d\", &T);for (int cas = 1; cas <= T; cas++)\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define ppb pop_back\n#define pft push_front\n#define ppf pop_front\n#define mp make_pair\n#define vec vector\n#define it iterator\n#define fir first\n#define sec second\n#define x first\n#define y second\n#define all(a) a.begin(),a.end()\n#define sz(a) (int)(a.size())\n#define bg(a) (a).begin()\n#define en(a) (a).end()\n#define clr(a) (a).clear()\n#define dbg(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n#define bit_cnt(x) __builtin_popcount((unsigned)x)\n#define gcd(a, b) __gcd(a, b)\n#define sqr(a) ((a) * (a))\n#define lch(t) (t << 1)\n#define rch(t) (t << 1 | 1)\n#define inf numeric_limits<int>::max()\n#define finf numeric_limits<double>::infinity()\nusing namespace std;\ntemplate<class T> inline bool gmin(T &a, T b) { if (a > b) return a = b, true; return false; }\ntemplate<class T> inline bool gmax(T &a, T b) { if (a < b) return a = b, true; return false; }\ntemplate<class T> T exgcd(T a, T b, T &x, T &y) { if (!b) return x = (T)1, y = (T)0, a; else { T d = exgcd(b, a % b, y, x); return y -= a / b * x, d; } }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<double, double> pdd;\ntypedef pair<double, pdd> pddd;\ntypedef vec<int> vi;\ntypedef vec<double> vd;\ntypedef vec<pii> vii;\ntypedef vec<pdd> vdd;\ntypedef istringstream iss;\ntypedef ostringstream oss;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1e10;\nconst double EPS = 1e-9;\nconst double PI = 3.14159265358979323846264338327950288;\nconst double TAU = 2.0 * PI;\ninline int sgn(const double &a) { return a > EPS ? 1 : (a < -EPS ? -1 : 0); }\ninline int lowbit(int i) { return i & (-i); }\nstruct Initializer { Initializer() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); } } initializer;\n\n/**************************************************\n * Templates\n **************************************************/\n\n\n\n/**************************************************\n * Main\n **************************************************/\n\nconst int MAXN = 1005;\n\nint n, m;\nint a[MAXN][MAXN], f1[MAXN][MAXN], f2[MAXN][MAXN], f3[MAXN][MAXN], f4[MAXN][MAXN];\n\nint main() {\n    SS(n, m);\n    rep (i, 1, n) rep (j, 1, m) R(a[i][j]);\n    Fill(f1, 0); Fill(f2, 0); Fill(f3, 0); Fill(f4, 0);\n    rep (i, 1, n) rep (j, 1, m) f1[i][j] = max(f1[i - 1][j], f1[i][j - 1]) + a[i][j];\n    rep (i, 1, n) rrep (j, m, 1) f2[i][j] = max(f2[i - 1][j], f2[i][j + 1]) + a[i][j];\n    rrep (i, n, 1) rep (j, 1, m) f3[i][j] = max(f3[i + 1][j], f3[i][j - 1]) + a[i][j];\n    rrep (i, n, 1) rrep (j, m, 1) f4[i][j] = max(f4[i + 1][j], f4[i][j + 1]) + a[i][j];\n    int ans = 0;\n    rep (i, 2, n - 1) rep (j, 2, m - 1) {\n        gmax(ans, f1[i - 1][j] + f4[i + 1][j] + f2[i][j + 1] + f3[i][j - 1]);\n        gmax(ans, f1[i][j - 1] + f4[i][j + 1] + f2[i - 1][j] + f3[i + 1][j]);\n    }\n    pf(\"%d\\n\", ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Working out.json",
    "editorial_link": "https://codeforces.com//blog/entry/12265",
    "editorial": "The particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.\n\nOnly 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.\n\n \n\nIn the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell.\n\nFor first case, Iahub comes from (1, 1) to (X, Y  1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X  1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X  1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y  1) and then from (X, Y + 1) to (1, M).\n\nWe can precalculate for dynamic programming matrixes and we're done.\n\ndp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.\n\ndp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.\n\ndp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.\n\ndp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.",
    "hint": []
}