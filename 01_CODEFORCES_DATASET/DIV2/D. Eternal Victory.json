{"link": "https://codeforces.com//contest/61/problem/D", "problemId": "329", "problem_idx": "D", "shortId": "61D", "contest_number": "61", "problem_submissions": {"E": [297557, 298354, 299765, 298760, 299302, 300026, 298805, 298830, 833084, 299976, 299390], "C": [299344, 297579, 298009, 298379, 297522, 299902], "D": [298617, 297917, 298753, 297829, 297376, 298013, 298270, 297930, 300268, 300239, 298137, 298462, 301286, 299908, 298694, 298971], "B": [297301, 297249, 297156, 300780, 297065, 300083, 296997, 297227, 297390, 297332, 298348, 297120, 297793, 299907, 297445], "A": [296624, 296901, 296650, 296734, 296546, 296509, 296491, 296685, 296595, 296884, 296502, 296659, 296457, 299906, 296765, 296472]}, "name": "D. Eternal Victory", "statement": "Valerian was captured by Shapur. The victory was such a great one that\r\nShapur decided to carve a scene of Valerian\u2019s defeat on a mountain. So\r\nhe had to find the best place to make his victory eternal!He decided to\r\nvisit all cities of Persia to find the best available mountain, but\r\nafter the recent war he was too tired and didn\u2019t want to traverse a lot.\r\nSo he wanted to visit each of these cities at least once with smallest\r\npossible traverse. Persian cities are connected with bidirectional\r\nroads. You can go from any city to any other one using these roads and\r\nthere is a unique path between each two cities.All cities are numbered\r\nto . Shapur is currently in the city and he wants to visit all other\r\ncities with minimum possible traverse. He can finish his travels in any\r\ncity.Help Shapur find how much He should travel.\r\n", "solutions": ["# include <cstdio>\n# include <vector>\n# include <algorithm>\n# include <iostream>\n\nusing namespace std;\n\nstruct two\n{\n    int vert,weight;\n};\n\nvector<two>adjlist [100000];\n\nint maxdepth=0;\n\nvoid dfs(int vertex,int parent,int depth)\n{\n    if(depth>maxdepth)maxdepth=depth;\n    for(int i=0;i<adjlist[vertex].size();i++)\n    {\n        int v=adjlist[vertex][i].vert;\n        if(v!=parent)dfs(v,vertex,depth+adjlist[vertex][i].weight);\n    }\n}\n\nint main()\n{\n    int N;\n    scanf(\"%d\",&N);\n    \n    long long ret=0ll;\n    for(int i=1;i<N;i++)\n    {\n        int a;\n        two temp;\n        scanf(\"%d%d%d\",&a,&temp.vert,&temp.weight);\n        --a;--temp.vert;\n        adjlist[a].push_back(temp);\n        swap(a,temp.vert);\n        adjlist[a].push_back(temp);\n        ret+=temp.weight;\n    }\n    ret<<=1;\n    \n    dfs(0,-1,0);\n    cout<<ret-maxdepth<<\"\\n\";\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "greedy", "shortest paths", "trees"], "dificulty": "1800", "interactive": false}