{
    "link": "https://codeforces.com//contest/703/problem/D",
    "problemId": "67404",
    "problem_idx": "D",
    "shortId": "703D",
    "contest_number": "703",
    "problem_submissions": {
        "E": [
            19666489,
            19673872
        ],
        "B": [
            19626552,
            19623646,
            19623489,
            19622672,
            19623589,
            19622607,
            19630316,
            19626462,
            19622834,
            19627334,
            19621557,
            19624072,
            19622040,
            19636121,
            19621168,
            19623567,
            19627920,
            19622029,
            19622154,
            19622540
        ],
        "D": [
            19626399,
            19625673,
            19630973,
            19636020,
            19629091,
            19634472,
            19637884,
            19624772,
            19628022,
            19634609,
            19626277,
            19629769,
            19629743,
            19636886,
            19631115,
            19635175,
            19634015,
            19631464,
            19625267,
            19625595,
            19625868
        ],
        "C": [
            19623139,
            19633081,
            19627637,
            19624674,
            19630730,
            19625930,
            19632821,
            19631298,
            19627565,
            19632128,
            19636417,
            19634592,
            19629638,
            19625401,
            19632242,
            19634683,
            19635534
        ],
        "A": [
            19617844,
            19618704,
            19618318,
            19617935,
            19617774,
            19620750,
            19618191,
            19619005,
            19619467,
            19627709,
            19617913,
            19620674,
            19618195,
            19621709,
            19617804,
            19620263,
            19618582,
            19620732,
            19617828,
            19618666
        ]
    },
    "name": "D. Mishka and Interesting sum",
    "statement": "Little Mishka enjoys programming. Since her birthday has just passed,\r\nher friends decided to present her with array of non-negative integers\r\nof elements!Mishka loved the array and she instantly decided to\r\ndetermine its beauty value, but she is too little and can’t process\r\nlarge arrays. Right because of that she invited you to visit her and\r\nasked you to process queries.Each query is processed in the following\r\nway: Two integers and () are specified bounds of query segment.\r\nIntegers, presented in array segment (in sequence of integers ) , are\r\nwritten down. XOR-sum of written down integers is calculated, and this\r\nvalue is the answer for a query. Formally, if integers written down in\r\npoint 2 are , then Mishka wants to know the value , where operator of\r\nexclusive bitwise OR. Since only the little bears know the definition of\r\narray beauty, all you are to do is to answer each of queries presented.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define FZ(n) memset((n),0,sizeof(n))\n#define FMO(n) memset((n),-1,sizeof(n))\n#define MC(n,m) memcpy((n),(m),sizeof(n))\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) begin(x),end(x)\n#define IOS do { ios_base::sync_with_stdio(0);cin.tie(0); } while (0)\n#define SZ(x) ((int)(x).size())\n#ifndef OFFLINE\n    #define ONLINE_JUDGE\n#endif\n#ifdef ONLINE_JUDGE\n#define FILEIO(name) \\\n    do { \\\n        freopen(name\".in\", \"r\", stdin); \\\n        freopen(name\".out\", \"w\", stdout); \\\n    } while (0)\n#else\n    #define FILEIO(name) do { } while(0)\n#endif\n\n#define _TOKEN_CAT2(x, y) x ## y\n#define _TOKEN_CAT(x, y) _TOKEN_CAT2(x, y)\n#define _MACRO_OVERL3(_1, _2, _3, _N, ...) _N\n#define _RANGE1(a) int _TOKEN_CAT(_t, __LINE__)=0; _TOKEN_CAT(_t, __LINE__)<(a); (_TOKEN_CAT(_t, __LINE__))++\n#define _RANGE2(i, a) int (i)=0; (i)<(a); (i)++\n#define _RANGE3(i, a, b) int (i)=(a); (i)!=(b); (i)+=((b)>(a)?1:-1)\n#define loop(...) for (_MACRO_OVERL3(__VA_ARGS__, _RANGE3, _RANGE2, _RANGE1)(__VA_ARGS__))\n\n#ifdef OFFLINE\ntemplate<typename T>\nvoid _dump(const char* s, T&& head) { \n    cerr << s << \" = \" << head << \" <<\" << endl; \n}\n\ntemplate<typename T, typename... Args>\nvoid _dump(const char* s, T&& head, Args&&... tail) {\n    int c = 0;\n    while (*s!=',' || c!=0) {\n        if (*s=='(' || *s=='[' || *s=='{' || *s=='<') c++;\n        if (*s==')' || *s==']' || *s=='}' || *s=='>') c--;\n        cerr << *s++;\n    }\n    cerr << \" = \" << head << \", \";\n    _dump(s+1, tail...);\n}\n\n#define dump(...) do { \\\n    cerr << \"\\033[32m>> \" << __LINE__ << \": \" << __PRETTY_FUNCTION__ << endl; \\\n    cout << \"   \"; \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n    cout << \"\\033[0m\"; \\\n} while (0)\n#else\n#define dump(...) \n#endif\n\n#define au auto\ntemplate<class T>\nusing vec = vector<T>;\n\ntemplate<typename Iter>\nostream& _IterOutput_(ostream &o, Iter b, Iter e, const string ss=\"\", const string se=\"\") {\n    o << ss;\n    for (auto it=b; it!=e; it++) o << (it==b ? \"\" : \", \") << *it;\n    return o << se;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const pair<T1, T2> &pair) {\n    return o << \"(\" << pair.F << \", \" << pair.S << \")\";\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const vector<T> &vec) {\n    return _IterOutput_(o, ALL(vec), \"[\", \"]\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const set<T> &st) {\n    return _IterOutput_(o, ALL(st), \"{\", \"}\");\n}\n\ntemplate<typename T, size_t N>\nostream& operator << (ostream &o, const array<T, N> &arr) {\n    return _IterOutput_(o, ALL(arr), \"|\", \"|\");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const map<T1, T2> &mp) {\n    o << \"{\";\n    for (auto it=mp.begin(); it!=mp.end(); it++) {\n        o << (it==mp.begin()?\"\":\", \") << it->F << \":\" << it->S;\n    }\n    o << \"}\";\n    return o;\n}\n\nvoid lucky_test() {\n    srand(time(NULL));\n    long long a = rand(), b = rand();\n    if ((a * 32768 + b) % 100000 == 0) {\n        cout << \"Not lucky\" << endl;\n        exit(0);\n    }\n}\n\nconst int MX = 1123456;\n\ninline int lb(int a) {\n    return a&(-a);\n}\nstruct BIT {\n    int v[MX];\n    void chg(int a, int x) {\n        a+=2;\n        for (int i=a; i; i-=lb(i)) {\n            v[i] ^= x;\n        }\n    }\n\n    int qry(int a) {\n        a+=2;\n        int t = 0;\n        for (int i=a; i<MX; i+=lb(i)) {\n            t ^= v[i];\n        }\n        return t;\n    }\n}bit;\n\n\nint32_t main() {\n    IOS;\n    lucky_test();\n\n    static int ip[MX];\n    int N;\n    cin >> N;\n    for (int i=0; i<N; i++) {\n        cin >> ip[i];\n    }\n\n    int Q;\n    cin>>Q;\n    using pii = pair<int, int>;\n    static vector<pii> q[MX];\n    for (int i=0; i<Q; i++) {\n        int l, r;\n        cin>>l>>r;\n        l--;\n        r--;\n        q[r].PB({l, i});\n    }\n\n    static int ans[MX];\n    map<int, int> mp;\n\n    for (int i=0; i<N; i++) {\n        int v = ip[i];\n        if (mp.count(v)) {\n            bit.chg(mp[v], v);\n            //cout << i << endl;\n            //cout << \"chg = \" << mp[v] << ' ' << v << endl;\n        }\n        mp[v] = i;\n\n        for (auto qr: q[i]) {\n            int l = qr.F, id = qr.S;\n            ans[id] = bit.qry(l);\n        }\n    }\n\n    for (int i=0; i<Q; i++) {\n        cout << ans[i] << '\\n';\n    }\n\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Mishka and Interesting sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/46434",
    "editorial": "Easy to see, that the answer for query is XOR-sum of all elements in the\r\nsegment xored with XOR-sum of distinct elements in the segment. XOR-sum\r\nof all numbers we can find in using partial sums. As for the XOR-sum of\r\ndistinct numbers... Letâs solve easier problem. Let the queries be like\r\n\"find the number of distinct values in a segment\". Letâs sort all the\r\nqueries according to their right bounds and iterate through all elements\r\nof our array. We also need to make a list , where is the last position\r\nof on the processed prefix of array. Assume we are at position . Then\r\nthe answer for the query in the segment () is , where if and otherwise.\r\nItâs easy to store and update such values in . When moving to the next\r\nposition we have to make the following assignments: . To get described\r\nsum in we can use segment tree (or Fenwick tree) instead of standard\r\narray. Now letâs turn back to our problem. Everything we have to do is\r\nto change assignment to and count XOR-sum instead of sum. Now we can\r\nsolve this problem in . Solution (with Fenwick) P.S.: Also there is a\r\nsolution with complexity (using Moâs algo), but we tried to kill it :D\r\n",
    "hint": []
}