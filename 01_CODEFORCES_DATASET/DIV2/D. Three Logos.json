{
    "link": "https://codeforces.com//contest/581/problem/D",
    "problemId": "36593",
    "problem_idx": "D",
    "shortId": "581D",
    "contest_number": "581",
    "problem_submissions": {
        "F": [
            13269721,
            13273884,
            13274265,
            13275076,
            13273744,
            28883204,
            28746729,
            47707720
        ],
        "D": [
            13265543,
            13266561,
            13267830,
            13267677,
            13269943,
            13268843,
            13267395,
            13266212,
            13271770,
            13271940,
            13275900,
            13267190,
            13291663,
            13273782,
            13269289,
            13268754,
            13272747,
            13271148,
            13266871
        ],
        "C": [
            13263338,
            13262839,
            13263933,
            13262818,
            13262223,
            13263848,
            13264045,
            13262035,
            13264956,
            13270049,
            13269879,
            13263828,
            13264992,
            13264829,
            13264204,
            13266233,
            13265980,
            13264067,
            13263215
        ],
        "B": [
            13262072,
            13261090,
            13262462,
            13261193,
            13266387,
            13261281,
            13260860,
            13260910,
            13262535,
            13261711,
            13263433,
            13261203,
            13261560,
            13261063,
            13261266,
            13262720,
            13262876,
            13261537,
            13260790
        ],
        "A": [
            13260348,
            13259765,
            13260479,
            13259829,
            13262614,
            13259668,
            13259435,
            13259565,
            13260421,
            13259502,
            13259898,
            13259464,
            13259945,
            13259651,
            13259594,
            13259520,
            13260392,
            13260013,
            13259545
        ]
    },
    "name": "D. Three Logos",
    "statement": "Three companies decided to order a billboard with pictures of their\r\nlogos. A billboard is a big board. A logo of each company is a rectangle\r\nof a non-zero area. Advertisers will put up the ad only if it is\r\npossible to place all three logos on the billboard so that they do not\r\noverlap and the billboard has no empty space left. When you put a logo\r\non the billboard, you should rotate it so that the sides were parallel\r\nto the sides of the billboard.Your task is to determine if it is\r\npossible to put the logos of all the three companies on some square\r\nbillboard without breaking any of the described rules.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint main()\n{\n    int a,b,c,d,e,f,ans=0,k=-1,n1,n2;\n    cin>>a>>b>>c>>d>>e>>f;\n    ans=a*b+c*d+e*f;\n    for(n1=1;n1<=1000;n1++)\n        if(n1*n1==ans)\n        {\n            k=n1;\n            break;\n        }\n    if(k==-1)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(b==k)\n        swap(a,b);\n    if(d==k)\n        swap(c,d);\n    if(f==k)\n        swap(e,f);\n    if(a==k&&c==k&&e==k)\n    {\n        cout<<k<<endl;\n        for(n1=1;n1<=b;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar('A');\n            printf(\"\\n\");\n        }\n        for(n1=1;n1<=d;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar('B');\n            printf(\"\\n\");\n        }\n        for(n1=1;n1<=f;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar('C');\n            printf(\"\\n\");\n        }\n        return 0;\n    }\n    int sd=0;\n    if(c==k)\n    {\n        sd=1;\n        swap(a,c);\n        swap(b,d);\n    }\n    else\n    if(e==k)\n    {\n        sd=2;\n        swap(a,e);\n        swap(b,f);\n    }\n    if(a!=k)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(d==k-b)\n        swap(c,d);\n    if(f==k-b)\n        swap(e,f);\n    if(c!=k-b||e!=k-b)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    {\n        cout<<k<<endl;\n        for(n1=1;n1<=b;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar('A'+sd);\n            printf(\"\\n\");\n        }\n        for(n1=1;n1<=k-b;n1++)\n        {\n            if(sd!=1)\n            for(n2=1;n2<=d;n2++)\n                putchar('B');\n            else\n            for(n2=1;n2<=d;n2++)\n                putchar('A');   \n            if(sd!=2)                       \n            for(n2=1;n2<=f;n2++)\n                putchar('C');\n            else\n            for(n2=1;n2<=f;n2++)\n                putchar('A');\n            printf(\"\\n\");\n        }\n        return 0;\n    }           \n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "geometry",
        "implementation",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Three Logos.json",
    "editorial_link": "https://codeforces.com//blog/entry/20508",
    "editorial": "This problem can be solved in many ways, let's consider one of them.\n\nThe first step is to calculate sum of squares s of given rectangles. Then the side of a answer square is sqrt(s). If sqrt(s) is not integer print -1. Else we need to make the following.\n\nWe brute the order in which we will add given rectangles in the answer square (we can do it with help of next_permutation()) and for every order we brute will we rotate current rectangle on 90 degrees or not (we can do it with help of bit masks). In the beginning on every iteration the answer square c in which we add the rectangles is empty.\n\nFor every rectangle, which we add to the answer square we make the following \u0097 we need to find the uppermost and leftmost empty cell free in answer square c (recall that we also brute will we rotate the current rectangle on 90 degrees or not). Now we try to impose current rectangle in the answer square c and the top left corner must coinside with the cell free. If current rectangle fully placed in the answer square c and does not intersect with the some rectangle which has already been added, we need to fill by the required letter appropriate cells in the answer square c.\n\nIf no one of the conditions did not disrupted after we added all three rectangles and all answer square c is fully filled by letters we found answer and we neeed only to print the answer square c.\n\nElse if we did not find answer after all iterations on the rectangles \u0097 print -1.\n\nFor random number of the rectangles k asymptotic behavior \u0097 O(k!?*?2k?*?s) where s \u0097 the sum of squares of the given rectangles.\n\nAlso this problem with 3 rectangles can be solved with the analysis of the cases with asymptotic O(s) where s \u0097 the sum of squares of given rectangles."
}