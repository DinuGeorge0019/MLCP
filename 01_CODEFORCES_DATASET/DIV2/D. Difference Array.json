{
    "link": "https://codeforces.com//contest/1708/problem/D",
    "problemId": "1465650",
    "problem_idx": "D",
    "shortId": "1708D",
    "contest_number": "1708",
    "problem_submissions": {
        "E": [
            164526365,
            164509978,
            164525791,
            164525144,
            164515105,
            164526880,
            164565405
        ],
        "D": [
            164483082,
            164475794,
            164498322,
            164502919,
            164500499,
            164493036,
            164483535,
            164489653,
            164492932,
            164487483,
            164496395,
            164492041,
            164496037,
            164494420,
            164494528,
            164500816,
            164498429,
            164498353,
            164501077
        ],
        "C": [
            164476151,
            164486488,
            164480189,
            164506917,
            164526449,
            164483780,
            164470946,
            164474613,
            164471073,
            164464598,
            164477489,
            164480460,
            164478377,
            164479833,
            164476392,
            164474668,
            164479091,
            164477458,
            164469257
        ],
        "B": [
            164463973,
            164514329,
            164488244,
            164465324,
            164492077,
            164499834,
            164464194,
            164460225,
            164462182,
            164458987,
            164462805,
            164471454,
            164467808,
            164468216,
            164463689,
            164461529,
            164464211,
            164467907,
            164461028
        ],
        "A": [
            164463865,
            164513385,
            164484667,
            164457212,
            164489629,
            164494393,
            164457849,
            164457193,
            164457578,
            164456205,
            164457572,
            164457666,
            164458662,
            164460280,
            164458147,
            164456758,
            164456563,
            164456719,
            164456652
        ]
    },
    "name": "D. Difference Array",
    "statement": "You are given an array a consisting of n non-negative integers. It is\r\nguaranteed that a is sorted from small to large.For each operation, we\r\ngenerate a new array b_i=a_{i+1}-a_{i} for 1\r\nle i < n. Then we sort b from small to large, replace a with b, and\r\ndecrease n by 1.After performing n-1 operations, n becomes 1. You need\r\nto output the only integer in array a (that is to say, you need to\r\noutput a_1).\r\n",
    "solutions": [
        "// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, 1e5 + 5)\n\nint n, m;\nint a[N], b[N], t1, t2;\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\tW(T) {\n\t\tqread(n); t1 = n;\n\t\trep(i, 1, n) qread(a[i]);\n\t\tint c0 = 0;\n\t\twhile(t1 > 1) {\n\t\t\tt2 = 0;\n\t\t\tif(c0) --c0, b[++t2] = a[1];\n\t\t\trep(i, 2, t1) b[++t2] = a[i] - a[i - 1];\n\t\t\tsort(b + 1, b + t2 + 1);\n\t\t\tt1 = 0;\n\t\t\trep(i, 1, t2) if(b[i]) a[++t1] = b[i]; else ++c0;\n\t\t}\n\t\tcout << (t1 ? a[1] : 0) << '\\n';\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Difference Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/104930",
    "editorial": "Let's prove that the brute-force solution (considering zeros differently) can pass.\n\nDefine S=?i=1nai\n and it changes when an operation is performed.\n\nAfter sorting the array a\n and ignoring 0\n s, the fact\n\nn?1+ann?1?S?S?an(ai?1)\n\nis always true.\n\nAnd after performing one operation, S=an?a1?an\n.\n\nSo in each operation, you cost O(nlogn)\n time to sort the new array and decrease S\n by at least n?1\n.\n\nAfter the first operation, S\n is O(an)\n. The complexity is O(AlogA)\n, where A=max{n,an}\n.",
    "hint": []
}