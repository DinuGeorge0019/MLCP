{
    "link": "https://codeforces.com//contest/749/problem/E",
    "problemId": "85479",
    "problem_idx": "E",
    "shortId": "749E",
    "contest_number": "749",
    "problem_submissions": {
        "E": [
            23157045,
            23158471,
            23159955,
            23159227,
            23159699,
            23201671,
            23188698,
            23188666,
            23161857,
            23249468,
            23159356,
            23161181
        ],
        "D": [
            23150269,
            23155017,
            23153167,
            23156936,
            23152064,
            23151488,
            23150216,
            23152653,
            23152526,
            23153002,
            23153816,
            23153299,
            23153576,
            23153949,
            23154660,
            23153221,
            23154083,
            23155240,
            23153806,
            23154081
        ],
        "C": [
            23147336,
            23149855,
            23149193,
            23149595,
            23147564,
            23151828,
            23148654,
            23149362,
            23149269,
            23149897,
            23148430,
            23149965,
            23148722,
            23175263,
            23147964,
            23150407,
            23148950,
            23162490,
            23148466
        ],
        "B": [
            23145982,
            23147492,
            23146643,
            23146380,
            23145252,
            23147345,
            23149268,
            23146406,
            23146519,
            23147467,
            23146720,
            23146308,
            23146859,
            23149282,
            23150475,
            23147414,
            23147519,
            23146953,
            23155115
        ],
        "A": [
            23143678,
            23144522,
            23143768,
            23144671,
            23143613,
            23143623,
            23143733,
            23144118,
            23144102,
            23144679,
            23143737,
            23143812,
            23143610,
            23143762,
            23150938,
            23145011,
            23144267,
            23144159,
            23143669
        ]
    },
    "name": "E. Inversions After Shuffle",
    "statement": "You are given a permutation of integers from to . Exactly once you apply\r\nthe following operation to this permutation: pick a random segment and\r\nshuffle its elements. Formally: Pick a random segment (continuous\r\nsubsequence) from to . All segments are equiprobable. Let , i.e. the\r\nlength of the chosen segment. Pick a random permutation of integers from\r\nto , . All permutation are equiprobable. This permutation is applied to\r\nelements of the chosen segment, i.e. permutation is transformed to . if\r\na pair of elements (not necessary neighbouring) with the wrong relative\r\norder. In other words, the number of inversion is equal to the number of\r\npairs such that and . Find the expected number of inversions after we\r\napply exactly one operation mentioned above.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\n\nll n;\nll a[N];\ntypedef pair <double, pair<double, ll> > pll;\npll t[4 * N];\ndouble f[4 * N];\n\ninline pll merge(pll a, pll b)\n{\n\treturn mp(a.F + b.F, mp(a.S.F + b.S.F, a.S.S + b.S.S));\n}\n\ninline double get2(ll v, ll tl, ll tr, ll l ,ll r)\n{\n\tif(l > r)\n\t\treturn 0;\n\tif(tl == l && tr == r)\n\t\treturn f[v];\n\tll tm = tl + tr >> 1;\n\treturn get2(v + v, tl ,tm, l, min(r, tm)) + get2(v + v +1 , tm + 1, tr, max(tm + 1, l), r);\t\n}\n\ninline void upd2(ll v, ll tl, ll tr , ll p, double x)\n{\n\tif(tl == tr)\n\t{\n\t\tf[v] = x;\n\t\treturn;\n\t}\n\tll tm = tl + tr >> 1;\n\tif(p <= tm)\n\t\tupd2(v + v, tl, tm, p, x);\n\telse\n\t\tupd2(v  +v + 1, tm + 1, tr, p, x);\n\tf[v] = f[v + v] + f[v + v + 1];\t\n}\n\ninline pll get(ll v, ll tl, ll tr, ll l, ll r)\n{\n\tif(l > r) return mp(0, mp(0, 0));\n\tif(tl == l && tr == r)\n\t\treturn t[v];\n\tll tm = tl + tr >> 1;\n\treturn merge(get(v + v, tl, tm, l, min(r, tm)), get(v + v + 1, tm + 1, tr, max(tm + 1, l), r));\n}\n\ninline void upd(ll v, ll tl, ll tr, ll p, pll x)\n{\n\tif(tl == tr)\n\t{\n\t\tt[v] = x;\n\t\treturn;\n\t}\n\tll tm = tl + tr >> 1;\n\tif(p <= tm)\n\t\tupd(v + v, tl, tm, p, x);\n\telse\n\t\tupd(v + v + 1, tm + 1, tr, p, x);\n\tt[v] = merge(t[v + v], t[v + v + 1]);\n}\ndouble ans;\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tcin>>n;\n\tfo(i,n)\n\t\tcin>>a[i];\n\tfor(ll i=n;i>=1;--i)\n\t{\n\t\tdouble c = i / 2.0;\n\t\tpair<double, pair<double, ll> > d = get(1, 1, n, 1, a[i] - 1);\n\t\tll cnt = d.S.S;\n\t\tdouble allj = d.F;\n\t\tdouble alli = d.S.F;\n\t\tans += ((n - i) * (n - i + 1) - (i * i + i)) / 2.0 * cnt;\n\t\tans += i * alli;\n\t\tans += allj;\n\t\tdouble s = get2(1, 1, n, 1, a[i] - 1);\n\t\tans += s * i / 2.0;\n\t\ts = get2(1, 1, n, a[i] + 1, n);\n\t\tans += s * i / 2.0;\n\t\tupd2(1, 1, n, a[i], n - i + 1);\n\t\tupd(1, 1, n, a[i], mp(0, mp(i, 1))); \n\t}\n\t     /*\n\ti < j \n\t\ta[i] < a[j]\n\t\t\ti * (n - j + 1) / 2.0;\n\t\ta[i] > a[j]\n\t\t\ti * (n - j + 1) / 2.0;\n\n\t\t (n - i) * (n - i + 1) / 2 - (j - i - 1) * (j - i) / 2\n\n\t\t- (j * j - i * j - j - i * j + i * i + i) / 2\n\t\t- i * i - i    / 2\n\n\t   (n - i) * (n - i + 1) / 2 - (i * i + i) / 2\n\n\t\t\n\t\t\t\n  */\n\n\tcout.precision(15);\n\tcout << fixed << ans / (n * (n + 1) / 2.0);\n\n\n\treturn 0;\t\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "probabilities"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Inversions After Shuffle.json",
    "editorial_link": "https://codeforces.com//blog/entry/49186",
    "editorial": "Lets calculate all available segments count . It will be a denominator\r\nof answer fraction.Also, necessary to understand, that expected value of\r\ninversion count in shuffled permutation with length len equal (It can be\r\nprooved by fact, that for each permutation there are mirrored\r\npermutation (or biection ) and sum of inversion count his permutations\r\nare equal inversions).Next, we will find expected value of difference\r\nbetween expected value of inversion count after operation and inversion\r\ncount in the source array. And add it to the inversion count in the\r\nsource array.For every segment we will calculate the count of inversions\r\nin it, and also the expected value of the inversion count in it after\r\nshuffle. Take the difference and divide by a denominator. Sum these\r\nvalues for all segments. This solution has quadratic asympthotics, try\r\nto improve it.We will go through the permutation from right to left and\r\nfor each position count the sum of inversions in the initial permutation\r\nfor all segments that start in the current position (denote that the\r\nlargest segment which ends at the position has the length ), also we\r\nwill maintain the sum of expected values of the inversion counts on the\r\nsegments of lengths . Knowing these two numbers, increase the answer by\r\ntheir difference divided by the denominator.To calculate the first value\r\nwe will use the data structure that can get the sum of numbers on the\r\nprefix and modify the value at the single position (e.g. Fenwick tree).\r\nFor the position we need to know how many numbers are less than , and\r\nevery number should be taken times, where is number of segments where it\r\nis contained. Suppose we have calculated answers for some suffix and are\r\nnow standing at the position . For every position to the left it will be\r\nadded times (the number of positions as the candidates for the right\r\nbound, in 1-indexation). Perform fenwick add(a[i], n - i + 1).\r\n"
}