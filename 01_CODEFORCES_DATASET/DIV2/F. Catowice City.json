{
    "link": "https://codeforces.com//contest/1248/problem/F",
    "problemId": "445268",
    "problem_idx": "F",
    "shortId": "1248F",
    "contest_number": "1248",
    "problem_submissions": {
        "D1": [
            62994883,
            62993569,
            62992994,
            62997000,
            62994405,
            62997123,
            62999879,
            62995062,
            63003271,
            63000150,
            62999671,
            62994350,
            62998586,
            63000530,
            62992886,
            63075982,
            63072868,
            62991824,
            63006771
        ],
        "F": [
            62993845,
            62998618,
            63004376,
            63001516,
            63005145,
            63007254,
            63006725,
            63065814,
            63007421,
            63002656,
            63007898,
            63005627,
            63007696,
            63008967,
            63006462,
            63004460,
            63011504,
            63004125,
            63006964
        ],
        "E": [
            62985708,
            63073739,
            63003347,
            63018519,
            63004851
        ],
        "B": [
            62982231,
            62980110,
            62981055,
            62979292,
            62979961,
            62980992,
            62979799,
            62981220,
            62982692,
            62978096,
            62982064,
            62982362,
            62978497,
            62981072,
            62981976,
            62984594,
            63075956,
            62980955,
            62980611,
            62983563,
            62990769
        ],
        "A": [
            62979317,
            62977969,
            62978225,
            62977588,
            62977692,
            62977600,
            62977679,
            62978301,
            62980908,
            62977684,
            62981014,
            62982770,
            62977469,
            62977721,
            62977859,
            62979794,
            63075933,
            62977868,
            62980509,
            62980376,
            62988720
        ],
        "C": [
            62977501,
            62984679,
            62987113,
            62992373,
            62990888,
            62990326,
            62991798,
            62987434,
            62987346,
            62987305,
            62995225,
            62994509,
            63000614,
            62991483,
            62996125,
            63009114,
            62993964,
            62985766,
            62994340,
            62987126
        ],
        "D2": [
            63072452,
            63005552
        ]
    },
    "name": "F. Catowice City",
    "statement": "In the Catowice city next weekend the cat contest will be held. However,\r\nthe jury members and the contestants haven’t been selected yet. There\r\nare n residents and n cats in the Catowice, and each resident has\r\nexactly one cat living in his house. The residents and cats are numbered\r\nwith integers from 1 to n, where the i-th cat is living in the house of\r\ni-th resident.Each Catowice resident is in friendship with several cats,\r\nincluding the one living in his house. In order to conduct a contest, at\r\nleast one jury member is needed and at least one cat contestant is\r\nneeded. Of course, every jury member should know none of the\r\ncontestants. For the contest to be successful, it’s also needed that the\r\nnumber of jury members plus the number of contestants is equal to\r\nn.Please help Catowice residents to select the jury and the contestants\r\nfor the upcoming competition, or determine that it’s impossible to do.\r\n",
    "solutions": [
        "// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC optimize(\"Ofast,no-stack-protector\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define debug(x) std::cerr << (#x) << \":\\t\" << (x) << std::endl;\n#define fastIO std::ios_base::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nstd::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst double PI = atan2(0., -1.);\nconst int INF = 0x3f3f3f3f;\nconst int N = 1000100;\n\nstd::vector<int> g[N], gr[N];\nbool used[N];\nint cmp[N];\nstd::vector<int> cmps[N];\nstd::vector<int> order;\nint curCmp = 0;\nbool isBad[N];\n\nvoid topSort(int v) {\n\tused[v] = true;\n\n\tfor (auto to : g[v]) {\n\t\tif (!used[to]) {\n\t\t\ttopSort(to);\n\t\t}\n\t}\n\n\torder.push_back(v);\n}\n\nvoid dfs(int v) {\n\tused[v] = true;\n\tcmp[v] = curCmp;\n\tcmps[curCmp].push_back(v);\n\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tg[i].clear();\n\t\tgr[i].clear();\n\t\tcmps[i].clear();\n\t\tused[i] = false;\n\t\tcmp[i] = 0;\n\t\tisBad[i] = false;\n\t}\n\n\tcurCmp = 0;\n\torder.clear();\n\n\twhile (m--) {\n\t\tint from, to;\n\t\tscanf(\"%d%d\", &from, &to);\n\n\t\tg[from - 1].push_back(to - 1);\n\t\tgr[to - 1].push_back(from - 1);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\ttopSort(i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tused[i] = false;\n\t}\n\n\tstd::reverse(order.begin(), order.end());\n\n\tfor (auto i : order) {\n\t\tif (!used[i]) {\n\t\t\tdfs(i);\n\t\t\t++curCmp;\n\t\t}\n\t}\n\n\tif (curCmp == 1) {\n\t\tprintf(\"No\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"Yes\\n\");\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (auto to : g[i]) {\n\t\t\tif (cmp[to] != cmp[i]) {\n\t\t\t\tisBad[cmp[i]] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = -1;\n\tfor (int i = 0; i < curCmp; ++i) {\n\t\tif (isBad[i]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tused[j] = false;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", (int)cmps[i].size(), n - (int)cmps[i].size());\n\n\t\tfor (auto i : cmps[i]) {\n\t\t\tprintf(\"%d \", i + 1);\n\t\t\tused[i] = true;\n\t\t}\n\t\tprintf(\"\\n\");\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tprintf(\"%d \", i + 1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\n\t\treturn;\n\t}\n}\n\nint main(void) {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Catowice City.json",
    "editorial_link": "https://codeforces.com//blog/entry/70720",
    "editorial": "You are given bipartite graph and a perfect matching in it. You have to find independent set of size n\n which doesn't coincide with either of two parts.\n\nSuppose such independent set exists, let's call it S\n. Also, let's call left part of graph as L\n and right part of graph as R\n. Then define A=S?L\n, B=L?A\n, A?\n is set of all nodes which are connected by edges from matching with A\n, B?\n  similarly for B\n. It's easy to see that S=A?B?\n.\n\n\nLet's direct all edges in graph. Edges from matching will be directed from right to left, and all other edges will be directed from left to right. Now edges from matching will direct from A?\n to A\n and from B?\n to B\n. Other edges could direct from A\n to A?\n, from B\n to B?\n and from B\n to A?\n. Observe that edges cannot direct from A\n to B?\n, cause it wouldn't be an independent set otherwise.\n\n\nIt's easy to see that B?\n isn't reachable from A\n. So, let's find all strongly connected components (SCC) in this graph. If there's only one such component, answer doesn't exist due to the fact that any node of B?\n isn't reachable from any node of A\n. If SCC is only one, any node is reachable from any other node therefore in this case either A\n or B?\n are empty. If there are at least two SCC, let's choose any source SCC and call it Q\n. Consider B?=Q?R\n and define A\n as set of all nodes in left part which are not connected by edges from matching with B?\n. Let's proof that if some l?L\n lies in B?\n, then r\n  pair of l\n in matching also lies in B?\n. That's obvious since there are no incoming edges in B?\n and there's edge from r\n to l\n. So, none of nodes from A\n will lay in chosen SCC. Thus B?\n won't be reachable from A\n and A?B?\n will be an independent set.\n\nThe only exception is n=1\n, in such case there are two SCC but answer doesn't exist (cause chosen A\n will be empty).",
    "hint": []
}