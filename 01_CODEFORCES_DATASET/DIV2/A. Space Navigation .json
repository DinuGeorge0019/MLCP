{
    "link": "https://codeforces.com//contest/1481/problem/A",
    "problemId": "888831",
    "problem_idx": "A",
    "shortId": "1481A",
    "contest_number": "1481",
    "problem_submissions": {
        "E": [
            106575657,
            106580122,
            106571072,
            106587922,
            106596561,
            106601300,
            106598150,
            106588203,
            106555230,
            106601691,
            106603323,
            106598805,
            106606116,
            106598692,
            106597406,
            106601560,
            106559099,
            106600288,
            106602866
        ],
        "D": [
            106568002,
            106573123,
            106565784,
            106576955,
            106573210,
            106578133,
            106576417,
            106596842,
            106581404,
            106583159,
            106580270,
            106581784,
            106581178,
            106589786,
            106588485,
            106598470,
            106585012,
            106578937,
            106593218
        ],
        "C": [
            106554240,
            106561563,
            106587826,
            106564449,
            106557128,
            106554455,
            106561081,
            106556949,
            106593975,
            106567836,
            106563207,
            106566579,
            106560187,
            106560571,
            106563380,
            106553575,
            106571925,
            106575164,
            106574000
        ],
        "B": [
            106545453,
            106545635,
            106575045,
            106557114,
            106546143,
            106544431,
            106547512,
            106547628,
            106600777,
            106555535,
            106546768,
            106552994,
            106545917,
            106549686,
            106553008,
            106544154,
            106594934,
            106546830,
            106553782
        ],
        "A": [
            106540084,
            106539696,
            106539972,
            106539768,
            106541130,
            106540757,
            106539872,
            106540973,
            106602935,
            106540095,
            106541018,
            106540813,
            106540248,
            106541459,
            106539556,
            106539597,
            106547797,
            106540934,
            106542940
        ],
        "F": [
            106632220,
            111955794,
            218518749,
            218505572
        ]
    },
    "name": "A. Space Navigation ",
    "statement": "You were dreaming that you are traveling to a planet named Planetforces\r\non your personal spaceship. Unfortunately, its piloting system was\r\ncorrupted and now you need to fix it in order to reach Planetforces.\r\nSpace can be represented as the XY plane. You are starting at point (0,\r\n0), and Planetforces is located in point (p_x, p_y).The piloting system\r\nof your spaceship follows its list of orders which can be represented as\r\na string s. The system reads s from left to right. Suppose you are at\r\npoint (x, y) and current order is s_i: if s_i =\r\ntext{U}, you move to (x, y + 1); if s_i =\r\ntext{D}, you move to (x, y - 1); if s_i =\r\ntext{R}, you move to (x + 1, y); if s_i =\r\ntext{L}, you move to (x - 1, y). Since string s could be corrupted,\r\nthere is a possibility that you won\u2019t reach Planetforces in the end.\r\nFortunately, .Can you delete several orders (possibly, zero) from s in\r\nsuch a way, that you\u2019ll reach Planetforces after the system processes\r\nall orders?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nmain(){\n    int t;\n    cin >> t;\n    while(t--){\n        int x, y;\n        string s;\n        cin >>x>>y>>s;\n        int l=0,r=0,d=0,u=0;\n        for(char i : s){\n            if(i=='L') l++;\n            if(i=='R') r++;\n            if(i =='U') u++;\n            if(i == 'D') d++;\n        }\n        if(x < 0) x = -x, swap(l,r);\n        if(y < 0) y = -y, swap(d,u);\n        if(r >= x && u >= y) cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Space Navigation .json",
    "editorial_link": "https://codeforces.com//blog/entry/87523",
    "editorial": "Hint 1: You can think of this problem as 2 independent 1D questions (one\r\nis up and down , and the other is left and right) instead of 1 2D\r\nquestion.Hint 2: For each 1D part what is the interval of positions that\r\nyou can reach and see if the end point is in this interval.Hint 3: The\r\ninterval of up and down is [-The count of D , The count of U] and the\r\ninterval of left and right is [-The count of L , The count of R].\r\n"
}