{
    "link": "https://codeforces.com//contest/959/problem/E",
    "problemId": "170882",
    "problem_idx": "E",
    "shortId": "959E",
    "contest_number": "959",
    "problem_submissions": {
        "F": [
            36922958,
            36921545,
            36916491,
            36923329,
            36927067,
            36929072,
            36922529,
            36949027,
            36923867
        ],
        "D": [
            36916641,
            36918902,
            36913950,
            36921936,
            36920649,
            36922086,
            36938795,
            36921202,
            36919547,
            36921230,
            36920592,
            36944605,
            36921671,
            36921791,
            36916069,
            36920555,
            36925905,
            36924207,
            36923247
        ],
        "E": [
            36914501,
            36913015,
            36925858,
            36917118,
            36923111,
            36917652,
            36920424,
            36917502,
            36915031,
            36915660,
            36915376,
            36919671,
            36917632,
            36917697,
            36920779,
            36924711,
            36918716,
            36918302,
            36918515
        ],
        "C": [
            36911904,
            36911030,
            36920972,
            36913089,
            36913595,
            36913140,
            36914345,
            36913057,
            36911886,
            36913682,
            36913398,
            36917432,
            36913393,
            36914727,
            36913492,
            36914481,
            36914594,
            36913357,
            36914333
        ],
        "B": [
            36910571,
            36909536,
            36910083,
            36911621,
            36910450,
            36910777,
            36911891,
            36911461,
            36909624,
            36911118,
            36910588,
            36915553,
            36910516,
            36911975,
            36910706,
            36910209,
            36911346,
            36910873,
            36911805
        ],
        "A": [
            36909207,
            36907273,
            36907351,
            36907609,
            36907481,
            36907506,
            36907642,
            36908528,
            36907595,
            36907279,
            36907604,
            36911260,
            36907582,
            36908413,
            36907465,
            36907398,
            36907769,
            36907688,
            36907674
        ]
    },
    "name": "E. Mahmoud and Ehab and the xor-MST",
    "statement": "Ehab is interested in the bitwise-xor operation and the special graphs.\r\nMahmoud gave him a problem that combines both. He has a complete graph\r\nconsisting of vertices numbered from to . For all , vertex and vertex\r\nare connected with an undirected edge that has weight (where is the\r\nbitwise-xor operation). Can you find the weight of the minimum spanning\r\ntree of that graph?You can read about complete graphs in\r\nhttps://en.wikipedia.org/wiki/Complete_graphYou can read about the\r\nminimum spanning tree in\r\nhttps://en.wikipedia.org/wiki/Minimum_spanning_treeThe weight of the\r\nminimum spanning tree is the sum of the weights on the edges included in\r\nit.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nll solve(ll n){\n\tif (n == 1) return 0ll;\n\tll ret = 0;\n\tint x = 0;\n\twhile ((1ll<<x) <= n) x++;\n\tx--;\n\n\tfor (int i = 0; i < x; i++){\n\t\tret = ret * 2;\n\t\tret += 1ll<<i;\n\t}\n\tif ((1ll<<x) == n) return ret;\n\tret += solve(n - (1ll<<x));\n\tret += 1ll<<x;\n\treturn ret;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll n; cin >> n;\n\tcout << solve(n) << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "graphs",
        "implementation",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Mahmoud and Ehab and the xor-MST.json",
    "editorial_link": "https://codeforces.com//blog/entry/58712",
    "editorial": "For convenience, let be the label of the last node not the number of\r\nnodes (i.e ). Denote as the value of the least significant bit set to 1\r\nin . The answer is , which means that node is connected to node for all\r\n(node is connected to node without that bit). Formal proofLetâs take a\r\nlook at a version of Boruvkaâs algorithm for the MST. It starts with an\r\nempty MST and then at each step, it chooses some components. For each of\r\nthem, it finds the edge with the minimum cost connecting this component\r\nto any other component and adds this edge to the minimum spanning tree.\r\nLetâs apply this algorithm here. Assume that at step , the components\r\nare of the form of intervals of length i.e component has nodes in .\r\nLetâs see what the algorithm does. Letâs see what happens for components\r\nwhere is odd. Assume the minimum cost for connecting this component is .\r\nYou can see that canât be less than . Thatâs because this intervals\r\ncontains integers that have all the possible combinations of the first\r\nbits. Take and , for example: the numbers are (in binary) , , , . All\r\nthe possible combinations for the first bits are there! Notice that if\r\nyou choose , youâre changing the first bits. We have all possible\r\ncombinations of them in the component so weâll make a cycle. That makes\r\nthe minimum cost . Thereâs always a way to make a connection with cost\r\nwhich is connecting the first node of this component with the first node\r\nof the previous component (i.e connect node with node ). Notice that\r\nbecause is odd (Can you see why this is false for even ?). After that\r\nhappens, the 2 components will form one big component and the components\r\nwill be in the form of intervals of length and the algorithm will repeat\r\nthe same pattern!! Notice that at the beginning, the nodes are of the\r\nform of intervals with length 1 so the algorithm will work like that\r\nuntil the MST is constructed. Each node is the first node of its\r\ncomponent and its component will have an odd index exactly once because\r\nafter that itâll be in the middle of another big component. When that\r\nhappens, itâll be when . Therefore, node adds to the answer!\r\n",
    "hint": []
}