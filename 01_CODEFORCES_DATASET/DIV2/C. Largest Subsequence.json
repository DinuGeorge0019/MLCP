{
    "link": "https://codeforces.com//contest/1905/problem/C",
    "problemId": "2384302",
    "problem_idx": "C",
    "shortId": "1905C",
    "contest_number": "1905",
    "problem_submissions": {
        "F": [
            237519503,
            237518706,
            237482920,
            237522705,
            237524131,
            237602806,
            237553489,
            237539816,
            237539559,
            237531355,
            238226356,
            238226333
        ],
        "E": [
            237505954,
            237497832,
            237495453,
            237512642,
            237513385,
            237508924,
            237511733,
            237515516,
            237508774,
            237502235,
            237513715,
            237519547,
            237522468,
            237711000,
            237515591,
            237507153,
            237518502,
            237520768,
            237516891,
            237516610
        ],
        "D": [
            237492749,
            237504330,
            237509326,
            237501351,
            237508164,
            237500145,
            237500325,
            237496593,
            237501654,
            237512862,
            237494885,
            237497599,
            237495760,
            237710975,
            237503073,
            237516000,
            237505850,
            237496346,
            237504183,
            237504223
        ],
        "C": [
            237484859,
            237486387,
            237514010,
            237484118,
            237485834,
            237477056,
            237481640,
            237480170,
            237483989,
            237484101,
            237482806,
            237484400,
            237487254,
            237710962,
            237490113,
            237487402,
            237483252,
            237485864,
            237495090,
            237491635
        ],
        "B": [
            237476673,
            237478416,
            237514764,
            237473227,
            237475996,
            237480677,
            237471243,
            237471572,
            237474579,
            237471819,
            237473855,
            237474076,
            237478005,
            237710941,
            237481035,
            237481302,
            237473092,
            237475685,
            237477792,
            237477297
        ],
        "A": [
            237470661,
            237474004,
            237515478,
            237470037,
            237470853,
            237487781,
            237469382,
            237469477,
            237471099,
            237469459,
            237470679,
            237470317,
            237471411,
            237710923,
            237474857,
            237474763,
            237469530,
            237469890,
            237472488,
            237474669
        ]
    },
    "name": "C. Largest Subsequence",
    "statement": "Given is a string s of length n. In one operation you can select the\r\nlexicographically largest^\r\ndagger subsequence of string s and cyclic shift it to the right^\r\nddagger. Your task is to calculate the minimum number of operations it\r\nwould take for s to become sorted, or report that it never reaches a\r\nsorted state.^\r\ndaggerA string a is lexicographically smaller than a string b if and\r\nonly if one of the following holds: a is a prefix of b, but a\r\nne b; In the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b.^\r\nddaggerBy cyclic shifting the string t_1t_2\r\nldots t_m to the right, we get the string t_mt_1\r\nldots t_{m-1}.\r\n",
    "solutions": [
        "// Problem: C. Largest Subsequence\n// Contest: Codeforces Round 915 (Div. 2)\n// URL: https://codeforces.com/contest/1905/problem/C\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n// #pragma GCC optimize(\"Ofast,inline,unroll-loops\")\n// #define _GLIBCXX_DEBUG //\u4ea4\u9898\u524d\u8bb0\u5f97\u6ce8\u91ca\u6389\u4e0d\u7136\u5bb9\u6613T\u3002\n#include<bits/stdc++.h>\n#define File(s) freopen(#s\".in\",\"r\",stdin),freopen(#s\".out\",\"w\",stdout)\n#ifdef GTRAKIOI\n#define defrog(...) fprintf(stderr,__VA_ARGS__)\n#define deb(x) (std::cerr<<#x<<\"@\"<<__LINE__<<\"=\"<<(x)<<'\\n')\n#else\n#define defrog(...) 1\n#define deb(x) 1\n#endif\n#define defrogf(...) defrog(__VA_ARGS__)\n#if __cplusplus>=201703L\n#define rg\n#else\n#define rg register\n#endif\n#define ri rg int\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int>pii;\ntypedef std::vector<int>vi;\ntypedef std::vector<ll>vll;\ntypedef std::vector<pii>vpii;\ntypedef std::vector<vi >vvi;\ntypedef long double ld;\ntypedef __int128 i128;\ntypedef __uint128_t u128;\n#define Tp template<typename T>\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define all(cont) cont.begin(),cont.end()\n\nchar ibuf[1<<15],*p1,*p2;\n#define getchar() (p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,1<<15,stdin),p1==p2)?EOF:*p1++)\nstruct FastIO{\n\t/*inline void ou128(u128 x){\n\t\tu128 y=1;\n\t\twhile(y<=x/10)y*=10;\n\t\tdo putchar(x/y|48),x%=y,y/=10;while(y);\n\t}*/\n\tinline int rint(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c=='-';ri unsigned a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n\tinline ll rll(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c=='-';rg ull a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n//\tinline operator int(){return rint();}\n\tinline operator ll(){return rll();}\n\tinline char rchar(){rg char c;while(!isgraph(c=getchar()));return c;}\n\tinline int rstr(char*s){rg char c;while(!isgraph(c=getchar()));int cnt=-1;do s[++cnt]=c;while(isgraph(c=getchar()));s[++cnt]=0;return cnt;}\n}g90;\n\ntemplate<typename T=int>std::vector<T>rvec(std::size_t n,std::size_t start=0) {\n\tstd::vector<T>res(start+n);\n\tfor(std::size_t i=start;i<start+n;++i)res[i]=g90;\n\treturn res;\n}\n\nstd::mt19937 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int rnd(const int&a,const int&b){\n\treturn std::uniform_int_distribution<int>(a,b)(rng);\n}\ninline ld rnd(const ld&a,const ld&b){\n\treturn std::uniform_real_distribution<ld>(a,b)(rng);\n}\nnamespace MY_STD{\n\tTp inline T abs(const T&a){return a<0?-a:a;}\n}\n\nstruct DSU{//unweighted\n\tusing key_type=int;\n\n\tstd::vector<key_type>fa,size;\n\tinline DSU(key_type n):fa(n),size(n,1){std::iota(fa.begin(),fa.end(),0);}\n\tinline key_type& getFa(key_type x){\n\t\twhile(x^fa[x])x=fa[x]=fa[fa[x]];\n\t\treturn fa[x];\n\t}\n\tinline key_type& operator[](const key_type&x){return getFa(x);}\n\tinline auto canMerge(const key_type&u,const key_type&v){return getFa(u)!=getFa(v);}\n\tinline bool merge(key_type u,key_type v){\n\t\tu=getFa(u),v=getFa(v);\n\t\treturn (u)!=(v)&&(size[u]<size[v]&&(std::swap(u,v),1),fa[v]=u,size[u]+=size[v],size[v]=0,true);\n\t}\n\n};\n\nconstexpr int N=-2023,M=1000000007;\ninline int qpow(ll a,ll b){ri res=1;for(;b;a=a*a%M,b>>=1)if(b&1)res=res*a%M;return res;}\n// #define pow qpow\n\nsigned main(){\n\t//std::ios::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);\n\tint T=1;\n\tT=g90;\n\tfor(;T--;)[&]{\n\t\tint n=g90;\n\t\tstatic char s[200200];\n\t\tg90.rstr(s);\n\t\tvi st;\n\t\tfor(int i=0;i<n;++i){\n\t\t\twhile(!st.empty()&&s[st.back()]<s[i])st.pop_back();\n\t\t\tst.eb(i);\n\t\t}\n\t\tvi tmp;\n\t\tfor(auto&&i:st)tmp.eb(s[i]);\n\t\tstd::sort(all(tmp));\n\t\tfor(int i=0;i<int(st.size());++i)s[st[i]]=tmp[i];\n\t\tif(std::is_sorted(s,s+n)){\n\t\t\tauto x=tmp.back();\n\t\t\twhile(!tmp.empty()&&tmp.back()==x)tmp.pop_back();\n\t\t\tprintf(\"%zu\\n\",tmp.size());\n\t\t}else puts(\"-1\");\n\t}();\n}//main()"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Largest Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/123384",
    "editorial": "SolutionWe can notice that this operation will ultimately reverse the\r\nlexicographically largest subset of the initial string. Thus, we can\r\neasily check if the string is sortable, and for finding the number of\r\noperations we will subtract the length of the largest prefix of equal\r\nvalues of the subset from its length.This solution works in time.\r\n"
}