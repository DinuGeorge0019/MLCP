{"link": "https://codeforces.com//contest/902/problem/D", "problemId": "139720", "problem_idx": "D", "shortId": "902D", "contest_number": "902", "problem_submissions": {"E": [33432769, 33432692, 33431724, 33432880, 33433143, 33425800, 33479713, 33434507], "C": [33418857, 33421216, 33418092, 33421721, 33425094, 33420634, 33423702, 33423018, 33420334, 33420303, 33419836, 33430662, 33420269, 33422420, 33422328, 33423548, 33420458, 33425360], "B": [33414393, 33416891, 33413564, 33416982, 33418778, 33415144, 33420150, 33416950, 33420947, 33415271, 33415194, 33431642, 33414521, 33417866, 33416627, 33417427, 33416186, 33419760], "A": [33412979, 33413298, 33412683, 33414789, 33412988, 33412835, 33415972, 33412736, 33422119, 33413143, 33413263, 33432089, 33412738, 33412994, 33413252, 33413078, 33413621, 33413563], "D": [33425081, 33422286, 33426122, 33429053, 33429776, 33430153, 33430663, 33428168, 33429601, 33428402, 33429733]}, "name": "D. GCD of Polynomials", "statement": "Suppose you have two polynomials and . Then polynomial can be uniquely\r\nrepresented in the following way:This can be done using long division.\r\nHere, denotes the degree of polynomial . is called the remainder of\r\ndivision of polynomial by polynomial , it is also denoted as . Since\r\nthere is a way to divide polynomials with remainder, we can define\r\nEuclid\u2019s algorithm of finding the greatest common divisor of two\r\npolynomials. The algorithm takes two polynomials . If the polynomial is\r\nzero, the result is , otherwise the result is the value the algorithm\r\nreturns for pair . On each step the degree of the second argument\r\ndecreases, so the algorithm works in finite number of steps. But how\r\nlarge that number could be? You are to answer this question. You are\r\ngiven an integer . You have to build two polynomials with degrees not\r\ngreater than , such that their coefficients are integers not exceeding\r\nby their absolute value, the leading coefficients (ones with the\r\ngreatest power of ) are equal to one, and the described Euclid\u2019s\r\nalgorithm performs exactly steps finding their greatest common divisor.\r\nMoreover, the degree of the first polynomial should be greater than the\r\ndegree of the second. By a step of the algorithm we mean the transition\r\nfrom pair to pair .\r\n", "solutions": ["/* You lost the game. */\n \n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <numeric>\n#include <cassert>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <vector>\n//#include <pthread.h>\n \n#define fin(i,n) for (int i = 0; i < n; i++)\n#define fin2(i,a,b) for (int i = a; i < b; i++)\n#define ford(i,n) for (int i = n-1; i >= 0; i--)\n#define ford2(i,a,b) for (int i = b-1; i >= a; i--)\n \n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define mod 1000000007\n#define PI 3.1415926535897932384626\n#define EXP1 2.718281828459045\n \n#define si(n) scanf(\"%d\", &n)\n#define sii(n,m) scanf(\"%d %d\", &n, &m)\n#define siii(n,m,k) scanf(\"%d %d %d\", &n, &m, &k)\n#define sl(n) scanf(\"%lld\", &n)\n#define sll(n,m) scanf(\"%lld %lld\", &n, &m)\n#define slll(n,m,k) scanf(\"%lld %lld %lld\", &n, &m, &k)\n#define sd(n) scanf(\"%lf\", &n)\n#define sdd(n,m) scanf(\"%lf %lf\", &n, &m)\n#define sddd(n,m,k) scanf(\"%lf %lf %lf\", &n, &m, &k)\n#define sc(c) scanf(\"%c\", &c)\n#define ss(s) scanf(\"%s\", s)\n#define sai(t,n) fin(i,n) { scanf(\"%d\", &t[i]); }\n#define sal(t,n) fin(i,n) { scanf(\"%lld\", &t[i]); }\n#define sad(t,n) fin(i,n) { scanf(\"%lf\", &t[i]); }\n \n#define pc(n) printf(\"%c\\n\", n)\n#define ps(s) printf(\"%s\\n\", s)\n#define pi(n) printf(\"%d\\n\", n)\n#define pii(n,m) printf(\"%d %d\\n\", n, m)\n#define pl(n) printf(\"%lld\\n\", n)\n#define pll(n,m) printf(\"%lld %lld\\n\", n, m)\n#define plll(n,m,k) printf(\"%lld %lld %lld\\n\", n, m, k)\n#define pd(n) printf(\"%lf\\n\", n)\n#define pdd(n,m) printf(\"%lf %lf\\n\", n, m)\n#define pai(t,n) fin(i,n) { printf(\"%d \", t[i]); } printf(\"\\n\")\n#define pal(t,n) fin(i,n) { printf(\"%lld \", t[i]); } printf(\"\\n\")\n#define pad(t,n) fin(i,n) { printf(\"%lf \", t[i]); } printf(\"\\n\")\n\n#define OK ps(\"OK\")\n#define OK1 ps(\"OK1\")\n#define OK2 ps(\"OK2\")\n \n#define L long long int\n#define D double\n#define PII pair<int, int>\n#define VPII vector<PII>\n#define VL vector<L>\n#define VI vector<int>\n#define VVI vector<VI>\n#define VD vector<D>\n#define VVD vector<VD>\n#define VVPII vector<VPII>\n#define VC vector<char>\n \nusing namespace std;\n\nint main() {\n    int n;\n    si(n);\n    VI p1, p2;\n    fin(i, n+1) { p1.pb(0); p2.pb(0); }\n    p1[0] = 1;\n    p2[1] = 1;\n    fin2(i, 1, n) {\n        VI p3 = p2, p4 = p2;\n        ford(i, n) {\n            p3[i+1] = p3[i];\n            p4[i+1] = p4[i];\n        }\n        p3[0] = 0;\n        p4[0] = 0;\n        int ok3 = 1, ok4 = 1;\n        fin(i, n+1) {\n            p3[i] += p1[i];\n            if (abs(p3[i]) > 1) { ok3 = 0; }\n            p4[i] -= p1[i];\n            if (abs(p4[i]) > 1) { ok4 = 0; }\n        }\n        p1 = p2;\n        if (ok3 == 1) { p2 = p3; }\n        else if (ok4 == 1) { p2 = p4; }\n        else { ok3 = ok4 / ok3; };\n    }\n    pi(n);\n    pai(p2, n+1);\n    pi(n-1);\n    pai(p1, n);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["math"], "dificulty": "2200", "interactive": false}