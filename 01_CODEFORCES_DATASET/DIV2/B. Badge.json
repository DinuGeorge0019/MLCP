{
    "link": "https://codeforces.com//contest/1020/problem/B",
    "problemId": "207009",
    "problem_idx": "B",
    "shortId": "1020B",
    "contest_number": "1020",
    "problem_submissions": {
        "D": [
            41489189,
            41489089,
            41486423,
            41490197,
            41489917,
            41487075,
            41490349,
            41489723,
            41491006,
            41484021,
            41492712,
            41493543,
            41493068,
            41492267,
            41492744,
            41493565,
            41533654,
            41492210,
            41493418,
            41496467
        ],
        "C": [
            41482847,
            41481559,
            41490429,
            41483828,
            41484432,
            41483284,
            41481342,
            41482980,
            41482276,
            41494412,
            41483383,
            41483904,
            41482436,
            41484813,
            41483954,
            41484715,
            41485204,
            41486868,
            41484572
        ],
        "B": [
            41472124,
            41472495,
            41472169,
            41471832,
            41473647,
            41472819,
            41474467,
            41474217,
            41476517,
            41474465,
            41477984,
            41542441,
            41472876,
            41475507,
            41474290,
            41474434,
            41473754,
            41480874,
            41476912,
            41474412
        ],
        "A": [
            41471287,
            41471470,
            41471174,
            41471276,
            41471647,
            41482521,
            41482998,
            41483546,
            41473507,
            41472376,
            41472014,
            41542424,
            41471633,
            41471835,
            41472031,
            41471489,
            41471801,
            41474026,
            41472191,
            41471736
        ],
        "E": [
            41565578
        ]
    },
    "name": "B. Badge",
    "statement": "In Summer Informatics School, if a student doesn\u2019t behave well, teachers\r\nmake a hole in his badge. And today one of the teachers caught a group\r\nof n students doing yet another trick. Let\u2019s assume that all these\r\nstudents are numbered from 1 to n. The teacher came to student a and put\r\na hole in his badge. The student, however, claimed that the main culprit\r\nis some other student p_a.After that, the teacher came to student p_a\r\nand made a hole in his badge as well. The student in reply said that the\r\nmain culprit was student p_{p_a}.This process went on for a while, but,\r\nsince the number of students was finite, eventually the teacher came to\r\nthe student, who already had a hole in his badge.After that, the teacher\r\nput a second hole in the student\u2019s badge and decided that he is done\r\nwith this process, and went to the sauna.You don\u2019t know the first\r\nstudent who was caught by the teacher. However, you know all the numbers\r\np_i. Your task is to find out for every student a, who would be the\r\nstudent with two holes in the badge if the first caught student was a.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define sz(x) ((int)x.size())\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint n, a[1010];\nbool chk[1010];\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\", a+i);\n\tfor(int i=1; i<=n; i++) {\n\t\tmemset(chk,0,sizeof(chk));\n\t\tint j = i;\n\t\twhile(!chk[j]) {\n\t\t\tchk[j] = 1;\n\t\t\tj = a[j];\n\t\t}\n\t\tprintf(\"%d \", j);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Badge.json",
    "editorial_link": "https://codeforces.com//blog/entry/61161",
    "editorial": "In this problem you are given a graph, with one outgoing edge from each\r\nvertex. You are asked which vertex is first to be visited twice, if you\r\nstart in some vertex, and go by outgoing edge from current vertex until\r\nyou visited some vertex twice.The problem can be solved by\r\nstraightforward implementation. You choose a starting vertex (which\r\nstudent is first to get a hole in their badge), and keep the current\r\nvertex, and for all vertices how many times it was visited. After\r\ntransition to the next vertex you just check if it has been already\r\nvisited, and update visited mark for it.This solution works in , and is\r\nvery easy in implementation. It can be optimized to , but it was not\r\nnecessary in this problem. It an easy and useful exercise left to\r\nreader.\r\n"
}