{"link": "https://codeforces.com//contest/588/problem/E", "problemId": "38256", "problem_idx": "E", "shortId": "588E", "contest_number": "588", "problem_submissions": {"E": [13645041, 13647234, 13646603, 13641082, 13648737, 13639739, 13645096, 13640996, 119991814, 13641078, 13641596, 13650376, 13644075, 13642626, 13643766, 13646050, 13642477, 13643960, 13644746], "D": [13639351, 13639649, 13643732, 13649370, 13642827, 13649049, 13637022, 13702546, 14030283, 13639966], "C": [13630106, 13631147, 13633040, 13630591, 13632505, 13631594, 13636634, 13630220, 13633364, 13635760, 13658418, 13630672, 13632240, 13630150, 13652664, 13632626, 13633303, 13634794, 13632441], "B": [13629094, 13628701, 13630705, 13628132, 13630053, 13630134, 13630520, 13628440, 13629087, 13629241, 13629690, 13629617, 13633004, 13629324, 13629595, 13629544, 13629480, 13630408], "A": [13627091, 13627133, 13628904, 13626934, 13626996, 13628463, 13629317, 13626624, 13627086, 13627884, 13627524, 13627373, 13632434, 13626712, 13627173, 13626674, 13627275, 13627838]}, "name": "E. Duff in the Army", "statement": "Recently Duff has been a soldier in the army. Malek is her\r\ncommander.Their country, Andarz Gu has cities (numbered from to ) and\r\nbidirectional roads. Each road connects two different cities. There\r\nexist a unique path between any two cities.There are also people living\r\nin Andarz Gu (numbered from to ). Each person has and ID number. ID\r\nnumber of person is and he/she lives in city number . Note that there\r\nmay be more than one person in a city, also there may be no people\r\nliving in the city. Malek loves to order. That\u2019s why he asks Duff to\r\nanswer to queries. In each query, he gives her numbers and .To answer a\r\nquery:Assume there are people living in the cities lying on the path\r\nfrom city to city . Assume these people\u2019s IDs are in increasing order.\r\nIf , then Duff should tell Malek numbers in this order. In the other\r\nwords, Malek wants to know minimums on that path (or less, if there are\r\nless than people).Duff is very busy at the moment, so she asked you to\r\nhelp her and answer the queries.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fr(a,b,c) for(int (a) = (b); (a) < (c); ++(a))\n#define rp(a,b) fr(a,0,b)\n#define fre(a,b) for(int a = adj[b]; ~a; a = ant[a])\n#define cl(a,b) memset((a), (b), sizeof(a))\n#define sc(a) scanf(\"%d\", &a)\n#define sc2(a,b) scanf(\"%d%d\", &a, &b)\n#define sc3(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define scs(s) scanf(\"%s\", s)\n#define pri(x) printf(\"%d\\n\", x)\n\n#define iter(a) __typeof((a).begin())\n#define fore(a,b) for(iter(b) a = (b).begin(); a != (b).end(); ++a)\n\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n\n#define db(x) cerr << #x << \" == \" << x << endl\n#define _ << \", \" <<\n\nconst int inf = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector< vi > vii;\n\n#define N 100009\n\nstruct minset{\n\tint a[12], l;\n\tminset() { l = 0; }\n\tvoid add(int v) {\n\t\tif (l == 10) return;\n\t\trp(i, l) if (a[i] == v) return;\n\t\ta[l++] = v;\n\t}\n\tminset operator+(minset m) {\n\t\tint a2[22], l2 = l + m.l;\n\t\trp(i, l) a2[i] = a[i];\n\t\tfr(i, l, l2) a2[i] = m.a[i-l];\n\t\tsort(a2, a2+l2);\n\t\tl2 = unique(a2, a2+l2) - a2;\n\t\t\n\t\tminset novo;\n\t\trp(i, min(l2, 10)) novo.add(a2[i]);\n\t\treturn novo;\n\t}\n\tvoid print() {\n\t\trp(i, l) printf(\"%d\", a[i]);\n\t\tputs(\"\");\n\t}\n} arr[N];\n\nint n, q;\nint logg[N];\n\n//listas de arestas\nint an, adj[N], to[2*N], ant[2*N];\n//tamanho da sub\u00e1rvore, pai, altura do n\u00f3 e filho preferido\nint sz[N], pai[N], h[N], pref[N];\n//a qual cada n\u00f3 pertence e seu \u00edndice dentro dele\nint comp[N], ind[N];\n//qtd de caminhos, tamanho do caminho, chefe do caminho, sequ\u00eancia de elementos do caminho e BIT do caminho\nint qcomp, plen[N], head[N], pos[N], qp;\nminset M[N][20], sta[N];\n\nstack<int> pilha;\n\nvoid add(int x, int y) {\n\tto[an] = y; ant[an] = adj[x]; adj[x] = an++;\n\tswap(x, y);\n\tto[an] = y; ant[an] = adj[x]; adj[x] = an++;\n}\n\nvoid prep_st() {\n\t//db(0);\n\trp(i, n) {\n\t\tM[i][0] = sta[i];\n\t\t//M[i][0].print();\n\t}\n\tfor(int j = 1; (1 << j) <= n; j++) {\n\t\t//db(j);\n\t\trp(i, n+1 - (1 << j)) {\n\t\t\tM[i][j] = M[i][j - 1] + \n\t\t\t\tM[i + (1 << (j - 1))][j - 1];\n\t\t\t\n\t\t\t//M[i][j].print();\n\t\t}\n\t}\n}\n\nminset query(int cmp, int b, int e) {\n\tb += pos[cmp];\n\te += pos[cmp];\n    int l = logg[e-b];\n    minset ret = M[b][l] + M[e-(1<<l)][l];\n    \n\t//db(cmp _ b _ e _ l);\n\t//ret.print();\n    \n    return ret;\n}\n\nvoid dfs1(int v, int p, int hght) {\n\tpai[v] = p;\n\th[v] = hght;\n\tsz[v] = 1;\n\tpref[v] = -1;\n\tfre(i, v) if (to[i] != pai[v]) {\n\t\tdfs1(to[i], v, hght+1);\n\t\tsz[v] += sz[to[i]];\n\t\tif (pref[v] == -1 || sz[to[i]] > sz[pref[v]])\n\t\t\tpref[v] = to[i];\n\t}\n\t//if (pref[v] != -1 && sz[pref[v]]*2 <= sz[v])\n\t//\tpref[v] = -1;\n}\n\nvoid buildhl(int v, int p_ind) {\n\tcomp[v] = qcomp;\n\tind[v] = p_ind;\n\tpilha.push(v);\n\t\n\tif (p_ind == 0) head[qcomp] = v;\n\t\n\tif (pref[v] != -1) \n\t\tbuildhl(pref[v], p_ind+1);\n\telse {\n\t\tint len = plen[qcomp] = pilha.size();\n\t\tpos[qcomp] = qp;\n\t\trp(i, len) {\n\t\t\t//printf(\"%d \", pilha.top());\n\t\t\tsta[qp++] = arr[pilha.top()]; pilha.pop();\n\t\t}\n\t\t//puts(\"\");\n\t\treverse(sta + qp - len, sta + qp);\n\t\tqcomp++;\n\t}\n\tfre(i, v) \n\t\tif (to[i] != pai[v] && to[i] != pref[v])\n\t\t\tbuildhl(to[i], 0);\n}\n\nvoid build() {\n\tdfs1(0, -1, 0);\n\tqcomp = 0;\n\tqp = 0;\n\tpilha = stack<int>();\n\tbuildhl(0, 0);\n}\n\nint up(int v) {\n\treturn head[comp[v]] != v? head[comp[v]]: \n\t\tpai[v] != -1? pai[v]: v;\n}\n\nint lca(int a, int b) {\n\twhile (comp[a] != comp[b]) {\n\t\tif (pai[a] == -1 || \n\t\t\th[up(a)] < h[up(b)]) swap(a, b);\n\t\ta = up(a);\n\t}\n\treturn h[a] < h[b]? a: b;\n}\n\nminset querry(int a, int b) {\n\tminset ret;\n\tint cmp;\n\twhile (comp[a] != comp[b]) {\n\t\tcmp = comp[a];\n\t\tret = ret + query(cmp, 0, ind[a]+1);\n\t\ta = pai[head[cmp]];\n\t}\n\tcmp = comp[a];\n\treturn ret + query(cmp, ind[b], ind[a]+1);\n}\n\nminset qquery(int a, int b) {\n\tint c = lca(a, b);\n\treturn querry(a, c) + querry(b, c);\n}\n\nint main() {\n\tlogg[0] = -1;\n\tfr(i, 1, N-2) logg[i] = 1 + logg[i>>1];\n\t\n\tint m;\n\twhile (sc3(n, m, q) == 3) {\n\t\tan = 0;\n\t\tmemset(adj, -1, (n+1)*sizeof(int));\n\t\trp(i, n-1) {\n\t\t\tint x, y;\n\t\t\tsc2(x, y);\n\t\t\tadd(x-1, y-1);\n\t\t}\n\t\t\n\t\trp(i, n) arr[i] = minset();\n\t\t\n\t\trp(i, m) {\n\t\t\tint v; sc(v);\n\t\t\tarr[v-1].add(i+1);\n\t\t}\n\t\t\n\t\tbuild();\n\t\tprep_st();\n\t\t\n\t\trp(i, q) {\n\t\t\t//db(i);\n\t\t\tint a, b, c;\n\t\t\tsc3(a, b, c);\n\t\t\ta--; b--;\n\t\t\t\n\t\t\tminset ans = qquery(a, b);\n\t\t\tc = min(c, ans.l);\n\t\t\tprintf(\"%d\", c);\n\t\t\trp(i, c) printf(\" %d\", ans.a[i]);\n\t\t\tputs(\"\");\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "trees"], "dificulty": "2200", "interactive": false}