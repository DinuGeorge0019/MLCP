{
    "link": "https://codeforces.com//contest/1834/problem/E",
    "problemId": "1970550",
    "problem_idx": "E",
    "shortId": "1834E",
    "contest_number": "1834",
    "problem_submissions": {
        "F": [
            210053333,
            210055795,
            210061394,
            210063603,
            210067240,
            210074011,
            210067928,
            210074058,
            210075127,
            210077576,
            210081254,
            210080638,
            210077908,
            210081433,
            210081470,
            210075926,
            210079720,
            210073143,
            210080327,
            210079002
        ],
        "E": [
            210043231,
            210048962,
            210050705,
            210040023,
            210052461,
            210056199,
            210057535,
            210057973,
            210068092,
            210063785,
            210047635,
            210066422,
            210066208,
            210059930,
            210084962,
            210058056,
            210078624,
            210065540,
            210102659,
            210075510,
            210066583,
            210054659
        ],
        "D": [
            210041205,
            210041410,
            210047091,
            210046686,
            210055618,
            210044791,
            210050088,
            210048637,
            210051528,
            210053073,
            210042552,
            210055020,
            210056083,
            210067524,
            210071426,
            210050909,
            210057660,
            210061801,
            210060481,
            210064580
        ],
        "C": [
            210036361,
            210039180,
            210042203,
            210051207,
            210041802,
            210040948,
            210044017,
            210043949,
            210040181,
            210047738,
            210064568,
            210043833,
            210041545,
            210044468,
            210046528,
            210040515,
            210054425,
            210046290,
            210037195,
            210068118
        ],
        "B": [
            210033459,
            210035736,
            210037921,
            210055396,
            210039182,
            210035904,
            210039397,
            210039555,
            210036625,
            210043087,
            210062502,
            210039428,
            210036497,
            210051272,
            210040630,
            210036404,
            210051486,
            210058486,
            210055398,
            210069509
        ],
        "A": [
            210032106,
            210032895,
            210032201,
            210033870,
            210032108,
            210032116,
            210033115,
            210033564,
            210032243,
            210032564,
            210032148,
            210033019,
            210032192,
            210033118,
            210032467,
            210032459,
            210045546,
            210036091,
            210032276,
            210070208
        ]
    },
    "name": "E. MEX of LCM",
    "statement": "You are given an array a of length n. A integer x is called if it is to\r\nfind a subsegment^{\r\ndagger} of the array such that the least common multiple of all its\r\nelements is equal to x.You need to find the smallest good integer.A\r\nsubsegment^{\r\ndagger} of the array a is a set of elements a_l, a_{l + 1},\r\nldots, a_r for some 1\r\nle l\r\nle r\r\nle n. We will denote such subsegment as [l, r].\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint a[300005];\nbitset<10000005> vis;\nint lcm(int x,int y)\n{\n\treturn x/__gcd(x,y)*y;\n}\nconst int inf=1e7;\nvoid mermermer()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<=n*30;i++) vis[i]=0;\n\tfor(int i=1;i<=n;i++) cin >> a[i];\n\tvector<int> v;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(auto &t:v) t=lcm(t,a[i]);\n\t\tv.push_back(a[i]);\n\t\tvector<int> V={v[0]};\n\t\tfor(auto t:v) if(V.back()!=t) V.push_back(t);\n\t\tswap(v,V);\n\t\twhile(v.size()&&v[0]>inf) v.erase(v.begin());\n\t\tfor(auto t:v) vis[t]=1;\n\t}\n\tint nw=1;\n\twhile(vis[nw]) ++nw;\n\tcout << nw << \"\\n\";\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) mermermer();\n\treturn 0;\n}\n//bu pa kun nan!!!"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. MEX of LCM.json",
    "editorial_link": "https://codeforces.com//blog/entry/117384",
    "editorial": "Notice that the MEX of numbers will not exceed . Let\u00e2\u0080\u0099s calculate all\r\npossible LCM values on segments that do not exceed . To do this, we will\r\niterate over the right endpoint of the segments and maintain a set of\r\ndifferent LCM values on segments with such a right endpoint.Let these\r\nvalues be . Then , indeed, for each , it is true that is divisible by ,\r\nand therefore , that is, , from which the required follows. That is, the\r\nvalues can be stored naively in some dynamic array. Now suppose we want\r\nto move the right endpoint, then the array should be replaced by and\r\nremove values greater than from the new array, as well as get rid of\r\nduplicates.All these actions can be performed in time, after which we\r\njust need to find the MEX among the known set of values. This solution\r\ncan also serve as proof that the desired MEX does not exceed , which is\r\nless than under the constraints of the problem. Thus, initially, we can\r\nonly maintain numbers less than and not worry about overflows of a\r\n64-bit integer type.\r\n"
}