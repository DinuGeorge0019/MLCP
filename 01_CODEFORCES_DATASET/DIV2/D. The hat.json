{
    "link": "https://codeforces.com//contest/1020/problem/D",
    "problemId": "207011",
    "problem_idx": "D",
    "shortId": "1020D",
    "contest_number": "1020",
    "problem_submissions": {
        "D": [
            41489189,
            41489089,
            41486423,
            41490197,
            41489917,
            41487075,
            41490349,
            41489723,
            41491006,
            41484021,
            41492712,
            41493543,
            41493068,
            41492267,
            41492744,
            41493565,
            41533654,
            41492210,
            41493418,
            41496467
        ],
        "C": [
            41482847,
            41481559,
            41490429,
            41483828,
            41484432,
            41483284,
            41481342,
            41482980,
            41482276,
            41494412,
            41483383,
            41483904,
            41482436,
            41484813,
            41483954,
            41484715,
            41485204,
            41486868,
            41484572
        ],
        "B": [
            41472124,
            41472495,
            41472169,
            41471832,
            41473647,
            41472819,
            41474467,
            41474217,
            41476517,
            41474465,
            41477984,
            41542441,
            41472876,
            41475507,
            41474290,
            41474434,
            41473754,
            41480874,
            41476912,
            41474412
        ],
        "A": [
            41471287,
            41471470,
            41471174,
            41471276,
            41471647,
            41482521,
            41482998,
            41483546,
            41473507,
            41472376,
            41472014,
            41542424,
            41471633,
            41471835,
            41472031,
            41471489,
            41471801,
            41474026,
            41472191,
            41471736
        ],
        "E": [
            41565578
        ]
    },
    "name": "D. The hat",
    "statement": "Imur Ishakov decided to organize a club for people who love to play the\r\nfamous game The hat . The club was visited by students, where is even.\r\nImur arranged them all in a circle and held a draw to break the students\r\nin pairs, but something went wrong. The participants are numbered so\r\nthat participant and participant () are adjacent, as well as participant\r\nand participant . Each student was given a piece of paper with a number\r\nin such a way, that for every two adjacent students, these numbers\r\ndiffer exactly by one. The plan was to form students with the same\r\nnumbers in a pair, but it turned out that not all numbers appeared\r\nexactly twice.As you know, the most convenient is to explain the words\r\nto the partner when he is sitting exactly across you. Students with\r\nnumbers and sit across each other. Imur is wondering if there are two\r\npeople sitting across each other with the same numbers given. Help him\r\nto find such pair of people if it exists.You can ask questions of form\r\nwhich number was received by student ? , and the goal is to determine\r\nwhether the desired pair exists in no more than questions.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define sz(x) ((int)x.size())\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\tif(n / 2 % 2) {\n\t\tprintf(\"! -1\");\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\tint v1, v2;\n\tprintf(\"? 1\\n\"); fflush(stdout);\n\tscanf(\"%d\", &v1);\n\tprintf(\"? %d\\n\", n/2+1); fflush(stdout);\n\tscanf(\"%d\", &v2);\n\tif(v1 == v2) {\n\t\tprintf(\"! 1\"); fflush(stdout);\n\t\treturn 0;\n\t}\n\tint r1 = v1, r2 = v2;\n\tint lo = 1, hi = n / 2;\n\twhile(lo < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tprintf(\"? %d\\n\", mid); fflush(stdout);\n\t\tscanf(\"%d\", &v1);\n\t\tprintf(\"? %d\\n\", (mid+n/2-1)%n+1); fflush(stdout);\n\t\tscanf(\"%d\", &v2);\n\t\tif(v1 == v2) {\n\t\t\tprintf(\"! %d\\n\", mid); fflush(stdout);\n\t\t\treturn 0;\n\t\t}\n\t\tif(r1 - r2 < 0) {\n\t\t\tif(v1 - v2 < 0) lo = mid + 1;\n\t\t\telse hi = mid - 1;\n\t\t} else {\n\t\t\tif(v1 - v2 > 0) lo = mid + 1;\n\t\t\telse hi = mid - 1;\n\t\t}\n\t}\n\tprintf(\"! %d\\n\", lo); fflush(stdout);\n\treturn 0;\n}\n\n// 1 2 3 4 3 2 1 0\n\n// a(i) - a(i+n/2)\n\n// 1 2 3 2 1 0 (1 2 3 2 1 0)\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "interactive"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. The hat.json",
    "editorial_link": "https://codeforces.com//blog/entry/61161",
    "editorial": "Let a(i) be a number given to the i-th student. Let's introduce function . As n is even,  is integer, and b(i) is defined correctly. Notice two facts: first, , and second, . The problem is to find an i such that b(i)?=?0.\n\nSecond note leads us to observation that all b(i) have the same oddity. So, let's find b(0), and if it is odd, then there is no answer, and we need to print ?-?1 \u0097 all b(i) have the same oddity (odd), and zero, as a number of different oddity, won't appear in b(i).\n\nOtherwise, suppose we know b(0), and it is equal to x (without loss of generality x?>?0). Notice that . As we remember from second observation that all b(i) have the same oddity, and neighboring numbers differ by no more than 2, we can use discrete continuity.\n\nLemma: if you have two indices i and j with values b(i) and b(j), then on segment between i and j there are all values with the same oddity from min(b(i),?b(j)) to max(b(i),?b(j)). Indeed, as neighboring b differ by no more than 2, we couldn't skip any number with the same oddity.\n\nNow we can use a binary search. At the start l?=?0, , and values b(l) and b(r) are even numbers with the different signs. By lemma, on segment between l and r there is a zero that we want to find. Let's take . If b(m)?=?0, we found the answer. Otherwise, based on sign of b(m) we can replace one of l, r in binary search to m, and reduce the problem to the same with smaller size. There will be no more than  iterations, and as calculation of b(i) requires two queries, we solved the problem in  queries."
}