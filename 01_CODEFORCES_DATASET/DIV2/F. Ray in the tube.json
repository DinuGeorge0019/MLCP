{
    "link": "https://codeforces.com//contest/1041/problem/F",
    "problemId": "220451",
    "problem_idx": "F",
    "shortId": "1041F",
    "contest_number": "1041",
    "problem_submissions": {
        "F": [
            42937145,
            42936460,
            42941789,
            42939791,
            42936055,
            42943259,
            42941945,
            42942600,
            42940476,
            42943214,
            42942904,
            42941561,
            42940422,
            42942676,
            42967085,
            42945698,
            42942819,
            42940517,
            42945082
        ],
        "E": [
            42931045,
            42932542,
            42929311,
            42932587,
            42939274,
            42934189,
            42934028,
            42935828,
            42936456,
            42936222,
            42934576,
            42934053,
            42934830,
            42936131,
            42933423,
            42935645,
            42936145,
            42934904
        ],
        "D": [
            42928058,
            42928419,
            42932086,
            42926606,
            42928328,
            42929346,
            42929592,
            42930860,
            42930895,
            42928722,
            42931546,
            42929735,
            42930750,
            42931175,
            42929657,
            42930694,
            42932165,
            42929565
        ],
        "C": [
            42924598,
            42925979,
            42923335,
            42923874,
            42924882,
            42924328,
            42925322,
            42926206,
            42927308,
            42925269,
            42926071,
            42925958,
            42929148,
            42926562,
            42925843,
            42927423,
            42929003,
            42925656
        ],
        "B": [
            42919830,
            42920297,
            42919741,
            42920667,
            42921333,
            42921057,
            42919493,
            42920331,
            42920664,
            42920599,
            42920862,
            42919750,
            42921237,
            42921905,
            42921366,
            42922548,
            42922190,
            42921585
        ],
        "A": [
            42918068,
            42918894,
            42917952,
            42918346,
            42918563,
            42921193,
            42918207,
            42918103,
            42917969,
            42918179,
            42919024,
            42917972,
            42919232,
            42918320,
            42918302,
            42919340,
            42918232,
            42918340
        ]
    },
    "name": "F. Ray in the tube",
    "statement": "You are given a tube which is reflective inside represented as two\r\nnon-coinciding, but parallel to Ox lines. Each line has some special\r\ninteger points positions of sensors on sides of the tube.You are going\r\nto emit a laser ray in the tube. To do so, you have to choose integer\r\npoints A and B on the first and the second line respectively\r\n(coordinates can be negative): the point A is responsible for the\r\nposition of the laser, and the point B for the direction of the laser\r\nray. The laser ray is a ray starting at A and directed at B which will\r\nreflect from the sides of the tube (it doesn’t matter if there are any\r\nsensors at a reflection point or not). A sensor will only register the\r\nray if the ray hits exactly at the position of the sensor. Calculate the\r\nmaximum number of sensors which can register your ray if you choose\r\npoints A and B on the first and the second lines respectively.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint f[200009];\nint a[200009];\nint b[200009];\nmain(){\n    int n, X;\n    cin >> n >> X;\n    for(int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    int m;\n    cin >> m >> X;\n    for(int j = 1; j <= m; j++){\n        cin >> b[j];\n    }\n    int ans  = 2;\n    for(int i = 0; i <= 29; i++){\n            vector<int> v;\n        for(int j = 1; j <= n; j++){\n             v.push_back((a[j]^(1<<(i)))&((1<<(i+1))-1));\n\n        }\n        for(int j = 1; j <= m; j++){\n            v.push_back((b[j])&((1<<(i+1))-1));\n\n        }\n        sort(v.begin(), v.end());\n        int cnt = 1;\n        for(int i = 1; i < v.size(); i++){\n            if(v[i] == v[i-1]){\n                cnt ++;\n                continue;\n            }\n            ans = max(ans, cnt);\n            cnt = 1;\n        }\n        //cout<<endl;\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n\n\n}\n\n/*\n4k+3\n4k+1\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dp",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Ray in the tube.json",
    "editorial_link": "https://codeforces.com/blog/entry/61876",
    "editorial": "At first, coordinates donât matter. Let be signed difference between\r\ncoordinates of and , then on the first line all points with coordinates\r\nwill be chosen, and on the second line all points with coordinates will\r\nbe chosen.Letâs prove that it is always optimal to take where . Let is\r\nnot a power of two, then , where is odd. Note that hits all points which\r\nis hitted by that why answer will not decrease. So, we need to check\r\nonly , number of such is equal to .For the fixed note that ray hits both\r\npoints on the same line iff . Analogically, the ray hits both points on\r\nthe different lines iff .Thatâs why we can split all point on the\r\nequivalent classes modulo and take the size of the biggest class. We can\r\ndo it by sort and two pointers or by .Result complexity is time and\r\nmemory.\r\n",
    "hint": []
}