{
    "link": "https://codeforces.com//contest/1981/problem/C",
    "problemId": "2672991",
    "problem_idx": "C",
    "shortId": "1981C",
    "contest_number": "1981",
    "problem_submissions": {
        "F": [
            263497142,
            263559226
        ],
        "E": [
            263476287,
            263464534,
            263479972,
            263479996,
            263481278,
            263484948,
            263487311,
            263488586,
            263490466,
            263488413,
            263485273,
            263486361,
            263491158,
            263492494,
            263487751,
            263490431,
            263594935,
            263475669,
            263731983
        ],
        "D": [
            263469280,
            263482604,
            263470136,
            263467974,
            263476735,
            263476815,
            263475122,
            263473573,
            263468370,
            263465514,
            263477018,
            263481941,
            263480436,
            263478668,
            263478475,
            263485875,
            263469409,
            263472129,
            263470882
        ],
        "C": [
            263456919,
            263468416,
            263459011,
            263454953,
            263461770,
            263457891,
            263464609,
            263463038,
            263456449,
            263472358,
            263463129,
            263464204,
            263463482,
            263460745,
            263470157,
            263458930,
            263460066,
            263458494,
            263461448
        ],
        "B": [
            263449078,
            263456587,
            263450957,
            263448611,
            263450566,
            263450086,
            263449888,
            263451971,
            263448293,
            263451226,
            263454153,
            263455701,
            263455723,
            263449188,
            263455405,
            263451294,
            263451169,
            263449953,
            263456283
        ],
        "A": [
            263445832,
            263446092,
            263445924,
            263445701,
            263447399,
            263445953,
            263446026,
            263448629,
            263445764,
            263445931,
            263446308,
            263445723,
            263447638,
            263446507,
            263449757,
            263445656,
            263446328,
            263445901,
            263446447
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129848",
    "editorial": "Handle the special case where all elements are first.Consider extracting\r\nall positions where the values are not , denoted as . The segments and\r\nwith s are easy to handle by repeatedly multiplying and dividing by .\r\nIt\u00e2\u0080\u0099s easy to see that the constructions of the segments are independent\r\nof each other. Therefore, we now only need to solve the problem where ,\r\n, and .It\u00e2\u0080\u0099s clear that if is determined, then can only be one of , , or\r\n.We observe that the transition is essentially moving along an edge in a\r\ncomplete binary tree. Therefore, the problem is reduced to finding a\r\npath in a complete binary tree with a given start point , end point ,\r\nand passing through nodes. For example, is equivalent to finding a path\r\nfrom to in the complete binary tree that passes through nodes: First,\r\nconsider finding the shortest path from to in the complete binary tree\r\n(which can be found by computing the LCA of and ; the shortest path is\r\n). Let the number of nodes in this shortest path be . There is no\r\nsolution if and only if or if the parities of and are different.\r\nOtherwise, we first fill with the nodes from the shortest path, and then\r\nalternate between and to fill the remaining positions.Time complexity:\r\nor per test case.\r\n",
    "name": "C. Turtle and an Incomplete Sequence",
    "statement": "Turtle was playing with a sequence a_1, a_2,\r\nldots, a_n consisting of positive integers. Unfortunately, some of the\r\nintegers went missing while playing.Now the sequence becomes incomplete.\r\nThere may exist an arbitrary number of indices i such that a_i becomes\r\n-1. Let the new sequence be a\u2019.Turtle is sad. But Turtle remembers that\r\nfor every integer i from 1 to n - 1, either a_i =\r\nleft\r\nlfloor\r\nfrac{a_{i + 1}}{2}\r\nright\r\nrfloor or a_{i + 1} =\r\nleft\r\nlfloor\r\nfrac{a_i}{2}\r\nright\r\nrfloor holds for the original sequence a.Turtle wants you to help him\r\ncomplete the sequence. But sometimes Turtle makes mistakes, so you need\r\nto tell him if you can\u2019t complete the sequence.Formally, you need to\r\nfind another sequence b_1, b_2,\r\nldots, b_n consisting of positive integers such that: For every integer\r\ni from 1 to n, if a\u2019_i\r\nne -1, then b_i = a\u2019_i. For every integer i from 1 to n - 1, either b_i\r\n=\r\nleft\r\nlfloor\r\nfrac{b_{i + 1}}{2}\r\nright\r\nrfloor or b_{i + 1} =\r\nleft\r\nlfloor\r\nfrac{b_i}{2}\r\nright\r\nrfloor holds. For every integer i from 1 to n, 1\r\nle b_i\r\nle 10^9. If there is no sequence b_1, b_2,\r\nldots, b_n that satisfies all of the conditions above, you need to\r\nreport -1.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define LL long long#define LLL __int128#define uint unsigned#define ldb long double#define uLL unsigned long longusing namespace std;\u00a0inline void MAIN(){\tint n;cin>>n;\tvector<LL>a(n);\tfor(auto&i:a)cin>>i;\tfor(int i=0,j=-1;i<=n;++i)if(i==n||~a[i]){\t\tif(j<0){\t\t\tif(i==n){\t\t\t\tfor(int k=0;k<n;++k)a[k]=(k&1?2:1);\t\t\t}\t\t\telse{\t\t\t\tfor(int k=i-1;k>=0;--k)a[k]=(a[k+1]>1?a[k+1]/2:a[k+1]*2);\t\t\t}\t\t}\t\telse{\t\t\tif(i==n){\t\t\t\tfor(int k=j+1;k<n;++k)a[k]=(a[k-1]>1?a[k-1]/2:a[k-1]*2);\t\t\t}\t\t\telse{\t\t\t\tint l=j,r=i;\t\t\t\twhile(l+1<r){\t\t\t\t\tif(a[l]==1&&a[r]==1){\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t\tif(a[l]>a[r])a[l+1]=a[l]/2,++l;\t\t\t\t\telse a[r-1]=a[r]/2,--r;\t\t\t\t}\t\t\t\tif(l+1<r){\t\t\t\t\tfor(int i=l+1;i<r;++i)a[i]=a[i-1]>1?a[i-1]/2:a[i-1]*2;\t\t\t\t}\t\t\t}\t\t}\t\tj=i;\t}\tfor(int i=0;i<n-1;++i)if(!(a[i]/2==a[i+1])&&!(a[i+1]/2==a[i]))return cout<<\"-1\\n\",void();\tfor(auto i:a)cout<<i<<' ';cout<<'\\n';}signed main(){    cin.tie(0)->sync_with_stdio(0);\tint t=1;cin>>t;while(t--)MAIN();    return 0;}/**/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Turtle and an Incomplete Sequence.json"
}