{
    "link": "https://codeforces.com//contest/1698/problem/B",
    "problemId": "1443727",
    "problem_idx": "B",
    "shortId": "1698B",
    "contest_number": "1698",
    "problem_submissions": {
        "F": [
            162124470,
            162134445,
            162141749,
            162152934,
            177654064,
            216084662,
            162196377,
            162139942,
            162355602,
            162159626,
            162690820
        ],
        "E": [
            162087630,
            162097353,
            162109816,
            162103301,
            162126529,
            162103867,
            162097541,
            162101116,
            162109117,
            162107378,
            162110311,
            162151314,
            162112938,
            162118264,
            162120819,
            162122603,
            162129047,
            162116428,
            162113567,
            162115753
        ],
        "D": [
            162072106,
            162078971,
            162084618,
            162091663,
            162091608,
            162080384,
            162079742,
            162083927,
            162089597,
            162090503,
            162089228,
            162119224,
            162090409,
            162087036,
            162090706,
            162084921,
            162084389,
            162101274,
            162089309,
            162089923
        ],
        "C": [
            162065641,
            162067112,
            162066151,
            162070233,
            162081538,
            162071658,
            162069982,
            162072714,
            162074007,
            162068223,
            162076542,
            162110420,
            162075987,
            162073114,
            162072860,
            162074806,
            162073708,
            162075609,
            162078161,
            162072891
        ],
        "B": [
            162059543,
            162058156,
            162059458,
            162060292,
            162065675,
            162061709,
            162057759,
            162058869,
            162063379,
            162060397,
            162060756,
            162115063,
            162060812,
            162061896,
            162062035,
            162068563,
            162064118,
            162063059,
            162062265,
            162061711
        ],
        "A": [
            162055540,
            162055455,
            162055545,
            162055770,
            162057397,
            162055986,
            162055221,
            162055288,
            162058360,
            162055918,
            162055534,
            162055768,
            162055783,
            162057223,
            162056112,
            162055836,
            162057629,
            162055832,
            162056104,
            162055773
        ],
        "G": [
            162150291,
            162713012
        ]
    },
    "name": "B. Rising Sand",
    "statement": "There are n piles of sand where the i-th pile has a_i blocks of sand.\r\nThe i-th pile is called if 1 < i < n and a_i > a_{i-1} + a_{i+1}. That\r\nis, a pile is too tall if it has more sand than its two neighbours\r\ncombined. (Note that piles on the ends of the array cannot be too\r\ntall.)You are given an integer k. An operation consists of picking k\r\nconsecutive piles of sand and adding one unit of sand to them all.\r\nFormally, pick 1\r\nleq l,r\r\nleq n such that r-l+1=k. Then for all l\r\nleq i\r\nleq r, update a_i\r\ngets a_i+1.What is the number of piles that can simultaneously be too\r\ntall after some (possibly zero) operations?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint T,n,k,tot,i,a[1000005];\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>k;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tif(k==1){\n\t\t\tcout<<(n+1>>1)-1<<\"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\ttot=0;\n\t\tfor(i=2;i<n;++i){\n\t\t\tif(a[i]>a[i-1]+a[i+1])++tot;\n\t\t}\n\t\tcout<<tot<<\"\\n\";\n\t}\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Rising Sand.json",
    "editorial_link": "https://codeforces.com//blog/entry/104310",
    "editorial": "Note that two piles in a row can\u00e2\u0080\u0099t be too tall, since a pile that is too\r\ntall has strictly more sand than its neighbours.If then we can make\r\nevery other pile too tall, excluding the ends of the array. For example,\r\nif , we can make piles and too tall by performing some large number of\r\noperations on them (say, by making it into .) The answer is .If , then\r\nnote that for any pile, if we perform the operation on it then we\r\nperform on one of its neighbours as well. Therefore, if the pile is not\r\ntoo tall initially, then it will never become too tall as a result of\r\nthese operations, since both a pile and at least one of its neighbours\r\nwill gain sand. So in this case, doing operations never improves the\r\nanswer, and so the answer is the number of too tall piles initially.The\r\ntime complexity is .\r\n"
}