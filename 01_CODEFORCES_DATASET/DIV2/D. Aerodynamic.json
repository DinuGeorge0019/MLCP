{
    "link": "https://codeforces.com//contest/1300/problem/D",
    "problemId": "536071",
    "problem_idx": "D",
    "shortId": "1300D",
    "contest_number": "1300",
    "problem_submissions": {
        "E": [
            70656422,
            70660342,
            70659594,
            70663407,
            70663445,
            70663695,
            70662627,
            70664459,
            70667573,
            70667578,
            70667153,
            70667998,
            70667370,
            70665044,
            70668944,
            70668742,
            70668939,
            70666794,
            70654169
        ],
        "D": [
            70649967,
            70648316,
            70653519,
            70647449,
            70651136,
            70653985,
            70656894,
            70651482,
            70650140,
            70652905,
            70654553,
            70654763,
            70657422,
            70654653,
            70647217,
            70652554,
            70651738,
            70666577
        ],
        "C": [
            70637820,
            70637616,
            70643543,
            70640283,
            70645889,
            70644943,
            70645600,
            70643218,
            70643243,
            70643430,
            70644879,
            70643858,
            70645790,
            70643117,
            70639743,
            70644978,
            70645908,
            70643196
        ],
        "B": [
            70633510,
            70632581,
            70637741,
            70648477,
            70642916,
            70637878,
            70636707,
            70634786,
            70633496,
            70632050,
            70637586,
            70633740,
            70639225,
            70635607,
            70634472,
            70636324,
            70635597,
            70636449
        ],
        "A": [
            70629102,
            70628944,
            70632868,
            70644279,
            70639039,
            70634945,
            70632554,
            70630514,
            70629803,
            70629176,
            70629854,
            70629908,
            70633145,
            70629847,
            70629744,
            70641116,
            70631231,
            70631279
        ]
    },
    "name": "D. Aerodynamic",
    "statement": "You\u2019re given a (i. e. no three points are collinear) polygon P which is\r\ndefined by coordinates of its vertices. Define P(x,y) as a polygon\r\nobtained by translating P by vector\r\noverrightarrow {(x,y)}. The picture below depicts an example of the\r\ntranslation:Define T as a set of points which is the union of all P(x,y)\r\nsuch that the origin (0,0) lies in P(x,y) (both strictly inside and on\r\nthe boundary). There is also an equivalent definition: a point (x,y)\r\nlies in T only if there are two points A,B in P such that\r\noverrightarrow {AB} =\r\noverrightarrow {(x,y)}. One can prove T is a polygon too. For example,\r\nif P is a regular triangle then T is a regular hexagon. At the picture\r\nbelow P is drawn in black and some P(x,y) which contain the origin are\r\ndrawn in colored: Your task is to check whether the polygons P and T are\r\nsimilar.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define Rint register int\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntemplate<typename T>\ninline void read(T &x){\n\tint ch = getchar(); x = 0;\n\tbool f = false;\n\twhile((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n\tif(ch == '-'){f = true; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9'){x = x * 10 + ch - '0'; ch = getchar();}\n\tif(f) x = -x;\t\n}\nconst int N = 200003;\nint n, x[N], y[N]; \nint main(){\n\tread(n);\n\tfor(Rint i = 1;i <= n;++ i){\n\t\tread(x[i]); read(y[i]);\n\t}\n\tif(n & 1) return puts(\"NO\"), 0; n >>= 1;\n\tfor(Rint i = 1;i <= n;++ i)\n\t\tif(x[i + 1] - x[i] != x[i + n] - x[(i + n) % (2 * n) + 1] || y[i + 1] - y[i] != y[i + n] - y[(i + n) % (2 * n) + 1]) return puts(\"NO\"), 0;\n\tputs(\"YES\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Aerodynamic.json",
    "editorial_link": "https://codeforces.com//blog/entry/73763",
    "editorial": "T\n has the central symmetry: indeed, if P(x,y)\n covers (0,0)\n and (x0,y0)\n then P(x?x0,y?y0)\n covers (?x0,?y0)\n and (0,0)\n. So the answer for polygons which don't have the sentral symmetry is NO. Let's prove if P\n has the central symmetry then the answer is YES. Translate P\n in such a way that the origin becomes its center of symmetry. Let's show that the homothety with the center at the origin and the coefficient 2\n transforms P\n into T\n:\n\nif a point (x0,y0)\n lies in P\n, then P(x0,y0)\n covers both (0,0)\n and (2x0,2y0)\n;\nif a point (x0,y0)\n doesn't lie in P\n, then consider a segment connecting the center of symmetry of the polygon P\n (also known as origin) and (x0,y0)\n; it crosses some side of P\n; WLOG, assume this side is parallel to the x\n-axis and lies in the line y=y1,y1>0\n (otherwise we can rotate the plane). Since the polygon is convex, it completely lies in the stripe y?[?y1;y1]\n, that's why there isn't any vector which connects two points in P\n with a y\n-coordinate greater than 2y1\n. Since 2y0>2y1\n, there isn't any vector which connects two points in P\n with a y\n-coordinate equal to 2y0\n, that's why the point (2x0,2y0)\n doesn't lie in T\n.\nTo find whether a polygon has the central symmetry, check whether the midpoints of segments connecting the opposite vertexes coincide; if a polygon has an odd number of vertexes it can't have the central symmetry."
}