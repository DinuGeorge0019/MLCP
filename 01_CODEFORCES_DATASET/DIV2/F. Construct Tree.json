{
    "link": "https://codeforces.com//contest/1917/problem/F",
    "problemId": "2396148",
    "problem_idx": "F",
    "shortId": "1917F",
    "contest_number": "1917",
    "problem_submissions": {
        "F": [
            238733616,
            238732449,
            238722650,
            238747708,
            238719236,
            238789557,
            238737024,
            238776133,
            238801763,
            238731647,
            239022549,
            238871907,
            238842440,
            239033126,
            238722153,
            238742411
        ],
        "E": [
            238721862,
            238726116,
            238727431,
            238737036,
            238700760,
            238738779,
            238770928,
            238719511,
            238730269,
            238724820,
            238713406,
            238730340,
            238732710,
            238724485,
            238737682
        ],
        "D": [
            238707805,
            238694785,
            238712512,
            238715225,
            238727535,
            238700990,
            238706030,
            238714969,
            238715935,
            238715986,
            238715678,
            238715941,
            238738577,
            238719803,
            238709527,
            238707807
        ],
        "C": [
            238697529,
            238700737,
            238690241,
            238696341,
            238701325,
            238711284,
            238686628,
            238710402,
            238697578,
            238703582,
            238693431,
            238697956,
            238702600,
            238708773,
            238700119,
            238694618,
            238692698,
            238693118
        ],
        "B": [
            238682533,
            238681807,
            238679080,
            238680525,
            238688332,
            238704922,
            238688891,
            238681860,
            238681830,
            238685486,
            238678116,
            238683453,
            238695119,
            238690853,
            238683129,
            238686944,
            238685014,
            238679989
        ],
        "A": [
            238678969,
            238676634,
            238676579,
            238676658,
            238681375,
            238702133,
            238676697,
            238677114,
            238676598,
            238677433,
            238676559,
            238676795,
            238690754,
            238695279,
            238676668,
            238682718,
            238676593,
            238676877
        ]
    },
    "name": "F. Construct Tree",
    "statement": "You are given an array of integers l_1, l_2,\r\ndots, l_n and an integer d. Is it possible to construct a tree\r\nsatisfying the following three conditions? The tree contains n + 1\r\nnodes. The length of the i-th edge is equal to l_i. The (weighted)\r\ndiameter of the tree is equal to d.\r\n",
    "solutions": [
        "#pragma GCC diagnostic error \"-std=c++11\"\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<random>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxn=2005;\nint T,n,d,p[maxn];\nbitset<maxn> g[maxn],dp;\nsigned main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>d;\n\t\tfor(int i=1;i<=n;++i)cin>>p[i];\n\t\tsort(p+1,p+n+1);\n\t\tif(p[n]+p[n-1]>d){\n\t\t\tcout<<\"No\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tif(p[n]>d/2){\n\t\t\tdp.reset();\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=1;i<n;++i)dp|=(dp<<p[i]);\n\t\t\tif(dp[d-p[n]]){\n\t\t\t\tcout<<\"Yes\\n\";\n\t\t\t}\n\t\t\telse cout<<\"No\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<=d;++i)g[i].reset();\n\t\tg[0][0]=1;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tfor(int j=d;j>=0;--j){\n\t\t\t\tg[j]|=(g[j]<<p[i]);\n\t\t\t\tif(j>=p[i])g[j]|=g[j-p[i]];\n\t\t\t}\n\t\t}\n\t\tint flag=0;\n\t\tfor(int i=p[n];i<=d/2;++i)if(g[i][d-i]){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(flag)cout<<\"Yes\\n\";\n\t\telse cout<<\"No\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Construct Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/123721",
    "editorial": "SolutionLetâs consider the lengths in increasing order: . We will\r\ndiscuss some cases depending on the maximum length : If , then the\r\nsolution doesnât exist since an arbitrary tree will have a diameter\r\ngreater than . There exists the subset of the given lengths , such that\r\nthe sum of the lengths of that subset is equal to (for making a\r\ndiameter) and is in that subset. In this case, the solution always\r\nexists, since we can construct a tree for example in the following way:\r\nletâs consider that the size of the found subset is equal to , then we\r\ncan connect the vertices from to , such that the vertices and are\r\nconnected by edge for each and . We have some remaining lengths that we\r\nhavenât used yet, so we can add edges for each length incident to the\r\nvertex . Added edges will not increase the diameter, since is greater\r\nthan or equal to all the remaining edges and . To check if there exists\r\na subset of lengths such that it contains and the sum of elements in the\r\nsubset is equal to , can be easily done by the knapsack algorithm. Here,\r\nwe need to find the subset of the given lengths , such that the sum of\r\nthe lengths of that subset is equal to (for making a diameter and we\r\nalso know that can not be in that subset). Letâs consider that diameter\r\nconsisting of the vertices , , , , such that and are connected by edge\r\nfor each . Now, we need to connect an edge with length to the one vertex\r\nfrom diameter, such that both and . All the other not-used lengths we\r\ncan also connect to the vertex . To check this, we should write knapsack\r\nbut with two states: and . Knapsack can be done using bitset and the\r\nfinal complexity will be . You can also optimize this two times, since\r\nwe know that the minimum of and is at most .\r\n",
    "hint": [
        "Hint 1 If a solution exists, then we can always construct a tree containing a diameter and edges incident to the vertex ( is from diameter).",
        "Hint 2 Try to consider the maximum of the given lengths.",
        "Hint 3 What can we say when there exist two lengths with a sum greater than ?",
        "Hint 4 If a solution exists, then there should be a subset of lengths with the sum equal to .",
        "Hint 5 Consider cases when there exists a subset of lengths containing the maximum length with the sum equal to and doesn't.",
        "Hint 6 Knapsack with bitset."
    ]
}