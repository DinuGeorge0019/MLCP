{"link": "https://codeforces.com//contest/14/problem/D", "problemId": "65", "problem_idx": "D", "shortId": "14D", "contest_number": "14", "problem_submissions": {"E": [62192, 62594, 62287, 61971, 63187, 62768, 63056, 63225, 62267, 62557, 62780, 61993, 62626], "D": [61970, 62027, 62458, 62850, 62826, 62538, 62467, 62772, 62917, 62832, 63108, 62975, 63625, 62539], "C": [61574, 61559, 61851, 61582, 61766, 61317, 61719, 62215, 62454, 61795, 62487, 63175, 61560, 61903], "B": [61265, 61141, 61609, 61379, 61308, 61111, 61382, 61412, 61201, 61434, 62041, 61107, 61138, 61353], "A": [60974, 60976, 61243, 61277, 61025, 61008, 61112, 61102, 61052, 61126, 61656, 60978, 60966, 61057]}, "name": "D. Two Paths", "statement": "As you know, Bob\u2019s brother lives in Flatland. In Flatland there are\r\ncities, connected by two-way roads. The cities are numbered from 1 to .\r\nYou can get from one city to another moving along the roads.The Two\r\nPaths company, where Bob\u2019s brother works, has won a tender to repair two\r\npaths in Flatland. A path is a sequence of different cities, connected\r\nsequentially by roads. The company is allowed to choose by itself the\r\npaths to repair. The only condition they have to meet is that the two\r\npaths shouldn\u2019t cross (i.e. shouldn\u2019t have common cities).It is known\r\nthat the profit, the Two Paths company will get, equals the product of\r\nthe lengths of the two paths. Let\u2019s consider the length of each road\r\nequals 1, and the length of a path equals the amount of roads in it.\r\nFind the maximum possible profit for the company.\r\n", "solutions": ["#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint n , ans;\nint a[201] , b[201];\nvector <int> sons[201];\nint far , farloc;\n\nvoid dfs(int cur , int from , int dist)\n{\n    if(dist > far)\n        far = dist , farloc = cur;\n    for(int i = 0 ; i < sons[cur].size() ; i++)\n        if(sons[cur][i] != from)\n            dfs(sons[cur][i] , cur , dist + 1);\n    \n    \n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while(cin>>n)\n    {\n        ans = 0;\n        for(int i = 1 ; i < n ; i++)\n            cin>>a[i]>>b[i];\n        for(int i = 1 ; i < n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n                sons[j].clear();\n            for(int j = 1 ; j < n ; j++)\n                if(j != i)\n                {\n                    sons[a[j]].push_back(b[j]);\n                    sons[b[j]].push_back(a[j]);\n                }\n            far = -1;\n            dfs(a[i] , -1 , 0);\n            dfs(farloc , -1 , 0);\n            int tem = far;\n            far = -1;\n            dfs(b[i] , -1 , 0);\n            dfs(farloc , -1 , 0);\n            ans = max(far * tem , ans);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "shortest paths", "trees", "two pointers"], "dificulty": "1900", "interactive": false}