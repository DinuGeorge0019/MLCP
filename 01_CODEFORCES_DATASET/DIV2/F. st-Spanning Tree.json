{
    "link": "https://codeforces.com//contest/723/problem/F",
    "problemId": "74122",
    "problem_idx": "F",
    "shortId": "723F",
    "contest_number": "723",
    "problem_submissions": {
        "F": [
            21155697,
            21154113,
            21155933,
            21154904,
            21149973,
            21159426,
            21152095,
            21153693,
            21156752,
            21154148,
            21155446,
            21158512,
            21156719,
            21157841,
            63684195,
            21157428,
            21156472,
            21165079
        ],
        "D": [
            21145243,
            21158845,
            21147482,
            21142220,
            21145053,
            21143706,
            21144743,
            21145722,
            21163140,
            21144768,
            21147552,
            21144060,
            21144166,
            21146675,
            21148374,
            21147946,
            21149603,
            21146889,
            21147955,
            21145653
        ],
        "E": [
            21142890,
            21148616,
            21159045,
            21149920,
            21158556,
            21150731,
            21180051,
            21153029,
            21177875,
            21161980,
            21155864,
            21154968,
            21148045
        ],
        "C": [
            21140474,
            21141296,
            21140148,
            21162108,
            21142166,
            21146292,
            21147879,
            21142862,
            21142174,
            21148589,
            21144499,
            21141215,
            21141347,
            21144291,
            21144339,
            21143781,
            21144417,
            21143640,
            21144289,
            21142493
        ],
        "B": [
            21138785,
            21138330,
            21144052,
            21141269,
            21138610,
            21139747,
            21138581,
            21138753,
            21138976,
            21139782,
            21142236,
            21137955,
            21139130,
            21139752,
            21139693,
            21141265,
            21138488,
            21140188,
            21156231
        ],
        "A": [
            21135605,
            21135289,
            21141496,
            21135525,
            21135366,
            21137068,
            21135345,
            21136036,
            21135454,
            21135984,
            21136355,
            21135335,
            21136286,
            21136540,
            21136310,
            21138762,
            21135363,
            21135712,
            21156449
        ]
    },
    "name": "F. st-Spanning Tree",
    "statement": "You are given an undirected connected graph consisting of vertices and\r\nedges. There are no loops and no multiple edges in the graph.You are\r\nalso given two distinct vertices and , and two values and . Your task is\r\nto build any spanning tree of the given graph (note that the graph is\r\nnot weighted), such that the degree of the vertex doesn’t exceed , and\r\nthe degree of the vertex doesn’t exceed , or determine, that there is no\r\nsuch spanning tree.The of the graph is a subgraph which is a tree and\r\ncontains all vertices of the graph . In other words, it is a connected\r\ngraph which contains edges and can be obtained by removing some of the\r\nedges from .The degree of a vertex is the number of edges incident to\r\nthis vertex.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n\nconst int N = 4e5 + 7;\ntypedef std::vector<std::pair<int, int> > EdgeList;\n\nint father[N];\nEdgeList edges;\n\nint find(int x) {\n\treturn father[x] == x ? x : father[x] = find(father[x]);\n}\n\nint n, m;\nint s, t, ds, dt;\n\nbool rel_st(std::pair<int, int> p) {\n\treturn (p.first == s || p.first == t ||\n\t\tp.second == s || p.second == t);\n}\n\nEdgeList solve(EdgeList edges) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfather[i] = i;\n\t}\n\tEdgeList ret;\n\tfor (int i = 0; i < edges.size(); i++) {\n\t\tint u = edges[i].first, v = edges[i].second;\n\t\tif (find(u) != find(v)) {\n\t\t\tfather[find(u)] = find(v);\n\t\t\tret.push_back({u, v});\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool to_s[N], to_t[N];\nint s2who[N], t2who[N];\n\nvoid get_info(int s, bool to[], int to_who[], EdgeList edges) {\n\tstd::fill(to + 1, to + n + 1, false);\n\tfor (auto e : edges) {\n\t\tif (e.second == s) std::swap(e.first, e.second);\n\t\tif (e.first == s) {\n\t\t\tint v = e.second;\n\t\t\tto[find(v)] = true;\n\t\t\tto_who[find(v)] = v;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges.push_back({u, v});\n\t}\n\tscanf(\"%d %d %d %d\", &s, &t, &ds, &dt);\n\tstd::vector<std::pair<int, int> > bak = edges;\n\tedges.clear();\n\tfor (auto p : bak) {\n\t\tif (!rel_st(p)) {\n\t\t\tedges.push_back(p);\n\t\t}\n\t}\n\tfor (auto p : bak) {\n\t\tif (rel_st(p)) {\n\t\t\tedges.push_back(p);\n\t\t}\n\t}\n\tauto vec = solve(edges);\n\tif (vec.size() < n - 1) {\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfather[i] = i;\n\t}\n\tEdgeList ans;\n\tfor (auto choosed : vec) {\n\t\tif (!rel_st(choosed)) {\n\t\t\tint u = choosed.first;\n\t\t\tint v = choosed.second;\n\t\t\tfather[find(u)] = father[find(v)];\n\t\t\tans.push_back(choosed);\n\t\t}\n\t}\n\tget_info(s, to_s, s2who, edges);\n\tget_info(t, to_t, t2who, edges);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i != s && i != t && i == find(i)) {\n\t\t\tassert(to_s[i] || to_t[i]);\n\t\t\tif (to_s[i] && !to_t[i]) {\n\t\t\t\tds--;\n\t\t\t\tfather[i] = s;\n\t\t\t\tans.push_back({s, s2who[i]});\n\t\t\t} else if (to_t[i] && !to_s[i]) {\n\t\t\t\tdt--;\n\t\t\t\tfather[i] = t;\n\t\t\t\tans.push_back({t, t2who[i]});\n\t\t\t}\n\t\t}\n\t}\n\tint extras = -1, extrat = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i != s && i != t && i == find(i)) {\n\t\t\tif (to_s[i] && to_t[i]) {\n\t\t\t\tif (ds > dt) {\n\t\t\t\t\tds--;\n\t\t\t\t\tans.push_back({s, s2who[i]});\n\t\t\t\t\textrat = t2who[i];\n\t\t\t\t} else {\n\t\t\t\t\tdt--;\n\t\t\t\t\tans.push_back({t, t2who[i]});\n\t\t\t\t\textras = s2who[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (extras == -1 && extrat == -1) {\n\t\tans.push_back({s, t});\n\t\tds--;\n\t\tdt--;\n\t} else if ((ds >= dt && extras != -1) || extrat == -1) {\n\t\tans.push_back({s, extras});\n\t\tds--;\n\t} else if ((dt >= ds && extrat != -1) || extras == -1) {\n\t\tans.push_back({t, extrat});\n\t\tdt--;\n\t}\n\tif (ds < 0 || dt < 0 || ans.size() < n - 1) {\n\t\tputs(\"No\");\n\t\treturn 0;\n\t} else {\n\t\tputs(\"Yes\");\n\t\tfor (auto a : ans) {\n\t\t\tprintf(\"%d %d\\n\", a.first, a.second);\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "graphs",
        "greedy",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. st-Spanning Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/47502",
    "editorial": "At first lets delete vertices and from the graph, find all connected\r\ncomponents in the remaining graph and build for every component any\r\nspanning trees.Now we need to add in spanning tree vertices and . At\r\nfirst let add edges from to all components, which have no edges to .\r\nThen let add edges from to all components, which have no edges to .If\r\nafter that the degree of became more than or the degree of became more\r\nthan answer does not exist.Now we have components which have edges and\r\nto and to . Also currently we have two spanning trees which does not\r\nconnect. Letâs choose how to connect them with vertex , with vertex or\r\nwith both of them (only if we have in the graph an edge ). For each\r\noption we need to greedily connect remaining components (if it is\r\npossible for current option). If we done it for any option we need only\r\nto print the answer.\r\n",
    "hint": []
}