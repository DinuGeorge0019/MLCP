{"link": "https://codeforces.com//contest/401/problem/D", "problemId": "6959", "problem_idx": "D", "shortId": "401D", "contest_number": "401", "problem_submissions": {"D": [5984020, 5984141, 5983864, 5981435, 5984587, 5985602, 5984819, 5989770, 5989652, 5985683, 5985592, 5986146, 5986479, 5986019, 5987077, 5985527, 5986927, 5987397, 5987110, 5982946], "C": [5982567, 5981674, 5981703, 5983252, 5981659, 5981584, 5982579, 5983834, 5982834, 5982433, 5981231, 5982713, 5981380, 5989529, 5980186, 5983524, 5981695, 5982769, 5984546], "B": [5981497, 5980354, 5980450, 5984055, 5980168, 5980824, 5980688, 5980343, 5980890, 5980668, 5982737, 5981001, 5980082, 5983516, 5981360, 5979897, 5980852, 5985462], "A": [5979782, 5978771, 5978488, 5978820, 5978676, 5979741, 5978935, 5978831, 5978982, 5978516, 5979643, 5978615, 5985991, 5978937, 5978457, 5979014, 5986063], "E": [5991956, 5996869]}, "name": "D. Roman and Numbers", "statement": "Roman is a young mathematician, very famous in Uzhland. Unfortunately,\r\nSereja doesn\u2019t think so. To make Sereja change his mind, Roman is ready\r\nto solve any mathematical problem. After some thought, Sereja asked Roma\r\nto find, how many numbers are close to number , modulo .Number is\r\nconsidered close to number modulo , if: it can be obtained by\r\nrearranging the digits of number , it doesn\u2019t have any leading zeroes,\r\nthe remainder after dividing number by equals 0. Roman is a good\r\nmathematician, but the number of such numbers is too huge for him. So he\r\nasks you to help him.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nlong long n;\nint f[20],num,m,maxn,g[10];\nlong long dp[1<<18][100];\nbool flag;\n\nint main()\n{\n    memset(f,0,sizeof(f));\n    memset(dp,0,sizeof(dp));\n    cin>>n>>m;\n    num=0;\n    if(n%m==0)flag=true;\n    else flag=false;\n    while(n)\n    {\n        f[num++]=n%10;\n        n=n/10;\n    }\n    maxn=1<<num;\n    dp[0][0]=1;\n    for(int k=0;k<num;k++)\n        if(f[k])dp[1<<k][f[k]%m]+=dp[0][0];\n    for(int i=1;i<maxn;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<num;k++)\n                if(!(i&(1<<k)))dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }\n    memset(g,0,sizeof(g));\n    for(int i=0;i<num;i++)\n        g[f[i]]++;\n    long long ans=dp[maxn-1][0];\n    for(int i=0;i<10;i++)\n        for(int j=1;j<=g[i];j++)\n            ans=ans/j;\n    //if(flag)ans--;\n    cout<<ans;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "combinatorics", "dp", "number theory"], "dificulty": "2000", "interactive": false}