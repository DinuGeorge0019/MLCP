{
    "link": "https://codeforces.com//contest/2007/problem/F",
    "problemId": "2845545",
    "problem_idx": "F",
    "shortId": "2007F",
    "contest_number": "2007",
    "problem_submissions": {
        "F": [
            278829889,
            278836909,
            278834397,
            278833574,
            278834465,
            278838066,
            278835361,
            278842334,
            278824105,
            278831692,
            278838908,
            278836968,
            278839548,
            278831301,
            278823086,
            278840296,
            278841111,
            278842601
        ],
        "E": [
            278819100,
            278812531,
            278814740,
            278819903,
            278822295,
            278825462,
            278818230,
            278822054,
            278840929,
            278825485,
            278828447,
            278833891,
            278799229,
            278838138,
            278839019,
            278828512,
            278831250,
            278831388,
            278817583,
            278815781
        ],
        "D": [
            278799468,
            278799575,
            278803157,
            278799799,
            278806603,
            278804232,
            278798668,
            278803495,
            278817444,
            278796667,
            278805268,
            278809906,
            278809488,
            278817233,
            278829523,
            278808086,
            278804865,
            278814312,
            278803553,
            278802384
        ],
        "C": [
            278780728,
            278781086,
            278788227,
            278789504,
            278792493,
            278790375,
            278787480,
            278788281,
            278794086,
            278818650,
            278789734,
            278788169,
            278787429,
            278793363,
            278793381,
            278800135,
            278810824,
            278793278,
            278788023,
            278790440
        ],
        "B": [
            278776959,
            278776203,
            278777907,
            278784810,
            278782747,
            278782953,
            278836748,
            278778704,
            278778803,
            278775898,
            278785508,
            278778671,
            278810717,
            278784596,
            278792140,
            278786468,
            278796546,
            278777191,
            278777412,
            278786342
        ],
        "A": [
            278773744,
            278773692,
            278774098,
            278774399,
            278775464,
            278777680,
            278775772,
            278775250,
            278773819,
            278773814,
            278774248,
            278884949,
            278773664,
            278780595,
            278777213,
            278780108,
            278778288,
            278781544,
            278774028,
            278774012,
            278778642
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/133382",
    "editorial": "Let's consider the elements in the final set a\n, and take bi=ai?ai?1\n as its difference array.\n\nObservation 1: bi\n is odd. Otherwise we can turn bi\n into two bi2\n.\n\nObservation 2: Adjacent bi\n are not different. Suppose bi\n and bi+1\n are different and odd, then ai+1?ai?1\n is even, and ai+1+ai?12?ai\n, so a\n can be larger.\n\nThus, the array a\n is an arithmetic progression, with an odd tolerance bi\n.\n\nIf you notice this, and can also notice the monotonicity, you can maintain (c,d,len)\n for a range of numbers to show that the final set is an arithmetic progression starting from c\n, consisting of len\n elements and has tolerance d\n. It's amazing that two pieces of information like this can be merged, so we can use sparse table to maintain.\n\nHowever, there's a better way to solve it. Similar to Euclidean Algorithm, the tolerance is equal to the maximum odd divisor of the gcd of the difference array of a\n, that is, gcd{ai?ai?1}\n. Then the restriction means that gcd{ai?ai?1}\n is a power of 2\n.\n\nFor a fixed point l\n, find the smallest r\n that interval [l,r]\n is good. A divisor of a power of 2\n is still a power of 2\n, so it has monotonicity, which makes it possible to use two pointers to maintain it in O(nlognV)\n or O(nlogV)\n. Using sparse table or binary lifting may reach the same complexity. Note that adjacent same numbers should be carefully dealt with.",
    "name": "F. Eri and Expanded Sets",
    "statement": "Let there be a set that contains positive integers. To expand the set to\r\ncontain as many integers as possible, Eri can choose two integers x\r\nneq y from the set such that their average\r\nfrac{x+y}2 is still a positive integer and isn’t contained in the set,\r\nand add it to the set. The integers x and y remain in the set.Let’s call\r\nthe set of integers if, after the elements are sorted, the difference\r\nbetween any pair of adjacent elements is 1. For example, sets\r\n{2\r\n},\r\n{2, 5, 4, 3\r\n},\r\n{5, 6, 8, 7\r\n} are consecutive, while\r\n{2, 4, 5, 6\r\n},\r\n{9, 7\r\n} are not.Eri likes consecutive sets. Suppose there is an array b, then\r\nEri puts all elements in b into the set. If after a finite number of\r\noperations described above, the set can become consecutive, the array b\r\nwill be called .Note that if the same integer appears in the array\r\nmultiple times, we only put it into the set , as a set always contains\r\ndistinct positive integers.Eri has an array a of n positive integers.\r\nPlease help him to count the number of pairs of integers (l,r) such that\r\n1\r\nleq l\r\nleq r\r\nleq n and the subarray a_l, a_{l+1},\r\nldots, a_r is brilliant.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; const int maxN = 440000;int a[maxN], g[maxN][20]; int getgcd(int a, int b) {\tint len = 31 - __builtin_clz(b - a + 1);\treturn __gcd(g[a][len], g[b - (1 << len) + 1][len]);} int main() {\tios::sync_with_stdio(0);\tcin.tie(0); cout.tie(0);\tint T;\tfor (cin >> T; T; T--) {\t\tint n; cin >> n;\t\tfor (int i = 0; i < n; i++) cin >> a[i];\t\tfor (int i = 1; i < n; i++)\t\t\tg[i][0] = abs(a[i] - a[i - 1]);\t\tfor (int i = 1; i < 20; i++) {\t\t\tfor (int j = 1; j < n; j++) {\t\t\t\tg[j][i] = g[j][i - 1];\t\t\t\tint k = j + (1 << i - 1);\t\t\t\tif (k < n) g[j][i] = __gcd(g[j][i], g[k][i - 1]);\t\t\t}\t\t}\t\tlong long ans = 0;\t\tfor (int i = 1; i < n; i++) {\t\t\tint st = i, ed = n;\t\t\twhile (st < ed) {\t\t\t\tint md = (st + ed) / 2;\t\t\t\tif (__builtin_popcount(getgcd(i, md)) == 1) ed = md;\t\t\t\telse st = md + 1;\t\t\t}\t\t\tans += n - st;\t\t\tst = i, ed = n;\t\t\twhile (st < ed) {\t\t\t\tint md = (st + ed) / 2;\t\t\t\tif (getgcd(i, md)) ed = md;\t\t\t\telse st = md + 1;\t\t\t}\t\t\tans += st - i + 1;\t\t}\t\tcout << ans + 1 << '\\n';\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "number theory",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Eri and Expanded Sets.json",
    "hint": []
}