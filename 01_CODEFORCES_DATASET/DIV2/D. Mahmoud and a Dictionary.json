{
    "link": "https://codeforces.com//contest/766/problem/D",
    "problemId": "92734",
    "problem_idx": "D",
    "shortId": "766D",
    "contest_number": "766",
    "problem_submissions": {
        "D": [
            24505946,
            24500916,
            24504908,
            24507791,
            24507596,
            24502515,
            24505444,
            24508821,
            24506093,
            24509131,
            24508400,
            24506164,
            24508411,
            24506236,
            24509954,
            24506157,
            24500663,
            24511147,
            24509915,
            24510742,
            24507071
        ],
        "C": [
            24503002,
            24497705,
            24503645,
            24497245,
            24504415,
            24507920,
            24498510,
            24499723,
            24502316,
            24500439,
            24497520,
            24497973,
            24498376,
            24502187,
            24500765,
            24500712,
            24509044,
            24499242,
            24501478,
            24510759
        ],
        "E": [
            24499598,
            24503926,
            24499034,
            24503749,
            24499107,
            24506022,
            24509883,
            24505215,
            24508282,
            24506448,
            24503360,
            24508753,
            24506776,
            24509196,
            24506537,
            24510465,
            24506832,
            24511136,
            24508039,
            24506667,
            24509589
        ],
        "B": [
            24494141,
            24493611,
            24500716,
            24498345,
            24502090,
            24496129,
            24493849,
            24494351,
            24495688,
            24493721,
            24507808,
            24494240,
            24493512,
            24496420,
            24496210,
            24495834,
            24507882,
            24494117,
            24496757,
            24494993
        ],
        "A": [
            24493013,
            24492877,
            24500045,
            24499173,
            24500116,
            24494575,
            24495318,
            24492979,
            24492967,
            24492862,
            24493192,
            24492913,
            24494460,
            24494158,
            24494086,
            24507606,
            24492997,
            24493480
        ]
    },
    "name": "D. Mahmoud and a Dictionary",
    "statement": "Mahmoud wants to write a new dictionary that contains words and\r\nrelations between them. There are two types of relations: synonymy (i.\r\ne. the two words mean the same) and antonymy (i. e. the two words mean\r\nthe opposite). From time to time he discovers a new relation between two\r\nwords.He know that if two words have a relation between them, then each\r\nof them has relations with the words that has relations with the other.\r\nFor example, if means and is the opposite of , then is also the opposite\r\nof . One more example: if is the opposite of and is the opposite of ,\r\nthen means , and so on.Sometimes Mahmoud discovers a wrong relation. A\r\nwrong relation is a relation that makes two words equal and opposite at\r\nthe same time. For example if he knows that means and is the opposite of\r\n, and then he figures out that means , the last relation is absolutely\r\nwrong because it makes and opposite and have the same meaning at the\r\nsame time.After Mahmoud figured out many relations, he was worried that\r\nsome of them were wrong so that they will make other relations also\r\nwrong, so he decided to tell every relation he figured out to his coder\r\nfriend Ehab and for every relation he wanted to know is it correct or\r\nwrong, basing on the previously discovered relations. If it is wrong he\r\nignores it, and doesn’t check with following relations.After adding all\r\nrelations, Mahmoud asked Ehab about relations between some words based\r\non the information he had given to him. Ehab is busy making a Codeforces\r\nround so he asked you for help.\r\n",
    "solutions": [
        "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)\n#define np(v) next_permutation(v.begin(), v.end())\n#define pll pair < long long, long long>\n#define all(a) a.begin(), a.end()\n#define ull unsigned long long\n#define pii pair < int, int >\n#define sz(a) (int)a.size()\n#define sqr(x) ((x) * (x))\n#define y1 stupid_cmath\n#define vi vector <int>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define f first\n#define s second\n\nconst int inf = (int)1e9;\nconst int mod = inf + 7;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\n\nstring u, v;\nint n, m, q;\nint t;\nstring s[100100];\nmap <string, int> id;\nint p[200200];\n\nint get(int v){\n    if(p[v] == v) return v;\n    return p[v] = get(p[v]);\n}\n\nint main(){\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cin >> n >> m >> q;\n    for(int i = 0; i < n; ++i){\n        cin >> s[i];\n        id[s[i]] = i;\n        p[i] = i;\n        p[i + n] = i + n;\n    }\n    for(int i = 0; i < m; ++i){\n        cin >> t >> u >> v;\n        int x = id[u];\n        int y = id[v];\n        if(t == 1){\n            if(get(x) == get(y + n)) cout << \"NO\" << \"\\n\";\n            else{\n                if(get(x) != get(y)){\n                    p[get(x)] = get(y);\n                }\n                if(get(x + n) != get(y + n)){\n                    p[get(x + n)] = get(y + n);\n                }\n                cout << \"YES\" << \"\\n\";\n            }\n        }else{\n            if(get(x) == get(y)){\n                cout << \"NO\" << \"\\n\";\n            }else{\n                if(get(x) != get(y + n)){\n                    p[get(x)] = get(y + n);\n                }\n                if(get(x + n) != get(y)){\n                    p[get(x + n)] = get(y);\n                }\n                cout << \"YES\" << \"\\n\";\n            }\n        }\n    }\n    for(int i = 0; i < q; ++i){\n        cin >> u >> v;\n        int x = id[u];\n        int y = id[v];\n        if(get(x) == get(y)) cout << 1 << \"\\n\";\n        else{\n            if(get(x) == get(y + n)) cout << 2 << \"\\n\";\n            else cout << 3 << \"\\n\";\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "dsu",
        "graphs"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Mahmoud and a Dictionary.json",
    "editorial_link": "https://codeforces.com//blog/entry/50294",
    "editorial": "Letâs build a graph containing the words, For every relation in the\r\ninput add a new edge with the weight of if they are equal and if they\r\nare opposites, If adding the edge doesnât make the graph cyclic, Our\r\nrelation is valid, Otherwise it may be valid or invalid so weâll answer\r\nthem offline. Check if adding that edge will make the graph cyclic or\r\nnot using union-find like Kruskalâs algorithm. Suspend answering\r\nrelations that will make the graph cyclic, Now we have a forest of\r\ntrees, Let be the xor of the weights on the edges in the path from the\r\nroot of the component of node to node . Calculate it using dfs. To find\r\nthe relation between 2 words and , Check if they are in the same\r\ncomponent using union-find, If they arenât, The answer is otherwise the\r\nanswer is , Now to answer suspended relations, Find the relation between\r\nthe 2 words and check if itâs the same as the input relation, Then\r\nanswer the queries. Code : http://pastebin.com/WqwduaYs Time complexity\r\n: where is the length of the longest string considering that union-find\r\nworks in constant time. Problem author : mahmoudbadawy. Solution author\r\n: me. Testers : me and mahmoudbadawy. Wait for a hard version of this\r\nproblem.\r\n",
    "hint": []
}