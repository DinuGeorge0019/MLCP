{"link": "https://codeforces.com//contest/560/problem/E", "problemId": "31957", "problem_idx": "E", "shortId": "560E", "contest_number": "560", "problem_submissions": {"E": [12181314, 12181454, 12176455, 12191515, 27897729, 12220479, 12223057, 12198112, 12197784], "D": [12176988, 12173417, 12184797, 12171285, 12174903, 12171851, 12175271, 12175100, 12171832, 12176403, 12545866, 12172755, 12170360, 12176803, 12175499, 12176746, 12176672, 12176886, 12175224, 12176471], "C": [12173418, 12170958, 12169024, 12169130, 12171468, 12168005, 12169958, 12171636, 12175268, 12170205, 12166791, 12175779, 12170596, 12171530, 12170301, 12171676, 12172737, 12172160, 12172611], "B": [12166586, 12170401, 12166753, 12166908, 12167772, 12166787, 12167175, 12168191, 12167188, 12165775, 12175964, 12165865, 12167390, 12169323, 12167704, 12168803, 12167427, 12168269, 12168924], "A": [12164875, 12165324, 12164911, 12164741, 12164812, 12165009, 12167558, 12165824, 12164606, 12166596, 12174689, 12164836, 12164796, 12165378, 12165156, 12165311, 12164941, 12166328, 12166259]}, "name": "E. Gerald and Giant Chess", "statement": "Giant chess is quite common in Geraldion. We will not delve into the\r\nrules of the game, we\u2019ll just say that the game takes place on an field,\r\nand it is painted in two colors, but not like in chess. Almost all cells\r\nof the field are white and only some of them are black. Currently Gerald\r\nis finishing a game of giant chess against his friend Pollard. Gerald\r\nhas almost won, and the only thing he needs to win is to bring the pawn\r\nfrom the upper left corner of the board, where it is now standing, to\r\nthe lower right corner. Gerald is so confident of victory that he became\r\ninterested, in how many ways can he win?The pawn, which Gerald has got\r\nleft can go in two ways: one cell down or one cell to the right. In\r\naddition, it can not go to the black cells, otherwise the Gerald still\r\nloses. There are no other pawns or pieces left on the field, so that,\r\naccording to the rules of giant chess Gerald moves his pawn until the\r\ngame is over, and Pollard is just watching this process.\r\n", "solutions": ["#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\nstatic const ll MOD = 1000000007;\n\nll FAC[200010], iFAC[200010];\n\nll mpow(ll a, ll b) {\n    if(b == 0) return 1;\n    ll res = mpow(a,b/2);\n    res *= res;\n    res %= MOD;\n    if(b&1ll) {\n        res *= a;\n        res %= MOD;\n    }\n    return res;\n}\n\nll inv(ll a) {\n    return mpow(a,MOD-2);\n}\n\nvoid pre_calc() {\n    FAC[0] = FAC[1] = 1;\n    for(int i=2;i<=200000;i++) FAC[i] = (FAC[i-1] * i) % MOD;\n    iFAC[0] = iFAC[1] = 1;\n    for(int i=2;i<=200000;i++) iFAC[i] = (iFAC[i-1] * inv(i)) % MOD;\n}\n\nll ways(int a, int b) {\n    if(a == 0 || b == 0) return 1;\n    ll res = (FAC[a+b] * iFAC[a]) % MOD;\n    res = (res * iFAC[b]) % MOD;\n    return res;\n}\n\nll ways(int p, int q, int u, int v) {\n    assert(u>=p);\n    assert(v>=q);\n    return ways(u-p, v-q);\n}\n\ntypedef pair<int,int> ip;\n#define fi first\n#define se second\nip pt[2010];\nll foo[2010];\n\nint main() {\n    pre_calc();\n    int H, W, N;\n    cin >> H >> W >> N;\n    ++N;\n    pt[0].fi = 1;\n    pt[0].se = 1;\n    for(int i=1;i<N;i++) cin >> pt[i].fi >> pt[i].se;\n    sort(pt,pt+N);\n    for(int i=N-1;i>=0;i--) {\n        foo[i] = ways(pt[i].fi,pt[i].se,H,W);\n        for(int j=i+1;j<N;j++) {\n            if(pt[j].se < pt[i].se) continue;\n            ll v = ways(pt[i].fi,pt[i].se,pt[j].fi,pt[j].se);\n            v  = (v * foo[j]) % MOD;\n            foo[i] = (foo[i] + MOD - v) % MOD;\n        }\n    }\n    cout << foo[0] << endl;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2200", "interactive": false}