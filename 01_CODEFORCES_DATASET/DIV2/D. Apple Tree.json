{
    "link": "https://codeforces.com//contest/349/problem/D",
    "problemId": "3549",
    "problem_idx": "D",
    "shortId": "349D",
    "contest_number": "349",
    "problem_submissions": {
        "D": [
            4586911,
            4587546,
            4590309,
            4605289,
            4592982,
            4589986
        ],
        "C": [
            4579349,
            4581158,
            4584057,
            4587362,
            4574321,
            4578875,
            4579333,
            4584378,
            4576583,
            4578735,
            4584376,
            4576741,
            4580415,
            4579374,
            4582012,
            4580781,
            4579724,
            4577757,
            4581731,
            4581196
        ],
        "B": [
            4577721,
            4578680,
            4579047,
            4581522,
            4584157,
            4576099,
            4576886,
            4578760,
            4580087,
            4577109,
            4580022,
            4582679,
            4591458,
            4578085,
            4577555,
            4578204,
            4577542,
            4580785,
            4578257,
            4579319
        ],
        "A": [
            4574694,
            4574505,
            4590368,
            4575523,
            4576263,
            4574373,
            4574842,
            4576276,
            4574753,
            4575065,
            4576296,
            4574412,
            4574285,
            4575011,
            4574739,
            4574413,
            4574926,
            4574582,
            4575353,
            4575100
        ]
    },
    "name": "D. Apple Tree",
    "statement": "You are given a rooted tree with vertices. In each leaf vertex there’s a\r\nsingle integer the number of apples in this vertex. The of a subtree is\r\nthe sum of all numbers in this subtree leaves. For instance, the weight\r\nof a subtree that corresponds to some leaf is the number written in the\r\nleaf.A tree is if for every vertex of the tree all its subtrees,\r\ncorresponding to the children of vertex , are of equal weight. Count the\r\nminimum number of apples that you need to remove from the tree\r\n(specifically, from some of its leaves) in order to make the tree\r\nbalanced. Notice that you can always achieve the goal by just removing\r\nall apples.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <math.h>\n\n#include <vector>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\ntemplate<typename T>inline string to_str(const T& v) {\n    ostringstream os; os << v; return os.str();\n}\ntemplate<typename T>inline T to_obj(const string& v) {\n    istringstream is(v); T r; is>>r; return r;\n}\ntemplate<class T>inline int cMin(T& a, T b) {return b<a ? a=b,1 : 0;}\ntemplate<class T>inline int cMax(T& a, T b) {return a<b ? a=b,1 : 0;}\n\n#define CLR(A,v) memset(A, v, sizeof(A))\n#define MP(a,b)  make_pair(a, b)\n#define F0(i, n) for(int i=0; i<(n); ++i)\n#define F1(i, n) for(int i=1; i<=(n); ++i)\n\n\nconst int NN = 100000 + 8;\nint  N;\nint  A[NN];\nint  nnn = 0;\ntypedef long long i64;\ni64  G[NN];\ni64  LM[NN];\n\nvector<vector<int> >  adj;\n\n\ntemplate <typename T> T gcd(const T& a, const T& b) {return b==0 ? a : gcd(b,a%b);}\ntemplate <typename T> T lcm(const T& a, const T& b) {return a/gcd(a,b)*b;}\n\n\ni64 ans = 0;\ni64 tot = 0;\n\nint dfs(int u, int fa) {\n    i64  tmp = 1;\n    i64  sum = 0;\n    int  cnt = 0;\n    i64  min_val = -1;\n    G[u] = A[u];\n    LM[u] = 1;\n    vector<int>& F=adj[u];\n    for(size_t k=0; k<F.size(); ++k) {\n        int  v = F[k];\n        if(v == fa) continue;\n        tmp = lcm<i64>(tmp, dfs(v, u));\n        ++cnt;\n        if(min_val < 0 || G[v] < min_val)\n            min_val = G[v];\n        sum += G[v];\n    }\n    LM[u] = tmp * cnt;\n    if(LM[u] == 0) LM[u] = 1;\n    if (!cnt) return 1;\n    bool tag = true;\n    while(tag && min_val>0) {\n        tag = false;\n        for(size_t k=0; k<F.size(); ++k) {\n            int  v = F[k];\n            if(v == fa) continue;\n            if(G[v] > min_val) {\n                i64  should_remove = G[v] - min_val;\n                if(should_remove%LM[v]) {\n                    should_remove = (should_remove/LM[v] + 1) * LM[v];\n                    min_val = G[v] - should_remove;\n                    tag = true;\n                    if(min_val < 0) min_val = 0;\n                }\n            }\n        }\n    }\n    G[u] = min_val * cnt;\n    return LM[u];\n}\n\nvoid add(int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\n\nint main(int argc, char *argv[]) {\n    scanf(\"%d\", &N);\n    adj = vector<vector<int> >(N);\n    F0(i, N) scanf(\"%d\", A+i);\n    F0(i, N) tot += A[i];\n    nnn = N;\n    for(int i=1; i<N; ++i) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add(u-1, v-1);\n    }\n    memset(G, 0, sizeof(G));\n    dfs(0, -1);\n    printf(\"%I64d\\n\", tot - G[0]);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "number theory",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Apple Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/9031",
    "editorial": "In the problem you need to find out minimal number of apples that you need to remove in order to make tree balanced.\n\nNotice, that if we know the value in the root then we know values in all other vertices. The value in the leaf is equal to the value in the root divided to the product of the powers of all vertices on the path between root and leaf.\n\nFor every vertex let's calculate di  minimal number in that vertex (not zero) in order to make tree balanced. For leaves di?=?1, for all other vertices di is equal to k·lcm(dj1,?dj2,?...,?djk), where j1,?j2,?...,?jk  sons of the vertex i. Let's calculate si  sum in the subtree of the vertex i. All that can be done using one depth first search from the root of the tree.\n\nUsing second depth first search one can calculate for every vertex maximal number that we can write in it and satisfty all conditions. More precisely, given vertex i and k of its sons j1,?j2,?...,?jk. Then if m?=?min(sj1,?sj2,?...,?sjk) and   minimal number, that we can write to the sons of vertex i, then it's worth to write numbers  to the sons of vertex i. Remains  we add to the answer.",
    "hint": []
}