{
    "link": "https://codeforces.com//contest/1894/problem/D",
    "problemId": "2312801",
    "problem_idx": "D",
    "shortId": "1894D",
    "contest_number": "1894",
    "problem_submissions": {
        "E": [
            231780542,
            231780764,
            231783721,
            231789834,
            231788705,
            231788269,
            231784914,
            231788986,
            231801971,
            231786358,
            231788036,
            231815440,
            231786637,
            231808858,
            231789692,
            231801877,
            231817632,
            231801951
        ],
        "D": [
            231763745,
            231766056,
            231762523,
            231754895,
            231759834,
            231769389,
            231770188,
            231758327,
            231760530,
            231775160,
            231770452,
            231759047,
            231773241,
            231762950,
            231774799,
            231763275,
            231763670,
            231771730
        ],
        "C": [
            231756298,
            231755831,
            231757004,
            231877074,
            231770559,
            231763470,
            231760236,
            231765769,
            231774024,
            231754920,
            231758557,
            231758057,
            231762243,
            231765459,
            231756919,
            231760340,
            231755946,
            231756421,
            231763397
        ],
        "A": [
            231751883,
            231747419,
            231747509,
            231747329,
            231751165,
            231747346,
            231747376,
            231747139,
            231747693,
            231747813,
            231746849,
            231749093,
            231749182,
            231746695,
            231748186,
            231747273,
            231747195,
            231746971
        ],
        "B": [
            231748751,
            231750138,
            231749611,
            231749322,
            231755477,
            231750451,
            231753159,
            231749369,
            231750440,
            231749706,
            231748963,
            231754750,
            231753097,
            231749553,
            231754197,
            231749717,
            231750764,
            231754291
        ]
    },
    "name": "D. Neutral Tonality",
    "statement": "You are given an array a consisting of n integers, as well as an array b\r\nconsisting of m integers.Let\r\ntext{LIS}(c) denote the length of the longest increasing subsequence of\r\narray c. For example,\r\ntext{LIS}([2,\r\nunderline{1}, 1,\r\nunderline{3}]) = 2,\r\ntext{LIS}([\r\nunderline{1},\r\nunderline{7},\r\nunderline{9}]) = 3,\r\ntext{LIS}([3,\r\nunderline{1},\r\nunderline{2},\r\nunderline{4}]) = 3.You need to insert the numbers b_1, b_2,\r\nldots, b_m into the array a, at any positions, in any order. Let the\r\nresulting array be c_1, c_2,\r\nldots, c_{n+m}. You need to choose the positions for insertion in order\r\nto\r\ntext{LIS}(c).Formally, you need to find an array c_1, c_2,\r\nldots, c_{n+m} that simultaneously satisfies the following conditions:\r\nThe array a_1, a_2,\r\nldots, a_n is a subsequence of the array c_1, c_2,\r\nldots, c_{n+m}. The array c_1, c_2,\r\nldots, c_{n+m} consists of the numbers a_1, a_2,\r\nldots, a_n, b_1, b_2,\r\nldots, b_m, possibly rearranged. The value of\r\ntext{LIS}(c) is the possible among all suitable arrays c.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <functional>\n#include <iostream>\nusing namespace std;\n\nint n, m;\nint a[200010], b[200010];\n\nvoid solve() {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= m; i++) {\n        cin >> b[i];\n    }\n\n    sort(&b[1], &b[m] + 1, greater<int>{});\n    int cur = 1;\n    for (int i = 1; i <= n; i++) {\n        while (cur <= m && b[cur] >= a[i]) {\n            cout << b[cur] << ' ';\n            cur++;\n        }\n        cout << a[i] << ' ';\n    }\n    while (cur <= m) {\n        cout << b[cur] << ' ';\n        cur++;\n    }\n    cout << '\\n';\n}\n\nint main() {\n#ifdef ONLINE_JUDGE\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    int t;\n    cin >> t;\n    for (int i = 1; i <= t; i++) {\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Neutral Tonality.json",
    "editorial_link": "https://codeforces.com//blog/entry/122074",
    "editorial": "First observation: LIS(c)?LIS(a)\n. This is true because the array c\n will always contain a\n as a subsequence, and therefore any subsequence of a\n as well.\n\nNotice that it is always possible to achieve LIS(c)?LIS(a)+1\n. Let b1?\u0085?bm\n. This can be achieved by inserting b1,\u0085,bm\n in a non-increasing order at any positions in the array a\n, because in this case, any increasing subsequence of c\n can have at most one element from the array b\n, which means LIS(c)?LIS(a)+1\n.\n\nTherefore, we need to understand when we can achieve LIS(c)=LIS(a)\n. It turns out that this can always be achieved!\n\nLet's understand how to insert one number (x\n) into the array while preserving LIS(a)\n. If x<min(a1,\u0085,an)\n, then we insert x\n at the end of the array a\n, so that x\n cannot be present in any increasing subsequence of length at least 2\n, and LIS(a)\n will not increase. Otherwise, we can insert x\n before the first index i\n such that x?ai\n. Then, both x\n and ai\n cannot be present in the same increasing subsequence. However, in any increasing subsequence where x\n is present, we can replace x\n with ai\n and the subsequence will still remain increasing. Thus, LIS(a)\n will not increase.\n\nNow we can apply this solution m\n times, inserting the numbers b1?b2?\u0085?bm\n one by one. The final algorithm turns out to be surprisingly simple and similar to the merge(a, b) function. Specifically, iterate on arrays a\n and b\n with two pointers, at each step adding the larger of the two numbers (ai\n or bj\n) to the answer and moving the corresponding pointer."
}