{
    "link": "https://codeforces.com//contest/1686/problem/D",
    "problemId": "1410461",
    "problem_idx": "D",
    "shortId": "1686D",
    "contest_number": "1686",
    "problem_submissions": {
        "E": [
            158466498,
            158623961,
            158493366,
            158653522
        ],
        "D": [
            158444604,
            158453399,
            158441005,
            158438618,
            158439368,
            158439942,
            158445018,
            158445760,
            158448365,
            158448646,
            158449006,
            158469820,
            158446506,
            158447775,
            158452792,
            158451110,
            158442777,
            158454124,
            158449945
        ],
        "C": [
            158421583,
            158419071,
            158419875,
            158426051,
            158425982,
            158428799,
            158424090,
            158428548,
            158428460,
            158427814,
            158485768,
            158427612,
            158427723,
            158430277,
            158423379,
            158427100,
            158433344,
            158424816,
            158432867
        ],
        "B": [
            158414448,
            158465960,
            158415549,
            158416857,
            158416742,
            158416745,
            158416637,
            158415727,
            158418974,
            158421168,
            158416305,
            158416075,
            158419159,
            158417410,
            158421561,
            158416494,
            158417640,
            158416669
        ],
        "A": [
            158414054,
            158464909,
            158414306,
            158414224,
            158414816,
            158414086,
            158414216,
            158419141,
            158416490,
            158414220,
            158414605,
            158414130,
            158415003,
            158415457,
            158417192,
            158414417,
            158414385,
            158414321
        ],
        "F": [
            158464234
        ]
    },
    "name": "D. Linguistics",
    "statement": "Alina has discovered a weird language, which contains only 4 words:\r\ntexttt{A},\r\ntexttt{B},\r\ntexttt{AB},\r\ntexttt{BA}. It also turned out that there are no spaces in this\r\nlanguage: a sentence is written by just concatenating its words into a\r\nsingle string.Alina has found one such sentence s and she is curious: is\r\nit possible that it consists of precisely a words\r\ntexttt{A}, b words\r\ntexttt{B}, c words\r\ntexttt{AB}, and d words\r\ntexttt{BA}?In other words, determine, if it\u2019s possible to concatenate\r\nthese a+b+c+d words in some order so that the resulting string is s.\r\nEach of the a+b+c+d words must be used exactly once in the\r\nconcatenation, but you can choose the order in which they are\r\nconcatenated.\r\n",
    "solutions": [
        "/********************************************************************************************************************\n*                                                                                                                   *\n*   lmqzzz : ILS 21 - 24                                                                                            *\n*                                                                                                                   *\n*                                                                                                                   *\n*       lllllll                                                                                                     *\n*       l:::::l                                                                                                     *\n*       l:::::l                                                                                                     *\n*       l:::::l                                                                                                     *\n*        l::::l    mmmmmmm    mmmmmmm      qqqqqqqqq   qqqqqzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz    *\n*        l::::l  mm:::::::m  m:::::::mm   q:::::::::qqq::::qz:::::::::::::::zz:::::::::::::::zz:::::::::::::::z     *\n*        l::::l m::::::::::mm::::::::::m q:::::::::::::::::qz::::::::::::::z z::::::::::::::z z::::::::::::::z      *\n*        l::::l m::::::::::::::::::::::mq::::::qqqqq::::::qqzzzzzzzz::::::z  zzzzzzzz::::::z  zzzzzzzz::::::z       *\n*        l::::l m:::::mmm::::::mmm:::::mq:::::q     q:::::q       z::::::z         z::::::z         z::::::z        *\n*        l::::l m::::m   m::::m   m::::mq:::::q     q:::::q      z::::::z         z::::::z         z::::::z         *\n*        l::::l m::::m   m::::m   m::::mq:::::q     q:::::q     z::::::z         z::::::z         z::::::z          *\n*        l::::l m::::m   m::::m   m::::mq::::::q    q:::::q    z::::::z         z::::::z         z::::::z           *\n*       l::::::lm::::m   m::::m   m::::mq:::::::qqqqq:::::q   z::::::zzzzzzzz  z::::::zzzzzzzz  z::::::zzzzzzzz     *\n*       l::::::lm::::m   m::::m   m::::m q::::::::::::::::q  z::::::::::::::z z::::::::::::::z z::::::::::::::z     *\n*       l::::::lm::::m   m::::m   m::::m  qq::::::::::::::q z:::::::::::::::zz:::::::::::::::zz:::::::::::::::z     *\n*       llllllllmmmmmm   mmmmmm   mmmmmm    qqqqqqqq::::::qzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz     *\n*                                                   q:::::q                                                         *\n*                                                   q:::::q                                                         *\n*                                                  q:::::::q                                                        *\n*                                                  q:::::::q                                                        *\n*                                                  q:::::::q                                                        *\n*                                                  qqqqqqqqq                                                        *\n*                                                                                                                   *\n********************************************************************************************************************/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define          int    long long\n\n#define           fi    first\n#define           se    second\n#define           pb    push_back\n#define           ep    emplace\n#define           eb    emplace_back\n#define           lb    lower_bound\n#define           ub    upper_bound\n#define       all(x)    x.begin(), x.end()\n#define      rall(x)    x.rbegin(), x.rend()\n#define   uniquev(v)    v.resize(unique(all(v)) - v.begin())\n#define     mem(f,x)    memset(f , x , sizeof(f))\n#define        sz(x)    (int32_t)(x).size()\n#define   rep(i,a,b)    for(int i = a ; i <= b ; i++)\n#define  repp(i,a,b)    for(int i = a ; i < b ; i++)\n#define   per(i,a,b)    for(int i = a ; i >= b ; i--)\n#define  perr(i,a,b)    for(int i = a ; i > b ; i--)\n#define          mxx    *max_element\n#define          mnn    *min_element\n#define    cntbit(x)    __builtin_popcountll(x)\n#define      MASK(x)    ( 1ll << (x) )\n#define          Yes    cout << \"Yes\"\n#define          YES    cout << \"YES\"\n#define           No    cout << \"No\"\n#define           NO    cout << \"NO\"\n#define           AA    cout << \"Alice\"\n#define           BB    cout << \"Bob\"\n\ntemplate <typename T> inline void read (T &x) { bool b = 0; char c; while (!isdigit (c = getchar()) && c != '-'); if (c == '-') { c = getchar(); b = 1; } x = c - 48; while (isdigit(c = getchar())) {x = x * 10 + (c - 48); } if (b) { x=-x; } }\ntemplate <typename T> inline T min(const T &a, const T &b, const T &c) { return min(a, min(b, c)); }\ntemplate <typename T> inline T max(const T &a, const T &b, const T &c) { return max(a, max(b, c)); }\ntemplate <typename T, typename U> inline void mini(T &a, const U &b) { if(a > b) a = b; }\ntemplate <typename T, typename U> inline void maxi(T &a, const U &b) { if(a < b) a = b; }\n\ntypedef           long double    ld;\ntypedef             long long    ll;\ntypedef       const long long    cll;\ntypedef             const int    cint;\ntypedef        pair<int, int>    ii;\ntypedef  tuple<int, int, int>    iii;\ntypedef         pair<ii, int>    piii;\ntypedef         pair<int, ii>    ipii;\ntypedef         pair<ll, int>    li;\ntypedef          pair<ll, ll>    pll;\ntypedef           vector<int>    vi;\ntypedef            vector<ll>    vll;\ntypedef            vector<vi>    vvi;\ntypedef           vector<vll>    vvl;\ntypedef            vector<ii>    vii;\ntypedef           vector<iii>    viii;\ntypedef           vector<vii>    vvii;\ntypedef           vector<vii>    vvii;\ntypedef         array<int, 3>    ar3;\ntypedef         array<int, 4>    ar4;\ntypedef         array<int, 5>    ar5;\n\nconstexpr   long double PI  =  acos( -1 );\nconstexpr  long double eps  =  1e-9;\nconstexpr     int32_t base  =  277;\nconstexpr     int16_t dr[]  =  {1, 0, -1, 0};\nconstexpr     int16_t dc[]  =  {0, -1, 0, 1};\nconstexpr      int64_t MOD  =  1e9 + 7;\nconstexpr     int32_t MAXN  =  1e6 + 10;\n\nint a[MAXN];\nint b[MAXN];\n\nvoid solve()\n{\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    string s;\n    cin >> s;\n    s = '_' + s;\n    int cnt[2] = {0,0};\n    int n = sz(s) - 1;\n    rep(i, 1, n) cnt[s[i] - 'A']++;\n    if(cnt[0] != a + c + d || cnt[1] != b + c + d)\n    {\n        NO;\n        return;\n    }\n    vii v;\n    int last = 1;\n    rep(i, 2, n) if(s[i] == s[i - 1]) v.eb(i - last, s[i] - 'A'), last = i;\n    v.eb(n - last + 1, s[n] - 'A');\n    sort(all(v));\n    int mxc = 0, mxd = 0;\n    vii vv;\n    int add = 0;\n    priority_queue<int>st[2];\n    for(auto [length, last] : v)\n    {\n        if(length == 1)\n            continue;\n        if(length == 2)\n        {\n            if(last == 1)\n                c --;\n            else d --;\n        }\n        else if(length & 1)\n        {\n            add += length / 2;\n        }\n        else\n        {\n            if(last)\n                c -= length / 2;\n            else d -= length / 2;\n            st[last].ep(length);\n        }\n    }\n//    cout << c << ' ' << d;\n    if(max(0ll, d) + max(0ll, c) - add > 0)\n    {\n        if(d >= 0 && c >= 0)\n        {\n            NO;\n            return;\n        }\n        if(d < 0)\n        {\n            while(sz(st[0]) && d < 0)\n            {\n                int length = st[0].top();\n                st[0].pop();\n                int mx = abs(d);\n                mx *= 2;\n                int nlength = max(0ll, length - mx);\n                d += (length - nlength) / 2;\n                c -= (length - nlength) / 2 - 1;\n                if(nlength)\n                    st[0].push(nlength);\n                if(max(0ll, d) + max(0ll, c) - add <= 0)\n                {\n                    YES;\n                    return;\n                }\n            }\n        }\n        else if(c < 0)\n        {\n//            cout << '!';\n            while(sz(st[1]) && c < 0)\n            {\n                int length = st[1].top();\n                st[1].pop();\n                int mx = abs(c);\n                mx *= 2;\n                int nlength = max(0ll, length - mx);\n                c += (length - nlength) / 2;\n                d -= (length - nlength) / 2 - 1;\n//                cout << c << ' ' << d;\n                if(nlength)\n                    st[1].push(nlength);\n\n                if(max(0ll, d) + max(0ll, c) - add <= 0)\n                {\n                    YES;\n                    return;\n                }\n            }\n        }\n//        cout << '!';\n        NO;\n        return;\n    }\n    else YES;\n}\nvoid init()\n{\n\n}\n\n/// TASK\n/// -----------------------------\n#define TASK \"C\"\n///------------------------------\n\nvoid gentest()\n{\n    if (fopen(TASK \".inp\", \"r\"))\n        freopen(TASK \".inp\",\"w\",stdout);\n    srand(time(0));\n//    int n = 0;\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    if (fopen(TASK \".inp\", \"r\")) {\n        freopen(TASK \".inp\", \"r\", stdin);\n        freopen(TASK \".out\", \"w\", stdout);\n    }\n//    gentest();\n//    return 0;\n//    init();\n    int32_t TT = 1;\n    cin >> TT;\n    for(int32_t TTT = 1 ; TTT <= TT ; TTT++)\n    {\n        solve();\n        cout << '\\n';\n    }\n\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "sortings",
        "strings",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Linguistics.json",
    "editorial_link": "https://codeforces.com//blog/entry/103198",
    "editorial": "For the answer to be YES\n the frequency of the character A\n in the a+b+c+d\n words must coincide with its frequency in the sentence s\n, which is equivalent to the condition a+c+d=#{i:si=A}\n. From now on we may assume that this is true.\n\nNotice that the answer to the problem is YES\n if and only if it is possible to tile the string s\n with c\n copies of AB\n and d\n copies of BA\n so that all the c+d\n substrings are disjoint. Indeed one can simply fill the remaining characters of s\n with the a\n copies of A\n and the b\n copies of B\n (we are sure that the number of characters A\n and B\n is correct because of the initial check). Moreover, if si=si+1\n, then clearly any tiling with AB\n and BA\n of s\n cannot cover with a single tile both si\n and si+1\n; therefore we can split the string s\n between si\n and si+1\n and try to tile the two resulting substrings. By repeating this argument we will end up with many alternating strings (a string t\n is alternating if ti?ti+1\n for all 1?i<|t|\n). So, we have reduced the problem to the following one:\n\nSubproblem: You are given many alternating strings, can you find in these strings c\n substrings equal to AB\n and d\n subtrings equal to BA\n such that all the c+d\n substrings are disjoint?\n\nIn order to solve the problem let us analyze what happens when only one alternating string is present. Given an alternating string t\n, we say that the pair (x,y)\n is valid if we can find in t\n x\n substrings equal to AB\n and y\n substrings equal to BA\n so that the x+y\n substrings are disjoint. Let us consider various cases:\n\nIf |t|=2k+1\n, then (x,y)\n is valid if and only if x+y?k\n. Let f(k):={(x,y):0?x,y and x+y?k}\n.\nIf |t|=2k\n and t1=A\n, then (x,y)\n is valid if and only if x+y?k?1\n or (x,y)=(k,0)\n. Let fAB(k):={(k,0)}?f(k?1)\n.\nIf |t|=2k\n and t1=B\n, then (x,y)\n is valid if and only if x+y?k?1\n or (x,y)=(0,k)\n. Let fBA(k):={(0,k)}?f(k?1)\n.\nLoosely speaking, the alternating strings of type 2. and 3. have a bonus if they are tiled only with one of the strings AB\n and BA\n.\nWe will provide a proof for the correcteness of the following greedy algorithm.\n\nGreedy algorithm: Sort the strings of type 2\n by length and fill them, starting from the shortest, only with AB\n (i.e., find as many disjoint copies of AB\n as possible) until you reach c\n or you finish them (a string of length 2k\n is filled with k\n AB\n). Do the same for the strings of type 3\n for the word BA\n. At this point there are no more bonuses to use and you can just fill the remaining strings with AB\n and BA\n in the only reasonable way. If in the end, if you have found c\n strings AB\n and d\n strings BA\n then the answer is YES\n, otherwise it is NO\n.\n\nLet us provide a proof of the correctness of this algorithm. Let us remark that the proof of the correctness is in fact rather easy, but a bit cumbersome to write down. The strategy of the proof is to start from a solution and to show that the one constructed by the greedy algorithm is \"better\".\n\nProof of the correctness of the greedy algorithm: Let U,V,W\n be the multisets of lengths of strings of the first, second and third type respectively (according to the case division above). Then the problem is equivalent to understanding if\n(c,d)??u?Uf(u)+?v?VfAB(v)+?w?WfBA(w).\n\nAssume that the answer is YES\n and consider a solution of the problem, i.e. a choice of a valid pair for each of the |U|+|V|+|W|\n alternating strings. Let V=V??V??\n where V?\n corresponds to the lengths of the strings in V\n where the valid pair of the solution is given by (k,0)\n (k\n is the length of the string). Partition W=W??W??\n analogously. Then we have\n(c,d)??u?Uf(u)+?v??V?(v?,0)+?v???V??f(v???1)+?w??W?(0,w?)+?w???W??f(w???1).\n\nLet us make a couple of observations:\n\nFor any k1,k2\n it holds f(k1)+f(k2)=f(k1+k2)\n.\nIf k1?k2\n, then f(k1)+(k2,0)?(k1,0)+f(k2)\n and also f(k1)+(0,k2)?(0,k1)+f(k2)\n.\nThanks to the second observation we know that we may assume (up to changing the solution to a better one) that V?\n contains the smaller elements of V\n (i.e., v??v??\n for each v??V?,v???V??\n), and W?\n contains the smaller elements of W\n. Then, applying the first observation, we reduce the problem to understanding if there is prefix V?\n of V\n (prefix in the sorted by length order) and a prefix W?\n of W\n such that\n(c,d)?f(?u?Uk+?v???V?V?(v???1)+?w???W?W?(w???1))+(?v??V?v?,0)+(0,?w??W?w?).(?)\nIt remains to show that we may assume that V?\n is the largest prefix so that ?V?:=?v??V?v??c\n (and the analogous result for W?\n) as this implies the correctness of the greedy algorithm (i.e., if there is a valid solution then the one constructed by the algorithm is a solution). Assume, by contradiction, that there is v???V?\n such that v??+?V??c\n. By (?)\n we know\n(c??V?,d??W?)?f(s),\nwhere s=?u?Uk+?v???V?V?(v???1)+?w???W?W?(w???1)\n. Thus, we deduce\n(c?(?V?+v??),d??W?)?f(s?(v???1)),\nwhich is equivalent to saying that (?\n) holds also if we replace V?\n with V??{v??}\n which is exactly what we wanted to prove"
}