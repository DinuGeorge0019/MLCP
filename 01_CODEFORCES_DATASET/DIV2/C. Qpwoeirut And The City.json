{
    "link": "https://codeforces.com//contest/1706/problem/C",
    "problemId": "1466353",
    "problem_idx": "C",
    "shortId": "1706C",
    "contest_number": "1706",
    "problem_submissions": {
        "D2": [
            164755947,
            164771403,
            164762268,
            164830322,
            164783821,
            164762155,
            164763660,
            167727726,
            164763512,
            164771385,
            164768987,
            164786591,
            165109549,
            164774482,
            164772244,
            164787948,
            164789501,
            164767866,
            164774049,
            164768972,
            164786019,
            164781366
        ],
        "D1": [
            164755812,
            164767814,
            164760721,
            164830311,
            164764715,
            164761873,
            164763978,
            167106725,
            164760911,
            164771592,
            164764309,
            164755426,
            164758751,
            164758461,
            164759026,
            164768432,
            164762506,
            164771653,
            164768895,
            164754659,
            164780135
        ],
        "E": [
            164750123,
            164754977,
            164771776,
            164830331,
            164760396,
            164775552,
            164750599,
            167106869,
            164780737,
            164776992,
            164776365,
            164769697,
            165109519,
            164782832,
            164784446,
            164777832,
            164745185,
            164783769,
            164782907,
            164785318,
            164774423,
            164765688
        ],
        "C": [
            164743602,
            164744687,
            164740571,
            164830300,
            164745917,
            164752415,
            164768743,
            167106646,
            167106607,
            164749531,
            164746963,
            164750898,
            164748957,
            164751304,
            164751822,
            164752230,
            164762906,
            164749665,
            164747043,
            164749516,
            164747945,
            164752780
        ],
        "B": [
            164740418,
            164739248,
            164748883,
            164830286,
            164740306,
            164748574,
            164773017,
            167106480,
            164740862,
            164740238,
            164743331,
            164741485,
            164741615,
            164739143,
            164740378,
            164753096,
            164741049,
            164740372,
            164742312,
            164741022,
            164745456
        ],
        "A": [
            164734517,
            164734482,
            164750605,
            164830274,
            164734645,
            164734321,
            164774887,
            167106382,
            164735301,
            164734871,
            164734669,
            164735191,
            164734536,
            164734449,
            164734493,
            164748128,
            164735346,
            164734733,
            164735598,
            164734982,
            164735759
        ]
    },
    "name": "C. Qpwoeirut And The City",
    "statement": "Qpwoeirutâ€™s city can be described as a row of n buildings, the i-th (1\r\nle i\r\nle n) of which is h_i floors high. You can assume that the height of\r\nevery floor in this problem is equal. Therefore, building i is taller\r\nthan the building j if and only if the number of floors h_i in building\r\ni is larger than the number of floors h_j in building j.Building i is if\r\nit is taller than both building i-1 and building i+1 (and both of them\r\nexist). Note that neither the 1-st nor the n-th building can be cool.To\r\nremodel the city, Qpwoeirut needs to maximize the number of cool\r\nbuildings. To do this, Qpwoeirut can build additional floors on top of\r\nany of the buildings to make them taller. Note that he cannot remove\r\nalready existing floors.Since building new floors is expensive,\r\nQpwoeirut wants to minimize the number of floors he builds. Find the\r\nminimum number of floors Qpwoeirut needs to build in order to maximize\r\nthe number of cool buildings.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < '-')\n\t\t;\n\tif (c == '-') {\n\t\tint x = gc - '0';\n\t\twhile (gc >= '0') x = x * 10 + c - '0';\n\t\treturn -x;\n\t}\n\tint x = c - '0';\n\twhile (gc >= '0') x = x * 10 + c - '0';\n\treturn x;\n}\n#undef gc\n\nconst int N = 1e5 + 5;\n\nint a[N], val[N];\nint T, n;\n\nint main() {\n#ifdef local\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\trep(i, 1, n) a[i] = read();\n\t\trep(i, 2, n - 1) val[i] = max(0, max(a[i - 1], a[i + 1]) - a[i] + 1);\n\t\tif (n % 2 == 1) {\n\t\t\tlong long ans = 0;\n\t\t\tfor (int i = 2; i <= n - 1; i += 2) {\n\t\t\t\tans += val[i];\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\t} else {\n\t\t\tlong long ans = 1e18, sum = 0;\n\t\t\tfor (int i = 3; i <= n - 1; i += 2) {\n\t\t\t\tsum += val[i];\n\t\t\t}\n\t\t\tans = sum;\n\t\t\tfor (int i = 2; i <= n - 2; i += 2) {\n\t\t\t\tsum += val[i];\n\t\t\t\tsum -= val[i + 1];\n\t\t\t\tans = min(ans, sum);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "flows",
        "greedy",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Qpwoeirut And The City.json",
    "editorial_link": "https://codeforces.com//blog/entry/105008",
    "editorial": "The first observation to be made is that no two adjacent building can\r\nboth be cool at the same time. This means that, for odd , there must be\r\ncool buildings arranged in the following configuration... For even ,\r\nthere must be cool buildings. This means that exactly one pair of\r\nadjacent buildings in the city is normal, meaning that the buildings\r\nmust be arranged in one of the following configurations... For odd , the\r\nsolution is relatively simple. Just find the total floors necessary to\r\nmake each of the alternating buildings (starting from the 2nd building)\r\ncool and that is the answer.For even , the solution is more complex.\r\nFirst, find the number of floors necessary to get to the first of the\r\nconfigurations shown above. Then, loop through each of the subsequent\r\nconfigurations, each time using the previous configuration to get the\r\nnumber of floors necessary for the new configuration in time. This\r\nenables a solution in time.For example, in the 4th test case from the\r\nexample in the problem statement, the possible configurations of cool\r\nbuildings are... The number of floors necessary to reach each of these\r\nconfigurations are... 1st configuration: (5 - 2) + (6 - 3) + (7 - 3) = .\r\n2nd configuration: - (7 - 3) + (6 - 6) = . 3rd configuration: - (6 -\r\n3) + (5 - 5) = . 4th configuration: - (5 - 2) + (4 - 1) = . The answer\r\nis the minimum of these values, which is .For even , the floors\r\nnecessary for every configuration can also be found in time using an\r\nalternating forward prefix sum array and an alternating backward prefix\r\nsum array.\r\n",
    "hint": []
}