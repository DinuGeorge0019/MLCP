{
    "link": "https://codeforces.com//contest/1794/problem/A",
    "problemId": "1808455",
    "problem_idx": "A",
    "shortId": "1794A",
    "contest_number": "1794",
    "problem_submissions": {
        "E": [
            196467319,
            196091024,
            196065447,
            196027516,
            196045507,
            196044539,
            196049784,
            196043653,
            196050334,
            196053527,
            196054181,
            196051837,
            196052921,
            196053608,
            196051434,
            196129108,
            196055320,
            196058590,
            196049523,
            196042891,
            196053778,
            196054545,
            196037576,
            196074501,
            196074391
        ],
        "D": [
            196083505,
            196016109,
            196024909,
            196024858,
            196021434,
            196025217,
            196028904,
            196025001,
            196032867,
            196029336,
            196033933,
            196031399,
            196038559,
            196037652,
            196048488,
            196050480,
            196036074,
            196036926,
            208633215,
            196022650
        ],
        "C": [
            196008950,
            196011685,
            196013987,
            196009207,
            196010114,
            196018308,
            196011596,
            196011705,
            196015187,
            196016689,
            196011713,
            196018563,
            196020776,
            196010830,
            196012003,
            196018106,
            196018224,
            196016136,
            196008531
        ],
        "B": [
            196004154,
            196004594,
            196009639,
            196005082,
            196031084,
            196004622,
            196004148,
            196006017,
            196007935,
            196006213,
            196009047,
            196004027,
            196017820,
            196010698,
            196013843,
            196006494,
            196003310,
            196003871
        ],
        "A": [
            196003031,
            196003363,
            196007521,
            196004024,
            196002777,
            196003379,
            196002990,
            196004171,
            196003805,
            196004167,
            196007050,
            196002947,
            196003739,
            196007194,
            196008753,
            196020821,
            196002700,
            196002959
        ]
    },
    "name": "A. Prefix and Suffix Array",
    "statement": "Marcos loves strings a lot, so he has a favorite string s consisting of\r\nlowercase English letters. For this string, he wrote down all its\r\nnon-empty prefixes and suffixes (except for s) on a piece of paper in\r\narbitrary order. You see all these strings and wonder if Marcosâ€™\r\nfavorite string is a palindrome or not. So, your task is to decide\r\nwhether s is a palindrome by just looking at the piece of paper.A string\r\na is a prefix of a string b if a can be obtained from b by deletion of\r\nseveral (possibly, zero or all) characters from the end.A string a is a\r\nsuffix of a string b if a can be obtained from b by deletion of several\r\n(possibly, zero or all) characters from the beginning.A palindrome is a\r\nstring that reads the same backward as forward, for example, strings \"\",\r\n\"\", \"\", \"\" are palindromes, but strings \"\", \"\", \"\" are not.\r\n",
    "solutions": [
        "#include <iostream>\nusing namespace std;\n\ntemplate <typename Int = int>\nInt read() {\n  Int s = 1, x = 0;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-')\n      s = -1;\n    c = getchar();\n  }\n  while (isdigit(c))\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return s * x;\n}\n\nstring read_s() {\n  string s;\n  char c = getchar();\n  while (isspace(c))\n    c = getchar();\n  while (c != EOF && !isspace(c))\n    s += c, c = getchar();\n  return s;\n}\n\nint main() {\n  int t = read();\n  while (t--) {\n    int n = read();\n    string s, t;\n    for (int i = 0; i < n * 2 - 2; i++) {\n      string u = read_s();\n      if ((int) u.size() == n - 1) {\n        if (s.empty())\n          s = u;\n        else\n          t = u;\n      }\n    }\n    if (s.substr(1, n - 2) == t.substr(0, n - 2))\n      s += t.back();\n    else {\n      t += s.back();\n      swap(s, t);\n    }\n    bool ok = 1;\n    for (int i = 0; i < (int) s.size() / 2; i++)\n      ok &= s[i] == s[n - i - 1];\n    printf(ok ? \"YES\\n\" : \"NO\\n\");\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "strings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Prefix and Suffix Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/113500",
    "editorial": "Observe that there are exactly two strings of length (one prefix and one\r\nsuffix). We will call them and . Then, is a palindrome if and only if ,\r\nwhere is the reversal of string .So, to solve the problem it is enough\r\nto find the two strings of length and check if one of them is equal to\r\nthe reversal of the other. This solution also works for any length\r\ngreater or equal to .Intended complexity: per test case. (reading the\r\ninput)\r\n",
    "hint": []
}