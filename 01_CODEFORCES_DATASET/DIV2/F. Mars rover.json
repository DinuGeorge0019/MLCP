{
    "link": "https://codeforces.com//contest/1011/problem/F",
    "problemId": "201801",
    "problem_idx": "F",
    "shortId": "1011F",
    "contest_number": "1011",
    "problem_submissions": {
        "F": [
            40800201,
            40801277,
            40801569,
            40804449,
            40805451,
            40806381,
            40806507,
            40806310,
            40805970,
            40801054,
            40808416,
            40809060,
            40810276,
            40808095,
            40807771,
            40805521,
            40807827,
            40807284,
            40807855,
            40804155
        ],
        "D": [
            40796440,
            40794546,
            40792902,
            40795417,
            40799478,
            40795262,
            40794405,
            40796227,
            40796647,
            40805819,
            40795341,
            40796956,
            40801974,
            40796562,
            40798015,
            40809194,
            40797770,
            40797730,
            40793882,
            40809940
        ],
        "E": [
            40792792,
            40796201,
            40795409,
            40798197,
            40794994,
            40796957,
            40798403,
            40799143,
            40799952,
            40795325,
            40797016,
            40792367,
            40793560,
            40799595,
            40800280,
            40796773,
            40803072,
            40801776,
            40801515,
            40795493
        ],
        "C": [
            40790603,
            40791320,
            40791211,
            40789571,
            40790418,
            40791673,
            40790329,
            40790847,
            40793263,
            40794440,
            40790415,
            40800020,
            40790652,
            40792667,
            40793177,
            40791559,
            40792533,
            40792592,
            40791239,
            40793128
        ],
        "B": [
            40785822,
            40786932,
            40787686,
            40786118,
            40785902,
            40788647,
            40785329,
            40786729,
            40785415,
            40788241,
            40792014,
            40785807,
            40787536,
            40787785,
            40787832,
            40786142,
            40787154,
            40790376,
            40787972,
            40786283
        ],
        "A": [
            40783703,
            40785050,
            40784061,
            40783967,
            40783664,
            40784798,
            40783422,
            40784073,
            40783746,
            40785817,
            40785710,
            40783675,
            40784732,
            40784635,
            40786064,
            40783474,
            40783765,
            40785159,
            40784090,
            40783568
        ]
    },
    "name": "F. Mars rover",
    "statement": "Natasha travels around Mars in the Mars rover. But suddenly it broke\r\ndown, namely the logical scheme inside it. The scheme is an undirected\r\ntree (connected acyclic graph) with a root in the vertex 1, in which\r\nevery leaf (excluding root) is an input, and all other vertices are\r\nlogical elements, including the root, which is output. One bit is fed to\r\neach input. One bit is returned at the output.There are four types of\r\nlogical elements: AND (2 inputs), OR (2 inputs), XOR (2 inputs), NOT (1\r\ninput). Logical elements take values from their direct descendants\r\n(inputs) and return the result of the function they perform. Natasha\r\nknows the logical scheme of the Mars rover, as well as the fact that\r\nonly one input is broken. In order to fix the Mars rover, she needs to\r\nchange the value on this input.For each input, determine what the output\r\nwill be if Natasha changes this input.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#define eps 1e-8\n\nusing namespace std;\n\nint son[1000005][2],kind[1000005],num[1000005];\nbool f[1000005],g[1000005][2];\n\nvoid dfs1(int x) {\n  if (kind[x]==1) {\n  \tdfs1(son[x][0]);\n  \tdfs1(son[x][1]);\n  \tf[x]=f[son[x][0]]&f[son[x][1]];\n  }\n  if (kind[x]==2) {\n  \tdfs1(son[x][0]);\n  \tdfs1(son[x][1]);\n  \tf[x]=f[son[x][0]]|f[son[x][1]];\n  }\n  if (kind[x]==3) {\n  \tdfs1(son[x][0]);\n  \tdfs1(son[x][1]);\n  \tf[x]=f[son[x][0]]^f[son[x][1]];\n  }\n  if (kind[x]==4) {\n  \tdfs1(son[x][0]);\n  \tf[x]=!f[son[x][0]];\n  }\n  if (kind[x]==5) f[x]=num[x];\n}\n\nvoid dfs2(int x) {\n  if (kind[x]==1) {\n  \tg[son[x][0]][0]=g[x][0&f[son[x][1]]];\n  \tg[son[x][0]][1]=g[x][1&f[son[x][1]]];\n  \tg[son[x][1]][0]=g[x][0&f[son[x][0]]];\n  \tg[son[x][1]][1]=g[x][1&f[son[x][0]]];\n  \tdfs2(son[x][0]);\n  \tdfs2(son[x][1]);\n  }\n  if (kind[x]==2) {\n  \tg[son[x][0]][0]=g[x][0|f[son[x][1]]];\n  \tg[son[x][0]][1]=g[x][1|f[son[x][1]]];\n  \tg[son[x][1]][0]=g[x][0|f[son[x][0]]];\n  \tg[son[x][1]][1]=g[x][1|f[son[x][0]]];\n  \tdfs2(son[x][0]);\n  \tdfs2(son[x][1]);\n  }\n  if (kind[x]==3) {\n  \tg[son[x][0]][0]=g[x][0^f[son[x][1]]];\n  \tg[son[x][0]][1]=g[x][1^f[son[x][1]]];\n  \tg[son[x][1]][0]=g[x][0^f[son[x][0]]];\n  \tg[son[x][1]][1]=g[x][1^f[son[x][0]]];\n  \tdfs2(son[x][0]);\n  \tdfs2(son[x][1]);\n  }\n  if (kind[x]==4) {\n  \tg[son[x][0]][0]=g[x][1];\n  \tg[son[x][0]][1]=g[x][0];\n  \tdfs2(son[x][0]);\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) {\n  \tchar str[5];\n  \tscanf(\"%s\",str);\n  \tif (str[0]=='A') {\n  \t\tkind[i]=1;\n  \t\tscanf(\"%d%d\",&son[i][0],&son[i][1]);\n\t  }\n  \tif (str[0]=='O') {\n  \t\tkind[i]=2;\n  \t\tscanf(\"%d%d\",&son[i][0],&son[i][1]);\n\t  }\n\tif (str[0]=='X') {\n  \t\tkind[i]=3;\n  \t\tscanf(\"%d%d\",&son[i][0],&son[i][1]);\n\t  }\n\tif (str[0]=='N') {\n  \t\tkind[i]=4;\n  \t\tscanf(\"%d\",&son[i][0]);\n\t  }\n\tif (str[0]=='I') {\n  \t\tkind[i]=5;\n  \t\tscanf(\"%d\",&num[i]);\n\t  }\n  }\n  dfs1(1);\n  g[1][0]=0;g[1][1]=1;\n  dfs2(1);\n  for(int i=1;i<=n;i++)\n    if (kind[i]==5) putchar('0'+g[i][num[i]^1]);\n  putchar('\\n');\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Mars rover.json",
    "editorial_link": "https://codeforces.com/blog/entry/60851",
    "editorial": "Let\u00e2\u0080\u0099s count the bit at each vertex. This can be done using depth-first\r\nsearch on this tree. Now for each vertex, let\u00e2\u0080\u0099s check: whether the bit\r\non the output of the scheme will change if the bit in the current vertex\r\nis changed. If all the vertices on the path from this vertex to the\r\noutput of the scheme. If at least one of them does not change, then the\r\noutput of the scheme does not change, and vice versa: if the output of\r\nthe scheme is changed, then each vertex on the path under consideration\r\nwill change. Now the solution can be implemented as follows. For each\r\nvertex, let\u00e2\u0080\u0099s make a note: whether the bit on the output of the scheme\r\nwill be changed if the bit on the current vertex is changed. For output\r\nof the scheme, this note is . Now let\u00e2\u0080\u0099s do the depth-first search on\r\nthis tree. If note at the current vertex is equal to , then at the\r\ninputs to it we make the note equal , otherwise, for each input to this\r\nvertex, we do the following. Let\u00e2\u0080\u0099s see if the current vertex is changed\r\nif the current input is changed. If it is changed, then at this input we\r\nwill make the note equal , otherwise .Complexity: .\r\n"
}