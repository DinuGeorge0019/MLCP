{"link": "https://codeforces.com//contest/31/problem/E", "problemId": "148", "problem_idx": "E", "shortId": "31E", "contest_number": "31", "problem_submissions": {"E": [134876, 134644, 134848, 134248, 135579], "D": [134485, 133596, 134295, 134196, 134946, 134425, 134440, 134597, 134581, 134770, 134731, 134788, 134711, 135223, 134329, 136009, 136008, 135064], "C": [134168, 134002, 133803, 133545, 134363, 133957, 133783, 133977, 134075, 133915, 134271, 134272, 134280, 134218, 133534, 134400], "B": [133252, 133258, 133180, 135478, 133631, 133324, 133519, 133415, 134235, 133789, 133861, 134099, 133348, 133444], "A": [132701, 132899, 132718, 132766, 132790, 133118, 132713, 132712, 132770, 953988, 757270, 132738, 133121, 133401, 133529, 132807, 132719, 132830]}, "name": "E. TV Game", "statement": "There is a new TV game on BerTV. In this game two players get a number\r\nconsisting of digits. Before each turn players determine who will make\r\nthe next move. Each player should make exactly moves. On it\u2019s turn -th\r\nplayer takes the leftmost digit of and appends it to his or her number .\r\nAfter that this leftmost digit is erased from . Initially the numbers of\r\nboth players ( and ) are empty . Leading zeroes in numbers are allowed.\r\nIn the end of the game the first player gets dollars, and the second\r\ngets dollars.One day Homer and Marge came to play the game. They managed\r\nto know the number beforehand. They want to find such sequence of their\r\nmoves that both of them makes exactly moves and which maximizes their\r\ntotal prize. Help them.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 32 + 1;\nconst int MAXL = 64 + 1;\n\nint n;\nbool path[MAXN][MAXN];\nlong long dp[MAXN][MAXN], pow[MAXN];\nchar num[MAXL], ans[MAXL];\n\nint main() {\n\tpow[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) pow[i] = pow[i - 1] * 10;\n\tmemset(dp, 0xFF, sizeof(dp));\n\tscanf(\"%d%s\", &n, num);\n\tdp[n][n] = 0;\n\tfor (int o = 0; o < n << 1; o++) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint j = (n << 1) - o - i;\n\t\t\tif (j < 0 || j > n) continue;\n//printf(\"o = %d i = %d j = %d\\n\", o, i, j);\n\t\t\t// H\n\t\t\tif (i && dp[i - 1][j] < dp[i][j] + (num[o] - '0') * pow[i - 1]) {\n\t\t\t\tdp[i - 1][j] = dp[i][j] + (num[o] - '0') * pow[i - 1];\n\t\t\t\tpath[i - 1][j] = true;\n\t\t\t}\n\t\t\t// M\n\t\t\tif (j && dp[i][j - 1] < dp[i][j] + (num[o] - '0') * pow[j - 1]) {\n\t\t\t\tdp[i][j - 1] = dp[i][j] + (num[o] - '0') * pow[j - 1];\n\t\t\t\tpath[i][j - 1] = false;\n\t\t\t}\n\t\t}\n\t}\n/*for (int i = 0; i <= n; i++) {\n\tfor (int j = 0; j <= n; j++) {\n\t\tprintf(\"%d \", path[i][j]);\n\t}\n\tputchar('\\n');\n}\nputs(\"\");\nfor (int i = 0; i <= n; i++) {\n\tfor (int j = 0; j <= n; j++) {\n\t\tprintf(\"%lld \", dp[i][j]);\n\t}\n\tputchar('\\n');\n}*/\n\tans[n << 1] = '\\0';\n\tint x = 0, y = 0;\n\twhile (x != n || y != n) {\n\t\tif (path[x][y]) {\n\t\t\tans[(n << 1) - x - y - 1] = 'H';\n\t\t\tx++;\n\t\t} else {\n\t\t\tans[(n << 1) - x - y - 1] = 'M';\n\t\t\ty++;\n\t\t}\n\t}\n\tputs(ans);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2400", "interactive": false}