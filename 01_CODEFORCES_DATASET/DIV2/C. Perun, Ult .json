{
    "link": "https://codeforces.com//contest/912/problem/C",
    "problemId": "144441",
    "problem_idx": "C",
    "shortId": "912C",
    "contest_number": "912",
    "problem_submissions": {
        "C": [
            33939960,
            33939332
        ],
        "E": [
            33937258,
            33933701,
            33945198,
            33942310,
            33943413,
            33944965,
            33944500,
            33944708,
            33947180,
            33947146,
            76791617,
            33941858,
            33941491
        ],
        "D": [
            33929983,
            33936192,
            33941962,
            33932459,
            33932813,
            33939373,
            33937374,
            33934352,
            33940764,
            33937493,
            33943638,
            33931105,
            33939804,
            33934462,
            33942378,
            33953796,
            33937778,
            33936199
        ],
        "B": [
            33924135,
            33925821,
            33925186,
            33924566,
            33925991,
            33928269,
            33929796,
            33936643,
            33929453,
            33927572,
            33926977,
            33926561,
            33926317,
            33935518,
            33928188,
            33928933,
            33930630,
            33931743
        ],
        "A": [
            33923797,
            33924106,
            33923840,
            33926847,
            33924254,
            33926307,
            33927750,
            33935324,
            33926290,
            33928561,
            33923877,
            33925336,
            33924071,
            33924047,
            33923947,
            33924293,
            33926054,
            33925244,
            33930321
        ]
    },
    "name": "C. Perun, Ult ",
    "statement": "A lot of students spend their winter holidays productively. Vlad has\r\nadvanced very well in doing so! For three days already, fueled by salads\r\nand tangerines the leftovers from New Year celebration he has been\r\ncalibrating his rating in his favorite MOBA game, playing as a hero\r\nnamed Perun.Perun has an ultimate ability called \"Thunderwrath\". At the\r\ninstant of its activation, each enemy on the map ( of them in total)\r\nloses health points as a single-time effect. It also has a restriction:\r\nit can only activated when the moment of time is an . The initial bounty\r\nfor killing an enemy is . Additionally, it increases by each second.\r\nFormally, if at some second the ability is activated and the -th enemy\r\nis killed as a result (i.e. his health drops to zero or lower), Vlad\r\nearns units of gold.Every enemy can receive damage, as well as be\r\nhealed. There are multiple ways of doing so, but Vlad is not interested\r\nin details. For each of enemies he knows: maximum number of health\r\npoints for the -th enemy; initial health of the enemy (on the -th\r\nsecond); the amount of health the -th enemy can regenerate per second.\r\nThere also health updates Vlad knows about: time when the health was\r\nupdated; the enemy whose health was updated; updated health points for .\r\nObviously, Vlad wants to maximize his profit. If it’s necessary, he\r\ncould even wait for years to activate his ability at the right second.\r\nHelp him determine the exact second (note that it must be ) from\r\n(inclusively) to so that a single activation of the ability would yield\r\nVlad the maximum possible amount of gold, and print this amount.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define pii pair<int,int>\nusing namespace std;\nint n, m, AA, inc, K, INF = 2e9;\nstruct point {\n\tint M, R;\n\tvector<pii>T;\n}w[101000];\nmap<int, int>B;\nint main() {\n\tint i, h, t, a, j;\n\tscanf(\"%d%d%d%d%d\", &n,&m,&AA,&inc,&K);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d%d\", &w[i].M, &h, &w[i].R);\n\t\tw[i].T.push_back({ 0, h });\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d\", &t, &a, &h);\n\t\tw[a].T.push_back({ t,h });\n\t}\n\tint ck = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tsort(w[i].T.begin(), w[i].T.end());\n\t\tif (w[i].M <= K && inc) {\n\t\t\tck = 1;\n\t\t}\n\t\tif (w[i].T.back().second <= K && w[i].R == 0 && inc) {\n\t\t\tck = 1;\n\t\t}\n\t\tw[i].T.push_back({ INF,0 });\n\t\tfor (j = 0; j < w[i].T.size() - 1; j++) {\n\t\t\tpii tp = w[i].T[j];\n\t\t\tint t1 = tp.first, hh = tp.second;\n\t\t\tint t2 = w[i].T[j + 1].first;\n\t\t\tif (hh > K)continue;\n\t\t\tif (w[i].R == 0 || w[i].M <= K) {\n\t\t\t\tB[t1]++;\n\t\t\t\tB[t2]--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tt = (K - hh) / w[i].R;\n\t\t\t\tB[t1]++;\n\t\t\t\tB[min(t2, t1 + tt + 1)]--;\n\t\t\t}\n\t\t}\n\t}\n\tif (ck) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint s = 0;\n\tlong long r = 0;\n\tfor (auto &tp : B){\n\t\tlong long t = 1ll*s*AA + 1ll*s*inc*(tp.first - 1);\n\t\tr = max(r, t);\n\t\ts += tp.second;\n\t}\n\tprintf(\"%lld\\n\", r);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Perun, Ult .json",
    "editorial_link": "https://codeforces.com//blog/entry/56920",
    "editorial": "The statement almost directly states the formula for the answer it is\r\ncalculated as , where is amount of enemies we can kill at -th second.\r\nThus, we need to learn how to calculate and find such values of that are\r\npotential candidates for the point the maximum is achieved at.First,\r\nletâs consider the case we have no enemies with maximum health exceeding\r\n. Additionally, let .So, how we can calculate ? Letâs model the process.\r\nThere are three kinds of events that affect its value: Some enemy has\r\nhis health updated, it is now less than or equal to , thus we can kill\r\nthe enemy; Some enemy has his health updated, it is now greater than ,\r\nthus we canât kill the enemy; The enemy has regenerated enough health to\r\nbecome invincible again. One can observe that the optimal answer is\r\nreached at the second exactly preceeding the events of the second and\r\nthe third kind. Indeed, otherwise we can move on to the next second: the\r\nbounty is increased and doesnât decrease, thus providing us with a\r\nbetter answer.What remains for us is to calculate the time when the\r\naforementioned events occur to run scanline. The first two kinds\r\ncorrespond directly to the updates (and initial values we can treat them\r\nas updates occuring at zeroth second). Letâs calculate when the events\r\nof third kind would occur. Let the second be the moment when one of the\r\nenemiesâ health became equal to . Let be the regeneration rate of the\r\nenemy. At the second he will regenerate enough health to become\r\ninvincible again. One also needs take care of the case when : if there\r\nare no health updates after the enemy became killable, one can kill him\r\nat any moment and earn infinitely large amount of money. Note that one\r\nshould need when did the last event of the first kind happen as updates\r\ncancel the potentially planned events of the third kind.Now, consider\r\nthe case when some enemy has maximum health less than or equal to . In\r\nthat case, there is always an enemy to kill, and, since the bounty\r\nincreases over time, the answer can be infinitely large.Finally, if ,\r\nthe bounty stays constant and we cannot obtain the infinitely large\r\nanswer. Since the bounty is constant, we are to find the maximum value\r\nof and multiply it by bounty. This is a simple task and is left as an\r\nexcersise :)Time complexity .\r\n",
    "hint": []
}