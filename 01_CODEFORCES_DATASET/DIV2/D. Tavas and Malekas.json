{
    "link": "https://codeforces.com//contest/535/problem/D",
    "problemId": "26040",
    "problem_idx": "D",
    "shortId": "535D",
    "contest_number": "535",
    "problem_submissions": {
        "D": [
            10715113,
            10714538,
            10713033,
            10717870,
            10717623,
            10718212,
            10719145,
            10719368,
            10718417,
            10717655,
            10712848,
            10714795,
            10715426,
            20417071,
            10716514,
            10715240
        ],
        "C": [
            10712561,
            10708236,
            10715493,
            10714489,
            10714358,
            10714749,
            10715771,
            10713528,
            10714886,
            10713502,
            10714572,
            10719561
        ],
        "B": [
            10707835,
            10715165,
            10706437,
            10708415,
            10709369,
            10710794,
            10710470,
            10709993,
            10707334,
            10711642,
            10714171,
            10710232,
            10711093,
            10713617,
            10708489,
            10710722
        ],
        "A": [
            10706255,
            10715866,
            10709239,
            10706497,
            10707836,
            10706378,
            10706480,
            10723848,
            10713315,
            10706570,
            10707243,
            10707771,
            10706513,
            10707324
        ]
    },
    "name": "D. Tavas and Malekas",
    "statement": "Today Tavas fell asleep in Malekas’ place. While he was sleeping,\r\nMalekas did a little process on . Malekas has a favorite string . He\r\ndetermined all positions where matches . More formally, for each () he\r\ncondition is fullfilled.Then Malekas wrote down one of subsequences of\r\n(possibly, he didn’t write anything) on a piece of paper. Here a\r\nsequence is a subsequence of sequence if and only if we can turn into by\r\nremoving some of its elements (maybe no one of them or all).After Tavas\r\nwoke up, Malekas told him everything. He couldn’t remember string , but\r\nhe knew that both and only contains lowercase English letters and also\r\nhe had the subsequence he had written on that piece of paper.Tavas\r\nwonders, what is the number of possible values of ? He asked SaDDas, but\r\nhe wasn’t smart enough to solve this. So, Tavas asked you to calculate\r\nthis number for him.Answer can be very large, so Tavas wants you to\r\nprint the answer modulo .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory.h>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nchar p[1000006];\nint z[1000006];\nbool f[1000006];\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%s\", p);\n\n  const int k = strlen(p);\n  for (int i = 1, l = 0, r = 0; i < k; i++) {\n    int cur = 0;\n    if (i <= r) {\n      cur = min(r - i + 1, z[i - l]);\n    }\n    while (i + cur < k && p[i + cur] == p[cur]) {\n      cur++;\n    }\n    if (i + cur - 1 > r) {\n      l = i;\n      r = i + cur - 1;\n    }\n    z[i] = cur;\n  }\n  z[0] = k;\n\n  if (m--) {\n    int y;\n    scanf(\"%d\", &y);\n    y--;\n\n    for (int i = y; i < y + k; i++) {\n      f[i] = true;\n    }\n\n    while (m--) {\n      int t;\n      scanf(\"%d\", &t);\n      t--;\n\n      if (y + k - 1 < t) {\n        for (int i = t; i < t + k; i++) {\n          f[i] = true;\n        }\n      } else {\n        const int j = t - y;\n        if (z[j] < k - j) {\n          puts(\"0\");\n          return 0;\n        }\n\n        for (int i = y + k; i < t + k; i++) {\n          f[i] = true;\n        }\n      }\n\n      y = t;\n    }\n  }\n\n  int ans = 1;\n  for (int i = 0; i < n; i++) {\n    if (!f[i]) {\n      ans = (1ll * ans * 26) % mod;\n    }\n  }\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "hashing",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Tavas and Malekas.json",
    "editorial_link": "https://codeforces.com//blog/entry/17401",
    "editorial": "First of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise its 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).\n",
    "hint": []
}