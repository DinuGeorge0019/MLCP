{
    "link": "https://codeforces.com//contest/705/problem/D",
    "problemId": "67575",
    "problem_idx": "D",
    "shortId": "705D",
    "contest_number": "705",
    "problem_submissions": {
        "D": [
            19710317,
            19709572,
            19706603,
            19723842,
            19714113
        ],
        "B": [
            19697015,
            19695602,
            19694872,
            19691908,
            19690813,
            19690994,
            19691365,
            19692977,
            19701184,
            19690077,
            19695542,
            19693836,
            19691432,
            19691430,
            19691201,
            19691141,
            19690981,
            19690624
        ],
        "C": [
            19695574,
            19701038,
            19703575,
            19694988,
            19695049,
            19694120,
            19694460,
            19696131,
            19693613,
            19695194,
            19694857,
            19693954,
            19699733,
            19694740,
            19697270,
            19695964,
            19694395,
            19694550,
            19694956
        ],
        "A": [
            19689053,
            19689391,
            19688190,
            19691873,
            19687916,
            19688114,
            19688082,
            19688059,
            19695855,
            19688080,
            19688873,
            19688894,
            19689037,
            19688592,
            19688331,
            19688091,
            19688817,
            19688188
        ]
    },
    "name": "D. Ant Man",
    "statement": "Scott Lang is at war with Darren Cross. There are chairs in a hall where\r\nthey are, numbered with from left to right. The -th chair is located at\r\ncoordinate . Scott is on chair number and Cross is on chair number .\r\nScott can jump to all other chairs (not only neighboring chairs). He\r\nwants to start at his position (chair number ), visit each chair and end\r\nup on chair number with Cross. As we all know, Scott can shrink or grow\r\nbig (grow big only to his normal size), so at any moment of time he can\r\nbe either small or large (normal). The thing is, he can only shrink or\r\ngrow big while being on a chair (not in the air while jumping to another\r\nchair). Jumping takes time, but shrinking and growing big takes no time.\r\nJumping from chair number to chair number takes seconds. Also, jumping\r\noff a chair and landing on a chair takes extra amount of time. If Scott\r\nwants to jump to a chair on his left, he can only be small, and if he\r\nwants to jump to a chair on his right he should be large.Jumping off the\r\n-th chair takes: extra seconds if he’s small. extra seconds otherwise\r\n(he’s large). Also, landing on -th chair takes: extra seconds if he’s\r\nsmall. extra seconds otherwise (he’s large). In simpler words, jumping\r\nfrom -th chair to -th chair takes exactly: seconds if . seconds\r\notherwise (). Given values of , , , , find the minimum time Scott can\r\nget to Cross, assuming he wants to visit each chair exactly once.\r\n",
    "solutions": [
        "#include \"stdio.h\"\n#include \"stdlib.h\"\n\n#define INF 10000000000\n\nint n,s,e,minP;\nlong long a[5005];\nlong long b[5005];\nlong long c[5005];\nlong long d[5005];\nlong long x[5005];\nlong long sum,mn,co;\nint next[5005];\n\nlong long getC(int i, int j){\n\tif(j<i){\n\t\treturn labs(x[i]-x[j]) + c[i] + b[j];\n\t}else{\n\t\treturn labs(x[i]-x[j]) + d[i] + a[j];\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&s,&e);\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%I64d\",&x[i]);\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%I64d\",&a[i]);\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%I64d\",&b[i]);\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%I64d\",&c[i]);\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%I64d\",&d[i]);\n\t}\n\tnext[s] = e;\n\tsum = getC(s,e);\n\tfor(int i = 1; i <= n; i++){\n\t\tif(i!=s&&i!=e){\n\t\t\tmn = INF;\n\t\t\tfor(int xi = s; xi != e; xi = next[xi]){\n\t\t\t\tco = getC(xi,i)-getC(xi,next[xi])+getC(i,next[xi]);\n\t\t\t\tif(co<mn){\n\t\t\t\t\tmn = co;\n\t\t\t\t\tminP = xi;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += mn;\n\t\t\tnext[i] = next[minP];\n\t\t\tnext[minP] = i;\n\t\t}\n\t}\n\tprintf(\"%I64d\\n\",sum);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Ant Man.json",
    "editorial_link": "https://codeforces.com//blog/entry/46450",
    "editorial": "Assume r?<?b (if not, just swap the colors). Build a bipartite graph where every vertical line is a vertex in part X and every horizontal line is a vertex in part Y. Now every point(shield) is an edge (between the corresponding vertical and horizontal lines it lies on). We write 1 on an edge if we want to color it in red and 0 if in blue (there may be more than one edge between two vertices). Each constraint says the difference between 0 and 1 edges connected to a certain vertex should be less than or equal to some value. For every vertex, only the constraint with smallest value matters (if there's no constraint on this vertex, we'll add one with di?=?number of edges connected to i).\n\nConsider vertex i. Assume there are qi edges connected to it and the constraint with smallest d on this vertex has dj?=?ei. Assume ri will be the number of red (with number 1 written on) edges connected to it at the end. With some algebra, you get that the constraint is fulfilled if and only if . Denote  and . So Li???ri???Ri. This gives us a L-R max-flow approach: aside these vertices, add a source S and a sink T. For every vertex v in part X, add an edge with minimum and maximum capacity Lv and Rv from S to v. For every vertex u in part Y, add an edge with minimum and maximum capacity Lu and Ru from u to T. And finally for every edge v?-?u from X to Y add an edge from v to u with capacity 1 (minimum capacity is 0).",
    "hint": []
}