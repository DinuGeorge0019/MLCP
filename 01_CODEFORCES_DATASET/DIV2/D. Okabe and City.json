{"link": "https://codeforces.com//contest/821/problem/D", "problemId": "111652", "problem_idx": "D", "shortId": "821D", "contest_number": "821", "problem_submissions": {"D": [28036388, 28036319, 28037093, 41734433, 28037174, 28036759, 28036893, 28108464, 28108438, 28053809, 28048526, 28037849, 28039886, 28037900, 28037562, 28037762, 28067673, 28050717], "E": [28031080, 28025704, 28029758, 28032764, 28034511, 28038207, 28056472, 28054979, 28053726, 28053708, 28053530, 28035432, 28032380, 28032466, 67190033, 28025986, 28039285, 28035423, 28028415, 28031314, 28033070, 28028563, 28033114, 28035978, 28036465, 28035018], "C": [28027564, 28028757, 28027102, 28028054, 28028077, 28026793, 28053306, 28050947, 28049926, 28028104, 28028806, 28032681, 28027048, 28027053, 28038599, 28026500, 28028038, 28025519, 28031473, 28029012, 28027297, 28028758, 28029118], "B": [28025033, 28029985, 28027229, 28026296, 28026743, 28025293, 28047680, 28046444, 28026532, 28026871, 28024943, 28029111, 28024882, 28027316, 28035127, 28026321, 28027518, 28033448, 28025512, 28026466, 28026910], "A": [28023814, 28030700, 28026806, 28025423, 28026686, 28024284, 28047598, 28025814, 28023873, 28023685, 28028848, 28024187, 28025303, 28024870, 28024246, 28024053, 28029160, 28023901, 28023721, 28024947, 28025828]}, "name": "D. Okabe and City", "statement": "Okabe likes to be able to walk through his city on a path lit by street\r\nlamps. That way, he doesn\u2019t get beaten up by schoolchildren.Okabe\u2019s city\r\nis represented by a 2D grid of cells. Rows are numbered from to from top\r\nto bottom, and columns are numbered to from left to right. Exactly cells\r\nin the city are lit by a street lamp. It\u2019s guaranteed that the top-left\r\ncell is lit.Okabe starts his walk from the top-left cell, and wants to\r\nreach the bottom-right cell. Of course, Okabe will only walk on lit\r\ncells, and he can only move to adjacent cells in the up, down, left, and\r\nright directions. However, Okabe can also temporarily light all the\r\ncells in any single row or column at a time if he pays coin, allowing\r\nhim to walk through some cells not lit initially. Note that Okabe can\r\nonly light a single row or column at a time, and has to pay a coin every\r\ntime he lights a new row or column. To change the row or column that is\r\ntemporarily lit, he must stand at a cell that is lit initially. Also,\r\nonce he removes his temporary light from a row or column, all cells in\r\nthat row/column not initially lit are now not lit.Help Okabe find the\r\nminimum number of coins he needs to pay to complete his walk!\r\n", "solutions": ["#include<bits/stdc++.h>\n#define oo 0x3f3f3f3f\n#define cl(x) memset(x, 0, sizeof(x))\n#define maxn 30010\ntypedef long long ll;\nusing namespace std;\nvoid gn(int &x) {\n\tx = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') ch = getchar();\n\twhile (ch >= '0' && ch <= '9')\n\t\tx = x * 10 + ch - '0', ch = getchar();\n}\nint n, m, k, x[maxn], y[maxn];\nint sx[maxn], sy[maxn];\nbool cmpx(const int &a, const int &b) {\n\treturn x[a] == x[b] ? y[a] < y[b] : x[a] < x[b];\n}\nbool cmpy(const int &a, const int &b) {\n\treturn y[a] == y[b] ? x[a] < x[b] : y[a] < y[b];\n}\nint posx[maxn], posy[maxn];\nbool inq[maxn];\nint dis[maxn], q[maxn], qh, qt, s;\nint g[maxn], ei;\nstruct edge {\n\tint t, w, nxt;\n}e[maxn * 30];\nvoid print(int a) {\n\tif (a <= k)\n\t\tprintf(\"(%d,%d)\", x[a], y[a]);\n\tif (a > k && a <= k + n)\n\t\tprintf(\"line %d\", a - k);\n\tif (a > k + n)\n\t\tprintf(\"col %d\", a - k - n);\n}\nvoid ae(int a, int b, int c) {\n\te[++ei].t = b; e[ei].nxt = g[a]; g[a] = ei; e[ei].w = c;\n}\nint main() {\n\tgn(n); gn(m); gn(k);\n\tfor (int i = 1; i <= k; ++i) {\n\t\tgn(x[i]); gn(y[i]);\n\t\tif (x[i] == 1 && y[i] == 1) s = i;\n\t}\n\tfor (int i = 1; i <= k; ++i) sx[i] = sy[i] = i;\n\tsort(sx + 1, sx + k + 1, cmpx);\n\tfor (int i = 1; i <= k; ++i) posx[sx[i]] = i;\n\tsort(sy + 1, sy + k + 1, cmpy);\n\tfor (int i = 1; i <= k; ++i) posy[sy[i]] = i;\n\tfor (int o = 1; o <= k; ++o) {\n\t\tint u, d, l, r;\n\t\tif (posx[o] > 1) {\n\t\t\tl = sx[posx[o] - 1];\n\t\t\tif (x[l] == x[o] && y[l] == y[o] - 1) {\n\t\t\t\tae(o, l, 0);\n\t\t\t}\n\t\t}\n\t\tif (posx[o] < k) {\n\t\t\tr = sx[posx[o] + 1];\n\t\t\tif (x[r] == x[o] && y[r] == y[o] + 1) {\n\t\t\t\tae(o, r, 0);\n\t\t\t}\n\t\t}\n\t\tif (posy[o] > 1) {\n\t\t\tu = sy[posy[o] - 1];\n\t\t\tif (y[u] == y[o] && x[u] == x[o] - 1) {\n\t\t\t\tae(o, u, 0);\n\t\t\t}\n\t\t}\n\t\tif (posy[o] < k) {\n\t\t\td = sy[posy[o] + 1];\n\t\t\tif (y[d] == y[o] && x[d] == x[o] + 1) {\n\t\t\t\tae(o, d, 0);\n\t\t\t}\n\t\t}\n\t\tae(o, k + x[o], 1); ae(k + x[o], o, 0);\n\t\tif (x[o] > 1) ae(o, k + x[o] - 1, 1), ae(k + x[o] - 1, o, 0);\n\t\tif (x[o] < n) ae(o, k + x[o] + 1, 1), ae(k + x[o] + 1, o, 0);\n\t\tae(o, k + n + y[o], 1); ae(k + n + y[o], o, 0);\n\t\tif (y[o] > 1) ae(o, k + n + y[o] - 1, 1), ae(k + n + y[o] - 1, o, 0);\n\t\tif (y[o] < m) ae(o, k + n + y[o] + 1, 1), ae(k + n + y[o] + 1, o, 0);\n\t}\n\tmemset(dis, 0x3f, sizeof(dis));\n\tqh = qt = 0;\n\tq[qt++] = s; dis[s] = 0; inq[s] = 1;\n\twhile (qh != qt) {\n\t\tint now = q[qh++]; if (qh == maxn) qh = 0;\n\t\tfor (int i = g[now]; i; i = e[i].nxt)\n\t\t\tif (dis[now] + e[i].w < dis[e[i].t]) {\n\t\t\t\tdis[e[i].t] = dis[now] + e[i].w;\n\t\t\t\tif (!inq[e[i].t]) {\n\t\t\t\t\tinq[e[i].t] = 1; q[qt++] = e[i].t; if (qt == maxn) qt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\tinq[now] = 0;\n\t}\n\tint ans = oo;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tif (x[i] == n && y[i] == m)\n\t\t\tans = min(ans, dis[i]);\n\t\tif (x[i] == n) ans = min(ans, dis[i] + 1);\n\t\tif (y[i] == m) ans = min(ans, dis[i] + 1);\n\t}\n\tans = min(ans, dis[k + n]); ans = min(ans, dis[k + n + m]);\n\tif (ans == oo) printf(\"-1\\n\"); else printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "shortest paths"], "dificulty": "2200", "interactive": false}