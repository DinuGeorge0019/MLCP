{"link": "https://codeforces.com//contest/1186/problem/E", "problemId": "364218", "problem_idx": "E", "shortId": "1186E", "contest_number": "1186", "problem_submissions": {"F": [56216938, 56221830, 56221641, 56218857, 56211953, 58409345, 56299282, 56213956, 56210718, 56211243, 56212157, 56210745, 56214646, 56218371, 56217250, 56211887, 56220407, 56219870], "E": [56211447, 56208778, 56218701, 56208813, 58409358, 56275284, 56222796, 56249700, 56215465, 56216547, 56237690, 56250633, 56250552, 56216656, 56220314], "D": [56200749, 56201695, 56206642, 56211181, 56202747, 56201586, 56205150, 56206151, 56203320, 56252310, 56249710, 56202028, 56208820, 56205852, 56200883, 56207730, 56204717, 56257061, 56203062, 56206927, 56205301, 56202759], "C": [56199249, 56199765, 56204054, 56222663, 56199984, 56199510, 56203530, 56202685, 56205514, 56200910, 56249725, 56199768, 56206169, 56202363, 56198182, 56204569, 56218666, 56537912, 56199932, 56203944, 56202070, 56199969], "A": [56196758, 56193054, 56194739, 56209279, 56193033, 56192921, 56196291, 56192487, 56193111, 56249716, 56195272, 56199424, 56197233, 56193792, 56192618, 56195433, 56193194, 56192578, 56193852, 56194487]}, "name": "E. Vus the Cossack and a Field", "statement": "Vus the Cossack has a field with dimensions n\r\ntimes m, which consists of \"\" and \"\". He is building an infinite field\r\nfrom this field. He is doing this in this way: He takes the current\r\nfield and finds a new inverted field. In other words, the new field will\r\ncontain \"\" only there, where \"\" was in the current field, and \"\" there,\r\nwhere \"\" was. To the current field, he adds the inverted field to the\r\nright. To the current field, he adds the inverted field to the bottom.\r\nTo the current field, he adds the current field to the bottom right. He\r\nrepeats it.For example, if the initial field was:\r\nbegin{matrix} 1 & 0 &\r\n1 & 1 &\r\nend{matrix} After the first iteration, the field will be like this:\r\nbegin{matrix} 1 & 0 & 0 & 1\r\n1 & 1 & 0 & 0\r\n0 & 1 & 1 & 0\r\n0 & 0 & 1 & 1\r\nend{matrix} After the second iteration, the field will be like this:\r\nbegin{matrix} 1 & 0 & 0 & 1 & 0 & 1 & 1 & 0\r\n1 & 1 & 0 & 0 & 0 & 0 & 1 & 1\r\n0 & 1 & 1 & 0 & 1 & 0 & 0 & 1\r\n0 & 0 & 1 & 1 & 1 & 1 & 0 & 0\r\n0 & 1 & 1 & 0 & 1 & 0 & 0 & 1\r\n0 & 0 & 1 & 1 & 1 & 1 & 0 & 0\r\n1 & 0 & 0 & 1 & 0 & 1 & 1 & 0\r\n1 & 1 & 0& 0 & 0 & 0 & 1 & 1\r\nend{matrix} And so on...Let\u2019s numerate lines from top to bottom from 1\r\nto infinity, and columns from left to right from 1 to infinity. We call\r\nthe submatrix (x_1, y_1, x_2, y_2) all numbers that have coordinates (x,\r\ny) such that x_1\r\nleq x\r\nleq x_2 and y_1\r\nleq y\r\nleq y_2.The Cossack needs sometimes to find the sum of all the numbers\r\nin submatrices. Since he is pretty busy right now, he is asking you to\r\nfind the answers!\r\n", "solutions": ["#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=1005;\n\nint n,m;\nchar a[MAXN][MAXN];\nint s[MAXN][MAXN];\nint calc(int x)\n{\n\tint ans=0;\n\tfor(;x;x>>=1)ans^=(x&1);\n\treturn ans;\n}\nll gsum(int x,int y,int t)\n\t{return t?(x+1)*(y+1)-s[x][y]:s[x][y];}\nll work(int x,int y)\n{\n\tif(!x || !y)return 0;\n\t--x;--y;\n\tint tx=x/n,ty=y/m;\n\tll ans=1ll*(tx>>1)*(y+1)*n+1ll*(ty>>1)*(x%(2*n)+1)*m;\n\tif((tx&1) && (ty&1))ans+=gsum(n-1,m-1,calc(tx-1)^calc(ty-1));\n\tif(tx&1)ans+=gsum(n-1,y%m,calc(tx-1)^calc(ty));\n\tif(ty&1)ans+=gsum(x%n,m-1,calc(tx)^calc(ty-1));\n\tans+=gsum(x%n,y%m,calc(tx)^calc(ty));\n\treturn ans;\n}\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(\"code.in\",\"r\",stdin);\n    //freopen(\"code.out\",\"w\",stdout);\n    #endif\n    int Q,x1,y1,x2,y2;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(int i=0;i<n;i++)\n    \tscanf(\"%s\",a[i]);\n    for(int i=0;i<n;i++)\n    \tfor(int j=0;j<m;j++)\n    \t\tif(i && j)s[i][j]=s[i-1][j]+s[i][j-1]+(a[i][j]-'0')-s[i-1][j-1];\n    \t\telse if(i)s[i][j]=s[i-1][j]+(a[i][j]-'0');\n    \t\telse if(j)s[i][j]=s[i][j-1]+(a[i][j]-'0');\n    \t\telse s[i][j]=a[i][j]-'0';\n/*for(int i=0;i<n;i++)\n{\n\tfor(int j=0;j<m;j++)\n\t\tcout<<gsum(i,j,1)<<\" \";\n\tcout<<endl;\n}\ncout<<endl;*/\n    while(Q--)\n    {\n    \tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n    \t--x1;--y1;\n    \tprintf(\"%I64d\\n\",work(x2,y2)-work(x1,y2)-work(x2,y1)+work(x1,y1));\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["divide and conquer", "implementation", "math"], "dificulty": "2500", "interactive": false}