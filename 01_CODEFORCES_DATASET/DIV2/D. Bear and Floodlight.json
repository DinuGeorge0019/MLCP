{"link": "https://codeforces.com//contest/385/problem/D", "problemId": "5934", "problem_idx": "D", "shortId": "385D", "contest_number": "385", "problem_submissions": {"E": [5794434, 5800310, 5798100, 12839340, 5793580, 5807353, 5798624, 5795785], "D": [5791982, 5791338, 5792966, 5793920, 5795427, 5791662, 5796473, 5796329, 5793942], "C": [5788908, 5788383, 5788712, 5790434, 5789032, 5794132, 5791478, 5792236, 5791660, 5800872, 5791637, 5790324, 5790844, 5792509, 5789960, 5787897, 5791710, 5799045], "B": [5786803, 5786394, 5787527, 5788072, 5786967, 5787817, 5788240, 5790217, 5789128, 5788273, 5787714, 5788006, 5786982, 5787829, 5787905, 5791193, 5786254, 5787251, 5788615], "A": [5786226, 5789111, 5786358, 5786644, 5786233, 5788977, 5786318, 5787575, 5786766, 5786887, 5786239, 5786463, 5786289, 5786726, 5786980, 5790591, 5788602, 5792556, 5787159]}, "name": "D. Bear and Floodlight", "statement": "One day a bear lived on the axis. He was afraid of the dark, so he\r\ncouldn\u2019t move at night along the plane points that aren\u2019t lit. One day\r\nthe bear wanted to have a night walk from his house at point to his\r\nfriend\u2019s house at point , along the segment of length . Of course, if he\r\nwants to make this walk, he needs each point of the segment to be lit.\r\nThat\u2019s why the bear called his friend (and yes, in the middle of the\r\nnight) asking for a very delicate favor.The axis contains floodlights.\r\nFloodlight is at point and can light any angle of the plane as large as\r\ndegree with vertex at point . The bear asked his friend to turn the\r\nfloodlights so that he (the bear) could go as far away from his house as\r\npossible during the walking along the segment. His kind friend agreed to\r\nfulfill his request. And while he is at it, the bear wonders: what is\r\nthe furthest he can go away from his house? Hep him and find this\r\ndistance.Consider that the plane has no obstacles and no other light\r\nsources besides the floodlights. The bear\u2019s friend cannot turn the\r\nfloodlights during the bear\u2019s walk. Assume that after all the\r\nfloodlights are turned in the correct direction, the bear goes for a\r\nwalk and his friend goes to bed.\r\n", "solutions": ["#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kMaxN = 20;\nconst double kPi = acos(-1.0);\nconst double kEps = 1E-8;\ndouble f[1 << kMaxN];\ndouble agl[kMaxN];\nint n, l, r;\n\ninline int sgn(double x) {\n    if (fabs(x) < kEps) return 0;\n    if (x > 0) return 1;\n    return -1;\n}\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x_, double y_) : x(x_), y(y_) {}\n} p[kMaxN];\n\ntypedef Point Vector;\n\nVector operator-(const Vector &a, const Vector &b) {\n    return Vector(a.x - b.x, a.y - b.y);\n}\n\nVector rotate(const Vector &v, double agl) {\n    return Vector(v.x * cos(agl) - v.y * sin(agl),\n            v.x * sin(agl) + v.y * cos(agl));\n}\n\ndouble calcMaxDist(double from, const Point &p, double agl) {\n    if (sgn(p.y) == 0) {\n        if (sgn(from - p.x) < 0) return p.x;\n        else return 1E100;\n    }\n    else {\n        Vector a = Point(from, 0) - p;\n        if (sgn(p.y) > 0) a = rotate(a, agl);\n        else a = rotate(a, 2.0 * kPi - agl);\n        if (sgn(a.y) == 0) return 1E100;\n        if (sgn(p.y) > 0 && sgn(a.y) > 0) return 1E100;\n        if (sgn(p.y) < 0 && sgn(a.y) < 0) return 1E100;\n        if (sgn(a.x) == 0) return p.x;\n        else {\n            double k = a.y / a.x;\n            double b = p.y - p.x * k;\n            return (-b) / k;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &l, &r);\n    for (int i = 0; i < (1 << n); ++ i) f[i] = l;\n    for (int i = 0, a; i < n; ++ i) {\n        scanf(\"%lf%lf%d\", &p[i].x, &p[i].y, &a);\n        agl[i] = a / 180.0 * kPi;\n    }\n    int upper = 1 << n;\n    for (int msk = 0; msk < upper; ++ msk) {\n        int can = upper - 1 - msk;\n        while (can) {\n            double current = f[msk];\n            int q = can & -can;\n            can ^= q;\n            q = __builtin_ctz(q);\n            current = max(current, calcMaxDist(current, p[q], agl[q]));\n            current = min(current, (double)r);\n            f[msk ^ (1 << q)] = max(f[msk ^ (1 << q)], current);\n        }\n    }\n    printf(\"%.8lf\\n\", f[upper - 1] - l);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp", "geometry"], "dificulty": "2200", "interactive": false}