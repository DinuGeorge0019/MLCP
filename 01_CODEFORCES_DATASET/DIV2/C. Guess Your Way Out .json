{
    "link": "https://codeforces.com//contest/507/problem/C",
    "problemId": "21016",
    "problem_idx": "C",
    "shortId": "507C",
    "contest_number": "507",
    "problem_submissions": {
        "E": [
            9526622,
            9522874,
            9528248,
            9522738,
            9519732,
            9522241,
            9524358,
            9526324,
            9526094,
            9526850,
            9526275,
            9527839,
            9524894,
            9533260,
            9526956,
            9526355,
            9527254,
            9534539,
            9527572,
            9528068,
            9528656
        ],
        "D": [
            9524452,
            9527107,
            9526768,
            9524593,
            10558273,
            10558123,
            10558122,
            9525066
        ],
        "C": [
            9521275,
            9525428,
            9521898,
            9519042,
            9523598,
            9520087,
            9521484,
            9522923,
            9523120,
            9521243,
            9521401,
            9526151,
            9520501,
            9521807,
            9523054,
            9522069,
            9522518,
            9521325,
            9520982
        ],
        "B": [
            9517387,
            9516026,
            9517698,
            9515711,
            9521710,
            9519733,
            9518855,
            9517565,
            9516742,
            9518683,
            9519009,
            9516196,
            9517854,
            9518052,
            9516626,
            9518923,
            9517641,
            9516929,
            9517425
        ],
        "A": [
            9515320,
            9514942,
            9515025,
            9514972,
            9520386,
            9520232,
            9514912,
            9515204,
            9515151,
            9515163,
            9515214,
            9515096,
            9514948,
            9515853,
            9515067,
            9517288,
            9515310,
            9515279,
            9516279
        ]
    },
    "name": "C. Guess Your Way Out ",
    "statement": "Amr bought a new video game \"Guess Your Way Out!\". The goal of the game\r\nis to find an exit from the maze that looks like a perfect binary tree\r\nof height . The player is initially standing at the root of the tree and\r\nthe exit from the tree is located at some leaf node. Let’s index all the\r\nleaf nodes from the left to the right from 1 to . The exit is located at\r\nsome node where , the player doesn’t know where the exit is so he has to\r\nguess his way out!Amr follows simple algorithm to choose the path. Let’s\r\nconsider infinite command string \"\" (consisting of alternating\r\ncharacters ” and ”). Amr sequentially executes the characters of the\r\nstring using following rules: Character ” means \"go to the left child of\r\nthe current node\"; Character ” means \"go to the right child of the\r\ncurrent node\"; If the destination node is already visited, Amr skips\r\ncurrent command, otherwise he moves to the destination node; If Amr\r\nskipped two consecutive commands, he goes back to the parent of the\r\ncurrent node before executing next command; If he reached a leaf node\r\nthat is not the exit, he returns to the parent of the current node; If\r\nhe reaches an exit, the game is finished. Now Amr wonders, if he follows\r\nthis algorithm, how many nodes he is going to visit before reaching the\r\nexit?\r\n",
    "solutions": [
        "#include <cstdio>\nusing namespace std;\n\nint main() {\n    int h;\n    long long id;\n    scanf(\"%d%I64d\", &h, &id);\n    long long s = 0;\n    long long ans = 0;\n    long long L = 1, R = 1LL << h;\n    int H = 0;\n    while (L != R) {\n        ans ++;\n        if (s == 0) {\n            long long len = (R - L + 1) / 2;\n            if (id <= L + len - 1) {\n                R = L + len - 1;\n            } else {\n                ans += (1LL << (h - H)) - 1;\n                L += len;\n                s = 1 - s;\n            }\n        } else {\n            long long len = (R - L + 1) / 2;\n            if (id >= L + len) {\n                L += len;\n            } else {\n                ans += (1LL << (h - H)) - 1;\n                R = L + len - 1;\n                s = 1 - s;\n            }\n        }\n        s = 1 - s;\n        H ++;\n    }\n    printf(\"%I64d\\n\", ans);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Guess Your Way Out .json",
    "editorial_link": "https://codeforces.com/blog/entry/15975",
    "editorial": "Hint: Simulate the algorithm until we reach a leaf node assume that itâs\r\nnot the exit. Now the question is Are there some nodes that are\r\nguaranteed to be visited before trying to reach the exit again?\r\nSolution: The first observation is that in order to return to a parent\r\nwe will have to visit all nodes of the right or the left subtree of some\r\nnode first. Now imagine we are in the situation below where is the exit.\r\nBy applying the algorithm weâll reach node . Both the and are in\r\ndifferent subtrees of the root. Which means before going to the proper\r\nsubtree in which the Exit exists weâll have to visit all the nodes of\r\nthe left subtree (marked in red). This means we have to get the node\r\nwhich the Exit and the current leaf node are in different subtrees which\r\nwill be the least common ancestor (LCA) of the two nodes. Assume the\r\nsubtree height is . This means we visited node. By adding the nodes\r\nabove the subtree which we visited during executing the string for the\r\nfirst time the total number of visited nodes will be . Now letâs go to\r\nthe other subtree. Obviously we donât need any other nodes except this\r\nsubtree. So letâs do the same we did to the original tree to this\r\nsubtree. Execute the algorithm until we reach a leaf node, get the LCA,\r\nadd to the solution where is the height of the subtree of the LCA node\r\nwhere the leaf node exists. And so on we keep applying the rules until\r\nafter executing the algorithm we will reach the exit. Also we can do the\r\nsame operations in by beginning to move from the root, if the exit is\r\nlocated to the left we go to the left and ans++ and then set the next\r\ncommand to âRâ else if it is located to the right we will visited the\r\nwhole left subtree so we add the left subtree nodes to the answer and\r\nthen set the next command to âLâ and so on. Time complexity: or\r\nChallenge: What if the pattern is given as an input (e.g.\r\n\"LRRLLRRRLRLRLRR...\"), How can this problem be solved? Implementation:\r\n9529181\r\n",
    "hint": []
}