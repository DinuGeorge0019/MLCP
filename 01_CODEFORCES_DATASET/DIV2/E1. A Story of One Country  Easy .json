{
    "link": "https://codeforces.com//contest/1181/problem/E1",
    "problemId": "359264",
    "problem_idx": "E1",
    "shortId": "1181E1",
    "contest_number": "1181",
    "problem_submissions": {
        "E2": [
            55650122,
            55830557,
            55704213
        ],
        "E1": [
            55633819,
            55638516,
            55638501,
            55637414,
            55641214,
            55640980,
            55643225,
            55640108,
            55640609,
            55642576,
            55643544,
            55642412,
            55643807,
            55641985,
            55642964,
            240099989
        ],
        "D": [
            55631090,
            55633784,
            55633448,
            55631287,
            55633631,
            55633273,
            55636890,
            55634366,
            55634832,
            55638016,
            55638738,
            55634315,
            55639336,
            55636804,
            55635357,
            55637569,
            55636303,
            55635471,
            55634737,
            55630910
        ],
        "B": [
            55627797,
            55620636,
            55623454,
            55633957,
            55622559,
            55626217,
            109938468,
            109937680,
            55629226,
            55627039,
            55625976,
            55641971,
            55622249,
            55622014,
            55624276,
            55623137
        ],
        "C": [
            55625127,
            55629408,
            55627484,
            55625656,
            55629031,
            55630033,
            55628446,
            55636714,
            55636852,
            55632570,
            55634750,
            55628993,
            55633600,
            55628788,
            55626023,
            55632494,
            55631294,
            55629796,
            55629116,
            55636617
        ],
        "A": [
            55616968,
            55616973,
            55617720,
            55617671,
            55617776,
            55617314,
            55618111,
            109966538,
            109938562,
            109938324,
            55618923,
            55617442,
            55639586,
            55635703,
            55628269,
            55617672,
            55630717,
            55619287,
            55617106,
            55617973,
            55617169,
            55617325
        ]
    },
    "name": "E1. A Story of One Country  Easy ",
    "statement": "Petya decided to visit Byteland during the summer holidays. It turned\r\nout that the history of this country is quite unusual.Initially, there\r\nwere n different countries on the land that is now Berland. Each country\r\nhad its own territory that was represented as a rectangle on the map.\r\nThe sides of the rectangle were parallel to the axes, and the corners\r\nwere located at points with integer coordinates. Territories of no two\r\ncountries intersected, but it was possible that some territories touched\r\neach other. As time passed, sometimes two countries merged into one. It\r\nonly happened if the union of their territories was also a rectangle. In\r\nthe end only one country remained Byteland.Initially, each country had a\r\nrectangular castle inside its territory. Its sides were parallel to the\r\naxes and its corners had integer coordinates. Some castles might touch\r\nthe border of the corresponding country and sides or other castles.\r\nMiraculously, after all the unions the castles are still intact.\r\nUnfortunately, their locations are the only information we have to\r\nrestore the initial territories of the countries. The possible formation\r\nof Byteland. The castles are shown in blue. Petya wonders why no\r\ninformation about the initial countries remained. He suspected that the\r\nwhole story is a fake. You were recommended to him as a smart person.\r\nPlease check whether or not there exists a possible set of initial\r\nterritories that could make the story true.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=1e3;\nint n, a[mxN], b[mxN], c[mxN], d[mxN];\n\nbool dc(vector<int> &v, int tr=0) {\n\tif(v.size()<3)\n\t\treturn 1;\n\tvector<int> x1{INT_MAX}, x2{INT_MAX};\n\tfor(int i : v) {\n\t\tx1.push_back(a[i]);\n\t\tx2.push_back(c[i]);\n\t}\n\tsort(x1.begin(), x1.end());\n\tsort(x2.begin(), x2.end());\n\tint px;\n\tfor(int i=0, j=0, s=0; i<x1.size()-1||j<x2.size()-1; ) {\n\t\tint cx;\n\t\tif(x2[j]<=x1[i]) {\n\t\t\t--s;\n\t\t\tcx=x2[j++];\n\t\t} else {\n\t\t\t++s;\n\t\t\tcx=x1[i++];\n\t\t}\n\t\tif(!s) {\n\t\t\tpx=cx;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(px<x2[x2.size()-2]) {\n\t\tvector<int> p1, p2;\n\t\tfor(int i : v) {\n\t\t\tif(a[i]<px)\n\t\t\t\tp1.push_back(i);\n\t\t\telse\n\t\t\t\tp2.push_back(i);\n\t\t}\n\t\treturn dc(p1)&&dc(p2);\n\t}\n\tif(!tr) {\n\t\tfor(int i : v) {\n\t\t\tswap(a[i], b[i]);\n\t\t\tswap(c[i], d[i]);\n\t\t}\n\t\treturn dc(v, 1);\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\tvector<int> v(n);\n\tiota(v.begin(), v.end(), 0);\n\tcout << (dc(v)?\"YES\":\"NO\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "divide and conquer",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. A Story of One Country  Easy .json",
    "editorial_link": "https://codeforces.com//blog/entry/67727",
    "editorial": "We can rephrase the problem as follows:\n\nThere is a set of non-intersecting rectangles on the plane. Let's say, that some rectangular area on the plane is good, if it contains exactly one rectangle in it or there exists a vertical or horizontal cut, which cuts the area into two good areas. You are asked to check whether the area [0;109]Ã—[0;109]\n is good.\n\nIt's easy to see that it is exactly the same process as in the statement, except we don't merge countries into one, we look at the reversed process, where we split one country into many.\n\nAlso let's notice, that when we found some cutting line, which doesn't goes through inner part of any rectangle, we can always apply it to separate our area into two. We can do that, since our predicate of set of rectangles being nice is monotonic: if we replace set of rectangles with its subset, it only can make better.\n\nNow let's analyze when the cut is good:\n\n\nThis already gives us a solution in O(n2log)\n, which passes the easy version of the problem. Simply solve the problem recursively, sorting rectangles as shown above. (and symmetrically for horizontal cuts) and try finding a cut. Once we find it, solve the problem recursively.\n\nNow we have working time: T(n)=T(x)+T(n?x)+O(nlogn)\n, where x\n is a size of one part of the cut. The worse case is x=1\n, so T(n)=O(n2log)\n. ?\n\nFor the full version we need a faster solution.\n\nThe key idea is: let's cut always \"smaller from larger\". Suppose we are magically able to find any valid cut in O(1)\n (basically the number x\n). Then we could have spent O(x)\n to cut out the smaller part into new recursive call. While we can continue the process of cutting with the remaining rectangles in this recursion call.\n\nThis solution works in O(nlogn)\n: Each time the size of problem reduces at least twice when we go into recursion, so there are only log\n levels.\n\nHowever we need to handle \"magic\" here. For example one could have used a segment tree to implement all mentioned above (it would give a O(nlog2)\n time). But there is a simpler solution!\n\nLet's sort rectangles using all 4\n possible sortings. And let's iterate over all this sortings simultaneously. We need 4\n directions instead of 2\n, because if we would e.g. only iterate from let to right, we wouldn't be able to cut out the \"smaller\" from \"larger\", in case the \"smaller\" is to the right of \"larger\". So we want to both go from left to right and from right to left.\n\nWhen in one of the directions we see a valid place to make a cut, we remove all the rectangles into the separate recursion call. We also mark all those rectangles in the current recursion call as deleted and start the procedure of cutting again. We can simply skip the rectangles marked as deleted when we encounter them. For example we could use a linked list for that:\n\n\nSo now we got a solution in O(nlog2)\n: one logarithm is from cutting smaller from larger and one logarithm is from sorting.\n\nOne could drop the second logarithm. For that we should sort all rectangles at the beginning and then carefully pass the correct ordering down the recursion. But that wasn't required.",
    "hint": []
}