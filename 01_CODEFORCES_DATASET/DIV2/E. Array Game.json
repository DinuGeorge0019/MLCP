{"link": "https://codeforces.com//contest/1600/problem/E", "problemId": "1136953", "problem_idx": "E", "shortId": "1600E", "contest_number": "1600", "problem_submissions": {"D": [131326791, 131319774, 131349265, 131313616, 131318416, 131323729], "F": [131320345, 131329426, 131350388], "E": [131316574, 131313861, 131305576, 131310151, 131314773], "I": [131312786, 131309903, 131307758, 131305198, 131310781], "A": [131307398], "J": [131302886, 131305362, 131303377, 131303391, 131305512], "B": [], "C": []}, "name": "E. Array Game", "statement": "Alice and Bob are playing a game. They are given an array A of length N.\r\nThe array consists of integers. They are building a sequence together.\r\nIn the beginning, the sequence is empty. In one turn a player can remove\r\na number from the left or right side of the array and append it to the\r\nsequence. The rule is that the sequence they are building must be\r\nstrictly increasing. The winner is the player that makes the last move.\r\nAlice is playing first. Given the starting array, under the assumption\r\nthat they both play optimally, who wins the game?\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define FOR(i,a,b) for (int i = a; i <= b; i++)\n#define FORD(i,a,b) for (int i = a; i >= b; i--)\n\n///// DEBUG TEMPLATE /////\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n///// DEBUG TEMPLATE /////\n\n///// MODNUM TEMPLATE /////\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n  using ll = long long;\n\n  int v;\n\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n\npublic:\n\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n  assert(b >= 0);\n  T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9 + 13)>;\n///// MODNUM TEMPLATE /////\n\nint n;\nvector<int> a;\nvector<int> toLeft, toRight;\nmap<pair<int, int>, int> dp;\n\nint check(int left, int right, int maximum = -1) {\n  // if (dp.count({left, right})) {\n  //   return dp[{left, right}];\n  // }\n  bool blockLeft = a[left] <= maximum;\n  bool blockRight = a[right] <= maximum;\n  if (blockLeft && blockRight) {\n    // dp[{left, right}] = 0;\n    return 0;\n  }\n  if (left == right) {\n    // dp[{left, right}] = 1;\n    return 1;\n  }\n\n  if (blockLeft) {\n    int r = toLeft[right];\n    if ((right - r) % 2 == 0) return 1;\n    else return 0;\n  }\n\n  if (blockRight) {\n    int l = toRight[left];\n    if ((l - left) % 2 == 0) return 1;\n    else return 0;\n  }\n\n  if (a[left] > maximum && check(left + 1, right, a[left]) == 0) {\n    // dp[{left, right}] = 1;\n    return 1;\n  }\n  if (a[right] > maximum && check(left, right - 1, a[right]) == 0) {\n    // dp[{left, right}] = 1;\n    return 1;\n  }\n  // dp[{left, right}] = 0;\n  return 0;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    a.assign(n + 1, 0);\n    FOR(i, 1, n) cin >> a[i];\n\n\n    toLeft.assign(n + 1, 0);\n    toRight.assign(n + 1, 0);\n\n    FOR(i, 1, n) {\n      toLeft[i] = i;\n      int j = i - 1;\n      if (j > 0 && a[j] > a[i]) {\n        toLeft[i] = toLeft[j];\n      }\n    }\n\n    FORD(i, n, 1) {\n      toRight[i] = i;\n      int j = i + 1;\n      if (j <= n && a[j] > a[i]) {\n        toRight[i] = toRight[j];\n      }\n    }\n\n\n    if (check(1, n) == 1) {\n      cout << \"Alice\" << endl;\n    } else {\n      cout << \"Bob\" << endl;\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["games", "greedy", "two pointers"], "dificulty": "1900", "interactive": false}