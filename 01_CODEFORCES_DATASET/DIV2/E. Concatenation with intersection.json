{"link": "https://codeforces.com//contest/1313/problem/E", "problemId": "546725", "problem_idx": "E", "shortId": "1313E", "contest_number": "1313", "problem_submissions": {"E": [71681170, 71676206, 71701918, 71678634, 71684245], "D": [71668784, 71676711, 71679066, 71902295, 71669382, 71676113, 71676282, 71682897, 71682850, 71684110, 71683951, 71679478, 71685695, 71684314, 71693014, 71684216, 71672133, 71677829, 71681283], "C1": [71659792, 71665149, 71664308, 71663397, 71902274, 71657100, 71662551, 71666875, 71662026, 71660339, 71665119, 71670647, 71661830, 71671471, 71673887, 71666482, 71663477, 71673192, 71664658, 71659547, 71660235], "C2": [71659727, 71665106, 71664225, 71663324, 71902282, 71657182, 71679705, 71666789, 71661927, 71660290, 71665068, 71670595, 71672508, 71671524, 71673974, 71666543, 71663428, 71673118, 71664615, 71659474, 71664008], "B": [71658438, 71660532, 71661422, 71660555, 71902225, 71683862, 71659255, 71661835, 71671081, 71672434, 71661140, 71675335, 71666293, 71666358, 71674883, 71661144, 71675700, 71667622], "A": [71654494, 71655402, 71656261, 71655976, 71902195, 71678655, 71654489, 71655616, 71656192, 71666785, 71655624, 71657167, 71655162, 71654706, 71657644, 71657443, 71657488, 71654829, 71654475, 71655371, 71655189]}, "name": "E. Concatenation with intersection", "statement": "Vasya had three strings a, b and s, which consist of lowercase English\r\nletters. The lengths of strings a and b are equal to n, the length of\r\nthe string s is equal to m. Vasya decided to choose a substring of the\r\nstring a, then choose a substring of the string b and concatenate them.\r\nFormally, he chooses a segment [l_1, r_1] (1\r\nleq l_1\r\nleq r_1\r\nleq n) and a segment [l_2, r_2] (1\r\nleq l_2\r\nleq r_2\r\nleq n), and after concatenation he obtains a string a[l_1, r_1] + b[l_2,\r\nr_2] = a_{l_1} a_{l_1 + 1}\r\nldots a_{r_1} b_{l_2} b_{l_2 + 1}\r\nldots b_{r_2}.Now, Vasya is interested in counting number of ways to\r\nchoose those segments adhering to the following conditions: segments\r\n[l_1, r_1] and [l_2, r_2] have non-empty intersection, i.e. there exists\r\nat least one integer x, such that l_1\r\nleq x\r\nleq r_1 and l_2\r\nleq x\r\nleq r_2; the string a[l_1, r_1] + b[l_2, r_2] is equal to the string s.\r\n", "solutions": ["#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nchar A[500010],B[500010],C[1000010];\nchar CA[1500010],BC[1500010];\nint z1[1500010],z2[1500010];\nvoid getz(char*A,int*z,int n){\n\tfor(int i=2,l=1,r=1;i<=n;++i){\n\t\tif(i<=r)z[i]=std::min(z[i-l+1],r-i);\n\t\twhile(A[z[i]+1]==A[z[i]+i])++z[i];\n\t\tif(i+z[i]>r)l=i,r=i+z[i];\n\t}\n}\nint n,m,a[500010],b[500010];\nll t1[1000010],t2[1000010];\nvoid add(ll*t,int p,ll num){while(p)t[p]+=num,p-=p&-p;}\nll sum(ll*t,int p){ll ret=0;if(!p)++p;while(p<=m)ret+=t[p],p+=p&-p;return ret;}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tn=gi(),m=gi();\n\tscanf(\"%s\",A+1);scanf(\"%s\",B+1);scanf(\"%s\",C+1);\n\tfor(int i=1;i<=m;++i)CA[i]=C[i];\n\tfor(int i=1;i<=n;++i)CA[i+m]=A[i];\n\tfor(int i=1;i<=n;++i)BC[i]=B[i];\n\tfor(int i=1;i<=m;++i)BC[i+n]=C[i];\n\tstd::reverse(BC+1,BC+n+m+1);\n\tgetz(CA,z1,n+m),getz(BC,z2,n+m);\n\tfor(int i=1;i<=n;++i)a[i]=std::min(m-1,z1[i+m]),b[i]=std::min(m-1,z2[n+m-i+1]);\n\tll ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i])add(t1,a[i],a[i]),add(t2,a[i],1);\n\t\tif(i>=m&&a[i-m+1])add(t1,a[i-m+1],-a[i-m+1]),add(t2,a[i-m+1],-1);\n\t\tif(b[i])ans+=sum(t1,m-b[i])+(b[i]-m+1)*sum(t2,m-b[i]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "hashing", "strings", "two pointers"], "dificulty": "2700", "interactive": false}