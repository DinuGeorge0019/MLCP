{
    "link": "https://codeforces.com//contest/1602/problem/A",
    "problemId": "1157770",
    "problem_idx": "A",
    "shortId": "1602A",
    "contest_number": "1602",
    "problem_submissions": {
        "E": [
            133032006,
            133003754,
            133004259,
            133007498,
            133009354,
            133008986,
            133015586,
            133014296,
            133019189,
            133016251,
            133023043,
            133017173,
            133017654,
            133031118,
            133031771,
            133023126,
            133023444,
            133026607,
            133071046,
            133071006,
            133023246,
            133026124
        ],
        "F": [
            133014631,
            133053467,
            133059590,
            133053314,
            133051962,
            133051828,
            133051273,
            133051246,
            133050986,
            133051444,
            133058927,
            154906935,
            133202717
        ],
        "D": [
            133005341,
            132997744,
            132998965,
            133002435,
            132995700,
            132999302,
            133001008,
            133003621,
            133003659,
            132999008,
            132999274,
            133007130,
            133055379,
            133006665,
            133001448,
            133002893,
            133007904,
            133005768,
            133005590,
            133006243,
            133009816
        ],
        "C": [
            132998504,
            132991987,
            132994038,
            132995401,
            132990761,
            132993753,
            132991630,
            132994468,
            132994573,
            133000658,
            132992001,
            132996442,
            132999119,
            132991525,
            132995757,
            132998190,
            132996165,
            132996191,
            132994329,
            132993830
        ],
        "B": [
            132991874,
            132990242,
            132989322,
            132992468,
            132988801,
            132988045,
            132989355,
            132992898,
            148604097,
            132990867,
            133003212,
            132988289,
            133227165,
            132993306,
            133064818,
            132995361,
            132995328,
            132993153,
            132995379,
            132997555,
            132991609,
            132992280,
            132992140
        ],
        "A": [
            132986686,
            132984939,
            132985573,
            132990670,
            132984472,
            132986995,
            132984659,
            132987933,
            148604079,
            132986349,
            132985981,
            132984656,
            133227226,
            132987663,
            132991514,
            132988125,
            132988425,
            132989208,
            132984538,
            132986551,
            132985450,
            132984595
        ]
    },
    "name": "A. Two Subsequences",
    "statement": "You are given a string s. You need to find two non-empty strings a and b\r\nsuch that the following conditions are satisfied: Strings a and b are\r\nboth of s. For each index i, character s_i of string s must belong to of\r\nstrings a or b. String a is minimum possible; string b may be any\r\npossible string. Given string s, print any valid a and b.A string a (b)\r\nis a of a string s if a (b) can be obtained from s by deletion of\r\nseveral (possibly, zero) elements. For example, \"\", \"\", and \"\" are\r\nsubsequences of \"\", while \"\" and \"\" are not.A string x is than a string\r\ny if and only if one of the following holds: x is a prefix of y, but x\r\nne y; in the first position where x and y differ, the string x has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in y.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint read()\n{\n\tint ret=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0')f|=(c=='-'),c=getchar();\n\twhile(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();\n\treturn f?-ret:ret;\n}\nint T;\nconst int maxn=105;\nint n;\nchar s[maxn];\nbool exi[26];\nint main()\n{\n\tT=read();\n\twhile(T--)\n\t{\n\t\tscanf(\"%s\",s+1);n=strlen(s+1);\n\t\tfor(int i=0;i<26;i++)exi[i]=0;\n\t\tfor(int i=1;i<=n;i++)exi[s[i]-'a']=1;\n\t\tfor(int i=0;i<26;i++)\n\t\t{\n\t\t\tif(exi[i])\n\t\t\t{\n\t\t\t\tprintf(\"%c \",i+'a');\n\t\t\t\tbool flag=0;\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(!flag&&s[j]-'a'==i){flag=1;continue;}\n\t\t\t\t\tprintf(\"%c\",s[j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Two Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/95865",
    "editorial": "Note that taking as minimum character in is always optimal ( starts with\r\nminimum possible character and is prefix of any other longer string). In\r\nsuch case, is just all characters from except character from .\r\n"
}