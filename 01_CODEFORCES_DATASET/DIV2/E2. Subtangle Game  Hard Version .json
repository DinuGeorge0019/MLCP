{
    "link": "https://codeforces.com//contest/2005/problem/E2",
    "problemId": "2874766",
    "problem_idx": "E2",
    "shortId": "2005E2",
    "contest_number": "2005",
    "problem_submissions": {
        "D": [
            281235653,
            281227144,
            281213796,
            281208378,
            281200216,
            281210661,
            281229125,
            281218901,
            281212535,
            281243866,
            281350064,
            281350034,
            281349836,
            281237949,
            281234174,
            281333026,
            281241673,
            281234895,
            281296853,
            281392724,
            281392690,
            281390698,
            281222053,
            281226405
        ],
        "E1": [
            281205887,
            281155079,
            281234070,
            281226477,
            281216705,
            281235212,
            281205331,
            281199518,
            281203018,
            281232678,
            281243730,
            281206762,
            281221617,
            281212135,
            281211097,
            281244210,
            281168056,
            281215476,
            281238723,
            281242094
        ],
        "E2": [
            281204742,
            281184010,
            281246880,
            281250832,
            281257196,
            281227631,
            281224421,
            281358152,
            281367297,
            281223410,
            281233931
        ],
        "A": [
            281164039,
            281207460,
            281140596,
            281137242,
            281136929,
            281139795,
            281140415,
            281137198,
            281141021,
            281139668,
            281139628,
            281147187,
            281141192,
            281140604,
            281139734,
            281142096,
            281145579,
            281142356
        ],
        "C": [
            281160355,
            281201042,
            281183655,
            281193050,
            281164715,
            281187878,
            281173957,
            281177930,
            281184031,
            281188476,
            281187130,
            281170696,
            281175121,
            281184097,
            281174240,
            281175117,
            281195983,
            281182012,
            281199232,
            281194476
        ],
        "B1": [
            281144574,
            281205694,
            281155464,
            281146115,
            281148469,
            281157812,
            281152325,
            281156606,
            281157252,
            281159142,
            281158472,
            281156353,
            281163937,
            281156241,
            281152111,
            281152521,
            281167116,
            281156822,
            281160647
        ],
        "B2": [
            281143694,
            281205362,
            281154775,
            281147352,
            281149038,
            281157058,
            281152845,
            281156903,
            281156460,
            281159520,
            281157889,
            281155572,
            281164430,
            281155566,
            281152797,
            281152721,
            281166374,
            281160753,
            281161736
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/133869",
    "editorial": "Let's define dp0i,j\n as the minimal even index k\n (1?k?l\n), such that dpk,i,j\n wins. Define dp1i,j\n similarly for odds. First, fill all of them with ?\n. Then, compute them from the bottom-right cell of the matrix to the top-left cell of the matrix. dp0i,j\n will be the minimal of the following three values:\n\ndp0i+1,j\n (if i=n\n there will be no submatrix left, so dp0i+1,j\n will be ?\n)\n\ndp0i,j+1\n\nLet's define by ind\n the index of bi,j\n in a\n (there are no duplicates in a\n and if there is no bi,j\n there, assign ?\n to ind\n). If dp1i+1,j+1>ind+1\n, which means that dpind+1,i+1,j+1\n loses and ensues the current player's win, then the value of this part will be ind\n. Otherwise, ?\n. This is because, in other cases, the opponent either had a winning position starting from ind+1\n or even earlier in the game, so we can't win from that index.\n\nWe count dp1\n similarly (but we count dp0\n and dp1\n simultaneously for every (i,j)\n).\n\nLastly, if dp11,1=1\n, then Tsovak wins, otherwise, Narek wins.",
    "name": "E2. Subtangle Game  Hard Version ",
    "statement": "Tsovak and Narek are playing a game. They have an array a and a matrix b\r\nof integers with n rows and m columns, numbered from 1. The cell in the\r\ni-th row and the j-th column is (i, j).They are looking for the elements\r\nof a in turns; Tsovak starts first. Each time a player looks for a cell\r\nin the matrix containing the current element of a (Tsovak looks for the\r\nfirst, then Narek looks for the second, etc.). Let’s say a player has\r\nchosen the cell (r, c). The next player has to choose his cell in the\r\nsubmatrix starting at (r + 1, c + 1) and ending in (n, m) (the submatrix\r\ncan be empty if r=n or c=m). If a player cannot find such a cell (or the\r\nremaining submatrix is empty) or the array ends (the previous player has\r\nchosen the last element), then he loses.Your task is to determine the\r\nwinner if the players play optimally.For example, in C++, it is enough\r\nto use the following lines at the start of the function: int main() {\r\nios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);}\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; vector < vector < pair <int , int> > > aparitii;vector < vector <int> > matrice;vector <int> sir , maxim; inline void Solve (){    int lungime , linii , coloane;    cin >> lungime >> linii >> coloane;     aparitii.resize(linii * coloane + 1);    matrice.resize(linii + 1);    sir.resize(lungime + 1);     for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[indice]; }     for (int linie = 1 ; linie <= linii ; linie++)     {        matrice[linie].resize(coloane + 1);        for (int coloana = 1 ; coloana <= coloane ; coloana++)            { cin >> matrice[linie][coloana]; }    }            for (int coloana = 1 ; coloana <= coloane ; coloana++) {        for (int linie = 1 ; linie <= linii ; linie++) {            if (!aparitii[matrice[linie][coloana]].empty() && aparitii[matrice[linie][coloana]].back().second == coloana)                { aparitii[matrice[linie][coloana]].back().first = linie; }            else                { aparitii[matrice[linie][coloana]].push_back({linie , coloana}); }        }    }         matrice.clear();    maxim.resize(coloane + 2);    for (int indice = lungime ; indice ; indice--)    {        int ramas = 0;        for (auto locatie : aparitii[sir[indice]])         {            while (ramas < locatie.second)                { maxim[++ramas] = 0; }             if (maxim[locatie.second + 1] <= locatie.first)                { maxim[ramas] = locatie.first; }        }         while (ramas < coloane)            { maxim[++ramas] = 0; }         for ( ; ramas ; ramas--)            { maxim[ramas] = max(maxim[ramas] , maxim[ramas + 1]); }    }     cout << (maxim[1] ? \"T\\n\" : \"N\\n\");     aparitii.clear();    maxim.clear();    sir.clear();} int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);     int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "games",
        "greedy",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Subtangle Game  Hard Version .json",
    "hint": []
}