{
    "link": "https://codeforces.com//contest/550/problem/C",
    "problemId": "28713",
    "problem_idx": "C",
    "shortId": "550C",
    "contest_number": "550",
    "problem_submissions": {
        "E": [
            11427018,
            11429644,
            11432526,
            11430611,
            11432228,
            11432165,
            11489207,
            11427558,
            11432275,
            11429524,
            11432478,
            11432415,
            11430446,
            11486308
        ],
        "D": [
            11423745,
            11423796,
            11427878,
            11431814,
            11429565,
            11429723,
            11427594,
            11427339,
            11431790,
            11428771,
            11426823,
            11429779,
            11429172,
            11429089,
            11430041
        ],
        "C": [
            11421138,
            11416776,
            11423192,
            11422512,
            11424510,
            11421428,
            11421418,
            11420140,
            11434273,
            11422988,
            11421940,
            11421776,
            11433710,
            11424080,
            11421277,
            11423080,
            11425605
        ],
        "B": [
            11420010,
            11420534,
            11419884,
            11420795,
            11419465,
            11418370,
            11419003,
            11418791,
            11421152,
            11420042,
            11419639,
            11419437,
            11420868,
            11422488,
            11419737,
            11424665,
            11422066,
            11422524
        ],
        "A": [
            11417030,
            11416689,
            11417915,
            11416872,
            11429128,
            11417246,
            11416778,
            11416762,
            11416557,
            11416626,
            11434617,
            11421161,
            11417521,
            11420430,
            11419146
        ]
    },
    "name": "C. Divisibility by Eight",
    "statement": "You are given a non-negative integer , its decimal representation\r\nconsists of at most digits and doesn\u2019t contain leading zeroes.Your task\r\nis to determine if it is possible in this case to remove some of the\r\ndigits (possibly not remove any digit at all) so that the result\r\ncontains at least one digit, forms a non-negative integer, doesn\u2019t have\r\nleading zeroes and is divisible by 8. After the removing, it is\r\nforbidden to rearrange the digits.If a solution exists, you should print\r\nit.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-9;\nconst int oo = 0x3f3f3f3;\nconst int MAXN = (int)1e5 + 10;\n\nbool lookthis(string &s, string &t){\n    int p1 = 0;\n    for (int i = 0; i < s.length() && p1 < t.length(); ++i)\n        if (s[i] == t[p1]) ++p1;\n    return p1 == t.length();\n}\n\nstring getString(int v){\n    if (v == 0) return \"0\";\n    string ans = \"\";\n    while (v){\n        char cur = (v % 10 + '0');\n        ans = cur + ans;\n        v /= 10;\n    }\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    string s; cin >> s;\n\n    for (int i = 0; i < 1000; i += 8){\n        string cur = getString(i);\n        if (lookthis(s, cur)){\n            cout << \"YES\" << endl << cur << endl;\n            exit(0);\n        }\n    }\n    cout << \"NO\" << endl;\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Divisibility by Eight.json",
    "editorial_link": "https://codeforces.com/blog/entry/18329",
    "editorial": "This problem can be solved with at least two different approaches. The\r\nfirst one is based on the \"school\" property of the divisibility by eight\r\nnumber can be divided by eight if and only if its last three digits form\r\na number that can be divided by eight. Thus, it is enough to test only\r\nnumbers that can be obtained from the original one by crossing out and\r\nthat contain at most three digits (so we check only all one-digit,\r\ntwo-digit and three-digit numbers). This can be done in with three\r\nnested loops (here is the length of the original number). Second\r\napproach uses dynamic programming. Let\u00e2\u0080\u0099s calculate , , . The value of dp\r\nis true if we can cross out some digits from the prefix of length such\r\nthat the remaining number gives modulo eight, and false otherwise. This\r\ndp can be calculated in the following way: let be th digit of the given\r\nnumber. Then (just this number). For all such that , (we add current\r\ndigit to some previous result), (we cross out current digit). Answer is\r\n\"YES\" if for some position . For restoring the answer we need to keep\r\nadditional array , which will say from where current value was\r\ncalculated. Complexity of such solution is (again is the length of the\r\noriginal number). Code for DP solution: Spoiler\r\n"
}