{
    "link": "https://codeforces.com//contest/821/problem/E",
    "problemId": "111653",
    "problem_idx": "E",
    "shortId": "821E",
    "contest_number": "821",
    "problem_submissions": {
        "D": [
            28036388,
            28036319,
            28037093,
            41734433,
            28037174,
            28036759,
            28036893,
            28108464,
            28108438,
            28053809,
            28048526,
            28037849,
            28039886,
            28037900,
            28037562,
            28037762,
            28067673,
            28050717
        ],
        "E": [
            28031080,
            28025704,
            28029758,
            28032764,
            28034511,
            28038207,
            28056472,
            28054979,
            28053726,
            28053708,
            28053530,
            28035432,
            28032380,
            28032466,
            67190033,
            28025986,
            28039285,
            28035423,
            28028415,
            28031314,
            28033070,
            28028563,
            28033114,
            28035978,
            28036465,
            28035018
        ],
        "C": [
            28027564,
            28028757,
            28027102,
            28028054,
            28028077,
            28026793,
            28053306,
            28050947,
            28049926,
            28028104,
            28028806,
            28032681,
            28027048,
            28027053,
            28038599,
            28026500,
            28028038,
            28025519,
            28031473,
            28029012,
            28027297,
            28028758,
            28029118
        ],
        "B": [
            28025033,
            28029985,
            28027229,
            28026296,
            28026743,
            28025293,
            28047680,
            28046444,
            28026532,
            28026871,
            28024943,
            28029111,
            28024882,
            28027316,
            28035127,
            28026321,
            28027518,
            28033448,
            28025512,
            28026466,
            28026910
        ],
        "A": [
            28023814,
            28030700,
            28026806,
            28025423,
            28026686,
            28024284,
            28047598,
            28025814,
            28023873,
            28023685,
            28028848,
            28024187,
            28025303,
            28024870,
            28024246,
            28024053,
            28029160,
            28023901,
            28023721,
            28024947,
            28025828
        ]
    },
    "name": "E. Okabe and El Psy Kongroo",
    "statement": "Okabe likes to take walks but knows that spies from the Organization\r\ncould be anywhere; that\u2019s why he wants to know how many different walks\r\nhe can take in his city safely. Okabe\u2019s city can be represented as all\r\npoints such that and are non-negative. Okabe starts at the origin (point\r\n), and needs to reach the point . If Okabe is currently at the point ,\r\nin one step he can go to , , or .Additionally, there are horizontal line\r\nsegments, the -th of which goes from to inclusive, and is at . It is\r\nguaranteed that , , and for . The -th line segment forces Okabe to walk\r\nwith -value in the range when his value satisfies , or else he might be\r\nspied on. This also means he is required to be under two line segments\r\nwhen one segment ends and another begins.Okabe now wants to know how\r\nmany walks there are from the origin to the point satisfying these\r\nconditions, modulo .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define oo 0x3f3f3f3f\n#define cl(x) memset(x, 0, sizeof(x))\n#define maxn 110\n#define maxm 16\n#define mo 1000000007\ntypedef long long ll;\nusing namespace std;\nvoid gn(int &x) {\n\tx = 0; bool f = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') f = 1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9')\n\t\tx = x * 10 + ch - '0', ch = getchar();\n\tif (f) x = -x;\n}\nvoid add(int &a, int b) {\n\ta += b; a %= mo;\n}\nll k, a[maxn], b[maxn];\nint n, c[maxn], m;\nint f[maxn][maxn];\nstruct mat{\n\tint x[maxm][maxm];\n\tvoid init() {\n\t\tcl(x);\n\t}\n}A, B, C;\nmat operator * (const mat &a, const mat &b) {\n\tmat c; c.init();\n\tfor (int i = 0; i <= m; ++i)\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tfor (int k = 0; k <= m; ++k)\n\t\t\t\tadd(c.x[i][j], 1ll * a.x[i][k] * b.x[k][j] % mo);\n\treturn c;\n}\nmat operator ^ (mat a, ll b) {\n\tmat c; c.init(); for (int i = 0; i <= m; ++i) c.x[i][i] = 1;\n\tfor (; b; b >>= 1ll, a = a * a)\n\t\tif (b & 1ll) c = c * a;\n\treturn c;\n}\nint main() {\n\tscanf(\"%d%I64d\", &n, &k);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%I64d%I64d%d\", &a[i], &b[i], &c[i]);\n\tf[0][0] = 1;\n\tb[n] = min(b[n], k);\n\tfor (int k = 1; k <= n; ++k) {\n\t\tA.init(); \n\t\tm = c[k];\n\t\tfor (int i = 0; i <= c[k]; ++i) {\n\t\t\tif (i) A.x[i][i - 1] = 1;\n\t\t\tA.x[i][i] = 1;\n\t\t\tif (i < c[k]) A.x[i][i + 1] = 1;\n\t\t}\n\t\tB = A ^ (b[k] - a[k]);\n\t\tfor (int i = 0; i <= c[k]; ++i) {\n\t\t\tfor (int j = 0; j <= c[k]; ++j)\n\t\t\t\tadd(f[k][i], 1ll * f[k - 1][j] * B.x[j][i] % mo);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][0]);\n\treturn 0;\n}\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "matrices"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Okabe and El Psy Kongroo.json",
    "editorial_link": "https://codeforces.com/blog/entry/52895",
    "editorial": "You can get a naive DP solution by computing f(x,?y), the number of ways to reach the point (x,?y). It's just f(x?-?1,?y?+?1)?+?f(x?-?1,?y)?+?f(x?-?1,?y?-?1), being careful about staying above x axis and under or on any segments.\n\nTo speed it up, note that the transitions are independent of x. This is screaming matrix multiplication! First, if you don't know the matrix exponentiation technique for speeding up DP, you should learn it from here.\n\nNow, let's think of the matrix representation. Since the x dimension is the long one and the y dimension is small, lets store a vector of values dp where dpi is the number of ways to get to a y value of i at the current x value. This will be the initial vector for matrix multiplication.\n\nNow, what about the transition matrix? Since our initial vector has length y and we need a matrix to multiply it with to map it to another vector with length y, we need a y by y matrix. Now, if you think about how matrix multiplication works, you come up with an idea like this: put a 1 in the entry (i,j) if from a y value of i we can reach a y value of j (i.e. |i?-?j|???1). Don't believe me, multiply some vector times a matrix of this form to see how and why the transition works.\n\nYou can then build this matrix quickly and then matrix exponentiate for under every segment and multiply by the initial vector, then make the result as the new initial vector for the next segment. You should make sure to remove values from the vector if the next segment is lower, or add values to the vector if the next segment is higher. This gives complexity O(nh3 log w) where h?=?16 and w?=?k."
}