{"link": "https://codeforces.com//contest/1604/problem/B", "problemId": "1163963", "problem_idx": "B", "shortId": "1604B", "contest_number": "1604", "problem_submissions": {"E": [133665266, 133665330, 133659495, 133662698, 133665754, 133665695, 133667913, 133670360, 133670641, 133670753, 133676806, 133672911, 133673104, 133674991, 133676775, 133679158, 133677605, 133683514, 133682221, 133683564], "D": [133632914, 133634675, 133646997, 133640774, 133645923, 133643402, 133646411, 133639935, 133645645, 133646807, 133649571, 133658060, 133654131, 133649231, 133663364, 133653039, 133654438, 133653052, 133653688, 133661097], "C": [133630411, 133638085, 133632064, 133625685, 133635045, 133633934, 133631657, 133625520, 133634475, 133635072, 133633002, 133634939, 133644373, 133640982, 133632402, 133642673, 133644331, 133633661, 133631330, 133642353], "B": [133625396, 133621698, 133626014, 133619603, 134090905, 133624581, 133623770, 133621459, 133634337, 133628885, 133630875, 133627020, 133622232, 133627089, 133635361, 133623364, 133634078, 133623924, 133625391, 133624417, 133621609], "A": [133617599, 133618208, 133617413, 133617141, 134090791, 133617364, 133617444, 133617618, 133619480, 133619710, 133620324, 133618064, 133617109, 133626724, 133628136, 133617925, 133618078, 133619587, 133619073, 133618066, 133617633], "F": [133735630, 133826813]}, "name": "B. XOR Specia-LIS-t", "statement": "YouKn0wWho has an integer sequence a_1, a_2,\r\nldots a_n. Now he will split the sequence a into one or more consecutive\r\nsubarrays so that each element of a belongs to exactly one subarray. Let\r\nk be the number of resulting subarrays, and h_1, h_2,\r\nldots, h_k be the lengths of the longest increasing subsequences of\r\ncorresponding subarrays.For example, if we split [2, 5, 3, 1, 4, 3, 2,\r\n2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2,\r\n1].YouKn0wWho wonders if it is possible to split the sequence a in such\r\na way that the bitwise XOR of h_1, h_2,\r\nldots, h_k is equal to 0. You have to tell whether it is possible.The\r\nlongest increasing subsequence (LIS) of a sequence b_1, b_2,\r\nldots, b_m is the longest sequence of valid indices i_1, i_2,\r\nldots, i_k such that i_1\r\nlt i_2\r\nlt\r\nldots\r\nlt i_k and b_{i_1}\r\nlt b_{i_2}\r\nlt\r\nldots\r\nlt b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which\r\nhas length 3.An array c is a subarray of an array b if c can be obtained\r\nfrom b by deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define N 100009\n#define INF 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ninline ll read() {\n    ll x=0,f=1;int c=getchar();\n    while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}\n    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    return x*f;\n}\nll flag,a[N],n,t;\nint main(){\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n    t=read();\n    while(t--){\n        n=read(),flag=0;\n        for(int i=1;i<=n;i++){\n            a[i]=read();\n            if(i!=1&&a[i]<=a[i-1]) flag=1;\n        }\n        if(n%2==0){printf(\"YES\\n\");continue;}\n        if(flag){printf(\"YES\\n\");continue;}\n        printf(\"NO\\n\");\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": [], "dificulty": "1100", "interactive": false}