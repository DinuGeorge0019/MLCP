{
    "link": "https://codeforces.com//contest/1228/problem/B",
    "problemId": "424243",
    "problem_idx": "B",
    "shortId": "1228B",
    "contest_number": "1228",
    "problem_submissions": {
        "F": [
            61496806,
            61502870,
            61502190,
            61505436,
            61526774,
            61501386,
            61506794,
            61506003,
            61507242,
            61528062,
            61506930,
            61504933,
            61527679,
            61758392,
            61506804,
            61501659
        ],
        "E": [
            61487066,
            61484839,
            61491424,
            61489793,
            61526757,
            61494082,
            61491501,
            61493504,
            61494383,
            61528054,
            61491524,
            61495860,
            61488344,
            61491222,
            61486950,
            61487675,
            61498567,
            61492377,
            61492698,
            61509475,
            61488264
        ],
        "D": [
            61485310,
            61482745,
            61489582,
            61486586,
            61526744,
            61490366,
            61487311,
            61489384,
            61491690,
            61528041,
            61498727,
            61505643,
            61485067,
            61484265,
            61490334,
            61491347,
            61491538,
            61486214,
            61487124,
            61487752,
            61482893
        ],
        "C": [
            61480399,
            61479345,
            61481687,
            61481376,
            61526733,
            61486187,
            61481654,
            61482779,
            61486226,
            61528029,
            61481914,
            61486289,
            61481778,
            61480281,
            61475855,
            61480938,
            61484833,
            61479319,
            61482763,
            61482555,
            61495805
        ],
        "B": [
            61476242,
            61476828,
            61478048,
            61477189,
            61526720,
            61483135,
            61479399,
            61477633,
            61477664,
            61528022,
            61483663,
            61478266,
            61477452,
            61477008,
            61479768,
            61476788,
            61509875,
            61476696,
            61478410,
            61478919,
            61476259
        ],
        "A": [
            61473188,
            61476420,
            61473176,
            61473720,
            61526708,
            61477230,
            61473216,
            61473745,
            61473523,
            61528006,
            61479593,
            61475038,
            61472935,
            61473261,
            61477228,
            61473405,
            61476821,
            61473215,
            61474472,
            61475483,
            61474687
        ]
    },
    "name": "B. Filling the Grid",
    "statement": "Suppose there is a h\r\ntimes w grid consisting of empty or full cells. Let\u2019s make some\r\ndefinitions: r_{i} is the number of consecutive full cells connected to\r\nthe left side in the i-th row (1\r\nle i\r\nle h). In particular, r_i=0 if the leftmost cell of the i-th row is\r\nempty. c_{j} is the number of consecutive full cells connected to the\r\ntop end in the j-th column (1\r\nle j\r\nle w). In particular, c_j=0 if the topmost cell of the j-th column is\r\nempty. In other words, the i-th row starts exactly with r_i full cells.\r\nSimilarly, the j-th column starts exactly with c_j full cells. You have\r\nvalues of r and c. Initially, all cells are empty. Find the number of\r\nways to fill grid cells to satisfy values of r and c. Since the answer\r\ncan be very large, find the answer modulo 1000000007\r\n,(10^{9} + 7). In other words, find the remainder after division of the\r\nanswer by 1000000007\r\n,(10^{9} + 7).\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1010, P = 1000000007;\n\nint vis[N][N];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    int r;\n    scanf(\"%d\", &r);\n    for (int j = 1; j <= r; ++j)\n      vis[i][j] = 1;\n    vis[i][r + 1] = -1;\n  }\n  for (int j = 1; j <= m; ++j) {\n    int c;\n    scanf(\"%d\", &c);\n    for (int i = 1; i <= c; ++i)\n      if (vis[i][j] == -1) {\n        puts(\"0\");\n        return 0;\n      } else\n        vis[i][j] = 1;\n    if (vis[c + 1][j] == 1) {\n      puts(\"0\");\n      return 0;\n    }\n    vis[c + 1][j] = -1;\n  }\n  int ans = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (vis[i][j] == 0)\n        ans = ans * 2 % P;\n  printf(\"%d\\n\", ans);\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Filling the Grid.json",
    "editorial_link": "https://codeforces.com//blog/entry/70162",
    "editorial": "You can see some observations below; and values reserves some cells to\r\nbe full, and some cells to be empty. Because they have to satisfy number\r\nof consecutive full cells in their row/column. If some cell is reserved\r\nto be full by some values and reserved to be empty by some other values,\r\nthen it is impossible to fill grid. Let\u00e2\u0080\u0099s call this kind of cell as\r\ninvalid cell. If there is no invalid cell, then the answer is where\r\nmeans the number of unreserved cells, because setting state of\r\nunreserved cells doesn\u00e2\u0080\u0099t affect validity of grid. For easier\r\nunderstanding, please look at the pictures below. Black cells are\r\nreserved to be full by some or value. White cells are reserved to be\r\nempty by some or value. White cells are unreserved cells. Red cells are\r\ninvalid cells. This is the explanation of the first example. There is\r\nunreserved cell, so the answer is . This is one of the impossible cases.\r\nThat red cell is reserved to be full by , but reserved to be empty by .\r\nSo this is impossible. Time complexity is .\r\n"
}