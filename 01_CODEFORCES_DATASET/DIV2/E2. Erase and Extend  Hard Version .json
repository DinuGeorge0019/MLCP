{
    "link": "https://codeforces.com//contest/1537/problem/E2",
    "problemId": "1020037",
    "problem_idx": "E2",
    "shortId": "1537E2",
    "contest_number": "1537",
    "problem_submissions": {
        "F": [
            119857657,
            119865425,
            119870905,
            119869709,
            119878489,
            119841761,
            119876881,
            119827052,
            119888747,
            119879106,
            119880915,
            119859997,
            119866305,
            119891935,
            119902585,
            119888207,
            119905201
        ],
        "E2": [
            119835892,
            119833759,
            119835378,
            119850866,
            119864462,
            119850270,
            119848823,
            119846727,
            119864146,
            119866899,
            119862789,
            119890309,
            119915102,
            119899495,
            119871715,
            119862744,
            119873692,
            119862189
        ],
        "E1": [
            119835645,
            119833327,
            119834682,
            119850640,
            119850149,
            119850091,
            119849196,
            119847381,
            119863846,
            119866683,
            119861833,
            119862580,
            119843723,
            119853461,
            119862505,
            119872582,
            119862557
        ],
        "C": [
            119829240,
            119814686,
            119839941,
            119823683,
            119824487,
            119855572,
            119826402,
            119863416,
            119822210,
            119816816,
            119835116,
            119830407,
            119824166,
            119824127,
            119821757,
            119820808,
            119828361
        ],
        "D": [
            119827244,
            119843258,
            119855094,
            119838364,
            119835110,
            119859731,
            119840938,
            119859070,
            119842821,
            119845056,
            119849019,
            119838171,
            119834738,
            119848959,
            119837547,
            119830929,
            119842836
        ],
        "B": [
            119806043,
            119808907,
            119822215,
            119810718,
            119813042,
            119826639,
            119819938,
            119868704,
            119815398,
            119811429,
            119818874,
            119840047,
            119815192,
            119806896,
            119810508,
            119848797,
            119816830
        ],
        "A": [
            119804349,
            119804485,
            119818462,
            119804932,
            119804259,
            119830936,
            119816677,
            119871286,
            119815557,
            119804275,
            119808687,
            119804663,
            119806484,
            119804635,
            119804555,
            119843057,
            119806262
        ]
    },
    "name": "E2. Erase and Extend  Hard Version ",
    "statement": "You have a string s, and you can do two types of operations on it:\r\nDelete the last character of the string. Duplicate the string: s:=s+s,\r\nwhere + denotes concatenation. You can use each operation any number of\r\ntimes (possibly none).Your task is to find the lexicographically\r\nsmallest string of length exactly k that can be obtained by doing these\r\noperations on string s.A string a is lexicographically smaller than a\r\nstring b if and only if one of the following holds: a is a prefix of b,\r\nbut a\r\nne b; In the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <random>\n#include \"map\"\ntypedef double ld;\ntypedef long long ll;\n#define all(x) x.begin(), x.end()\nusing namespace std;\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    int ind = 0;\n    string s2;\n    s2 += s[0];\n    // 4 3 4 2 4 4\n    for (int i = 1; i < n; ++i) {\n        if (s[i] > s[ind])\n            break;\n        s2 += s[i];\n        if (s[i] == s[ind]) {\n            ind++;\n        } else {\n            ind = 0;\n        }\n    }\n    while (ind != 0) {\n        s2.pop_back();\n        ind--;\n    }\n    for (int i = 0; i < k; ++i) {\n        cout << s2[i % s2.size()];\n    }\n    cout << '\\n';\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int q = 1;\n    while (q--) solve();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "hashing",
        "string suffix structures",
        "strings",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Erase and Extend  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/91381",
    "editorial": "If the parity of the sum of the initial values doesn\u00e2\u0080\u0099t match the parity\r\nof the sum of the target values then there is no solution. Because is an\r\ninteger and we always add the value to the sum of the initial values in\r\neach operation it\u00e2\u0080\u0099s easy to notice that the parity of the sum of the\r\ninitial values never changes.Otherwise, let\u00e2\u0080\u0099s consider cases:2) The\r\ngraph is bipartite.3) The graph is not bipartite.If the graph is\r\nbipartite, let the nodes be coloured red and blue with the condition\r\nthat all the neighbors of any red node are blue and all the neighbours\r\nof any blue node are red. Let us call for each blue node and for each\r\nred node. We want to determine if we can make for each node, which is\r\nequivalent to saying and . We notice that the difference between and is\r\ninvariant in a bipartite graph because all operations will add to and at\r\nthe same time. So to make and we need to be equal to initially.If the\r\ngraph is not bipartite, then it is always possible because if the graph\r\nis not bipartite, it contains two neighboring vertices of the same\r\ncolor, which can be used to add or subtract from their color sum.\r\n"
}