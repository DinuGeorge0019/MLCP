{
    "link": "https://codeforces.com//contest/1748/problem/E",
    "problemId": "1632967",
    "problem_idx": "E",
    "shortId": "1748E",
    "contest_number": "1748",
    "problem_submissions": {
        "F": [
            180651535,
            180677196,
            181105630,
            180664800,
            181374019,
            180658674,
            180695681,
            180655443,
            180742899
        ],
        "E": [
            180637637,
            180628826,
            180634324,
            180638179,
            180642534,
            180644596,
            180636672,
            181374010,
            180641599,
            180630018,
            180635790,
            180636019,
            180643172,
            180645795,
            180743214,
            180638578,
            180968480,
            180635598,
            180635749,
            180647581,
            180646430,
            180647569,
            180646469
        ],
        "D": [
            180633726,
            180624258,
            180629104,
            180634928,
            180631821,
            180631702,
            180639756,
            181373997,
            180632286,
            180647106,
            180647136,
            180632247,
            180695817,
            180636057,
            180743200,
            180643463,
            180968348,
            180645591,
            180644512,
            180637600,
            180635174,
            180636597,
            180633591
        ],
        "C": [
            180627069,
            180617304,
            180624008,
            180625748,
            180621980,
            180623459,
            180622660,
            181373988,
            180628239,
            180625933,
            180628451,
            180622380,
            180627739,
            180622385,
            180743249,
            180625569,
            180968325,
            180627789,
            180629833,
            180622612,
            180628495,
            180626202,
            180630095
        ],
        "B": [
            180622705,
            180613102,
            180624297,
            180615500,
            180617761,
            180619392,
            180619994,
            181373974,
            180622730,
            180621189,
            180616618,
            180613628,
            180622929,
            180618545,
            180743160,
            180616164,
            180968311,
            180615958,
            180614803,
            180618593,
            180622095,
            180621136
        ],
        "A": [
            180613831,
            180610319,
            180610882,
            180610734,
            180612490,
            180611586,
            180619768,
            181373957,
            180612666,
            180610632,
            180610694,
            180610429,
            180620047,
            180612131,
            180743129,
            180611466,
            180968275,
            180611045,
            180610310,
            180612188,
            180613830,
            180610743
        ]
    },
    "name": "E. Yet Another Array Counting Problem",
    "statement": "The position of the leftmost maximum on the segment [l; r] of array x =\r\n[x_1, x_2,\r\nldots, x_n] is the smallest integer i such that l\r\nle i\r\nle r and x_i =\r\nmax(x_l, x_{l+1},\r\nldots, x_r).You are given an array a = [a_1, a_2,\r\nldots, a_n] of length n. Find the number of integer arrays b = [b_1,\r\nb_2,\r\nldots, b_n] of length n that satisfy the following conditions: 1\r\nle b_i\r\nle m for all 1\r\nle i\r\nle n; for all pairs of integers 1\r\nle l\r\nle r\r\nle n, the position of the leftmost maximum on the segment [l; r] of the\r\narray b is equal to the position of the leftmost maximum on the segment\r\n[l; r] of the array a. Since the answer might be very large, print its\r\nremainder modulo 10^9+7.\r\n",
    "solutions": [
        "# include <cstdlib>\n# include <cstring>\n# include <vector>\n# include <algorithm>\n# include <cstdio>\n\nnamespace khin {\n  using namespace std;\n  namespace main {\n    inline namespace source {\n      typedef unsigned long int ulong;\n      typedef unsigned short int ushort;\n      typedef unsigned int uint;\n    }\n    namespace e { void main(); }\n  }\n}\n\nint main() { khin::main::e::main(); }\n\nnamespace khin::main::e {\n  namespace test_case {\n    constexpr uint mod(1'000'000'007);\n    constexpr uint n_max(200'000);\n    uint n; uint m, a[n_max + 1];\n    uint d[n_max + 1][2];\n    vector<uint> f[n_max + 1];\n    void search(uint const x) {\n      f[x].resize(m, 1);\n      if (d[x][0]) {\n        uint const d(test_case::d[x][0]);\n        search(d);\n        for (uint i(0); i < m; ++i)\n          f[x][i] = 1ull * f[x][i] * (i ? f[d][i - 1] : 0) % mod;\n        f[d].clear();\n      }\n      if (d[x][1]) {\n        uint const d(test_case::d[x][1]);\n        search(d);\n        for (uint i(0); i < m; ++i)\n          f[x][i] = 1ull * f[x][i] * f[d][i] % mod;\n        f[d].clear();\n      }\n      for (uint i(1); i < m; ++i)\n        f[x][i] = (f[x][i] + f[x][i - 1]) % mod;\n    }\n    void main() {\n      scanf(\"%u%u\", &n, &m);\n      for (uint i(1); i <= n; ++i) scanf(\"%u\", &a[i]);\n      vector<uint> s;\n      for (uint i(1); i <= n; ++i) {\n        while (s.size() > 1 && a[s[s.size() - 2]] < a[i])\n          d[s[s.size() - 2]][1] = s.back(), s.pop_back();\n        if (!s.empty() && a[s.back()] < a[i])\n          d[i][0] = s.back(), s.pop_back();\n        s.push_back(i);\n      }\n      while (s.size() > 1)\n        d[s[s.size() - 2]][1] = s.back(), s.pop_back();\n      search(s.back());\n      printf(\"%u\\n\", f[s.back()].back()), f[s.back()].clear();\n      memset(d + 1, 0x00, n * sizeof(uint[2]));\n    }\n  }\n  void main() {\n    ushort t;\n    scanf(\"%hu\", &t);\n    while (test_case::main(), --t);\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dp",
        "flows",
        "math",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Yet Another Array Counting Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/108319",
    "editorial": "SolutionLet be the position of the leftmost maximum in the interval ,\r\n.Let\u00e2\u0080\u0099s consider an interval such that . For the sake of simplicity,\r\nlet\u00e2\u0080\u0099s assume that .Let and . Since is the leftmost maximum in , and ,\r\nthe following conditions must hold for array : Let\u00e2\u0080\u0099s consider a binary\r\ntree where the children of node are nodes and , for every . Note that if\r\n, is not defined, and, as such, node will have no left child. Similarly,\r\nif , then node will have no right child.Let be equal to the number of\r\nways to assign values to every element from the subtree rooted in , if .\r\nIf has a left child and , then ; Otherwise, if has two children, then ;\r\nIf only has a left child, then ; If only has a right child, then ; If\r\nhas no children, then . To optimise the transitions, we\u00e2\u0080\u0099ll also need to\r\ncompute alongside our normal .Intended time complexity per testcase:\r\nAdditional implementation detailsIn order to construct the binary tree,\r\nwe can use a recursive divide and conquer function to split our current\r\ninterval into two new intervals and .Additionally, we can also compute\r\nthe values of and inside after calling and divide .Range leftmost\r\nmaximumum queries can be answered in using a sparse table, see the model\r\nsolution for more information.\r\n"
}