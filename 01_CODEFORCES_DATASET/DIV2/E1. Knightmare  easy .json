{"link": "https://codeforces.com//contest/1201/problem/E1", "problemId": "383828", "problem_idx": "E1", "shortId": "1201E1", "contest_number": "1201", "problem_submissions": {"D": [58282984, 58285276, 58288662, 58287120, 58288428, 58288088, 58287196, 58286940, 58293709, 58290148, 58292701, 58291902, 58289292, 58289457, 58289281, 58288685, 58285856, 58292531], "C": [58274262, 58275378, 58275429, 116632449, 116631019, 58275062, 58276963, 58278514, 58276803, 58277770, 58276940, 58274085, 58273643, 58275528, 58274524, 58274700, 58277775, 58274570, 58271303, 58273056], "B": [58271978, 58270841, 58272256, 58272912, 58273123, 58271671, 58271261, 58275291, 58272166, 58271760, 58271053, 58271553, 58271578, 58272097, 58275948, 58271369, 58278712, 58274589], "A": [58270131, 58270185, 58270752, 58271799, 58270882, 58270392, 58270232, 58273480, 58270504, 58270476, 58308382, 58270298, 58270453, 58270435, 58270635, 58270730, 58270229, 58270187, 58276880], "E1": [58306902, 58388117, 58386937], "E2": [58306808]}, "name": "E1. Knightmare  easy ", "statement": "Alice and Bob are playing a game on the chessboard of size n\r\ntimes m where n and m are . The rows are numbered from 1 to n and the\r\ncolumns are numbered from 1 to m. There are two knights on the\r\nchessboard. A white one initially is on the position (x_1, y_1), while\r\nthe black one is on the position (x_2, y_2). Alice will choose one of\r\nthe knights to play with, and Bob will use the other one.The Alice and\r\nBob will play in turns and whoever controls knight starts the game.\r\nDuring a turn, the player must move their knight adhering the chess\r\nrules. That is, if the knight is currently on the position (x, y), it\r\ncan be moved to any of those positions (as long as they are inside the\r\nchessboard): (x+1, y+2), (x+1, y-2), (x-1, y+2), (x-1, y-2),(x+2, y+1),\r\n(x+2, y-1), (x-2, y+1), (x-2, y-1). We all know that knights are\r\nstrongest in the middle of the board. Both knight have a single position\r\nthey want to reach: the owner of the white knight wins if it captures\r\nthe black knight or if the white knight is at (n/2, m/2) and this\r\nposition is not under attack of the black knight at this moment; The\r\nowner of the black knight wins if it captures the white knight or if the\r\nblack knight is at (n/2+1, m/2) and this position is not under attack of\r\nthe white knight at this moment. Formally, the player who captures the\r\nother knight wins. The player who is at its target square ((n/2, m/2)\r\nfor white, (n/2+1, m/2) for black) and this position is not under\r\nopponent\u2019s attack, also wins.A position is under attack of a knight if\r\nit can move into this position. Capturing a knight means that a player\r\nmoves their knight to the cell where the opponent\u2019s knight is.If Alice\r\nmade 350 moves and nobody won, the game is a draw.Alice is unsure in her\r\nchess skills, so she asks you for a help. Choose a knight and win the\r\ngame for her. It can be shown, that Alice always has a winning strategy.\r\n", "solutions": ["#include<bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2}, dy[8] = {2, -2, 2, -2, 1, -1, 1, -1};\nconst int N = 1005;\n\nint n, m, dis1[N][N], dis2[N][N];\n\nbool chk(int x,int y) {\n\treturn x >= 1 && x <= n && y >= 1 && y <= m;\n}\n\nvoid run(int x, int y, int dis[N][N]) {\n\tvector<pair<int,int>> q;\n\tdis[x][y]=1;\n\tq.push_back(make_pair(x,y));\n\tfor(int i = 0; i < q.size(); i++)\n\t{\n\t\tint x = q[i].first, y = q[i].second;\n\t\tfor (int j = 0; j < 8; j++)\n\t\t\tif (chk(x + dx[j], y + dy[j]) && !dis[x + dx[j]][y + dy[j]]) {\n\t\t\t\tq.push_back(make_pair(x + dx[j], y + dy[j]));\n\t\t\t\tdis[x + dx[j]][y + dy[j]] = dis[x][y] + 1;\n\t\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tdis[i][j]--;\n}\n\nint get(int x0, int y0, int x1, int y1, bool st) {\n\tif(!st) {\n\t\tif (x0 == n / 2 && y0 == m / 2) return 0;\n\t\tfor (int i = 0; i < 8; i++) if (x0 + dx[i] == x1 && y0 + dy[i] == y1) return 0;\n\t\tif (dis1[x0][y0] <= dis2[x1][y1]) {\n\t\t\tif (dis1[x0][y0] < dis1[x1][y1] || ((dis1[x0][y0] ^ dis1[x1][y1]) & 1)) return 0;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (dis2[x1][y1] + 1 < dis2[x0][y0] || (~(dis2[x1][y1] ^ dis2[x0][y0]) & 1)) return 1;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (x1 == n / 2 + 1 && y1 == m / 2) return 1;\n\t\tfor (int i = 0; i < 8; i++) if (x0 + dx[i] == x1 && y0 + dy[i] == y1) return 1;\n\t\tif (dis2[x1][y1] <= dis1[x0][y0]) {\n\t\t\tif (dis2[x1][y1] < dis2[x0][y0] || ((dis2[x1][y1] ^ dis2[x0][y0]) & 1)) return 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (dis1[x0][y0] + 1 < dis1[x1][y1] || (~(dis1[x0][y0] ^ dis1[x1][y1]) & 1)) return 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n\nset<ll> vis;\n\nint main() {\n\tint x0, y0, x1, y1;\n\tscanf(\"%d%d%d%d%d%d\", &n, &m, &x0, &y0, &x1, &y1);\n\tvis.insert((ll)x0 << 30 | y0 << 20 | x1 << 10 | y1);\n\trun(n / 2, m / 2, dis1);\n\trun(n / 2 + 1, m / 2, dis2);\n\tbool mt = get(x0, y0, x1, y1, 0) == 1;\n\tputs(mt ? \"BLACK\" : \"WHITE\");\n\tfflush(stdout);\n\tbool turn = 0;\n\tfor (; ; turn ^= 1, vis.insert((ll)x0 << 30 | y0 << 20 | x1 << 10 | y1)) {\n\t\tif (turn != mt) {\n\t\t\tif (turn == 0) scanf(\"%d%d\", &x0, &y0);\n\t\t\telse scanf(\"%d%d\", &x1, &y1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (turn == 0) {\n\t\t\tint fdis = 1e9, ox, oy;\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tif (chk(x0 + dx[i], y0 + dy[i]) && (get(x0 + dx[i], y0 + dy[i], x1, y1, 1) == 0 || (x0 + dx[i] == x1 && y0 + dy[i] == y1))) {\n\t\t\t\t\tif (!vis.count((ll)(x0 + dx[i]) << 30 | (y0 + dy[i]) << 20 | x1 << 10 | y1) && dis1[x0 + dx[i]][y0 + dy[i]] < fdis) {\n\t\t\t\t\t\tox = x0 + dx[i], oy = y0 + dy[i];\n\t\t\t\t\t\tfdis = dis1[x0 + dx[i]][y0 + dy[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx0 = ox, y0 = oy;\n\t\t\tprintf(\"%d %d\\n\", ox, oy);\n\t\t\tfflush(stdout);\n\t\t\tif (ox == n / 2 && oy == m / 2) return 0;\n\t\t\tif (ox == x1 && oy == y1) return 0;\n\t\t} else {\n\t\t\tint fdis = 1e9, ox, oy;\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tif (chk(x1 + dx[i], y1 + dy[i]) && (get(x0, y0, x1 + dx[i], y1 + dy[i], 0) == 1 || (x1 + dx[i] == x0 && y1 + dy[i] == y0))) {\n\t\t\t\t\tif (!vis.count((ll)x0 << 30 | y0 << 20 | (x1 + dx[i]) << 10 | (y1 + dy[i])) && dis2[x1 + dx[i]][y1 + dy[i]] < fdis) {\n\t\t\t\t\t\tox = x1 + dx[i], oy = y1 + dy[i];\n\t\t\t\t\t\tfdis = dis2[x1 + dx[i]][y1 + dy[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx1 = ox, y1 = oy;\n\t\t\tprintf(\"%d %d\\n\", ox, oy);\n\t\t\tfflush(stdout);\n\t\t\tif (ox == n / 2 + 1 && oy == m / 2) return 0;\n\t\t\tif (ox == x0 && oy == y0) return 0;\n\t\t}\n\t}\n}"], "input": "", "output": "", "tags": ["graphs", "interactive", "shortest paths"], "dificulty": "2900", "interactive": false}