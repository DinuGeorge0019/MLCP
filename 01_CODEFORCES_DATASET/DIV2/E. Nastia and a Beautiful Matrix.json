{
    "link": "https://codeforces.com//contest/1521/problem/E",
    "problemId": "977647",
    "problem_idx": "E",
    "shortId": "1521E",
    "contest_number": "1521",
    "problem_submissions": {
        "D": [
            115581818,
            115594850,
            115598612,
            115603691,
            115599448,
            115601993,
            115608478,
            115569159,
            115612872,
            115604589,
            115610795,
            115602271,
            115608146,
            115607408,
            115599985
        ],
        "C": [
            115571933,
            115576814,
            115571686,
            115575287,
            115554792,
            115578008,
            115583346,
            115581715,
            115563254,
            115563941,
            115569253,
            115571673,
            115577961,
            115579502,
            115578223,
            115583699
        ],
        "B": [
            115555782,
            115541222,
            115542122,
            115539078,
            115535984,
            115537884,
            115535617,
            115535973,
            115540952,
            115589944,
            115543027,
            115535929,
            115532822,
            115550853,
            115551249,
            115536556,
            115547431,
            115535420
        ],
        "A": [
            115533383,
            115523492,
            115530232,
            115525696,
            115523586,
            115527609,
            115525343,
            115525115,
            115586248,
            115523901,
            115524582,
            115523559,
            115530582,
            115527602,
            115524514,
            115526011,
            115524612
        ],
        "E": [
            115603853,
            115608158,
            115614666,
            116024421,
            115649428,
            115659057,
            115613282,
            115649743,
            115610712
        ]
    },
    "name": "E. Nastia and a Beautiful Matrix",
    "statement": "Let a_i be how many numbers i (1\r\nle i\r\nle k) you have.An n\r\ntimes n matrix is called beautiful if it contains the numbers you have,\r\nand for 2\r\ntimes 2 submatrix of the original matrix is satisfied: The number of\r\noccupied cells doesn’t exceed 3; The numbers on each diagonal are\r\ndistinct. Make a beautiful matrix of size.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"avx,avx2,sse,sse2\")\n\n\n    #define int long long\n    \n\n#define YES cout<<\"YES\\n\";return; \n#define NO cout<<\"NO\\n\";return; \n#define write(a) cout<<a<<\"\\n\";return; \n#define F first \n#define S second\n\nusing namespace std;\nusing vi=vector<int>; \nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\nlong long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n}\nlong long gcd(long long a, long long b) {\n    if (a==0) return b;\n    if (b==0) return a;\n    if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n}\nint prime(int p) { // 1 - простое\nif (p==1) return 0; \n    for (int i=2;i*i<=p;i++) {\n    if (p%i==0 && i<p) return i;  \n    }\n    return 1;\n}\n        \n int inv(int a, int mod) {\n    return powmod(a,mod-2,mod); \n}\n            \n int random_modul() {\n        \n    uniform_int_distribution <int> u1(1e9, 2e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n    \ntemplate <typename T1> void ifmax(T1 &max, T1 kek) {\n    if (kek>max) max=kek; \n    return; \n}\ntemplate <typename T1> void ifmin(T1 &min, T1 kek) {\n    if (kek<min) min=kek;\n    return; \n}\n     \n\ntemplate <typename T1> istream& operator>> (std::istream& in, pair<T1,T1> & a) {\nin>>a.first>>a.second; \nreturn in; \n    \n}\n    \ntemplate <typename T1> istream& operator>> (std::istream& in, vector<T1> & a) {\n    for (int i=0;i<a.size();i++) in>>a[i]; \n    return in;\n} \n     \ntemplate <typename T1>  ostream& operator<< (std::ostream& out, vector <T1> &b) {\n    for (int i=0;i<b.size();i++) out<<b[i]; \n    return out; \n} \ntemplate <typename T1> void sort(vector <T1> &m) {\n    sort(m.begin(),m.end());\n}\n\ntemplate <typename T1> void reverse(vector <T1> &m) {\n reverse(m.begin(),m.end());\n}\nint mod=1000000007; \nint fac[200005];\nint inv_fac[200005]; \nint co(int a, int b) {\n    int ans=1;\n    ans*=fac[b]; \n    ans*=inv_fac[b-a]; ans%=mod; \n    ans*=inv_fac[a]; \n    return ans%mod; \n}    \n\n\nvoid solve () {\n           \n           \n     /* ---- !! F, S !!  ---- */\n         \n   int k,a;\n   cin>>k>>a;\n   vector <pair<int,int>> m(a);\n   for (int i=0;i<a;i++) {\n       cin>>m[i].first; m[i].second=i; \n   }\n   sort(m);\n   for (int i=1;i<=1000;i++) {\n       if (i%2==0) {\n           int blocked=(i*i)/4; \n           int free=(i*i)/4;\n           int maximal=(i*i)/4;\n           int check=1; \n           if ((3*i*i)/4<k) check=0;\n           if (check) {\n               int need=0; \n               for (int j=a-1;j>=0;j--) {\n                   if (m[j].first>maximal) {need+=m[j].first-maximal; } else break; \n               }\n               if (need>free) check=0; \n           }\n           if (check==1) {\n               cout<<i<<\"\\n\"; \n               vector <vector <int>> ans(i, vector <int> (i));  \n               int BLOCK=0; \n               vector <pair<int,int>> p_free; \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       if (x%2==1 && y%2==1) {\n                           ans[x][y]=BLOCK; \n                       }\n                       if (x%2==0 && y%2==0) {\n                          p_free.push_back({x,y}); \n                       }\n                   }\n               }\n               \n                   int find=-1; \n                   if (m[a-1].first>=maximal) {find=m[a-1].second+1; }\n                   vector <pair<int,int>> omegalul1;\n                   vector <pair<int,int>> omegalul2;\n                   for (int x=0;x<i;x++) {\n                       for (int y=0;y<i;y++) {\n                           if (x%2==0 && y%2==1) omegalul1.push_back({x,y});\n                           if (x%2==1 && y%2==0) omegalul2.push_back({x,y}); \n                       }\n                   }\n                   \n                  \n                   if (find!=-1) {\n                      for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       if (x%2==0 && y%2==1) {\n                           ans[x][y]=find; \n                       }\n                       \n                   }\n               }\n               m[a-1].first-=maximal; \n               for (int j=0;j<omegalul2.size();j++) p_free.push_back(omegalul2[j]); \n               int cur=0; \n               for (int j=a-1;j>=0;j--) {\n                   //cout<<m[j].first<<\" \"; \n                   for (int qq=0;qq<m[j].first;qq++) {\n                       int x1=p_free[cur].first; \n                       int y1=p_free[cur].second; \n                       ans[x1][y1]=m[j].second+1; \n                       cur++; \n                   }\n               }\n               \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       cout<<ans[x][y]<<\" \"; \n                       \n                   } cout<<\"\\n\"; \n               } return; \n                }\n                \n                \n                \n                vector <pair<int,int>> poses;\n                for (int i=0;i<omegalul1.size();i++) poses.push_back(omegalul1[i]); \n                for (int i=0;i<p_free.size();i++) poses.push_back(p_free[i]); \n                 for (int i=0;i<omegalul2.size();i++) poses.push_back(omegalul2[i]);   \n               int cur=0; \n               for (int j=a-1;j>=0;j--) {\n                   //cout<<m[j].first<<\" \"; \n                   for (int qq=0;qq<m[j].first;qq++) {\n                       int x1=poses[cur].first; \n                       int y1=poses[cur].second; \n                       ans[x1][y1]=m[j].second+1; \n                       cur++; \n                   }\n               }\n               \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       cout<<ans[x][y]<<\" \"; \n                       \n                   } cout<<\"\\n\"; \n               } return; \n               return; \n           }\n       }\n       \n       else {\n           int blocked=((i-1)*(i-1))/4;\n           int free=(i+1)*(i+1)/4;\n           int maximal=(i/2)*(i-i/2); \n           int check=1; \n           if (free+maximal*2<k) check=0;\n           if (check) {\n               int need=0; \n               for (int j=a-1;j>=0;j--) {\n                   if (m[j].first>maximal) {need+=m[j].first-maximal; } else break; \n               }\n               if (need>free) check=0; \n           }\n           if (check==1) {\n               cout<<i<<\"\\n\";\n               \n               vector <vector <int>> ans(i, vector <int> (i));  \n               int BLOCK=0; \n               vector <pair<int,int>> p_free; \n               vector <pair<int,int>> omegalul1;\n               vector <pair<int,int>> omegalul2; \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       if (x%2==1 && y%2==1) {\n                           ans[x][y]=BLOCK; \n                       }\n                       if (x%2==0 && y%2==0) {\n                          p_free.push_back({x,y}); \n                       }\n                   }\n               }\n               \n                for (int x=0;x<i;x++) {\n                       for (int y=0;y<i;y++) {\n                           if (x%2==0 && y%2==1) omegalul1.push_back({x,y});\n                           if (x%2==1 && y%2==0) omegalul2.push_back({x,y}); \n                       }\n                   }\n               \n               int find=-1; \n                   if (m[a-1].first>=maximal) {find=m[a-1].second+1; }\n                   \n                   if (find!=-1) {\n                      for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       if (x%2==0 && y%2==1) {\n                           ans[x][y]=find; \n                       }\n                       \n                   }\n               }\n               m[a-1].first-=maximal; \n               for (int j=0;j<omegalul2.size();j++) p_free.push_back(omegalul2[j]); \n               int cur=0; \n               for (int j=a-1;j>=0;j--) {\n                   //cout<<m[j].first<<\" \"; \n                   for (int qq=0;qq<m[j].first;qq++) {\n                       int x1=p_free[cur].first; \n                       int y1=p_free[cur].second; \n                       ans[x1][y1]=m[j].second+1; \n                       cur++; \n                   }\n               }\n               \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       cout<<ans[x][y]<<\" \"; \n                       \n                   } cout<<\"\\n\"; \n               } return; \n                }\n                \n                \n                \n                vector <pair<int,int>> poses;\n                for (int i=0;i<omegalul1.size();i++) poses.push_back(omegalul1[i]); \n                for (int i=0;i<p_free.size();i++) poses.push_back(p_free[i]); \n                 for (int i=0;i<omegalul2.size();i++) poses.push_back(omegalul2[i]);   \n               int cur=0; \n               for (int j=a-1;j>=0;j--) {\n                   //cout<<m[j].first<<\" \"; \n                   for (int qq=0;qq<m[j].first;qq++) {\n                       int x1=poses[cur].first; \n                       int y1=poses[cur].second; \n                       ans[x1][y1]=m[j].second+1; \n                       cur++; \n                   }\n               }\n               \n               for (int x=0;x<i;x++) {\n                   for (int y=0;y<i;y++) {\n                       cout<<ans[x][y]<<\" \"; \n                       \n                   } cout<<\"\\n\"; \n               } return; \n               \n               \n               return; \n           }\n       }\n   }\n    \n    /* --------- */  \n    return;\n    }\n         \n         \n         \n    signed main() {\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0); \n           \n           \n      cout<<fixed<<setprecision(10); \n           \n           \n        int multitest = 1 ;    \n           \n      int tututu;\n      tututu=1;\n      \n      \n     int combinatorics = 0;  \n      \n      if (combinatorics) { \n     fac[1]=1;\n     fac[0]=1; \n     for (int i=2;i<200005;i++) {\n         fac[i]=fac[i-1]*i; fac[i]%=mod; \n     }\n     for (int i=0;i<200005;i++) {\n         inv_fac[i]=inv(fac[i],mod); \n     }\n      } \n      \n      \n      \n      if (multitest) cin>>tututu; // если нет запросов, то закоментить\n            \n      for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n          \n           \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Nastia and a Beautiful Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/90477",
    "editorial": "Letâs fix and will check whether we build a beautiful matrix or\r\nnot.Letâs define the variable as a maximum element among all elements\r\nfrom the array . In other words, the amount of the most frequently\r\noccurring number we have. Also, define the variable as an amount of\r\nnumbers we have.We can single out the criteria. These are and . It can\r\nbe proved by spitting the matrix into disjoint matrices . Letâs\r\nconstruct the structure of the matrix and provide the algorithm of\r\narrangement, that if the previous conditions are satisfied, then we\r\nalways can create the beautiful matrix of size. Take a look at the\r\npicture: There are types of cells. White cells are empty, blue ones can\r\nconsist of any number.Letâs fill yellow and red cells in a way that they\r\ndonât have any common number. We will do it greedily:Letâs fill red\r\ncells at first. Letâs take numbers , which is the most frequently\r\noccurring, and just try to fill red cells using only it.If all numbers\r\nare fully fit there, then we just take a new and continue filling cells.\r\nIf there are elements of color that cannot be placed there then we put\r\nall such remaining elements in blue cells. It is always possible to do\r\nbecause the number of blue cells and yellow cells together is , that is\r\nthe upper bound of the value . In this way, we filled red cells and some\r\nblue cells. The other elements, which havenât been placed yet, can be\r\nplaced randomly because they wonât match(by diagonal) due to the way of\r\nfilling red cells.\r\n",
    "hint": []
}