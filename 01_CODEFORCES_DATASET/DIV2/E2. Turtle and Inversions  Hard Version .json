{
    "link": "https://codeforces.com//contest/2003/problem/E2",
    "problemId": "2836631",
    "problem_idx": "E2",
    "shortId": "2003E2",
    "contest_number": "2003",
    "problem_submissions": {
        "E2": [
            278341707,
            278455104,
            278330622,
            278179988,
            278257072,
            278360261,
            278589270
        ],
        "E1": [
            278142159,
            278142843,
            278147621,
            278145820,
            278139445,
            278118163,
            278284773,
            278152908,
            278522597
        ],
        "D2": [
            278115632,
            278124223,
            278116119,
            278123063,
            278131280,
            278090274,
            278184104,
            278101954,
            278115622,
            278113440,
            278105822,
            278109507,
            278111408,
            278106372,
            278109910,
            278114958,
            278113518,
            278109092
        ],
        "D1": [
            278092613,
            278095057,
            278099358,
            278106267,
            278123018,
            278076086,
            278136646,
            278080662,
            278086676,
            278089029,
            278091347,
            278090118,
            278085289,
            278096196,
            278091226,
            278088309,
            278092415,
            278094460
        ],
        "C": [
            278073298,
            278084142,
            278084204,
            278091216,
            278102032,
            278059873,
            278062388,
            278064696,
            278066407,
            278065300,
            278076163,
            278064469,
            278071045,
            278077312,
            278070267,
            278068388,
            278071776,
            278071322
        ],
        "B": [
            278057061,
            278062158,
            278060356,
            278059818,
            278072173,
            278051522,
            278051239,
            278054673,
            278056246,
            278057857,
            278063310,
            278056133,
            278051957,
            278062245,
            278058767,
            278054937,
            278067356,
            278063368
        ],
        "A": [
            278051014,
            278054951,
            278054980,
            278049465,
            278052299,
            278047930,
            278047962,
            278049334,
            278049908,
            278052979,
            278052705,
            278049194,
            278048004,
            278057248,
            278049244,
            278048425,
            278067001,
            278049077
        ],
        "F": [
            283415067,
            278185607,
            278644931
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/132953",
    "editorial": "Compared to problem E1, this version contains the situation where\r\nintervals can overlap.Consider a pair of overlapping intervals and\r\n(assuming ). The range must consist entirely of s, and the range must\r\nconsist entirely of s. Then, you can remove the intervals and , add a\r\nnew interval , and keep track of which numbers are guaranteed to be and\r\nwhich are guaranteed to be .After processing in this way, the intervals\r\nwill no longer overlap, reducing the problem to problem E1.Time\r\ncomplexity: per test case.\r\n",
    "name": "E2. Turtle and Inversions  Hard Version ",
    "statement": "Turtle gives you m intervals [l_1, r_1], [l_2, r_2],\r\nldots, [l_m, r_m]. He thinks that a permutation p is interesting if\r\nthere exists an integer k_i for every interval (l_i\r\nle k_i < r_i), and if he lets a_i =\r\nmax\r\nlimits_{j = l_i}^{k_i} p_j, b_i =\r\nmin\r\nlimits_{j = k_i + 1}^{r_i} p_j for every integer i from 1 to m, the\r\nfollowing condition holds:\r\nmax\r\nlimits_{i = 1}^m a_i <\r\nmin\r\nlimits_{i = 1}^m b_iTurtle wants you to calculate the maximum number of\r\ninversions of all interesting permutations of length n, or tell him if\r\nthere is no interesting permutation.An inversion of a permutation p is a\r\npair of integers (i, j) (1\r\nle i < j\r\nle n) such that p_i > p_j.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> #define ranges std::ranges#define views std::views using u32 = unsigned;using i64 = long long;using u64 = unsigned long long; using pii = std::pair<int, int>;using a3 = std::array<int, 3>;using a4 = std::array<int, 4>; const int N = 1e6;const int MAXN = 1e6 + 10;const int inf = 1e9;// const int mod = 1e9 + 7;const int mod = 998244353; template<typename T>struct Fenwick {    int n;    std::vector<T> a;     Fenwick(int n_ = 0) {        init(n_);    }     void init(int n_) {        n = n_;        a.assign(n + 5, T{});    }     void add(int x, const T& v) {        for (int i = x; i <= n; i += i & -i) {            a[i] = a[i] + v;        }    }     T sum(int x) {        T ans{};        for (int i = x; i > 0; i -= i & -i) {            ans = ans + a[i];        }        return ans;    }     T rangeSum(int l, int r) {        return sum(r) - sum(l);    }     int select(const T& k) {        int x = 0;        T cur{};        for (int i = 1 << std::__lg(n); i; i /= 2) {            if (x + i <= n && cur + a[x + i] <= k) {                x += i;                cur = cur + a[x];            }        }        return x;    }}; void solve() {    int n, m;std::cin >> n >> m;    std::vector<pii> info(m);    for (auto& [l, r] : info)std::cin >> l >> r;    std::vector<int> tag(n + 1);    std::vector<int> big(n + 1), small(n + 1);//, other;    ranges::sort(info);    std::vector<pii> cur;    int prex = 0;    auto work = [&]() {        if (cur.empty())return;        int maxl = 0, minr = inf;        for (auto [l, r] : cur) {            maxl = std::max(maxl, l);            minr = std::min(minr, r);        }        int p = cur.front().first, s = prex;        for (int i = p;i <= maxl;++i)small[i] = 1;        for (int i = minr;i <= s;++i)big[i] = 1;        };    for (auto [l, r] : info) {        if (prex < l) {            work();            cur.clear();        }        prex = std::max(prex, r);        cur.push_back({ l,r });    }    work();    std::vector<int> pre(n + 1), suf(n + 2);    for (int i = 1;i <= n;++i)pre[i] = pre[i - 1] + small[i];    for (int i = n;i >= 1;--i)suf[i] = suf[i + 1] + big[i];    for (int i = 1;i <= n;++i) {        if (!small[i] && !big[i]) {            if (pre[i] >= suf[i])small[i] = 1;            else big[i] = 1;        }        if (small[i] && big[i]) {            std::cout << -1 << '\\n';            return;        }    }    std::vector<int> ans(n + 1);    int max = n;    // ranges::sort(big);    // ranges::sort(small);    // for (auto y : big)ans[y] = max, max--;    // for (auto y : small)ans[y] = max, max--;    for (int i = 1;i <= n;++i) {        if (big[i]) {            ans[i] = max;            max--;        }    }    for (int i = 1;i <= n;++i) {        if (small[i]) {            ans[i] = max;            max--;        }    }    Fenwick<int> fw(n);    i64 ot = 0;    for (int i = 1;i <= n;++i) {        ot += i - 1 - fw.sum(ans[i]);        fw.add(ans[i], 1);    }    std::cout << ot << '\\n';    // for (int i = 1;i <= n;++i)    //     std::cout << ans[i] << \" \";} signed main() {    std::ios::sync_with_stdio(false);    std::cin.tie(0), std::cout.tie(0);    int t;std::cin >> t;    while (t--) {        solve();    }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "divide and conquer",
        "dp",
        "greedy",
        "math",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Turtle and Inversions  Hard Version .json",
    "hint": [
        "Hint Try to handle overlapping intervals."
    ]
}