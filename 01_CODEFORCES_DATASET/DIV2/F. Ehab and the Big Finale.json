{"link": "https://codeforces.com//contest/1174/problem/F", "problemId": "353395", "problem_idx": "F", "shortId": "1174F", "contest_number": "1174", "problem_submissions": {"E": [55039336, 55044361, 55047429, 55040838, 55047094, 55042040, 55042878, 55038492, 55074361, 55045215, 55070465, 55052562, 55043353, 55077730, 55041823, 55062278, 55053681], "D": [55035444, 55029768, 55027239, 55028917, 55030017, 55031266, 55030524, 55028205, 55035219, 55028511, 55029682, 55031022, 55031315, 55027972, 55032439, 55032979, 55028299, 55033103, 55028679, 55031061], "F": [55031300, 55038342, 55040097, 55045770, 55039431, 55046891, 55053088, 55047685, 55049921, 55049066, 55039349, 55055925, 55055858, 55055759, 55055564, 55043749, 55038284, 55041004, 55058775, 55042228, 55041603, 55041698, 55114618, 55041755, 55042241], "C": [55029741, 55022001, 55024172, 55023941, 55024511, 55027105, 55028150, 55023124, 55027027, 55025166, 55024084, 55029153, 55025965, 55022505, 55024454, 55026547, 55024657, 55028838, 55026161, 55026567], "A": [55027419, 55020850, 55019913, 55020331, 55020481, 55020928, 55020714, 55019727, 55021559, 55020242, 55019597, 55021256, 55019953, 55019896, 55019608, 55020117, 55020693, 55023232, 55019790, 55019854], "B": [55024841, 55019799, 55022270, 55021874, 55022067, 55023546, 55022681, 55021183, 55024705, 55023720, 55021538, 55025471, 55021813, 55021948, 55022335, 55022891, 55031469, 55023328, 55023867, 55022256]}, "name": "F. Ehab and the Big Finale", "statement": "You\u2019re given a tree consisting of n nodes, rooted at node 1. A tree is a\r\nconnected graph with no cycles.We chose a hidden node x. In order to\r\nfind this node, you can ask queries of two types: u (1\r\nle u\r\nle n). We will answer with the distance between nodes u and x. The\r\ndistance between two nodes is the number of edges in the shortest path\r\nbetween them. u (1\r\nle u\r\nle n). We will answer with the second node on the path from u to x.\r\nHowever, there\u2019s a plot twist. If u is an ancestor of x, you\u2019ll receive\r\n\"\" verdict! Node a is called an ancestor of node b if a\r\nne b and the shortest path from node 1 to node b passes through node a.\r\n.Can you find x in no more than 36 queries? The hidden node is fixed in\r\neach test beforehand and does not depend on your queries.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e5 + 5;\n\nint dep[N], n;\nint hed[N], to[N], nxt[N], cnt;\nint sz[N];\ninline void adde(int u, int v)\n{\n\t++cnt;\n\tto[cnt] = v, nxt[cnt] = hed[u];\n\thed[u] = cnt;\n}\nint hvy[N], lst[N], fa[N];\ninline void dfs(int x, int pre)\n{\n\tsz[x] = 1;\n\tfa[x] = pre;\n\tfor (int i = hed[x]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif (v == pre)\n\t\t\tcontinue;\n\t\tdep[v] = dep[x] + 1;\n\t\tdfs(v, x);\n\t\tsz[x] += sz[v];\n\t\tif (sz[v] > sz[hvy[x]])\n\t\t\thvy[x] = v;\n\t}\n\tlst[x] = hvy[x] ? lst[hvy[x]] : x;\n}\n\ninline int q_d(int x)\n{\n\tprintf(\"d %d\\n\", x);\n\tfflush(stdout);\n\tint ret;\n\tscanf(\"%d\", &ret);\n\treturn ret;\n}\n\ninline int q_s(int x)\n{\n\tprintf(\"s %d\\n\", x);\n\tfflush(stdout);\n\tint ret;\n\tscanf(\"%d\", &ret);\n\treturn ret;\n}\n\nint DEP;\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadde(u, v), adde(v, u);\n\t}\n\tdfs(1, 0);\n\tDEP = q_d(1);\n\tint cur = 1;\n\twhile (1)\n\t{\n\t\tint last = lst[cur];\n\t\tint deplast = dep[lst[cur]];\n\t\tint dis = q_d(last);\n\t\twhile (-2 * dep[last] + DEP + deplast != dis)\n\t\t\tlast = fa[last];\n\t\tcur = last;\n\t\tif (dep[last] == DEP)\n\t\t\tbreak;\n\t\telse\n\t\t\tcur = q_s(cur);\n\t}\n\tprintf(\"! %d\\n\", cur);\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "divide and conquer", "graphs", "implementation", "interactive", "trees"], "dificulty": "2400", "interactive": false}