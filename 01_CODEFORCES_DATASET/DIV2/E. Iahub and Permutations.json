{
    "link": "https://codeforces.com//contest/340/problem/E",
    "problemId": "3421",
    "problem_idx": "E",
    "shortId": "340E",
    "contest_number": "340",
    "problem_submissions": {
        "E": [
            4380220,
            4380834,
            4380126,
            4391968,
            4382367,
            4376164,
            4380005,
            4381859,
            4379851,
            4381825,
            4380671,
            4377641,
            4381576,
            4383755
        ],
        "D": [
            4377289,
            4376595,
            4378029,
            4372963,
            4376785,
            4377666,
            4373992,
            4376684,
            4376514,
            4377010,
            4380983,
            4375663,
            4376643,
            4377274,
            4373081,
            4406324,
            4378181,
            4380917,
            4377354,
            4383338
        ],
        "C": [
            4375809,
            4375002,
            4377603,
            4374632,
            4375617,
            4376250,
            4378682,
            4380136,
            4373891,
            4375990,
            4378082,
            4377910,
            4377314,
            4378457,
            4375078,
            4376703,
            4378516,
            4378506,
            4374797
        ],
        "B": [
            4372293,
            4378644,
            4376876,
            4375385,
            4378732,
            4374049,
            4386232,
            4373253,
            4380096,
            4376212,
            4383111,
            4383087,
            4379013,
            4399484,
            4382621,
            4372666
        ],
        "A": [
            4371264,
            4371296,
            4372303,
            4375873,
            4371313,
            4371976,
            4371443,
            4371936,
            4378560,
            4371824,
            4374190,
            4371558,
            4371435,
            4371343,
            4371370,
            4371365,
            4371526,
            4371376,
            4371280
        ]
    },
    "name": "E. Iahub and Permutations",
    "statement": "Iahub is so happy about inventing bubble sort graphs that he’s staying\r\nall day long at the office and writing permutations. Iahubina is angry\r\nthat she is no more important for Iahub. When Iahub goes away, Iahubina\r\ncomes to his office and sabotage his research work.The girl finds an\r\nimportant permutation for the research. The permutation contains\r\ndistinct integers , , ..., . She replaces some of permutation elements\r\nwith -1 value as a revenge. When Iahub finds out his important\r\npermutation is broken, he tries to recover it. The only thing he\r\nremembers about the permutation is it didn’t have any fixed point. A\r\nfixed point for a permutation is an element which has value equal to .\r\nYour job is to proof to Iahub that trying to recover it is not a good\r\nidea. Output the number of permutations which could be originally\r\nIahub’s important permutation, modulo ().\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define DOWN(i,a,b) for(int i = (a); i>=(b);i--)\n#define FR(i,a) for(int i = 0; i < (a); i++)\nusing namespace std;\nlong long Base = 1000000007;\n#define maxn 100010\nint n,a[maxn];\nbool dd[maxn];\nlong long c[2003][2003];\nlong long P[maxn];\nint main() {\n    //freopen(\"test.in\",\"r\",stdin);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    FOR(i,1,n) cin >> a[i];\n    FOR(i,1,n) dd[i] = true;\n    FOR(i,1,n)\n    if (a[i] != -1) dd[a[i]] = false;\n    int cnt1 = 0, cnt2 = 0;\n    FOR(i,1,n)\n    if (a[i] == -1) {\n        if (dd[i]) cnt1++;\n        else cnt2++;\n    }\n    FOR(i,0,2000) c[0][i] = 1;\n    FOR(i,1,2000) FOR(j,i,2000) {\n        c[i][j] = (c[i][j-1] + c[i-1][j-1]);\n        if (c[i][j] >= Base) c[i][j] -= Base;\n    }\n    P[0] = 1;\n    FOR(i,1,n) P[i] = (P[i-1] * i) % Base;\n    long long res = 0, sign;\n    FOR(i,0,cnt1) {\n        if (i % 2 == 0) sign = 1;\n        else sign = -1;\n\n        long long total = (c[i][cnt1] * P[cnt2+cnt1-i]) % Base;\n\n        res = (res + sign * total) % Base;\n        if (res < 0) res += Base;\n    }\n    cout << res << endl;\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Iahub and Permutations.json",
    "editorial_link": "https://codeforces.com/blog/entry/8755",
    "editorial": "In this task, authorâs intended solution is an O(N ^ 2) dp. However,\r\nduring testing Gerald fount a solution using principle of inclusion and\r\nexclusion. Weâve thought to keep both solutions. Weâre sorry if you say\r\nthe problem was well-known, but for both me and the author of the task,\r\nit was first time we saw it. Dynamic programming solution After reading\r\nthe sequence, we can find which elements are deleted. Suppose we have in\r\na set D all deleted elements. Iâll define from now on a \"free position\"\r\na position which has -1 value, so it needs to be completed with a\r\ndeleted element. We observe that some elements from D can appear on all\r\nfree positions of permutation without creating a fixed point. The other\r\nelements from D can appear in all free positions except one, that will\r\ncreate the fixed point. Itâs intuitive that those two \"classes\" donât\r\ninfluence in the same way the result, so they need to be treated\r\nseparated. So from here we can get the dp state. Let dp(n, k) = in how\r\nmany ways can I fill (n + k) free positions, such as n elements from D\r\ncan be placed anywhere in the free position and the other k elements can\r\nbe placed in all free positions except one, which will create the fixed\r\npoint. As weâll prove by the recurrences, we are not interested of the\r\nvalues from elements of D. Instead, weâll interested in their property:\r\nif they can(not) appear in all free positions. If k = 0, the problem\r\nbecomes straight-forward. The answer for dp(n, 0) will be n!, as each\r\npermutation of (n + 0) = n numbers is valid, because all numbers can\r\nappear on all free positions. We can also calculate dp(n, 1). This means\r\nwe are not allowed to place an element in a position out of (n + 1) free\r\npositions. However, we can place it in the other n positions. From now\r\nwe get n elements which can be placed anywhere in the n free positions\r\nleft. Hence, dp(n, 1) = n! * n. We want to calculate dp(n, k) now,\r\nk > 1. Our goal is to reduce the number k, until find something we know\r\nhow to calculate. That is, when k becomes 0 or 1 problem is solved.\r\nOtherwise, we want to reduce the problem to a problem when k becomes 0\r\nor 1. I have two cases. In a first case, I take a number from numbers\r\nwhich can be placed anywhere in order to reduce the numbers which can\r\nform fixed points. In the second case, I take a number from those which\r\ncan form fixed points in order to make the same goal as in the first\r\ncase. Letâs analyze them. Case 1. Suppose X is the first free position,\r\nsuch as in the set of k numbers there exist one which cannot be placed\r\nthere (because it will make a fixed point). Obviously, this position\r\nexist, otherwise k = 0. Also obviously, this position will need to be\r\ncompleted with a term when having a solution. In this case, I complete\r\nposition X with one of n numbers. This will make number equal to X from\r\nthe k numbers set to become a number which can be placed anywhere. So I\r\n\"loose\" one number which can be placed anywhere, but I also \"gain\" one.\r\nAs well, I loose one number which can form a fixed point. Hence dp(n, k)\r\n+= n * dp(n, k 1). Case 2. In this case position X will be completed\r\nwith one number from the k numbers set. All numbers which can form fixed\r\npoints can appear there, except number having value equal to X. So there\r\nare k 1 of them. I choose an arbitrary number Y from those k 1 to place\r\non the position X. This time I \"loose\" two numbers which could form\r\nfixed points: X and Y. As well, I \"gain\" one number which can be placed\r\nanywhere: X. Hence dp(n, k) += (k 1) * dp(n + 1, k 2). TL;DR dp[N][0]=N!\r\ndp[N][1]=N*dp[N][0] dp[N][K]=N*dp[N][K-1]+(K-1)*dp[N+1][K-2] for K>=2\r\nThis recurrences can be computed by classical dp or by memoization. Iâll\r\npresent DamianSâs source, which used memoization. As you can see, itâs\r\nvery short and easy to implement. Link Inclusion and exclusion principle\r\nIâll present here an alternative to the dynamic programming solution.\r\nLetâs calculate in the number of deleted numbers. Also, letâs calculate\r\nin the maximal number of fixed points a permutation can have. For\r\ncalculate , letâs iterate with an index each permutation position. We\r\ncan have a fixed point on position if element from position was deleted\r\n( = -1) and element i does not exist in sequence . With other words,\r\nelement was deleted and now I want to add it back on position to obtain\r\nmaximal number of fixed points. We iterate now an index from to . Let\r\nsol[i] = the number of possible permutations having exactly fixed\r\npoints. Obviously, sol[0] is the answer to our problem. Letâs introduce\r\na combination representing in how many ways I can choose k objects out\r\nof n. I have list of positions which can be transformed into fix points\r\n(they are positions). I need to choose of them. According to the above\r\ndefinition, I get sol[i] = . Next, I have to fill positions with\r\nremained elements. Weâll consider for this moment valid each permutation\r\nof not used values. So, sol[i] = . Where is the problem to this formula?\r\nThe problem is that itâs possible, when permuting (tot i) remained\r\nelements to be added, one (or more) elements to form more (new) fixed\r\npoints. But if somehow I can exclude (subtract) the wrong choices from\r\nsol[i], sol[i] will be calculated correctly. I iterate another index\r\nfrom i + 1 to . For each j, Iâll calculate how many permutations I\r\nconsidered in sol[i] having fixed points but actually they have . Iâll\r\nsubtract from sol[i] this value calculated for each j. If I do this,\r\nobviously sol[i] will be calculated correctly. Suppose we fixed a j. We\r\nknow that exactly sol[j] permutations have j fixed points (as j > i,\r\nthis value is calculated correctly). Suppose now I fix a permutation\r\nhaving j fixed points. For get the full result, I need to calculate for\r\nall sol[j] permutations. Happily, I can multiply result obtained for a\r\nsingle permutation with sol[j] and obtain the result for all\r\npermutations having j fixed points. So you have a permutation having j\r\nfixed points. The problem reduces to choosing i objects from a total of\r\nj. Why? Those i objects chosen are actually the positions considered in\r\nsol[i] to be ones having exactly i fixed points. But permutation has j\r\nfixed points. Quoting for above, \"For each j, Iâll calculate how many\r\npermutations I considered in sol[i] having fixed points but actually\r\nthey have \" . This is exactly what algorithm does. To sum up in a\r\n\"LaTeX\" way, We can compute binomial coefficients using Pascalâs\r\ntriangle. Using inclusion and exclusion principle, we get . Please note\r\nthat there exist an solution for this task, using inclusion and\r\nexclusion principle, but itâs not necessary to get AC. Iâll upload\r\nGeraldâs source here.\r\n",
    "hint": []
}