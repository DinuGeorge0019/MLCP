{"link": "https://codeforces.com//contest/340/problem/B", "problemId": "3418", "problem_idx": "B", "shortId": "340B", "contest_number": "340", "problem_submissions": {"E": [4380220, 4380834, 4380126, 4391968, 4382367, 4376164, 4380005, 4381859, 4379851, 4381825, 4380671, 4377641, 4381576, 4383755], "D": [4377289, 4376595, 4378029, 4372963, 4376785, 4377666, 4373992, 4376684, 4376514, 4377010, 4380983, 4375663, 4376643, 4377274, 4373081, 4406324, 4378181, 4380917, 4377354, 4383338], "C": [4375809, 4375002, 4377603, 4374632, 4375617, 4376250, 4378682, 4380136, 4373891, 4375990, 4378082, 4377910, 4377314, 4378457, 4375078, 4376703, 4378516, 4378506, 4374797], "B": [4372293, 4378644, 4376876, 4375385, 4378732, 4374049, 4386232, 4373253, 4380096, 4376212, 4383111, 4383087, 4379013, 4399484, 4382621, 4372666], "A": [4371264, 4371296, 4372303, 4375873, 4371313, 4371976, 4371443, 4371936, 4378560, 4371824, 4374190, 4371558, 4371435, 4371343, 4371370, 4371365, 4371526, 4371376, 4371280]}, "name": "B. Maximal Area Quadrilateral", "statement": "Iahub has drawn a set of points in the cartesian plane which he calls\r\n\"special points\". A quadrilateral is a simple polygon without\r\nself-intersections with four sides (also called edges) and four vertices\r\n(also called corners). Please note that a quadrilateral doesn\u2019t have to\r\nbe convex. A special quadrilateral is one which has all four vertices in\r\nthe set of special points. Given the set of special points, please\r\ncalculate the maximal area of a special quadrilateral.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define FR(i,a) for(int i = 0; i < (a); i++)\nusing namespace std;\n\nstruct Point {\n    double x,y;\n    Point() {}\n    Point(double x, double y):x(x),y(y){}\n    Point operator -(Point q) {return Point(x-q.x,y-q.y);}\n    double operator %(Point q){ return x*q.y-y*q.x;}\n};\nint n;\nPoint p[2000];\n\nvoid get(int i, int j, double &a, double &b, double &c) {\n    a = p[i].y - p[j].y;\n    b = p[j].x - p[i].x;\n    c = - a * p[i].x - b * p[i].y;\n}\ndouble f(Point X, double A, double B, double C) {\n    return X.x * A + X.y * B + C;\n}\ndouble get_area(Point A, Point B, Point C) {\n    return (0.5*abs(((B-A)%(C-A))));\n}\nint main() {\n    //freopen(\"test.in\",\"r\",stdin);\n    //freopen(\"A.out\",\"w\",stdout);\n    cin >> n;\n    FOR(i,1,n) cin >> p[i].x >> p[i].y;\n    double res = 0;\n    FOR(i,1,n)\n    FOR(j,i+1,n) {\n        bool ok1 = false, ok2 = false;\n        double a,b,c;\n        get(i,j,a,b,c);\n        FOR(k,1,n)\n        if (k != i && k != j) {\n            if (f(p[k],a,b,c) < 0) ok1 = true;\n            if (f(p[k],a,b,c) > 0) ok2 = true;\n        }\n        if (!ok1 || !ok2) continue;\n        double area1 = -1e9, area2 = -1e9;\n        FOR(k,1,n)\n        if (k != i && k != j) {\n            if (f(p[k],a,b,c) < 0)\n                area1 = max(area1,get_area(p[k],p[i],p[j]));\n            if (f(p[k],a,b,c) > 0)\n                area2 = max(area2,get_area(p[k],p[i],p[j]));\n        }\n        res = max(res,area1+area2);\n    }\n    printf(\"%.9lf\\n\",res);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "geometry"], "dificulty": "2100", "interactive": false}