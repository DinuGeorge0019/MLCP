{"link": "https://codeforces.com//contest/1546/problem/D", "problemId": "1042727", "problem_idx": "D", "shortId": "1546D", "contest_number": "1546", "problem_submissions": {"E": [122125227, 122124148], "D": [122105872, 122107863, 122096889, 122095603, 122105333, 122096936, 122095472, 122118686, 122098923, 122101207, 122099148, 122104914, 122098428, 122104640, 122105136, 122100488, 122105772, 122099537, 122110448], "B": [122090097, 122085108, 122076540, 122081488, 122082915, 122087734, 122082809, 122086822, 122082800, 122087773, 122082175, 122080119, 122083530, 122081814, 122079226, 122091795, 122081873, 122092861, 122090128], "A": [122086851, 122077567, 122075663, 122076476, 122076552, 122078623, 122076889, 122078972, 122076287, 122076026, 122077753, 122076449, 122078299, 122077156, 122075823, 122076339, 122075922, 122080175, 122215627, 122079018], "C": [122093146, 122079907, 122085065, 122080664, 122088293, 122092424, 122089139, 122082548, 122092063, 122084125, 122087870, 122085723, 122081465, 122087209, 122087382, 122088738, 122085153]}, "name": "D. AquaMoon and Chess", "statement": "Cirno gave AquaMoon a chessboard of size 1\r\ntimes n. Its cells are numbered with integers from 1 to n from left to\r\nright. In the beginning, some of the cells are occupied with at most one\r\npawn, and other cells are unoccupied.In each operation, AquaMoon can\r\nchoose a cell i with a pawn, and do of the following (if possible): Move\r\npawn from it to the (i+2)-th cell, if i+2\r\nleq n and the (i+1)-th cell is occupied and the (i+2)-th cell is\r\nunoccupied. Move pawn from it to the (i-2)-th cell, if i-2\r\ngeq 1 and the (i-1)-th cell is occupied and the (i-2)-th cell is\r\nunoccupied. You are given an initial state of the chessboard. AquaMoon\r\nwants to count the number of states reachable from the initial state\r\nwith some sequence of operations. But she is not good at programming.\r\nCan you help her? As the answer can be large find it modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\") \n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 1e16;\nconst long long mod = 998244353;\nconst long long hashmod = 100003;\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\nint n;\nchar a[100005];\nll fact[200005],invfact[200005];\n\nll mpow(ll x,ll M) {\n    if(!M) return 1;\n    ll tmp = mpow(x,M/2);\n    tmp = tmp*tmp%mod;\n    if(M % 2) return tmp*x%mod;\n    return tmp;\n}\n\nll nCr(ll A,ll B) {\n    return fact[A]*invfact[B]%mod*invfact[A-B]%mod;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    fact[0] = 1;\n    for(int i = 1;i <= 200000;i++) {\n        fact[i] = fact[i-1]*i%mod;\n    }\n    for(int i = 0;i <= 200000;i++) {\n        invfact[i] = mpow(fact[i],mod-2);\n    }\n    while(T--) {\n        cin >> n >> a+1;\n        ll nam = 0, ans = 0;\n        for(int i = 1;i <= n;i++) {\n            if(a[i] == '0') nam++;\n            if(a[i] == '1'&&a[i-1] == '1') {\n                nam++;\n                ans++;\n                a[i] = a[i-1] = '0';\n            }\n        }\n        cout << nCr(nam,ans) << '\\n';\n    }\n}"], "input": "", "output": "", "tags": ["combinatorics", "math"], "dificulty": "1900", "interactive": false}