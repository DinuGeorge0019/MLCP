{
    "link": "https://codeforces.com//contest/894/problem/D",
    "problemId": "134793",
    "problem_idx": "D",
    "shortId": "894D",
    "contest_number": "894",
    "problem_submissions": {
        "E": [
            32471307,
            32470808,
            32477653,
            32468892,
            32476378,
            32473286,
            32472749,
            32479578,
            32478798,
            32483759,
            32466869,
            32470695,
            32470873,
            32493311
        ],
        "C": [
            32467626,
            32472589,
            32462133,
            32463427,
            32461488,
            32465456,
            32463529,
            32464758,
            32463676,
            32464462,
            32469317,
            32465537,
            32470577,
            32468611,
            32464977,
            32465202,
            32462633,
            32464400
        ],
        "B": [
            32465947,
            32462718,
            32464339,
            32462164,
            32478784,
            32490475,
            32479651,
            32463872,
            32461816,
            32462196,
            32472670,
            32462354,
            32463630,
            32462716,
            32463341,
            32469382
        ],
        "D": [
            32464126,
            32467179,
            32469559,
            32463935,
            32469406,
            32468195,
            32470253,
            32466945,
            32470315,
            32471173,
            32471807,
            32476896,
            32473554,
            32474533,
            32473511
        ],
        "A": [
            32458491,
            32461795,
            32458601,
            32458521,
            32458627,
            32465359,
            32458507,
            32458624,
            32459097,
            32461613,
            32461662,
            32461348,
            32461278,
            32459033,
            32459890,
            32458837,
            32458739,
            32458734
        ]
    },
    "name": "D. Ralph And His Tour in Binary Country",
    "statement": "Ralph is in the Binary Country. The Binary Country consists of cities\r\nand bidirectional roads connecting the cities. The roads are numbered\r\nfrom to , the -th road connects the city labeled (here denotes the\r\nrounded down to the nearest integer) and the city labeled , and the\r\nlength of the -th road is .Now Ralph gives you queries. In each query he\r\ntells you some city and an integer . He wants to make some tours\r\nstarting from this city. He can choose any city in the Binary Country\r\n(including ) as the terminal city for a tour. He gains happiness during\r\na tour, where is the distance between the city and the terminal\r\ncity.Ralph is interested in tours from in which he can gain positive\r\nhappiness. For each query, compute the sum of happiness gains for all\r\nsuch tours.Ralph will never take the same tour twice or more (in one\r\nquery), he will never pass the same city twice or more in one tour.\r\n",
    "solutions": [
        "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 2333333\nint n,m,l[SZ];\nvector<int> vs[1000099];\nll ans[SZ];\nvector<pii> qs[1000099];\ninline void add_qry(int a,int b,int c)\n{\n\tif(c>=0) qs[b].pb(pii(a,c));\n}\nint ts[SZ]; ll qzh[SZ];\n#define UP 23333333\nvoid dfs(int x)\n{\n\tif(x+x<=n)\n\t{\n\t\tdfs(x+x);\n\t\tfor(auto g:vs[x+x])\n\t\t\tif(g+l[x+x]<=UP) vs[x].pb(g+l[x+x]);\n\t\tvs[x+x].clear();\n\t}\n\tif(x+x+1<=n)\n\t{\n\t\tdfs(x+x+1);\n\t\tfor(auto g:vs[x+x+1])\n\t\t\tif(g+l[x+x+1]<=UP) vs[x].pb(g+l[x+x+1]);\n\t\tvs[x+x+1].clear();\n\t}\n\tvs[x].pb(0);\n\tint tn=0;\n\tfor(auto g:vs[x]) ts[++tn]=g;\n\tsort(ts+1,ts+1+tn);\n\tfor(int i=1;i<=tn;++i)\n\t\tqzh[i]=qzh[i-1]+ts[i];\n\tfor(auto q:qs[x])\n\t{\n\t\tint c=q.se,u=upper_bound(ts+1,ts+1+tn,c)-ts-1;\n\t\tans[q.fi]+=c*(ll)u-qzh[u];\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=2;i<=n;++i) scanf(\"%d\",l+i);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint a,b,bf=0;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd_qry(i,a,b);\n\t\tfor(int g=a;g&&b>=0;bf=g,b-=l[g],g>>=1)\n\t\t{\n\t\t\tif(g==a) continue;\n\t\t\tans[i]+=b;\n\t\t\tadd_qry(i,bf^1,b-l[bf^1]);\n\t\t}\n\t}\n\tdfs(1);\n\tfor(int i=1;i<=m;++i)\n\t\tprintf(\"%I64d\\n\",ans[i]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Ralph And His Tour in Binary Country.json",
    "editorial_link": "https://codeforces.com//blog/entry/55884",
    "editorial": "Before answering each query, pre-process on the tree. On each vertice,\r\nwe can get a sorted array of all the vertices in its subtree sorted by\r\ndistance to this vertex. And it costs time using merge sort or time\r\nusing . If you use , you should implement it carefully or it won\u00e2\u0080\u0099t be\r\nable to fit in the time limit. Because the tree is an almost complete\r\nbinary tree, one vertex will appear at most times in all sorted\r\narrays,so the memory complexity is .To answer each query, we can iterate\r\non the highest vertex on the tour and do binary search on the sorted\r\narray to get the answer. We\u00e2\u0080\u0099ll do at most times of iteration and the\r\nbinary search is per iteration, so we can answer each query in\r\ntime.Overall, the time complexity is and the memory complexity is . If\r\nyou use , the time complexity will be and the memory complexity is the\r\nsame.\r\n"
}