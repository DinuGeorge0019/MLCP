{
    "link": "https://codeforces.com//contest/1099/problem/E",
    "problemId": "278505",
    "problem_idx": "E",
    "shortId": "1099E",
    "contest_number": "1099",
    "problem_submissions": {
        "E": [
            48000148,
            48008414,
            48015162,
            48015155,
            47998674,
            68679965,
            48055305,
            48002816,
            48005156,
            48004046
        ],
        "F": [
            47993398,
            48000668,
            47998030,
            47996940,
            48003129,
            48002459,
            48000786,
            48002880,
            48003524,
            48001521,
            48002772,
            48065469,
            48065253,
            48007017,
            48004595,
            48004955,
            48023235,
            48006181,
            48008407
        ],
        "D": [
            47985584,
            47989615,
            47984416,
            47978723,
            47985339,
            47986984,
            47992304,
            47990729,
            47990739,
            47992156,
            47990766,
            47987456,
            47986225,
            47993500,
            47991322,
            47992653,
            47992397,
            47991707,
            47988171,
            47987589
        ],
        "C": [
            47981176,
            47983527,
            47980104,
            47987818,
            47981157,
            47982699,
            47982090,
            47982267,
            47986173,
            47985738,
            47981653,
            47982375,
            47988366,
            47985929,
            47986209,
            47986811,
            47984704,
            47981818,
            47983683
        ],
        "B": [
            47976890,
            47977488,
            47975669,
            47984516,
            47975576,
            47975800,
            47977583,
            47977135,
            47978430,
            47982162,
            47977417,
            47977771,
            47981576,
            47979226,
            47979187,
            47980494,
            47977529,
            47975997,
            47978338
        ],
        "A": [
            47974401,
            47973914,
            47973933,
            47982820,
            47974013,
            47974051,
            47974701,
            47974488,
            47974881,
            47974319,
            47973925,
            47973908,
            47975086,
            47976101,
            47974397,
            47974659,
            47974316,
            47973944,
            47974200
        ]
    },
    "name": "E. Nice table",
    "statement": "You are given an n\r\ntimes m table, consisting of characters , , , . Letâ€™s call a table , if\r\nevery 2\r\ntimes 2 square contains all four distinct characters. Your task is to\r\nfind a nice table (also consisting of , , , ), that differs from the\r\ngiven table in the minimum number of characters.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define endl '\\n'\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (int)3e5 + 42;\n\nusing table = vector<string>;\n\nint n, m;\ntable s;\n\nvoid read()\n{\n\tcin >> n >> m;\n\ts.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> s[i];\n}\n\nstring Sg = {'A', 'G', 'C', 'T'};\n\npair<int, table> answer;\n\nint dp[MAXN][4][4];\npair<int, int> best[MAXN][4][4];\n\nint rec1(int row, int last1, int last2)\n{\n\tif(row == n)\n\t\treturn 0;\n\n\tint &memo = dp[row][last1][last2];\n\tif(memo != -1) return memo;\n\n\tvector<int> li;\n\tfor(int i = 0; i < 4; i++) \n\t\tif(row == 0 || (i != last1 && i != last2))\n\t\t\tli.pb(i);\t\t\n\n\tfor(int i = 0; i < SZ(li); i++)\n\t\tfor(int j = 0; j < SZ(li); j++)\n\t\t\tif(i != j)\n\t\t\t{\n\t\t\t\tint cost = 0;\n\t\t\t\tfor(int c = 0; c < m; c++)\n\t\t\t\t{\n\t\t\t\t\tif(!(c & 1)) if(Sg[li[i]] == s[row][c]) cost++;\n\t\t\t\t\tif(c & 1) if(Sg[li[j]] == s[row][c]) cost++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(chkmax(memo, cost + rec1(row + 1, li[i], li[j])))\n\t\t\t\t\tbest[row][last1][last2] = {li[i], li[j]};\n\t\t\t}\n\n\treturn memo;\n}\n\nint rec2(int row, int last1, int last2)\n{\n\tif(row == m)\n\t\treturn 0;\n\n\tint &memo = dp[row][last1][last2];\n\tif(memo != -1) return memo;\n\n\tvector<int> li;\n\tfor(int i = 0; i < 4; i++) \n\t\tif(row == 0 || (i != last1 && i != last2))\n\t\t\tli.pb(i);\t\t\n\n\tfor(int i = 0; i < SZ(li); i++)\n\t\tfor(int j = 0; j < SZ(li); j++)\n\t\t\tif(i != j)\n\t\t\t{\n\t\t\t\tint cost = 0;\n\t\t\t\tfor(int c = 0; c < n; c++)\n\t\t\t\t{\n\t\t\t\t\tif(!(c & 1)) if(Sg[li[i]] == s[c][row]) cost++;\n\t\t\t\t\tif(c & 1) if(Sg[li[j]] == s[c][row]) cost++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(chkmax(memo, cost + rec2(row + 1, li[i], li[j])))\n\t\t\t\t\tbest[row][last1][last2] = {li[i], li[j]};\n\t\t\t}\n\n\treturn memo;\n}\n\n\nvoid solve1()\n{\n\tmemset(dp, -1, sizeof(dp));\n\n\tint best_ans = rec1(0, 0, 0);\n\tint row = 0, last1 = 0, last2 = 0;\n\n\ttable answer;\n\tanswer.assign(n, string(m, ' '));\n\n\twhile(row < n)\n\t{\n\t\trec1(row, last1, last2);\n\t\tint nw_last1 = best[row][last1][last2].first, nw_last2 = best[row][last1][last2].second;\n\t\tlast1 = nw_last1, last2 = nw_last2;\n\t\t\n\t\tfor(int c = 0; c < m; c++)\n\t\t\tif(c & 1) answer[row][c] = Sg[last2];\n\t\t\telse answer[row][c] = Sg[last1];\n\n\t\trow++;\n\t}\n\n\tchkmax(::answer, make_pair(best_ans, answer));\n}\n\nvoid solve2()\n{\n\tmemset(dp, -1, sizeof(dp));\n\n\tint best_ans = rec2(0, 0, 0);\n\tint row = 0, last1 = 0, last2 = 0;\n\n\ttable answer;\n\tanswer.assign(n, string(m, ' '));\n\n\twhile(row < m)\n\t{\n\t\trec2(row, last1, last2);\n\t\tint nw_last1 = best[row][last1][last2].first, nw_last2 = best[row][last1][last2].second;\n\t\tlast1 = nw_last1, last2 = nw_last2;\n\t\t\n\t\tfor(int c = 0; c < n; c++)\n\t\t\tif(c & 1) answer[c][row] = Sg[last2];\n\t\t\telse answer[c][row] = Sg[last1];\n\n\t\trow++;\n\t}\n\n\tchkmax(::answer, make_pair(best_ans, answer));\n}\nvoid solve()\n{\n\tanswer.first = -1;\n\t\n\tsolve1();\n\tsolve2();\n\n\tfor(int i = 0; i < n; i++)\n\t\tcout << answer.second[i] << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Nice table.json",
    "editorial_link": "https://codeforces.com/blog/entry/64331",
    "editorial": ":In a good matrix, either each row contain at most two different\r\ncharacters, or each column contain at most two different characters.:\r\n(it will be here, but for now the editorial fields are too narrow to\r\ncontain it).In other words, the field looks either like (up to a\r\npermutation of ): (or ) (or ) (or ) (or )(and so on)or similarly by\r\ncolumns.So, the solution is to say that we have this alternation by\r\nrows, iterate over the permutation of letters, for each row choose from\r\nthe row and its inversion the one that differs from the row of the\r\noriginal matrix in the minimum number of characters. Then rotate the\r\nmatrix, and solve similarly again, and take a more optimal one.\r\n",
    "hint": []
}