{
    "link": "https://codeforces.com//contest/545/problem/D",
    "problemId": "28037",
    "problem_idx": "D",
    "shortId": "545D",
    "contest_number": "545",
    "problem_submissions": {
        "E": [
            11152908,
            11157700,
            11157522,
            11156542,
            11161300,
            11156960,
            11158926,
            11159332,
            11158333,
            11161026,
            11158857,
            11159720,
            11174097,
            11173935,
            11160858,
            11161651,
            11159778,
            11161054,
            11160310,
            11161820,
            11163252
        ],
        "C": [
            11150440,
            11147958,
            11150824,
            11150276,
            11148970,
            11148884,
            11153300,
            11153422,
            11152117,
            11151008,
            11151654,
            11153299,
            11155654,
            11152365,
            11152087,
            11153750,
            11154873,
            11151525,
            11151659
        ],
        "D": [
            11148301,
            11149439,
            11148692,
            11151407,
            11150444,
            11147349,
            11150296,
            11170906,
            11151431,
            11154441,
            11153203,
            11155014,
            11154361,
            11150015,
            11154687,
            11154652,
            11154830,
            11154199,
            11153829,
            11150376
        ],
        "B": [
            11147493,
            11152440,
            11147604,
            11147721,
            11147256,
            11149962,
            11148762,
            11149882,
            11149290,
            11148961,
            11148519,
            11150280,
            11148361,
            11149006,
            11149406,
            11151773,
            11147710,
            11148107,
            11147713
        ],
        "A": [
            11146984,
            11151375,
            11147061,
            11147027,
            11146977,
            11151139,
            11147222,
            11147723,
            11147389,
            11147403,
            11160745,
            11149107,
            11147430,
            11147598,
            11148409,
            11148792,
            11148668,
            11147021,
            11147024
        ]
    },
    "name": "D. Queue",
    "statement": "Little girl Susie went shopping with her mom and she wondered how to\r\nimprove service quality. There are people in the queue. For each person\r\nwe know time needed to serve him. A person will be disappointed if the\r\ntime he waits is more than the time needed to serve him. The time a\r\nperson waits is the total time when all the people who stand in the\r\nqueue in front of him are served. Susie thought that if we swap some\r\npeople in the queue, then we can decrease the number of people who are\r\ndisappointed. Help Susie find out what is the maximum number of not\r\ndisappointed people can be achieved by swapping people in the queue.\r\n",
    "solutions": [
        "//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 1e6 + 9;\nlong long cur = 0;\nint arr[Maxn];\nint main(){\n\tios_base::sync_with_stdio(0);\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n;i++) cin >> arr[i];\n\tsort(arr,arr+n);\n\tint ans = 0;\n\tfor(int i = 0; i < n;i++){\n\t\tif(cur <= arr[i]) cur += arr[i],ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Queue.json",
    "editorial_link": "https://codeforces.com//blog/entry/17982",
    "editorial": "We can solve this problem by greedy algorithm. Letâs prove that it is\r\nalways possible find an answer (queue with the maximal number of not\r\ndisappointed people), where all not disappointed people are at the begin\r\nof queue. Assume the contrary there are two position and such that ,\r\npersons at position from to are disappointed, but -th person isnât. Then\r\njust swap persons at positions and . After that all persons from to will\r\nbe still disappointed (or become not disappointed) and -th person will\r\nbe still not disappointed. So the answer isnât maked worse. So, we need\r\nto find person with minimal , that can be served now and will be not\r\ndisappointed. We can do that by sorting all the people by time and try\r\nto serve them one by one. If somebody will be disappointed, we may send\r\nhe to the end of queue, and doesnât add his serve time to the waiting\r\ntime. Time complexity .\r\n",
    "hint": []
}