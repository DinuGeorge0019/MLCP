{
    "link": "https://codeforces.com//contest/1293/problem/E",
    "problemId": "519786",
    "problem_idx": "E",
    "shortId": "1293E",
    "contest_number": "1293",
    "problem_submissions": {
        "F": [
            69144490
        ],
        "E": [
            69128562,
            69139795,
            69142024,
            69131945,
            69142296,
            69141087,
            69144888,
            69145848,
            69164707
        ],
        "D": [
            69110626,
            69117551,
            69124060,
            69120174,
            69127386,
            69126155,
            69129595,
            69130299,
            69114746,
            69117610,
            69118282,
            69119817,
            69121032,
            69120169,
            69124854,
            69120660,
            69119364,
            69123969,
            69120677
        ],
        "C": [
            69102974,
            69108977,
            69107084,
            69104834,
            69114459,
            69118062,
            69106027,
            69117297,
            69105999,
            69106862,
            69108959,
            69111194,
            69109221,
            69111162,
            69107446,
            69109831,
            69111539,
            69110537,
            69100793
        ],
        "B": [
            69100602,
            69105372,
            69103818,
            69141041,
            69106215,
            69103881,
            69107978,
            69109703,
            69102030,
            69102659,
            69103831,
            69103631,
            69104162,
            69106217,
            69102105,
            69103438,
            69103183,
            69102839,
            69102420
        ],
        "A": [
            69100208,
            69103403,
            69101074,
            69134161,
            69102156,
            69101452,
            69101459,
            69101593,
            69100449,
            69100351,
            69100975,
            69100577,
            69100919,
            69101698,
            69100184,
            69100301,
            69100964,
            69100796,
            69109424
        ]
    },
    "name": "E. Xenon s Attack on the Gangs",
    "statement": "On another floor of the A.R.C. Markland-N, the young man Simon \"Xenon\"\r\nJackson, takes a break after finishing his project early (as always).\r\nHaving a lot of free time, he decides to put on his legendary hacker \"X\"\r\ninstinct and fight against the gangs of the cyber world.His target is a\r\nnetwork of n small gangs. This network contains exactly n - 1 direct\r\nlinks, each of them connecting two gangs together. The links are placed\r\nin such a way that every pair of gangs is connected through a sequence\r\nof direct links.By mining data, Xenon figured out that the gangs used a\r\nform of cross-encryption to avoid being busted: every link was assigned\r\nan integer from 0 to n - 2 such that all assigned integers are distinct\r\nand every integer was assigned to some link. If an intruder tries to\r\naccess the encrypted data, they will have to surpass S password layers,\r\nwith S being defined by the following formula:S =\r\nsum_{1\r\nleq u < v\r\nleq n} mex(u, v)Here, mex(u, v) denotes the smallest non-negative\r\ninteger that does not appear on any link on the unique simple path from\r\ngang u to gang v.Xenon doesn\u2019t know the way the integers are assigned,\r\nbut it\u2019s not a problem. He decides to let his AI\u2019s instances try all the\r\npasswords on his behalf, but before that, he needs to know the maximum\r\npossible value of S, so that the AIs can be deployed efficiently.Now,\r\nXenon is out to write the AI scripts, and he is expected to finish them\r\nin two hours. Can you find the maximum possible S before he returns?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint fr[3005], to[3005];\nvector <int> adj[3005];\nint dad[3005][3005], sz[3005][3005];\nint d[3005][3005];\nlong long f[3005][3005];\nvector <pair <int, int> > di[3005];\n\nvoid dfs2(int u, int r) {\n    sz[u][r] = 1;\n    for (auto v: adj[u]) {\n        if (v == dad[u][r]) continue;\n        dad[v][r] = u;\n        d[v][r] = d[u][r] + 1;\n        di[d[v][r]].push_back({v, r});\n        dfs2(v, r);\n        sz[u][r] += sz[v][r];\n    }\n}\n\nint main(void) {\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int u, v;\n        cin >> u >> v;\n        fr[i] = u, to[i] = v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    for (int i = 1; i <= n; ++i) {\n        dfs2(i, i);\n    }\n    long long ans = 0;\n    for (int y = 1; di[y].size(); ++y) {\n        for (auto z: di[y]) {\n            int u = z.first, v = z.second;\n            int pu = dad[u][v], pv = dad[v][u];\n            int su = sz[u][v], sv = sz[v][u];\n            f[u][v] = max(f[u][v], f[pu][v] + su * sv);\n            f[u][v] = max(f[u][v], f[u][pv] + su * sv);\n            ans = max(ans, f[u][v]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Xenon s Attack on the Gangs.json",
    "editorial_link": "https://codeforces.com//blog/entry/73051",
    "editorial": "The first observation is that, the formula can be rewritten as:\n\nS=?1?u<v?nmex(u,v)=?1?x?n???mex(u,v)=xx??=?1?x?n???mex(u,v)?x1??=?1?x?nf(x)\n\nWhere f(x)\n is number of pairs (u,v)\n such that 1?u<v?n\n and mex(u,v)?x\n (in other word, the path from u\n to v\n contains all numbers from 0\n to x?1\n).\n\nConsider the process of placing numbers in order from 0\n to n?1\n (first place number 0\n, then place number 1\n, etc.) on edges of the tree. Suppose that the placement for all numbers from 0\n to x?1\n are fixed, and now we need to place number x\n. To maximize S\n, we should try to place x\n in a way that there exists a path contain all numbers from 0\n to x\n (if this is possible).\n\nIn other word, in the optimal solution, there will be a path connecting two leaf vertices that contain all numbers from 0\n to l?1\n (where l\n is the number of vertices in that path). The placement of numbers from l\n to n?2\n does not matter, since it will not affect the result.\n\nNow, suppose that the location of such path is fixed, and its length is l\n. Let a\n the sequence of number on edges on the path from u\n to v\n. One can show that, in other to archive maximum S\n, a\n must be a 'valley' sequence (there exist some position p\n such that a1>a2>\u0085>ap<\u0085<al?1<al\n.\n\nAll the observation above leads to the following dynamic programming solution:\n\nLet dp[u][v]\n the maximum value of ?1?x?lf(x)\n if all number from 0\n to l?1\n are written on the edges on the path from u\n to v\n (with l\n denote the length of that path). We also define:\n\npar(r,u)\n: the parent of vertex u\n if we root the tree at vertex r\n.\nsub(r,u)\n: the number of vertices in the subtree of vertex u\n if we root the tree at vertex r\n.\nThe figure below demonstrate par(u,v)\n and par(v,u)\n for two vertices u\n and v\n (in the figure, pu,v\n is par(u,v)\n and pv,u\n is par(v,u)\n).\n\n\nTo calculate dp[u][v]\n, there are two cases:\n\nPutting number l\n on the edge (u,par(v,u))\n. In this case:\n?1?x?lf(x)=f(l)+?1?x?l?1f(x)=sub(u,v)\u00d7sub(v,u)+dp[par(v,u)][v]\n\nPutting number l\n on the edge (v,par(u,v))\n. Similarly, ?1?x?lf(x)=sub(u,v)\u00d7sub(v,u)+dp[u][par(u,v)]\nThe final formula to calculate dp[u][v]\n is:\n\ndp[u][v]=sub(u,v)\u00d7sub(v,u)+max(dp[par(v,u)][v],dp[u][par(u,v)])\n\nThe formula can be calculated in O(1)\n if all the values of par(r,u)\n and sub(r,u)\n are calculated (we can preprocess to calculate these value in O(n2)\n. by doing performing DFS once from each vertex). Therefore, the overall complexity for this algorithm is O(n2)\n."
}