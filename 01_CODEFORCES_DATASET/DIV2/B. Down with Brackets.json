{
    "link": "https://codeforces.com//contest/2110/problem/B",
    "problemId": "3402551",
    "problem_idx": "B",
    "shortId": "2110B",
    "contest_number": "2110",
    "problem_submissions": {
        "F": [
            321110781,
            321123390,
            321106745,
            321118551,
            321166762,
            321127347,
            321131871,
            321131150,
            321234951,
            321139338,
            321137483,
            321137509,
            321132400,
            321147266,
            321142991,
            321140692,
            321135198,
            321138923,
            321109632
        ],
        "E": [
            321090795,
            321099993,
            321121829,
            321106571,
            321097123,
            321114727,
            321150192,
            321149551,
            321115626,
            321107798,
            321113548,
            321113381,
            321101851,
            322032404,
            322032368,
            322030701,
            322030587,
            322030501,
            321694257,
            321694217,
            321211859,
            321122398,
            321110387,
            321130397,
            321132692,
            321115982,
            321092986
        ],
        "D": [
            321077211,
            321082627,
            321102210,
            321098776,
            321083582,
            321095490,
            321089006,
            321076593,
            321095324,
            321089964,
            321118720,
            321820812,
            321147382,
            321107801,
            321120467,
            321120327,
            321111437,
            321121243,
            321082273
        ],
        "C": [
            321063959,
            321071650,
            321077012,
            321075164,
            321074791,
            321072972,
            321072110,
            321091606,
            321078282,
            321078383,
            321092747,
            321075406,
            321096734,
            321100841,
            321086791,
            321137116,
            321068675
        ],
        "B": [
            321056024,
            321058204,
            321059758,
            321061309,
            321060112,
            321061450,
            321061306,
            321067648,
            321061121,
            321062458,
            321066403,
            321059168,
            321060412,
            321061877,
            321059766,
            321139109,
            321058973
        ],
        "A": [
            321053134,
            321055856,
            321056086,
            321056607,
            321053392,
            321055181,
            321056518,
            321054040,
            321053613,
            321057499,
            321058294,
            321054230,
            321053600,
            321056212,
            321054083,
            321139381,
            321053997
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/143186",
    "editorial": "Let’s recall the algorithm for checking the correctness of a bracket\r\nsequence. To do this, we check that the balance at each prefix is\r\nnon-negative, and that the balance of the entire sequence is equal to\r\n.To break a correct bracket sequence, we need to violate at least one of\r\nthe conditions. Note that the balance of the entire sequence will not\r\nchange when we remove one opening bracket and one closing bracket.\r\nTherefore, we need to violate the first condition.Notice that removing\r\nan opening bracket will decrease by 1 in the suffix to the right of the\r\nbracket. Similarly, for a closing bracket, it will increase by 1 in the\r\nsuffix.It is clear that among all closing brackets, it is advantageous\r\nto remove the very last one, as this will not increase any . Among all\r\nopening brackets, it is advantageous to remove the very first one, as\r\nthis will decrease all by 1 (which is obviously the most optimal option\r\nafter removal).Thus, the answer is actually the result of checking the\r\noriginal bracket sequence without the first and last brackets for\r\ncorrectness. If it is correct, then the sequence cannot be broken;\r\notherwise, it can be.\r\n",
    "name": "B. Down with Brackets",
    "statement": "In 2077, robots decided to get rid of balanced bracket sequences once\r\nand for all!A bracket sequence is called if it can be constructed by the\r\nfollowing formal grammar. The empty sequence\r\nvarnothing is balanced. If the bracket sequence A is balanced, then\r\nmathtt{(}A\r\nmathtt{)} is also balanced. If the bracket sequences A and B are\r\nbalanced, then the concatenated sequence A B is also balanced. You are\r\nthe head of the department for combating balanced bracket sequences, and\r\nyour main task is to determine which brackets you can destroy and which\r\nyou cannot.You are given a balanced bracket sequence represented by a\r\nstring s, consisting of the characters and . Since the robots’\r\ncapabilities are not limitless, they can remove one opening bracket and\r\none closing bracket from the string.Your task is to determine whether\r\nthe robots can delete such two brackets so that the string s is no\r\nlonger a balanced bracket sequence.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "strings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Down with Brackets.json",
    "hint": []
}