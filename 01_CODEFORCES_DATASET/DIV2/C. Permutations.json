{
    "link": "https://codeforces.com//contest/189/problem/C",
    "problemId": "1318",
    "problem_idx": "C",
    "shortId": "189C",
    "contest_number": "189",
    "problem_submissions": {
        "E": [
            1678506,
            1678460,
            1678211,
            1678693,
            1677477,
            1677700,
            1680381,
            1677887,
            1678428,
            1681566
        ],
        "D": [
            1676682,
            1676035,
            1677096,
            1677898,
            1674240,
            1680791,
            1676256,
            1676755,
            1676792,
            1677405,
            1676745,
            1676612,
            1677482,
            1677225,
            1676566
        ],
        "C": [
            1674208,
            1675081,
            1675273,
            1676086,
            1673529,
            1673748,
            1674530,
            1675036,
            1674970,
            1674691,
            1674910,
            1675504,
            1675160,
            1673957,
            1675084,
            1674909
        ],
        "B": [
            1673360,
            1673410,
            1674214,
            1674813,
            1672769,
            1673156,
            1673373,
            1673917,
            1674026,
            1673370,
            1673358,
            1672790,
            1673649,
            1674219,
            1672936,
            1673608,
            1675358
        ],
        "A": [
            1672718,
            1672777,
            1673274,
            1672957,
            1672602,
            1672581,
            1672722,
            1673173,
            1673083,
            1672709,
            1672650,
            1672579,
            1672834,
            1672816,
            1674499,
            1672796,
            1672817
        ]
    },
    "name": "C. Permutations",
    "statement": "Happy PMP is freshman and he is learning about algorithmic problems. He\r\nenjoys playing algorithmic games a lot.One of the seniors gave Happy PMP\r\na nice game. He is given two permutations of numbers through and is\r\nasked to convert the first one to the second. In one move he can remove\r\nthe last number from the permutation of numbers and inserts it back in\r\nan arbitrary position. He can either insert last number between any two\r\nconsecutive numbers, or he can place it at the beginning of the\r\npermutation.Happy PMP has an algorithm that solves the problem. But it\r\nis not fast enough. He wants to know the minimum number of moves to\r\nconvert the first permutation to the second.\r\n",
    "solutions": [
        "/*\n * Author: code6\n * Created Time:  2012/5/10 23:44:39\n * File Name: C.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n#define out(v) cerr << #v << \": \" << (v) << endl\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntypedef long long ll;\nconst double PI=acos(-1.0);\nconst double eps=1e-11;\n\nconst int MAX = 1000000;\n\nint n;\nint arr[MAX],  ref[MAX];\n\nint main() {\n    cin>>n;\n    int i, j;\n    for (i = 1; i <= n; i++) {\n        scanf(\"%d\", &arr[i]);\n        ref[arr[i]] = i;\n    }\n    \n    for (i = 1; i <= n; i++) {\n        int v;\n        scanf(\"%d\", &v);\n        arr[ref[v]] = i;\n    }\n    \n    for (i = 2; i <= n && arr[i] > arr[i - 1]; i++);\n    \n    cout<<n - (i - 1)<<endl;\n    \n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Permutations.json",
    "editorial_link": "https://codeforces.com//blog/entry/4540",
    "editorial": "It is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.\n\nEach time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number.\n\nSo, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted.\n\nTherefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i."
}