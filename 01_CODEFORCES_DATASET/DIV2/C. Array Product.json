{
    "link": "https://codeforces.com//contest/1042/problem/C",
    "problemId": "220707",
    "problem_idx": "C",
    "shortId": "1042C",
    "contest_number": "1042",
    "problem_submissions": {
        "F": [
            42987714,
            42984651,
            42989319,
            42983649,
            42989168,
            42989334,
            42988495,
            42988621,
            42990991,
            42984782,
            42991318,
            42984734,
            42989762,
            42989508,
            42989199,
            42985445,
            42984262,
            42986731
        ],
        "A": [
            42984167,
            42973725,
            42974031,
            42973482,
            42973429,
            42973632,
            42973538,
            42974330,
            42975529,
            42973708,
            42993729,
            42975026,
            42986836,
            42989940,
            42973749,
            42992518,
            42973915,
            42973554,
            42973556,
            42973468
        ],
        "E": [
            42983656,
            42983448,
            42981915,
            42988922,
            42984518,
            42985483,
            42983668,
            42985621,
            42980250,
            42987926,
            42982614,
            42990994,
            42986527,
            42985364,
            42983020,
            42986197,
            42989170,
            42987817,
            42982499
        ],
        "C": [
            42982112,
            42977810,
            42976676,
            42978400,
            42979933,
            42981591,
            42978723,
            42979152,
            42981616,
            43020286,
            42983391,
            42977530,
            42987879,
            42980102,
            42982752,
            42979907,
            42979506,
            42982122,
            42993016,
            42980948,
            42977178
        ],
        "B": [
            42975906,
            42974331,
            42974910,
            42974847,
            42974321,
            42975176,
            42975023,
            42975453,
            42976952,
            42975043,
            42975357,
            42976939,
            42975515,
            42976516,
            42974965,
            42975963,
            42975276,
            42974792,
            42974885,
            42974787
        ],
        "D": [
            42975097,
            42975491,
            42978165,
            42980511,
            42976657,
            42978683,
            42980559,
            42982541,
            42983622,
            43020160,
            42982284,
            42979330,
            42979227,
            42983154,
            42978119,
            42977687,
            42982730,
            42983764,
            42980017,
            42976894,
            42978512
        ]
    },
    "name": "C. Array Product",
    "statement": "You are given an array a consisting of n integers. You can perform the\r\nfollowing operations with it: Choose some positions i and j (1\r\nle i, j\r\nle n, i\r\nne j), write the value of a_i\r\ncdot a_j into the j-th cell and from the i-th cell; Choose some position\r\ni and from the i-th cell (this operation can be performed ). The number\r\nof elements decreases by one after each operation. However, the indexing\r\nof positions stays the same. Deleted numbers can\u2019t be used in the later\r\noperations.Your task is to perform exactly n - 1 operations with the\r\narray in such a way that the only number that remains in the array is\r\nmaximum possible. This number can be rather large, so instead of\r\nprinting it you need to print sequence of operations which leads to this\r\nmaximum number. Read the output format to understand what exactly you\r\nneed to print.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdio>\n// Linsanity is back \t\n// Who\u2019s Kobe? \n// Fisherman can\u2019t stop us\n// Average ABCDE on a good day\nusing namespace std;\n\nint n;\nconst int MAXN = 200005;\nlong long a[MAXN];\nvector<int> curr, z;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n;\n\n\tlong long neg = 0, idxn = 0, smallneg = 1e9 + 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> a[i];\n\t\tif(a[i] < 0)\n\t\t{\n\t\t\tneg++;\n\t\t\tif(abs(a[i]) < smallneg)\n\t\t\t{\n\t\t\t\tsmallneg = abs(a[i]);\n\t\t\t\tidxn = i;\n\t\t\t}\n\t\t}\n\t\tif(a[i] == 0)\n\t\t\tz.push_back(i);\n\t}\n\n\tint counter = 0;\n\tfor(int i = 0; i < (int)z.size() - 1; i++)\n\t{\n\t\tcout << 1 << \" \" << z[i] << \" \" << z[i + 1] << \"\\n\";\n\t\tcounter++;\n\t}\n\n\tint pos = -1;\n\tif (!z.empty())\n\t\tpos = z.back();\n\tif(neg % 2 == 1)\n\t{\n\t\tpos = idxn;\n\t\tif(!z.empty())\n\t\t{\n\t\t\tcout << 1 << \" \" << z.back() << \" \" << idxn << \"\\n\";\n\t\t\tcounter++;\n\t\t}\n\t}\n\tif(counter == n - 1)\n\t\treturn 0;\n\telse if (pos != -1)\n\t\tcout << 2 << \" \" << pos << \"\\n\";\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(a[i] != 0 && (neg % 2 == 0 || i != idxn))\n\t\t\tcurr.push_back(i);\n\n\tfor(int i = 0; i < curr.size() - 1; i++)\n\t\tcout << 1 << \" \" << curr[i] << \" \" << curr[i + 1] << \"\\n\";\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Array Product.json",
    "editorial_link": "https://codeforces.com/blog/entry/61891",
    "editorial": "There are several cases in the problem. Let the number of zeroes in the\r\narray be and the number of negative elements be . Also let be the\r\nposition of the maximum negative element in the array, or if there are\r\nno negative elements in the array.Let the answer part be the product of\r\nall the numbers which will be in the answer and the removed part be the\r\nproduct of all the numbers which will be removed by the second type\r\noperation.The first case is the following: and . Then the answer part is\r\nthe product of all the numbers in the array. The removed part is\r\nempty.The second case is the following: is odd. Then the answer part is\r\nthe product of all the numbers in the array except all zeroes and . The\r\nremoved part is the product of all zeroes and .And the third case is the\r\nfollowing: is even. Then the answer part is the product of all the\r\nnumbers in the array except all zeroes. The removed part is the product\r\nof all zeroes in the array (be careful in case and ).Be careful with\r\nprinting the answer because my first solution printed operations instead\r\nof operations in case or and .And the funniest part of this problem is\r\nthe checker. The first thing I thought was \"Well, I want to write a fair\r\nchecker on this problem\". I did exactly that. What do we need? Split all\r\nthe numbers in the array into two parts? Okay, let\u00e2\u0080\u0099s write DSU to do\r\nthat. What\u00e2\u0080\u0099s next? Multiply numbers from to ? Okay, let\u00e2\u0080\u0099s use FFT and\r\nDivide and Conquer! And the last part is the comparing two numbers of\r\nlength about . So writing this checker was pretty easy problem. But the\r\ncoordinator didn\u00e2\u0080\u0099t like that and I replaced it with very easy checker\r\nwhich uses some ideas from the solution. :(\r\n"
}