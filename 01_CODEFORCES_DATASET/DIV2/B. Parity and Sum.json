{
    "link": "https://codeforces.com//contest/1993/problem/B",
    "problemId": "2795982",
    "problem_idx": "B",
    "shortId": "1993B",
    "contest_number": "1993",
    "problem_submissions": {
        "C": [
            274402188,
            274358757,
            274374996,
            274374747,
            274368652,
            274357644,
            274365562,
            274356432,
            274379356,
            274367132,
            274372055,
            274371076,
            274363983,
            274370693,
            274369864,
            274367679,
            274363345,
            274405366,
            274364436
        ],
        "B": [
            274397223,
            274346884,
            274361191,
            274359127,
            274350863,
            274346370,
            274355668,
            274347298,
            274365588,
            274350765,
            274364310,
            274350846,
            274352824,
            274355191,
            274352816,
            274350915,
            274351222,
            274395841,
            274351441
        ],
        "A": [
            274391220,
            274335769,
            274358967,
            274335712,
            274338856,
            274337195,
            274340094,
            274335737,
            274356689,
            274336110,
            274349520,
            274336792,
            274342378,
            274342208,
            274335539,
            274352863,
            274335926,
            274386754,
            274342173
        ],
        "D": [
            274387898,
            274378476,
            274479687,
            274386087,
            274394516,
            274379793,
            274384145,
            274380644,
            274383004,
            274432739,
            274365274,
            274383568,
            274381874,
            274380805,
            274387445,
            274383605,
            274390133,
            275106936,
            274388789,
            274469604,
            274391022,
            274416385,
            274388682
        ],
        "E": [
            274380482,
            274416572,
            274415942,
            274406977,
            274400748,
            275106863,
            274409594,
            281997956,
            274569827
        ],
        "F2": [
            274361444,
            274397454,
            274414076,
            274417256,
            274415219,
            276095739,
            274383447
        ],
        "F1": [
            274349830,
            274385685,
            274402182,
            274415340,
            274413779,
            274417154,
            274400648,
            274391762,
            274403361,
            274395449,
            274405171,
            274404884,
            274415155,
            274426602,
            274426556,
            274426256,
            274400601,
            274403335,
            274384119,
            274407161
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132185",
    "editorial": "SolutionFirst, if all elements already have the same parity, we don\u00e2\u0080\u0099t\r\nneed to do perform any operation.Next, if the array contains both and\r\nnumbers. In this case, it is impossible to convert all elements to\r\nnumbers. Why?If we apply an operation on: two elements, one of them\r\nremains . two elements of distinct parities, one of them is replaced\r\nwith their sum, which is an number. This implies even if we want to\r\nchange an element to number, it fails in both ways possible.So we just\r\nwant to convert all of them to numbers. Now come the greedy part: it\r\ndoesn\u00e2\u0080\u0099t reduce the number of elements, so skip it. this creates another\r\nnumber, indeed very awful. this is great, but only if the sum replaces\r\nthe one (which means ). Let\u00e2\u0080\u0099s find the largest element and call it .\r\nThen traverse each elements in non-decreasing order and apply an\r\noperation on and : If , becomes largest odd number. Thus, we set . This\r\nreduce the number of even element by . If , before we do this operation,\r\nwe need to do another on and the largest even element to make the\r\nlargest in the array. Note that this case only happens at most once. As\r\na result, the answer is the number of even elements (plus if the second\r\ncase occurs).Time complexity: .\r\n",
    "name": "B. Parity and Sum",
    "statement": "Given an array a of n positive integers.In one operation, you can pick\r\nany pair of indexes (i, j) such that a_i and a_j have parity, then\r\nreplace the smaller one with the sum of them. More formally: If a_i <\r\na_j, replace a_i with a_i + a_j; Otherwise, replace a_j with a_i + a_j.\r\nFind the minimum number of operations needed to make all elements of the\r\narray have the same parity.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}void run(){\tvi od,ev;\tint n,x;\tcin>>n;\trep(i,n){\t\tcin>>x;\t\tif(x&1)od.pb(x);\t\telse ev.pb(x);\t}\tif(od.empty()||ev.empty()){\t\tcout<<\"0\\n\";\t\tre;\t}\tsort(all(od));\tsort(all(ev));\tint mxe=ev.back(),mxo=od.back();\tif(mxo>mxe){\t\tcout<<sz(ev)<<\"\\n\";\t\tre;\t}\tint mx=mxo;\tfor(int i:ev){\t\tif(i<mxo){\t\t\tmxo+=i;\t\t}\t\telse{\t\t\tcout<<sz(ev)+1<<\"\\n\";\t\t\tre;\t\t}\t}\tcout<<sz(ev)<<\"\\n\";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Parity and Sum.json"
}