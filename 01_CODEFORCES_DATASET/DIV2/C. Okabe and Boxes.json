{
    "link": "https://codeforces.com//contest/821/problem/C",
    "problemId": "111651",
    "problem_idx": "C",
    "shortId": "821C",
    "contest_number": "821",
    "problem_submissions": {
        "D": [
            28036388,
            28036319,
            28037093,
            41734433,
            28037174,
            28036759,
            28036893,
            28108464,
            28108438,
            28053809,
            28048526,
            28037849,
            28039886,
            28037900,
            28037562,
            28037762,
            28067673,
            28050717
        ],
        "E": [
            28031080,
            28025704,
            28029758,
            28032764,
            28034511,
            28038207,
            28056472,
            28054979,
            28053726,
            28053708,
            28053530,
            28035432,
            28032380,
            28032466,
            67190033,
            28025986,
            28039285,
            28035423,
            28028415,
            28031314,
            28033070,
            28028563,
            28033114,
            28035978,
            28036465,
            28035018
        ],
        "C": [
            28027564,
            28028757,
            28027102,
            28028054,
            28028077,
            28026793,
            28053306,
            28050947,
            28049926,
            28028104,
            28028806,
            28032681,
            28027048,
            28027053,
            28038599,
            28026500,
            28028038,
            28025519,
            28031473,
            28029012,
            28027297,
            28028758,
            28029118
        ],
        "B": [
            28025033,
            28029985,
            28027229,
            28026296,
            28026743,
            28025293,
            28047680,
            28046444,
            28026532,
            28026871,
            28024943,
            28029111,
            28024882,
            28027316,
            28035127,
            28026321,
            28027518,
            28033448,
            28025512,
            28026466,
            28026910
        ],
        "A": [
            28023814,
            28030700,
            28026806,
            28025423,
            28026686,
            28024284,
            28047598,
            28025814,
            28023873,
            28023685,
            28028848,
            28024187,
            28025303,
            28024870,
            28024246,
            28024053,
            28029160,
            28023901,
            28023721,
            28024947,
            28025828
        ]
    },
    "name": "C. Okabe and Boxes",
    "statement": "Okabe and Super Hacker Daru are stacking and removing boxes. There are\r\nboxes numbered from to . Initially there are no boxes on the\r\nstack.Okabe, being a control freak, gives Daru commands: of which are to\r\nadd a box to the top of the stack, and of which are to remove a box from\r\nthe top of the stack and throw it in the trash. Okabe wants Daru to\r\nthrow away the boxes in the order from to . Of course, this means that\r\nit might be impossible for Daru to perform some of Okabe\u2019s commands,\r\nbecause the required box is not on the top of the stack.That\u2019s why Daru\r\ncan decide to wait until Okabe looks away and then reorder the boxes in\r\nthe stack in any way he wants. He can do it at any point of time between\r\nOkabe\u2019s commands, but he can\u2019t add or remove boxes while he does it.Tell\r\nDaru the minimum number of times he needs to reorder the boxes so that\r\nhe can successfully complete all of Okabe\u2019s commands. It is guaranteed\r\nthat every box is added before it is required to be removed.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define oo 0x3f3f3f3f\n#define cl(x) memset(x, 0, sizeof(x))\n#define maxn 300010\ntypedef long long ll;\nusing namespace std;\nvoid gn(int &x) {\n\tx = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') ch = getchar();\n\twhile (ch >= '0' && ch <= '9')\n\t\tx = x * 10 + ch - '0', ch = getchar();\n}\nchar s[20];\nint n, sta[maxn], top, x, k, ans;\nint main() {\n\tgn(n);\n\tfor (int i = 1; i <= 2 * n; ++i) {\n\t\tscanf(\"%s\", s + 1);\n\t\tif (s[1] == 'a') {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tsta[++top] = x; \n\t\t} else {\n\t\t\t++k;\n\t\t\tif (top && sta[top] == k) {\n\t\t\t\t--top;\n\t\t\t} else {\n\t\t\t\tif (!top) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\t++ans; top = 0; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Okabe and Boxes.json",
    "editorial_link": "https://codeforces.com/blog/entry/52895",
    "editorial": "It looks like Daru should only reorder the boxes when he has to (i.e. he gets a remove operation on a number which isn't at the top of the stack). The proof is simple: reordering when Daru has more boxes is always not worse than reordering when he has less boxes, because Daru can sort more boxes into the optimal arrangement. Therefore, our greedy algorithm is as follows: simulate all the steps until we need to reorder, and then we resort the stack in ascending order from top to bottom.\n\nThis has complexity O(n2 log n). However, we can speed this up if we note that whenever we reorder boxes, any box currently on the stack can be put in an optimal position and we can pretty much forget about it. So whenever we reorder, we can just clear the stack as well and continue. This gives us O(n) complexity because every element is added and removed exactly once."
}