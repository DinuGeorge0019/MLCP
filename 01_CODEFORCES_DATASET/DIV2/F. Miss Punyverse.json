{"link": "https://codeforces.com//contest/1281/problem/F", "problemId": "495771", "problem_idx": "F", "shortId": "1281F", "contest_number": "1281", "problem_submissions": {"E": [66919654, 66920588, 66925092, 66923975, 66921225, 66926039, 66924486, 66925911, 66919753, 66924443, 66921735, 66926640, 66923762, 66928689, 66923984, 66929347, 66922347, 66925800, 66926136, 66926785], "D": [66913905, 66912980, 66914351, 66914888, 66918186, 66917312, 66919310, 66913455, 66927167, 66918040, 66916917, 66918767, 66920615, 66919931, 66917311, 66920679, 66926946, 66921289, 66921368, 66915749], "C": [66910411, 66909108, 66910083, 66911847, 66912648, 66912093, 66912420, 66917797, 66912812, 66913195, 66926185, 66911123, 66913114, 66915044, 66929796, 66916101, 66915614, 66912997, 66913346, 66920684], "B": [66903686, 66904970, 66904261, 66905849, 66904183, 70825921, 66906323, 66905017, 66906316, 66904966, 66910332, 66906601, 66907853, 66908474, 66905210, 66905588, 66906778, 66904477, 66905850, 66914866, 66908783], "A": [66901264, 66901388, 66900754, 66900661, 66900790, 70825928, 66900330, 66900663, 66904497, 66901649, 66900680, 66901270, 66900668, 66900286, 66902138, 66900321, 66900528, 66900477, 66900340, 66913834, 66903613], "F": [66933294, 67581587]}, "name": "F. Miss Punyverse", "statement": "The Oak has n nesting places, numbered with integers from 1 to n.\r\nNesting place i is home to b_i bees and w_i wasps.Some nesting places\r\nare connected by branches. We call two nesting places if there exists a\r\nbranch between them. A from nesting place x to y is given by a sequence\r\ns_0,\r\nldots, s_p of distinct nesting places, where p is a non-negative\r\ninteger, s_0 = x, s_p = y, and s_{i-1} and s_{i} are adjacent for each i\r\n= 1,\r\nldots, p. The branches of The Oak are set up in such a way that for any\r\ntwo pairs of nesting places x and y, there exists a unique simple path\r\nfrom x to y. Because of this, biologists and computer scientists agree\r\nthat The Oak is in fact, a tree.A is a set V of nesting places such that\r\nfor any two x and y in V, there exists a simple path from x to y whose\r\nintermediate nesting places all lie in V. A set of villages\r\ncal P is called a if each of the n nesting places is contained in\r\nexactly one of the villages in\r\ncal P. In other words, no two villages in\r\ncal P share any common nesting place, and altogether, they contain all n\r\nnesting places.The Oak holds its annual Miss Punyverse beauty pageant.\r\nThe two contestants this year are Ugly Wasp and Pretty Bee. The winner\r\nof the beauty pageant is determined by voting, which we will now\r\nexplain. Suppose\r\nmathcal{P} is a partition of the nesting places into m villages V_1,\r\nldots, V_m. There is a local election in each village. Each of the\r\ninsects in this village vote for their favorite contestant. If there are\r\nmore votes for Ugly Wasp than Pretty Bee, then Ugly Wasp is said to in\r\nthat village. Otherwise, Pretty Bee . Whoever wins in the most number of\r\nvillages wins.As it always goes with these pageants, bees always vote\r\nfor the bee (which is Pretty Bee this year) and wasps always vote for\r\nthe wasp (which is Ugly Wasp this year). Unlike their general elections,\r\nno one abstains from voting for Miss Punyverse as everyone takes it very\r\nseriously.Mayor Waspacito, and his assistant Alexwasp, wants Ugly Wasp\r\nto win. He has the power to choose how to partition The Oak into exactly\r\nm villages. If he chooses the partition optimally, determine the maximum\r\nnumber of villages in which Ugly Wasp wins.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\nconst int maxn=3005;\nint n,m,siz[maxn],f[maxn][maxn];\nll a[maxn],b[maxn],g[maxn][maxn],s[maxn],t[maxn];\nvector<int> e[maxn];\nvoid dfs(int x,int ff)\n{\n\tf[x][0]=0,g[x][0]=b[x]-a[x],siz[x]=1;\n\tfor(auto y:e[x])\n\t\tif(y!=ff)\n\t\t{\n\t\t\tdfs(y,x);\n\t\t\tfor(int i=0;i<=siz[x]+siz[y];i++) s[i]=-1e9,t[i]=-(1ll<<50);\n\t\t\tfor(int i=siz[x];i>=0;i--)\n\t\t\t\tfor(int j=siz[y];j>=0;j--)\n\t\t\t\t\tif(s[i+j]<f[x][i]+f[y][j])\n\t\t\t\t\t{\n\t\t\t\t\t\ts[i+j]=f[x][i]+f[y][j];\n\t\t\t\t\t\tt[i+j]=g[x][i]+g[y][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[i+j]==f[x][i]+f[y][j] && t[i+j]<g[x][i]+g[y][j])\n\t\t\t\t\t\tt[i+j]=g[x][i]+g[y][j];\n\t\t\tsiz[x]+=siz[y];\n\t\t\tfor(int i=0;i<=siz[x];i++) f[x][i]=s[i],g[x][i]=t[i];\n\t\t}\n\tfor(int i=siz[x]-1;i>=0;i--)\n\t{\n\t\tint t=(g[x][i]>0)?1:0;\n\t\tif(f[x][i+1]<f[x][i]+t) f[x][i+1]=f[x][i]+t,g[x][i+1]=0;\n\t\telse if(f[x][i+1]==f[x][i]+t && g[x][i+1]<0) g[x][i+1]=0;\n\t}\n}\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=1;i<=n;i++) e[i].clear();\n\t\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\t\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&b[i]);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=0;j<=n;j++) f[i][j]=-1e9,g[i][j]=-(1ll<<50);\n\t\tint x,y;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\te[x].push_back(y);\n\t\t\te[y].push_back(x);\n\t\t}\n\t\tdfs(1,0);\n\t\tprintf(\"%d\\n\",f[1][m-1]+(g[1][m-1]>0));\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "greedy", "trees"], "dificulty": "2500", "interactive": false}