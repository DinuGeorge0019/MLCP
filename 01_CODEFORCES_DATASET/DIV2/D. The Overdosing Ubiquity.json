{
    "link": "https://codeforces.com//contest/869/problem/D",
    "problemId": "126371",
    "problem_idx": "D",
    "shortId": "869D",
    "contest_number": "869",
    "problem_submissions": {
        "D": [
            31079634,
            31141598,
            31145705
        ],
        "E": [
            31075785,
            31069215,
            31080040,
            31081323,
            31074160,
            31082163,
            31082035,
            31082564,
            31082141,
            31081908,
            31081217,
            31081628,
            31082993,
            31083283,
            31083912,
            31087767,
            31084108,
            31078586,
            31084855,
            31083040
        ],
        "A": [
            31067793,
            31073676,
            31074428,
            31068201,
            31086909,
            31079089,
            31067885,
            31068981,
            31068063,
            31067651,
            31070628,
            31074705,
            31084568,
            31078753,
            31067709,
            31067304,
            31161754,
            31073201,
            31081947,
            31075757,
            31070398
        ],
        "B": [
            31073025,
            31075269,
            31070123,
            31075379,
            31070811,
            31071135,
            31069986,
            31068990,
            31069939,
            31070787,
            31070307,
            31076966,
            31068695,
            31068797,
            31070262,
            31082457,
            31069869,
            31072376
        ],
        "C": [
            31072413,
            31073328,
            31078301,
            31083141,
            31075905,
            31078217,
            31077340,
            31075408,
            31078573,
            31078127,
            31076488,
            31075475,
            31078939,
            31081015,
            31078419,
            31081092,
            31079081,
            31082030
        ]
    },
    "name": "D. The Overdosing Ubiquity",
    "statement": "The Cinderswarm Bee. Koyomi knows it.The bees, according to their\r\nnature, live in a tree. To be more specific, a with nodes numbered from\r\nto . The node numbered is the root, and the parent of the -th () node is\r\n. Note that, however, all edges in the tree are undirected.Koyomi adds\r\nextra undirected edges to the tree, creating more complication to trick\r\nthe bees. And you\u2019re here to count the number of in the resulting graph,\r\nmodulo . A is an alternating sequence of adjacent nodes and undirected\r\nedges, which begins and ends with nodes and does not contain any node\r\nmore than once. Do note that a single node is also considered a valid\r\nunder this definition. Please refer to the examples and notes below for\r\ninstances.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x[10], y[10];\nint sz[1000];\nint mod = 1000000007;\nmap<int, int> g, id;\nset<int> s;\nvector<int> a[1000];\nlong long ans;\nbool vis[1000];\nvoid gao(int x) {\n\twhile (x > 0) {\n\t\ts.insert(x);\n\t\tx /= 2;\n\t}\n}\n\nvoid dfs(int x, long long b) {\n\tvis[x] = true;\n\tans += b * sz[x];\n\tans %= mod;\n\tfor (int i: a[x]) {\n\t\tif (!vis[i]) {\n\t\t\tdfs(i, b);\n\t\t}\n\t}\n\tvis[x] = false;\n}\n\nint calc(int x) {\n\tint left = x;\n\tint right = x;\n\tint re = 0;\n\twhile (true) {\n\t\tif (left > n) {\n\t\t\treturn re;\n\t\t}\n\t\tre += min(right, n) - left + 1;\n\t\tright = right * 2 + 1;\n\t\tleft = left * 2;\n\t}\n\treturn re;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\tgao(x[i]);\n\t\tgao(y[i]);\n\t}\n\ts.insert(1);\n\tfor (int i: s) {\n\t\tif (s.find(2 * i) == s.end() && s.find(2 * i + 1) == s.end()) {\n\t\t\tg[i] = calc(i);\n\t\t} else {\n\t\t\tg[i] = 1;\n\t\t\tif (2 * i <= n && s.find(2 * i) == s.end()) {\n\t\t\t\tg[2 * i] = calc(2 * i);\n\t\t\t}\n\t\t\tif (2 * i + 1 <= n && s.find(2 * i + 1) == s.end()) {\n\t\t\t\tg[2 * i + 1] = calc(2 * i + 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (pair<int, int> sth: g) {\n\t\tint i = sth.first;\n\t\tint u = id.size();\n\t\tid[i] = u;\n\t\tsz[u] = g[i];\n\t}\n\tassert(g.size() == id.size());\n\tint nn = g.size();\n\tfor (pair<int, int> sth: id) {\n\t\tint i = sth.first;\n\t\tif (i == 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint child = id[i];\n\t\tint father = id[i / 2];\n\t\ta[child].push_back(father);\n\t\ta[father].push_back(child);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint first = id[x[i]];\n\t\tint second = id[y[i]];\n\t\ta[first].push_back(second);\n\t\ta[second].push_back(first);\n\t}\n\tfor (int i = 0; i < nn; i++) {\n\t\tdfs(i, sz[i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. The Overdosing Ubiquity.json",
    "editorial_link": "https://codeforces.com//blog/entry/55009",
    "editorial": "There are no more than ways to go through these extra edges, each of\r\nwhich will bring us at most more simple paths. If we count all these\r\nsimple paths using simple depth-first search, the time complexity will\r\nbe , which is the same as the order of the answer.However, we can reduce\r\nthe original graph to a pretty small one, for example, by keeping all\r\nthe nodes on some cycle and compressing the others. Noticing that the\r\nlongest simple path on a complete binary tree is just , the compressed\r\ngraph will contain at most nodes. Running simple depth-first search on\r\nsuch a small graph will lead to an solution, which fits in with the\r\nsmall constraint of and works really fast in practice.\r\n"
}