{
    "link": "https://codeforces.com//contest/1659/problem/B",
    "problemId": "1371412",
    "problem_idx": "B",
    "shortId": "1659B",
    "contest_number": "1659",
    "problem_submissions": {
        "E": [
            153913573,
            153929614,
            153928927,
            153922832,
            153919141,
            153972138,
            153926923,
            153927092,
            153929319,
            153932903,
            153930192,
            153930364,
            153930632,
            153931626,
            153929090,
            153932497,
            153927674,
            153932539,
            153931108,
            153930225
        ],
        "D": [
            153912412,
            153905719,
            153910339,
            153913081,
            153925687,
            153914747,
            153914843,
            153917030,
            153914214,
            153914225,
            153916202,
            153914923,
            153911260,
            153911942,
            153919382,
            153913809,
            153916530,
            153910597,
            153914778,
            153923066
        ],
        "B": [
            153899189,
            153895163,
            153894044,
            153901045,
            153896660,
            153905534,
            153895509,
            153894100,
            153894393,
            153894053,
            153896780,
            153900091,
            153895296,
            153893292,
            153896323,
            153897272,
            153895755,
            153896012,
            153922971,
            153892638
        ],
        "C": [
            153893804,
            153899081,
            153898923,
            153904670,
            153899860,
            153895491,
            153906966,
            153902317,
            153904388,
            153898598,
            153905688,
            153905657,
            153901854,
            153898683,
            153904460,
            153903103,
            153900333,
            153901824,
            153895900,
            153899518
        ],
        "A": [
            153892134,
            153890875,
            153890881,
            153898852,
            153891639,
            153899777,
            153891702,
            153891302,
            153890852,
            153890890,
            153891590,
            153893681,
            153891282,
            153890712,
            153890944,
            153892901,
            153890725,
            153890838,
            153891604,
            153890839
        ],
        "F": [
            153937865
        ]
    },
    "name": "B. Bit Flipping",
    "statement": "You are given a binary string of length n. You have k moves. In one\r\nmove, you must select a single bit. The state of all bits that bit will\r\nget flipped (0 becomes 1, 1 becomes 0). You need to output the\r\nlexicographically largest string that you can get after using k moves.\r\nAlso, output the number of times you will select each bit. If there are\r\nmultiple ways to do this, you may output any of them.A binary string a\r\nis lexicographically larger than a binary string b of the same length,\r\nif and only if the following holds: in the first position where a and b\r\ndiffer, the string a contains a 1, and the string b contains a 0.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nint T, n, k, a[N];\nchar s[N];\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> T;\n\twhile(T--){\n\t\tcin >> n >> k;\n\t\tcin >> s + 1;\n\t\tint num = 0;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tif(((s[i] == '1' && (k & 1)) || (s[i] == '0' && k % 2 == 0)) && num < k){\n\t\t\t\ta[i] = 1;\n\t\t\t\ts[i] = '1';\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\telse if(s[i] == '0' && k % 2 == 1) s[i] = '1';\n\t\t\telse if(s[i] == '1' && k % 2 == 1) s[i] = '0'; \n\t\t}\n\t\tif(num < k){\n\t\t\ta[n] += k - num;\n\t\t\tif((k - num) & 1) s[n] = '0';\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i) cout << s[i];\n\t\tcout << endl;\n\t\tfor(int i = 1; i <= n; ++i) cout << a[i] << \" \", a[i] = 0;\n\t\tcout << endl;\n \t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "greedy",
        "strings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Bit Flipping.json",
    "editorial_link": "https://codeforces.com//blog/entry/100938",
    "editorial": "Letâs see how many times a given bit will get flipped. Clearly, a bit\r\ngets flipped whenever it is not selected in an operation. Therefore, the\r\n-th bit gets flipped times. We want to select a bit as few times as\r\npossible. Now we can handle a few cases. is even, bit is (even number of\r\nflips donât change the bit) is even, bit is (odd number of flips toggle\r\nthe bit from to ) is odd, bit is (even number of flips donât change the\r\nbit) is odd, bit is (odd number of flips toggle the bit from to )\r\nProcess the string from left to right until you canât anymore. If you\r\nstill have some remaining moves at the end, you can just give them all\r\nto the last bit. Then you can construct the final string by checking the\r\nparity of .Time complexity:\r\n",
    "hint": [
        "Hint 1 Let's say you don't ever pick a bit. How many times will it get flipped?",
        "Hint 2 If you do pick a bit once at some point, it will get flipped less time overall.",
        "Hint 3 To get the lexicographically largest string, you need to make bits starting from the left. What is the minimum number of times you have to select a bit to ensure it gets flipped, or stays the same?"
    ]
}