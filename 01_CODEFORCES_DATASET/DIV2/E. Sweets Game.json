{"link": "https://codeforces.com//contest/63/problem/E", "problemId": "340", "problem_idx": "E", "shortId": "63E", "contest_number": "63", "problem_submissions": {"E": [311463, 311795, 311658, 312041, 311459, 311614, 312617, 312614, 312611, 311794, 313907], "D": [310975, 311092, 311255, 311536, 312237, 314064, 312662, 313516, 311785, 311719, 311559, 312152, 311462, 311572], "C": [310530, 310622, 311964, 310809, 310631, 310750, 310684, 311187, 310895, 310934, 311409, 312431, 312213], "B": [310080, 310144, 310881, 310482, 310197, 310082, 310056, 310432, 310241, 310401, 310624, 310354, 310493], "A": [309670, 309659, 310177, 310020, 309894, 309667, 309653, 309878, 309812, 309824, 309970, 309929, 310031]}, "name": "E. Sweets Game", "statement": "Karlsson has visited Lillebror again. They found a box of chocolates and\r\na big whipped cream cake at Lillebror\u2019s place. Karlsson immediately\r\nsuggested to divide the sweets fairly between Lillebror and himself.\r\nSpecifically, to play together a game he has just invented with the\r\nchocolates. The winner will get the cake as a reward.The box of\r\nchocolates has the form of a hexagon. It contains 19 cells for the\r\nchocolates, some of which contain a chocolate. The players move in\r\nturns. During one move it is allowed to eat one or several chocolates\r\nthat lay in the neighboring cells on one line, parallel to one of the\r\nbox\u2019s sides. The picture below shows the examples of allowed moves and\r\nof an unacceptable one. The player who cannot make a move loses.\r\nKarlsson makes the first move as he is Lillebror\u2019s guest and not vice\r\nversa. The players play optimally. Determine who will get the cake.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst char *a[15]={\n  \"abc\",\n  \"defg\",\n  \"hijkl\",\n  \"mnop\",\n  \"qrs\",\n  \"adh\",\n  \"beim\",\n  \"cfjnq\",\n  \"gkor\",\n  \"lps\",\n  \"cgl\",\n  \"bfkp\",\n  \"aejos\",\n  \"dinr\",\n  \"hmq\",\n};\n\nchar s[5];\n\nvector <int> moves;\nset <int> was;\n\nint ans[(1<<19) + 239];\n\nint main (void)\n{\n  for (int i=0; i<15; i++)\n  {\n    int l = strlen(a[i]);\n    for (int j=0; j<l; j++)\n      for (int k=j; k<l; k++)\n      {\n        int mask = 0;\n        for (int t=j; t<=k; t++)\n          mask |= (1 << (a[i][t] - 'a'));\n        if (!was.count(mask)) {\n          was.insert(mask);\n          moves.push_back(mask);\n//          cout << mask << endl;\n        }\n      }\n  }\n\n  int mask = 0;\n  for (int i=0; i<19; i++) {\n    scanf(\"%s\", s);\n    if (s[0] != '.')\n      mask |= (1 << i);\n  }\n\n  ans[0] = 1;\n  for (int i=1; i < (1 << 19); i++) \n  {\n    int win = 0;\n    for (int j=0; j<(int)moves.size() && !win; j++) {\n      if ((i | moves[j]) == i && ans[i ^ moves[j]]) \n        win = 1;\n    }\n    ans[i] = 1 - win;\n  }\n\n  cout << (ans[mask] ? \"Lillebror\" : \"Karlsson\") << endl;\n\n  return 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "dfs and similar", "dp", "games", "implementation"], "dificulty": "2000", "interactive": false}