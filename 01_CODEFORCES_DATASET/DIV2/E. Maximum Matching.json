{
    "link": "https://codeforces.com//contest/1038/problem/E",
    "problemId": "216025",
    "problem_idx": "E",
    "shortId": "1038E",
    "contest_number": "1038",
    "problem_submissions": {
        "F": [
            42582709,
            42588924
        ],
        "E": [
            42575080,
            42578573,
            42575208,
            42576431,
            42577789,
            42580719,
            42575666,
            42580571,
            42583311,
            42581396,
            42582088,
            42580954,
            42583334,
            42579643,
            42582008,
            42580920,
            42583129,
            42582580,
            42583754
        ],
        "D": [
            42573485,
            42569896,
            42569634,
            42567012,
            42572149,
            42570113,
            42576120,
            42571013,
            42565752,
            42571052,
            42574327,
            42570312,
            42567294,
            42575127,
            42575057,
            42572394,
            42574539,
            42573852,
            42573051
        ],
        "C": [
            42566710,
            42563399,
            42564810,
            42563947,
            42567501,
            42564966,
            42562683,
            42566829,
            42562396,
            42564608,
            42563976,
            42565121,
            42570852,
            42564983,
            42565516,
            42568404,
            42566048,
            42568514,
            42566544
        ],
        "B": [
            42560979,
            42561635,
            42561921,
            42561073,
            42563881,
            42561586,
            42565172,
            42563091,
            42560475,
            42561602,
            42561362,
            42562336,
            42564791,
            42568121,
            42563027,
            42564081,
            42563007,
            42563149,
            42562895
        ],
        "A": [
            42559251,
            42559046,
            42559189,
            42559233,
            42563411,
            42559174,
            42559467,
            42559825,
            42558982,
            42559283,
            42559010,
            42559078,
            42560087,
            42561636,
            42561187,
            42559807,
            42559670,
            42559820,
            42559436
        ]
    },
    "name": "E. Maximum Matching",
    "statement": "You are given n blocks, each of them is of the form , where the block\r\ncan also be flipped to get . A sequence of blocks is called if the\r\ntouching endpoints of neighboring blocks have the same color. For\r\nexample, the sequence of three blocks A, B and C is valid if the left\r\ncolor of the B is the same as the right color of the A and the right\r\ncolor of the B is the same as the left color of C.The value of the\r\nsequence is defined as the sum of the values of the blocks in this\r\nsequence.Find the maximum possible value of the valid sequence that can\r\nbe constructed from the subset of the given blocks. The blocks from the\r\nsubset can be reordered and flipped if necessary. Each block can be used\r\nat most once in the sequence.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nint F[105][81][1<<6],id[5][5],f[5],d[5],_[5],n;\nvoid up(int &x,int y){if (y>x) x=y;}\nint get(int u){return f[u]==u?u:f[u]=get(f[u]);}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int S=0;S<81;S++)\n\t\t\tfor (int E=0;E<(1<<6);E++)\n\t\t\t\tF[i][S][E]=-1e9;\n\tint S=0;\n\tfor (int i=0;i<4;i++)\n\t\tS=S*3+2;\n\tF[0][S][0]=0;\n\tint tot=0;\n\tfor (int i=0;i<4;i++)\n\t\tfor (int j=i+1;j<4;j++)\n\t\t\tid[i][j]=(1<<tot++);\n\tfor (int t=1;t<=n;t++){\n\t\tint p,val,q;\n\t\tscanf(\"%d%d%d\",&p,&val,&q);\n\t\t--p;--q;if (p>q) swap(p,q);\n\t\tfor (int S=0;S<81;S++){\n\t\t\tfor (int i=0,cur=S;i<4;i++)\n\t\t\t\td[i]=cur%3,cur/=3;\n\t\t\tfor (int E=0;E<(1<<6);E++)\n\t\t\t\tif (F[t-1][S][E]>=0){\n\t\t\t\t\tup(F[t][S][E],F[t-1][S][E]);\n\t\t\t\t\tfor (int i=0;i<4;i++) _[i]=d[i];\n\t\t\t\t\tif (_[p]==2) _[p]=1;else _[p]^=1;\n\t\t\t\t\tif (_[q]==2) _[q]=1;else _[q]^=1;\n\t\t\t\t\tint newS=0;\n\t\t\t\t\tfor (int i=3;i>=0;i--)\n\t\t\t\t\t\tnewS=newS*3+_[i];\n\t\t\t\t\tup(F[t][newS][E|id[p][q]],F[t-1][S][E]+val);\n\t\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int S=0;S<81;S++){\n\t\tint sum[3]={0,0,0};\n\t\tfor (int i=0,cur=S;i<4;i++)\n\t\t\tsum[d[i]=cur%3]++,cur/=3;\n\t\tif (sum[1]!=2&&sum[1]!=0) continue;\n\t\tfor (int E=0;E<(1<<6);E++)\n\t\t\tif (F[n][S][E]>ans){\n\t\t\t\tfor (int i=0;i<4;i++) f[i]=i;\n\t\t\t\tint tot=0;\n\t\t\t\tfor (int i=0;i<4;i++)\n\t\t\t\t\tfor (int j=i+1;j<4;j++)\n\t\t\t\t\t\tif ((E>>tot++)&1) f[get(i)]=get(j);\n\t\t\t\tint rt=-1;\n\t\t\t\tfor (int i=0;i<4;i++)\n\t\t\t\t\tif (d[i]!=2) rt=get(i);\n\t\t\t\tint ok=1;\n\t\t\t\tfor (int i=0;i<4;i++)\n\t\t\t\t\tok&=d[i]==2||get(i)==get(rt);\n\t\t\t\tif (ok) ans=F[n][S][E];\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dfs and similar",
        "dp",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Maximum Matching.json",
    "editorial_link": "https://codeforces.com/blog/entry/61692",
    "editorial": "Create a graph with nodes representing the colors. Then the of a block\r\nserves as an edge between the two colors of that block. Then the\r\nquestion reduces to finding an euler tour in the graph with the maximum\r\nsum of edges traveled. An euler tour may not exist with all the given\r\nedges, so the question is: Which edges do we remove?One can note that\r\nthere are types of edges. (Edges connecting 1 to 1, 1 to 2 and so on).\r\nThere may be multiple edges of a specific type, however atmost 1 of it\r\nwill be removed to form a valid euler tour. This is because if we have\r\nedges between node and node where , we can simply loop back and forth\r\nbetween and times to end up at the node we started from.Since there are\r\nonly types of edges, we can use bitmask to iterate over all the\r\npossibilities, and checking whether an euler tour exists in the graph\r\nwith the marked edges removed (if there are multiple edges between node\r\nand node , we remove only one edge, the one with the least value). Refer\r\nto authorâs solution/any AC codes to see implementation details. Overall\r\nComplexity: Bonus: Can you solve this question in ? How about ?\r\n",
    "hint": []
}