{
    "link": "https://codeforces.com//contest/1370/problem/D",
    "problemId": "652386",
    "problem_idx": "D",
    "shortId": "1370D",
    "contest_number": "1370",
    "problem_submissions": {
        "F2": [
            84487930,
            84501037,
            84507034,
            84502122,
            84505842,
            84494417,
            84504172,
            84566845,
            84578526,
            84673821,
            84511966,
            84521155,
            84516268,
            84510958,
            84637167,
            84542732
        ],
        "F1": [
            84486378,
            84486419,
            84492617,
            84502436,
            84505676,
            84494227,
            84501907,
            84505799,
            84499630,
            84498065,
            84511746,
            84521030,
            84480006,
            84503644,
            84491858,
            84509184,
            84485122,
            84503318,
            84509115,
            84506881
        ],
        "E": [
            84464817,
            84468991,
            84473151,
            84479507,
            84475443,
            84500759,
            84489817,
            84460631,
            84470842,
            84474055,
            84482485,
            84496561,
            84465043,
            84479036,
            84484283,
            84492032,
            84480292,
            84478287,
            84477997
        ],
        "D": [
            84455500,
            84452319,
            84463814,
            84469488,
            84464677,
            84451453,
            84463855,
            84448741,
            84456676,
            84455689,
            84468315,
            84454815,
            84457156,
            84464597,
            84470092,
            84462687,
            84463427,
            84468065,
            84460953
        ],
        "C": [
            84440472,
            84440716,
            84454929,
            84448947,
            84446464,
            84442992,
            84450392,
            84441491,
            84448508,
            84447398,
            84459387,
            84446704,
            84452028,
            84452970,
            84461892,
            84451604,
            84450230,
            84447402,
            84456732
        ],
        "B": [
            84435577,
            84430992,
            84438860,
            84436667,
            84431532,
            84431988,
            84433331,
            84431260,
            84434049,
            84434058,
            84441995,
            84433852,
            84624590,
            84440409,
            84443832,
            84438516,
            84432500,
            84433721,
            84440325,
            84431147
        ],
        "A": [
            84423084,
            84423206,
            84424226,
            84425612,
            84423582,
            84423261,
            84424093,
            84424056,
            84423388,
            84425755,
            84429438,
            84426743,
            84423750,
            84423134,
            84428806,
            84425122,
            84423069,
            84423389,
            84423328
        ]
    },
    "name": "D. Odd-Even Subsequence",
    "statement": "Ashish has an array a of size n.A subsequence of a is defined as a\r\nsequence that can be obtained from a by deleting some elements (possibly\r\nnone), without changing the order of the remaining elements.Consider a\r\nsubsequence s of a. He defines the cost of s as the minimum between: The\r\nmaximum among all elements at odd indices of s. The maximum among all\r\nelements at even indices of s. Note that the index of an element is its\r\nindex in s, rather than its index in a. The positions are numbered\r\nfrom 1. So, the cost of s is equal to min(max(s_1, s_3, s_5,\r\nldots), max(s_2, s_4, s_6,\r\nldots)).For example, the cost of\r\n{7, 5, 6\r\n} is min( max(7, 6), max(5) ) = min(7, 5) = 5.Help him find the minimum\r\ncost of a subsequence of size k.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint const maxn = 2e5 + 5;\nint a[maxn], good[maxn], pref[maxn], suff[maxn];\npair < int, int > b[maxn];\n\ninline int oks(int n, int k, int x) {\n    for (int i = 1; i <= n; ++i) good[i] = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (b[i].first <= x) good[b[i].second] = 1;\n    }\n    for (int i = 1; i <= n; ++i) {\n        pref[i] = pref[i - 1];\n        if (good[i]) {\n            pref[i] = max(pref[i], 1);\n            if (i >= 2) pref[i] = max(pref[i], pref[i - 2] + 2);\n        }\n    }\n    for (int i = n; i >= 1; --i) {\n        suff[i] = suff[i + 1];\n        if (good[i]) {\n            suff[i] = max(suff[i], 1);\n            if (i + 1 <= n) suff[i] = max(suff[i], suff[i + 2] + 2);\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (a[i] >= x) {\n            if (pref[i - 1] + 1 + suff[i + 1] >= k) return 1;\n        }\n    }\n    return 0;\n}\n\nmain() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= n; ++i) b[i] = {a[i], i};\n    sort(b + 1, b + n + 1);\n    set < int > Q;\n    for (int i = 1; i <= n; ++i) Q.insert(a[i]);\n    vector < int > t;\n    for (auto key : Q) t.push_back(key);\n    int lef = -1, righ = (int)t.size();\n    while (righ - lef > 1) {\n        int mid = (righ + lef) / 2;\n        if (oks(n, k, t[mid])) righ = mid;\n        else lef = mid;\n    }\n    cout << t[righ];\n    return 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "dsu",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Odd-Even Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/79107",
    "editorial": ":Binary search over the answer and check if given , it is possible to\r\nform a subsequence of length at least such that either all elements at\r\nodd indices or even indices are .:Let us binary search over the answer\r\nand fix if the answer comes from elements at odd or even indices in the\r\nsubsequence. Suppose we want to find if there exists a subsequence of\r\nlength at least such that the elements at odd indices are . We will\r\nconstruct the subsequence greedily. Letâs iterate on the array from left\r\nto right. Suppose we are at index in the array and the current length of\r\nthe subsequence formed is . If is odd, the next added element would be\r\nat an even index. In this case, we do not care about what this element\r\nis as we only want elements at odd indices to be . So, in this case, we\r\nadd to the subsequence. If is even, then the next added element would be\r\nat an odd index, so, it must be . If , we can add to the subsequence,\r\notherwise we do not add to the subsequence and continue to the next\r\nelement in .Note that we can do a similar greedy construction for\r\nelements at even indices. If the length of the subsequence formed is\r\n(either by construction from odd indices or even indices), then the\r\nanswer can be equal to and we can reduce the upper bound of the binary\r\nsearch otherwise we increase the lower bound.Time Complexity - or\r\n",
    "hint": []
}