{
    "link": "https://codeforces.com//contest/1816/problem/E",
    "problemId": "1871641",
    "problem_idx": "E",
    "shortId": "1816E",
    "contest_number": "1816",
    "problem_submissions": {
        "F": [
            201571165,
            201575603
        ],
        "E": [
            201540535,
            201521580,
            201552172,
            201540274,
            201551497,
            201560232,
            201559664,
            201557564,
            201560804,
            201563162,
            201561880,
            201537774,
            201526707,
            201515322,
            201535371,
            201540257,
            201545215
        ],
        "D": [
            201526272,
            201555297,
            201531457,
            201549839,
            201530007,
            201538289,
            201538409,
            201545276,
            201541091,
            201540016,
            201546751,
            201561431
        ],
        "C": [
            201502393,
            201505622,
            201493541,
            201488761,
            201501981,
            201485106,
            201492364,
            201508062,
            201504590,
            201507370,
            201512800,
            201550313,
            201501935,
            201545685,
            201512228,
            201507426,
            201505339
        ],
        "B": [
            201495797,
            201498113,
            201488843,
            201489011,
            201486184,
            201503986,
            201518658,
            201489822,
            201495126,
            201490303,
            201498690,
            201494781,
            201494291,
            201504455,
            201496973,
            201494497,
            201495296
        ],
        "A": [
            201482599,
            201481556,
            201482965,
            201480957,
            201481143,
            201486345,
            201502905,
            201481407,
            201481488,
            201481674,
            201480959,
            201483748,
            201481910,
            201493735,
            201483634,
            201482175,
            201488121
        ]
    },
    "name": "E. Between",
    "statement": "You are given an integer n, as well as m pairs of integers (a_i,b_i),\r\nwhere 1\r\nleq a_i , b_i\r\nleq n, a_i\r\nne b_i.You want to construct a sequence satisfying the following\r\nrequirements: All elements in the sequence are integers between 1 and n.\r\nThere is exactly one element with value 1 in the sequence. For each i (1\r\nle i\r\nle m), between any two elements (on different positions) in the sequence\r\nwith value a_i, there is at least one element with value b_i. The\r\nsequence constructed has the length among all possible sequences\r\nsatisfying the above properties. Sometimes, it is possible that such a\r\nsequence can be arbitrarily long, in which case you should output \"\".\r\nOtherwise, you should output \"\" and the sequence itself. If there are\r\nmultiple possible constructions that yield the maximum length, output\r\nany.\r\n",
    "solutions": [
        "//\n//  main.cpp\n//  E\n//\n//  Created by Thomas Guo on 2023-04-09.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#define maxn 1502\n#define pb push_back\nusing namespace std;\nint main(){\n    int t;cin>>t;\n    while(t--){\n        vector<int>adj[maxn];\n        int n,m;cin>>n>>m;\n        while(m--){\n            int a,b;cin>>a>>b;\n            if(a!=1){\n                adj[b].pb(a);\n            }\n        }\n        bool vis[maxn];\n        int dis[maxn];\n        memset(vis, 0, sizeof vis);\n        dis[1] = 0;\n        queue<int>bfs;bfs.push(1);\n        while(!bfs.empty()){\n            int v = bfs.front();bfs.pop();\n            for(int nxt: adj[v]){\n                if(!vis[nxt]){\n                    vis[nxt] = 1;\n                    dis[nxt] = dis[v] + 1;\n                    bfs.push(nxt);\n                }\n            }\n        }\n        bool infinite = 0;\n        for(int i=2; i<=n; i++){\n            if(!vis[i]){\n                infinite = 1;\n            }\n        }\n        if(infinite){\n            cout<<\"INFINITE\\n\";\n            continue;\n        }\n        cout<<\"FINITE\\n\";\n        vector<int>layers[maxn];\n        int maxlayer = 0;\n        for(int i=1; i<=n; i++){\n            layers[dis[i]].pb(i);\n            maxlayer = max(maxlayer, dis[i]);\n        }\n        vector<int>ans;\n        for(int i = maxlayer; i >= 0; i--){\n            for(int j = maxlayer; j >= maxlayer - i; j--){\n                for(int k: layers[j]){\n                    ans.pb(k);\n                }\n            }\n        }\n        cout<<ans.size()<<\"\\n\";\n        for(int i:ans){\n            cout<<i<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Between.json",
    "editorial_link": "https://codeforces.com//blog/entry/114899",
    "editorial": "Construct a graph with n\n vertices and add a directed edge a?b\n if between every two a\n there must be a b\n.\n\nLet va\n be the number of occurrences of a\n. The key observation is that if a?b\n, then va?vb+1\n.\n\nSuppose ak?ak?1??a1\n is a directed path, where a1=1\n. Then since v1=1\n, we must have vai?i\n. In other words, vs?ds\n. where ds\n is one plus the length of the shortest directed path from s\n to 1\n.\n\nTherefore, the total array length does not exceed ?ni=1di\n. We claim that we can achieve this.\n\nIt is easy to calculate the ds\n by a BFS. Let Ti\n consists of vertices x\n such that vx=s\n. Let M\n the largest value of di\n among all i?1,2?n\n. Consider\n\n[TM],[TM?1][TM],[TM?2][TM?1][TM],?[T1][T2][T3]?[Tm]\nwhere for each i\n, vertices in various occurrences of Ti\n must be arranged in the same order.\n\nIt is easy to check that this construction satisfies all the constraints and achieve the upper bound ?ni=1di\n. Thus, this output is correct.\n\nThe sequence can be arbitrarily long if and only if there is some v\n that does not have a path directed to 1\n. To see this, let S\n be the set of vertices that do not have path directed to 1\n, then the following construction gives an arbitrarily long output that satisfy all constraints:\n\n1[S][S][S]?",
    "hint": []
}