{
    "link": "https://codeforces.com//contest/733/problem/C",
    "problemId": "78299",
    "problem_idx": "C",
    "shortId": "733C",
    "contest_number": "733",
    "problem_submissions": {
        "F": [
            21944181,
            21943396,
            21967823,
            21944382,
            21944760,
            21938912,
            21991227,
            22059840,
            21937562,
            21938035,
            21985645,
            21991821,
            21953425,
            22015051,
            21990688
        ],
        "E": [
            21937191,
            21938008,
            21943531,
            21943185,
            21953321,
            21943118,
            21945071,
            21961545
        ],
        "D": [
            21929126,
            21923181,
            21934246,
            21934699,
            21930359,
            21930083,
            21921931,
            21937281,
            21933013,
            21933051,
            21930915,
            21933717,
            21930137,
            21931610,
            21929842,
            21935332,
            21929335,
            21936423,
            21930780,
            21933993
        ],
        "C": [
            21927957,
            21950571,
            21931020,
            21929401,
            21936037,
            21935885,
            21953665,
            21934528,
            21938848,
            21929683,
            21937215,
            21940711,
            21934393,
            21928582,
            21934351,
            21931346,
            21936860,
            21931930
        ],
        "B": [
            21922288,
            21927937,
            21923164,
            21922462,
            21923910,
            21924025,
            21925504,
            21933294,
            21928279,
            21922570,
            21924161,
            21922272,
            21921961,
            21923577,
            21924912,
            21921350,
            21922700,
            21923311,
            21923198,
            21925029
        ],
        "A": [
            21919764,
            21920167,
            21920208,
            21919696,
            21920676,
            21920418,
            21919388,
            21932202,
            21929074,
            21920399,
            21925006,
            21920161,
            21919497,
            21919471,
            21922256,
            21919494,
            21926774,
            21920063,
            21919707,
            21927283
        ]
    },
    "name": "C. Epidemic in Monstropolis",
    "statement": "There was an epidemic in Monstropolis and all monsters became sick. To\r\nrecover, all monsters lined up in queue for an appointment to the only\r\ndoctor in the city.Soon, monsters became hungry and began to eat each\r\nother. One monster can eat other monster if its weight is than the\r\nweight of the monster being eaten, and they stand in the queue next to\r\neach other. Monsters eat each other instantly. There are no monsters\r\nwhich are being eaten at the same moment. After the monster eats the\r\nmonster , the weight of the monster increases by the weight of the eaten\r\nmonster . In result of such eating the length of the queue decreases by\r\none, all monsters after the eaten one step forward so that there is no\r\nempty places in the queue again. A monster can eat several monsters one\r\nafter another. Initially there were monsters in the queue, the -th of\r\nwhich had weight .For example, if weights are (in order of queue,\r\nmonsters are numbered from to from left to right) then some of the\r\noptions are: the first monster can’t eat the second monster because is\r\nnot greater than ; the second monster can’t eat the third monster\r\nbecause is not greater than ; the second monster can’t eat the fifth\r\nmonster because they are not neighbors; the second monster can eat the\r\nfirst monster, the queue will be transformed to . After some time,\r\nsomeone said a good joke and all monsters recovered. At that moment\r\nthere were () monsters in the queue, the -th of which had weight . Both\r\nsequences ( and ) contain the weights of the monsters in the order from\r\nthe first to the last.You are required to provide one of the possible\r\norders of eating monsters which led to the current queue, or to\r\ndetermine that this could not happen. Assume that the doctor didn’t make\r\nany appointments while monsters were eating each other.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int MX=(1<<20) , inf = -(1<<29);\nint dp[509][509];\nint sum[509] , n , arr[509];\nvector < pair < int , char > > sol;\nint calc(int x , int y){\n    if(x > y || x == y) return 1;\n    int &ret = dp[x][y]; if(ret != -1) return ret;\n    ret = 0;\n    for(int k = x ; k < y ; k++){\n        if(sum[k] - sum[x-1] != sum[y] - sum[k])\n            ret |= ( calc(x , k) && calc(k+1 , y) );\n    }\n    return ret;\n}\nvoid find_sol(int x , int y , int add){\n    if(x > y || x == y) return;\n    for(int k = x ; k < y ; k++){\n        if(sum[k] - sum[x-1] != sum[y] - sum[k] && calc(x , k) && calc(k+1 , y) ){\n            find_sol(x , k , add);\n            find_sol(k+1 , y , add+1);\n            if(sum[k] - sum[x-1] > sum[y] - sum[k])\n                sol.push_back({add+1 , 'R'});\n            else sol.push_back({add+2 , 'L'});\n            break;\n        }\n    }\n}\nbool solve(vector < int > v){\n    n = v.size();\n    for(int j=1;j<=n;j++){\n        arr[j] = v[j-1];\n        sum[j] = arr[j] + sum[j-1];\n    }\n    memset(dp , -1 , sizeof(dp));\n    sol.clear();\n    if(!calc(1,n)) return 0;\n    find_sol(1 , n , 0);\n    return 1;\n}\nint aa , bb;\nint main(){\n    scanf(\"%d\",&aa);\n    vector < int > src;\n    for(int j=1;j<=aa;j++){\n        int x;\n        scanf(\"%d\",&x);\n        src.push_back(x);\n    }\n    bool nosol = 0;\n    reverse(src.begin() , src.end());\n    scanf(\"%d\",&bb);\n    vector < pair < int , char > > wholy;\n    for(int iter = 1 ; iter <= bb ; iter++){\n        vector < int > v;\n        int x;\n        scanf(\"%d\",&x);\n        while(!src.empty()){\n            if(src.back() > x) break;\n            v.push_back(src.back());\n            x-=src.back();\n            src.pop_back();\n        }\n        if(x){\n            nosol = 1;\n            break;\n        }\n        if(!solve(v)){\n            nosol = 1;\n            break;\n        }\n        for(auto pp : sol)\n            wholy.push_back({pp.first + iter -1 , pp.second});\n    }\n    if(src.size()) nosol = 1;\n    if(nosol){\n        puts(\"NO\");\n        return 0;\n    }\n    puts(\"YES\");\n    for(auto pp : wholy)\n        cout<<pp.first<<' '<<pp.second<<endl;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Epidemic in Monstropolis.json",
    "editorial_link": "https://codeforces.com//blog/entry/48133",
    "editorial": "The key observation to solution is to notice that is union (monsters eat\r\none another one by one in such a way that only one is being left) of\r\nelements of some prefix of . And if you remove this prefix and first\r\nelement of then this condition will remain true for new arrays and .\r\nAnswer is \"NO\" when: There is no such prefix that has sum of . Prefix of\r\nsum consists of equal elements and its size . Now letâs consider certain\r\nprefix. Our goal is to find sequence of moves to get only one monster\r\nleft.Here is one of possible solutions: Find such that is maximum in\r\nprefix and either or is strictly less that . Eat any of possible\r\nneighbors. If only one monster is left then move to next segment. If all\r\nweights become equal then print \"NO\". The only thing left is to\r\ncarefully calculate real positions of monsters on each step. Also you\r\ncanât output them at a moment of calculation as there might be a \"NO\"\r\nanswer afterwards.Time complexity .And challenge: can you optimize it to\r\n?\r\n",
    "hint": []
}