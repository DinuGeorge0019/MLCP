{
    "link": "https://codeforces.com//contest/1972/problem/F",
    "problemId": "2620262",
    "problem_idx": "F",
    "shortId": "1972F",
    "contest_number": "1972",
    "problem_submissions": {
        "E": [
            258907706,
            258906689,
            258908735,
            258886738,
            258901485,
            258906022,
            258913488,
            258911752,
            258913907,
            258913999,
            258916450,
            258914641,
            258910690,
            258920127,
            258912063,
            258910772,
            258915135,
            258914430
        ],
        "D2": [
            258898687,
            258895159,
            258892501,
            258911037,
            258914022,
            258908970,
            258902827,
            258898337,
            258897157,
            258907327,
            258896398,
            258902164,
            258918202,
            258887350,
            258904678,
            258922033,
            258908345,
            258904117
        ],
        "D1": [
            258879224,
            258887924,
            258886804,
            258889175,
            258886155,
            258888199,
            258887247,
            258892352,
            258882986,
            258888686,
            258890551,
            258888559,
            258871438,
            258899829,
            258888037,
            258891042,
            258898086
        ],
        "C": [
            258877059,
            258881081,
            258882446,
            258885988,
            258877387,
            258876397,
            258878529,
            258880771,
            258878031,
            258885936,
            258887870,
            258877926,
            258892416,
            258887161,
            258883084,
            258878181,
            258887720
        ],
        "B": [
            258867491,
            258869795,
            258867759,
            258890058,
            258867358,
            258869952,
            258866940,
            258871940,
            258871253,
            258870378,
            258871631,
            258870002,
            258877290,
            258868779,
            258871179,
            258886225,
            258878415
        ],
        "A": [
            258864858,
            258865079,
            258865742,
            258864993,
            258865457,
            258865824,
            258864584,
            258865871,
            258870891,
            258866770,
            258865991,
            258864627,
            258872625,
            258865600,
            258867355,
            258871468,
            258864633
        ],
        "F": [
            258956362
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129027",
    "editorial": "If we separately consider each operation, it could be really hard.\n\nThus, binary search on the answer of magics. Greedily, we want a1\n as small as possible, and then a2\n, etc.\n\nEnumerate i\n from 1\n to n\n. Enumerate ai=w\n for w\n from 1\n to m\n. If it is possible for ai=w\n after k\n steps, i?i+1\n; Otherwise, w?w+1\n. If i\n gets to n+1\n first, it's valid. If w\n gets to m+1\n first, it's invalid.\n\nThe last question is how to judge whether vertex u\n is reachable from vertex v\n in k\n steps in O(1)\n time.\n\nBuild a graph with edges i?pi\n. Assume that the graph is a tree, now the condition is equivalent to\n\ndepu?depv?k\n;\nu\n is in the subtree of v\n. We can simply check the DFS order and size: dfnv<dfnu<dfnv+szv\n.\nHowever, the graph contains n\n vertices and n\n edges, so it turns out to be a pseudo forest. One of the processing ways is to cut one edge on the cycle of each pseudo tree. If the path from u\n to v\n doesn't contain the edge, we process the above method. Otherwise, let the cut edge be s?t\n (In fact, s\n is exactly the root of the tree), and we want u?s?t?v\n, so\n\ndeps?depu+depv?dept+1?k\n;\nu\n is in the subtree of s\n, while t\n is in the subtree of v\n.\nIt takes a little time to implement, but be patient and clear-minded, and you are sure to get Accepted.",
    "name": "F. Long Way to be Non-decreasing",
    "statement": "Little R is a magician who likes non-decreasing arrays. She has an array\r\nof length n, initially as a_1,\r\nldots, a_n, in which each element is an integer between [1, m]. She\r\nwants it to be non-decreasing, i.e., a_1\r\nleq a_2\r\nleq\r\nldots\r\nleq a_n.To do this, she can perform several magic tricks. Little R has a\r\nfixed array b_1\r\nldots b_m of length m. Formally, letâ€™s define a trick as a procedure\r\nthat does the following things in order: Choose a set S\r\nsubseteq\r\n{1, 2,\r\nldots, n\r\n}. For each u\r\nin S, assign a_u with b_{a_u}. Little R wonders how many tricks are\r\nneeded at least to make the initial array non-decreasing. If it is not\r\npossible with any amount of tricks, print -1 instead.\r\n",
    "solutions": [
        "#pragma GCC optimize(2)#pragma GCC optimize(3)#pragma GCC optimize(\"Ofast,unroll-loops\")#include<bits/stdc++.h>#include<ext/pb_ds/priority_queue.hpp>using namespace std;typedef long long ll;typedef unsigned long long ull;template <class Miaowu>inline void in(Miaowu &x){    char c;x=0;bool f=0;    for(c=getchar();c<'0'||c>'9';c=getchar())f|=c=='-';    for(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c^48);    x=f?-x:x;}const int N=1e6+5;bool vis[N],instk[N];vector<int>g[N];int T,n,m,cntcir,ind,a[N],b[N],dfn[N],siz[N],de[N],bel[N],len[N],id[N],top,stk[N],rt[N];inline bool calc(int u,int stp,int num){\tint dt=de[u]-de[num];\tif(dt<0||dt>stp)return false;\tif(dfn[num]<=dfn[u]&&dfn[u]<=dfn[num]+siz[num]-1)return true;\tif(!bel[num]||bel[num]!=bel[rt[u]])return false;\tint rst=stp-dt;\tif(id[num]>id[rt[u]])return rst>=id[num]-id[rt[u]];\treturn rst>=len[bel[num]]-id[rt[u]]+id[num];}inline bool check(int x){\tint now=1;\tfor(int i=1;i<=n;i++){\t\twhile(now<=m&&!calc(a[i],x,now))now++;\t\tif(now>m)return false;\t}\treturn true;}inline void findcir(int u){\tstk[++top]=u;\tvis[u]=1,instk[u]=1;\tfor(int v:g[u]){\t\tif(!vis[v])findcir(v);\t\telse if(instk[v]){\t\t\t++cntcir;\t\t\tint all=0;\t\t\tfor(int i=top;;i--){\t\t\t\tbel[stk[i]]=cntcir,all++;\t\t\t\tif(stk[i]==v)break;\t\t\t}\t\t\tlen[cntcir]=all,all=0;\t\t\tfor(int i=top;;i--){\t\t\t\tid[stk[i]]=++all;\t\t\t\tif(stk[i]==v)break;\t\t\t}\t\t}\t}\ttop--,instk[u]=0;}inline void dfs(int u,int fa,int rrt){\trt[u]=rrt,de[u]=de[fa]+1;\tdfn[u]=++ind,siz[u]=1;\tfor(int v:g[u]){\t\tif(!bel[v])dfs(v,u,rrt),siz[u]+=siz[v];\t}}int main(){\tfor(cin>>T;T;T--){\t\tin(n),in(m);\t\tfor(int i=1;i<=n;i++)in(a[i]);\t\tfor(int i=1;i<=m;i++){\t\t\tg[i].clear(),de[i]=len[i]=id[i]=bel[i]=0,vis[i]=0;\t\t\tdfn[i]=siz[i]=rt[i]=0;\t\t}\t\tfor(int i=1;i<=m;i++)in(b[i]),g[b[i]].push_back(i);\t\tcntcir=ind=0;\t\tfor(int i=1;i<=m;i++){\t\t\tif(!vis[i])findcir(i);\t\t}\t\tfor(int i=1;i<=m;i++)\t\t\tif(bel[i])dfs(i,0,i);\t\tint l=0,r=m,res=-1;\t\twhile(l<=r){\t\t\tint mid=l+r>>1;\t\t\tif(check(mid))res=mid,r=mid-1;\t\t\telse l=mid+1;\t\t}\t\tprintf(\"%d\\n\",res);\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "graphs",
        "implementation"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Long Way to be Non-decreasing.json",
    "hint": []
}