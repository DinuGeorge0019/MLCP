{"link": "https://codeforces.com//contest/1004/problem/E", "problemId": "195381", "problem_idx": "E", "shortId": "1004E", "contest_number": "1004", "problem_submissions": {"D": [40003970, 40002114, 40006190, 40065552, 40018246, 40318920, 39996575, 39998916, 39999974, 40000249, 40000299], "E": [40002484, 40005119, 40002116, 39999883, 39999448, 40001703, 40001918, 40001172, 40000650, 40002637, 40008283, 40003263, 40002856, 40003509, 40018331, 40018260, 40018197, 40017976, 40019825], "F": [40001175, 40176983, 40353564, 40007502, 40003848], "C": [39997306, 39993584, 39996423, 39991994, 39992348, 39992627, 39992610, 39994247, 39996536, 39995648, 39993270, 39993344, 39994504, 39995916, 39993496, 39993165, 39993772, 39993747, 39997604], "B": [39994165, 39991785, 39998844, 39994058, 39994368, 39991334, 39991006, 39993012, 39992174, 39992714, 39991428, 39991267, 39992520, 39993434, 39991814, 39991327, 39991886, 39991449, 39996736], "A": [39992007, 39990327, 39997320, 39990328, 39990314, 39990627, 39990358, 39990498, 39990516, 39991224, 39990460, 39990569, 39990938, 39991677, 39990538, 39990378, 39990592, 39990535, 39995891]}, "name": "E. Sonya and Ice Cream", "statement": "Sonya likes ice cream very much. She eats it even during programming\r\ncompetitions. That is why the girl decided that she wants to open her\r\nown ice cream shops.Sonya lives in a city with n junctions and n-1\r\nstreets between them. All streets are two-way and connect two junctions.\r\nIt is possible to travel from any junction to any other using one or\r\nmore streets. City Hall allows opening shops only on junctions. The girl\r\ncannot open shops in the middle of streets. Sonya has exactly k friends\r\nwhom she can trust. If she opens a shop, one of her friends has to work\r\nthere and not to allow anybody to eat an ice cream not paying for it.\r\nSince Sonya does not want to skip an important competition, she will not\r\nwork in shops personally.Sonya wants all her ice cream shops to form a\r\nsimple path of the length r (1\r\nle r\r\nle k), i.e. to be located in different junctions f_1, f_2,\r\ndots, f_r and there is street between f_i and f_{i+1} for each i from 1\r\nto r-1.The girl takes care of potential buyers, so she also wants to\r\nminimize the maximum distance between the junctions to the nearest ice\r\ncream shop. The distance between two junctions a and b is equal to the\r\nsum of all the street lengths that you need to pass to get from the\r\njunction a to the junction b. So Sonya wants to\r\nmax_{a}\r\nmin_{1\r\nle i\r\nle r} d_{a,f_i}where a takes a value of all possible n junctions, f_i\r\nthe junction where the i-th Sonya\u2019s shop is located, and d_{x,y} the\r\ndistance between the junctions x and y.Sonya is not sure that she can\r\nfind the optimal shops locations, that is why she is asking you to help\r\nher to open not more than k shops that will form a simple path and the\r\nmaximum distance between any junction and the nearest shop would be\r\nminimal.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> Edge;\n\n#define MAXN 100001\n#define MAXD 17\n#define INF 0x3f3f3f3f\n\nint n, s, p[MAXN], f[MAXN], tot, que[MAXN], dis[MAXN], pre[MAXN], suf[MAXN], Log[MAXN], st[MAXD][MAXN];\nvector<Edge> e[MAXN];\nbool inq[MAXN];\n\nint rmq(int l, int r) {\n\tif(l > r)\n\t\treturn 0;\n\tint d = Log[r - l + 1];\n\treturn max(st[d][l], st[d][r - (1 << d) + 1]);\n}\n\nvoid dfs(int u, int fa) {\n\tf[u] = 0;\n\tfor(auto it : e[u]) {\n\t\tint v = it.first, w = it.second;\n\t\tif(v == fa || inq[v])\n\t\t\tcontinue;\n\t\tdfs(v, u);\n\t\tif(f[u] < f[v] + w) {\n\t\t\tf[u] = f[v] + w;\n\t\t\tp[u] = v;\n\t\t}\n\t}\n}\n\nint main() {\n\tLog[1] = 0;\n\tfor(int i = 2; i < MAXN; ++i)\n\t\tLog[i] = Log[i >> 1] + 1;\n\tscanf(\"%d%d\", &n, &s);\n\tfor(int i = 1; i < n; ++i) {\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\te[u].push_back(make_pair(v, w));\n\t\te[v].push_back(make_pair(u, w));\n\t}\n\tdfs(1, -1);\n\tfor(que[tot++] = 1; f[que[0]]; que[0] = p[que[0]]);\n\tdfs(que[0], -1);\n\tinq[que[0]] = 1;\n\tdis[0] = f[que[0]];\n\tfor(int u = que[0]; f[u]; u = p[u]) {\n\t\tinq[p[u]] = 1;\n\t\tdis[tot] = f[p[u]];\n\t\tque[tot++] = p[u];\n\t}\n\tfor(int i = 0; i < tot; ++i) {\n\t\tdfs(que[i], -1);\n\t\tpre[i] = suf[i] = st[0][i] = f[que[i]];\n\t}\n\tfor(int i = 1; i < tot; ++i)\n\t\tif(pre[i] < pre[i - 1] + dis[i - 1] - dis[i])\n\t\t\tpre[i] = pre[i - 1] + dis[i - 1] - dis[i];\n\tfor(int i = tot - 2; i >= 0; --i)\n\t\tif(suf[i] < suf[i + 1] + dis[i] - dis[i + 1])\n\t\t\tsuf[i] = suf[i + 1] + dis[i] - dis[i + 1];\n\tfor(int d = 1; d < MAXD; ++d)\n\t\tfor(int i = 0; i < tot && i + (1 << d - 1) < tot; ++i)\n\t\t\tst[d][i] = max(st[d - 1][i], st[d - 1][i + (1 << d - 1)]);\n\tint ans = INF;\n\tfor(int i = 0, j = 0; i < tot; ++i)\n\t\tfor(j = j < i ? i : j; j < tot && j - i + 1 <= s; ++j) {\n\t\t\tint tmp = max(max(pre[i], suf[j]), rmq(i + 1, j - 1));\n\t\t\tif(ans > tmp)\n\t\t\t\tans = tmp;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "dp", "greedy", "shortest paths", "trees"], "dificulty": "2400", "interactive": false}