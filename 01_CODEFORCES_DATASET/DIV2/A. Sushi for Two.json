{
    "link": "https://codeforces.com//contest/1138/problem/A",
    "problemId": "309123",
    "problem_idx": "A",
    "shortId": "1138A",
    "contest_number": "1138",
    "problem_submissions": {
        "F": [
            51023634,
            51022679,
            51020619,
            51116992,
            51021353,
            51023578,
            51058557,
            51025400,
            51024171,
            51210412
        ],
        "D": [
            51010497,
            51010075,
            51011127,
            51013543,
            51016946,
            51013080,
            51010984,
            51018905,
            51015654,
            51021599,
            51016846,
            51011106,
            51012210,
            51010079,
            51014682,
            51012504,
            51012027,
            51012863,
            51011280,
            51013123
        ],
        "C": [
            51009558,
            51007967,
            51009995,
            51010952,
            51015174,
            51011344,
            51014468,
            51017187,
            51013830,
            51019773,
            51013378,
            51012781,
            51010541,
            51011719,
            51010213,
            51010247,
            51010268,
            51010649,
            51012791,
            51010664
        ],
        "B": [
            51008088,
            51018029,
            51007957,
            51203745,
            51017235,
            51013207,
            51009939,
            51015227,
            51016412,
            51016667,
            51019928,
            51008726,
            51015366,
            51011120,
            51014342,
            51015668,
            51014019,
            51015624,
            51013885
        ],
        "A": [
            51005649,
            51019409,
            51005726,
            51203724,
            51006686,
            51010568,
            51006260,
            51011468,
            51005966,
            51005745,
            51006723,
            51007288,
            51005675,
            51005671,
            51006328,
            51008250,
            51006899,
            51005800,
            51005715,
            51005850,
            51006402
        ],
        "E": [
            51015293,
            51019023,
            51203589,
            51203519,
            51023924,
            51025422,
            51204108
        ]
    },
    "name": "A. Sushi for Two",
    "statement": "Arkady invited Anna for a dinner to a sushi restaurant. The restaurant\r\nis a bit unusual: it offers n pieces of sushi aligned in a row, and a\r\ncustomer has to choose a continuous subsegment of these sushi to buy.The\r\npieces of sushi are of two types: either with tuna or with eel. Letâ€™s\r\ndenote the type of the i-th from the left sushi as t_i, where t_i = 1\r\nmeans it is with tuna, and t_i = 2 means it is with eel.Arkady does not\r\nlike tuna, Anna does not like eel. Arkady wants to choose such a\r\ncontinuous subsegment of sushi that it has equal number of sushi of each\r\ntype and each half of the subsegment has only sushi of one type. For\r\nexample, subsegment [2, 2, 2, 1, 1, 1] is valid, but subsegment [1, 2,\r\n1, 2, 1, 2] is not, because both halves contain both types of sushi.Find\r\nthe length of the longest continuous subsegment of sushi Arkady can buy.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000;\nint n, ans, f[maxn + 10], g[maxn + 10], a[maxn + 10];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; ++i) f[i] = a[i] == a[i - 1] ? f[i - 1] + 1 : 1;\n\tfor (int i = n; i >= 1; --i) g[i] = a[i] == a[i + 1] ? g[i + 1] + 1 : 1;\n\tfor (int i = 1; i < n; ++i)\n\t\tif (a[i] != a[i + 1]) ans = max(ans, min(f[i], g[i + 1]) * 2);\n\tprintf(\"%d\", ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "implementation"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Sushi for Two.json",
    "editorial_link": "https://codeforces.com//blog/entry/65825",
    "editorial": "It is more or less obvious that the answer is the maximum among the\r\nminimums of the length of two consecutive segments of equal elements. As\r\nfor implementation, just go from left to right and keep the last\r\nelement, the length of the current segment and the length of the next\r\nsegment. When the current element is not the same as the last element,\r\nupdate the answer.\r\n",
    "hint": []
}