{
    "link": "https://codeforces.com//contest/1990/problem/B",
    "problemId": "2766777",
    "problem_idx": "B",
    "shortId": "1990B",
    "contest_number": "1990",
    "problem_submissions": {
        "E2": [
            271608671,
            271607138,
            271614388,
            271623848,
            271611159,
            271612390,
            271624654,
            271606284,
            271618767,
            271968367,
            271632009,
            271670295,
            271670041,
            271669953,
            271631571,
            271628300,
            271628735,
            271594502,
            271625522,
            271630429,
            271657508,
            271657312,
            271656848,
            271656620,
            271656329,
            271656057,
            271655884,
            271651026,
            271650811,
            271629403,
            271633667
        ],
        "E1": [
            271608290,
            271606824,
            271613580,
            271620803,
            271612480,
            271607245,
            271626074,
            271605565,
            271618674,
            271617329,
            271631880,
            271630922,
            271628223,
            271626847,
            271593184,
            271625989,
            271629147,
            271621610,
            271633499
        ],
        "D": [
            271584964,
            271585839,
            271588228,
            271580018,
            271775642,
            271574070,
            271621395,
            271597835,
            276025328,
            271618139,
            271579386,
            271580161,
            271592306,
            271593113,
            271583094,
            271588957,
            271599530,
            271586840,
            271606900,
            271582390,
            271597556,
            271601916
        ],
        "C": [
            271573202,
            271574801,
            271573394,
            271562726,
            271563640,
            271558919,
            271563245,
            276025316,
            271572711,
            271573247,
            271567920,
            271567517,
            271556748,
            271561905,
            271578677,
            271614383,
            271580098,
            271585887,
            271628007,
            271582340,
            271582612
        ],
        "B": [
            271544838,
            271560423,
            271562782,
            271545814,
            271553448,
            271544083,
            271550614,
            271557693,
            271552078,
            271550946,
            271576591,
            271554451,
            271552855,
            271607828,
            271555492,
            271573754,
            271547063,
            271567926,
            271553335
        ],
        "A": [
            271536644,
            271538330,
            271540486,
            271536626,
            271537675,
            271536719,
            271540682,
            271537637,
            271536282,
            271542554,
            271544093,
            271538945,
            271539444,
            271610786,
            271544740,
            271545994,
            271537196,
            271539275,
            271540687
        ],
        "F": [
            271738112,
            271736701,
            271736437,
            271736279,
            271732364,
            271623141
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131716",
    "editorial": "First, we consider making presumx>presumj\n for all x<i?n\n, and similarly for y\n. We can think of a trivial construction: a[r,\u0085,l]=[1,\u0085,1],a[1,\u0085...,r?1]=[?1,\u0085,?1]\n and a[l+1,\u0085,n]=[?1,\u0085,?1]\n.\n\nThe construction doesn't works when presumx<0\n, but we are close to the correct solution. Next, we will make a little adjustment: a[r,\u0085,l]=[1,\u0085,1],a[1,\u0085...,r?1]=[\u0085,1,?1]\n and a[l+1,\u0085,n]=[?1,1,\u0085]\n.\n\nIt is not hard to see presumx?presumj\n for all x<i?n\n, and for 1?i?y\n, max(presumi)?min(presumi)?1\n. Thus, we get presumx?2+presumy?1?2+min(presumi)?1+max(presumi)\n. The same applies to the suffix sum as well. Therefore, this construction is valid.",
    "name": "B. Array Craft",
    "statement": "For an array b of size m, we define: the of b is the index i that\r\nsatisfies b_1+\r\nldots+b_i=\r\nmax_{j=1}^{m}(b_1+\r\nldots+b_j); the of b is the index i that satisfies b_i+\r\nldots+b_m=\r\nmax_{j=1}^{m}(b_j+\r\nldots+b_m).You are given three integers n, x, and y (x > y). Construct\r\nan array a of size n satisfying: a_i is either 1 or -1 for all 1\r\nle i\r\nle n; the of a is x; the of a is y.If there are multiple arrays that\r\nmeet the conditions, print any. It can be proven that such an array\r\nalways exists under the given conditions.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0using ll = long long;// #define int ll\u00a0#define endl '\\n'#define pb push_backusing pi = array<int, 2>;\u00a0void skibidi_sigma() {  int n, x, y;  cin >> n >> x >> y;  --x; --y;    vector<int> a(n);  for (int i = y; i < n; ++i) {    a[i] = 1;  }  for (int i = y - 1; i >= 0; --i) {    a[i] = (a[i + 1] == 1 ? -1 : 1);  }  for (int i = x + 1; i < n; ++i) {    a[i] = (a[i - 1] == 1 ? -1 : 1);  }    for (int i = 0; i < n; ++i) {    cout << a[i] << \" \";  }}\u00a0int32_t main() {  ios_base::sync_with_stdio(false);  cin.tie(NULL);    int T;  cin >> T;    while (T--) {    skibidi_sigma();    cout << endl;  }}\u00a0/*\u00a0*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Array Craft.json"
}