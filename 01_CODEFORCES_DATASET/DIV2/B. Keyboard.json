{"link": "https://codeforces.com//contest/88/problem/B", "problemId": "463", "problem_idx": "B", "shortId": "88B", "contest_number": "88", "problem_submissions": {"C": [479214, 477433, 478480, 479134, 478757, 479137, 478197, 479335, 478450, 478394, 479058, 479099, 479046, 479022, 479366, 479334], "E": [478957, 479559, 480051, 480963, 480059, 480346], "D": [478514, 480342, 480973, 480128, 481356, 478837, 479383, 479878, 480300, 479915, 479925, 479918, 479873, 479951, 480276, 480590], "B": [477549, 478068, 479072, 478755, 478307, 477476, 477775, 478506, 478046, 478017, 478075, 478148, 478475, 478281, 478490, 478605], "A": [477248, 478721, 477778, 478222, 477506, 477190, 477214, 477921, 477275, 477376, 477294, 477359, 477333, 477383, 477417, 477451, 477678]}, "name": "B. Keyboard", "statement": "Vasya learns to type. He has an unusual keyboard at his disposal: it is\r\nrectangular and it has rows of keys containing keys in each row.\r\nBesides, the keys are of two types. Some of the keys have lowercase\r\nLatin letters on them and some of the keys work like the \"Shift\" key on\r\nstandard keyboards, that is, they make lowercase letters uppercase.Vasya\r\ncan press one or two keys with one hand. However, he can only press two\r\nkeys if the Euclidean distance between the centers of the keys does not\r\nexceed . The keys are considered as squares with a side equal to 1.\r\nThere are no empty spaces between neighbouring keys.Vasya is a very lazy\r\nboy, that\u2019s why he tries to type with one hand as he eats chips with his\r\nother one. However, it is possible that some symbol can\u2019t be typed with\r\none hand only, because the distance between it and the closest \"Shift\"\r\nkey is strictly larger than . In this case he will have to use his other\r\nhand. Having typed the symbol, Vasya returns other hand back to the\r\nchips.You are given Vasya\u2019s keyboard and the text. Count the minimum\r\nnumber of times Vasya will have to use the other hand.\r\n", "solutions": ["#include<stdio.h>\n#include<string.h>\nint can[30],canb[30];\nchar in[33][33];\nchar tmp[500010];\nint main(){\n    int n,m,i,j,k,l;\n    int x;\n    scanf(\"%d%d%d\",&n,&m,&x);\n    for(i=0;i<n;i++)scanf(\"%s\",in[i]);\n    bool hass=0;\n    for(i=0;i<n;i++){\n\tfor(j=0;j<m;j++){\n\t    if(in[i][j]=='S'){\n\t\thass=1;\n\t\tfor(k=0;k<n;k++){\n\t\t    for(l=0;l<m;l++){\n\t\t\tif((k-i)*(k-i)+(l-j)*(l-j)<=x*x&&in[k][l]!='S'){\n\t\t\t    canb[in[k][l]-'a']=1;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }else{\n\t\tcan[in[i][j]-'a']=1;\n\t    }\n\t}\n    }\n    int q;\n    scanf(\"%d%s\",&q,tmp);\n    int ans=0;\n    for(i=0;i<q;i++){\n\tif(tmp[i]>='A'&&tmp[i]<='Z'){\n\t    if(!hass)break;\n\t    if(canb[tmp[i]-'A']){\n\t    }else if(can[tmp[i]-'A']){\n\t\tans++;\n\t    }else break;\n\t}else{\n\t    if(can[tmp[i]-'a']){\n\t    }else break;\n\t}\n    }\n    if(i<q)puts(\"-1\");\n    else printf(\"%d\\n\",ans);\n}\n"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "1500", "interactive": false}