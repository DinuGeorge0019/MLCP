{"link": "https://codeforces.com//contest/322/problem/E", "problemId": "3272", "problem_idx": "E", "shortId": "322E", "contest_number": "322", "problem_submissions": {"A": [3981623, 3973095, 3973865, 3973090, 3972819, 3972791, 3973637, 3972934, 3972906, 3972918, 3973641, 3972985, 3973091, 3972935, 3972929, 3973182, 3972893], "B": [3981333, 3975842, 3976873, 3974714, 3975747, 3973669, 3974548, 3974146, 3977509, 3974324, 3974761, 3974551, 3974557, 3976086, 3974559, 3974642], "C": [3980891, 3983597, 3976039, 3978515, 3978858, 3978735, 3977369, 3982226, 3976048, 3983804, 3979009, 3978590, 3980069, 3985116, 3977870, 3978375, 3975800], "D": [3978233, 3979300, 3979714, 3982078, 3981365, 3983063, 3981155, 3982692, 3980839, 3983851, 3983012, 3984085, 3984750, 3982466], "E": [3976453, 3981756, 3983016, 3990331, 3980078]}, "name": "E. Ciel the Commander", "statement": "Now Fox Ciel becomes a commander of Tree Land. Tree Land, like its name\r\nsaid, has cities connected by undirected roads, and for any two cities\r\nthere always exists a path between them.Fox Ciel needs to assign an\r\nofficer to each city. Each officer has a rank a letter from \u201d to \u201d. So\r\nthere will be 26 different ranks, and \u201d is the topmost, so \u201d is the\r\nbottommost.There are enough officers of each rank. But there is a\r\nspecial rule must obey: if and are two distinct cities and their\r\nofficers have the same rank, then on the simple path between and there\r\nmust be a city that has an officer with higher rank. The rule guarantee\r\nthat a communications between same rank officers will be monitored by\r\nhigher rank officer.Help Ciel to make a valid plan, and if it\u2019s\r\nimpossible, output \"\".\r\n", "solutions": ["#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\n#define inf 1023456789\n#define linf 1023456789123456789ll\n#define pii pair<int,int>\n#define pipii pair<int, pii >\n#define pll pair<long long,long long>\n#define vint vector<int>\n#define vvint vector<vector<int> >\n\n#define DEBUG\n#ifdef DEBUG\n#define db(x) cerr << #x << \" = \" << x << endl\n#else\n#define db(x)\n#endif\n\nvvint sus;\nvint otec, subtree;\nvvint syn;\nvector<char> hodnost;\n\nint dfs(int node)\n{\n\tfor(int i=0; i<sus[node].size(); i++)\n\t{\n\t\tint on = sus[node][i];\n\t\tif(on == otec[node])continue;\n\t\totec[on] = node;\n\t\tsyn[node].push_back(on);\n\t\tsubtree[node] += dfs(on);\n\t}\n\treturn subtree[node];\n}\n\nvoid solve(int node, char hodn)\n{\n\tint siz = subtree[node];\n\tint cur = node;\n\twhile(1)\n\t{\n\t\tint ex = -1, worst = -1;\n\t\tfor(int i=0; i<syn[cur].size(); i++)\n\t\t{\n\t\t\tif(subtree[syn[cur][i]] > ex)\n\t\t\t{\n\t\t\t\tex = subtree[syn[cur][i]];\n\t\t\t\tworst = syn[cur][i];\n\t\t\t}\n\t\t}\n\t\tif(ex > siz/2)cur = worst;\n\t\telse break;\n\t}\n\thodnost[cur] = hodn;\n\thodn++;\n\tif(cur != node)\n\t{\n\t\tint ot = otec[cur];\n\t\tfor(int i=0; i<syn[ot].size(); i++)\n\t\t{\n\t\t\tif(syn[ot][i] == cur)\n\t\t\t{\n\t\t\t\tswap(syn[ot][i], syn[ot][syn[ot].size()-1]);\n\t\t\t\tsyn[ot].pop_back();\n\t\t\t}\n\t\t}\n\t\totec[cur] = -1;\n\t\tfor(int i=ot; i!=-1; i=otec[i])subtree[i] -= subtree[cur];\n\t\tsolve(node, hodn);\n\t}\n\tfor(int i=0; i<syn[cur].size(); i++)\n\t{\n\t\tint on = syn[cur][i];\n\t\totec[on] = -1;\n\t\tsolve(on, hodn);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tsus.resize(n);\n\t\n\tfor(int i=0; i<n-1; i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tsus[a].push_back(b);\n\t\tsus[b].push_back(a);\n\t}\n\t\n\totec.resize(n, -1);\n\tsubtree.resize(n, 1);\n\thodnost.resize(n);\n\tsyn.resize(n);\n\tdfs(0);\n\t\n\tsolve(0, 'A');\n\t\n\tprintf(\"%c\",hodnost[0]);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tprintf(\" %c\",hodnost[i]);\n\t}\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["divide and conquer"], "dificulty": "2100", "interactive": false}