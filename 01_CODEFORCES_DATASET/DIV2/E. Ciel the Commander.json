{
    "link": "https://codeforces.com//contest/322/problem/E",
    "problemId": "3272",
    "problem_idx": "E",
    "shortId": "322E",
    "contest_number": "322",
    "problem_submissions": {
        "A": [
            3981623,
            3973095,
            3973865,
            3973090,
            3972819,
            3972791,
            3973637,
            3972934,
            3972906,
            3972918,
            3973641,
            3972985,
            3973091,
            3972935,
            3972929,
            3973182,
            3972893
        ],
        "B": [
            3981333,
            3975842,
            3976873,
            3974714,
            3975747,
            3973669,
            3974548,
            3974146,
            3977509,
            3974324,
            3974761,
            3974551,
            3974557,
            3976086,
            3974559,
            3974642
        ],
        "C": [
            3980891,
            3983597,
            3976039,
            3978515,
            3978858,
            3978735,
            3977369,
            3982226,
            3976048,
            3983804,
            3979009,
            3978590,
            3980069,
            3985116,
            3977870,
            3978375,
            3975800
        ],
        "D": [
            3978233,
            3979300,
            3979714,
            3982078,
            3981365,
            3983063,
            3981155,
            3982692,
            3980839,
            3983851,
            3983012,
            3984085,
            3984750,
            3982466
        ],
        "E": [
            3976453,
            3981756,
            3983016,
            3990331,
            3980078
        ]
    },
    "name": "E. Ciel the Commander",
    "statement": "Now Fox Ciel becomes a commander of Tree Land. Tree Land, like its name\r\nsaid, has cities connected by undirected roads, and for any two cities\r\nthere always exists a path between them.Fox Ciel needs to assign an\r\nofficer to each city. Each officer has a rank a letter from \u201d to \u201d. So\r\nthere will be 26 different ranks, and \u201d is the topmost, so \u201d is the\r\nbottommost.There are enough officers of each rank. But there is a\r\nspecial rule must obey: if and are two distinct cities and their\r\nofficers have the same rank, then on the simple path between and there\r\nmust be a city that has an officer with higher rank. The rule guarantee\r\nthat a communications between same rank officers will be monitored by\r\nhigher rank officer.Help Ciel to make a valid plan, and if it\u2019s\r\nimpossible, output \"\".\r\n",
    "solutions": [
        "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\n#define inf 1023456789\n#define linf 1023456789123456789ll\n#define pii pair<int,int>\n#define pipii pair<int, pii >\n#define pll pair<long long,long long>\n#define vint vector<int>\n#define vvint vector<vector<int> >\n\n#define DEBUG\n#ifdef DEBUG\n#define db(x) cerr << #x << \" = \" << x << endl\n#else\n#define db(x)\n#endif\n\nvvint sus;\nvint otec, subtree;\nvvint syn;\nvector<char> hodnost;\n\nint dfs(int node)\n{\n\tfor(int i=0; i<sus[node].size(); i++)\n\t{\n\t\tint on = sus[node][i];\n\t\tif(on == otec[node])continue;\n\t\totec[on] = node;\n\t\tsyn[node].push_back(on);\n\t\tsubtree[node] += dfs(on);\n\t}\n\treturn subtree[node];\n}\n\nvoid solve(int node, char hodn)\n{\n\tint siz = subtree[node];\n\tint cur = node;\n\twhile(1)\n\t{\n\t\tint ex = -1, worst = -1;\n\t\tfor(int i=0; i<syn[cur].size(); i++)\n\t\t{\n\t\t\tif(subtree[syn[cur][i]] > ex)\n\t\t\t{\n\t\t\t\tex = subtree[syn[cur][i]];\n\t\t\t\tworst = syn[cur][i];\n\t\t\t}\n\t\t}\n\t\tif(ex > siz/2)cur = worst;\n\t\telse break;\n\t}\n\thodnost[cur] = hodn;\n\thodn++;\n\tif(cur != node)\n\t{\n\t\tint ot = otec[cur];\n\t\tfor(int i=0; i<syn[ot].size(); i++)\n\t\t{\n\t\t\tif(syn[ot][i] == cur)\n\t\t\t{\n\t\t\t\tswap(syn[ot][i], syn[ot][syn[ot].size()-1]);\n\t\t\t\tsyn[ot].pop_back();\n\t\t\t}\n\t\t}\n\t\totec[cur] = -1;\n\t\tfor(int i=ot; i!=-1; i=otec[i])subtree[i] -= subtree[cur];\n\t\tsolve(node, hodn);\n\t}\n\tfor(int i=0; i<syn[cur].size(); i++)\n\t{\n\t\tint on = syn[cur][i];\n\t\totec[on] = -1;\n\t\tsolve(on, hodn);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tsus.resize(n);\n\t\n\tfor(int i=0; i<n-1; i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tsus[a].push_back(b);\n\t\tsus[b].push_back(a);\n\t}\n\t\n\totec.resize(n, -1);\n\tsubtree.resize(n, 1);\n\thodnost.resize(n);\n\tsyn.resize(n);\n\tdfs(0);\n\t\n\tsolve(0, 'A');\n\t\n\tprintf(\"%c\",hodnost[0]);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tprintf(\" %c\",hodnost[i]);\n\t}\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Ciel the Commander.json",
    "editorial_link": "https://codeforces.com//blog/entry/8192",
    "editorial": "This is a problem with construction on trees. And for these kind of\r\nproblems, we usually use two method: up-down or down-up. So we have 1\r\nsolution for each method: = 1. up-down construction = Suppose we assign\r\nan officer with rank A at node x. Then for two distinct subtree rooted\r\nby x, says T1 and T2: There can\u00e2\u0080\u0099t be any invalid path cross T1 and T2,\r\nbecause it is blocked by node x. (It\u00e2\u0080\u0099s clear that we can\u00e2\u0080\u0099t make 2 rank A\r\nofficer.) So we can solve these subtree independently: the only\r\ndifferent is that we can\u00e2\u0080\u0099t use rank A anymore. Then the question is:\r\nwhich node should x be? It could be good if any subtree will has a small\r\nsize. And if you have the knowledge of \"centroid of tree\", then you can\r\nquickly find that if x be the centroid of this tree, the subtree\u00e2\u0080\u0099s size\r\nwill be no more than half of the original tree. So we only needs about\r\nlog2(n) nodes and 26 is enough. = 2. down-up construction = The above\r\nsolution involves the concept of \"centroid of tree\" but you might not\r\nheard about that, don\u00e2\u0080\u0099t worry, we have another solution can solve this\r\nproblem without knowing that, and it\u00e2\u0080\u0099s easier to implement. Suppose we\r\nchoose 1 as the root and consider it as a directed tree, and on some day\r\nwe have the following problem: We have some subtree rooted at T1, T2,\r\n..., Tk, and they are already assigned an officer, we need to assign an\r\nofficer to node x and link them to this node. Well, a normal idea is: we\r\nchoose one with lowest possible rank. The rank of x should satisfy: So\r\nwe can use this rule to choose the lowest possible rank. But can it\r\npasses? Yes, it can, but the proof is not such easy, I\u00e2\u0080\u0099ll introduce the\r\nmain idea here:\r\n"
}