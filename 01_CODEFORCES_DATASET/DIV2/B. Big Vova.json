{
    "link": "https://codeforces.com//contest/1407/problem/B",
    "problemId": "718472",
    "problem_idx": "B",
    "shortId": "1407B",
    "contest_number": "1407",
    "problem_submissions": {
        "D": [
            92297631,
            92239112,
            92260381,
            92252806,
            92252049,
            92262520,
            92228234,
            92259211,
            92260360,
            92261376,
            92261918,
            92266899,
            92256587,
            92266172,
            92260274,
            92262912,
            92303878,
            92302623,
            92256275,
            92270984,
            92272252,
            92271510,
            92282349
        ],
        "E": [
            92256636,
            92233407,
            92267510,
            92279480,
            92272807,
            92274460,
            92269480,
            92269259,
            92273514,
            92279715,
            92278350,
            92279867,
            92282565,
            92283409,
            92274020,
            92304060,
            92282786,
            92228831,
            92283331,
            92283427,
            92278831
        ],
        "C": [
            92232599,
            92248324,
            92233479,
            92234268,
            92236468,
            92249353,
            92246953,
            92244705,
            92238987,
            92236719,
            92240957,
            92237611,
            92237282,
            92240234,
            92248416,
            92302688,
            92246152,
            92275036,
            92246613,
            92261035,
            92227354
        ],
        "B": [
            92224272,
            92243377,
            92224493,
            92224273,
            92227246,
            92253319,
            92237934,
            92228855,
            92225988,
            92227692,
            92222986,
            92232613,
            92224373,
            92228873,
            92234801,
            92303526,
            92302715,
            92233774,
            92277941,
            92232453,
            92246726,
            92238191
        ],
        "A": [
            92221741,
            92238499,
            92221489,
            92220356,
            92223704,
            92240968,
            92227717,
            92262213,
            92222693,
            92221930,
            92220180,
            92226337,
            92220737,
            92223399,
            92226099,
            92303272,
            92302746,
            92224681,
            92281196,
            92221648,
            92239991,
            92220826
        ]
    },
    "name": "B. Big Vova",
    "statement": "Alexander is a well-known programmer. Today he decided to finally go out\r\nand play football, but with the first hit he left a dent on the new\r\nRolls-Royce of the wealthy businessman Big Vova. Vladimir has recently\r\nopened a store on the popular online marketplace \"Zmey-Gorynych\", and\r\noffers Alex a job: if he shows his programming skills by solving a task,\r\nhe\u2019ll work as a cybersecurity specialist. Otherwise, he\u2019ll be delivering\r\nsome doubtful products for the next two years.You\u2019re given n positive\r\nintegers a_1, a_2,\r\ndots, a_n. Using each of them , you\u2019re to make such sequence b_1, b_2,\r\ndots, b_n that sequence c_1, c_2,\r\ndots, c_n is , where c_i=GCD(b_1,\r\ndots,b_i) - the greatest common divisor of the first i elements of b.\r\nAlexander is really afraid of the conditions of this simple task, so he\r\nasks you to solve it.A sequence a is lexicographically smaller than a\r\nsequence b if and only if one of the following holds: a is a prefix of\r\nb, but a\r\nne b; in the first position where a and b differ, the sequence a has a\r\nsmaller element than the corresponding element in b.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\n\nint n, te, a[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> te;\n    while (te--) {\n        cin >> n;\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        int cur = 0;\n        for (int i = 1; i <= n; i++) {\n            pair<int, int> mx = {0, 0};\n            for (int j = 1; j <= n; j++) {\n                if (a[j] != -1) {\n                    mx = max(mx, {__gcd(cur, a[j]), j});\n                }\n            }\n            int ind = mx.second;\n            cur = mx.first;\n            cout << a[ind] << \" \\n\"[i == n];\n            a[ind] = -1;\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Big Vova.json",
    "editorial_link": "https://codeforces.com//blog/entry/82417",
    "editorial": "We\u00e2\u0080\u0099ll describe several constructive solutions for this task, differing\r\nby the time complexity:1. Let be an empty sequence in the beginning.\r\nWe\u00e2\u0080\u0099ll consequently transfer elements from to in a certain order.Let\u00e2\u0080\u0099s\r\nnotice that if we\u00e2\u0080\u0099ve already transfered elements then we can choose to\r\nthe place of any element left in such that is maximal. A-priory, if\r\nwe\u00e2\u0080\u0099ve fixed the first elements of the sequence, lexicographically\r\ngreater would be the one in which is maximal. The particular value of\r\nhere doesn\u00e2\u0080\u0099t matter: each element divides all the previous ones, so for\r\nany .So the algorithm is following: let\u00e2\u0080\u0099s say that we have auxiliary\r\nelement of the sequence , and for any integer . Then we make iterations:\r\nduring the -th one we choose such (overall elements left in ) that the\r\nvalue of is maximal, and make , removing from the sequence . The -th\r\niteration will be passed in , where is the greatest possible value in\r\nthe original sequence, is the time complexity of the Euclidean algorithm\r\nfor searching . Via summing time complexities overall iterations we get\r\nsummary time complexity of the algorithm.2. The main idea is the same as\r\nin the first solution, but the realisation is different: the main array\r\nis contained as an array of size , where is the amount of elements in\r\nthat are equal to . Searching for the optimal element is for each of\r\niterations, so the summary is .3. This solution is based on the\r\nfollowing idea: for each either or . That means any possible sequence\r\ncontains different values.So we do iterations, on each we find the value\r\namong the elements left in that maximizes (where is the amount of\r\nelements already transfered to , and ) and transfer all the elements\r\nleft in of the value equal to to the end of . Each iteration is done in\r\nso the total time complexity is .\r\n"
}