{"link": "https://codeforces.com//contest/1206/problem/F", "problemId": "390608", "problem_idx": "F", "shortId": "1206F", "contest_number": "1206", "problem_submissions": {"E": [59039805, 59036400, 59045379, 59047524, 59061157, 59038336, 59098032], "D": [59025954, 59041661, 59045740, 59034406, 59022167, 59028235, 59026731, 59020676, 59024989, 59028222, 59026919, 59119609, 59027379, 59028274, 59026956, 59027397, 59024272, 59026921, 59027483, 59030980], "C": [59011466, 59030604, 59014696, 59020664, 59011212, 59015302, 59007726, 59013014, 59014421, 59011545, 59013350, 59012812, 59015649, 59015519, 59018230, 59019306, 59015315, 59013410, 59013599, 59015972], "B": [59004708, 59042916, 59007475, 59009856, 59005675, 59005365, 59003891, 59005761, 59008869, 59005044, 59005517, 59007045, 59004938, 59005819, 59066728, 59009485, 59006550, 59008990, 59005654, 59005940, 59006088], "A": [59001296, 59043245, 59001405, 59010625, 59001679, 59001121, 59001149, 59003026, 59003048, 59001270, 59001447, 59001759, 59001966, 59002120, 59066711, 59002946, 59001221, 59005963, 59002062, 59004823, 59001151], "F": [59027482, 59114990, 59100319]}, "name": "F. Almost All", "statement": "You are given a tree with n nodes. You have to write non-negative\r\nintegers on its edges so that the following condition would be\r\nsatisfied:For every two nodes i, j, look at the path between them and\r\ncount the sum of numbers on the edges of this path. Write all obtained\r\nsums on the blackboard. Then every integer from 1 to\r\nlfloor\r\nfrac{2n^2}{9}\r\nrfloor has to be written on the blackboard at least once. It is\r\nguaranteed that such an arrangement exists.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <vector>\n#define all(x) x.begin() , x.end()\n#define fi first\n#define se second\n#define pb push_back\n#define umax( x , y ) x = max( x , (y) )\n#define umin( x , y ) x = min( x , (y) )\n#define For( i , a ) for(int i=1;i<=a;i++)\n#define ort (b+s)/2\n#define y2 asrwjaelkf\n#define y1 asseopirwjaelkf\n#define set multiset\n\nusing namespace std;\n\ntypedef long long Lint;\ntypedef double db;\ntypedef pair<int,int> ii;\ntypedef pair<int,char> ic;\ntypedef pair<db,db> dd;\ntypedef pair<ii,int> iii;\ntypedef pair<ii,ii> i4;\n\nconst int maxn = 2000020;\nconst int maxm = 1000020;\nconst int MOd = 1e9 + 7;\n\nint a, X;\nvector<ii> w[maxn];\nint dad[maxn], ar[maxn];\n\nint  dfs( int n, int back ) {\n\tint ret = 1;\n\tfor(int i=0;i<w[n].size();i++) if( w[n][i].fi != back ) ret += w[n][i].se = dfs( w[n][i].fi, n );\n\tfor(int i=0;i<w[n].size();i++) if( w[n][i].fi == back ) w[n][i].se = a - ret;\n\treturn ret;\n}\n\nbool comp( const ii &a, const ii &b ) {\n\treturn a.se > b.se;\n}\n\nint big = 0, sm = 0, B;\n\nvoid go( int n, int back, bool small ) {\n\t//printf(\"hmm %d %d\\n\",n,back);\n\tdad[n] = back;\n\tif( small ) {\n\t\tsm++;\n\t\tar[n] = sm;\n\t\tprintf(\"%d %d %d\\n\",back,n,ar[n]-ar[back]);\n\t} else {\n\t\tbig += B;\n\t\tar[n] = big;\n\t\tprintf(\"%d %d %d\\n\",back,n,ar[n]-ar[back]);\n\t}\n\tfor(int i=0;i<w[n].size();i++)\n\t\tif( w[n][i].fi != back ) go( w[n][i].fi, n, small );\n}\n\nbool tr( int n ) {\n\tsort( all( w[n] ) );\n\tint f=1, s=0;\n\tvector<int> v( w[n].size(), 0 );\n\tfor(int i=0;i<w[n].size();i++) {\n\t\tif( f <= s ) {\n\t\t\tv[i] = 1;\n\t\t\tf += w[n][i].se;\n\t\t} else {\n\t\t\ts += w[n][i].se;\n\t\t}\n\t}\n\t//printf(\"asdasd %d\\n\",f*(s+1)-1);\n\tif( f*(s+1)-1 < X ) return false;\n\tar[n] = 0;\n\tB = f;\n\t//printf(\"asd %d %d\\n\",(int)w[n].size(),(int)v.size());\n\tfor(int i=0;i<v.size();i++)\n\t\tif( v[i] ) {\n\t\t\tgo( w[n][i].fi, n, 1 );\n\t\t} else {\n\t\t\tgo( w[n][i].fi, n, 0 );\n\t\t}\n\tassert( sm == B-1 );\n\t//printf(\"WOW %d\\n\",n);\n\treturn true;\n}\n\nint main() {\n\n    //freopen(\"asd.in\",\"r\",stdin);\n    //freopen(\"output17.txt\",\"w\",stdout);\n    scanf(\"%d\",&a);\n    X = 2*a*a/9;\n\n    for(int i=1,j,k;i<a;i++) {\n    \tscanf(\"%d %d\",&j,&k);\n    \tw[j].pb( ii( k, 0 ) );\n    \tw[k].pb( ii( j, 0 ) );\n    }\n\n    dfs( 1, 0 );\n\n    for(int i=1;i<=a;i++) {\n    \tif( tr( i ) ) {\n    \t\treturn 0;\n    \t}\n    }\n    assert(0);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "trees"], "dificulty": "2700", "interactive": false}