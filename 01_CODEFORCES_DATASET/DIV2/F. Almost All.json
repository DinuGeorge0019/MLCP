{
    "link": "https://codeforces.com//contest/1206/problem/F",
    "problemId": "390608",
    "problem_idx": "F",
    "shortId": "1206F",
    "contest_number": "1206",
    "problem_submissions": {
        "E": [
            59039805,
            59036400,
            59045379,
            59047524,
            59061157,
            59038336,
            59098032
        ],
        "D": [
            59025954,
            59041661,
            59045740,
            59034406,
            59022167,
            59028235,
            59026731,
            59020676,
            59024989,
            59028222,
            59026919,
            59119609,
            59027379,
            59028274,
            59026956,
            59027397,
            59024272,
            59026921,
            59027483,
            59030980
        ],
        "C": [
            59011466,
            59030604,
            59014696,
            59020664,
            59011212,
            59015302,
            59007726,
            59013014,
            59014421,
            59011545,
            59013350,
            59012812,
            59015649,
            59015519,
            59018230,
            59019306,
            59015315,
            59013410,
            59013599,
            59015972
        ],
        "B": [
            59004708,
            59042916,
            59007475,
            59009856,
            59005675,
            59005365,
            59003891,
            59005761,
            59008869,
            59005044,
            59005517,
            59007045,
            59004938,
            59005819,
            59066728,
            59009485,
            59006550,
            59008990,
            59005654,
            59005940,
            59006088
        ],
        "A": [
            59001296,
            59043245,
            59001405,
            59010625,
            59001679,
            59001121,
            59001149,
            59003026,
            59003048,
            59001270,
            59001447,
            59001759,
            59001966,
            59002120,
            59066711,
            59002946,
            59001221,
            59005963,
            59002062,
            59004823,
            59001151
        ],
        "F": [
            59027482,
            59114990,
            59100319
        ]
    },
    "name": "F. Almost All",
    "statement": "You are given a tree with n nodes. You have to write non-negative\r\nintegers on its edges so that the following condition would be\r\nsatisfied:For every two nodes i, j, look at the path between them and\r\ncount the sum of numbers on the edges of this path. Write all obtained\r\nsums on the blackboard. Then every integer from 1 to\r\nlfloor\r\nfrac{2n^2}{9}\r\nrfloor has to be written on the blackboard at least once. It is\r\nguaranteed that such an arrangement exists.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <vector>\n#define all(x) x.begin() , x.end()\n#define fi first\n#define se second\n#define pb push_back\n#define umax( x , y ) x = max( x , (y) )\n#define umin( x , y ) x = min( x , (y) )\n#define For( i , a ) for(int i=1;i<=a;i++)\n#define ort (b+s)/2\n#define y2 asrwjaelkf\n#define y1 asseopirwjaelkf\n#define set multiset\n\nusing namespace std;\n\ntypedef long long Lint;\ntypedef double db;\ntypedef pair<int,int> ii;\ntypedef pair<int,char> ic;\ntypedef pair<db,db> dd;\ntypedef pair<ii,int> iii;\ntypedef pair<ii,ii> i4;\n\nconst int maxn = 2000020;\nconst int maxm = 1000020;\nconst int MOd = 1e9 + 7;\n\nint a, X;\nvector<ii> w[maxn];\nint dad[maxn], ar[maxn];\n\nint  dfs( int n, int back ) {\n\tint ret = 1;\n\tfor(int i=0;i<w[n].size();i++) if( w[n][i].fi != back ) ret += w[n][i].se = dfs( w[n][i].fi, n );\n\tfor(int i=0;i<w[n].size();i++) if( w[n][i].fi == back ) w[n][i].se = a - ret;\n\treturn ret;\n}\n\nbool comp( const ii &a, const ii &b ) {\n\treturn a.se > b.se;\n}\n\nint big = 0, sm = 0, B;\n\nvoid go( int n, int back, bool small ) {\n\t//printf(\"hmm %d %d\\n\",n,back);\n\tdad[n] = back;\n\tif( small ) {\n\t\tsm++;\n\t\tar[n] = sm;\n\t\tprintf(\"%d %d %d\\n\",back,n,ar[n]-ar[back]);\n\t} else {\n\t\tbig += B;\n\t\tar[n] = big;\n\t\tprintf(\"%d %d %d\\n\",back,n,ar[n]-ar[back]);\n\t}\n\tfor(int i=0;i<w[n].size();i++)\n\t\tif( w[n][i].fi != back ) go( w[n][i].fi, n, small );\n}\n\nbool tr( int n ) {\n\tsort( all( w[n] ) );\n\tint f=1, s=0;\n\tvector<int> v( w[n].size(), 0 );\n\tfor(int i=0;i<w[n].size();i++) {\n\t\tif( f <= s ) {\n\t\t\tv[i] = 1;\n\t\t\tf += w[n][i].se;\n\t\t} else {\n\t\t\ts += w[n][i].se;\n\t\t}\n\t}\n\t//printf(\"asdasd %d\\n\",f*(s+1)-1);\n\tif( f*(s+1)-1 < X ) return false;\n\tar[n] = 0;\n\tB = f;\n\t//printf(\"asd %d %d\\n\",(int)w[n].size(),(int)v.size());\n\tfor(int i=0;i<v.size();i++)\n\t\tif( v[i] ) {\n\t\t\tgo( w[n][i].fi, n, 1 );\n\t\t} else {\n\t\t\tgo( w[n][i].fi, n, 0 );\n\t\t}\n\tassert( sm == B-1 );\n\t//printf(\"WOW %d\\n\",n);\n\treturn true;\n}\n\nint main() {\n\n    //freopen(\"asd.in\",\"r\",stdin);\n    //freopen(\"output17.txt\",\"w\",stdout);\n    scanf(\"%d\",&a);\n    X = 2*a*a/9;\n\n    for(int i=1,j,k;i<a;i++) {\n    \tscanf(\"%d %d\",&j,&k);\n    \tw[j].pb( ii( k, 0 ) );\n    \tw[k].pb( ii( j, 0 ) );\n    }\n\n    dfs( 1, 0 );\n\n    for(int i=1;i<=a;i++) {\n    \tif( tr( i ) ) {\n    \t\treturn 0;\n    \t}\n    }\n    assert(0);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Almost All.json",
    "editorial_link": "https://codeforces.com//blog/entry/69158",
    "editorial": "First we prove the following lemma:\n\nSuppose that there are n\n vertices in the tree G\n with the root v\n. Let also 0<a1<a2?<an?1\n be any n?1\n different positive numbers. Then we can arrange non-negative integers on the edges of G\n so that the distances from v\n to the remaining vertices of the tree are a1,a2,,an?1\n in some order.\n\nProof: for example, by induction. Let s\n be some child of v\n in whose subtree, including s\n, there are m\n vertices. Then we write on the edge between (v,s)\n a1\n, and solve the problem for the subtree s\n and the numbers a2?a1,a3?a1,,am?a1\n. After that, we discard the subtree of s\n from consideration and fill in the remaining edges for the numbers am+1,,an?1\n.\n\nThus, the lemma is proved.\n\nNow let c\n be the centroid of tree. Root the tree from c\n and let s1,s2,,sk\n be the sizes of the subtrees of his childs (as we know, si?n2\n). Divide the subtrees of the childs into two groups so that size of each group is at least ?n?13?\n. It is possible: while there are at least 4\n subtrees, there are two for which there are no more than n2\n vertices in total, then we unite them. When we have 3\n subtrees left, we will unite two smaller ones into one group. It is easy to see that in each of the two groups there will be at least ?n?13?\n vertices.\n\nLet the first group have a\n vertices and the second b\n. Then, using the lemma, we put the numbers on the edges in a\n and between c\n and a\n so that the distances from c\n to the vertices of the first group are 1,2,,a\n. Similarly, we make the distance from c\n to the vertices of the second group equal to (a+1),2(a+1),,b(a+1)\n. Then each number from 1\n to (a+1)(b+1)?1\n can be obtained as the distance between some vertex from the first group and some from the second. It is easy to show that (a+1)(b+1)?1\n for a+b=n?1\n and a,b??n?13?\n cannot be less than 2n29\n. (For example, we can say that this value is minimized at a=n?13\n and get (a+1)(b+1)?1?(n+23)(2n+13)?1=2n2+5n+39?1?2n29\n for n>1\n (the case of n=1\n is obvious)).\n\nAsymptotics O(n)\n (but a checker takes O(n2)\n)",
    "hint": []
}