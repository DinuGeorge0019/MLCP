{
    "link": "https://codeforces.com//contest/991/problem/F",
    "problemId": "192855",
    "problem_idx": "F",
    "shortId": "991F",
    "contest_number": "991",
    "problem_submissions": {
        "F": [
            39576800,
            39587349,
            39587290,
            39590781
        ],
        "E": [
            39560920,
            39563177,
            39554918,
            39559780,
            39559264,
            39559562,
            39558267,
            39561151,
            39561555,
            39562575,
            39562535,
            39558347,
            39564264,
            39564956,
            39563328,
            39561476,
            39562779,
            39563469,
            39566393
        ],
        "D": [
            39555573,
            39558828,
            39558568,
            39556690,
            39555594,
            39556894,
            39555092,
            39556834,
            39556593,
            39555383,
            39556152,
            39555415,
            39558075,
            39558604,
            39558390,
            39558262,
            39556471,
            39559559,
            39557003
        ],
        "C": [
            39552143,
            39554582,
            39560997,
            39551727,
            39552807,
            39552053,
            39550273,
            39551314,
            39545924,
            39552118,
            39549887,
            39551605,
            110388396,
            39551266,
            39552996,
            39551353,
            39554425,
            39551429,
            39552969,
            39552631
        ],
        "B": [
            39547610,
            39548679,
            39554562,
            39547503,
            39548120,
            39548048,
            39546472,
            39547257,
            39549325,
            39548599,
            39547328,
            39547986,
            39548474,
            39549006,
            39549960,
            39550453,
            39548096,
            39548463,
            39547961
        ],
        "A": [
            39545591,
            39545651,
            39551664,
            39545432,
            39545677,
            39545592,
            39545183,
            39545239,
            39545475,
            39545255,
            39547682,
            39545791,
            39545926,
            39552806,
            39547513,
            39545857,
            39549213,
            39545940
        ]
    },
    "name": "F. Concise and clear",
    "statement": "Vasya is a regular participant at programming contests and is already\r\nexperienced in finding important sentences in long statements. Of\r\ncourse, numbers constraints are important factorization of a number less\r\nthan is easier than of a number less than . However, sometimes it\u2019s hard\r\nto understand the number at the first glance. Could it be shortened? For\r\nexample, instead of you could write 10^{6}, instead of 10^{9}, instead\r\nof 10^{9}+7.Vasya decided that, to be concise, the notation should\r\nfollow several rules: the notation should only consist of numbers,\r\noperations of addition (\"\"), multiplication (\"\") and exponentiation\r\n(\"\"), in particular, the use of braces is forbidden; the use of several\r\nexponentiation operations in a row is forbidden, for example, writing \"\"\r\nis unacceptable; the value of the resulting expression equals to the\r\ninitial number; the notation should consist of the minimal amount of\r\nsymbols. Given n, find the equivalent concise notation for it.\r\n",
    "solutions": [
        "// who's it from?\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define f first\n#define s second\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n\nll n;\nvector<pair<ll,string> > po;\nmap<ll, string> mp;\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int base = 2; base <= 100000; base++) {\n\t\tll val = base;\n\t\tstring s = to_string(base) + '^';\n\t\tfor (int e = 2; val * base <= 10000000000ll; e++) {\n\t\t\tval *= base;\n\t\t\tpo.emplace_back(val, s + to_string(e));\n\t\t\tif(mp.count(val) && SZ(s + to_string(e)) < SZ(mp[val])) {\n\t\t\t\tmp[val] = s + to_string(e);\n\t\t\t} else if (!mp.count(val)) {\n\t\t\t\tmp[val] = s + to_string(e);\n\t\t\t}\n\t\t}\n\t}\n\t//for (ll n = 1; n <= 10000; n++) {\n\tstring res = to_string(n);\n\tfor (const pair<ll,string> &p : po) {\n\t\tif (n >= p.f) {\n\t\t\tif (mp.count(n - p.f)) {\n\t\t\t\tstring tmp = p.s + '+' + mp[n - p.f];\n\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\tres = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif ((n - i) % p.f == 0 && mp.count((n - i) / p.f)) {\n\t\t\t\t\tstring tmp = p.s + '*' + mp[(n - i) / p.f];\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\ttmp += '+';\n\t\t\t\t\t\ttmp += to_string(i);\n\t\t\t\t\t}\n\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (int i = 2; i < 10; i++) {\n\t\t\t\tif (p.f * i <= n) {\n\t\t\t\t\tif (mp.count(n - p.f * i)) {\n\t\t\t\t\t\tstring tmp = p.s + '*' + to_string(i) + '+' + mp[n - p.f * i];\n\t\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (n % (p.f * i) == 0) {\n\t\t\t\t\t\tif (mp.count(n / (p.f * i))) {\n\t\t\t\t\t\t\tstring tmp = p.s + '*' + to_string(i) + '*' + mp[n / (p.f * i)];\n\t\t\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring tmp = p.s;\n\t\t\tif (n - p.f != 0) {\n\t\t\t\ttmp += '+';\n\t\t\t\ttmp += to_string(n - p.f);\n\t\t\t}\n\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\tres = tmp;\n\t\t\t}\n\t\t\tll c = n / p.f;\n\t\t\tint d = 0;\n\t\t\tll asdf = c;\n\t\t\twhile (asdf) {\n\t\t\t\td++;\n\t\t\t\tasdf /= 10;\n\t\t\t}\n\t\t\tll num = 0;\n\t\t\tfor (int i = 1; i < d; i++) {\n\t\t\t\tnum = num * 10 + 9;\n\t\t\t\ttmp = to_string(num) + '*' + p.s;\n\t\t\t\tassert(n - num * p.f >= 0);\n\t\t\t\tif (n - num * p.f != 0) {\n\t\t\t\t\ttmp += '+';\n\t\t\t\t\ttmp += to_string(n - num * p.f);\n\t\t\t\t}\n\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\tres = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = to_string(c) + '*' + p.s;\n\t\t\tif (n - c * p.f != 0) {\n\t\t\t\ttmp += '+';\n\t\t\t\ttmp += to_string(n - c * p.f);\n\t\t\t}\n\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\tres = tmp;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << n << ' ';\n\tcout << res << endl;\n\t//}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Concise and clear.json",
    "editorial_link": "https://codeforces.com/blog/entry/60181",
    "editorial": "EditorialAll the problem numbers (except for , which is given in the\r\nsamples) contain at most 10 digits. It means that we have to use at most\r\n9 digits if we want to find a shorter representation. Notice that the\r\nlength of sum of two integers is not greater than sum of the lengths of\r\nthese integers, so in the optimal representation at most one term is a\r\nnumber while other terms are expressions containing * and/or ^. Each\r\nexpression (not a number) contains at least 3 symbols, so the optimal\r\nrepresentation can contain at most 3 terms. The maximal integer that can\r\nbe represented in such manner is 9^9+9^9+9, but it contains only 9\r\ndigits while expressions with 3 terms always contain at least 9 symbols.\r\nSo we proved that there always exists an optimal representation which is\r\na sum of at most two terms.So there exist only 3 types of representation\r\nof the original number: n = a^b n = x+y n = x*y where and some\r\nexpressions (in the first case and are numbers), which doesn\u00e2\u0080\u0099t contain\r\n+. Moreover in all the cases such expressions should contain at most 7\r\ndigits.Let\u00e2\u0080\u0099s find for each a shortest valid representation , containing\r\nat most 7 symbols (if it exists and contains less digits than simple\r\nnumber ), and for each length set of integers which can be represented\r\nby an expression of length . The standard containers (std::map and\r\nstd::set C++) are suitable for that: Firstly let\u00e2\u0080\u0099s add all expressions\r\na^b, there are about sqrt(n) such expressions. Now lets consider the\r\nexpressions containing several multipliers. The same way (as for\r\naddition) in such representation at most one multiplier is a number.\r\nIncluding that the expression can contain at most 7 digits we have only\r\n2 possible ways: x = a^b*c^d x = a^b*c where , , and are some numbers.\r\nLets iterate through the length of the representation of the first\r\nmultiplier and go over all values stored in . The second multiplier can\r\nhave length at most and the total number of ways to choose two\r\nmultipliers will be small enough. The second multiplier should be\r\nselected from containers for length at most (in the first case), or we\r\nshould iterate from to (in the second case). After that we will have\r\nabout numbers in in total: Now lets go back to the representation of the\r\noriginal number. For the first case a^b we have already stored such\r\nvalues in . For the cases x+y and x*y we may assume that the length of\r\nexpression of is not greater than 4. Now lets iterate through among\r\nfound representations of length up to 4, and among integers from 1 to .\r\nFor each such and for each of 2 cases we determine value of uniquely,\r\nand the optimal representation of is already stored in or it is just a\r\nnumber. So, for each such we can find optimal answer for by at most two\r\naddressing to i.e. in operations. Finally, the total algorithm\r\ncomplexity is .\r\n"
}