{"link": "https://codeforces.com//contest/796/problem/F", "problemId": "102477", "problem_idx": "F", "shortId": "796F", "contest_number": "796", "problem_submissions": {"D": [26270676, 26268879, 26272464, 26267846, 26271244, 26271502, 26279976, 26280757, 26270905, 26273570, 26272084, 26278210, 26277165, 26274914, 26273555, 26270674, 26274828, 26272225, 26276256, 26275870], "C": [26266928, 26275839, 26289710, 26263867, 26268031, 26268145, 26268959, 26275805, 26276716, 26267202, 26282722, 26266268, 26273046, 26271604, 26307139, 26307124, 26307117, 26306972, 26268576, 26276501, 26270809, 26275985, 26270211, 26272901], "B": [26260444, 26260714, 26260928, 26268179, 26259754, 26260202, 26259813, 26260983, 26261840, 26260679, 26259761, 26261074, 26260940, 26259972, 26266557, 26259771, 26262157, 26259891, 26263590, 26260396], "A": [26258377, 26258938, 26258411, 26258195, 26258231, 26258560, 26258094, 26258499, 26258460, 26258203, 26258087, 26258420, 26258693, 26258275, 26258381, 26258161, 26258669, 26258379, 26260347, 26258265], "E": [26280397, 26347598, 26308967, 26308953], "F": [58542353]}, "name": "F. Sequence Recovery", "statement": "Zane once had a sequence consisting of integers but he has lost it.A\r\nsequence is said to be if and only if all of its integers are\r\nnon-negative and do not exceed in value. However, Zane remembers having\r\nplayed around with his sequence by applying operations to it.There are\r\ntwo types of operations:1. Find the maximum value of integers with\r\nindices such that , given and .2. Assign as the value of the integer\r\nwith index , given and .After he finished playing, he restored his\r\nsequence to the state it was before any operations were applied. That\r\nis, sequence was no longer affected by the applied type 2 operations.\r\nThen, he lost his sequence at some time between now and\r\nthen.Fortunately, Zane remembers all the operations and the order he\r\napplied them to his sequence, along with the results of all type 1\r\noperations. Moreover, among all sequences that would produce the same\r\nresults when the same operations are applied in the same order, he knows\r\nthat his sequence has the greatest .We define of a sequence as the\r\nbitwise OR result of all integers in such sequence. For example, the of\r\nZane\u2019s sequence is ... .Zane understands that it might not be possible\r\nto recover exactly the lost sequence given his information, so he would\r\nbe happy to get any sequence consisting of integers that:1. would give\r\nthe same results when the same operations are applied in the same order,\r\nand2. has the same as that of Zane\u2019s original sequence .If there is such\r\na sequence, find it. Otherwise, it means that Zane must have remembered\r\nsomething incorrectly, which is possible.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define oo 1000000010\n#define mod 1000000007\nconst int N = 300010;\nint n , m ;\n\nint t[N] , l[N] , r[N] , x[N];\n\nint arr[N];\n\nint cnt = 0;\n\nint seg[4 * N];\n\nbool done[N];\n\nint Mx;\n\nint build(int s,int e,int idx){\n    if(s == e)\n        return seg[idx] = arr[s];\n    return seg[idx] = max(build(s,((s+e) >> 1),(idx << 1)),build(((s+e) >> 1) + 1,e,(idx << 1) + 1));\n}\n\nint L , R , val;\n\nvoid update2(int s,int e,int idx){\n    if(s > R || e < L) return;\n    if(s >= L && e <= R){\n        seg[idx] = min(seg[idx] , val);\n        return;\n    }\n    update2(s,((s+e) >> 1),(idx << 1));\n    update2(((s+e) >> 1) + 1,e,(idx << 1) + 1);\n}\n\nint get2(int i){\n    int s = 0 , e = n - 1 , res = Mx , idx = 1;\n    while(true){\n        res = min(res , seg[idx]);\n        if(s == e) break;\n        if(i > ((s + e) >> 1)){\n            s = ((s + e) >> 1) + 1;\n            idx = (idx << 1) + 1;\n        }\n        else{\n            e = ((s+e) >> 1);\n            idx = (idx << 1);\n        }\n    }\n    return res;\n}\n\nint update(int s,int e,int idx){\n    if(s > R || e < L) \n        return seg[idx];\n    if(s == e)\n        return seg[idx] = val;\n    return seg[idx] = max(update(s,((s+e) >> 1),(idx << 1)) , update(((s+e) >> 1) + 1,e,(idx << 1) + 1));\n}\n\nint getmax(int s,int e,int idx){\n    if(s > R || e < L)\n        return 0;\n    if(s >= L && e <= R)\n        return seg[idx];\n    return max(getmax(s,((s+e) >> 1),(idx << 1)) , getmax(((s+e) >> 1) + 1,e,(idx << 1) + 1));\n}\n\nbool check(int Val){\n    Mx = Val;\n    for(int i = 0 ;i < n;i++) \n        arr[i] = Val , done[i] = false;\n    build(0,n-1,1);\n    for(int i = 0 ;i < m;i++){\n        if(t[i] == 2){\n            if(done[l[i]]) continue;\n            arr[l[i]] = get2(l[i]);\n            done[l[i]] = true;\n            continue;\n        }\n        L = l[i] , R = r[i] , val = x[i];\n        update2(0, n - 1 , 1);\n    }\n    for(int i = 0 ;i < n;i++){\n        if(!done[i])\n            arr[i] = get2(i);\n    }\n    build(0,n-1,1);\n    for(int i = 0 ;i < m;i++){\n        if(t[i] == 2){\n            L = R = l[i];\n            val = x[i];\n            update(0,n-1,1);\n        }\n        else{\n            L = l[i] , R = r[i];\n            if(getmax(0,n-1,1) != x[i])\n                return false;\n        }\n    }\n    return true;\n}\n\nmap < int , bool > Done;\n\ninline int get(int val){\n    for(int i = 29 ;i >= 0 ;i--){\n        if(((val >> i) & 1) == 1)\n            return (1 << i) - 1;\n    }\n    return 0; \n}\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 0 ;i < m;i++){\n        scanf(\"%d%d%d\",&t[i],&l[i],&r[i]);\n        if(t[i] == 1){\n            l[i]--,r[i]--;\n            scanf(\"%d\",&x[i]);\n        }\n        else{\n            x[i] = r[i];\n            l[i]--;\n            r[i] = l[i];\n        }\n    }\n    int val = (int)1e9 + 1;\n    if(!check(val)){\n        puts(\"NO\");\n        return 0;\n    }\n    puts(\"YES\");\n    for(int i = 0 ;i < n;i++){\n        if(arr[i] == val) continue;\n        if(Done[arr[i]]){\n            arr[i] = get(arr[i]);\n            continue;\n        }\n        Done[arr[i]] = true;\n    }\n    int o = 0;\n    for(int i = 0 ;i < n;i++){\n        if(arr[i] == val){\n            continue;\n        }\n        o |= arr[i];\n    }\n    o ^= ((1 << 30) - 1);\n    for(int i = 0 ;i < n;i++){\n        if(arr[i] != val) continue;\n        arr[i] = 0;\n        for(int j = 29 ;j >=0 ;j--){\n            if(((o >> j) & 1) == 0) continue;\n            if((arr[i] ^ (1 << j)) >= val) continue;\n            arr[i] ^= (1 << j);\n            o ^= (1 << j);\n        }\n    }\n\n    for(int i = 0 ;i < n;i++){\n        if(i) putchar(' ');\n        printf(\"%d\",arr[i]);\n    }\n    puts(\"\");\n    return 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "data structures", "greedy"], "dificulty": "2800", "interactive": false}