{
    "link": "https://codeforces.com//contest/964/problem/D",
    "problemId": "175444",
    "problem_idx": "D",
    "shortId": "964D",
    "contest_number": "964",
    "problem_submissions": {
        "E": [
            37409419,
            37412882,
            37412551,
            37537258
        ],
        "D": [
            37405314,
            37405406,
            37407186,
            37404280,
            37404169,
            37408650,
            37406709,
            37408309,
            37407949,
            37409754,
            37405372,
            37408312,
            37409242,
            37407775,
            37408039,
            37410204,
            37408800,
            37409358,
            37410244,
            37411197
        ],
        "C": [
            37403398,
            37403877,
            37404364,
            37401413,
            37406057,
            37403278,
            37403765,
            37403218,
            37404076,
            37402918,
            37409929,
            37404535,
            37403561,
            37404289,
            37406113,
            37406564,
            37405628,
            37403427,
            37405874,
            37402908
        ],
        "B": [
            37401124,
            37399470,
            37399569,
            37398293,
            37401006,
            37399516,
            37400304,
            37400317,
            37401519,
            37403572,
            37400503,
            37400997,
            37400932,
            37399240,
            37399448,
            37399083,
            37401068,
            37406879,
            37401310,
            37399198
        ],
        "A": [
            37400130,
            37398594,
            37414688,
            37397760,
            37399494,
            37397960,
            37399304,
            37398291,
            37400088,
            37398209,
            37398067,
            37399344,
            37399606,
            37397801,
            37398329,
            37398304,
            37399455,
            37398145,
            37398241,
            37397856
        ]
    },
    "name": "D. Destruction of a Tree",
    "statement": "You are given a tree (a graph with vertices and edges in which it\u2019s\r\npossible to reach any vertex from any other vertex using only its\r\nedges).A vertex can be destroyed if this vertex has even degree. If you\r\ndestroy a vertex, all edges connected to it are also deleted.Destroy all\r\nvertices in the given tree or determine that it is impossible.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\n\nbool ok = true;\nint head, tail;\nint o[maxn], deg[maxn];\nvector<int> e[maxn];\n\nvoid dfs(int u, int pre) {\n\tif (pre != 0) deg[u] = 1, deg[pre]++;\n\telse deg[u] = 0;\n\t\n\tif (pre != 0 && e[u].size() == 1) {\n\t\t//leaf\n\t\to[tail++] = u;\n\t\treturn ;\n\t}\t\n\tfor (int i = e[u].size() - 1; i >= 0; i--) \n\t\tif (e[u][i] != pre) dfs(e[u][i], u);\n\t\n\tif (deg[u] & 1) {\n\t\tif (pre == 0) {\n\t\t\tok = false;\n\t\t}\n\t\to[tail++] = u;\n\t}\n\telse {\n\t\to[--head] = u;\n\t\tif (pre) deg[pre]--;\n\t}\n}\n\nint main() {\n\tint n, root;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u == 0) root = i;\n\t\telse {\n\t\t\te[u].push_back(i);\n\t\t\te[i].push_back(u);\n\t\t}\n\t}\n\thead = n;\n\tdfs(1, 0);\n\tif (!ok) {\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"YES\\n\");\n\tfor (int i = n - 1; i >= 0; i--) printf(\"%d\\n\", o[i]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Destruction of a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/58991",
    "editorial": "If n is even, then the answer is always NO, because such trees have odd degree, but we can destroy only even number of edges.\n\nFor any odd n the answer exists.\n\nLet's call dfs(i) from subtree i and destroy such nodes, that new subtree will be empty or for all alive nodes in connected component will be true, that they have odd degree.\n\nRealisation of this dfs:\n\nCall it from sons of i and recount degree of i, if it is even we destroy all subtree.\n\nAssume, that after the destruction we have nonempty subtree. All nodes have odd degree, so amount of left nodes is even. So number of left edges is odd, but in start we have even count of edges, contradiction. That means, that we destroyed all nodes."
}