{"link": "https://codeforces.com//contest/1189/problem/C", "problemId": "366814", "problem_idx": "C", "shortId": "1189C", "contest_number": "1189", "problem_submissions": {"F": [56579282, 56588782], "E": [56573729, 56581060, 56587807, 56582721, 56573316, 56576668, 56574574, 56574253, 56578675, 56569961, 56571979, 56580045, 56581830, 56582305, 56578680, 56579770, 56574900, 56580107, 56581322, 56581737], "D2": [56570743, 56583951, 56590479], "D1": [56566287, 56577941, 56576232, 56577551, 56577147, 56570210, 56577116, 56576238, 56575115, 56582247, 56573204, 56575137, 56576626, 56575444, 56576506, 56574493, 56579444, 56574000, 56578325, 56573475], "C": [56564288, 56574952, 56571400, 56573424, 56567619, 56566699, 56569018, 56568449, 56569895, 56577759, 56579059, 56569406, 56571224, 56569610, 56573567, 56600577, 56571447, 56582169, 56576771, 56570411, 56571321], "B": [56562679, 56568440, 56565277, 56565965, 56565753, 56564877, 56565902, 56566168, 56565507, 56574431, 56576380, 56566755, 56565186, 56567011, 56566710, 56600572, 56577002, 56568448, 56570059, 56563578, 56569221], "A": [56561345, 56562783, 56561869, 56561808, 56562857, 56561895, 56562128, 56561757, 56561830, 56571793, 56568111, 56561276, 56563011, 56562623, 56562477, 56600568, 56563950, 56562575, 56563861, 56594597, 56561346, 56563282]}, "name": "C. Candies ", "statement": "Consider a sequence of digits of length 2^k [a_1, a_2,\r\nldots, a_{2^k}]. We perform the following operation with it: replace\r\npairs (a_{2i+1}, a_{2i+2}) with (a_{2i+1} + a_{2i+2})\r\nbmod 10 for 0\r\nle i<2^{k-1}. For every i where a_{2i+1} + a_{2i+2}\r\nge 10 we get a candy! As a result, we will get a sequence of length\r\n2^{k-1}.Less formally, we partition sequence of length 2^k into 2^{k-1}\r\npairs, each consisting of 2 numbers: the first pair consists of the\r\nfirst and second numbers, the second of the third and fourth\r\nldots, the last pair consists of the (2^k-1)-th and (2^k)-th numbers.\r\nFor every pair such that sum of numbers in it is at least 10, we get a\r\ncandy. After that, we replace every pair of numbers with a remainder of\r\nthe division of their sum by 10 (and don\u2019t change the order of the\r\nnumbers).Perform this operation with a resulting array until it becomes\r\nof length 1. Let f([a_1, a_2,\r\nldots, a_{2^k}]) denote the number of candies we get in this process.\r\nFor example: if the starting sequence is [8, 7, 3, 1, 7, 0, 9, 4]\r\nthen:After the first operation the sequence becomes [(8 + 7)\r\nbmod 10, (3 + 1)\r\nbmod 10, (7 + 0)\r\nbmod 10, (9 + 4)\r\nbmod 10] = [5, 4, 7, 3], and we get 2 candies as 8 + 7\r\nge 10 and 9 + 4\r\nge 10.After the second operation the sequence becomes [(5 + 4)\r\nbmod 10, (7 + 3)\r\nbmod 10] = [9, 0], and we get one more candy as 7 + 3\r\nge 10. After the final operation sequence becomes [(9 + 0)\r\nbmod 10] = [9]. Therefore, f([8, 7, 3, 1, 7, 0, 9, 4]) = 3 as we got 3\r\ncandies in total.You are given a sequence of digits of length n s_1,\r\ns_2,\r\nldots s_n. You have to answer q queries of the form (l_i, r_i), where\r\nfor i-th query you have to output f([s_{l_i}, s_{l_i+1},\r\nldots, s_{r_i}]). It is guaranteed that r_i-l_i+1 is of form 2^k for\r\nsome nonnegative integer k.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nint a[101010],s[101010];\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",a+i);\n\tfor(int i=0;i<n;i++)s[i+1]=s[i]+a[i];\n\tint q;scanf(\"%d\",&q);\n\twhile(q--){\n\t\tint l,r;scanf(\"%d%d\",&l,&r);\n\t\tl--;\n\t\tprintf(\"%d\\n\",(s[r]-s[l])/10);\n\t}\n}"], "input": "", "output": "", "tags": ["data structures", "dp", "implementation", "math"], "dificulty": "1400", "interactive": false}