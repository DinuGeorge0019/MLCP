{"link": "https://codeforces.com//contest/129/problem/C", "problemId": "679", "problem_idx": "C", "shortId": "129C", "contest_number": "129", "problem_submissions": {"D": [870060, 869793, 868329, 868490, 871604, 869018, 869569], "E": [867711, 868998, 867271, 866024, 867668, 866384, 868771, 868972, 869787, 869113, 869182, 869294, 869358], "C": [866691, 866148, 865711, 868095, 866773, 867004, 867491, 867351, 866936, 866349, 867158, 866312, 867092, 867601, 867201, 867450, 867706, 867793], "B": [865720, 865280, 865180, 865582, 865310, 866211, 868127, 865744, 865731, 866928, 865788, 865528, 865521, 866153, 866294, 865110, 865388, 865554], "A": [864668, 864600, 864704, 864708, 864607, 864653, 868290, 864785, 864784, 867045, 864843, 864624, 864640, 865218, 864855, 865276, 864658, 864664]}, "name": "C. Statues", "statement": "In this task Anna and Maria play a game with a very unpleasant rival.\r\nAnna and Maria are in the opposite squares of a chessboard (): Anna is\r\nin the upper right corner, and Maria is in the lower left one. Apart\r\nfrom them, the board has several statues. Each statue occupies exactly\r\none square. A square that contains a statue cannot have anything or\r\nanyone neither any other statues, nor Anna, nor Maria.Anna is present on\r\nthe board as a figurant (she stands still and never moves), and Maria\r\nhas been actively involved in the game. Her goal is to come to Anna\u2019s\r\nsquare. Maria and statues move in turn, Maria moves first. During one\r\nmove Maria can go to any adjacent on the side or diagonal cell in which\r\nthere is no statue, or she can stay in the cell where she is. The\r\nstatues during their move must go one square down simultaneously, and\r\nthose statues that were in the bottom row fall from the board and are no\r\nlonger appeared.At that moment, when one of the statues is in the cell\r\nin which the Maria is, the statues are declared winners. At the moment\r\nwhen Maria comes into the cell where Anna has been waiting, Maria is\r\ndeclared the winner.Obviously, nothing depends on the statues, so it all\r\ndepends on Maria. Determine who will win, if Maria does not make a\r\nstrategic error.\r\n", "solutions": ["#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <sstream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <set>\n#include <iterator>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair< int, int > PRII;\ntypedef pair< double, double > PRDD;\ntypedef vector< string > VS;\ntypedef vector< int > VI;\n\n#define x first\n#define y second\n#define p_b push_back\n#define m_p make_pair\n#define oo 1000000000\n\n#define sqr(x) ((x)*(x))\n#define Size(a) ((int)a.size())\n#define forn(i,n) for( i = 0 ; i < n ; ++i )\n\nconst double pi = acos(-1);\n\n#define maxn 10\n#define maxm 1000\n\nint n = 8;\nchar s[maxn][maxn];\nbool hash[maxn][maxn][maxn];\nint dl[maxm][3];\n\nint main()\n{\n    int i,j,k,dx,dy,p,q,l = 0,r = 1;\n    \n    for( i = 1 ; i <= n ; ++i )\n        for( j = 1 ; j <= n ; ++j )\n            scanf(\" %c\",&s[i][j]);\n    \n    dl[0][0] = n, dl[0][1] = 1, dl[0][2] = 0;\n    hash[n][1][0] = 1;\n    while( l < r )\n        {\n            i = dl[l][0], j = dl[l][1], k = dl[l][2];\n            ++l;\n            for( dx = -1 ; dx <= 1 ; ++dx )\n                for( dy = -1 ; dy <= 1 ; ++dy )\n                    {\n                        p = i+dx, q = j+dy;\n                        if( p < 1 || p > n || q < 1 || q > n )\n                            continue;\n                        if( p-k-1 >= 1 && s[p-k-1][q] == 'S' )\n                            continue;\n                        if( p-k >= 1 && s[p-k][q] == 'S' )\n                            continue;\n                        if( !hash[p][q][k+1] )\n                            {\n                                hash[p][q][k+1] = 1;\n                                dl[r][0] = p, dl[r][1] = q, dl[r][2] = k+1;\n                                ++r;\n                                if( (p == 1 && q == n) || k+1 > 8 )\n                                    {\n                                        printf(\"WIN\\n\");\n                                        goto abc;\n                                    }\n                            }\n                    }\n        }\n    printf(\"LOSE\\n\");\n    abc:;\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "implementation"], "dificulty": "1500", "interactive": false}