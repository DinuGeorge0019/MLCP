{
    "link": "https://codeforces.com//contest/2021/problem/B",
    "problemId": "2929692",
    "problem_idx": "B",
    "shortId": "2021B",
    "contest_number": "2021",
    "problem_submissions": {
        "D": [
            284590256,
            284590001,
            284586301,
            284623851,
            284569171,
            284578878,
            284712748,
            284578625,
            284581515,
            284581353,
            284637993
        ],
        "E3": [
            284578176,
            284565599,
            284600842,
            284850992,
            284584216,
            284618196,
            284597636,
            284599022,
            284585148,
            286020331,
            284745105
        ],
        "E1": [
            284577293,
            284599054,
            284566976,
            284599574,
            284568532,
            284584477,
            284579805,
            284586608,
            284600476,
            284585423,
            284594051,
            284576473,
            284592731,
            284581221,
            284582830,
            284576965,
            286020463,
            284573682,
            284745154,
            284585073
        ],
        "E2": [
            284576481,
            284599368,
            284566551,
            284571784,
            284584447,
            284580377,
            284586193,
            284585357,
            284576258,
            284585492,
            284583546,
            284582548,
            286020438,
            284593395,
            284766277,
            284587863
        ],
        "C2": [
            284552959,
            284550125,
            284578847,
            284570668,
            284557743,
            284572571,
            284559765,
            284559531,
            284592443,
            284564745,
            284553608,
            284551809,
            284555032,
            284564040,
            284565535,
            284591262,
            284564727,
            284560092
        ],
        "C1": [
            284543395,
            284545189,
            284579118,
            284555011,
            284551439,
            284544381,
            284549845,
            284558858,
            284582609,
            284556392,
            284545368,
            284554154,
            284545358,
            284546156,
            284555833,
            284553560,
            284550666,
            284546712,
            284545533,
            284552561
        ],
        "B": [
            284537997,
            284541648,
            284545572,
            284550280,
            284536827,
            284538339,
            284543136,
            284541306,
            284577835,
            284541582,
            284538597,
            284539525,
            284540971,
            284538476,
            284541915,
            284545007,
            284543924,
            284540121,
            284540098,
            284544260
        ],
        "A": [
            284536034,
            284541336,
            284535964,
            284545882,
            284543072,
            284535980,
            284537720,
            284537149,
            284572305,
            284541440,
            284535781,
            284536205,
            284539247,
            284535865,
            284537520,
            284541705,
            284541775,
            284537231,
            284537773,
            284536991
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134873",
    "editorial": "For the to be at least , then each non-negative integer from to must\r\nappear at least once in the array.First, notice that since there are\r\nonly elements in the array, there are at most different values, so the\r\ncan only be at most . And since we can only increase an elementâs value,\r\nthat means every element with values bigger than can be ignored.We\r\nconstruct a frequency array such that is the number of elements in with\r\nvalue .Notice that the values just need to appear at least once to\r\ncontribute to the , so two or more elements with the same value should\r\nbe split into different values to yield a potentially better result. To\r\nfind the maximum possible , we iterate each index in the array from to .\r\nIn each iteration of , if we find , that means itâs possible to have the\r\nbe bigger than , so we can iterate to the next value. Before we iterate\r\nto the next value, if we find , that indicates duplicates, so we should\r\ndo an operation to all except one of those values to change them into ,\r\nwhich increases by and changes into . In each iteration of , if we find\r\n, that means, is the maximum we can get, and we should end the\r\nprocess.Time complexity for each test case:\r\n",
    "name": "B. Maximize Mex",
    "statement": "You are given an array a of n positive integers and an integer x. You\r\ncan do the following two-step operation any (possibly zero) number of\r\ntimes: Choose an index i (1\r\nleq i\r\nleq n). Increase a_i by x, in other words a_i := a_i + x. Find the\r\nmaximum value of the\r\noperatorname{MEX} of a if you perform the operations optimally.The\r\noperatorname{MEX} (minimum excluded value) of an array is the smallest\r\nnon-negative integer that is not in the array. For example: The\r\noperatorname{MEX} of [2,2,1] is 0 because 0 is not in the array. The\r\noperatorname{MEX} of [3,1,0,1] is 2 because 0 and 1 are in the array but\r\n2 is not. The\r\noperatorname{MEX} of [0,3,1,2] is 4 because 0, 1, 2 and 3 are in the\r\narray but 4 is not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;int Qread(){\tint x=0;bool f=false;char ch=getchar();\twhile(ch<'0'||ch>'9') f|=(ch=='-'),ch=getchar();\twhile(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();\treturn f?-x:x;}int n,x,a,cnt[500010];void solve(){\tmemset(cnt,0,(n+3)<<2);\tn=Qread(),x=Qread();\tfor(int i=1;i<=n;i++)\t{\t\ta=Qread();\t\tif(a<=n) cnt[a]++;\t}\tfor(int i=0;i<=n;i++)\t{\t\tif(!cnt[i]) return printf(\"%d\\n\",i),void();\t\telse if(i+x<=n) cnt[i+x]+=cnt[i]-1;\t}}int main(){\tint T=Qread();\twhile(T--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Maximize Mex.json",
    "hint": []
}