{"link": "https://codeforces.com//contest/588/problem/D", "problemId": "38255", "problem_idx": "D", "shortId": "588D", "contest_number": "588", "problem_submissions": {"E": [13645041, 13647234, 13646603, 13641082, 13648737, 13639739, 13645096, 13640996, 119991814, 13641078, 13641596, 13650376, 13644075, 13642626, 13643766, 13646050, 13642477, 13643960, 13644746], "D": [13639351, 13639649, 13643732, 13649370, 13642827, 13649049, 13637022, 13702546, 14030283, 13639966], "C": [13630106, 13631147, 13633040, 13630591, 13632505, 13631594, 13636634, 13630220, 13633364, 13635760, 13658418, 13630672, 13632240, 13630150, 13652664, 13632626, 13633303, 13634794, 13632441], "B": [13629094, 13628701, 13630705, 13628132, 13630053, 13630134, 13630520, 13628440, 13629087, 13629241, 13629690, 13629617, 13633004, 13629324, 13629595, 13629544, 13629480, 13630408], "A": [13627091, 13627133, 13628904, 13626934, 13626996, 13628463, 13629317, 13626624, 13627086, 13627884, 13627524, 13627373, 13632434, 13626712, 13627173, 13626674, 13627275, 13627838]}, "name": "D. Duff in Beach", "statement": "While Duff was resting in the beach, she accidentally found a strange\r\narray consisting of positive integers. This array was strange because it\r\nwas extremely long, but there was another (maybe shorter) array, that\r\ncan be build from with formula: where denoted the remainder of dividing\r\nby . Duff is so curious, she wants to know the number of subsequences of\r\nlike (), such that: For each , For each , . i.e this subsequence is\r\nnon-decreasing. Since this number can be very large, she want to know it\r\nmodulo .Duff is not a programmer, and Malek is unavailable at the\r\nmoment. So she asked for your help. Please tell her this number.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fr(a,b,c) for(int (a) = (b); (a) < (c); ++(a))\n#define rp(a,b) fr(a,0,b)\n#define fre(a,b) for(int a = adj[b]; ~a; a = ant[a])\n#define cl(a,b) memset((a), (b), sizeof(a))\n#define sc(a) scanf(\"%d\", &a)\n#define sc2(a,b) scanf(\"%d%d\", &a, &b)\n#define sc3(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define scs(s) scanf(\"%s\", s)\n#define pri(x) printf(\"%d\\n\", x)\n\n#define iter(a) __typeof((a).begin())\n#define fore(a,b) for(iter(b) a = (b).begin(); a != (b).end(); ++a)\n\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n\n#define db(x) cerr << #x << \" == \" << x << endl\n#define dbs(x) cerr << x << endl\n#define _ << \", \" <<\n\nconst int oo = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector< vi > vii;\n\n#define N 1000009\n\nint mod = 1000000007;\nint n, k, md, a[N];\nint ord[N];\nll l;\n\nint cmp(int i, int j) {\n\treturn a[i] < a[j];\n}\n\nint sp1[N], sp2[N], *pd1, *pd2;\n\nint proc() {\n\tpd1 = sp1;\n\tpd2 = sp2;\n\trp(i, n) pd1[i] = 1;\n\tll ret = l%mod, sz = l/n;\n\t\n\tfr(j, 2, k+1) {\n\t\tif (sz - ll(j) + 2ll <= 0) break;\n\t\t//rp(i, n) printf(\"%d \", pd1[i]);\n\t\t//puts(\"\");\n\t\tll sum = 0;\n\t\t\n\t\tfor(int p = 0, q; p < n; p = q) {\n\t\t\tq = p;\n\t\t\twhile(q < n && a[ord[p]] == a[ord[q]]) q++;\n\t\t\tfr(k, p, q) sum = (sum + ll(pd1[ord[k]]))%mod;\n\t\t\tfr(k, p, q) {\n\t\t\t\tpd2[ord[k]] = sum;\n\t\t\t\t\n\t\t\t\tll desl = sz - ll(j) + 1ll;\n\t\t\t\tif (ord[k] < md) desl++;\n\t\t\t\tdesl = max(desl, 0ll);\n\t\t\t\tdesl %= mod;\n\t\t\t\tll add = (desl*sum)%mod;\n\t\t\t\tret = (ret + add)%mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswap(pd1, pd2);\n\t}\n\t//rp(i, n) printf(\"%d \", pd1[i]);\n\t//puts(\"\");\n\t\n\treturn ret;\n}\n\nint main() {\n\twhile (sc(n) == 1) {\n\t\tscanf(\"%I64d%d\", &l, &k);\n\t\tmd = l%n;\n\t\trp(i, n) {\n\t\t\tsc(a[i]);\n\t\t\tord[i] = i;\n\t\t}\n\t\tsort(ord, ord+n, cmp);\n\t\t\n\t\tpri(proc());\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"], "input": "", "output": "", "tags": [], "dificulty": "2100", "interactive": false}