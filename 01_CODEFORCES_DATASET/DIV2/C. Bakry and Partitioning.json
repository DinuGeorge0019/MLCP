{
    "link": "https://codeforces.com//contest/1592/problem/C",
    "problemId": "1129221",
    "problem_idx": "C",
    "shortId": "1592C",
    "contest_number": "1592",
    "problem_submissions": {
        "F2": [
            130713058,
            130745405,
            130752812,
            130700115,
            130719186,
            130720967,
            130722508,
            130857743,
            130747284
        ],
        "F1": [
            130708913,
            130716472,
            130712966,
            130690640,
            130721286,
            130704100,
            130714549,
            130712433,
            130713697,
            130851358,
            130725206,
            130716184
        ],
        "E": [
            130702698,
            130695073,
            130712585,
            130690161,
            130713929,
            130713176,
            130705621,
            130689937,
            130710720,
            130851028,
            130710139,
            130712353,
            130705313,
            130701661,
            130698871,
            130698929,
            130696498
        ],
        "D": [
            130686766,
            130712124,
            130687989,
            130703162,
            130719297,
            130699331,
            130692683,
            130699442,
            130699159,
            130850999,
            130702540,
            130701084,
            130699463,
            130712566,
            130716938,
            130713876,
            130700116
        ],
        "C": [
            130673756,
            130678234,
            130691078,
            130722241,
            130692718,
            130685086,
            130684627,
            130684454,
            130695547,
            130686901,
            130682234,
            130850976,
            130687343,
            130686079,
            130680261,
            130693322,
            130682408,
            130683213,
            130708723,
            130704235
        ],
        "B": [
            130668341,
            130668419,
            130669045,
            130704250,
            130680256,
            130671878,
            130678194,
            130668270,
            130665664,
            130670263,
            130668846,
            130676770,
            130673397,
            130708534,
            130677615,
            130673769,
            130685667,
            130666906
        ],
        "A": [
            130663321,
            130663779,
            130671236,
            130667562,
            130676197,
            130664558,
            130674304,
            130663697,
            130663364,
            130664358,
            130664439,
            130664164,
            130666634,
            130663540,
            130663720,
            130665536,
            130664639,
            130664321,
            130671799
        ]
    },
    "name": "C. Bakry and Partitioning",
    "statement": "Bakry faced a problem, but since heâ€™s lazy to solve it, he asks for your\r\nhelp.You are given a tree of n nodes, the i-th node has value a_i\r\nassigned to it for each i from 1 to n. As a reminder, a tree on n nodes\r\nis a connected graph with n-1 edges.You want to delete from the tree, so\r\nthat the following condition would hold:For every connected component\r\ncalculate the bitwise XOR of the values of the nodes in it. Then, these\r\nvalues have to be the same for all connected components.Is it possible\r\nto achieve this condition?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nint n,l,a[100005],f[100005],ban,s;\nint hd[100005],nxt[200005],to[200005],tot;\nvoid add(int x,int y)\n{\n\ttot++;nxt[tot]=hd[x];to[tot]=y;hd[x]=tot;\n}\nint dfs(int x,int fa)\n{\n\tf[x]=a[x];\n\tint i;\n\tfor(i=hd[x];i;i=nxt[i])if(to[i]!=fa&&to[i]!=ban)\n\t{\n\t\tint t=dfs(to[i],x);\n\t\tif(t)return t;\n\t\tf[x]^=f[to[i]];\n\t}\n\tif(f[x]==s)return x;\n\treturn 0;\n}\nvoid solve()\n{\n\tcin>>n>>l;\n\trep(i,n) hd[i]=0;\n\ts=0;\n\trep(i,n)\n\t{\n\t\tcin>>a[i];\n\t\ts^=a[i];\n\t}\n\ttot=0;\n\trep(i,n-1)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tif(s==0)\n\t{\n\t\tputs(\"YES\");\n\t\treturn;\n\t}\n\tif(l==2)\n\t{\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\tban=0;\n\tif(!(ban=dfs(1,0))||ban==1)\n\t{\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\tif(dfs(1,0)<=1)\n\t{\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\tputs(\"YES\");\n}\nint main()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Bakry and Partitioning.json",
    "editorial_link": "https://codeforces.com//blog/entry/95583",
    "editorial": "The most important observation is: If you can partition the tree into\r\ncomponents such that the xor of every component is , Then you can\r\npartition the tree into components by merging any 3 adjacent components\r\ninto 1 component, and the xor of the new component will equal , since\r\nxor xor = .Notice that the answer is always YES if the xor of the array\r\nis . Because you can delete any edge in the tree, and the 2 components\r\nwill have the same xor.Otherwise, We need to partition the tree into 3\r\ncomponents that have the same xor. Let be the xor of all node values in\r\nthe tree, then The xor of every component will equal .We need to search\r\nfor 2 edges to delete from the tree and one of them such that the xor\r\nevery component equals and if we found them and then the answer is \"YES\"\r\notherwise \"NO\".To search on the 2 edges, We will first root the tree on\r\nnode 1, then we will search on the deepest subtree such that xor value\r\nof subtree equals , then erase the edge and search again for the 2nd\r\nedge.\r\n",
    "hint": []
}