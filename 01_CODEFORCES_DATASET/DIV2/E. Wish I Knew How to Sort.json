{
    "link": "https://codeforces.com//contest/1754/problem/E",
    "problemId": "1601073",
    "problem_idx": "E",
    "shortId": "1754E",
    "contest_number": "1754",
    "problem_submissions": {
        "F": [
            177585023,
            177595292,
            177589725,
            177595672,
            177592227,
            177594371,
            177600616,
            177598864,
            177604397,
            177602614,
            177600745,
            177650521
        ],
        "E": [
            177569689,
            177567357,
            177579016,
            177575748,
            177578227,
            177581574,
            177582284,
            177718437,
            177559205,
            177578841,
            177592467,
            177571365,
            177604409,
            177574278,
            177575358,
            177581672,
            177580864,
            177577975,
            177576690,
            177577060,
            177575788
        ],
        "D": [
            177558843,
            177556402,
            177557867,
            177557341,
            177566023,
            177561555,
            177537301,
            177563632,
            177569625,
            177568630,
            177559753,
            177582529,
            177556010,
            177555670,
            177565457,
            177546662,
            177548683,
            177569461,
            177558389,
            177564007
        ],
        "C2": [
            177551655,
            177558288,
            177573497,
            177569544,
            177555242,
            177556994,
            177560273,
            177574456,
            177565363,
            177565266,
            177553021,
            177580177,
            177562940,
            177559475,
            177572826,
            177570567,
            177562030,
            177570649,
            177565206
        ],
        "C1": [
            177547310,
            177553157,
            177573631,
            177554026,
            177551066,
            177557135,
            177560766,
            177574531,
            177555999,
            177565804,
            177552312,
            177567879,
            177563083,
            177549386,
            177558755,
            177554824,
            177557780,
            177570332,
            177559045
        ],
        "B": [
            177536928,
            177540939,
            177544434,
            177539979,
            177546063,
            177755484,
            177551911,
            177569215,
            177582864,
            177540989,
            177550638,
            177541452,
            177561666,
            177543484,
            177541411,
            177704318,
            177536796,
            177542739,
            177547137,
            178632445,
            177550998,
            177541636
        ],
        "A": [
            177533931,
            177534875,
            177539057,
            177534599,
            177534878,
            177755451,
            177538378,
            177573057,
            177577215,
            177534289,
            177537921,
            177534413,
            177539691,
            177533195,
            177532916,
            177535356,
            177704314,
            177533258,
            177538336,
            177537857,
            178632436,
            177537629,
            177532986
        ]
    },
    "name": "E. Wish I Knew How to Sort",
    "statement": "You are given a binary array a (all elements of the array are 0 or 1) of\r\nlength n. You wish to sort this array, but unfortunately, your\r\nalgorithms teacher forgot to teach you sorting algorithms. You perform\r\nthe following operations until a is sorted: Choose two random indices i\r\nand j such that i < j. Indices are chosen equally probable among all\r\npairs of indices (i, j) such that 1\r\nle i < j\r\nle n. If a_i > a_j, then swap elements a_i and a_j. What is the expected\r\nnumber of such operations you will perform before the array becomes\r\nsorted?It can be shown that the answer can be expressed as an\r\nirreducible fraction\r\nfrac{p}{q}, where p and q are integers and q\r\nnot\r\nequiv 0\r\npmod{998\r\n,244\r\n,353}. Output the integer equal to p\r\ncdot q^{-1}\r\nbmod 998\r\n,244\r\n,353. In other words, output such an integer x that 0\r\nle x < 998\r\n,244\r\n,353 and x\r\ncdot q\r\nequiv p\r\npmod{998\r\n,244\r\n,353}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define ln cout<<'\\n'\n#define ll long long\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}\ntemplate<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?\" \":\"\");pr(b...);}\ntemplate<class A>void PR(A a,ll n){rep(i,n)cout<<(i?\" \":\"\")<<a[i];ln;}\nconst ll MAX=998244353,MAXL=1LL<<61,dx[8]={-1,0,1,0,-1,-1,1,1},dy[8]={0,1,0,-1,-1,1,1,-1};\ntypedef pair<ll,ll> P;\n\nvoid extended_euclid(ll x,ll y,ll *c,ll *a,ll *b){\n  ll a0,a1,a2,b0,b1,b2,r0,r1,r2,q;r0=x;r1=y;a0=1;a1=0;b0=0;b1=1;\n  while(r1>0){q=r0/r1;r2=r0%r1;a2=a0-q*a1;b2=b0-q*b1;r0=r1;r1=r2;a0=a1;a1=a2;b0=b1;b1=b2;}\n  *c=r0;*a=a0;*b=b0;\n}\n\nll get_inv(ll n, ll p){\n  ll a,b,c;\n  extended_euclid(n,p,&c,&a,&b);\n  if(a<p) a+=p;\n  return a%p;\n}\n\nll fact[2000100],fact_inv[2000100];\n\nvoid init() {\n  fact[0]=1;\n  REP(i,1,2000100) fact[i]=fact[i-1]*i%MAX;\n  fact_inv[2000050]=get_inv(fact[2000050],MAX);\n  rrep(i,2000050)fact_inv[i]=fact_inv[i+1]*(i+1)%MAX;\n}\n\nll nCr(ll N,ll K){\n  if(K<0||K>N)return 0;\n  return fact[N]*fact_inv[K]%MAX*fact_inv[N-K]%MAX;\n}\n\nvoid Main() {\n  init();\n  ll T;\n  R T;\n  while(T--) {\n    ll n;\n    R n;\n    ll a[n];\n    rep(i,n) R a[i];\n    ll m=0;\n    rep(i,n) {\n      if(!a[i]) m++;\n    }\n    ll x=0;\n    rep(i,m) {\n      if(a[i]) x++;\n    }\n    ll ans=0;\n    rep(i,x) {\n      ans+=nCr(n,2)*get_inv(nCr(x-i,1),MAX)%MAX*get_inv(nCr(x-i,1),MAX)%MAX;\n      ans%=MAX;\n    }\n    pr(ans);\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "probabilities",
        "probabilities"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Wish I Knew How to Sort.json",
    "editorial_link": "https://codeforces.com//blog/entry/108336",
    "editorial": "Let the number of zeros in the array be g\n. Let dp[k]\n be the expected number of swaps needed when there are k\n zeros in the first g\n positions. Then, we know that dp[g]=0\n, and we can write down the recurrence equations for dp[k]\n by considering the case where some element equals to one from the first g\n positions and some element equals to zero from the last (n?g)\n positions are swapped.\n\nThis is the only case where the dp\n value will change. Thus, our recurrence is as follows.\n\nLet p=2?(g?k)?(g?k)n?(n?1)\n. Then dp[k]=1+dp[k]?(1?p)+dp[k+1]?p\n.\n\nThe answer is dp[o]\n, where o\n is the initial number of zeros in the first g\n positions."
}