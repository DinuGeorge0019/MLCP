{
    "link": "https://codeforces.com//contest/1348/problem/E",
    "problemId": "609092",
    "problem_idx": "E",
    "shortId": "1348E",
    "contest_number": "1348",
    "problem_submissions": {
        "F": [
            78730137,
            78732956,
            78738021,
            78735188,
            78738507,
            78734079,
            78753080,
            78717089,
            78727355,
            78727368,
            78773476,
            78740376
        ],
        "E": [
            78711148,
            78713291,
            78707898,
            78710381,
            78719540,
            78713433,
            78709333,
            79466363,
            78772738,
            78713600,
            78699633,
            78717322,
            78717382,
            78717153,
            78728870,
            78722408,
            78722025,
            78727426,
            78728940
        ],
        "C": [
            78694419,
            78693419,
            78696011,
            78687630,
            78679892,
            78697771,
            78685191,
            78681524,
            78686378,
            78693929,
            78687938,
            78717342,
            78689661,
            78687381,
            78689833,
            78687589,
            78685601,
            78687639,
            78687038
        ],
        "D": [
            78686862,
            78702906,
            78690856,
            78698132,
            78702134,
            78701001,
            78706132,
            78701735,
            78701924,
            78711443,
            78693858,
            78706550,
            78704171,
            78707502,
            78702198,
            78714055,
            78702526,
            78697601,
            78708853,
            78702351
        ],
        "B": [
            78677169,
            78673852,
            78668555,
            78675102,
            78668889,
            78672084,
            78671272,
            78669645,
            79465649,
            78671217,
            78677254,
            78667586,
            78673648,
            78677181,
            78676314,
            78695320,
            78673038,
            78670148,
            78674360,
            78670529,
            78675058
        ],
        "A": [
            78669591,
            78665336,
            78662907,
            78664918,
            78662747,
            78662442,
            78662941,
            78662589,
            78662555,
            78665985,
            78662547,
            78662641,
            78669435,
            78666111,
            78662690,
            78662462,
            78663929,
            78669719,
            78662632,
            78663426
        ]
    },
    "name": "E. Phoenix and Berries",
    "statement": "Phoenix is picking berries in his backyard. There are n shrubs, and each\r\nshrub has a_i red berries and b_i blue berries.Each basket can contain k\r\nberries. But, Phoenix has decided that each basket may only contain\r\nberries from the same shrub or berries of the same color (red or blue).\r\nIn other words, all berries in a basket must be from the same shrub\r\nor/and have the same color.For example, if there are two shrubs with 5\r\nred and 2 blue berries in the first shrub and 2 red and 1 blue berries\r\nin the second shrub then Phoenix can fill 2 baskets of capacity 4\r\ncompletely: the first basket will contain 3 red and 1 blue berries from\r\nthe first shrub; the second basket will contain the 2 remaining red\r\nberries from the first shrub and 2 red berries from the second shrub.\r\nHelp Phoenix determine the maximum number of baskets he can !\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=510;\nint n,k,a[MAXN],b[MAXN];\nll dp[2][MAXN],sum,ans;\nint main () {\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=0;i<k;i++) {dp[0][i]=-1e18;}\n\tdp[0][0]=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=0;j<k;j++) {dp[i&1][j]=-1e18;}\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tfor (int j=0;j<k;j++){ \n\t\t\tint tmp=(sum%k+k-j)%k;\n\t\t\tfor (int l=0;l<min(k,a[i]+1);l++) {\n\t\t\t\tint tmp2=((a[i]+b[i])%k+k-l)%k;\n\t\t\t\t//cout << i << \"    \" << j << \"  \" << tmp << \"    \" << l << \"  \" << tmp2 << \"    \" << dp[i&1][(j+l)%k] << \"    \";\n\t\t\t\tif (tmp2>b[i]) {continue;}\n\t\t\t\tdp[i&1][(j+l)%k]=max(dp[i&1][(j+l)%k],dp[(i&1)^1][j]+(j+l)/k+(tmp+tmp2)/k+(a[i]+b[i]-tmp2-l)/k);\n\t\t\t\t//cout << dp[i&1][(j+l)%k] << \"    \" << dp[(i&1)^1][j]+(j+l)/k+(tmp+tmp2)/k+(a[i]+b[i]-tmp2-l)/k << endl;\n\t\t\t}\n\t\t}\n\t\tsum+=a[i];\n\t\tsum+=b[i];\n\t}\n\tans=0;\n\tfor (int i=0;i<k;i++) {ans=max(ans,dp[n&1][i]);}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Phoenix and Berries.json",
    "editorial_link": "https://codeforces.com//blog/entry/76555",
    "editorial": "There is no obvious greedy solution, so we will try dynamic programming.\r\nLet be a boolean array that denotes whether we can have extra red\r\nberries after considering the first shrubs. A berry is extra if it is\r\nnot placed into a full basket (of any kind). Note that if we know that\r\nthere are extra red berries, we can also easily calculate how many extra\r\nblue berries there are. Note that we can choose to never have more than\r\nextra red berries, because otherwise we can fill some number of baskets\r\nwith them.To transition from shrub to shrub , we loop over all possible\r\nvalues from to and check whether or not we can leave extra red berries\r\nfrom the current shrub . For some and , we can leave extra red berries\r\nand put the remaining red berries in baskets possibly with blue berries\r\nfrom the same shrub if . The reasoning for this is as follows:First of\r\nall, we are leaving red berries (or at least trying to). We show that\r\nfrom this shrub, there will be at most one basket containing both red\r\nand blue berries (all from this shrub). To place the remaining red\r\nberries into full baskets, the more blue berries we have the better. It\r\nis optimal to place the remaining red berries into their own separate\r\nbaskets first before merging with the blue berries (this way requires\r\nfewest blue berries to satisfy the condition). Then, if is at least , we\r\ncan fill some basket with the remaining red berries and possibly some\r\nblue berries. Remember that we do not care about how many extra blue\r\nberries we leave because that is uniquely determined by the number of\r\nextra red berries.Also note that we can always leave extra red\r\nberries.Denote the total number of berries as . The answer will be\r\nmaximum over all such that is true, .Time Complexity: We use dynamic\r\nprogramming. Let be true if after considering the first shrubs , is the\r\nnumber of red berries in heterogenous baskets modulo . Heterogenous\r\nbaskets contain berries from the same shrub, and homogenous baskets\r\ncontain berries of the same type.Suppose we know the number of red\r\nberries in heterogeneous baskets modulo . This determines the number of\r\nblue berries in heterogeneous baskets modulo . Since the number of red\r\nberries in homogeneous baskets is a multiple of , it also determines the\r\nnumber of red berries not in any baskets (we can safely assume this to\r\nbe less than since otherwise we can form another basket). Similarly, we\r\ncan determine the number of blue berries not in any basket, and thus\r\ndeduce the number of baskets.To compute the possible numbers of red\r\nberries in heterogeneous baskets modulo , it suffices to look at each\r\nshrub separately and determine the possible numbers of red berries\r\nmodulo in heterogeneous baskets for that shrub. If there is more than\r\none heterogeneous basket for one shrub, we can rearrange the berries to\r\nleave at most one heterogeneous. Now we have two cases. If there are no\r\nheterogeneous baskets, the number of red berries in those baskets is\r\nobviously zero. If there is one heterogeneous basket, let be the number\r\nof red berries in it and be the number of blue berries in it. Clearly,\r\nand . Rearranging, we get . These correspond to the transitions for our\r\nDP.There exists faster solutions (like ), can you find it?\r\n"
}