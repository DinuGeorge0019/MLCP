{
    "link": "https://codeforces.com//contest/279/problem/D",
    "problemId": "2704",
    "problem_idx": "D",
    "shortId": "279D",
    "contest_number": "279",
    "problem_submissions": {
        "D": [
            3249313,
            3247594,
            3244905,
            3249853,
            3249691,
            3249081,
            3250467,
            3250451,
            3250359,
            3474157
        ],
        "E": [
            3244979,
            3247752,
            3238796,
            3241502,
            3241802,
            3249970,
            3248144,
            3243573,
            3243340,
            3243108,
            3244030,
            3244923,
            3240469,
            3247041,
            3244724,
            3242537,
            3242804,
            3247622
        ],
        "C": [
            3242350,
            3240214,
            3241436,
            3243563,
            3243315,
            3242680,
            3242006,
            3239324,
            3241143,
            3241800,
            3242584,
            3244958,
            3240145,
            3241851,
            3245710,
            3247069,
            3242483
        ],
        "A": [
            3240766,
            3242016,
            3239749,
            3239283,
            3250054,
            3239155,
            3241094,
            3244109,
            3239779,
            3240700,
            3243000,
            3238846,
            3246020,
            3239320,
            3239919,
            3240334
        ],
        "B": [
            3238919,
            3240626,
            3239249,
            3238903,
            3240194,
            3239523,
            3239885,
            3242187,
            3239867,
            3240726,
            3239001,
            3243481,
            3239120,
            3239326,
            3240278,
            3240808,
            3239300
        ]
    },
    "name": "D. The Minimum Number of Variables",
    "statement": "You\u2019ve got a positive integer sequence . All numbers in the sequence are\r\ndistinct. Let\u2019s fix the set of variables . Initially each variable\r\ncontains the value of zero. Consider the following sequence, consisting\r\nof operations.The first operation is assigning the value of to some\r\nvariable . Each of the following operations is assigning to some\r\nvariable the value that is equal to the sum of values that are stored in\r\nthe variables and . At that, the value that is assigned on the -th\r\noperation, must equal . For each operation numbers are chosen anew.Your\r\ntask is to find the minimum number of variables , such that those\r\nvariables can help you perform the described sequence of operations.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:256000000\")\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <stdio.h>\n#include <set>\n#include <map>\n#include <stack>\n#include <fstream>\n#include <deque>\n#include <list>\n#include <ctime>\n\n#define SZ(a) (int(a.size()))\n#define MEM(a, val) memset(a, val, sizeof(a))\n#define MP(a, b) make_pair(a, b)\n#define PB(a) push_back(a)\n#define ALL(a) a.begin(), a.end()\n#define REP(i, n) for(int (i) = 0; (i) < (n); ++(i))\n#define FOR(i, a, b) for(int (i) = (a); (i) <= (b); ++(i))\n#define SQR(a) ((a) * (a))\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\ntypedef long long LL;\ntypedef long double dbl;\ntypedef pair<int, int> pii ;\ntypedef vector<int> vint;\ntypedef vector<LL> vLL;\n\nvector<bool> f[25];\nconst int inf = 1000000001;\nint n;\nint a[25];\ninline int bit(int i, int mask) {\n    return (mask >> i) & 1;\n}\n\nint main()\n{\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);\n#endif\n    cin >> n;\n    FOR(i, 1, n)\n        cin >> a[i];\n    f[1].resize(2);\n    f[1][0] = false;\n    f[1][1] = true;\n    for (int i = 1; i < n; ++i) {\n        f[i + 1].assign(1 << (i + 1), 0);\n        for (int mask = 0; mask < (1 << i); ++mask) {\n            if (f[i][mask]) {\n                bool end = false;\n                for (int j = 0; j < i && !end; ++j) {\n                    if (bit(j, mask) == 0)\n                        continue;\n                    for (int k = j; k < i && !end; ++k) {\n                        if (bit(k, mask) == 0)\n                            continue;\n                        if (a[j + 1] + a[k + 1] == a[i + 1]) {\n                            mask += (1 << i);\n                            f[i + 1][mask] = true;\n                            for (int u = 0; u < i; ++u) {\n                                if (bit(u, mask)) {\n                                    f[i + 1][mask ^ (1 << u)] = true;\n                                }\n                            }\n                            end = true;\n                            mask -= (1 << i);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int ans = inf;\n    for (int mask = 0; mask < (1 << n); ++mask) {\n        if (f[n][mask]) {\n            int pans = 0;\n            int t = mask;\n            while (t > 0) {\n                pans += t & 1;\n                t >>= 1;\n            }\n            ans = min(ans, pans);\n        }\n    }\n    if (ans == inf)\n        cout << -1 << endl;\n    else\n        cout << ans << endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. The Minimum Number of Variables.json",
    "editorial_link": "https://codeforces.com//blog/entry/95148",
    "editorial": "You can notice that when we want to perform some operation, we are only\r\ninterested in a subset of current values of variables (including zeros).\r\nSo let\u00e2\u0080\u0099s create , which is if we can perform first operations and end up\r\nwith the values from . Here -bit in the mask corresponds to the value ,\r\nwhere array stores all numbers in and a zero, and -th bit is set iff the\r\nvalue of one of the variables is . To make transition from to , let\u00e2\u0080\u0099s\r\nlook at the operation. We have to find two values in the such that their\r\nsum is . Then to calculate we have to set -th bit in the , where is such\r\nthat . Also, while writing new variable we can overwrite any existing\r\nvariable, so we have an option to disable any bit in the . Now it looks\r\nlike we have states and transitions from each state (disabling each\r\nbit). But actually if we only make transition from , the complexity will\r\nbe , because for each there are at most masks that we can achieve, since\r\nthere are only distinct numbers on the current prefix plus an additional\r\nzero. And . The only problem left is to check if we can build some\r\nnumber from using numbers from . This can be precomputed in : let\u00e2\u0080\u0099s\r\ncalculate array , where -th bit in is set iff we can get number from\r\nmask on the next step. To calculate it, first for each with at most bits\r\njust calculate all possible with any straightforward approach, since\r\nthere are only such masks. For any other mask notice that we can get iff\r\nsum of some two values equals to . So we can iterate over all submasks\r\nsuch that they differ from in exactly one bit and update with . And\r\nsince has at least bits, if there is a pair which sums up to , this pair\r\nwill be included into at least one of the submasks. One can even notice\r\nthat we only need any such submasks to cover every pair of bits. The\r\nanswer is minimum number of bits over all masks such that . Code\r\n"
}