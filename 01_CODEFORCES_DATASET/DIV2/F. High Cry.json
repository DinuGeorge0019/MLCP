{
    "link": "https://codeforces.com//contest/876/problem/F",
    "problemId": "128569",
    "problem_idx": "F",
    "shortId": "876F",
    "contest_number": "876",
    "problem_submissions": {
        "B": [
            31407957,
            31390264,
            31393381,
            31391206,
            31391466,
            31392339,
            31391060,
            31390938,
            31390567,
            31392566,
            31390250,
            31392918,
            31393416,
            31394028,
            31401993,
            31389526,
            31389712,
            31390216,
            31389562
        ],
        "A": [
            31405767,
            31391325,
            31391881,
            31389424,
            31389560,
            31388926,
            31389247,
            31393134,
            31389868,
            31389561,
            31394568,
            31390723,
            31391034,
            31389865,
            31400983,
            31389038,
            31388897,
            31389161,
            31389027
        ],
        "C": [
            31404075,
            31392627,
            31389974,
            31393244,
            31393165,
            31389911,
            31392538,
            31389074,
            31392390,
            31391100,
            31389284,
            31395230,
            31394623,
            31401857,
            31389486,
            31390891,
            31391818,
            31392408,
            31390396
        ],
        "E": [
            31403443,
            31404809,
            31410622,
            31404653,
            31403064,
            31401931,
            31411025,
            31411620,
            31408688,
            31405891,
            31410487,
            31405970,
            31410186,
            31407418,
            31435175,
            31531044,
            31402962,
            31506799
        ],
        "D": [
            31396243,
            31396563,
            31404310,
            31398673,
            31397247,
            31395845,
            31404545,
            31404510,
            31397166,
            31396858,
            31397566,
            31401459,
            31403057,
            31403652,
            31393742,
            31395931,
            31396814,
            31396196,
            31396310
        ],
        "F": [
            31393486,
            31413796,
            31413775,
            31407346,
            31399521,
            31409736,
            31411099,
            31410876,
            31400786,
            31401699,
            31407687,
            31412301,
            31409391,
            31411373,
            31408468,
            31411926,
            31398584,
            31404957,
            31405002,
            31406473
        ]
    },
    "name": "F. High Cry",
    "statement": "Rick and Morty like to go to the ridge High Cry for crying loudly there\r\nis an extraordinary echo. Recently they discovered an interesting\r\nacoustic characteristic of this ridge: if Rick and Morty begin crying\r\nsimultaneously from different mountains, their cry would be heard\r\nbetween these mountains up to the height equal the bitwise OR of\r\nmountains they’ve climbed and all the mountains between them. Bitwise OR\r\nis a binary operation which is determined the following way. Consider\r\nrepresentation of numbers and in binary numeric system (probably with\r\nleading zeroes) and . Then is defined following way: , where , if or ,\r\nand otherwise. In the other words, digit of bitwise OR of two numbers\r\nequals zero if and only if digits at corresponding positions is both\r\nnumbers equals zero. For example bitwise OR of numbers and equals . In\r\nprogramming languages C/C++/Java/Python this operation is defined as ,\r\nand in Pascal as .Help Rick and Morty calculate the number of ways they\r\ncan select two mountains in such a way that if they start crying from\r\nthese mountains their cry will be heard above these mountains and all\r\nmountains between them. More formally you should find number of pairs\r\nand () such that bitwise OR of heights of all mountains between and\r\n(inclusive) is larger than the height of any mountain at this interval.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define ll long long\nusing namespace std;\n\nvector<int> a;\nvector<vector<int>> t;\n\nvoid build() {\n    int n = a.size();\n    int lg = 0;\n    while ((1 << lg) < n)\n        ++lg;\n    t.resize(n, vector<int>(lg, 0));\n    for (int j = 0; j < lg; ++j) {\n        for (int i = 0; i < n; ++i) {\n            if (j && i + (1 << (j - 1)) < n)\n                t[i][j] = t[i][j - 1] | t[i + (1 << (j - 1))][j - 1];\n            else\n                t[i][j] = a[i];\n        }\n    }\n}\n\nint get(int l, int r) {\n    int n = r - l + 1;\n    int lg = 0;\n    while ((1 << lg) < n)\n        ++lg;\n    --lg;\n    return t[l][lg] | t[r - (1 << lg) + 1][lg];\n}\n\nint main() {\n#ifdef __APPLE__\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int n;\n    scanf(\"%d\", &n);\n    a.resize(n);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%d\", &a[i]);\n    build();\n    map<int, vector<tuple<int, int, int>>> mp;\n    for (int i = 0; i < n; ++i) {\n        int tl = 0, tr = i + 1;\n        while (tr - tl > 1) {\n            int tm = (tl + tr) / 2;\n            if (get(i - tm, i) == a[i])\n                tl = tm;\n            else\n                tr = tm;\n        }\n        int tl2 = 0, tr2 = n - i;\n        while (tr2 - tl2 > 1) {\n            int tm = (tl2 + tr2) / 2;\n            if (get(i, i + tm) == a[i])\n                tl2 = tm;\n            else\n                tr2 = tm;\n        }\n        mp[a[i]].push_back(make_tuple(i - tl, i, i + tl2));\n    }\n    ll ans = n * 1ll * (n + 1) / 2;\n    for (auto it : mp) {\n        int prev = -1;\n        for (auto it2 : it.second) {\n            int len1 = max(0, get<1>(it2) - max(prev, get<0>(it2)) + 1);\n            int len2 = max(0, get<2>(it2) - get<1>(it2) + 1);\n            ans -= len1 * 1ll * len2;\n            prev = max(prev, get<1>(it2) + 1);\n        }\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "data structures"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. High Cry.json",
    "editorial_link": "https://codeforces.com//blog/entry/55233",
    "editorial": "First we find for each element the nearest element on the left and on the right more than it. It can be done by many ways, for example using stack.\n\nThen you find for each element x the nearest on the left and on the right element y so that x|y?>?x. For this note that in y must be some bit set, which is not set in x. So you can just pass from left to the right (and then from right to the left) along the array, calculating goi  the nearest on the left (on the right) element in which the bit i equals 1.\n\nWe fix the mountain which will be the highest on the segment from the answer (if the heights are equal  the most left, for example). Then the segment must be completely nested in the segment on which the given mountain is the highest and must cross at least one element, OR with which our element is greater than the element itself.\n\nThis solution works in O(n)?+?O(nlogc)?+?O(n)?=?O(nlogc).",
    "hint": []
}