{
    "link": "https://codeforces.com//contest/1185/problem/G1",
    "problemId": "360327",
    "problem_idx": "G1",
    "shortId": "1185G1",
    "contest_number": "1185",
    "problem_submissions": {
        "G2": [
            55788875,
            55790981,
            55805220,
            55805211,
            55805181,
            55805110,
            55805072,
            55792804,
            55790893,
            55798346,
            55839723
        ],
        "F": [
            55780405,
            55784226,
            55779797,
            55790435,
            55783948,
            55774453,
            55775306,
            55787301,
            55787239,
            55780510,
            55776902,
            55778347,
            55775969,
            55787695,
            55787943,
            55780581,
            55779230,
            55782760,
            55786882,
            55789076
        ],
        "G1": [
            55775590,
            55777444,
            55773026,
            55772290,
            55770464,
            55777149,
            55766017,
            55779783,
            55780697,
            55775163,
            55781086,
            55781273,
            55783475,
            55770087,
            55781658,
            55783057,
            55787570,
            55776249,
            55782788,
            55780634
        ],
        "E": [
            55773709,
            55771675,
            55770836,
            55777430,
            55780309,
            55781282,
            55788835,
            55774037,
            55773565,
            55789637,
            55786175,
            55787728,
            55781452,
            55776381,
            55777447,
            55775569,
            55774578,
            55788543,
            55772414,
            55777859
        ],
        "D": [
            55764805,
            55765160,
            55763333,
            55764561,
            55767970,
            55767077,
            55763517,
            55765643,
            55766955,
            55766963,
            55766612,
            55765495,
            55757519,
            55767392,
            55769540,
            55767234,
            55769033,
            55770802,
            55765015,
            55772029
        ],
        "C1": [
            55760617,
            55761184,
            55760176,
            55760890,
            55765300,
            55759868,
            55766915,
            55759835,
            55763415,
            55762227,
            55760086,
            55765957,
            55763972,
            55762753,
            55765982,
            55761920,
            55763575,
            55762040,
            55779786,
            55761686
        ],
        "C2": [
            55760448,
            55761127,
            55759974,
            55760758,
            55765213,
            55759811,
            55767080,
            55761513,
            55763197,
            55762148,
            55760260,
            55762050,
            55763657,
            55765005,
            55765960,
            55761757,
            55779613,
            55763567,
            55779964,
            55761855
        ],
        "B": [
            55757432,
            55757400,
            55757118,
            55756714,
            55760856,
            55756979,
            55757746,
            55757494,
            55758775,
            55757209,
            55756807,
            55758385,
            55768633,
            55758969,
            55760948,
            55757700,
            55756899,
            55760037,
            55759228,
            55756676
        ],
        "A": [
            55755278,
            55754991,
            55754916,
            55754981,
            55758172,
            55754952,
            55755176,
            55754923,
            55755064,
            55755117,
            55755166,
            55754951,
            55770975,
            55755955,
            55755304,
            55755094,
            55755216,
            55755238,
            55756678,
            55754929
        ]
    },
    "name": "G1. Playlist for Polycarp  easy version ",
    "statement": "Polycarp loves to listen to music, so he never leaves the player, even\r\non the way home from the university. Polycarp overcomes the distance\r\nfrom the university to the house in exactly T minutes.In the player,\r\nPolycarp stores n songs, each of which is characterized by two\r\nparameters: t_i and g_i, where t_i is the length of the song in minutes\r\n(1\r\nle t_i\r\nle 15), g_i is its genre (1\r\nle g_i\r\nle 3).Polycarp wants to create such a playlist so that he can listen to\r\nmusic all the time on the way from the university to his home, and at\r\nthe time of his arrival home, the playlist is over. Polycarp never\r\ninterrupts songs and always listens to them from beginning to end. Thus,\r\nif he started listening to the i-th song, he would spend exactly t_i\r\nminutes on its listening. Polycarp also does not like when two songs of\r\nthe same genre play in a row (i.e. successively/adjacently) or when the\r\nsongs in his playlist are repeated.Help Polycarpus count the number of\r\ndifferent sequences of songs (their order matters), the total duration\r\nis exactly T, such that there are no two consecutive songs of the same\r\ngenre in them and all the songs in the playlist are different.\r\n",
    "solutions": [
        "///Mn kotr el labawy mb2t4 nawy\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nusing ll = long long;\nvector<pair<int,int>> go[26];\nint dp[300][1<<15][4];\nint g[15], t[15], n, T;\nint solve(int curTime, int mask, int lstG){\n  if(curTime>T)return 0;\n  if(curTime == T)\n    return 1;\n  int &ret = dp[curTime][mask][lstG];\n  if(~ret)\n    return ret;\n  ret = 0;\n  for(int k = 0;k < n; k++)\n  if(mask>>k&1^1){\n    if(g[k]!=lstG){\n      ret+=solve(curTime+t[k],mask|(1<<k),g[k]);\n      if(ret>=MOD)ret-=MOD;\n    }\n  }\n  return ret;\n}\nint main(){\n  ios_base::sync_with_stdio(0);cin.tie(0);\n\n  cin >> n >> T;\n  memset(dp,-1,sizeof dp);\n  for(int i = 0; i < n; i++){\n    cin >> t[i] >> g[i];  --g[i];\n  }\n\n  cout << solve(0,0,3) << '\\n';\n\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G1. Playlist for Polycarp  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/67829",
    "editorial": "Consider all genres are from to instead of from to . It will be easier\r\nto deal with 0-based indices.Let\u00e2\u0080\u0099s use DP to calculate , where () is a\r\nbinary mask of songs and is a genre of the last song. The value means\r\nthe number of ways to order songs corresponding to the in such a way\r\nthat any neighboring (adjacent) songs have different genres and the\r\ngenre of the last song is .DP to find the array is follows. It is easy\r\nto see that if is calculated correctly, you iterate over all possible\r\nsongs to append (such songs should be out of and a genre different from\r\n). In this case, you should increase by . Here is the sample code to\r\ncalculate all cells of :Here we use some fake genre to initialize DP (it\r\ncan precede any real genre).To find the answer, just take into account\r\nonly such masks that the correspondent total duration is exactly . Just\r\nfind the sum of all such that the correspondent total duration is\r\nexactly . You can do it at the same time with DP calculations. So the\r\nresulting code is:The total complexity is .\r\n"
}