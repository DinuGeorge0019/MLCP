{
    "link": "https://codeforces.com//contest/1501/problem/F",
    "problemId": "922991",
    "problem_idx": "F",
    "shortId": "1501F",
    "contest_number": "1501",
    "problem_submissions": {
        "E": [
            109941376,
            109875512,
            109883789,
            110105518,
            110105287
        ],
        "F": [
            109904857
        ],
        "A": [
            109878442,
            109847988,
            109846729,
            109846494,
            109846135,
            109845267,
            109845587,
            109847199,
            109845456,
            109847603,
            109846645,
            109853330,
            109847527,
            109845680,
            109862040,
            109861437,
            109857820,
            109847064,
            109879578,
            109846519
        ],
        "B": [
            109859119,
            109845806,
            109857469,
            109847916,
            109848937,
            109845741,
            109938795,
            109847183,
            109850677,
            109848222,
            109850447,
            109858630,
            109845453,
            109850407,
            109847950,
            109859017,
            109850474,
            109855074,
            109848387,
            109851675,
            109849198
        ],
        "D": [
            109857126,
            109874773,
            109867593,
            109877645,
            109872691,
            109883837,
            109870581,
            109889646,
            109873833,
            109880027,
            109879853,
            109876481,
            109884289,
            109877446,
            109871324,
            109884869,
            109884357,
            109879548,
            109886127,
            109876946,
            109883128
        ],
        "C": [
            109846358,
            109849688,
            109852611,
            109851798,
            109861330,
            109852150,
            109856203,
            109859435,
            109862259,
            109860307,
            109858003,
            109857809,
            109860809,
            109860157,
            109856014,
            109855070,
            109852660,
            109851031,
            109863843,
            109867505
        ]
    },
    "name": "F. Tiles for Bathroom",
    "statement": "Kostya is extremely busy: he is renovating his house! He needs to hand\r\nwallpaper, assemble furniture throw away trash.Kostya is buying tiles\r\nfor bathroom today. He is standing in front of a large square stand with\r\ntiles in a shop. The stand is a square of n\r\ntimes n cells, each cell of which contains a small tile with color c_{i,\r\n,j}. The shop sells tiles in packs: more specifically, you can only buy\r\na subsquare of the initial square.A subsquare is any square part of the\r\nstand, i. e. any set S(i_0, j_0, k) =\r\n{c_{i,\r\n,j}\r\n|\r\ni_0\r\nle i < i_0 + k, j_0\r\nle j < j_0 + k\r\n} with 1\r\nle i_0, j_0\r\nle n - k + 1.Kostya still does not know how many tiles he needs, so he\r\nconsiders the subsquares of all possible sizes. He doesn’t want his\r\nbathroom to be too colorful. Help Kostya to count for each k\r\nle n the number of subsquares of size k\r\ntimes k that have at most q different colors of tiles. Two subsquares\r\nare considered different if their location on the stand is different.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst long long M=75161927681ll;\nconst int N=1505,E=524288;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nint n,m,i,j,a,ans[N][N],as[N],mp,q,k,s[N][N];\nstruct str{\n\tint x,y;\n}g[N*N*11];\nint vis[N][N][10];\nbool Find(int x,int y,int f)\n{\n\tfor(int j=0;j<10&&vis[x][y][j];++j)\n\t\tif(vis[x][y][j]==f)\n\t\t\treturn true;\n\treturn false;\n}\nvoid P(int x,int y,int f)\n{\n\tint i;\n\tfor(i=0;vis[x][y][i];++i);\n\tvis[x][y][i]=f;\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\tgi(n),gi(q);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tgi(a);\n\t\t\tg[++k]={(i-1)*n+j,a};\n\t\t\tP(i,j,a);\n\t\t\ts[i][j]=1;\n\t\t}\n\tint mp=1,nx=k;\n\tfor(i=1;i<=k;++i)\n\t{\n\t\tif(i>nx)\n\t\t{\n\t\t\tnx=k;\n\t\t\t++mp;\n\t\t}\n\t\tstr x;\n\t\tx.x=(g[i].x+n-1)/n,x.y=(g[i].x-1)%n+1;\n\t\tif(s[x.x+1][x.y]<=q&&x.x<n&&!Find(x.x+1,x.y,g[i].y))\n\t\t{\n\t\t\tif(s[x.x+1][x.y]<q)\n\t\t\t\tP(x.x+1,x.y,g[i].y);\n\t\t\telse\n\t\t\t\tans[x.x+1][x.y]=mp+1;\n\t\t\t++s[x.x+1][x.y];\n\t\t\tg[++k]={x.x*n+x.y,g[i].y};\n\t\t}\n\t\tif(s[x.x][x.y+1]<=q&&x.y<n&&!Find(x.x,x.y+1,g[i].y))\n\t\t{\n\t\t\tif(s[x.x][x.y+1]<q)\n\t\t\t\tP(x.x,x.y+1,g[i].y);\n\t\t\telse\n\t\t\t\tans[x.x][x.y+1]=mp+1;\n\t\t\t++s[x.x][x.y+1];\n\t\t\tg[++k]={(x.x-1)*n+x.y+1,g[i].y};\n\t\t}\n\t\tif(s[x.x+1][x.y+1]<=q&&x.x<n&&x.y<n&&!Find(x.x+1,x.y+1,g[i].y))\n\t\t{\n\t\t\tif(s[x.x+1][x.y+1]<q)\n\t\t\t\tP(x.x+1,x.y+1,g[i].y);\n\t\t\telse\n\t\t\t\tans[x.x+1][x.y+1]=mp+1;\n\t\t\t++s[x.x+1][x.y+1];\n\t\t\tg[++k]={x.x*n+x.y+1,g[i].y};\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tif(ans[i][j]==0)\n\t\t\t\tans[i][j]=min(i,j)+1;\n\t\t\tans[i][j]=min(ans[i][j],min(i,j)+1);\n\t\t\t--as[ans[i][j]];\n\t\t\t++as[1];\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tas[i]=as[i-1]+as[i];\n\t\tprintf(\"%d\\n\",as[i]);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "two pointers"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Tiles for Bathroom.json",
    "editorial_link": "https://codeforces.com//blog/entry/88591",
    "editorial": "Let's denote ansi,j\n as max \"good\" subsquare side size with left top angle at (i,j)\n cell. It's obvious that every subsquare with side less than ansi,j\n is \"good\" too. So we need to find ansi,j\n and then print answer for k-size side as ?x=kn|{(i,j) | ansi,j=k}\n. This value can be found with partial sums on count array of ansi,j\n.\n\nNow we need to calculate ansi,j\n. Let's notice that ansi,j+1?ansi,j?1\n, because (i,j+1)\n-th square is inside of (i,j)\n square if it's side is longer than 1. So, we can use amortized algorithm of sequential increase square's side. Every time when we can increase ansi,j\n we will do it, then we will go to calculating ansi,j+1\n. Using linear algorithm to check if new square's size is \"good\", we will get O(n3)\n solution, which is not effective enough, but can be optimized.\n\nNow let's use small constraints for q\n. For each (i,j)\n cell we will precalc array colorsi,j\n, which will have (q+1)\n nearest colors in line (i?,j),i??i\n. For each color, we will keep it's earliest occurrence It can be calculated in O(n2q)\n, because colorsi,j=colorsi,j+1?ci,j\n. If ci,j\n exists in colorsi,j\n, we must change earliest occurrence. If it isn't, we should delete the most far color, then insert the current one. All values can be keeped with increasing left occurrence in O(q)\n for each cell.\n\nLast step  we can merge colorsi,j, , colorsi+m?1,j\n in O(mq)\n  it will be the array of q+1\n values corresponding for earliest colors in line of width m\n. Merging two lines is almost like merge of two sorted arrays  it is used to find q+1\n minimal left occurrences. Maximal \"good\" width can be found as left occurrence of (q+1)\n-th elementh minus j\n.\n\nNow we need to unite some rows in a structure and merge lines for current square, then erase first row and repeat the process. The structure can be realized as queue on two stacks, each of whose is keeping merge value of all lines in itself. ",
    "hint": []
}