{
    "link": "https://codeforces.com//contest/1732/problem/C2",
    "problemId": "1601557",
    "problem_idx": "C2",
    "shortId": "1732C2",
    "contest_number": "1732",
    "problem_submissions": {
        "A": [
            177780757,
            177610358,
            177608551,
            177606643,
            177607169,
            177610084,
            177606577,
            177608412,
            177606634,
            177606927,
            177606608,
            177607362,
            177606772,
            177606726,
            177606713,
            177607069,
            177607097,
            177611108,
            177606918,
            177704415,
            177608226,
            177608992
        ],
        "E": [
            177657016,
            177656202,
            177633902,
            177640667,
            177803227,
            177634482,
            219606714,
            177713292,
            205728264
        ],
        "D2": [
            177641910,
            177631345,
            177624639,
            177622507,
            177657720,
            177627306,
            177634600,
            177636897,
            177705044,
            177639536,
            177633383,
            177633472,
            177633356,
            177632157,
            177640421,
            177640870,
            177713072,
            177632770,
            177633150,
            177631372,
            177704515,
            177639496,
            177628055
        ],
        "C2": [
            177632291,
            177641962,
            177622438,
            177615256,
            177628405,
            177620951,
            177620108,
            177616118,
            177614696,
            177620919,
            177623972,
            177616635,
            177637052,
            177635166,
            177620867,
            178222629,
            177623840,
            177623959,
            177628626,
            177704465,
            177632045,
            177631184
        ],
        "D1": [
            177621374,
            177621523,
            177609368,
            177617748,
            177635005,
            177615122,
            177622111,
            177619777,
            177625112,
            177625655,
            177620912,
            177619034,
            177613806,
            177616102,
            177629698,
            177628519,
            177632466,
            177625833,
            177704487,
            177616074,
            177626081
        ],
        "C1": [
            177616773,
            177634647,
            177613208,
            177615318,
            177628507,
            177619693,
            177620176,
            177616207,
            177614603,
            177613000,
            177624015,
            177616698,
            177626783,
            177614045,
            177620826,
            177623767,
            177623763,
            177621443,
            177704454,
            177618806,
            177621758
        ],
        "B": [
            177611173,
            177612224,
            177608250,
            177608561,
            177614708,
            177608123,
            177608457,
            177614546,
            177608888,
            177607945,
            177608753,
            177607801,
            177610965,
            177607589,
            177608533,
            177609886,
            177611017,
            177610279,
            177704436,
            177611009,
            177609323
        ]
    },
    "name": "C2. Sheikh  Hard Version ",
    "statement": "You are given an array of integers a_1, a_2,\r\nldots, a_n.The cost of a subsegment of the array [l, r], 1\r\nleq l\r\nleq r\r\nleq n, is the value f(l, r) =\r\noperatorname{sum}(l, r) -\r\noperatorname{xor}(l, r), where\r\noperatorname{sum}(l, r) = a_l + a_{l+1} +\r\nldots + a_r, and\r\noperatorname{xor}(l, r) = a_l\r\noplus a_{l+1}\r\noplus\r\nldots\r\noplus a_r (\r\noplus stands for bitwise XOR).You will have q queries. Each query is\r\ngiven by a pair of numbers L_i, R_i, where 1\r\nleq L_i\r\nleq R_i\r\nleq n. You need to find the subsegment [l, r], L_i\r\nleq l\r\nleq r\r\nleq R_i, with maximum value f(l, r). If there are several answers, then\r\namong them you need to find a subsegment with the minimum length, that\r\nis, the minimum value of r - l + 1.\r\n",
    "solutions": [
        "#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c=='-')f=-1;\n\t\tfor(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(;c>='0'&&c<='9';c=gc())\n\t\t\tx=x*10+(c-'0');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c='\\n'){\n\t\tif(x<0)pc('-'),x=-x;\n\t\tif(x==0) pc('0'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+'0';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint t,n,q,a[100005],nxt[100005];\nLL s[100005],s2[100005];\nsigned main(){\n\tsrand(time(0));\n\tgi(t);\n\twhile(t--){\n\t\tgi(n),gi(q);\n\t\tfor(int i=1;i<=n;i++)gi(a[i]),s[i]=s[i-1]^a[i],s2[i]=s2[i-1]+a[i];\n\t\tnxt[n+1]=n+1;\n\t\tfor(int i=n;i;i--){\n\t\t\tif(a[i])nxt[i]=i;\n\t\t\telse nxt[i]=nxt[i+1];\n\t\t}\n\t\twhile(q--){\n\t\t\tint L,R;\n\t\t\tgi(L),gi(R);\n\t\t\tif(nxt[L]>R){pi(L,' ');pi(L,'\\n');continue;}\n\t\t\tint ansl=-1,ansr=-1;\n\t\t\tLL mx=s2[R]-s2[L-1]-(s[R]^s[L-1]);\n\t\t\tfor (int x=nxt[L];x<=R;x=nxt[x+1]){\n\t\t\t\tLL now=s2[R]-s2[x-1]-(s[R]^s[x-1]);\n    \t\t\tif (now!=mx) break;\n\t\t\t\tint l=x,r=R,ans=-1;\n\t\t\t\twhile(l<=r){\n\t\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\t\tLL val=s2[mid]-s2[x-1]-(s[mid]^s[x-1]);\n\t\t\t\t\tif(val==mx)ans=mid,r=mid-1;\n\t\t\t\t\telse l=mid+1;\n\t\t\t\t}\n\t\t\t\tif(ans!=-1){\n\t\t\t\t\tif(ansl==-1)ansl=x,ansr=ans;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(ans-x+1<ansr-ansl+1)\n\t\t\t\t\t\t\tansl=x,ansr=ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpi(ansl,' ');\n\t\t\tpi(ansr,'\\n');\n\t\t}\n\t}\n\treturn 0;\n} \n/*\n错误的，偏激的，极右翼的，非马恩主义的，女权的，失败的，人民日报的，乐的！ \n文明之美看东方\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C2. Sheikh  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/108327",
    "editorial": "Note that . To prove this fact, letâs see how the sum and xor change\r\nwhen the element is added. The sum will increase by , but cannot\r\nincrease by more than . From this we obtain that the maximum value of is\r\nreached on the entire subsegment.Next, letâs see in which case changes\r\nexactly by , because if it changes by a smaller value, then will be\r\nstrictly less than . The value of will change exactly by if all 1 bits\r\nof were zeros in the current . In fact, this means that if we consider\r\nthe first element, then at least one of the bits will occur twice, and\r\nthus the value of the function will become smaller.Letâs put all these\r\nfacts together: we can remove at most non-zero element from the\r\nbeginning and end of the subsegment. Then letâs just iterate over how\r\nmany non-zero elements we remove on the prefix and suffix (their\r\npositions can be found using binary search) and using prefix sums and\r\n-s, calculate the value on this subsegment.\r\n",
    "hint": []
}