{
    "link": "https://codeforces.com//contest/1694/problem/E",
    "problemId": "1430898",
    "problem_idx": "E",
    "shortId": "1694E",
    "contest_number": "1694",
    "problem_submissions": {
        "E": [
            160856186,
            160866174,
            160873008,
            160869335,
            160868951,
            160877330,
            160898676,
            160877174,
            160875442,
            160876502,
            160879470,
            160875237,
            160876355,
            160882396,
            160879879,
            160879629,
            160876481,
            160881373,
            160884964,
            160881275
        ],
        "D": [
            160848272,
            160842517,
            160849905,
            160853063,
            160857057,
            160853921,
            160854624,
            160847127,
            160845187,
            160855341,
            160850688,
            160860686,
            160857001,
            160853657,
            160862452,
            160862852,
            160864038,
            160855376,
            160858063
        ],
        "C": [
            160836570,
            160829494,
            160839678,
            160844593,
            160847177,
            160836731,
            160843728,
            160843693,
            160838092,
            160845965,
            160845179,
            160854286,
            160843446,
            160844276,
            160856430,
            160857207,
            160844960,
            160846963,
            160849978
        ],
        "B": [
            160832238,
            160835941,
            160831844,
            160834416,
            160835663,
            160829339,
            160834030,
            160840102,
            160851072,
            160836730,
            160864814,
            160845534,
            160830377,
            160835010,
            160833897,
            160845509,
            160927414,
            160837907,
            160860824,
            160841779
        ],
        "A": [
            160832046,
            160833611,
            160826245,
            160824355,
            160825264,
            160825514,
            160825648,
            160826360,
            160852110,
            160825530,
            160855429,
            160829525,
            160824626,
            160825478,
            160825695,
            160824627,
            160922182,
            160921765,
            160830254,
            160825318,
            160825557
        ],
        "F": [
            160914915
        ]
    },
    "name": "E. Keshi in Search of AmShZ",
    "statement": "AmShZ has traveled to Italy from Iran for the Thom Yorke concert. There\r\nare n cities in Italy indexed from 1 to n and m roads indexed from 1 to\r\nm. Initially, Keshi is located in the city 1 and wants to go to AmShZ\u2019s\r\nhouse in the city n. Since Keshi doesn\u2019t know the map of Italy, AmShZ\r\nhelps him to see each other as soon as possible.In the beginning of each\r\nday, AmShZ can send one of the following two messages to Keshi: AmShZ\r\nsends the index of one road to Keshi as a road. Then Keshi will\r\nunderstand that he should never use that road and he will remain in his\r\ncurrent city for the day. AmShZ tells Keshi to move. Then, Keshi will\r\nrandomly choose one of the cities reachable from his current city and\r\nmove there. (city B is reachable from city A if there\u2019s an out-going\r\nroad from city A to city B which hasn\u2019t become yet). If there are no\r\nsuch cities, Keshi will remain in his current city.Note that AmShZ\r\nalways knows Keshi\u2019s current location. AmShZ and Keshi want to find the\r\nsmallest possible integer d for which they can make sure that they will\r\nsee each other after at most d days. Help them find d.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\ntemplate <typename Fun>\nstruct y_combinator {\n    const Fun fun;\n\n    explicit y_combinator(const Fun&& fun) : fun(std::forward<const Fun>(fun)) {}\n\n    template <typename... Args>\n    auto operator()(Args&&... args) const {\n        return fun(std::ref(*this), std::forward<Args>(args)...);\n    }\n};\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n), _g(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        _g[v].push_back(u);\n    }\n    vector<int> dist(n, n + m);\n    vector<int> count(n);\n    for (int i = 0; i < n; ++i) {\n        count[i] = g[i].size();\n    }\n    dist[n - 1] = 0;\n    set<pair<int, int>> s;\n    s.insert({0, n - 1});\n    while (!s.empty()) {\n        int v = s.begin()->second;\n        s.erase(s.begin());\n        for (auto u : _g[v]) {\n            count[u]--;\n        }\n        for (auto u : _g[v]) {\n            if (dist[u] > dist[v] + count[u] + 1) {\n                s.erase({dist[u], u});\n                dist[u] = dist[v] + count[u] + 1;\n                s.insert({dist[u], u});\n            }\n        }\n    }\n    cout << dist[0] << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    // cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Keshi in Search of AmShZ.json",
    "editorial_link": "https://codeforces.com//blog/entry/103952",
    "editorial": "Define disv\n as the minimum number of days needed to reach city n\n from city v\n. disn=0\n.\n\nWe have to assume that Keshi will always choose the worst reachable city, that is the city with maximum dis\n.\n\nFor each node v\n we kind of have to choose nxtv\n and block all neighbors(outgoing edges) with a distance more than disnxtv\n.\n\nWe will use Dijkstra's algorithm.\n\nNote that in Dijkstra's algorithm we mark the nodes in increasing order of dis\n.\n\nAt each step get the node v\n with the minimum dis\n. For each node u\n that there is an edge from u\n to v\n, calculate disu\n if nxtu\n was v\n. You know the number of edges you have to block since the neighbors with greater dis\n are the ones that are not marked yet.\n\nTime complexity: O(nlogn)"
}