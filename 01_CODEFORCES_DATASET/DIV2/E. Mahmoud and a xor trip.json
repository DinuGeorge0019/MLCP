{"link": "https://codeforces.com//contest/766/problem/E", "problemId": "92735", "problem_idx": "E", "shortId": "766E", "contest_number": "766", "problem_submissions": {"D": [24505946, 24500916, 24504908, 24507791, 24507596, 24502515, 24505444, 24508821, 24506093, 24509131, 24508400, 24506164, 24508411, 24506236, 24509954, 24506157, 24500663, 24511147, 24509915, 24510742, 24507071], "C": [24503002, 24497705, 24503645, 24497245, 24504415, 24507920, 24498510, 24499723, 24502316, 24500439, 24497520, 24497973, 24498376, 24502187, 24500765, 24500712, 24509044, 24499242, 24501478, 24510759], "E": [24499598, 24503926, 24499034, 24503749, 24499107, 24506022, 24509883, 24505215, 24508282, 24506448, 24503360, 24508753, 24506776, 24509196, 24506537, 24510465, 24506832, 24511136, 24508039, 24506667, 24509589], "B": [24494141, 24493611, 24500716, 24498345, 24502090, 24496129, 24493849, 24494351, 24495688, 24493721, 24507808, 24494240, 24493512, 24496420, 24496210, 24495834, 24507882, 24494117, 24496757, 24494993], "A": [24493013, 24492877, 24500045, 24499173, 24500116, 24494575, 24495318, 24492979, 24492967, 24492862, 24493192, 24492913, 24494460, 24494158, 24494086, 24507606, 24492997, 24493480]}, "name": "E. Mahmoud and a xor trip", "statement": "Mahmoud and Ehab live in a country with cities numbered from to and\r\nconnected by undirected roads. It\u2019s guaranteed that you can reach any\r\ncity from any other using these roads. Each city has a number attached\r\nto it.We define the distance from city to city as the of numbers\r\nattached to the cities on the path from to . In other words if values\r\nattached to the cities on the path from to form an array of length then\r\nthe distance between them is , where is bitwise operation.Mahmoud and\r\nEhab want to choose two cities and make a journey from one to another.\r\nThe index of the start city is always less than or equal to the index of\r\nthe finish city (they may start and finish in the same city and in this\r\ncase the distance equals the number attached to that city). They can\u2019t\r\ndetermine the two cities so they try every city as a start and every\r\ncity with greater index as a finish. They want to know the total\r\ndistance between all pairs of cities.\r\n", "solutions": ["#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)\n#define np(v) next_permutation(v.begin(), v.end())\n#define pll pair < long long, long long>\n#define all(a) a.begin(), a.end()\n#define ull unsigned long long\n#define pii pair < int, int >\n#define sz(a) (int)a.size()\n#define sqr(x) ((x) * (x))\n#define y1 stupid_cmath\n#define vi vector <int>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define f first\n#define s second\n\nconst int inf = (int)1e9;\nconst int mod = inf + 7;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\n\nll n, a[100100], b[100100];\nll cnt[100100][2];\nll sum;\nvector <int> g[100100];\n\nvoid dfs(int v, int pr = -1){\n    cnt[v][0] = cnt[v][1] = 0;\n    cnt[v][b[v]]++;\n    for(int i = 0; i < g[v].size(); ++i){\n        int to = g[v][i];\n        if(to != pr){\n            dfs(to, v);\n            sum += cnt[to][0] * cnt[v][1] + cnt[to][1] * cnt[v][0];\n            cnt[v][b[v]] += cnt[to][0];\n            cnt[v][b[v] ^ 1] += cnt[to][1];\n        }\n    }\n    sum += b[v];\n}\n\nint main(){\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cin >> n;\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n    }\n    for(int i = 2, u, v; i <= n; ++i){\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll ans = 0;\n    for(int i = 0; i <= 20; ++i){\n        sum = 0;\n        for(int j = 1; j <= n; ++j){\n            if(a[j] & (1 << i)){\n                b[j] = 1;\n            }else{\n                b[j] = 0;\n            }\n        }\n        dfs(1);\n        ans += (sum << i);\n    }\n    cout << ans << endl;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "data structures", "dfs and similar", "dp", "math", "trees"], "dificulty": "2100", "interactive": false}