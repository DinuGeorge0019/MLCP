{
    "link": "https://codeforces.com//contest/1199/problem/E",
    "problemId": "380945",
    "problem_idx": "E",
    "shortId": "1199E",
    "contest_number": "1199",
    "problem_submissions": {
        "E": [
            58030586,
            58021734,
            58025826,
            58022450,
            58018815,
            58018132,
            58016064,
            58035343,
            58034869,
            58017816,
            58024170,
            58025918,
            58022291,
            58023170,
            58022937,
            58024351,
            58028105
        ],
        "F": [
            58024830,
            58028686,
            58018020,
            58017115,
            58028245,
            58019034,
            58384931,
            58013729,
            58065279,
            58027365,
            58334987,
            58059871,
            58026310
        ],
        "D": [
            58011622,
            58006050,
            58005239,
            58009886,
            58003558,
            58013213,
            58006910,
            58023637,
            58004292,
            58010802,
            58010127,
            58010591,
            58010277,
            58011062,
            58011952,
            58012323,
            58015144,
            58009223,
            58018000
        ],
        "C": [
            58003286,
            58015626,
            58038871,
            58045412,
            58007604,
            58002586,
            58019533,
            58011071,
            58005193,
            58006733,
            58004437,
            58004399,
            58006254,
            58008729,
            58007961,
            58005653,
            58003369,
            58011620
        ],
        "B": [
            57997198,
            58010291,
            57996992,
            57996941,
            58045445,
            57999240,
            57998882,
            57996286,
            57999211,
            58000305,
            58000178,
            58000443,
            57996371,
            57996748,
            57996780,
            57999052,
            57996536,
            57997898,
            57997650,
            58000545
        ],
        "A": [
            57995512,
            58007859,
            57995725,
            57995380,
            57995192,
            57996027,
            57994975,
            57996866,
            57994742,
            57994764,
            57995474,
            57994875,
            57994979,
            57995233,
            57995511,
            57995009,
            57994816,
            57996166,
            57995838
        ]
    },
    "name": "E. Matching vs Independent Set",
    "statement": "You are given a graph with 3\r\ncdot n vertices and m edges. You are to find a matching of n edges, an\r\nindependent set of n vertices.A set of edges is called a matching if no\r\ntwo edges share an endpoint.A set of vertices is called an independent\r\nset if no two vertices are connected with an edge.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n\n#define isNum(a) (a >= '0' && a <= '9')\n#define SP putchar(' ')\n#define EL putchar('\\n')\n#define File(a) freopen(a \".in\", \"r\", stdin), freopen(a \".out\", \"w\", stdout)\n\ntemplate<class T>\ninline void read(T&);\ntemplate<class T>\ninline void write(const T&);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef const int& ci;\ntypedef std::pair<int, int> pii;\nconst int iinf = 2147483647;\nconst ll llinf = 9223372036854775807ll;\nusing std::min;\nusing std::max;\nusing std::abs;\nusing std::sort;\nconst int N = 300005;\nconst int M = 1000005;\n\nvoid add(int, int);\n\nint hed[N], nxt[M], to[M], id;\nint mat[N], cnt;\nbool vis[N];\n\nint main () {\n    int t;\n    read(t);\n    while (t--) {\n        int n, m;\n        read(n), read(m);\n        for (int i = 1; i <= 3 * n; ++i) {\n            hed[i] = vis[i] = 0;\n        }\n        id = 0;\n        for (int i = 1; i <= m; ++i) {\n            int u, v;\n            read(u), read(v);\n            add(u, v), add(v, u);\n        }\n        cnt = 0;\n        for (int i = 1; i <= 3 * n; ++i) {\n            if (vis[i]) {\n                continue;\n            }\n            for (int j = hed[i]; j; j = nxt[j]) {\n                int v = to[j];\n                if (vis[v]) {\n                    continue;\n                }\n                vis[v] = true;\n                vis[i] = true;\n                mat[++cnt] = (j + 1) >> 1;\n                break;\n            }\n        }\n        if (cnt >= n) {\n            puts(\"Matching\");\n            for (int i = 1; i <= n; ++i) {\n                write(mat[i]), SP;\n            }\n            EL;\n            continue;\n        }\n        int num = 3 * n - cnt * 2;\n        if (num >= n) {\n            puts(\"IndSet\");\n            cnt = 0;\n            for (int i = 1; i <= 3 * n && cnt < n; ++i) {\n                if (!vis[i]) {\n                    write(i), SP;\n                    ++cnt;\n                }\n            }\n            EL;\n            continue;\n        }\n        puts(\"Impossible\");\n    }\n    return 0;\n}\n\ntemplate<class T>\nvoid read(T &Re) {\n    T k = 0;\n    char ch = getchar();\n    int flag = 1;\n    while (!isNum(ch)) {\n        if (ch == '-') {\n            flag = -1;\n        }\n        ch = getchar();\n    }\n    while (isNum(ch)) {\n        k = (k << 1) + (k << 3) + ch - '0';\n        ch = getchar();\n    }\n    Re = flag * k;\n}\ntemplate<class T>\nvoid write(const T &Wr) {\n    if (Wr < 0) {\n        putchar('-');\n        write(-Wr);\n    } else {\n        if (Wr < 10) {\n            putchar(Wr + '0');\n        } else {\n            write(Wr / 10);\n            putchar((Wr % 10) + '0');\n        }\n    }\n}\n\nvoid add(int u, int v) {\n    nxt[++id] = hed[u];\n    hed[u] = id;\n    to[id] = v;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Matching vs Independent Set.json",
    "editorial_link": "https://codeforces.com/blog/entry/68812",
    "editorial": "Let's try to take edges to matching greedily in some order. If we can add an edge to the matching (both endpoints are not covered), then we take it. It is easy to see that all vertices not covered by the matching form an independent set  otherwise we would add an edge to the matching. Either matching or independent set has size at least n\n. Complexity  O(n+m)\n.",
    "hint": []
}