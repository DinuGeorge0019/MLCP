{"link": "https://codeforces.com//contest/116/problem/B", "problemId": "610", "problem_idx": "B", "shortId": "116B", "contest_number": "116", "problem_submissions": {"E": [700161, 701799, 701421, 702282, 700977, 704488, 701119], "D": [699566, 698442, 699880, 700164, 701655, 698834, 699735, 698841, 698890, 9443336, 709309, 699987, 699816, 700455, 699803, 699649, 699931, 699910], "C": [698001, 696869, 697453, 698296, 698175, 697132, 696265, 697608, 697369, 9442997, 698325, 697976, 696978, 697819, 697685, 698132, 697395, 698281], "B": [697389, 699259, 696737, 697208, 697213, 696507, 697595, 696839, 696682, 9442209, 697385, 697177, 698196, 696508, 698380, 697274, 696601, 696966], "A": [696282, 695857, 695773, 696139, 695925, 695792, 696656, 695824, 695837, 9442134, 696797, 695862, 696053, 695796, 695742, 696321, 695753, 695835]}, "name": "B. Little Pigs and Wolves", "statement": "Once upon a time there were several little pigs and several wolves on a\r\ntwo-dimensional grid of size . Each cell in this grid was either empty,\r\ncontaining one little pig, or containing one wolf.A little pig and a\r\nwolf are adjacent if the cells that they are located at share a side.\r\nThe little pigs are afraid of wolves, so there will be at most one wolf\r\nadjacent to each little pig. But each wolf may be adjacent to any number\r\nof little pigs.They have been living peacefully for several years. But\r\ntoday the wolves got hungry. One by one, each wolf will choose one of\r\nthe little pigs adjacent to it (if any), and eats the poor little pig.\r\nThis process is not repeated. That is, each wolf will get to eat at most\r\none little pig. Once a little pig gets eaten, it disappears and cannot\r\nbe eaten by any other wolf.What is the maximum number of little pigs\r\nthat may be eaten by the wolves?\r\n", "solutions": ["#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <numeric>\n \nusing namespace std;\n \nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n \n#define sz(c) int((c).size())\n#define all(c) (c).begin(), (c).end()\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define FORD(i,a,b) for (int i = int(b)-1; i >= (a); i--)\n#define FORIT(i,c) for (__typeof__((c).begin()) i = (c).begin(); i != (c).end(); i++)\n\nint M, N;\nstring grid[20];\n\nbool check(int i, int j) {\n\tif(i > 0 && grid[i-1][j] == 'P') return true;\n\tif(i < M-1 && grid[i+1][j] == 'P') return true;\n\tif(j > 0 && grid[i][j-1] == 'P') return true;\n\tif(j < N-1 && grid[i][j+1] == 'P') return true;\n\treturn false;\n}\n\nint main() {\n\tcin >> M >> N;\n\tFOR(i,0,M) cin >> grid[i];\n\tint ct = 0;\n\tFOR(i,0,M) FOR(j,0,N) {\n\t\tif(grid[i][j] == 'W' && check(i,j)) ct++;\n\t}\n\tcout << ct << endl;\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["greedy", "implementation"], "dificulty": "1100", "interactive": false}