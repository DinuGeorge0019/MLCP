{
    "link": "https://codeforces.com//contest/831/problem/E",
    "problemId": "114251",
    "problem_idx": "E",
    "shortId": "831E",
    "contest_number": "831",
    "problem_submissions": {
        "F": [
            28524412,
            28589075
        ],
        "E": [
            28518576,
            28519922,
            28516725,
            28518610,
            28517316,
            28518604,
            28514634,
            28517509,
            28512481,
            28519183,
            28520727,
            28519505,
            28520653,
            28522570,
            28522388,
            28519257,
            28516821,
            28521941,
            28520051,
            28517313
        ],
        "D": [
            28515659,
            28515412,
            28513332,
            28513652,
            28513411,
            28516483,
            28516655,
            28522155,
            28520115,
            28516173,
            28515154,
            28516779,
            28516912,
            28515110,
            28514947,
            28514700,
            28517868,
            28516879,
            28517907,
            28522125
        ],
        "C": [
            28513086,
            28513404,
            28511104,
            28512442,
            28514905,
            28512216,
            28520896,
            28511207,
            28520643,
            28514218,
            28513025,
            28512706,
            28513552,
            28512508,
            28511403,
            28520892,
            28521339,
            28514051,
            28515858,
            28520114
        ],
        "B": [
            28507101,
            28507693,
            28506648,
            28506753,
            28507510,
            28507533,
            28507834,
            28507930,
            28507062,
            28507463,
            28509384,
            28508411,
            28507824,
            28508253,
            28508638,
            28507559,
            28507917,
            28511079,
            28507613
        ],
        "A": [
            28506106,
            28506123,
            28506025,
            28506039,
            28506323,
            28506210,
            28506627,
            28506516,
            28506009,
            28506088,
            28508398,
            28506582,
            28506848,
            28506960,
            28507487,
            28506150,
            28506496,
            28507984,
            28506206
        ]
    },
    "name": "E. Cards Sorting",
    "statement": "Vasily has a deck of cards consisting of cards. There is an integer on\r\neach of the cards, this integer is between and , inclusive. It is\r\npossible that some cards have the same integers on them.Vasily decided\r\nto sort the cards. To do this, he repeatedly takes the top card from the\r\ndeck, and if the number on it equals the minimum number written on the\r\ncards in the deck, then he places the card away. Otherwise, he puts it\r\nunder the deck and takes the next card from the top, and so on. The\r\nprocess ends as soon as there are no cards in the deck. You can assume\r\nthat Vasily always knows the minimum number written on some card in the\r\nremaining deck, but doesn\u2019t know where this card (or these cards) is.You\r\nare to determine the total number of times Vasily takes the top card\r\nfrom the deck.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nint n;\nstruct pos{\n\tint x,y;\n}ps[100007];\nbool operator<(pos a,pos b){\n\treturn a.y!=b.y?a.y<b.y:a.x<b.x;\n}\nint bit[100007];\nvoid inc(int w,int a){\n\tfor(;w<=n;w+=w&-w)bit[w]+=a;\n}\nint sum(int w){\n\tint s=0;\n\tfor(;w;w-=w&-w)s+=bit[w];\n\treturn s;\n}\nint dis(int a,int b){\n\tif(a>b)return dis(a,n)+dis(0,b);\n//\tprintf(\"%d->%d\\n\",a,b);\n\treturn b-sum(b)-a+sum(a);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&ps[i].y),ps[i].x=i;\n\tstd::sort(ps+1,ps+n+1);\n\tint pw=0;\n\tlong long ans=0;\n\tfor(int i=1,j=1;j<=n;i=j){\n\t\tfor(;j<=n&&ps[i].y==ps[j].y;++j);\n\t\tint k=std::upper_bound(ps+i,ps+j,(pos){pw,ps[i].y})-ps;\n\t\tint l=ps[k==i?j-1:k-1].x;\n\t\tint r=ps[k==j?i:k].x;\n//\t\tprintf(\"%d[%d,%d]\\n\",ps[i].y,r,l);\n\t\tans+=dis(pw,r);\n\t\tans+=dis(r,l);\n\t\tpw=l;\n\t\tfor(int a=i;a<j;++a)inc(ps[a].x,1);\n\t}\n\tprintf(\"%I64d\\n\",ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Cards Sorting.json",
    "editorial_link": "https://codeforces.com//blog/entry/53302",
    "editorial": "First note that operation \"put a card under the deck\" is the same as \"stark viewing from the beginning when you reach the end\", and do not move cards anywhere.\n\nThen, let's proceed all cards with equal numbers on them at once. It's obvious that Vasily puts them away one after another. Let's denote the position where he was when he put the last card less than x be position p in the deck. Two cases are possible.\n\nIf all cards equal to x are after position p, then he looks all the cards until he takes the last card with x, and puts away all cards equal to x;\nOtherwise there is a card with x that is before p. In this case Valisy looks at all cards from p to the end, and after that \u0097 at all cards from the beginning of the deck to the last card with x that is before p.\nIt's easy to process both cases if we keep for each x positions of all cards with x from the top to the bottom of the deck. Aside of this we need any data structure that is capable of computing sum on a segment and changing a single value (we can store 1 for a position with a card in the deck, and 0 is the card is already put away). We can use segment tree or Fenwick tree for example."
}