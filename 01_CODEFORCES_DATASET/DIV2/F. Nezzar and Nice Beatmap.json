{
    "link": "https://codeforces.com//contest/1478/problem/F",
    "problemId": "879394",
    "problem_idx": "F",
    "shortId": "1478F",
    "contest_number": "1478",
    "problem_submissions": {
        "F": [
            105745770,
            105755730,
            105740257,
            105759758,
            105734600,
            105755284,
            105756717,
            105766844,
            105793777,
            105757168,
            105755750,
            105751368,
            105774495,
            105749168,
            105760060
        ],
        "E": [
            105741982,
            105745927,
            105765147,
            105765706,
            105765965,
            105763865,
            105754042,
            105761626,
            105739939,
            105721165,
            105766403,
            105749463,
            105750984,
            105763896,
            105756596,
            105752745
        ],
        "D": [
            105701384,
            105722470,
            105753195,
            105738392,
            105746684,
            105720945,
            105734191,
            105749589,
            105715391,
            105733991,
            105751898,
            105743147,
            105712944,
            105730170,
            105705577,
            106043703,
            105747710,
            105704995,
            105736139
        ],
        "C": [
            105694901,
            105704831,
            105695273,
            105720027,
            105742447,
            105744248,
            105740268,
            105734450,
            105693735,
            105690240,
            105751278,
            105716768,
            105739420,
            105702365,
            105732790,
            105719496,
            105717686,
            105735493,
            105713455
        ],
        "B": [
            105686332,
            105685165,
            105684581,
            105689777,
            105689090,
            105695004,
            105684674,
            105704956,
            105686767,
            105697452,
            105714810,
            105690830,
            105686870,
            105681347,
            105686702,
            105690335,
            105688451,
            105684176,
            105689461
        ],
        "A": [
            105679437,
            105677748,
            105676437,
            105679439,
            105676338,
            105678358,
            105795468,
            105681333,
            105678297,
            105686569,
            105679854,
            105679642,
            105677865,
            105676184,
            105678986,
            105680204,
            105677192,
            105687845,
            105679361
        ]
    },
    "name": "F. Nezzar and Nice Beatmap",
    "statement": "Nezzar loves the game osu!.osu! is played on beatmaps, which can be seen\r\nas an array consisting of points on a plane. A beatmap is called nice if\r\nfor any three consecutive points A,B,C listed in order, the angle\r\nbetween these three points, centered at B, is 90 degrees. Now Nezzar has\r\na beatmap of n points A_1,A_2,\r\nldots,A_n. Nezzar would like to reorder these n points so that the\r\nresulting beatmap is nice.Formally, you are required to find a\r\npermutation p_1,p_2,\r\nldots,p_n of integers from 1 to n, such that beatmap A_{p_1},A_{p_2},\r\nldots,A_{p_n} is nice. If it is impossible, you should determine it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 5050\n\nint n;\ntypedef long long ll;\nstruct pnt{\n\tint x, y;\n\tvoid in() {\n\t\tscanf(\"%d %d\", &x, &y);\n\t}\n\tll dist(const pnt &p) const {\n\t\treturn 1ll * (x - p.x) * (x - p.x) + 1ll * (y - p.y) * (y - p.y);\n\t}\n} p[N];\n\nbool vis[N];\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i ++) p[i].in();\n    p[0].x = p[0].y = -1e9-7;\n    for (int i = 1, c = 0; i <= n; i ++) {\n\t\tll mx = 0;\n\t\tint k = -1;\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tif (vis[j]) continue;\n\t\t\tll d = p[c].dist(p[j]);\n\t\t\tif (d > mx) mx = d, k = j;\n\t\t}\n\t\tc = k; vis[c] = 1; printf(\"%d \", c);\n    }\n    puts(\"\");\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "geometry",
        "greedy",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Nezzar and Nice Beatmap.json",
    "editorial_link": "https://codeforces.com//blog/entry/87294",
    "editorial": "There are two different approaches to solve this task.\n\nFurthest Points\n\nPick an arbitrary point, and in each iteration, select the furthest point from previously chosen point among all available points. Indeed, we can prove the correctness by contradiction.\n\nInsertion Sorting\n\nNotice that in any triangle (possibly degenerate), there exists at most one obtuse angle or right angle in this triangle. Therefore, we may build our permutation using modified version of insertion sort (it suffices to substitute comparing operator).\n\nWe believe that time complexity for the latter approach is better than O(n2)\n. However, we fail to find a proof or counterexample for it. It would be grateful if someone could figure it out and inform us about it!",
    "hint": []
}