{
    "link": "https://codeforces.com//contest/1150/problem/C",
    "problemId": "337487",
    "problem_idx": "C",
    "shortId": "1150C",
    "contest_number": "1150",
    "problem_submissions": {
        "B": [
            53540534,
            53507569,
            53508198,
            53505953,
            53507902,
            53502830,
            53513376,
            53506258,
            53506938,
            53507029,
            53505090,
            53506786,
            53507919,
            53505701,
            53508136,
            53505737,
            53510148,
            53505896,
            53509474,
            53506927
        ],
        "A": [
            53540520,
            53504501,
            53501762,
            53504323,
            53502423,
            53506385,
            53503912,
            53503441,
            53502508,
            53503428,
            53501838,
            53503271,
            53503651,
            53502306,
            53502491,
            53507914,
            53502081,
            53502083,
            53506610,
            53502822
        ],
        "D": [
            53516414,
            53520400,
            53521416,
            53522657,
            53528159,
            53520710,
            53520700,
            53521674,
            53520691,
            53521939,
            53524571,
            53524486,
            53563821,
            53526080,
            53525497,
            53525654,
            53525306,
            53525173,
            53524887,
            53526333,
            53526204
        ],
        "C": [
            53509607,
            53510070,
            53509423,
            53505062,
            53510041,
            53509499,
            53512010,
            53510164,
            53511943,
            53509231,
            53509848,
            53515668,
            53510065,
            53514034,
            53514382,
            53512626,
            53511942,
            53512622,
            53512550
        ],
        "E": [
            53531623,
            53531513,
            53525648
        ]
    },
    "name": "C. Prefix Sum Primes",
    "statement": "We\u2019re giving away nice huge bags containing number tiles! A bag we want\r\nto present to you contains n tiles. Each of them has a single number\r\nwritten on it either 1 or 2.However, there is one condition you must\r\nfulfill in order to receive the prize. You will need to put all the\r\ntiles from the bag in a sequence, in any order you wish. We will then\r\ncompute the sums of all prefixes in the sequence, and then count how\r\nmany of these sums are prime numbers. If you want to keep the prize, you\r\nwill need to maximize the number of primes you get.Can you win the\r\nprize? Hurry up, the bags are waiting!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nint n;\nint cnt1,cnt2;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tif(a==1){\n\t\t\t++cnt1;\n\t\t}else{\n\t\t\t++cnt2;\n\t\t}\n\t}\n\tif(!cnt1){\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tprintf(\"2 \");\n\t\t}\n\t}else if(!cnt2){\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tprintf(\"1 \");\n\t\t}\n\t}else{\n\t\tprintf(\"2 1 \");\n\t\tfor(int i=1;i<cnt2;++i){\n\t\t\tprintf(\"2 \");\n\t\t}\n\t\tfor(int i=1;i<cnt1;++i){\n\t\t\tprintf(\"1 \");\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Prefix Sum Primes.json",
    "editorial_link": "https://codeforces.com/blog/entry/66783",
    "editorial": "There are at least a couple of correct solutions I had in mind. Let me\r\npresent the one I find the most straightforward, which doesn\u00e2\u0080\u0099t even\r\nrequire implementing any sieve.If all the numbers on the tiles are\r\nequal, we have no choice but to output the only possible permutation. In\r\nthe remaining cases, we\u00e2\u0080\u0099ll show that the following solution is optimal:\r\nStart with and . Use all remaining s. Finish with all remaining s. It\u00e2\u0080\u0099s\r\neasy to see that we generate and all odd numbers between and as the\r\nprefix sums. Notice now that each prime is either or an odd number\r\ngreater than or equal to . Therefore, using the construction above we\r\nconstruct all possible prime prefix sums we possibly can and so the\r\nconstruction is optimal. The solution can be implemented easily in time.\r\n"
}