{
    "link": "https://codeforces.com//contest/451/problem/B",
    "problemId": "11650",
    "problem_idx": "B",
    "shortId": "451B",
    "contest_number": "451",
    "problem_submissions": {
        "E": [
            7231717,
            7231672,
            7229188,
            7229828,
            7229144,
            7232326,
            7229495,
            7238238,
            7238167,
            7229116,
            7226633,
            7227263,
            7247662
        ],
        "D": [
            7225617,
            7224925,
            7225848,
            7230836,
            7232036,
            7232208,
            7233333,
            7231670,
            7237781,
            7230929,
            7225387,
            7226229,
            7225552,
            7225891,
            7226960,
            7225792,
            7226635,
            7227303
        ],
        "C": [
            7223372,
            7224029,
            7230879,
            7223425,
            7226587,
            7227220,
            7237498,
            7226365,
            7222867,
            7234088,
            7223197,
            7222284,
            7224237,
            7223958,
            7224798,
            7224092,
            7223679,
            7225151
        ],
        "B": [
            7221027,
            7219770,
            7219898,
            7220171,
            7221061,
            7220518,
            7220494,
            7220841,
            7220379,
            7220295,
            7219145,
            7221007,
            7221160,
            7222507,
            7220416,
            7221272,
            7220758
        ],
        "A": [
            7217849,
            7218406,
            7218033,
            7217926,
            7218217,
            7218264,
            7218470,
            7218605,
            7218503,
            7219664,
            7217957,
            7218042,
            7220324,
            7218265,
            7218702,
            7218555
        ]
    },
    "name": "B. Sort the Array",
    "statement": "Being a programmer, you like arrays a lot. For your birthday, your\r\nfriends have given you an array consisting of integers.Unfortunately,\r\nthe size of is too small. You want a bigger array! Your friends agree to\r\ngive you a bigger array, but only if you are able to answer the\r\nfollowing question correctly: is it possible to sort the array (in\r\nincreasing order) by reversing segment of ? See definitions of segment\r\nand reversing in the notes.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define fst first\n#define snd second\n#define mp make_pair\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\n#define ri(x) scanf(\"%d\", &x)\n#define rii(x,y) scanf(\"%d%d\", &x, &y)\n#define riii(x,y,z) scanf(\"%d%d%d\", &x, &y, &z)\n#define ria(a, n) rep(_, n) scanf(\"%d\", &a[_])\n\n#define pi(x) printf(\"%d\\n\", x)\n#define pia(a, n) rep(_, n) printf(\"%d%c\", a[_], _==n-1?'\\n': ' ')\n\n#define Ttimes int T; scanf(\"%d\", &T); while(T--)\n\nint n, a[100010];\nint main() {\n    ri(n); ria(a, n);\n    int x = 0;\n    rep(i, n) {\n        if(i > 0 && a[i]<a[i-1]) {\n            x = i;\n        }\n    }\n    int y = x;\n    while(y > 0 && a[y] < a[y-1]) y--;\n    reverse(a+y, a+x+1);\n    if(is_sorted(a, a+n)) printf(\"yes\\n%d %d\\n\", y+1, x+1);\n    else puts(\"no\");\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Sort the Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/13181",
    "editorial": "Note that if from a given sorted array, if reverse a segment, then the\r\nremaining array will be arranged in following way. First increasing\r\nsequence, then decreasing, then again increasing. You can find the first\r\nposition where the sequences start decreasing from the beginning. Call\r\nit .You can find the first position where the sequences start increasing\r\nfrom the end. Call it . Now we just need to reverse the segment between\r\nto . Here is outline of my solution which is easy to implement. First I\r\nmap larger numbers to numbers strictly in the range 1, n.As all the\r\nnumbers are distinct, no two numbers in the mapping will be equal too.\r\nLet us define to be smallest index such that .Let us also define to be\r\nlargest index such that . Note that if there is no such L and R, it\r\nmeans that array is sorted already. So answer will be \"yes\", we can\r\nsimply reverse any of the 1 length consecutive segment. Otherwise we\r\nwill simply reverse the array from . After the reversal, we will check\r\nwhether the array is sorted or not. Complexity: Solution codes\r\n",
    "hint": []
}