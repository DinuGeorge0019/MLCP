{
    "link": "https://codeforces.com//contest/895/problem/C",
    "problemId": "136056",
    "problem_idx": "C",
    "shortId": "895C",
    "contest_number": "895",
    "problem_submissions": {
        "B": [
            32688468,
            32699862,
            32678233,
            32693050,
            32686509,
            32685665,
            32686167,
            32677480,
            32679593,
            32679598,
            32678660,
            32679991,
            32682934,
            32679855,
            32677931,
            32686786,
            32693881,
            32679230,
            32679053
        ],
        "A": [
            32686687,
            32676253,
            32692247,
            32687355,
            32675778,
            32681798,
            32679509,
            32675934,
            32676147,
            32676898,
            32676014,
            32676714,
            32676536,
            32676059,
            32675756,
            32675820,
            32681275,
            32675999,
            32675924,
            32676186
        ],
        "E": [
            32685470,
            32693933,
            32688720,
            32686566,
            32794358,
            32794273,
            32732458,
            32681330,
            34740059,
            32691274,
            32699769,
            32720207,
            32720179,
            32720088,
            32698361,
            32698258,
            32698305
        ],
        "D": [
            32681888,
            32681308,
            32690694,
            32686236,
            32685937,
            32689479,
            32691053,
            32781770,
            32686848,
            32691934,
            32691134,
            32690110,
            32688741,
            32690589,
            32685060,
            32692013
        ],
        "C": [
            32678196,
            32689081,
            32683426,
            32681542,
            32680606,
            32690938,
            32678815,
            32682493,
            32687456,
            32690603,
            32685722,
            32686946,
            32686892,
            32689317,
            32680568,
            32678934,
            32808410,
            32685463,
            32687263,
            32681038
        ]
    },
    "name": "C. Square Subsets",
    "statement": "Petya was late for the lesson too. The teacher gave him an additional\r\ntask. For some array Petya should find the number of different ways to\r\nselect non-empty subset of elements from it in such a way that their\r\nproduct is equal to a square of some integer.Two ways are considered\r\ndifferent if sets of indexes of elements chosen by these ways are\r\ndifferent.Since the answer can be very large, you should find the answer\r\nmodulo .\r\n",
    "solutions": [
        "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,tot;\n\nint nm[100];\n\nint f[20][2],g[20][2];\n\nPII A[maxn];\n\nbool check(int n){\n\tfor(int i=2;i*i<=n;i++)if(n%i==0)return false;\n\treturn true;\n}\n\nint main(){\n\tread(n);\n\tREP(i,2,7)if(check(i))nm[i]=tot++;\n\tREP(i,1,n){\n\t\tint x,t=0;\n\t\tread(x);\n\t\tREP(j,2,7)if(x%j==0){\n\t\t\twhile(x%j==0){\n\t\t\t\tx/=j;\n\t\t\t\tt^=1<<nm[j];\n\t\t\t}\n\t\t}\n\t\tA[i]=MP(x,t);\n\t}\n\tsort(A+1,A+n+1);\n\tf[0][0]=1;\n\tfor(int i=1,j;i<=n;i=j+1){\n\t\tfor(j=i;j<n&&A[j+1].fi==A[j].fi;j++);\n\t\tREP(k,i,j){\n\t\t\tmemcpy(g,f,sizeof(g));memset(f,0,sizeof(f));\n\t\t\tREP(sta,0,(1<<tot)-1)\n\t\t\t\tREP(l,0,1){\n\t\t\t\t\tf[sta][l]=(f[sta][l]+g[sta][l])%mod;\n\t\t\t\t\tf[sta^A[k].se][l^1]=(f[sta^A[k].se][l^1]+g[sta][l])%mod;\n\t\t\t\t}\n\t\t}\n\t\tif(A[i].fi==1){\n\t\t\tREP(sta,0,(1<<tot)-1)f[sta][0]=(f[sta][0]+f[sta][1])%mod;\n\t\t}\n\t\tREP(sta,0,(1<<tot)-1)f[sta][1]=0;\n\t}\n\tf[0][0]=(f[0][0]-1+mod)%mod;\n\tiout(f[0][0]);\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Square Subsets.json",
    "editorial_link": "https://codeforces.com//blog/entry/56028",
    "editorial": "We can notice that is a perfect square of some integer if and only if\r\neach prime number enters decomposition of into prime factors even times.\r\nThere are only prime numbers less than . Now we should find the bitmask\r\nfor each integer in by the following way: There is in bit representation\r\nof mask in -th place if -th prime number enters decomposition of that\r\nnumber odd times. Else there is . For each integer between and we need\r\nto find the number of ways we can take odd and even amount of it from .\r\nLet , be that number of ways relatively. Let be the number of ways to\r\nchoose some elements which are <= from , and their product has only\r\nthose prime numbers in odd degree on whose index number has in binary\r\nrepresentation. Initially . The answer is . Time complexity is\r\n(*2^cnt(max)), where is maximal integer , and is the number of prime\r\nnumbers less than . Solution\r\n",
    "hint": []
}