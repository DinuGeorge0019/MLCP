{"link": "https://codeforces.com//contest/1673/problem/D", "problemId": "1385666", "problem_idx": "D", "shortId": "1673D", "contest_number": "1673", "problem_submissions": {"E": [155426965, 155417061, 155442389, 155435971, 155444716, 155445002, 155444871, 155514328, 155514309, 155514225, 155443263, 155444297, 155443581, 155433854], "F": [155419208, 155424822, 155430193, 155426235, 155421394, 155428770, 155436120, 155468393, 155433714, 155432038, 155436911, 155434672, 155436663, 155437291, 155437403, 155444380, 155421502, 155466705, 155436336], "D": [155415117, 155435345, 155420108, 155439489, 155431441, 155419630, 155415726, 155421120, 155422405, 155419806, 155421729, 155424346, 155424705, 155419720, 155443639, 155434940, 155418827, 155423765], "C": [155404978, 155404876, 155407310, 155404678, 155403723, 155410318, 155407177, 155407649, 155410425, 155412404, 155411432, 155412241, 155405106, 155408638, 155409170, 155443684, 155416480, 155405320, 155408554], "B": [155402768, 155402072, 155401370, 155411423, 155405962, 155405267, 155404158, 155402546, 155402518, 155406241, 155407263, 155417097, 155402117, 155403200, 155414493, 155417214, 155402941, 155413813], "A": [155398139, 155398122, 155398102, 155398465, 155398314, 155398797, 155398162, 155398613, 155398972, 155398376, 155400350, 155398178, 155398450, 155400124, 155418014, 155398258, 155398425]}, "name": "D. Lost Arithmetic Progression", "statement": "Long ago, you thought of two finite arithmetic progressions A and B.\r\nThen you found out another sequence C containing all elements common to\r\nboth A and B. It is not hard to see that C is also a finite arithmetic\r\nprogression. After many years, you forgot what A was but remember B and\r\nC. You are, for some reason, determined to find this lost arithmetic\r\nprogression. Before you begin this eternal search, you want to know how\r\nmany different finite arithmetic progressions exist which can be your\r\nlost progression A. Two arithmetic progressions are considered different\r\nif they differ in their first term, common difference or number of\r\nterms.It may be possible that there are infinitely many such\r\nprogressions, in which case you won\u2019t even try to look for them! Print\r\n-1 in all such cases. Even if there are finite number of them, the\r\nanswer might be very large. So, you are only interested to find the\r\nanswer modulo 10^9+7.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nconst int mod=1e9+7;\n\nll b,q,y;\nll c,r,z;\n\nll lcm(ll x,ll y){return x/__gcd(x,y)*y;}\n\nvoid solve(){\n    scanf(\"%lld%lld%lld\",&b,&q,&y);\n    scanf(\"%lld%lld%lld\",&c,&r,&z);\n    if(r%q)return puts(\"0\"),void();\n    if((b-c)%q)return puts(\"0\"),void();\n    if(c<b||c+r*(z-1)>b+q*(y-1))return puts(\"0\"),void();\n    ll ans=0;\n    bool flag=0;\n    ll pos1,pos2;\n    pos1=(c-b)/q+1;\n    pos2=(c+r*(z-1)-b)/q+1;\n    auto sol=[&](ll x){\n        ll t=lcm(x,q);\n        if(t<r)return;\n        assert(t==r);\n        ll new_pos1=pos1-r/q;\n        ll new_pos2=pos2+r/q;\n        if(new_pos1<1||new_pos2>y){\n            flag=1;\n            return;\n        }else{\n            ans+=(r/x)*(r/x);\n            ans%=mod;\n        }\n    };\n    for(int i=1;i*i<=r;i++)if(r%i==0){\n        sol(i);\n        if(i!=r/i)sol(r/i);\n    }\n    if(flag)puts(\"-1\");\n    else print(ans,'\\n');\n}\n\nint main(){\n    int T=read();\n    while(T--)solve();\n    return 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "math", "number theory"], "dificulty": "1900", "interactive": false}