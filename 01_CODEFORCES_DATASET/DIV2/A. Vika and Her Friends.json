{
    "link": "https://codeforces.com//contest/1848/problem/A",
    "problemId": "2046238",
    "problem_idx": "A",
    "shortId": "1848A",
    "contest_number": "1848",
    "problem_submissions": {
        "E": [
            214078806,
            214088202,
            214079632,
            214087057,
            214086323,
            214083544,
            214090057,
            214082643,
            214094277,
            214095285,
            214705225
        ],
        "F": [
            214070984,
            214075949,
            214084495,
            214080175,
            214065714,
            214087986,
            214082128,
            214076389,
            214084949,
            214073421,
            214060099,
            214088437,
            214086968,
            214091347,
            214089467,
            214079366
        ],
        "D": [
            214068277,
            214064922,
            214070767,
            214068735,
            214079075,
            214069131,
            214069700,
            214066329,
            214075678,
            214084591,
            214097754,
            214075100,
            214072308,
            214074287,
            214061875,
            214091346
        ],
        "C": [
            214056697,
            214056251,
            214061525,
            214059146,
            214071785,
            214061591,
            214056000,
            214073174,
            214063820,
            214060194,
            214078312,
            214056865,
            214065402,
            214062471,
            214092811,
            214062217
        ],
        "B": [
            214052297,
            214051762,
            214052731,
            214053122,
            214056975,
            214052187,
            214052073,
            214064615,
            214054312,
            214052430,
            214052268,
            214050368,
            214053885,
            214053048,
            214051754,
            214051131
        ],
        "A": [
            214049674,
            214048967,
            214049923,
            214049713,
            214052070,
            214049845,
            214048850,
            214050906,
            214049091,
            214049973,
            214049534,
            214049002,
            214049762,
            214049567,
            214049272,
            214049415
        ]
    },
    "name": "A. Vika and Her Friends",
    "statement": "Vika and her friends went shopping in a mall, which can be represented\r\nas a rectangular grid of rooms with sides of length n and m. Each room\r\nhas coordinates (a, b), where 1\r\nle a\r\nle n, 1\r\nle b\r\nle m. Thus we call a hall with coordinates (c, d) a neighbouring for it\r\nif |a - c| + |b - d| = 1.Tired of empty fashion talks, Vika decided to\r\nsneak away unnoticed. But since she hasn’t had a chance to visit one of\r\nthe shops yet, she doesn’t want to leave the mall. After a while, her\r\nfriends noticed Vika’s disappearance and started looking for\r\nher.Currently, Vika is in a room with coordinates (x, y), and her k\r\nfriends are in rooms with coordinates (x_1, y_1), (x_2, y_2), ... ,\r\n(x_k, y_k), respectively. The coordinates can coincide. Note that all\r\nthe girls move to the neighbouring rooms.Every minute, first Vika moves\r\nto one of the adjacent to the side rooms of her choice, and then each\r\nfriend () also chooses one of the adjacent rooms to move to.If (that is,\r\nafter all the girls have moved on to the neighbouring rooms) at least\r\none friend is in the same room as Vika, she is caught and all the other\r\nfriends are called.Tell us, can Vika run away from her annoying friends\r\nforever, or will she have to continue listening to empty fashion talks\r\nafter some time?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\nconst int mod = 998244353, N = 100005;\n \nvoid frank() {\n    int n, m, k; cin >> n >> m >> k;\n    int x, y; cin >> x >> y;\n    bool ok = 1;\n    for (int i = 0; i < k; ++i) {\n        int a, b; cin >> a >> b;\n        if ((a + b + x + y) % 2 == 0) ok = 0;\n    }\n    cout << (ok ? \"YES\" : \"NO\") << \"\\n\";\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        frank();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "math"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Vika and Her Friends.json",
    "editorial_link": "https://codeforces.com//blog/entry/118333",
    "editorial": "Letâs color the halls of a rectangle in a chess coloring. Then Vika will\r\nbe able to escape from her friends infinitely only if none of her\r\nfriends is on a cell of the same color as Vika.This observation seems\r\nintuitively clear, but letâs formalize it. It is true, because if\r\ninitially Vika and her friend were in halls of different colors, then\r\nafter one move they will remain in halls of different colors. Letâs\r\nchoose any of the friends who is in a hall of the same color as Vika. We\r\nwill show how the friend will act to catch Vika in a finite time. First,\r\nletâs define a quantity that we will call the area to Vika: If Vika and\r\nthe friend are in the same column, then the area to Vika is equal to the\r\nsum of the areas of all rows in the direction of Vika and the row where\r\nthe friend is located. If Vika and the friend are in the same row, then\r\nthe area to Vika is equal to the sum of the areas of all columns in the\r\ndirection of Vika and the column where the friend is located. Otherwise,\r\nthe area to Vika is equal to the area of the quadrant in which Vika is\r\nlocated relative to the friend. Now letâs notice that after each action,\r\nthe friend can improve the next ordered pair: (Manhattan distance to\r\nVika, area to Vika). If Vika goes towards the friend, then the friend\r\ngoes towards her, reducing the distance. If Vika goes in the opposite\r\ndirection, then the friend also goes towards her, reducing the area to\r\nVika. If Vika goes along the row, then the friend goes towards Vika\r\nalong the column, which also reduces the area to Vika. If Vika goes\r\ntowards the friend, then the friend goes towards her, reducing the\r\ndistance. If Vika goes in the opposite direction, then the friend also\r\ngoes towards her, reducing the area to Vika. If Vika goes along the\r\ncolumn, then the friend goes towards Vika along the row, which also\r\nreduces the area to Vika. If Vika goes towards the friend along the row,\r\nthen the friend goes towards her along the column, reducing the\r\ndistance. If Vika goes towards the friend along the column, then the\r\nfriend goes towards her along the row, reducing the distance. If Vika\r\ngoes away from the friend, then the friend makes a move in the same\r\ndirection, thereby reducing the area to Vika. Since each of the\r\nquantities in the ordered pair cannot decrease infinitely many times, at\r\nsome point the distance will become zero, which means a successful\r\ncapture of Vika.\r\n",
    "hint": []
}