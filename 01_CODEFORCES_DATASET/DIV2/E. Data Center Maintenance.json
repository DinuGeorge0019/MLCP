{
    "link": "https://codeforces.com//contest/950/problem/E",
    "problemId": "163626",
    "problem_idx": "E",
    "shortId": "950E",
    "contest_number": "950",
    "problem_submissions": {
        "F": [
            36110799,
            36106874,
            36110418,
            36111996,
            36110842,
            36112881,
            36112066,
            36111037,
            36115685,
            36107783,
            36111061,
            36110969
        ],
        "E": [
            36106600,
            36110576,
            36107020,
            36108185,
            36105421,
            36110602,
            36104100,
            36112036,
            36103180,
            36119591,
            36103520,
            36104391,
            36111839,
            36104803,
            36105285,
            36106153,
            36105692,
            36107917,
            36133513,
            36106022
        ],
        "D": [
            36099255,
            36103207,
            36103975,
            36101168,
            36099422,
            36104316,
            36100451,
            36105727,
            36100010,
            36100957,
            36098808,
            36101447,
            36108972,
            36101180,
            36100807,
            36101948,
            36101824,
            36102198,
            36099705,
            36115114,
            36103338
        ],
        "B": [
            36097037,
            36093570,
            36096763,
            36102283,
            36107341,
            36096070,
            36118539,
            36103628,
            36098191,
            36093324,
            36097654,
            36092909,
            36097186,
            36093092,
            36094178,
            36093761,
            36093826,
            36092324,
            36094422,
            36093177
        ],
        "C": [
            36095719,
            36096428,
            36100419,
            36099281,
            36103315,
            36101716,
            36094357,
            36100382,
            36094934,
            36098794,
            36096378,
            36098545,
            36106922,
            36096674,
            36097941,
            36096847,
            36097394,
            36095627,
            36097024,
            36097344
        ],
        "A": [
            36091256,
            36091581,
            36094574,
            36100244,
            36107668,
            36091536,
            36095298,
            36101664,
            36095785,
            36091314,
            36098215,
            36091291,
            36093398,
            36091393,
            36091803,
            36091568,
            36091610,
            36091266,
            36092123,
            36091364
        ]
    },
    "name": "E. Data Center Maintenance",
    "statement": "BigData Inc. is a corporation that has data centers indexed from to that\r\nare located all over the world. These data centers provide storage for\r\nclient data (you can figure out that client data is really big!).Main\r\nfeature of services offered by BigData Inc. is the access availability\r\nguarantee even under the circumstances of any data center having an\r\noutage. Such a guarantee is ensured by using the . Two-way replication\r\nis such an approach for data storage that any piece of data is\r\nrepresented by two identical copies that are stored in two different\r\ndata centers.For each of company clients, let us denote indices of two\r\ndifferent data centers storing this client data as and .In order to keep\r\ndata centers operational and safe, the software running on data center\r\ncomputers is being updated regularly. Release cycle of BigData Inc. is\r\none day meaning that the new version of software is being deployed to\r\nthe data center computers each day.Data center software update is a\r\nnon-trivial long process, that is why there is a special hour-long time\r\nframe that is dedicated for data center maintenance. During the\r\nmaintenance period, data center computers are installing software\r\nupdates, and thus they may be unavailable. Consider the day to be\r\nexactly hours long. For each data center there is an integer () defining\r\nthe index of an hour of day, such that during this hour data center is\r\nunavailable due to maintenance.Summing up everything above, the\r\ncondition should hold for each client, or otherwise his data may be\r\nunaccessible while data centers that store it are under maintenance.Due\r\nto occasional timezone change in different cities all over the world,\r\nthe maintenance time in some of the data centers may change by one hour\r\nsometimes. Company should be prepared for such situation, that is why\r\nthey decided to conduct an experiment, choosing some non-empty subset of\r\ndata centers, and shifting the maintenance time for them by an hour\r\nlater (i.e. if , then the new maintenance hour would become , otherwise\r\nit would become ). Nonetheless, such an experiment should not break the\r\naccessibility guarantees, meaning that data of any client should be\r\nstill available during any hour of a day after the data center\r\nmaintenance times are changed.Such an experiment would provide useful\r\ninsights, but changing update time is quite an expensive procedure, that\r\nis why the company asked you to find out the minimum number of data\r\ncenters that have to be included in an experiment in order to keep the\r\ndata accessibility guarantees.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100100;\nint n,m,h,st[N],sz[N],vis[N],cnt,scnt,vd[N],sn[N],a[N];\nvector<int>vec[N],vec2[N];\n\nvoid dfs1(int x){\n\tif(vis[x])return;\n\tvis[x]=1;\n\tfor(int i=0;i<vec[x].size();i++)dfs1(vec[x][i]);\n\tst[++cnt]=x;\n}\nvoid dfs2(int x){\n\tif(sn[x]){\n\t\tif(sn[x]!=scnt)vd[sn[x]]=1;\n\t\treturn;\n\t}\n\tsn[x]=scnt;sz[scnt]++;\n\tfor(int i=0;i<vec2[x].size();i++)dfs2(vec2[x][i]);\n}\n\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&h);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tif((a[u]-a[v]+h)%h==1)vec[v].push_back(u),vec2[u].push_back(v);\n\t\tif((a[v]-a[u]+h)%h==1)vec[u].push_back(v),vec2[v].push_back(u);\n\t}\n\tfor(int i=1;i<=n;i++)dfs1(i);\n\tfor(int i=n;i;i--)\n\t\tif(!sn[st[i]]){\n\t\t\tscnt++;dfs2(st[i]);\n\t\t}\n\tint ans=0;sz[0]=n+1;\n\tfor(int i=1;i<=scnt;i++)if(!vd[i]&&sz[i]<sz[ans])ans=i;\n\tprintf(\"%d\\n\",sz[ans]);\n\tfor(int i=1;i<=n;i++)if(sn[i]==ans)printf(\"%d \",i);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "graphs"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Data Center Maintenance.json",
    "editorial_link": "https://codeforces.com//blog/entry/58291",
    "editorial": "Formally you are given a properly colored graph and you are asked to find out size of smallest non-empty subset such that after addition 1 modulo h to colors of vertices in this subset coloring will remain proper.\n\nLet's build a directed graph with n vertices and edge from u to v iff u and v are connected by edge in original graph and . Now let's fix some vertex which color will be changed. It's clear that we should take into its set all vertices which are reachable from it. Now our problem is reduced to following problem: \"Given directed graph find vertex with smallest number reachable from it vertices\". It's just any vertex from smallest strongly connected component which is sink (strongly connected component such there is no strongly connected component reachable from it).",
    "hint": []
}