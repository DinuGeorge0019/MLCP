{
    "link": "https://codeforces.com//contest/1627/problem/C",
    "problemId": "1262392",
    "problem_idx": "C",
    "shortId": "1627C",
    "contest_number": "1627",
    "problem_submissions": {
        "A": [
            142856858,
            142829078,
            142831063,
            142828619,
            142829282,
            142829501,
            142828956,
            142828768,
            142829546,
            142828636,
            142829064,
            142830437,
            142829297,
            142829030,
            142829071,
            142830213,
            142829290,
            142834401,
            142829511,
            142828971
        ],
        "B": [
            142855615,
            142836231,
            143077575,
            142843639,
            142833513,
            142834057,
            142834633,
            142836507,
            142832659,
            142835053,
            142835365,
            142833153,
            142834936,
            142836596,
            142833128,
            142834428,
            142837068,
            142835176,
            142841259,
            142840070,
            142832942
        ],
        "C": [
            142853368,
            142841436,
            142848282,
            142837534,
            142840619,
            142840854,
            142841599,
            142841065,
            142841353,
            142842344,
            142840078,
            142839450,
            142843531,
            142839772,
            142838837,
            142843623,
            142841636,
            142846207,
            142840529,
            142843637
        ],
        "D": [
            142850438,
            142848536,
            143170284,
            142854619,
            142844350,
            142843215,
            142846147,
            142845730,
            142844598,
            142844258,
            142848096,
            142845506,
            142844896,
            142848460,
            142849869,
            142841967,
            142847523,
            142848652,
            142849056,
            142845741,
            142849286
        ],
        "E": [
            142848975,
            142862261,
            142856441,
            142857018,
            142861778,
            142861405,
            142859738,
            142864236,
            142861113,
            142866137,
            142865452,
            142865639,
            142862871,
            142864756,
            142864934,
            142867450,
            142864191,
            142861812,
            142865000
        ],
        "F": [
            142838000,
            142875000,
            142859934,
            142890898,
            147974497
        ]
    },
    "name": "C. Not Assigning",
    "statement": "You are given a tree of n vertices numbered from 1 to n, with edges\r\nnumbered from 1 to n-1. A tree is a connected undirected graph without\r\ncycles. You have to assign integer weights to each edge of the tree,\r\nsuch that the resultant graph is a prime tree.A is a tree where the\r\nweight of every path consisting of is prime. A path should not visit any\r\nvertex twice. The weight of a path is the sum of edge weights on that\r\npath.Consider the graph below. It is a prime tree as the weight of every\r\npath of two or less edges is prime. For example, the following path of\r\ntwo edges: 2\r\nto 1\r\nto 3 has a weight of 11 + 2 = 13, which is prime. Similarly, the path of\r\none edge: 4\r\nto 3 has a weight of 5, which is also prime. Print valid assignment of\r\nweights such that the resultant tree is a prime tree. If there is no\r\nsuch assignment, then print -1. It can be proven that if a valid\r\nassignment exists, one exists with weights between 1 and 10^5 as well.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((int)(x).size())\n#define each(x,v) for(auto&x:v)\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nconst int N=100005;\nint T,n,dep[N],ans[N];\nvector<pair<int,int> >e[N];\nvoid dfs1(int k1,int k2){\n\tdep[k1]=dep[k2]+1;\n\teach(x,e[k1])if(get<0>(x)!=k2){\n\t\tans[get<1>(x)]=dep[k1]&1?2:3;\n\t\tdfs1(get<0>(x),k1);\n\t}\n}\nint main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d\",&n);\n\t\trep(i,1,n)e[i].clear();\n\t\trep(i,2,n){\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\te[u].eb(v,i),e[v].eb(u,i);\n\t\t}\n\t\tbool err=0;\n\t\trep(i,1,n)if(SZ(e[i])>2){\n\t\t\terr=1;\n\t\t}\n\t\tif(err){\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint root=1;\n\t\trep(i,1,n)if(SZ(e[i])<=1){root=i;break;}\n\t\tdfs1(root,0);\n\t\trep(i,2,n)printf(\"%d \",ans[i]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "number theory",
        "trees"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Not Assigning.json",
    "editorial_link": "https://codeforces.com//blog/entry/99067",
    "editorial": "Let us first see when a valid assignment does not exist. If any vertex\r\nhas 3 or more edges adjacent to it, no valid assignment exists. Consider\r\na graph where a vertex has edges to three other vertices with weights ,\r\nand respectively. For a valid assignment, , and need to be primes\r\nthemselves. Also, , and need to be primes too.Since (as is the smallest\r\nprime), thus , so they must be odd primes. This implies: and have\r\nopposite parity. and have opposite parity. and have opposite parity. As\r\nall the three conditions cannot hold together, hence we have a\r\ncontradiction. So, we have a tree where every vertex has either one or\r\ntwo edges adjacent to it. Such a tree will have exactly two leaf nodes\r\nfor and have the following structure, where and are the leaf nodes.Thus,\r\nstarting a DFS from any leaf node, we can assign weights and (or and the\r\nfirst number of any twin prime pair) alternatingly to form a prime tree,\r\nas , and are all primes.Expected time complexity:\r\n"
}