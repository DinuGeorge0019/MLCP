{"link": "https://codeforces.com//contest/257/problem/E", "problemId": "2502", "problem_idx": "E", "shortId": "257E", "contest_number": "257", "problem_submissions": {"E": [2893499, 2905131], "D": [2888828, 2888815, 2889989, 2890313, 2889878, 2888430, 2887802, 2890677, 2891009, 2890941, 2890050, 2891384], "C": [2887785, 2887326, 2887433, 2890384, 2887249, 2888432, 2892651, 2892447, 2891062, 2889397, 2889354, 2891081, 2889995], "B": [2887685, 2890108, 2889351, 2888373, 2890099, 2890775, 2887640, 2889176, 2887264, 2888202, 2887592, 2887031, 2886691], "A": [2886234, 2885722, 2886258, 2888302, 2885640, 2885926, 2886671, 2885877, 2886694, 2886610, 2885637, 2885791]}, "name": "E. Greedy Elevator", "statement": "The -floor office of international corporation CodeForces has the\r\nadvanced elevator control system established. It works as follows.All\r\noffice floors are sequentially numbered with integers from 1 to . At\r\ntime , the elevator is on the first floor, the elevator is empty and\r\nnobody is waiting for the elevator on other floors. Next, at times\r\npeople come to the elevator. For simplicity, we assume that one person\r\nuses the elevator only once during the reported interval. For every\r\nperson we know three parameters: the time at which the person comes to\r\nthe elevator, the floor on which the person is initially, and the floor\r\nto which he wants to go.The movement of the elevator between the floors\r\nis as follows. At time (, is an integer) the elevator is always at some\r\nfloor. First the elevator releases all people who are in the elevator\r\nand want to get to the current floor. Then it lets in all the people\r\nwaiting for the elevator on this floor. If a person comes to the\r\nelevator exactly at time , then he has enough time to get into it. We\r\ncan assume that all of these actions (going in or out from the elevator)\r\nare made instantly. After that the elevator decides, which way to move\r\nand at time the elevator gets to the selected floor.The elevator selects\r\nthe direction of moving by the following algorithm. If the elevator is\r\nempty and at the current time no one is waiting for the elevator on any\r\nfloor, then the elevator remains at the current floor. Otherwise, let\u2019s\r\nassume that the elevator is on the floor number . Then elevator\r\ncalculates the directions\u2019 \"priorities\" and : is the sum of the number\r\nof people waiting for the elevator on the floors with numbers greater\r\nthan , and the number of people in the elevator, who want to get to the\r\nfloors with the numbers greater than ; is the sum of the number of\r\npeople waiting for the elevator on the floors with numbers less than ,\r\nand the number of people in the elevator, who want to get to the floors\r\nwith the numbers less than . If , then the elevator goes one floor above\r\nthe current one (that is, from floor to floor ), otherwise the elevator\r\ngoes one floor below the current one (that is, from floor to floor ).\r\nYour task is to simulate the work of the elevator and for each person to\r\ntell the time when the elevator will get to the floor this person needs.\r\nPlease note that the elevator is large enough to accommodate all the\r\npeople at once.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef long long int64;\n\nstruct Event\n{\n\tint floor, idx, target;\n\tfriend bool operator == (Event a, Event b)\n\t{\n\t\treturn a.idx == b.idx && a.floor == b.floor;\n\t}\n\tfriend bool operator < (Event a, Event b)\n\t{\n\t\treturn a.floor < b.floor || a.floor == b.floor && a.idx < b.idx;\n\t}\n\tstatic Event Null()\n\t{\n\t\tEvent ret;\n\t\tret.idx = -1;\n\t\treturn ret;\n\t}\n\tEvent(){}\n\tEvent(int a, int b, int c)\n\t{\n\t\tfloor = a, idx = b, target = c;\n\t}\n};\n\nstruct NODE{Event Val; int Pry, Size; struct NODE *L, *R;};\ntypedef struct NODE *TNODE;\n\nTNODE Head, Null;\n\ninline void Update(TNODE &Root){Root->Size= 1 + Root->L->Size + Root->R->Size;}\n\ninline void RotateLeft(TNODE &Root)\n{\n    TNODE Temp= Root->L;\n    Root->L= Temp->R;\n    Temp->R= Root;\n    Update(Root); Update(Temp);\n    Root= Temp;\n}\n\ninline void RotateRight(TNODE &Root)\n{\n    TNODE Temp= Root->R;\n    Root->R= Temp->L;\n    Temp->L= Root;\n    Update(Root); Update(Temp);\n    Root= Temp;\n}\n\nvoid Insert(TNODE &Root, Event Val)\n{\n    if(Root == Null)\n    {\n        Root= new(NODE);\n        Root->Val= Val;\n        Root->Size= 1;\n        Root->Pry= rand();\n        Root->L= Root->R= Null;\n        return ;\n    }\n    if(Root->Val < Val)\n    {\n        Insert(Root->R, Val);\n        if(Root->R->Pry < Root->Pry)RotateRight(Root);\n    }\n    else\n    {\n        Insert(Root->L, Val);\n        if(Root->L->Pry < Root->Pry)RotateLeft(Root);\n    }\n    Update(Root);\n}\n\nEvent FindNext(TNODE &Root, Event Val)\n{\n    if(Root == Null)return Event::Null();\n    if(Root->Val.floor < Val.floor)return FindNext(Root->R, Val);\n    Event Tmp= FindNext(Root->L, Val);\n    if(Tmp.idx != -1)return Tmp; else return Root->Val;\n}\n\nEvent FindPrev(TNODE &Root, Event Val)\n{\n    if(Root == Null)return Event::Null();\n    if(Val.floor < Root->Val.floor)return FindPrev(Root->L, Val);\n    Event Tmp= FindPrev(Root->R, Val);\n    if(Tmp.idx != -1)return Tmp; else return Root->Val;\n}\n\nint GetUp(TNODE &Root, int cur)\n{\n\tif(Root == Null)\n\t\treturn 0;\n\tif(Root->Val.floor > cur)\n\t\treturn Root->R->Size + 1 + GetUp(Root->L, cur);\n\treturn GetUp(Root->R, cur);\n}\n\nint GetDown(TNODE &Root, int cur)\n{\n\tif(Root == Null)\n\t\treturn 0;\n\tif(Root->Val.floor < cur)\n\t\treturn Root->L->Size + 1 + GetDown(Root->R, cur);\n\treturn GetDown(Root->L, cur);\n}\n\nvoid Delete(TNODE &Root, Event Val)\n{\n\tif(Root == Null)\n\t{\n\t\tprintf(\"Delete Failed.\\n\");\n\t\texit(0);\n\t}\n\tif(Root->Val == Val)\n\t{\n\t\tif(Root->L == Null && Root->R == Null)\n\t\t{\n\t\t\tfree(Root);Root= Null; return ;\n\t\t}\n\t\tif(Root->L->Pry < Root->R->Pry)\n\t\t{\n\t\t\tRotateLeft(Root);\n\t\t\tDelete(Root->R, Val);\n\t\t}else\n\t\t{\n\t\t\tRotateRight(Root);\n\t\t\tDelete(Root->L, Val);\n\t\t}\n\t\tUpdate(Root);\n\t\treturn ;\n\t}\n\tif(Val < Root->Val)Delete(Root->L, Val);else Delete(Root->R, Val);\n\tUpdate(Root);\n}\n\nstruct Passenger\n{\n\tint t, s, f, idx;\n\tstatic bool Compare(Passenger a, Passenger b)\n\t{\n\t\treturn a.t < b.t;\n\t}\n}a[100005];\n\nint64 ans[100005];\n\nint n, m;\nint64 tick;\nint step;\n\nvoid Handle(Event x)\n{\n\tif(x.target == -1)\n\t{\n\t\t//printf(\"Arrived : tick=%I64d, floor=%d, idx=%d\\n\", tick, x.floor, x.idx);\n\t\t++ step;\n\t\tans[x.idx] = tick;\n\t\tDelete(Head, x);\n\t}else\n\t{\n\t\t//printf(\"Entered : tick=%I64d, floor=%d, target=%d, idx=%d\\n\", tick, x.floor, x.target, x.idx);\n\t\tDelete(Head, x);\n\t\tInsert(Head, Event(x.target, x.idx, -1));\n\t}\n}\n\nint main()\n{\n\tNull= new(NODE);\n\tNull->Val.idx = -1;\n    Null->Size= 0;\n    Null->Pry= 0x7fffffff;\n    Head= Null;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i(1); i <= n; ++ i)\n\t{\n\t\tscanf(\"%d%d%d\", &a[i].t, &a[i].s, &a[i].f);\n\t\ta[i].idx = i;\n\t}\n\tstd::sort(a + 1, a + 1 + n, Passenger::Compare);\n\tint pos = 1;\n\n\tEvent cur;\n\tcur.floor = 1;\n\twhile(step < n)\n\t{\n\t\tEvent Tmp;\n\t\twhile((Tmp = FindNext(Head, cur)).idx != -1)\n\t\t{\n\t\t\tif(Tmp.floor != cur.floor)\n\t\t\t\tbreak;\n\t\t\tHandle(Tmp);\n\t\t}\n\t\tif(step == n)\n\t\t\tbreak;\n\t\tif(Head->Size == 0)\n\t\t{\n\t\t\ttick = a[pos].t;\n\t\t\tfor(; pos <= n && a[pos].t == tick; ++ pos)\n\t\t\t{\n\t\t\t\t//printf(\"Insert : tick=%I64d, cur=%d, floor=%d, idx=%d\\n\", tick, cur.floor, a[pos].s, a[pos].idx);\n\t\t\t\tInsert(Head, Event(a[pos].s, a[pos].idx, a[pos].f));\n\t\t\t}\n\t\t}else\n\t\t{\n\t\t\tint64 nextTime = tick;\n\t\t\tint Up = GetUp(Head, cur.floor), Down = GetDown(Head, cur.floor);\n\t\t\tEvent Next = FindNext(Head, cur), Prev = FindPrev(Head, cur);\n\t\t\tif(Up >= Down)\n\t\t\t\tnextTime += Next.floor - cur.floor;\n\t\t\telse\n\t\t\t\tnextTime += cur.floor - Prev.floor;\n\t\t\tif(pos <= n && a[pos].t <= nextTime)\n\t\t\t{\n\t\t\t\tint64 old = tick;\n\t\t\t\ttick = a[pos].t;\n\t\t\t\tfor(; pos <= n && a[pos].t == tick; ++ pos)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"Insert : tick=%I64d, cur=%d, floor=%d, idx=%d\\n\", tick, cur.floor, a[pos].s, a[pos].idx);\n\t\t\t\t\tInsert(Head, Event(a[pos].s, a[pos].idx, a[pos].f));\n\t\t\t\t}\n\t\t\t\tcur.floor = Up >= Down ? cur.floor + tick - old : cur.floor - tick + old;\n\t\t\t}else\n\t\t\t{\n\t\t\t\ttick = nextTime;\n\t\t\t\tcur.floor = Up >= Down ? Next.floor : Prev.floor;\n\t\t\t}\n\t\t}\n\n\t}\n\tfor(int i(1); i <= n; ++ i)\n\t\tprintf(\"%I64d\\n\", ans[i]);\n}\n"], "input": "", "output": "", "tags": ["data structures", "implementation"], "dificulty": "2200", "interactive": false}