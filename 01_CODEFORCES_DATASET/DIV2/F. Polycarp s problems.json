{
    "link": "https://codeforces.com//contest/727/problem/F",
    "problemId": "75804",
    "problem_idx": "F",
    "shortId": "727F",
    "contest_number": "727",
    "problem_submissions": {
        "F": [
            21454299,
            21463560,
            21456437,
            21465295,
            21454474,
            21458264,
            21456589
        ],
        "E": [
            21449841,
            21449822,
            21450904,
            21453568,
            21453967,
            21760601,
            21511825,
            21511807,
            21511800,
            21454554,
            21549212,
            21460363,
            21455919,
            21459919
        ],
        "D": [
            21446491,
            21446004,
            21446992,
            21445398,
            21448520,
            21448519,
            21447217,
            21446535,
            21447223,
            21446711,
            21448124,
            21446242,
            21447928,
            21448652,
            21448435,
            21449709,
            21448635,
            21445975,
            21450092
        ],
        "C": [
            21445102,
            21444938,
            21445707,
            21444476,
            21446045,
            21446680,
            21446166,
            21445050,
            21443956,
            21445410,
            21446522,
            21445734,
            21446213,
            21445295,
            21445829,
            21445999,
            21444171,
            21447101
        ],
        "B": [
            21444430,
            21444284,
            21444596,
            21443833,
            21445575,
            21445150,
            21455506,
            21444391,
            21445186,
            21444885,
            21444164,
            21445217,
            21445115,
            21446297,
            21444840,
            21445324,
            21453096,
            21445206
        ],
        "A": [
            21442889,
            21442869,
            21443136,
            21442911,
            21443243,
            21443224,
            21443033,
            21442981,
            21442858,
            21442965,
            21442983,
            21442922,
            21442918,
            21442957,
            21443069,
            21443067,
            21443028,
            21443089,
            21442924,
            21443118
        ]
    },
    "name": "F. Polycarp s problems",
    "statement": "Polycarp is an experienced participant in Codehorses programming\r\ncontests. Now he wants to become a problemsetter.He sent to the\r\ncoordinator a set of problems. Each problem has it’s quality, the\r\nquality of the -th problem is ( can be positive, negative or equal to\r\nzero). The problems are ordered by expected difficulty, but the\r\ndifficulty is not related to the quality in any way. The easiest problem\r\nhas index , the hardest problem has index .The coordinator’s mood is\r\nequal to now. After reading a problem, the mood changes by it’s quality.\r\nIt means that after the coordinator reads a problem with quality , the\r\nvalue is added to his mood. The coordinator always reads problems one by\r\none from the easiest to the hardest, it’s impossible to change the order\r\nof the problems.If after reading some problem the coordinator’s mood\r\nbecomes negative, he immediately stops reading and rejects the\r\nproblemset.Polycarp wants to remove the minimum number of problems from\r\nhis problemset to make the coordinator’s mood non-negative at any moment\r\nof time. Polycarp is not sure about the current coordinator’s mood, but\r\nhe has guesses \"the current coordinator’s mood \".For each of guesses,\r\nfind the minimum number of problems Polycarp needs to remove so that the\r\ncoordinator’s mood will always be greater or equal to while he reads\r\nproblems from the easiest of the remaining problems to the hardest.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld EPS = 1e-7;\n\nconst int N = 755;\nconst int M = 2e5 + 123;\n\nint n, m;\nint a[N];\n\nint calc(ll s) {\n    priority_queue<int> q;\n    int res = 0;\n    \n    for (int i = 0; i < n; i++) {\n        q.push(-a[i]);\n        s += a[i];\n        if (s < 0) {\n            s += q.top();\n            q.pop();\n            res++;\n        }\n    }\n    \n    return n - res;\n}\n\nll dp[N];\n\nint run() {\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n            \n    for (int val = 0; val <= n; val++) {\n        ll left = -1e12;\n        ll right = 1e12;\n        \n        while (right - left > 1) {\n            ll mid = (left + right) / 2;\n            if (calc(mid) >= val) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        \n        dp[val] = right;\n    }\n    \n    for (int i = 0; i < m; i++) {\n        ll q;\n        cin >> q;\n        \n        int ans = (int) (upper_bound(dp, dp + n + 1, q) - dp) - 1;\n        ans = n - ans;\n        cout << ans << \"\\n\";\n    }\n    \n    return 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    return run();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Polycarp s problems.json",
    "editorial_link": "https://codeforces.com//blog/entry/47773",
    "editorial": "At first letâs solve the problem for one value of . It is easy to show\r\nthat optimal solution is the following: add to the set of tasks next\r\ntask with quality equals to . While the value of mood (the sum of\r\nqualities and ) is less than 0, delete from the set of remaining task\r\nthe task with worst quality. The quality of such task will be less than\r\n0, because we will not spoil the mood on previous tasks. This solution\r\ncan be implement with help of structures or .Described solution helps us\r\nto find answer on the query in , but does not fill in time limit. Note,\r\nthat while we increase the number of deleted problems does not increase\r\nand the possible number of such numbers is only . So we need to solve\r\nthe following task: for calculate minimum value of that the number of\r\ndeleted problems does not exceed . This problem can be easily solved for\r\neach with help of binary search in , in sum for all we got . Also we\r\nhave an interest only values of , we can make the binary search only on\r\nthis values and in total we got For each answer with help of stored\r\nvalues we need to find the first answer which minimum value of does not\r\nmore than in the query. We can do it easy in or with binary search in\r\n(because the values for the answers does not increase). In total we will\r\nget or in sum.The best asymptotic behavior is but solutions which work\r\nin also passed all tests.\r\n",
    "hint": []
}