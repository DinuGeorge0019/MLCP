{"link": "https://codeforces.com//contest/861/problem/D", "problemId": "122872", "problem_idx": "D", "shortId": "861D", "contest_number": "861", "problem_submissions": {"B": [30441262, 30424376, 30427161, 30427960, 30424359, 30424926, 30425840, 30430094, 30424319, 30428309, 30428624, 30440366, 30437511, 30435804, 30427921, 30432832, 30423882], "F": [30440095, 30439628, 30440266, 30439498, 30441670, 30441500, 30452319, 30437084], "E": [30436514, 30436701, 30441404, 30443472, 30442827, 30445184, 30445314, 30443353, 30443911], "D": [30428168, 30427382, 30423887, 30433533, 30430871, 30432293, 30434646, 30433520, 30433941, 30433630, 30434459, 30436865, 30433644, 30426019, 30432738, 30434925, 30433542, 30432317, 30434703], "A": [30424689, 30422095, 30427679, 30422354, 30422107, 30422516, 30422863, 30426215, 30422101, 30424813, 30422256, 30425576, 30489148, 30430836, 30422849, 30423019, 30422141, 30422002], "C": [30423987, 30425801, 30429852, 30426800, 30428131, 30429744, 30425472, 30430400, 30430892, 30431289, 30440032, 30431284, 30432065, 30432412, 30435482, 30426919]}, "name": "D. Polycarp s phone book", "statement": "There are phone numbers in Polycarp\u2019s contacts on his phone. Each number\r\nis a 9-digit integer, starting with a digit different from . All the\r\nnumbers are distinct.There is the latest version of Berdroid OS\r\ninstalled on Polycarp\u2019s phone. If some number is entered, is shows up\r\nall the numbers in the contacts for which there is a substring equal to\r\nthe entered sequence of digits. For example, is there are three phone\r\nnumbers in Polycarp\u2019s contacts: , and , then: if he enters two numbers\r\nwill show up: and , if he enters two numbers will show up and , if he\r\nenters there will be only one number . For each of the phone numbers in\r\nPolycarp\u2019s contacts, find the minimum in length sequence of digits such\r\nthat if Polycarp enters this sequence, Berdroid shows this only phone\r\nnumber.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n// pulkit kapoor\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <cassert>\nusing namespace std; \n#define DEBUG(numx) cout << '>' << #numx << ':' << numx << endl;\n#define REP(idx1,num1) for(int idx1=0;idx1<(num1);idx1++)\n#define FOR(idx1,num1,bin) for(int idx1=(num1);idx1<=(bin);idx1++)\n#define FORD(idx1,num1,bin) for(int idx1=(num1);idx1>=(bin);idx1--)\ninline bool EQ(double num1, double bin) { return fabs(num1-bin) < 1e-9; }\nconst int INF = 1<<29;\ntypedef long long ll;\ninline int two(int num1) { return 1 << num1; }\ninline int test(int num1, int bin) { return (num1>>bin)&1; }\ninline void set_bit(int & num1, int bin) { num1 |= two(bin); }\ninline void unset_bit(int & num1, int bin) { num1 &= ~two(bin); }\ninline int last_bit(int num1) { return num1 & (-num1); }\ninline int ones(int num1) { int res = 0; while(num1 && ++res) num1-=num1&(-num1); return res; }\ntemplate<class T> void chmax(T & num1, const T & bin) { num1 = max(num1, bin); }\ntemplate<class T> void chmin(T & num1, const T & bin) { num1 = min(num1, bin); }\n#define SZ(num1) (int)(num1.size())\n#define SET(num1,bin) memset(num1,bin,sizeof(num1))\n#define LET(numx,num1) __typeof(num1) numx(num1)\n#define TR(vecc,it) for( LET(it,vecc.begin()) ; it != vecc.end() ; it++)\n#define repi(idx1,num1) for(int idx1=0; idx1<(int)num1;idx1++)\n#define si(num1) scanf(\"%d\",&num1)\n#define sll(num1) scanf(\"%lld\",&num1)\n#define DRT()  int test; cin>>test; while(test--)\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define ll long long\n#define TRACE\n \n//FILE *fin = freopen(\"in\",\"r\",stdin);\n//FILE *fout = freopen(\"out\",\"s2numx\",stdout);\n \n \n#ifdef TRACE\n#define trace1(numx)                cerr << #numx << \": \" << numx << endl;\n#define trace2(numx, to)             cerr << #numx << \": \" << numx << \" | \" << #to << \": \" << to << endl;\n#define trace3(numx, to, nn3)          cerr << #numx << \": \" << numx << \" | \" << #to << \": \" << to << \" | \" << #nn3 << \": \" << nn3 << endl;\n#define trace4(num1, bin, ch, d)       cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << endl;\n#define trace5(num1, bin, ch, d, e)    cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << \" | \" << #e << \": \" << e << endl;\n#define trace6(num1, bin, ch, d, e, det) cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << \" | \" << #e << \": \" << e << \" | \" << #det << \": \" << det << endl;\n \n#else\n \n#define trace1(numx)\n#define trace2(numx, to)\n#define trace3(numx, to, nn3)\n#define trace4(num1, bin, ch, d)\n#define trace5(num1, bin, ch, d, e)\n#define trace6(num1, bin, ch, d, e, det)\n \n#endif\n #define ll long long\n#define pi(numx) printf(\"%d\\num1\",numx)\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define cp int testCases;cin >> testCases; for(int test = 1 ; test <= testCases; test++)\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPII;\n#define mdd 1000000007\n#define fast ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define ll long long\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n \nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> vvec;\n\tmap<string, int> mp1;\n\tmap<int, string> mp2;\n\tfor(int i=0; i<n; i++){\n\t\tstring ss1;\n\t\tcin >> ss1;\n\t\tint tmp1 = stoi(ss1);\n\t\tvvec.pb(tmp1);\n\t\tfor(int j=0; j<9; j++){\n\t\t\tstring ss2 = \"\";\n\t\t\tfor(int k=j; k<9; k++){\n\t\t\t\tss2+=ss1[k];\n\t\t\t\tif(!mp1.count(ss2)){\n\t\t\t\t\tmp1[ss2] = tmp1;\n\t\t\t\t}\n\t\t\t\telse if (mp1[ss2] != tmp1){\n\t\t\t\t\tmp1[ss2] = -1;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(auto pai : mp1){\n\t\tif(pai.ss == -1) continue;\n\t\tint ss1 = pai.ss;\n\t\tstring tmp1 = pai.ff;\n\t\tif(!mp2.count(ss1)) \n\t\t    mp2[ss1] = tmp1;\n\t\telse{\n\t\t\tif(mp2[ss1].size() > tmp1.size())\n\t\t\t    mp2[ss1] = tmp1;\n\t\t}\n\t}\n\tfor(int i=0; i<vvec.size(); i++){\n\t\tcout << mp2[vvec[i]] << endl;\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "implementation", "strings"], "dificulty": "1600", "interactive": false}