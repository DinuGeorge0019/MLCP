{
    "link": "https://codeforces.com//contest/842/problem/C",
    "problemId": "120314",
    "problem_idx": "C",
    "shortId": "842C",
    "contest_number": "842",
    "problem_submissions": {
        "E": [
            29892175,
            29896709,
            29892728
        ],
        "C": [
            29876363,
            29876870,
            29881263,
            29880716,
            29891701,
            29882766,
            29881217,
            29877383,
            29881389,
            29887847,
            29882055,
            29876553,
            29885327,
            29897484,
            29879763,
            29887443,
            29895634,
            29895199,
            29916549,
            29916532,
            29916152,
            29891176,
            29895609
        ],
        "D": [
            29875168,
            29881874,
            29886504,
            29883941,
            29879589,
            29886046,
            29872999,
            29882468,
            29887643,
            29882954,
            29887687,
            29889517,
            29890953,
            29888540,
            29891985,
            29892689,
            29883468,
            29883460,
            29887258,
            29886746
        ],
        "B": [
            29874014,
            29874407,
            29872985,
            29872379,
            29886135,
            38859573,
            29873183,
            29883006,
            29876642,
            29873270,
            29874068,
            29874064,
            29886058,
            29876537,
            29878343,
            29881672,
            29872806,
            29873575,
            29872847,
            29873445,
            29873104
        ],
        "A": [
            29870801,
            29869133,
            29887434,
            29870152,
            29882916,
            29869760,
            29883576,
            29869196,
            29869793,
            29870793,
            29869617,
            29869267,
            29869102,
            29871125,
            29882379,
            29869173,
            29870818,
            29869360,
            29870433,
            29869454
        ]
    },
    "name": "C. Ilya And The Tree",
    "statement": "Ilya is very fond of graphs, especially trees. During his last trip to\r\nthe forest Ilya found a very interesting tree rooted at vertex . There\r\nis an integer number written on each vertex of the tree; the number\r\nwritten on vertex is equal to .Ilya believes that the beauty of the\r\nvertex is the greatest common divisor of all numbers written on the\r\nvertices on the path from the root to , including this vertex itself. In\r\naddition, Ilya can change the number in one arbitrary vertex to or leave\r\nall vertices unchanged. Now for each vertex Ilya wants to know the\r\nmaximum possible beauty it can have.\r\n",
    "solutions": [
        "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#define INF 0x3FFFFFFF\n#define MN 2005\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n#define MN 200000\nstruct edge{int nx,t;}e[MN*2+5];\nint a[MN+5],h[MN+5],en,v[MN+5],ans[MN+5];\ninline void ins(int x,int y)\n{\n\te[++en]=(edge){h[x],y};h[x]=en;\n\te[++en]=(edge){h[y],x};h[y]=en;\n}\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\nvoid dfs(int x,int fa,int d,int g)\n{\n\tans[x]=g;int i;\n\tfor(i=1;i*i<a[x];++i)if(a[x]%i==0)\n\t{\n\t\tif(++v[i]>=d)ans[x]=max(ans[x],i);\n\t\tif(++v[a[x]/i]>=d)ans[x]=max(ans[x],a[x]/i);\n\t}\n\tif(i*i==a[x]&&++v[i]>=d)ans[x]=max(ans[x],i);\n\tfor(i=h[x];i;i=e[i].nx)if(e[i].t!=fa)\n\t\tdfs(e[i].t,x,d+1,gcd(g,a[x]));\n\tfor(i=1;i*i<a[x];++i)if(a[x]%i==0)--v[i],--v[a[x]/i];\n\tif(i*i==a[x])--v[i];\n}\nint main()\n{\n\tint n=read(),i;\n\tfor(i=1;i<=n;++i)a[i]=read();\n\tfor(i=1;i<n;++i)ins(read(),read());\n\tdfs(1,0,0,0);\n\tfor(i=1;i<=n;++i)printf(\"%d \",ans[i]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "math",
        "number theory",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Ilya And The Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/54179",
    "editorial": "It\u00e2\u0080\u0099s easy to see that if the number written on some vertex is not equal\r\nto , then its beauty will be some divisor of . Also if the number\r\nwritten on the root is then the beauty of each vertex can be easily\r\ncalculated. Otherwise beauty of each vertex will be a divisor of the\r\nnumber in the root. Let\u00e2\u0080\u0099s calculate the beauty of each vertex if the\r\nnumber in the root is 0. This can be done by traversing the tree, and\r\nthe beauty of is . If the number in the root is not , then possible\r\nvalues of beauty for each vertex are among divisors of this number. For\r\neach of these divisors we can maintain how many numbers on the path from\r\nthe root to current vertex are divisible by that divisor. When we enter\r\nor leave some vertex, we need to update this information by iterating on\r\ndivisors of the number in the root. If we maintain it and current depth\r\n, then we can calculate the possible beauty of current vertex. It is\r\nequal to greatest divisor such that there are at least numbers on the\r\npath that are divisible by this divisor. https://ideone.com/uQNFX3\r\n"
}