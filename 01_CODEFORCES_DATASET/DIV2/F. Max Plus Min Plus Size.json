{
    "link": "https://codeforces.com//contest/2019/problem/F",
    "problemId": "2905358",
    "problem_idx": "F",
    "shortId": "2019F",
    "contest_number": "2019",
    "problem_submissions": {
        "F": [
            283223839,
            283223286,
            283233615,
            283232657,
            283229948,
            283240516,
            283246459,
            283246565,
            283251452,
            283250505,
            283246427,
            283244651,
            283250557,
            283250319,
            283249369,
            283252799,
            283231473,
            283385869
        ],
        "D": [
            283212674,
            283217889,
            283216603,
            283210525,
            283219753,
            283227849,
            283216187,
            283224832,
            283209439,
            283233196,
            283224958,
            283235552,
            283222166,
            283223408,
            283233229,
            283225040,
            283257759,
            283214659,
            283210870,
            283212555
        ],
        "C": [
            283205819,
            283208819,
            283200046,
            283197191,
            283204787,
            283192339,
            283195887,
            283200218,
            283196222,
            283200867,
            283211801,
            283203783,
            283208730,
            283210534,
            283225468,
            283214456,
            283200932,
            283202854,
            283202139,
            283199131
        ],
        "B": [
            283197247,
            283193710,
            283188887,
            283186540,
            283192007,
            283185443,
            283202984,
            283190900,
            283188420,
            283188733,
            283190635,
            283190801,
            283197405,
            283188473,
            283191300,
            283202121,
            283194633,
            283194452,
            283194664,
            283188555
        ],
        "A": [
            283194983,
            283181021,
            283181315,
            283181373,
            283182984,
            283180436,
            283198713,
            283181153,
            283180882,
            283182334,
            283181092,
            283183886,
            283188674,
            283181377,
            283181185,
            283196847,
            283190061,
            283183844,
            283182154,
            283180956
        ],
        "E": [
            283192360,
            283198927,
            283209740,
            283216991,
            283212803,
            283197800,
            283209059,
            283219624,
            283225534,
            283213304,
            283232353,
            283227746,
            283232779,
            283233925,
            283218649,
            283231587,
            283221137,
            283211364,
            283219849,
            283218893
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "The optimal subsequence must contain at least one occurrence of the maximum (r\n) (suppose it doesn't; then you can just add one occurrence, at the cost of removing at most two elements, and this does not make your score smaller).\n\nNow you can iterate over the minimum value (l\n), in decreasing order. At any moment, you can pick elements with values [l,r]\n. Then you have to support queries \"insert pick-able element\" and \"calculate score\".\n\nThe pick-able elements make some \"connected components\" of size s\n, and you can pick ?s/2?\n elements. You can maintain the components with a DSU.\n\nYou also want to pick an element with value r\n. For each component, check if it contains r\n in a subsequence with maximum size. If this does not happen for any component, your score decreases by 1\n. All this information can be maintained by storing, for each component, if it contains r\n in even positions, and if it contains r\n in odd positions.\n\nComplexity: O(n?(n))",
    "name": "F. Max Plus Min Plus Size",
    "statement": "You are given an array a_1, a_2,\r\nldots, a_n of positive integers.You can color some elements of the array\r\nred, but there cannot be two adjacent red elements (i.e., for 1\r\nleq i\r\nleq n-1, at least one of a_i and a_{i+1} must not be red).Your score is\r\nthe maximum value of a red element, plus the minimum value of a red\r\nelement, plus the number of red elements. Find the maximum score you can\r\nget.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;const int N=2e5+7;int T,n,a[N],id[N],maxxn,sum,ok;bool cmp(int x,int y){\treturn a[x]>a[y];}int sum_odd[N],sum_even[N];int fa[N],ans,minn[N],maxn[N];bool used[N];int find(int x){\treturn fa[x]==x?x:fa[x]=find(fa[x]);}int calc_odd(int l,int r){\tif(l%2==0)l++;\tif(r%2==0)r--;\tif(l>r)return 0;\tint u=sum_odd[r];\tif(l>1){\t\tu-=sum_odd[l-2];\t}\treturn u;}int calc_even(int l,int r){\tif(l%2==1)l++;\tif(r%2==1)r--;\tif(l>r)return 0;\tint u=sum_even[r];\tu-=sum_even[l-2];\treturn u;}void add(int x,int y){\tint od=maxn[x]-minn[x]+1;\tint l=minn[x],r=maxn[x],as=0;\tif(od%2==0){\t\tas+=calc_odd(l,r);\t\tas+=calc_even(l,r);\t}else{\t\tif(l%2==1){\t\t\tas+=calc_odd(l,r);\t\t}else as+=calc_even(l,r);\t}\tod=(od+1)/2;\tsum+=y*od;\tok+=y*as;\treturn;}void add(int i){\tused[i]=1;\tif(used[i-1]){\t\tint uu=find(i-1);\t\tadd(uu,-1);\t\tfa[uu]=i;\t\tminn[i]=min(minn[i],minn[uu]);\t}\tif(used[i+1]){\t\tint uu=find(i+1);\t\tadd(uu,-1);\t\tfa[uu]=i;\t\tmaxn[i]=max(maxn[i],maxn[uu]);\t}\tadd(i,1);\treturn;}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);\tcin>>T;\twhile(T--){\t\tcin>>n;\t\tmaxxn=0;\t\tfor(int i=1;i<=n;i++){\t\t\tcin>>a[i];\t\t\tid[i]=i;\t\t\tmaxxn=max(maxxn,a[i]);\t\t\tfa[i]=i;\t\t\tminn[i]=maxn[i]=i;\t\t}\t\tsort(id+1,id+n+1,cmp);\t\tfor(int i=1;i<=n;i++){\t\t\tif(i&1){\t\t\t\tif(i>1){\t\t\t\t\tsum_odd[i]=sum_odd[i-2];\t\t\t\t}\t\t\t\tif(a[i]==maxxn)sum_odd[i]++;\t\t\t}else{\t\t\t\tsum_even[i]=sum_even[i-2];\t\t\t\tif(a[i]==maxxn)sum_even[i]++;\t\t\t}\t\t}\t\tans=sum=ok=0;\t\tfor(int i=1;i<=n;i++){\t\t\tadd(id[i]);\t\t\tif(ok)ans=max(ans,maxxn+a[id[i]]+sum);\t\t\telse ans=max(ans,maxxn+a[id[i]]+sum-1);\t\t}\t\tcout<<ans<<\"\\n\";\t\tfor(int i=1;i<=n;i++){\t\t\tused[i]=0;\t\t\tsum_even[i]=sum_odd[i]=0;\t\t}\t}\treturn 0;}\u00a0/*___   ___   ___  ___ \u6700\u5927\u7684max\u00a0\u679a\u4e3emaxmax max+sum */"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "dsu",
        "greedy",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Max Plus Min Plus Size.json"
}