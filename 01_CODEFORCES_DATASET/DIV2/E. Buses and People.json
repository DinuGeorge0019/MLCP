{"link": "https://codeforces.com//contest/160/problem/E", "problemId": "978", "problem_idx": "E", "shortId": "160E", "contest_number": "160", "problem_submissions": {"E": [1302014, 1301400, 1301723, 1307282, 1307281], "C": [1300399, 1296100, 1297834, 1296838, 1295835, 1299587, 1298372, 1299856, 1297589, 1298396, 1305413, 1299188, 1297999, 1298453, 1300558, 1297702], "D": [1298476, 1301798, 1300820, 1302679, 1303700, 1303100, 1312626, 1301986, 1302012], "B": [1295207, 1297802, 1295947, 1295135, 1302419, 1297089, 1295596, 1298115, 1295467, 1296000, 1296940, 1295692, 1296028, 1296085, 1296588, 1295245], "A": [1294660, 1294871, 1294936, 1294584, 1302018, 1295798, 1294840, 1294601, 1294792, 1295753, 1294780, 1294924, 1351569, 1294961, 1294857, 1295932]}, "name": "E. Buses and People", "statement": "The main Bertown street is represented by a straight line. There are bus\r\nstops located on the line. The stops are numbered with integers from to\r\nin the order in which they follow on the road. The city has buses. Every\r\nday the -th bus drives from stop number to stop number (), it stops on\r\nall intermediate stops and returns only at night. The bus starts driving\r\nat time and drives so fast that it finishes driving also at time . The\r\ntime is different for all buses. The buses have infinite\r\ncapacity.Bertown has citizens. Today the -th person should get from stop\r\nnumber to stop number (); the -th citizen comes to his initial stop ()\r\nat time . Each person, on the one hand, wants to get to the destination\r\npoint as quickly as possible, and on the other hand, definitely does not\r\nwant to change the buses as he rides. More formally: the -th person\r\nchooses bus , with minimum time , such that , and . Your task is to\r\ndetermine for each citizen whether he can ride to the destination point\r\ntoday and if he can, find the number of the bus on which the citizen\r\nwill ride.\r\n", "solutions": ["/*\n * e.cpp\n *\n *  Created on: 2012-3-6\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\n#include <set>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nconst int MAX_N = 100000 + 10;\n\nstruct Tree {\n\tTree*pl, *pr;\n\tint l, r;\n\tpair<int, int> v;\n\n\tset<pair<int, int> > st;\n\n\tTree(int _l, int _r) :\n\t\t\tl(_l), r(_r) {\n\t\tint m = (l + r) >> 1;\n\t\tif (l + 1 == r) {\n\t\t\tpl = pr = 0;\n\t\t\tv = make_pair(INT_MAX, INT_MAX);\n\t\t\tst.insert(v);\n\t\t\treturn;\n\t\t}\n\t\tpl = new Tree(l, m);\n\t\tpr = new Tree(m, r);\n\t\tv = min(pl->v, pr->v);\n\t}\n\n\tvoid add(int at, pair<int, int> w) {\n\t\tif (l + 1 == r) {\n\t\t\tst.insert(w);\n\t\t\tv = *st.begin();\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tif (at < m)\n\t\t\tpl->add(at, w);\n\t\telse\n\t\t\tpr->add(at, w);\n\t\tv = min(pl->v, pr->v);\n\t}\n\n\tvoid remove(int at, pair<int, int> w) {\n\t\tif (l + 1 == r) {\n\t\t\tst.erase(w);\n\t\t\tv = *st.begin();\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tif (at < m)\n\t\t\tpl->remove(at, w);\n\t\telse\n\t\t\tpr->remove(at, w);\n\t\tv = min(pl->v, pr->v);\n\t}\n\n\tpair<int, int> ask(int L, int R) {\n\t\tif (L >= r || l >= R)\n\t\t\treturn make_pair(INT_MAX, INT_MAX);\n\t\tif (L <= l && R >= r) {\n\t\t\treturn v;\n\t\t}\n\t\treturn min(pl->ask(L, R), pr->ask(L, R));\n\t}\n}*root;\n\nint n, m;\nstruct Data {\n\tint l, r, t;\n\tint type, id;\n\tvoid read() {\n\t\tscanf(\"%d%d%d\", &l, &r, &t);\n\t}\n\n\tbool operator<(const Data&o) const {\n\t\treturn t != o.t ? t < o.t : type > o.type;\n\t}\n};\n\ntemplate<class T>\nstruct Index: public vector<T> {\n\tusing vector<T>::erase;\n\tusing vector<T>::begin;\n\tusing vector<T>::end;\n\tvoid doit() {\n\t\tsort(begin(), end());\n\t\terase(unique(begin(), end()), end());\n\t}\n\tint get(T x) {\n\t\treturn lower_bound(begin(), end(), x) - begin();\n\t}\n};\n\nData a[MAX_N * 2];\n\nIndex<int> idx;\n\nint ans[MAX_N];\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].read();\n\t\ta[i].type = 0;\n\t\ta[i].id = i;\n\t}\n\tfor (int i = n; i < n + m; ++i) {\n\t\ta[i].read();\n\t\ta[i].type = 1;\n\t\ta[i].id = i - n;\n\t}\n\tfor (int i = 0; i < n + m; ++i) {\n\t\tidx.push_back(a[i].l);\n\t\tidx.push_back(a[i].r);\n\t}\n\tidx.doit();\n\tfor (int i = 0; i < n + m; ++i) {\n\t\ta[i].l = idx.get(a[i].l);\n\t\ta[i].r = idx.get(a[i].r);\n\t}\n\tsort(a, a + n + m);\n\tTree*root = new Tree(0, idx.size());\n\n\tmemset(ans, -1, sizeof ans);\n\n\tfor (int i = 0; i < n + m; ++i) {\n\t\tif (a[i].type == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tpair<int, int> v = root->ask(a[i].l, a[i].r + 1);\n\t\t\t\tif (v.first <= a[i].r) {\n\t\t\t\t\tint who = v.second;\n\n\t\t\t\t\tans[a[who].id] = a[i].id + 1;\n\t\t\t\t\troot->remove(a[who].l, v);\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\troot->add(a[i].l, make_pair(a[i].r, i));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "sortings"], "dificulty": "2400", "interactive": false}