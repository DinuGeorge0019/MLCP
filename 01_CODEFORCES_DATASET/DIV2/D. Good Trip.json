{
    "link": "https://codeforces.com//contest/1925/problem/D",
    "problemId": "2447854",
    "problem_idx": "D",
    "shortId": "1925D",
    "contest_number": "1925",
    "problem_submissions": {
        "F": [
            243635672,
            243648922,
            243652277,
            243654463,
            243696386
        ],
        "E": [
            243616564,
            243621263,
            243626621,
            243628373,
            243642423,
            243636417,
            243643693,
            243633557,
            243638778,
            243637771,
            243645710,
            243648841,
            243629267,
            243713101,
            243632960,
            243654973,
            243648168,
            243647861,
            243652611,
            243647183,
            243650906
        ],
        "D": [
            243592234,
            243594869,
            243599958,
            243596486,
            243624513,
            243610640,
            243600801,
            243608352,
            243605500,
            243665895,
            243608581,
            243587140,
            243614894,
            243606314,
            243649266,
            243604378,
            243609277,
            243609750,
            243623206,
            243609456,
            249399690,
            243606073
        ],
        "C": [
            243570353,
            243577698,
            243576709,
            243576761,
            243588406,
            243564488,
            243578879,
            243585269,
            243576848,
            243595639,
            243608536,
            243585312,
            243573744,
            243571216,
            243580792,
            243582138,
            243591440,
            243576695,
            243587225,
            249717100,
            243587500
        ],
        "B": [
            243565143,
            243557943,
            243563278,
            243563287,
            243557566,
            243563680,
            243568156,
            243559337,
            243561416,
            243559345,
            243566711,
            243558705,
            243561296,
            243561403,
            243570584,
            243570498,
            243563900,
            243563678,
            243565505
        ],
        "A": [
            243556584,
            243556225,
            243557446,
            243557520,
            243556082,
            243557771,
            243560727,
            243556392,
            243556560,
            243556879,
            243556644,
            243556058,
            243556214,
            243556452,
            243557610,
            243558322,
            243556372,
            243556420,
            243556133
        ]
    },
    "name": "D. Good Trip",
    "statement": "There are n children in a class, m pairs among them are friends. The\r\ni-th pair who are friends have a friendship value of f_i. The teacher\r\nhas to go for k excursions, and for each of the excursions she chooses a\r\npair of children randomly, equiprobably and independently. If a pair of\r\nchildren who are friends is chosen, their friendship value increases by\r\n1 for all subsequent excursions (the teacher can choose a pair of\r\nchildren more than once). The friendship value of a pair who are not\r\nfriends is considered 0, and it does not change for subsequent\r\nexcursions. Find the expected value of the sum of friendship values of\r\nall k pairs chosen for the excursions (at the time of being chosen). It\r\ncan be shown that this answer can always be expressed as a fraction\r\ndfrac{p}{q} where p and q are coprime integers. Calculate p\r\ncdot q^{-1}\r\nbmod (10^9+7).\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <string>\n\nconst int64_t MOD = 1000000007LL;\n\nusing namespace std;\n\nbool __hack = ios::sync_with_stdio(false);\nauto __hack1 = cin.tie(nullptr);\n\ntemplate<typename T>\nT next() {\n    T x;\n    cin >> x;\n    return x;\n}\n\nint64_t mod_pow(int64_t a, int64_t b) {\n    int64_t r = 1;\n    while (b) {\n        if (b & 1) {\n            r = r * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return r;\n}\n\nint64_t mod_inv(int64_t a) {\n    return mod_pow(a, MOD - 2);\n}\n\nint main() {\n    vector<int64_t> fact(200001);\n    fact[0] = 1;\n    for (int i = 1; i < fact.size(); ++i) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    vector<int64_t> inv_fact(200001);\n    inv_fact[fact.size() - 1] = mod_inv(fact[fact.size() - 1]);\n    for (int i = fact.size() - 2; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n    auto binomial = [&](int n, int k) {\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n    };\n    int tests = next<int>();\n    for (int test = 0; test < tests; ++test) {\n        int64_t n = next<int>();\n        int64_t m = next<int>();\n        int64_t k = next<int>();\n        int64_t ans = 0;\n        int64_t p = mod_inv(n * (n - 1) / 2 % MOD);\n        int64_t q = (1 + MOD - p) % MOD;\n        int64_t coeff = k * p % MOD;\n        int64_t add = 0;\n        for (int64_t i = 1; i <= k; ++i) {\n            int64_t s = i * (i - 1) / 2 % MOD;\n            add = (add + s * binomial(k, i) % MOD * mod_pow(p, i) % MOD * mod_pow(q, k - i) % MOD) % MOD;\n        }\n        for (int i = 0; i < m; ++i) {\n            int a = next<int>();\n            int b = next<int>();\n            int64_t f = next<int64_t>();\n            if (f) {\n                ans = (ans + coeff * f + add) % MOD;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Good Trip.json",
    "editorial_link": "https://codeforces.com//blog/entry/125137",
    "editorial": "TutorialSince expected value is linear, we can consider the contribution\r\nof initial friendship values and the contribution of increase in\r\nfriendship values by repeated excursions independently.Let denote the\r\ntotal number of pairs of students that can be formed.Contribution of the\r\ninitial friendship values will be .Now, to calculate the contribution to\r\nthe answer by the increase in friendship values due to excursions, for\r\neach pair of friends, it will be where is the probability of a pair of\r\nfriends to be selected for exactly out of the excursions which is given\r\nby .Since the increase is uniform for all pair of friends, we just have\r\nto multiply this value by and add it to the answer.The time complexity\r\nis per test case.\r\n",
    "hint": []
}