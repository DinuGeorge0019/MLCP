{
    "link": "https://codeforces.com//contest/812/problem/C",
    "problemId": "108004",
    "problem_idx": "C",
    "shortId": "812C",
    "contest_number": "812",
    "problem_submissions": {
        "E": [
            27494142,
            27491477,
            27493766,
            27515655,
            27496725,
            27495067,
            27497471,
            27496279,
            27497446,
            27497581,
            27499309,
            27499707,
            27489928,
            27498644,
            27502197,
            27500634,
            27499517,
            27499414,
            27502641,
            27500094,
            27500259
        ],
        "B": [
            27491993,
            27495156,
            27497709,
            27512953,
            27489354,
            27496857,
            27494139,
            27493311,
            27490608,
            27494150,
            27488730,
            27492610,
            27500920,
            27493253,
            27490411,
            27496233,
            27491317,
            27491574,
            27492471,
            27492075,
            27490349
        ],
        "C": [
            27490421,
            27492136,
            27488817,
            27489120,
            27487355,
            27489159,
            27489035,
            27492785,
            27488367,
            27489931,
            27490104,
            27498191,
            27489300,
            27492185,
            27489814,
            27490763,
            27493690,
            27489337,
            27493758,
            27491206
        ],
        "A": [
            27487305,
            27493249,
            27495525,
            27491891,
            27490175,
            27487261,
            27487056,
            27487516,
            27499547,
            27493817,
            27487154,
            27503033,
            27487455,
            27486987,
            27488643,
            27487109,
            27486628,
            27487274,
            27487808,
            27486790
        ],
        "D": [
            27503386,
            27512794,
            27534240,
            27564141,
            27521512
        ]
    },
    "name": "C. Sagheer and Nubian Market",
    "statement": "On his trip to Luxor and Aswan, Sagheer went to a Nubian market to buy\r\nsome souvenirs for his friends and relatives. The market has some\r\nstrange rules. It contains different items numbered from to . The -th\r\nitem has base cost Egyptian pounds. If Sagheer buys items with indices ,\r\nthen the cost of item is for . In other words, the cost of an item is\r\nequal to its base cost in addition to its index multiplied by the factor\r\n.Sagheer wants to buy as many souvenirs as possible without paying more\r\nthan Egyptian pounds. Note that he cannot buy a souvenir more than once.\r\nIf there are many ways to maximize the number of souvenirs, he will\r\nchoose the way that will minimize the total cost. Can you help him with\r\nthis task?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#if __cplusplus >= 201103L\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#include <vector>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define FOR(i,a,b) for(int i=a;i<(b);i++)\n#define FORN(i,b) for(int i=0;i<(b);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> > vii;\n\nint n;\nll w,t,a[100005],c[100005];\n\nbool can(int k){\n\tFORN(i,n)c[i]=a[i]+1LL*(i+1)*k;\n\tsort(c,c+n);\n\tt=0;\n\tFORN(i,k)t+=c[i];\n\treturn t<=w;\n}\n\nint main(){\n\tscanf(\"%d%lld\",&n,&w);\n\tFORN(i,n)scanf(\"%lld\",a+i);\n\tint s=0,e=n+1;\n\twhile(e-s>1){\n\t\tint m=(s+e)/2;\n\t\tif(can(m))s=m;\n\t\telse e=m;\n\t}\n\tassert(can(s));\n\tprintf(\"%d %lld\\n\",s,t);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Sagheer and Nubian Market.json",
    "editorial_link": "https://codeforces.com//blog/entry/52318",
    "editorial": "If Sagheer can buy items, then he can also buy less than items because\r\nthey will be within his budget. If he can t buy items, then can t also\r\nbuy more than items because they will exceed his budget. So, we can\r\napply binary search to find the best value for . For each value , we\r\nwill compute the new prices, sort them and pick the minimum prices to\r\nfind the best minimum cost for items. Complexity: Implementation\r\n",
    "hint": []
}