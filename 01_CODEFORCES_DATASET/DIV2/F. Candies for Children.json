{
    "link": "https://codeforces.com//contest/1064/problem/F",
    "problemId": "236972",
    "problem_idx": "F",
    "shortId": "1064F",
    "contest_number": "1064",
    "problem_submissions": {
        "B": [
            44655610,
            44296972,
            44293144,
            44292773,
            44293812,
            44293718,
            44293000,
            44344754,
            44293975,
            44295190,
            44293365,
            44295370,
            44302868,
            44293963,
            44294620,
            44294475,
            44296374,
            44298406,
            44294385,
            44297171,
            44295746
        ],
        "A": [
            44655603,
            44292257,
            44291327,
            44291231,
            44292052,
            44291980,
            44291181,
            44344735,
            44291813,
            44291934,
            44291290,
            44294068,
            44291371,
            44291185,
            44291129,
            44291644,
            44291587,
            44296995,
            44291676,
            44291601,
            44292439
        ],
        "D": [
            44310987,
            44300224,
            44301769,
            44303356,
            44301800,
            44301521,
            44299632,
            44306110,
            44302195,
            44302177,
            44301311,
            44302882,
            44301868,
            44302023,
            44303439,
            44302526,
            44302660,
            44306757,
            44303670
        ],
        "E": [
            44303702,
            44306444,
            44305605,
            44306133,
            44308351,
            44308131,
            44310963,
            44309275,
            44308545,
            44310866,
            44307847,
            44308332,
            44308689,
            44308749,
            44307609,
            44306211,
            44309665,
            44312766,
            44308919
        ],
        "C": [
            44293719,
            44294513,
            44294217,
            44296068,
            44295654,
            44294557,
            44296176,
            44300122,
            44295991,
            44293129,
            44296152,
            44295799,
            44321133,
            44296946,
            44298909,
            44297762,
            44299676,
            44296772,
            44300478,
            44298201
        ],
        "F": [
            44354268
        ]
    },
    "name": "F. Candies for Children",
    "statement": "At the children’s festival, children were dancing in a circle. When\r\nmusic stopped playing, the children were still standing in a circle.\r\nThen Lena remembered, that her parents gave her a candy box with exactly\r\nk candies \"Wilky May\". Lena is not a greedy person, so she decided to\r\npresent all her candies to her friends in the circle. Lena knows, that\r\nsome of her friends have a sweet tooth and others do not. Sweet tooth\r\ntakes out of the box two candies, if the box has at least two candies,\r\nand otherwise takes one. The rest of Lena’s friends always take exactly\r\none candy from the box.Before starting to give candies, Lena step out of\r\nthe circle, after that there were exactly n people remaining there. Lena\r\nnumbered her friends in a clockwise order with positive integers\r\nstarting with 1 in such a way that index 1 was assigned to her best\r\nfriend Roma.Initially, Lena gave the box to the friend with number l,\r\nafter that each friend (starting from friend number l) took candies from\r\nthe box and passed the box to the next friend in clockwise order. The\r\nprocess ended with the friend number r taking the last candy (or two,\r\nwho knows) and the empty box. Please note that it is possible that some\r\nof Lena’s friends took candy from the box several times, that is, the\r\nbox could have gone several full circles before becoming empty.Lena does\r\nnot know which of her friends have a sweet tooth, but she is interested\r\nin the maximum possible number of friends that can have a sweet tooth.\r\nIf the situation could not happen, and Lena have been proved wrong in\r\nher observations, please tell her about this.\r\n",
    "solutions": [
        "//Williams Wu\n/*#include <EGE.h>  //��ͼͷ�ļ�\n#define SHOW_CONSOLE*/\n/*#include <cstdio> //��������/�������\n#include <iostream> //����������/���\n#include <algorithm> //STLͨ���㷨\n#include <cmath> //������ѧ����\n#include <cstdlib> //������������ڴ���亯��\n#include <cstring> //�ַ�������\n#include <string> //�ַ�����\n#include <ctime> //�������ʱ��ĺ���*/\n/*#include <bitset> //STLλ������\n#include <cstype> //�ַ�����\n#include <cerrno> //���������\n#include <complex> //������\n#include <clocale> //���屾�ػ�����\n#include <deque> //STL˫�˶�������\n#include <exception> //�쳣������\n#include <fstream> //�ļ�����/���\n#include <functional> //STL�������㺯��(���������)\n#include <limits> //�����������������ֵ����\n#include <list> //STL�����б�����\n#include <map> //STLӳ������\n#include <iomanip> //����������/���\n#include <ios> //��������/���֧��\n#include <iosfwd> //����/���ϵͳʹ�õ�ǰ������\n#include <istream> //����������\n#include <ostream> //���������\n#include <queue> //STL��������\n#include <set> //STL��������\n#include <sstream> //�����ַ�������\n#include <stack> //STL��ջ����\n#include <stdexcept> //��׼�쳣��\n#include <streambuf> //�ײ�����/���֧��\n#include <utility> //STLͨ��ģ����\n#include <vector> //STL��̬��������\n#include <cwchar.h>//���ַ���������/���\n#include <cwctype.h> //���ַ�����*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(x,y,z) for(LL x=(y);(x)<=(z);(x)++)\n#define rep_(x,y,z) for(int x=(y);(x)<(z);(x)++)\n#define repf(x,y,z) for(int x=(y);(x)>=(z);(x)--)\n#define repf_(x,y,z) for(int x=(y);(x)>(z);(x)--)\n#define inf 0x3f3f3f3f  //0x7fffffff\n#define cle(x) memset(x,0,sizeof(x))\n#define clemin(x) memset(x,-1,sizeof(x))\n#define clemax(x) memset(x,0x3f,sizeof(x))  //127\nconst double PI=3.14159265358979323846264338327950288419716939937510;\nconst double E=2.7182818284590452353602874713526624977572470936999596;\nconst double eps=0.000000001;\nconst int MOD=1000000007;\ntypedef long long LL;\ninline int max(int x,int y){return x>y?x:y;}\ninline int min(int x,int y){return x<y?x:y;}\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\n///////////////////////optimize//////////////////////////\ntemplate <typename T>\ninline void read(T& x){char ch;x=0;bool flag=0;ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')flag=1;ch=getchar();}\n  while((ch<='9'&&ch>='0')){x=x*10+ch-'0';ch=getchar();}if(flag)x*=-1;}\ntemplate <typename T>\ninline void read(T& x, T& y){read(x);read(y);}\ntemplate <typename T>\ninline void read(T& x, T& y, T& z){read(x);read(y);read(z);}\n/////////////////variables&functions/////////////////////\n\nint main()\n{\n\tLL n;\n\tread(n);\n\tLL l,r,len;\n\tread(l,r);\n\tif(r>=l) len=r-l+1;\n\t\telse len=r+n-l+1;\n\tLL k;\n\tread(k);\n\tLL ans=-1,lx,ly,rx,ry;\n\trep(y,0,2000000)\n\t{\n\t\tif(y>n) break;\n\t\tif(k-y+n-len*2<0) continue;\n\t\trx=(k-y+n-len*2)/(y+n);\n\t\tif(k<len) continue;\n\t\trx=min(rx,(k-len)/(y+n));\n\t\tLL tmp=max(0ll,k-len*2);\n\t\tif(tmp%(y+n)==0) lx=tmp/(y+n);\n\t\t\telse lx=tmp/(y+n)+1;\n\t\tif(lx<=rx) ans=max(ans,y);\n\t}\n\tif(len*2>=k&&len<=k) ans=max(ans,min(n,k+n-len*2));\n\trep(x,1,2000000)\n\t{\n\t\tLL tmp=k-x*n+n-len*2;\n\t\tif(tmp<0) continue;\n\t\try=tmp/(x+1);\n\t\tif(k<len) continue;\n\t\try=min(ry,(k-len)/x-n);\n\t\tif(ry<0) continue;\n\t\ttmp=max(0ll,k-len*2-x*n);\n\t\tif(tmp%x==0) ly=tmp/x;\n\t\t\telse ly=tmp/x+1;\n\t\try=min(ry,n);\n\t\tif(ly<=ry) ans=max(ans,ry);\n\t}\n\tk++;\n\trep(y,0,2000000)\n\t{\n\t\tif(y>n) break;\n\t\tif(k-y+n-len*2<0) continue;\n\t\trx=(k-y+n-len*2)/(y+n);\n\t\tif(k<=len) continue;\n\t\trx=min(rx,(k-(len+1))/(y+n));\n\t\tLL tmp=max(0ll,k-len-len);\n\t\tif(tmp%(y+n)==0) lx=tmp/(y+n);\n\t\t\telse lx=tmp/(y+n)+1;\n\t\tif(lx<=rx&&y>0) ans=max(ans,y);\n\t}\n\tif(len*2>=k&&len<=k&&min(n,k+n-len*2)>0) ans=max(ans,min(n,k+n-len*2));\n\trep(x,1,2000000)\n\t{\n\t\tLL tmp=k-x*n+n-len*2;\n\t\tif(tmp<0) continue;\n\t\try=tmp/(x+1);\n\t\tif(k<len+1) continue;\n\t\try=min(ry,(k-(len+1))/x-n);\n\t\tif(ry<0) continue;\n\t\ttmp=max(0ll,k-len*2-x*n);\n\t\tif(tmp%x==0) ly=tmp/x;\n\t\t\telse ly=tmp/x+1;\n\t\try=min(ry,n);\n\t\tif(ly<=ry&&ry>0) ans=max(ans,ry);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Candies for Children.json",
    "editorial_link": "https://codeforces.com//blog/entry/62455",
    "editorial": "Solution works in min(n2,k/n)\n time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.\n\nThis adds few more cases but the idea stays the same. Basically in the formulas below just few ?1\n will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.\n\nSo how to solve problem in n2\n?\n\nNote, that basically we have two parts of the circle  the part between [l;r]\n which get's candies one times more than the rest and the other one.\n\nSince we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as x\n and y\n.\n\nTo solve in n2\n let's bruteforce the number of sweet tooth on first part (a\n) and the number of sweet tooth on the second part (b\n).\n\nSuppose that there were full t\n loops. This way the number of eaten candies is a?2?(t+1)+(x?a)?1?(t+1)+b?2?t+(y?b)?1?t\n.\n\nThis should be equal to k\n. Since we just bruteforced the values of a\n and b\n we now just have linear equation. If it is solvable, consider relaxing answer with a+b\n.\n\nHow to solve problem in k/n\n?\n\nSo as the asymptotic suggests the amount of turns ?k/n\n, so we can bruteforce it instead.\n\nAlso it is worthy to handle case of 0\n turns specifically here since it produces some unpleasant effects otherwise.\n\nSo each person in \"x\n\" part of the circle eats candies t+1\n times (so each person contributes t+1\n or 2t+2\n) and the other persons have eaten candies t\n times (so each person contributes t\n or 2t\n).\n\nLet's account all persons as if they are not sweet tooths.\n\nSo now each person in x\n contributes 0\n or t+1\n and each person in y\n contributes 0\n or t\n.\n\nSo we basically have (t+1)a+tb=?\n. A Diophantine equation.\n\nCareful analysis or bits of theory suggest that the solutions are\n\na=a0?tz\n, b=b0+(t+1)z\n, for all integer z\n.\n\nWhere a0\n and b0\n some arbitrary solutions which we can get with formulas.\n\nAlso we need to have 0?a?x\n, 0?b?y\n, and the a+b?max\n.\n\nThese bounds imply that t\n takes values only in some range [t1;t2]\n.\n\nSince the a+b\n is linear function we can only consider t1\n and t2\n while searching for maximum a+b\n.",
    "hint": []
}