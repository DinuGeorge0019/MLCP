{
    "link": "https://codeforces.com//contest/916/problem/B",
    "problemId": "148025",
    "problem_idx": "B",
    "shortId": "916B",
    "contest_number": "916",
    "problem_submissions": {
        "D": [
            34326007,
            34322565,
            34563169,
            34324237,
            34325530,
            34324573,
            34324098,
            34325922,
            34326213
        ],
        "E": [
            34322258,
            34325502,
            34323285,
            34321851,
            34318358,
            34324148,
            34325404,
            34326324
        ],
        "C": [
            34310995,
            34313571,
            34311523,
            34309797,
            34318416,
            34314936,
            34314832,
            34312668,
            34312494,
            34311976,
            34311906,
            34316835,
            34313644,
            34314417,
            34316195,
            34307237,
            34308290,
            34307428,
            34311584,
            34315270
        ],
        "A": [
            34305522,
            34305848,
            34306019,
            34311849,
            34318455,
            34305611,
            34307081,
            34305645,
            34305601,
            34305829,
            34305615,
            34306758,
            34307093,
            34306724,
            34305983,
            34307982,
            34313895,
            34310913,
            34305897,
            34305681
        ],
        "B": [
            34321729,
            34337379,
            34311562,
            34312817,
            34317165,
            34316891,
            34316674
        ]
    },
    "name": "B. Jamie and Binary Sequence  changed after round ",
    "statement": "Jamie is preparing a Codeforces round. He has got an idea for a problem,\r\nbut does not know how to solve it. Help him write a solution to the\r\nfollowing problem:Find integers such that the sum of two to the power of\r\neach number equals to the number and the largest integer in the answer\r\nis as small as possible. As there may be multiple answers, you are asked\r\nto output the lexicographically largest one. To be more clear, consider\r\nall integer sequence with length with . Give a value to each sequence.\r\nAmong all sequence(s) that have the minimum value, output the one that\r\nis the lexicographically largest.For definitions of powers and\r\nlexicographical order see notes.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define bit(a , b) (((a)>>(b))&1)\n#define int ll\n\nconst int maxn = 1e6 + 20;\n\nint t[maxn * 2];\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tll n , k;\n\tcin >> n >> k;\n\tfor(int i = 0; i < 64; i++)\n\t\tif(bit(n , i))\n\t\t\tt[i + maxn]++ , k--;\n\tif(k < 0)\n\t\treturn cout << \"No\" << endl , 0;\n\tcout << \"Yes\" << endl;\n\tfor(int i = 2 * maxn - 1; i >= 1; i--)\n\t{\n\t\tif(k >= t[i])\n\t\t{\n\t\t\tk -= t[i];\n\t\t\tt[i - 1] += 2 * t[i];\n\t\t\tt[i] = 0;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor(int i = 1; i < 2 * maxn; i++)\n\t\tif(k && t[i])\n\t\t{\n\t\t\tk--;\n\t\t\tt[i]--;\n\t\t\tt[i - 1] += 2;\n\t\t\ti -= 2;\n\t\t}\n\tfor(int i = maxn * 2 - 1; i >= 0; i--)\n\t\tfor(int j = 0; j < t[i]; j++)\n\t\t\tcout << i - maxn << \" \";\n\tcout << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "greedy",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Jamie and Binary Sequence  changed after round .json",
    "editorial_link": "https://codeforces.com//blog/entry/57223",
    "editorial": "The main idea of the solution is\n, that means you can replace 1 element with 2 elements. To start with,\nexpress in binary powers of two. As we can only increase the number of\nelements, there is no solution if there exists more than elements. Let\u00e2\u0080\u0099s\nfix the value first. Observe that we can decrease the value only if all\ncan be changed to . So we scan from the largest power and try to break\nit down if doing so does not produce more than elements. After is fixed,\nwe can greedily decrease the smallest element while the number of\nelements is less than . My implementation: 34342011\n"
}