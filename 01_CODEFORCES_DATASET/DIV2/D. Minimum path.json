{
    "link": "https://codeforces.com//contest/1072/problem/D",
    "problemId": "240872",
    "problem_idx": "D",
    "shortId": "1072D",
    "contest_number": "1072",
    "problem_submissions": {
        "E": [
            44644399,
            44650543,
            44734034
        ],
        "D": [
            44632605,
            44632447,
            44632175,
            44637652,
            44635628,
            44637006,
            44633885,
            151267020,
            44638964,
            44635045,
            44638115,
            44637529,
            44637972,
            44638624,
            44636915,
            44640412,
            44642212,
            44637605,
            44638663,
            44639668,
            44680075,
            44642131
        ],
        "C": [
            44629439,
            44628133,
            44629672,
            44628147,
            44630750,
            44631571,
            44630332,
            44631317,
            44630520,
            44628174,
            44630246,
            44632020,
            44630576,
            44632772,
            44630621,
            44630463,
            44631591,
            44634217,
            44633521,
            44631795
        ],
        "B": [
            44628286,
            44626280,
            44627642,
            44625837,
            44627706,
            44628961,
            44626684,
            44627105,
            44628089,
            44633570,
            44627458,
            44628288,
            44627756,
            44630738,
            44627790,
            44627828,
            44631462,
            44628114,
            44627946,
            44628620
        ],
        "A": [
            44624145,
            44624123,
            44661469,
            44624742,
            44624134,
            44625024,
            44624914,
            44624126,
            44624358,
            44624143,
            44630174,
            44624249,
            44625453,
            44624220,
            44625169,
            44624173,
            44624200,
            44631557,
            44625268,
            44624520,
            44624259
        ],
        "F": [
            44725275
        ]
    },
    "name": "D. Minimum path",
    "statement": "You are given a matrix of size n\r\ntimes n filled with lowercase English letters. You can change no more\r\nthan k letters in this matrix.Consider all paths from the upper left\r\ncorner to the lower right corner that move from a cell to its\r\nneighboring cell to the right or down. Each path is associated with the\r\nstring that is formed by all the letters in the cells the path visits.\r\nThus, the length of each string is 2n - 1.Find the lexicographically\r\nsmallest string that can be associated with a path after changing\r\nletters in at most k cells of the matrix.A string a is lexicographically\r\nsmaller than a string b, if the first different letter in a and b is\r\nsmaller in a.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e3 + 5;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, k, dp[MAXN][MAXN];\nchar s[MAXN][MAXN], ans[MAXN * 2];\nint main() {\n\tread(n), read(k);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"\\n%s\", s[i] + 1);\n\tmemset(dp, -1, sizeof(dp));\n\tif (s[1][1] == 'a' || k >= 1) {\n\t\tans[1] = 'a';\n\t\tdp[1][1] = k - (s[1][1] != 'a');\n\t} else {\n\t\tans[1] = s[1][1];\n\t\tdp[1][1] = 0;\n\t}\n\tfor (int i = 2, now = 0, dest = 1; i <= 2 * n - 1; i++, swap(now, dest)) {\n\t\tchar opt = 'z';\n\t\tfor (int x = 1; x <= n; x++) {\n\t\t\tint y = i - x;\n\t\t\tif (y < 0 || y > n || dp[x][y] == -1) continue;\n\t\t\tif (dp[x][y]) opt = 'a';\n\t\t\tif (x + 1 <= n) chkmin(opt, s[x + 1][y]);\n\n\t\t\tif (y + 1 <= n) chkmin(opt, s[x][y + 1]);\n\t\t}\n\t\tans[i] = opt;\n\t\tfor (int x = 1; x <= n; x++) {\n\t\t\tint y = i - x;\n\t\t\tif (y < 0 || y > n || dp[x][y] == -1) continue;\n\t\t\tif (dp[x][y]) {\n\t\t\t\tif (x + 1 <= n) chkmax(dp[x + 1][y], dp[x][y] - (s[x + 1][y] != 'a'));\n\t\t\t\tif (y + 1 <= n) chkmax(dp[x][y + 1], dp[x][y] - (s[x][y + 1] != 'a'));\n\t\t\t} else {\n\t\t\t\tif (x + 1 <= n && s[x + 1][y] == opt) chkmax(dp[x + 1][y], dp[x][y]);\n\t\t\t\tif (y + 1 <= n && s[x][y + 1] == opt) chkmax(dp[x][y + 1], dp[x][y]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%s\\n\", ans + 1);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "greedy",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Minimum path.json",
    "editorial_link": "https://codeforces.com//blog/entry/62612",
    "editorial": "First, let's find the number of a-s in the beginning of the answer. To do this one can calculate dp[i][j] standing for the minimal number of non-a-s among all paths from the initial corner to (i, j). The number of a-s is simply the greatest (i+j)\n among all pairs (i,j)\n such that dp[i][j]?k\n (or 0\n, if there are no).\n\nConsider all cells where we can go right after obtaining the prefix of a-s. Now we repeat the following: append the minimal symbol in these cells to the answer, choose those cells and go from them in both possible directions to obtain the new set of cells. One can see that the answer we obtain is indeed the required answer."
}