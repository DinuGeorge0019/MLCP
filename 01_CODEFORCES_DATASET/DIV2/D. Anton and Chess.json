{"link": "https://codeforces.com//contest/734/problem/D", "problemId": "80476", "problem_idx": "D", "shortId": "734D", "contest_number": "734", "problem_submissions": {"F": [22242677, 22263963], "D": [22237702, 22238671, 22238436, 22238926, 22238773, 22237833, 22241230, 22239041, 22239616, 22240014, 22239208, 22240034, 22240178, 22236173, 22238427, 22246118, 22238956, 22239478, 22239903, 22238000], "C": [22234888, 22234918, 22235409, 22236073, 22235114, 22235451, 22235615, 22235516, 22234702, 22235336, 22234636, 22235118, 22237525, 22238970, 22235561, 22239159, 22235440, 22236588, 22236772, 22235639], "B": [22228951, 22228069, 22228596, 22229294, 22228497, 22229303, 22229501, 22229322, 22228369, 22229545, 22228175, 22229688, 22229766, 22229538, 22230326, 22233850, 22229247, 22231472, 22229353, 22228678], "A": [22226500, 22226334, 22226410, 22226760, 22226352, 22226714, 22226436, 22226603, 22226585, 22226921, 22226580, 22226632, 22227401, 22227664, 22229822, 22226975, 22228813, 22226738, 22226445], "E": [22241795, 22241633, 22241388, 22240916, 22242495, 22246165, 22242439, 22243868, 22243102, 22245799, 22245135, 22244767, 22245998, 22247226, 22236319, 22244870, 22244604, 22244885, 22244356]}, "name": "D. Anton and Chess", "statement": "Anton likes to play chess. Also, he likes to do programming. That is why\r\nhe decided to write the program that plays chess. However, he finds the\r\ngame on to board to too simple, he uses an infinite one instead.The\r\nfirst task he faced is to check whether the king is in check. Anton\r\ndoesn\u2019t know how to implement this so he asks you to help.Consider that\r\nan infinite chess board contains one white king and the number of black\r\npieces. There are only rooks, bishops and queens, as the other pieces\r\nare not supported yet. The white king is said to be in check if at least\r\none black piece can reach the cell with the king in one move. Help Anton\r\nand write the program that for the given position determines whether the\r\nwhite king is in check.Remainder, on how do chess pieces move: Bishop\r\nmoves any number of cells diagonally, but it can\u2019t \"leap\" over the\r\noccupied cells. Rook moves any number of cells horizontally or\r\nvertically, but it also can\u2019t \"leap\" over the occupied cells. Queen is\r\nable to move any number of cells horizontally, vertically or diagonally,\r\nbut it also can\u2019t \"leap\".\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <list>\n#include <stack>\n#include <deque>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <ctime>\n#include <iterator>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\nconst int maxn = 100500;\nconst int inf = 2e9;\nconst double eps = 1e-8;\nconst int base = 1073676287;\n\npair < int, int > Hl, Hr, Vh, Vd, MainD1, MainD2, SecD1, SecD2;\n\nvoid updateH( int x, int y, int x0, int y0, char type ) {\n\tif ( y < y0 ) {\n\t\tif ( !Hl.f || Hl.s < y )\n\t\t\tHl = mp( type, y );\n\t\treturn;\n\t}\n\tif ( !Hr.f || Hr.s > y )\n\t\tHr = mp( type, y );\n}\n\nvoid updateV( int x, int y, int x0, int y0, char type ) {\n\tif ( x < x0 ) {\n\t\tif ( !Vh.f || Vh.s < x )\n\t\t\tVh = mp( type, x );\n\t\treturn;\n\t}\n\tif ( !Vd.f || Vd.s > x )\n\t\tVd = mp( type, x );\n}\n\nvoid updateMainD( int x, int y, int x0, int y0, char type ) {\n\tint delta = abs( x - x0 );\n\tif ( x < x0 ) {\n\t\tif ( !MainD1.f || MainD1.s > delta )\n\t\t\tMainD1 = mp( type, delta );\n\t\treturn;\n\t}\n\tif ( !MainD2.f || MainD2.s > delta )\n\t\tMainD2 = mp( type, delta );\n}\n\nvoid updateSecD( int x, int y, int x0, int y0, char type ) {\n\tint delta = abs( x - x0 );\n\tif ( x < x0 ) {\n\t\tif ( !SecD1.f || SecD1.s > delta )\n\t\t\tSecD1 = mp( type, delta );\n\t\treturn;\n\t}\n\tif ( !SecD2.f || SecD2.s > delta )\n\t\tSecD2 = mp( type, delta );\n}\n\nint main()\n{\n    srand( time( 0 ) );\n    // freopen( \"input.txt\", \"r\", stdin );\n    // freopen( \"output.txt\", \"w\", stdout );\n    // ios_base::sync_with_stdio(false);\n    int n;\n    int x0, y0;\n    scanf ( \"%d%d%d\\n\", &n, &x0, &y0 );\n    for ( int j = 0; j < n; j++ ) {\n    \tint x, y;\n    \tchar type;\n    \tscanf ( \"%c %d %d\\n\", &type, &x, &y );\n    \tif ( x == x0 )\n    \t\tupdateH( x, y, x0, y0, type );\n    \tif ( y == y0 )\n    \t\tupdateV( x, y, x0, y0, type );\n    \tint delta1 = x - x0;\n    \tint delta2 = y - y0;\n    \tif ( delta1 == delta2 )\n    \t\tupdateMainD( x, y, x0, y0, type );\n    \tif ( delta1 == -delta2 )\n    \t\tupdateSecD( x, y, x0, y0, type );\n    }\n    if ( Hl.f == 'R' || Hl.f == 'Q' ) {\n    \tputs( \"YES\" );\n    \treturn 0;\n    }\n    if ( Hr.f == 'R' || Hr.f == 'Q' ) {\n    \tputs( \"YES\" );\n    \treturn 0;\n    }\n    if ( Vh.f == 'R' || Vh.f == 'Q' ) {\n    \tputs( \"YES\" );\n    \treturn 0;\n    }\n    if ( Vd.f == 'R' || Vd.f == 'Q' ) {\n    \tputs( \"YES\" );\n    \treturn 0;\n    }\n\n    if ( MainD1.f == 'B' || MainD1.f == 'Q' ) {\n    \tputs( \"YES\" );\n    \treturn 0;\n    }\n    if ( MainD2.f == 'B' || MainD2.f == 'Q' ) {\n    \tputs( \"YES\" );\n    \treturn 0;\n    }\n    if ( SecD1.f == 'B' || SecD1.f == 'Q' ) {\n    \tputs( \"YES\" );\n    \treturn 0;\n    }\n    if ( SecD2.f == 'B' || SecD2.f == 'Q' ) {\n    \tputs( \"YES\" );\n    \treturn 0;\n    }\n    puts( \"NO\" );\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "1700", "interactive": false}