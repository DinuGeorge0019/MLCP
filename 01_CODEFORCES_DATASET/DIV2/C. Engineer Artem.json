{
    "link": "https://codeforces.com//contest/1438/problem/C",
    "problemId": "793474",
    "problem_idx": "C",
    "shortId": "1438C",
    "contest_number": "1438",
    "problem_submissions": {
        "F": [
            98319461
        ],
        "E": [
            98311897,
            98314215,
            98306470,
            98317401,
            98315562,
            98322785,
            98318720,
            99208201,
            99208187,
            99208130,
            98328285,
            98328073,
            98322490,
            98320922,
            98318257,
            98322974,
            98321581
        ],
        "D": [
            98297867,
            98301844,
            98300240,
            98304054,
            98318299,
            98309651,
            98315030,
            98308693,
            98315767,
            98313297,
            98316364,
            98315158,
            98303678,
            98304345,
            98304632,
            98306346,
            98305264,
            98305346,
            98303552,
            98306335
        ],
        "C": [
            98289953,
            98289036,
            98308314,
            98293256,
            98292637,
            98297135,
            98292890,
            98294300,
            98300290,
            98319932,
            98304074,
            98317336,
            98290569,
            98289827,
            98289903,
            98288415,
            98294636,
            98293103,
            98292335,
            98295796
        ],
        "B": [
            98286960,
            98285186,
            98298192,
            98293037,
            98287297,
            98288613,
            98287215,
            98290416,
            98288546,
            98286932,
            98293844,
            98285378,
            98286885,
            98286961,
            98287702,
            98285226,
            98286945,
            98289425,
            98287421,
            98290261
        ],
        "A": [
            98283268,
            98281489,
            98282933,
            98292930,
            98282693,
            98281140,
            98281789,
            98285668,
            98284421,
            98282468,
            98283785,
            98281307,
            98281791,
            98283429,
            98281766,
            98282741,
            98281310,
            98282372,
            98281634,
            98285176
        ]
    },
    "name": "C. Engineer Artem",
    "statement": "Artem is building a new robot. He has a matrix a consisting of n rows\r\nand m columns. The cell located on the i-th row from the top and the\r\nj-th column from the left has a value a_{i,j} written in it. If two\r\nadjacent cells contain the same value, the robot will break. A matrix is\r\ncalled if no two adjacent cells contain the same value, where two cells\r\nare called adjacent if they share a side. Artem wants to to make a\r\ngood.More formally, find a good matrix b that satisfies the following\r\ncondition For all valid (i,j), either b_{i,j} = a_{i,j} or b_{i,j} =\r\na_{i,j}+1. For the constraints of this problem, it can be shown that\r\nsuch a matrix b always exists. If there are several such tables, you can\r\noutput any of them. Please note that you do not have to minimize the\r\nnumber of increments.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n\n        static int a[103][103];\n\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                cin >> a[i][j];\n                if((a[i][j] + i + j) & 1)\n                    a[i][j]++;\n            }\n        }\n\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j)\n                cout << a[i][j] << \" \";\n            cout << '\\n';\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "chinese remainder theorem",
        "constructive algorithms",
        "fft",
        "flows"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Engineer Artem.json",
    "editorial_link": "https://codeforces.com//blog/entry/84589",
    "editorial": "The increment by one operation essentially allows us to change the\r\nparity of any position. Letâs color the matrix like a chessboard. Since\r\nevery pair of adjacent cells consist of cells with different colors, we\r\ncan make values at all black cells even and values at all white cells\r\nodd.\r\n",
    "hint": []
}