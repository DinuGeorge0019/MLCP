{
    "link": "https://codeforces.com//contest/1106/problem/E",
    "problemId": "290934",
    "problem_idx": "E",
    "shortId": "1106E",
    "contest_number": "1106",
    "problem_submissions": {
        "F": [
            49265817,
            49264923,
            49266558,
            49269257,
            49271213,
            49272184,
            49272969,
            49267903,
            49273554,
            49895559,
            49298045,
            49263114,
            49273336,
            49274102,
            49274867,
            49300428,
            49276394,
            49277229,
            49269016,
            49266937,
            49277423,
            49277280,
            49269846
        ],
        "E": [
            49261808,
            49267815,
            49266852,
            49261526,
            49261539,
            49258516,
            49262159,
            49269184,
            49261973,
            49895562,
            49273364,
            49263914,
            49261370,
            49261525,
            49300401,
            49261737,
            49261915,
            49273907,
            49276075,
            49262981,
            49266273,
            49276021
        ],
        "B": [
            49257277,
            49252209,
            49248876,
            49251236,
            49256788,
            49251411,
            49251144,
            49255473,
            49251954,
            49895487,
            49263583,
            49254902,
            49252783,
            49253845,
            49300101,
            49250570,
            49252035,
            49259947,
            49251497,
            49253887,
            49260721,
            49251319
        ],
        "D": [
            49252880,
            49254281,
            49252504,
            49255122,
            49251697,
            49253429,
            49254193,
            49257749,
            49255378,
            49895514,
            49296674,
            49250135,
            49257979,
            49256084,
            49256833,
            49300300,
            49255435,
            49255524,
            49255367,
            49255410,
            49258191,
            49255067,
            49255106
        ],
        "C": [
            49249200,
            49252258,
            49250171,
            49253405,
            49249251,
            49247144,
            49252242,
            49250452,
            49253463,
            49895495,
            49252232,
            49249038,
            49255058,
            49255040,
            49300208,
            49300199,
            49252907,
            49253665,
            49252133,
            49253357,
            49255807,
            49250684,
            49253071
        ],
        "A": [
            49246544,
            49245865,
            49245896,
            49246235,
            49246566,
            49245858,
            49246274,
            49248820,
            49246242,
            49895480,
            49249300,
            49246352,
            49247004,
            49246275,
            49300057,
            49300056,
            49246548,
            49246161,
            49246888,
            49246017,
            49246734,
            49261784,
            49245817
        ]
    },
    "name": "E. Lunar New Year and Red Envelopes",
    "statement": "But collecting money from red envelopes is a time-consuming process\r\nitself.Let\u2019s describe this problem in a mathematical way. Consider a\r\ntimeline from time 1 to n. The i-th red envelope will be available from\r\ntime s_i to t_i, inclusive, and contain w_i coins. If Bob chooses to\r\ncollect the coins in the i-th red envelope, he can do it only in an\r\npoint of time between s_i and t_i, inclusive, and he can\u2019t collect any\r\nmore envelopes until time d_i (inclusive) after that. Here s_i\r\nleq t_i\r\nleq d_i holds.Bob is a greedy man, he collects coins greedily whenever\r\nhe can collect coins at some integer time x, he collects the available\r\nred envelope with the maximum number of coins. If there are multiple\r\nenvelopes with the same maximum number of coins, Bob would choose the\r\none whose parameter d is the . If there are still multiple choices, Bob\r\nwill choose one from them randomly.However, Alice his daughter doesn\u2019t\r\nwant her father to get too many coins. She could disturb Bob at no more\r\nthan m integer time moments. If Alice decides to disturb Bob at time x,\r\nhe could not do anything at time x and resumes his usual strategy at the\r\ntime x + 1 (inclusive), which may lead to missing some red\r\nenvelopes.Calculate the minimum number of coins Bob would get if Alice\r\ndisturbs him optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110000;\nconst int M = 220;\n\nlong long dp[N][M];\nmultiset<pair<int, int> > S;\nvector<pair<int, int> > vec[N], era[N];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tint n, m, k; cin >> n >> m >> k;\n\tfor (int i = 1; i <= k; i++) {\n\t\tint s, t, d, w; cin >> s >> t >> d >> w;\n\t\tvec[t].push_back(make_pair(-w, -d));\n\t\tera[s].push_back(make_pair(-w, -d));\n\t}\n\tfor (int i = n; i >= 1; i--) {\n\t\tfor (auto e : vec[i]) S.insert(e);\n\t\tpair<int, int> ma = make_pair(0, 0);\n\t\tif (!S.empty()) ma = *S.begin();\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tdp[i][j] = dp[ma.first ? -(ma.second) + 1 : i + 1][j] - ma.first;\n\t\t\tif (j) dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]);\n\t\t}\n\t\tfor (auto e : era[i]) S.erase(S.lower_bound(e));\n\t}\n\tcout << dp[1][m] << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Lunar New Year and Red Envelopes.json",
    "editorial_link": "https://codeforces.com/blog/entry/64928",
    "editorial": "Yes, this is where Alice shows up and ... probably the problem is not\r\nrelated to Game Theory. Let\u00e2\u0080\u0099s divide the problem into two parts: The\r\nfirst is to obtain the maximum coins Bob can get from time points to ,\r\nand the second is to decide when to disturb Bob.For the first part, we\r\napply event sorting to those time segments. After that, we use a set\r\nwith a sweep line to deal with it. Whenever we meet a start or a\r\nterminate of one red envelope, we add this into the set or remove that\r\nfrom the set. Note that you need to use , since there can be multiple\r\nred envelopes with same and .For the second part, we apply dynamic\r\nprogramming since is relatively small. Let denote that the minimum coins\r\nBob gets when we only consider the timeline from to and Alice disturbs\r\nBob for times. The transition is trivial and you can take a look at it\r\nin the code.\r\n"
}