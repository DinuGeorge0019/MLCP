{
    "link": "https://codeforces.com//contest/659/problem/E",
    "problemId": "53563",
    "problem_idx": "E",
    "shortId": "659E",
    "contest_number": "659",
    "problem_submissions": {
        "G": [
            17048942,
            17051082,
            17053499,
            17056302,
            17057443,
            17052627,
            17057183,
            17057162,
            17076131,
            17045172,
            17053158,
            17056518
        ],
        "F": [
            17047834,
            17053774,
            17049969,
            17050820,
            17052174,
            17056026,
            17050842,
            17053250,
            17050852,
            17050686,
            17050499,
            17050611,
            17052481,
            17064456,
            17051398,
            17051617,
            17051540,
            17050465
        ],
        "E": [
            17042676,
            17043109,
            17045262,
            17042718,
            17047927,
            17046574,
            17040925,
            17048651,
            17040880,
            17052066,
            17041600,
            17046501,
            17046168,
            17045890,
            17045191,
            17046107,
            17048339,
            17043013,
            17046378
        ],
        "D": [
            17040164,
            17050025,
            17044036,
            17045724,
            17041432,
            17042750,
            17045206,
            17042744,
            17045258,
            17053191,
            17040131,
            17041993,
            17045154,
            20417581,
            17042968,
            17047543,
            17044200,
            17041493,
            17046806,
            17044650
        ],
        "B": [
            17039409,
            17039152,
            17039943,
            17044093,
            17038870,
            17038621,
            17044105,
            17040190,
            17043575,
            17055274,
            17038055,
            17038759,
            17039771,
            17039240,
            17039293,
            17039271,
            17043285,
            17040658,
            17040098
        ],
        "C": [
            17039394,
            17040359,
            17041969,
            17039075,
            17037528,
            17039602,
            17038719,
            17041409,
            17038514,
            17053925,
            17038798,
            17040270,
            17038600,
            17041901,
            17040814,
            17041935,
            17039324,
            17039760,
            17041613
        ],
        "A": [
            17037687,
            17039404,
            17037482,
            17037338,
            17052801,
            17037726,
            17040138,
            17037138,
            17055546,
            17037115,
            17039098,
            17037248,
            17037187,
            17037309,
            17038070,
            17037352,
            17037563
        ]
    },
    "name": "E. New Reform",
    "statement": "Berland has cities connected by bidirectional roads. No road connects a\r\ncity to itself, and each pair of cities is connected by no more than one\r\nroad. It is that you can get from any city to any other one, using only\r\nthe existing roads.The President of Berland decided to make changes to\r\nthe road system and instructed the Ministry of Transport to make this\r\nreform. Now, each road should be unidirectional (only lead from one city\r\nto another).In order not to cause great resentment among residents, the\r\nreform needs to be conducted so that there can be as few separate cities\r\nas possible. A city is considered , if no road leads into it, while it\r\nis allowed to have roads leading from this city.Help the Ministry of\r\nTransport to find the minimum possible number of separate cities after\r\nthe reform.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, u, v, fa[100005], tot[100005] = {0}, TOT[100005] = {0};\nint findfa(int x){return fa[x] == x? x : fa[x] = findfa(fa[x]);}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) fa[i] = i, tot[i] = 1, TOT[i] = 0;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu = findfa(u), v = findfa(v);\n\t\tif (u == v) TOT[u]++;\n\t\telse\n\t\t{\n\t\t\tfa[u] = v;\n\t\t\ttot[v] += tot[u];\n\t\t\tTOT[v] += TOT[u] + 1;\n\t\t\ttot[u] = TOT[u] = 0;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfindfa(i);\n\t\tif (fa[i] == i) ans += tot[i] > TOT[i]? 1 : 0;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. New Reform.json",
    "editorial_link": "https://codeforces.com//blog/entry/44093",
    "editorial": "One should notice, that for every connected component of the graph the\r\nproblem could be solved independently, so we just need to solve the\r\nproblem for any connected graph. Let this connected graph (of vertices)\r\ncontain edge (such is called a tree). If one maintain a DFS from any of\r\nits vertex, every edge will be oriented, and each of them could given to\r\nits ending vertex, this way every vertex (except the one we launched DFS\r\nfrom, that is the root) will be satisfied by an edge. In this case the\r\nanswer is equal to . Let\u00e2\u0080\u0099s then deal with a case when the graph contains\r\nmore than edges. This graph contains at least one cycle. Let\u00e2\u0080\u0099s take\r\narbitrary vertex from any of the cycles and launch a DFS (as above) from\r\nit. All vertices except chosen will be satisfied, so we are to give an\r\nedge to the chosen vertex. As soon as chosen vertex belongs to a cycle,\r\nat least one of its edge will not be taken to account in the DFS, so it\r\ncan be given to a root. This way all the vertices will be satisfied. Now\r\nwe are able to solve the task for any connected graph, so we are to\r\ndivide the graph into a connected components this can be easily done by\r\nDFS or BFS. The solution complexity is .\r\n"
}