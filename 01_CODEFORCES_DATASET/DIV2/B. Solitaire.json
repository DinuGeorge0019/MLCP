{
    "link": "https://codeforces.com//contest/208/problem/B",
    "problemId": "1578",
    "problem_idx": "B",
    "shortId": "208B",
    "contest_number": "208",
    "problem_submissions": {
        "E": [
            1931263,
            1927824,
            1940917,
            1948656,
            36290584,
            1939808,
            1937161,
            1932047,
            1932077
        ],
        "C": [
            1928931,
            1931391,
            1928213,
            1929670,
            1928209,
            1928353,
            1929933,
            1927379,
            1929594,
            1928751,
            1930544,
            1930482,
            1930992,
            1929917,
            1931270,
            1930709,
            1931133
        ],
        "B": [
            1927386,
            1932558,
            1929923,
            1928218,
            1930610,
            1930208,
            1928807,
            1930969,
            1927627,
            1930670,
            1928423,
            1927797,
            1928378,
            1928980,
            1928852
        ],
        "D": [
            1925890,
            1925434,
            1926145,
            1926157,
            1925983,
            1925956,
            1925579,
            1928233,
            1930197,
            1926282,
            1926515,
            1926378,
            1926735,
            1926780,
            1925704,
            1929547
        ],
        "A": [
            1925047,
            1924758,
            1924977,
            1925009,
            1924805,
            1924742,
            1924870,
            1924729,
            1925347,
            1924867,
            1924876,
            1925279,
            1925817,
            1925469,
            1924754,
            1925708
        ]
    },
    "name": "B. Solitaire",
    "statement": "A boy named Vasya wants to play an old Russian solitaire called\r\n\"Accordion\". In this solitaire, the player must observe the following\r\nrules: A deck of cards is carefully shuffled, then all cards are put on\r\nthe table in a line from left to right; Before each move the table has\r\nseveral piles of cards lying in a line (initially there are piles, each\r\npile has one card). Let’s number the piles from left to right, from 1 to\r\n. During one move, a player can take the whole pile with the maximum\r\nnumber (that is the rightmost of remaining) and put it on the top of\r\npile (if it exists) or on the top of pile (if it exists). The player can\r\nput one pile on top of another one only if the piles’ top cards have the\r\nsame suits or values. Please note that if pile goes on top of pile ,\r\nthen the top card of pile becomes the top card of the resulting pile.\r\nAlso note that each move decreases the total number of piles by 1; The\r\nsolitaire is considered completed if all cards are in the same pile.\r\nVasya has already shuffled the cards and put them on the table, help him\r\nunderstand whether completing this solitaire is possible or not.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<stdlib.h>\n#include<cstring>\n#include<iostream>\n#include<ctype.h>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#include<iomanip>\n#include<complex>\n#include<utility>\n\n#define X first\n#define Y second\n#define REP_0(i,n) for(int i=0;i<(n);++i)\n#define REP_1(i,n) for(int i=1;i<=(n);++i)\n#define REP_2(i,a,b) for(int i=(a);i<(b);++i)\n#define REP_3(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c))\n#define DOW_0(i,n) for(int i=(n)-1;-1<i;--i)\n#define DOW_1(i,n) for(int i=(n);0<i;--i)\n#define DOW_2(i,a,b) for(int i=(b);(a)<i;--i)\n#define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i)\n#define FOREACH(a,b) for(typeof(b.begin()) a=(b).begin();a!=(b).end();++a)\n#define RFOREACH(a,b) for(typeof(b.rbegin()) a=(b).rbegin();a!=b.rend();++a)\n#define PB push_back\n#define PF push_front\n#define MP make_pair\n#define IS insert\n#define ES erase\n#define IT iterator\n#define RI reserve_iterator\n#define PQ priority_queue\n#define LB lower_bound\n#define UB upper_bound\n\n#define PI 3.1415926535897932384626433832795\n#define EXP 2.7182818284590452353602874713527\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef double DB;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef pair<int,PII> PIII;\ntypedef pair<LD,int> PLDI;\ntypedef vector<PII> VII;\n\ntemplate<class T>\nT By(T x,T y,T P){\n\tT F1=0;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1+=x;\n\t\t\tif(F1<0||F1>=P)F1-=P;\n\t\t}\n\t\tx<<=1;\n\t\tif(x<0||x>=P)x-=P;\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Mul(T x,T y,T P){\n\tT F1=1;x%=P;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1=By(F1,x,P);\n\t\t}\n\t\tx=By(x,x,P);\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Gcd(T x,T y){\n\tif(y==0)return x;\n\tT z;\n\twhile(z=x%y){\n\t\tx=y,y=z;\n\t}\n\treturn y;\n}\n\nstruct EDGE{\n\tint T;EDGE *Nxt;\n};\n\ntemplate<class T>\nvoid UpdataMin(T &x,T y){\n\tif(y<x)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nvoid UpdataMax(T &x,T y){\n\tif(x<y)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nT Sqr(const T x){\n\treturn x*x;\n}\n\n#define MaxBuffer 20000000\nclass ReadBuffer{\n\tchar buff[MaxBuffer];\n\tchar *buf;\n\tvoid init(int size=MaxBuffer)\n\t{\n\t\tfread(buff,1,size,stdin);\n\t}\n\ttemplate<class T>\n\tbool readInterger(T &x)\n\t{\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag;\n\t\tflag=0;\n\t\tif(*buf=='-') flag=true;\n\t\telse x=*buf-'0';\n\t\twhile(isdigit(*++buf)) x=x*10+*buf-'0';\n\t\tif(flag) x=-x;\n\t\treturn true;\n\t}\n\ttemplate<class T>\n\tbool readFloat(T &x)\n\t{\n\t\tlong double nowpos=0.1;\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag,decimal;\n\t\tdecimal=flag=0;\n\t\tif(*buf=='-') flag=true,++buf;\n\t\telse if(*buf=='.') decimal=true;\n\t\twhile(isdigit(*buf)||*buf=='.')\n\t\t{\n\t\t\tif(*buf=='.') decimal=true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(decimal)\n\t\t\t\t{\n\t\t\t\t\tx+=nowpos*(*buf-'0');\n\t\t\t\t\tnowpos*=0.1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tx=x*10+*buf-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t++buf;\n\t\t}\n\t\treturn true;\n\t}\n\tbool readChar(char c)\n\t{\n\t\tif(*buf==0) return 0;\n\t\treturn c=*buf++,1;\n\t}\n\tbool readString(char *s)\n\t{\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(!*buf) return false;\n\t\twhile(!isspace(*buf)) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn true;\n\t}\n\tint countSpacetonext(){\n\t\tint total=0;\n\t\twhile(*buf&&*buf==' ') ++total,++buf;\n\t\treturn total;\n\t}\n\tbool splitBycharactor(char *s,char Split='\\n'){\n\t\twhile(*buf&&*buf!=Split) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn *buf!=0;\n\t}\n};\n\nbool dp[55][55][55][55];\n\nchar card[55][5];\nint n;\n\nbool check(int i,int j){\n\treturn card[i][0]==card[j][0]||card[i][1]==card[j][1];\n}\nbool check3(){\n\tREP_1(i,n) if(!check(i,n)) return false;\n\treturn true;\n}\nbool checkall(){\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tfor(int k=1;k<=n;++k)\n\t\t\t{\n\t\t\t\tif(dp[1][i][j][k]&&check(i,k)&&check(j,k))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tREP_1(i,n)\n\t{\n\t\tscanf(\"%s\",card[i]);\n\t}\n\tif(n<=3)\n\t{\n\t\tprintf(\"%s\\n\",check3()?\"YES\":\"NO\");\n\t}\n\telse\n\t{\n\t\tdp[n-2][n-2][n-1][n]=1;\n\t\tfor(int i=n-2;i>1;--i)\n\t\t{\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=n;++k)\n\t\t\t\t{\n\t\t\t\t\tfor(int l=1;l<=n;++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(dp[i][j][k][l])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(check(i-1,l)) dp[i-1][l][j][k]=1;\n\t\t\t\t\t\t\tif(check(k,l)) dp[i-1][i-1][j][l]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",checkall()?\"YES\":\"NO\");\n\t}\n\tcin>>card[0];\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Solitaire.json",
    "editorial_link": "https://codeforces.com/blog/entry/4930",
    "editorial": "In this problem you could write breadth-first search. The state is the\r\nfollowing four elements: number of remaining piles and three strings\r\nthree rightmost cards on the top of three rightmost piles. We have two\r\ntransitions in general case. We can take the rightmost pile and shift it\r\nleft by or on another pile. If the number of remaining piles become at\r\nsome moment print , else print . The number of states is , the number of\r\ntransitions , so the complexity of solution is .\r\n",
    "hint": []
}