{"link": "https://codeforces.com//contest/330/problem/E", "problemId": "3353", "problem_idx": "E", "shortId": "330E", "contest_number": "330", "problem_submissions": {"E": [4121855, 4129603, 4139778, 4139451, 4213008], "D": [4117664, 4117609, 4117505, 4117842, 4117606, 4117463, 4115484, 4117887, 4117520, 4117977, 4117817, 4117617, 4117937, 4117768, 4118484, 4119072, 4118154, 4117838, 4118899], "C": [4115956, 4115187, 4115372, 4115604, 4115813, 4117683, 4115859, 4115396, 4115931, 4115861, 4115789, 4115557, 4115689, 4114734, 4115836, 4117100, 4115924], "B": [4114293, 4113546, 4113615, 4113315, 4113231, 4116357, 4113644, 4113499, 4114262, 4113658, 4113108, 4114038, 4113172, 4113061, 4113986, 4114337, 4113965], "A": [4113132, 4112577, 4112734, 4112448, 4112410, 4112458, 4112430, 4114037, 4112918, 4112498, 4112396, 4112828, 4112414, 4112412, 4112843, 4112551, 4112821]}, "name": "E. Graph Reconstruction", "statement": "I have an undirected graph consisting of nodes, numbered 1 through .\r\nEach node has at most two incident edges. For each pair of nodes, there\r\nis at most an edge connecting them. No edge connects a node to itself.I\r\nwould like to create a new graph in such a way that: The new graph\r\nconsists of the same number of nodes and edges as the old graph. The\r\nproperties in the first paragraph still hold. For each two nodes and ,\r\nif there is an edge connecting them in the old graph, there is no edge\r\nconnecting them in the new graph. Help me construct the new graph, or\r\ntell me if it is impossible.\r\n", "solutions": ["#include <stdio.h>\n#include <memory.h>\n#include <vector>\n#include <time.h>\n#include <algorithm>\nusing namespace std;\n#define M 100100\nint deg[M];\nint num[M];\nvector<int> v[M];\nint a[M], b[M];\n\nint main(){\n///\tfreopen(\"1.in\", \"r\", stdin);\n\tint i, j, k, n, m;\n\tint x, y;\n\tscanf(\"%d %d\", &n, &m);\n\tfor(i=0; i<m; i++){\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t\tdeg[x]++, deg[y]++;\n\t}\n\n\tif(n<20 and n*(n-1)<4*m){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tif(n==4 and m==3){\n\t\tfor(i=1; i<=4; i++)if(!deg[i])break;\n\t\tif(i<=4){\n\t\t\tputs(\"-1\");\treturn 0;\n\t\t}\n\t}\n\n\twhile(1){\n\t\tint ans = 0;\n\t\tmemset(num, 0, sizeof(num));\n\t\tint t = rand()%n + 1;\n\t\tfor(int ii=t; ii<n+t; ii++){\n\t\t\tif(ii>n)i=ii-n; else i=ii;\n\t\t\tif(num[i]<2){\n\t\t\t\tint I=v[i].size();\n\t\t\t\tif(I>0)x=v[i][0]; else x=0;\n\t\t\t\tif(I>1)y=v[i][1]; else y=0;\n\t\t///\t\tprintf(\"i=%d, cur=%d\\n\", i, cur);\n\t\t\t\tfor(j=i+1; j<=n; j++)if(i!=j and num[j]<2 and j!=x and j!=y){\n\t\t\t\t\ta[ans] = i, b[ans++] = j;\n\t\t\t\t\tnum[i]++;\n\t\t\t\t\tnum[j]++;\n\t\t\t\t\tif(ans==m){\n\t\t\t\t\t\tfor(k=0; k<ans; k++){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\", a[k], b[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(num[i]==2)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(num, 0, sizeof(num));\n\t\tt = rand()%n + 1;\n\t\tfor(int ii=t+n; ii>t; ii--){\n\t\t\tif(ii>n)i=ii-n; else i=ii;\n\t\t\tif(num[i]<2){\n\t\t\t\tint I=v[i].size();\n\t\t\t\tif(I>0)x=v[i][0]; else x=0;\n\t\t\t\tif(I>1)y=v[i][1]; else y=0;\n\t\t///\t\tprintf(\"i=%d, cur=%d\\n\", i, cur);\n\t\t\t\tfor(j=i+1; j<=n; j++)if(i!=j and num[j]<2 and j!=x and j!=y){\n\t\t\t\t\ta[ans] = i, b[ans++] = j;\n\t\t\t\t\tnum[i]++;\n\t\t\t\t\tnum[j]++;\n\t\t\t\t\tif(ans==m){\n\t\t\t\t\t\tfor(k=0; k<ans; k++){\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\", a[k], b[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(num[i]==2)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(clock()>2800000.){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": [], "dificulty": "2400", "interactive": false}