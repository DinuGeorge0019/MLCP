{
    "link": "https://codeforces.com//contest/2024/problem/B",
    "problemId": "2964357",
    "problem_idx": "B",
    "shortId": "2024B",
    "contest_number": "2024",
    "problem_submissions": {
        "F": [
            287015023,
            287169223,
            287373673,
            287215917,
            287215736,
            287211292,
            287210539
        ],
        "D": [
            286987175,
            286931903,
            286960958,
            286961825,
            286971656,
            286929566,
            286931351,
            286932695,
            286932954,
            286934298,
            286931628,
            286927969,
            286932481,
            286936758,
            286930518,
            286960977,
            286959072,
            286943034,
            286936933
        ],
        "B": [
            286981623,
            286914966,
            286919282,
            286915114,
            286921371,
            286905134,
            286915552,
            286914323,
            286916482,
            286915957,
            286912577,
            286914600,
            286917409,
            286917069,
            286960523,
            286915841,
            286912540,
            286913505,
            286928405,
            286917057
        ],
        "E": [
            286971252,
            287005601,
            287014904,
            287015860,
            287015861,
            287172897,
            287179171,
            286984012
        ],
        "A": [
            286921784,
            286907603,
            286905627,
            286906243,
            286909098,
            286912198,
            286906985,
            286905683,
            286907292,
            286909521,
            286906250,
            286906979,
            286905397,
            286905452,
            286905213,
            286906731,
            286905626,
            286906240,
            286907336,
            286905986
        ],
        "C": [
            286916369,
            286924618,
            286933885,
            286931704,
            286933058,
            286906288,
            286921833,
            286923843,
            286925202,
            286923774,
            286923641,
            286921029,
            286922676,
            286924091,
            286919391,
            286920408,
            286922209,
            286923637,
            286916167,
            286927200
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "Letâs make a few simple observations about the optimal strategy of\r\nactions. First, if after pressing a certain button, no cans have been\r\nobtained, there is no point in pressing that button again. Second, among\r\nthe buttons that have not yet resulted in a failure, it is always\r\nadvantageous to press the button that has been pressed the least number\r\nof times. This can be loosely justified by the fact that the fewer times\r\na button has been pressed, the greater the chance that the next press\r\nwill be successful, as we have no other information to distinguish these\r\nbuttons from one another. From this, our strategy clearly emerges: letâs\r\nsort the array, let . In the first action, we will press all buttons\r\ntimes. It is clear that all these presses will yield cans, and in total,\r\nwe will collect cans. If , no further presses are needed. However, if ,\r\nwe need to make at least one more press. Since all buttons are still\r\nindistinguishable to us, it may happen that this press will be made on\r\nthe button corresponding to and will be unsuccessful. Next, we will\r\npress all remaining buttons times; these presses will also be guaranteed\r\nto be successful. After that, again, if does not exceed the number of\r\ncans already collected, we finish; otherwise, we need to make at least\r\none more press, which may hit an empty cell . And so on. In total, the\r\nanswer to the problem will be , where is the smallest number from to\r\nsuch that the following holds: (here we consider ). .\r\n",
    "name": "B. Buying Lemonade",
    "statement": "There is a vending machine that sells lemonade. The machine has a total\r\nof n slots. You know that initially, the i-th slot contains a_i cans of\r\nlemonade. There are also n buttons on the machine, each button\r\ncorresponds to a slot, with exactly one button corresponding to each\r\nslot. Unfortunately, the labels on the buttons have worn off, so you\r\nwhich button corresponds to which slot.When you press the button\r\ncorresponding to the i-th slot, one of two events occurs: If there is a\r\ncan of lemonade in the i-th slot, it will drop out and you will take it.\r\nAt this point, the number of cans in the i-th slot decreases by 1. If\r\nthere are no cans of lemonade left in the i-th slot, nothing will drop\r\nout. After pressing, the can drops out so quickly that it is impossible\r\nto track from which slot it fell. The contents of the slots are hidden\r\nfrom your view, so you cannot see how many cans are left in each slot.\r\nThe only thing you know is the initial number of cans in the slots: a_1,\r\na_2,\r\nldots, a_n.Determine the minimum number of button presses needed to\r\nguarantee that you receive at least k cans of lemonade.Note that you can\r\nadapt your strategy during the button presses based on whether you\r\nreceived a can or not. It is guaranteed that there are at least k cans\r\nof lemonade in total in the machine. In other words, k\r\nleq a_1 + a_2 +\r\nldots + a_n.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; typedef long long int ll;const ll FOD = 998244353;typedef pair<ll, ll> P;using ull = unsigned long long;template <class T> using V = vector<T>;template <class T> using VV = V<V<T>>;  template <ll MD> struct ModInt {    using M = ModInt;    const static M G;    ll v;    ModInt(ll _v = 0) { set_v(_v % MD + MD); }    M& set_v(ll _v) {        v = (_v < MD) ? _v : _v - MD;        return *this;    }    explicit operator bool() const { return v != 0; }    M operator-() const { return M() - *this; }    M operator+(const M& r) const { return M().set_v(v + r.v); }    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }    M operator*(const M& r) const { return M().set_v(ll(v) * r.v % MD); }    M operator/(const M& r) const { return *this * r.inv(); }    M& operator+=(const M& r) { return *this = *this + r; }    M& operator-=(const M& r) { return *this = *this - r; }    M& operator*=(const M& r) { return *this = *this * r; }    M& operator/=(const M& r) { return *this = *this / r; }    bool operator==(const M& r) const { return v == r.v; }    M pow(ll n) const {        M x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    M inv() const { return pow(MD - 2); }    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }};using Mint = ModInt<998244353>;template<> const Mint Mint::G = Mint(3); template <class Mint> void nft(bool type, V<Mint>& a) {    int n = int(a.size()), s = 0;    while ((1 << s) < n) s++;    assert(1 << s == n);     static V<Mint> ep, iep;    while (int(ep.size()) <= s) {        ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));        iep.push_back(ep.back().inv());    }    V<Mint> b(n);    for (int i = 1; i <= s; i++) {        int w = 1 << (s - i);        Mint base = type ? iep[i] : ep[i], now = 1;        for (int y = 0; y < n / 2; y += w) {            for (int x = 0; x < w; x++) {                auto l = a[y << 1 | x];                auto r = now * a[y << 1 | x | w];                b[y | x] = l + r;                b[y | x | n >> 1] = l - r;            }            now *= base;        }        swap(a, b);    }} template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {    int n = int(a.size()), m = int(b.size());    if (!n || !m) return {};    int lg = 0;    while ((1 << lg) < n + m - 1) lg++;    int z = 1 << lg;    auto a2 = a, b2 = b;    a2.resize(z);    b2.resize(z);    nft(false, a2);    nft(false, b2);    for (int i = 0; i < z; i++) a2[i] *= b2[i];    nft(true, a2);    a2.resize(n + m - 1);    Mint iz = Mint(z).inv();    for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;    return a2;} ll n, k, q, h, w; ll m1, m2;vector<ll> g[200'009 * 2]; vector<ll> a, b; vector<ll> qs[200'009];ll qi = 0;ll sz = 0; Mint mod_pow (Mint l, ll r) {\tif (r == 0) return 1; \treturn mod_pow((l * l), r/2) * ((r%2) ? l : 1);}Mint mod_inv (Mint x) {\treturn mod_pow(x, FOD-2);} ll id[200'009 * 2];void dfs (ll v) {\tfor (ll u : g[v]) {\t\tif (id[u] != -1) continue; \t\tid[u] = (id[v] + 1) % k;\t\tdfs(u);\t}} template<class T>vector<ll> mp (const vector<T> &s) {\tvector<ll> ans(s.size() + 1);\tans[0] = -1;\tll j = -1;\tfor (ll i = 0; i < s.size(); i++) {\t\twhile (j >= 0 && s[i] != s[j]) j = ans[j];\t\tj++;\t\tans[i+1] = j;\t}\treturn ans;} void solve () {\tsort(a.begin(), a.end()); \tll i = 0;\tll miss = 0, gua = 0;\twhile (gua < k) {\t\tll diff = (a[i] - (i ? a[i-1] : 0));\t\tgua += diff * (n - i);\t\tif (gua >= k) break;\t\t\t\tmiss++;\t\ti++;\t} \tll ans = k + miss;\tcout << ans << \"\\n\"; } int main (void) {\tcin >> q;\twhile (q--) {\t\tcin >> n >> k;\t\ta.resize(n);\t\tfor (ll i = 0; i < n; i++) {\t\t\tcin >> a[i];\t\t}\t\t\t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "sortings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Buying Lemonade.json",
    "hint": []
}