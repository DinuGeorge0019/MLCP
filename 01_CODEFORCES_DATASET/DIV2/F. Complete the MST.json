{
    "link": "https://codeforces.com//contest/1509/problem/F",
    "problemId": "958792",
    "problem_idx": "F",
    "shortId": "1509F",
    "contest_number": "1509",
    "problem_submissions": {
        "F": [
            113256937,
            113452435,
            113285395
        ],
        "E": [
            113232874,
            113219267,
            113224061,
            113223560,
            113233730,
            113226238,
            113242617,
            113234728,
            113229028,
            113234613,
            113236691,
            113233309,
            113237999,
            113236924,
            113234998,
            113244661,
            113248199,
            113294044,
            113242554,
            113241170,
            113238407
        ],
        "D": [
            113221122,
            113205083,
            113211524,
            113212503,
            113218682,
            113218702,
            113210079,
            113222981,
            113224859,
            113213502,
            113222656,
            113222165,
            113224508,
            113227361,
            113205851,
            113214932,
            113213501,
            113214642,
            113227110,
            113229498
        ],
        "C": [
            113210555,
            113197246,
            113200376,
            113200962,
            113204903,
            113197040,
            113198240,
            113210183,
            113210598,
            113200328,
            113196898,
            113203900,
            113204261,
            113210665,
            113209464,
            113204447,
            113203994,
            113206401,
            113202494,
            113202048
        ],
        "B": [
            113194717,
            113193937,
            113192191,
            113190108,
            113198761,
            113232450,
            113190578,
            113195766,
            113197868,
            113220965,
            113207035,
            113194479,
            113196536,
            113224188,
            113200860,
            113198840,
            113198891,
            113192926,
            113195317
        ],
        "A": [
            113186426,
            113184937,
            113185796,
            113185053,
            113185023,
            113184968,
            113185012,
            113185414,
            113185256,
            113188852,
            113200720,
            113185467,
            113185688,
            113212116,
            113186288,
            113188479,
            113188850,
            113184903,
            113188945
        ]
    },
    "name": "F. Complete the MST",
    "statement": "As a teacher, Riko Hakozaki often needs to help her students with\r\nproblems from various subjects. Today, she is asked a programming task\r\nwhich goes as follows.You are given an undirected complete graph with n\r\nnodes, where some edges are pre-assigned with a positive weight while\r\nthe rest arenâ€™t. You need to assign all unassigned edges with so that in\r\nthe resulting fully-assigned complete graph the XOR sum of all weights\r\nwould be equal to 0.Define the of a fully-assigned complete graph the\r\nweight of its minimum spanning tree, where the weight of a spanning tree\r\nequals the sum of weights of its edges. You need to assign the weights\r\nso that the ugliness of the resulting graph is as small as possible.As a\r\nreminder, an undirected complete graph with n nodes contains all edges\r\n(u, v) with 1\r\nle u < v\r\nle n; such a graph has\r\nfrac{n(n-1)}{2} edges.She is not sure how to solve this problem, so she\r\nasks you to solve it for her.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\n#define int long long\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define F first\n#define S second\n\n\nvoid accell() {\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n}\n\nstruct E {\n    int v, u, w;\n};\n\nconst int N = 558228;\n\nint p[N];\nint sz[N];\n\nvoid make_set(int v) {\n    p[v] = v;\n    sz[v] = 1;\n}\n\nint get(int a) {\n    if (a == p[a]) return a;\n    return p[a] = get(p[a]);\n}\n\nvoid merge(int a, int b) {\n    a = get(a);\n    b = get(b);\n    if (sz[a] > sz[b]) \n        swap(a, b);\n    sz[b] += sz[a];\n    p[a] = b;\n}\n\nvector<int> g[N];\n\n\nvoid dfs(int v, set<int>& s) {\n    sort(all(g[v]));\n    int ptr = 0;\n    if (s.size() == 0) return;\n    auto it = s.begin();\n    vector<int> shit;\n    for (auto it : s) {\n        while (ptr < g[v].size() && g[v][ptr] < it) {\n            ++ptr;\n        }\n        if (ptr < g[v].size()) {\n            if (g[v][ptr] != it) {\n                shit.push_back(it);\n                if (get(v) != get(it)) {\n                    merge(v, it);\n                }\n            }\n        }\n        if (ptr == g[v].size()) {\n            shit.push_back(it);\n            if (get(v) != get(it)) {\n                merge(v, it);\n            }\n        }\n    }\n    for (auto er : shit) {\n        s.erase(er);\n    }\n    for (auto er : shit) {\n        dfs(er, s);\n    }\n}\n\n\nint big(int n, int m) {\n    vector<E>edge(m);\n    vector<int> deg(n);\n    for (int i = 0; i < m; ++i) {\n        cin >> edge[i].v >> edge[i].u >> edge[i].w;\n        edge[i].v--;\n        edge[i].u--;\n        deg[edge[i].v]++;\n        deg[edge[i].u]++;\n        g[edge[i].v].push_back(edge[i].u);\n        g[edge[i].u].push_back(edge[i].v);\n    }\n    set<int> s;\n    for (int i = 0; i < n; ++i) {\n        s.insert(i);\n        make_set(i);\n    }\n    for (int i = 0; i < n; ++i) {\n        if (s.find(i) != s.end()) {\n            dfs(i, s);\n        }\n    }\n    int ans = 0;\n    sort(edge.begin(), edge.end(), [](E a, E b) {\n        return a.w < b.w;\n    });\n    for (int i = 0; i < m; ++i) {\n        if (get(edge[i].v) != get(edge[i].u)) {\n            ans += edge[i].w;\n            merge(edge[i].v, edge[i].u);\n        }\n    }\n    return ans;\n}\n\n\nint small(int n, int m) {\n    vector<E>edge(m);\n    vector<vector<int>> matrix(n, vector<int>(n, -1));\n    int xr = 0;\n    for (int i = 0; i < m; ++i) {\n        cin >> edge[i].v >> edge[i].u >> edge[i].w;\n        --edge[i].v, --edge[i].u;\n        matrix[edge[i].v][edge[i].u] = matrix[edge[i].u][edge[i].v] = edge[i].w;\n        xr ^= edge[i].w;\n    }\n    sort(edge.begin(), edge.end(), [](E a, E b) {\n        return a.w < b.w;\n    });\n    vector<E> extra;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (matrix[i][j] == -1) {\n                extra.push_back({i, j, 0});\n            }\n        }\n    }\n    int ans = 1e18;\n    for (int i = 0; i < extra.size(); ++i) {\n        for (int j = 0; j < n; ++j) {\n            make_set(j);\n        }\n        int cur = 0;\n        for (int j = 0; j < extra.size(); ++j) {\n            if (j != i && get(extra[j].v) != get(extra[j].u)) {\n                merge(extra[j].v, extra[j].u);\n                //cout << extra[j].v << ' ' << extra[j].u << endl;\n            }\n        }\n        for (int j = 0; j < edge.size(); ++j) {\n            if (xr <= edge[j].w) {\n                if (get(extra[i].v) != get(extra[i].u)) {\n                    merge(extra[i].v, extra[i].u);\n                    cur += xr;\n                }\n            }\n            if (get(edge[j].v) != get(edge[j].u)) {\n                merge(edge[j].v, edge[j].u);\n                cur += edge[j].w;\n            }\n        }\n        if (get(extra[i].v) != get(extra[i].u)) {\n            merge(extra[i].v, extra[i].u);\n            // cout << extra[i].v << ' ' << extra[i].u << endl;\n            cur += xr;\n        }\n        // cout << extra[i].v << ' ' << extra[i].u << ' ' << xr << ' ' << cur << endl;\n        ans = min(ans, cur);\n    }\n    return ans;\n}\n\n\nsigned main() {\n    accell();\n    int n, m;\n    cin >> n >> m;\n    int ans = 0;\n    if (n * (n - 1) / 2 - m >= 2 * n + 500) {\n        ans = big(n, m);\n    } else {\n        ans = small(n, m);\n    }\n    cout << ans << endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Complete the MST.json",
    "editorial_link": "https://codeforces.com//blog/entry/89644",
    "editorial": "Call x\n the XOR sum of the weights of all pre-assigned edges.\n\nLemma. All but one unassigned edges are assigned with 0\n, while the remaining unassigned edge is assigned with x\n.\n\nProof. Consider any assignment of unassigned edges. There are two cases on the minimum spanning tree:\n\nThe MST does not use all unassigned edges: We can assign one unused unassigned edge with x\n, while all other unassigned edges (including all used in the MST) are assigned with 0\n. This reduces the weight of the MST.\nThe MST uses all unassigned edges: We can prove that the sum of weights of unassigned edges is at least x\n, and the equality can be achieved with the construction from the lemma. Intuitively, the XOR sum is an \"uncarried\" summation, and the construction from the lemma removes any digit carry.\nLet's DFS on the unassigned edges. It can happen that the unassigned edges may separate the graph into multiple components, and we might need to use some pre-assigned edges in our MST. I will divide the collection of pre-assigned edges into 3 types:\n\nEdges that must be included in the MST: these are edges with smallest weights that connect the components after traversing through unassigned edges.\nEdges that cannot be included in the MST: these are edges that form cycles with smaller-weighted pre-assigned edges. In other words, these are edges that do not exist in the minimum spanning forest of the pre-assigned edges.\nEdges that are in neither of the previous types.\nFor the unassigned edges, there are two cases:\n\nThe unassigned edges form at least a cycle: We can assign any edge on this cycle as x\n, the rest as 0\n, then build an MST using the 0\n-weighted edges with pre-assigned edges of type 1.\nThe unassigned edges does not form a cycle. Suppose we build the tree using only unassigned edges and edges of type 1. Then any edge of type 3 can replace an unassigned edge in the tree. That is because the edges of type 3 must form a cycle with edges of type 1 and unassigned edges (else it would either be in type 1 or type 2). We can simply replace an unassigned edge in that cycle with this type 3 edge.\nTherefore, for this case, our solution is to first form the tree with all edges of type 1 and unassigned edge. Then, if the smallest weighted type 3 edge has weight <x\n, we can replace an unassigned edge with this edge; else, we keep the tree.",
    "hint": []
}