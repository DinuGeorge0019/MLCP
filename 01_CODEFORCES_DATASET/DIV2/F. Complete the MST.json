{"link": "https://codeforces.com//contest/1509/problem/F", "problemId": "958792", "problem_idx": "F", "shortId": "1509F", "contest_number": "1509", "problem_submissions": {"F": [113256937, 113452435, 113285395], "E": [113232874, 113219267, 113224061, 113223560, 113233730, 113226238, 113242617, 113234728, 113229028, 113234613, 113236691, 113233309, 113237999, 113236924, 113234998, 113244661, 113248199, 113294044, 113242554, 113241170, 113238407], "D": [113221122, 113205083, 113211524, 113212503, 113218682, 113218702, 113210079, 113222981, 113224859, 113213502, 113222656, 113222165, 113224508, 113227361, 113205851, 113214932, 113213501, 113214642, 113227110, 113229498], "C": [113210555, 113197246, 113200376, 113200962, 113204903, 113197040, 113198240, 113210183, 113210598, 113200328, 113196898, 113203900, 113204261, 113210665, 113209464, 113204447, 113203994, 113206401, 113202494, 113202048], "B": [113194717, 113193937, 113192191, 113190108, 113198761, 113232450, 113190578, 113195766, 113197868, 113220965, 113207035, 113194479, 113196536, 113224188, 113200860, 113198840, 113198891, 113192926, 113195317], "A": [113186426, 113184937, 113185796, 113185053, 113185023, 113184968, 113185012, 113185414, 113185256, 113188852, 113200720, 113185467, 113185688, 113212116, 113186288, 113188479, 113188850, 113184903, 113188945]}, "name": "F. Complete the MST", "statement": "As a teacher, Riko Hakozaki often needs to help her students with\r\nproblems from various subjects. Today, she is asked a programming task\r\nwhich goes as follows.You are given an undirected complete graph with n\r\nnodes, where some edges are pre-assigned with a positive weight while\r\nthe rest aren\u2019t. You need to assign all unassigned edges with so that in\r\nthe resulting fully-assigned complete graph the XOR sum of all weights\r\nwould be equal to 0.Define the of a fully-assigned complete graph the\r\nweight of its minimum spanning tree, where the weight of a spanning tree\r\nequals the sum of weights of its edges. You need to assign the weights\r\nso that the ugliness of the resulting graph is as small as possible.As a\r\nreminder, an undirected complete graph with n nodes contains all edges\r\n(u, v) with 1\r\nle u < v\r\nle n; such a graph has\r\nfrac{n(n-1)}{2} edges.She is not sure how to solve this problem, so she\r\nasks you to solve it for her.\r\n", "solutions": ["#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\n#define int long long\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define F first\n#define S second\n\n\nvoid accell() {\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n}\n\nstruct E {\n    int v, u, w;\n};\n\nconst int N = 558228;\n\nint p[N];\nint sz[N];\n\nvoid make_set(int v) {\n    p[v] = v;\n    sz[v] = 1;\n}\n\nint get(int a) {\n    if (a == p[a]) return a;\n    return p[a] = get(p[a]);\n}\n\nvoid merge(int a, int b) {\n    a = get(a);\n    b = get(b);\n    if (sz[a] > sz[b]) \n        swap(a, b);\n    sz[b] += sz[a];\n    p[a] = b;\n}\n\nvector<int> g[N];\n\n\nvoid dfs(int v, set<int>& s) {\n    sort(all(g[v]));\n    int ptr = 0;\n    if (s.size() == 0) return;\n    auto it = s.begin();\n    vector<int> shit;\n    for (auto it : s) {\n        while (ptr < g[v].size() && g[v][ptr] < it) {\n            ++ptr;\n        }\n        if (ptr < g[v].size()) {\n            if (g[v][ptr] != it) {\n                shit.push_back(it);\n                if (get(v) != get(it)) {\n                    merge(v, it);\n                }\n            }\n        }\n        if (ptr == g[v].size()) {\n            shit.push_back(it);\n            if (get(v) != get(it)) {\n                merge(v, it);\n            }\n        }\n    }\n    for (auto er : shit) {\n        s.erase(er);\n    }\n    for (auto er : shit) {\n        dfs(er, s);\n    }\n}\n\n\nint big(int n, int m) {\n    vector<E>edge(m);\n    vector<int> deg(n);\n    for (int i = 0; i < m; ++i) {\n        cin >> edge[i].v >> edge[i].u >> edge[i].w;\n        edge[i].v--;\n        edge[i].u--;\n        deg[edge[i].v]++;\n        deg[edge[i].u]++;\n        g[edge[i].v].push_back(edge[i].u);\n        g[edge[i].u].push_back(edge[i].v);\n    }\n    set<int> s;\n    for (int i = 0; i < n; ++i) {\n        s.insert(i);\n        make_set(i);\n    }\n    for (int i = 0; i < n; ++i) {\n        if (s.find(i) != s.end()) {\n            dfs(i, s);\n        }\n    }\n    int ans = 0;\n    sort(edge.begin(), edge.end(), [](E a, E b) {\n        return a.w < b.w;\n    });\n    for (int i = 0; i < m; ++i) {\n        if (get(edge[i].v) != get(edge[i].u)) {\n            ans += edge[i].w;\n            merge(edge[i].v, edge[i].u);\n        }\n    }\n    return ans;\n}\n\n\nint small(int n, int m) {\n    vector<E>edge(m);\n    vector<vector<int>> matrix(n, vector<int>(n, -1));\n    int xr = 0;\n    for (int i = 0; i < m; ++i) {\n        cin >> edge[i].v >> edge[i].u >> edge[i].w;\n        --edge[i].v, --edge[i].u;\n        matrix[edge[i].v][edge[i].u] = matrix[edge[i].u][edge[i].v] = edge[i].w;\n        xr ^= edge[i].w;\n    }\n    sort(edge.begin(), edge.end(), [](E a, E b) {\n        return a.w < b.w;\n    });\n    vector<E> extra;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (matrix[i][j] == -1) {\n                extra.push_back({i, j, 0});\n            }\n        }\n    }\n    int ans = 1e18;\n    for (int i = 0; i < extra.size(); ++i) {\n        for (int j = 0; j < n; ++j) {\n            make_set(j);\n        }\n        int cur = 0;\n        for (int j = 0; j < extra.size(); ++j) {\n            if (j != i && get(extra[j].v) != get(extra[j].u)) {\n                merge(extra[j].v, extra[j].u);\n                //cout << extra[j].v << ' ' << extra[j].u << endl;\n            }\n        }\n        for (int j = 0; j < edge.size(); ++j) {\n            if (xr <= edge[j].w) {\n                if (get(extra[i].v) != get(extra[i].u)) {\n                    merge(extra[i].v, extra[i].u);\n                    cur += xr;\n                }\n            }\n            if (get(edge[j].v) != get(edge[j].u)) {\n                merge(edge[j].v, edge[j].u);\n                cur += edge[j].w;\n            }\n        }\n        if (get(extra[i].v) != get(extra[i].u)) {\n            merge(extra[i].v, extra[i].u);\n            // cout << extra[i].v << ' ' << extra[i].u << endl;\n            cur += xr;\n        }\n        // cout << extra[i].v << ' ' << extra[i].u << ' ' << xr << ' ' << cur << endl;\n        ans = min(ans, cur);\n    }\n    return ans;\n}\n\n\nsigned main() {\n    accell();\n    int n, m;\n    cin >> n >> m;\n    int ans = 0;\n    if (n * (n - 1) / 2 - m >= 2 * n + 500) {\n        ans = big(n, m);\n    } else {\n        ans = small(n, m);\n    }\n    cout << ans << endl;\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dsu", "graphs", "greedy", "trees"], "dificulty": "2500", "interactive": false}