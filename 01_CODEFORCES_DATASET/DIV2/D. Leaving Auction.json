{
    "link": "https://codeforces.com//contest/749/problem/D",
    "problemId": "85478",
    "problem_idx": "D",
    "shortId": "749D",
    "contest_number": "749",
    "problem_submissions": {
        "E": [
            23157045,
            23158471,
            23159955,
            23159227,
            23159699,
            23201671,
            23188698,
            23188666,
            23161857,
            23249468,
            23159356,
            23161181
        ],
        "D": [
            23150269,
            23155017,
            23153167,
            23156936,
            23152064,
            23151488,
            23150216,
            23152653,
            23152526,
            23153002,
            23153816,
            23153299,
            23153576,
            23153949,
            23154660,
            23153221,
            23154083,
            23155240,
            23153806,
            23154081
        ],
        "C": [
            23147336,
            23149855,
            23149193,
            23149595,
            23147564,
            23151828,
            23148654,
            23149362,
            23149269,
            23149897,
            23148430,
            23149965,
            23148722,
            23175263,
            23147964,
            23150407,
            23148950,
            23162490,
            23148466
        ],
        "B": [
            23145982,
            23147492,
            23146643,
            23146380,
            23145252,
            23147345,
            23149268,
            23146406,
            23146519,
            23147467,
            23146720,
            23146308,
            23146859,
            23149282,
            23150475,
            23147414,
            23147519,
            23146953,
            23155115
        ],
        "A": [
            23143678,
            23144522,
            23143768,
            23144671,
            23143613,
            23143623,
            23143733,
            23144118,
            23144102,
            23144679,
            23143737,
            23143812,
            23143610,
            23143762,
            23150938,
            23145011,
            23144267,
            23144159,
            23143669
        ]
    },
    "name": "D. Leaving Auction",
    "statement": "There are people taking part in auction today. The rules of auction are\r\nclassical. There were bids made, though it\u2019s not guaranteed they were\r\nfrom different people. It might happen that some people made no bids at\r\nall.Each bid is define by two integers , where is the index of the\r\nperson, who made this bid and is its size. Bids are given in\r\nchronological order, meaning for all . Moreover, participant never makes\r\ntwo bids in a row (no one updates his own bid), i.e. for all .Now you\r\nare curious with the following question: who (and which bid) will win\r\nthe auction if some participants were absent? Consider that if someone\r\nwas absent, all his bids are just removed and no new bids are\r\nadded.Note, that if during this imaginary exclusion of some participants\r\nit happens that some of the remaining participants makes a bid twice (or\r\nmore times) in a row, only first of these bids is counted. For better\r\nunderstanding take a look at the samples.You have several questions in\r\nyour mind, compute the answer for each of them.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n\ntypedef long long ll;\ntypedef pair <ll,ll> pii;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\nll n,a[N],b[N],q,l[N],f[N];\npii t[4*N];\nvector<ll> g[N];\n\ninline pii merge(pii a, pii b)\n{\n\tif(b.F >= a.F)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\ninline void upd(int v, int tl, int tr ,int p, ll x)\n{\n\tif(tl==tr)\n\t{\n\t\tt[v].F=x;\n\t\tt[v].S=tl;\n\t\treturn;\n\t}\n\tint tm=tl+tr>>1;\n\tif(p<=tm) upd(v+v,tl,tm,p,x);\n\telse upd(v+v+1,tm+1,tr,p,x);\n\tt[v]=merge(t[v+v],t[v+v+1]);\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfo(i,n)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\tf[a[i]]=b[i];\n\t\tg[a[i]].pb(b[i]);\n\t}\n\tfo(i,n)\n\t\tupd(1,1,n,i,f[i]);\n\tcin>>q;\n\tfo(i,q)\n\t{\n\t\tint k;\n\t\tcin>>k;\n\t\tfo(j,k)\n\t\t{\n\t\t\tcin>>l[j];\n\t\t\tupd(1,1,n,l[j],0);\n\t\t}\n\t\tint winner=t[1].S;\n\t\tif(t[1].F==0)\n\t\t{\n\t\t\tcout<<0<<' '<<0<<\"\\n\";\n\t\t\tfo(j,k)\n\t\t\t\tupd(1,1,n,l[j],f[l[j]]);\n\t\t\tcontinue;\n\t\t}\n\t\tupd(1,1,n,winner,0);\n\t\tcout<<winner<<' ';\n\t\tint sec=t[1].F;\n\t\tint z=lower_bound(g[winner].begin(),g[winner].end(),sec)-g[winner].begin();\n\t\tcout<<g[winner][z]<<\"\\n\";\n\t\tupd(1,1,n,winner,f[winner]);\n\t\tfo(j,k)\n\t\t\tupd(1,1,n,l[j],f[l[j]]);\n\t}\n\treturn 0;\t\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Leaving Auction.json",
    "editorial_link": "https://codeforces.com//blog/entry/49186",
    "editorial": "For every man at the auction we will save two values: his maximum bid\r\nand the list of all his bids. Then save all men in the set sorted by the\r\nmaximal bid.Now, when the query comes, we will remove from the set all\r\nmen who left the auction, then answer the query, and then add the men\r\nback. The total number of deletions and insertions will not exceed\r\n200000.How to answer the query. Now our set contains only men who has\r\nnot left. If the set is empty, the answer is 0 0. Otherwise, the maximal\r\nman in the set is the winner. Now we have to determine the winning bid.\r\nLet s look at the second maximal man in the set. If it doesn t exist,\r\nthe winner takes part solo and wins with his minimal bid. Otherwise he\r\nshould bid the minimal value that is greater than the maximal bid of the\r\nsecond man in the set. This is where we need a list of bids of the first\r\nmaximal man. We can apply binary search and find the maximal bid of the\r\nsecond man there.\r\n"
}