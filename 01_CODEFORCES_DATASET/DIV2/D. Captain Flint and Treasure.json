{
    "link": "https://codeforces.com//contest/1388/problem/D",
    "problemId": "686569",
    "problem_idx": "D",
    "shortId": "1388D",
    "contest_number": "1388",
    "problem_submissions": {
        "E": [
            88517531,
            88530891,
            88517600,
            88523055,
            88559408,
            88542097
        ],
        "C": [
            88495900,
            88476175,
            88487310,
            88473716,
            88465503,
            88475038,
            88476262,
            88491274,
            88495411,
            88490211,
            88478175,
            88476725,
            88481845,
            88482918,
            88481225,
            88495504,
            88478995,
            88495759,
            88479604,
            88484795
        ],
        "D": [
            88480866,
            88490926,
            88497401,
            88487086,
            88484181,
            88486444,
            88489488,
            88473157,
            98881770,
            88482199,
            88475588,
            88491188,
            88488173,
            88491949,
            88494949,
            88491042,
            88480887,
            88497356,
            88482729,
            88496957,
            88493773
        ],
        "B": [
            88462054,
            88457078,
            88466301,
            88459212,
            88468622,
            88456432,
            88454997,
            88458888,
            88464610,
            88464365,
            88460797,
            88461431,
            88459743,
            88458713,
            88465245,
            88463298,
            88463309,
            88464312,
            88458653,
            88460565
        ],
        "A": [
            88452967,
            88450708,
            88455876,
            88453483,
            88454243,
            88450256,
            88459790,
            88452559,
            88453995,
            88452985,
            88451474,
            88453407,
            88450218,
            88453612,
            88453949,
            88452546,
            88454306,
            88453052,
            88449709,
            88452291
        ]
    },
    "name": "D. Captain Flint and Treasure",
    "statement": "There are two arrays a and b of length n. Initially, an ans is equal to\r\n0 and the following operation is defined: Choose position i (1\r\nle i\r\nle n); Add a_i to ans; If b_i\r\nneq -1 then add a_i to a_{b_i}. What is the maximum ans you can get by\r\nperforming the operation on each i (1\r\nle i\r\nle n) ?Uncle Bogdan is eager to get the reward, so he is asking your\r\nhelp to find the optimal order of positions to perform the operation on\r\nthem.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 400000\n\n\nint main() {\n\tlong long a[N];\n\tlong long b[N];\n\tlong long c[N];\n\tlong long d[N];\n\tbool used[N];\n\tvector<long long>e;\n\tf(i, N) {\n\t\ta[i] = 0;\n\t\tb[i] = 0;\n\t\tc[i] = 0;\n\t\td[i] = 0;\n\t\tused[i] = false;\n\t}\n\tlong long n, k, ans;\n\tscanf(\"%lld\", &n);\n\tf(i, n) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\tf(i, n) {\n\t\tscanf(\"%lld\", &b[i]);\n\t\tb[i]--;\n\t\tif (b[i] >= 0)c[b[i]]++;\n\t}\n\tans = 0;\n\tk = 0;\n\tf(i, n) {\n\t\tif (c[i] == 0) {\n\t\t\td[k] = i;\n\t\t\tk++;\n\t\t}\n\t}\n\tf(i, n) {\n\t\tans += a[d[i]];\n\t\tif (b[d[i]] >= 0) {\n\t\t\tif (a[d[i]] > 0) {\n\t\t\t\tused[d[i]] = true;\n\t\t\t\te.push_back(d[i]+1);\n\t\t\t\ta[b[d[i]]] += a[d[i]];\n\t\t\t}\n\t\t\tc[b[d[i]]]--;\n\t\t\tif (c[b[d[i]]] == 0) {\n\t\t\t\td[k] = b[d[i]];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\n\t}\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (!used[d[i]])e.push_back(d[i]+1);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\tf(i, n - 1)printf(\"%lld \", e[i]);\n\tprintf(\"%lld\\n\", e[n - 1]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Captain Flint and Treasure.json",
    "editorial_link": "https://codeforces.com//blog/entry/80828",
    "editorial": "Letâs construct a graph with vertices and directed edges .Note that it\r\nis not profitable to process the vertex if the vertices , for which ,\r\nhave not yet been processed, since it is possible to process these\r\nvertices so that they will not decrease .We will do the following\r\noperation times:Choose a vertex which does not contain any edge (there\r\nis always such a vertex due to an additional condition in the problem).\r\nLetâs process it as follows: if , then apply the operation from the\r\ncondition to this vertex. This is beneficial because if then we will\r\nimprove the value of . if , then the value of will not improve, which\r\nmeans that it is profitable to apply the operation to the vertex after\r\n(if ). Letâs remember when to process the vertex and then remove it from\r\nthe graph.Letâs store two containers and . In we store the order of\r\nprocessing of vertices for which . In - for which . Then letâs notice\r\nthat the order is appropriate to achieve the maximum answer.Total or\r\ndepending on the implementation.\r\n",
    "hint": []
}