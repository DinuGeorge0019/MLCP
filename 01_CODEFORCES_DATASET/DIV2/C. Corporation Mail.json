{"link": "https://codeforces.com//contest/56/problem/C", "problemId": "294", "problem_idx": "C", "shortId": "56C", "contest_number": "56", "problem_submissions": {"E": [258649, 275636, 258438, 257981, 258601, 259067, 259739], "D": [258330, 258098, 257671, 258532, 258585, 258647, 258137, 259765, 259114, 259097, 259090, 259087, 258433, 258859, 258531, 258403], "C": [257968, 257135, 257281, 257886, 258037, 257842, 257990, 257633, 257657, 257674, 257434, 257851, 257922, 257982], "B": [257322, 275541, 256897, 257039, 257245, 257159, 256958, 257543, 256938, 257029, 256950, 257096, 256939, 257185, 257167, 257332, 257174, 257484], "A": [256682, 258521, 256494, 256668, 256712, 256667, 256559, 256742, 256436, 256563, 256540, 256671, 258296, 256737, 256662, 256687, 256601, 256658]}, "name": "C. Corporation Mail", "statement": "The Beroil corporation structure is hierarchical, that is it can be\r\nrepresented as a tree. Let\u2019s examine the presentation of this structure\r\nas follows: ::= | ... ::= name of an employee That is, the description\r\nof each employee consists of his name, a colon (), the descriptions of\r\nall his subordinates separated by commas, and, finally, a dot. If an\r\nemployee has no subordinates, then the colon is not present in his\r\ndescription.For example, line is the correct way of recording the\r\nstructure of a corporation where the director has subordinates , and .\r\nhas a subordinate whose name is , just as the name of his boss and two\r\nsubordinates of are called , just like himself.In the Beroil corporation\r\nevery employee can only correspond with his subordinates, at that the\r\nsubordinates are not necessarily direct. Let\u2019s call an uncomfortable\r\nsituation the situation when a person whose name is writes a letter to\r\nanother person whose name is also . In the example given above are two\r\nsuch pairs: a pair involving , and two pairs for (a pair for each of his\r\nsubordinates).Your task is by the given structure of the corporation to\r\nfind the number of uncomfortable pairs in it.\r\n", "solutions": ["//#pragma comment(linker,\"/STACK:256000000\")\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <stdio.h>\n#include <string>\n#include <memory.h>\n\nusing namespace std;\n\n#define ldb long double\n#define LL long long\n#define nextline() {int c; while ((c = getchar()) != 10 && c != EOF);}\n\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-9\n\n#define sqr(x) ((x) * (x))\n#define ABS(a) ((a)<0?-(a):(a))\n#define EQ(a,b) (ABS((a)-(b))<EPS)\n\n#define all(a) a.begin(), a.end()\n#define two(i) (1 << (i))\n#define has(mask, i) ((((mask) & two(i)) == 0) ? false : true)\n\nconst int inf = 1000 * 1000 * 1000;\nconst LL inf64 = 1000LL * 1000LL * 1000LL * 1000LL * 1000LL * 1000LL;\n\nvector <int> next[2000];\nstring str[2000];\n\nstring s;\nint n;\nint node = 0;\n\nint parse(int l)\n{\n\tint cur_node = node;\n\tstring x = \"\";\n\twhile (s[l] != '.' && s[l] != ':')\t\n\t{\n\t\tx += s[l];\n\t\tl++;\n\t}\n\tstr[cur_node] = x;\n\tif (s[l] == ':')\n\t{\n\t\tl++;\n\t\tnode++;\n\t\tnext[cur_node].push_back(node);\n\t\tl = parse(l);\n\t\twhile (s[l] != '.')\n\t\t{\n\t\t\tl++;\n\t\t\tnode++;\n\t\t\tnext[cur_node].push_back(node);\n\t\t\tl = parse(l);\t\t\n\t\t}\n\n\t\t\t\t\n\t}\n\treturn l + 1;\n}\n\n\nvoid Load()\n{\n\tcin >> s;\n\n\tparse(0);\n}\n\nint ans = 0;\n\nvoid dfs (int n)\n{\n\tif (s == str[n]) ans++ ;\n\tfor (int i = 0; i < (int)next[n].size(); i++)\n\t\tdfs(next[n][i]);\n\t\n}\n\nvoid Solve()\n{\n   \tfor (int i = 0; i < node; i++)\n   \t{\n   \t\ts = str[i];\n   \t\tdfs (i);\n   \t}\n   \tans -= node;\n   \tcout << ans;\n}\n                \nint main()\n{\n\t//ios_base::sync_with_stdio(0);\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in\", \"rt\", stdin);\n\tfreopen(\"out\", \"wt\", stdout);\n#endif\n\tLoad();\n\tSolve();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "expression parsing", "implementation"], "dificulty": "1700", "interactive": false}