{
    "link": "https://codeforces.com//contest/1406/problem/C",
    "problemId": "720773",
    "problem_idx": "C",
    "shortId": "1406C",
    "contest_number": "1406",
    "problem_submissions": {
        "E": [
            92629042,
            92630500,
            92628899,
            92635228,
            92634107,
            92638626,
            92619773,
            97164376,
            92640175,
            92638803,
            92636918,
            92676046,
            92671322,
            92625530,
            92637463,
            92637483,
            92614606,
            92630766,
            92631813,
            92662786
        ],
        "D": [
            92610024,
            92609433,
            92611409,
            92609957,
            92609251,
            92609187,
            92633310,
            92613282,
            92627048,
            92606021,
            92676006,
            92636207,
            92606425,
            92616730,
            92693126,
            92691073,
            92607353,
            92606067,
            92612958
        ],
        "C": [
            92591912,
            92593174,
            92597136,
            92597584,
            92597579,
            92602468,
            92594387,
            92596256,
            92599703,
            92594293,
            92675991,
            92618821,
            92592065,
            92605879,
            92597551,
            92594066,
            92693156,
            92691032,
            92598806,
            92594142,
            92595349
        ],
        "B": [
            92585402,
            92587012,
            92590282,
            92585685,
            92585843,
            92593482,
            92586267,
            92588568,
            92586097,
            92589192,
            92675966,
            92591284,
            92587210,
            92582618,
            92588033,
            92585543,
            92691012,
            92591068,
            92596476,
            92585669
        ],
        "A": [
            92582753,
            92582816,
            92583498,
            92583384,
            92582723,
            92583951,
            92583076,
            92582946,
            92583005,
            92675955,
            92583729,
            92582667,
            92591746,
            92583143,
            92583399,
            92690980,
            92584679,
            92582643,
            92583860
        ]
    },
    "name": "C. Link Cut Centroids",
    "statement": "Fishing Prince loves trees, and he especially loves trees with only one\r\ncentroid. The tree is a connected graph without cycles.A vertex is a of\r\na tree only when you cut this vertex (remove it and remove all edges\r\nfrom this vertex), the size of the largest connected component of the\r\nremaining graph is the smallest possible.For example, the centroid of\r\nthe following tree is 2, because when you cut it, the size of the\r\nlargest connected component of the remaining graph is 2 and it can\u2019t be\r\nsmaller. However, in some trees, there might be more than one centroid,\r\nfor example: Both vertex 1 and vertex 2 are centroids because the size\r\nof the largest connected component is 3 after cutting each of them.Now\r\nFishing Prince has a tree. He should cut one edge of the tree (it means\r\nto remove the edge). After that, he should add one edge. The resulting\r\ngraph after these two operations should be a tree. He can add the edge\r\nthat he cut.He wants the centroid of the resulting tree to be unique.\r\nHelp him and find any possible way to make the operations. It can be\r\nproved, that at least one such way always exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl '\\n'\n//#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\nconst int N = 100100;\nvi g[N];\nint tam[N];\n\n\nvi centroid;\nint n;\nvoid dfs1(int v,int p = -1){\n  tam[v] = 1;\n  bool is= 1;\n\n  for(int to : g[v])if(to!=p){\n    dfs1(to,v);\n    tam[v]+=tam[to];\n    if(tam[to] > n/2)is = 0;\n  }\n  if(n - tam[v] > n/2)is = 0;\n  if(is)centroid.pb(v);\n}\n\n\n\nvoid solve(){\n  cin >> n;\n  for(int i=1;i<=n;i++)g[i].clear(),tam[i] = 1;\n\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    g[a].pb(b);\n    g[b].pb(a);\n  } \n  centroid.clear();\n  dfs1(1);\n  vector<pii> ans;\n  if(sz(centroid) == 1){\n    int to = g[1][0];\n    ans.pb(pii(1,to));\n    ans.pb(pii(1,to));\n  }else{\n    for(int to : g[centroid[0]]){\n      if(to!=centroid[1]){\n        ans.pb(pii(centroid[0],to));\n        ans.pb(pii(to,centroid[1]));\n        break;\n      }\n    }\n  }\n  assert(sz(ans) == 2);\n  for(auto it : ans){\n    cout << it.ff<<\" \"<<it.ss<<endl;\n  }\n}\n\nint32_t main(){\n  FASTIO;\n  int t;\n  cin >> t;\n  while(t--){\n    solve();\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Link Cut Centroids.json",
    "editorial_link": "https://codeforces.com//blog/entry/82560",
    "editorial": "Let vertex be the root of the tree. If there is only one centroid, just\r\ncut any edge and link it back.Otherwise there are two centroids. Let\r\nthem be and , then there must be an edge connecting and . (If not,\r\nchoose any other vertex on the path from to and the size of the largest\r\nconnected component after cutting it will be smaller than and ).Let be\r\n\u00e2\u0080\u0099s father. (If not, swap and ) Then just cut a leaf from \u00e2\u0080\u0099s subtree and\r\nlink it with . After that, becomes the only centroid.Proof: It\u00e2\u0080\u0099s easy to\r\nsee that the size of \u00e2\u0080\u0099s subtree must be exactly . After cutting and\r\nlinking, the maxinum component size of becomes while the maxinum\r\ncomponent size of is still .\r\n"
}