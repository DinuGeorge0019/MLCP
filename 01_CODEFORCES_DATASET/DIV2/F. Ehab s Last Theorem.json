{
    "link": "https://codeforces.com//contest/1325/problem/F",
    "problemId": "561458",
    "problem_idx": "F",
    "shortId": "1325F",
    "contest_number": "1325",
    "problem_submissions": {
        "E": [
            73269401,
            73332152,
            73299753,
            73395378,
            73360091,
            73360008
        ],
        "F": [
            73248978,
            73251409,
            73254927,
            73256076,
            73255610,
            73257423,
            73262364,
            73259512,
            73356282,
            73356144,
            73263300,
            73263158,
            73261258,
            73265350,
            73262400,
            73265312,
            73263991,
            73268889,
            73270937
        ],
        "D": [
            73244100,
            73243574,
            73240330,
            73242761,
            73241884,
            73241409,
            73246071,
            73252259,
            73251009,
            73248948,
            73245139,
            73243278,
            73250903,
            73243449,
            73248645,
            73246841,
            73242067
        ],
        "C": [
            73236055,
            73236410,
            73233326,
            73229143,
            73233805,
            73246561,
            73234913,
            73236946,
            73236155,
            73241716,
            73237967,
            73239330,
            73240506,
            73236929,
            73231917,
            73233819,
            73237479
        ],
        "B": [
            73227966,
            73225855,
            73227806,
            73223000,
            73224291,
            73227411,
            73226586,
            73225151,
            73229505,
            73230477,
            73228144,
            73229165,
            73230081,
            73251563,
            73223597,
            73227071,
            73225379
        ],
        "A": [
            73222798,
            73222976,
            73224188,
            73222275,
            73222466,
            73223833,
            73222584,
            73222533,
            73226908,
            73225662,
            73224126,
            73224793,
            73228118,
            73227876,
            73225812,
            73222400,
            73222615
        ]
    },
    "name": "F. Ehab s Last Theorem",
    "statement": "It\u2019s the year 5555. You have a graph, and you want to find a long cycle\r\nand a huge independent set, just because you can. But for now, let\u2019s\r\njust stick with finding either.Given a connected graph with n vertices,\r\nyou can choose to either: find an independent set that has\r\nlceil\r\nsqrt{n}\r\nrceil vertices. find a cycle of length\r\nlceil\r\nsqrt{n}\r\nrceil. An independent set is a set of vertices such that no two of them\r\nare connected by an edge. A simple cycle is a cycle that doesn\u2019t contain\r\nany vertex twice. I have a proof you can always solve one of these\r\nproblems, but it\u2019s too long to fit this margin.\r\n",
    "solutions": [
        "///BE NAME KHODA\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define S second\n#define F first\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxn = 2e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nint n, m, sq, sq2;\nvector<int> g[maxn], ta[maxn];\nint mark[maxn], h[maxn], par[maxn];\n\nvoid dfs(int v)\n{\n    ta[h[v]%sq2].push_back(v);\n    mark[v] = 1;\n    for(auto u : g[v])\n        if(!mark[u])\n        {\n            h[u] = h[v] + 1;\n            par[u] = v;\n            dfs(u);\n        }\n        else\n            if(h[v] - h[u] + 1 >= sq)\n            {\n                cout<< 2 <<\"\\n\";\n\n                vector<int> ans;\n                int V = v;\n                while(v != u)\n                {\n                    ans.push_back(v);\n                    v = par[v];\n                }\n                ans.push_back(u);\n\n                cout<< ans.size() <<\"\\n\";\n                for(auto x : ans) cout<< x <<\" \";\n\n                exit(0);\n            }\n\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n >> m;\n    int x = sqrt(n);\n    if(x * x == n)\n        sq = sqrt(n);\n    else\n        sq = sqrt(n) + 1;\n    sq2 = sqrt(n);\n\n    for(int i = 1, u , v; i <= m; i++)\n    {\n        cin>> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(1);\n\n    cout<< 1 <<\"\\n\";\n    for(int i = 0; i < sq2; i++)\n        if(ta[i].size() >= sq)\n        {\n            for(int j = 0; j < sq; j++)\n                cout<< ta[i][j] <<\" \";\n            return 0;\n        }\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Ehab s Last Theorem.json",
    "editorial_link": "https://codeforces.com//blog/entry/74235",
    "editorial": "A solution using DFS trees\nIf you're not familiar with back-edges, I recommend reading this first.\n\nLet's take the DFS tree of our graph. Assume you're currently in node u\n in the DFS. If u\n has sq?1\n or more back-edges, look at the one that connects u\n to its furthest ancestor. It forms a cycle of length at least sq\n. If u\n doesn't have that many back-edges, you can add it to the independent set (if none of its neighbors was added.) That way, if you don't find a cycle, every node only blocks at most sq?1\n other nodes, the ones connected to it by a back-edge, so you'll find an independent set!"
}