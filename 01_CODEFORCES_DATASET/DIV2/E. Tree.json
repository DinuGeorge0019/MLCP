{"link": "https://codeforces.com//contest/1111/problem/E", "problemId": "292521", "problem_idx": "E", "shortId": "1111E", "contest_number": "1111", "problem_submissions": {"D": [49422912, 49426608, 49445983, 49428765, 49430406, 49429665, 49436958], "C": [49409497, 49410558, 49410163, 49418920, 49410172, 49413606, 49411915, 49417203, 49413501, 49413738, 49417020, 49443919, 49443886, 49417049, 49414103, 49415090, 49412459, 49414253, 49415380, 49421248, 49439899, 49413981], "B": [49406849, 49405440, 49407099, 49408763, 49406563, 49408463, 49406490, 49408964, 49408646, 49408980, 49405550, 49418102, 49454731, 49438417, 49408744, 49409042, 49407957, 49421603, 49407686, 49409374, 49409345], "A": [49402871, 49402831, 49403748, 49403927, 49403205, 49402975, 49402985, 49410269, 49405415, 49404207, 49402972, 49402894, 49402944, 49404497, 49403455, 49404512, 49404416, 49403696, 49403984], "E": [49501912]}, "name": "E. Tree", "statement": "You are given a tree with n nodes and q queries.Every query starts with\r\nthree integers k, m and r, followed by k nodes of the tree a_1, a_2,\r\nldots, a_k. To answer a query, assume that the tree is rooted at r. We\r\nwant to divide the k given nodes into m groups such that the following\r\nconditions are met: Each node should be in exactly one group and each\r\ngroup should have at least one node. In any group, there should be no\r\ntwo distinct nodes such that one node is an ancestor (direct or\r\nindirect) of the other. You need to output the number of ways modulo\r\n10^{9}+7 for every query.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+7,mod=1e9+7;\nint n,q,k,m,r,cnt,a[N],b[N],v[N],nxt[N],hd[N],sz[N],dep[N],fa[N],pos[N],son[N],top[N],d[N],f[365];\nvoid add(int x,int y){v[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;}\nvoid dfs1(int u)\n{\n\tsz[u]=1,dep[u]=dep[fa[u]]+1;\n\tfor(int i=hd[u];i;i=nxt[i])\n\tif(v[i]!=fa[u])\n\t{\n\t\tfa[v[i]]=u,dfs1(v[i]),sz[u]+=sz[v[i]];\n\t\tif(sz[v[i]]>sz[son[u]])son[u]=v[i];\n\t}\n}\nvoid dfs2(int u,int tp)\n{\n\ttop[u]=tp,pos[u]=++cnt;\n\tif(son[u])dfs2(son[u],tp);\n\tfor(int i=hd[u];i;i=nxt[i])if(v[i]!=fa[u]&&v[i]!=son[u])dfs2(v[i],v[i]);\n}\nint lca(int x,int y)\n{\n\twhile(top[x]!=top[y])(dep[top[x]]>dep[top[y]])?x=fa[top[x]]:y=fa[top[y]];\n\treturn dep[x]<dep[y]?x:y;\n}\nvoid update(int x,int v){while(x<=n)d[x]+=v,x+=x&-x;}\nint query(int x){int ret=0;while(x)ret+=d[x],x-=x&-x;return ret;}\nint query(int l,int r){return query(r)-query(l-1);}\nint ask(int x,int y)\n{\n\tint ret=0;\n\twhile(top[x]^top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tret+=query(pos[top[x]],pos[x]);\n\t\tx=fa[top[x]];\n\t}\n\tret+=query(min(pos[x],pos[y]),max(pos[x],pos[y]));\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1,x,y;i<n;i++)scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tdfs1(1),cnt=0,dfs2(1,1);\n\twhile(q--)\n\t{\n\t\tscanf(\"%d%d%d\",&k,&m,&r);\n\t\tfor(int i=1;i<=k;i++)scanf(\"%d\",&b[i]),update(pos[b[i]],1);\n\t\tfor(int i=1;i<=k;i++)a[i]=ask(b[i],r)-1;\n\t\tsort(a+1,a+k+1);\n\t\tint flag=0;\n\t\tfor(int i=1;!flag&&i<=k;i++)\n\t\tif(a[i]>=m)flag=1;\n\t\tif(flag)\n\t\t{\n\t\t\tputs(\"0\");for(int i=1;i<=k;i++)update(pos[b[i]],-1);\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(f,0,sizeof f);\n\t\tf[0]=1;\n\t\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=min(i,m);~j;j--)\n\t\tif(j<=a[i])f[j]=0;else f[j]=(1ll*f[j]*(j-a[i])%mod+f[j-1])%mod;\n\t\tint ans=0;\n\t\tfor(int i=0;i<=m;i++)ans=(ans+f[i])%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t\tfor(int i=1;i<=k;i++)update(pos[b[i]],-1);\n\t}\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dp", "graphs", "trees"], "dificulty": "2500", "interactive": false}