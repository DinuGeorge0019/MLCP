{
    "link": "https://codeforces.com//contest/1111/problem/E",
    "problemId": "292521",
    "problem_idx": "E",
    "shortId": "1111E",
    "contest_number": "1111",
    "problem_submissions": {
        "D": [
            49422912,
            49426608,
            49445983,
            49428765,
            49430406,
            49429665,
            49436958
        ],
        "C": [
            49409497,
            49410558,
            49410163,
            49418920,
            49410172,
            49413606,
            49411915,
            49417203,
            49413501,
            49413738,
            49417020,
            49443919,
            49443886,
            49417049,
            49414103,
            49415090,
            49412459,
            49414253,
            49415380,
            49421248,
            49439899,
            49413981
        ],
        "B": [
            49406849,
            49405440,
            49407099,
            49408763,
            49406563,
            49408463,
            49406490,
            49408964,
            49408646,
            49408980,
            49405550,
            49418102,
            49454731,
            49438417,
            49408744,
            49409042,
            49407957,
            49421603,
            49407686,
            49409374,
            49409345
        ],
        "A": [
            49402871,
            49402831,
            49403748,
            49403927,
            49403205,
            49402975,
            49402985,
            49410269,
            49405415,
            49404207,
            49402972,
            49402894,
            49402944,
            49404497,
            49403455,
            49404512,
            49404416,
            49403696,
            49403984
        ],
        "E": [
            49501912
        ]
    },
    "name": "E. Tree",
    "statement": "You are given a tree with n nodes and q queries.Every query starts with\r\nthree integers k, m and r, followed by k nodes of the tree a_1, a_2,\r\nldots, a_k. To answer a query, assume that the tree is rooted at r. We\r\nwant to divide the k given nodes into m groups such that the following\r\nconditions are met: Each node should be in exactly one group and each\r\ngroup should have at least one node. In any group, there should be no\r\ntwo distinct nodes such that one node is an ancestor (direct or\r\nindirect) of the other. You need to output the number of ways modulo\r\n10^{9}+7 for every query.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+7,mod=1e9+7;\nint n,q,k,m,r,cnt,a[N],b[N],v[N],nxt[N],hd[N],sz[N],dep[N],fa[N],pos[N],son[N],top[N],d[N],f[365];\nvoid add(int x,int y){v[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;}\nvoid dfs1(int u)\n{\n\tsz[u]=1,dep[u]=dep[fa[u]]+1;\n\tfor(int i=hd[u];i;i=nxt[i])\n\tif(v[i]!=fa[u])\n\t{\n\t\tfa[v[i]]=u,dfs1(v[i]),sz[u]+=sz[v[i]];\n\t\tif(sz[v[i]]>sz[son[u]])son[u]=v[i];\n\t}\n}\nvoid dfs2(int u,int tp)\n{\n\ttop[u]=tp,pos[u]=++cnt;\n\tif(son[u])dfs2(son[u],tp);\n\tfor(int i=hd[u];i;i=nxt[i])if(v[i]!=fa[u]&&v[i]!=son[u])dfs2(v[i],v[i]);\n}\nint lca(int x,int y)\n{\n\twhile(top[x]!=top[y])(dep[top[x]]>dep[top[y]])?x=fa[top[x]]:y=fa[top[y]];\n\treturn dep[x]<dep[y]?x:y;\n}\nvoid update(int x,int v){while(x<=n)d[x]+=v,x+=x&-x;}\nint query(int x){int ret=0;while(x)ret+=d[x],x-=x&-x;return ret;}\nint query(int l,int r){return query(r)-query(l-1);}\nint ask(int x,int y)\n{\n\tint ret=0;\n\twhile(top[x]^top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tret+=query(pos[top[x]],pos[x]);\n\t\tx=fa[top[x]];\n\t}\n\tret+=query(min(pos[x],pos[y]),max(pos[x],pos[y]));\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1,x,y;i<n;i++)scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tdfs1(1),cnt=0,dfs2(1,1);\n\twhile(q--)\n\t{\n\t\tscanf(\"%d%d%d\",&k,&m,&r);\n\t\tfor(int i=1;i<=k;i++)scanf(\"%d\",&b[i]),update(pos[b[i]],1);\n\t\tfor(int i=1;i<=k;i++)a[i]=ask(b[i],r)-1;\n\t\tsort(a+1,a+k+1);\n\t\tint flag=0;\n\t\tfor(int i=1;!flag&&i<=k;i++)\n\t\tif(a[i]>=m)flag=1;\n\t\tif(flag)\n\t\t{\n\t\t\tputs(\"0\");for(int i=1;i<=k;i++)update(pos[b[i]],-1);\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(f,0,sizeof f);\n\t\tf[0]=1;\n\t\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=min(i,m);~j;j--)\n\t\tif(j<=a[i])f[j]=0;else f[j]=(1ll*f[j]*(j-a[i])%mod+f[j-1])%mod;\n\t\tint ans=0;\n\t\tfor(int i=0;i<=m;i++)ans=(ans+f[i])%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t\tfor(int i=1;i<=k;i++)update(pos[b[i]],-1);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/64989",
    "editorial": "Assume that we didnât have to root at Y in each query. Lets first solve\r\nthe problem for all queries having root at 1. While processing the\r\nquery, letâs sort the given set of nodes according to the dfs order. Let\r\ndp[i][j] denotes the number of ways to divide the first i nodes in the\r\nset into j non-empty groups. For a node i, let h[i] denote the number of\r\nancestors in the query set. Now,dp[i][j] = dp[i-1][j](j-h[i]) +\r\ndp[i-1][j-1]The first part basically says, that apart from the groups of\r\nthe ancestors of i, it can be included in any other group, hence\r\n(j-h[i]) choices for allocating a group to i. The second part is\r\nincluding -th node in a completely new group. Thus our final answer\r\nwould have been the sum of dp[n][j] for all j from 1 to x. Now how to\r\nfind h[i]? If we mark all the nodes which have appeared in the query,\r\nh[i] is the number of marked nodes from i to the root. This can be\r\ncomputed using standard range updates and point queries on Euler tree.\r\nFor all nodes i, perform a range update on the range [ST(i),EN(i)] and\r\nh[i] basically becomes query(ST[i]). Now a key observation. Notice that\r\nactually we only care that for node i, before updating its dp, all its\r\nancestors are visited. This means we actually do not need the dfs order,\r\ninstead just the level-wise order. So all we need to do is sort all\r\nnodes in the query set according to the h[i] values. By removing the\r\ncondition for dfs order on the ordering of the dp, the condition for\r\nrerooting can also be handled. If the tree is rooted at Y, Now hnew[i]\r\nbecomes the number of marked nodes between i and root Y. This can be\r\ncomputed using the same technique of range update and query. hnew[i] =\r\nh[i] + h[Y] - 2h[ LCA(i,Y)] + (mark[LCA(i,Y)]==true) -1(-1 because we do\r\nnot want to include i in hnew[i])Now we do the same dp and compute the\r\nanswer.For every query: Sorting = O(KlogK), LCA computation = O(KlogN),\r\nbit update and query= O(KlogN) LCA precomputation = O(NlogN) Thus final\r\ncomplexity = O( NlogN + logN(summation over all values of K))(where\r\nsummation of K <= 10^5)\r\n",
    "hint": []
}