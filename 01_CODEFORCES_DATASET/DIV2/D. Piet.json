{
    "link": "https://codeforces.com//contest/133/problem/D",
    "problemId": "704",
    "problem_idx": "D",
    "shortId": "133D",
    "contest_number": "133",
    "problem_submissions": {
        "E": [
            924813,
            923201,
            925122,
            924740,
            923151,
            925910,
            928212,
            925928,
            924995,
            923703,
            924128,
            929077,
            924213,
            924289
        ],
        "D": [
            923670,
            925451,
            923404,
            923731,
            926478,
            924800,
            924588,
            926856,
            923474,
            924032,
            924197,
            924879
        ],
        "C": [
            921698,
            921926,
            921368,
            921398,
            921083,
            921917,
            922348,
            919949,
            921656,
            922402,
            921490,
            922221,
            929129,
            921781,
            920761,
            921370,
            922130
        ],
        "B": [
            920321,
            920624,
            920117,
            919992,
            919882,
            920500,
            921070,
            921364,
            920093,
            921113,
            920430,
            920262,
            929115,
            919964,
            919777,
            919852,
            920879
        ],
        "A": [
            919203,
            919548,
            919250,
            919042,
            919124,
            919191,
            920089,
            921756,
            919222,
            920426,
            919339,
            918987,
            918923,
            918953,
            918882,
            918982
        ]
    },
    "name": "D. Piet",
    "statement": "Piet is one of the most known visual esoteric programming languages. The\r\nprograms in Piet are constructed from colorful blocks of pixels and\r\ninterpreted using pretty complicated rules. In this problem we will use\r\na subset of Piet language with simplified rules.The program will be a\r\nrectangular image consisting of colored and black pixels. The color of\r\neach pixel will be given by an integer number between 0 and 9,\r\ninclusive, with 0 denoting black. A block of pixels is defined as a\r\nrectangle of pixels of the same color (not black). It is guaranteed that\r\nall connected groups of colored pixels of the same color will form\r\nrectangular blocks. Groups of black pixels can form arbitrary shapes.The\r\nprogram is interpreted using movement of instruction pointer (IP) which\r\nconsists of three parts: current block pointer (BP); note that there is\r\nno concept of current pixel within the block; direction pointer (DP)\r\nwhich can point left, right, up or down; block chooser (CP) which can\r\npoint to the left or to the right from the direction given by DP; in\r\nabsolute values CP can differ from DP by 90 degrees counterclockwise or\r\nclockwise, respectively.Initially BP points to the block which contains\r\nthe top-left corner of the program, DP points to the right, and CP\r\npoints to the left (see the orange square on the image below).One step\r\nof program interpretation changes the state of IP in a following way.\r\nThe interpreter finds the furthest edge of the current color block in\r\nthe direction of the DP. From all pixels that form this edge, the\r\ninterpreter selects the furthest one in the direction of . After this,\r\nBP attempts to move from this pixel into the next one in the direction\r\nof DP. If the next pixel belongs to a colored block, this block becomes\r\nthe current one, and two other parts of IP stay the same. It the next\r\npixel is black or outside of the program, BP stays the same but two\r\nother parts of IP change. If CP was pointing to the left, now it points\r\nto the right, and DP stays the same. If CP was pointing to the right,\r\nnow it points to the left, and DP is rotated 90 degrees clockwise.This\r\nway BP will never point to a black block (it is guaranteed that top-left\r\npixel of the program will not be black).You are given a Piet program.\r\nYou have to figure out which block of the program will be current after\r\nsteps.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <string>\n#include <map>\n#include <cstring>\n#include <bitset>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <memory.h>\n#include <list>\n#include <vector>\n#include <set>\n#include <stack>\n#include <deque>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define sqr(n)  (n)*(n)\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define INF 2000000000\n\ntypedef long long ll;\n\nbool calced[60][60][4][2];\nbool possible[60][60][4][2];\npair<int,int> Go[60][60][4][2];\nint field[60][60];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint main()\n{\n    mem0(calced);\n    mem0(possible);\n    int M,N;\n    string s;\n    scanf(\"%d%d\",&M,&N);\n    for(int i = 0; i < M; i++){\n        cin >> s;\n        field[i+1][0] = 0;\n        field[i+1][s.size() + 1] = 0;\n        for(int j = 0; j < s.size(); j++)\n            field[i+1][j+1] = s[j]-'0';\n    }\n    for(int i = 0; i < 60; i++)\n        field[0][i] = field[M+1][i] = 0;\n    pair<int,int> current = make_pair(1,1);\n    int dp = 0;\n    int cp = 0;\n    for(int z = 0; z < N; z++){\n        pair<int,int> temp = current;\n        if(calced[current.first][current.second][dp][cp]){\n            if(possible[current.first][current.second][dp][cp]){\n                current = Go[current.first][current.second][dp][cp];\n                continue;\n            }\n            else{\n                if(cp==1)\n                {\n                    cp = 0;\n                    dp = (dp+1)%4;\n                }\n                else\n                    cp = 1;\n                continue;\n            }\n        }\n        while(field[current.first + dx[dp]][current.second + dy[dp]]==field[temp.first][temp.second])\n        {\n            current.first += dx[dp];\n            current.second += dy[dp];\n        }\n        int ddx, ddy;\n        if(dp == 0)\n            ddx = -1,ddy = 0;\n        else if(dp==1)\n            ddx = 0, ddy = 1;\n        else if(dp==2)\n            ddx = 1, ddy = 0;\n        else ddx = 0, ddy = -1;\n        if(cp==1){\n            ddx*=-1;\n            ddy*=-1;\n        }\n        while(field[current.first + ddx][current.second + ddy]==field[temp.first][temp.second])\n        {\n            current.first += ddx;\n            current.second += ddy;\n        }\n        calced[temp.first][temp.second][dp][cp] = true;\n        if(field[current.first + dx[dp]][current.second + dy[dp]]==0){\n            possible[temp.first][temp.second][dp][cp] = false;\n            if(cp==1)\n            {\n                cp = 0;\n                dp = (dp+1)%4;\n            }\n            else\n                cp = 1;\n            continue;\n        }\n        else\n        {\n            possible[temp.first][temp.second][dp][cp] = true;\n            current.first += dx[dp];\n            current.second += dy[dp];\n            Go[temp.first][temp.second][dp][cp] = current;\n            continue;\n        }\n    }\n    printf(\"%d\",field[current.first][current.second]);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Piet.json",
    "editorial_link": "https://codeforces.com//blog/entry/3302",
    "editorial": "As youâve already noticed, Piet differs from most other esoteric\r\nprogramming languages in the way it interprets the image the problem\r\noffered a very simplified version of it, and still it was quite cruel.\r\nThe first step of the solution is finding colored blocks. Given that\r\nthey are rectangular, this can be done without BFS; once youâve found a\r\ncolored pixel which is not part of any block youâve seen before, you\r\njust find the maximal contiguous sequence of pixels of the same color in\r\nthe same line that starts with this pixel, and assume that itâs\r\nhorizontal dimension of its block. I found it convenient to index the\r\nblocks and store their colors and dimensions at this point, so that this\r\ndoesnât need to be re-done later. After this I calculated \"state\r\ntransition function\" a function which for each state of instruction\r\npointer defined the next state. The IP has at most 50x50x4x2 states, and\r\nthey can be indexed with 8*(index of current block) + 2*(direction\r\npointer) + (block chooser). Thus, the transition function can be\r\ndescribed with a one-dimensional array (index is current state of IP,\r\nand value is the next one), and the simulation of interpretation steps\r\nbecomes just updating the current state of IP, which is easier than\r\nrepeating the full procedure described in the statement on each step. It\r\nwas also possible to note that at some point there will be a loop in the\r\nstates of the IP, since the maximal possible number of distinct states\r\nis less than the number of steps to be done. But exploiting this wasnât\r\nnecessary.\r\n",
    "hint": []
}