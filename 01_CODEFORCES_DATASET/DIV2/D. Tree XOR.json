{
    "link": "https://codeforces.com//contest/1882/problem/D",
    "problemId": "2227517",
    "problem_idx": "D",
    "shortId": "1882D",
    "contest_number": "1882",
    "problem_submissions": {
        "E2": [
            225204189,
            225160002,
            225202768,
            225477016,
            225476880,
            225475232,
            225472626
        ],
        "E1": [
            225123936,
            225133746,
            225140131,
            225133665,
            225132240,
            225138063,
            225142760,
            225139602,
            225142422,
            225147512,
            225146106,
            225142740,
            225141291,
            225138856,
            225144845,
            225148151,
            225478094,
            225148992,
            225162295,
            225152100,
            225152337,
            225148869
        ],
        "D": [
            225106356,
            225113280,
            225112999,
            225122785,
            225103764,
            225119012,
            225120043,
            225120508,
            225110063,
            225117734,
            225117249,
            225125156,
            225114397,
            225121683,
            225123705,
            225117693,
            225627016,
            225115870,
            225118591,
            225116324,
            225122541
        ],
        "C": [
            225101844,
            225106102,
            225108446,
            225110739,
            225110971,
            225110665,
            225111630,
            225111292,
            225113490,
            225109057,
            225111482,
            225110667,
            225107121,
            225115756,
            225110831,
            225108821,
            225109177,
            225108521,
            225104527,
            225107759
        ],
        "B": [
            225097300,
            225100132,
            225102630,
            225101761,
            225116077,
            225104479,
            225103013,
            225101827,
            225105709,
            225102804,
            225106906,
            225101186,
            225121302,
            225101604,
            225099036,
            225100746,
            225104002,
            225103297,
            225100386,
            225100570
        ],
        "A": [
            225093910,
            225094018,
            225094163,
            225094069,
            225115330,
            225094938,
            225094567,
            225094063,
            225094790,
            225097756,
            225096481,
            225094301,
            225094479,
            225093976,
            225093977,
            225093952,
            225104147,
            225094178,
            225095571,
            225096872
        ]
    },
    "name": "D. Tree XOR",
    "statement": "You are given a tree with n vertices labeled from 1 to n. An integer\r\na_{i} is written on vertex i for i = 1, 2,\r\nldots, n. You want to make all a_{i} equal by performing some (possibly,\r\nzero) spells.Suppose you root the tree at some vertex. On each spell,\r\nyou can select any vertex v and any non-negative integer c. Then for all\r\nvertices i in the subtree^{\r\ndagger} of v, replace a_{i} with a_{i}\r\noplus c. The cost of this spell is s\r\ncdot c, where s is the number of vertices in the subtree. Here\r\noplus denotes the bitwise XOR operation.Let m_r be the minimum possible\r\ntotal cost required to make all a_i equal, if vertex r is chosen as the\r\nroot of the tree. Find m_{1}, m_{2},\r\nldots, m_{n}.^{\r\ndagger} Suppose vertex r is chosen as the root of the tree. Then vertex\r\ni belongs to the subtree of v if the simple path from i to r contains v.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=500005;\nint n,m,T;\nint a[maxn],sz[maxn];\nlong long ans[maxn];\nvector<int>v[maxn];\nvoid dfs1(int x,int last){\n\tsz[x]=1;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==last)\n\t\t\tcontinue;\n\t\tdfs1(y,x),sz[x]+=sz[y],ans[1]+=1ll*(a[x]^a[y])*sz[y];\n\t}\n}\nvoid dfs2(int x,int last){\n\tsz[x]=1;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==last)\n\t\t\tcontinue;\n\t\tans[y]=ans[x]-1ll*(a[x]^a[y])*sz[y]+1ll*(a[x]^a[y])*(n-sz[y]);\n\t\tdfs2(y,x);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\tfor(int i=1,x,y;i<n;i++)\n\t\t\tscanf(\"%d%d\",&x,&y),v[x].emplace_back(y),v[y].emplace_back(x);\n\t\tdfs1(1,0),dfs2(1,0);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"%lld%c\",ans[i],i==n? '\\n':' '),ans[i]=0,v[i].clear();\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Tree XOR.json",
    "editorial_link": "https://codeforces.com//blog/entry/120792",
    "editorial": "Add an extra character \u00e2\u0080\u009d in front of the permutation. Here\nposition of won\u00e2\u0080\u0099t be changed by the operation, and will always locate at\nleft of . Then in each operation, the permutation will change as: .Now,\nlet\u00e2\u0080\u0099s consider the array made by and permutation as circular. This is\npossible because is always in left of st element, so it marks the start\nof the permutation. Then is equivalent with .Then the operation is: ,\nwhich is same with swapping and .Now we need to calculate the minimum\nodd number of swaps and even number of swaps(of and any element) each,\nturning to one of , , , , .To calculate the minimum number of swaps\nrequired to turn to the given array, first renumber the initial array to\n, then change the given array in the same correspondence. Do permutation\ncycle decomposition. Then the answer is (sum of (size + 1) for cycles\nwhich have size 2 and don\u00e2\u0080\u0099t contain ) + (\u00e2\u0080\u0099s cycle size 1). This can be\nproven easily by counting the number of elements which go into the\nproper place in each operations.Calculate this for all , , , , . Since\nwe can\u00e2\u0080\u0099t make the same array using different parity of number of swaps,\nwe can achieve the goal by calculating the minimum odd number and\nminimum even number each.The overall time complexity is .\n"
}