{"link": "https://codeforces.com//contest/1882/problem/D", "problemId": "2227517", "problem_idx": "D", "shortId": "1882D", "contest_number": "1882", "problem_submissions": {"E2": [225204189, 225160002, 225202768, 225477016, 225476880, 225475232, 225472626], "E1": [225123936, 225133746, 225140131, 225133665, 225132240, 225138063, 225142760, 225139602, 225142422, 225147512, 225146106, 225142740, 225141291, 225138856, 225144845, 225148151, 225478094, 225148992, 225162295, 225152100, 225152337, 225148869], "D": [225106356, 225113280, 225112999, 225122785, 225103764, 225119012, 225120043, 225120508, 225110063, 225117734, 225117249, 225125156, 225114397, 225121683, 225123705, 225117693, 225627016, 225115870, 225118591, 225116324, 225122541], "C": [225101844, 225106102, 225108446, 225110739, 225110971, 225110665, 225111630, 225111292, 225113490, 225109057, 225111482, 225110667, 225107121, 225115756, 225110831, 225108821, 225109177, 225108521, 225104527, 225107759], "B": [225097300, 225100132, 225102630, 225101761, 225116077, 225104479, 225103013, 225101827, 225105709, 225102804, 225106906, 225101186, 225121302, 225101604, 225099036, 225100746, 225104002, 225103297, 225100386, 225100570], "A": [225093910, 225094018, 225094163, 225094069, 225115330, 225094938, 225094567, 225094063, 225094790, 225097756, 225096481, 225094301, 225094479, 225093976, 225093977, 225093952, 225104147, 225094178, 225095571, 225096872]}, "name": "D. Tree XOR", "statement": "You are given a tree with n vertices labeled from 1 to n. An integer\r\na_{i} is written on vertex i for i = 1, 2,\r\nldots, n. You want to make all a_{i} equal by performing some (possibly,\r\nzero) spells.Suppose you root the tree at some vertex. On each spell,\r\nyou can select any vertex v and any non-negative integer c. Then for all\r\nvertices i in the subtree^{\r\ndagger} of v, replace a_{i} with a_{i}\r\noplus c. The cost of this spell is s\r\ncdot c, where s is the number of vertices in the subtree. Here\r\noplus denotes the bitwise XOR operation.Let m_r be the minimum possible\r\ntotal cost required to make all a_i equal, if vertex r is chosen as the\r\nroot of the tree. Find m_{1}, m_{2},\r\nldots, m_{n}.^{\r\ndagger} Suppose vertex r is chosen as the root of the tree. Then vertex\r\ni belongs to the subtree of v if the simple path from i to r contains v.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=500005;\nint n,m,T;\nint a[maxn],sz[maxn];\nlong long ans[maxn];\nvector<int>v[maxn];\nvoid dfs1(int x,int last){\n\tsz[x]=1;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==last)\n\t\t\tcontinue;\n\t\tdfs1(y,x),sz[x]+=sz[y],ans[1]+=1ll*(a[x]^a[y])*sz[y];\n\t}\n}\nvoid dfs2(int x,int last){\n\tsz[x]=1;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==last)\n\t\t\tcontinue;\n\t\tans[y]=ans[x]-1ll*(a[x]^a[y])*sz[y]+1ll*(a[x]^a[y])*(n-sz[y]);\n\t\tdfs2(y,x);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\tfor(int i=1,x,y;i<n;i++)\n\t\t\tscanf(\"%d%d\",&x,&y),v[x].emplace_back(y),v[y].emplace_back(x);\n\t\tdfs1(1,0),dfs2(1,0);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"%lld%c\",ans[i],i==n? '\\n':' '),ans[i]=0,v[i].clear();\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dfs and similar", "dp", "greedy", "trees"], "dificulty": "1900", "interactive": false}