{
    "link": "https://codeforces.com//contest/1215/problem/D",
    "problemId": "412394",
    "problem_idx": "D",
    "shortId": "1215D",
    "contest_number": "1215",
    "problem_submissions": {
        "F": [
            60620224,
            60633144,
            60628796,
            62102987,
            60657759
        ],
        "E": [
            60614830,
            60620100,
            60624259,
            60618193,
            60620939,
            60619722,
            60618555,
            60619211,
            60623129,
            60624049,
            60623962,
            60621062,
            60625235,
            60625015,
            60623138,
            60622255,
            60623519,
            60627768,
            60628419,
            60622708
        ],
        "D": [
            60613485,
            60617335,
            60619535,
            60616864,
            60615351,
            60616017,
            60622796,
            60619079,
            60617400,
            60616935,
            60621165,
            60617806,
            60616391,
            60616135,
            60618699,
            60620021,
            60619257,
            60623666,
            60614165,
            60618490
        ],
        "C": [
            60611883,
            60614880,
            60616986,
            60613872,
            60612356,
            60613808,
            60613237,
            60615096,
            60615058,
            60613116,
            60615948,
            60615995,
            60614183,
            60613610,
            60614082,
            60612548,
            60614439,
            60618385,
            60611650,
            60615653
        ],
        "B": [
            60609609,
            60611892,
            60614411,
            60610320,
            60609887,
            60611712,
            60610288,
            60610941,
            60611470,
            60610159,
            60611942,
            60611586,
            60611453,
            60611164,
            60611443,
            60609621,
            60611512,
            60611710,
            60609773,
            60612774
        ],
        "A": [
            60609389,
            60610541,
            60610424,
            60609620,
            60609428,
            60610648,
            60609442,
            60611977,
            60609576,
            60609429,
            60610464,
            60609932,
            60609744,
            60609643,
            60609965,
            60616895,
            60610358,
            60609768,
            60609404,
            60611551
        ]
    },
    "name": "D. Ticket Game",
    "statement": "Monocarp and Bicarp live in Berland, where every bus ticket consists of\r\nn digits (n is an even number). During the evening walk Monocarp and\r\nBicarp found a ticket where some of the digits have been erased.\r\n.Monocarp and Bicarp have decided to play a game with this ticket.\r\nMonocarp hates happy tickets, while Bicarp collects them. A ticket is\r\nconsidered happy if the sum of the first\r\nfrac{n}{2} digits of this ticket is equal to the sum of the last\r\nfrac{n}{2} digits.Monocarp and Bicarp take turns (and Monocarp performs\r\nthe first of them). During each turn, the current player must replace\r\nany erased digit with any digit from 0 to 9. The game ends when there\r\nare no erased digits in the ticket.If the ticket is happy after all\r\nerased digits are replaced with decimal digits, then Bicarp wins.\r\nOtherwise, Monocarp wins. You have to determine who will win if both\r\nplayers play optimally.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nint n,s1,c1,s2,c2;\nchar s[1000005];\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\n\tFor(i,1,n/2)\n\t\tif (s[i]=='?') c1++;\n\t\telse s1+=s[i]-'0';\n\tFor(i,n/2+1,n)\n\t\tif (s[i]=='?') c2++;\n\t\telse s2+=s[i]-'0';\n\ts1+=c1/2*9; c1%=2;\n\ts2+=c2/2*9; c2%=2;\n\tputs(s1==s2?\"Bicarp\":\"Monocarp\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Ticket Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/69815",
    "editorial": "Letâs denote the balance as the difference between the sum of digits in\r\nthe left half and the sum of digits in the right half. Also let be the\r\nminimum possible balance (it can be calculated if we replace all\r\nquestion marks in the left half with âs and all the question marks in\r\nthe right half with âs), and let be the maximum possible balance.The\r\nsecond player wins if and only if . Letâs prove it by induction on the\r\nnumber of question marks left in the ticket.If all characters are\r\ndigits, the second player wins only if the ticket is happy, and that is\r\nwhen .Okay, now suppose the number of question marks is even, and now\r\nitâs first playerâs turn. Each turn decreases the value of by , and may\r\nset to any number from current to . If , then the first player can make\r\nas large as possible, and set it to . The best thing the second player\r\ncan do on his turn is to set to (and leave as it is), and the value of\r\nwill be the same as it was two turns earlier. The case can be analyzed\r\nsimilarly. And in the case the second player has a symmetric strategy.\r\n",
    "hint": []
}