{
    "link": "https://codeforces.com//contest/814/problem/B",
    "problemId": "108814",
    "problem_idx": "B",
    "shortId": "814B",
    "contest_number": "814",
    "problem_submissions": {
        "D": [
            27647493,
            27672108,
            27640106,
            27643923,
            27641961,
            27641720,
            27642103,
            27641350,
            27644262,
            27643542,
            27643790,
            27645753,
            27644413,
            27642630,
            27644185,
            27644064,
            27644363,
            27643194,
            27644293,
            27646026
        ],
        "C": [
            27645217,
            27635551,
            27636661,
            27634217,
            27636436,
            27636571,
            27637453,
            27638720,
            27637173,
            27637214,
            27639563,
            27637118,
            27638741,
            27639783,
            27640321,
            27639165,
            27639941,
            27659642,
            27639358,
            27640727,
            27637633
        ],
        "A": [
            27642326,
            27632216,
            27632277,
            27632196,
            27632419,
            27632275,
            27632342,
            27633234,
            27632333,
            27632408,
            27632471,
            27632235,
            27632967,
            27632675,
            27632317,
            27633643,
            27632625,
            27632707,
            27632622,
            27632717
        ],
        "E": [
            27641600,
            27647168,
            27666856,
            27661378,
            27652552,
            27730170,
            27729667,
            27669973,
            27692659
        ],
        "B": [
            27634262,
            27635046,
            27632554,
            27634627,
            27634088,
            27635201,
            27635429,
            27634469,
            27634865,
            27635554,
            27634700,
            27635414,
            27636492,
            27635586,
            27636132,
            27636741,
            27636455,
            27636685,
            27634894
        ]
    },
    "name": "B. An express train to reveries",
    "statement": "Sengoku still remembers the mysterious \"colourful meteoroids\" she\r\ndiscovered with Lala-chan when they were little. In particular, one of\r\nthe nights impressed her deeply, giving her the illusion that all her\r\nfancies would be realized.On that night, Sengoku constructed a\r\npermutation of integers from to inclusive, with each integer\r\nrepresenting a colour, wishing for the colours to see in the coming\r\nmeteor outburst. Two incredible outbursts then arrived, each with\r\nmeteorids, colours of which being integer sequences and respectively.\r\nMeteoroids’ colours were also between and inclusive, and the two\r\nsequences were not identical, that is, at least one () exists, such that\r\nholds.Well, she almost had it all each of the sequences and matched\r\nexactly elements in Sengoku’s permutation. In other words, there is\r\nexactly one () such that , and exactly one () such that .For now,\r\nSengoku is able to recover the actual colour sequences and through\r\nastronomical records, but her wishes have been long forgotten. You are\r\nto reconstruct any possible permutation Sengoku could have had on that\r\nnight.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\nint ok[N];\nint n, a[N], b[N];\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tcin >> n;\n\tfo(i, n)\n\t\tcin >> a[i];\n\tfo(i, n)\n\t\tcin >> b[i];\n\tvector<int> q;\n\tfo(i, n)\n\t\tif(a[i] != b[i])\n\t\t\tq.pb(i);\n\tif(q.size() == 1)\n\t{\n\t\tfo(i, n)\n\t\t\tif(a[i] == b[i])\n\t\t\t\tok[a[i]] = 1;\n\t\tfo(i, n)\n\t\t\tif(a[i] == b[i])\n\t\t\t\tcout << a[i] << \" \";\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int j = 1; j <= n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif(j != a[i] && j != b[i] && !ok[j])\n\t\t\t\t\t\tcout << j << ' ', j = n + 1;\n\t\t\t\t}\n\t\t\t}\n\t\treturn 0;\n\t}\n\tfo(i, n)\n\t\tif(a[i] == b[i])\n\t\t\tok[a[i]] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tif(!ok[a[q[0]]] && !ok[b[q[1]]])\n\t\t{\n\t\t\tif(i == q[0])\n\t\t\t\tcout << a[i];\n\t\t\telse \n\t\t\t\tcout << b[i];\n\t\t\tcout << ' ';\n\t\t} \n\t\telse\n\t\t{\n\t\t\tif(i == q[0])\n\t\t\t\tcout << b[i];\n\t\t\telse\n\t\t\t\tcout << a[i];\n\t\t\tcout << ' ';\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. An express train to reveries.json",
    "editorial_link": "https://codeforces.com//blog/entry/52449",
    "editorial": "Permutating directly no longer works here. Letâs try to dig something\r\nout from the constraints.Imagine that we take a permutation , and change\r\none of its elements to a different integer in , resulting in the\r\nsequence . There are exactly positions () such that , while the other\r\nelements are kept untouched. This is actually what and satisfy.Find out\r\nthese two positions in , and the two candidates for them that is, the\r\nonly two numbers not present in the remaining elements. Iterate over\r\ntheir two possible orders, and check the validity against sequence .Of\r\ncourse you can solve this with casework if you like.\r\n",
    "hint": []
}