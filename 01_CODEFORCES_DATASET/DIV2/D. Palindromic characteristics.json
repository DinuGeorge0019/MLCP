{
    "link": "https://codeforces.com//contest/835/problem/D",
    "problemId": "116349",
    "problem_idx": "D",
    "shortId": "835D",
    "contest_number": "835",
    "problem_submissions": {
        "D": [
            29372323,
            29063139,
            29065486,
            29070406,
            29071972,
            29065004,
            29066901,
            29072296,
            29065942,
            29065319,
            29066211,
            29066423,
            29075382,
            29067277,
            29065713,
            29073319,
            29071645,
            29059686
        ],
        "F": [
            29082635,
            29069949,
            29070481,
            29064958,
            29071364,
            29065236,
            29070446,
            29064892,
            29066866,
            29074301,
            29064205,
            29065410
        ],
        "E": [
            29073719,
            29074800,
            29065648,
            29071559,
            29118023,
            29074000,
            29070288,
            29074317,
            29074268,
            29072935,
            29075101,
            29066717
        ],
        "C": [
            29058240,
            29062830,
            29058737,
            29063335,
            29056792,
            29060472,
            29066295,
            29062534,
            29061132,
            29058860,
            29063690,
            29065693,
            29064050,
            29057954,
            29069770,
            29060762,
            29065225,
            29063124,
            29064200,
            29068485
        ],
        "B": [
            29056834,
            29060334,
            29054848,
            29057576,
            29053644,
            29056903,
            29057508,
            29057673,
            29056074,
            29075847,
            29059991,
            29061445,
            29056492,
            29073726,
            29059387,
            29100665,
            29056240,
            29055742,
            29057065,
            29080041,
            29054530
        ],
        "A": [
            29052216,
            29052753,
            29051567,
            29054419,
            29051774,
            29054501,
            29055498,
            29051558,
            29052865,
            29055926,
            29056006,
            29052148,
            29051882,
            29054461,
            29085374,
            29052881,
            29053437,
            29053701,
            29066515,
            29051895
        ]
    },
    "name": "D. Palindromic characteristics",
    "statement": "Palindromic characteristics of string with length is a sequence of\r\nintegers, where -th number is the total number of non-empty substrings\r\nof which are -palindromes.A string is -palindrome if and only if it\r\nreads the same backward as forward.A string is -palindrome () if and\r\nonly if: Its left half equals to its right half. Its left and right\r\nhalfs are non-empty ()-palindromes. The left half of string is its\r\nprefix of length , and right half the suffix of the same length. denotes\r\nthe length of string divided by , rounded down.Note that each substring\r\nis counted as many times as it appears in the string. For example, in\r\nthe string \"aaa\" the substring \"a\" appears 3 times.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nint nxt[1000010][30];\nint fail[1000010];\nint len[1000010];\nint trans[1000010];\nint a[1000010];\nint f[1000010];\nint cnt[1000010];\nll ans[1000010];\nint p;\nint n;\nint last;\nvoid init(int x)\n{\n    int i;\n    for(i=1;i<=26;i++)\n        nxt[x][i]=2;\n}\nvoid add(int x)\n{\n    a[++n]=x;\n    while(a[n-len[last]-1]!=a[n])\n        last=fail[last];\n    int cur=last;\n    if(nxt[cur][x]==2)\n    {\n        int now=++p;\n        init(p);\n        len[now]=len[cur]+2;\n        last=fail[last];\n        while(a[n-len[last]-1]!=a[n])\n            last=fail[last];\n        fail[now]=nxt[last][x];\n        if(len[fail[now]]<=len[now]/2)//\u6ca1\u6709\u8fd9\u90e8\u5206\u4e5f\u53ef\u4ee5AC \n            trans[now]=fail[now];\n        else\n        {\n            last=trans[cur];\n            while(len[last]+2>len[now]/2||a[n-len[last]-1]!=a[n])\n                last=fail[last];\n            trans[now]=nxt[last][x];\n        }\n        nxt[cur][x]=now;\n    }\n    last=nxt[cur][x];\n    cnt[last]++;\n}\nvoid solve()\n{\n    f[1]=0;\n    f[2]=0;\n    int i;\n    for(i=3;i<=p;i++)\n    \tif(len[trans[i]]==len[i]/2)\n\t    \tf[i]=f[trans[i]]+1;\n\t    else\n\t    \tf[i]=1;\n    for(i=p;i>=3;i--)\n    \tcnt[fail[i]]+=cnt[i];\n    for(i=3;i<=p;i++)\n    \tans[f[i]]+=cnt[i];\n}\nchar s[100010];\nint main()\n{\n//  freopen(\"necklace.in\",\"r\",stdin);\n//  freopen(\"necklace.out\",\"w\",stdout);\n    p=0;\n    n=0;\n    init(++p);\n    fail[p]=2;\n    len[p]=-1;\n    trans[p]=2;\n    init(++p);\n    fail[p]=1;\n    len[p]=0;\n    a[0]=-1;\n    trans[p]=1;\n    last=p;\n    int m;\n    scanf(\"%s\",s+1);\n    m=strlen(s+1);\n    int i;\n    for(i=1;i<=m;i++)\n        add(s[i]-'a'+1);\n    solve();\n    for(i=m-1;i>=1;i--)\n    \tans[i]+=ans[i+1];\n    for(i=1;i<=m;i++)\n    \tprintf(\"%I64d \",ans[i]);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "hashing",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Palindromic characteristics.json",
    "editorial_link": "https://codeforces.com//blog/entry/53588",
    "editorial": "If the string is -palindrome, then it is ()-palindrome.The string is\r\n-palindrome if and only if the both following conditions are true: It is\r\na palindrome. It\u00e2\u0080\u0099s left half is non-empty ()-palindrome. Let\u00e2\u0080\u0099s calculate\r\nthe following dp. is the maximum such that the substring built from\r\ncharacters from to is -palindrome. The dynamics is calculated in the\r\norder of non-decreasing of substring lengths. The values for and are\r\ncomputed trivially. Let . Then, if or , . Otherwise , where . When we\r\nhave dp values, we can calculate the number of substrings, which dp\r\nvalue is . Then the number of substrings that are -palindromes is .The\r\nsolution works in time and uses memory.Also, you could notice that the\r\nstring can be no more than -palindrome, and solve the problem in time,\r\nreducing the memory usage to .\r\n"
}