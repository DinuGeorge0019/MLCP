{
    "link": "https://codeforces.com//contest/1447/problem/C",
    "problemId": "797264",
    "problem_idx": "C",
    "shortId": "1447C",
    "contest_number": "1447",
    "problem_submissions": {
        "F1": [
            98482074,
            98493054,
            99700638,
            99700288,
            98507770,
            98535197
        ],
        "E": [
            98471672,
            98487762,
            98462641,
            98467656,
            98474856,
            98475468,
            98466748,
            98471089,
            98474335,
            98473016,
            98472819,
            98475501,
            98476100,
            98473152,
            98480927,
            98480063,
            98483273,
            98472232,
            98484816
        ],
        "D": [
            98465943,
            98460161,
            98460032,
            98460272,
            98457345,
            98456392,
            98459724,
            98462491,
            98458555,
            98456607,
            98463156,
            98464783,
            98463338,
            98468636,
            98460203,
            98469147,
            98464911,
            98463572,
            98466107
        ],
        "C": [
            98461616,
            98454149,
            98456198,
            98455102,
            98451609,
            98450909,
            98449636,
            98454179,
            98454951,
            98450139,
            98456033,
            98456615,
            98452367,
            98462699,
            98462915,
            98451741,
            98459164,
            98457799,
            98456088
        ],
        "B": [
            98459424,
            98448840,
            98451090,
            98683205,
            98449593,
            98453136,
            98446655,
            98474948,
            98449629,
            98450999,
            98461566,
            98449722,
            98448167,
            106347351,
            98672986,
            98448001,
            98455222,
            98451056,
            98457032,
            98449675,
            98477349,
            98451673
        ],
        "A": [
            98453484,
            98445641,
            98444797,
            98683165,
            98445393,
            98446357,
            98444563,
            98446885,
            98447224,
            98445951,
            98458580,
            98444650,
            98444710,
            135934878,
            135934648,
            135925416,
            135925369,
            135925314,
            135925279,
            135925096,
            135925047,
            135924862,
            135924832,
            135924797,
            135924764,
            135924707,
            135924661,
            135924602,
            135924566,
            135924526,
            135924432,
            135924298,
            135924179,
            106344775,
            98672850,
            98445798,
            98445995,
            98446080,
            98454545,
            98452405,
            98445713,
            98447399
        ],
        "F2": [
            100134501,
            99704090
        ]
    },
    "name": "C. Knapsack",
    "statement": "You have a knapsack with the capacity of W. There are also n items, the\r\ni-th one has weight w_i. You want to put some of these items into the\r\nknapsack in such a way that their total weight C is at least half of its\r\nsize, but (obviously) does not exceed it. Formally, C should satisfy:\r\nlceil\r\nfrac{W}{2}\r\nrceil\r\nle C\r\nle W. Output the list of items you will put into the knapsack or\r\ndetermine that fulfilling the conditions is impossible. If there are\r\nseveral possible lists of items satisfying the conditions, you can\r\noutput any. Note that you have to maximize the sum of weights of items\r\nin the knapsack.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\nint N;\ntypedef pair<LL,int> pli;\npli A[200010];\nLL W;\n\nint main() {\n    int T;\n    scanf(\"%d\",&T);\n    while(T--) {\n        scanf(\"%d%lld\",&N,&W);\n        for (int i=1;i<=N;i++) {\n            scanf(\"%lld\", &A[i].first);\n            A[i].second = i;\n        }\n        sort(A+1,A+N+1);\n        vector<int>ans;\n        LL S = 0;\n        for (int i=N;i>=1;i--) {\n            if (S + A[i].first > W) continue;\n            S += A[i].first;\n            ans.push_back(A[i].second);\n        }\n        if (S * 2 < W) puts(\"-1\");\n        else {\n            printf(\"%d\\n\",ans.size());\n            for (int i=0;i<ans.size();i++) {\n                printf(\"%d%c\",ans[i],\" \\n\"[i==ans.size()-1]);\n            }\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Knapsack.json",
    "editorial_link": "https://codeforces.com//blog/entry/82067",
    "editorial": "SolutionIf there is an item of size satisfying: , it is enough to output\r\nonly that item. Otherwise, we should exclude items which are larger than\r\nthe size of the knapsack and take a closer look at the situation.\r\nConsider greedily adding items in any order until we find a valid\r\nsolution or run out of items.This is correct because all items have\r\nsizes less than , so it is not possible to exceed knapsack size by\r\nadding one item in a situation where the sum of items doesn\u00e2\u0080\u0099t satisfy\r\nconstraint .This gives us a solution in .\r\n"
}