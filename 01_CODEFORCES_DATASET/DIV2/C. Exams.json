{
    "link": "https://codeforces.com//contest/479/problem/C",
    "problemId": "15735",
    "problem_idx": "C",
    "shortId": "479C",
    "contest_number": "479",
    "problem_submissions": {
        "A": [
            8309900,
            8302126,
            8303586,
            8301931,
            8301886,
            8303454,
            8302426,
            8303355,
            8302448,
            8301877,
            8303309,
            8302705,
            8301884,
            8303259,
            8303414,
            8319050,
            8314132,
            8301946,
            8520832
        ],
        "E": [
            8309056,
            8311803,
            8312909,
            8313438,
            8316084,
            8316020,
            8313424,
            8327786,
            8315963,
            8317334,
            8309253,
            8316559,
            8315476,
            8316804,
            8316031,
            8315095,
            8316251,
            8315450,
            8317290,
            8312971,
            8313774
        ],
        "D": [
            8307373,
            8309115,
            8309669,
            8309141,
            8311118,
            8310810,
            8314426,
            8309794,
            8310784,
            8315457,
            8313129,
            8315683,
            8314350,
            8316993,
            8315739,
            8312498,
            8311921,
            8333608,
            8316306
        ],
        "C": [
            8305195,
            8306485,
            8306619,
            8305446,
            8306856,
            8306836,
            8308389,
            8306838,
            8306950,
            8305838,
            8307233,
            8304436,
            8308183,
            8305296,
            8304427,
            8304574,
            8306220,
            8306521,
            8306064,
            8305718
        ],
        "B": [
            8304577,
            8305140,
            8304920,
            8353901,
            8304212,
            8303937,
            8306178,
            8306010,
            8306262,
            8305338,
            8304463,
            8306364,
            8309399,
            8307051,
            8303801,
            8309094,
            8310340,
            8304911,
            8313716,
            8303910,
            8520830
        ]
    },
    "name": "C. Exams",
    "statement": "Student Valera is an undergraduate student at the University. His end of\r\nterm exams are approaching and he is to pass exactly exams. Valera is a\r\nsmart guy, so he will be able to pass any exam he takes on his first\r\ntry. Besides, he can take several exams on one day, and in any\r\norder.According to the schedule, a student can take the exam for the -th\r\nsubject on the day number . However, Valera has made an arrangement with\r\neach teacher and the teacher of the -th subject allowed him to take an\r\nexam before the schedule time on day (). Thus, Valera can take an exam\r\nfor the -th subject either on day , or on day . All the teachers put the\r\nrecord of the exam in the student\u2019s record book on the day of the actual\r\nexam and write down the date of the mark as number .Valera believes that\r\nit would be rather strange if the entries in the record book did not go\r\nin the order of non-decreasing date. Therefore Valera asks you to help\r\nhim. Find the minimum possible value of the day when Valera can take the\r\nfinal exam if he takes exams so that all the records in his record book\r\ngo in the order of non-decreasing date.\r\n",
    "solutions": [
        "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<cstring>\n#define rep(i,a,b) for (int i=a;i<=b;++i)\n#define dep(i,a,b) for (int i=a;i>=b;--i)\n#define For(i,u) for (int i=H[u];i;i=nxt[i])\n#define re(i,x) for (i=x.begin();i!=x.end();++i)\n#define mp make_pair\n#define pb push_back\n#define mod 1000000007\n#define N 100005\n#define X first\n#define Y second\nusing namespace std;\ntemplate<class T> inline void read(T&x){bool fu=0;char c;for(c=getchar();c<=32;c=getchar());if(c=='-')fu=1,c=getchar();for(x=0;c>32;c=getchar())x=x*10+c-'0';if(fu)x=-x;};\ntemplate<class T> inline void read(T&x,T&y){read(x);read(y);}\ntemplate<class T> inline void read(T&x,T&y,T&z){read(x);read(y);read(z);}\ntypedef long long ll;\ntypedef pair<int,int> pii;\npii a[N];\n//head\nint n,k;\nint main() {\n    read(n);rep(i,1,n)read(a[i].X,a[i].Y);\n    sort(a+1,a+n+1);\n    int ans=0;\n    rep(i,1,n) ans=a[i].second>=ans?a[i].second:a[i].first;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Exams.json",
    "editorial_link": "https://codeforces.com//blog/entry/14351",
    "editorial": "The solution is again greedy. Sort the exams by increasing , breaking\r\nties by increasing . Let s consider exams in this order and try to take\r\nthe exams as early as possible. Take the first exams in this order on\r\nthe early day (). Move to the second exam. If we can take it on the day\r\n(i.e. ), do it. Otherwise, take the second exam on the day . Continue\r\nthe process, keeping the day of the latest exam.\r\n"
}