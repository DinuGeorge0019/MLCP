{"link": "https://codeforces.com//contest/965/problem/E", "problemId": "178363", "problem_idx": "E", "shortId": "965E", "contest_number": "965", "problem_submissions": {"E": [37616803, 37610971, 41503980, 40197656, 37654456, 37654431, 40318499, 37616580], "D": [37611930, 37607040, 41317763, 37610171, 37612067, 37611181, 37613901, 37612776, 37612200, 37613391, 37614260, 37613271, 37613054, 37610290, 37613116, 37613596, 37613050, 37608849, 37612402], "C": [37610216, 37627090, 37608448, 37610114, 37609387, 37611531, 37607821, 37608408, 37609724, 37610645, 37613952, 37610230, 37612051, 37612323], "B": [37605866, 37605512, 37606428, 37607027, 37606169, 37607177, 37606751, 37606339, 37606193, 37607495, 37606252, 37606978, 37608449, 37606976, 37606755, 37607765, 37606148, 37607397], "A": [37604550, 37604452, 37604479, 37604681, 37604781, 37605030, 37604765, 37604552, 37605013, 37605227, 37604704, 37604697, 37605015, 37604932, 37605063, 37605445, 37634065, 37604890]}, "name": "E. Short Code", "statement": "Arkady\u2019s code contains n variables. Each variable has a unique name\r\nconsisting of lowercase English letters only. One day Arkady decided to\r\nshorten his code.He wants to replace each variable name with its\r\nnon-empty prefix so that these new names are still unique (however, a\r\nnew name of some variable can coincide with some old name of another or\r\nsame variable). Among such possibilities he wants to find the way with\r\nthe smallest possible total length of the new names.A string a is a\r\nprefix of a string b if you can delete some (possibly none) characters\r\nfrom the end of b and obtain a.Please find this minimum possible total\r\nlength of new names.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define f first\n#define s second\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nstruct br {\n int next[30];\n int ok;\n int d;\n};\n\nint n;\n\nstring s[N];\n\nbr t[N];\n\nint sz = 1;\n\nmultiset <int> st[N];\n\nint P[N];\n\nvoid add(string s) {\n int v = 1;\n int last = 1;\n for (int i = 0; i < int(s.size()); i++) {\n  if (!t[v].next[s[i] - 'a']) {\n   t[v].next[s[i] - 'a'] = ++sz;\n   fill(t[sz].next, t[sz].next + 26, 0);\n  }\n  last = v;\n  v = t[v].next[s[i] - 'a'];\n  t[v].d = t[last].d + 1;\n }\n t[v].ok = 1;\n}\n\nvoid get(int v) {\n P[v] = v;\n if (t[v].ok) st[v].insert(t[v].d);\n for (int i = 0; i < 26; i++) {\n  if (t[v].next[i]) {\n   get(t[v].next[i]);\n   int id = t[v].next[i];\n   if (int(st[P[id]].size()) < int(st[P[v]].size())) {\n    for (auto x : st[P[id]]) {\n     st[P[v]].insert(x);\n    }\n   } else {\n    for (auto x : st[P[v]]) {\n     st[P[id]].insert(x);\n    }\n    P[v] = P[id];\n   }\n  }\n }\n if (!t[v].ok) {\n  st[P[v]].erase(--st[P[v]].end());\n  st[P[v]].insert(t[v].d);\n }\n}\n\nint main() {\n ios_base::sync_with_stdio(false);\n cin >> n;\n t[1].d = 0;\n t[1].ok = 1;\n for (int i = 1; i <= n; i++) {\n  cin >> s[i];\n  add(s[i]);\n }\n get(1);\n int sum = 0;\n for (auto it : st[P[1]]) {\n  sum += it;\n }\n cout << sum;\n return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "greedy", "strings", "trees"], "dificulty": "2200", "interactive": false}