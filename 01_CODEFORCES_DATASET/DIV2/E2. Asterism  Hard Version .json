{
    "link": "https://codeforces.com//contest/1371/problem/E2",
    "problemId": "658033",
    "problem_idx": "E2",
    "shortId": "1371E2",
    "contest_number": "1371",
    "problem_submissions": {
        "F": [
            85724126,
            85680245,
            85681350,
            85699885
        ],
        "E2": [
            85657442,
            85655168,
            85656290,
            85748587,
            85748232,
            85708674,
            85665045,
            85668857,
            85658632,
            85666166,
            85670120,
            85660293,
            85663781,
            85670954,
            85668210,
            85680055,
            85669661,
            85682351,
            85669454,
            85672846,
            85682060,
            85671106
        ],
        "E1": [
            85647787,
            85655311,
            85656202,
            85709850,
            85654362,
            85651600,
            85658237,
            85658032,
            85654262,
            85660541,
            85663528,
            85656065,
            85668083,
            85661660,
            85665638,
            85654459,
            85668563,
            85663741,
            85657234,
            85666469
        ],
        "D": [
            85643050,
            85667344,
            85644091,
            85642391,
            85641068,
            85648738,
            85648076,
            85650769,
            85650684,
            85651359,
            85649126,
            85650672,
            85644656,
            85652003,
            85647555,
            85653607,
            85654186,
            85646247,
            85653171
        ],
        "C": [
            85639893,
            85664644,
            85640509,
            85637217,
            85637662,
            85643069,
            85643313,
            85639582,
            85644962,
            85641558,
            85643750,
            85642402,
            85635916,
            85643555,
            85643224,
            85639831,
            85646794,
            85639649,
            85640565
        ],
        "B": [
            85637385,
            85659549,
            85636246,
            85634765,
            85643737,
            85638003,
            85639540,
            85641465,
            85641062,
            85638464,
            85641050,
            85638539,
            85645723,
            85639381,
            85639446,
            85646495,
            85640832,
            85636683,
            85636740
        ],
        "A": [
            85625335,
            85659712,
            85625054,
            85624966,
            85631182,
            85625230,
            85625986,
            85627166,
            85626824,
            85627013,
            85638725,
            85626600,
            85625210,
            85625324,
            85628198,
            85626246,
            85627731,
            85625426,
            85631949
        ]
    },
    "name": "E2. Asterism  Hard Version ",
    "statement": "First, Aoi came up with the following idea for the competitive\r\nprogramming problem:Yuzu is a girl who collecting candies. Originally,\r\nshe has x candies. There are also n enemies numbered with integers from\r\n1 to n. Enemy i has a_i candies.Yuzu is going to determine a permutation\r\nP. A permutation is an array consisting of n distinct integers from 1 to\r\nn in arbitrary order. For example,\r\n{2,3,1,5,4\r\n} is a permutation, but\r\n{1,2,2\r\n} is not a permutation (2 appears twice in the array) and\r\n{1,3,4\r\n} is also not a permutation (because n=3 but there is the number 4 in\r\nthe array).After that, she will do n duels with the enemies with the\r\nfollowing rules: If Yuzu has number of candies than enemy P_i, she wins\r\nthe duel and . Otherwise, she loses the duel and gets nothing. The candy\r\nwhich Yuzu gets will be used in the next duels. Yuzu wants to . How many\r\nvalid permutations P exist?This problem was easy and wasn\u2019t interesting\r\nfor Akari, who is a friend of Aoi. And Akari made the following problem\r\nfrom the above idea:Let\u2019s define f(x) as the number of valid\r\npermutations for the integer x.You are given n, a and p\r\nle n. Let\u2019s call a positive integer x , if the value f(x) is divisible\r\nby p. Find good integers x.Your task is to solve this problem made by\r\nAkari.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 200005;\nint n, p, cnt, mini, a[Maxn], Ans[Maxn];\nint main()\n{\n\tscanf(\"%d%d\", &n, &p);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = 1; i <= n; i++)\n\t\tmini = max(a[i] - i + 1, mini);\n\tint lt = mini - 1, rt = mini + 99999;\n\twhile (lt + 1 <= rt)\n\t{\n\t\tint mid = (lt + rt + 1) >> 1, pnt = 1;\n\t\tlong long ans = 1;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\twhile (pnt <= n && a[pnt] - j + 1 <= mid) pnt++;\n\t\t\t(ans *= pnt - j) %= p;\n\t\t}\n\t\tif (!ans) rt = mid - 1;\n\t\telse lt = mid;\n\t}\n\tprintf(\"%d\\n\", lt - mini + 1);\n\tfor (int i = mini; i <= lt; i++)\n\t\tprintf(\"%d \", i);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "dp",
        "math",
        "number theory",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Asterism  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/79624",
    "editorial": "There are two different solutions to solve this problem.Solution\r\n1:First, find the minimum which has . You can use binary search or\r\ncumulative sum for it.Now, we can say the answers form a segment (or\r\nthere are no answers). Find and proof this.Let\u00e2\u0080\u0099s define as the number of\r\nthe enemies who has than candies.Then, observe the value : once the\r\nvalue exceed , is divisible by because is decremented by (at most) 1 in\r\none step and contains some in this . are always satisfied. Then, once is\r\ndivisible by , is also divisible by , so can be find by using binary\r\nsearch. We can find without binary search by the following\r\nmethod:Solution 2:We can say that .We should find all , such that there\r\nis no , such that .It\u00e2\u0080\u0099s easy to see, that there should be to have and\r\n(they are both divisible by ).Let\u00e2\u0080\u0099s calculate for all necessary values\r\nand after that we can solve the problem by .Anyway, the total complexity\r\nis or .\r\n"
}