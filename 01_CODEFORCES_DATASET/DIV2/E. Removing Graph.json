{
    "link": "https://codeforces.com//contest/1823/problem/E",
    "problemId": "1896871",
    "problem_idx": "E",
    "shortId": "1823E",
    "contest_number": "1823",
    "problem_submissions": {
        "E": [
            203705839,
            203701788,
            203710907,
            203711770,
            203705371,
            203702158,
            203705164,
            203708687,
            203695617,
            203698015,
            203713863,
            203711164,
            203711208
        ],
        "F": [
            203698273,
            203688371,
            203699854,
            203692525,
            203713776,
            203706591,
            203701681,
            203697250,
            203707004,
            203714464,
            203718741,
            203709649,
            204276537,
            203715624
        ],
        "D": [
            203690544,
            203695164,
            203688855,
            203701895,
            203696407,
            203691855,
            203694127,
            203710546,
            203714159,
            203700668,
            203695441,
            203690745,
            203703946,
            203707611,
            203710099,
            203694539,
            203701580,
            203697921,
            203699365
        ],
        "C": [
            203682587,
            203678999,
            203681052,
            203684144,
            203687732,
            203680914,
            203689997,
            203682944,
            203686588,
            203690248,
            203682397,
            203683673,
            203689305,
            203682640,
            203682923,
            203682065,
            203686779,
            203685407,
            203684445,
            203683205
        ],
        "B": [
            203677458,
            203684522,
            203677423,
            203681465,
            203680710,
            203678118,
            203686689,
            203678181,
            203679545,
            203680940,
            203678605,
            203678733,
            203683292,
            203678419,
            203679073,
            203679634,
            203680902,
            203679216,
            203679313
        ],
        "A": [
            203676393,
            203676826,
            203676383,
            203676665,
            203678720,
            203676331,
            203678496,
            203676540,
            203676948,
            203676909,
            203676591,
            203676707,
            203676528,
            203676629,
            203676389,
            203676483,
            203678253,
            203677369,
            203678056
        ]
    },
    "name": "E. Removing Graph",
    "statement": "Alice and Bob are playing a game on a graph. They have an undirected\r\ngraph without self-loops and multiple edges. All vertices of the graph\r\nhave . The graph may consist of several components. Note that if such\r\ngraph has n vertices, it will have exactly n edges.Alice and Bob take\r\nturn. Alice goes first. In each turn, the player can choose k (l\r\nle k\r\nle r; l < r) vertices that form and erase these vertices from the graph,\r\nincluding all incident edges.The player who can’t make a step loses.For\r\nexample, suppose they are playing on the given graph with given l = 2\r\nand r = 3: A valid vertex set for Alice to choose at the first move is\r\none of the following:\r\n{1, 2\r\n}\r\n{1, 3\r\n}\r\n{2, 3\r\n}\r\n{4, 5\r\n}\r\n{4, 6\r\n}\r\n{5, 6\r\n}\r\n{1, 2, 3\r\n}\r\n{4, 5, 6\r\n} Suppose, Alice chooses subgraph\r\n{4, 6\r\n}.Then a valid vertex set for Bob to choose at the first move is one of\r\nthe following:\r\n{1, 2\r\n}\r\n{1, 3\r\n}\r\n{2, 3\r\n}\r\n{1, 2, 3\r\n} Suppose, Bob chooses subgraph\r\n{1, 2, 3\r\n}.Alice can’t make a move, so she loses.You are given a graph of size n\r\nand integers l and r. Who will win if both Alice and Bob play optimally.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005,mod=998244353;\nint add(int x, int y){x+=y; if(x>=mod) x-=mod; return x;}\nint sub(int x, int y){x-=y; if(x<0) x+=mod; return x;}\nint mul(int x, int y){return ((ll)x)*y%mod;}\nint Pow(int x, ll y=mod-2){int res=1; for(; y; x=mul(x,x),y>>=1) if(y&1) res=mul(res,x); return res;}\n\nint n,l,r;\nvector<int> adj[N];\nbool vis[N];\n\nint cnt;\nvoid dfs(int u){\n    cnt++;\n    vis[u]=1;\n    for(auto v: adj[u]) if(!vis[v]) dfs(v);\n}\n\nvoid ldc(){\n    cin >> n >> l >> r;\n    for(int i=0; i<n; ++i){\n        int u,v; cin >> u >> v; u--,v--;\n        adj[u].pb(v),adj[v].pb(u);\n    }\n    int res=0;\n    for(int i=0; i<n; ++i) if(!vis[i]){\n        cnt=0;\n        dfs(i);\n        if(cnt<l+r) res^=cnt/l;\n    }\n    cout << (res?\"Alice\":\"Bob\") << \"\\n\";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    t=1;\n    while(t--) ldc();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "games",
        "graphs",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Removing Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/115465",
    "editorial": "The solution requires knowledge of the Sprague-Grundy theory. Recall\r\nthat means the operation, and is equal to the minimum non-negative\r\nnumber that is not in the set ..The given graph is a set of cycles, and\r\nthe game runs independently in each cycle. If we can calculate nim-value\r\nfor a cycle of each size, then nim-value of the whole game is equal to\r\nof these values.To calculate nim-value for the cycle of length (), we\r\nneed to take of nim-values from all transitions. But since all\r\ntransitions transform a cycle to a chain, then we will calculate\r\nnim-values for chains as well, or .To calculate nim-value for the chain\r\n, we need to consider all possible transitions. We can either cut off\r\nfrom the end of the chain, or from the middle of the chain. In either\r\ncase, we end up with two smaller chains (maybe one of them is empty),\r\nwhich are themselves independent games, so .Implementing this directly\r\nrequires time. A more accurate implementation with recalculations\r\nrequires time. For a complete solution, something needs to be noticed in\r\nnim-values.Consider an example. Let , .\r\nindex0123456789101112131415161718190000111122223333444400001111222233334400\r\non is obviously equal to ; on segment (proof is below); for all : since\r\nyou can always split the chain in two equal chains . This transition\r\nadds nim-value into , thatâs why . is equal to up to : itâs because is\r\nequal to ; for , itâs because for . So, if , then , otherwise . We have\r\nto calculate the sizes of all cycles in the graph and calculate of those\r\nvalues. If it is zero, the winner is Bob, otherwise, winner is\r\nAlice.Letâs prove that on segment : : there are transitions to pairs of\r\nchains where and is any number from . Their nim-value is equal to , so .\r\nis exactly equal to : we can prove that for any pair of chains with\r\nvalue :\r\n",
    "hint": []
}