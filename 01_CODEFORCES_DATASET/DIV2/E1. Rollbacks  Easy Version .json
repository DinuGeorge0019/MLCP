{
    "link": "https://codeforces.com//contest/1858/problem/E1",
    "problemId": "2166170",
    "problem_idx": "E1",
    "shortId": "1858E1",
    "contest_number": "1858",
    "problem_submissions": {
        "E1": [
            218971675,
            218948691,
            218950036,
            218981081,
            218981577,
            218982148,
            219044099,
            218987081,
            218959071,
            219043079,
            218997113,
            218975893,
            218978028,
            218974432,
            218978584,
            218984712,
            218984251,
            219051896,
            218984058,
            218985452,
            218989668,
            218998871,
            218971815
        ],
        "E2": [
            218971226,
            218946559,
            218949779,
            219003260,
            218981396,
            218982111,
            218983780,
            219043918,
            218987338,
            219043124,
            218997698,
            218975689,
            218977856,
            219035037,
            219051939,
            218998573
        ],
        "D": [
            218958822,
            218970595,
            218957970,
            218958903,
            218949856,
            218961365,
            218967040,
            218972943,
            219043010,
            218960726,
            218998607,
            218989664,
            218961840,
            218965618,
            218966574,
            218969464,
            218974328,
            218972414,
            218969139,
            218981714,
            218991387
        ],
        "C": [
            218944984,
            218929618,
            218962105,
            218928296,
            218926980,
            218941771,
            218950307,
            218944949,
            219042947,
            218946392,
            218934108,
            218941439,
            218951937,
            218933349,
            218935592,
            218942151,
            218948522,
            218948262,
            218943920,
            218947281,
            218951547
        ],
        "B": [
            218935374,
            218982876,
            218965626,
            218941114,
            218939372,
            218933262,
            218946217,
            218938100,
            219042924,
            218940019,
            218950811,
            218937233,
            218946328,
            218943500,
            218950259,
            218936903,
            218940772,
            218941478,
            218938583,
            218962280,
            218941262
        ],
        "A": [
            218918372,
            218920879,
            218959798,
            218918668,
            218919313,
            218918787,
            218926715,
            218920787,
            219043052,
            219042898,
            218921173,
            218920067,
            218918574,
            218919674,
            218918423,
            218919655,
            218919188,
            218922439,
            218922802,
            218918900,
            218943440,
            218921894
        ]
    },
    "name": "E1. Rollbacks  Easy Version ",
    "statement": "You have an array a, which is initially empty. You need to process\r\nqueries of the following types: x add the integer x to the end of the\r\narray a. k remove the last k numbers from the array a. roll back the\r\nlast active change (i.e., make the array a the way it was before the\r\nchange). In this problem, only queries of the first two types ( and )\r\nare considered as changes. find the number of distinct numbers in the\r\narray a.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define debug(...)\n#endif\n\nconst int N = 1e6 + 6, A = 1e6, L = 20;\nconst int N_ = N * (L + 1);\n\nint tt = 0;\nint lc[N_], rc[N_];\n\nint copy(int k) {\n  int i = ++tt;\n  lc[i] = lc[k];\n  rc[i] = rc[k];\n  return i;\n}\nvoid upd(int &k, int l, int r, int i) {\n  k = copy(k);\n  if (l < r) {\n    int m = (l + r) / 2;\n    if (i <= m) {\n      upd(lc[k], l, m, i);\n    } else {\n      upd(rc[k], m + 1, r, i);\n    }\n  }\n}\nbool qry(int k, int l, int r, int i) {\n  if (!k) return 0;\n  if (l == r) return 1;\n  int m = (l + r) / 2;\n  return i <= m ? qry(lc[k], l, m, i) : qry(rc[k], m + 1, r, i);\n}\n\nint ver[N], sum[N];\nint pp[L][N], par[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.exceptions(cin.failbit);\n  cin.tie(NULL);\n  int q;\n  cin >> q;\n  for (int h = 1; h <= q; h++) {\n    char c;\n    cin >> c;\n    if (c == '+') {\n      int x;\n      cin >> x, x--;\n      par[h] = h - 1;\n      ver[h] = ver[h - 1];\n      sum[h] = sum[h - 1];\n      if (!qry(ver[h], 0, A - 1, x)) {\n        upd(ver[h], 0, A - 1, x);\n        sum[h]++;\n      }\n      pp[0][h] = h - 1;\n      for (int l = 1; l < L; l++) {\n        pp[l][h] = pp[l - 1][pp[l - 1][h]];\n      }\n    } else if (c == '-') {\n      int k;\n      cin >> k;\n      par[h] = h - 1;\n      int u = h - 1;\n      for (int l = 0; l < L; l++)\n        if (k >> l & 1) u = pp[l][u];\n      ver[h] = ver[u];\n      sum[h] = sum[u];\n      for (int l = 0; l < L; l++) pp[l][h] = pp[l][u];\n    } else if (c == '!') {\n      int p = par[h - 1];\n      par[h] = par[p];\n      ver[h] = ver[p];\n      sum[h] = sum[p];\n      for (int l = 0; l < L; l++) pp[l][h] = pp[l][p];\n    } else {\n      par[h] = par[h - 1];\n      ver[h] = ver[h - 1];\n      sum[h] = sum[h - 1];\n      for (int l = 0; l < L; l++) pp[l][h] = pp[l][h - 1];\n      cout << sum[h] << '\\n';\n    }\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Rollbacks  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/119398",
    "editorial": "First, let's learn how to solve the problem without rollbacks. Let b\n be an array of the same length as a\n, where bi=1\n if i\n is the minimum position at which the number ai\n is in the array a\n, and bi=0\n otherwise. Then the number of different numbers in the array a\n is equal to the sum of all the elements of the array b\n.\n\nThe b\n array can be maintained using a Fenwick tree, a segment tree, or any other data structure that supports point updates and range sum queries. The author's solution uses the Fenwick tree.\n\nLet's use the method that is often used when implementing a stack or a deque: we create a large array A\n and at each moment we store the index of the last \"existing\" element r\n (this is just the size of the array a\n at this moment). The array a\n itself will be a prefix of A\n, that is, ai=Ai\n for i?len(a)\n. Also, for each value val\n we maintain std::set of indexes on which the val\n value is located in the A\n array (in A\n, not in a\n).\n\nThen for the operation of removing k\n elements from the end of the array a\n, it is enough to reduce the value of the index r\n by k\n. This operation works in O(1)\n.\n\nWhen adding one element x\n to the end of the array, we need to check if it has been encountered before, and change one element in the Fenwick tree accordingly. This can be done in O(logq)\n using std::set for the corresponding value. You also need to increase r\n by 1, assign Ar=x\n after that, and update the corresponding std::set. This operation works for O(logq)\n.\n\nIn order to find the number of different numbers in a\n, we need to find the sum in the Fenwick tree on the prefix of length r\n in the array b\n. This operation works in O(logq)\n.\n\nNow, we need to learn how to roll back operations. Note that we perform the deletion operation in O(1)\n, and the addition operation in O(logq)\n, so we can roll back these operations with the same asymptotics. We can just store a stack of all changes, and remember everything that we changed during the operations.\n\nThe final asymptotics is O(qlogq)\n.",
    "hint": []
}