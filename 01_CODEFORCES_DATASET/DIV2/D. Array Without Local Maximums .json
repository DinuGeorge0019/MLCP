{
    "link": "https://codeforces.com//contest/1068/problem/D",
    "problemId": "242824",
    "problem_idx": "D",
    "shortId": "1068D",
    "contest_number": "1068",
    "problem_submissions": {
        "C": [
            44804609,
            44787225,
            44783973,
            44791722,
            44788969,
            44795395,
            44788534,
            44796839,
            44794223,
            44802675,
            44793149,
            44791347,
            44791718,
            44799632,
            45919927,
            44995670,
            44792807,
            44787914,
            45131859,
            45131819,
            44809435,
            44799658
        ],
        "E": [
            44798389,
            44796278,
            44796319,
            44792474,
            44806152,
            44807222,
            44805314,
            44809246,
            44805901,
            44806685,
            44806349,
            44805897,
            44809417,
            44803952,
            44807694,
            44809008,
            44809472,
            44805216,
            44807724
        ],
        "D": [
            44791215,
            44806495,
            44806429,
            44801917,
            44799230,
            44796871,
            44798866,
            44798712,
            44802512,
            44801974,
            44797087,
            44801487,
            44802268,
            44817888,
            44808939,
            44797764,
            44805243,
            44807172,
            44799620,
            44790945
        ],
        "B": [
            44783822,
            44782929,
            44781389,
            44784465,
            44783047,
            44783627,
            44784192,
            44786901,
            44784629,
            44784410,
            44789258,
            44784311,
            44783736,
            44784363,
            44781413,
            44782490,
            44787464,
            44794535
        ],
        "A": [
            44781781,
            44781589,
            44813303,
            44781338,
            44782084,
            44782565,
            44782183,
            44785669,
            44781504,
            44803190,
            44787315,
            44781691,
            44781558,
            44782973,
            44787832,
            44781454,
            44783541,
            44813482
        ],
        "F": [
            44823303,
            44827702,
            44826052
        ]
    },
    "name": "D. Array Without Local Maximums ",
    "statement": "Ivan unexpectedly saw a present from one of his previous birthdays. It\r\nis array of n numbers from 1 to 200. Array is old and some numbers are\r\nhard to read. Ivan remembers that for all elements at least one of its\r\nneighbours ls not less than it, more formally:a_{1}\r\nle a_{2},a_{n}\r\nle a_{n-1} anda_{i}\r\nle max(a_{i-1},\r\n,\r\n, a_{i+1}) for all i from 2 to n-1.Ivan does not remember the array and\r\nasks to find the number of ways to restore it. Restored elements also\r\nshould be integers from 1 to 200. Since the number of ways can be big,\r\nprint it modulo 998244353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\nconst int mod = 998244353;\n\nvoid add(int &x,int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\n\nint n;\nint a[N];\nint f[N][205][2];\nint g[N][205][2];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\tif (a[1] == -1) {\n\t\tfor (int i = 1; i <= 200; ++i) {\n\t\t\tf[1][i][0] = 1;\n\t\t\tg[1][i][0] = g[1][i - 1][0];\n\t\t\tadd(g[1][i][0], f[1][i][0]);\n\t\t}\n\t}\n\telse {\n\t\tf[1][a[1]][0] = 1;\n\t\tfor (int i = 1; i <= 200; ++i) {\n\t\t\tif (i >= a[1]) g[1][i][0] = 1;\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tfor (int j = 1; j <= 200; ++j) {\n\t\t\t// don't sure\n\t\t\tif (a[i] != -1 && a[i] != j) continue;\n\t\t\tadd(f[i][j][0], g[i - 1][j - 1][0]);\n\t\t\tadd(f[i][j][0], g[i - 1][j - 1][1]);\n\t\t\t// sure\n\t\t\tadd(f[i][j][1], g[i - 1][200][1]);\n\t\t\tadd(f[i][j][1], mod - g[i - 1][j][1]);\n\t\t\tadd(f[i][j][1], f[i - 1][j][0]);\n\t\t\tadd(f[i][j][1], f[i - 1][j][1]);\n\t\t}\n\t\tfor (int j = 1; j <= 200; ++j) {\n\t\t\tg[i][j][0] = g[i][j - 1][0];\n\t\t\tg[i][j][1] = g[i][j - 1][1];\n\t\t\tadd(g[i][j][0], f[i][j][0]);\n\t\t\tadd(g[i][j][1], f[i][j][1]);\n\t\t}\n\t}\n\tcout << g[n][200][1] << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Array Without Local Maximums .json",
    "editorial_link": "https://codeforces.com/blog/entry/62688",
    "editorial": "Let's find solution with complexity O(n?a2)\n. We can count dp[prefix][a][flag]\n \u0097 quantity of ways to restore element from 1\n to pref\n with last element equalls to a\n, flag=0\n means that previous element is less then the last or last element is first, flag=1\n \u0097 the opposite. So dp[pref][a][0]=?a?1i=1(dp[pref?1][i][1]+dp[pref?1][i][0])\n, dp[pref][a][1]=dp[pref?1][a][0]+?200i=adp[pref?1][i][1]\n.\n\nNow let's count prefix_sums[a][flag]=?ai=1dp[pref][i][flag]\n on each prefix before counting all dp[pref]\n, so we can recalculate dp in O(1) time."
}