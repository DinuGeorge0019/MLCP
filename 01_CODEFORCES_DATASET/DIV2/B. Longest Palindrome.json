{
    "link": "https://codeforces.com//contest/1304/problem/B",
    "problemId": "540878",
    "problem_idx": "B",
    "shortId": "1304B",
    "contest_number": "1304",
    "problem_submissions": {
        "F2": [
            71153662,
            71152758,
            71152225,
            71157272,
            71159942,
            71160337,
            71152268,
            71164565,
            71154293,
            71154692,
            71162717,
            71159530,
            71162560,
            71166676,
            71162579,
            71158531,
            71165317,
            71164377,
            71163973
        ],
        "F1": [
            71153447,
            71152867,
            71152180,
            71151661,
            71153091,
            71154085,
            71149583,
            71154537,
            71154276,
            71154806,
            71156318,
            71151191,
            71154828,
            71149041,
            71160757,
            71162740,
            71158430,
            71158819,
            71164218,
            71159683
        ],
        "A": [
            71141804,
            71123780,
            71124247,
            71124384,
            71123709,
            71123734,
            71133014,
            71123605,
            71123682,
            71125835,
            71124122,
            71125469,
            71123778,
            71125797,
            71123883,
            71124957,
            71124272,
            71124584,
            71125887
        ],
        "B": [
            71141077,
            71127745,
            71130904,
            71129813,
            71129002,
            71129323,
            71131933,
            71128951,
            71128799,
            71129490,
            71131971,
            71130601,
            71128231,
            71131633,
            71131054,
            71131655,
            71131218,
            71131770,
            71130665
        ],
        "C": [
            71139292,
            71131382,
            71132670,
            71132117,
            71132267,
            71132849,
            71127878,
            71132933,
            71133726,
            71136633,
            71134870,
            71133707,
            71131661,
            71135936,
            71133295,
            71134276,
            71135200,
            71134880,
            71134692
        ],
        "D": [
            71135174,
            71139070,
            71140467,
            71140425,
            71138874,
            71140258,
            71140794,
            71137521,
            71136980,
            71141949,
            71140004,
            71141241,
            71141696,
            71140892,
            71143691,
            71147524,
            71140481,
            71142776,
            71142040
        ],
        "E": [
            71129417,
            71143322,
            71144172,
            71144650,
            71144907,
            71145653,
            71155565,
            71142523,
            71145871,
            71145649,
            71146288,
            71152807,
            71148538,
            71135583,
            71146697,
            71149801,
            71151693,
            71149896,
            71147231,
            71153923
        ]
    },
    "name": "B. Longest Palindrome",
    "statement": "Returning back to problem solving, Gildong is now studying about\r\npalindromes. He learned that a is a string that is the same as its\r\nreverse. For example, strings \"\", \"\", \"\", and \"\" are palindromes, while\r\nstrings \"\", \"\", and \"\" are not. Gildong loves this concept so much, so\r\nhe wants to play with it. He has n strings of equal length m. He wants\r\nto discard some of the strings (possibly none or all) and reorder the\r\nremaining strings so that the concatenation becomes a palindrome. He\r\nalso wants the palindrome to be as long as possible. Please help him\r\nfind one.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\n#include<vector>\nusing namespace std;\n\nstring arr[1003]; int N , M; bool vis[1003];\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 1 ; i <= N ; ++i) cin >> arr[i];\n\tvector < string > pot1 , pot2; string mid;\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\tstring tmp = arr[i]; reverse(tmp.begin() , tmp.end());\n\t\tfor(int j = i + 1 ; j <= N ; ++j)\n\t\t\tif(!vis[j] && arr[j] == tmp){\n\t\t\t\tvis[i] = vis[j] = 1; pot1.push_back(arr[i]); pot2.push_back(arr[j]);\n\t\t\t}\n\t\tif(!vis[i] && tmp == arr[i] && mid.empty()) mid = arr[i];\n\t}\n\tcout << (pot1.size() + (bool)mid.size() + pot2.size()) * M << endl;\n\tfor(auto t : pot1) cout << t;\n\tcout << mid;\n\treverse(pot2.begin() , pot2.end());\n\tfor(auto t : pot2) cout << t;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Longest Palindrome.json",
    "editorial_link": "https://codeforces.com//blog/entry/73934",
    "editorial": "Letâs define as the reversed string of a string . There are two cases\r\nwhen we choose strings to make a palindrome string : If is even, for\r\nevery integer (), . if is odd, must be palindrome. Also for every\r\ninteger (), . In either case we want to find as many pairs of strings as\r\npossible such that one is the reverse of the other. It is also clear\r\nthat if is a palindrome string then . We cannot make a pair of T and\r\nrev(T) because all strings in the input are distinct.Therefore, for each\r\nstring we need to find if there is another string that is its reverse.\r\nIf there exists one, put them on the left / right end respectively. If\r\nthere are one or more strings that are palindrome themselves, pick any\r\none of them and put it in the middle.Time complexity: if we implement it\r\nnaively. is possible if we use a data structure that provides search\r\nsuch as std::set in C++.\r\n",
    "hint": []
}