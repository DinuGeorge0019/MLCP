{
    "link": "https://codeforces.com//contest/1131/problem/F",
    "problemId": "302313",
    "problem_idx": "F",
    "shortId": "1131F",
    "contest_number": "1131",
    "problem_submissions": {
        "G": [
            50392574,
            50483553,
            50483191,
            50597351
        ],
        "E": [
            50370230,
            50377398,
            50376874,
            50374805,
            50370023,
            50374639,
            50376085,
            50370141,
            59337133,
            50372624,
            50376988,
            50380444,
            51393637,
            50379092,
            50379324,
            50375235,
            50378370,
            50376960,
            50378218,
            50375618,
            50380739,
            50377794
        ],
        "D": [
            50363533,
            50363627,
            50365255,
            50374692,
            50360365,
            50367830,
            50371553,
            50364690,
            59336364,
            50377671,
            50371391,
            50369645,
            51393629,
            50371580,
            50368694,
            50364122,
            50370641,
            50367474,
            50370633,
            50364697,
            50370324,
            50391827,
            50367431
        ],
        "F": [
            50359710,
            50366576,
            50362359,
            50363609,
            50372028,
            50364108,
            54391189,
            54391158,
            54391141,
            50775614,
            50775596,
            50775586,
            50775566,
            50775556,
            50366322,
            50374409,
            59338739,
            50364318,
            50366547,
            50364869,
            51393655,
            50365763,
            50362358,
            50366172,
            50366229,
            50370184,
            50365915,
            50363686,
            50365490,
            50370524
        ],
        "C": [
            50357039,
            50359567,
            50360582,
            50355123,
            50364439,
            50361693,
            50361183,
            50360745,
            50361372,
            50363542,
            50360374,
            50363293,
            50355730,
            50368491,
            50363309,
            50362385,
            50362421,
            50365348,
            50362731,
            50360623
        ],
        "B": [
            50355578,
            50356862,
            50357573,
            50357717,
            50364015,
            50361039,
            50356264,
            50358549,
            50359269,
            50359561,
            50357291,
            50358021,
            50372318,
            50359218,
            50357829,
            50359757,
            50364553,
            50364635,
            50358492,
            50357639
        ],
        "A": [
            50354897,
            50355112,
            50355078,
            50360224,
            50354946,
            50354851,
            50362936,
            50355762,
            50355563,
            50355186,
            50355036,
            50355259,
            50369979,
            50355032,
            50355231,
            50355565,
            50355478,
            50359515,
            50355346,
            50355260
        ]
    },
    "name": "F. Asya And Kittens",
    "statement": "Asya loves animals very much. Recently, she purchased n kittens,\r\nenumerated them from 1 and n and then put them into the cage. The cage\r\nconsists of one row of n cells, enumerated with integers from 1 to n\r\nfrom left to right. Adjacent cells had a partially transparent partition\r\nwall between them, hence there were n - 1 partitions originally.\r\nInitially, each cell contained exactly one kitten with some\r\nnumber.Observing the kittens, Asya noticed, that they are very friendly\r\nand often a pair of kittens in neighboring cells wants to play together.\r\nSo Asya started to remove partitions between neighboring cells. In\r\nparticular, on the day i, Asya: Noticed, that the kittens x_i and y_i,\r\nlocated in neighboring cells want to play together. Removed the\r\npartition between these two cells, efficiently creating a single cell,\r\nhaving all kittens from two original cells. Since Asya has never putted\r\npartitions back, after n - 1 days the cage contained a single cell,\r\nhaving all kittens.For every day, Asya remembers numbers of kittens x_i\r\nand y_i, who wanted to play together, however she doesn\u2019t remember how\r\nshe placed kittens in the cage in the beginning. Please help her and\r\nfind any possible initial arrangement of the kittens into n cells.\r\n",
    "solutions": [
        "/**************************************************************\n    Problem: ????\n    User: Big_Red_Dates\n    Language: GNU_C++11\n    Result: Accepted\n    Time:0 ms\n    Memory:0 kb\n    length:0 kb\n    score: inf\n****************************************************************/\n//CLOCKS_PER_SEC\nusing namespace std;\n#include<bitset>\n#include<deque>\n#include<stdint.h>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<ctime>\n#include<map>\n#define sqr(x) (x)*(x)\n#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,\"r\",stdin);\n#define fpo(x) freopen(x,\"w\",stdout);\n#define fprio fpi(\"in.txt\");fpo(\"out.txt\");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void readc(char &x){char c;while ((c=getchar())==' ');x=c;}\ninline void writes(string s){puts(s.c_str());}\ninline void writeln(){writes(\"\");}\ninline void writei(int x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\ninline void writell(ll x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\n/*\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(5)\n#pragma GCC optimize(6)\n#pragma GCC optimize(7)\n#pragma GCC optimize(8)\n#pragma GCC optimize(9)\n*/\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)\n#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define itr iterator\n#define forcsc(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define NO {cout<<\"NO\";return 0;}\n#define YES {cout<<\"YES\";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 0x3bbbbbbb\n#define lnf 0x1bbbbbbbbbbbbbbbll\n#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n/*************************************************/\nint n,m,i,j,k,a[150005],l[150005],r[150005],fl[150005],fr[150005],x,y;\nint gfl(int x){if (fl[x]==x) return x;return fl[x]=gfl(fl[x]);}\nint gfr(int x){if (fr[x]==x) return x;return fr[x]=gfr(fr[x]);}\nint main()\n{\n\tread(n);\n\trep(i,n)\n\t{\n\t\tfl[i]=fr[i]=l[i]=r[i]=i;\n\t}\n\trep(i,n-1)\n\t{\n\t\tread(x);read(y);\n\t\tx=gfr(x);y=gfl(y);\n\t\tr[x]=y;l[y]=x;\n\t\tfr[x]=y;fl[y]=x; \n\t}\n\tx=gfl(1);\n\trep(i,n)\n\t{\n\t\tprintf(\"%d \",x);\n\t\tx=r[x];\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dsu"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Asya And Kittens.json",
    "editorial_link": "https://codeforces.com//blog/entry/65487",
    "editorial": "In this problem we are given a disjoint set union process with steps,\r\nmerging initial 1-element sets into one -element set. We have to put\r\nelements into a linear array of cells, so that the cells to be joined at\r\neach step of the process were immediate neighbours (i.e. not separated\r\nby other cells).This problem can be solved in or in (where is the\r\ninverse Ackermann function) via standard disjoint-set data structure,\r\nadditionally storing lists of elements in each set. The simplest\r\nsolution is based on a set-size version of rank heuristic: storing\r\nmapping from item to id (representative) of its current set, and the\r\ninverse mapping from set to the list of its elements when we have to\r\nmerge two sets and , we make the smaller set part of the larger set and\r\nupdate mappings, assigning new set ids for elements in and concatenating\r\nthe lists (can be done in or in ) This gives us : element can not change\r\nits set more than times, because the change leads to (at least) doubling\r\nof the element\u00e2\u0080\u0099s set size.In order to get , we have to use the disjoint\r\nset structure with both path compression and rank heuristics, plus\r\nconcatenation of lists should be done in .\r\n"
}