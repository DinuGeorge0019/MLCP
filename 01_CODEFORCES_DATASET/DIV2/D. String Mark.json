{"link": "https://codeforces.com//contest/895/problem/D", "problemId": "136057", "problem_idx": "D", "shortId": "895D", "contest_number": "895", "problem_submissions": {"B": [32688468, 32699862, 32678233, 32693050, 32686509, 32685665, 32686167, 32677480, 32679593, 32679598, 32678660, 32679991, 32682934, 32679855, 32677931, 32686786, 32693881, 32679230, 32679053], "A": [32686687, 32676253, 32692247, 32687355, 32675778, 32681798, 32679509, 32675934, 32676147, 32676898, 32676014, 32676714, 32676536, 32676059, 32675756, 32675820, 32681275, 32675999, 32675924, 32676186], "E": [32685470, 32693933, 32688720, 32686566, 32794358, 32794273, 32732458, 32681330, 34740059, 32691274, 32699769, 32720207, 32720179, 32720088, 32698361, 32698258, 32698305], "D": [32681888, 32681308, 32690694, 32686236, 32685937, 32689479, 32691053, 32781770, 32686848, 32691934, 32691134, 32690110, 32688741, 32690589, 32685060, 32692013], "C": [32678196, 32689081, 32683426, 32681542, 32680606, 32690938, 32678815, 32682493, 32687456, 32690603, 32685722, 32686946, 32686892, 32689317, 32680568, 32678934, 32808410, 32685463, 32687263, 32681038]}, "name": "D. String Mark", "statement": "At the Byteland State University marks are strings of the same length.\r\nMark is considered better than if string is lexicographically smaller\r\nthan .Recently at the BSU was an important test work on which Vasya\r\nrecived the mark . It is very hard for the teacher to remember the exact\r\nmark of every student, but he knows the mark , such that every student\r\nrecieved mark strictly smaller than .Vasya isn\u2019t satisfied with his mark\r\nso he decided to improve it. He can swap characters in the string\r\ncorresponding to his mark as many times as he like. Now he want to know\r\nonly the number of different ways to improve his mark so that his\r\nteacher didn\u2019t notice something suspicious.More formally: you are given\r\ntwo strings , of the same length and you need to figure out the number\r\nof different strings such that:1) can be obtained from by swapping some\r\ncharacters, in other words is a permutation of .2) String is\r\nlexicographically smaller than .3) String is lexicographically smaller\r\nthan .For two strings and of the same length it is true that is\r\nlexicographically smaller than if there exists such , that .Since the\r\nanswer can be very large, you need to find answer modulo .\r\n", "solutions": ["#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 1000010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,ans;\n\nchar A[maxn],B[maxn];\n\nint fac[maxn],inv[maxn],has[30],pre[30],suf[30];\n\n\nvoid Work(){\n\tREP(j,1,n){\n\t\tpre[0]=1;\n\t\tREP(i,1,26)pre[i]=1ll*pre[i-1]*inv[has[i]]%mod;\n\t\tsuf[27]=1;\n\t\tRREP(i,26,1)suf[i]=1ll*suf[i+1]*inv[has[i]]%mod;\n\t\tREP(i,1,B[j]-'a')if(has[i]){\n\t\t\tans=(1ll*fac[n-j]*pre[i-1]%mod*suf[i+1]%mod*inv[has[i]-1]+ans)%mod;\n\t\t}\n\t\tif(!has[B[j]-'a'+1])break;\n\t\thas[B[j]-'a'+1]--;\n\t}\n\tREP(i,1,26)has[i]=0;\n\tREP(i,1,n)has[A[i]-'a'+1]++;\n\tREP(j,1,n){\n\t\tpre[0]=1;\n\t\tREP(i,1,26)pre[i]=1ll*pre[i-1]*inv[has[i]]%mod;\n\t\tsuf[27]=1;\n\t\tRREP(i,26,1)suf[i]=1ll*suf[i+1]*inv[has[i]]%mod;\n\t\tREP(i,1,A[j]-'a')if(has[i]){\n\t\t\tans=(ans-1ll*fac[n-j]*pre[i-1]%mod*suf[i+1]%mod*inv[has[i]-1]%mod+mod)%mod;\n\t\t}\n\t\thas[A[j]-'a'+1]--;\n\t}\n\tans=(ans-1+mod)%mod;\n\tiout(ans);\n}\n\nvoid Init(){\n\tscanf(\"%s%s\",A+1,B+1);\n\tn=strlen(A+1);\n\tREP(i,1,n)has[A[i]-'a'+1]++;\n\tfac[0]=1;REP(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n\tREP(i,0,n)inv[i]=fexp(fac[i],mod-2);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["combinatorics", "math", "strings"], "dificulty": "2100", "interactive": false}