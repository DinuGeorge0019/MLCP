{
    "link": "https://codeforces.com//contest/1991/problem/E",
    "problemId": "2781505",
    "problem_idx": "E",
    "shortId": "1991E",
    "contest_number": "1991",
    "problem_submissions": {
        "H": [
            273210632,
            273212730,
            273219908,
            273194851,
            273200656,
            273213505,
            273204889,
            273220591,
            273225451,
            273220804,
            273226512,
            273222266,
            273229115,
            278405080,
            273216843
        ],
        "G": [
            273180456,
            273179521,
            273174064,
            273209283,
            273179708,
            273185549,
            273216085,
            273188851,
            273191410,
            273193985,
            273189153,
            273194518,
            273197531,
            273190195,
            273195818,
            273188177,
            273190908,
            273195464,
            273198241
        ],
        "F": [
            273160781,
            273160990,
            273158593,
            273158141,
            273171320,
            273168196,
            273159727,
            273170129,
            273173513,
            273170857,
            273165439,
            273182207,
            273174869,
            273166190,
            273163947,
            273173198,
            273175470,
            273163587,
            273174682,
            273170108
        ],
        "E": [
            273150868,
            273153734,
            273152235,
            273150823,
            273156934,
            273151786,
            273150935,
            273157824,
            273151366,
            273154414,
            273174335,
            273161395,
            273159133,
            273156803,
            273161464,
            273162124,
            273154749,
            273158567,
            273155964
        ],
        "D": [
            273143134,
            273144551,
            273142645,
            273141713,
            273147820,
            273143829,
            273141673,
            273145581,
            273156995,
            273145729,
            273149790,
            273146459,
            273144249,
            273145676,
            273154684,
            273150687,
            273147840,
            273144991,
            273148567
        ],
        "C": [
            273139495,
            273142387,
            273139319,
            273241170,
            273142853,
            273141897,
            273140491,
            273138783,
            273141460,
            273141958,
            273141853,
            273144830,
            273141321,
            273143714,
            273141051,
            273142758,
            273145128,
            273137630,
            273141184,
            273143400
        ],
        "B": [
            273133106,
            273134906,
            273133339,
            273134525,
            273138116,
            273135569,
            273133092,
            273135379,
            273136693,
            273135755,
            273136343,
            273135805,
            273132915,
            273135366,
            273136849,
            273139913,
            273132449,
            273135138,
            273136549
        ],
        "A": [
            273130858,
            273132065,
            273130939,
            273130875,
            273131982,
            273132539,
            273130929,
            273131106,
            273131228,
            273130992,
            273131052,
            273131178,
            273130862,
            273131382,
            273131308,
            273132778,
            273130871,
            273130965,
            273131362
        ],
        "I": [
            273238749,
            273429741
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/132014",
    "editorial": "If the graph is not bipartite, Alice will win. If the graph is bipartite, Bob will win.\n\nIf the graph is not bipartite, Alice can always choose colors 1\n and 2\n. According to the definition of a non-bipartite graph, Bob cannot color the graph with two colors without having two adjacent vertices of the same color.\n\nIf the graph is bipartite, it can be divided into two parts, Part 1\n and Part 2\n, with no edges within each part. If the colors chosen by Alice include color 1\n, Bob can paint vertices in part 1\n with color 1\n. If the colors chosen by Alice include color 2\n, Bob can paint vertices in part 2\n with color 2\n. Once one part is completely painted, Bob can use color 3\n or continue using the original color of that part to paint the remaining vertices, ensuring no two adjacent vertices have the same color. In this way, Bob will win.",
    "name": "E. Coloring Game",
    "statement": "Consider an undirected connected graph consisting of n vertices and m\r\nedges. Each vertex can be colored with one of three colors: 1, 2, or 3.\r\nInitially, all vertices are uncolored.Alice and Bob are playing a game\r\nconsisting of n rounds. In each round, the following two-step process\r\nhappens: Alice chooses two colors. Bob chooses an uncolored vertex and\r\ncolors it with one of the two colors chosen by Alice. Alice wins if\r\nthere exists an edge connecting two vertices of the same color.\r\nOtherwise, Bob wins.You are given the graph. Your task is to decide\r\nwhich player you wish to play as and win the game.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 28.07.2024 10:48:58**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0class dsu { public:  vector<int> p;  int n;\u00a0  dsu(int _n) : n(_n) {    p.resize(n);    iota(p.begin(), p.end(), 0);  }\u00a0  inline int get(int x) {    return (x == p[x] ? x : (p[x] = get(p[x])));  }\u00a0  inline bool unite(int x, int y) {    x = get(x);    y = get(y);    if (x != y) {      p[x] = y;      return true;    }    return false;  }};\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int n, m;    cin >> n >> m;    dsu d(2 * n);    for (int i = 0; i < m; i++) {      int a, b;      cin >> a >> b;      --a; --b;      d.unite(a, b + n);      d.unite(b, a + n);    }    bool non = false;    for (int i = 0; i < n; i++) {      if (d.get(i) == d.get(i + n)) {        non = true;        break;      }    }    if (non) {      cout << \"Alice\" << endl;      for (int i = 0; i < n; i++) {        cout << \"1 2\" << endl;        int a, b;        cin >> a >> b;      }    } else {      cout << \"Bob\" << endl;      vector<int> a, b;      for (int i = 0; i < n; i++) {        if (d.get(i) == d.get(0)) {          a.push_back(i);        } else {          b.push_back(i);        }      }      for (int it = 0; it < n; it++) {        int x, y;        cin >> x >> y;        if (x > y) {          swap(x, y);        }        int r = 6 - x - y;        if (a.empty()) {          cout << b.back() + 1 << \" \" << (r == 2 ? 3 : 2) << endl;          b.pop_back();          continue;        }        if (b.empty()) {          cout << a.back() + 1 << \" \" << (r == 1 ? 3 : 1) << endl;          a.pop_back();          continue;        }        if (r == 1) {          cout << b.back() + 1 << \" \" << 2 << endl;          b.pop_back();        } else {          cout << a.back() + 1 << \" \" << 1 << endl;          a.pop_back();        }      }    }  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "games",
        "graphs",
        "greedy",
        "interactive"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Coloring Game.json"
}