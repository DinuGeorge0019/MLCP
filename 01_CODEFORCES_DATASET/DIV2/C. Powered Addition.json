{
    "link": "https://codeforces.com//contest/1339/problem/C",
    "problemId": "590528",
    "problem_idx": "C",
    "shortId": "1339C",
    "contest_number": "1339",
    "problem_submissions": {
        "E": [
            76376836,
            76387473,
            76384887,
            76379831,
            76388585,
            76390578,
            76396660,
            76387000,
            76387243,
            76398417,
            76396262,
            76393298,
            76399344,
            76397428,
            76394900,
            76392890,
            76397397
        ],
        "D": [
            76366206,
            76361616,
            76361489,
            76362609,
            76370115,
            76368889,
            76363614,
            76372647,
            76369118,
            76367884,
            76374852,
            76373935,
            76373663,
            76374136,
            76369373,
            76371535,
            76374633
        ],
        "C": [
            76348562,
            76344606,
            76350287,
            76349364,
            76346531,
            76351575,
            76343954,
            76360371,
            76355938,
            76349819,
            76351779,
            76350689,
            76348249,
            76354286,
            76352877,
            76346445,
            76346553
        ],
        "B": [
            76343501,
            76338131,
            76337793,
            76336924,
            76339593,
            76343198,
            76337765,
            76339336,
            76344314,
            76341691,
            76343582,
            76339210,
            76341443,
            76348496,
            76344625,
            76338360,
            76339452
        ],
        "A": [
            76339423,
            76333974,
            76334483,
            76333757,
            76334414,
            76335125,
            76333704,
            76335982,
            76335394,
            76336250,
            76335663,
            76334669,
            76335712,
            76339115,
            76336582,
            76353895,
            76335154
        ]
    },
    "name": "C. Powered Addition",
    "statement": "You have an array a of length n. For every positive integer x you are\r\ngoing to perform the following operation during the x-th second: Select\r\nsome distinct indices i_{1}, i_{2},\r\nldots, i_{k} which are between 1 and n inclusive, and add 2^{x-1} to\r\neach corresponding position of a. Formally, a_{i_{j}} := a_{i_{j}} +\r\n2^{x-1} for j = 1, 2,\r\nldots, k. You have to make a nondecreasing as fast as possible. Find the\r\nsmallest number T such that you can make the array nondecreasing after\r\nat most T seconds.Array a is nondecreasing if and only if a_{1}\r\nle a_{2}\r\nle\r\nldots\r\nle a_{n}.You have to answer t independent test cases.\r\n",
    "solutions": [
        "﻿#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct Problem {\n\n\tvoid Loop() {\n\t\tUL N; cin >> N;\n\t\tvector<LL> A(N); rep(i, N) cin >> A[i];\n\t\tLL ans = 0;\n\t\tLL buf = -10000000000;\n\t\trep(i, N) {\n\t\t\tif (A[i] >= buf) {\n\t\t\t\tbuf = A[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = max(ans, buf - A[i]);\n\t\t\t}\n\t\t}\n\t\tUL t = 0;\n\t\twhile ((1ull << t) <= ans) t++;\n\t\tcout << t << endl;\n\t}\n\n\tvoid Solve() {\n\t\tUL Q; cin >> Q;\n\t\trep(i, Q) {\n\t\t\tLoop();\n\t\t}\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Powered Addition.json",
    "editorial_link": "https://codeforces.com//blog/entry/75913",
    "editorial": "First, let's define b\n as ideal destination of a\n, when we used operations.\n\nObservation 1. Whatever you select any b\n, there is only one way to make it, because there is no more than single way to make specific amount of addition. That means we just have to select optimal destination of a\n.\n\nFor example, if you want to make a1\n from 10 to 21, then you must do 10?11?13?21\n. There is no other way to make 10\n to 21\n using given operations.\n\nSo now we have to minimize max(b1?a1,b2?a2,,bn?an)\n, as smaller differences leads to use shorter time to make a\n nondecreasing.\n\nObservation 2. b\n is optimal when bi\n is the maximum value among b1,b2,,bi?1\n and ai\n.\n\nBecause for each position i\n, we have to make bi?ai\n as smallest possible. Since bi\n should be not smaller than previous b\n values and also ai\n, we derived such formula.\n\nSo from position 1,2,,n\n, greedily find a bi\n, and check how many seconds needed to convert ai\n to bi\n. The answer is maximum needed seconds among all positions.\n\nTime complexity is O(n)\n, but you can do O(nlogn)\n with \"std::set\" or whatever.",
    "hint": []
}