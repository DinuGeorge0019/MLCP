{
    "link": "https://codeforces.com//contest/1111/problem/D",
    "problemId": "292520",
    "problem_idx": "D",
    "shortId": "1111D",
    "contest_number": "1111",
    "problem_submissions": {
        "D": [
            49422912,
            49426608,
            49445983,
            49428765,
            49430406,
            49429665,
            49436958
        ],
        "C": [
            49409497,
            49410558,
            49410163,
            49418920,
            49410172,
            49413606,
            49411915,
            49417203,
            49413501,
            49413738,
            49417020,
            49443919,
            49443886,
            49417049,
            49414103,
            49415090,
            49412459,
            49414253,
            49415380,
            49421248,
            49439899,
            49413981
        ],
        "B": [
            49406849,
            49405440,
            49407099,
            49408763,
            49406563,
            49408463,
            49406490,
            49408964,
            49408646,
            49408980,
            49405550,
            49418102,
            49454731,
            49438417,
            49408744,
            49409042,
            49407957,
            49421603,
            49407686,
            49409374,
            49409345
        ],
        "A": [
            49402871,
            49402831,
            49403748,
            49403927,
            49403205,
            49402975,
            49402985,
            49410269,
            49405415,
            49404207,
            49402972,
            49402894,
            49402944,
            49404497,
            49403455,
            49404512,
            49404416,
            49403696,
            49403984
        ],
        "E": [
            49501912
        ]
    },
    "name": "D. Destroy the Colony",
    "statement": "There is a colony of villains with several holes aligned in a row, where\r\neach hole contains exactly one villain.Each colony arrangement can be\r\nexpressed as a string of length, where the i-th character of the string\r\nrepresents the type of villain in the i-th hole. Iron Man can destroy a\r\ncolony only if the colony arrangement is such that all villains of a\r\ncertain type either live in the first half of the colony or in the\r\nsecond half of the colony.His assistant Jarvis has a special power. It\r\ncan swap villains of any two holes, i.e. swap any two characters in the\r\nstring; he can do this operation any number of times.Now Iron Man asks\r\nJarvis q questions. In each question, he gives Jarvis two numbers x and\r\ny. Jarvis has to tell Iron Man the number of distinct colony\r\narrangements he can create from the original one using his powers such\r\nthat all villains having the same type as those originally living in\r\nx-th hole or y-th hole live in the same half and the Iron Man can\r\ndestroy that colony arrangement.Two colony arrangements are considered\r\nto be different if there exists a hole such that different types of\r\nvillains are present in that hole in the arrangements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl \"\\n\"\n#define ll long long\n\nconst int mxN=1e5, M=1e9+7;\nstring s;\nint q, c2i[256], c[52], n;\nll dp1[53][mxN/2+1], dp2[53][mxN/2+1], iv[mxN+1], f1[mxN+1], f2[mxN+1], ans[52][52], dp3[53][mxN/2+1];\n\nint32_t main()\n{\n\tIOS;\n\tfor(int i=0; i<26; ++i) {\n\t\tc2i['a'+i]=i;\n\t\tc2i['A'+i]=i+26;\n\t}\n\tcin >> s;\n\tn=s.size();\n\tfor(char ci : s)\n\t\t++c[c2i[ci]];\n\tiv[1]=1;\n\tfor(int i=2; i<=n; ++i)\n\t\tiv[i]=M-M/i*iv[M%i]%M;\n\tf1[0]=1;\n\tf2[0]=1;\n\tfor(int i=1; i<=n; ++i) {\n\t\tf1[i]=f1[i-1]*i%M;\n\t\tf2[i]=f2[i-1]*iv[i]%M;\n\t}\n\tdp1[0][0]=dp2[52][0]=1;\n\tfor(int i=0; i<52; ++i) {\n\t\tfor(int j=0; j<=n/2; ++j) {\n\t\t\tif(j+c[i]<=n/2&&c[i]) {\n\t\t\t\tdp1[i+1][j+c[i]]=(dp1[i+1][j+c[i]]+dp1[i][j])%M;\n\t\t\t}\n\t\t\tdp1[i+1][j]=(dp1[i+1][j]+dp1[i][j])%M;\n\t\t}\n\t}\n\tfor(int i=51; i>=0; --i) {\n\t\tfor(int j=0; j<=n/2; ++j) {\n\t\t\tif(j+c[i]<=n/2&&c[i]) {\n\t\t\t\tdp2[i][j+c[i]]=(dp2[i][j+c[i]]+dp2[i+1][j])%M;\n\t\t\t}\n\t\t\tdp2[i][j]=(dp2[i][j]+dp2[i+1][j])%M;\n\t\t}\n\t}\n\t//cout << dp2[2][2] << endl;\n\tll mult=f1[n/2]*f1[n/2]%M;\n\tfor(int i=0; i<52; ++i)\n\t\tmult=mult*f2[c[i]]%M;\n\tfor(int i=0; i<52; ++i) {\n\t\tmemcpy(dp3[i+1], dp1[i], sizeof(dp1[0]));\n\t\tfor(int j=i+1; j<52; ++j) {\n\t\t\tfor(int k=0; k<=n/2; ++k)\n\t\t\t\tans[i][j]=(ans[i][j]+dp3[j][k]*dp2[j+1][n/2-k])%M;\n\t\t\t//if(!i)\n\t\t\t//cout << ans[i][j] << endl;\n\t\t\tans[i][j]=2*ans[i][j]*mult%M;\n\t\t\tmemset(dp3[j+1], 0, sizeof(dp1[0]));\n\t\t\tfor(int k=0; k<=n/2; ++k) {\n\t\t\t\tif(k+c[j]<=n/2&&c[j]) {\n\t\t\t\t\tdp3[j+1][k+c[j]]=(dp3[j+1][k+c[j]]+dp3[j][k])%M;\n\t\t\t\t}\n\t\t\t\tdp3[j+1][k]=(dp3[j+1][k]+dp3[j][k])%M;\n\t\t\t}\n\t\t}\n\t}\n\tcin >> q;\n\twhile(q--) {\n\t\tint xi, yi;\n\t\tcin >> xi >> yi, --xi, --yi;\n\t\txi=c2i[s[xi]];\n\t\tyi=c2i[s[yi]];\n\t\tif(xi==yi) {\n\t\t\tcout << dp1[52][n/2]*mult%M << \"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tif(xi>yi)\n\t\t\tswap(xi, yi);\n\t\tcout << ans[xi][yi] << \"\\n\";\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Destroy the Colony.json",
    "editorial_link": "https://codeforces.com//blog/entry/64989",
    "editorial": "The question reduces to the following. Given a string s with lowercase\r\nand uppercase characters,a good string is one which can be generated by\r\nreshuffling characters, such that all occurences of a particular\r\nalphabet are in the same half. ( (1 to n/2) or (n/2+1 to n)) and this\r\ncondition is true for all alphabets. Now given a pair and , you want to\r\nfind the number of good strings such that all the occurences of and in\r\nthe string are also in the same half in the string.Lets first try to\r\nfind the number of good strings. = total number of alphabets.Store the\r\nfrequencies of the alphabets as their order does not matter, and let\r\nthem be Now if we can select indices such that = n/2 then we can arrange\r\nthose alphabets in the first half, and the remaining in the second half.\r\nTotal ways for arranging in first half = Similarly total ways for\r\narranging in 2nd half = (product of factorials of remaining\r\nfrequencies.)Thus total ways = (product of factorials of frequencies of\r\nall alphabets) (say) Thus notice that, for all combinations of\r\nfrequencies adding upto , the number of ways comes out to be constant.\r\nHence now the total number of good strings (number of combinations of\r\nfrequencies adding to )The part for the number of combinations adding\r\nupto can be computed using standard knapsack dp.Now let\u00e2\u0080\u0099s try to solve\r\nfor the condition that all occurrences of and , should all also be in\r\nthe same half, apart from the condition of the string being a good\r\nstring.This basically means now we want to select alphabet frequencies\r\nadding upto from the remaining frequencies ( excluding the frequency of\r\nalphabet and ). One way is to use the same method we did above for all\r\ngood strings.This gives complexity O for every pair, taking a total of O\r\nfor pairs.Now using the idea of adding items to a knapsack, we can also\r\nextend it to remove items.In short, we can use the pre-computed dp table\r\nto remove the number of ways which included the ith item, by reversing\r\nthe direction of the loop and the operation ( addition becomes\r\nsubtraction). Let the frequency of the element we want to remove be\r\n.dp[j] = number of ways to get sum as j using all elements. for (int\r\nj=x;j<=n;j++)dp[j]-=dp[j-x];( see the code for more details)In this way\r\nfor every pair , you copy the precomputed dp into a temporary array,\r\nremove ways using characters and and then the answer will be ( 2 because\r\nyou can choose the first or the second half for putting the group\r\ncontaining and ). After precomputation, each query is answered in O.\r\nTotal time O, for every pair and there are pairs. Final time complexity\r\nO\r\n"
}