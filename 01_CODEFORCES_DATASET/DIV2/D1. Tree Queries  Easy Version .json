{
    "link": "https://codeforces.com//contest/1695/problem/D1",
    "problemId": "1432674",
    "problem_idx": "D1",
    "shortId": "1695D1",
    "contest_number": "1695",
    "problem_submissions": {
        "E": [
            161099994,
            161385353
        ],
        "D1": [
            161071005,
            161074543,
            161081125,
            161072748,
            161085205,
            161076792,
            161086180,
            161088285,
            161078663,
            161087570,
            161090981,
            161081382,
            161096600,
            161083265,
            161094007,
            161083359,
            161087191,
            161099464,
            161103072
        ],
        "D2": [
            161070538,
            161074164,
            161080949,
            161072924,
            161085070,
            161077074,
            161086067,
            161090573,
            161078799,
            161087356,
            161091244,
            161098503,
            161096503,
            161083640,
            161093884,
            161083859,
            161106845,
            161102938,
            161103184
        ],
        "C": [
            161049795,
            161059348,
            161063490,
            161060415,
            161055337,
            161053834,
            161061413,
            161054883,
            161053215,
            161065273,
            161068360,
            161076346,
            161062519,
            161063339,
            161079032,
            161066869,
            161096184,
            161063492,
            161059254,
            161053168
        ],
        "B": [
            161047262,
            161053402,
            161051570,
            161054862,
            161050104,
            161049992,
            161050979,
            161048731,
            161049540,
            161057199,
            161054074,
            161054984,
            161050691,
            161052531,
            161068152,
            161056401,
            161053679,
            161049800,
            161064268,
            161048819
        ],
        "A": [
            161046762,
            161046971,
            161046828,
            161047950,
            161046933,
            161046876,
            161047188,
            161046813,
            161046805,
            161048336,
            161047711,
            161049772,
            161046830,
            161047996,
            161062872,
            161046949,
            161047484,
            161047163,
            161047431,
            161046827
        ]
    },
    "name": "D1. Tree Queries  Easy Version ",
    "statement": "You are given an unrooted tree with n vertices. There is some hidden\r\nvertex x in that tree that you are trying to find.To do this, you may\r\nask k queries v_1, v_2,\r\nldots, v_k where the v_i are vertices in the tree. After you are\r\nfinished asking all of the queries, you are given k numbers d_1, d_2,\r\nldots, d_k, where d_i is the number of edges on the shortest path\r\nbetween v_i and x. Note that you know which distance corresponds to\r\nwhich query.What is the minimum k such that there exists some queries\r\nv_1, v_2,\r\nldots, v_k that let you always uniquely identify x (no matter what x\r\nis).Note that you donâ€™t actually need to output these queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5, INF = 1e9;\n\nvector<int> adj[N];\nint ans;\n\nint dfs(int u, int fa) {\n    int cnt = 0, cnt2 = 0;\n    for (auto v : adj[u]) {\n        if (v == fa) continue;\n        cnt += dfs(v, u);\n        ++cnt2;\n    }\n    if (cnt != cnt2 && adj[u].size() >= 3) --ans;\n    return (cnt > 0) | (adj[u].size() >= 3);\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T, n;\n    cin >> T;\n    while (T--) {\n        cin >> n;\n        \n        if (n == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        for (int i = 0; i < n; i++) adj[i].clear();\n\n        for (int i = 1; i < n; i++) {\n            int u, v;\n            cin >> u >> v;\n            --u; --v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        ans = 0;\n        for (int i = 0; i < n; i++) ans += (adj[i].size() == 1);\n\n        int id = -1;\n        for (int i = 0; i < n; i++) {\n            if (adj[i].size() >= 3) {\n                id = i;\n                break;\n            }\n        }\n        if (id == -1) {\n            cout << 1 << endl;\n            continue;\n        }\n        dfs(id, id);\n        cout << ans << endl;\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Tree Queries  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/103996",
    "editorial": "If , then no queries are needed, because there is only one vertex.\r\nOtherwise, we need at least one query.If we fix a node , and force it to\r\nbe a query, we can root the tree at and do a greedy DFS to compute the\r\nanswer. Note that because we guarantee that the root is a query, when we\r\nare computing the answer for any node in this DFS, we can assume that\r\neither or some vertex not in the subtree of has already been queried.We\r\ndefine to be the minimal number of queries to distinguish all vertices\r\nin the subtree of , given that or some vertex not in the subtree of has\r\nbeen queried. Note that for each child of , we need to be able to\r\ndistinguish all vertices in the subtree of , so we have . Additionally,\r\nthere can be at most one child of with no queries in its subtree,\r\notherwise all of these children will be indistinguishable by the\r\nqueries. If there are such children of , we can query the first of them,\r\nwhich will be enough to differentiate all vertices in these subtrees.\r\nSo, using this definition of , our final formula isFor each possible\r\nroot, we do a DFS to recursively compute these answers. The answer is\r\nthe minimum , where the is to account for the fact that we are querying\r\nthe root.Complexity: O(n^2)\r\n",
    "hint": []
}