{
    "link": "https://codeforces.com//contest/1195/problem/E",
    "problemId": "373881",
    "problem_idx": "E",
    "shortId": "1195E",
    "contest_number": "1195",
    "problem_submissions": {
        "F": [
            57231940,
            57228583,
            57230665,
            57230760,
            57233707,
            57236452,
            57231972,
            57234436,
            57234600,
            57238063,
            57234775,
            57310298,
            57228874,
            57290272,
            57225125
        ],
        "E": [
            57221608,
            57223793,
            57222513,
            57225684,
            57222906,
            57215919,
            57226202,
            57226594,
            57228678,
            57225929,
            57227306,
            57224920,
            57217658,
            57221326,
            57221813,
            57226168,
            57222930,
            57258569,
            57224143
        ],
        "D1": [
            57217173,
            57217670,
            57213566,
            57216495,
            57217668,
            57218460,
            57220879,
            57217890,
            57215569,
            57210215,
            57222516,
            57213030,
            57213769,
            57209778,
            57215844,
            57218863,
            57212403,
            57215924,
            57215516,
            57217529
        ],
        "D2": [
            57216895,
            57217496,
            57213368,
            57216364,
            57217535,
            57229402,
            57220576,
            57217862,
            57215401,
            57216742,
            57222653,
            57217606,
            57213863,
            57214793,
            57215958,
            57218634,
            57215884,
            57216070,
            57229811,
            57216866
        ],
        "C": [
            57208411,
            57206363,
            57208350,
            57208286,
            57212089,
            57204975,
            57209742,
            57209624,
            57207426,
            57206667,
            57209966,
            57209554,
            57208702,
            57205876,
            57208547,
            57209651,
            57208031,
            57210123,
            57210767,
            57209324
        ],
        "B": [
            57206484,
            57204728,
            57206113,
            57205986,
            57206681,
            57203895,
            57206510,
            57205624,
            57205603,
            57204561,
            57207235,
            57206451,
            57206143,
            57204517,
            57206504,
            57207159,
            57205738,
            57206747,
            57207265
        ],
        "A": [
            57203812,
            57203699,
            57205723,
            57203885,
            57204288,
            57203645,
            57204262,
            57204010,
            57204256,
            57203704,
            57203968,
            57204725,
            57203853,
            57203719,
            57204238,
            57204466,
            57203857,
            57203680,
            57204939,
            57203939
        ]
    },
    "name": "E. OpenStreetMap",
    "statement": "Seryozha conducts a course dedicated to building a map of heights of\r\nStepanovo recreation center. He laid a rectangle grid of size n\r\ntimes m cells on a map (rows of grid are numbered from 1 to n from north\r\nto south, and columns are numbered from 1 to m from west to east). After\r\nthat he measured the average height of each cell above Rybinsk sea level\r\nand obtained a matrix of heights of size n\r\ntimes m. The cell (i, j) lies on the intersection of the i-th row and\r\nthe j-th column and has height h_{i, j}. Seryozha is going to look at\r\nthe result of his work in the browser. The screen of Seryozha\u2019s laptop\r\ncan fit a subrectangle of size a\r\ntimes b of matrix of heights (1\r\nle a\r\nle n, 1\r\nle b\r\nle m). Seryozha tries to decide how the weather can affect the\r\nrecreation center for example, if it rains, where all the rainwater will\r\ngather. To do so, he is going to find the cell having minimum height\r\namong all cells that are shown on the screen of his laptop.Help Seryozha\r\nto calculate the sum of heights of such cells for all possible\r\nsubrectangles he can see on his screen. In other words, you have to\r\ncalculate the sum of minimum heights in submatrices of size a\r\ntimes b with top left corners in (i, j) over all 1\r\nle i\r\nle n - a + 1 and 1\r\nle j\r\nle m - b + 1.Consider the sequence g_i = (g_{i - 1}\r\ncdot x + y)\r\nbmod z. You are given integers g_0, x, y and z. By miraculous\r\ncoincidence, h_{i, j} = g_{(i - 1)\r\ncdot m + j - 1} ((i - 1)\r\ncdot m + j - 1 is the index).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 3005;\n\nint tmp[N], q[N], h[N][N];\n\nint main() {\n    int n, m, a, b;\n    cin >> n >> m >> a >> b;\n    LL g, x, y, z;\n    cin >> g >> x >> y >> z;\n    for (int i = 0; i < n; i++) {\n        int head = 0, tail = -1;\n        for (int j = 0; j < m; j++) {\n            tmp[j] = g;\n            g = (g * x + y) % z;\n            while (head <= tail && tmp[q[tail]] > tmp[j]) --tail;\n            q[++tail] = j;\n            while (head <= tail && q[head] <= j-b) ++head;\n            if (j >= b-1) h[i][j-b+1] = tmp[q[head]];\n        }\n    }\n    LL res = 0;\n    for (int j = 0; j <= m-b; j++) {\n        int head = 0, tail = -1;\n        for (int i = 0; i < n; i++) {\n            while (head <= tail && h[q[tail]][j] > h[i][j]) --tail;\n            q[++tail] = i;\n            while (head <= tail && q[head] <= i-a) ++head;\n            if (i >= a-1) res += h[q[head]][j];\n        }\n    }\n    cout << res << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. OpenStreetMap.json",
    "editorial_link": "https://codeforces.com/blog/entry/68471",
    "editorial": "There is almost nothing to say about this problem. It is pretty standard\r\ndata structure problem.Let be the minimum value over all values . If is\r\nless than then its value does not matter for us because the\r\ncorresponding submatrix is not counted in the answer. These values can\r\nbe calculated using or minimum queue. You can read more about it here:\r\nhttps://cp-algorithms.com/data_structures/stack_queue_modification.html.After\r\nbuilding such matrix we can actually calculate the answer. Let\u00e2\u0080\u0099s iterate\r\nover all rows of the matrix (starting from row ) and carry the floating\r\nwindow of width of values . And when the size of the queue with minimums\r\nreaches we know the minimum on the corresponding submatrix that ends in\r\nthe current element and we can add it to the answer.Time complexity: .\r\n"
}