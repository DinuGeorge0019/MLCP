{"link": "https://codeforces.com//contest/680/problem/D", "problemId": "61902", "problem_idx": "D", "shortId": "680D", "contest_number": "680", "problem_submissions": {"E": [18325043, 18336819, 18313780, 18325133, 18326159, 91465868, 91465765, 18326865, 18326653, 18321290, 18325524], "D": [18318422, 18317712, 18319515, 18318081, 18319018, 18319894, 18321280, 18314391, 18321896, 18322082, 18323629, 18321461], "C": [18310807, 18309120, 18309109, 18310395, 18309474, 18309104, 18322448, 18311311, 18310069, 18313252, 93169698, 91285497, 20188952, 18318579, 18308421, 18311792, 18307772, 18311986, 18308165, 18323717, 18309473, 18312494], "B": [18305109, 18304731, 18305069, 18305817, 18305879, 18305478, 18318612, 18306119, 18307273, 18305717, 54153853, 54153852, 54153523, 54153520, 18308586, 18305117, 18306452, 18305702, 18306808, 18308328, 18304898, 18305913, 18306422], "A": [18302780, 18302872, 18302977, 18303253, 18302950, 18302797, 18317513, 18303506, 18302976, 18303711, 54152578, 54152576, 54152557, 54152556, 18306442, 18302916, 18303646, 18303474, 18304094, 18302798, 18302792, 18304079, 18303143]}, "name": "D. Bear and Tower of Cubes", "statement": "Limak is a little polar bear. He plays by building towers from blocks.\r\nEvery block is a cube with positive integer length of side. Limak has\r\ninfinitely many blocks of each side length.A block with side has volume\r\n. A tower consisting of blocks with sides has the total volume .Limak is\r\ngoing to build a tower. First, he asks you to tell him a positive\r\ninteger the required total volume of the tower. Then, Limak adds new\r\nblocks greedily, one by one. Each time he adds the biggest block such\r\nthat the total volume doesn\u2019t exceed .Limak asks you to choose not\r\ngreater than . Also, he wants to maximize the number of blocks in the\r\ntower at the end (however, he still behaves greedily). Secondarily, he\r\nwants to maximize .Can you help Limak? Find the maximum number of blocks\r\nhis tower can have and the maximum that results this number of blocks.\r\n", "solutions": ["#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int N = 1e5 + 5;\nll x[N] , n;int f[N];\npair<int,ll> Max[N] , p[N];\n\npair<int,ll> solve(ll a){\n    if(a <= 215) return p[a];\n    int t = upper_bound(x + 1, x + N , a) - x - 1;\n    pair<int,ll> ret = Max[t-1] , c2 = solve(a - x[t]);\n    c2.fi++ , c2.se += x[t];\n    ret = max(ret , c2);\n    return ret;\n}\nint main(){\n    rep(i,1,N) x[i] = (ll)i * i * i;\n    cin >> n;\n    for(int i=1;i<=215;++i){\n        int j = 1;while(x[j+1]<=i) ++j;\n        f[i] = f[i-x[j]] + 1;\n        p[i] = mp(f[i] , (ll)i);\n        p[i] = max(p[i-1] , p[i]);\n    }\n    for(int i=1;i<=5;++i){\n        Max[i] = mp(0,0);\n        for(int j=x[i];j<x[i+1];++j)\n            Max[i] = max(Max[i] , mp(f[j] , (ll)j));\n    }\n    //rep(i,1,6) cout << i << \" \" << Max[i].fi << \" \" << Max[i].se << endl;\n    if(n <= 215) cout << p[n].fi << \" \" << p[n].se << endl;\n    else{\n        int i = 6;\n        for(i=6;x[i]<=n;++i){\n            Max[i] = solve(x[i+1] - x[i] - 1);\n            Max[i].fi++ , Max[i].se += x[i];\n            Max[i] = max(Max[i] , Max[i-1]);\n        }\n        --i;\n        pair<int,ll> p = solve(n - x[i]);p.se += x[i] , p.fi++;\n        p = max(p , Max[i-1]);\n        cout << p.fi << \" \" << p.se << endl;\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "constructive algorithms", "greedy"], "dificulty": "2200", "interactive": false}