{
    "link": "https://codeforces.com//contest/1629/problem/F2",
    "problemId": "1270556",
    "problem_idx": "F2",
    "shortId": "1629F2",
    "contest_number": "1629",
    "problem_submissions": {
        "E": [
            143691687,
            143672752,
            143687137,
            143663655,
            143674506,
            143679445,
            143862635,
            143682492,
            143680665,
            143680424,
            143685684,
            143684891,
            143753002,
            143685619,
            143692185,
            143689230,
            143685863,
            143687115,
            143695099,
            143693974
        ],
        "F2": [
            143688718,
            143726329,
            143690987
        ],
        "F1": [
            143676123,
            143697164,
            143692998,
            143741879,
            143678223,
            143750588,
            143750365
        ],
        "D": [
            143667461,
            143661533,
            143674891,
            143656107,
            143648676,
            143665361,
            143663909,
            143668220,
            143661278,
            143662732,
            143656926,
            143668180,
            143668746,
            143665526,
            143669234,
            143667378,
            143676861,
            143663591,
            143664123
        ],
        "C": [
            143651046,
            143647499,
            143659885,
            143651714,
            143662268,
            143651456,
            143647120,
            143654421,
            143646086,
            143650221,
            143697555,
            143656282,
            143655178,
            143644392,
            143657665,
            143654804,
            143651022,
            143650097,
            143652583
        ],
        "B": [
            143642034,
            143637040,
            143638720,
            143651837,
            143664772,
            143638989,
            143637268,
            143641201,
            143638312,
            143634980,
            143632383,
            143644246,
            143635339,
            143635326,
            143637617,
            143639992,
            143639371,
            143640785,
            143642627
        ],
        "A": [
            143633916,
            143631168,
            143632391,
            143651906,
            143666062,
            143631304,
            143631044,
            143630886,
            143631218,
            143630607,
            143639841,
            143633922,
            143630487,
            143630572,
            143630653,
            143631188,
            143630505,
            143635250,
            143635282
        ]
    },
    "name": "F2. Game on Sum  Hard Version ",
    "statement": "Alice and Bob are given the numbers n, m and k, and play a game as\r\nfollows:The game has a score that Alice tries to maximize, and Bob tries\r\nto minimize. The score is initially 0. The game consists of n turns.\r\nEach turn, Alice picks a number from 0 to k (inclusive) which Bob either\r\nadds to or subtracts from the score of the game. But throughout the\r\ngame, Bob has to choose to add at least m out of the n turns.Bob gets to\r\nknow which number Alice picked before deciding whether to add or\r\nsubtract the number from the score, and Alice gets to know whether Bob\r\nadded or subtracted the number for the previous turn before picking the\r\nnumber for the current turn (except on the first turn since there was no\r\nprevious turn).If Alice and Bob play optimally, what will the final\r\nscore of the game be?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 1000000007\n#define inv2 500000004\nll read() {\n\tll x=0,f=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\nll power(ll x,ll y) {\n\tll ret=1;\n\twhile(y) {\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint T;\nll fac[1010101],inv[1010101],n,m,k;\nll C(int x,int y){return fac[x]*inv[y]%mod*inv[x-y]%mod;}\nint main() {\n\tfac[0]=fac[1]=1;\n\tfor(int i=1;i<=1000000;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[1000000]=power(fac[1000000],mod-2);\n\tinv[0]=inv[1]=1;\n\tfor(int i=2;i<=1000000;i++) inv[i]=((mod-(mod/i))*inv[mod%i])%mod;\n\tfor(int i=2;i<=1000000;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tscanf(\"%d\",&T);\n\twhile(T--) {\n\t\tll ans=0;\n\t\tscanf(\"%lld%lld%lld\",&n,&m,&k);\n\t\tif(n==m) {cout<<k*n%mod<<'\\n';continue;}\n\t\tfor(int i=1;i<=m;i++) {\n\t\t\tans=ans+C(n-i-1,m-i)*power(inv2,n-i)%mod*i%mod;\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans*k%mod<<endl;\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "games"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. Game on Sum  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/99276",
    "editorial": "We have base cases\n\nDP[i][0]=0\nDP[i][i]=k?i\nAnd transition DP[i][j]=(DP[i?1][j?1]+DP[i?1][j])/2\n\nCheck the explanation for the easy version to see why.\n\nThis DP\n can be optimized by looking at contributions from the base cases.\n\nIf we draw the DP\n states on a grid and ignore the division by 2\n in the transition, we can see that the number of times states DP[i][i]\n contributes to state DP[n][m]\n is the number of paths from (i,j)\n to (n,m)\n in the grid such that at each step, both i\n and j\n increase, or only j\n increases, except we have to exclude paths that go through other base cases. The number of such paths is (n?i?1m?j)\n. Since the number of steps in all of these paths is the same, we can account for the division by 2\n in each transition by dividing by 2n?i\n in the end.\n\nTo find the value of DP[n][m]\n we sum the contribution form every base case DP[i][i]\n for 1?i?n\n."
}