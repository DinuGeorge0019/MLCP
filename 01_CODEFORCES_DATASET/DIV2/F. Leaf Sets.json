{
    "link": "https://codeforces.com//contest/1042/problem/F",
    "problemId": "220710",
    "problem_idx": "F",
    "shortId": "1042F",
    "contest_number": "1042",
    "problem_submissions": {
        "F": [
            42987714,
            42984651,
            42989319,
            42983649,
            42989168,
            42989334,
            42988495,
            42988621,
            42990991,
            42984782,
            42991318,
            42984734,
            42989762,
            42989508,
            42989199,
            42985445,
            42984262,
            42986731
        ],
        "A": [
            42984167,
            42973725,
            42974031,
            42973482,
            42973429,
            42973632,
            42973538,
            42974330,
            42975529,
            42973708,
            42993729,
            42975026,
            42986836,
            42989940,
            42973749,
            42992518,
            42973915,
            42973554,
            42973556,
            42973468
        ],
        "E": [
            42983656,
            42983448,
            42981915,
            42988922,
            42984518,
            42985483,
            42983668,
            42985621,
            42980250,
            42987926,
            42982614,
            42990994,
            42986527,
            42985364,
            42983020,
            42986197,
            42989170,
            42987817,
            42982499
        ],
        "C": [
            42982112,
            42977810,
            42976676,
            42978400,
            42979933,
            42981591,
            42978723,
            42979152,
            42981616,
            43020286,
            42983391,
            42977530,
            42987879,
            42980102,
            42982752,
            42979907,
            42979506,
            42982122,
            42993016,
            42980948,
            42977178
        ],
        "B": [
            42975906,
            42974331,
            42974910,
            42974847,
            42974321,
            42975176,
            42975023,
            42975453,
            42976952,
            42975043,
            42975357,
            42976939,
            42975515,
            42976516,
            42974965,
            42975963,
            42975276,
            42974792,
            42974885,
            42974787
        ],
        "D": [
            42975097,
            42975491,
            42978165,
            42980511,
            42976657,
            42978683,
            42980559,
            42982541,
            42983622,
            43020160,
            42982284,
            42979330,
            42979227,
            42983154,
            42978119,
            42977687,
            42982730,
            42983764,
            42980017,
            42976894,
            42978512
        ]
    },
    "name": "F. Leaf Sets",
    "statement": "You are given an undirected tree, consisting of n vertices.The vertex is\r\ncalled a leaf if it has exactly one vertex adjacent to it.The distance\r\nbetween some pair of vertices is the number of edges in the shortest\r\npath between them.Let\u2019s call some set of leaves if the maximum distance\r\nbetween any pair of leaves in it is less or equal to k.You want to split\r\nleaves into beautiful sets. What is the minimal number of sets in such a\r\nsplit?\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdio>\n// Linsanity is back \n// Who\u2019s Kobe? \n// Fisherman can\u2019t stop us\n// Average ABCDE on a good day\nusing namespace std;\n\nconst int MAXN = 1000005;\nint N, K;\nvector<int> adj[MAXN];\nint A[MAXN];\nint ans = 0;\n\nvoid dfs(int cur, int prv)\n{\n    if (adj[cur].size() == 1)\n    {\n        A[cur] = 0;\n        return;\n    }\n\n    vector<int> v;\n    for (auto nxt : adj[cur])\n    {\n        if (nxt == prv)\n            continue;\n        dfs(nxt, cur);\n        if (A[nxt] != -1)\n            v.push_back(A[nxt] + 1);\n    }\n    sort(v.begin(), v.end());\n    while (!v.empty() && v.back() >= K)\n    {\n        v.pop_back();\n        ans++;\n    }\n    while (v.size() >= 2 && v.back() + v[v.size() - 2] > K)\n    {\n        v.pop_back();\n        ans++;\n    }\n    if (!v.empty())\n        A[cur] = v.back();\n}\n\nint main()\n{\n    scanf(\"%d %d\", &N, &K);\n    for (int i = 0, a, b; i < N - 1; i++)\n    {\n        scanf(\"%d %d\", &a, &b);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int root = -1;\n    for (int i = 1; i <= N; i++)\n        if (adj[i].size() > 1)\n        {\n            root = i;\n            break;\n        }\n\n    memset(A, -1, sizeof(A));\n    dfs(root, 0);\n    ans += A[root] != -1;\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "sortings",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Leaf Sets.json",
    "editorial_link": "https://codeforces.com/blog/entry/61891",
    "editorial": "Let\u00e2\u0080\u0099s use the following technique, which is pretty common for tree\r\nproblems. Let the root of the tree be some none-leaf vertex. Run dfs\r\nfrom the root and let the vertex yield all the resulting sets in the\r\noptimal answer for its subtree. For each vertex you iterate over its\r\nchildren and merge the yielded sets.The first thing to notice is that\r\nyou only need the deepest vertex from each set to check its\r\nmergeability. Let\u00e2\u0080\u0099s call the distance between the vertex and the deepest\r\nvertex in some set in its subtree . Now two sets and can be merged only\r\nif . Moreover, value of the resulting the set is .The time has come to\r\nreveal the merging process. We will heavily rely on a fact that the\r\nresulting doesn\u00e2\u0080\u0099t change after merging. Let\u00e2\u0080\u0099s merge the sets with the\r\nsmallest to any other possible sets. Now we can deduce the\r\nsmall-to-large solution from it. Let the vertex yield the whole multiset\r\nof the depths of the resulting sets. Now take the child with the largest\r\nnumber of resulting sets and add all the values from the other children\r\nto its multiset. Then merge the maximum possible number of sets and\r\nyield the result. The size of set yielded by the root is the answer.The\r\ncomplexity of this solution is , which still can be too slow.You can\r\nnotice that if you have a pair of sets and such that , set will never\r\naffect the answer. If some set could later be merged with , it can be\r\nwith as well. Thus, you can erase set from the result and add to the\r\nanswer. Then the vertex will always yield a single set. The solution\r\nmentioned above works in with this modification.This can later be\r\nmodified a bit to a solution but that is totally unnecessary and works\r\nabout the same time as . It still takes most of the time to read the\r\ninput.\r\n"
}