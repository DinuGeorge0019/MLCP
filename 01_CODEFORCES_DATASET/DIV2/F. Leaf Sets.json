{"link": "https://codeforces.com//contest/1042/problem/F", "problemId": "220710", "problem_idx": "F", "shortId": "1042F", "contest_number": "1042", "problem_submissions": {"F": [42987714, 42984651, 42989319, 42983649, 42989168, 42989334, 42988495, 42988621, 42990991, 42984782, 42991318, 42984734, 42989762, 42989508, 42989199, 42985445, 42984262, 42986731], "A": [42984167, 42973725, 42974031, 42973482, 42973429, 42973632, 42973538, 42974330, 42975529, 42973708, 42993729, 42975026, 42986836, 42989940, 42973749, 42992518, 42973915, 42973554, 42973556, 42973468], "E": [42983656, 42983448, 42981915, 42988922, 42984518, 42985483, 42983668, 42985621, 42980250, 42987926, 42982614, 42990994, 42986527, 42985364, 42983020, 42986197, 42989170, 42987817, 42982499], "C": [42982112, 42977810, 42976676, 42978400, 42979933, 42981591, 42978723, 42979152, 42981616, 43020286, 42983391, 42977530, 42987879, 42980102, 42982752, 42979907, 42979506, 42982122, 42993016, 42980948, 42977178], "B": [42975906, 42974331, 42974910, 42974847, 42974321, 42975176, 42975023, 42975453, 42976952, 42975043, 42975357, 42976939, 42975515, 42976516, 42974965, 42975963, 42975276, 42974792, 42974885, 42974787], "D": [42975097, 42975491, 42978165, 42980511, 42976657, 42978683, 42980559, 42982541, 42983622, 43020160, 42982284, 42979330, 42979227, 42983154, 42978119, 42977687, 42982730, 42983764, 42980017, 42976894, 42978512]}, "name": "F. Leaf Sets", "statement": "You are given an undirected tree, consisting of n vertices.The vertex is\r\ncalled a leaf if it has exactly one vertex adjacent to it.The distance\r\nbetween some pair of vertices is the number of edges in the shortest\r\npath between them.Let\u2019s call some set of leaves if the maximum distance\r\nbetween any pair of leaves in it is less or equal to k.You want to split\r\nleaves into beautiful sets. What is the minimal number of sets in such a\r\nsplit?\r\n", "solutions": ["#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdio>\n// Linsanity is back \n// Who\u2019s Kobe? \n// Fisherman can\u2019t stop us\n// Average ABCDE on a good day\nusing namespace std;\n\nconst int MAXN = 1000005;\nint N, K;\nvector<int> adj[MAXN];\nint A[MAXN];\nint ans = 0;\n\nvoid dfs(int cur, int prv)\n{\n    if (adj[cur].size() == 1)\n    {\n        A[cur] = 0;\n        return;\n    }\n\n    vector<int> v;\n    for (auto nxt : adj[cur])\n    {\n        if (nxt == prv)\n            continue;\n        dfs(nxt, cur);\n        if (A[nxt] != -1)\n            v.push_back(A[nxt] + 1);\n    }\n    sort(v.begin(), v.end());\n    while (!v.empty() && v.back() >= K)\n    {\n        v.pop_back();\n        ans++;\n    }\n    while (v.size() >= 2 && v.back() + v[v.size() - 2] > K)\n    {\n        v.pop_back();\n        ans++;\n    }\n    if (!v.empty())\n        A[cur] = v.back();\n}\n\nint main()\n{\n    scanf(\"%d %d\", &N, &K);\n    for (int i = 0, a, b; i < N - 1; i++)\n    {\n        scanf(\"%d %d\", &a, &b);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int root = -1;\n    for (int i = 1; i <= N; i++)\n        if (adj[i].size() > 1)\n        {\n            root = i;\n            break;\n        }\n\n    memset(A, -1, sizeof(A));\n    dfs(root, 0);\n    ans += A[root] != -1;\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dsu", "graphs", "greedy", "sortings", "trees"], "dificulty": "2400", "interactive": false}