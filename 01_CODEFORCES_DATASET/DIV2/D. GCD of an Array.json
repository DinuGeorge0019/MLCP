{
    "link": "https://codeforces.com//contest/1493/problem/D",
    "problemId": "916231",
    "problem_idx": "D",
    "shortId": "1493D",
    "contest_number": "1493",
    "problem_submissions": {
        "E": [
            109300691,
            109266485,
            109271539,
            109262971,
            109276076,
            109269136,
            109397471,
            109327948,
            109273809,
            109280460,
            109407951,
            109291144
        ],
        "B": [
            109260545,
            109239746,
            109254991,
            109270234,
            109241243,
            109242522,
            109253609,
            109252334,
            109327832,
            109233296,
            109238405,
            109249942,
            109232284,
            109235737,
            109235442,
            109237822,
            109237430,
            109234756,
            109237333,
            109236735
        ],
        "C": [
            109257705,
            109251136,
            109251134,
            109246054,
            109250920,
            109266513,
            109273162,
            109327814,
            109245427,
            109240048,
            109234896,
            109238348,
            109245265,
            109246216,
            109245882,
            109254906,
            109244489,
            109256285,
            109246006
        ],
        "F": [
            109251446,
            109300451,
            109300023,
            109263743,
            109278727,
            109492473,
            109395367,
            109755119
        ],
        "D": [
            109250583,
            109257293,
            109245697,
            109282268,
            109255131,
            109236733,
            109257985,
            109245022,
            109241096,
            109327857,
            109262894,
            109249582,
            109243883,
            109253883,
            109249816,
            109255048,
            109252679,
            109247391,
            109256541,
            109248836,
            109257345
        ],
        "A": [
            109228407,
            109230343,
            109243099,
            109232737,
            109227629,
            109231368,
            109228074,
            109228388,
            109327785,
            109227973,
            109230330,
            109252518,
            109227990,
            109230461,
            109228220,
            109228782,
            109229679,
            109227822,
            109229042,
            109229707
        ]
    },
    "name": "D. GCD of an Array",
    "statement": "You are given an array a of length n. You are asked to process q queries\r\nof the following format: given integers i and x, multiply a_i by x.After\r\nprocessing each query you need to output the greatest common divisor\r\n(GCD) of all elements of the array a.Since the answer can be too large,\r\nyou are asked to output it modulo 10^9+7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define vi vector<int>\n#define pii pair<int,int>\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define ull unsigned long long\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define Fin(s) freopen(s,\"r\",stdin)\n#define Fout(s) freopen(s,\"w\",stdout)\n#define file(s) Fin(s\".in\"),Fout(s\".out\")\n#define INF ((1<<30)-1)\n#define int long long\nconst int P=1e9+7; //\nusing namespace std;\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\ninline int mul(int a,int b) {return 1ll*a*b%P;}\n//inline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\ninline void mulmod(int &a,int b) {a=mul(a, b);}\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\ninline void fprint(const vector<int> &f) {for(int i=0;i<f.size();i++) fprintf(stderr,\"%d \",f[i]); fprintf(stderr,\"\\n\");}\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a,P-2);}\nnamespace FastIO {\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\n  int read(char *s) {\n    while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n  }\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\n  void write(int x) {\n    if(!x) obuf[opt++]='0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\n  }\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\n};\ninline int read() {int x; FI(x); return x;}\nconst int MN=2e5+5;\nint n,Q,p[MN],tot,vis[MN];\nvector<int>d[MN];\nvoid init(int n=MN-5) {\n\tfor(int i=2;i<=n;i++) {\n\t\tif(!vis[i]) {\n\t\t\tp[++tot]=i;\n\t\t\tfor(int j=i;j<=n;j+=i) {\n\t\t\t\tvis[j]=1; d[j].pb(i);\n\t\t\t}\t\n\t\t}\n\t\t\n\t}\n}\nint a[MN];\nmap<int,int>t[MN];\npriority_queue<int,vector<int>,greater<int> >q[MN],del[MN];\nint cc[MN];\nvoid erase(int i,int x) {\n\tdel[i].push(x);\n\twhile(q[i].size()&&del[i].size()&&q[i].top()==del[i].top()) q[i].pop(),del[i].pop();\n}\n\nvoid add(int i,int x) {\n\tq[i].push(x);\n}\nsigned main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"pro.in\",\"r\",stdin);\n\t\tfreopen(\"pro.out\",\"w\",stdout);\n\t#endif\n\tn=read(),Q=read(); init();\n\tFor(i,1,n) a[i]=read();\n\tint res=a[1]; For(i,2,n) res=__gcd(res,a[i]);\n\tFor(i,1,n) {\n\t\tfor(auto it:d[a[i]]) {\n//\t\t\tcerr<<i<<' '<<it<<endl;\n\t\t\tint cnt=0;\n\t\t\twhile(a[i]%it==0) a[i]/=it,cnt++;\t\n\t\t\tq[it].push(cnt); t[i][it]=cnt; cc[it]++;\n\t\t}\n\t}\n//\tcerr<<\"?\";\n//\tFor(i,1,12) {\n//\t\tcerr<<q[i].size()<<endl;\t\n//\t}\n//\tFor(i,1,12) {\n//\t\tcerr<<cc[i]<<endl;\t\n//\t}\n\twhile(Q--) {\n\t\tint i=read(),x=read();\n//\t\tcerr<<\"!\"<<' '<<i<<' '<<x<<endl;\n\t\tfor(auto it:d[x]) {\n\t\t\tint cnt=0;\n\t\t\twhile(x%it==0) x/=it,cnt++;\t\n//\t\t\tcerr<<it<<' '<<cnt<<endl;\n\t\t\tif(cc[it]==n) {\n\t\t\t\tassert(q[it].size());\n\t\t\t\tmulmod(res,inv(ksm(it,q[it].top())));\t\n\t\t\t}\n\t\t\tif(t[i].count(it)) {\n//\t\t\t\tcerr<<\"?\"<<' '<<i<<' '<<it<<endl;\n\t\t\t\terase(it,t[i][it]);\n\t\t\t\tt[i][it]+=cnt; add(it,t[i][it]);\n\t\t\t} else {\n\t\t\t\tt[i][it]=cnt; add(it,t[i][it]); cc[it]++;\n\t\t\t}\n//\t\t\tcerr<<\"?\";\n\t\t\tif(cc[it]==n) {\n//\t\t\t\tcerr<<it<<' '<<q[it].top()<<endl;\n\t\t\t\tmulmod(res,ksm(it,q[it].top()));\t\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn FastIO::Fflush(),0;\n}\n/*\n0. Enough array size? Enough array size? Integer overflow?\n\n1. Think TWICE, Code ONCE!\nAre there any counterexamples to your algo?\n\n2. Be careful about the BOUNDARIES!\nN=1? P=1? Something about 0?\n\n3. Do not make STUPID MISTAKES!\nTime complexity? Memory usage? Precision error?\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "hashing",
        "implementation",
        "math",
        "number theory",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. GCD of an Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/88422",
    "editorial": "Notice that after each query the answer doesn\u00e2\u0080\u0099t become smaller and we\r\ncan solve the problem for each prime divisor independently.For each\r\nnumber let\u00e2\u0080\u0099s maintain an amount of occurences for all its prime divisors\r\n(you can implement it using ). For each prime divisor let\u00e2\u0080\u0099s write to its\r\ncorresponding the amount of times it is met in every of the numbers of\r\nthe array, at the same time we won\u00e2\u0080\u0099t add null values.Initially, . Let\u00e2\u0080\u0099s\r\nunderstand the way a prime divisor is included in the answer. If the\r\nsize of its is not equal to , then won\u00e2\u0080\u0099t change, otherwise , where is a\r\nminimal number of .Since is not decreasing, then we can avoid\r\ncalculating it all over again every time and instead recalculate it only\r\nfor divisors that are being changed (with that, because the minimal\r\nnumber of is not decreasing as well, we can just increase the answer\r\nusing multiplication).To process the query, we need to find the prime\r\nfactorization of (for example, using the Sieve of Eratosthenes) and add\r\nthe prime divisors to the for -th element (and correspondingly change\r\nthe for that divisor).Each query is processed in the complexity of the\r\namount of prime divisors multiplied by the time of and operation, i.e. .\r\n"
}