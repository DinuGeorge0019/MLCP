{
    "link": "https://codeforces.com//contest/1700/problem/F",
    "problemId": "1433687",
    "problem_idx": "F",
    "shortId": "1700F",
    "contest_number": "1700",
    "problem_submissions": {
        "F": [
            161204184,
            161175037,
            161206125,
            161212939,
            161208920,
            161208613,
            161221499,
            161209546
        ],
        "E": [
            161198687,
            161196286,
            161355967,
            161718414,
            161625123,
            161210058,
            161186427,
            161205675,
            161211460,
            161212251,
            161209815,
            161226432,
            161215179,
            161212687,
            161209759,
            161208133,
            161212427
        ],
        "D": [
            161181899,
            161187142,
            161172748,
            161191235,
            161182477,
            161193166,
            161184771,
            161194388,
            161383056,
            161196489,
            161188119,
            161188891,
            161183798,
            161190373,
            161201766,
            161189358,
            161191653,
            161196390,
            161376237,
            161189700,
            161191427
        ],
        "C": [
            161179311,
            161183541,
            161180380,
            161184212,
            161718390,
            161184885,
            161181511,
            161178526,
            161188654,
            161193034,
            161183225,
            161183002,
            161175389,
            161193124,
            161191878,
            161177816,
            161183179,
            161187003,
            161183522,
            161177845
        ],
        "B": [
            161174411,
            161180612,
            161180415,
            161180363,
            161174680,
            161179087,
            161174700,
            161180026,
            161190959,
            161175925,
            161173974,
            161173339,
            161174147,
            161181560,
            161181382,
            161172925,
            161174110
        ],
        "A": [
            161167944,
            161176736,
            161168168,
            161168440,
            161176515,
            161168925,
            161168213,
            161168654,
            161187609,
            161168766,
            161168663,
            161168483,
            161168047,
            161169513,
            161168007,
            161168296,
            161173279,
            161168814,
            161167994
        ]
    },
    "name": "F. Puzzle",
    "statement": "Pupils Alice and Ibragim are best friends. It’s Ibragim’s birthday soon,\r\nso Alice decided to gift him a new puzzle. The puzzle can be represented\r\nas a matrix with 2 rows and n columns, every element of which is either\r\n0 or 1. In one move you can swap two values in neighboring cells.More\r\nformally, let’s number rows 1 to 2 from top to bottom, and columns 1 to\r\nn from left to right. Also, let’s denote a cell in row x and column y as\r\n(x, y). We consider cells (x_1, y_1) and (x_2, y_2) neighboring if\r\n|x_1 - x_2| + |y_1 - y_2| = 1.Alice doesn’t like the way in which the\r\ncells are currently arranged, so she came up with her own arrangement,\r\nwith which she wants to gift the puzzle to Ibragim. Since you are her\r\nsmartest friend, she asked you to help her find the minimal possible\r\nnumber of operations in which she can get the desired arrangement. Find\r\nthis number, or determine that it’s not possible to get the new\r\narrangement.\r\n",
    "solutions": [
        "/*\n\n_/      _/       _/_/_/      _/      _/    _/           _/_/_/_/_/\n _/    _/      _/      _/     _/    _/     _/           _/\n  _/  _/      _/               _/  _/      _/           _/\n   _/_/       _/                 _/        _/           _/_/_/_/\n  _/  _/      _/                 _/        _/           _/\n _/    _/      _/      _/        _/        _/           _/\n_/      _/       _/_/_/          _/        _/_/_/_/_/   _/_/_/_/_/\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ru(i, l, r) for (int i = (l); i <= (r); i++)\n#define rd(i, r, l) for (int i = (r); i >= (l); i--)\n#define mid ((l + r) >> 1)\n#define maxn 200005\nusing namespace std;\ninline int read()\n{\n\tint x = 0, w = 0; char ch = getchar();\n\twhile(!isdigit(ch)) {w |= ch == '-'; ch = getchar();}\n\twhile(isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}\n\treturn w ? -x : x;\n}\nint n, a[2][maxn];\nint main()\n{\n\tn = read();\n\tru(i, 0, 1) ru(j, 1, n) a[i][j] += read();\n\tru(i, 0, 1) ru(j, 1, n) a[i][j] -= read();\n\tint cnt[2] = {0, 0}; ll ans = 0;\n\tru(i, 1, n)\n\t{\n\t\tans += abs(cnt[0] + cnt[1]);\n\t\tru(j, 0, 1) cnt[j] += a[j][i];\n\t\tif((ll)cnt[0] * cnt[1] < 0)\n\t\t{\n\t\t\tans += min(abs(cnt[0]), abs(cnt[1]));\n\t\t\tif(abs(cnt[0]) > abs(cnt[1]))\n\t\t\t{\n\t\t\t\tcnt[0] += cnt[1];\n\t\t\t\tcnt[1] = 0;\n\t\t\t}\n\t\t\telse cnt[1] += cnt[0], cnt[0] = 0;\n\t\t}\n\t}\n\tif(cnt[0] != 0 || cnt[1] != 0) printf(\"-1\");\n\telse printf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Puzzle.json",
    "editorial_link": "https://codeforces.com//blog/entry/103978",
    "editorial": "We are asked to find a minimum cost perfect matching between âs in the\r\nmatrices, where the cost between and is . Notice that the answer exists\r\nonly if the number of âs is equal in both matrices. Consider that this\r\nis the case.Notice that every either stays in its original row or\r\nchanges it in a single operation. For simplicity letâs assume that all\r\noperations of that kind are performed in the beginning. Letâs denote as\r\nthe difference between the -th prefix sum in -th row of the matrices. If\r\nthe final row for each is fixed, then the answer is equal to , where in\r\nthe number of âs that changed its row.Now letâs look at what happens\r\nwhen we change the row of a . For simplicity letâs assume that it was in\r\na cell . Then after the swap we have to increment by , decrement all by\r\n, and increment all by .Now letâs solve the following problem: we are\r\ngiven and and in one operation we can increment some suffix by and\r\ndecrement the same suffix in the other array by . The goal is to\r\nminimize .Notice that the following greedy algorithm works: iterate\r\nthrough columns from left to right and while and have different signs,\r\ndecrement the suffix of one thatâs greater and increment suffix of one\r\nthatâs lower.Now letâs prove that this algorithm minimizes the target\r\nsum. For this consider some optimal sequence of operations. It doesnât\r\nmatter in which order operations are performed, so letâs assume they are\r\nperformed from left to right, and are accumulated in a single element\r\nfor the same suffix. If the sequences differ, denote as the first such\r\nposition. Note that before that all and are the same in both our answer\r\nand the optimal one. Suppose that in the optimal answer we incremented\r\n-th suffix of by and decremented -th suffix of by . Then the target sum\r\nwill increase by .Consider the following cases: and or and . By triangle\r\ninequality , which means that those operations could be performed on the\r\n-st suffix and that wouldnât increase the answer. and . Here if , ,\r\nwhich means that those operations could be performed on the -st suffix\r\nand that wouldnât increase the answer. Now if . We can assume that ,\r\notherwise we will perform an operation on values with the same sign,\r\nwhich we already shown can be done later on. Then . Greedy algorithm\r\nsuggests doing exactly operations. Note that if we perform operations on\r\nsuffix and operations on suffix , we will add to the answer and get the\r\nsame state as the optimal answer. This means that we can do operations\r\nand not increase the answer. and . This case can be analyzed in the same\r\nway. What we showed here is that we can always extend the matching\r\nprefix with the optimal answer, which means that the greedy algorithm\r\nproduces the same answer.Letâs come back to the original problem.\r\nDescribed greedy algorithm finds a lower bound on the answer. Letâs show\r\nthat it is always possible to achieve it when the operations are allowed\r\nonly for moving âs between rows and the number of s in each row at the\r\nend should be the same. For this note that we can \"perform\" operations\r\non âs from the second matrix, if we reverse their order and append to\r\nthe end of the sequence for the first matrix. Now note that if on some\r\nprefix and have the same sign, but on prefix the signs differ, there has\r\nto be at least a single in column , and we can perform the operation\r\nsuggested by the greedy algorithm. Finally, if the answer exists it is\r\ntrue that , and if and have the same sign at the end this means that\r\nthey are both , which means that the constructed answer is correct.This\r\nsolution works in time.\r\n",
    "hint": []
}