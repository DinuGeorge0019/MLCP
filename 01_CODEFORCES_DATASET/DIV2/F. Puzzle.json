{"link": "https://codeforces.com//contest/1700/problem/F", "problemId": "1433687", "problem_idx": "F", "shortId": "1700F", "contest_number": "1700", "problem_submissions": {"F": [161204184, 161175037, 161206125, 161212939, 161208920, 161208613, 161221499, 161209546], "E": [161198687, 161196286, 161355967, 161718414, 161625123, 161210058, 161186427, 161205675, 161211460, 161212251, 161209815, 161226432, 161215179, 161212687, 161209759, 161208133, 161212427], "D": [161181899, 161187142, 161172748, 161191235, 161182477, 161193166, 161184771, 161194388, 161383056, 161196489, 161188119, 161188891, 161183798, 161190373, 161201766, 161189358, 161191653, 161196390, 161376237, 161189700, 161191427], "C": [161179311, 161183541, 161180380, 161184212, 161718390, 161184885, 161181511, 161178526, 161188654, 161193034, 161183225, 161183002, 161175389, 161193124, 161191878, 161177816, 161183179, 161187003, 161183522, 161177845], "B": [161174411, 161180612, 161180415, 161180363, 161174680, 161179087, 161174700, 161180026, 161190959, 161175925, 161173974, 161173339, 161174147, 161181560, 161181382, 161172925, 161174110], "A": [161167944, 161176736, 161168168, 161168440, 161176515, 161168925, 161168213, 161168654, 161187609, 161168766, 161168663, 161168483, 161168047, 161169513, 161168007, 161168296, 161173279, 161168814, 161167994]}, "name": "F. Puzzle", "statement": "Pupils Alice and Ibragim are best friends. It\u2019s Ibragim\u2019s birthday soon,\r\nso Alice decided to gift him a new puzzle. The puzzle can be represented\r\nas a matrix with 2 rows and n columns, every element of which is either\r\n0 or 1. In one move you can swap two values in neighboring cells.More\r\nformally, let\u2019s number rows 1 to 2 from top to bottom, and columns 1 to\r\nn from left to right. Also, let\u2019s denote a cell in row x and column y as\r\n(x, y). We consider cells (x_1, y_1) and (x_2, y_2) neighboring if\r\n|x_1 - x_2| + |y_1 - y_2| = 1.Alice doesn\u2019t like the way in which the\r\ncells are currently arranged, so she came up with her own arrangement,\r\nwith which she wants to gift the puzzle to Ibragim. Since you are her\r\nsmartest friend, she asked you to help her find the minimal possible\r\nnumber of operations in which she can get the desired arrangement. Find\r\nthis number, or determine that it\u2019s not possible to get the new\r\narrangement.\r\n", "solutions": ["/*\n\n_/      _/       _/_/_/      _/      _/    _/           _/_/_/_/_/\n _/    _/      _/      _/     _/    _/     _/           _/\n  _/  _/      _/               _/  _/      _/           _/\n   _/_/       _/                 _/        _/           _/_/_/_/\n  _/  _/      _/                 _/        _/           _/\n _/    _/      _/      _/        _/        _/           _/\n_/      _/       _/_/_/          _/        _/_/_/_/_/   _/_/_/_/_/\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ru(i, l, r) for (int i = (l); i <= (r); i++)\n#define rd(i, r, l) for (int i = (r); i >= (l); i--)\n#define mid ((l + r) >> 1)\n#define maxn 200005\nusing namespace std;\ninline int read()\n{\n\tint x = 0, w = 0; char ch = getchar();\n\twhile(!isdigit(ch)) {w |= ch == '-'; ch = getchar();}\n\twhile(isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}\n\treturn w ? -x : x;\n}\nint n, a[2][maxn];\nint main()\n{\n\tn = read();\n\tru(i, 0, 1) ru(j, 1, n) a[i][j] += read();\n\tru(i, 0, 1) ru(j, 1, n) a[i][j] -= read();\n\tint cnt[2] = {0, 0}; ll ans = 0;\n\tru(i, 1, n)\n\t{\n\t\tans += abs(cnt[0] + cnt[1]);\n\t\tru(j, 0, 1) cnt[j] += a[j][i];\n\t\tif((ll)cnt[0] * cnt[1] < 0)\n\t\t{\n\t\t\tans += min(abs(cnt[0]), abs(cnt[1]));\n\t\t\tif(abs(cnt[0]) > abs(cnt[1]))\n\t\t\t{\n\t\t\t\tcnt[0] += cnt[1];\n\t\t\t\tcnt[1] = 0;\n\t\t\t}\n\t\t\telse cnt[1] += cnt[0], cnt[0] = 0;\n\t\t}\n\t}\n\tif(cnt[0] != 0 || cnt[1] != 0) printf(\"-1\");\n\telse printf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "greedy"], "dificulty": "2600", "interactive": false}