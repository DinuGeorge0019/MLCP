{
    "link": "https://codeforces.com//contest/92/problem/E",
    "problemId": "486",
    "problem_idx": "E",
    "shortId": "92E",
    "contest_number": "92",
    "problem_submissions": {
        "E": [
            502340,
            502235,
            503231,
            503523,
            502875,
            1934622,
            504390,
            504399
        ],
        "D": [
            501536,
            501225,
            500880,
            502434,
            501591,
            501746,
            502190,
            500876,
            502107,
            1934547,
            501066,
            502802,
            501866,
            502445,
            503569,
            502507,
            502093,
            502285,
            502239
        ],
        "C": [
            500714,
            501838,
            501748,
            501346,
            502515,
            500790,
            501606,
            500378,
            501102,
            1934749,
            500620,
            501744,
            501022,
            501650,
            501493,
            501780,
            501873,
            501256,
            501229
        ],
        "B": [
            500032,
            502068,
            499811,
            499879,
            500650,
            499787,
            500445,
            499339,
            500204,
            1934408,
            499909,
            500192,
            500246,
            500348,
            500291,
            502825,
            500705,
            500227,
            499923
        ],
        "A": [
            499184,
            499077,
            498989,
            499217,
            499137,
            499006,
            499104,
            498985,
            498993,
            1934380,
            499022,
            499009,
            499187,
            499279,
            499007,
            503011,
            499075,
            499110,
            498994
        ]
    },
    "name": "E. Ski Base",
    "statement": "A ski base is planned to be built in Walrusland. Recently, however, the\r\nproject is still in the constructing phase. A large land lot was chosen\r\nfor the construction. It contains ski junctions, numbered from to .\r\nInitially the junctions aren’t connected in any way.In the constructing\r\nprocess bidirectional ski roads will be built. The roads are built one\r\nafter another: first the road number will be built, then the road number\r\n, and so on. The -th road connects the junctions with numbers and . is\r\nthe route with the following properties: The route is closed, that is,\r\nit begins and ends in one and the same junction. The route contains at\r\nleast one road. The route doesn’t go on one road more than once, however\r\nit can visit any junction any number of times. Let’s consider the as a\r\nnon-empty set of roads that can be divided into one or more tracks so\r\nthat exactly one track went along each road of the chosen set. Besides,\r\neach track can consist only of roads from the chosen set. Ski base\r\ndoesn’t have to be connected.Two ski bases are considered different if\r\nthey consist of different road sets.After building each new road the\r\nWalrusland government wants to know the number of variants of choosing a\r\nski base based on some subset of the already built roads. The government\r\nasks you to help them solve the given problem.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n//\ntypedef long long LL;\ntypedef pair<int,int> PII;\n#define MP make_pair\n#define VI vector<int>\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SIZE(x) (int)x.size()\n#define ALL(c) c.begin(),c.end()\n//\n#define rep(i,b) for(int i=(0);i<(b);++i)\n#define fo(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define fore(a,b) for(__typeof((b).begin()) a = (b).begin();a!=(b).end();++a)\n#define vv vector\n#define pb push_back\n#define ll long long\n#define ld long double\n#define ss(a) (int)(a).size()\n#define all(x) (x).begin(),(x).end()\n#define clr(x,a) memset(x,a,sizeof(x))\n#define vi vv<int>\n#define vs vv<string>\ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}\n\nint cond = (ll)1;\n#define db(x) { if (cond > 0) { cond--; rep (xxx, 1) cerr << __LINE__ << \" \" << #x << \" \" << x << endl; cerr.flush(); } }\n\n\n// 3180 icpclive\n// regular veresion\nstruct fus {\n    int sz;\n    int *pa;\n    fus (int sz_) {\n        sz = sz_;\n        pa = new int [sz];\n        rep (i, sz) pa[i] = i;\n    }\n\n    int parent(int i) {\n        if (pa[i] == i) return i; else return pa[i] = parent(pa[i]);\n    }\n\n    void join(int a, int b) {\n        pa[parent(a)] = parent(b);\n    }\n\n    bool is_joined(int a, int b) { return parent(a) == parent(b); }\n};\n\nvoid _main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    fus zbior(n);\n    int mod = (int)1e9+9;\n    int ret = 1;\n    rep (i, m) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--;b--;\n        if (zbior.is_joined(a, b)) {\n            ret = (ret * 2) % mod;\n        }\n        zbior.join(a,b);\n        if (ret == 0) printf(\"%d\\n\", mod-1);\n        else printf(\"%d\\n\", ret - 1);\n    }\n}\n\nint main(int argc, char ** argv) {\n    string p = \"../gcj/source/\" + string(\"\") + argv[0][strlen(argv[0])-1];\n//    if (argc >= 2 && strcmp(argv[1], \"q\") != 0) { freopen(argv[1],\"r\",stdin);}\n\n    rep (i, argc) if (strcmp(argv[i], \"1n\") == 0) { freopen(\"1.in\",\"r\",stdin);}\n    rep (i, argc) if (strcmp(argv[i], \"2n\") == 0) { freopen(\"2.in\",\"r\",stdin);}\n    rep (i, argc) if (strcmp(argv[i], \"3n\") == 0) { freopen(\"3.in\",\"r\",stdin);}\n    rep (i, argc) if (strcmp(argv[i], \"4n\") == 0) { freopen(\"4.in\",\"r\",stdin);}\n    rep (i, argc) if (strcmp(argv[i], \"5n\") == 0) { freopen(\"5.in\",\"r\",stdin);}\n\n    rep (i, argc) if (strcmp(argv[i], \"s0\") == 0) { freopen((p + \"-small-0.in\").c_str(),\"r\",stdin);freopen((p + \"-small-0.out\").c_str(),\"w\",stdout); }\n    rep (i, argc) if (strcmp(argv[i], \"s1\") == 0) { freopen((p + \"-small-1.in\").c_str(),\"r\",stdin);freopen((p + \"-small-1.out\").c_str(),\"w\",stdout); }\n    rep (i, argc) if (strcmp(argv[i], \"s2\") == 0) { freopen((p + \"-small-2.in\").c_str(),\"r\",stdin);freopen((p + \"-small-2.out\").c_str(),\"w\",stdout); }\n    rep (i, argc) if (strcmp(argv[i], \"l0\") == 0) { freopen((p + \"-large-0.in\").c_str(),\"r\",stdin);freopen((p + \"-large-0.out\").c_str(),\"w\",stdout); }\n    rep (i, argc) if (strcmp(argv[i], \"q\") == 0) cond = 1 << 30;\n    _main();\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "graphs"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Ski Base.json",
    "editorial_link": "https://codeforces.com//blog/entry/2182",
    "editorial": "We will count the number of ski bases including the base consisted of empty subset of edges (before printing just subtract one). In the beginning the number of bases is equal to 1. If we connect vertexes in the same connected components then the result should be multiplied by 2 else do nothing. You should use DJS data structure to know information about connected components where vertexes are and to unite them.\n\nWhy is it correct?\nTo prove it we will use the matrix of incidence I, rows in it will be edges and columns will be vertexes. Let's define xor of two rows. Xor of two rows a ? b will be row c such that ci?=?ai xor bi. Notice if  xor of some subset of rows is equal to a zero row then this subset form the ski base. It's correct because, the degree of contiguity of every vertex is even, so we can form an Euler cycle in every connected component. The answer is  2(m?-?rank(I)). \n\nWhy it is correct? Let's write the number of edge from the right of each row which suit this row. While finding the matrix rank using gauss method with xor operation, we will xor the subsets from the right of the strings. In the end the subsets of edges written from the right of the zero rows will form the basis of the linear space. Thats why we can take any subset of vectors from basis and make up a new ski base. The number of these subsets is equal to 2k = 2(m?-?rank(I)), where k is the number of zero rows.\n\n\nThe last thing we should notice that the adding row is liner depended if and only if there is exist a way between the vertexes a and b (a and b are the ends of the adding edge).",
    "hint": []
}