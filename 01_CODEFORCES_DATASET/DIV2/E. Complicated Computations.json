{
    "link": "https://codeforces.com//contest/1436/problem/E",
    "problemId": "772600",
    "problem_idx": "E",
    "shortId": "1436E",
    "contest_number": "1436",
    "problem_submissions": {
        "D": [
            244333966,
            96574214,
            96571456,
            96558532,
            96571048,
            96571994,
            96563376,
            96571151,
            96576643,
            96574299,
            96567342,
            96567085,
            96573866,
            96576086,
            96577575,
            96562284,
            96570394,
            96578043,
            96575753
        ],
        "F": [
            240918218,
            96566504,
            96572912,
            96753174
        ],
        "E": [
            96592979,
            96584648,
            96574218,
            96584890,
            96586188,
            96585819,
            96587447,
            96587153,
            96585609,
            96587917,
            96588463,
            96591240,
            96584846,
            96586193,
            96587617,
            96587454,
            96590850,
            96588483,
            96583371
        ],
        "C": [
            96570072,
            96563215,
            96588737,
            96565809,
            96564790,
            96575488,
            96583604,
            96564799,
            96558226,
            96553282,
            96572718,
            96560930,
            96568810,
            96563409,
            96560716,
            96573151,
            96560791,
            96559882,
            96576285
        ],
        "B": [
            96563722,
            96545744,
            96546426,
            96547973,
            96548924,
            96541502,
            96573998,
            96558603,
            96548113,
            96541622,
            96546010,
            96548513,
            96563296,
            96545652,
            96541454,
            96544953,
            96544692,
            96543086,
            96559069
        ],
        "A": [
            96538154,
            96541957,
            96536078,
            96536651,
            96535505,
            96535718,
            96541514,
            96539181,
            96535535,
            96535532,
            96537279,
            96538197,
            96541879,
            96569353,
            96561847,
            96535411,
            96538782,
            96535867,
            96538910
        ]
    },
    "name": "E. Complicated Computations",
    "statement": "In this problem MEX of a certain array is the smallest integer not\r\ncontained in this array.Everyone knows this definition, including Lesha.\r\nBut Lesha loves MEX, so he comes up with a new problem involving MEX\r\nevery day, including today.You are given an array a of length n. Lesha\r\nconsiders all the subarrays of the initial array and computes MEX for\r\neach of them. Then Lesha computes MEX of the obtained numbers.An array b\r\nis a subarray of an array a, if b can be obtained from a by deletion of\r\nseveral (possible none or all) elements from the beginning and several\r\n(possibly none or all) elements from the end. In particular, an array is\r\na subarray of itself.Lesha understands that the problem is very\r\ninteresting this time, but he doesn’t know how to solve it. Help him and\r\nfind the MEX of MEXes of all the subarrays!\r\n",
    "solutions": [
        "//#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n//#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"debug-template.hpp\"\n#endif\n\nusing namespace std;\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tvector<int> a(n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tvector<int> last(n + 2), mex(n + 2);\n\tint N = 1;\n\twhile (N <= n + 2) {\n\t\tN *= 2;\n\t}\n\tvector<int> d(N + N);\n\tauto update = [&](int u, int x) {\n\t\td[u += N] = x;\n\t\tfor (u >>= 1; u; u >>= 1) {\n\t\t\td[u] = min(d[u + u], d[u + u + 1]);\n\t\t}\n\t};\n\tauto query = [&](int l, int r) {\n\t\tl += N, r += N + 1;\n\t\tint ret = 1e9;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) {\n\t\t\t\tret = min(ret, d[l]);\n\t\t\t}\n\t\t\tif (r & 1) {\n\t\t\t\tret = min(ret, d[r - 1]);\n\t\t\t}\n\t\t\tl = l + 1 >> 1, r >>= 1;\n\t\t}\n\t\treturn ret;\n\t};\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i] == 1) {\n\t\t\tif (last[1] + 1 < i) {\n\t\t\t\tmex[1] = 1;\n\t\t\t}\n\t\t} else if (query(1, a[i] - 1) > last[a[i]]) {\n\t\t\tmex[a[i]] = 1;\n\t\t}\n\t\tlast[a[i]] = i;\n\t\tupdate(a[i], i);\n\t}\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tif (mex[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tif (last[i] < n) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (query(1, i - 1) > last[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tcout << i << endl;\n\t\treturn 0;\n\t}\n\tcout << n + 2 << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Complicated Computations.json",
    "editorial_link": "https://codeforces.com//blog/entry/84024",
    "editorial": "Letâs iterate over the answer. Let the current answer be , then we can\r\nget it only when there are no subarrays, whose MEX is . Note that we\r\nneed to check the MEX of the subarrays that are between all occurrences\r\nof . This can be done, for example, using a segment tree, processing its\r\noccurrences in order. A number for which MEX is not found will be the\r\nanswer.\r\n",
    "hint": []
}