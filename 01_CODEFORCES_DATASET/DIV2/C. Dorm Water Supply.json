{
    "link": "https://codeforces.com//contest/108/problem/C",
    "problemId": "569",
    "problem_idx": "C",
    "shortId": "108C",
    "contest_number": "108",
    "problem_submissions": {
        "D": [
            631152,
            630566,
            631699,
            633125,
            632252,
            630736,
            631399,
            630814,
            631533,
            630518,
            631851,
            632455,
            631854,
            632380,
            632591,
            632622
        ],
        "C": [
            629180,
            629868,
            629472,
            629971,
            635740,
            630685,
            688399,
            631427,
            630137,
            631303,
            628693,
            629432,
            630403,
            630647,
            631107,
            630964,
            630765,
            630940
        ],
        "B": [
            628051,
            628449,
            68305499,
            628675,
            632122,
            628702,
            627917,
            628889,
            628448,
            630178,
            632188,
            628860,
            628600,
            628771,
            628618,
            629621,
            629072
        ],
        "A": [
            627480,
            627844,
            627421,
            627636,
            631848,
            627468,
            627396,
            627555,
            627512,
            629270,
            627646,
            627419,
            627496,
            627622,
            632729,
            627875,
            627538
        ],
        "E": [
            631664,
            641028
        ]
    },
    "name": "C. Dorm Water Supply",
    "statement": "The German University in Cairo (GUC) dorm houses are numbered from to .\r\nUnderground water pipes connect these houses together. Each pipe has\r\ncertain direction (water can flow only in this direction and not vice\r\nversa), and diameter (which characterizes the maximal amount of water it\r\ncan handle).For each house, there is at most one pipe going into it and\r\nat most one pipe going out of it. With the new semester starting, GUC\r\nstudent and dorm resident, Lulu, wants to install tanks and taps at the\r\ndorms. For every house with an outgoing water pipe and without an\r\nincoming water pipe, Lulu should install a water tank at that house. For\r\nevery house with an incoming water pipe and without an outgoing water\r\npipe, Lulu should install a water tap at that house. Each tank house\r\nwill convey water to all houses that have a sequence of pipes from the\r\ntank to it. Accordingly, each tap house will receive water originating\r\nfrom some tank house.In order to avoid pipes from bursting one week\r\nlater (like what happened last semester), Lulu also has to consider the\r\ndiameter of the pipes. The amount of water each tank conveys should not\r\nexceed the diameter of the pipes connecting a tank to its corresponding\r\ntap. Lulu wants to find the maximal amount of water that can be safely\r\nconveyed from each tank to its corresponding tap.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n\nusing namespace std;\n\nconst int MAX=1005, inf=1000000000;\nint N,P; \nint next[MAX], prev[MAX], dist[MAX];\n\nstruct flow{\n    int s,e,f;\n};\n\nvector<flow > ans;\n\nvoid solve(int a){\n    int maxcap=inf;\n    int cur=a;\n    while(next[cur]!=-1){\n\tmaxcap=min(maxcap,dist[cur]);\n\tcur=next[cur];\n    }\n    flow g;\n    g.s=a+1; g.e=cur+1; g.f=maxcap;\n    ans.push_back(g);\n}\n\nint main(){\n    cin >> N >> P; \n    for(int i=0; i<N; i++){\n\tnext[i]=prev[i]=-1;\n\tdist[i]=inf;\n    }\n    for(int i=0; i<P; i++){\n\tint a,b,d; cin >> a >> b >> d;\n\ta--; b--;\n\tnext[a]=b; prev[b]=a;\n\tdist[a]=d;\n    }\n    for(int i=0; i<N; i++){\n\tif(prev[i]==-1 and next[i]!=-1){\n\t    solve(i);\n\t}\n    }\n    cout << ans.size() << endl;\n    for(int i=0; i<ans.size(); i++){\n\tcout << ans[i].s << \" \" << ans[i].e << \" \" << ans[i].f << endl;\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Dorm Water Supply.json",
    "editorial_link": "https://codeforces.com//blog/entry/2514",
    "editorial": "The problem describes a graph of houses as nodes and one-way pipes as edges. The problem states that the graph will contain 1 or more chains of nodes. The required is to find the start and end of every chain (consisting of more than 1 node, which caused many hacks). The other requirement was to find the weakest edge in each of the chains. This can be done by traversing (using Depth-First Search (DFS) for example) the graph from each un-visited node with no incoming edges. These nodes are the start of a chain. By keeping track of the minimum diameter so far, whenever the DFS reaches a node with no outgoing edges, it means that this node is the end of the current chain. After storing, in a list or vector, the tuples (start,?end,?minimum diameter), we sort these tuples by start index and print.",
    "hint": []
}