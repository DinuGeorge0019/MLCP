{"link": "https://codeforces.com//contest/294/problem/E", "problemId": "2810", "problem_idx": "E", "shortId": "294E", "contest_number": "294", "problem_submissions": {"D": [3489455, 3490392], "E": [3487299, 3487883, 3488957, 3485802, 3487525, 3494240, 3497332, 3493600, 3489972], "C": [3486147, 3485304, 3486088, 3488625, 3489289, 3484703, 3483687, 3487009, 3485239, 3485635, 3486050, 3485757, 3485793, 3486458, 3486345, 3485667, 3486505, 3486019], "A": [3482812, 3482475, 3482613, 3488228, 3482534, 3482882, 3482485, 3482654, 3482539, 3482697, 3482561, 3482633, 3483083, 3483097, 3483409, 3482585, 3483087, 3482816], "B": [3483440, 3483787, 3487702, 3490250, 3483629, 3484145, 3483917, 3483569, 3484549, 3484018, 3484016, 3483940, 3484588, 3484893, 3483567, 3484832, 3485008]}, "name": "E. Shaass the Great", "statement": "The great Shaass is the new king of the Drakht empire. The empire has\r\ncities which are connected by bidirectional roads. Each road has an\r\nspecific length and connects a pair of cities. There\u2019s a unique simple\r\npath connecting each pair of cities.His majesty the great Shaass has\r\ndecided to tear down one of the roads and build another road with the\r\nsame length between some pair of cities. He should build such road that\r\nit\u2019s still possible to travel from each city to any other city. He might\r\nbuild the same road again.You as his advisor should help him to find a\r\nway to make the described action. You should find the way that minimize\r\nthe total sum of pairwise distances between cities after the action. So\r\ncalculate the minimum sum.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nstruct Edge\n{\n    int from, to, len, next;\n}edge[4999 * 2];\nint head[5000], L;\nvoid init(int n)\n{\n    memset(head, -1, 4 * n);\n    L = 0;\n}\nvoid add_edge(int u, int v, int len)\n{\n    edge[L].from = u;\n    edge[L].to = v;\n    edge[L].len = len;\n    edge[L].next = head[u];\n    head[u] = L++;\n}\nint size[5000];\nlong long dp[5000];\nvoid dfs(int u, int fu)\n{\n    size[u] = 1;\n    dp[u] = 0;\n    for (int i = head[u]; i != -1; i = edge[i].next)\n    {\n        int v = edge[i].to;\n        if (v == fu)\n            continue;\n        dfs(v, u);\n        size[u] += size[v];\n        dp[u] += dp[v] + (long long)size[v] * edge[i].len;\n    }\n}\nlong long sum, tot;\nint m;\nvoid dfs2(int u, int fu)\n{\n    sum = min(sum, dp[u]);\n    for (int i = head[u]; i != -1; i = edge[i].next)\n    {\n        int v = edge[i].to;\n        if (v == fu)\n            continue;\n        tot += (long long)(m - size[v]) * size[v] * edge[i].len;\n        dp[v] = dp[u] + (long long)(m - size[v] * 2) * edge[i].len;\n        dfs2(v, u);\n    }\n}\nconst long long inf = 0x7f7f7f7f7f7f7f7fLL;\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    init(n);\n    for (int i = 1; i < n; ++i)\n    {\n        int u, v, len;\n        scanf(\"%d%d%d\", &u, &v, &len);\n        add_edge(--u, --v, len);\n        add_edge(v, u, len);\n    }\n    long long ans = inf;\n    for (int i = 0; i < n * 2 - 2; i += 2)\n    {\n//      edge[i].flag = edge[i ^ 1].flag = 1;\n        tot = 0;\n        sum = inf;\n        dfs(edge[i].from, edge[i].to);\n        m = size[edge[i].from];\n        dfs2(edge[i].from, edge[i].to);\n        tot += (long long)(n - m) * sum;\n        sum = inf;\n        dfs(edge[i].to, edge[i].from);\n        m = size[edge[i].to];\n        dfs2(edge[i].to, edge[i].from);\n        tot += (long long)(n - m) * sum;\n        tot += (long long)m * (n - m) * edge[i].len;\n        ans = min(tot, ans);\n//      edge[i].flag = edge[i ^ 1].flag = 0;\n    }\n    printf(\"%I64d\\n\", ans);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "trees"], "dificulty": "2300", "interactive": false}