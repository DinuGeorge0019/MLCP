{
    "link": "https://codeforces.com//contest/466/problem/C",
    "problemId": "13619",
    "problem_idx": "C",
    "shortId": "466C",
    "contest_number": "466",
    "problem_submissions": {
        "E": [
            7763666,
            7769585,
            7768735,
            7765359,
            7770616,
            7766927,
            7769884,
            7936642,
            7936570,
            7804886
        ],
        "D": [
            7760155,
            7763392,
            7765904,
            7759889,
            7764966,
            7764929,
            7766580,
            7764380,
            7763942,
            7761240,
            7768596,
            7764705,
            7771255,
            7771465,
            7770057,
            7768205,
            7768615,
            7771047
        ],
        "C": [
            7757835,
            7757048,
            7761148,
            7755629,
            7761932,
            7754727,
            7758439,
            7760456,
            7753794,
            7759346,
            7760630,
            7760707,
            7767525,
            7760730,
            7766019,
            7761785,
            7755926,
            7763063
        ],
        "B": [
            7756023,
            7760247,
            7761532,
            7779459,
            7760026,
            7758357,
            7756812,
            7758808,
            7762686,
            7763357,
            7765778,
            7757733,
            7758154,
            7761303,
            7770307,
            7779355,
            7764832
        ],
        "A": [
            7753709,
            7753409,
            7756375,
            7767138,
            7753599,
            7759314,
            7753051,
            7754371,
            7755884,
            7753912,
            7754692,
            7753400,
            7753875,
            7756172,
            7753401,
            7753155,
            7754269
        ]
    },
    "name": "C. Number of Ways",
    "statement": "Youâ€™ve got array , consisting of integers. Count the number of ways to\r\nsplit all the elements of the array into three contiguous parts so that\r\nthe sum of elements in each part is the same. More formally, you need to\r\nfind the number of such pairs of indices , that .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MAXN 500005\n#define INF 0x7fffffffffffffffLL\nusing namespace std ;\ntypedef long long LL ;\n\nmap<LL, LL> have[4] ;\nLL dp[MAXN][4] ;\nLL p[MAXN], sum[MAXN] ;\nint N ;\n\nint main()\n{\n\tint i, j ;\n\tscanf(\"%d\", &N) ;\n\tfor(i = 1; i <= N; i ++)\n\t\tscanf(\"%I64d\", &p[i]), sum[i] = sum[i-1]+p[i] ;\n\tfor(i = 1; i <= N; i ++)\n\t{\n\t\tdp[i][1] = 1 ;\n\t\tif(sum[i]%2 == 0) dp[i][2] = have[1][sum[i]/2] ;\n\t\tif(sum[i]%3 == 0) dp[i][3] = have[2][sum[i]/3] ;\n\t\thave[1][sum[i]] ++ ;\n\t\tif(sum[i]%2 == 0) have[2][sum[i]/2] += dp[i][2] ;\n\t\tif(sum[i]%3 == 0) have[3][sum[i]/3] += dp[i][3] ;\n\t}\n\tprintf(\"%I64d\\n\", dp[N][3]) ;\n\t//system(\"pause\") ;\n\treturn 0 ;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Number of Ways.json",
    "editorial_link": "https://codeforces.com//blog/entry/13758",
    "editorial": "First of all, notice that if sum of all elements is equal then sum of\r\neach of three parts is equal . Therefore, if is not divided by then\r\nanswer is . Otherwise, let s iterate the end of first part () and if sum\r\nof 1..i elements is equal then it means that we have to add to the\r\nanswer the amount of such () that the sum of elements from -th to -tn\r\nalso equals . Let s create an array cnt[], where equals 1, if the sum of\r\nelements from -th to -th equals and 0 otherwise. Now, to calculate the\r\nanswer we have to find the sum cnt[j] + cnt[j+1] + ... + cnt[n] faster\r\nthen O(n). There are a lot of required ways to do this, but the easiest\r\none is to create a new additional array sums[] where in -th element will\r\nbe cnt[j] + cnt[j+1] + ... + cnt[n]. It is easy to calculate in such\r\nway: sums[n] = cnt[n], sums[i] = sums[i+1] + cnt[i] (i < n). Thus, we\r\nreceive very simple solution: for each prefix of initial array 1..i with\r\nthe sum that equals we need to add to the answer sums[i+2]. Complexity:\r\nSolution: 7784781\r\n",
    "hint": []
}