{"link": "https://codeforces.com//contest/35/problem/C", "problemId": "166", "problem_idx": "C", "shortId": "35C", "contest_number": "35", "problem_submissions": {"E": [154745, 154634, 155001, 155046, 155106, 155283, 155729], "D": [154342, 154272, 154130, 154311, 153835, 155440, 154204, 154250, 154067, 154477, 154655, 154659, 154763, 154771, 153757, 154608], "C": [154062, 153916, 153821, 154057, 153649, 155441, 153981, 153912, 153668, 154279, 154275, 154526, 154222, 154207, 153616, 154747], "B": [153817, 153677, 154472, 153724, 155455, 153704, 154027, 154569, 154040, 154009, 154129, 154473, 154591, 155725, 154964], "A": [153493, 153454, 153281, 153341, 153328, 153676, 153548, 153463, 154008, 153336, 154158, 154206, 153882, 153410, 154421]}, "name": "C. Fire Again", "statement": "After a terrifying forest fire in Berland a forest rebirth program was\r\ncarried out. Due to it rows with trees each were planted and the rows\r\nwere so neat that one could map it on a system of coordinates so that\r\nthe -th tree in the -th row would have the coordinates of . However a\r\nterrible thing happened and the young forest caught fire. Now we must\r\nfind the coordinates of the tree that will catch fire last to plan\r\nevacuation.The burning began in points simultaneously, which means that\r\ninitially trees started to burn. Every minute the fire gets from the\r\nburning trees to the ones that aren t burning and that the distance from\r\nthem to the nearest burning tree equals to 1.Find the tree that will be\r\nthe last to start burning. If there are several such trees, output any.\r\n", "solutions": ["#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\nbool used[2001][2001];\n\nint dirx[] = {-1,+1, 0, 0};\nint diry[] = { 0, 0,-1,+1};\nint dirlen = sizeof(dirx)/sizeof(int);\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    int N, M, K;\n    scanf(\"%d%d%d\", &N, &M, &K);\n    memset(used, false, sizeof(used));\n    queue<PII> q;\n    PII last;\n    for(int i=0; i<K; i++){\n        int xi, yi;\n        scanf(\"%d%d\", &xi, &yi);\n        used[xi][yi] = true;\n        q.push(make_pair(xi, yi));\n    }\n    while (!q.empty()){\n        PII c = q.front(); q.pop();\n        last = c;\n        int xi = c.first, yi =c.second;\n        for(int k=0; k<dirlen; k++){\n            int nxi=xi+dirx[k], nyi=yi+diry[k];\n            if (nxi < 1 || nxi > N ||\n                nyi < 1 || nyi > M) continue;\n            if (!used[nxi][nyi]) {\n                q.push(make_pair(nxi, nyi));\n                used[nxi][nyi] = true;\n            }\n        }\n    }\n    printf(\"%d %d\\n\", last.first, last.second);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dfs and similar", "shortest paths"], "dificulty": "1500", "interactive": false}