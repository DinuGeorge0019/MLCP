{
    "link": "https://codeforces.com//contest/834/problem/B",
    "problemId": "116225",
    "problem_idx": "B",
    "shortId": "834B",
    "contest_number": "834",
    "problem_submissions": {
        "A": [
            29008155,
            28994281,
            28993223,
            28993383,
            28993299,
            28998453,
            28993114,
            29004117,
            28996516,
            28993649,
            28993425,
            28992926,
            28993510,
            28995590,
            28994499,
            28992928,
            28997910,
            28993023,
            28993758,
            28994961
        ],
        "B": [
            29006607,
            28994310,
            28996695,
            28995339,
            28995566,
            28997950,
            28994742,
            29001213,
            28994365,
            28997334,
            28993196,
            28996141,
            28998138,
            28998574,
            28996986,
            28993597,
            29001178,
            28994781,
            28995788,
            28998348
        ],
        "D": [
            29003125,
            29012205,
            29010300,
            29010636,
            29106415,
            29106137,
            29011585,
            29009751,
            29011863,
            29014000,
            29030352,
            29012705,
            29015197,
            29012485,
            29012573,
            29017014,
            29013068,
            29016244,
            29027664,
            29015960,
            29015461,
            29013386,
            32498451,
            29017312,
            29015875
        ],
        "C": [
            28993611,
            28993624,
            29000277,
            29001499,
            29003185,
            29003274,
            29002460,
            28995797,
            29001808,
            29003104,
            29004949,
            29000425,
            29000467,
            29008986,
            29000566,
            29367098,
            29002153,
            29002279,
            29005747,
            29003864,
            29006871
        ],
        "E": [
            29044757,
            29044567
        ]
    },
    "name": "B. The Festive Evening",
    "statement": "It’s the end of July the time when a festive evening is held at Jelly\r\nCastle! Guests from all over the kingdom gather here to discuss new\r\ntrends in the world of confectionery. Yet some of the things discussed\r\nhere are not supposed to be disclosed to the general public: the\r\ninformation can cause discord in the kingdom of Sweetland in case it\r\nturns out to reach the wrong hands. So it’s a necessity to not let any\r\nuninvited guests in.There are 26 entrances in Jelly Castle, enumerated\r\nwith uppercase English letters from to . Because of security measures,\r\neach guest is known to be assigned an entrance he should enter the\r\ncastle through. The door of each entrance is opened right before the\r\nfirst guest’s arrival and closed right after the arrival of the last\r\nguest that should enter the castle through this entrance. No two guests\r\ncan enter the castle simultaneously.For an entrance to be protected from\r\npossible intrusion, a candy guard should be assigned to it. There are\r\nsuch guards in the castle, so if there are more than opened doors, one\r\nof them is going to be left unguarded! Notice that a guard can’t leave\r\nhis post until the door he is assigned to is closed.Slastyona had a\r\nsuspicion that there could be uninvited guests at the evening. She knows\r\nthe order in which the invited guests entered the castle, and wants you\r\nto help her check whether there was a moment when more than doors were\r\nopened.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n#define fir first\n#define sec second\n\nint n, k;\nchar a[1000006];\nint s[1000006];\nint L[128];\nint R[128];\n\nint main() {\n\tcin >> n >> k;\n\tscanf(\"%s\", a);\n\t\n\tfor (int i = 0; i < 128; ++i) {\n\t\tL[i] = INT_MAX;\n\t\tR[i] = INT_MIN;\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tL[a[i]] = min(L[a[i]], i);\n\t\tR[a[i]] = max(R[a[i]], i);\n\t}\n\t\n\tfor (int i = 0; i < 128; ++i) if (L[i] != INT_MAX)\n\t\tfor (int j = L[i]; j <= R[i]; ++j)\n\t\t\t++s[j];\n\t\n\tputs(*max_element(s, s + n) <= k ? \"NO\" : \"YES\");\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. The Festive Evening.json",
    "editorial_link": "https://codeforces.com//blog/entry/53567",
    "editorial": "none.This problem is solved with two linear sweeps. In the first one, we\r\ndetermine the last position for each letter. In the second one, we just\r\nmodel the process: we mark the letter as active when we stumble upon it\r\nfor the first time, and as inactive when we reach the last position for\r\nthis letter. If there are more than letters active at some specific\r\npoint of time, we output \"\". Otherwise, we output \"\". .\r\n",
    "hint": []
}