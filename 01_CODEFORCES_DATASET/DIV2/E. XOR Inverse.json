{
    "link": "https://codeforces.com//contest/1417/problem/E",
    "problemId": "740375",
    "problem_idx": "E",
    "shortId": "1417E",
    "contest_number": "1417",
    "problem_submissions": {
        "D": [
            94021013,
            93997987,
            93994414,
            94008928,
            93994813,
            93993974,
            93997393,
            93994886,
            93995533,
            94000707,
            94022056,
            93991179,
            93997856,
            94000293,
            94004446,
            94003381,
            93990919,
            93999146,
            94004809,
            93994289,
            93993273
        ],
        "C": [
            94008586,
            93979621,
            93985626,
            93982539,
            93981622,
            93998363,
            93982359,
            93986555,
            93983202,
            93992239,
            93983337,
            93991411,
            93986598,
            93990140,
            93991651,
            94001522,
            93986870,
            93985359,
            93998445,
            93985761
        ],
        "B": [
            94003048,
            93973490,
            93978330,
            93975968,
            93973585,
            93982217,
            93975658,
            93979313,
            93975689,
            93981775,
            93977350,
            93981714,
            93975469,
            93979278,
            93978354,
            96285430,
            93978356,
            93980291,
            93977440,
            94041345,
            93979236,
            93977870
        ],
        "A": [
            94001724,
            93970294,
            93970800,
            93971885,
            93969936,
            93980954,
            93971325,
            93970349,
            93971917,
            93971289,
            93969984,
            93970972,
            93971064,
            93971068,
            93971066,
            96285403,
            93971270,
            93973889,
            93971400,
            94041333,
            93974793,
            93971921
        ],
        "E": [
            94000180,
            93995718,
            94008025,
            93998585,
            94011058,
            94003165,
            94008902,
            94012205,
            94012202,
            94009571,
            94022535,
            94014181,
            94009089,
            94015399,
            94011955,
            94009323,
            94016150,
            94015958,
            94013413,
            94011012,
            94019762
        ],
        "F": [
            93992993,
            94142204,
            94142122
        ]
    },
    "name": "E. XOR Inverse",
    "statement": "You are given an array a consisting of n non-negative integers. You have\r\nto choose a non-negative integer x and form a new array b of size n\r\naccording to the following rule: for all i from 1 to n, b_i = a_i\r\noplus x (\r\noplus denotes the operation bitwise XOR).An inversion in the b array is\r\na pair of integers i and j such that 1\r\nle i < j\r\nle n and b_i > b_j.You should choose x in such a way that the number of\r\ninversions in b is minimized. If there are several options for x output\r\nthe smallest one.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nll invcnt[32][2];\n\nvoid func(vector<int> &a, int ind){\n\tif(a.empty())return;\n\tif(ind == -1)return;\n\tll cnt1 = 0;\n\tll cnt2 = 0;\n\tint ones = 0;\n\tint zers = 0;\n\tvector<int> left, right;\n\tfor(auto x : a){\n\t\tif((x >> ind) & 1){\n\t\t\tones++;\n\t\t\tcnt2 += zers;\n\t\t\tright.push_back(x);\n\t\t}else{\n\t\t\tzers++;\n\t\t\tcnt1 += ones;\n\t\t\tleft.push_back(x);\n\t\t}\n\t}\n\tinvcnt[ind][0] += cnt1;\n\tinvcnt[ind][1] += cnt2;\n\tfunc(left, ind - 1);\n\tfunc(right, ind - 1);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout<<setprecision(32);\n\n\tint n; cin >> n;\n\tvector<int> a(n);\n\tfor(int &x : a){\n\t\tcin >> x;\n\t}\n\tmemset(invcnt, 0, sizeof(invcnt));\n\tfunc(a, 29);\n\tll ans = 0;\n\tll x = 0;\n\tfor(int i = 0; i < 30; i++){\n\t\tif(invcnt[i][0] <= invcnt[i][1]){\n\t\t\tans += invcnt[i][0];\n\t\t}else{\n\t\t\tans += invcnt[i][1];\n\t\t\tx ^= (1 << i);\n\t\t}\n\t}\n\tcout << ans << \" \" << x << '\\n';\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "divide and conquer",
        "strings",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. XOR Inverse.json",
    "editorial_link": "https://codeforces.com//blog/entry/83036",
    "editorial": "Note: the integer x\n from the statement is marked as an uppercase X\n for clarity.\n\nTake any arbitrary integers x\n and y\n. It is a well-known fact that whether x<y\n or x>y\n depends only on one bit  the highest bit which differs in both.\n\nSo, let's construct a trie on our array integers. Represent each number as a binary string from the highest bit (29\n) to the lowest bit (0\n). Each leaf will keep a corresponding index/indices from the array and each non-leaf node will have at most two children  one for 0\n-edge and one for 1\n-edge.\n\nLet's denote S(v)\n as a sorted list of indices of all values in the subtree of v\n. These lists can be easily maintained while inserting our numbers into trie. Take any arbitrary vertex v\n which has both children and has a depth (distance from root) of k\n. Let a\n and b\n be its children. Here comes the most important thing to notice: If the k\n-th highest bit of X\n is toggled, lists S(a)\n and S(b)\n will change their relative order. Otherwise, it will not change. Thus, exploiting the fact that both lists are sorted, we can efficiently calculate the corresponding number of inversions between those lists and add them to our values sum[k][0]\n and sum[k][1]\n. sum[i][j]\n means the number of inversions we have to add if i\n-th highest bit of X\n is equal to j\n.\n\nAfter the calculation of our sum\n table is done, the value of X\n can be easily restored.\n\nTime complexity: O(nlog109)\n\nMemory complexity: O(nlog109)",
    "hint": []
}