{
    "link": "https://codeforces.com//contest/1166/problem/C",
    "problemId": "345550",
    "problem_idx": "C",
    "shortId": "1166C",
    "contest_number": "1166",
    "problem_submissions": {
        "F": [
            54316652,
            54307224,
            54305584,
            54310646,
            54378086,
            54313232,
            54308575
        ],
        "E": [
            54298891,
            54300156,
            54304094,
            54294518,
            54300338,
            54303194,
            54301468,
            54302857,
            54297877,
            54295582,
            54302504,
            54299216,
            54297435,
            54297855,
            54304772,
            54304820,
            54295745,
            54296534
        ],
        "D": [
            54296262,
            54291838,
            54301051,
            54302058,
            54297357,
            54294897,
            54294795,
            54298322,
            54305898,
            54305908,
            54298392,
            54300155,
            54304713,
            54305703,
            54307005,
            54301062,
            54300346,
            54307391,
            54309804
        ],
        "C": [
            54289104,
            54297291,
            54291974,
            54290534,
            54287551,
            54289613,
            54287736,
            54292153,
            54290078,
            54292325,
            54290260,
            54291592,
            54291908,
            54293597,
            54292202,
            54290296,
            54292002,
            54299709,
            54289976
        ],
        "B": [
            54286717,
            54295090,
            54286733,
            54287427,
            54290240,
            54285781,
            54285576,
            54288042,
            54287483,
            54286749,
            54287663,
            54286685,
            54286479,
            54286327,
            54288426,
            54286838,
            54288503,
            54286890,
            54287732
        ],
        "A": [
            54284453,
            54292968,
            54284797,
            54284966,
            54291534,
            54284478,
            54284450,
            54284940,
            54284548,
            54284402,
            54284377,
            54284696,
            54284645,
            54284386,
            54285929,
            54284902,
            54285432,
            54284438,
            54284725
        ]
    },
    "name": "C. A Tale of Two Lands",
    "statement": "The legend of the foundation of Vectorland talks of two integers x and\r\ny. Centuries ago, the array king placed two markers at points |x| and\r\n|y| on the number line and conquered all the land in between (including\r\nthe endpoints), which he declared to be Arrayland. Many years later, the\r\nvector king placed markers at points |x - y| and |x + y| and conquered\r\nall the land in between (including the endpoints), which he declared to\r\nbe Vectorland. He did so in such a way that the land of Arrayland was\r\ncompletely inside (including the endpoints) the land of Vectorland.Here\r\n|z| denotes the absolute value of z.Now, Jose is stuck on a question of\r\nhis history exam: \"What are the values of x and y?\" Jose doesn’t know\r\nthe answer, but he believes he has narrowed the possible answers down to\r\nn integers a_1, a_2,\r\ndots, a_n. Now, he wants to know the number of pairs formed by two\r\nelements from these n integers such that the legend could be true if x\r\nand y were equal to these two values. Note that it is possible that Jose\r\nis wrong, and that no pairs could possibly make the legend true.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define y0 holdtheflower\n#define y1 enjoythecolorandscent\n#define yn walkthroughthesoulgarden\n#define j1 feelthewarmbreathofkindnessandsalvation\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint n; vector<int> a;\n\nvoid Input() {\n\tcin >> n; a.resize(n);\n\tfor (auto &z: a) {cin >> z; z = abs(z);}\n}\n\nvoid Solve() {\n\tlong long ans = 0;\n\tsort(a.begin(), a.end());\n\tfor (int i=0; i<n; i++) {\n\t\tint j = upper_bound(a.begin(), a.end(), a[i] * 2) - a.begin();\n\t\tans += max(0, j - i - 1);\n\t}\n\tcout << ans << endl;\n}\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\tInput(); Solve(); return 0;\n}\n\n/******************************************\\\n *  Thuy-Trang Tran, #Team4T's Leader     *\n *  #Team4T Primary Flagship - Salvation  *\n\\******************************************/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. A Tale of Two Lands.json",
    "editorial_link": "https://codeforces.com//blog/entry/67081",
    "editorial": "Formally, the condition for the legend being true readsNow, it is\r\npossible to characterize when this condition happens through casework on\r\nthe signs and sizes of and , but this can be tricky to do right.\r\nHowever, there is a neat trick that allows us to solve the problem\r\nwithout any casework. What happens if we change into ? The values of and\r\nstay the same, while and will swap values. This means that the pair\r\nworks if and only if works. Similarly we can switch the sign of . This\r\nmeans that we can replace and by their absolute values, and the original\r\npair works if and only if the new one works.If and then the condition\r\nbecomes . The upper bound obviously always holds, while the lower bound\r\nis equivalent by some simple algebra toSo the problem reduces to\r\ncounting the number of pairs with and . To solve this we now take the\r\nabsolute values of all the and sort them into an array . The answer to\r\nthe problem is the number of pairs with and . For each fixed we\r\ncalculate the largest that satisfies this condition, and just add to the\r\nanswer, as the values are all the ones that work for this . We can\r\neither do a binary search for the best at each , or calculate the\r\noptimal âs for all of the âs in using two pointers. Either way, our\r\nfinal complexity is as this is the time required to sort the\r\narray.Complexity:\r\n",
    "hint": []
}