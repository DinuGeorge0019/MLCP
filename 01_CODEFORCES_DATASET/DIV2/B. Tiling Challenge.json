{
    "link": "https://codeforces.com//contest/1150/problem/B",
    "problemId": "337486",
    "problem_idx": "B",
    "shortId": "1150B",
    "contest_number": "1150",
    "problem_submissions": {
        "B": [
            53540534,
            53507569,
            53508198,
            53505953,
            53507902,
            53502830,
            53513376,
            53506258,
            53506938,
            53507029,
            53505090,
            53506786,
            53507919,
            53505701,
            53508136,
            53505737,
            53510148,
            53505896,
            53509474,
            53506927
        ],
        "A": [
            53540520,
            53504501,
            53501762,
            53504323,
            53502423,
            53506385,
            53503912,
            53503441,
            53502508,
            53503428,
            53501838,
            53503271,
            53503651,
            53502306,
            53502491,
            53507914,
            53502081,
            53502083,
            53506610,
            53502822
        ],
        "D": [
            53516414,
            53520400,
            53521416,
            53522657,
            53528159,
            53520710,
            53520700,
            53521674,
            53520691,
            53521939,
            53524571,
            53524486,
            53563821,
            53526080,
            53525497,
            53525654,
            53525306,
            53525173,
            53524887,
            53526333,
            53526204
        ],
        "C": [
            53509607,
            53510070,
            53509423,
            53505062,
            53510041,
            53509499,
            53512010,
            53510164,
            53511943,
            53509231,
            53509848,
            53515668,
            53510065,
            53514034,
            53514382,
            53512626,
            53511942,
            53512622,
            53512550
        ],
        "E": [
            53531623,
            53531513,
            53525648
        ]
    },
    "name": "B. Tiling Challenge",
    "statement": "One day Alice was cleaning up her basement when she noticed something\r\nvery curious: an set of wooden pieces! Each piece was made of five\r\nsquare tiles, with four tiles adjacent to the fifth center tile: By the\r\npieces lay a large square wooden board. The board is divided into n^2\r\ncells arranged into n rows and n columns. Some of the cells are already\r\noccupied by single tiles stuck to it. The remaining cells are free.Alice\r\nstarted wondering whether she could fill the board completely using the\r\npieces she had found. Of course, each piece has to cover exactly five\r\ndistinct cells of the board, no two pieces can overlap and every piece\r\nshould fit in the board entirely, without some parts laying outside the\r\nboard borders. The board however was too large for Alice to do the\r\ntiling by hand. Can you help determine if it’s possible to fully tile\r\nthe board?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nconst int MAXN=50+5;\nconst int dx[]={1,1,1,2},dy[]={-1,0,1,0};\nint n;\nchar a[MAXN+5][MAXN+5];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%s\",a[i]+1);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(a[i][j]=='.'){\n\t\t\t\ta[i][j]='#';\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\t\t\tif(x>=1&&x<=n&&y>=1&y<=n&&a[x][y]=='.'){\n\t\t\t\t\t\ta[x][y]='#';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Tiling Challenge.json",
    "editorial_link": "https://codeforces.com/blog/entry/66783",
    "editorial": "Notice that there is only one orientation of the wooden piece (and this\r\nis the orientation depicted in the statement). Moreover, we can notice\r\nthe following fact:The fact is pretty obvious there is simply no other\r\nway to cover the cell.Having that, itâs straightforward to implement an\r\nsolution: while the board isnât fully covered, take any topmost untiled\r\ncell and try to cover it with a piece. If itâs impossible, declare the\r\nfailure. If itâs possible, lay the piece and repeat the procedure. We\r\ncan lay at most pieces, and weâre looking for the topmost cell in time.\r\nThis gives us running time.While this is enough to solve the task, one\r\ncan also notice that we donât have to seek the whole board in search of\r\nthe cell. In fact, we can do a single scan through the board in\r\nrow-major order, and as soon as we find any uncovered cell, we try to\r\ncover it by a wooden piece. This allows us to implement the solution in\r\ntime.\r\n",
    "hint": []
}