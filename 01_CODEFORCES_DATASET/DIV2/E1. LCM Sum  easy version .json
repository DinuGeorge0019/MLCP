{
    "link": "https://codeforces.com//contest/1712/problem/E1",
    "problemId": "1501807",
    "problem_idx": "E1",
    "shortId": "1712E1",
    "contest_number": "1712",
    "problem_submissions": {
        "F": [
            168185997,
            168251887,
            168219993
        ],
        "D": [
            168145291,
            168129998,
            168130818,
            168126018,
            168130208,
            168150361,
            168134585,
            168133390,
            168138455,
            168134081,
            168125783,
            168137077,
            168136879,
            168129408,
            168136930,
            168129243,
            168125119,
            168132698,
            168160697
        ],
        "E2": [
            168140188,
            168158270,
            168148121,
            168161916,
            168160378,
            168143972,
            168164627,
            168154079,
            168159111,
            168162533,
            168162132,
            168162930,
            168162457,
            168165260,
            168162375,
            168157107,
            168171929,
            168162727,
            168146310
        ],
        "E1": [
            168139990,
            168143565,
            168142598,
            168152240,
            168154486,
            168136125,
            168153299,
            168148039,
            168146574,
            168156854,
            168162049,
            168149859,
            168153717,
            168157309,
            168155734,
            168157279,
            168163352,
            168162849,
            168111592
        ],
        "C": [
            168099696,
            168121142,
            168097588,
            168110349,
            168111432,
            168115384,
            168111269,
            168107817,
            168332689,
            168116564,
            168111708,
            168108690,
            168109977,
            168116188,
            168105860,
            168124053,
            168136319,
            168107454,
            168118827,
            168132254
        ],
        "B": [
            168092536,
            168105158,
            168090795,
            168101197,
            168098906,
            168103766,
            168096786,
            168097289,
            168095985,
            168094917,
            168094914,
            168099431,
            168102987,
            168092377,
            168105879,
            168092526,
            168097397,
            168101154,
            168148773
        ],
        "A": [
            168089016,
            168089238,
            168089117,
            168090448,
            168090182,
            168095836,
            168091066,
            168089267,
            168092084,
            168090133,
            168090067,
            168092244,
            168092571,
            168089003,
            168099380,
            168089001,
            168089147,
            168093453,
            168116561
        ]
    },
    "name": "E1. LCM Sum  easy version ",
    "statement": "Some NumberYou are given two positive integers l and r.Count the number\r\nof distinct triplets of integers (i, j, k) such that l\r\nle i < j < k\r\nle r and\r\noperatorname{lcm}(i,j,k)\r\nge i + j + k.Here\r\noperatorname{lcm}(i, j, k) denotes the least common multiple (LCM) of\r\nintegers i, j, and k.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define IOS ios::sync_with_stdio(0)\n#define N 1000005\n#define ls k<<1\n#define rs k<<1|1\n#define mid (L+R>>1)\n#define low(x) (x&-x)\n#define ll long long\nint T,n,l,ys[N],r,i,j,k,a[N],pos[N],gg,tot; \nll ans[N];\nll c[N];\nstruct query{\n\tint l,r,pos;\n}tmp,q[N];\nquery mk(int l,int r,int pos){\n\ttmp.l=l;\n\ttmp.r=r;\n\ttmp.pos=pos;\n\treturn tmp;\n}\ninline bool cmp(query aa,query bb){\n\treturn aa.l<bb.l;\n}\nvoid add(int k,int y){\n\twhile(k<N){\n\t\tc[k]+=y;\n\t\tk+=low(k);\n\t}\n}\nll sum(int k){\n\tll ret=0;\n\twhile(k){\n\t\tret+=c[k];\n\t\tk-=low(k);\n\t}\n\treturn ret;\n}\nll f3(ll x){\n\treturn x*(x-1)*(x-2)/6;\n}\nsigned main(){\n\tIOS;\n\tcin>>T;\n\tfor(i=1;i<=T;++i){\n\t\tcin>>l>>r;\n\t\tq[++tot]=mk(l,r,i);\n\t\tint f1=(l*2+5)/6*6;\n\t\tans[i]=max(0,r-f1+6)/6;\n\t\tf1=(l*5+1)/2;\n\t\tf1=(f1+14)/15*15;\n\t\tans[i]+=max(0,r-f1+15)/15;\n\t\tans[i]=f3(r-l+1)-ans[i];\n\t}\n\tsort(q+1,q+tot+1,cmp);\n\tfor(i=1;i<=200000;++i){\n\t\tfor(j=i;j<=200000;j+=i){\n\t\t\t++ys[j];\n\t\t}\n\t}\n\tfor(i=1;i<=200000;++i)add(i,(ys[i]-2)*(ys[i]-1)/2);\n\tq[0].l=1;\n\tfor(i=1;i<=T;++i){\n\t\tfor(j=q[i-1].l;j<q[i].l;++j){\n\t\t\tfor(k=j;k<=200000;k+=j){\n\t\t\t\tadd(k,2-ys[k]);\n\t\t\t\t--ys[k];\n\t\t\t}\n\t\t}\n\t\tans[q[i].pos]-=sum(q[i].r)-sum(q[i].l+1);\n\t}\n\tfor(i=1;i<=T;++i){\n\t\tcout<<ans[i]<<\"\\n\";\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "combinatorics",
        "math",
        "number theory",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. LCM Sum  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/105919",
    "editorial": "Let's count the number of bad triplets that don't satisfy the condition, i.e. lcm(i,j,k)<i+j+k\n. Then the answer for one test case is (r?l+1)?(r?l)?(r?l?1)6?\n the number of bad triplets.\n\nSince i<j<k\n, a triplet is bad only when lcm(i,j,k)=k\n or (lcm(i,j,k)=2?k\n and i+j>k\n). This means that both i\n and j\n must be a divisor of 2?k\n.\n\nFor every segment [i;k]\n where i\n is a divisor of 2?k\n, let's count the number of j\n such that i<j<k\n. Let's call it the weight of the segment. Turns out that for the current constraints, for every k\n, we can iterate over all pairs of 1?i<j<k\n, where i\n and j\n are divisors of 2?k\n, and check if the triplet is bad. If it is, then we increase the weight of the segment [i;k]\n by one.\n\nTo get answers for the test cases, we just need to find the sum of the weights of the segments [i;k]\n that are inside [l;r]\n. This is a pretty standard problem, which can be solved in offline using a data structure that supports point add and range sum.\n\nIt is possible to solve E1 without a data structure by iterating over the segments and checking for every one of them if it lies inside [l;r]\n.\n\nComplexity: O(nlog2n+tlogn+?ni=1?0(2?i)2)\n with a seg tree (?ni=1?0(2?i)\n is about nlogn\n and a seg tree update works in O(logn)\n, so we get nlog2n\n).\n\nYou can also use sqrt decomposition to get O(nlogn+tn???+?ni=1?0(2?i)2)\n.",
    "hint": []
}