{
    "link": "https://codeforces.com//contest/2019/problem/E",
    "problemId": "2905357",
    "problem_idx": "E",
    "shortId": "2019E",
    "contest_number": "2019",
    "problem_submissions": {
        "F": [
            283223839,
            283223286,
            283233615,
            283232657,
            283229948,
            283240516,
            283246459,
            283246565,
            283251452,
            283250505,
            283246427,
            283244651,
            283250557,
            283250319,
            283249369,
            283252799,
            283231473,
            283385869
        ],
        "D": [
            283212674,
            283217889,
            283216603,
            283210525,
            283219753,
            283227849,
            283216187,
            283224832,
            283209439,
            283233196,
            283224958,
            283235552,
            283222166,
            283223408,
            283233229,
            283225040,
            283257759,
            283214659,
            283210870,
            283212555
        ],
        "C": [
            283205819,
            283208819,
            283200046,
            283197191,
            283204787,
            283192339,
            283195887,
            283200218,
            283196222,
            283200867,
            283211801,
            283203783,
            283208730,
            283210534,
            283225468,
            283214456,
            283200932,
            283202854,
            283202139,
            283199131
        ],
        "B": [
            283197247,
            283193710,
            283188887,
            283186540,
            283192007,
            283185443,
            283202984,
            283190900,
            283188420,
            283188733,
            283190635,
            283190801,
            283197405,
            283188473,
            283191300,
            283202121,
            283194633,
            283194452,
            283194664,
            283188555
        ],
        "A": [
            283194983,
            283181021,
            283181315,
            283181373,
            283182984,
            283180436,
            283198713,
            283181153,
            283180882,
            283182334,
            283181092,
            283183886,
            283188674,
            283181377,
            283181185,
            283196847,
            283190061,
            283183844,
            283182154,
            283180956
        ],
        "E": [
            283192360,
            283198927,
            283209740,
            283216991,
            283212803,
            283197800,
            283209059,
            283219624,
            283225534,
            283213304,
            283232353,
            283227746,
            283232779,
            283233925,
            283218649,
            283231587,
            283221137,
            283211364,
            283219849,
            283218893
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "If the final depth of the leaves is d\n, it's optimal to keep in the tree all the nodes at depth d\n and all their ancestors. These nodes are the only ones which satisfy the following two conditions:\n\ntheir depth (ai\n) is ?d\n;\nthe maximum depth of a node in their subtree (bi\n) is ?d\n.\nSo every node is alive in the interval of depths [ai,bi]\n. The optimal d\n is the one contained in the maximum number of intervals.",
    "name": "E. Tree Pruning",
    "statement": "You are given a tree with n nodes, rooted at node 1. In this problem, a\r\nleaf is a non-root node with degree 1.In one operation, you can remove a\r\nleaf and the edge adjacent to it (possibly, new leaves appear). What is\r\nthe minimum number of operations that you have to perform to get a tree,\r\nalso rooted at node 1, where all the leaves are at the same distance\r\nfrom the root?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;const int N=5e5+7;int T,ans,n,nw;vector<int>e[N];bool vis[N];int dep[N],cnt[N],ff[N],sn[N];vector<int>lf[N];void dfs(int x,int fa){\tint sz=e[x].size();\tif(fa)sz--;\tif(sz==0){\t\tlf[dep[x]].push_back(x);\t}\tcnt[dep[x]]++;\tfor(auto v:e[x])if(v!=fa){\t\tsn[x]++;\t\tff[v]=x;\t\tdep[v]=dep[x]+1;\t\tdfs(v,x);\t}\treturn;}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);\tcin>>T;\twhile(T--){\t\tnw=0;\t\tcin>>n;\t\tans=n-1;\t\tfor(int i=1;i<=n;i++){\t\t\tvis[i]=0;\t\t}\t\tvis[1]=1;\t\tfor(int i=1;i<n;i++){\t\t\tint u,v;\t\t\tcin>>u>>v;\t\t\te[u].push_back(v);\t\t\te[v].push_back(u);\t\t}\t\tdep[1]=1;\t\tdfs(1,0);\t\tfor(int i=n-1;i;i--)\t\t\tcnt[i]+=cnt[i+1];\t\tfor(int de=1;de<=n;de++){\t\t\tfor(auto x:lf[de-1]){\t\t\t\tint hp=x;\t\t\t\twhile(!sn[hp]){\t\t\t\t\tvis[hp]=1;\t\t\t\t\tnw++;\t\t\t\t\tsn[ff[hp]]--;\t\t\t\t\thp=ff[hp];\t\t\t\t}\t\t\t}\t\t\tint cst=cnt[de+1]+nw;\t\t\tans=min(ans,cst);\t\t}\t\tfor(int i=1;i<=n;i++){\t\t\te[i].clear();\t\t\tlf[i].clear();\t\t\tcnt[i]=0;\t\t\tff[i]=0;\t\t\tsn[i]=0;\t\t}\t\tcout<<ans<<\"\\n\";\t}\t\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "sortings",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Tree Pruning.json",
    "hint": []
}