{"link": "https://codeforces.com//contest/711/problem/D", "problemId": "69435", "problem_idx": "D", "shortId": "711D", "contest_number": "711", "problem_submissions": {"E": [20243389, 20243503, 20251107, 20247122, 20236128, 20244311, 20247031, 20249581, 20251290, 20251110, 20236252, 20252814, 20251720, 20253127, 20249558, 20253691, 20251603, 20254289, 20255257, 20254984], "D": [20236748, 20238445, 20241120, 20241449, 20243957, 20248074, 20235096, 20241386, 20243419, 20245769, 20252016, 20241009, 20246037, 20248033, 20253018, 20249456, 20247107, 20247154, 20250386, 20243861], "C": [20233774, 20236081, 20235214, 20238143, 20247473, 20235216, 20238803, 20236811, 20238264, 20238615, 20243230, 20238055, 20240001, 20236172, 20233634, 20240235, 20250548, 20242121, 20238810, 20252383], "B": [20231663, 20231286, 20231641, 20233400, 20241564, 20239107, 20249116, 20232416, 20233691, 20233328, 20237744, 20233188, 20232782, 20232671, 20234921, 20232432, 20236746, 20235044, 20234855, 20236166], "A": [20229146, 20229063, 20229191, 20229690, 20306899, 20229217, 20232219, 20240668, 20229251, 20229508, 20229028, 20230826, 20229961, 20229487, 20229092, 20231432, 20229019, 20229332, 20231409, 20230327, 20229746]}, "name": "D. Directed Roads", "statement": "ZS the Coder and Chris the Baboon has explored Udayland for quite some\r\ntime. They realize that it consists of towns numbered from to . There\r\nare directed roads in the Udayland. -th of them goes from town to some\r\nother town (). ZS the Coder can flip the direction of any road in\r\nUdayland, i.e. if it goes from town to town before the flip, it will go\r\nfrom town to town after.ZS the Coder considers the roads in the Udayland\r\n, if there is a sequence of distinct towns () such that for every there\r\nis a road from town to town and another road from town to town . In\r\nother words, the roads are confusing if form a directed cycle of some\r\ntowns.Now ZS the Coder wonders how many sets of roads (there are\r\nvariants) in initial configuration can he choose to flip such that after\r\nflipping each road in the set exactly once, the resulting network will\r\nbe confusing.Note that it is allowed that after the flipping there are\r\nmore than one directed road from some town and possibly some towns with\r\nno roads leading out of it, or multiple roads between any pair of\r\ncities.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int maxn = (int)1e6;\nconst int inf = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll INF = (ll)1e18;\nconst double eps = 1e-9;\n\nint n, a[200200];\nvector<int> g[200200];\nbool used[200200];\nint sz[200200];\nint col[200200];\nint T = 0;\n\nvoid dfs(int v, int c) {\n\tif (col[v] == c) return;\n\tcol[v] = c;\n\tsz[c]++;\n\tfor (int i = 0; i < (int)g[v].size(); i++) {\n\t\tdfs(g[v][i], c);\n\t}\n}\n\nint szv = 0, v[200200], p[200200];\nint ex[200200];\n\nint main()\n{\n\n\tex[0] = 1;\n\tfor (int i = 1; i < 200200; i++) {\n\t\tex[i] = 2 * ex[i - 1];\n\t\tif (ex[i] >= mod) ex[i] -= mod;\n\t}\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", a + i);\n\t\ta[i]--;\n\t\tg[i].pb(a[i]);\n\t\tg[a[i]].pb(i);\n\t}\n\t\n\tmemset(col, -1, sizeof col);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tif (col[i] == -1) {\n\t\t\tdfs(i, T);\n\t\t\tT++;\n\t\t}\n\t}\n\t\n\tint ans = 1;\n\tmemset(p, -1, sizeof p);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!used[col[i]]) {\n\t\t\tused[col[i]] = 1;\n\t\t\tint j = i;\n\t\t\tint cnt = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (p[j] != -1) break;\n\t\t\t\tp[j] = cnt;\n\t\t\t\tcnt++;\n\t\t\t\tj = a[j];\n\t\t\t}\n\t\t\tint m = cnt - p[j];\n\t\t\tint cur = ex[m] - 2;\n\t\t\tif (cur < 0) cur += mod;\n\t\t\tint c = sz[col[i]] - m;\n\t\t\tcur = 1ll * cur * ex[c] % mod;\n\t\t\tans = 1ll * ans * cur % mod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dfs and similar", "graphs", "math"], "dificulty": "1900", "interactive": false}