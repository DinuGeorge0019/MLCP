{
    "link": "https://codeforces.com//contest/899/problem/E",
    "problemId": "139224",
    "problem_idx": "E",
    "shortId": "899E",
    "contest_number": "899",
    "problem_submissions": {
        "E": [
            33341966,
            33340018,
            33344607,
            33341901,
            33341539,
            33344275,
            33337380,
            33342849,
            33340726,
            33347352,
            33343799,
            33343759,
            33341387,
            33344491,
            33344757,
            33341661,
            33346130,
            33338732
        ],
        "C": [
            33340695,
            33335345,
            33336434,
            33335120,
            33335041,
            33335499,
            33334442,
            33348052,
            33335755,
            33342632,
            33337468,
            33334609,
            33334793,
            33334208,
            33335451,
            33337214,
            33334080,
            33333085,
            33333444,
            33331734
        ],
        "F": [
            33338461,
            33343719,
            33339590,
            33345961,
            33344150,
            33347582,
            33346148,
            33345517,
            33343018,
            33342469,
            33347771,
            33346884,
            33346523,
            33344745,
            33367339,
            33341779,
            33351995,
            33344839,
            33365793
        ],
        "D": [
            33336515,
            33337716,
            33334973,
            33338435,
            33339737,
            33338654,
            33342392,
            33336907,
            33337363,
            33345764,
            33341905,
            33342131,
            33336716,
            33359470,
            33338983,
            33337743,
            33339386,
            33340477,
            33334813
        ],
        "B": [
            33333018,
            33334262,
            33335995,
            33336742,
            33345182,
            33334298,
            33344445,
            33333097,
            33339162,
            33346906,
            33355091,
            33333588,
            33336070,
            33332639,
            33334734,
            33332707,
            33332034,
            33335177,
            33341675
        ],
        "A": [
            33330877,
            33331991,
            33335753,
            33330957,
            33342381,
            33331004,
            33335366,
            33331266,
            33330748,
            33330942,
            33330958,
            33330948,
            33331773,
            33330761,
            33330943,
            33331310,
            33330809,
            33330687,
            33330860,
            33341110
        ]
    },
    "name": "E. Segments Removal",
    "statement": "Vasya has an array of integers of length .Vasya performs the following\r\noperations on the array: on each step he finds the longest segment of\r\nconsecutive equal integers (the leftmost, if there are several such\r\nsegments) and removes it. For example, if Vasya\u2019s array is , then after\r\none operation it becomes .Compute the number of operations Vasya should\r\nmake until the array becomes empty, i.e. Vasya removes all elements from\r\nit.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\nconst int M=(int)2e5+5;\nset<pair<int,int> >st,ans;\nset<pair<int,int> >::iterator it,it1,it2;\nint n,a[M];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;)\n\t\tif(a[i]!=a[i-1]){\n\t\t\tint c=0,l=i;\n\t\t\twhile(a[i]==a[l])c++,i++;\n\t\t\tst.insert(pair<int,int>(l,c));\n\t\t\tans.insert(pair<int,int>(-c,l));\n\t\t}\n\tint ANS=0;\n\twhile(!ans.empty()){\n\t\tit=ans.begin();\n\t\tpair<int,int> pr=(*it);\n\t\tANS++;\n\t\tans.erase(it);\n\t\tit=st.find(pair<int,int>(pr.second,-pr.first));\n\t\tit1=it;\n\t\tit2=it;\n\t\tit2++;\n\t\tbool f1=(it==st.begin()),f2=(it2==st.end());\n\t\tif(f1&&f2)break;\n\t\telse if(f1&&!f2){\n\t\t\tst.erase(it);\n\t\t}else if(!f1&&f2){\n\t\t\tst.erase(it);\n\t\t}else if(!f1&&!f2){\n\t\t\tit1--;\n\t\t\tst.erase(it);\n\t\t\tif(a[(*it1).first]==a[(*it2).first]){\n\t\t\t\tans.erase(ans.find(pair<int,int>(-(*it1).second,(*it1).first)));\n\t\t\t\tans.erase(ans.find(pair<int,int>(-(*it2).second,(*it2).first)));\n\t\t\t\tans.insert(pair<int,int>(-(*it1).second-(*it2).second,(*it1).first));\n\t\t\t\tpr=(*it1);\n\t\t\t\tpr.second+=(*it2).second;\n\t\t\t\tst.erase(it1);\n\t\t\t\tst.erase(it2);\n\t\t\t\tst.insert(pr);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ANS);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "flows",
        "implementation",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Segments Removal.json",
    "editorial_link": "https://codeforces.com//blog/entry/56392",
    "editorial": "We will use to set of pairs. In the first set (call it ) we will store\r\nall segments consisting of the same numbers in a format the length of\r\nthe segment multiplied on and the position of the beginning of the\r\nsegment. In the second set (call it ) we will store all segments\r\nconsisting of the same numbers in a format the position of the beginning\r\nof the segment and the length of the segment.Initially we will put in\r\nthe sets all segments from the given array consisting of the same\r\nnumbers.After that we will repeat the following algorithm until in sets\r\nthere are non-deleted segments: increase answer on ; take from the\r\nlongest and the leftmost segment (it will be in the beginning of the ,\r\nbecause we store here all length multiplied on ) and remove it from .\r\nLet this segment beginning in the position and has length ; with help of\r\nwe can find in the left and the right segments relatively the segment\r\nfrom the previous article. After that we should remove from the segments\r\nthe segment ; if both left and right relatively of the current longest\r\nsegment there are non-deleted segments and they consisting of the same\r\nnumbers, we should to unite them in one segment. To do this, we should\r\nremove the left and right segments from and and put the new merged\r\nsegment in and in the described format.\r\n"
}