{
    "link": "https://codeforces.com//contest/2030/problem/D",
    "problemId": "2962991",
    "problem_idx": "D",
    "shortId": "2030D",
    "contest_number": "2030",
    "problem_submissions": {
        "D": [
            286870605,
            286870097,
            286766067,
            286743790,
            286749704,
            286752517,
            286743540,
            286763694,
            286769489,
            286762215,
            286755968,
            286807582,
            286774479,
            286755264,
            286748829,
            286762354,
            286767397,
            286766307,
            286775817,
            286773805,
            286867460,
            286806694,
            286757030
        ],
        "C": [
            286860734,
            286764785,
            286775512,
            286732737,
            286735870,
            286731279,
            286736529,
            286759035,
            286741312,
            286740209,
            286770332,
            286732276,
            286730948,
            286749099,
            286748589,
            286737019,
            286738816,
            286732618,
            286746919,
            286735952,
            286744382
        ],
        "B": [
            286858184,
            286726117,
            286721582,
            286722000,
            286722997,
            286722179,
            286731090,
            286742656,
            286728669,
            286721456,
            286721616,
            286722634,
            286723485,
            286723817,
            286722712,
            286723090,
            286725291,
            286719819,
            286727047,
            286721215,
            286722880
        ],
        "A": [
            286857205,
            286716570,
            286716508,
            286717068,
            286716187,
            286716722,
            286727391,
            286716522,
            286715165,
            286715628,
            286715445,
            286716659,
            286717260,
            286715083,
            286717340,
            286715258,
            286718621,
            286715888,
            286722488,
            286715834,
            286716388
        ],
        "G1": [
            286855127,
            286854605,
            287072911,
            286866647
        ],
        "F": [
            286768609,
            286793091,
            286802410,
            286804764,
            286807723,
            286808203,
            286799478,
            286806636,
            286814242,
            286786481,
            286811066,
            286813827,
            286813676,
            286816754,
            286814190,
            286813606,
            286813682,
            286795825,
            286808765,
            286817519
        ],
        "E": [
            286766337,
            286759349,
            286779444,
            286786742,
            286788454,
            286791781,
            286783999,
            286800776,
            286780259,
            286764648,
            286793854,
            286792948,
            286789703,
            286779768,
            286799721,
            286794191,
            286791806,
            286816988,
            286786381,
            286789315
        ],
        "G2": [
            287138384
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135218",
    "editorial": "Through a series of swaps, we can swap an element from position to\nposition (WLOG, assume ) if there is no such such that such that and\n.Let\u00e2\u0080\u0099s mark all indices such that and as bad. If represents the position\nof in , then we must make sure it is possible to swap from to . As you\ncan see, we can model these conditions as intervals. We must make sure\nthere are no bad indices included in any intervals.We need to gather\nindices such that is included in at least one interval. This can be done\nwith difference array. Let denote the number of intervals that include .\nIf , then we need to make sure is not a bad index. We can keep all bad\nindices in a set. Notice that when we update , we can only potentially\ntoggle indices and from good to bad (or vice versa). For example, if , ,\nand index is not in the bad set, then we will insert it. After each\nquery, if the bad set is empty, then the answer is \"YES\".\n",
    "name": "D. QED s Favorite Permutation",
    "statement": "QED is given a permutation^{\r\ntext{ }} p of length n. He also has a string s of length n containing\r\nonly characters\r\ntexttt{L} and\r\ntexttt{R}. QED only likes permutations that are sorted in non-decreasing\r\norder. To sort p, he can select any of the following operations and\r\nperform them any number of times: Choose an index i such that s_i =\r\ntexttt{L}. Then, swap p_i and p_{i-1}. It is guaranteed that s_1\r\nneq\r\ntexttt{L}. Choose an index i such that s_i =\r\ntexttt{R}. Then, swap p_i and p_{i+1}. It is guaranteed that s_n\r\nneq\r\ntexttt{R}. He is also given q queries. In each query, he selects an\r\nindex i and changes s_i from\r\ntexttt{L} to\r\ntexttt{R} (or from\r\ntexttt{R} to\r\ntexttt{L}). Note that the changes are . After each query, he asks you if\r\nit is possible to sort p in non-decreasing order by performing the\r\naforementioned operations any number of times. Note that before\r\nanswering each query, the permutation p is reset to its original form.^{\r\ntext{ }}A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"using namespace std;using ll = long long;using vi = vector<int>;\u00a0#define endl '\\n'#define pb emplace_back#define sz(x) (int)(x).size()#define all(x) (x).begin(), (x).end()#define make_unique(x) sort(all(x)), x.resize(unique(all(x)) - begin(x))#define debug(x) cerr << \"[\" << __LINE__ << \"] \"#x\" = \" << (x) << endl\u00a0const int MN = 2e5 + 105;int cnt = 0;\u00a0void solve() {\tint n, q;\tcin >> n >> q;\t\tvector <vector <int>> st(n), en(n);\tvector <bool> flg(n, false);\tvector <int> vec(n, 0);\tvector <int> p(n);\tset <int> miss;\tstring str, str_;\t//\tauto proc = [&](int pos) -> void {//\t\tif (str[pos] == 'R') {//\t\t\tvec[pos] --, vec[pos - 1] ++;//\t\t\tstr[pos] = 'L';//\t\t} else {//\t\t\tvec[pos - 1] --, vec[pos] ++;//\t\t\tstr[pos] = 'R';//\t\t}//\t};\t\tfor (int i = 0; i < n; i ++) {\t\tcin >> p[i];\t\tp[i] --;\t\tif (i == p[i]) continue;\t\tst[min(i, p[i])].pb(i);\t\ten[max(i, p[i]) - 1].pb(i);\t}\t\tint cur = 0;\t\t\tfor (int i = 0 ; i < n; i ++ ) {\t\tcur += st[i].size();\t\tif (cur > 0) {\t\t\tflg[i] = true;\t\t}\t\tcur -= en[i].size();\t}\t\t\tcin >> str;\tstr_ = str;\tfor (int i = 0; i < n; i ++) {\t\tif (str[i] == 'R') {\t\t\tvec[i] ++;\t\t\t\t} else {\t\t\tvec[i - 1] ++;\t\t}\t}\t\tfor (int i = 0; i < n - 1; i ++) {\t\tif (flg[i] && !vec[i] ) {\t\t\tmiss.insert(i);\t\t\t\t\t}\t}\t\u00a0\t\twhile (q --) {\t\tint x;\t\tcin >> x;  \t\tx --;\t\t\t\tif (str[x] == 'R') {\t\t\tif (vec[x] <= 1 && flg[x]) miss.insert(x);\t\t\tif (vec[x - 1] == 0 && flg[x - 1]) miss.erase(x - 1);\t\t\tcerr << 'x' << x << endl;\t\t\tvec[x] --, vec[x - 1] ++;\t\t\tstr[x] = 'L';\t\t} else {\t\t\tif (vec[x - 1] <= 1 && flg[x - 1]) miss.insert(x - 1);\t\t\tif (vec[x] == 0 && flg[x]) miss.erase(x);\t\t\tvec[x - 1] -- , vec[x] ++;\t\t\tstr[x] = 'R';\t\t}\t\t\t\tif (miss.empty()) {\t\t\tcout << \"YES\" << endl;\t\t} else {\t\t\tcout << \"NO\" << endl;\t\t}\t}}\u00a0\u00a0\u00a0int main() {#ifndef ONLINE_JUDGE\tfreopen(\"in.txt\", \"r\", stdin);//\tfreopen(\"out.txt\", \"w\", stdout);#endif\u00a0\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\u00a0\tint tc = 1;\tcin >> tc;\twhile (tc --) solve();\u00a0\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. QED s Favorite Permutation.json"
}