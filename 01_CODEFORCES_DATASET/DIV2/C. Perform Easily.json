{
    "link": "https://codeforces.com//contest/1435/problem/C",
    "problemId": "773405",
    "problem_idx": "C",
    "shortId": "1435C",
    "contest_number": "1435",
    "problem_submissions": {
        "E": [
            96673338,
            96681148,
            96682797,
            96685288,
            96847098,
            96685903,
            96675878,
            96687224,
            96687243,
            96686976,
            96689725,
            96692435,
            96691487,
            96692658,
            96691299,
            96690805,
            96693692,
            96679915,
            96692643,
            96687850
        ],
        "D": [
            96666232,
            96664904,
            96669284,
            96672253,
            96669314,
            96662222,
            96670668,
            96669409,
            96677310,
            96678148,
            96672549,
            96673104,
            96674256,
            96678523,
            96677726,
            96675716,
            96674961,
            96679765,
            96674688
        ],
        "C": [
            96659129,
            96657575,
            96664731,
            96660163,
            96661902,
            96686570,
            96658550,
            96663667,
            96669546,
            96664295,
            96666298,
            96669749,
            96666819,
            96667412,
            96671053,
            96669495,
            96685954,
            96666507,
            96668496,
            96674329
        ],
        "B": [
            96653882,
            96659883,
            96653749,
            96652475,
            96653199,
            96659428,
            96653053,
            96655781,
            96654431,
            96655376,
            96655587,
            96653268,
            96655657,
            96658338,
            96657193,
            96656576,
            96657563,
            96655601,
            96656271
        ],
        "A": [
            96648730,
            96649969,
            96649216,
            96648637,
            96648957,
            96653721,
            96648796,
            96663309,
            96649948,
            96651571,
            96648683,
            96648672,
            96658175,
            96649723,
            96648927,
            96651329,
            96649879,
            96649976,
            96675513
        ]
    },
    "name": "C. Perform Easily",
    "statement": "After battling Shikamaru, Tayuya decided that her flute is too\r\npredictable, and replaced it with a guitar. The guitar has 6 strings and\r\nan infinite number of frets numbered from 1. Fretting the fret number j\r\non the i-th string produces the note a_{i} + j.Tayuya wants to play a\r\nmelody of n notes. Each note can be played on different string-fret\r\ncombination. The easiness of performance depends on the difference\r\nbetween the maximal and the minimal indices of used frets. The less this\r\ndifference is, the easier it is to perform the technique. Please\r\ndetermine the minimal possible difference.For example, if a = [1, 1, 2,\r\n2, 3, 3], and the sequence of notes is 4, 11, 11, 12, 12, 13, 13\r\n(corresponding to the second example), we can play the first note on the\r\nfirst string, and all the other notes on the sixth string. Then the\r\nmaximal fret will be 10, the minimal one will be 3, and the answer is\r\n10 - 3 = 7, as shown on the picture.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n#include <cstring>\n#include <sstream>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n\n#define pb push_back\n#define F first\n#define S second\n#define _sz(x) ((int)x.size())\n\nconst int N = 1e5 + 20;\n\nint a[6];\nint n, b[N];\n\n\nint ptr[N];\nset <pii> st;\n\nint main()\n{\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    \n    for (int i = 0; i < 6; i++) cin >> a[i];\n\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> b[i];\n\n    sort(a, a + 6);\n    sort(b, b + n);\n\n    for (int i = 0; i < n; i++) {\n        ptr[i] = 5;\n        st.insert({b[i] - a[ptr[i]], i});\n    }\n\n    int ans = (*st.rbegin()).F - (st.begin() -> F);\n\n    while (_sz(st)) {\n        pii p = *st.begin();\n        st.erase(p);\n\n        int i = p.S;\n\n        if (ptr[i] == 0) break;\n\n        ptr[i]--;\n\n        st.insert({b[i] - a[ptr[i]], i});\n\n        ans = min(ans, (*st.rbegin()).F - (st.begin() -> F));\n    }\n\n    cout << ans << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Perform Easily.json",
    "editorial_link": "https://codeforces.com//blog/entry/84056",
    "editorial": "My logic : The maximal and minimal frets are obviously useful frets i.e.\r\nthey are used by some fret. So I first sorted the notes and then fixed\r\nthe \"minimal used fret\" by using the frets required by the first note by\r\nthe various strings (the logic being that the smallest note will use the\r\nsmallest fret from all possible combinations). So out of the 6 frets\r\nusable by the first note, one of them should be the \"minimal\" fret of\r\nthe optimum set. Then I just binary search for the right hand side by\r\nchecking if all notes can be played for the specified minimal fret.\r\n",
    "hint": []
}