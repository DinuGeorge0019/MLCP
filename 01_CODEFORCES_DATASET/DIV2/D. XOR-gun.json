{
    "link": "https://codeforces.com//contest/1457/problem/D",
    "problemId": "814144",
    "problem_idx": "D",
    "shortId": "1457D",
    "contest_number": "1457",
    "problem_submissions": {
        "E": [
            99868612,
            99868820,
            99868894,
            99871379,
            99876241,
            99873210,
            99873073,
            99877427,
            99875242,
            99874362,
            99880934,
            99878599,
            99880282,
            99880267,
            99880129,
            99881010,
            99881186,
            99878842,
            99883433,
            99887042
        ],
        "D": [
            99860413,
            99858501,
            99859224,
            99855503,
            99852261,
            99861676,
            99862738,
            99863057,
            99864198,
            99864361,
            99855111,
            99866971,
            99857047,
            99869259,
            99872023,
            99871057,
            99871185,
            99871389,
            99870989,
            99870957
        ],
        "C": [
            99848523,
            99846546,
            99854121,
            99849522,
            99849975,
            99852554,
            99857957,
            99855488,
            99850137,
            99854183,
            99851123,
            99848085,
            99862644,
            99857309,
            99851618,
            99858097,
            99853416,
            99850485,
            99861161,
            99863907
        ],
        "B": [
            99842172,
            99842416,
            99847160,
            99843642,
            99841920,
            99843802,
            99852704,
            99845703,
            99844331,
            99847361,
            99846671,
            99841358,
            99851090,
            99848157,
            99844121,
            99845368,
            99843677,
            99857603,
            99853155,
            99848846
        ],
        "A": [
            99839848,
            99840102,
            99841257,
            99839720,
            99841011,
            99840218,
            99839732,
            99841278,
            99840508,
            99841843,
            99839833,
            99839677,
            99846294,
            99845677,
            99840019,
            99840219,
            99840262,
            99842567,
            99843366,
            99841538
        ]
    },
    "name": "D. XOR-gun",
    "statement": "Arkady owns a array a_1, a_2,\r\nldots, a_n. You are jealous of its beauty and want to destroy this\r\nproperty. You have a so-called that you can use one or more times.In one\r\nstep you can select two elements of the array, let’s say x and y, remove\r\nthem from the array and insert the integer x\r\noplus y on their place, where\r\noplus denotes the bitwise XOR operation. Note that the length of the\r\narray decreases by one after the operation. You can’t perform this\r\noperation when the length of the array reaches one.For example, if the\r\narray is [2, 5, 6, 8], you can select 5 and 6 and replace them with 5\r\noplus 6 = 3. The array becomes [2, 3, 8].You want the array no longer be\r\nnon-decreasing. What is the minimum number of steps needed? If the array\r\nstays non-decreasing no matter what you do, print -1.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define pre(i,a,b) for(int i=a;i>=b;i--)\n#define N 100005\nusing namespace std;\nint n,a[N],s[N],b[N],c[N];\nint bt(int x){\n\tint sum=0;\n\twhile(x)x>>=1,sum++;\n\treturn sum;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%d\",&a[i]);\n\trep(i,1,n)b[i]=bt(a[i]),c[b[i]]++;\n\trep(i,1,32)if(c[i]>2){\n\t\tputs(\"1\");return 0;\n\t}\n\tint ans=n;\n\trep(i,1,n)s[i]=s[i-1]^a[i];\n\trep(l,1,n-1)rep(r,l+1,n)rep(k,l,r-1){\n\t\tif((s[k]^s[l-1])>(s[r]^s[k]))ans=min(ans,r-l-1);\n\t}\n\tif(ans==n)puts(\"-1\");else printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dp"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. XOR-gun.json",
    "editorial_link": "https://codeforces.com//blog/entry/85118",
    "editorial": "First let's compute array b1,b2,,bn\n, where bi\n is the index of the highest bit equal to 1\n in the binary notation of ai\n. The statement says bi?bi+1\n. These values can be computed by dividing the given numbers by 2\n until they are zero.\n\nNote that if for a given i\n the equality bi?1=bi=bi+1=t\n holds, then we can apply an operation to ai\n and ai+1\n, and the resulting integer is smaller than ai?1\n. Indeed, in ai?1\n the highest bit set is t\n, but in ai?ai+1\n the t\n-th and higher bits are zeros. That means if there is such an i\n (it is easy to check in a single linear pass), then the answer is 1\n.\n\nNow note that if there is no such i\n, then the size of the array n\n is not bigger than 2?(?log2109?+1)=60\n! Indeed, there are no more than two integers with the same highest bit set. It is much easier to solve the problem in such constraints.\n\nConsider some solution. In the final array, let's denote it as c\n, there is i\n such that ci>ci+1\n. Note that each element of the final array is equal to XOR of some subsegment of the initial array, and each element of the initial array belongs to exactly one such subsegment. Let this subsegment for ci\n be al,al+1,,am\n, and for ci+1\n be am+1,am+2,,ar\n. Then it's clear that to find an optimal solution it is enough to loop through all possible values of l\n, m\n, and r\n and check whether XOR of all elements of the left subsegment is larger than XOR of all elements of the right subsegment. If this inequality holds, update answer with value r?l?1\n. The complexity of this part is O(n3)\n or O(n4)\n depending on implementation.",
    "hint": []
}