{"link": "https://codeforces.com//contest/320/problem/B", "problemId": "3251", "problem_idx": "B", "shortId": "320B", "contest_number": "320", "problem_submissions": {"E": [3947787, 3947991, 3950460, 3950423, 3950804, 3966579, 3964196, 3952271], "D": [3945386, 3948801, 3947835, 3948803, 3948306, 3946600, 3946788, 3946323, 3947962, 3948204, 3949156, 3949185, 3948762, 3950341, 3948763, 3948830, 3949570, 3949588, 3948736], "C": [3944304, 3946570, 3945118, 3946127, 3947195, 3945029, 3945376, 3944923, 3946219, 3946207, 3946206, 3946330, 3946413, 3944056, 3946806, 3947161, 3946298, 3946947], "B": [3943587, 3943527, 3944238, 3945074, 3946102, 3943469, 3943701, 3946193, 3944211, 3944838, 3944825, 3944402, 3943607, 3945327, 3945105, 3945231, 3944216, 3944488, 3945725], "A": [3942664, 3942547, 3943263, 3943194, 3942602, 3942567, 3942605, 3944414, 3942943, 3942965, 3942610, 3942731, 3942604, 3944341, 3942932, 3943709, 3942746, 3943368]}, "name": "B. Ping-Pong  Easy Version ", "statement": "In this problem at each moment you have a set of intervals. You can move\r\nfrom interval from our set to interval from our set if and only if .\r\nAlso there is a path from interval from our set to interval from our set\r\nif there is a sequence of successive moves starting from so that we can\r\nreach .Your program should handle the queries of the following two\r\ntypes: \"\" add the new interval to the set of intervals. The length of\r\nthe new interval is guaranteed to be strictly greater than all the\r\nprevious intervals. \"\" answer the question: is there a path from -th\r\n(one-based) added interval to -th (one-based) added interval? Answer all\r\nthe queries. Note, that initially you have an empty set of intervals.\r\n", "solutions": ["#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<fstream>\n#include<map>\n#include<ctime>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<bitset>\n#include<functional>\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define REP(i,l,r) for((i)=(l);(i)<=(r);++(i))\n#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))\nusing namespace std;\n\ntypedef long long LL;\ntypedef double ld;\n\nconst int NUM=100+10;\n\nint n;\nint tot;\nint l[NUM],r[NUM];\nint g[NUM][NUM];\n\nint can(int b,int a)\n{\n\treturn (l[a]<l[b] && l[b]<r[a]) || (l[a]<r[b] && r[b]<r[a]);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout);\n#endif\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tint type,a,b;\n\tREP(i,1,n)\n\t{\n\t\tscanf(\"%d%d%d\",&type,&a,&b);\n\t\tif(type==1)\n\t\t{\n\t\t\tl[++tot]=a;\n\t\t\tr[tot]=b;\n\t\t\tREP(j,1,tot)\n\t\t\t{\n\t\t\t\tg[j][tot]=can(j,tot);\n\t\t\t\tg[tot][j]=can(tot,j);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tqueue<int> q;\n\t\t\tint hash[1000];\n\t\t\tmemset(hash,0,sizeof hash);\n\t\t\tq.push(a);\n\t\t\thash[a]=1;\n\t\t\twhile(!q.empty())\n\t\t\t{\n\t\t\t\tint u=q.front();\n\t\t\t\tq.pop();\n\t\t\t\tREP(j,1,tot)\n\t\t\t\t\tif(g[u][j] && !hash[j])\n\t\t\t\t\t{\n\t\t\t\t\t\thash[j]=1;\n\t\t\t\t\t\tq.push(j);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(hash[b])\n\t\t\t\tcout<<\"YES\"<<endl;\n\t\t\telse cout<<\"NO\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs"], "dificulty": "1500", "interactive": false}