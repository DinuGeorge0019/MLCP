{
    "link": "https://codeforces.com//contest/1891/problem/E",
    "problemId": "2296092",
    "problem_idx": "E",
    "shortId": "1891E",
    "contest_number": "1891",
    "problem_submissions": {
        "E": [
            230546323,
            230549698,
            230546568,
            230560113,
            230535473,
            230555886,
            230556588,
            230572665,
            230562765,
            230571525,
            230577549,
            230577437,
            230577312,
            230576387,
            230568654,
            230542621,
            230562980,
            230569462,
            230570942,
            230569058,
            230570276,
            230567059,
            230568509,
            230570393
        ],
        "D": [
            230534861,
            230532955,
            230530542,
            230539370,
            230549040,
            230536739,
            230534616,
            230532674,
            230544623,
            230533495,
            230543589,
            230549007,
            230547762,
            230544535,
            230536524,
            230537913,
            230537614,
            230536080,
            230540544,
            230539494
        ],
        "F": [
            230528098,
            230541255,
            230552010,
            230529998,
            230540710,
            230542715,
            230590093,
            230590013,
            230545702,
            230538147,
            251594037,
            230535448,
            230545719,
            230533122,
            230519163,
            230533480,
            230536870,
            230548382,
            230551293,
            230550179,
            230543750,
            230553764,
            230541029
        ],
        "C": [
            230517325,
            230519256,
            230521040,
            230519508,
            230552157,
            230529446,
            230519957,
            230521645,
            230529295,
            230521526,
            230527664,
            230555714,
            230523852,
            230528582,
            230522749,
            230531812,
            230530352,
            230518984,
            230520316,
            230536742
        ],
        "A": [
            230515478,
            230512076,
            230512426,
            230512477,
            230513749,
            230513572,
            230511745,
            230511922,
            230513704,
            230511875,
            230512212,
            230559679,
            230512242,
            230513480,
            230512561,
            230512123,
            230512943,
            230547595,
            230512205,
            230518051
        ],
        "B": [
            230513054,
            230513705,
            230515902,
            230515002,
            230527506,
            230517573,
            230513080,
            230513453,
            230518089,
            230513986,
            230515796,
            230558558,
            230539558,
            230516521,
            230515634,
            230516319,
            230517013,
            230552749,
            230513951,
            230522884
        ]
    },
    "name": "E. Brukhovich and Exams",
    "statement": "The boy Smilo is learning algorithms with a teacher named\r\nBrukhovich.Over the course of the year, Brukhovich will administer n\r\nexams. For each exam, its difficulty a_i is known, which is a\r\nnon-negative integer.Smilo doesn’t like when the greatest common divisor\r\nof the difficulties of two consecutive exams is equal to 1. Therefore,\r\nhe considers the of the academic year to be the number of such pairs of\r\nexams. More formally, the is the number of indices i (1\r\nleq i\r\nleq n - 1) such that gcd(a_i, a_{i+1}) = 1, where gcd(x, y) is the\r\ngreatest common divisor of integers x and y.Brukhovich wants to minimize\r\nthe sadness of the year of Smilo. To do this, he can set the difficulty\r\nof any exam to 0. However, Brukhovich doesn’t want to make his students’\r\nlives too easy. Therefore, he will perform this action no more than k\r\ntimes.Help Smilo determine the minimum sadness that Brukhovich can\r\nachieve if he performs no more than k operations.As a reminder, the\r\ngreatest common divisor (GCD) of two non-negative integers x and y is\r\nthe maximum integer that is a divisor of both x and y and is denoted as\r\ngcd(x, y). In particular, gcd(x, 0) = gcd(0, x) = x for any non-negative\r\ninteger x.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rg register\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n\nusing namespace std;\n\nconst int maxn=1e5+10;\n\ninline int gcd(int x,int y)\n{\n    if(!y)return x;\n    return gcd(y,x%y);\n}\n\nint n,K;\nint A[maxn];\n\ninline void solve()\n{\n    scanf(\"%d %d\",&n,&K);\n    for(rg int i=1;i<=n;i+=1)scanf(\"%d\",A+i);\n    if(n==1)\n    {\n\tputs(\"0\");\n\treturn;\n    }\n    bool ccf=true;\n    for(rg int i=1;i<=n;i+=1)ccf&=A[i]==1;\n    if(ccf)\n    {\n\tfor(rg int i=1;i<=K;i+=1)A[i]=0;\n\tint Ans=0;\n\tfor(rg int i=1;i<n;i+=1)Ans+=gcd(A[i],A[i+1]);\n\tcout<<Ans<<endl;\n\treturn;\n    }\n    vector<int>B,C;\n    for(rg int i=1;i<=n;i+=1)\n    {\n\tif(A[i]==1)continue;\n\trg int j=i;\n\twhile(j<n&&A[j+1]^1&&gcd(A[j],A[j+1])==1)j+=1;\n\tfor(rg int k=i+1;k<j;k+=2)B.emplace_back(k);\n\tif((j-i)&1)C.emplace_back(j);\n\ti=j;\n    }\n    while(K&&B.size())\n    {\n\tA[B.back()]=0;B.pop_back();\n\tK-=1;\n    }\n    vector<pair<int,int> >Seq;\n    for(rg int i=1;i<=n;i+=1)\n\tif(A[i]==1)\n\t{\n\t    rg int j=i;\n\t    while(j<n&&A[j+1]==1)j+=1;\n\t    if(i>1&&j<n)Seq.emplace_back(i,j);\n\t    i=j;\n\t}\n    sort(Seq.begin(),Seq.end(),[](auto x,auto y)\n\t\t\t       {\n\t\t\t\t   return x.second-x.first>y.second-y.first;\n\t\t\t       });\n    while(Seq.size()&&Seq.back().second-Seq.back().first+1<=K)\n    {\n\tauto [l,r]=Seq.back();Seq.pop_back();\n\tK-=r-l+1;\n\tfor(rg int i=l;i<=r;i+=1)A[i]=0;\n    }\n    while(K&&C.size())\n    {\n\tA[C.back()]=0,C.pop_back();\n\tK-=1;\n    }\n    int Ans=0;\n    for(rg int i=1;i<n;i+=1)Ans+=gcd(A[i],A[i+1])==1;\n    int cnt=0;\n    for(rg int i=1;i<=n;i+=1)cnt+=A[i]==1;\n    Ans-=min(K,cnt);\n    printf(\"%d\\n\",Ans);\n}\n\nint main()\n{\n    int T;scanf(\"%d\",&T);\n    while(T--)solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation",
        "math",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Brukhovich and Exams.json",
    "editorial_link": "https://codeforces.com//blog/entry/121876",
    "editorial": "Consider that every . Then, we can split our array into blocks in which\r\neach adjacent element has . For example, consider [, , , , , , ], then\r\nthe array divides into two blocks: [, , , ] and [, , ]. Notice that if\r\nthe lenght of a block is , then it gives to Smilo. Also notice that we\r\ncan reduce by two using only one operation: we can, for instance,\r\nnullify the second element in a block (if the length of the block is\r\nmore than two). For illustration, if we nullify the second element in\r\nblock [, , ], the will decrease by two, and the block will be splitted\r\ninto [], [], [] with zero in each block. If the size of a block is\r\nexactly two, we can decrease the by one using one operation. Then notice\r\nthat while we are having at least one block, which lenght is at least ,\r\nwe can decrease by . Otherwise, we can decrease at most by\r\n.Unfortunately, we have ones in our array. In this case our algorithm\r\nwonât work, since in order to make pair [, ] good, we will have to\r\nnullify both elements. Then letâs slightly modify the algorithm: we will\r\nput consecutive ones in different blocks. For example, if [, , , , , ,\r\n], then our array will be splitted into 4 blocks: [, , ], [, ], [], [].\r\nNow notice that if the block of ones is located at the edge of our\r\narray, then the will decrease by using operations ( is the lenght of the\r\nblock). Otherwise, will decrease by using operations. The final solution\r\nbecomes obvious. Firstly, we should nullify the elements in non-ones\r\nblocks (if possible) in order to decrease by each operation. Then we\r\nneed to nullify whole blocks of ones (which are not on the edge of the\r\narray) in ascending order of lenght. And finally, we need to use\r\nremaining operations to reduce by one each operation.The complexity is\r\n().\r\n",
    "hint": []
}