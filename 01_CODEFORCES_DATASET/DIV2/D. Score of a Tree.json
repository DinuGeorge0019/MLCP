{
    "link": "https://codeforces.com//contest/1777/problem/D",
    "problemId": "1746204",
    "problem_idx": "D",
    "shortId": "1777D",
    "contest_number": "1777",
    "problem_submissions": {
        "F": [
            189999253,
            189998361,
            189995169,
            190011490,
            190011116,
            190013769,
            190004003,
            190169577,
            190021489,
            190008226,
            190022277,
            190024196,
            190001976,
            190021500,
            190024711,
            190004961,
            190022857,
            190022045,
            190022993,
            190023276
        ],
        "E": [
            189990969,
            189994239,
            190006715,
            190001929,
            190054762,
            190054746,
            190004086,
            189987917,
            190017805,
            190001567,
            190021800,
            189999439,
            190005213,
            190019127,
            190007828,
            190009522,
            190469875,
            190020733,
            190022555,
            190013627,
            190011832,
            190008524,
            190011505
        ],
        "D": [
            189985748,
            189986829,
            189987429,
            189993541,
            189993926,
            189998094,
            189993119,
            189991582,
            189993898,
            189993229,
            189996303,
            190011551,
            189999620,
            189998025,
            189985279,
            189989471,
            190001136,
            190003775,
            189995371
        ],
        "C": [
            189982736,
            189982649,
            189981053,
            189986400,
            189987697,
            189986317,
            189985767,
            189986390,
            189987035,
            189982802,
            189983463,
            189984656,
            189988557,
            189987620,
            190014819,
            189984186,
            189995951,
            189999181,
            189985198
        ],
        "B": [
            189976042,
            189976916,
            189975827,
            189979459,
            189978444,
            189990271,
            189980176,
            189980492,
            189982493,
            189987295,
            189978177,
            189974359,
            189977682,
            189978251,
            190006967,
            189977343,
            189982864,
            189993219,
            189987444
        ],
        "A": [
            189973782,
            189974189,
            189973729,
            189974335,
            189974674,
            189974171,
            189975493,
            189974143,
            189973720,
            189987925,
            189975596,
            189973718,
            189975380,
            189974227,
            189988175,
            189973870,
            189975652,
            189992324,
            189990668
        ]
    },
    "name": "D. Score of a Tree",
    "statement": "You are given a tree of n nodes, rooted at 1. Every node has a value of\r\neither 0 or 1 at time t=0.At any integer time t>0, the value of a node\r\nbecomes the bitwise XOR of the values of its children at time t - 1; the\r\nvalues of leaves become 0 since they don’t have any children.Let S(t)\r\ndenote the sum of values of all nodes at time t. Let F(A) denote the sum\r\nof S(t) across all values of t such that 0\r\nle t\r\nle 10^{100}, where A is the initial assignment of 0s and 1s in the\r\ntree.The task is to find the sum of F(A) for all 2^n initial\r\nconfigurations of 0s and 1s in the tree. Print the sum modulo 10^9+7.\r\n",
    "solutions": [
        "//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include \"my_header\\debug.h\"\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef unsigned long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nnamespace _fac\n{\n\ttypedef unsigned int ui;\n\ttypedef unsigned long long ll;\n\tconst int N=1e6+2;\n\tconst ll p=1e9+7;\n\tll fac[N];\n\tll ifac[N];\n\tll inv[N];\n\tll ksm(ll x,int y)\n\t{\n\t\tll r=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) r=(ll)r*x%p;\n\t\t\tx=(ll)x*x%p;\n\t\t\ty>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tll C(int n,int m)\n\t{\n\t\tif (n<m||m<0) return 0;\n\t\treturn (ll)fac[n]*ifac[m]%p*ifac[n-m]%p;\n\t}\n\tvoid init_fac()\n\t{\n\t\tint i;\n\t\tfac[0]=1;\n\t\tfor (i=1; i<N; i++) fac[i]=(ll)fac[i-1]*i%p;\n\n\t\tifac[N-1]=ksm(fac[N-1],p-2);\n\t\tfor (i=N-1; i; i--) ifac[i-1]=(ll)ifac[i]*i%p;\n\n\t\tll x; inv[1]=1;\n\t\tfor (i=2; i<N; i++)\n\t\t{\n\t\t\tx=p/i;\n\t\t\tinv[i]=(ll)x*(p-inv[p-x*i])%p;\n\t\t}\n\t}\n}\nusing _fac::init_fac; using _fac::fac; using _fac::ifac; using _fac::inv;\nusing _fac::ksm; using _fac::C; using _fac::p;\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n;\n\t\tvector e(n+1,vector<int>());\n\t\tfor (i=1; i<n; i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tcin>>u>>v;\n\t\t\te[u].push_back(v);\n\t\t\te[v].push_back(u);\n\t\t}\n\t\tvector<int> dep(n+1),md(n+1);\n\t\tll ans=0;\n\t\tfunction<void(int)> dfs=[&](int u)\n\t\t{\n\t\t\tmd[u]=dep[u];\n\t\t\tfor (int v:e[u]) if (!dep[v]) dep[v]=dep[u]+1,dfs(v),cmax(md[u],md[v]);\n\t\t\tans=(ans+md[u]-dep[u]+1)%p;\n\t\t};\n\t\tdfs(dep[1]=1);\n\t\tcout<<ans*ksm(2,n-1)%p<<'\\n';\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dfs and similar",
        "dp",
        "math",
        "probabilities",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Score of a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/111729",
    "editorial": "We will focus on computing the expected value of rather than the sum, as\r\nthe sum is just .Let denote the sum of all values at node from time to ,\r\nif the initial configuration is .Clearly, .With linearity of\r\nexpectations,Define as the value of node at time , if the initial\r\nconfiguration is .Observe that is simply if there is no node in âs\r\nsubtree at a distance of from , otherwise, the value is the bitwise xor\r\nof the initial values of all nodes in the subtree of at a distance of\r\nfrom .Thus, define as the length of the longest path from to a leaf in\r\nâs subtree. Now, is half if is less than or equal to , otherwise itâs .\r\nThis is because the expected value of xor of boolean values is is is\r\nzero, otherwise itâs half. This fact has multiple combinatorial proofs.\r\nFor example, one can simply count the number of ways of choosing odd\r\nnumber of boolean values, among the values as to get We use this to get:\r\nAll the values can be computed by a single traversal of the tree.Our\r\nfinal result is:Time complexity:\r\n",
    "hint": [
        "Hint 1 What would be the value of a node at time ?",
        "Hint 2 The value of a node after time would be the xor of the initial values of all nodes in the subtree of which are at a distance from .",
        "Hint 3 What is the expected value of xor of boolean values?"
    ]
}