{
    "link": "https://codeforces.com//contest/1754/problem/F",
    "problemId": "1601074",
    "problem_idx": "F",
    "shortId": "1754F",
    "contest_number": "1754",
    "problem_submissions": {
        "F": [
            177585023,
            177595292,
            177589725,
            177595672,
            177592227,
            177594371,
            177600616,
            177598864,
            177604397,
            177602614,
            177600745,
            177650521
        ],
        "E": [
            177569689,
            177567357,
            177579016,
            177575748,
            177578227,
            177581574,
            177582284,
            177718437,
            177559205,
            177578841,
            177592467,
            177571365,
            177604409,
            177574278,
            177575358,
            177581672,
            177580864,
            177577975,
            177576690,
            177577060,
            177575788
        ],
        "D": [
            177558843,
            177556402,
            177557867,
            177557341,
            177566023,
            177561555,
            177537301,
            177563632,
            177569625,
            177568630,
            177559753,
            177582529,
            177556010,
            177555670,
            177565457,
            177546662,
            177548683,
            177569461,
            177558389,
            177564007
        ],
        "C2": [
            177551655,
            177558288,
            177573497,
            177569544,
            177555242,
            177556994,
            177560273,
            177574456,
            177565363,
            177565266,
            177553021,
            177580177,
            177562940,
            177559475,
            177572826,
            177570567,
            177562030,
            177570649,
            177565206
        ],
        "C1": [
            177547310,
            177553157,
            177573631,
            177554026,
            177551066,
            177557135,
            177560766,
            177574531,
            177555999,
            177565804,
            177552312,
            177567879,
            177563083,
            177549386,
            177558755,
            177554824,
            177557780,
            177570332,
            177559045
        ],
        "B": [
            177536928,
            177540939,
            177544434,
            177539979,
            177546063,
            177755484,
            177551911,
            177569215,
            177582864,
            177540989,
            177550638,
            177541452,
            177561666,
            177543484,
            177541411,
            177704318,
            177536796,
            177542739,
            177547137,
            178632445,
            177550998,
            177541636
        ],
        "A": [
            177533931,
            177534875,
            177539057,
            177534599,
            177534878,
            177755451,
            177538378,
            177573057,
            177577215,
            177534289,
            177537921,
            177534413,
            177539691,
            177533195,
            177532916,
            177535356,
            177704314,
            177533258,
            177538336,
            177537857,
            178632436,
            177537629,
            177532986
        ]
    },
    "name": "F. The Beach",
    "statement": "Andrew loves the sea. That’s why, at the height of the summer season, he\r\ndecided to go to the beach, taking a sunbed with him to sunbathe.The\r\nbeach is a rectangular field with n rows and m columns. Some cells of\r\nthe beach are free, some have roads, stones, shops and other non-movable\r\nobjects. Some of two adjacent along the side cells can have sunbeds\r\nlocated either horizontally or vertically.Andrew hopes to put his sunbed\r\nsomewhere, but that’s a bad luck, there may no longer be free places for\r\nhim! That’s why Andrew asked you to help him to find a free place for\r\nhis sunbed. Andrew’s sunbed also should be places on two adjacent cells.\r\nIf there are no two adjacent free cells, then in order to free some\r\nplace for a sunbed, you will have to disturb other tourists. You can do\r\nthe following actions: Come to some sunbed and, after causing p units of\r\ndiscomfort to its owner, lift the sunbed by one of its sides and rotate\r\nit by 90 degrees. One half of the sunbed must remain in the same cell\r\nand another half of the sunbed must move to the free cell. At the same\r\ntime, anything could be on the way of a sunbed during the rotation .\r\nCome to some sunbed and, after causing q units of discomfort to its\r\nowner, shift the sunbed along its long side by one cell. One half of the\r\nsunbed must move to the place of another, and another to the free cell.\r\nIn any moment each sunbed occupies two adjacent free cells. You cannot\r\nmove more than one sunbed at a time.Help Andrew to free a space for his\r\nsunbed, causing the minimum possible number of units of discomfort to\r\nother tourists, or detect that it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define ln cout<<'\\n'\n#define ll long long\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}\ntemplate<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?\" \":\"\");pr(b...);}\ntemplate<class A>void PR(A a,ll n){rep(i,n)cout<<(i?\" \":\"\")<<a[i];ln;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={-1,0,1,0,-1,-1,1,1},dy[8]={0,1,0,-1,-1,1,1,-1};\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\n\nvoid Main() {\n  ll n,m,p,q;\n  cin >> n >> m >> p >> q;\n  string s[n];\n  rep(i,n) R s[i];\n  ll d[n][m];\n  priority_queue<PP,vector<PP>,greater<PP> > que;\n  rep(i,n)rep(j,m) {\n    d[i][j]=MAXL;\n    if(s[i][j]=='.') {\n      d[i][j]=0;\n      que.push(PP(0,P(i,j)));\n    }\n  }\n  while(!que.empty()) {\n    PP pp=que.top();que.pop();\n    ll x=pp.S.F,y=pp.S.S,c=pp.F;\n    if(d[x][y]<c) continue;\n    if(check(n,m,x,y+1)&&s[x][y+1]=='L') {\n      if(d[x][y+2]>c+q) {\n        d[x][y+2]=c+q;\n        que.push(PP(c+q,P(x,y+2)));\n      }\n    }\n    if(check(n,m,x,y-1)&&s[x][y-1]=='R') {\n      if(d[x][y-2]>c+q) {\n        d[x][y-2]=c+q;\n        que.push(PP(c+q,P(x,y-2)));\n      }\n    }\n    if(check(n,m,x+1,y)&&s[x+1][y]=='U') {\n      if(d[x+2][y]>c+q) {\n        d[x+2][y]=c+q;\n        que.push(PP(c+q,P(x+2,y)));\n      }\n    }\n    if(check(n,m,x-1,y)&&s[x-1][y]=='D') {\n      if(d[x-2][y]>c+q) {\n        d[x-2][y]=c+q;\n        que.push(PP(c+q,P(x-2,y)));\n      }\n    }\n    \n    if(check(n,m,x,y+1)&&s[x][y+1]=='D') {\n      if(d[x-1][y+1]>c+p) {\n        d[x-1][y+1]=c+p;\n        que.push(PP(c+p,P(x-1,y+1)));\n      }\n    }\n    if(check(n,m,x,y+1)&&s[x][y+1]=='U') {\n      if(d[x+1][y+1]>c+p) {\n        d[x+1][y+1]=c+p;\n        que.push(PP(c+p,P(x+1,y+1)));\n      }\n    }\n    if(check(n,m,x,y-1)&&s[x][y-1]=='D') {\n      if(d[x-1][y-1]>c+p) {\n        d[x-1][y-1]=c+p;\n        que.push(PP(c+p,P(x-1,y-1)));\n      }\n    }\n    if(check(n,m,x,y-1)&&s[x][y-1]=='U') {\n      if(d[x+1][y-1]>c+p) {\n        d[x+1][y-1]=c+p;\n        que.push(PP(c+p,P(x+1,y-1)));\n      }\n    }\n    if(check(n,m,x+1,y)&&s[x+1][y]=='R') {\n      if(d[x+1][y-1]>c+p) {\n        d[x+1][y-1]=c+p;\n        que.push(PP(c+p,P(x+1,y-1)));\n      }\n    }\n    if(check(n,m,x+1,y)&&s[x+1][y]=='L') {\n      if(d[x+1][y+1]>c+p) {\n        d[x+1][y+1]=c+p;\n        que.push(PP(c+p,P(x+1,y+1)));\n      }\n    }\n    if(check(n,m,x-1,y)&&s[x-1][y]=='R') {\n      if(d[x-1][y-1]>c+p) {\n        d[x-1][y-1]=c+p;\n        que.push(PP(c+p,P(x-1,y-1)));\n      }\n    }\n    if(check(n,m,x-1,y)&&s[x-1][y]=='L') {\n      if(d[x-1][y+1]>c+p) {\n        d[x-1][y+1]=c+p;\n        que.push(PP(c+p,P(x-1,y+1)));\n      }\n    }\n  }\n  ll ans=MAXL;\n  rep(i,n) {\n    rep(j,m) {\n      rep(k,4) {\n        ll x=i+dx[k],y=j+dy[k];\n        if(check(n,m,x,y)&&s[i][j]!='#'&&s[x][y]!='#') ans=min(ans,d[i][j]+d[x][y]);\n      }\n    }\n  }\n  if(ans==MAXL) ans=-1;\n  pr(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "shortest paths",
        "shortest paths",
        "shortest paths"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. The Beach.json",
    "editorial_link": "https://codeforces.com//blog/entry/108336",
    "editorial": "Let's paint our field in a chess coloring.\n\nNow let's consider our operations not as the movement of sunbeds, but as the movement of free cells. Then, a free cell adjacent to the long side of the sunbed can move to a cell of the sunbed that is not adjacent to this one, for p\n units of discomfort. A free cell adjacent to the short side of the sunbed can move to a cell of the sunbed that is not adjacent to this one, for q\n units of discomfort. Note that in this cases, the free cell does not change its color (in chess coloring).\n\nSince each sunbed should occupy one black and one white cell, then some two free cells of different colors should move to neighboring ones using operations.\n\nIt can be shown that in the optimal answer we use no more than one operation with each sunbed.\n\nThen, for each position, looking at the adjacent sunbeds, we will determine where the free cell can move if it turns out to be in this position. Let's construct a weighted oriented graph on the cells of the field. Edge (x1,y1)?(x2,y2)\n of weight w\n (equal to p\n or q\n) will mean that there is a sunbed such that by moving it with an operation that brings w\n discomfort, we will free the cell (x2,y2)\n and block the cell (x1,y1)\n.\n\nNote that the graphs on the black and white cells are not connected. Let's run Dijkstra's algorithm from all free cells at once. Then, for each cell dx,y\n - the minimum distance in this graph from a free cell is equal to the minimum amount of discomfort that must be used to free this cell.\n\nThe answer to the problem is the minimum for all pairs (x1,y1)\n, (x2,y2)\n neighboring cells, dx1,y1+dx2,y2\n. Or ?1\n if there is no pair of adjacent cells, both of which are reachable from the free ones.\n\nAsymptotics of the solution: O(nm?log(nm))",
    "hint": []
}