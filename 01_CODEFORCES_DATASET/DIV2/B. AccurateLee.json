{
    "link": "https://codeforces.com//contest/1369/problem/B",
    "problemId": "651256",
    "problem_idx": "B",
    "shortId": "1369B",
    "contest_number": "1369",
    "problem_submissions": {
        "F": [
            84805615,
            84815422,
            84821788,
            84848209,
            84808586,
            84845078,
            84819664,
            84809525
        ],
        "E": [
            84783653,
            84794541,
            84777094,
            84792178,
            84796407,
            84799473,
            84847985,
            84794191,
            84802657,
            84799608,
            84843231,
            84798901,
            84802992,
            84803891,
            84799522,
            84803293,
            84803734,
            84801605
        ],
        "D": [
            84774757,
            84783341,
            84767385,
            84777566,
            84781335,
            84780403,
            84783178,
            84780507,
            84786495,
            84784013,
            84784219,
            84785925,
            84784946,
            84790889,
            84787139,
            84785887,
            84796956,
            84790843
        ],
        "C": [
            84764211,
            84776491,
            85764231,
            85764174,
            84784880,
            84769031,
            84773069,
            84769214,
            84772926,
            84766954,
            84773427,
            84767072,
            84773264,
            84775000,
            84772759,
            84772359,
            84919485,
            84776351,
            84771759,
            84772941,
            84776880
        ],
        "B": [
            84758680,
            84760470,
            84777367,
            84762433,
            84762003,
            84761770,
            84766923,
            84760439,
            84763340,
            84761080,
            84766453,
            84765969,
            84767231,
            84765006,
            84759974,
            84762031,
            84767553,
            84769489
        ],
        "A": [
            84750967,
            84766185,
            84750778,
            84752543,
            84752490,
            84752217,
            84767956,
            84750544,
            84755659,
            84751856,
            84756195,
            84753655,
            84751015,
            84749918,
            84749358,
            84749254,
            84751162,
            84756777
        ]
    },
    "name": "B. AccurateLee",
    "statement": "The string s he found is a binary string of length n (i. e. string\r\nconsists only of -s and -s).In one move he can choose two consecutive\r\ncharacters s_i and s_{i+1}, and if s_i is and s_{i + 1} is , he can\r\nerase (he can choose which one to erase but he can’t erase both\r\ncharacters simultaneously). The string shrinks after erasing.Lee can\r\nmake an arbitrary number of moves (possibly zero) and he’d like to make\r\nthe string s as as possible. He thinks for two different strings x and\r\ny, the string is cleaner, and if they are the same length, then the\r\nstring is cleaner.Now you should answer t test cases: for the i-th test\r\ncase, print the cleanest possible string that Lee can get by doing some\r\nnumber of moves.Small reminder: if we have two strings x and y of the\r\nsame length then x is lexicographically smaller than y if there is a\r\nposition i such that x_1 = y_1, x_2 = y_2,..., x_{i - 1} = y_{i - 1} and\r\nx_i < y_i.\r\n",
    "solutions": [
        "// You may love a girl deeply\n// but you can't express in it more than 7-8 inches...\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(ass) ass.begin(), ass.end()\nusing namespace std;\n\ntypedef long long ll;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007;\nconst ll N = 2e5 + 85;\nconst ll Inf = 1e18;\nconst ll Log = 69;\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll t;\n\tcin >> t;\n\tfor(int i = 0; i < t; i++){\n\t\tll n;\n\t\tcin >> n;\n\t\tstr s;\n\t\tcin >> s;\n\t\tstr a = \"\", b = \"\";\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(s[i] == '1') break;\n\t\t\ta += '0';\n\t\t}\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\tif(s[i] == '0') break;\n\t\t\tb += '1';\n\t\t}\n\t\tcout << a;\n\t\tif((a.size() + b.size()) < n) cout << \"0\";\n\t\tcout << b << '\\n';\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. AccurateLee.json",
    "editorial_link": "https://codeforces.com//blog/entry/79235",
    "editorial": ":Realize that the answer is always non-descending, and we canât perform\r\nany operations on non-descending strings.First we know that we canât\r\nperform any operations on non-descending strings, so the answer to a\r\nnon-descending string is itself. From now we consider our string to not\r\nto be non-descending. (i.e. there exist index such that and )Also\r\nrealize that the remaining string wont be empty, so \"0\" is the cleanest\r\npossible answer, but we canât reach it probable.Now realize that leading\r\nzeroes and trailing ones canât be present in any operation. So they have\r\nto be in the answer, erase them from , and add them to the answer for\r\nthe modified . From now we know that the string has no leading zeroes\r\nand/or trailing ones, and is not non-descending, so it starts with and\r\nends with . (why?)With some small paperwork, we will realize that the\r\nanswer to a string that starts with and ends with is a single (proof is\r\nbellow). So if the string is non-descending and it has leading zeroes\r\nand trailing ones( and can be equal to zero), then the answer is (its\r\nzeroes and ones in order)We will randomly perform operations until we\r\ncanât do any more or the stringâs length is equal to , but we wont erase\r\nthe first and the last , we want to prove that the remaining stringâs\r\nlength is exactly after the process ends, proof by contradiction :So\r\nitâs length is at least , so we have at least two or at least two . If\r\nwe had two or more then the string will not be non-descending(so we can\r\nperform more operations as we proved in , but the process have ended,\r\ncontradiction!) and if we had two or more then the string will not be\r\nnon-descending. So the length of the remaining string is exactly , and\r\nwe havenât erased first â1â and last â0â, so the string is equal to\r\n\"10\", now erase â1â to get the cleanest string.Sorry if the proof seems\r\ntoo long and hard, i wanted to explain it accurately. ^-^\r\n",
    "hint": []
}