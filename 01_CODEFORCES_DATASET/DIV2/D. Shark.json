{"link": "https://codeforces.com//contest/982/problem/D", "problemId": "183674", "problem_idx": "D", "shortId": "982D", "contest_number": "982", "problem_submissions": {"D": [38375535, 38368851, 38373726, 38377162, 38371395, 38370646, 38371994, 38375134, 38373026, 38372327, 38378250, 38374514, 38364939, 38373007, 38369726, 38368852, 38367484, 38371092, 38368305], "C": [38369557, 38365950, 38368727, 38373748, 38365636, 38362990, 38360353, 38357935, 38366403, 38365707, 38366242, 38368203, 38360426, 38360914, 38358247, 38360443, 38360473, 38363231, 38362845], "B": [38368596, 38365056, 38363500, 38360346, 38360284, 38359729, 38364781, 38362446, 38362143, 38359325, 38360710, 38365274, 38357153, 38595002, 38358897, 38360993, 38362869, 38358240, 38360536, 38357974], "A": [38367216, 38364962, 38356449, 38356432, 38356314, 38356331, 38367453, 38355628, 38357632, 38356537, 38357572, 38363973, 38355536, 38355838, 38356345, 38364483, 38355616, 38357300, 38355573], "F": [38365213, 38386318, 38386309, 38375562, 38372484, 38551586], "E": [38373371, 38376699, 38377910, 38376666, 38377583, 38377503, 38378506, 38374036, 38378687, 40182999]}, "name": "D. Shark", "statement": "For long time scientists study the behavior of sharks. Sharks, as many\r\nother species, alternate short movements in a certain location and long\r\nmovements between locations.Max is a young biologist. For n days he\r\nwatched a specific shark, and now he knows the distance the shark\r\ntraveled in each of the days. All the distances are distinct. Max wants\r\nto know now how many locations the shark visited. He assumed there is\r\nsuch an integer k that if the shark in some day traveled the distance\r\nstrictly less than k, then it didn\u2019t change the location; otherwise, if\r\nin one day the shark traveled the distance greater than or equal to k;\r\nthen it was changing a location in that day. Note that it is possible\r\nthat the shark changed a location for several consecutive days, in each\r\nof them the shark traveled the distance at least k.The shark never\r\nreturned to the same location after it has moved from it. Thus, in the\r\nsequence of n days we can find consecutive nonempty segments when the\r\nshark traveled the distance less than k in each of the days: each such\r\nsegment corresponds to one location. Max wants to choose such k that the\r\nlengths of all such segments are equal.Find such integer k, that the\r\nnumber of locations is as large as possible. If there are several such\r\nk, print the smallest one.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#define rep(i,n) for(int i=1;i<=n;++i)\n#define pb push_back\nusing namespace std;\n\nusing namespace std;\n\nstruct node\n{\n\tint v,p;\n\tfriend bool operator <(node x,node y)\n\t{\n\t\treturn x.v<y.v;\n\t}\n}a[210000];\n\nstruct node2\n{\n\tint l,r;\n\tint cnt,sum;\n}st[210000*36];\n\nint v[210000],father[210000],num[210000],seq[210000];\nint n;\nint ll,ans,root,tot,sum;\n\nint getfather(int x)\n{\n\tif (x==father[x]) return x;\n\treturn father[x]=getfather(father[x]);\n}\n\nvoid modify(int &x,int l,int r,int p,int k)\n{\n\tif (x==0) \n\t{\n\t\tx=++tot; \n\t\tst[x].l=st[x].r=st[x].cnt=st[x].sum=0; \n\t}\n\tif (l==r) \n\t{\n\t    st[x].sum=st[x].sum+k; \n\t\tst[x].cnt=(st[x].sum>0);\n\t    return;\n\t}\n\tint mid=(l+r)/2;\n\tif (p<=mid)modify(st[x].l,l,mid,p,k);\n\telse modify(st[x].r,mid+1,r,p,k);\n\n\tst[x].cnt=st[st[x].l].cnt+st[st[x].r].cnt;\n}\nvoid init()\n{\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)father[i]=i,num[i]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&v[i]);\n\t\ta[i].v=v[i]; \n\t\ta[i].p=i;\n\t}\n\tsort(a+1,a+n+1);\n}\nint main()\n{\n\tinit();\n\n\trep(i,n)\n\t{\n\t    int p=a[i].p; \n\t    seq[p]=1;\n\t    if (p>1) \n\t    {\n\t    \tif (seq[p-1]==1) \n\t    \t{\n\t    \t\tint tx=getfather(p-1); \n\t    \t\tint ty=getfather(p);\n    \t\t    modify(root,1,n,num[tx],-1);\n    \t\t    father[tx]=ty;\n    \t\t    num[ty]=num[ty]+num[tx];\n    \t\t    sum++;\n\t    \t}\n\t    }\n\t    if (p<n) \n\t    {\n\t    \tif (seq[p+1]==1) \n\t    \t{\n\t    \t\tint tx=getfather(p+1); \n\t    \t\tint ty=getfather(p);\n    \t\t    modify(root,1,n,num[tx],-1);\n    \t\t    father[tx]=ty;\n    \t\t    num[ty]=num[ty]+num[tx];\n    \t\t    sum++;\n\t    \t}\n\t    }\n\t    int tx=getfather(p);\n\t    modify(root,1,n,num[tx],1);\n\t    if (st[root].cnt==1 && i-sum>ll)\n\t\t{\n\t\t\t\tll=i-sum;\n\t\t\t\tans=a[i].v+1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "dsu", "trees"], "dificulty": "1900", "interactive": false}