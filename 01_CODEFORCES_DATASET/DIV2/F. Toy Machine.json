{
    "link": "https://codeforces.com//contest/1818/problem/F",
    "problemId": "1897388",
    "problem_idx": "F",
    "shortId": "1818F",
    "contest_number": "1818",
    "problem_submissions": {
        "F": [
            203954465,
            203930910,
            203989728,
            203950170
        ],
        "E": [
            203940713,
            203952207,
            203954969,
            203955944,
            204078536,
            203944339,
            203943920,
            203965332,
            203957684,
            203924512
        ],
        "D": [
            203935580,
            203930131,
            203939536,
            203937747,
            203926993,
            203932798,
            203948151,
            203919017,
            203933133,
            203930283,
            203939418,
            203978791,
            203937294,
            203949049,
            203940699,
            203938945,
            203937604,
            203937271
        ],
        "C": [
            203927589,
            203919798,
            203928628,
            203925534,
            203931513,
            203921512,
            203927085,
            203928001,
            203926317,
            203916672,
            203923862,
            203933925,
            203926373,
            203934292,
            203922244,
            203928248,
            203928037,
            203928918
        ],
        "B": [
            203922412,
            203918213,
            203919638,
            203920216,
            203917691,
            203917420,
            203954835,
            203921335,
            203916143,
            203918490,
            203937550,
            203919150,
            203922597,
            203918604,
            203921444,
            203917928,
            203921361,
            203920046,
            203919333
        ],
        "A": [
            203919670,
            203917474,
            203915999,
            203915969,
            203915149,
            203915496,
            203915115,
            203915794,
            203934868,
            203916606,
            203917417,
            203915457,
            203960905,
            203915626,
            203915203,
            203915634,
            203917495
        ]
    },
    "name": "F. Toy Machine",
    "statement": "There is a toy machine with toys arranged in two rows of n cells each (n\r\nis odd). Initially, n-2 toys are placed in the non-corner cells of the\r\ntop row. The bottom row is initially empty, and its leftmost, rightmost,\r\nand central cells are blocked. There are 4 buttons to control the toy\r\nmachine: left, right, up, and down marked by the letters , , , and\r\ncorrespondingly.When pressing , , , or , all the toys will be moved\r\nsimultaneously in the corresponding direction and will only stop if they\r\npush into another toy, the wall or a blocked cell. Your goal is to move\r\nthe k-th toy into the leftmost cell of the top row. The toys are\r\nnumbered from 1 to n-2 from left to right. Given n and k, find a\r\nsolution that uses at most 1\r\n,000\r\n,000 button presses.To test out the toy machine, a is available that\r\nlets you play the game in real time.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nusing PI = pair<int, int>;\nusing LL = long long;\n\nconst int N = 105;\n\nint a[N];\nstring s[N];\nbool vis[N];\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint n, k; cin >> n >> k;\n\tn -= 2;\n\tint m = (n + 1) / 2;\n\tif (k == m) {\n\t\tcout << \"DL\" << endl;\n\t\treturn 0;\n\t}\n\tif (k < m) {\n\t\tfor (int i = 0; i < m - k - 1; i ++) {\n\t\t\tcout << \"RDRU\";\n\t\t}\n\t\tcout << \"RDL\" << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < k - m - 1; i ++) {\n\t\tcout << \"LDLU\";\n\t}\n\tcout << \"LDR\";\n\tfor (int i = 0; i < n; i ++) {\n\t\tcout << \"RDRU\";\n\t}\n\n\tcout << \"LU\";\n\t\n\tfor (int i = 0; i < m - 1; i ++) {\n\t\tcout << \"LDLU\";\n\t}\n\tcout << \"RU\";\n\tcout << \"RDL\" << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Toy Machine.json",
    "editorial_link": "https://codeforces.com//blog/entry/115586",
    "editorial": "Instead of caring about the positions of all the toys, we only need to care about the position of the special toy with index k\n. The other toys can be treated as undistinguishable.\n\nThe intended way of solving this problem is playing the game in the webpage, trying to come up with some simple combinations of operations that make the special toy move to another position in a predictable way. Using these building blocks in a smart way, finding a way to move the special toy to the topleft.\n\nAs the size of the grid can be up to 100000\n and we can make 1000000\n moves, we will be aiming for a solution which does a linear number of moves.\n\nThere are lots of potential solutions which use a linear number of moves, here is a relatively painless one:\n\nDo casework on k\n:\n\nCase 1\n: If 1?k<n?12\n, we initally make one R\n button press to align the toys with the right boundary. After this, there is an easy pattern to expose all the toys in the left halve, one by one: DRURDRUR...\n repeated. When the special toy is exposed, the repeating pattern is stopped, and DL\n are pressed. Toy k\n will be moved to the topleft corner.\nVisualization\nCase 2\n: If k=n?12\n, the puzzle can be solved in two moves: DL\n.\nVisualization\nCase 3\n: If n?12<k?n?2\n, we try to reduce back to case 1\n, by moving the special toy to the left halve, and ensuring that all other toys are in the top row. Using symmetry, we can apply case 1\n to k?=n?1?k\n, but mirror all horizontal moves, to move the toy to the topright corner. The other toys are no longer all in the top row. To fix this, the last pattern we need is again DRURDRUR...\n repeated. After a while of repeating this, all toys will be in the right halve of the board, occupying the top and bottom row. To finish moving the special toy (which stayed in the topright corner), we do the buttons presses LDRU\n. All toys end up in the top row, and the special toy will be at position knew=n?12?1\n, so this successfully reduces to case 1\n.\nVisualization\nHow many moves does this take? In case 1\n the pattern DRUR\n needs to be repeated at most ?n2\n times. In case 3\n, we need to use the first pattern n2\n times, and we use the second pattern n2\n times. We reduce down to case 1\n, but luckily the special toy is already close to the correct position, so only a constant number of extra moves are done.\n\nSo in total, this solution uses O(1)+max(4n2,4?2n2)=4n+O(1)\n moves. So this solution fits well within the constraints, although it is pretty wasteful.\n\nBonus: Can you prove that the optimal number of moves needed in the worstcase (over all k\n) for a width of n\n is ?(n)\n? We only did some testing of small cases, with a bruteforce BFS solution, and found that the worstcase is around n/2\n button presses.",
    "hint": []
}