{
    "link": "https://codeforces.com//contest/1330/problem/D",
    "problemId": "582581",
    "problem_idx": "D",
    "shortId": "1330D",
    "contest_number": "1330",
    "problem_submissions": {
        "E": [
            75407483,
            75403686,
            75406825,
            75412857,
            75411514,
            75411404,
            75407783,
            75407274,
            75400418,
            75447922,
            75412935,
            75466280
        ],
        "D": [
            75391296,
            75385541,
            80644507,
            75388709,
            75387337,
            75393475,
            75395701,
            75385540,
            75376125,
            75379564,
            75382546,
            75380901,
            75384917,
            75382324,
            75380657,
            75388115,
            75386567,
            75461008,
            75388223,
            75387064
        ],
        "C": [
            75379279,
            75374912,
            75381565,
            75376079,
            75376451,
            75390556,
            75381440,
            75360964,
            75379654,
            75372629,
            75367460,
            75443397,
            75374056,
            75373762,
            75374173,
            220742361,
            75370741,
            75373514,
            75361682,
            75373297
        ],
        "B": [
            75362106,
            75368513,
            75363431,
            75362706,
            75364291,
            75378289,
            75379661,
            75360912,
            75356953,
            75360775,
            75363811,
            75360857,
            75361079,
            75359545,
            195278107,
            75360634,
            75361090,
            75371429,
            75361221
        ],
        "A": [
            75355521,
            75354244,
            75354217,
            75356116,
            75354591,
            75364896,
            75353923,
            75353902,
            75354562,
            75354818,
            75353692,
            75353618,
            75362319,
            179068881,
            75354934,
            75353839,
            75364875,
            75354143
        ]
    },
    "name": "D. Dreamoon Likes Sequences",
    "statement": "Dreamoon likes sequences very much. So he created a problem about the\r\nsequence that you can’t find in OEIS: You are given two integers d, m,\r\nfind the number of arrays a, satisfying the following constraints: The\r\nlength of a is n, n\r\nge 1 1\r\nle a_1 < a_2 <\r\ndots < a_n\r\nle d Define an array b of length n as follows: b_1 = a_1,\r\nforall i > 1, b_i = b_{i - 1}\r\noplus a_i, where\r\noplus is the bitwise exclusive-or (xor). After constructing an array b,\r\nthe constraint b_1 < b_2 <\r\ndots < b_{n - 1} < b_n should hold. Since the number of possible arrays\r\nmay be too large, you need to find the answer modulo m.\r\n",
    "solutions": [
        "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nint t,d,m,now;\nll ans;\nint main(){\n\tscanf(\"%d\",&t);\n\twhile (t--){\n\t\tscanf(\"%d%d\",&d,&m); ans=1;\n\t\tfor (int i=0;;i++){\n\t\t\tif ((1<<(i+1))<=d) now=1<<i;//2^i..2^(i+1)-1\n\t\t\telse now=d-(1<<i)+1;\n\t\t\tans=ans*(now+1)%m;\n\t\t\tif ((1<<(i+1))>d) break;\n\t\t}\n\t\tprintf(\"%lld\\n\",(ans+m-1)%m);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Dreamoon Likes Sequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/75559",
    "editorial": "Firstly, we define a function h(x)\n as the position of the highest bit which is set to 1 in a positive integer x\n. For example, h(1)=0,h(2)=h(3)=1\n, and h(4)=h(7)=2\n.\n\nIf the constraints in this problem is satisfied, there is some observations, h(ai)=h(bi)\n and h(ai)\n must less than h(ai+1)\n. And luckily, if h(ai)<h(ai+1)\n is always hold, the constraints in this problem will also be satisfied (Please prove them by yourself or wait for someone prove it in comments : ) P.S. the link of proof written by someone is int the end. )\n\nIn other words, for each non-negative integer v\n, there is at most one i\n such that h(ai)=v\n. This is, at most one of the positive numbers in range [2v,min(2(v+1)?1,d)]\n can occur in ai\n. In each non-empty range, we can choose one integer in it or don't choose anyone. So for each of them we have min(2(v+1)?1,d)?2v+2\n different choice. Then according to the rule of product, we can multiply all number of choices for different v\n and minus the value by one to get the answer. For example, when d = 6, there are 2\n choices for v=0\n, 3\n choices for v=1\n, 4\n choices for v=2\n. So the answer for d=6\n is 2×3×4?1=23\n.",
    "hint": []
}