{
    "link": "https://codeforces.com//contest/1041/problem/D",
    "problemId": "220442",
    "problem_idx": "D",
    "shortId": "1041D",
    "contest_number": "1041",
    "problem_submissions": {
        "F": [
            42937145,
            42936460,
            42941789,
            42939791,
            42936055,
            42943259,
            42941945,
            42942600,
            42940476,
            42943214,
            42942904,
            42941561,
            42940422,
            42942676,
            42967085,
            42945698,
            42942819,
            42940517,
            42945082
        ],
        "E": [
            42931045,
            42932542,
            42929311,
            42932587,
            42939274,
            42934189,
            42934028,
            42935828,
            42936456,
            42936222,
            42934576,
            42934053,
            42934830,
            42936131,
            42933423,
            42935645,
            42936145,
            42934904
        ],
        "D": [
            42928058,
            42928419,
            42932086,
            42926606,
            42928328,
            42929346,
            42929592,
            42930860,
            42930895,
            42928722,
            42931546,
            42929735,
            42930750,
            42931175,
            42929657,
            42930694,
            42932165,
            42929565
        ],
        "C": [
            42924598,
            42925979,
            42923335,
            42923874,
            42924882,
            42924328,
            42925322,
            42926206,
            42927308,
            42925269,
            42926071,
            42925958,
            42929148,
            42926562,
            42925843,
            42927423,
            42929003,
            42925656
        ],
        "B": [
            42919830,
            42920297,
            42919741,
            42920667,
            42921333,
            42921057,
            42919493,
            42920331,
            42920664,
            42920599,
            42920862,
            42919750,
            42921237,
            42921905,
            42921366,
            42922548,
            42922190,
            42921585
        ],
        "A": [
            42918068,
            42918894,
            42917952,
            42918346,
            42918563,
            42921193,
            42918207,
            42918103,
            42917969,
            42918179,
            42919024,
            42917972,
            42919232,
            42918320,
            42918302,
            42919340,
            42918232,
            42918340
        ]
    },
    "name": "D. Glider",
    "statement": "A plane is flying at a constant height of h meters above the ground\r\nsurface. Let\u2019s consider that it is flying from the point (-10^9, h) to\r\nthe point (10^9, h) parallel with Ox axis.A glider is inside the plane,\r\nready to start his flight at any moment (for the sake of simplicity\r\nlet\u2019s consider that he may start only when the plane\u2019s coordinates are\r\nintegers). After jumping from the plane, he will fly in the same\r\ndirection as the plane, parallel to Ox axis, covering a unit of distance\r\nevery second. Naturally, he will also descend; thus his second\r\ncoordinate will decrease by one unit every second.There are ascending\r\nair flows on certain segments, each such segment is characterized by two\r\nnumbers x_1 and x_2 (x_1 < x_2) representing its endpoints. No two\r\nsegments share any common points. When the glider is inside one of such\r\nsegments, he doesn\u2019t descend, so his second coordinate stays the same\r\neach second. The glider still flies along Ox axis, covering one unit of\r\ndistance every second. Determine the maximum distance along Ox axis from\r\nthe point where the glider\u2019s flight starts to the point where his flight\r\nends if the glider can choose any integer coordinate to jump from the\r\nplane and start his flight. After touching the ground the glider stops\r\naltogether, so he cannot glide through an ascending airflow segment if\r\nhis second coordinate is 0.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint s[200009];\nint l[200009];\nint r[200009];\nmain(){\n    int n, h;\n    cin >> n >> h;\n    vector<pair<int,int> > v;\n    for(int i = 0; i < n; i++){\n        int a, b;\n        cin >>a >> b;\n        v.push_back({a, b});\n    }\n    sort(v.begin(),v .end());\n\n    for(int i = 1; i <= n; i++){\n        l[i] =  v[i - 1].first;\n        r[i] =  v[i - 1].second;\n    }\n    for(int i = 1; i <= n; i++){\n        s[i] = s[i - 1] +r[i] - l[i];\n    }\n    int ans = 0;\n    for(int i = 1; i <= n; i++){\n        int lo = i, hi = n;\n        while(lo < hi){\n            int mid = (lo + hi + 1)/2;\n            if(r[mid] - l[i] < s[mid] - s[i - 1] + h)\n                lo = mid;\n            else hi = mid - 1;\n        }\n        ans = max(ans, h + s[lo] - s[i - 1]);\n\n    }\n    cout << ans <<endl;\n\n\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Glider.json",
    "editorial_link": "https://codeforces.com/blog/entry/61876",
    "editorial": "At first, let\u00e2\u0080\u0099s prove that it is always optimal to jump out at the\r\nbeginning of any ascending air flows: if his point of jump is out of any\r\nair flow, he can move his point to answer will not decrease, in the same\r\nway, if his point of jump in some air flow but not in its beginning, he\r\ncan move his point to .Next observation: height of glider is\r\nnon-ascending function for the fixed point of jump, so we can for each\r\noptimal point of jump use binary search of the answer. Let glider jump\r\nout at position and we need to calculate its height at some position ,\r\nthen height is equal to , where is a total length of all flows of\r\nsegment and can be calculated using prefix sums (yes, and ).Result\r\ncomplexity of time and of memory.Of course, you can note that this task\r\ncan be solved with two pointers technique, what is faster, but it is not\r\nnecessary since built in function is fast enough (unlike some or segment\r\ntree, which should be written optimally).On the other hand, java-users\r\nneed to do some extra work by writing its own function for since will\r\ncause a slowdown.\r\n"
}