{
    "link": "https://codeforces.com//contest/439/problem/C",
    "problemId": "10096",
    "problem_idx": "C",
    "shortId": "439C",
    "contest_number": "439",
    "problem_submissions": {
        "D": [
            6805901,
            6804419,
            6803200,
            6805988,
            6804881,
            6805810,
            6805384,
            6806017,
            6807497,
            6805650,
            6808014,
            6804059,
            6806158,
            6805574,
            6805399,
            6806326,
            6804741,
            6806396,
            6808041
        ],
        "E": [
            6803795,
            6806475,
            6805122,
            6808945,
            6805874,
            6808804,
            6804029,
            6812447,
            6809672,
            6805934,
            7363028
        ],
        "C": [
            6800932,
            6800886,
            6803463,
            6802772,
            6807376,
            6802931,
            6803473,
            6802763,
            6804861,
            6803810,
            6804665,
            6808359,
            6803941,
            6812392,
            6803612,
            6803230
        ],
        "B": [
            6798509,
            6800129,
            6798401,
            6799435,
            6798872,
            6811724,
            6799339,
            6807876,
            6800630,
            6798132,
            6800776,
            6807661,
            6800880,
            6806303,
            6802646,
            6801021,
            6799365,
            6798816,
            6798888
        ],
        "A": [
            6798027,
            6801375,
            6797956,
            6798638,
            6798087,
            6798192,
            6808386,
            6799422,
            6799363,
            6798034,
            6798516,
            6806347,
            6798287,
            6808882,
            6801124,
            6798895,
            6798307,
            6798019,
            6798088
        ]
    },
    "name": "C. Devu and Partitioning of the Array",
    "statement": "Devu being a small kid, likes to play a lot, but he only likes to play\r\nwith arrays. While playing he came up with an interesting question which\r\nhe could not solve, can you please solve it for him?Given an array\r\nconsisting of distinct integers. Is it possible to partition the whole\r\narray into disjoint non-empty parts such that of the parts have even sum\r\n(each of them must have even sum) and remaining - have odd sum? (note\r\nthat parts need not to be continuous).If it is possible to partition the\r\narray, also give any possible way of valid partitioning.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<set>\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#define debug cerr<<\"OK\";\n#define f cin\n#define g cout\n#define mp make_pair\n#define pb push_back\n#define y second\n#define ll long long\n#define mod 1000000007\n#define inf (1LL<<60)\n#define N 100100\n#define DIM 1000100\n#define pct pair<long double,long double>\nusing namespace std;\n/*ifstream f(\"a.in\");\nofstream g(\"a.out\");*/\n//int dx[]={0,0,0,1,-1};\n//int dy[]={0,1,-1,0,0};\nvector<int> v[N];\nint par[N],imp[N],ti,x,tp,po,p,k,n;\nint main ()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(\"a.in\",\"r\",stdin);\n    freopen(\"a.out\",\"w\",stdout);\n    #endif\n    \n    f>>n>>k>>p;\n    p=k-p;\n    FOR(i,1,n)\n    {\n        f>>x;\n        if(x&1)\n            imp[++ti]=x;\n        else\n            par[++tp]=x;\n    }\n    while(ti>p)\n    {\n        ++po;\n        if(po==k+1)\n            po=1;\n        v[po].pb(imp[ti]);\n        v[po].pb(imp[ti-1]);\n        ti-=2;\n    }\n    if(ti!=p)\n    {\n        g<<\"NO\";\n        return 0;\n    }\n    while(tp)\n    {\n        ++po;\n        if(po==k+1)\n            po=1;\n        v[po].pb(par[tp]);\n        tp--;\n    }\n    while(ti)\n    {\n        po++;\n        if(po==k+1)\n            po=1;\n        v[po].pb(imp[ti]);\n        ti--;\n    }\n    FOR(i,1,k)\n    if(v[i].size()==0)\n    {\n        g<<\"NO\";\n        return 0;\n    }\n    g<<\"YES\\n\";\n    FOR(i,1,k)\n    {\n        g<<v[i].size()<<\" \";\n        for(int j=0;j<v[i].size();++j)\n            g<<v[i][j]<<\" \";\n        g<<\"\\n\";\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "implementation",
        "number theory"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Devu and Partitioning of the Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/12545",
    "editorial": "Let us first try to find the condition required to make sure the\r\nexistence of the partitions. Notice the following points. If the parity\r\nof sum does not match with parity of number of odd partitions () , then\r\nwe canât create the required partitions. eg. , , , Then you can not\r\ncreate two partitions of odd size, because then sum of the elements of\r\nthe partitions of the array will be even whereas the sum of elements of\r\nthe array is odd. If number of odd elements in are less than (number of\r\nrequired partitions with odd sum), then we can not do a valid\r\npartitioning. If number of even elements are less than , then we can not\r\ncreate even partitions simply by using even numbers, we have to use odd\r\nnumbers too. Notice the simple fact that sum of two odd numbers is even.\r\nHence we will try to include odd elements in our partitions too. So if\r\nwe can create partitions in which every partition contains odd elements,\r\nthen we can do a valid partitioning otherwise we canât. Here denotes the\r\nnumber of odd elements which are not used in any of the partitions made\r\nup to now. Let denotes the number of odd elements in array . Similarly\r\ndenotes the number of even elements. So the answer exists if For\r\ngenerating the actual partitions, you can follow the same strategy used\r\nin detecting the existence of the partitions. We will first generate any\r\nvalid partitions (forget about the condition of using the entire array),\r\nthen we can simply include the remaining elements of the array in the\r\nlast partition and we are done. Solution Codes [user:Gerald]âs solution\r\nmy code\r\n",
    "hint": []
}