{
    "link": "https://codeforces.com//contest/1918/problem/D",
    "problemId": "2452574",
    "problem_idx": "D",
    "shortId": "1918D",
    "contest_number": "1918",
    "problem_submissions": {
        "G": [
            244132893,
            245985475,
            244948797,
            244948670
        ],
        "F": [
            244120772,
            244125092,
            244126848,
            244126771,
            244130168,
            244131697,
            244138260,
            244138344,
            244139263,
            244138435,
            244141669,
            244144124,
            244142227,
            244122678,
            244157073,
            244156595,
            244332251,
            244124771,
            244360495,
            244129898
        ],
        "D": [
            244109167,
            244099156,
            244092966,
            244101787,
            244100881,
            244108481,
            244101721,
            244106486,
            244109529,
            244104916,
            244106995,
            244113590,
            244113865,
            244099423,
            244110295,
            244096244,
            244108027,
            244103663,
            244360463,
            244108155
        ],
        "E": [
            244103507,
            244108050,
            244110113,
            244110472,
            244112287,
            244124161,
            244125655,
            244123391,
            244119446,
            244125406,
            244135128,
            244134725,
            244128795,
            244112679,
            244118320,
            244116217,
            244928601,
            244928561
        ],
        "C": [
            244091247,
            244087599,
            244079342,
            244087694,
            244092782,
            244089213,
            244094187,
            244089808,
            244094684,
            244096501,
            244097023,
            244099017,
            244107490,
            244085730,
            244089866,
            244086764,
            244094953,
            244095107,
            244360406,
            244091142
        ],
        "B": [
            244083801,
            244076050,
            244075794,
            244073267,
            244075602,
            244075619,
            244082026,
            244079074,
            244080512,
            244082819,
            244079063,
            244082004,
            244078089,
            244075054,
            244078156,
            244075906,
            244081851,
            244083244,
            244360342,
            244080338
        ],
        "A": [
            244083099,
            244071431,
            244072186,
            244071210,
            244070855,
            244071315,
            244075506,
            244071630,
            244072257,
            244074358,
            244071939,
            244071253,
            244071114,
            244071560,
            244071154,
            244071990,
            244074495,
            244089579,
            244360312,
            244073174
        ]
    },
    "name": "D. Blocking Elements",
    "statement": "You are given an array of numbers a_1, a_2,\r\nldots, a_n. Your task is to block some elements of the array in order to\r\nminimize its cost. Suppose you block the elements with indices 1\r\nleq b_1 < b_2 <\r\nldots < b_m\r\nleq n. Then the cost of the array is calculated as the maximum of: the\r\nsum of the blocked elements, i.e., a_{b_1} + a_{b_2} +\r\nldots + a_{b_m}. the maximum sum of the segments into which the array is\r\ndivided when the blocked elements are removed. That is, the maximum sum\r\nof the following (m + 1) subarrays: [1, b_1 1], [b_1 + 1, b_2 1], [\r\nldots], [b_{m 1} + 1, b_m - 1], [b_m + 1, n] (the sum of numbers in a\r\nsubarray of the form [x,x 1] is considered to be 0). For example, if n =\r\n6, the original array is [1, 4, 5, 3, 3, 2], and you block the elements\r\nat positions 2 and 5, then the cost of the array will be the maximum of\r\nthe sum of the blocked elements (4 + 3 = 7) and the sums of the\r\nsubarrays (1, 5 + 3 = 8, 2), which is\r\nmax(7,1,8,2) = 8. You need to output the minimum cost of the array after\r\nblocking.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define N 100005\n#define P 1000000007\n#define INF 1061109567\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> PII;\ntypedef unsigned long long ull;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline ll read(){\n\tll x=0,f=1;char ch=GC;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=GC;}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=GC;}\n\treturn x*f;\n}\nint n,a[N];\nll s[N],f[N];\nint l,r,q[N];\nbool check(ll mid){\n\tf[0]=0;q[l=r=1]=0;\n\tfor(int i=1;i<=n+1;i++){\n\t\twhile(l<r&&s[i-1]-s[q[l]]>mid)l++;\n\t\tf[i]=f[q[l]]+a[i];\n\t\twhile(l<r&&f[q[r]]>f[i])r--;\n\t\tq[++r]=i;\n\t}\n\treturn f[n+1]<=mid;\n}\nvoid Solve(){\n\tn=read();\n\tfor(int i=1;i<=n;i++)a[i]=read(),s[i]=s[i-1]+a[i];\n\ta[n+1]=0;s[n+1]=s[n];\n\tll L=1,R=s[n],mid;\n\twhile(L<R){\n\t\tmid=(L+R)>>1;\n\t\tif(check(mid))R=mid;\n\t\telse L=mid+1;\n\t}\n\tprintf(\"%lld\\n\",R);\n}\nint main(){\n\tfor(int T=read();T--;)Solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Blocking Elements.json",
    "editorial_link": "https://codeforces.com//blog/entry/125300",
    "editorial": "TutorialLet\u00e2\u0080\u0099s do a binary search. Suppose we know that the minimum\r\npossible cost is at least and not greater than . Let\u00e2\u0080\u0099s choose . We need\r\nto learn how to check if the answer is less than or equal to . We will\r\ncalculate the minimum sum of blocked elements in the prefix up to if\r\nposition is blocked, and on each of the subsegments without blocked\r\nelements, the sum of elements is less than or equal to . Then for all\r\nsuch that the sum on the subsegment from to is less than or equal to .\r\nSuch form a segment, since is positive. We will maintain the boundaries\r\nof this segment. We will also maintain all for inside this subsegment in\r\nthe set. When moving from to , we will move the left boundary of the\r\nsubsegment until the sum on it becomes less than or equal to , and\r\nremove from the set, and also add to the set. The minimum sum of blocked\r\nelements under the condition that the sum on all subsegments without\r\nblocked elements is less than or equal to can be found as the minimum\r\namong all such that the sum from to is less than or equal to . If this\r\nanswer is less than or equal to , then the answer to the problem is less\r\nthan or equal to , otherwise the answer is greater than .Time\r\ncomplexity: per test case.\r\n"
}