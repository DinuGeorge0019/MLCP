{"link": "https://codeforces.com//contest/1682/problem/F", "problemId": "1407924", "problem_idx": "F", "shortId": "1682F", "contest_number": "1682", "problem_submissions": {"F": [158050798, 158077786, 158086685, 158039286, 158069961, 158110252, 158078476, 158248901], "D": [158028363, 158027200, 158028814, 158069864, 158039569, 158036346, 158030046, 158050282, 158037974, 158041123, 158041068, 158036998, 158042298, 158032953, 158041526, 158029661, 158056637, 158029667], "C": [158015824, 158013904, 158013129, 158070941, 158017154, 158019512, 158011476, 158017137, 158021257, 158018627, 158020682, 158022180, 158021471, 158039652, 158019776, 158037446, 158028182], "B": [158006894, 158007821, 158007318, 158071816, 158008119, 158009978, 158007984, 158008572, 158013225, 158009923, 158010666, 158009973, 158013386, 158010013, 158016214, 158026210, 158017588, 158010270], "A": [158004280, 158004512, 158004427, 158072894, 158004570, 158007124, 158005591, 158005462, 158005647, 158004983, 158006433, 158004812, 158012816, 158004216, 158013837, 158039471, 158008517, 158004710], "E": [158050246, 158056393, 158060063, 158060073, 158067774, 158059309, 158065396, 158067467, 158070762, 158068042, 158070815, 158073429, 158070617, 158069678, 158075426, 158064743]}, "name": "F. MCMF ", "statement": "You are given two integer arrays a and b (b_i\r\nneq 0 and |b_i|\r\nleq 10^9). Array a is sorted in order.The cost of a subarray a[l:r] is\r\ndefined as follows:If\r\nsum\r\nlimits_{j = l}^{r} b_j\r\nneq 0, then the cost is not defined.Otherwise: Construct a bipartite\r\nflow graph with r-l+1 vertices, labeled from l to r, with all vertices\r\nhaving b_i\r\nlt 0 on the left and those with b_i\r\ngt 0 on right. For each i, j such that l\r\nle i, j\r\nle r, b_i<0 and b_j>0, draw an edge from i to j with infinite capacity\r\nand cost of unit flow as |a_i-a_j|. Add two more vertices: source S and\r\nsink T. For each i such that l\r\nle i\r\nle r and b_i<0, add an edge from S to i with cost 0 and capacity |b_i|.\r\nFor each i such that l\r\nle i\r\nle r and b_i>0, add an edge from i to T with cost 0 and capacity |b_i|.\r\nThe cost of the subarray is then defined as the minimum cost of maximum\r\nflow from S to T.You are given q queries in the form of two integers l\r\nand r. You have to compute the cost of subarray a[l:r] for each query,\r\nmodulo 10^9 + 7.If you don\u2019t know what the minimum cost of maximum flow\r\nmeans, read here.\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector> \n#define int long long\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[200005],b[200005],ta[200005],qzh[200005];\nint f1[200005],f2[200005],n;\nvoid insert1(int k,int x)\n{\n\twhile(k<=n)\n\t{\n\t\tf1[k]=(f1[k]+x)%mod;\n\t\tk+=((k&(-k)));\n\t}\n}\nint query1(int k)\n{\n\tint ans=0;\n\twhile(k>=1)\n\t{\n\t\tans=(ans+f1[k])%mod;\n\t\tk-=((k)&(-k));\n\t}\n\treturn ans;\n}\nvoid insert2(int k,int x)\n{\n\twhile(k<=n)\n\t{\n\t\tf2[k]=(f2[k]+x)%mod;\n\t\tk+=((k&(-k)));\n\t}\n}\nint query2(int k)\n{\n\tint ans=0;\n\twhile(k>=1)\n\t{\n\t\tans=(ans+f2[k])%mod;\n\t\tk-=((k)&(-k));\n\t}\n\treturn ans;\n}\nint pos[200005];\nbool bi(int x,int y)\n{\n\treturn qzh[x]<qzh[y];\n}\nint ql[200005],qr[200005],qans[200005];\nvector<int>v[200005];\nsigned main()\n{\n\tint q;\n\tn=read();\n\tq=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tfor(int i=1;i<=n-1;i++)ta[i]=a[i+1]-a[i];\n\tta[n]=0;\n\tfor(int i=1;i<=n;i++)b[i]=read(),qzh[i]=qzh[i-1]+b[i],pos[i]=i;\n\tsort(pos+1,pos+n+1,bi);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tql[i]=read();\n\t\tqr[i]=read();\n\t\tv[qr[i]].push_back(i);\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint x=pos[i];\n\t\tinsert1(x,ta[x]);\n\t\tinsert2(x,(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t//printf(\"vis:%lld %lld %lld\\n\",x,ta[x],(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t\tfor(int j=0;j<v[x].size();j++)\n\t\t{\n\t\t\t//printf(\"%lld %lld %lld %lld\\n\",v[x][j],((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod,((query1(qr[v[x][j]])-query1(ql[v[x][j]]-1))%mod+mod)%mod,qzh[ql[v[x][j]]-1]);\n\t\t\tqans[v[x][j]]=(qans[v[x][j]]+((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod+mod-1LL*(qzh[ql[v[x][j]]-1]%mod+mod)%mod*((query1(qr[v[x][j]])+mod-query1(ql[v[x][j]]-1))%mod+mod)%mod)%mod;\n\t\t}\n\t}\n\t//for(int i=1;i<=q;i++)printf(\"%lld\\n\",qans[i]);\n\tfor(int i=1;i<=n;i++)f1[i]=f2[i]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=pos[i];\n\t\tinsert1(x,ta[x]);\n\t\tinsert2(x,(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t\tfor(int j=0;j<v[x].size();j++)\n\t\t{\n\t\t\tqans[v[x][j]]=(qans[v[x][j]]+mod-((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod+1LL*(qzh[ql[v[x][j]]-1]%mod+mod)%mod*((query1(qr[v[x][j]])+mod-query1(ql[v[x][j]]-1))%mod+mod)%mod)%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;i++)printf(\"%lld\\n\",qans[i]);\n\treturn 0;\n} "], "input": "", "output": "", "tags": ["data structures", "flows", "graphs", "greedy", "sortings", "two pointers"], "dificulty": "2700", "interactive": false}