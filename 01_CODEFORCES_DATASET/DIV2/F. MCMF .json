{
    "link": "https://codeforces.com//contest/1682/problem/F",
    "problemId": "1407924",
    "problem_idx": "F",
    "shortId": "1682F",
    "contest_number": "1682",
    "problem_submissions": {
        "F": [
            158050798,
            158077786,
            158086685,
            158039286,
            158069961,
            158110252,
            158078476,
            158248901
        ],
        "D": [
            158028363,
            158027200,
            158028814,
            158069864,
            158039569,
            158036346,
            158030046,
            158050282,
            158037974,
            158041123,
            158041068,
            158036998,
            158042298,
            158032953,
            158041526,
            158029661,
            158056637,
            158029667
        ],
        "C": [
            158015824,
            158013904,
            158013129,
            158070941,
            158017154,
            158019512,
            158011476,
            158017137,
            158021257,
            158018627,
            158020682,
            158022180,
            158021471,
            158039652,
            158019776,
            158037446,
            158028182
        ],
        "B": [
            158006894,
            158007821,
            158007318,
            158071816,
            158008119,
            158009978,
            158007984,
            158008572,
            158013225,
            158009923,
            158010666,
            158009973,
            158013386,
            158010013,
            158016214,
            158026210,
            158017588,
            158010270
        ],
        "A": [
            158004280,
            158004512,
            158004427,
            158072894,
            158004570,
            158007124,
            158005591,
            158005462,
            158005647,
            158004983,
            158006433,
            158004812,
            158012816,
            158004216,
            158013837,
            158039471,
            158008517,
            158004710
        ],
        "E": [
            158050246,
            158056393,
            158060063,
            158060073,
            158067774,
            158059309,
            158065396,
            158067467,
            158070762,
            158068042,
            158070815,
            158073429,
            158070617,
            158069678,
            158075426,
            158064743
        ]
    },
    "name": "F. MCMF ",
    "statement": "You are given two integer arrays a and b (b_i\r\nneq 0 and |b_i|\r\nleq 10^9). Array a is sorted in order.The cost of a subarray a[l:r] is\r\ndefined as follows:If\r\nsum\r\nlimits_{j = l}^{r} b_j\r\nneq 0, then the cost is not defined.Otherwise: Construct a bipartite\r\nflow graph with r-l+1 vertices, labeled from l to r, with all vertices\r\nhaving b_i\r\nlt 0 on the left and those with b_i\r\ngt 0 on right. For each i, j such that l\r\nle i, j\r\nle r, b_i<0 and b_j>0, draw an edge from i to j with infinite capacity\r\nand cost of unit flow as |a_i-a_j|. Add two more vertices: source S and\r\nsink T. For each i such that l\r\nle i\r\nle r and b_i<0, add an edge from S to i with cost 0 and capacity |b_i|.\r\nFor each i such that l\r\nle i\r\nle r and b_i>0, add an edge from i to T with cost 0 and capacity |b_i|.\r\nThe cost of the subarray is then defined as the minimum cost of maximum\r\nflow from S to T.You are given q queries in the form of two integers l\r\nand r. You have to compute the cost of subarray a[l:r] for each query,\r\nmodulo 10^9 + 7.If you don\u2019t know what the minimum cost of maximum flow\r\nmeans, read here.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector> \n#define int long long\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[200005],b[200005],ta[200005],qzh[200005];\nint f1[200005],f2[200005],n;\nvoid insert1(int k,int x)\n{\n\twhile(k<=n)\n\t{\n\t\tf1[k]=(f1[k]+x)%mod;\n\t\tk+=((k&(-k)));\n\t}\n}\nint query1(int k)\n{\n\tint ans=0;\n\twhile(k>=1)\n\t{\n\t\tans=(ans+f1[k])%mod;\n\t\tk-=((k)&(-k));\n\t}\n\treturn ans;\n}\nvoid insert2(int k,int x)\n{\n\twhile(k<=n)\n\t{\n\t\tf2[k]=(f2[k]+x)%mod;\n\t\tk+=((k&(-k)));\n\t}\n}\nint query2(int k)\n{\n\tint ans=0;\n\twhile(k>=1)\n\t{\n\t\tans=(ans+f2[k])%mod;\n\t\tk-=((k)&(-k));\n\t}\n\treturn ans;\n}\nint pos[200005];\nbool bi(int x,int y)\n{\n\treturn qzh[x]<qzh[y];\n}\nint ql[200005],qr[200005],qans[200005];\nvector<int>v[200005];\nsigned main()\n{\n\tint q;\n\tn=read();\n\tq=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tfor(int i=1;i<=n-1;i++)ta[i]=a[i+1]-a[i];\n\tta[n]=0;\n\tfor(int i=1;i<=n;i++)b[i]=read(),qzh[i]=qzh[i-1]+b[i],pos[i]=i;\n\tsort(pos+1,pos+n+1,bi);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tql[i]=read();\n\t\tqr[i]=read();\n\t\tv[qr[i]].push_back(i);\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint x=pos[i];\n\t\tinsert1(x,ta[x]);\n\t\tinsert2(x,(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t//printf(\"vis:%lld %lld %lld\\n\",x,ta[x],(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t\tfor(int j=0;j<v[x].size();j++)\n\t\t{\n\t\t\t//printf(\"%lld %lld %lld %lld\\n\",v[x][j],((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod,((query1(qr[v[x][j]])-query1(ql[v[x][j]]-1))%mod+mod)%mod,qzh[ql[v[x][j]]-1]);\n\t\t\tqans[v[x][j]]=(qans[v[x][j]]+((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod+mod-1LL*(qzh[ql[v[x][j]]-1]%mod+mod)%mod*((query1(qr[v[x][j]])+mod-query1(ql[v[x][j]]-1))%mod+mod)%mod)%mod;\n\t\t}\n\t}\n\t//for(int i=1;i<=q;i++)printf(\"%lld\\n\",qans[i]);\n\tfor(int i=1;i<=n;i++)f1[i]=f2[i]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=pos[i];\n\t\tinsert1(x,ta[x]);\n\t\tinsert2(x,(1LL*qzh[x]%mod*ta[x]%mod+mod)%mod);\n\t\tfor(int j=0;j<v[x].size();j++)\n\t\t{\n\t\t\tqans[v[x][j]]=(qans[v[x][j]]+mod-((query2(qr[v[x][j]])-query2(ql[v[x][j]]-1))%mod+mod)%mod+1LL*(qzh[ql[v[x][j]]-1]%mod+mod)%mod*((query1(qr[v[x][j]])+mod-query1(ql[v[x][j]]-1))%mod+mod)%mod)%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;i++)printf(\"%lld\\n\",qans[i]);\n\treturn 0;\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "flows",
        "graphs",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. MCMF .json",
    "editorial_link": "https://codeforces.com//blog/entry/103097",
    "editorial": "TutorialLet us suppose we need to calculate the answer for only one\r\nquery, say complete array i.e .The scary flow structure in the problem\r\ncan be reduced as-Let\u00e2\u0080\u0099s replicate each vertex , times. Then we can see\r\nthat there will be an equal number of vertices on the left and right\r\nside. Now the problem reduces that we have to match these vertices with\r\nminimum cost such that the cost of matching and is .There are only 2\r\ntype of elements (left side and right side) and the following greedy\r\nalgorithm to match the elements works.Algorithm: Sort the type and\r\nelements independently and match them in the sorted order. ProofAssume\r\nthat two elements from left are matched with two elements from right as\r\nand , then it can be easily shown that matching and is always more\r\noptimal. The proof is left as an excercise to reader.Since the array is\r\ngiven in sorted order, let\u00e2\u0080\u0099s use it!!Let\u00e2\u0080\u0099s assume- Type elements are\r\nthose having . Type elements are those having . Now instead of\r\nreplicating elements times and sorting them independently, let\u00e2\u0080\u0099s iterate\r\non array from left to right and add the contribution of each element\r\nindependently. Say we are at index , and prefix sum of so far is , then\r\nthe following cases arise- , There is no unmatched type element on the\r\nleft, so we just add this element\u00e2\u0080\u0099s contribution to the answer i.e . ,\r\nThere are more than unmatched type elements on the left, so we match of\r\nthem to , adding a contribution of to the answer. , and There are less\r\nthan unmatched elements () on the left, so we match those with equal\r\nnumber of and remaining are propagated further, adding a contribution of\r\n, where the positive term comes from those matching with previous\r\nunmatched elements and the negative term comes from those that are going\r\nto be left unmatched. Similar cases are there for .Ok so now we can\r\neasily solve the problem for one query in .Main idea:Let\u00e2\u0080\u0099s simulate the\r\nabove algorithm for every suffix and record the obtained answer in for\r\nsuffix. Note that the value doesn\u00e2\u0080\u0099t denote any answer for some suffix\r\nbecause the sum of over that suffix might or might not be zero. One\r\nimportant observation here is that- Let some subarray for which sum of\r\nis , then do have a good meaning, it\u00e2\u0080\u0099s the answer for that query indeed.\r\nProofOur answer for would have been the result of simulation on the\r\nsubarray, but how does simulation on suffix looks?It greedily matches\r\nthe subarray first because the sum of is zero, so it will surely pair up\r\nall elements in that subarray. Then it moves further on and continuing\r\nthe simulation after is equivalent to starting the simulation from\r\nitself because so far (defined above) would be automatically 0.Note that\r\ndoesn\u00e2\u0080\u0099t have any physical meaning because it will add some junk value if\r\nelements after are not paired up equally but those junk values are\r\nexactly same in and which cancel out, giving the correct answer.But\r\nstill, we can\u00e2\u0080\u0099t simulate for every suffix, right? It would go\r\nagain.Let\u00e2\u0080\u0099s iterate from left to right and for every try calculating\r\nit\u00e2\u0080\u0099s contribution in , , ..., suffixes which is easy because it depends\r\nonly on , (which are constant for a given ) and for contribution to\r\nsuffix. This is pretty standard using fenwick trees.How to calculate ?\r\nLet\u00e2\u0080\u0099s solve and independently, say for now. Other case is similar.Let\r\n.Consider the contribution of index to for , from three cases described\r\nabove the contribution is different for different with different . We\r\ncan build a fenwick tree on compressed prefix sums. Case and above add a\r\nconstant value to a range of prefix sums that can be maintained in one\r\nfenwick tree and Case gives some linear function of to be added in a\r\nrange that can be maintained in other fenwick tree. Add contribution of\r\neach from to first, and let\u00e2\u0080\u0099s start calculating . For , can be obtained\r\nby querying at in both fenwicks. Then we remove the contribution of from\r\nthe two fenwick trees (simply the negative of which we added above),\r\nbecause won\u00e2\u0080\u0099t be contributing to any suffix other than one. Similarly we\r\nmove from left to right and calculate by querying at and then remove the\r\ncontribution of element.\r\n"
}