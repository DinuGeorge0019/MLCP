{
    "link": "https://codeforces.com//contest/1080/problem/F",
    "problemId": "259658",
    "problem_idx": "F",
    "shortId": "1080F",
    "contest_number": "1080",
    "problem_submissions": {
        "F": [
            46161976,
            46162778,
            46160192,
            46159146,
            46160650,
            46161330,
            46177225,
            46181279,
            46177040,
            46159242,
            46165879,
            46244094
        ],
        "E": [
            46159833,
            46158289,
            46156414,
            46159947,
            46162060,
            46170130,
            46156194,
            46160134,
            46157810,
            46160983,
            46162313,
            46162730,
            46268200,
            46162883,
            46161436,
            46165893,
            46162523,
            46157004,
            46162154
        ],
        "D": [
            46156149,
            46155986,
            46154022,
            46155513,
            46158228,
            46156068,
            46156726,
            46159618,
            46156456,
            46155088,
            46157318,
            46173998,
            46159164,
            46155242,
            46156719,
            46155734,
            46161044,
            46159764
        ],
        "C": [
            46152444,
            46149941,
            46152568,
            46150576,
            46153451,
            46151555,
            46151650,
            46150697,
            46153316,
            46152202,
            46153935,
            46150267,
            46152022,
            46151720,
            46151339,
            46154831,
            46152462,
            46152573,
            46153346,
            46152817
        ],
        "B": [
            46149045,
            46145345,
            46149235,
            46146926,
            46149668,
            46147319,
            46152091,
            46147240,
            46146639,
            46147840,
            46147532,
            46146841,
            46147485,
            46146840,
            46146905,
            46150391,
            46147300,
            46147235,
            46147802,
            46148682
        ],
        "A": [
            46146332,
            46144961,
            46147960,
            46145347,
            46146629,
            46145256,
            46151812,
            46146189,
            46145164,
            46147556,
            46144974,
            46145039,
            46145991,
            46145058,
            46145185,
            46149238,
            46145401,
            46145176,
            46145572,
            46145659
        ]
    },
    "name": "F. Katya and Segments Sets",
    "statement": "It is a very important day for Katya. She has a test in a programming\r\nclass. As always, she was given an interesting problem that she solved\r\nvery fast. Can you solve that problem?You are given n ordered segments\r\nsets. Each segment can be represented as a pair of two integers [l, r]\r\nwhere l\r\nleq r. Each set can contain an arbitrary number of segments (even 0). It\r\nis possible that some segments are equal.You are also given m queries,\r\neach of them can be represented as four numbers: a, b, x, y. For each\r\nsegment, find out whether it is true that each set p (a\r\nleq p\r\nleq b) contains at least one segment [l, r] that lies entirely on the\r\nsegment [x, y], that is x\r\nleq l\r\nleq r\r\nleq y. Find out the answer to each query.Note that you need to solve\r\nthis problem . That is, you will get a new query only after you print\r\nthe answer for the previous query.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 300050;\nconst int NN = N * 20;\nconst int INF = 2000000000;\n\nint root[N], maxv[NN], lc[NN], rc[NN], cnt = 1;\n\nvoid insert(int &o, int l, int r, int p, int y) {\n  maxv[cnt] = maxv[o];\n  lc[cnt] = lc[o];\n  rc[cnt] = rc[o];\n  o = cnt++;\n  if (l == r) maxv[o] = std::min(maxv[o], y);\n  else {\n    int mid = (l + r) / 2;\n    if (p <= mid) insert(lc[o], l, mid, p, y);\n    else insert(rc[o], mid + 1, r, p, y);\n    maxv[o] = std::max(maxv[lc[o]], maxv[rc[o]]);\n  }\n}\n\nint query(int o, int l, int r, int L, int R) {\n  if (l > R || L > r) return 0;\n  if (!o) return INF;\n  if (L <= l && r <= R) return maxv[o];\n  int mid = (l + r) / 2;\n  return std::max(query(lc[o], l, mid, L, R), query(rc[o], mid + 1, r, L, R));\n}\n\nstruct Interval {\n  int l, r, p;\n  friend bool operator<(const Interval &a, const Interval &b) {\n    return a.l > b.l;\n  }\n} I[N];\n\nint n, m, k;\n\nint main(){\n  maxv[0] = INF;\n  lc[0] = rc[0] = 0;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 0; i < k; ++i)\n    scanf(\"%d%d%d\", &I[i].l, &I[i].r, &I[i].p);\n  std::sort(I, I + k);\n  root[0] = 0;\n  for (int i = 0; i < k; ++i) {\n    //printf(\"  %d %d %d %d\\n\", i, I[i].l, I[i].r, I[i].p);\n    insert(root[i + 1] = root[i], 1, n, I[i].p, I[i].r);\n  }\n  while (m--) {\n    int a, b, x, y;\n    scanf(\"%d%d%d%d\", &a, &b, &x, &y);\n    Interval t;\n    t.l = x;\n    int i = std::upper_bound(I, I + k, t) - I;\n    //printf(\"  %d \", i);\n    puts(query(root[i], 1, n, a, b) <= y ? \"yes\" : \"no\");\n    fflush(stdout);\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "interactive",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Katya and Segments Sets.json",
    "editorial_link": "https://codeforces.com//blog/entry/63436",
    "editorial": "Let\u00e2\u0080\u0099s have an array in which we will store each segment and the number\r\nof the set to which it belongs. Sort this array in the non-decreasing\r\norder of the left border. If the left border is equal, we sort in random\r\norder.Now consider any query . We should find the first position where\r\nthe left border of the segment is greater than or equal to . If there is\r\nno such position, then it is obvious that the answer will be \"\", since\r\nthere is no set that contains at least one suitable segment. Otherwise,\r\nwe are interested only in the segments from the position that we have\r\nfound to the last segment in the array. We can forget about the rest.\r\nNow let\u00e2\u0080\u0099s among these segments for each set with a number from to , find\r\nthe minimum number , such that there exists at least one segment that\r\nbelongs to this set and its right bound is (note that we consider only\r\nthose segments whose left bound is greater than or equal to ). If for\r\nsome segment this number is greater than , then the answer is \"\".\r\nOtherwise the answer is \"\".Let\u00e2\u0080\u0099s create a persistent segment tree, where\r\nfor each set we keep its number . We will update our values in reverse\r\norder from the last segment to the first one. After hanging the value of\r\nthe new , we will save the current version in our segment tree.Then how\r\nto respond to requests? Let\u00e2\u0080\u0099s find the position starting from which all\r\nthe left borders of our segments will be at least . After that, take the\r\nversion of the persistent tree of segments that was added immediately\r\nafter adding this segment. And in this segment tree, we take the minimum\r\non the segment from to . If our minimum is greater than , then the\r\nanswer is \"\". Otherwise the answer is \"\".\r\n"
}