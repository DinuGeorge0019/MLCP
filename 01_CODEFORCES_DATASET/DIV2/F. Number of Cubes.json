{
    "link": "https://codeforces.com//contest/2040/problem/F",
    "problemId": "3075500",
    "problem_idx": "F",
    "shortId": "2040F",
    "contest_number": "2040",
    "problem_submissions": {
        "E": [
            295634858,
            295598220,
            295603659,
            295602852,
            295609062,
            295608956,
            295609438,
            295613265,
            295617536,
            295622256,
            295615426,
            295623087,
            295613034,
            295632243,
            295615757,
            295623729,
            295822197,
            295614576,
            295629623,
            295677087,
            295677053,
            295616459,
            295615739
        ],
        "F": [
            295625297,
            295602948,
            295765575,
            295764437,
            295628810,
            295613638,
            295772184
        ],
        "C": [
            295613817,
            295578002,
            295582361,
            295582510,
            295585319,
            295585121,
            295589541,
            295584238,
            295583765,
            295584198,
            295582424,
            295585127,
            295590138,
            295581996,
            295587456,
            295580712,
            295586116,
            295581622,
            295590178,
            295583863
        ],
        "D": [
            295602955,
            295588244,
            295593423,
            295591690,
            295596226,
            295661257,
            295596632,
            295595711,
            295594858,
            295602270,
            295597697,
            295602059,
            295598368,
            295600419,
            295605426,
            295590011,
            295601199,
            295607620
        ],
        "B": [
            295586789,
            295590381,
            295574073,
            295576257,
            295574329,
            295574189,
            295580781,
            295572257,
            295573109,
            295573299,
            295575453,
            295572099,
            295577165,
            295593436,
            295571846,
            295572279,
            295571755,
            295574449,
            295577717,
            295572094
        ],
        "A": [
            295581636,
            295569030,
            295573127,
            295568276,
            295571294,
            295574905,
            295568027,
            295568114,
            295567840,
            295567999,
            295568293,
            295568412,
            295569901,
            295568913,
            295567935,
            295568054,
            295568783,
            295570941,
            295568578
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137074",
    "editorial": "Recall Burnside\u00e2\u0080\u0099s lemma the number of elements up to an action group\r\nis:, where if and if .Let\u00e2\u0080\u0099s try to iterate over the elements of the\r\naction group all triplets of numbers , , . When applying a fixed action\r\n, the element moves to this vector. Let\u00e2\u0080\u0099s choose a cell and add a vector\r\nto it until we reach it again. We have drawn a cycle all cells on it\r\nmust be of the same type. An example of such a traversal for , (each\r\ndifferent number in the table corresponds to a cycle):\r\n123123123456456456123123123456456456 You can count the cycles by\r\ntraversal, or you can derive formula: the length of all cycles is the\r\nsame and equals .What\u00e2\u0080\u0099s good about the equal lengths of the cycles?\r\nBecause the formula for calculating the number of stationary\r\nparallelepipeds is simple. First, all must be divisible by . Then we\r\ndistribute them among the cycles. This is the multinomial coefficient\r\nfor .Current total time : iterated over vector triplets, calculated ,\r\nchecked divisibility for all numbers, and if successful, calculated the\r\nmultinomial coefficient of size .Let\u00e2\u0080\u0099s speed up the solution. Let\u00e2\u0080\u0099s\r\ncalculate . Since all are divisible by , then is also divisible by .\r\nThere are no more different than the number of divisors of . Let\u00e2\u0080\u0099s\r\ncalculate the number of triplets that give each value of , and at the\r\nend we will calculate the multinomial coefficient for all identical\r\nvalues of at once.The total time is , where is the number of divisors of\r\n, and appears due to the calculation of .Let\u00e2\u0080\u0099s continue to speed up the\r\nsolution. There are two solutions further.Solution 1.Let\u00e2\u0080\u0099s look again at\r\nthe formula . For convenience, we will focus on the first element. Let\u00e2\u0080\u0099s\r\nsay we want the first element to be . Then is divisible by and . is\r\ndivisible by , so is divisible by . Then the possible are of the form ,\r\nwhere , and the equality is exactly satisfied. is coprime to , otherwise\r\nthe value of will be multiplied by their common divisor and the equality\r\nwill be violated. Therefore the number of suitable is equal to , where\r\nEuler\u00e2\u0080\u0099s function.So, let\u00e2\u0080\u0099s enumerate triplets of divisors of , and . The\r\nnumber of ways to obtain a triple is equal to . Let\u00e2\u0080\u0099s calculate using\r\nthe Sieve of Eratosthenes.We get a solution in and for\r\npre-calculation.Solution 2.Let\u00e2\u0080\u0099s calculate the same using dynamic\r\nprogramming. For convenience, we denote the dimensions of , , and by the\r\narray . Let be the number of ways, having passed dimensions, to obtain\r\nequal to . The transitions will be as follows: we will iterate over the\r\npairs of the previous and the next divisor of the size of the next\r\ndimension . Then the new will be equal to and we make the transition ,\r\nwhere the number of such that .How to calculate the array . We cannot\r\ncalculate it trivially in , since it is too long time. For simplicity,\r\nwe calculate the array equal to the number of such that . We iterate\r\nover the divisors of in ascending order. Let the current divisor be .\r\nAdd to , since that many will be divisible by . Those that are divisible\r\nby but are not equal to it, we will subtract later. We iterate over the\r\ndivisors of . We subtract from , since their is actually not , but or a\r\nnumber that divides. Let\u00e2\u0080\u0099s calculate .If we pre-calculate the divisors\r\nof all numbers and compress their \"coordinates\", we get a solution in .\r\n",
    "name": "F. Number of Cubes",
    "statement": "Consider a rectangular parallelepiped with sides a, b, and c, that\r\nconsists of unit cubes of k different colors. We can apply cyclic shifts\r\nto the parallelepiped in any of the three directions any number of\r\ntimes^{\r\ntext{ }}.There are d_i cubes of the i-th color (1\r\nle i\r\nle k). How many different parallelepipeds (with the given sides) can be\r\nformed from these cubes, no two of which can be made equal by some\r\ncombination of cyclic shifts?^{\r\ntext{ }}On the image: Top left shows the top view of the original\r\nparallelepiped. Lower layers will shift in the same way as the top\r\nlayer. Top right shows the top view of a parallelepiped shifted to the\r\nright by 1. Bottom left shows the top view of a parallelepiped shifted\r\ndown by 2. Bottom right shows the top view of a parallelepiped shifted\r\nto the right by 1 and down by 2.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0using ll = long long;using ld = long double;using pii = pair<int, int>;using pll = pair<ll, ll>;using vi = vector<int>;using vll = vector<ll>;\u00a0constexpr int INF = 1000000000;constexpr ll LINF = 1000000000000000000LL;constexpr ld EPS = 1e-9;\u00a0#ifdef MOD#undef MOD#endifconstexpr int MOD = 998244353;\u00a0#define fast_io() ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)#define all(x) (x).begin(), (x).end()#define sz(x) ((int)(x).size())#define pb push_back#define fi first#define se second\u00a0static const int MAXN = 3000000;static ll fact[MAXN+1], invfact[MAXN+1];static int phi_arr[MAXN+1];\u00a0inline ll modexp(ll base, ll exp) {    ll res = 1 % MOD, cur = base % MOD;    while (exp > 0) {        if (exp & 1) res = (res * cur) % MOD;        cur = (cur * cur) % MOD;        exp >>= 1;    }    return res;}\u00a0inline void precompute_factorials(int n) {    fact[0] = 1;    for (int i = 1; i <= n; i++) fact[i] = fact[i-1]*i % MOD;    invfact[n] = modexp(fact[n], MOD-2);    for (int i = n-1; i >= 0; i--) invfact[i] = invfact[i+1]*(i+1)%MOD;}\u00a0inline void precompute_phi(int n) {    for (int i = 1; i <= n; i++) phi_arr[i] = i;    for (int i = 2; i <= n; i++) {        if (phi_arr[i] == i) {            for (int j = i; j <= n; j += i) {                phi_arr[j] -= phi_arr[j]/i;            }        }    }}\u00a0inline ll ways_from_counts(const vi &counts) {    int M = 0; for (auto &x: counts) M += x;    ll ans = fact[M];    for (auto &x: counts) ans = (ans * invfact[x]) % MOD;    return ans;}\u00a0inline vi get_divisors(int x) {    vi divs;    for (int i = 1; i*i <= x; i++) {        if (x % i == 0) {            divs.pb(i);            if (i*i != x) divs.pb(x/i);        }    }    return divs;}\u00a0inline int lcm_int(int x, int y) {return (int)((ll)x / __gcd(x,y) * (ll)y);}\u00a0void solve() {    int a,b,c,k; cin >> a >> b >> c >> k;    vi d(k);    for (int i = 0; i < k; i++) cin >> d[i];\u00a0    ll abc = (ll)a*b*c;    vector<ll> countArr(abc+1, 0);\u00a0    vi divA = get_divisors(a), divB = get_divisors(b), divC = get_divisors(c);\u00a0    for (auto X: divA) {        int phiX = phi_arr[X];        for (auto Y: divB) {            int phiY = phi_arr[Y];            int L = lcm_int(X,Y);            for (auto Z: divC) {                int phiZ = phi_arr[Z];                int L2 = lcm_int(L,Z);                countArr[L2] += (ll)phiX * phiY * phiZ;            }        }    }\u00a0    ll ans = 0;    for (int tt = 1; tt <= (int)abc; tt++) {        if (countArr[tt] == 0) continue;        bool divisible = true;        for (auto &x: d) {            if (x % tt != 0) { divisible = false; break; }        }        if (!divisible) continue;        int M = (int)(abc/tt);        vi div_counts(k);        for (int i = 0; i < k; i++) div_counts[i] = d[i]/tt;        ll w = ways_from_counts(div_counts);        ll addVal = (w * (countArr[tt] % MOD)) % MOD;        ans = (ans + addVal) % MOD;    }\u00a0    ll inv_abc = modexp(abc, MOD-2);    ans = (ans * inv_abc) % MOD;\u00a0    cout << ans << \"\\n\";}\u00a0int main() {    fast_io();    int t; cin >> t;    precompute_factorials(MAXN);    precompute_phi(MAXN);    while (t--) solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Number of Cubes.json"
}