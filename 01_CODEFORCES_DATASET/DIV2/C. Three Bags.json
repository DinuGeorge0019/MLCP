{"link": "https://codeforces.com//contest/1467/problem/C", "problemId": "858754", "problem_idx": "C", "shortId": "1467C", "contest_number": "1467", "problem_submissions": {"A": [103781028, 103732975, 103789355, 103727649, 103776107, 103728134, 103733285, 103731503, 103734108, 103745618, 103776057, 103728589, 103737241, 103730063, 103728536, 103782858, 103740519, 103780744, 103730125, 103733429], "B": [103776223, 103763378, 103735716, 103743111, 103753392, 103747731, 103744698, 103825399, 103745451, 103752738, 103745778, 103769242, 103752112, 103747036, 103750474, 103751826, 103737251, 103751660, 103806893, 103752900, 103749089], "C": [103771486, 103780246, 103746693, 103766971, 103761062, 103800886, 103767932, 103776708, 103770869, 103762101, 103786323, 103768958, 103786670, 103776678, 103772104, 103785995, 103773040, 103799284, 103805177, 103785884], "D": [103764796, 103781468, 103759529, 103758056, 103768367, 103763856, 103774343, 103763817, 103781960, 103777881, 103743423, 103779264, 103772933, 103764332, 103785499, 103746072, 103785798, 103785854, 103759639, 103785071], "E": [103749029, 103758281, 103840304, 103785768, 103786917, 103785220, 103779762, 103798134, 103802685, 103796217, 103804930, 103797788, 103804889, 103803175, 103801192, 103810505, 103804335, 103855637, 103803060, 103803658, 103762986, 103795272, 103809021]}, "name": "C. Three Bags", "statement": "You are given bags. Each bag contains a non-empty multiset of numbers.\r\nYou can perform a number of operations on these bags. In one operation,\r\nyou can choose any two non-empty bags, and choose one number from each\r\nof the bags. Let\u2019s say that you choose number a from the first bag and\r\nnumber b from the second bag. Then, you remove b from the second bag and\r\nreplace a with a-b in the first bag. Note that if there are multiple\r\noccurrences of these numbers, then you shall only remove/replace exactly\r\none occurrence.You have to perform these operations in such a way that\r\nyou have exactly one number remaining in exactly one of the bags (the\r\nother two bags being empty). It can be shown that you can always apply\r\nthese operations to receive such a configuration in the end. Among all\r\nthese configurations, find the one which has the maximum number left in\r\nthe end.\r\n", "solutions": ["// author: xay5421\n// created: Fri Jan  8 23:21:46 2021\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\ntypedef long long LL;\nint n[3];\nvector<int>v[3];\nLL sum[3],ans;\nint main(){\n\trep(i,0,2)scanf(\"%d\",&n[i]);\n\trep(i,0,2){\n\t\tv[i].resize(n[i]);\n\t\trep(j,0,n[i]-1)scanf(\"%d\",&v[i][j]),sum[i]+=v[i][j];\n\t\tsort(v[i].begin(),v[i].end());\n\t}\n\trep(i,0,2)rep(j,i+1,2){\n\t\tans=max(ans,sum[0]+sum[1]+sum[2]-v[i][0]*2-v[j][0]*2);\n\t}\n\trep(i,0,2){\n\t\tans=max(ans,sum[0]+sum[1]+sum[2]-sum[i]*2);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "1900", "interactive": false}