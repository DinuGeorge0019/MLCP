{
    "link": "https://codeforces.com//contest/1114/problem/D",
    "problemId": "295526",
    "problem_idx": "D",
    "shortId": "1114D",
    "contest_number": "1114",
    "problem_submissions": {
        "E": [
            49723158,
            49715728,
            49717586,
            49715673,
            49722801,
            49716158,
            49718191,
            49719573,
            49752574,
            49752490,
            49731134,
            49732179,
            49723266,
            49731088,
            49731791,
            49709398,
            49709699,
            49747930,
            49752856,
            49752305,
            49752243,
            49751661,
            49717020,
            49711667,
            49716380
        ],
        "D": [
            49715413,
            49709860,
            49711770,
            49711237,
            49709601,
            49710358,
            49712973,
            49713792,
            49713441,
            49727466,
            49728830,
            49707199,
            49710354,
            49729290,
            49706402,
            49726434,
            49712605,
            49711462,
            49713489,
            49710031
        ],
        "F": [
            49712180,
            49727873,
            49729579,
            49729533,
            49726481,
            49727101,
            49727851,
            49731205,
            49722332,
            49708876,
            49721497,
            49732987,
            49730916,
            49722816,
            49711859,
            49722110,
            49737560,
            49795547
        ],
        "B": [
            49703429,
            49701684,
            49702412,
            49706794,
            49704297,
            49702841,
            49708341,
            49704456,
            49705411,
            49718896,
            49701034,
            49703871,
            49704671,
            49716920,
            49700530,
            49704223,
            49704334,
            49707941,
            49702883,
            49701403
        ],
        "C": [
            49701343,
            49703467,
            49706082,
            49704226,
            49698909,
            49708135,
            49709609,
            49709215,
            49708563,
            49712949,
            49704721,
            49705449,
            49707404,
            49724763,
            49703776,
            49705794,
            49710442,
            49704405,
            49704935,
            49704203
        ],
        "A": [
            49696863,
            49696786,
            49698271,
            49697340,
            49701634,
            49697080,
            49706366,
            49697215,
            49702348,
            49720550,
            49696844,
            49696791,
            49698691,
            49696775,
            49697211,
            49696953,
            49699702,
            49696860,
            49697429,
            49697130
        ]
    },
    "name": "D. Flood Fill",
    "statement": "You are given a line of n colored squares in a row, numbered from 1 to n\r\nfrom left to right. The i-th square initially has the color c_i.Letâ€™s\r\nsay, that two squares i and j belong to the same connected component if\r\nc_i = c_j, and c_i = c_k for all k satisfying i < k < j. In other words,\r\nall squares on the segment from i to j should have the same color.For\r\nexample, the line [3, 3, 3] has 1 connected component, while the line\r\n[5, 2, 4, 4] has 3 connected components.The game \"flood fill\" is played\r\non the given line as follows: At the start of the game you pick any\r\nstarting square (this is not counted as a turn). Then, in each game\r\nturn, change the color of the connected component containing the\r\nstarting square to any other color. Find the minimum number of turns\r\nneeded for the entire line to be changed into a single color.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 5050;\nconst int MOD = 1000000007;\n\nint c[MAXN];\nint nxt[MAXN], prv[MAXN];\nint dp[MAXN][MAXN][2];\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i];\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    int nxt = n + 1;\n    for (int j = i; j <= n; ++j) {\n      if (c[j] != c[i]) {\n        nxt = j;\n        break;\n      }\n    }\n    ::nxt[i] = nxt;\n    int prv = -1;\n    for (int j = i; j >= 1; --j) {\n      if (c[j] != c[i]) {\n        prv = j;\n        break;\n      }\n    }\n    ::prv[i] = prv;\n  }\n\n  for (int len = 1; len <= n; ++len) {\n    for (int l = 1; l + len - 1 <= n; ++l) {\n      int r = l + len - 1;\n      if (nxt[l] > r) {\n        dp[l][r][0] = dp[l][r][1] = 0;\n        continue;\n      }\n\n      dp[l][r][0] = dp[l][r][1] = n + 1;\n\n      int a = nxt[l];\n      int b = prv[r];\n\n      dp[l][r][0] = min(dp[a][r][0] + (c[l] != c[a]), dp[l][r][0]);\n      dp[l][r][0] = min(dp[a][r][1] + (c[l] != c[r]), dp[l][r][0]);\n      dp[l][r][1] = min(dp[l][b][1] + (c[r] != c[b]), dp[l][r][1]);\n      dp[l][r][1] = min(dp[l][b][0] + (c[r] != c[l]), dp[l][r][1]);\n    }\n  }\n  cout << min(dp[1][n][0], dp[1][n][1]) << endl;\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Flood Fill.json",
    "editorial_link": "https://codeforces.com/blog/entry/65136",
    "editorial": "TutorialThis problem was inspired by the game Flood-it. It is apparently\r\nNP-hard. You can try out the game here.\r\nhttps://www.chiark.greenend.org.uk/\r\n",
    "hint": []
}