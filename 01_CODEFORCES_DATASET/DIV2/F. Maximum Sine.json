{
    "link": "https://codeforces.com//contest/1182/problem/F",
    "problemId": "356991",
    "problem_idx": "F",
    "shortId": "1182F",
    "contest_number": "1182",
    "problem_submissions": {
        "D": [
            55455650,
            55586970,
            55459316,
            55455659,
            55458949,
            55453924,
            55478512,
            55482188,
            55498428,
            55481213,
            55567538,
            55453786
        ],
        "E": [
            55450747,
            55461164,
            55449899,
            55449075,
            55460684,
            55454104,
            55453180,
            55453677,
            55453916,
            55451090,
            55454249,
            55453623,
            55476218,
            55446106,
            55449885,
            55454784,
            55483027,
            55456083,
            55457367,
            55456526
        ],
        "A": [
            55445533,
            55434238,
            55434241,
            55436061,
            55434955,
            55434411,
            55437033,
            55434181,
            55435131,
            55435071,
            55434914,
            55434583,
            55476206,
            55434538,
            55436427,
            55434458,
            55434180,
            55434233,
            55434292,
            55434474
        ],
        "B": [
            55445010,
            55437924,
            55440985,
            55440064,
            55439189,
            55438618,
            55443275,
            55439911,
            55437513,
            55438913,
            55441336,
            55438725,
            55438778,
            55476210,
            55439290,
            55442014,
            55440569,
            55438740,
            55438330,
            55438657,
            55438254
        ],
        "C": [
            55442056,
            55444294,
            55448723,
            55461519,
            55444763,
            55447324,
            55449390,
            55446594,
            55444945,
            55447149,
            55449216,
            55447861,
            55449136,
            55476215,
            55459225,
            55455453,
            55447166,
            55483042,
            55444199,
            55447099,
            55446909,
            55445149
        ],
        "F": [
            55479857
        ]
    },
    "name": "F. Maximum Sine",
    "statement": "You have given integers a, b, p, and q. Let f(x) =\r\ntext{abs}(\r\ntext{sin}(\r\nfrac{p}{q}\r\npi x)).Find minimum possible integer x that maximizes f(x) where a\r\nle x\r\nle b.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#include<stdint.h>\nusing namespace std;\n#define IOS {cin.tie(0);ios_base::sync_with_stdio(false);}\n#define N 300005\n#define int int64_t\nmap<int,int> mp;\n\nint32_t main(){\n\tIOS;\n\tint t,a,b,p,q,add = 0;\n\tcin >> t;\n\twhile(t--){\n\t\tmp.clear(); add = 0;\n\t\tcin >> a >> b >> p >> q;\n\t\tint gap = sqrt(b-a+1),mn = abs(2*p*a % (2*q) - q),best=a,wq = q;\n\t\tfor(int i=a;i<a+gap;i++) {\n\t\t\tif(mp.find(2*p*i % (2*q)) == mp.end())\n\t\t\t\tmp[2*p*i % (2*q)] = i;\n\t\t}\n\t\tauto it = mp.lower_bound(wq);\n\t\tauto it2 = mp.upper_bound(wq);\n\t\tif(it2!=mp.begin()){\n\t\t\t--it2;\n\t\t\tif(mn > abs(it2->first - wq)){\n\t\t\t\tmn = abs(it2->first - wq);\n\t\t\t\tbest = it2->second + add;\n\t\t\t}\n\t\t\tif(mn == abs(it2->first - wq)){\n\t\t\t\tbest = min(best,it2->second + add);\n\t\t\t}\n\t\t}\n\t\tif(it!=mp.end()) {\n\t\t\tif(mn > abs(it->first - wq)){\n\t\t\t\tmn = abs(it->first - wq);\n\t\t\t\tbest = it->second + add;\n\t\t\t}\n\t\t\tif(mn == abs(it->first - wq)){\n\t\t\t\tbest = min(best,it->second + add);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(a+gap < b-1000){\n\t\t\t\ta += gap;\n\t\t\t\tadd += gap;\n\t\t\t\twq = ((wq - 2*p*(gap)) % (2*q) + (2*q) ) % (2*q);\n\t\t\t\tit = mp.lower_bound(wq);\n\t\t\t\tit2 = mp.upper_bound(wq);\n\t\t\t\tif(it2!=mp.begin()){\n\t\t\t\t--it2;\n\t\t\t\tif(mn > abs(it2->first - wq)){\n\t\t\t\t\tmn = abs(it2->first - wq);\n\t\t\t\t\tbest = it2->second + add;\n\t\t\t\t}\n\t\t\t\tif(mn == abs(it2->first - wq)){\n\t\t\t\t\tbest = min(best,it2->second + add);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(it!=mp.end()) {\n\t\t\t\tif(mn > abs(it->first - wq)){\n\t\t\t\t\tmn = abs(it->first - wq);\n\t\t\t\t\tbest = it->second + add;\n\t\t\t\t}\n\t\t\t\tif(mn == abs(it->first - wq)){\n\t\t\t\t\tbest = min(best,it->second + add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=a;i<=b;i++){\n\t\t\tif(mn > abs(2*p*i % (2*q) - q)){\n\t\t\t\tmn = abs(2*p*i % (2*q) - q);\n\t\t\t\tbest = i;\n\t\t\t}\n\t\t}\n\t\tcout << best << '\\n';\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Maximum Sine.json",
    "editorial_link": "https://codeforces.com//blog/entry/67614",
    "editorial": "Lemma: For all , , if then is more closer to the than .With this lemma,\r\nwe can avoid the calculation of floating precision numbers. Let\u00e2\u0080\u0099s reform\r\nthe problem; Find minimum possible integer that is the closest to . This\r\nis equivalent to find minimum possible integer that is the closest to .\r\nLet . Now set the interval with length and construct the list like this\r\n. Then remove the big number s with duplicated values from the list and\r\nsort the list.Now we can find any that is the closest to any integer in\r\n. We will search all numbers in range without modifying the list we\r\ncreated. How is this possible? Because for all integers , .So in every\r\niterations, we can set the target and just find. More precisely, our\r\ntarget value is for -th iteration. With this search, we can find such\r\nminimum possible integer . Oh, don\u00e2\u0080\u0099t forget to do bruteforce in\r\nremaining range!The time complexity is .\r\n"
}