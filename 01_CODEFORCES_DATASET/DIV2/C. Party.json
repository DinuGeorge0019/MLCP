{"link": "https://codeforces.com//contest/116/problem/C", "problemId": "606", "problem_idx": "C", "shortId": "116C", "contest_number": "116", "problem_submissions": {"E": [700161, 701799, 701421, 702282, 700977, 704488, 701119], "D": [699566, 698442, 699880, 700164, 701655, 698834, 699735, 698841, 698890, 9443336, 709309, 699987, 699816, 700455, 699803, 699649, 699931, 699910], "C": [698001, 696869, 697453, 698296, 698175, 697132, 696265, 697608, 697369, 9442997, 698325, 697976, 696978, 697819, 697685, 698132, 697395, 698281], "B": [697389, 699259, 696737, 697208, 697213, 696507, 697595, 696839, 696682, 9442209, 697385, 697177, 698196, 696508, 698380, 697274, 696601, 696966], "A": [696282, 695857, 695773, 696139, 695925, 695792, 696656, 695824, 695837, 9442134, 696797, 695862, 696053, 695796, 695742, 696321, 695753, 695835]}, "name": "C. Party", "statement": "A company has employees numbered from to . Each employee either has no\r\nimmediate manager or exactly one immediate manager, who is another\r\nemployee with a different number. An employee is said to be the of\r\nanother employee if at least one of the following is true: Employee is\r\nthe immediate manager of employee Employee has an immediate manager\r\nemployee such that employee is the superior of employee . The company\r\nwill not have a managerial cycle. That is, there will not exist an\r\nemployee who is the superior of his/her own immediate manager.Today the\r\ncompany is going to arrange a party. This involves dividing all\r\nemployees into several groups: every employee must belong to exactly one\r\ngroup. Furthermore, within any single group, there must not be two\r\nemployees and such that is the superior of .What is the minimum number\r\nof groups that must be formed?\r\n", "solutions": ["#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <numeric>\n \nusing namespace std;\n \nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n \n#define sz(c) int((c).size())\n#define all(c) (c).begin(), (c).end()\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define FORD(i,a,b) for (int i = int(b)-1; i >= (a); i--)\n#define FORIT(i,c) for (__typeof__((c).begin()) i = (c).begin(); i != (c).end(); i++)\n\nint N;\nvi adj[5000];\nint par[5000];\nint h;\n\nvoid dfs(int start, int akth) {\n\th = max(h, akth);\n\tFORIT(it,adj[start]) {\n\t\tdfs(*it,akth+1);\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tFOR(i,0,N) adj[i].clear();\n\tFOR(i,0,N) {\n\t\tcin >> par[i];\n\t\tif(par[i] != -1) {\n\t\t\tpar[i]--;\n\t\t\tadj[par[i]].push_back(i);\n\t\t}\n\t}\n\th = 0;\n\tFOR(i,0,N) if(par[i] == -1) dfs(i, 1);\n\tcout << h << endl;\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "trees"], "dificulty": "900", "interactive": false}