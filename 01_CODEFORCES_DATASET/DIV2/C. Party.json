{
    "link": "https://codeforces.com//contest/116/problem/C",
    "problemId": "606",
    "problem_idx": "C",
    "shortId": "116C",
    "contest_number": "116",
    "problem_submissions": {
        "E": [
            700161,
            701799,
            701421,
            702282,
            700977,
            704488,
            701119
        ],
        "D": [
            699566,
            698442,
            699880,
            700164,
            701655,
            698834,
            699735,
            698841,
            698890,
            9443336,
            709309,
            699987,
            699816,
            700455,
            699803,
            699649,
            699931,
            699910
        ],
        "C": [
            698001,
            696869,
            697453,
            698296,
            698175,
            697132,
            696265,
            697608,
            697369,
            9442997,
            698325,
            697976,
            696978,
            697819,
            697685,
            698132,
            697395,
            698281
        ],
        "B": [
            697389,
            699259,
            696737,
            697208,
            697213,
            696507,
            697595,
            696839,
            696682,
            9442209,
            697385,
            697177,
            698196,
            696508,
            698380,
            697274,
            696601,
            696966
        ],
        "A": [
            696282,
            695857,
            695773,
            696139,
            695925,
            695792,
            696656,
            695824,
            695837,
            9442134,
            696797,
            695862,
            696053,
            695796,
            695742,
            696321,
            695753,
            695835
        ]
    },
    "name": "C. Party",
    "statement": "A company has employees numbered from to . Each employee either has no\r\nimmediate manager or exactly one immediate manager, who is another\r\nemployee with a different number. An employee is said to be the of\r\nanother employee if at least one of the following is true: Employee is\r\nthe immediate manager of employee Employee has an immediate manager\r\nemployee such that employee is the superior of employee . The company\r\nwill not have a managerial cycle. That is, there will not exist an\r\nemployee who is the superior of his/her own immediate manager.Today the\r\ncompany is going to arrange a party. This involves dividing all\r\nemployees into several groups: every employee must belong to exactly one\r\ngroup. Furthermore, within any single group, there must not be two\r\nemployees and such that is the superior of .What is the minimum number\r\nof groups that must be formed?\r\n",
    "solutions": [
        "#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <numeric>\n \nusing namespace std;\n \nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n \n#define sz(c) int((c).size())\n#define all(c) (c).begin(), (c).end()\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define FORD(i,a,b) for (int i = int(b)-1; i >= (a); i--)\n#define FORIT(i,c) for (__typeof__((c).begin()) i = (c).begin(); i != (c).end(); i++)\n\nint N;\nvi adj[5000];\nint par[5000];\nint h;\n\nvoid dfs(int start, int akth) {\n\th = max(h, akth);\n\tFORIT(it,adj[start]) {\n\t\tdfs(*it,akth+1);\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tFOR(i,0,N) adj[i].clear();\n\tFOR(i,0,N) {\n\t\tcin >> par[i];\n\t\tif(par[i] != -1) {\n\t\t\tpar[i]--;\n\t\t\tadj[par[i]].push_back(i);\n\t\t}\n\t}\n\th = 0;\n\tFOR(i,0,N) if(par[i] == -1) dfs(i, 1);\n\tcout << h << endl;\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Party.json",
    "editorial_link": "https://codeforces.com//blog/entry/2584",
    "editorial": "We let an employee without a manager called as root. There's an edge from a manager to an employee that he/she manages.\n\nFirst notice that the graph is a collection of directed trees. Hence, we can assign a depth label to each node - denoting the number of nodes on the simple path from the root to it. The answer is then the maximum depth a node has.\n\nWhy?\n\nFirst, the answer is bounded below by this number because any pair of employees in this path cannot be in the same group. Second, since the graph is a tree, each node in the graph has a unique depth label assigned to it. Simply put all nodes with the same depth in the same group. It's fairly easy to see that no one will be the superior of another within a group, for otherwise their depths will not be equal.\n\nRemark\n\nYou might notice that there exist an O(N) implementation of the above algorithm, yet the constraint is 2000. Well, this problem was swapped with the D1-B because the previous D1-A was thought to be harder than expected. And so, in the process, we also decrease the constraint for N from 200,000 to 2,000. I hope you like it :)"
}