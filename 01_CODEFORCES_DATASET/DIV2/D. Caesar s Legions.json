{"link": "https://codeforces.com//contest/118/problem/D", "problemId": "620", "problem_idx": "D", "shortId": "118D", "contest_number": "118", "problem_submissions": {"E": [744037, 745078, 744813, 745388, 745323, 745867, 745436, 743649, 746938, 747382, 916949, 916937, 745101, 744662, 746262, 745809, 747461, 745823, 746138], "D": [743430, 743260, 743613, 743901, 743105, 744593, 742112, 744619, 744423, 745827, 743409, 746775, 745410, 743985, 744866, 743911, 743861, 744184, 744358, 744533], "C": [743075, 741949, 742890, 743396, 742360, 743301, 743646, 747932, 743990, 743060, 744985, 747243, 742852, 748623, 744300, 747942, 746584], "B": [741723, 743683, 741482, 741838, 741312, 741497, 746089, 742393, 742319, 741483, 742136, 741733, 740956, 741809, 742820, 742009, 741676, 741556, 742466, 742218], "A": [741066, 743899, 740889, 741247, 744792, 740920, 740962, 741172, 741019, 740916, 741008, 741288, 741140, 741579, 741121, 741180, 741200, 741119]}, "name": "D. Caesar s Legions", "statement": "Gaius Julius Caesar, a famous general, loved to line up his soldiers.\r\nOverall the army had footmen and horsemen. Caesar thought that an\r\narrangement is beautiful if somewhere in the line there are strictly\r\nmore that footmen standing successively one after another, or there are\r\nstrictly more than horsemen standing successively one after another.\r\nFind the number of arrangements of the soldiers. Note that all warriors\r\nshould be present at each arrangement. All footmen are considered\r\nindistinguishable among themselves. Similarly, all horsemen are\r\nconsidered indistinguishable among themselves.\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\n#define NextLine() { char c = getchar(); while (c != 10 && c != EOF) { c = getchar(); } }\n\nconst int MOD = 100000000;\n\nint n1, n2, k1, k2;\n\nvoid Load()\n{\n\tscanf(\"%d%d%d%d\", &n1, &n2, &k1, &k2);\n}\n\nint res[110][110][2];\n\nint Count(int n1, int n2, int f)\n{\n\tif (res[n1][n2][f] != -1)\n\t{\n\t\treturn res[n1][n2][f];\n\t}\n\tif (n1 + n2 == 0)\n\t{\n\t\tres[n1][n2][f] = 1 % MOD;\n\t\treturn res[n1][n2][f];\n\t}\n\tint j;\n\tres[n1][n2][f] = 0;\n\tif (f == 0)\n\t{\n\t\tfor (j = 1; j <= min(n1, k1); j++)\n\t\t{\n\t\t\tres[n1][n2][f] += Count(n1 - j, n2, 1 - f);\n\t\t\tres[n1][n2][f] %= MOD;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (j = 1; j <= min(n2, k2); j++)\n\t\t{\n\t\t\tres[n1][n2][f] += Count(n1, n2 - j, 1 - f);\n\t\t\tres[n1][n2][f] %= MOD;\n\t\t}\n\t}\n\treturn res[n1][n2][f];\n}\n\nvoid Solve()\n{\n\tmemset(res, 0xFF, sizeof(res));\n\tprintf(\"%d\", (Count(n1, n2, 0) + Count(n1, n2, 1)) % MOD);\n}\n\nint main()\n{\n\tLoad();\n\tSolve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dp"], "dificulty": "1700", "interactive": false}