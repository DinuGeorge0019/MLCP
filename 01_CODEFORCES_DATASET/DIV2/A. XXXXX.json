{"link": "https://codeforces.com//contest/1364/problem/A", "problemId": "647817", "problem_idx": "A", "shortId": "1364A", "contest_number": "1364", "problem_submissions": {"E": [83685190, 83684728, 83670044, 83708391, 86874545, 83727888, 94916861, 83733626, 83892588], "D": [83674039, 83643909, 83643324, 83650173, 83654530, 83655343, 83656667, 83658116, 83652702, 83655398, 83657128, 83655879, 83656798, 83659303, 83654673, 83652945, 83654032, 83654691, 83660980, 84168459, 83653853], "C": [83641956, 83631075, 83632825, 83637025, 83635932, 83634309, 83632050, 83634741, 83637967, 83633786, 83640244, 83634458, 83638454, 83638371, 83638980, 83647774, 83644474, 83643505, 83634306, 83639352], "B": [83634593, 83624903, 83627972, 83631302, 83628554, 83625631, 83625293, 83627339, 83628623, 83628644, 83625351, 83628184, 83628428, 83624769, 83633106, 83628572, 83637716, 83626469, 83630293], "A": [83629697, 83628427, 83623168, 83625873, 83624275, 83623298, 83623685, 83623482, 83625309, 83624536, 83623274, 83624381, 83624214, 83623297, 83623701, 83625943, 83623507, 83625742]}, "name": "A. XXXXX", "statement": "Ehab loves number theory, but for some reason he hates the number x.\r\nGiven an array a, find the length of its longest subarray such that the\r\nsum of its elements divisible by x, or determine that such subarray\r\ndoesn\u2019t exist.An array a is a subarray of an array b if a can be\r\nobtained from b by deletion of several (possibly, zero or all) elements\r\nfrom the beginning and several (possibly, zero or all) elements from the\r\nend.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, x;\n    cin >> n >> x;\n    vector<int> a(n);\n    unordered_set<int> rem;\n    int sum = 0;\n    for (auto &i : a) {\n      cin >> i;\n      (sum += i) %= x;\n      rem.insert(i % x);\n    }\n    if (sum != 0) {\n      cout << n << '\\n';\n    } else {\n      int l = 0, r = n - 1;\n      while (a[l] % x == 0 && l < n) {\n        l++;\n      }\n      while (a[r] % x == 0 && r >= 0) {\n        r--;\n      }\n      if (l < r) {\n        cout << max(n - (l + 1), r) << '\\n';\n      } else {\n        cout << -1 << '\\n';\n      }\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "number theory", "two pointers"], "dificulty": "1200", "interactive": false}