{
    "link": "https://codeforces.com//contest/1440/problem/D",
    "problemId": "798724",
    "problem_idx": "D",
    "shortId": "1440D",
    "contest_number": "1440",
    "problem_submissions": {
        "E": [
            98728391,
            98730128,
            98724308,
            98735269,
            98730903,
            98733313,
            98735079,
            98720072,
            98721791,
            98776063,
            98776025
        ],
        "B": [
            98718215,
            98690348,
            98694152,
            98694066,
            98717379,
            98694490,
            98698050,
            98691119,
            98694372,
            98737100,
            98701238,
            98693027,
            98692019,
            98693130,
            98694602,
            98691874,
            98694997,
            98690784
        ],
        "D": [
            98713473,
            98716992,
            98721114,
            98895168,
            98737070
        ],
        "C1": [
            98700917,
            98704185,
            98727324,
            98710881,
            98711510,
            98720805,
            98703327,
            98773521,
            98732444,
            98719724,
            98704756,
            98707436,
            98707143,
            98709098,
            98710542,
            98704302,
            98708466
        ],
        "C2": [
            98700859,
            98709321,
            98775076,
            98710936,
            98720737,
            98774165,
            98704870,
            98707384,
            98707212,
            98709164,
            98710454,
            98714510,
            98708395
        ],
        "A": [
            98687569,
            98688718,
            98687545,
            98693499,
            98688756,
            98688775,
            98687763,
            98689068,
            98687766,
            98699186,
            98688328,
            98687540,
            98687537,
            98688127,
            98688428,
            98687491,
            98687961
        ]
    },
    "name": "D. Graph Subset Problem",
    "statement": "You are given an undirected graph with n vertices and m edges. Also, you\r\nare given an integer k.Find either a clique of size k or a non-empty\r\nsubset of vertices such that each vertex of this subset has at least k\r\nneighbors in the subset. If there are no such cliques and subsets report\r\nabout it.A subset of vertices is called a clique of size k if its size\r\nis k and there exists an edge between every two vertices from the\r\nsubset. A vertex is called a neighbor of the other vertex if there\r\nexists an edge between them.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    int tst;\n    cin >> tst;\n    while (tst--) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        vector<vector<int>> g(n);\n        vector<int> deg(n);\n        for (int i = 0; i < m; i++) {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            g[a].emplace_back(b);\n            g[b].emplace_back(a);\n            deg[a]++; deg[b]++;\n        }\n        for (int i = 0; i < n; i++) {\n            sort(g[i].begin(), g[i].end());\n        }\n        vector<bool> used(n), inQ(n);\n        vector<int> Q(n);\n        int topQ = 0;\n        vector<int> vert(k);\n        bool fnd = false;\n        for (int i = 0; i < n; i++) {\n            used[i] = inQ[i] = false;\n            if (deg[i] < k) {\n                inQ[i] = true;\n                Q[topQ++] = i;\n            }\n        }\n        for (int i = 0; i < topQ; i++) {\n            int u = Q[i];\n            used[u] = true;\n            inQ[u] = false;\n            if (deg[u] < (k - 1)) {\n                for (int j : g[u]) {\n                    if (!used[j]) --m;\n                    deg[j]--;\n                    if (!inQ[j] && !used[j] && deg[j] < k) {\n                        inQ[j] = true;\n                        Q[topQ++] = j;\n                    }\n                }\n                continue;\n            }\n            else if (deg[u] == k - 1) {\n                if ((long long)k * (k - 1)  <= 2 * (long long)m) {\n                    int r = 0;\n                    for (int p : g[u]) {\n                        if (!used[p]) {\n                            vert[r++] = p;\n                        }\n                    }\n                    assert (r == (k - 1));\n                    bool good = true;\n                    for (int x = 0; x < r; x++) {\n                        if (!good) break;\n                        for (int y = x + 1; y < r; y++) {\n                            int pp = lower_bound(g[vert[x]].begin(), g[vert[x]].end(), vert[y]) - g[vert[x]].begin();\n                            if (pp == g[vert[x]].size() || g[vert[x]][pp] != vert[y]) {\n                                good = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (good) {\n                        fnd = true;\n                        cout << 2 << '\\n';\n                        cout << u + 1 << \" \";\n                        for (int c = 0; c < r; c++) {\n                            cout << vert[c] + 1 << \" \";\n                        }\n                        cout << '\\n';\n                        break;\n                    }\n                }\n            }\n            for (int j : g[u]) {\n                deg[j]--;\n                if (!used[j]) --m;\n                if (!inQ[j] && !used[j] && deg[j] < k) {\n                    inQ[j] = true;\n                    Q[topQ++] = j;\n                }\n            }\n        }\n        if (fnd) continue;\n        vector<int> f;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) f.emplace_back(i);\n        }\n        if (!f.empty()) {\n            cout << 1 << \" \" << f.size() << '\\n';\n            for (int c : f) {\n                c++;\n                cout << c << \" \";\n            }\n            cout << '\\n';\n        }\n        else {\n            cout << -1 << '\\n';\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "hashing"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Graph Subset Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/84731",
    "editorial": "It is easy to see that if k>2m????\n the answer is ?1\n; because if k>2m????\n, no matter whether we have a clique of size k\n or a subset of the graph with ??k\n, we will have more than m\n edges in total.\n\nNow, the main idea is to suppose u\n is the vertex with minimum degree; if d(u)<k?1\n we should delete u\n becuase u\n can not be in clique or the subset of vertices such that each vertex of this subset has at least k\n neighbors in the subset; so we have to erase u\n and all edges attached to it.\n\nIf d(u)>k\n, remaining vertices will form a subset that every vertex have at least k\n neighbors in the subset, so we'll print this subset as answer.\n\nIf d(u)=k?1\n, we consider u\n and all neighbors of u\n as candidate for clique of size k\n. then we erase u\n and all edges attached to it.\n\nIf we erase all vertices and didn't found any good subset, then we should check clique candidates.\n\nfor checking clique candidates fast, iterate over vertices and name current vertex v\n. then for neighbors of v\n set neiv\n to 1\n and 0\n otherwise. for each clique candidate that contains v\n like C\n, we check edge between v\n and u?C\n in O(1)\n using array nei\n.\n\nevery time we find new clique candidate, we remove at least k?1\n edges, so number of clique candidates is at most mk?1\n. for every candidate we check O(k2)\n edges in overall. so time complexity is O(mk).O(k2)?O(m.k)\n."
}