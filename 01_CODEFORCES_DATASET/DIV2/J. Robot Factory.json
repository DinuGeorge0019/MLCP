{"link": "https://codeforces.com//contest/1600/problem/J", "problemId": "1136959", "problem_idx": "J", "shortId": "1600J", "contest_number": "1600", "problem_submissions": {"D": [131326791, 131319774, 131349265, 131313616, 131318416, 131323729], "F": [131320345, 131329426, 131350388], "E": [131316574, 131313861, 131305576, 131310151, 131314773], "I": [131312786, 131309903, 131307758, 131305198, 131310781], "A": [131307398], "J": [131302886, 131305362, 131303377, 131303391, 131305512], "B": [], "C": [], "G": [], "H": []}, "name": "J. Robot Factory", "statement": "You have received data from a Bubble bot. You know your task is to make\r\nfactory facilities, but before you even start, you need to know how big\r\nthe factory is and how many rooms it has. When you look at the data you\r\nsee that you have the dimensions of the construction, which is in\r\nrectangle shape: N x M. Then in the next N lines you have M numbers.\r\nThese numbers represent factory tiles and they can go from 0 to 15. Each\r\nof these numbers should be looked in its binary form. Because from each\r\nnumber you know on which side the tile has walls. For example number 10\r\nin it\u2019s binary form is 1010, which means that it has a wall from the\r\nside, it doesn\u2019t have a wall from the , it has a wall on the side and it\r\ndoesn\u2019t have a wall on the side. So it goes North, East, South, West. It\r\nis guaranteed that the construction always has walls on it\u2019s edges. The\r\ninput will be correct. Your task is to print the size of the rooms from\r\nbiggest to smallest.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define FOR(i,a,b) for (int i = a; i <= b; i++)\n#define FORD(i,a,b) for (int i = a; i >= b; i--)\n\n///// DEBUG TEMPLATE /////\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n///// DEBUG TEMPLATE /////\n\n///// MODNUM TEMPLATE /////\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n  using ll = long long;\n\n  int v;\n\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n\npublic:\n\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n  assert(b >= 0);\n  T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9 + 13)>;\n///// MODNUM TEMPLATE /////\n\nint a[1111][1111];\nint comp[1111][1111];\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> m >> n;\n    FOR(i, 1, m) FOR(j, 1, n) cin >> a[i][j];\n\n    int cntComp = 0;\n    queue<pair<int, int>> q;\n    vector<int> s;\n    FOR(i, 1, m) FOR(j, 1, n) if (comp[i][j] == 0) {\n      cntComp++;\n      q.push({i, j});\n      comp[i][j] = cntComp;\n      int area = 1;\n      while (!q.empty()) {\n        auto p = q.front(); q.pop();\n        int u = p.first;\n        int v = p.second;        \n        REP(dir, 4) {\n          int uu = u + dx[dir];\n          int vv = v + dy[dir];\n          if (uu < 1 || uu > m || vv < 1 || vv > n) continue;\n          if (a[u][v] & (1 << dir)) continue;\n          if (comp[uu][vv] == 0) {\n            comp[uu][vv] = cntComp;\n            q.push({uu, vv});\n            area++;\n          }\n        }\n      }\n      s.push_back(area);\n    }\n    sort(s.begin(), s.end());\n    FORD(i, s.size() - 1, 0) cout << s[i] << \" \";\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dfs and similar"], "dificulty": "1400", "interactive": false}