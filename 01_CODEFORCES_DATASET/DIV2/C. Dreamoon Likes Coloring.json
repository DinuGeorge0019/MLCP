{
    "link": "https://codeforces.com//contest/1330/problem/C",
    "problemId": "582580",
    "problem_idx": "C",
    "shortId": "1330C",
    "contest_number": "1330",
    "problem_submissions": {
        "E": [
            75407483,
            75403686,
            75406825,
            75412857,
            75411514,
            75411404,
            75407783,
            75407274,
            75400418,
            75447922,
            75412935,
            75466280
        ],
        "D": [
            75391296,
            75385541,
            80644507,
            75388709,
            75387337,
            75393475,
            75395701,
            75385540,
            75376125,
            75379564,
            75382546,
            75380901,
            75384917,
            75382324,
            75380657,
            75388115,
            75386567,
            75461008,
            75388223,
            75387064
        ],
        "C": [
            75379279,
            75374912,
            75381565,
            75376079,
            75376451,
            75390556,
            75381440,
            75360964,
            75379654,
            75372629,
            75367460,
            75443397,
            75374056,
            75373762,
            75374173,
            220742361,
            75370741,
            75373514,
            75361682,
            75373297
        ],
        "B": [
            75362106,
            75368513,
            75363431,
            75362706,
            75364291,
            75378289,
            75379661,
            75360912,
            75356953,
            75360775,
            75363811,
            75360857,
            75361079,
            75359545,
            195278107,
            75360634,
            75361090,
            75371429,
            75361221
        ],
        "A": [
            75355521,
            75354244,
            75354217,
            75356116,
            75354591,
            75364896,
            75353923,
            75353902,
            75354562,
            75354818,
            75353692,
            75353618,
            75362319,
            179068881,
            75354934,
            75353839,
            75364875,
            75354143
        ]
    },
    "name": "C. Dreamoon Likes Coloring",
    "statement": "Dreamoon likes coloring cells very much.There is a row of n cells.\r\nInitially, all cells are empty (don\u2019t contain any color). Cells are\r\nnumbered from 1 to n.You are given an integer m and m integers l_1, l_2,\r\nldots, l_m (1\r\nle l_i\r\nle n)Dreamoon will perform m operations.In i-th operation, Dreamoon will\r\nchoose a number p_i from range [1, n-l_i+1] (inclusive) and will paint\r\nall cells from p_i to p_i+l_i-1 (inclusive) in i-th color. Note that\r\ncells may be colored more one than once, in this case, cell will have\r\nthe color from the latest operation.Dreamoon hopes that after these m\r\noperations, all colors will appear at least once and all cells will be\r\ncolored. Please help Dreamoon to choose p_i in each operation to satisfy\r\nall constraints.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nint n,m,a[210000],Ans[210000];\nll suf[210000];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif (i+a[i]-1>n){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=m;i>=1;i--) suf[i]=suf[i+1]+a[i];\n\tif (suf[1]<n){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint mx=0;\n\tfor (int i=1;i<=m;i++){\n\t\tif (i<=n-suf[i]+1&&n-suf[i]+1<=mx+1){\n\t\t\tfor (int j=1;j<i;j++) Ans[j]=j;\n\t\t\tAns[i]=n-suf[i]+1;\n\t\t\tfor (int j=i;j<m;j++) Ans[j+1]=Ans[j]+a[j];\n\t\t\tfor (int j=1;j<m;j++) printf(\"%d \",Ans[j]);\n\t\t\tprintf(\"%d\\n\",Ans[m]);\n\t\t\treturn 0;\n\t\t}\n\t\tmx=max(mx,i+a[i]-1);\n\t}\n\tputs(\"-1\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Dreamoon Likes Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/75559",
    "editorial": "After reading the statement, you may find this is a problem that will be tagged as \"constructive algorithms\" in Codefores. And you also can find this problem is just problem A in Div. 1. So basically we can expect there exist some simple methods to solve it.\n\nIf a \"constructive algorithms\" problem asks you to determine whether the solution exists or not, usually they have a common pattern(especially in problem hardness which is before Div. 1 B(inclusive)), this is, there are some simple constraints can divide test data into \"Yes\", and \"No\". Therefore, the first thing to solve this problem is finding some trivial conditions that cannot achieve Dreamoon's hope.\n\nAfter some try, you may find there are two trivial conditions that achieving Dreamoon's hope is impossible. The two conditions are listed as follows:\n\n1. Sum of li\n is less than n\n. In this condition, there always is at least one empty grid.\n\n2. There exists some i\n such that li+i?1>n\n. If n?li<i?1\n, it means after you do i\n-th operation, there only n?li\n grid is not colored by i\n-th color. So at least one of previous i?1\n color will disapear after this operation.\n\nNow I want to talk about another feature of some \"constructive algorithms\" first.\n\nSometimes, the condition given by the problem is to \"open\", this is to say that if we added some more strict constraint, the problem is still can be solved. And when the constraint it more strict, we can deduce the solution more easily.\n\nOne of common \"strict constraint\" is \"sorted\". I believe you have ever seen many problems that the first step is sorting something. Now, we also want to apply \"sorted\" in the problem.\n\nAfter applying \"sort\", we firstly consider the edge cases of above two impossible conditions. The first case is \"sum of li\n is equal to n\n\". In this case, we have a unique solution after applying \"sort\", pi=m??j=i+1mlj+1\n. The second case is li+i?1=n\n is hold for all i\n. In this case, there is also a unique solution that pi=i\n. The two cases coressond to n\n is largest and n\n is smallest among all n\n that exist solutions for same li\n. And for same li\n, when we decrase n\n from the largest possible value, we can just change pi\n from m??j=i+1mlj+1\n to i\n for some smallest indices i\n to get solution. To sum it up, finally, we get the answer. The answer is just pi=max(i,n?suffix_sum[i]+1)\n, for each i\n.\n\nThere exist many other methods to construct solutions. I believe the construction method one can think out is relative to the study experience."
}