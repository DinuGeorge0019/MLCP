{
    "link": "https://codeforces.com//contest/894/problem/B",
    "problemId": "134791",
    "problem_idx": "B",
    "shortId": "894B",
    "contest_number": "894",
    "problem_submissions": {
        "E": [
            32471307,
            32470808,
            32477653,
            32468892,
            32476378,
            32473286,
            32472749,
            32479578,
            32478798,
            32483759,
            32466869,
            32470695,
            32470873,
            32493311
        ],
        "C": [
            32467626,
            32472589,
            32462133,
            32463427,
            32461488,
            32465456,
            32463529,
            32464758,
            32463676,
            32464462,
            32469317,
            32465537,
            32470577,
            32468611,
            32464977,
            32465202,
            32462633,
            32464400
        ],
        "B": [
            32465947,
            32462718,
            32464339,
            32462164,
            32478784,
            32490475,
            32479651,
            32463872,
            32461816,
            32462196,
            32472670,
            32462354,
            32463630,
            32462716,
            32463341,
            32469382
        ],
        "D": [
            32464126,
            32467179,
            32469559,
            32463935,
            32469406,
            32468195,
            32470253,
            32466945,
            32470315,
            32471173,
            32471807,
            32476896,
            32473554,
            32474533,
            32473511
        ],
        "A": [
            32458491,
            32461795,
            32458601,
            32458521,
            32458627,
            32465359,
            32458507,
            32458624,
            32459097,
            32461613,
            32461662,
            32461348,
            32461278,
            32459033,
            32459890,
            32458837,
            32458739,
            32458734
        ]
    },
    "name": "B. Ralph And His Magic Field",
    "statement": "Ralph has a magic field which is divided into blocks. That is to say,\r\nthere are rows and columns on the field. Ralph can put an integer in\r\neach block. However, the magic field doesn\u2019t always work properly. It\r\nworks only if the product of integers in each row and each column equals\r\nto , where is either or .Now Ralph wants you to figure out the number of\r\nways to put numbers in each block in such a way that the magic field\r\nworks properly. Two ways are considered different if and only if there\r\nexists at least one block where the numbers in the first way and in the\r\nsecond way are different. You are asked to output the answer modulo\r\n.Note that there is no range of the numbers to put in the blocks, but we\r\ncan prove that the answer is not infinity.\r\n",
    "solutions": [
        "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nll MOD=1e9+7;\nint main()\n{\n\tll n,m,k,ans=1;\n\tcin>>n>>m>>k;\n\tif(k==-1&&n%2!=m%2)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t--n, --m; n%=MOD-1; m%=MOD-1;\n\tll x=2,b=n*m;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*x%MOD;\n\t\tx=x*x%MOD; b>>=1;\n\t}\n\tcout<<ans<<\"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Ralph And His Magic Field.json",
    "editorial_link": "https://codeforces.com//blog/entry/55884",
    "editorial": "First, it\u00e2\u0080\u0099s obvious that the numbers put can be only or . If equals to\r\nand the parity of and differ, the answer is obviously .Otherwise, for\r\nthe first lines and the first columns, we can put either or in it, and\r\nthere\u00e2\u0080\u0099re ways in total. Then it\u00e2\u0080\u0099s obvious that the remaining numbers are\r\nuniquely determined because the product of each row and each column is\r\nknown already. So in this case the answer is .\r\n"
}