{"link": "https://codeforces.com//contest/659/problem/F", "problemId": "53562", "problem_idx": "F", "shortId": "659F", "contest_number": "659", "problem_submissions": {"G": [17048942, 17051082, 17053499, 17056302, 17057443, 17052627, 17057183, 17057162, 17076131, 17045172, 17053158, 17056518], "F": [17047834, 17053774, 17049969, 17050820, 17052174, 17056026, 17050842, 17053250, 17050852, 17050686, 17050499, 17050611, 17052481, 17064456, 17051398, 17051617, 17051540, 17050465], "E": [17042676, 17043109, 17045262, 17042718, 17047927, 17046574, 17040925, 17048651, 17040880, 17052066, 17041600, 17046501, 17046168, 17045890, 17045191, 17046107, 17048339, 17043013, 17046378], "D": [17040164, 17050025, 17044036, 17045724, 17041432, 17042750, 17045206, 17042744, 17045258, 17053191, 17040131, 17041993, 17045154, 20417581, 17042968, 17047543, 17044200, 17041493, 17046806, 17044650], "B": [17039409, 17039152, 17039943, 17044093, 17038870, 17038621, 17044105, 17040190, 17043575, 17055274, 17038055, 17038759, 17039771, 17039240, 17039293, 17039271, 17043285, 17040658, 17040098], "C": [17039394, 17040359, 17041969, 17039075, 17037528, 17039602, 17038719, 17041409, 17038514, 17053925, 17038798, 17040270, 17038600, 17041901, 17040814, 17041935, 17039324, 17039760, 17041613], "A": [17037687, 17039404, 17037482, 17037338, 17052801, 17037726, 17040138, 17037138, 17055546, 17037115, 17039098, 17037248, 17037187, 17037309, 17038070, 17037352, 17037563]}, "name": "F. Polycarp and Hay", "statement": "The farmer Polycarp has a warehouse with hay, which can be represented\r\nas an rectangular table, where is the number of rows, and is the number\r\nof columns in the table. Each cell of the table contains a haystack. The\r\nheight in meters of the hay located in the -th row and the -th column is\r\nequal to an integer and coincides with the number of cubic meters of hay\r\nin the haystack, because all cells have the size of the base . Polycarp\r\nhas decided to tidy up in the warehouse by removing an arbitrary integer\r\namount of cubic meters of hay from the top of each stack. You can take\r\ndifferent amounts of hay from different haystacks. Besides, it is\r\nallowed not to touch a stack at all, or, on the contrary, to remove it\r\ncompletely. If a stack is completely removed, the corresponding cell\r\nbecomes empty and no longer contains the stack.Polycarp wants the\r\nfollowing requirements to hold after the reorganization: the total\r\namount of hay remaining in the warehouse must be to , the heights of all\r\nstacks (i.e., cells containing a non-zero amount of hay) should be the\r\nsame, the height of at least one stack must remain the same as it was,\r\nfor the stability of the remaining structure all the stacks should form\r\none connected region. The two stacks are considered adjacent if they\r\nshare a side in the table. The area is called connected if from any of\r\nthe stack in the area you can get to any other stack in this area,\r\nmoving only to adjacent stacks. In this case two adjacent stacks\r\nnecessarily belong to the same area.Help Polycarp complete this\r\nchallenging task or inform that it is impossible.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#define X first\n#define Y second\n\nconst int maxn = 1005;\nconst int maxs = 1e6 + 5;\nconst int move[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint n, m;\nlong long K;\n\nint a[maxn][maxn], b[maxn][maxn], fa[maxs], size[maxs];\nstd::pair<int, std::pair<int,int> > t[maxs];\nint tot, lim;\n\nint find(int x)\n{\n\treturn fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nvoid merge(int a,int b)\n{\n\ta = find(a), b = find(b);\n\t\n\tif(a != b)\n\t{\n\t\tsize[a] += size[b];\n\t\tsize[b] = 0, fa[b] = a;\n\t}\n}\nvoid dfs(int x,int y)\n{\n\tif(!(x >= 0 && x < n && y >= 0 && y < m)) return;\n\tif(a[x][y] < lim || b[x][y] || !tot) return; \n\t\n\tb[x][y] = lim, tot--;\n\t\n\tdfs(x + 1, y);\n\tdfs(x - 1, y);\n\tdfs(x, y - 1);\n\tdfs(x, y + 1);\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d%d\", &n, &m);\n\tstd::cin >> K;\n\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tt[i * m + j] = std::make_pair(a[i][j], std::make_pair(i, j));\n\t\t}\n\t\t\n\tstd::sort(t, t + n * m);\n\tstd::reverse(t, t + n * m);\n\n\tfor(int i = 0; i < n * m; i++) fa[i] = i, size[i] = 1;\n\t\n\tint ans = -1;\n\t\n\tfor(int i = 0, j = 0; i < n * m; i = j)\n\t{\n\t\twhile(j < n * m && t[j].X == t[i].X)\n\t\t{\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint ox = t[j].Y.X;\n\t\t\t\tint oy = t[j].Y.Y;\n\t\t\t\tint x = move[k][0] + ox;\n\t\t\t\tint y = move[k][1] + oy;\n\t\t\t\t\n\t\t\t\tif(x >= 0 && x < n && y >= 0 && y < m)\n\t\t\t\t\tif(a[x][y] >= t[i].X) merge(x * m + y, ox * m + oy);\n\t\t\t}\n\t\t\t\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tif(t[i].X && K % t[i].X == 0)\n\t\t{\n\t\t\tfor(int k = i; k < j; k++)\n\t\t\t{\n\t\t\t\tint x = t[k].Y.X, y = t[k].Y.Y;\n\t\t\t\t\t\n\t\t\t\tif(size[find(x * m + y)] >= K / t[i].X)\n\t\t\t\t\t{ ans = x * m + y; break; }\n\t\t\t}\n\t\t\n\t\t\tif(ans != -1) break;\n\t\t}\n\t}\n\t\n\tif(ans == -1) puts(\"NO\");\n\telse\n\t{\n\t\tlim = a[ans / m][ans % m];\n\t\ttot = K / lim;\n\t\t\n\t\tdfs(ans / m, ans % m);\n\t\t\n\t\tputs(\"YES\");\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tprintf(\"%d \", b[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\t\n#ifndef ONLINE_JUDGE\n\tfclose(stdin);\n\tfclose(stdout);\n#endif\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dsu", "graphs", "greedy", "sortings"], "dificulty": "2000", "interactive": false}