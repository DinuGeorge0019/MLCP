{
    "link": "https://codeforces.com//contest/430/problem/C",
    "problemId": "9399",
    "problem_idx": "C",
    "shortId": "430C",
    "contest_number": "430",
    "problem_submissions": {
        "E": [
            6596209,
            6601239,
            6595457,
            6596869,
            6611998
        ],
        "C": [
            6593903,
            6589689,
            6590185,
            6591146,
            6594509,
            6591043,
            6594881,
            6592145,
            6591439,
            6590916,
            6592010,
            6592041,
            6592596,
            6592644,
            6593233,
            6592230,
            6592515,
            6591488,
            6591864
        ],
        "D": [
            6592681,
            6591086,
            6597590,
            6592274,
            6591820,
            6594037,
            6592628,
            6594400,
            6599564,
            6594397,
            6596203,
            6595708,
            6594744,
            6595014,
            6595972,
            6596088,
            6594380,
            6593712,
            6595433
        ],
        "B": [
            6591917,
            6588904,
            6589347,
            6590112,
            6589136,
            6589725,
            6590062,
            6590923,
            6589922,
            6588990,
            6590100,
            6590128,
            6591019,
            6591186,
            6590471,
            6590715,
            6590194,
            6589294,
            6593720
        ],
        "A": [
            6588412,
            6588136,
            6588222,
            6588465,
            6590072,
            6588672,
            6588238,
            6589003,
            6588856,
            6595945,
            6588333,
            6588427,
            6589419,
            6589285,
            6588864,
            6589371,
            6595841,
            6600698,
            6589758
        ]
    },
    "name": "C. Xor-tree",
    "statement": "Iahub is very proud of his recent discovery, propagating trees. Right\r\nnow, he invented a new tree, called xor-tree. After this new\r\nrevolutionary discovery, he invented a game for kids which uses\r\nxor-trees.The game is played on a tree having nodes, numbered from to .\r\nEach node has an initial value , which is either 0 or 1. The root of the\r\ntree is node 1.One can perform several (possibly, zero) operations on\r\nthe tree during the game. The only available type of operation is to\r\npick a node . Right after someone has picked node , the value of node\r\nflips, the values of sons of remain the same, the values of sons of sons\r\nof flips, the values of sons of sons of sons of remain the same and so\r\non.The goal of the game is to get each node to have value , which can\r\nalso be only 0 or 1. You need to reach the goal of the game by using\r\nminimum number of operations.\r\n",
    "solutions": [
        "/**************************************************\n *        Problem:  Codeforces #245 Div.2 Problem C\n *         Author:  clavichord93\n *          State:  \n **************************************************/\n\n/**************************************************\n * Header\n **************************************************/\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <limits>\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Copy(a, b) memcpy(a, b, sizeof(b))\n#define NPOS string::npos\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define rrep(i, a, b) for (int i = a; i >= b; i--)\n#define erep(j, a) for (Edge *j = a; j; j = j->next)\n#define irep(i, a) for (__typeof(a.begin()) i = a.begin(); i != a.end(); i++)\n#define srep(sub, s) for (int sub = s & (s - 1); sub; sub = (sub - 1) & s)\n#define sqr(a) ((a) * (a))\n#define R(x) scanf(\"%d\", &x)\n#define SS(a, b) scanf(\"%d %d\", &a, &b)\n#define SSS(a, b, c) scanf(\"%d %d %d\", &a, &b, &c)\n#define O(x) pf(\"%d\\n\", x)\n#define TEST int T;scanf(\"%d\", &T);for (int cas = 1; cas <= T; cas++)\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define ppb pop_back\n#define pft push_front\n#define ppf pop_front\n#define mp make_pair\n#define vec vector\n#define it iterator\n#define fir first\n#define sec second\n#define x first\n#define y second\n#define all(a) a.begin(),a.end()\n#define sz(a) (int)(a.size())\n#define bg(a) (a).begin()\n#define en(a) (a).end()\n#define clr(a) (a).clear()\n#define dbg(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n#define bit_cnt(x) __builtin_popcount((unsigned)x)\n#define gcd(a, b) __gcd(a, b)\n#define sqr(a) ((a) * (a))\n#define lch(t) (t << 1)\n#define rch(t) (t << 1 | 1)\n#define inf numeric_limits<int>::max()\n#define finf numeric_limits<double>::infinity()\nusing namespace std;\ntemplate<class T> inline bool gmin(T &a, T b) { if (a > b) return a = b, true; return false; }\ntemplate<class T> inline bool gmax(T &a, T b) { if (a < b) return a = b, true; return false; }\ntemplate<class T> T exgcd(T a, T b, T &x, T &y) { if (!b) return x = (T)1, y = (T)0, a; else { T d = exgcd(b, a % b, y, x); return y -= a / b * x, d; } }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<double, double> pdd;\ntypedef pair<double, pdd> pddd;\ntypedef vec<int> vi;\ntypedef vec<double> vd;\ntypedef vec<pii> vii;\ntypedef vec<pdd> vdd;\ntypedef istringstream iss;\ntypedef ostringstream oss;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1e10;\nconst double EPS = 1e-9;\nconst double PI = 3.14159265358979323846264338327950288;\nconst double TAU = 2.0 * PI;\ninline int sgn(const double &a) { return a > EPS ? 1 : (a < -EPS ? -1 : 0); }\ninline int lowbit(int i) { return i & (-i); }\nstruct Initializer { Initializer() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); } } initializer;\n\n/**************************************************\n * Templates\n **************************************************/\n\n\n\n/**************************************************\n * Main\n **************************************************/\n\nconst int MAXN = 200005;\nconst int MAXE = 400005;\n\nstruct Edge {\n    int dest;\n    Edge *next;\n    Edge() {}\n    Edge(int _dest, Edge *_next) : dest(_dest), next(_next) {}\n}EdgePool[MAXE], *EP, *e[MAXN];\n\nint n;\nint goal[MAXN], init[MAXN], x[MAXN], ans[MAXN], q[MAXN], fa[MAXN], sum[MAXN];\nbool vis[MAXN];\n\ninline void addedge(int a, int b) {\n    e[a] = new(EP++)Edge(b, e[a]);\n    e[b] = new(EP++)Edge(a, e[b]);\n}\n\nvoid bfs() {\n    Fill(fa, 0);\n    Fill(vis, 0);\n    Fill(ans, 0);\n    q[1] = 1;\n    for (int l = 1, r = 1; l <= r; l++) {\n        int i = q[l];\n        vis[i] = 1;\n        ans[i] = sum[fa[fa[i]]] ^ x[i];\n        sum[i] = sum[fa[fa[i]]] ^ ans[i];\n        erep (j, e[i]) if (!vis[j->dest]) {\n            fa[j->dest] = i;\n            q[++r] = j->dest;\n        }\n    }\n}\n\nint main() {\n    EP = EdgePool; Fill(e, 0);\n    R(n);\n    rep (i, 1, n - 1) {\n        int a, b;\n        SS(a, b);\n        addedge(a, b);\n    }\n    rep (i, 1, n) R(init[i]);\n    rep (i, 1, n) R(goal[i]);\n    rep (i, 1, n) x[i] = init[i] ^ goal[i];\n    bfs();\n    int tot = 0;\n    rep (i, 1, n) tot += ans[i];\n    pf(\"%d\\n\", tot);\n    rep (i, 1, n) if (ans[i]) pf(\"%d\\n\", i);\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Xor-tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/12265",
    "editorial": "There is something to learn from \u0093propagating tree\u0094 problem, used in round #225. It\u0092s how the special operation works. I\u0092ll copy paste the explanation from there (with some modification, corresponding to the problem):\n\nLet\u0092s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won\u0092t be flipped. Let\u0092s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won\u0092t. We\u0092ll use this fact later. For now, let\u0092s think what should be our first operation. Let\u0092s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we\u0092ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We\u0092ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.\n\nWhat we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won\u0092t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won\u0092t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed.\n\nHow can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won\u0092t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won\u0092t have any unfixed ancestor (because it won\u0092t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it\u0092s unfixed and this is the only way to fix it, you\u0092ll be obligated to do this operation. This means, in an optimal sequence of operations, you\u0092ll be obligated to do this operation, too.\n\nSo, if node 1 was unfixed, we did an operation on it. If it was already fixed, we\u0092re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it\u0092s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won\u0092t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we\u0092ll have to make operations on them. Let\u0092s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn\u0092t helpful, because even if it fixes this node, it unfixes 1. Then, you\u0092ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.\n\nGenerally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we\u0092ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we\u0092re forced to do it.\n\nThis leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2.\n\nWe can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N)."
}