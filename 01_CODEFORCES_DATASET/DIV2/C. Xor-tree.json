{"link": "https://codeforces.com//contest/430/problem/C", "problemId": "9399", "problem_idx": "C", "shortId": "430C", "contest_number": "430", "problem_submissions": {"E": [6596209, 6601239, 6595457, 6596869, 6611998], "C": [6593903, 6589689, 6590185, 6591146, 6594509, 6591043, 6594881, 6592145, 6591439, 6590916, 6592010, 6592041, 6592596, 6592644, 6593233, 6592230, 6592515, 6591488, 6591864], "D": [6592681, 6591086, 6597590, 6592274, 6591820, 6594037, 6592628, 6594400, 6599564, 6594397, 6596203, 6595708, 6594744, 6595014, 6595972, 6596088, 6594380, 6593712, 6595433], "B": [6591917, 6588904, 6589347, 6590112, 6589136, 6589725, 6590062, 6590923, 6589922, 6588990, 6590100, 6590128, 6591019, 6591186, 6590471, 6590715, 6590194, 6589294, 6593720], "A": [6588412, 6588136, 6588222, 6588465, 6590072, 6588672, 6588238, 6589003, 6588856, 6595945, 6588333, 6588427, 6589419, 6589285, 6588864, 6589371, 6595841, 6600698, 6589758]}, "name": "C. Xor-tree", "statement": "Iahub is very proud of his recent discovery, propagating trees. Right\r\nnow, he invented a new tree, called xor-tree. After this new\r\nrevolutionary discovery, he invented a game for kids which uses\r\nxor-trees.The game is played on a tree having nodes, numbered from to .\r\nEach node has an initial value , which is either 0 or 1. The root of the\r\ntree is node 1.One can perform several (possibly, zero) operations on\r\nthe tree during the game. The only available type of operation is to\r\npick a node . Right after someone has picked node , the value of node\r\nflips, the values of sons of remain the same, the values of sons of sons\r\nof flips, the values of sons of sons of sons of remain the same and so\r\non.The goal of the game is to get each node to have value , which can\r\nalso be only 0 or 1. You need to reach the goal of the game by using\r\nminimum number of operations.\r\n", "solutions": ["/**************************************************\n *        Problem:  Codeforces #245 Div.2 Problem C\n *         Author:  clavichord93\n *          State:  \n **************************************************/\n\n/**************************************************\n * Header\n **************************************************/\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <limits>\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Copy(a, b) memcpy(a, b, sizeof(b))\n#define NPOS string::npos\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define rrep(i, a, b) for (int i = a; i >= b; i--)\n#define erep(j, a) for (Edge *j = a; j; j = j->next)\n#define irep(i, a) for (__typeof(a.begin()) i = a.begin(); i != a.end(); i++)\n#define srep(sub, s) for (int sub = s & (s - 1); sub; sub = (sub - 1) & s)\n#define sqr(a) ((a) * (a))\n#define R(x) scanf(\"%d\", &x)\n#define SS(a, b) scanf(\"%d %d\", &a, &b)\n#define SSS(a, b, c) scanf(\"%d %d %d\", &a, &b, &c)\n#define O(x) pf(\"%d\\n\", x)\n#define TEST int T;scanf(\"%d\", &T);for (int cas = 1; cas <= T; cas++)\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define ppb pop_back\n#define pft push_front\n#define ppf pop_front\n#define mp make_pair\n#define vec vector\n#define it iterator\n#define fir first\n#define sec second\n#define x first\n#define y second\n#define all(a) a.begin(),a.end()\n#define sz(a) (int)(a.size())\n#define bg(a) (a).begin()\n#define en(a) (a).end()\n#define clr(a) (a).clear()\n#define dbg(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n#define bit_cnt(x) __builtin_popcount((unsigned)x)\n#define gcd(a, b) __gcd(a, b)\n#define sqr(a) ((a) * (a))\n#define lch(t) (t << 1)\n#define rch(t) (t << 1 | 1)\n#define inf numeric_limits<int>::max()\n#define finf numeric_limits<double>::infinity()\nusing namespace std;\ntemplate<class T> inline bool gmin(T &a, T b) { if (a > b) return a = b, true; return false; }\ntemplate<class T> inline bool gmax(T &a, T b) { if (a < b) return a = b, true; return false; }\ntemplate<class T> T exgcd(T a, T b, T &x, T &y) { if (!b) return x = (T)1, y = (T)0, a; else { T d = exgcd(b, a % b, y, x); return y -= a / b * x, d; } }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<double, double> pdd;\ntypedef pair<double, pdd> pddd;\ntypedef vec<int> vi;\ntypedef vec<double> vd;\ntypedef vec<pii> vii;\ntypedef vec<pdd> vdd;\ntypedef istringstream iss;\ntypedef ostringstream oss;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1e10;\nconst double EPS = 1e-9;\nconst double PI = 3.14159265358979323846264338327950288;\nconst double TAU = 2.0 * PI;\ninline int sgn(const double &a) { return a > EPS ? 1 : (a < -EPS ? -1 : 0); }\ninline int lowbit(int i) { return i & (-i); }\nstruct Initializer { Initializer() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); } } initializer;\n\n/**************************************************\n * Templates\n **************************************************/\n\n\n\n/**************************************************\n * Main\n **************************************************/\n\nconst int MAXN = 200005;\nconst int MAXE = 400005;\n\nstruct Edge {\n    int dest;\n    Edge *next;\n    Edge() {}\n    Edge(int _dest, Edge *_next) : dest(_dest), next(_next) {}\n}EdgePool[MAXE], *EP, *e[MAXN];\n\nint n;\nint goal[MAXN], init[MAXN], x[MAXN], ans[MAXN], q[MAXN], fa[MAXN], sum[MAXN];\nbool vis[MAXN];\n\ninline void addedge(int a, int b) {\n    e[a] = new(EP++)Edge(b, e[a]);\n    e[b] = new(EP++)Edge(a, e[b]);\n}\n\nvoid bfs() {\n    Fill(fa, 0);\n    Fill(vis, 0);\n    Fill(ans, 0);\n    q[1] = 1;\n    for (int l = 1, r = 1; l <= r; l++) {\n        int i = q[l];\n        vis[i] = 1;\n        ans[i] = sum[fa[fa[i]]] ^ x[i];\n        sum[i] = sum[fa[fa[i]]] ^ ans[i];\n        erep (j, e[i]) if (!vis[j->dest]) {\n            fa[j->dest] = i;\n            q[++r] = j->dest;\n        }\n    }\n}\n\nint main() {\n    EP = EdgePool; Fill(e, 0);\n    R(n);\n    rep (i, 1, n - 1) {\n        int a, b;\n        SS(a, b);\n        addedge(a, b);\n    }\n    rep (i, 1, n) R(init[i]);\n    rep (i, 1, n) R(goal[i]);\n    rep (i, 1, n) x[i] = init[i] ^ goal[i];\n    bfs();\n    int tot = 0;\n    rep (i, 1, n) tot += ans[i];\n    pf(\"%d\\n\", tot);\n    rep (i, 1, n) if (ans[i]) pf(\"%d\\n\", i);\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "dfs and similar", "trees"], "dificulty": "1300", "interactive": false}