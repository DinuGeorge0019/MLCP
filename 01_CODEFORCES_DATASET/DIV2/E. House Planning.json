{"link": "https://codeforces.com//contest/1735/problem/E", "problemId": "1564419", "problem_idx": "E", "shortId": "1735E", "contest_number": "1735", "problem_submissions": {"B": [177889662, 177889589, 174382271, 174383359, 174378958, 174381714, 174380678, 174381284, 174379449, 174381236, 174383409, 174380794, 174386997, 174380696, 174383029, 174388681, 174388918, 174381361, 174381492, 174380657], "C": [177889461, 174387237, 174388475, 174385426, 174386634, 174386940, 174388812, 174387047, 174386729, 174389951, 174392206, 174395309, 174395650, 174392066, 174399201, 174396076, 174396038, 174408989, 174396383], "D": [177889264, 177889136, 174395610, 174396308, 174396251, 174394725, 174402042, 174395692, 174394285, 174419012, 174399212, 175815897, 174399788, 174408325, 174404931, 174401396, 174409441, 174402400, 174412649, 174401383, 174405540], "E": [177889081, 174408134, 174405644, 174412472, 174412292, 174413019, 174414458, 174417521, 174411011, 174419212, 175815464, 174463147, 174421324, 174420863, 174423975, 174427537, 174420606, 174423899, 174420778, 174422936, 174422611], "F": [177888879, 174528121, 174463614, 174586382], "A": [177888485, 174377614, 174378788, 174377462, 174377792, 174377956, 174378462, 174377717, 174377806, 174378861, 174382247, 174379109, 174377781, 174377528, 174379924, 174379851, 174378283, 174383584, 174377997]}, "name": "E. House Planning", "statement": "There are n houses in your city arranged on an axis at points h_1, h_2,\r\nldots, h_n. You want to build a new house for yourself and consider two\r\noptions where to place it: points p_1 and p_2.As you like visiting\r\nfriends, you have calculated in advance the distances from both options\r\nto all existing houses. More formally, you have calculated two arrays\r\nd_1, d_2: d_{i, j} =\r\nleft|p_i - h_j\r\nright|, where |x| defines the absolute value of x.After a long time of\r\ninactivity you have forgotten the locations of the houses h and the\r\noptions p_1, p_2. But your diary still keeps two arrays d_1, d_2, whose\r\nauthenticity you doubt. Also, the values inside each array could be , so\r\nvalues at the same positions of d_1 and d_2 may correspond to different\r\nhouses. Pay attention, that values from one array could not get to\r\nanother, in other words, all values in the array d_1 correspond the\r\ndistances from p_1 to the houses, and in the array d_2 from p_2 to the\r\nhouses.Also pay attention, that the locations of the houses h_i and the\r\nconsidered options p_j could match. For example, the next locations are\r\ncorrect: h =\r\n{1, 0, 3, 3\r\n}, p =\r\n{1, 1\r\n}, that could correspond to already shuffled d_1 =\r\n{0, 2, 1, 2\r\n}, d_2 =\r\n{2, 2, 1, 0\r\n}.Check whether there are locations of houses h and considered points\r\np_1, p_2, for which the founded arrays of distances would be correct. If\r\nit is possible, find appropriate locations of houses and considered\r\noptions.\r\n", "solutions": ["// LUOGU_RID: 91547067\n//author: HugeWide\n/*rating:\nCodeforces: 2028,Candidate Master\nAtcoder: 2025,1Dan\nLuogu: 312=100+52+0+100+60\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\n\ninline ll read() {\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') {\n\t\tif(ch=='-') f=-f;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') {\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline void write(ll x) {\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>=10) write(x/10);\n\tputchar(x%10+'0');\n}\n#define writesp(x) write(x),putchar(' ')\n#define writeln(x) write(x),putchar('\\n')\n\n#define rep(x,l,r) for(int x=l;x<=r;x++)\n#define per(x,r,l) for(int x=r;x>=l;x--)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nconst int N=1010;\n\nint n;\nll d[2][N];\nbool vis[2][N];\npriority_queue<pair<ll,pair<int,int> > > q;\nset<pair<ll,int> > s[2];\nvector<ll> ans;\nvector<ll> a[2];\nll P[2];\nbool check(ll D) {\n//\tcout<<\"\\t\\t\"<<D<<'\\n';\n\tP[0]=0,P[1]=D;\n\tans.clear();\n\twhile(!q.empty()) q.pop(); rep(j,0,1) s[j].clear();\n\trep(j,0,1) rep(i,1,n) {\n\t\tq.push(mp(d[j][i],mp(j,i)));\n\t\ts[j].insert(mp(d[j][i],i));\n\t\tvis[j][i]=0;\n\t}\n\twhile(!q.empty()) {\n\t\tll v=q.top().first;\n\t\tint j=q.top().second.first;\n\t\tint i=q.top().second.second;\n\t\tq.pop(); if(vis[j][i]) continue;\n\t\tif(v<=D) break; vis[j][i]=1;\n\t\tset<pair<ll,int> >::iterator it=s[j^1].lower_bound(mp(v-D,0));\n\t\tif(it==s[j^1].end()) return false;\n//\t\tcout<<v<<' '<<it->first<<'\\n';\n\t\tif(it->first!=v-D) return false;\n\t\ts[j^1].erase(it);\n\t\tint jj=j^1;\n\t\tint ii=it->second;\n\t\tvis[jj][ii]=1;\n\t\tif(j==0) {\n\t\t\tans.pb(v);\n\t\t} else {\n\t\t\tans.pb(D-v);\n\t\t}\n\t\tit=s[j].find(mp(d[j][i],i));\n\t\ts[j].erase(it);\n\t}\n\trep(j,0,1) a[j].clear();\n\trep(j,0,1) rep(i,1,n) if(!vis[j][i]) {\n\t\ta[j].pb(d[j][i]);\n\t}\n\tsort(all(a[0])),sort(all(a[1])),reverse(all(a[1]));\n\tint siz=a[0].size();\n\tif(a[0].size()!=a[1].size()) exit(11);\n//\tcout<<'a';\n//\trep(j,0,1) {\n//\t\trep(i,0,siz-1) cout<<a[j][i];\n//\t\tcout<<'\\n';\n//\t}\n\trep(i,0,siz-1) {\n\t\tif(a[0][i]+a[1][i]!=D) return false;\n//\t\tcout<<'a';\n\t\tans.pb(a[0][i]);\n\t}\n\treturn true;\n}\n\nll f(ll x) {\n\treturn x>=0?x:-x;\n}\nvoid chk() {\n\tll mn=0;\n\trep(i,0,n-1) mn=min(mn,ans[i]);\n\tmn=min(mn,min(P[0],P[1]));\n\trep(i,0,n-1) ans[i]-=mn;\n\tP[0]-=mn,P[1]-=mn;\n}\nvoid print() {\n\tprintf(\"YES\\n\");\n\trep(i,0,n-1) writesp(ans[i]);\n\tputchar('\\n');\n\twritesp(P[0]),writeln(P[1]);\n}\nvoid solve() {\n\tn=read();\n\trep(j,0,1) rep(i,1,n) d[j][i]=read();\n//\tcheck(36);\n\trep(i,1,n) {\n\t\tif(check(f(d[1][i]-d[0][1]))) {\n\t\t\tchk(),print(); return;\n\t\t}\n\t\tif(check(f(d[1][i]+d[0][1]))) {\n\t\t\tchk(),print(); return;\n\t\t}\n\t}\n\tprintf(\"NO\\n\");\n}\n\nint main() {\n\tint t=read(); while(t--) solve();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "graph matchings", "greedy"], "dificulty": "2400", "interactive": false}