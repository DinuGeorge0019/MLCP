{
    "link": "https://codeforces.com//contest/465/problem/C",
    "problemId": "13521",
    "problem_idx": "C",
    "shortId": "465C",
    "contest_number": "465",
    "problem_submissions": {
        "A": [
            7711802,
            7701020,
            7701162,
            7701215,
            7701067,
            7700923,
            7700938,
            7700998,
            7700973,
            7701012,
            7701685,
            7701159,
            7701027,
            7700987,
            7701142,
            7707761
        ],
        "B": [
            7710960,
            7702304,
            7704505,
            7702799,
            7702477,
            7701665,
            7702245,
            7703705,
            7702813,
            7701866,
            7704644,
            7703425,
            7704203,
            7702935,
            7704029,
            7708200
        ],
        "C": [
            7710335,
            7706333,
            7703312,
            7705351,
            7704980,
            7706564,
            7707092,
            7707812,
            7708661,
            7712440,
            7711616,
            7713184,
            7708012,
            7713150,
            7707559,
            7704663,
            7713529
        ],
        "D": [
            7709422,
            7712990,
            7717263,
            7711449,
            7714497,
            7710959,
            7711750,
            7710792,
            7709092,
            7709745,
            7709556,
            7712262,
            7717463,
            7717446,
            7710168,
            7710367
        ],
        "E": [
            7704010,
            7709717,
            7707403,
            7708373,
            7710918,
            7711818,
            9363741,
            7713618,
            7713248
        ]
    },
    "name": "C. No to Palindromes ",
    "statement": "Paul palindromes. He assumes that string is if each its character is one\r\nof the first letters of the English alphabet and doesnâ€™t contain any\r\npalindrome contiguous substring of length 2 or more.Paul has found a\r\ntolerable string of length . Help him find the lexicographically next\r\ntolerable string of the same length or else state that such string does\r\nnot exist.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iostream>\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i != _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 1000;\n\nint n, p;\n\nchar st[maxn + 5];\nchar tmp;\n\nbool find(const int &x)\n{\n\tif (x == -1) return 0;\n\tfor (int i = 1; ; ++i)\n\t{\n\t\tif (st[x] + i >= tmp) break;\n\t\tif (x > 0 && st[x - 1] == st[x] + i) continue;\n\t\tif (x > 1 && st[x - 2] == st[x] + i) continue;\n\t\tst[x] += i;\n\t\treturn 1;\n\t}\n\tif (!find(x - 1)) return 0;\n\tst[x] = 'a';\n\tfor (int i = 0; ; ++i)\n\t{\n\t\tif (st[x] + i >= tmp) break;\n\t\tif (x > 0 && st[x - 1] == st[x] + i) continue;\n\t\tif (x > 1 && st[x - 2] == st[x] + i) continue;\n\t\tst[x] += i;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d%d\", &n, &p);\n\ttmp = 'a' + p;\n\tscanf(\"%s\", st);\n\tif (find(n - 1)) printf(\"%s\\n\", st);\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. No to Palindromes .json",
    "editorial_link": "https://codeforces.com//blog/entry/13694",
    "editorial": "If string s contains a non-trivial palindromic substring w, then it must contain palindromic substring of length 2 or 3 (for instance, center of w). Therefore the string is tolerable iff no adjacent symbols or symbols at distance 1 are equal.\n\nNow for the lexicographically next tolerable string t. t is greater than s, so they have common prefix of some size (maybe zero) and the next symbol is greater in t than in s. This symbol should be as right as possible to obtain minimal possible t. For some position i we can try to increment si and ensure it's not equal to si?-?1 or si?-?2. If we find some way to do this, the suffix can always be filled correctly if only p???3, as at most two symbols are forbidden at every moment. Every symbol from suffix should be as small as possible not to make conflicts. So, a greedy procedure or some kind of clever brute-force can be implemented to solve the problem in O(n). Cases p?=?1 or 2 are easy, as only strings of length at most 1, and at most 2 respectively fit.\n\nThis is an application on general approach to generate next lexicographical something: try to increment rightmost position so that suffix can be filled up in some way, then fill the suffix in least possible way.\n\nAs pointed out in Russian discussion, this problem is a simplified version of the problem from some previous round: 196D - The Next Good String. We were not aware of this and apologize for the misfortune. Luckily, no copied solutions from that problem were spotted. If you enjoyed this simple version, you may want to try the harder one know. =)",
    "hint": []
}