{
    "link": "https://codeforces.com//contest/1370/problem/B",
    "problemId": "652384",
    "problem_idx": "B",
    "shortId": "1370B",
    "contest_number": "1370",
    "problem_submissions": {
        "F2": [
            84487930,
            84501037,
            84507034,
            84502122,
            84505842,
            84494417,
            84504172,
            84566845,
            84578526,
            84673821,
            84511966,
            84521155,
            84516268,
            84510958,
            84637167,
            84542732
        ],
        "F1": [
            84486378,
            84486419,
            84492617,
            84502436,
            84505676,
            84494227,
            84501907,
            84505799,
            84499630,
            84498065,
            84511746,
            84521030,
            84480006,
            84503644,
            84491858,
            84509184,
            84485122,
            84503318,
            84509115,
            84506881
        ],
        "E": [
            84464817,
            84468991,
            84473151,
            84479507,
            84475443,
            84500759,
            84489817,
            84460631,
            84470842,
            84474055,
            84482485,
            84496561,
            84465043,
            84479036,
            84484283,
            84492032,
            84480292,
            84478287,
            84477997
        ],
        "D": [
            84455500,
            84452319,
            84463814,
            84469488,
            84464677,
            84451453,
            84463855,
            84448741,
            84456676,
            84455689,
            84468315,
            84454815,
            84457156,
            84464597,
            84470092,
            84462687,
            84463427,
            84468065,
            84460953
        ],
        "C": [
            84440472,
            84440716,
            84454929,
            84448947,
            84446464,
            84442992,
            84450392,
            84441491,
            84448508,
            84447398,
            84459387,
            84446704,
            84452028,
            84452970,
            84461892,
            84451604,
            84450230,
            84447402,
            84456732
        ],
        "B": [
            84435577,
            84430992,
            84438860,
            84436667,
            84431532,
            84431988,
            84433331,
            84431260,
            84434049,
            84434058,
            84441995,
            84433852,
            84624590,
            84440409,
            84443832,
            84438516,
            84432500,
            84433721,
            84440325,
            84431147
        ],
        "A": [
            84423084,
            84423206,
            84424226,
            84425612,
            84423582,
            84423261,
            84424093,
            84424056,
            84423388,
            84425755,
            84429438,
            84426743,
            84423750,
            84423134,
            84428806,
            84425122,
            84423069,
            84423389,
            84423328
        ]
    },
    "name": "B. GCD Compression",
    "statement": "Ashish has an array a of consisting of 2n positive integers. He wants to\r\ncompress a into an array b of size n-1. To do this, he first discards\r\nexactly 2 (any two) elements from a. He then performs the following\r\noperation until there are no elements left in a: Remove any two elements\r\nfrom a and append their sum to b. The compressed array b has to have a\r\nspecial property. The greatest common divisor (\r\nmathrm{gcd}) of all its elements should be greater than 1.Recall that\r\nthe\r\nmathrm{gcd} of an array of positive integers is the biggest integer that\r\nis a divisor of all integers in the array.It can be proven that it is\r\nalways possible to compress array a into an array b of size n-1 such\r\nthat gcd(b_1, b_2..., b_{n-1}) > 1. Help Ashish find a way to do so.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint a[2005], cnt[1005], used[2005], lst[1005];\n\nmain() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    vector < int > primes;\n    for (int i = 2; i <= 1000; ++i) {\n        int ok = 1;\n        for (int j = 2; j < i; ++j) if (i % j == 0) ok = 0;\n        if (ok) primes.push_back(i);\n    }\n    while (t--) {\n        int n;\n        cin >> n;\n        for (int i = 1; i <= 2 * n; ++i) used[i] = 0;\n        for (int i = 1; i <= 2 * n; ++i) cin >> a[i];\n        for (auto key : primes) {\n            for (int j = 0; j < key; ++j) cnt[j] = 0;\n            for (int i = 1; i <= 2 * n; ++i) cnt[a[i] % key]++;\n            int sum = 0;\n            for (int i = 0; i < key; ++i) {\n                if (i == 0) sum += cnt[i] / 2;\n                else if (i <= key - i) sum += min(cnt[i], cnt[key - i]);\n            }\n            if (sum >= n - 1) {\n                for (int t = 1; t <= n - 1; ++t) {\n                    for (int j = 0; j < key; ++j) lst[j] = 0;\n                    for (int i = 1; i <= 2 * n; ++i) {\n                        if (used[i]) continue;\n                        int val = (key - a[i] % key) % key;\n                        if (lst[val] != 0) {\n                            cout << i << \" \" << lst[val] << '\\n';\n                            used[i] = 1;\n                            used[lst[val]] = 1;\n                            break;\n                        }\n                        lst[a[i] % key] = i;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. GCD Compression.json",
    "editorial_link": "https://codeforces.com//blog/entry/79107",
    "editorial": ":It is always possible to form pairs of elements such that their gcd is\r\ndivisible by .:We can pair up the odd numbers and even numbers\r\nseparately so that the sum of numbers in each pair is divisible by .\r\nNote that we can always form pairs in the above manner because in the\r\nworst case, we would discard one odd number and one even number from .\r\nIf we discarded more than one even or odd numbers, we could instead form\r\nanother pair with even sum.Time Complexity:\r\n",
    "hint": []
}