{
    "link": "https://codeforces.com//contest/1365/problem/D",
    "problemId": "643139",
    "problem_idx": "D",
    "shortId": "1365D",
    "contest_number": "1365",
    "problem_submissions": {
        "G": [
            82837838,
            82865836,
            82846144,
            82865744,
            83288423,
            83288390,
            83115367,
            83113068,
            82891046,
            83317408
        ],
        "F": [
            82823576,
            82831163,
            82869715,
            82841291,
            82797913,
            82821383,
            82823224,
            82820878,
            82825962,
            82827764,
            82819318,
            82822994,
            82828397,
            82835003,
            82834772,
            82828790,
            83116114,
            82838680,
            82843357,
            82850042
        ],
        "E": [
            82816827,
            82806889,
            82828546,
            82852781,
            82820451,
            82809338,
            82811048,
            82815094,
            82813767,
            82818099,
            82819025,
            82806699,
            82809270,
            82814661,
            82803838,
            82820792,
            82820031,
            82816700,
            82817857,
            82816698
        ],
        "D": [
            82812948,
            82823500,
            82822183,
            82824676,
            82812570,
            82806668,
            82804333,
            82805751,
            82808225,
            82811038,
            82801401,
            82805193,
            82808495,
            82818445,
            82814370,
            83282843,
            82816083,
            82808400,
            82807406,
            82806087
        ],
        "C": [
            82796097,
            82796764,
            82804011,
            82805788,
            82786984,
            82796314,
            82793579,
            82793092,
            82796581,
            82800342,
            82827239,
            82793084,
            82792671,
            82807140,
            82802231,
            82801070,
            82793918,
            82793032,
            82794670
        ],
        "B": [
            82789379,
            82791264,
            82799267,
            82793610,
            82787860,
            82790701,
            82790486,
            82792963,
            82793820,
            82794046,
            82787508,
            82790351,
            82789454,
            82795420,
            82796086,
            83567414,
            83567289,
            83567233,
            83566819,
            83566572,
            83566088,
            83137777,
            83136749,
            83136555,
            82797438,
            82788975,
            82789229,
            82789419
        ],
        "A": [
            82787406,
            82788164,
            82795856,
            82788300,
            82789945,
            82787354,
            82787533,
            82792868,
            82790605,
            82788592,
            83313475,
            82823189,
            82788613,
            82787440,
            82788379,
            82788620,
            82787269,
            82787662,
            82787203,
            82787209
        ]
    },
    "name": "D. Solve The Maze",
    "statement": "Vivek has encountered a problem. He has a maze that can be represented\r\nas an n\r\ntimes m grid. Each of the grid cells may represent the following: Empty\r\n” Wall ” Good person ” Bad person ” The only escape from the maze is at\r\ncell (n, m).A person can move to a cell only if it shares a side with\r\ntheir current cell and does not contain a wall. Vivek wants to block\r\nsome of the empty cells by replacing them with walls in such a way, that\r\nall the good people are able to escape, while none of the bad people are\r\nable to. A cell that initially contains ” or ” and .Help him determine\r\nif there exists a way to replace some (zero or more) empty cells with\r\nwalls to satisfy the above conditions. Vivek can also block this cell.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint getTile(){\n\tchar c;\n\tfor(;;){\n\t\tc=getchar();\n\t\tif(c=='.')return 0;\n\t\tif(c=='#')return 1;\n\t\tif(c=='G')return 2;\n\t\tif(c=='B')return 3;\n\t}\n}\nconst int movex[]={1, -1, 0, 0};\nconst int movey[]={0, 0, 1, -1};\nvector <int> p;\nvoid par(int x){\n\tif(p[x]==x)return;\n\tpar(p[x]);\n\tp[x]=p[p[x]];\n}\nint main(){\n\tint t=1;\n\tscanf(\"%d\" ,&t);\n\twhile(t--){\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tvector <vector <int> > b(n, vector <int> (m));\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tb[i][j]=getTile();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tif(b[i][j]==3){\n\t\t\t\t\tfor(int k = 0;k < 4;k ++){\n\t\t\t\t\t\tif(i+movex[k]==n||i+movex[k]==-1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(j+movey[k]==m||j+movey[k]==-1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(b[i+movex[k]][j+movey[k]]==0){\n\t\t\t\t\t\t\tb[i+movex[k]][j+movey[k]]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp.resize(n*m);\n\t\tfor(int i = 0;i < n*m;i ++){\n\t\t\tp[i]=i;\n\t\t}\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m-1;j ++){\n\t\t\t\tif(b[i][j]!=1&&b[i][j+1]!=1){\n\t\t\t\t\tint x=i*m+j, y=i*m+j+1;\n\t\t\t\t\tpar(x), par(y);\n\t\t\t\t\tif(p[x]!=p[y]){\n\t\t\t\t\t\tp[p[x]]=p[y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n-1;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tif(b[i+1][j]!=1&&b[i][j]!=1){\n\t\t\t\t\tint x=i*m+j+m, y=i*m+j;\n\t\t\t\t\tpar(x), par(y);\n\t\t\t\t\tif(p[x]!=p[y]){\n\t\t\t\t\t\tp[p[x]]=p[y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool good=true;\n\t\tbool bad=false;\n\t\tint y=n*m-1;\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tif(b[i][j]==2){\n\t\t\t\t\tint x=i*m+j;\n\t\t\t\t\tpar(x), par(y);\n\t\t\t\t\tif(p[x]!=p[y]){\n\t\t\t\t\t\tgood=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(b[i][j]==3){\n\t\t\t\t\tint x=i*m+j;\n\t\t\t\t\tpar(x), par(y);\n\t\t\t\t\tif(p[x]==p[y]){\n\t\t\t\t\t\tbad=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!good){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(bad){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"Yes\\n\");\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Solve The Maze.json",
    "editorial_link": "https://codeforces.com//blog/entry/78504",
    "editorial": "We can block all empty neighbouring cells of bad people and then check\r\nif all good people can escape and no bad people are able to\r\nescape.Consider all the neighbouring cells of bad people. There\r\nshouldnât be any path from these cells to the cell . If there is a path\r\nfrom any such cell, the bad person adjacent to that cell can also then\r\nreach the cell . So, if any good and bad people are in adjacent cells,\r\nthe answer is \"\".Based on this idea, we can block any empty cell\r\nneighbouring a bad person. Suppose there is another solution in which a\r\ncell neighbouring a bad person does not need to be blocked. There still\r\nwonât be any path from to in that solution. So we can block in that\r\nsolution too without affecting the solution itself.It is sufficient to\r\nblock only the empty neighbouring cells of bad people and check the\r\nrequired conditions, which can be done using a bfs on the grid.Proof:We\r\nwill assume there are no adjacent good and bad people since in that\r\ncase, the answer is \"\". There are three cases: A bad person is adjacent\r\nto the cell . In this case, the cell must be blocked. Now no one will be\r\nable to escape. If there is at least one good person present, the answer\r\nis \"\". If after blocking the neighbouring cells of bad people, there is\r\nsome good person who is not able to escape, then the answer is again \"\".\r\nOtherwise, the answer is always \"\". Suppose there is some path from a\r\nbad person at cell to the cell . One of the neighbours of this person\r\nmust be another bad person since the only other case is an adjacent good\r\nperson (which is already covered above). Extending this, all the cells\r\non the path from to must have bad people. This is not possible since in\r\nthis case, there must be a bad person adjacent to and this case is\r\nalready covered above. Time complexity:\r\n",
    "hint": []
}