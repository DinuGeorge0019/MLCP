{
    "link": "https://codeforces.com//contest/1786/problem/A2",
    "problemId": "1767291",
    "problem_idx": "A2",
    "shortId": "1786A2",
    "contest_number": "1786",
    "problem_submissions": {
        "E": [
            192342570,
            192306394,
            192404273,
            192327524,
            192339032,
            192311189,
            192325805,
            192320065,
            192441626,
            192343977,
            192328171,
            192315469,
            192316636,
            192338226,
            192342670,
            192339784,
            192342778
        ],
        "D": [
            192320379,
            192313768,
            192307277,
            192318549,
            192309409,
            192292999,
            192316314,
            192320950,
            192332305,
            192309612,
            192327595,
            192325214,
            192325223,
            192311769,
            192310059,
            192313834,
            192316588,
            192327743
        ],
        "F": [
            192310858,
            192336618,
            192349130,
            192348404,
            192333052,
            192339600,
            192329659,
            192334176,
            192328243,
            192307751,
            192340487,
            192363526,
            192345318
        ],
        "C": [
            192293366,
            192290648,
            192294881,
            192293245,
            192293510,
            192290179,
            192292716,
            192294689,
            192305954,
            192310133,
            192289535,
            192298071,
            192296223,
            192302623,
            192296901,
            192292106,
            192294116,
            192300798,
            192295593,
            192301556
        ],
        "B": [
            192288687,
            192344141,
            192291360,
            192289646,
            192340206,
            192287135,
            192290672,
            192302280,
            192292700,
            192296847,
            192294213,
            192293367,
            192300808,
            192292539,
            192288767,
            192289750,
            192293496,
            192292722,
            192296815
        ],
        "A2": [
            192287082,
            192284625,
            192286145,
            192285724,
            192290142,
            192283788,
            192286284,
            192297549,
            192284597,
            192306985,
            192286345,
            192288530,
            192296607,
            192287030,
            192284519,
            192284365,
            192288011,
            192288312,
            192289376
        ],
        "A1": [
            192287049,
            192283178,
            192286410,
            192283361,
            192283338,
            192284177,
            192283764,
            192296237,
            192283279,
            192307201,
            192286846,
            192283729,
            192297100,
            192283762,
            192283137,
            192282950,
            192288217,
            192285269,
            192287405
        ]
    },
    "name": "A2. Alternating Deck  hard version ",
    "statement": "Alice has n cards, each card is either black or white. The cards are\r\nstacked in a deck in such a way that the card colors alternate, starting\r\nfrom a white card. Alice deals the cards to herself and to Bob, dealing\r\nat once several cards from the top of the deck in the following order:\r\none card to herself, two cards to Bob, three cards to Bob, four cards to\r\nherself, five cards to herself, six cards to Bob, seven cards to Bob,\r\neight cards to herself, and so on. In other words, on the i-th step,\r\nAlice deals i top cards from the deck to one of the players; on the\r\nfirst step, she deals the cards to herself and then alternates the\r\nplayers every two steps. When there aren\u2019t enough cards at some step,\r\nAlice deals all the remaining cards to the current player, and the\r\nprocess stops. How many cards of each color will Alice and Bob have at\r\nthe end?\r\n",
    "solutions": [
        "// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, 1e5 + 5)\n\nint n, m;\nint a[N];\nint c[2][2];\n\nvoid solve() {\n\tqread(n);\n\trep(i, 0, 1) rep(j, 0, 1) c[i][j] = 0;\n\tc[0][1] = 1;\n\tint nw = 2, cc = 2, f = 1;\n\twhile(nw <= n) {\n\t\tint to = min(nw + cc - 1, n);\n\t\trep(i, nw, to) ++c[f][i & 1];\n\t\t++cc;\n\t\tnw = to + 1;\n\t\tto = min(nw + cc - 1, n);\n\t\trep(i, nw, to) ++c[f][i & 1];\n\t\t++cc;\n\t\tnw = to + 1; f ^= 1;\n\t}\n\tcout << c[0][1] << ' ' << c[0][0] << ' ' << c[1][1] << ' ' << c[1][0] << '\\n';\n}\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\twhile(T--) solve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A2. Alternating Deck  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/112875",
    "editorial": "Note that on the -th step, Alice takes cards from the deck. It means\r\nthat after steps, steps are taken from the deck. Thus, after steps, the\r\ndeck is empty. We can simulate the steps one by one by taking care of\r\nwhose turn it is and what is the color of the top card. Using this\r\ninformation, we can keep track of how many cards of what color each\r\nplayer has. Print this information in the end.\r\n"
}