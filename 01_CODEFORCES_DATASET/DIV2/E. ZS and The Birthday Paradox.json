{
    "link": "https://codeforces.com//contest/711/problem/E",
    "problemId": "69436",
    "problem_idx": "E",
    "shortId": "711E",
    "contest_number": "711",
    "problem_submissions": {
        "E": [
            20243389,
            20243503,
            20251107,
            20247122,
            20236128,
            20244311,
            20247031,
            20249581,
            20251290,
            20251110,
            20236252,
            20252814,
            20251720,
            20253127,
            20249558,
            20253691,
            20251603,
            20254289,
            20255257,
            20254984
        ],
        "D": [
            20236748,
            20238445,
            20241120,
            20241449,
            20243957,
            20248074,
            20235096,
            20241386,
            20243419,
            20245769,
            20252016,
            20241009,
            20246037,
            20248033,
            20253018,
            20249456,
            20247107,
            20247154,
            20250386,
            20243861
        ],
        "C": [
            20233774,
            20236081,
            20235214,
            20238143,
            20247473,
            20235216,
            20238803,
            20236811,
            20238264,
            20238615,
            20243230,
            20238055,
            20240001,
            20236172,
            20233634,
            20240235,
            20250548,
            20242121,
            20238810,
            20252383
        ],
        "B": [
            20231663,
            20231286,
            20231641,
            20233400,
            20241564,
            20239107,
            20249116,
            20232416,
            20233691,
            20233328,
            20237744,
            20233188,
            20232782,
            20232671,
            20234921,
            20232432,
            20236746,
            20235044,
            20234855,
            20236166
        ],
        "A": [
            20229146,
            20229063,
            20229191,
            20229690,
            20306899,
            20229217,
            20232219,
            20240668,
            20229251,
            20229508,
            20229028,
            20230826,
            20229961,
            20229487,
            20229092,
            20231432,
            20229019,
            20229332,
            20231409,
            20230327,
            20229746
        ]
    },
    "name": "E. ZS and The Birthday Paradox",
    "statement": "ZS the Coder has recently found an interesting concept called the\r\nBirthday Paradox. It states that given a random set of people, there is\r\naround chance that some two of them share the same birthday. ZS the\r\nCoder finds this very interesting, and decides to test this with the\r\ninhabitants of Udayland.In Udayland, there are days in a year. ZS the\r\nCoder wants to interview people from Udayland, each of them has birthday\r\nin one of days (each day with equal probability). He is interested in\r\nthe probability of at least two of them have the birthday at the same\r\nday. ZS the Coder knows that the answer can be written as an irreducible\r\nfraction . He wants to find the values of and (he does not like to deal\r\nwith floating point numbers). Can you help him?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int maxn = (int)1e6;\nconst int inf = (int)1e9;\nconst int mod = (int)1e6 + 3;\nconst ll INF = (ll)1e18;\nconst double eps = 1e-9;\n\nll n, k;\n\nll binpow(ll a, ll k) {\n\tif (k == 0) return 1;\n\tll ans = binpow(a, k / 2);\n\tans = 1ll * ans * ans % mod;\n\tif (k % 2) ans = 1ll * ans * a % mod;\n\treturn ans;\n}\n\nll g(ll n, ll k) {\n\tif (k < mod) {\n\t\tll t = binpow(2, n);\n\t\tll ans = 1;\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tans *= (t - (2ll * i + 1));\n\t\t\tans %= mod;\n\t\t\tif (ans < 0) ans += mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tll t = binpow(2, n);\n\tll cur = 1;\n\tfor (int i = 0; i < mod; i++) {\n\t\tcur *= (t - (2ll * i + 1));\n\t\tcur %= mod;\n\t\tif (cur < 0) cur += mod;\n\t}\n\tll s = k / mod;\n\tll ans = binpow(cur, s) * g(n, k % mod) % mod;\n\treturn ans;\n}\n\nll f(ll n, ll k) {\n\tif (k == 0) return 1;\n\tll t = (k - 1) / 2;\n\tll ans = g(n, t);\n\treturn ans * 1ll * f(n - 1, k / 2) % mod;\n}\n\nll get(ll n, ll k) {\n\tif (k == 0) return 0;\n\tll t = k / 2;\n\treturn t + get(n, t);\n}\n\nint main()\n{\n\n\tcin >> n >> k;\n\t\n\tif (n <= 60) {\n\t\tll mx = 1;\n\t\tfor (int i = 0; i < n; i++) mx *= 2;\n\t\tif (mx < k) {\n\t\t\tcout << 1 << \" \" << 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tll alpha = get(n, k - 1);\n\tll P = f(n, k - 1);\n\tll t = n % (mod - 1) * 1ll * ((k - 1) % (mod - 1)) % (mod - 1);\n\tt -= alpha;\n\tt %= mod - 1;\n\tt += mod - 1;\n\tt %= mod - 1;\n\tll Q = binpow(2, t);\n\t\n\tP = Q - P;\n\tP %= mod; P += mod; P %= mod;\n\t\n\tcout << P << \" \" << Q << endl;\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory",
        "probabilities"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. ZS and The Birthday Paradox.json",
    "editorial_link": "https://codeforces.com//blog/entry/46830",
    "editorial": "Note that is a prime.Firstly, if we have , then by pigeonhole principle\r\nwe must have people with the same birthday. Thus, we can directly output\r\n.Thus, now we suppose . Then, instead of computing the probability\r\ndirectly, we compute the complement, i.e. the probability that all the\r\npeople have distinct birthdays. This probability turns out to be much\r\nsimpler to calculate, as it is just . (Fix the birthday of the first\r\nperson, the probability that the second person has different birthday is\r\n, and for the next person itâs and so on.Now, we know that the\r\ndenominator is just a power of . However, we still have to reduce the\r\nfraction to the lowest terms. Note that is in the lowest terms if and\r\nonly if is in the lowest terms, since . Also, note that the gcd is a\r\npower of since the denominator is a power of . Thus, we need to find the\r\nhighest power of that divides . This is also equal to the sum of the\r\nhighest power of that divides , , ..., .Now, if a power of divides ,\r\nthen it must also divides and vice versa. So, we can actually translate\r\nthis to finding the sum of highest power of that divides , or the\r\nhighest power of that divides . Now, this is simple to calculate by\r\nLegendreâs formula (which is quite easy to prove) in .Now that we find\r\nthe gcd of the numerator and denominator, we can immediately find the\r\nreduced denominator by binary exponentiation. For the numerator, we need\r\na bit more work, since we have to deal with . However, it is not hard\r\neither. The key fact is that is small, so if , the product above is\r\nequal to modulo , because among consecutive integers there must be one\r\nthat is a multiple of . Thus, the above product can be calculated in if\r\nand otherwise. The remaining parts can be calculated using direct binary\r\nexponentiation.One minor note is that when weâre calculating , the value\r\nof might overflow. One way to resolve this is to reduce it modulo ,\r\nsince modulo by Fermatâs Little Theorem. Another way is to just evaluate\r\nfirst, then take the result and raise it to the -th power.Time\r\nComplexity :\r\n",
    "hint": []
}