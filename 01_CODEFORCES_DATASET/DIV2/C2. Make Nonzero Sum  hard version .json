{
    "link": "https://codeforces.com//contest/1754/problem/C2",
    "problemId": "1601071",
    "problem_idx": "C2",
    "shortId": "1754C2",
    "contest_number": "1754",
    "problem_submissions": {
        "F": [
            177585023,
            177595292,
            177589725,
            177595672,
            177592227,
            177594371,
            177600616,
            177598864,
            177604397,
            177602614,
            177600745,
            177650521
        ],
        "E": [
            177569689,
            177567357,
            177579016,
            177575748,
            177578227,
            177581574,
            177582284,
            177718437,
            177559205,
            177578841,
            177592467,
            177571365,
            177604409,
            177574278,
            177575358,
            177581672,
            177580864,
            177577975,
            177576690,
            177577060,
            177575788
        ],
        "D": [
            177558843,
            177556402,
            177557867,
            177557341,
            177566023,
            177561555,
            177537301,
            177563632,
            177569625,
            177568630,
            177559753,
            177582529,
            177556010,
            177555670,
            177565457,
            177546662,
            177548683,
            177569461,
            177558389,
            177564007
        ],
        "C2": [
            177551655,
            177558288,
            177573497,
            177569544,
            177555242,
            177556994,
            177560273,
            177574456,
            177565363,
            177565266,
            177553021,
            177580177,
            177562940,
            177559475,
            177572826,
            177570567,
            177562030,
            177570649,
            177565206
        ],
        "C1": [
            177547310,
            177553157,
            177573631,
            177554026,
            177551066,
            177557135,
            177560766,
            177574531,
            177555999,
            177565804,
            177552312,
            177567879,
            177563083,
            177549386,
            177558755,
            177554824,
            177557780,
            177570332,
            177559045
        ],
        "B": [
            177536928,
            177540939,
            177544434,
            177539979,
            177546063,
            177755484,
            177551911,
            177569215,
            177582864,
            177540989,
            177550638,
            177541452,
            177561666,
            177543484,
            177541411,
            177704318,
            177536796,
            177542739,
            177547137,
            178632445,
            177550998,
            177541636
        ],
        "A": [
            177533931,
            177534875,
            177539057,
            177534599,
            177534878,
            177755451,
            177538378,
            177573057,
            177577215,
            177534289,
            177537921,
            177534413,
            177539691,
            177533195,
            177532916,
            177535356,
            177704314,
            177533258,
            177538336,
            177537857,
            178632436,
            177537629,
            177532986
        ]
    },
    "name": "C2. Make Nonzero Sum  hard version ",
    "statement": "You are given an array [a_1, a_2,\r\nldots a_n] consisting of integers -1, 0 and 1. You have to build a\r\npartition of this array into the set of segments [l_1, r_1], [l_2, r_2],\r\nldots, [l_k, r_k] with the following property: Denote the alternating\r\nsum of all elements of the i-th segment as s_i: s_i = a_{l_i} -\r\na_{l_i+1} + a_{l_i+2} - a_{l_i+3} +\r\nldots\r\npm a_{r_i}. For example, the alternating sum of elements of segment [2,\r\n4] in array [1, 0, -1, 1, 1] equals to 0 - (-1) + 1 = 2. The sum of s_i\r\nover all segments of partition should be equal to zero. Note that each\r\ns_i does have to be equal to zero, this property is about sum of s_i\r\nover all segments of partition.The set of segments [l_1, r_1], [l_2,\r\nr_2],\r\nldots, [l_k, r_k] is called a of the array a of length n if 1 = l_1\r\nle r_1, l_2\r\nle r_2,\r\nldots, l_k\r\nle r_k = n and r_i + 1 = l_{i+1} for all i = 1, 2,\r\nldots k-1. In other words, each element of the array must belong to\r\nexactly one segment.You have to build a partition of the given array\r\nwith properties described above or determine that such partition does\r\nnot exist.Note that it is required to minimize the number of segments in\r\nthe partition.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define ln cout<<'\\n'\n#define ll long long\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}\ntemplate<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?\" \":\"\");pr(b...);}\ntemplate<class A>void PR(A a,ll n){rep(i,n)cout<<(i?\" \":\"\")<<a[i];ln;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={-1,0,1,0,-1,-1,1,1},dy[8]={0,1,0,-1,-1,1,1,-1};\ntypedef pair<ll,ll> P;\n\nvoid Main() {\n  ll T;\n  R T;\n  while(T--) {\n    ll n;\n    R n;\n    ll a[n];\n    rep(i,n) R a[i];\n    ll sum=0;\n    rep(i,n) sum+=a[i];\n    vector<P> ans;\n    vector<ll> v;\n    rep(i,n) {\n      if(a[i]) v.pb(i);\n    }\n    for(ll i=0; i<n; i++) {\n      if(i+1<n&&sum<0) {\n        ll k=upper_bound(all(v),i)-v.begin();\n        if(k<v.size()&&(v[k]-i)%2&&a[v[k]]==-1) {\n          ans.pb(P(i+1,v[k]+1));\n          sum+=2;\n          i=v[k];\n        } else ans.pb(P(i+1,i+1));\n      } else if(i+1<n&&sum>0) {\n        ll k=upper_bound(all(v),i)-v.begin();\n        if(k<v.size()&&(v[k]-i)%2&&a[v[k]]==1) {\n          ans.pb(P(i+1,v[k]+1));\n          sum-=2;\n          i=v[k];\n        } else ans.pb(P(i+1,i+1));\n      } else ans.pb(P(i+1,i+1));\n    }\n    if(!sum) {\n      pr(ans.size());\n      rep(i,ans.size()) pr(ans[i].F,ans[i].S);\n    } else pr(-1);\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C2. Make Nonzero Sum  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/108336",
    "editorial": "If the sum of all numbers in the array is odd, then splitting is impossible, because splitting does not affect the evenness of the sum. Otherwise, we will build the answer constructively. Suppose we have considered some kind of array prefix. Let's keep going until we get exactly 2\n non-zero numbers.\n\nWe want to make these two non-zero numbers add up to 0\n. Then if on the last segment the sum is already equal to 0\n, then just take it as an answer. Otherwise, consider a few cases:\n\nIf the length of the segment is even, then we simply separate the last number (it will be non-zero) into a separate segment. Then its sign will change and in total these two numbers will give 0\n.\nThe same can be done if the length of the segment is odd, but its first element is equal to 0\n. Separate this 0\n and repeat the algorithm above.\nIf the length of the segment is odd and the first element is not equal to 0\n, then we separate it. Then the value of the first element will not change, and the last will change to the opposite, and then their sum will be equal to 0\n.",
    "hint": []
}