{
    "link": "https://codeforces.com//contest/2028/problem/E",
    "problemId": "3015769",
    "problem_idx": "E",
    "shortId": "2028E",
    "contest_number": "2028",
    "problem_submissions": {
        "F": [
            290935691,
            290949712,
            290955148,
            290955187,
            290957184,
            292391424
        ],
        "E": [
            290922245,
            290922480,
            290920424,
            290927233,
            290924245,
            290933073,
            290931752,
            290929839,
            290930222,
            290933477,
            290938776,
            290925205,
            290935230,
            290939685,
            290935948,
            290940043,
            290940956,
            290939742,
            290941596
        ],
        "D": [
            290914114,
            290910753,
            290911155,
            290918762,
            290914432,
            290916818,
            290919264,
            290917594,
            290919639,
            290918811,
            290925900,
            290936103,
            290915690,
            290926820,
            290971789,
            290922189,
            290916679,
            290927684,
            290928018,
            290925322
        ],
        "C": [
            290904384,
            290896368,
            290900564,
            290905625,
            290896283,
            290906809,
            290893283,
            290905680,
            290908077,
            290905220,
            290900117,
            290902591,
            290910230,
            290901329,
            290904962,
            290902731,
            290903557,
            290906063,
            290905134
        ],
        "B": [
            290895606,
            290891907,
            290894947,
            290900151,
            290892659,
            290894607,
            290903522,
            290896362,
            290901510,
            290898064,
            290894885,
            290895319,
            290897887,
            290896070,
            290896548,
            290895196,
            290898108,
            290896215
        ],
        "A": [
            290889080,
            290888110,
            290888845,
            290888449,
            290888344,
            290888834,
            290895010,
            290888416,
            290888296,
            290888948,
            290888415,
            290888738,
            290892035,
            290889212,
            290888467,
            290903576,
            290888326,
            290888321,
            290889167
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136096",
    "editorial": "Note that Alice should always aim to move to the root, as this maximizes\r\nher probability of escaping (i.e., for any path from leaf to root,\r\nAlice\u00e2\u0080\u0099s probability of escaping increases moving up the path).\r\nFurthermore, the Queen should always move downward for the same reason\r\nas above. Furthermore, the Queen should always move to the closest leaf\r\nin the subtree rooted at the current node.There are now a few ways to\r\ncompute this, but basically all of them are . For one such slick way,\r\ndefine to be the distance to the closest leaf of the subtree of , to be\r\nthe parent of , and to be the probability Alice gets the treasure\r\nstarting at node . Then, we claim that for all vertices except the root.\r\nWe can populate these values as we DFS down the tree.Indeed, suppose\r\nthat the tree is just a path with vertices, labelled from through .\r\nThen, Alice\u00e2\u0080\u0099s probability of getting the treasure at node is (this comes\r\nfrom solving a system of linear equations). This lines up with the above\r\ncalculation.Now, we can construct the answer inductively. Let be a\r\nshortest root-to-leaf path in and consider the subtrees formed by\r\nremoving the edges of from . Each such subtree is rooted at some node .\r\nThen, in a subtree rooted at , the probability of Alice getting the\r\ntreasure is exactly the probability that Alice gets to node and then to\r\nnode from , by the chain rule of conditioning and noting that the Queen\r\nwill never re-enter the subtree and the game will only play out along\r\nfrom this point forward. Therefore, it suffices to deconstruct into\r\nshortest root-to-leaf paths and note that at a given vertex , we only\r\nhave to play along the sequence of shortest root-to-leaf paths leading\r\nfrom to . Along each of these paths, the above probability calculation\r\nholds, so we are done.\r\n",
    "name": "E. Alice s Adventures in the Rabbit Hole",
    "statement": "Alice is at the bottom of the rabbit hole! The rabbit hole can be\r\nmodeled as a tree^{\r\ntext{ }} which has an exit at vertex 1, and Alice starts at some vertex\r\nv. She wants to get out of the hole, but unfortunately, the Queen of\r\nHearts has ordered her execution. Each minute, a fair coin is flipped.\r\nIf it lands heads, Alice gets to move to an adjacent vertex of her\r\ncurrent location, and otherwise, the Queen of Hearts gets to pull Alice\r\nto an adjacent vertex of the Queen\u2019s choosing. If Alice ever ends up on\r\nany of the non-root leaves^{\r\ntext{ }} of the tree, Alice loses.Assuming both of them move optimally,\r\ncompute the probability that Alice manages to escape for every single\r\nstarting vertex 1\r\nle v\r\nle n. Since these probabilities can be very small, output them modulo\r\n998\r\n,244\r\n,353.Formally, let M = 998\r\n,244\r\n,353. It can be shown that the exact answer can be expressed as an\r\nirreducible fraction\r\nfrac{p}{q}, where p and q are integers and q\r\nnot\r\nequiv 0\r\npmod{M}. Output the integer equal to p\r\ncdot q^{-1}\r\nbmod M. In other words, output such an integer x that 0\r\nle x < M and x\r\ncdot q\r\nequiv p\r\npmod{M}. ^{\r\ntext{ }}A is a connected simple graph which has n vertices and n-1\r\nedges.^{\r\ntext{ }}A is a vertex that is connected to exactly one edge.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")#define ll long long#define ull unsigned long long#define lll __int128#define pc __builtin_popcount#define pr pair<int,int>#define pb push_back#define mp make_pair#define x first#define y second#define lb(x) x&-xusing namespace std;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());ll rint(ll l,ll r){return uniform_int_distribution<ll>(l,r)(rnd);}const int maxn=2e5+10,p=998244353;void read(int &X){\tX=0;\tchar cr=getchar();\twhile(cr<'0'||cr>'9') cr=getchar();\twhile(cr>='0'&&cr<='9') X=(X<<3)+(X<<1)+(cr^48),cr=getchar();}int ksm(int X,int Y){\tint T=1,U=X;\twhile(Y)\t{\t\tif(Y&1) T=1ll*T*U%p;\t\tY>>=1,U=1ll*U*U%p;\t}\treturn T;}int T,n,f[maxn],g[maxn],dep[maxn],v[maxn];vector<int> e[maxn];void dfs(int now,int fa){\tdep[now]=dep[fa]+1,v[now]=1e9;\tif(e[now].size()==1&&now!=1)\t{\t\tg[now]=0,v[now]=dep[now];\t\treturn;\t}\tint sm=-1;\tfor(int i:e[now])\t{\t\tif(i!=fa)\t\t{\t\t\tdfs(i,now);\t\t\tif(v[i]<v[now]) v[now]=v[i],sm=g[i];\t\t}\t}\tg[now]=ksm(p+2-sm,p-2);}void dfs2(int now,int fa){\tif(now==1) f[now]=1;\telse f[now]=1ll*g[now]*f[fa]%p;\tfor(int i:e[now]) if(i!=fa) dfs2(i,now);}int main(){//\tfreopen(\".in\",\"r\",stdin);//\tfreopen(\".out\",\"w\",stdout);\tread(T);\twhile(T--)\t{\t\tread(n);\t\tfor(int i=1;i<=n;i++) e[i].clear();\t\tfor(int i=1,x,y;i<n;i++) read(x),read(y),e[x].pb(y),e[y].pb(x);\t\tdfs(1,0),dfs2(1,0);\t\tfor(int i=1;i<=n;i++) printf(\"%d \",f[i]);\t\tprintf(\"\\n\");\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dp",
        "games",
        "greedy",
        "math",
        "probabilities",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Alice s Adventures in the Rabbit Hole.json"
}