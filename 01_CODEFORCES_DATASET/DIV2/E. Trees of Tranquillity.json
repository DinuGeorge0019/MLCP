{
    "link": "https://codeforces.com//contest/1529/problem/E",
    "problemId": "994172",
    "problem_idx": "E",
    "shortId": "1529E",
    "contest_number": "1529",
    "problem_submissions": {
        "E": [
            117241256,
            117224077,
            117234541,
            117233577,
            117569320,
            117237517,
            117242490,
            117246187,
            117240165,
            117245259,
            117241507,
            117250798,
            117245729,
            117250742,
            117250857,
            117218644
        ],
        "D": [
            117230306,
            117212621,
            117202664,
            117207279,
            117225346,
            117220644,
            117216468,
            117216196,
            117213173,
            117222042,
            117220584,
            117225498,
            117227881,
            117216922,
            117220354,
            117229060,
            117222399,
            117222507,
            117238884
        ],
        "C": [
            117214605,
            117199641,
            117194393,
            117203572,
            117194679,
            117202937,
            117207535,
            117193168,
            117200629,
            117205705,
            117207405,
            117200109,
            117211977,
            117207102,
            117207383,
            117205160,
            117202511,
            117210501,
            117233461
        ],
        "B": [
            117211463,
            117191644,
            117208208,
            117195752,
            117203773,
            117196989,
            117200392,
            117204712,
            117192618,
            117194128,
            117187965,
            117194040,
            117204576,
            117200157,
            117198432,
            117201536,
            117194899,
            117196661,
            117225707
        ],
        "A": [
            117204278,
            117182610,
            117191375,
            117182552,
            117181735,
            117183060,
            117186706,
            117181614,
            117182779,
            117184006,
            117181468,
            117181785,
            117189122,
            117193871,
            117183062,
            117182596,
            117181449,
            117183504,
            117220486
        ],
        "F": [
            117202382,
            117258211,
            117241820,
            117455126,
            117572881,
            117239369,
            117247608,
            117266116,
            117251683,
            117256888,
            117254087
        ]
    },
    "name": "E. Trees of Tranquillity",
    "statement": "Soroush and Keshi each have a labeled and rooted tree on n vertices.\r\nBoth of their trees are rooted from vertex 1.Soroush and Keshi used to\r\nbe at war. After endless decades of fighting, they finally became allies\r\nto prepare a Codeforces round. To celebrate this fortunate event, they\r\ndecided to make a memorial graph on n vertices.They add an edge between\r\nvertices u and v in the memorial graph if of the following conditions\r\nhold: One of u or v is the ancestor of the other in Soroush\u2019s tree.\r\nNeither of u or v is the ancestor of the other in Keshi\u2019s tree. Here\r\nvertex u is considered ancestor of vertex v, if u lies on the path from\r\n1 (the root) to the v.Popping out of nowhere, Mashtali tried to find the\r\nmaximum clique in the memorial graph for no reason. He failed because\r\nthe graph was too big. Help Mashtali by finding the size of the maximum\r\nclique in the memorial graph.As a reminder, clique is a subset of\r\nvertices of the graph, each two of which are connected by an edge.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 300005;\n\nstruct Action{\n    int timestamp;\n    int action;\n    pair<int, int> seg;\n};\n\nint n, ntime;\nint l[maxn], r[maxn], ans;\nvector<int> g[maxn], g2[maxn];\nset<pair<int, int>> segments;\nvector<Action> actions;\n\nvoid dfs_prepare(int v) {\n    l[v] = ++ntime;\n    for(int s : g2[v]) dfs_prepare(s);\n    r[v] = ntime;\n}\n\nbool cut(pair<int, int> u, pair<int, int> v) {\n    return (\n        (u.first <= v.first && u.second >= v.second) ||\n        (v.first <= u.first && v.second >= u.second)\n    );\n}\n\npair<int, int> findConflict(pair<int, int> cur) {\n    auto it = segments.upper_bound(make_pair(cur.second, cur.second));\n    if (it == segments.begin()) return make_pair(-1, -1);\n    --it;\n    if(cut(*it, cur)) return *it;\n    return make_pair(-1, -1);\n}\n\n\nvoid dfs_solve(int v) {\n    int stamp = ++ntime;\n    auto seg = make_pair(l[v], r[v]);\n    auto conf = findConflict(seg);\n\n    if (conf.first != -1) {\n        if(conf.first < seg.first) {\n            actions.push_back({stamp, 0, conf});\n            actions.push_back({stamp, 1, seg});\n            segments.insert(seg);\n            segments.erase(conf);\n        }\n    }\n    else {\n        actions.push_back({stamp, 1, seg});\n        segments.insert(seg);\n    }\n\n    ans = max(ans, (int)segments.size());\n\n    for(int s: g[v]) {\n        dfs_solve(s);\n        while(actions.size() > 0 && actions.back().timestamp > stamp) {\n            auto act = actions.back();\n            if (act.action == 0) {\n                segments.insert(act.seg);\n            }\n            else {\n                segments.erase(act.seg);\n            }\n            actions.pop_back();\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL);\n\n    int ntest; cin >> ntest;\n    while(ntest--) {\n        ntime = 0;\n        cin >> n;\n        for(int i = 1; i < n; ++i) {\n            int p; cin >> p; --p;\n            g[p].push_back(i);\n        }\n\n        for(int i = 1; i < n; ++i) {\n            int p; cin >> p; --p;\n            g2[p].push_back(i);\n        }\n\n        dfs_prepare(0);\n\n        ans = 0;\n        dfs_solve(0);\n        cout << ans << \"\\n\";\n\n        for(int i = 0; i < n; ++i) {\n            g[i].clear();\n            g2[i].clear();\n            ntime = 0;\n            segments.clear();\n            actions.clear();\n        }\n    }\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Trees of Tranquillity.json",
    "editorial_link": "https://codeforces.com//blog/entry/91058",
    "editorial": "Let's start with some observations.\n\nTake any clique C\n in the memorial graph.\n\nNotice that the vertices of C\n are a subset of a path from root to some leaf in Soroush's tree. So it's sufficient to solve the task for every leaf in Soroush's tree, specifically we should consider subsets of the paths starting from the root and ending in a leaf in Soroush's tree.\n\nAssume you have a data structure that supports the following operations:\n\nInsert a vertex.\nErase a vertex.\nAmong the vertices inside it, find the biggest set of vertices S\n such that none of them is the ancestor of the other in Keshi's tree.\nTo solve the task, start doing DFS from the root of Soroush's tree. Every time you visit a new vertex v\n, add v\n using the 1\n-st operation. Every time you finish doing DFS in a vertex v\n, erase v\n using the 2\n-nd operation.\n\nIt's easy to see that the vertices in the data structure always form a path from root to some vertex v\n in Soroush's tree.\n\nThe answer to the task is the maximum size of S\n in the 3\n-rd operation for every leaf u\n of Soroush's tree, when adding u\n has been the last operation in the data structure; In other words ans=max(ans,x)\n where x\n is the size of S\n in the 3\n-rd operation whenever you reach a leaf while doing DFS in Soroush's tree.\n\nWhen adding a vertex v\n to the data structure, if no vertex u?S\n existed such that u\n was in v\n's subtree in Keshi's tree, consider the following cases:\n\nIf no ancestor of v\n was in S\n, greedily add v\n to S\n.\nOtherwise, let that ancestor be w\n, erase w\n from S\n and add v\n instead.\nOn the other hand, if such a vertex u\n already existed in S\n, we won't add v\n to S\n based on the greedy solution mentioned above.\n\nWhatever notation used from here onwards refers to Keshi's tree unless stated.\n\nDo a DFS on the tree and find the starting time/finishing time for each vertex.\n\nIt's widely known that vertex v\n is an ancestor of vertex u?\n stv?stu\n and ftv?ftu\n.\n\nObservation: for any pair of vertices u\n and v\n, segments [stu,ftu]\n and [stv,ftv]\n either don't share an element or one of them lies completely inside the other.\n\nTo construct the aforementioned data structure:\n\nLet the set S\n be a maximal set of the vertices that form a clique in the memorial graph. For each vertex v\n we store a pair {stv,v}\n in S\n.\n\nNow to check whether any vertex u\n in the subtree of vertex v\n exists in S\n: Let p\n be the first pair in S\n such that the first element in p?stv\n. If p\n's second element's finishing time is less than ftv\n then p\n's second element is in v\n's subtree, otherwise it's not.\n\nNow to check whether any ancestor of v\n is in S\n or not: Let p\n be the first pair in S\n such that p\n's first element is less than stv\n, it can be proved that if an ancestor u\n of v\n exists in S\n, then p={stu,u}\n, thus we can check if v\n is in the subtree of p\n's second element by the aforementioned observation.\n\nDoing the erase operation is also possible by keeping a history of the deleted elements from the set S\n.\n\ncomplexity: O(nlogn)"
}