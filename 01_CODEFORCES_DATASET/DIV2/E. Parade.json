{"link": "https://codeforces.com//contest/35/problem/E", "problemId": "168", "problem_idx": "E", "shortId": "35E", "contest_number": "35", "problem_submissions": {"E": [154745, 154634, 155001, 155046, 155106, 155283, 155729], "D": [154342, 154272, 154130, 154311, 153835, 155440, 154204, 154250, 154067, 154477, 154655, 154659, 154763, 154771, 153757, 154608], "C": [154062, 153916, 153821, 154057, 153649, 155441, 153981, 153912, 153668, 154279, 154275, 154526, 154222, 154207, 153616, 154747], "B": [153817, 153677, 154472, 153724, 155455, 153704, 154027, 154569, 154040, 154009, 154129, 154473, 154591, 155725, 154964], "A": [153493, 153454, 153281, 153341, 153328, 153676, 153548, 153463, 154008, 153336, 154158, 154206, 153882, 153410, 154421]}, "name": "E. Parade", "statement": "No Great Victory anniversary in Berland has ever passed without the war\r\nparade. This year is not an exception. That s why the preparations are\r\non in full strength. Tanks are building a line, artillery mounts are\r\nready to fire, soldiers are marching on the main square... And the air\r\nforces general Mr. Generalov is in trouble again. This year a lot of\r\nsky-scrapers have been built which makes it difficult for the airplanes\r\nto fly above the city. It was decided that the planes should fly\r\nstrictly from south to north. Moreover, there must be no sky scraper on\r\na plane s route, otherwise the anniversary will become a tragedy. The\r\nMinistry of Building gave the data on sky scrapers (the rest of the\r\nbuildings are rather small and will not be a problem to the planes).\r\nWhen looking at the city from south to north as a geometrical plane, the\r\n-th building is a rectangle of height . Its westernmost point has the\r\nx-coordinate of and the easternmost of . The terrain of the area is\r\nplain so that all the buildings stand on one level. Your task as the\r\nMinistry of Defence s head programmer is to find an polyline using the\r\ndata on the sky-scrapers. The polyline s properties are as follows: If\r\nyou look at the city from south to north as a plane, then any part of\r\nany building will be inside or on the boarder of the area that the\r\npolyline encloses together with the land surface. The polyline starts\r\nand ends on the land level, i.e. at the height equal to 0. The segments\r\nof the polyline are parallel to the coordinate axes, i.e. they can only\r\nbe vertical or horizontal. The polyline s vertices should have integer\r\ncoordinates. If you look at the city from south to north the polyline\r\n(together with the land surface) must enclose the minimum possible area.\r\nThe polyline must have the smallest length among all the polylines,\r\nenclosing the minimum possible area with the land. The consecutive\r\nsegments of the polyline must be perpendicular. Picture to the second\r\nsample test (the enveloping polyline is marked on the right).\r\n", "solutions": ["#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\nstruct Skyscrapper{\n    int h, l, r;\n} A[100000];\nint n;\n\nvoid solve(int b, int e, vector<int> &ans) {\n    if (b == e){\n        ans.push_back(A[b].l);\n        ans.push_back(A[b].h);\n        ans.push_back(A[b].r);\n        ans.push_back(0);\n    }\n    else {\n        vector<int> v1, v2;\n        solve(b, (b+e)/2, v1);\n        solve((b+e)/2 + 1, e, v2);\n        int cur1, cur2, h1, h2, len1, len2,curh;\n        len1 = v1.size(); len2 = v2.size();\n        cur1=cur2=0;\n        h1=h2=0;\n        curh=0;\n        while (cur1 < len1 || cur2 < len2) {\n            if (cur2 >= len2 || cur1 < len1 && v1[cur1] <= v2[cur2]){\n                h1 = v1[cur1+1];\n                if (cur2 >= len2 || cur1 < len1 && v1[cur1] != v2[cur2]){\n                    if (max(h1, h2) != curh) {\n                        ans.push_back(v1[cur1]);\n                        curh = max(h1, h2);\n                        ans.push_back(curh);\n                    }\n                }\n                cur1 += 2;\n            }\n            else{\n                h2 = v2[cur2+1];\n                if (cur1 >= len1 || cur2 < len2 && v1[cur1] != v2[cur2]){\n                    if (max(h1, h2) != curh) {\n                        ans.push_back(v2[cur2]);\n                        curh = max(h1, h2);\n                        ans.push_back(curh);\n                    }\n                }\n                cur2 += 2;\n            }\n        }\n    }\n}\n\nint main () {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++){\n        scanf(\"%d%d%d\", &A[i].h,\n                        &A[i].l,\n                        &A[i].r);\n    }\n    vector<int> poly;\n    solve(0, n-1, poly);\n    printf(\"%d\\n\", (int)poly.size());\n\n    int curh=0;\n    for(int i=0; i<poly.size(); i+=2) {\n        printf(\"%d %d\\n\", poly[i], curh);\n        printf(\"%d %d\\n\", poly[i], poly[i+1]);\n        curh = poly[i+1];\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "sortings"], "dificulty": "2100", "interactive": false}