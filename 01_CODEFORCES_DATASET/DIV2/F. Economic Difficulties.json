{"link": "https://codeforces.com//contest/1263/problem/F", "problemId": "483582", "problem_idx": "F", "shortId": "1263F", "contest_number": "1263", "problem_submissions": {"F": [65982966, 65978661, 65982743, 66004105, 65981403, 65982906, 65984527, 65967209, 65985700, 65987420, 65990597, 65985690, 65988080, 66082681, 66082661, 65991200, 65988308, 65990381, 65990481, 66004842, 66004759, 66004719, 66004190, 65989038, 65986432, 65987559], "A": [65969521, 65961098, 65960714, 65962476, 65960820, 65960894, 65980138, 65961073, 65960873, 65961438, 65963263, 65960772, 65978824, 65961157, 65962102, 65960839, 65961853, 65961109, 65961702], "E": [65968592, 65970858, 65970511, 66002882, 65966227, 65975131, 65974148, 65975198, 65975184, 65976510, 65977397, 65977245, 65977807, 65973180, 65969025, 65981150, 65979864, 65980298, 65982044, 65990889, 65982753], "D": [65964312, 65966149, 65963758, 65968928, 65967814, 65969772, 65976755, 65969893, 65967529, 65964864, 65971947, 65966055, 65962087, 65967297, 65966037, 65973690, 65970452, 65967218, 65972623], "C": [65962585, 65964625, 65962104, 65977080, 65966153, 65965608, 65964949, 65977661, 65966317, 65964823, 65965028, 65969369, 65963751, 65963273, 65964947, 65961279, 65968926, 65968185, 65964802, 65969882], "B": [65961580, 65962530, 65961425, 65964286, 65964464, 65963229, 65979595, 65963832, 65962737, 65962077, 65967269, 65974357, 65980348, 65962893, 65969125, 65965548, 65964171, 65963429, 65966476]}, "name": "F. Economic Difficulties", "statement": "An electrical grid in Berland palaces consists of 2 grids: main and\r\nreserve. Wires in palaces are made of expensive material, so selling\r\nsome of them would be a good idea!Each grid (main and reserve) has a\r\nhead node (its number is 1). Every other node gets electricity from the\r\nhead node. Each node can be reached from the head node by a unique path.\r\nAlso, both grids have exactly n nodes, which do not spread electricity\r\nfurther.In other words, every grid is a rooted directed tree on n leaves\r\nwith a root in the node, which number is 1. Each tree has independent\r\nenumeration and nodes from one grid are not connected with nodes of\r\nanother grid.Also, the palace has n electrical devices. Each device is\r\nconnected with one node of the main grid and with one node of the\r\nreserve grid. Devices connect only with nodes, from which electricity is\r\nnot spread further (these nodes are the tree\u2019s leaves). Each grid\u2019s leaf\r\nis connected with exactly one device. It is guaranteed that the whole\r\ngrid (two grids and n devices) can be shown in this way (like in the\r\npicture above): main grid is a top tree, whose wires are directed \u2019from\r\nthe top to the down\u2019, reserve grid is a lower tree, whose wires are\r\ndirected \u2019from the down to the top\u2019, devices horizontal row between two\r\ngrids, which are numbered from 1 to n from the left to the right, wires\r\nbetween nodes do not intersect. Formally, for each tree exists a\r\ndepth-first search from the node with number 1, that visits leaves in\r\norder of connection to devices 1, 2,\r\ndots, n (firstly, the node, that is connected to the device 1, then the\r\nnode, that is connected to the device 2, etc.).Businessman wants to sell\r\n(remove) amount of wires so that each device will be powered from at\r\nleast one grid (main or reserve). In other words, for each device should\r\nexist at least one path to the head node (in the main grid or the\r\nreserve grid), which contains only nodes from one grid.\r\n", "solutions": ["#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nint dp[2][1002]; // last used left(0), right(1). other side was used by (j-1)\nint ndp[2][1002];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int A, B;\n  scanf(\"%d\", &A);\n  vector<int> pA(A, -1), dA(n);\n  for (int i = 1; i < A; i++) { scanf(\"%d\", &pA[i]); pA[i]--; }\n  for (int i = 0; i < n; i++) { scanf(\"%d\", &dA[i]); dA[i]--; }\n  scanf(\"%d\", &B);\n  vector<int> pB(B, -1), dB(n);\n  for (int i = 1; i < B; i++) { scanf(\"%d\", &pB[i]); pB[i]--; }\n  for (int i = 0; i < n; i++) { scanf(\"%d\", &dB[i]); dB[i]--; }\n  vector<vector<int>> aPath;\n  for (int i = 0; i < A; i++) {\n    vector<int> cur;\n    int p = i;\n    while (p != 0) {\n      cur.push_back(p);\n      p = pA[p];\n    }\n    aPath.emplace_back(cur);\n  }\n  vector<vector<int>> bPath;\n  for (int i = 0; i < B; i++) {\n    vector<int> cur;\n    int p = i;\n    while (p != 0) {\n      cur.push_back(p);\n      p = pB[p];\n    }\n    bPath.emplace_back(cur);\n  }\n\n  for (int i = 0; i < n; i++) {\n    set<int> sideAcache, sideBcache;\n    sideAcache.insert(aPath[dA[i]].begin(), aPath[dA[i]].end());\n    sideBcache.insert(bPath[dB[i]].begin(), bPath[dB[i]].end());\n\n    for (int side = 0; side < 2; side++) fill(ndp[side], ndp[side] + 1002, INT_MAX/2);\n    for (int side = 0; side < 2; side++) {\n      int same_cost = 0;\n      if (side == 0) {\n        same_cost = sideAcache.size();\n      } else {\n        same_cost = sideBcache.size();\n      }\n      if (i > 0) {\n        if (side == 0) {\n          for (auto p : aPath[dA[i - 1]]) if (sideAcache.count(p)) same_cost--;\n        } else {\n          for (auto p : bPath[dB[i - 1]]) if (sideBcache.count(p)) same_cost--;\n        }\n      }\n\n      for (int j = 0; j <= i; j++) {\n        int last_other = j - 1;\n        int base = dp[side][j];\n        if (base >= INT_MAX / 2) continue;\n        // use same side\n        {\n          ndp[side][j] = min(ndp[side][j], base + same_cost);\n        }\n        // use different side\n        {\n          int diff_cost = (side == 0) ? sideBcache.size() : sideAcache.size();\n          if (last_other >= 0) {\n            if (side == 0) { // use B side\n              int bans = bPath[dB[last_other]].size();\n              int low = 0, high = bans - 1;\n              while (low <= high) {\n                int mid = (low + high) >> 1;\n                if (sideBcache.count(bPath[dB[last_other]][mid])) {\n                  bans = mid;\n                  high = mid - 1;\n                } else {\n                  low = mid + 1;\n                }\n              }\n              diff_cost -= (int)bPath[dB[last_other]].size() - bans;\n            } else { // use A side\n              int bans = aPath[dA[last_other]].size();\n              int low = 0, high = bans - 1;\n              while (low <= high) {\n                int mid = (low + high) >> 1;\n                if (sideAcache.count(aPath[dA[last_other]][mid])) {\n                  bans = mid;\n                  high = mid - 1;\n                } else {\n                  low = mid + 1;\n                }\n              }\n              diff_cost -= (int)aPath[dA[last_other]].size() - bans;\n            }\n          }\n          ndp[side ^ 1][i] = min(ndp[side ^ 1][i], base + diff_cost);\n        }\n      }\n    }\n    memcpy(dp, ndp, sizeof(dp));\n  }\n  int ans = min(*min_element(ndp[0], ndp[0] + 1002), *min_element(ndp[1], ndp[1] + 1002));\n  ans = A + B - ans - 2;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dp", "flows", "graphs", "trees"], "dificulty": "2400", "interactive": false}