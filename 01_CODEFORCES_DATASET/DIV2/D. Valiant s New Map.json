{
    "link": "https://codeforces.com//contest/1731/problem/D",
    "problemId": "1711454",
    "problem_idx": "D",
    "shortId": "1731D",
    "contest_number": "1731",
    "problem_submissions": {
        "F": [
            186914595,
            186916746,
            188609637,
            186918241,
            186915978,
            186924114,
            186923167,
            186928435,
            186940850,
            186934089,
            186928158,
            186942000,
            186931590,
            186939314,
            186931829,
            186925046,
            187042657,
            186976314,
            186961335,
            186947151,
            186935943,
            186943841,
            186947800,
            187100429,
            186936912
        ],
        "E": [
            186902388,
            186907542,
            188609583,
            186907228,
            186922877,
            186908811,
            186913909,
            186909533,
            186905298,
            186914796,
            186914318,
            186909008,
            186915275,
            186912330,
            186916821,
            186935842,
            186913227,
            186922201,
            186915075,
            186915635,
            186916449
        ],
        "D": [
            186894672,
            186898337,
            188609534,
            186899725,
            186899215,
            186903320,
            186903576,
            186904113,
            186896689,
            186902110,
            186905198,
            186902394,
            186905223,
            186904629,
            186906063,
            186899445,
            186905463,
            186908692,
            186911370,
            186906776,
            186904962
        ],
        "C": [
            186891713,
            186894904,
            188609500,
            186897483,
            186895982,
            186900151,
            186899934,
            186901212,
            186894367,
            186897519,
            186898993,
            186897615,
            186900357,
            186899391,
            186902000,
            186905696,
            186894285,
            186902878,
            186897844,
            186898614,
            186901628
        ],
        "B": [
            186886340,
            186890465,
            188609426,
            186888165,
            186892347,
            186894409,
            186892290,
            186893227,
            186887848,
            186893176,
            186892310,
            186890495,
            186892951,
            186895205,
            186908452,
            186891159,
            186900599,
            186895520,
            186894487,
            186892361,
            186896199
        ],
        "A": [
            186884556,
            186884624,
            188609361,
            186884628,
            186886996,
            186885867,
            186884614,
            186885171,
            186884576,
            186884932,
            186885049,
            186884957,
            186885253,
            186885130,
            186885370,
            186887288,
            186885246,
            186886527,
            186884899,
            186885189,
            186885071
        ]
    },
    "name": "D. Valiant s New Map",
    "statement": "Game studio \"DbZ Games\" wants to introduce another map in their popular\r\ngame \"Valiant\". This time, the map named \"Panvel\" will be based on the\r\ncity of Mumbai.Mumbai can be represented as n\r\ntimes m cellular grid. Each cell (i, j) (1\r\nle i\r\nle n; 1\r\nle j\r\nle m) of the grid is occupied by a cuboid building of height\r\na_{i,j}.This time, DbZ Games want to make a map that has perfect\r\nvertical gameplay. That\u2019s why they want to choose an l\r\ntimes l square inside Mumbai, such that each building inside the square\r\nhas a height of at least l.Can you help DbZ Games find such a square of\r\nthe maximum possible size l?\r\n",
    "solutions": [
        "//\u8fd9\u56de\u53ea\u82b1\u4e86114514min\u5c31\u6253\u5b8c\u4e86\u3002\n//\u771f\u597d\u3002\u8bb0\u5f97\u591a\u624b\u9020\u51e0\u7ec4\u3002ACM\u62cd\u4ec0\u4e48\u62cd\u3002 \n#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include \"my_header\\debug.h\"\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n>>m;\n\t\tvector a(n,vector(m,0));\n\t\tcin>>a;\n\t\tint l=0,r=n;\n\t\twhile (l<r)\n\t\t{\n\t\t\tint mid=l+r+1>>1;\n\t\t\tauto ck=[&](int mid)\n\t\t\t{\n\t\t\t\tint i,j;\n\t\t\t\tvector s(n+1,vector(m+1,0));\n\t\t\t\tfor (i=0; i<n; i++) for (j=0; j<m; j++) s[i+1][j+1]=s[i][j+1]+s[i+1][j]-s[i][j]+(a[i][j]>=mid);\n\t\t\t\tfor (i=mid; i<=n; i++) for (j=mid; j<=m; j++) if (s[i][j]+s[i-mid][j-mid]-s[i][j-mid]-s[i-mid][j]==mid*mid) return 1;\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t\tif (ck(mid)) l=mid; else r=mid-1;\n\t\t}\n\t\tcout<<l<<'\\n';\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Valiant s New Map.json",
    "editorial_link": "https://codeforces.com//blog/entry/110630",
    "editorial": "The basic brute force solution for this problem was to just iterate\r\nthrough all the values of sides possible. Note that the value of sides\r\ncan range only from to as product of can\u00e2\u0080\u0099t exceed , so there can\u00e2\u0080\u0099t be a\r\ncube having all sides greater than . After setting side length (let\u00e2\u0080\u0099s\r\nsay ) we look into all possible submatrices of dimensions and see if we\r\ncan form a cube from any one of those. This could only be possible if\r\nthere exists a submatrix with its minimum . Now, we need to do all these\r\noperations efficiently, looking at the constraints. The main thing that\r\nwe need to do is Binary search on the answer. As obviously, it is\r\npossible to make a cube with a smaller side if it is possible to make\r\nthe one with the current side length. For a particular side , check for\r\nall submatrices of size , if their minimum is greater than equal to . If\r\nyou find any such submatrix, then this value of side is possible. A\r\nminimum can be calculated in using sparse tree. You might have tried\r\nusing segment tree, which takes time per query. But it may not to pass\r\nwith these constraints.So, the time complexity to solve this problem is\r\n). It would pass these constraints. Another ) solution where you don\u00e2\u0080\u0099t\r\nuse binary search is also there but would fail with these constraints.\r\nThe segment tree solution takes ) . So, only sparse tree can be\r\nused.This is a much simpler solution. First, we create another matrix,\r\nlet\u00e2\u0080\u0099s say . Now, for a particular side length , we take all the indices\r\nwhere the building heights are greater than equal to and set the\r\nelements of at those indices to . Other elements are set to . Now we\r\nprecalculate the prefix sum for this matrix. Then for each index of the\r\nmatrix , we check if the square starting from that index has a prefix\r\nsum equal to . If anyone of it does, then this side length for the cube\r\nis possible.Time Complexity is again .\r\n"
}