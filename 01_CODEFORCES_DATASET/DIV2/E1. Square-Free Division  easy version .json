{"link": "https://codeforces.com//contest/1497/problem/E1", "problemId": "925009", "problem_idx": "E1", "shortId": "1497E1", "contest_number": "1497", "problem_submissions": {"E1": [110218942, 110204547, 110209862, 110204250, 110204165, 110231486, 110202339, 110191058, 110208748, 110226922, 110214718, 110213615, 110206316, 110227739, 110214379, 110211872, 110213209, 110211236, 110214947, 110214631], "E2": [110218489, 110228575, 214425397, 110217629, 110222364, 110204786, 110244884, 110204758, 110216448, 128480996, 110231341, 110288360, 110287974, 110284396, 110226837, 110233982, 110227741], "D": [110209131, 110229942, 110235570, 110232860, 110227785, 110226987, 110217671, 110285138, 110213904, 110231090, 110226178, 110248432, 110223649, 110238019, 110211006, 110234017], "B": [110201204, 110197893, 110193488, 110190033, 110218332, 110197422, 110188452, 110197952, 110193152, 110191609, 110193962, 110209906, 110189973, 110196774, 110193252, 110192209, 110193977, 110191962, 110193050, 110190991], "A": [110197966, 110183441, 110185344, 110183392, 110207927, 110188054, 110182581, 110186628, 110190659, 110182727, 110186155, 110183196, 110185241, 110185407, 110184362, 110184636, 110184528, 110183883, 110183214, 110182538], "C1": [110193783, 110197460, 110198652, 110201523, 110223073, 110204540, 110193389, 110211919, 110203639, 110203131, 110197927, 110199227, 110194627, 110203913, 110203003, 110207436, 110203526, 110203044, 110197492, 110205586], "C2": [110193437, 110198415, 110198429, 110211803, 110223191, 110204421, 110194238, 110212138, 110204892, 110207285, 110199495, 110215157, 110198718, 110207240, 110202742, 110207482, 110291141, 110202605, 110201810, 110207375]}, "name": "E1. Square-Free Division  easy version ", "statement": "There is an array a_1, a_2,\r\nldots, a_n of n positive integers. You should divide it into a minimal\r\nnumber of continuous segments, such that in each segment there are no\r\ntwo numbers (on different positions), whose product is a perfect\r\nsquare.Moreover, it is allowed to do at most k such operations before\r\nthe division: choose a number in the array and change its value to any\r\npositive integer. But in this version k = 0, so it is not important.What\r\nis the minimum number of continuous segments you should use if you will\r\nmake changes optimally?\r\n", "solutions": ["#pragma GCC optimize(\"Ofast\")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    vector<int> h(1e7 + 5);\n    vector<int> e(1e7 + 5, 1);\n    vector<int> minD(1e7 + 5, -1);\n    minD[1] = 1;\n    for (ll i = 2; i < 1e7 + 5; ++i) {\n        if (e[i]) {\n            minD[i] = i;\n            for (ll j = i; j * i < 1e7 + 5; ++j) {\n                e[i * j] = 0;\n                if (minD[i * j] == -1) {\n                    minD[i * j] = i;\n                } else {\n                    minD[i * j] = min(minD[i * j], (int)i);\n                }\n\n            }\n        }\n    }\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            int ans = 1;\n            map<int, int> cnt;\n            while (minD[a[i]] != 1) {\n                ++cnt[minD[a[i]]];\n                a[i] /= minD[a[i]];\n            }\n            for (auto &elem : cnt) {\n                if (elem.se % 2) {\n                    ans *= elem.fi;\n                }\n            }\n            a[i] = ans;\n        }\n        vector<vector<int>> sameSegment(k + 1, vector<int>(n));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) h[a[j]] = 0;\n            int l = 0, cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                ++h[a[j]];\n                if (h[a[j]] > 1) {\n                    ++cnt;\n                }\n                while (cnt > i) {\n                    if (h[a[l]] > 1) {\n                        --cnt;\n                    }\n                    --h[a[l]];\n                    ++l;\n                }\n                sameSegment[i][j] = l;\n            }\n        }\n        vector<vector<int>> dp(k + 1, vector<int>(n, 1e9));\n        for (int i = 0; i <= k; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int z = 0; z <= i; ++z) {\n                    int ans = 1;\n                    if (sameSegment[i - z][j] - 1 != -1) {\n                        ans += dp[z][sameSegment[i - z][j] - 1];\n                    }\n                    dp[i][j] = min(dp[i][j], ans);\n                }\n            }\n        }\n        int res = 1e9;\n        for (int j = 0; j <= k; ++j) {\n            res = min(res, dp[j][n - 1]);\n        }\n        cout << res << '\\n';\n    }\n}\n/*\n*/\n"], "input": "", "output": "", "tags": ["data structures", "dp", "greedy", "math", "number theory", "two pointers"], "dificulty": "1700", "interactive": false}