{
    "link": "https://codeforces.com//contest/1659/problem/F",
    "problemId": "1371416",
    "problem_idx": "F",
    "shortId": "1659F",
    "contest_number": "1659",
    "problem_submissions": {
        "E": [
            153913573,
            153929614,
            153928927,
            153922832,
            153919141,
            153972138,
            153926923,
            153927092,
            153929319,
            153932903,
            153930192,
            153930364,
            153930632,
            153931626,
            153929090,
            153932497,
            153927674,
            153932539,
            153931108,
            153930225
        ],
        "D": [
            153912412,
            153905719,
            153910339,
            153913081,
            153925687,
            153914747,
            153914843,
            153917030,
            153914214,
            153914225,
            153916202,
            153914923,
            153911260,
            153911942,
            153919382,
            153913809,
            153916530,
            153910597,
            153914778,
            153923066
        ],
        "B": [
            153899189,
            153895163,
            153894044,
            153901045,
            153896660,
            153905534,
            153895509,
            153894100,
            153894393,
            153894053,
            153896780,
            153900091,
            153895296,
            153893292,
            153896323,
            153897272,
            153895755,
            153896012,
            153922971,
            153892638
        ],
        "C": [
            153893804,
            153899081,
            153898923,
            153904670,
            153899860,
            153895491,
            153906966,
            153902317,
            153904388,
            153898598,
            153905688,
            153905657,
            153901854,
            153898683,
            153904460,
            153903103,
            153900333,
            153901824,
            153895900,
            153899518
        ],
        "A": [
            153892134,
            153890875,
            153890881,
            153898852,
            153891639,
            153899777,
            153891702,
            153891302,
            153890852,
            153890890,
            153891590,
            153893681,
            153891282,
            153890712,
            153890944,
            153892901,
            153890725,
            153890838,
            153891604,
            153890839
        ],
        "F": [
            153937865
        ]
    },
    "name": "F. Tree and Permutation Game",
    "statement": "There is a tree of n vertices and a permutation p of size n. A token is\r\npresent on vertex x of the tree.Alice and Bob are playing a game. Alice\r\nis in control of the permutation p, and Bob is in control of the token\r\non the tree. In Alice’s turn, she pick two u and v ( positions; u\r\nneq v), such that the token is neither at vertex u nor vertex v on the\r\ntree, and swap their positions in the permutation p. In Bob’s turn, he\r\nmove the token to an adjacent vertex from the one it is currently\r\non.Alice wants to sort the permutation in increasing order. Bob wants to\r\nprevent that. Alice wins if the permutation is sorted in increasing\r\norder at the beginning or end of her turn. Bob wins if he can make the\r\ngame go on for an infinite number of moves (which means that Alice is\r\nnever able to get a sorted permutation). Both players play optimally.\r\nAlice makes the first move.Given the tree, the permutation p, and the\r\nvertex x on which the token initially is, find the winner of the game.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\n#define X first\n#define Y second\n#define MP make_pair\n#define PB push_back\n#define ll long long\n\nusing namespace std;\n\nll t,n,k;\nll prov;\nll koji;\nll niz[200005];\nll di;\nll a,b;\nll nes;\nll gdje[200005];\nll br;\n\nint main () {\n\t\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>k;\n\t\tkoji=-1;\n\t\tprov=0;\n\t\tdi=0;\n\t\tbr=0;\n\t\t//memset(niz,0,sizeof(niz));\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tcin>>a>>b;\n\t\t\tniz[a]++;\n\t\t\tniz[b]++;\n\t\t}\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(niz[i]==n-1){\n\t\t\t\tkoji=i;\n\t\t\t}\n\t\t}\n\t\tif(koji==-1 && prov==0){\n\t\t\tcout<<\"Alice\\n\";\n\t\t\tprov=1;\n\t\t}\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tcin>>niz[i];\n\t\t\tgdje[niz[i]]=i;\n\t\t\tif(niz[i]==koji){\n\t\t\t\tdi=i;\n\t\t\t}\n\t\t}\n\t\t//cout<<koji<<\" \"<<t<<\"\\n\";\n\t\tif(di!=koji && (k==koji || k==niz[koji]) && prov==0){\n\t\t\tcout<<\"Bob\\n\";\n\t\t\tprov=1;\n\t\t}\n\t\tnes=0;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(niz[i]==i){\n\t\t\t\tnes++;\n\t\t\t}\n\t\t}\n\t\tif(nes==n && prov==0){\n\t\t\tcout<<\"Alice\\n\";\n\t\t\tprov=1;\n\t\t}\n\t\tif(di!=koji){\n\t\t\tgdje[niz[koji]]=di;\n\t\t\tgdje[niz[di]]=koji;\n\t\t\tswap(niz[koji],niz[di]);\n\t\t\tk=koji;\n\t\t}\n\t\tbr=0;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(niz[i]!=i){\n\t\t\t\tbr++;\n\t\t\t\ta=i;\n\t\t\t\tb=niz[i];\n\t\t\t\tgdje[niz[i]]=gdje[i];\n\t\t\t\tswap(niz[i],niz[gdje[i]]);\n\t\t\t\tgdje[i]=i;\n\t\t\t}\n\t\t}\n\t\tif(prov==0){\n\t\t\tif(br==0){\n\t\t\t\tcout<<\"Alice\\n\";\n\t\t\t}\n\t\t\telse if(k==koji){\n\t\t\t\tif(br%2==1){\n\t\t\t\t\tcout<<\"Alice\\n\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout<<\"Bob\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(br==1 && k!=a && k!=b){\n\t\t\t\t\tcout<<\"Alice\\n\";\n\t\t\t\t}\n\t\t\t\telse if(br%2==1){\n\t\t\t\t\tcout<<\"Bob\\n\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout<<\"Alice\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tprov=1;\n\t\t}\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tniz[i]=0;\n\t\t}\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tgdje[i]=0;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "games",
        "graphs",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Tree and Permutation Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/100938",
    "editorial": "Let us call all such that satisfy as . If , it is called . Also, a\r\nnotation like means \"swap and in the permutation\".We are going to show\r\nthat it is always possible for Alice to win if the diameter of the tree\r\nis .First of all, it should be obvious that no matter what moves are\r\nmade, we will eventually end up at a state where we have just marked\r\nvertices and the token is either on one of them or neither of them (with\r\nAlice having to move). In the latter case we have a trivial win.As long\r\nas there are marked numbers, you can always find a pair of numbers to\r\nswap that will unmark one of the numbers. One can imagine this in terms\r\nof the cycle decomposition of the permutation. Next, let us show that\r\nfrom the former state, we can also force a state where the two marked\r\nvertices are adjacent to each other (with Alice having to move).If the\r\ntwo marked vertices are already adjacent, we donât need to do anything.\r\nElse, letâs say we have and where is the vertex with the token on it.\r\nNow, consider two cases. If is at distance from , we can choose any\r\nadjacent vertex to . Let it be . Swap and . Now Bob has the option of\r\nmoving the token onto or not. It wouldnât be optimal to move it away\r\nfrom , because then we can force the sequence and Bob wonât be able to\r\ncover any vertex with his token. So Bob must move his token onto . Swap\r\nand , which puts in its right place. Now Bob must move this token onto ,\r\nso we did it. If is instead at distance from , pick the vertex between\r\nand as , and we can repeat the same analysis as above. Now, letâs say we\r\nhave and with being the vertex with the token on it. Let us show that,\r\nif possible, we can always move over and over (effectively \"jumping\"\r\nover the opposite vertex).For the first one, pick some vertex adjacent\r\nto (not ). Let it be . Swap and . Now Bob has the option of moving to\r\neither or . If he moves to , we can force and win. If he moves to , we\r\nswap (putting in the right place) and Bob has to move his token to . Now\r\nwe can see that the marked vertex which was , \"jumped\" over to reach\r\n.For the second one, pick some vertex adjacent to (not ). Let it be .\r\nBob must move his token to . Swap and (putting in the right place). Bob\r\nmust move his token to . Now we can see that the marked vertex with a\r\ntoken which was , \"jumped\" over to reach . Like this, we can move all\r\nover the tree. Now letâs move such that both of the marked vertices lie\r\non a diameter of the tree and one of them is at one end of it.Consider a\r\ntree with diameter . That means we have a line of at least vertices\r\ntaking the two marked vertices at one end. Letâs consider just the first\r\nvertices, and show that we can always win here.Say we have a\r\nconfiguration like â where and are marked and has the token on it. If\r\nhas the token on it instead, we can use the moving strategy explained\r\nbefore to first move to and then to and then it is equivalent to the\r\nfirst configuration. Swap and . Now Bob must move his token to . Swap\r\nand (putting in its right place). Now no matter where Bob moves, after\r\nhis turn no vertex will be covered and we can force and win. Therefore,\r\nif the diameter of the tree is , we always win.If the diameter of the\r\ntree is , it is a star graph, and this is a more problematic case.First\r\nof all, we must check if the permutation is already sorted, or we can\r\nwin in the first move. We can only win in the first move if only swap is\r\nrequired to sort the permutation, and the token is on neither of the\r\nnumbers we need to swap.If the above is not possible, several cases\r\nfollow.Let us make the following observation first. If Bob is at the\r\ncenter of the star and the center is a marked vertex, Bob can infinitely\r\nstall Alice.Letâs call the center , and suppose we need to swap the\r\nnumber with it to put it in its right place. is definitely at a leaf and\r\nvertex away because of the structure of the star graph. So when Bobâs\r\nturn comes he can simply move the token to where is and alternate this\r\nway between and , infinitely stalling Alice. Obviously, even if we try\r\nswapping with a different number , we can just move to where is next\r\nuntil there are just two vertices left, the center and a leaf. So Bob\r\nwins. In light of this, it never makes sense to mark the center in our\r\nturn if it is unmarked and not covered by the token.So we have cases to\r\nthink of now:- Token on center and center is marked vertex: As explained\r\nbefore, Alice loses here.Before discussing the rest of the cases, let us\r\ndefine as the minimum number of swaps required to sort the permutation\r\nand is if the token is on the center and if it is on a leaf.Now I claim\r\nthat the parity of is invariant. The magnitude of changes by exactly\r\nevery turn and we can say the same about . So considering all possible\r\nchanges (,) (,) (,) (,) we can see the sum of the changes is always .\r\nHence proved.Consider the possible end states for the game: (all with\r\nmarked vertices and with Alice having to move) Token at center, center\r\nmarked Token at unmarked leaf, center marked Token at marked leaf,\r\ncenter marked Token at center, center unmarked Token at unmarked leaf,\r\ncenter unmarked Token at marked leaf, center unmarked Observe that end\r\nstates and will never occur if the game lasts longer than turn because\r\nif you go back by turn, Bob would have a more optimal move. Therefore,\r\nin states and we can win in the very first move. Further observe that\r\nstates and will never occur if the center was initially unmarked or we\r\ncould unmark it in the first move. The only other possibility would be\r\nus being unable to unmark the center in the first move, which is a\r\nlosing state. So we only care about states and now.Observe that state is\r\na winning position while state is a losing position. Also observe that\r\nstate has odd but state has even. Now let us continue with the cases and\r\nuse these facts.- Token at center and center is unmarked vertex: Check\r\nthe parity of here. If it is odd, we win, otherwise we lose (follows\r\nfrom the invariance of ).- Token at leaf and center is marked vertex: If\r\nwe cannot unmark the center vertex in our very first move, weâll reach a\r\nlosing position. If we can, check parity of . Odd is win, even is lose.\r\nWhen can we not unmark the center vertex? Only if the token is on .\r\nOtherwise it is always possible.- Token at leaf and center is unmarked\r\nvertex: Check parity of . Odd is win, even is lose.This completes the\r\nsolution.Time complexity: or (depending on whether you use cycles or\r\ninversions to find the parity of )\r\n",
    "hint": [
        "Hint 1 Notice that as long as there are elements not in their correct place, Alice can always put at least element into the correct place.",
        "Hint 2 Intuitively, Alice should win if the tree is \"big enough\", because Bob won't be able to reach some places quickly enough. How to define this sense of \"big enough\"?",
        "Hint 3 Try to solve this problem on a line graph.",
        "Hint 4 It is actually possible to force a sequence of moves to get the remaining elements onto the diameter of the tree. Given this, use the answer to Hint 3.",
        "Hint 5 Prove that Alice always wins on trees with diameter .",
        "Hint 6 A tree of diameter is a star graph. This case has a number of edge cases. This time, try to look at permutation cycles. Can you define some kind of invariant?"
    ]
}