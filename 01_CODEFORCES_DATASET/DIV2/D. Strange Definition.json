{
    "link": "https://codeforces.com//contest/1471/problem/D",
    "problemId": "855311",
    "problem_idx": "D",
    "shortId": "1471D",
    "contest_number": "1471",
    "problem_submissions": {
        "E": [
            103450052,
            103527230,
            103525401,
            103598525
        ],
        "F": [
            103434846,
            103427866,
            103439415,
            103444744,
            103449013,
            103443306,
            103451232,
            103449545,
            103450844,
            103457122,
            103444374,
            103429431,
            103453099,
            103450549,
            103452495,
            103451463,
            103455883,
            103458926,
            103459110,
            103458706
        ],
        "D": [
            103430457,
            103433587,
            103415562,
            103429984,
            103422346,
            103434860,
            103464447,
            103432755,
            103438270,
            103433203,
            103429688,
            103431896,
            103454609,
            103429555,
            103432993,
            103431363,
            103439051,
            103433971,
            103434798,
            103443976,
            103435625
        ],
        "C": [
            103407997,
            103401931,
            103402977,
            103409572,
            103406225,
            103408555,
            103406435,
            103414503,
            103418347,
            103405513,
            103405296,
            103416304,
            103408620,
            103413240,
            103409443,
            103419306,
            103414842,
            103414451,
            103407384,
            103412728
        ],
        "B": [
            103396816,
            103402555,
            103399513,
            103402026,
            103401651,
            103404250,
            103396796,
            103402859,
            103407240,
            103400401,
            103398000,
            103404884,
            103399937,
            103406757,
            103403051,
            103411496,
            103400880,
            103401862,
            103399435,
            103395040
        ],
        "A": [
            103391504,
            103392070,
            103391475,
            103392431,
            103397645,
            103392332,
            103392672,
            103392165,
            103392211,
            103391494,
            103393909,
            103392635,
            103393542,
            103391831,
            103396953,
            103391758,
            103391661,
            103393211,
            103391536
        ]
    },
    "name": "D. Strange Definition",
    "statement": "Let us call two integers x and y if\r\nfrac{lcm(x, y)}{gcd(x, y)} is a perfect square. For example, 3 and 12\r\nare adjacent, but 6 and 9 are not.Here gcd(x, y) denotes the greatest\r\ncommon divisor (GCD) of integers x and y, and lcm(x, y) denotes the\r\nleast common multiple (LCM) of integers x and y.You are given an array a\r\nof length n. Each second the following happens: each element a_i of the\r\narray is by the product of all elements of the array (including itself),\r\nthat are adjacent to the current value. Let d_i be the number of\r\nadjacent elements to a_i (including a_i itself). The of the array is\r\ndefined as\r\nmax_{1\r\nle i\r\nle n} d_i. You are given q queries: each query is described by an\r\ninteger w, and you have to output the beauty of the array after w\r\nseconds.\r\n",
    "solutions": [
        "// Author: wlzhouzhuan\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\n\nconst int N = 1000005;\nint a[N], p[N], d[N], n;\nint pr[N], vis[N], len;\nvoid sieve(int n) {\n  vis[0] = vis[1] = 1, d[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (!vis[i]) pr[++len] = i, d[i] = i;\n    for (int j = 1; j <= len && pr[j] * i <= n; j++) {\n      vis[pr[j] * i] = 1;\n      d[pr[j] * i] = d[i] % pr[j] == 0 ? d[i] / pr[j] : d[i] * pr[j]; \n      if (i % pr[j] == 0) {\n        break;\n      }\n    }\n  }\n}\nsigned main() {\n  sieve(N - 5);\n  int T = read();\n  while (T--) {\n    n = read();\n    rep(i, 1, n) a[i] = read(), a[i] = d[a[i]];\n    sort(a + 1, a + n + 1);\n    int res0 = 0;\n    for (int i = 1; i <= n; i++) {\n      int j = i;\n      while (j <= n && a[i] == a[j]) j++;\n      res0 = max(res0, j - i);\n      if ((j - i) % 2 == 0) {\n        for (int k = i; k < j; k++) a[k] = 1;\n      }\n      i = j - 1;\n    }\n    sort(a + 1, a + n + 1);\n    int res1 = 0;\n    for (int i = 1; i <= n; i++) {\n      int j = i;\n      while (j <= n && a[i] == a[j]) j++;\n      res1 = max(res1, j - i);\n      i = j - 1;\n    }\n    int q = read();\n    while (q--) {\n      ll w = read();\n      if (w == 0) printf(\"%lld\\n\", res0);\n      else printf(\"%lld\\n\", res1);\n    }\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "graphs",
        "hashing",
        "math",
        "number theory"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Strange Definition.json",
    "editorial_link": "https://codeforces.com//blog/entry/86464",
    "editorial": "It is well known that lcm(x,y)=x?ygcd(x,y)\n, and it immediately follows that lcm(x,y)gcd(x,y)\n =\n x?ygcd(x,y)2\n, which means that numbers x\n and y\n are adjacent if and only if x?y\n is a perfect square.\n\nLet alphax\n be the maximum possible integer such that palphax\n divides x\n, and alphay\n be the maximum possible integer such that palphay\n divides y\n. Then x?y\n is perfect square if and only if ?x+?y\n is even, which means ?x??y\n (mod 2\n).\n\nLet x=p?11?\u0085?p?kk\n. Let's replace it with p?1mod21?\u0085?p?kmod2k\n. After such a replacement two integers are adjacent if and only if they are equal.\n\nLet's replace each element of the array and split the numbers into classes of equal numbers. If the number of integers in a single class is even, after a single operation each element from this class will be transformed to 1\n, and if the number of integers is odd, the class of the element will remain unchanged. Since the class of integer 1 always remains unchanged, all integers will keep their classes starting from after the first operation.\n\nSince di\n denotes the size of the class, the beauty of the array is defined as the size of the maximal class. If a\n if the size of the maximal class at the beginning of the process, and b\n \u0097 the total number of elements with a class of even size or with the class equal to 1. Then for a query with w=0\n the answer is a\n, for a query with w>0\n the answer is max(a,b)\n.\n\nThis solution can easily be implemented with O(nlogA)\n complexity, where A\n denotes the maximum number in the array."
}