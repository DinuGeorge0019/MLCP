{
    "link": "https://codeforces.com//contest/1979/problem/D",
    "problemId": "2684282",
    "problem_idx": "D",
    "shortId": "1979D",
    "contest_number": "1979",
    "problem_submissions": {
        "F": [
            264479061,
            264488646,
            264505247,
            264595233,
            264619291
        ],
        "E": [
            264463709,
            264456182,
            264454663,
            264460110,
            264469235,
            264463422,
            264466790,
            264478578,
            264473477,
            264470909,
            264471670,
            264477459,
            264475074,
            264468357,
            264475963,
            264472031,
            264477800,
            264475608,
            264472217
        ],
        "D": [
            264443096,
            264466698,
            264438605,
            264433389,
            264436848,
            264441621,
            264445629,
            264439468,
            264443494,
            264448547,
            264437284,
            264438609,
            264445824,
            264448565,
            264448792,
            264448782,
            264436980,
            264445527,
            264444587
        ],
        "C": [
            264426913,
            264419354,
            264425968,
            264424857,
            264419880,
            264427385,
            264428474,
            264417768,
            264426268,
            264426216,
            264426191,
            264428203,
            264424558,
            264432779,
            264423537,
            264427769,
            264423741,
            264426473,
            264428054
        ],
        "B": [
            264418439,
            264411481,
            264417433,
            264418710,
            264412854,
            264416785,
            264417289,
            264409596,
            264415411,
            264416480,
            264411733,
            264416203,
            264418002,
            264418445,
            264413144,
            264415814,
            264415134,
            264412074,
            264419017
        ],
        "A": [
            264409604,
            264408727,
            264409156,
            264412898,
            264408950,
            264409241,
            264410321,
            264408352,
            264408494,
            264408922,
            264408390,
            264408516,
            264410187,
            264409625,
            264408487,
            264409057,
            264408498,
            264408238,
            264408615
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130213",
    "editorial": "SolutionLet\u00e2\u0080\u0099s consider the block of characters at the end. Notice that\r\ntheir quantity cannot decrease. Let be the number of identical\r\ncharacters at the end; there are three possible cases: it is enough to\r\nfind any block of length greater than and separate a block of length\r\nfrom it; obviously, there is no solution; find a block of length or and\r\nseparate a block of length from it. This solution works in , but it is\r\nnot the only correct one. Your solution may differ significantly from\r\nthe one proposed.\r\n",
    "name": "D. Fixing a Binary String",
    "statement": "You are given a binary string s of length n, consisting of zeros and\r\nones. You can perform the following operation : Choose an integer p (1\r\nle p\r\nle n). Reverse the substring s_1 s_2\r\nldots s_p. After this step, the string s_1 s_2\r\nldots s_n will become s_p s_{p-1}\r\nldots s_1 s_{p+1} s_{p+2}\r\nldots s_n. Then, perform a cyclic shift of the string s to the left p\r\ntimes. After this step, the initial string s_1s_2\r\nldots s_n will become s_{p+1}s_{p+2}\r\nldots s_n s_p s_{p-1}\r\nldots s_1. For example, if you apply the operation to the string with\r\np=3, after the second step, the string will become , and after the third\r\nstep, it will become .A string s is called if two conditions are met:\r\ns_1=s_2=\r\nldots=s_k; s_{i+k}\r\nneq s_i for any i (1\r\nle i\r\nle n - k). For example, with k=3, the strings , , and are k-proper,\r\nwhile the strings , , and are not.You are given an integer k, which of\r\nn. Find an integer p (1\r\nle p\r\nle n) such that after performing the operation, the string s becomes\r\nk-proper, or determine that it is impossible. Note that if the string is\r\ninitially k-proper, you still need to apply exactly one operation to it.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));const int MOD=1e9+7;const int P=rnd()%MOD;const int MAXN=2e5+5;ll pw[MAXN],hs[MAXN],rhs[MAXN];int n,k;char c[MAXN];ll get_hs(ll *h,int l,int r){return (h[r]-h[l-1]*pw[r-l+1]%MOD+MOD)%MOD;}void solve(){\tcin>>n>>k>>(c+1);\tfor(int i=1;i<=n;i++) hs[i]=(hs[i-1]*P+c[i]-'0')%MOD;\trhs[n+1]=hs[n+1]=0;\tfor(int i=1;i<=n;i++) rhs[i]=(rhs[i-1]*P+c[n+1-i]-'0')%MOD;\tll g1=0,g2=0;\tfor(int i=0;i<n;i++){\t\tg1=(g1*P+((i/k)%2))%MOD;\t\tg2=(g2*P+(1-(i/k)%2))%MOD;\t}\tfor(int p=1;p<=n;p++){\t\tll gh=get_hs(hs,p+1,n)*pw[p]+get_hs(rhs,n+1-p,n);\t\tgh%=MOD;\t\tif(gh==g1||gh==g2){\t\t\tcout<<p<<'\\n';\t\t\treturn;\t\t}\t}\tcout<<\"-1\\n\";}int main(){\tios::sync_with_stdio(false);\t// freopen(\"Otomachi_Una.in\",\"r\",stdin);\t// freopen(\"Otomachi_Una.out\",\"w\",stdout);\tpw[0]=1;\tfor(int i=1;i<MAXN;i++) pw[i]=pw[i-1]*P%MOD;\tint _;cin>>_;\twhile(_--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "dp",
        "greedy",
        "hashing",
        "strings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Fixing a Binary String.json"
}