{
    "link": "https://codeforces.com//contest/347/problem/E",
    "problemId": "3512",
    "problem_idx": "E",
    "shortId": "347E",
    "contest_number": "347",
    "problem_submissions": {
        "C": [
            4518768,
            4513742,
            4517653,
            4518839,
            4520636,
            4513589,
            4515480,
            4513320,
            4513590,
            4521190,
            4514183,
            4515546,
            4513940,
            4516018,
            4514431,
            4512340,
            4514717,
            4516799,
            4519674
        ],
        "D": [
            4515778,
            4520517,
            4519885,
            4520973,
            4523724,
            4519031,
            4523601
        ],
        "B": [
            4512188,
            4512255,
            4513932,
            4514468,
            4511829,
            4511441,
            4512094,
            4512109,
            4512127,
            4512494,
            4511760,
            4512987,
            4512079,
            4512011,
            4512852,
            4513990,
            4514484,
            4513535,
            4513631,
            4514973
        ],
        "A": [
            4510977,
            4511197,
            4511967,
            4512169,
            4511066,
            4511024,
            4511167,
            4511360,
            4511075,
            4511574,
            4515121,
            4511042,
            4511261,
            4512777,
            4514480,
            4513698,
            4511919,
            4511676,
            4512313
        ],
        "E": [
            4519822,
            4520189,
            4521340,
            4522190
        ]
    },
    "name": "E. Number Transformation II",
    "statement": "You are given a sequence of positive integers and two non-negative\r\nintegers and . Your task is to transform into . To do that, you can\r\nperform the following moves: subtract 1 from the current ; subtract mod\r\nfrom the current . Operation mod means taking the remainder after\r\ndivision of number by number .Now you want to know the minimum number of\r\nmoves needed to transform into .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<string>\n#include<cstring>\n#include<vector>\n\nusing namespace std;\n\nint a, b;\nint n;\nint v[1001001];\nint x[101000];\nbool y[101000];\n\nvoid set(int i){\n\tint z=i*(b/i);\n\tif(b != z)\n\t\tz+=i;\n\twhile(z<a){\n\t\tif(z + i-1 < a){\n\t\t\tif(z-b < v[z + i-1 - b])\n\t\t\t\tv[z + i-1 - b] = z-b;\n\t\t}\n\t\telse if(z-b < v[a - b])\n\t\t\tv[a - b] = z-b;\n\t\tz += i;\n\t}\n\treturn;\n}\n\nint main(){\n\tcin >> n;\n\tmemset(y, 0, sizeof(y));\n\tfor(int i=0; i<n; i++){\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tx[i]=t;\n\t\tif(t<100000)\n\t\t\ty[t] = true;\n\t}\n\tscanf(\"%d %d\", &a, &b);\n\tif(a == b){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=a-b; i++)\n\t\tv[i]=i-1;\n\tfor(int i=2; i<100000; i++)\n\t\tif(y[i])\n\t\t\tset(i);\n\tfor(int i=0; i<n; i++)\n\t\tif(x[i]>=100000)\n\t\t\tset(x[i]);\n\tint m = a-b;\n\tfor(int i=a-b; i>0; i--){\n\t\tif(v[i] < m)\n\t\t\tm = v[i];\n\t\telse\n\t\t\tv[i] = m;\n\t}\n\tint cont=0;\n\tfor(int i = a-b; i > 0; i = v[i])\n\t\tcont++;\n\tcout << cont << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Number Transformation II.json",
    "editorial_link": "https://codeforces.com//blog/entry/8903",
    "editorial": "Brief description:\nYou have a number b, and want to minus it to a, what you can do in each step is weather subtract 1 or b mod xi from b. And we ask what is the minimum number of steps you need.\n\nAnalysis:\nI bet there is a few people know the greedy method even if he/she have solved the early version before.\n\nCodeforces #153 Div 1. Problem C. Number Transformation\n\nLet dp[k] denotes the minimum number of steps to transform b+k to b. In each step, you could only choose i which makes b+k-(b+k) mod x[i] minimal to calc dp[k]. It works bacause dp[0..k-1] is a monotone increasing function. Proof: - Say dp[k]=dp[k-t]+1.If t==1, then dp[0..k] is monotone increasing obviously.Otherwise dp[k-1]<=dp[k-t]+1=dp[k] (there must exist a x[i] makes b+k-1 also transform to b+k-t,and it is not necessarily the optimal decision of dp[k-1]). So dp[k] is a monotone increasing function, we can greedily calc dp[a-b].\n\nIn the first glance, it looks like something which will run in square complexity. But actually is linear. That is because, we could cut exactly max{xi} in each 2 step. It can be proof by induction.\n\nSo the remians work is to delete those same xi, and watch out some situation could cause degeneration. Many of us failed in this last step and got TLE"
}