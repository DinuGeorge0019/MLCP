{
    "link": "https://codeforces.com//contest/1573/problem/C",
    "problemId": "1113071",
    "problem_idx": "C",
    "shortId": "1573C",
    "contest_number": "1573",
    "problem_submissions": {
        "D": [
            129211729,
            129206759,
            129197164,
            129194726,
            129186807,
            129296553,
            129201143,
            129198553,
            129200951,
            129204017,
            129203484,
            129203960,
            129200720,
            129203477,
            129203437,
            129205853
        ],
        "E": [
            129195381,
            129194363,
            129199429,
            129179637,
            129197397,
            129196652
        ],
        "C": [
            129184190,
            129188576,
            129188704,
            129201501,
            129185674,
            129198766,
            129196140,
            129200201,
            129228180,
            129201620,
            129186651,
            129189132,
            129188899,
            129187320,
            129192678,
            129192241,
            129184572,
            129199512,
            129191618,
            129190718
        ],
        "B": [
            129172862,
            129196906,
            129176190,
            129203844,
            129172298,
            129171523,
            129174991,
            129187627,
            129183320,
            129178269,
            129185994,
            129182784,
            129179822,
            129174918,
            129183834,
            129199069,
            129172947,
            129197456,
            129180823
        ],
        "A": [
            129167486,
            129167526,
            129168431,
            129168344,
            129167107,
            129167895,
            129167756,
            129167152,
            129174946,
            129168601,
            129168318,
            129169357,
            129170825,
            129173901,
            129168162,
            129170465,
            129167770,
            129167307,
            129177822,
            129167367
        ],
        "F": [
            132459885
        ]
    },
    "name": "C. Book",
    "statement": "You are given a book with n chapters.Each chapter has a specified list\r\nof other chapters that need to be understood in order to understand this\r\nchapter. To understand a chapter, you must read it after you understand\r\nevery chapter on its required list.Currently you don\u2019t understand any of\r\nthe chapters. You are going to read the book from the beginning till the\r\nend repeatedly until you understand the whole book. Note that if you\r\nread a chapter at a moment when you don\u2019t understand some of the\r\nrequired chapters, you don\u2019t understand this chapter.Determine how many\r\ntimes you will read the book to understand every chapter, or determine\r\nthat you will never understand every chapter no matter how many times\r\nyou read the book.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint i,j,k,n,m,t,it,son[200500],res,lst,x;\n\nvector<int> v[200500];\n\nint main(){\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tscanf(\"%d\",&n);res=0;\n\t\tm=n;\n\t\tpriority_queue<int> q,q2;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tv[i].clear();\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tson[i]=k;\n\t\t\twhile(k--){\n\t\t\t\tscanf(\"%d\",&j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t\tif(!son[i])q.push(-i);\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tlst=0;res++;\n\t\t\twhile(!q.empty()){\n\t\t\t\tx=-q.top();q.pop();\n\t\t\t\tif(x<lst){\n\t\t\t\t\tq2.push(-x);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlst=x;\n\t\t\t\t\tm--;\n\t\t\t\t\tfor(auto i:v[x]){\n\t\t\t\t\t\t//printf(\"a%d %d\\n\",x,i);\n\t\t\t\t\t\tif(!son[i])continue;\n\t\t\t\t\t\tson[i]--;\n\t\t\t\t\t\tif(!son[i])q.push(-i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!q2.empty())swap(q,q2);\n\t\t}\n\t\tif(m)puts(\"-1\");\n\t\telse printf(\"%d\\n\",res);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "graphs",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Book.json",
    "editorial_link": "https://codeforces.com//blog/entry/95086",
    "editorial": "There are two main solutions in this task.\n\nThe first solution simulates the process of reading the book. Let ri\n be the number of chapters that need to be understood in order to understand i\n-th chapter. We will keep this array updated during the simulation. Now we will simulate the process by keeping a set of chapters that are ready to be understood. Suppose we have just understood chapter x\n. We will update array r\n by iterating over all chapters that require x\n to be understood. If some chapter becomes ready to be understood, we will insert it to the set. Then, we will lowerbound on our set to the next chapter that can be understood and when we hit the end, the answer increases by one and we come back to the beginning.\n\nThe entire process runs in O(nlogn)\n.\n\nThe second solution is more graph based. We will construct a graph, where there is a directed edge from a\n to b\n if chapter b\n is needed to understand chapter a\n. This edge has weight 0\n if a>b\n and 1\n otherwise. The answer is the length of the longest weighted path in this graph incremented by 1\n. If there exists a cycle we should output ?1\n. If the graph is a DAG, we can use toposort and a simple DP to calculate the answer."
}