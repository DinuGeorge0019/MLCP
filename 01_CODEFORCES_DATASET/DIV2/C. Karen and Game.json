{
    "link": "https://codeforces.com//contest/816/problem/C",
    "problemId": "110366",
    "problem_idx": "C",
    "shortId": "816C",
    "contest_number": "816",
    "problem_submissions": {
        "E": [
            27863231,
            27863827,
            27863029,
            27860461,
            27863136,
            27865351,
            27864615,
            27864468,
            27888047,
            27887967,
            27937085
        ],
        "C": [
            27850215,
            27861317,
            27854036,
            27851177,
            27862299,
            27857090,
            27854650,
            27852662,
            27850415,
            27853530,
            27854524,
            27855938,
            27852726,
            27856877,
            27849179,
            27853471,
            27855491,
            27856929,
            27856486
        ],
        "B": [
            27848642,
            27849640,
            27850149,
            27848668,
            27849856,
            27851634,
            27849204,
            27854414,
            27848329,
            27850570,
            27851030,
            27849936,
            27849151,
            27848884,
            27852810,
            27850464,
            27851714,
            27851843,
            27851131
        ],
        "A": [
            27848027,
            27848026,
            27848067,
            27848089,
            27848256,
            27849615,
            27848022,
            27851364,
            27847966,
            27848494,
            27847999,
            27848587,
            27848127,
            27847967,
            27851375,
            27849723,
            27848224,
            27848952,
            27848135
        ],
        "D": [
            27863292,
            28057801,
            28341325,
            27862819,
            27861012,
            27860728,
            27886034,
            27863751,
            27864128
        ]
    },
    "name": "C. Karen and Game",
    "statement": "On the way to school, Karen became fixated on the puzzle game on her\r\nphone! The game is played as follows. In each level, you have a grid\r\nwith rows and columns. Each cell originally contains the number .One\r\nmove consists of choosing one row or column, and adding to all of the\r\ncells in that row or column.To win the level, after all the moves, the\r\nnumber in the cell at the -th row and -th column should be equal to\r\n.Karen is stuck on one level, and wants to know a way to beat this level\r\nusing the minimum number of moves. Please, help her with this task!\r\n",
    "solutions": [
        "//#pragma comment(linker,\"/STACK:16777216\") /*16Mb*/\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <list>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <time.h>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\n\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define RFOR(i,a,b) for(int (i)=(a)-1;(i)>=(b);--(i))\n#define MP make_pair\n#define I insert\n#define mod 1000000007\n#define INF 2000000007\n#define PB push_back\n#define x0 sdfhrthrth\n#define x1 fdhttrlhn\n#define y0 kihrbdb\n#define y1 ugvrrtgtrg\n#define eps 1e-5\n#define X first\n#define Y second\n\nconst int MAXN = 300000;\n\nint n, m;\nint a[111][111];\nint ans;\nvector<int> r, c;\n\nvoid dorow()\n{\n    FOR (i,0,n)\n    {\n        int val = 1000;\n        FOR (j,0,m) val = min(val,a[i][j]);\n        ans += val;\n        FOR (j,0,m) a[i][j] -= val;\n        FOR (k,0,val) r.PB(i);\n    }\n}\n\nvoid docol()\n{\n    FOR (i,0,m)\n    {\n        int val = 1000;\n        FOR (j,0,n) val = min(val,a[j][i]);\n        ans += val;\n        FOR (j,0,n) a[j][i] -= val;\n        FOR (k,0,val) c.PB(i);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n    FOR (i,0,n)\n    FOR (j,0,m)\n        cin >> a[i][j];\n    if (n < m) dorow(), docol();\n    else docol(), dorow();\n    bool ok = 1;\n    FOR (i,0,n)\n    FOR (j,0,m)\n    if (a[i][j]) ok = 0;\n    if (!ok) cout << -1;\n    else\n    {\n        cout << ans << \"\\n\";\n        FOR (i,0,r.size())\n            cout << \"row \"<<r[i]+1<<\"\\n\";\n        FOR (i,0,c.size())\n            cout << \"col \"<<c[i]+1<<\"\\n\";\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Karen and Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/52742",
    "editorial": "Fix the number of times we choose the first row. Say we choose the first row k times. This actually uniquely determines the rest of the solution; consider the cells on the first row. There is no other way to increase these cells, except by choosing the columns they are on, and so we need to choose the j-th column g1,?j?-?k times.\n\nNow, once we know the number of times we have to choose each column, we will also know how many times to choose the remaining rows. At this point, for any given row i, the remaining number of times we have to choose it is gi,?j?-?(g1,?j?-?k), this should be the same for all j in a given row (otherwise there is no solution).\n\nWe can simply try all k, see if they can form a valid solution, and if so, calculate how many moves it will take. Find the smallest required number of moves, and then recover the solution.\n\nImplemented properly, it should run in O(n) time, which should be fast enough. Note that there are O(max gi,?j) possible choices for k, and testing a certain k can be done in O(nm) time. A solution will have at most O(max(n,?m)\u00b7max gi,?j) moves, so printing them will take that much time.\n\nOverall, this solution hence runs in O(nm\u00b7max gi,?j) time, which is acceptable.\n\nThere is a faster solution to this, both in terms of runtime and implementation time, which we will describe below.\n\nNotice that, when there is a 0 on the grid, all the moves are already fixed. If the 0 is at gi,?j, then we need to choose row i' exactly gi',?j times, and column j' exactly gi,?j' times.\n\nWhat if there is no 0 on the grid? Well, we intuitively want to reduce numbers as much as possible, and in fact the greedy algorithm works here. If there are not more rows (n???m), we should keep choosing rows, and if there are fewer columns (n?>?m), we should keep choosing columns, until there is a 0. It doesn't even matter which particular rows or columns we choose; for example, if n???m, we could just keep choosing row 1 until a 0 appears, or we could choose all rows 1,?2,?3,?...,?n in order and just keep cycling through them. The end result will be the same.\n\nWe can just check that the grid is correct at the end and print ?-?1 otherwise.\n\nImplemented properly, this runs in O(nm?+?max(n,?m)\u00b7max gi,?j), which is asymptotically optimal; it takes at least O(nm) time to read the input, and O(max(n,?m)\u00b7max gi,?j) to print the output."
}