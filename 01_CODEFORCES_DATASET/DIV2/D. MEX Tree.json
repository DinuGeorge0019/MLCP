{"link": "https://codeforces.com//contest/1527/problem/D", "problemId": "990897", "problem_idx": "D", "shortId": "1527D", "contest_number": "1527", "problem_submissions": {"D": [116815110, 116809404, 116791032, 116828575, 116792418, 116804682, 116790154, 116835794, 116845531, 116905646, 116813710, 116859388, 117355591, 116924969, 116847643], "E": [116803777, 116781667, 116811124, 116796120, 116809821, 116778009, 116805495, 116805635, 116810211, 116816164, 116795407, 116798117, 116858484, 116831292, 116785094, 123210634, 116826695, 116821286, 116806456, 116822934, 116825433], "B2": [116779583, 116824497, 116839392, 116808334, 116863718, 116773876, 116814004, 116802164, 116826569, 116803739, 116800671, 116833299, 116836369, 116807478], "C": [116768817, 116763349, 116757962, 116777964, 116765975, 116809173, 116768519, 116774311, 116777675, 116761218, 116817305, 116773251, 116794638, 116759497, 116781691, 116771054, 116772322, 116802912], "B1": [116758740, 116815267, 116826483, 116782539, 116761604, 116831651, 116786152, 116771964, 116779790, 116822211, 116765970, 116802975, 116804039, 116787374, 116833209, 116785198, 116777321], "A": [116752292, 116752502, 116752724, 116753777, 116753108, 116820306, 116752554, 116757169, 116752471, 116755373, 116825258, 116752544, 116831071, 116753774, 116752394, 116754330, 116756044, 116754569]}, "name": "D. MEX Tree", "statement": "You are given a tree with n nodes, numerated from 0 to n-1. For each k\r\nbetween 0 and n, inclusive, you have to count the number of unordered\r\npairs (u,v), u\r\nneq v, such that the of all the node labels in the shortest path from u\r\nto v (including end points) is k.The of a sequence of integers is the\r\nsmallest non-negative integer that does not belong to the sequence.\r\n", "solutions": ["/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC optimize(\"fast-math\")\n//#pragma GCC target(\"avx2\")\n// if avx2 not supported, use this instead\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n// something\n//#pragma GCC optimize(\"O3\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n//#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n//#pragma GCC target(\"avx\")  //Enable AVX\n\n#include <bits/stdc++.h>\n#ifdef ONPC\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n#define all(x) (x).begin(), (x).end()\n#define fr first\n#define sc second\n#define m_p make_pair\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define low_bo(a, x) ((int)(lower_bound(a.begin(), a.end(), x) - a.begin()))\n#define up_bo(a, x) ((int)(upper_bound(a.begin(), a.end(), x) - a.begin()))\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define popcnt(x) __builtin_popcount(x)\n#define shuffle(a) shuffle(a.begin(), a.end(), rnd)\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\nusing namespace std;\n\n/*\nconst int MEMSIZE = 1e9;\nchar memory[MEMSIZE];\nint memorypos;\ninline void * operator new(size_t n){\n    if (memorypos + n >= MEMSIZE)\n        memorypos = MEMSIZE / 3;\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\ninline void operator delete(void *){}\n*/\n\nusing ll = long long;\n\n#ifndef ONPC\n#define cerr cerr_maksim\nstruct Cerr : public ostream {\n    template<typename T>\n    Cerr& operator<<(T const&) {\n        return *this;\n    }\n} cerr;\n#endif\n\n#ifdef ONPC\nmt19937 rnd(223);\nmt19937_64 rndll(231);\n#else\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rndll(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\n\ntemplate<typename T>\nvoid setmin(T &x, T y) {\n    x = min(x, y);\n}\n\ntemplate<typename T>\nvoid setmax(T &x, T y) {\n    x = max(x, y);\n}\n\nnamespace Ment {\n    template<typename T>\n    T inverse(T a, T m) {\n        T u = 0, v = 1;\n        while (a != 0) {\n            T t = m / a;\n            m -= t * a;\n            swap(a, m);\n            u -= t * v;\n            swap(u, v);\n        }\n        assert(m == 1);\n        return u;\n    }\n\n    template<typename T>\n    class Modular {\n    public:\n        using Type = typename decay<decltype(T::value)>::type;\n\n        constexpr Modular() : value() {}\n\n        template<typename U>\n        Modular(const U &x) {\n            value = normalize(x);\n        }\n\n        template<typename U>\n        static Type normalize(const U &x) {\n            Type v;\n            if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n            else v = static_cast<Type>(x % mod());\n            if (v < 0) v += mod();\n            return v;\n        }\n\n        const Type &operator()() const { return value; }\n\n        template<typename U>\n        explicit operator U() const { return static_cast<U>(value); }\n\n        constexpr static Type mod() { return T::value; }\n\n        Modular &operator+=(const Modular &other) {\n            if ((value += other.value) >= mod()) value -= mod();\n            return *this;\n        }\n\n        Modular &operator-=(const Modular &other) {\n            if ((value -= other.value) < 0) value += mod();\n            return *this;\n        }\n\n        template<typename U>\n        Modular &operator+=(const U &other) { return *this += Modular(other); }\n\n        template<typename U>\n        Modular &operator-=(const U &other) { return *this -= Modular(other); }\n\n        Modular &operator++() { return *this += 1; }\n\n        Modular &operator--() { return *this -= 1; }\n\n        Modular operator++(int) {\n            Modular result(*this);\n            *this += 1;\n            return result;\n        }\n\n        Modular operator--(int) {\n            Modular result(*this);\n            *this -= 1;\n            return result;\n        }\n\n        Modular operator-() const { return Modular(-value); }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n#ifdef _WIN32\n            uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n            uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n            asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n            );\n            value = m;\n#else\n            value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n            value = normalize(value * rhs.value - q * mod());\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            value = normalize(value * rhs.value);\n            return *this;\n        }\n\n        Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }\n\n        template<typename U>\n        friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\n    private:\n        Type value;\n    };\n\n    template<typename T>\n    bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\n\n    template<typename T, typename U>\n    bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\n\n    template<typename T, typename U>\n    bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\n    template<typename T>\n    bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T>\n    bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\n    template<typename T>\n    Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T>\n    Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T>\n    Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T>\n    Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> power(const Modular<T> &a, const U &b) {\n        assert(b >= 0);\n        Modular<T> x = a, res = 1;\n        U p = b;\n        while (p > 0) {\n            if (p & 1) res *= x;\n            x *= x;\n            p >>= 1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    string to_string(const Modular<T> &number) {\n        return to_string(number());\n    }\n\n    template<typename T>\n    std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n        return stream << number();\n    }\n\n    template<typename T>\n    std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n        typename common_type<typename Modular<T>::Type, int64_t>::type x;\n        stream >> x;\n        number.value = Modular<T>::normalize(x);\n        return stream;\n    }\n\n    constexpr int md = 1e9 + 7;\n    using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n}\nusing Ment::Mint;\n/*\nusing ModType = int;\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\n#define TIME (clock() * 1.0 / CLOCKS_PER_SEC)\n\n// WARNING!!!!!!\n// Maksim reads solution\n// be careful!!!!\n\n// solution starts here\n\nusing ld = double;\n\nconst ll llinf = 1e18 + 100;\n\nconst int maxn = 2e5 + 100, maxw = (1 << 20) + 5, inf = 1e9 + 100, LG = 18;\n\nvector<int> e[maxn];\n\nint up[LG][maxn], sz[maxn], h[maxn];\n\npair<int, int> seg[maxn];\n\nint tnow;\n\nvoid dfs(int v = 0, int p = -1) {\n    sz[v] = 1;\n    seg[v].fr = tnow++;\n    for (int i : e[v])\n        if (i != p) {\n            h[i] = h[v] + 1;\n            dfs(i, v);\n            sz[v] += sz[i];\n            up[0][i] = v;\n        }\n    seg[v].sc = tnow - 1;\n}\n\n// v anc of u\n\nbool isanc(int v, int u) {\n    return seg[v].fr <= seg[u].fr && seg[v].sc >= seg[u].sc;\n}\n\nint climb(int v, int t) {\n    for (int i = 0; i < LG; i++)\n        if ((1 << i) & t)\n            v = up[i][v];\n    return v;\n}\n\nint get_lca(int v, int u) {\n    if (h[v] < h[u])\n        swap(v, u);\n    v = climb(v, h[v] - h[u]);\n    if (v == u)\n        return v;\n    for (int i = LG - 1; i >= 0; i--)\n        if (up[i][v] != up[i][u])\n            v = up[i][v], u = up[i][u];\n    return up[0][v];\n}\n\nint n;\n\nvoid solve() {\n    tnow = 0;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        e[i].clear();\n    for (int i = 1; i < n; i++) {\n        int v, u;\n        cin >> v >> u;\n        e[v].push_back(u);\n        e[u].push_back(v);\n    }\n    dfs();\n    for (int j = 1; j < LG; j++)\n        for (int i = 0; i < n; i++)\n            up[j][i] = up[j - 1][up[j - 1][i]];\n\n    vector<ll> dp(n + 2);\n    dp[0] = n * (ll)(n - 1) / 2;\n    dp[1] = dp[0];\n    for (int i : e[0])\n        dp[1] -= sz[i] * (ll)(sz[i] - 1) / 2;\n\n    int v = 0, u = 1;\n    for (int it = 2; it <= n; it++) {\n        cerr << \"at \" << it - 1 << \" \" << v << ' ' << u << '\\n';\n        if (h[v] < h[u])\n            swap(v, u);\n        if (isanc(u, v)) {\n            dp[it] = sz[v] * (ll)(n - sz[climb(v, h[v] - h[u] - 1)]);\n        } else {\n            dp[it] = sz[v] * (ll)sz[u];\n        }\n        if (it == n)\n            break;\n\n        int lca = get_lca(v, u);\n        if (isanc(lca, it) && (isanc(it, v) || isanc(it, u)))\n            continue;\n\n        if (isanc(u, v)) {\n            if (isanc(v, it)) {\n                v = it;\n                continue;\n            }\n            if (isanc(climb(v, h[v] - h[u] - 1), it)) {\n                break;\n            }\n            u = it;\n            continue;\n        }\n        if (isanc(v, it)) {\n            v = it;\n            continue;\n        }\n        if (isanc(u, it)) {\n            u = it;\n            continue;\n        }\n        break;\n    }\n    for (int i = 0; i <= n; i++)\n        cout << dp[i] - dp[i + 1] << ' ';\n    cout << '\\n';\n    //todo clear\n}\n\n// check test counter\n\nint main() {\n#ifdef ONPC\n    freopen(\"../a.in\", \"r\", stdin);\n    freopen(\"../a.out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed;\n    cout.precision(20);\n    //precalc();\n    if (false) {\n        int te = 0;\n        while (1) {\n            cerr << ++te << '\\n';\n            solve();\n        }\n    }\n    int ts;\n    ts = 1;\n    cin >> ts;\n    for (int its = 1; its <= ts; its++) {\n        //cerr << \"\\nts \" << its << '\\n';\n        //cout << \"Case #\" << its << \": \";\n        solve();\n    }\n#ifdef ONPC\n    cerr << \"\\n\\nConsumed \" << TIME << '\\n';\n#endif\n}"], "input": "", "output": "", "tags": ["combinatorics", "dfs and similar", "implementation", "math", "trees"], "dificulty": "2400", "interactive": false}