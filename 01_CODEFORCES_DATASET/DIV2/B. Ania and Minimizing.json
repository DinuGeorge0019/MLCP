{
    "link": "https://codeforces.com//contest/1230/problem/B",
    "problemId": "419096",
    "problem_idx": "B",
    "shortId": "1230B",
    "contest_number": "1230",
    "problem_submissions": {
        "F": [
            61160420,
            61168761,
            61169473,
            61163448,
            61168484,
            61211410,
            61166190,
            61161224
        ],
        "E": [
            61148718,
            61161040,
            61146705,
            61151905,
            61156612,
            61143760,
            61134387,
            61160007,
            61147362,
            61152540,
            61143988,
            61157501,
            61156272,
            61146445,
            61139279,
            61157405,
            61162378
        ],
        "D": [
            61141780,
            61141760,
            61139292,
            61144818,
            61153245,
            61138124,
            61148103,
            61186591,
            61153749,
            61148878,
            61139116,
            61159398,
            61147761,
            61146515,
            61163213,
            61156688,
            61153790,
            61144523
        ],
        "C": [
            61128802,
            61146533,
            61172060,
            61167384,
            61149264,
            61133355,
            61139896,
            61137699,
            61129905,
            61146775,
            61146749,
            61137639,
            61130666,
            61128891,
            61133021,
            61163475,
            61147427,
            61133523
        ],
        "B": [
            61122260,
            61138928,
            61125100,
            61135886,
            61136151,
            61126292,
            61136826,
            61131007,
            61122773,
            61127439,
            61129919,
            61122576,
            61124319,
            61122348,
            62114936,
            61124404,
            61125885,
            61125887,
            61124264
        ],
        "A": [
            61120076,
            61128524,
            61121738,
            61130255,
            61122144,
            61123763,
            61140465,
            61128200,
            61120371,
            61124618,
            61133127,
            61121262,
            61120693,
            61119937,
            62114885,
            61126319,
            61122327,
            61122607,
            61120311
        ]
    },
    "name": "B. Ania and Minimizing",
    "statement": "Ania has a large integer S. Its decimal representation has length n and\r\ndoesn\u2019t contain any leading zeroes. Ania is allowed to change at most k\r\ndigits of S. She wants to do it in such a way that S still won\u2019t contain\r\nany leading zeroes and it\u2019ll be minimal possible. What integer will Ania\r\nfinish with?\r\n",
    "solutions": [
        "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 2e5 + 5;\n\nchar s[N];\n\nint main() {\n    int n, k;\n    scanf(\"%d%d%s\", &n, &k, s);\n    for (int i = 0; i < n; ++i) {\n        char aim = (i || n == 1) ? '0' : '1';\n        if (k && s[i] != aim) {\n            s[i] = aim;\n            --k;\n        }\n    }\n    puts(s);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Ania and Minimizing.json",
    "editorial_link": "https://codeforces.com//blog/entry/70008",
    "editorial": "There are a couple of corner cases: if , we cannot change . Otherwise,\r\nif , we can change into .Now assume that and . A simple greedy approach\r\nworks here: we can iterate over the digits from left to right and change\r\nthem to the lowest possible digits as long as we still can change\r\nanything. The leftmost digit can be only changed to , and all the\r\nremaining digits should be changed to . We need to remember not to fix\r\nthe digits that are currently the lowest possible.For instance, if , the\r\nnumber will be changed to (the modified digits are marked blue).The\r\nalgorithm can be easily implemented in time.\r\n"
}