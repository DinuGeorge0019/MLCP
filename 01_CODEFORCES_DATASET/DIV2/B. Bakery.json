{
    "link": "https://codeforces.com//contest/707/problem/B",
    "problemId": "68576",
    "problem_idx": "B",
    "shortId": "707B",
    "contest_number": "707",
    "problem_submissions": {
        "E": [
            19999638,
            20000220,
            19999902,
            20004459,
            20001527,
            20000267,
            20003187,
            19998436,
            19997562,
            20002961,
            20002001
        ],
        "D": [
            19992217,
            19995484,
            19994755,
            19992826,
            19997136,
            19993596,
            20006942,
            19997119,
            20013037,
            19993142,
            19995313,
            19999894,
            19997617,
            19996425,
            19998702,
            19999735,
            21372182,
            21371999,
            19995598
        ],
        "C": [
            19989680,
            19991341,
            19989052,
            19995374,
            20002471,
            19987427,
            19991851,
            19986782,
            19987642,
            20012707,
            19989756,
            19990354,
            19991429,
            19991374,
            19994085,
            19991752,
            19991441
        ],
        "B": [
            19985922,
            19986558,
            19987945,
            19996933,
            19986674,
            19984891,
            20010196,
            19984984,
            19989212,
            19987604,
            19990363,
            19989764,
            19987808,
            19989404,
            19988496,
            19990285,
            19987180,
            19991247
        ],
        "A": [
            19982567,
            19982966,
            19983593,
            19982522,
            19982389,
            19984792,
            19998325,
            19995326,
            19993243,
            19983627,
            19985898,
            19982933,
            19984161,
            19983215,
            19983795
        ]
    },
    "name": "B. Bakery",
    "statement": "Masha wants to open her own bakery and bake muffins in one of the cities\r\nnumbered from to . There are bidirectional roads, each of whose connects\r\nsome pair of cities.To bake muffins in her bakery, Masha needs to\r\nestablish flour supply from some storage. There are only storages,\r\nlocated in different cities numbered .Unforunately the law of the\r\ncountry Masha lives in prohibits opening bakery in any of the cities\r\nwhich has storage located in it. She can open it only in one of another\r\ncities, and, of course, flour delivery should be paid for every\r\nkilometer of path between storage and bakery Masha should pay\r\nruble.Formally, Masha will pay roubles, if she will open the bakery in\r\nsome city ( for every ) and choose a storage in some city ( for some )\r\nand and are connected by some path of roads of summary length (if there\r\nare more than one path, Masha is able to choose which of them should be\r\nused).Masha is very thrifty and rational. She is interested in a city,\r\nwhere she can open her bakery (and choose one of storages and one of the\r\npaths between city with bakery and city with storage) and pay minimum\r\npossible amount of rubles for flour delivery. Please help Masha find\r\nthis amount.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nconst int maxn = 200005;\n\ntypedef long long ll;\ntypedef pair<ll,int> P;\n\npriority_queue<P,vector<P>,greater<P> > Q;\nll d[maxn];\nbool fal[maxn];\nint to[maxn],next[maxn],cost[maxn],final[maxn],tot,n,m,k;\n\nvoid link(int u,int v,int l)\n{\n\tto[++ tot] = v,next[tot] = final[u],cost[tot] = l,final[u] = tot;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor(int i = 1;i <= m;i ++)\n\t{\n\t\tint u,v,l;\n\t\tscanf(\"%d%d%d\", &u, &v, &l);\n\t\tlink(u,v,l),link(v,u,l);\n\t}\n\tfor(int i = 1;i <= n;i ++) d[i] = (1ll << 60);\n\tfor(int i = 1;i <= k;i ++)\n\t{\n\t\tint u;\n\t\tscanf(\"%d\", &u),fal[u] = 1;\n\t\td[u] = 0;\n\t\tQ.push(P(0ll,u));\n\t}\n\twhile (!Q.empty())\n\t{\n\t\tP u = Q.top();Q.pop();\n\t\tif (u.first != d[u.second]) continue;\n\t\tfor(int i = final[u.second];i;i = next[i])\n\t\t{\n\t\t\tll w = u.first + cost[i];\n\t\t\tif (w < d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]] = w;\n\t\t\t\tQ.push(P(d[to[i]],to[i]));\n\t\t\t}\n\t\t}\n\t}\n\tll mi = (1ll << 60);\n\tfor(int i = 1;i <= n;i ++)\n\t\tif (!fal[i]) mi = min(mi,d[i]);\n\tif (mi == (1ll << 60)) printf(\"-1\\n\"); else\n\t\tprintf(\"%I64d\\n\", mi);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Bakery.json",
    "editorial_link": "https://codeforces.com//blog/entry/46662",
    "editorial": "Note that it makes no sense to choose the city for bakeries and the city with the warehouse so that had more than one way between them, as every road increases the distance over which you have to pay.\n\nSo, the problem reduces to the following: select two neighboring cities so that one is a warehouse, and in the other & mdash; no. For doing this, simply iterate through all the city with the warehouse, among the neighbors of each town without looking for a warehouse and update the answer. If there is such a pair of cities, print -1.",
    "hint": []
}