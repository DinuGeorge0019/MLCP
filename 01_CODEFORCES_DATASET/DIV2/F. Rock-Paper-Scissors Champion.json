{"link": "https://codeforces.com//contest/1087/problem/F", "problemId": "273650", "problem_idx": "F", "shortId": "1087F", "contest_number": "1087", "problem_submissions": {"E": [58252522, 47419404, 47425055, 47427281, 47427199, 47427772, 47427175, 47429424, 47427691, 47428203, 47426678, 47429553, 47424066, 47442342, 47431388], "F": [47420077, 47423866, 47885139, 47468746, 47429059, 47443089], "D": [47418729, 47408054, 47412096, 47414267, 47413772, 47414393, 47411787, 47412026, 47410837, 47416228, 47416942, 47404060, 47424226, 47415168, 47411121, 47421101, 47407066, 47410268, 47411462, 47409719], "C": [47405054, 47411233, 47407822, 47412155, 47406359, 47410875, 47413841, 47406249, 47409638, 47412893, 47414989, 47429784, 47418255, 47431334, 47431242, 47407433, 47430615, 47412255, 47405671, 47407818, 47406818], "B": [47401231, 47412385, 47401723, 47403755, 47401975, 47403962, 47406414, 47402530, 47402488, 47401578, 47406978, 47400393, 47407454, 47402895, 47400789, 47403406, 47402600, 47400687, 47402493, 47402234], "A": [47400159, 47405287, 47400196, 47400342, 47400796, 47401502, 47401673, 47400758, 47400490, 47400180, 47403017, 47409819, 47408382, 47400648, 47400053, 47400839, 47400496, 47400902, 47400447, 47400696]}, "name": "F. Rock-Paper-Scissors Champion", "statement": "n players are going to play a rock-paper-scissors tournament. As you\r\nprobably know, in a one-on-one match of rock-paper-scissors, two players\r\nchoose their shapes independently. The outcome is then determined\r\ndepending on the chosen shapes: \"paper\" beats \"rock\", \"rock\" beats\r\n\"scissors\", \"scissors\" beat \"paper\", and two equal shapes result in a\r\ndraw.At the start of the tournament all players will stand in a row,\r\nwith their numbers increasing from 1 for the leftmost player, to n for\r\nthe rightmost player. Each player has a pre-chosen shape that they will\r\nuse in every game throughout the tournament. Here\u2019s how the tournament\r\nis conducted: If there is only one player left, he is declared the\r\nchampion. Otherwise, two adjacent players in the row are chosen\r\narbitrarily, and they play the next match. The losing player is\r\neliminated from the tournament and leaves his place in the row (with his\r\nformer neighbours becoming adjacent). If the game is a draw, the losing\r\nplayer is determined by a coin toss.The organizers are informed about\r\nall players\u2019 favoured shapes. They wish to find out the total number of\r\nplayers who have a chance of becoming the tournament champion (that is,\r\nthere is a suitable way to choose the order of the games and manipulate\r\nthe coin tosses). However, some players are still optimizing their\r\nstrategy, and can inform the organizers about their new shapes. Can you\r\nfind the number of possible champions after each such request?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define ff first\n#define ss second\n#define all(X) begin(X), end(X)\nvector<int>v;\nstruct node{\n\tint l,r;\n\tint val[3] = {};\n\tnode*L, *R;\n\tnode(int ll, int rr){\n\t\tl = ll, r = rr;\n\t\tif(l == r)val[v[l]]++;\n\t\telse {\n\t\t\tL = new node(l,l+r>>1);\n\t\t\tR = new node((l+r>>1)+1, r);\n\t\t\tval[0] = L->val[0] + R->val[0];\n\t\t\tval[1] = L->val[1] + R->val[1];\n\t\t\tval[2] = L->val[2] + R->val[2];\n\t\t}\n\t}\n\tint query(int ql, int qr, int i){\n\t\tif(qr < l || ql > r || ql > qr)return 0;\n\t\tif(ql <= l && qr >= r)return val[i];\n\t\telse return L->query(ql,qr,i) + R->query(ql,qr,i);\n\t}\n\tvoid modify(int i, int x){\n\t\tif(l == r){\n\t\t\tval[0] = 0;\n\t\t\tval[1] = 0;\n\t\t\tval[2] = 0;\n\t\t\tval[x] = 1;\n\t\t}\n\t\telse{\n\t\t\t(i <= (l+r>>1)?L:R)->modify(i,x);\n\t\t\tval[0] = L->val[0] + R->val[0];\n\t\t\tval[1] = L->val[1] + R->val[1];\n\t\t\tval[2] = L->val[2] + R->val[2];\n\t\t}\n\t}\n} *root;\n#define ROCK 0\n#define PAPER 1\n#define SCISSOR 2\n#define fst(o) (*begin(o))\n#define lst(o) (*(--end(o)))\nset<int> x[3];\ninline int val(char c){\n\tif(c == 'R')return ROCK;\n\tif(c == 'P')return PAPER;\n\tif(c == 'S')return SCISSOR;\n\treturn -1;\n}\nint getans(int n){\n\tint ans = n;\n\tfor(int i = 0; i < 3; i++){\n\t\tint j = (i+1)%3;\n\t\tint k = (j+1)%3;\n\t\tif(!x[j].empty()){\n\t\t\tif(!x[k].empty()){\n\t\t\t\tans-=root->query(fst(x[j]),fst(x[k]),i);\n\t\t\t\tans-=root->query(lst(x[k]),lst(x[j]),i);\n\t\t\t}else{\n\t\t\t\tans-=root->query(0,n-1,i);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\n}\nsigned main(){\n\tint n,q;\n\tcin >> n >> q;\n\tstring s;\n\tcin >> s;\n\tfor(int i = 0; i < n; i++){\n\t\tchar c = s[i];\n\t\tv.pb(val(c));\n\t\tx[val(c)].insert(i);\n\t}\n\troot = new node(0,n-1);\n\tcout << getans(n) << endl;\n\twhile(q--){\n\t\tint t; char c;\n\t\tcin >> t >> c;\n\t\tt--;\n\t\tx[v[t]].erase(x[v[t]].find(t));\n\t\tx[val(c)].insert(t);\n\t\tv[t] = val(c);\n\t\troot->modify(t,val(c));\n\t\tcout << getans(n) << endl;\n\t}\n\t\n} "], "input": "", "output": "", "tags": [], "dificulty": "2500", "interactive": false}