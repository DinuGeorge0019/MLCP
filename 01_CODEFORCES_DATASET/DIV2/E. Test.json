{"link": "https://codeforces.com//contest/25/problem/E", "problemId": "118", "problem_idx": "E", "shortId": "25E", "contest_number": "25", "problem_submissions": {"E": [108305, 107891, 108459, 109074, 109171, 109424, 109005, 109444, 109356, 110109, 109944], "D": [107815, 107231, 107893, 107939, 107979, 108143, 107913, 108468, 108112, 108146, 108477, 108033, 107622, 108937, 108395, 108185, 107746], "C": [107542, 107972, 107666, 109348, 109330, 109305, 109284, 107599, 107695, 109679, 107814, 107526, 108085, 109622, 107856, 107775, 108767, 108192, 107976, 107797, 107728, 107534], "B": [107003, 106875, 107055, 106850, 107367, 107390, 107161, 107267, 107320, 107286, 107129, 107361, 106975, 107251, 107517, 106925, 106908], "A": [106730, 106739, 106878, 106704, 106912, 107216, 106718, 106909, 107174, 107012, 106856, 106840, 106744, 106943, 106825, 106728, 106741]}, "name": "E. Test", "statement": "Sometimes it is hard to prepare tests for programming problems. Now Bob\r\nis preparing tests to new problem about strings input data to his\r\nproblem is one string. Bob has 3 wrong solutions to this problem. The\r\nfirst gives the wrong answer if the input data contains the substring ,\r\nthe second enters an infinite loop if the input data contains the\r\nsubstring , and the third requires too much memory if the input data\r\ncontains the substring . Bob wants these solutions to fail single test.\r\nWhat is the minimal length of test, which couldn\u2019t be passed by all\r\nthree Bob\u2019s solutions?\r\n", "solutions": ["#include <assert.h>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <list>\n#include <stack>\n#include <string.h>\n#include <stdlib.h>\n#include <vector>\n#include <utility>\n#include <list>\n#define INF 0x3fffffff\n#define LINF 0x3fffffffffffffffll\n#define DINF 1e100;\n\ntypedef long long ll;\n#define PII pair<int, int>\n#define PLL pair<ll, ll>\n#define PDD pair<double, double>\n#define PIL pair<int, ll>\n#define PLI pair<ll, int>\n#define PID pair<int, double>\n#define PDI pair<double, int>\n#define PLD pair<ll, double>\n#define PDL pair<double, ll>\n\n#define NUL(x) memset(x, 0, sizeof(x))\n#define MINUS(x) memset(x, 0xff, sizeof(x))\n#define PQ(x) priority_queue< x >  //highest first\n#define PQR(x) priority_queue< x , vector< x > , greater < x > > //lowest first\n#define MP make_pair\n#define PB push_back\n#define IT(x) for (typeof((x).begin()) it = (x).begin() ; it != (x).end() ; it++)\n#define IT2(x) for (typeof((x).begin()) it2 = (x).begin() ; it2 != (x).end() ; it2++)\n#define FOR(i, a, b) for (int i = (a) ; i< (b) ; i++)\n#define DEB(x...) fprintf(stderr,x);\n//#define DEB\n\nusing namespace std;\n\n\nint* precalc(char* pattern)\n{\n  int l=strlen(pattern)+1,j;\n  int* F = new int[l];\n  memset(F, 0, l*4);\n\n  FOR(i,2,l)\n    for( j = F[i-1] ; ; j=F[j])\n      if (pattern[j] == pattern[i-1])\n        {\n          F[i] = j+1;\n          break;\n        }\n      else if (!j)\n        break;\n\n  return F;\n}\n\nint find_pattern(char* text, char* pattern)\n{\n  int* F = precalc(pattern);\n  int tl=strlen(text);\n  int pl=strlen(pattern);\n  int f=0;\n  char* found=0;\n\n  for (int t=0;t<tl;)\n    {\n      if (text[t]==pattern[f])\n        {\n          f++;\n          t++;\n          if (f==pl)\n            {\n              found =  text+t-f;\n              break;\n            }\n        }\n      else if(f)\n        f=F[f];\n      else\n        t++;\n    }\n\n  delete[] F;\n\n  if (found)\n    return -1;//good!\n  else return f;\n}\n\n\nchar A[3][100005];\nint L[3];\nchar buf [200005];\nint getl(int a, int b, int c)\n{\n  int x=find_pattern(A[a], A[b]),lb;\n  //printf(\"[%s | %s] -> x=%i\\n\",A[a], A[b], x);\n  if (x!=-1)\n    {\n      FOR(i,0,L[a]) buf[i]=A[a][i];\n      FOR(i,0,L[b]-x) buf[i+L[a]]=A[b][i+x];\n      lb=L[b]-x+L[a];\n      buf[lb]=0;\n      //printf(\"{%s}\\n\",buf);\n    }\n  else\n    {\n      FOR(i,0,L[a]) buf[i]=A[a][i];\n      lb=L[a];\n      buf[lb]=0;\n    }\n\n  x=find_pattern(buf, A[c]);\n  //  printf(\"[%s | %s] -> x=%i\\n\",buf, A[c], x);\n  if (x==-1) return lb;\n  else return lb+L[c]-x;\n}\n\nint main()\n{\n  FOR(i,0,3)\n    {\n      gets(A[i]);\n      L[i]=strlen(A[i]);\n    }\n  int m=getl(0,1,2);\n  m=min(m,getl(0,2,1));\n  m=min(m,getl(1,0,2));\n  m=min(m,getl(1,2,0));\n  m=min(m,getl(2,0,1));\n  m=min(m,getl(2,1,0));\n\n  printf(\"%i\\n\", m);\n\n  /*\n    while(testc());\n  */\n  \n  return 0;\n}\n"], "input": "", "output": "", "tags": ["hashing", "strings"], "dificulty": "2200", "interactive": false}