{
    "link": "https://codeforces.com//contest/1673/problem/E",
    "problemId": "1385667",
    "problem_idx": "E",
    "shortId": "1673E",
    "contest_number": "1673",
    "problem_submissions": {
        "E": [
            155426965,
            155417061,
            155442389,
            155435971,
            155444716,
            155445002,
            155444871,
            155514328,
            155514309,
            155514225,
            155443263,
            155444297,
            155443581,
            155433854
        ],
        "F": [
            155419208,
            155424822,
            155430193,
            155426235,
            155421394,
            155428770,
            155436120,
            155468393,
            155433714,
            155432038,
            155436911,
            155434672,
            155436663,
            155437291,
            155437403,
            155444380,
            155421502,
            155466705,
            155436336
        ],
        "D": [
            155415117,
            155435345,
            155420108,
            155439489,
            155431441,
            155419630,
            155415726,
            155421120,
            155422405,
            155419806,
            155421729,
            155424346,
            155424705,
            155419720,
            155443639,
            155434940,
            155418827,
            155423765
        ],
        "C": [
            155404978,
            155404876,
            155407310,
            155404678,
            155403723,
            155410318,
            155407177,
            155407649,
            155410425,
            155412404,
            155411432,
            155412241,
            155405106,
            155408638,
            155409170,
            155443684,
            155416480,
            155405320,
            155408554
        ],
        "B": [
            155402768,
            155402072,
            155401370,
            155411423,
            155405962,
            155405267,
            155404158,
            155402546,
            155402518,
            155406241,
            155407263,
            155417097,
            155402117,
            155403200,
            155414493,
            155417214,
            155402941,
            155413813
        ],
        "A": [
            155398139,
            155398122,
            155398102,
            155398465,
            155398314,
            155398797,
            155398162,
            155398613,
            155398972,
            155398376,
            155400350,
            155398178,
            155398450,
            155400124,
            155418014,
            155398258,
            155398425
        ]
    },
    "name": "E. Power or XOR ",
    "statement": "The symbol\r\nwedge is quite ambiguous, especially when used without context.\r\nSometimes it is used to denote a (a\r\nwedge b = a^b) and sometimes it is used to denote the operation (a\r\nwedge b=a\r\noplus b). You have an ambiguous expression E=A_1\r\nwedge A_2\r\nwedge A_3\r\nwedge\r\nldots\r\nwedge A_n. You can replace each\r\nwedge symbol with either a\r\ntexttt{Power} operation or a\r\ntexttt{XOR} operation to get an unambiguous expression E\u2019.The value of\r\nthis expression E\u2019 is determined according to the following rules: All\r\ntexttt{Power} operations are performed before any\r\ntexttt{XOR} operation. In other words, the\r\ntexttt{Power} operation takes precedence over\r\ntexttt{XOR} operation. For example, 4\r\n;\r\ntexttt{XOR}\r\n;6\r\n;\r\ntexttt{Power}\r\n;2=4\r\noplus (6^2)=4\r\noplus 36=32. Consecutive powers are calculated from . For example, 2\r\n;\r\ntexttt{Power}\r\n;3\r\n;\r\ntexttt{Power}\r\n;4 = (2^3)^4 = 8^4 = 4096. You are given an array B of length n and an\r\ninteger k. The array A is given by A_i=2^{B_i} and the expression E is\r\ngiven by E=A_1\r\nwedge A_2\r\nwedge A_3\r\nwedge\r\nldots\r\nwedge A_n. You need to find the XOR of the values of all possible\r\nunambiguous expressions E\u2019 which can be obtained from E and has at least\r\nk\r\nwedge symbols used as\r\ntexttt{XOR} operation. Since the answer can be very large, you need to\r\nfind it modulo 2^{2^{20}}. Since this number can also be very large, you\r\nneed to print its binary representation . If the answer is equal to 0,\r\nprint 0.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nint a[1048577],n,k;\nint C[30][1048577],ans[1048577],tail;\n\ninline int calc(int n,int m){\n    return (n&m)==m;\n}\n\nint main(){\n    n=read(),k=read();\n    rep(i,1,n)a[i]=read();\n    rep(t,0,29){\n        per(j,n,0)\n            C[t][j]=C[t][j+1]^calc(n-t,j);\n    }\n    for(int l=1;l<=n;l++){\n        int now=1;\n        for(int r=l;r<=n;r++){\n            if(r==l)now=a[r];\n            else{\n                if(a[r]>20||1ll*now*(1ll<<a[r])>=1048576)break;\n                now*=1<<a[r];\n            }\n            // printf(\"[l=%d,r=%d]: now=%d\\n\",l,r,now);\n            int lefn=max(0,l-2)+max(0,n-r-1);\n            int lefk=k-(l>1)-(r<n);\n            // printf(\"lefn=%d,lefk=%d\\n\",lefn,lefk);\n            lefk=max(0,lefk);\n            if(C[n-lefn][lefk])/*printf(\"in!\\n\"),*/ans[now]^=1;\n        }\n    }\n    tail=1048576-1;\n    while(tail&&!ans[tail])tail--;\n    per(i,tail,0)putchar(ans[i]+'0');\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "math",
        "number theory"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Power or XOR .json",
    "editorial_link": "https://codeforces.com//blog/entry/102389",
    "editorial": "TutorialLet\u00e2\u0080\u0099s consider a subsegment . Let all the symbols in this\r\nsegment be replaced by and the symbols before and after be replaced by .\r\nThen the value of this segment will not be affected by the rest of the\r\nexpression. Moreover, out of all the expressions in which this segment\r\nappears as above, it will contribute the same value to the final answer.\r\nSince the final answer is also a , if the segment appears in the above\r\nmentioned form in odd number of valid unambiguous expressions, it will\r\ncontribute to the final answer else it will contribute nothing. We can\r\nfind the contribution of each segment independently for all values of .\r\nNow, there are two things we need to find out: How much will contribute\r\nto the final answer, modulo . What is the parity of the count of valid\r\nunambiguous expressions, in which the segment appears as . Part 1:\r\nNotice that since all the elements of are powers of , will also be a\r\npower of . It means that -ing it with answer will flip not more than bit\r\nin the answer. The rest of the calculations is pretty straightforward.\r\nby properties of exponents. So, if it contributes to the answer, it will\r\nflip the th bit of the answer. Now, note that if , it will have no\r\neffect on the answer because will then be . So, we care only for those\r\nfor which . Since , and so, because . Thus, it is sufficient to\r\ncalculate for only values of per value of .Part 2: We have used\r\noperators as and , or operators as . Let\u00e2\u0080\u0099s say that out of the unused\r\noperators, we need to use at least of them as . Then the number of ways\r\nto do this is . Infact, instead of finding this value, we are only\r\ninterested in finding whether it is even or odd. So, we need the value\r\nof as and by definition. can be found using Lucas\u00e2\u0080\u0099 Theorem. It turns out\r\nthat is odd if and only if is a submask of , i.e., . Note that there are\r\nalso many other ways to find this value (like Submasks DP or using the\r\nfact that for precomputation) but this is the easiest one.Some final\r\nnotes - We can maintain the final answer as a binary string of length .\r\nFind the value and if the required parity is odd and , flip the X\u00e2\u0088\u0092th bit\r\nof the string. We need to be careful while calculating since can be as\r\nlarge as . But since we are interested in values that evaluate to\r\nsomething smaller than , we will never try to multiply for anything with\r\n. Calculating the parity of in may time out. The constraints are strict\r\nenough. Total time Complexity\r\n"
}