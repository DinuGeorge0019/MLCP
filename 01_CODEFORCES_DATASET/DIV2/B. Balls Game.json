{
    "link": "https://codeforces.com//contest/430/problem/B",
    "problemId": "9398",
    "problem_idx": "B",
    "shortId": "430B",
    "contest_number": "430",
    "problem_submissions": {
        "E": [
            6596209,
            6601239,
            6595457,
            6596869,
            6611998
        ],
        "C": [
            6593903,
            6589689,
            6590185,
            6591146,
            6594509,
            6591043,
            6594881,
            6592145,
            6591439,
            6590916,
            6592010,
            6592041,
            6592596,
            6592644,
            6593233,
            6592230,
            6592515,
            6591488,
            6591864
        ],
        "D": [
            6592681,
            6591086,
            6597590,
            6592274,
            6591820,
            6594037,
            6592628,
            6594400,
            6599564,
            6594397,
            6596203,
            6595708,
            6594744,
            6595014,
            6595972,
            6596088,
            6594380,
            6593712,
            6595433
        ],
        "B": [
            6591917,
            6588904,
            6589347,
            6590112,
            6589136,
            6589725,
            6590062,
            6590923,
            6589922,
            6588990,
            6590100,
            6590128,
            6591019,
            6591186,
            6590471,
            6590715,
            6590194,
            6589294,
            6593720
        ],
        "A": [
            6588412,
            6588136,
            6588222,
            6588465,
            6590072,
            6588672,
            6588238,
            6589003,
            6588856,
            6595945,
            6588333,
            6588427,
            6589419,
            6589285,
            6588864,
            6589371,
            6595841,
            6600698,
            6589758
        ]
    },
    "name": "B. Balls Game",
    "statement": "Iahub is training for the IOI. What is a better way to train than\r\nplaying a Zuma-like game? There are balls put in a row. Each ball is\r\ncolored in one of colors. Initially the row doesn\u2019t contain three or\r\nmore contiguous balls with the same color. Iahub has a single ball of\r\ncolor . He can insert his ball at any position in the row (probably,\r\nbetween two other balls). If at any moment there are three or more\r\ncontiguous balls of the same color in the row, they are destroyed\r\nimmediately. This rule is applied multiple times, until there are no\r\nmore sets of 3 or more contiguous balls of the same color. For example,\r\nif Iahub has the row of balls [black, black, white, white, black, black]\r\nand a white ball, he can insert the ball between two white balls. Thus\r\nthree white balls are destroyed, and then four black balls become\r\ncontiguous, so all four balls are destroyed. The row will not contain\r\nany ball in the end, so Iahub can destroy all 6 balls.Iahub wants to\r\ndestroy as many balls as possible. You are given the description of the\r\nrow of balls, and the color of Iahub\u2019s ball. Help Iahub train for the\r\nIOI by telling him the maximum number of balls from the row he can\r\ndestroy.\r\n",
    "solutions": [
        "/**************************************************\n *        Problem:  Codeforces #245 Div.2 Problem B\n *         Author:  clavichord93\n *          State:  \n **************************************************/\n\n/**************************************************\n * Header\n **************************************************/\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <limits>\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Copy(a, b) memcpy(a, b, sizeof(b))\n#define NPOS string::npos\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define rrep(i, a, b) for (int i = a; i >= b; i--)\n#define erep(j, a) for (Edge *j = a; j; j = j->next)\n#define irep(i, a) for (__typeof(a.begin()) i = a.begin(); i != a.end(); i++)\n#define srep(sub, s) for (int sub = s & (s - 1); sub; sub = (sub - 1) & s)\n#define sqr(a) ((a) * (a))\n#define R(x) scanf(\"%d\", &x)\n#define SS(a, b) scanf(\"%d %d\", &a, &b)\n#define SSS(a, b, c) scanf(\"%d %d %d\", &a, &b, &c)\n#define O(x) pf(\"%d\\n\", x)\n#define TEST int T;scanf(\"%d\", &T);for (int cas = 1; cas <= T; cas++)\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define ppb pop_back\n#define pft push_front\n#define ppf pop_front\n#define mp make_pair\n#define vec vector\n#define it iterator\n#define fir first\n#define sec second\n#define x first\n#define y second\n#define all(a) a.begin(),a.end()\n#define sz(a) (int)(a.size())\n#define bg(a) (a).begin()\n#define en(a) (a).end()\n#define clr(a) (a).clear()\n#define dbg(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n#define bit_cnt(x) __builtin_popcount((unsigned)x)\n#define gcd(a, b) __gcd(a, b)\n#define sqr(a) ((a) * (a))\n#define lch(t) (t << 1)\n#define rch(t) (t << 1 | 1)\n#define inf numeric_limits<int>::max()\n#define finf numeric_limits<double>::infinity()\nusing namespace std;\ntemplate<class T> inline bool gmin(T &a, T b) { if (a > b) return a = b, true; return false; }\ntemplate<class T> inline bool gmax(T &a, T b) { if (a < b) return a = b, true; return false; }\ntemplate<class T> T exgcd(T a, T b, T &x, T &y) { if (!b) return x = (T)1, y = (T)0, a; else { T d = exgcd(b, a % b, y, x); return y -= a / b * x, d; } }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<double, double> pdd;\ntypedef pair<double, pdd> pddd;\ntypedef vec<int> vi;\ntypedef vec<double> vd;\ntypedef vec<pii> vii;\ntypedef vec<pdd> vdd;\ntypedef istringstream iss;\ntypedef ostringstream oss;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1e10;\nconst double EPS = 1e-9;\nconst double PI = 3.14159265358979323846264338327950288;\nconst double TAU = 2.0 * PI;\ninline int sgn(const double &a) { return a > EPS ? 1 : (a < -EPS ? -1 : 0); }\ninline int lowbit(int i) { return i & (-i); }\nstruct Initializer { Initializer() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); } } initializer;\n\n/**************************************************\n * Templates\n **************************************************/\n\n\n\n/**************************************************\n * Main\n **************************************************/\n\nconst int MAXN = 105;\n\nint n, k, x, tot;\nint c[MAXN];\npii b[MAXN];\n\nint main() {\n    SSS(n, k, x);\n    rep (i, 1, n) R(c[i]);\n    for (int i = 1; i <= n; ) {\n        int j = i;\n        while (j + 1 <= n && c[j + 1] == c[j]) j++;\n        b[++tot] = mp(c[i], j - i + 1);\n        i = j + 1;\n    }\n    int ans = 0;\n    rep (i, 1, tot) if (b[i].fir == x && b[i].sec == 2) {\n        int j = 1, sum = 2;\n        while (i - j >= 1 && i + j <= tot && b[i - j].fir == b[i + j].fir && b[i - j].sec + b[i + j].sec >= 3) sum += b[i - j].sec + b[i + j].sec, j++;\n        gmax(ans, sum);\n    }\n    pf(\"%d\\n\", ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Balls Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/12265",
    "editorial": "This is an implementation problem. There is not so much to explain.\r\nPerhaps the trick at implementation problems is to divide code into\r\nsmaller subproblems, easy to code and then put them together. I don t\r\nknow if this is the universally truth, but this is how I approach them.\r\nHere, there are two main parts: the part when you insert a ball between\r\n2 balls and the part when you see how many balls are destroyed after the\r\nmove. We can keep an array a[] with initial configuration of balls, then\r\nfor each insertion create an array b[] with current configuration after\r\nthe insertion. If my ball is inserted after position pos, b is something\r\nlike this: b = a[1....pos] + {my_ball} + a[pos+1....n]. For now we have\r\narray b[] and we need to know how many balls will disappear. The problem\r\nstatement gives us an important clue: no 3 balls will initially have the\r\nsame color. This means, any time, at most one contiguous range of balls\r\nof same color will exist with length at least 3. If it exists, we have\r\nto remove it. Then, we have to repeat this process. So algorithm is\r\nsomething like bubble sort: while b[] array has changed last step,\r\ncontinue algorithm, otherwise exit it. Now, search an i for which b[i] =\r\nb[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i],\r\nwith i < k <= j. You have to remove from b[] the subarray [i...j] and\r\nadd j i + 1 to the destroyed balls. You ll need to return this sum 1,\r\nbecause the ball you added wasn t there at beginning. Pay attention on\r\ncase when you can t destroy anything, you need to output 0 instead of\r\n-1. There are O(n) positions where you can insert the new ball, for each\r\nof them there are maximal O(n) steps when balls are deleted and deleting\r\nballs takes maximal O(n) time, so overall complexity is O(n ^ 3). Note:\r\nin my solution, I don t actually do deletion. If I have to delete a\r\nrange [i, j] I create a new array c[] = b[1...i 1] + b[j+1....n] and\r\nthen copy c[] into b[] array. This guarantees O(n) time for deletion.\r\n"
}