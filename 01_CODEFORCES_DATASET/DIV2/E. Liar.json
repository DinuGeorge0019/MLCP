{
    "link": "https://codeforces.com//contest/822/problem/E",
    "problemId": "112704",
    "problem_idx": "E",
    "shortId": "822E",
    "contest_number": "822",
    "problem_submissions": {
        "F": [
            28226477,
            28227833,
            28234485,
            121378904,
            28235297,
            28231678,
            28231485,
            28258361
        ],
        "D": [
            28220361,
            28241973,
            28222879,
            28224886,
            28220519,
            28218772,
            28221801,
            28232006,
            28222390,
            28222910,
            28223049,
            28223706,
            28222751,
            28223008,
            28223545,
            28225049,
            30808892,
            30808809,
            30775148,
            30775133,
            28260630,
            28260627,
            28260623,
            28260619,
            28260616,
            28222313,
            28221933,
            28223249,
            28222763
        ],
        "C": [
            28217855,
            28220105,
            28229992,
            28218508,
            28216902,
            28218827,
            28229058,
            28219916,
            28218406,
            28233624,
            28219679,
            28219443,
            28243847,
            28242189,
            28220976,
            28220363,
            28217221,
            28234024,
            28220512,
            28220807
        ],
        "B": [
            28215617,
            28217499,
            28217671,
            28215623,
            28216740,
            28215319,
            28227052,
            28216354,
            28215387,
            28712598,
            28216046,
            28216098,
            28217782,
            28218866,
            28215991,
            28217059,
            28215364,
            28224742,
            28216904,
            28216277
        ],
        "A": [
            28213695,
            28241921,
            28215982,
            28214402,
            28213808,
            28213653,
            28225926,
            28213772,
            28213642,
            28213882,
            28213766,
            28213670,
            28216840,
            28213795,
            28214218,
            28213662,
            28224209,
            28214112,
            28214126
        ],
        "E": [
            28265504,
            28265214,
            28263196,
            28263185,
            28262827,
            28262769,
            28261419,
            28261271,
            28261020,
            28248181,
            28229657,
            28474980,
            28225496,
            104050719,
            28227963,
            28248236,
            28295336,
            28271106
        ]
    },
    "name": "E. Liar",
    "statement": "The first semester ended. You know, after the end of the first semester\r\nthe holidays begin. On holidays Noora decided to return to Vi kopolis.\r\nAs a modest souvenir for Leha, she brought a sausage of length from\r\nPavlopolis. Everyone knows that any sausage can be represented as a\r\nstring of lowercase English letters, the length of which is equal to the\r\nlength of the sausage.Leha was very pleased with the gift and\r\nimmediately ate the sausage. But then he realized that it was a quite\r\ntactless act, because the sausage was a souvenir! So the hacker\r\nimmediately went to the butcher shop. Unfortunately, there was only\r\nanother sausage of length in the shop. However Leha was not upset and\r\nbought this sausage. After coming home, he decided to cut the purchased\r\nsausage into several pieces and number the pieces starting from from\r\nleft to right. Then he wants to select several pieces and glue them\r\ntogether so that the obtained sausage is equal to the sausage that Noora\r\ngave. But the hacker can glue two pieces together only when the number\r\nof the left piece is less than the number of the right piece. Besides he\r\nknows that if he glues more than pieces, Noora will notice that he has\r\nfalsified souvenir sausage and will be very upset. Of course Leha doesn\r\nt want to upset the girl. The hacker asks you to find out whether he is\r\nable to cut the sausage he bought, and then glue some of the pieces so\r\nthat Noora doesn\u2019t notice anything.Formally, you are given two strings\r\nand . The length of the string is , the length of the string is . It is\r\nrequired to select several pairwise non-intersecting substrings from ,\r\nso that their concatenation in the same order as these substrings appear\r\nin , is equal to the string . Denote by the minimal number of substrings\r\nto be chosen so that their concatenation is equal to the string . If it\r\nis impossible to choose such substrings, then . Leha really wants to\r\nknow whether it s true that .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n//suffix array with lcp query\nstruct suff_arr {\n\tint n;\n\tvector<int> A,I;\n\tvector<vector<int> > rmq;\n\tstatic inline int lg(int a){return 31-__builtin_clz(a);}\n\n\tvoid kasai(const string& s) {\n\t\trmq = vector<vector<int> >(lg(n)+1,vector<int>(n));\n\t\tint k = 0,j;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(I[i]==n-1) {\n\t\t\t\tk = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(j = A[I[i]+1];i+k<n && j+k<n && s[i+k] == s[j+k]; ++k);\n\t\t\trmq[0][I[i]] = k;\n\t\t\tif(k) --k;\n\t\t}\n\t\tfor(k = 0, j = 1; k+1 < rmq.size(); j<<=1,++k)\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\trmq[k+1][i] = (i+j<n)?min(rmq[k][i],rmq[k][i+j]):rmq[k][i];\n\t}\n\n\tsuff_arr(const string& s):n(s.size()),A(s.size()+1) {\n\t\tfor(int i = 0; i < n; ++i) A[i] = s[i]+1;\n\t\tvector<int> T(n),L(n),F(n+1);\n\t\tI = A;\n\t\tfor(int i = 0; i < n; ++i) L[i] = i;\n\t\tA[n] = I[n] = 0;\n\t\tsort(L.begin(),L.end(),[this](int i, int j) {return (A[i]!=A[j])?A[i]<A[j]:A[min(i+1,n)]<A[min(j+1,n)];});\n\t\tfor(int g = 1;;) {\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\tI[L[i]] = (i && A[L[i]]==A[L[i-1]] && A[min(L[i]+g,n)]==A[min(L[i-1]+g,n)]) ? I[L[i-1]] : i+1;\n\t\t\tif((g <<= 1) < n) {\n\t\t\t\tfill(F.begin(),F.end(),0);\n\t\t\t\tF[0] = g;\n\t\t\t\tfor(int i = n-1; i >= g; --i) ++F[I[min(i,n)]];\n\t\t\t\tfor(int i = 1; i <= n; ++i) F[i] += F[i-1];\n\t\t\t\tfor(int i = 0; i < n; ++i) T[--F[I[min(i+g,n)]]] = i;\n\t\t\t\tfill(F.begin(),F.end(),0);\n\t\t\t\tfor(int i = 0; i < n; ++i) ++F[I[i]];\n\t\t\t\tfor(int i = 1; i <= n; ++i) F[i] += F[i-1];\n\t\t\t\tfor(int i = n-1; i >= 0; --i) L[--F[I[T[i]]]] = T[i];\n\t\t\t\tswap(A,I);\n\t\t\t} else break;\n\t\t}\n\t\tA.pop_back(), I.pop_back();\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tA[--I[i]] = i;\n\t\tkasai(s); //can be removed if not needed\n\t}\t\n\n\tint lcp(int i, int j) const {\n\t\tif(i == j) return n-i;\n\t\ti=I[i],j=I[j];\n\t\tif(j<i) swap(i,j);\t\n\t\tint l = lg(j-i);\n\t\treturn min(rmq[l][i],rmq[l][j-(1<<l)]);\n\t}\n};\n\nconst int N = 1e5+5;\nint dp[N][33];\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\tint n,m,x;\n\tstring s,t;\n\tcin >> n >> s >> m >> t >> x;\n\tsuff_arr S(s + \"$\" + t);\n\tfor(int i = 0; i <= n; ++i) {\n\t\tfor(int r = 0; r <= x; ++r) {\n\t\t\tif(dp[i][r] == m) {\n\t\t\t\tcout << \"YES\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[i+1][r] = max(dp[i+1][r],dp[i][r]);\n\t\t\tif(dp[i][r] == m || i == n || s[i] != t[dp[i][r]]) continue;\n\t\t\tint lcp = S.lcp(i,n+1+dp[i][r]);\n\t\t\tdp[i+lcp][r+1] = max(dp[i+lcp][r+1],dp[i][r]+lcp);\n\t\t}\n\t}\n\tcout << \"NO\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "hashing",
        "string suffix structures"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Liar.json",
    "editorial_link": "https://codeforces.com//blog/entry/53068?locale=en",
    "editorial": "Formally, you were given two strings and . Also number was given. You\r\nneed to determine whether condition is satisfied. is equal to the\r\nminimal number of non-intersect substrings of string which can be\r\nconcatenated together to get . Substrings should be concatenated in the\r\nsame order they appear in .Note that for short strings we can use .Note\r\nthat we are not interested in such states in which value of is greater\r\nthan . Also note that we can swap value with one parameter to get new\r\nDP: , where value of old DP, maximal for which condition is satisfied: .\r\nhave states. But it\u00e2\u0080\u0099s not clear how to make transitions to make total\r\ncomplexity smaller.Note that there is only two transitions:First\r\ntransition is obviously, because we make prefix longer by one letter,\r\ni.e. can be split into several parts to get prefix of string , i.e.\r\n.Second transition is not so obviously, but if we take some part from\r\nstring to cover string , it\u00e2\u0080\u0099s easy to see that it\u00e2\u0080\u0099s optimal to take the\r\nlongest possible part. Length of such longest possible part is .We can\r\nfind using suffix array.Total complexity is , where . But solutions with\r\ncomplexity also passed. Also can be found by binary search with hashes.\r\nSo the total complexity of such solution is .\r\n"
}