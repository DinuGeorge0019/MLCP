{
    "link": "https://codeforces.com//contest/1536/problem/D",
    "problemId": "1007472",
    "problem_idx": "D",
    "shortId": "1536D",
    "contest_number": "1536",
    "problem_submissions": {
        "E": [
            118631124,
            118614939,
            118616967,
            118624386,
            118627719,
            118635620,
            118636863,
            118621534,
            118623141,
            118619496,
            118630371,
            118626916,
            118634340,
            118635235,
            118626014,
            118625912,
            118631232,
            118724771,
            118637508,
            118632134,
            118634841
        ],
        "F": [
            118625791,
            118638866,
            118613437,
            118637695,
            118644936,
            118650446,
            118647459,
            118663966,
            118711352,
            118653882,
            118654218,
            118882357
        ],
        "C": [
            118608971,
            118600883,
            118628209,
            118608554,
            118608052,
            118619465,
            118622898,
            118607847,
            118602584,
            118598176,
            118609484,
            118609006,
            118618271,
            118606277,
            118606392,
            118620701,
            118612692,
            118724743,
            118612675,
            118612583,
            118612872
        ],
        "D": [
            118608031,
            118607288,
            118623947,
            118617513,
            118619773,
            118632284,
            118632215,
            118614859,
            118617552,
            118601113,
            118616452,
            118622152,
            118614133,
            118620886,
            118617343,
            118616486,
            118624441,
            118724752,
            118620219,
            118627264,
            118625159
        ],
        "B": [
            118602956,
            118599083,
            118634218,
            118612957,
            118602526,
            118613641,
            118606813,
            118602130,
            118599340,
            118630482,
            118605942,
            118604400,
            118601413,
            118601634,
            118600081,
            118601184,
            118602824,
            118724734,
            118602945,
            118605239,
            118604772
        ],
        "A": [
            118598232,
            118597991,
            118635775,
            118598107,
            118598184,
            118601999,
            118598235,
            118599189,
            118598143,
            118622748,
            118598451,
            118598128,
            118598114,
            118598284,
            118598026,
            118597979,
            118598563,
            118724715,
            118598620,
            118599178,
            118598920
        ]
    },
    "name": "D. Omkar and Medians",
    "statement": "Uh oh! Ray lost his array yet again! However, Omkar might be able to\r\nhelp because he thinks he has found the of Ray’s array. The of an array\r\na with elements a_1, a_2,\r\nldots, a_{2k-1}, is the array b with elements b_1, b_2,\r\nldots, b_{k} such that b_i is equal to the median of a_1, a_2,\r\nldots, a_{2i-1} for all i. Omkar has found an array b of size n (1\r\nleq n\r\nleq 2\r\ncdot 10^5, -10^9\r\nleq b_i\r\nleq 10^9). Given this array b, Ray wants to test Omkar’s claim and see\r\nif b actually is an of some array a. Can you help Ray?The median of a\r\nset of numbers a_1, a_2,\r\nldots, a_{2i-1} is the number c_{i} where c_{1}, c_{2},\r\nldots, c_{2i-1} represents a_1, a_2,\r\nldots, a_{2i-1} sorted in nondecreasing order.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define re register\n#define ll long long\n#define LL inline ll\n#define I inline int\n#define V inline void\n#define FOR(i,a,b) for(re int i=(a),i##i=(b) ; i<=i##i ; ++i)\n#define ROF(i,a,b) for(re int i=(a),i##i=(b) ; i>=i##i ; --i)\n#define gc getchar()\n//#define gc (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<18,stdin),fs==ft))?0:*fs++\nusing namespace std;\nconst int N=2e5+10,mo=1e9+7;\nchar *fs,*ft,buf[1<<18];\nLL read(){\n    ll p=0; char ch=gc; bool w=0;\n    while(!isdigit(ch)) w=ch=='-'?1:0,ch=gc;\n    while(isdigit(ch)) p=p*10+ch-'0',ch=gc;\n    return w?-p:p;\n}\nint T,n,cnt,ans;\nint a[N],sck[N],bt[N];\nI lb(int x){ return x&(-x); }\nV add(int x,int k){ for(;x<=cnt&&x;x+=lb(x)) bt[x]+=k;}\nI ask(int x){ int as=0; for(;x<=cnt&&x;x-=lb(x)) as+=bt[x]; return as;}\nV sol(){\n\tsort(sck+1,sck+1+cnt);\n\tcnt=unique(sck+1,sck+1+cnt)-sck-1;\n\tFOR(i,1,n) a[i]=lower_bound(sck+1,sck+1+cnt,a[i])-sck;\n\tFOR(i,1,cnt) bt[i]=0;\n\ta[0]=1;\n\tint x,y;\n\tFOR(i,1,n){\n\t\tx=max(a[i],a[i-1]),y=min(a[i],a[i-1]);\n\t\tif(ask(x-1)-ask(y)>0) ans=0;\n\t\tadd(a[i],1);\n\t}\n\tif(ans) cout<<\"YES\"<<'\\n';\n\telse cout<<\"NO\"<<'\\n';\n\treturn ;\n}\nint main(){\n\tT=read();\n\twhile(T--){\n\t\tn=read(),cnt=0,ans=1;\n\t\tFOR(i,1,n) a[i]=read(),sck[++cnt]=a[i];\n\t\tsol();\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Omkar and Medians.json",
    "editorial_link": "https://codeforces.com//blog/entry/91520",
    "editorial": "SolutionFor some , assume is the OmkArray of some , and we want to see\r\nwhat values of we can add so that is the OmkArray of . Let be sorted in\r\nascending order.If , note that and there are elements of , so no matter\r\nhow large are there will be at most elements larger than in . This gives\r\n. We can use a similar argument to show . Now we want to bound and .\r\nNote that each distinct value among must appear at least once in .\r\nTherefore, if , satisfy that is the largest value of and , and is the\r\nsmallest value of , , then we have , , and so . If no such\r\nlargest/smallest values exist, then we can assume is not bounded\r\nabove/below.Therefore, if has an OmkArray, it is necessary that for all\r\n, there does not exist a such that is between and , exclusive. I claim\r\nthis is also sufficient. We can construct such an array using the\r\nfollowing algorithm: Let . If for some with , let (we can replace with\r\nsome sufficiently small constant at the end of our array creation\r\nprocess). Otherwise, if then let , . If for some with , let (we can\r\nreplace with some sufficiently large constant at the end of our array\r\ncreation process). Otherwise, if then let , . Finally, if , let , . This\r\nmeans that an equivalent condition to having an OmkArray is for all ,\r\nthere does not exist a such that is between and , exclusive. There are\r\nmultiple ways to check this for an array , but one clean way would be to\r\nkeep some TreeSet , and check if is between\r\nt{s.ceil()} and\r\nt{s.floor()} for all , and then adding to if it is not already added.\r\n",
    "hint": []
}