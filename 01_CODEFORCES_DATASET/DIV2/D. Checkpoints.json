{
    "link": "https://codeforces.com//contest/1453/problem/D",
    "problemId": "821025",
    "problem_idx": "D",
    "shortId": "1453D",
    "contest_number": "1453",
    "problem_submissions": {
        "E": [
            100380052,
            155118161,
            100374406,
            100382833,
            100376358,
            100380373,
            100377845,
            100376439,
            100372651,
            100372508,
            100374319,
            100375311,
            100361396,
            100374016,
            100375798,
            100374877,
            100376885,
            100376092,
            100374918,
            100369776
        ],
        "D": [
            100375780,
            155118139,
            100367299,
            100371256,
            100369898,
            100372322,
            100371648,
            100366312,
            100368463,
            100366176,
            100366391,
            100373742,
            100368086,
            100364639,
            100371848,
            100367162,
            100368628,
            100369799,
            100372351
        ],
        "C": [
            100370717,
            155118105,
            100363680,
            100365192,
            100365975,
            100366748,
            100365481,
            100362777,
            100362628,
            100362653,
            100362794,
            100366264,
            100365011,
            100362269,
            100364059,
            100363843,
            100363639,
            100365174,
            100365522,
            100366070
        ],
        "F": [
            100365572,
            155118244,
            100384810,
            100377057,
            100384158,
            100383537,
            100385977,
            100390112,
            100382350,
            100381472,
            100408619,
            100428520
        ],
        "B": [
            100359448,
            155118064,
            100359921,
            100359636,
            100358954,
            100362716,
            100359915,
            100357443,
            100358086,
            100356217,
            100356739,
            100370528,
            100358105,
            100356427,
            100359186,
            100359063,
            100373277,
            100358271,
            100360209,
            100363310
        ],
        "A": [
            100352068,
            155118022,
            100354202,
            100352085,
            100350847,
            100354848,
            100351796,
            100357299,
            100351053,
            100350650,
            100351488,
            100367409,
            100350533,
            100350757,
            100350887,
            100350551,
            100351187,
            100351697,
            100352074,
            100358933
        ]
    },
    "name": "D. Checkpoints",
    "statement": "Gildong is developing a game consisting of n stages numbered from 1 to\r\nn. The player starts the game from the 1-st stage and should beat the\r\nstages in increasing order of the stage number. The player wins the game\r\nafter beating the n-th stage.There is at most one checkpoint on each\r\nstage, and there is always a checkpoint on the 1-st stage. At the\r\nbeginning of the game, only the checkpoint on the 1-st stage is\r\nactivated, and all other checkpoints are deactivated. When the player\r\ngets to the i-th stage that has a checkpoint, that checkpoint is\r\nactivated.For each try of a stage, the player can either beat the stage\r\nor fail the stage. If they beat the i-th stage, the player is moved to\r\nthe i+1-st stage. If they fail the i-th stage, the player is moved to\r\nthe most recent checkpoint they activated, and they have to beat the\r\nstages after that checkpoint again.For example, assume that n = 4 and\r\nthe checkpoints are on the 1-st and 3-rd stages. The player starts at\r\nthe 1-st stage. If they fail on the 1-st stage, they need to retry the\r\n1-st stage because the checkpoint on the 1-st stage is the most recent\r\ncheckpoint they activated. If the player beats the 1-st stage, they’re\r\nmoved to the 2-nd stage. If they fail it, they’re sent back to the 1-st\r\nstage again. If they beat both the 1-st stage and the 2-nd stage, they\r\nget to the 3-rd stage and the checkpoint on the 3-rd stage is activated.\r\nNow whenever they fail on the 3-rd stage, or the 4-th stage after\r\nbeating the 3-rd stage, they’re sent back to the 3-rd stage. If they\r\nbeat both the 3-rd stage and the 4-th stage, they win the game.Gildong\r\nis going to build the stages to have equal difficulty. He wants you to\r\nfind any series of stages and checkpoints using at most 2000 stages,\r\nwhere the expected number of tries over all stages is exactly k, for a\r\nplayer whose probability of beating each stage is exactly\r\ncfrac{1}{2}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nvector<int>ans;\nint _;\nll n;\nll f[100];\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\",\"r\",stdin);\n        freopen(\"out.txt\",\"w\",stdout);\n    #endif\n    read(_);\n    f[1]=2;\n    F(i,2,59)f[i]=f[i-1]*2+2;\n\twhile(_--){\n\t\tread(n);\n\t\tif(n&1){\n\t\t\tcout<<-1<<'\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tans.clear();\n\t\tD(i,59,1){\n\t\t\twhile(n>=f[i]){\n\t\t\t\tn-=f[i];\n\t\t\t\tans.PB(1);\n\t\t\t\tF(j,1,i-1)ans.PB(0);\n\t\t\t}\n\t\t}\n\t\tcout<<ans.size()<<'\\n';\n\t\tRep(y,ans)cout<<y<<' ';\n\t\tcout<<'\\n';\n\t}\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "math",
        "probabilities"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Checkpoints.json",
    "editorial_link": "https://codeforces.com//blog/entry/85288",
    "editorial": "As already explained in the notes (and is quite obvious), the expected\r\nnumber of tries to beat stage with a checkpoint where stage also has a\r\ncheckpoint (or is the end of the game) is . What if stage doesnât have a\r\ncheckpoint and stage has a checkpoint?We can think of it like this. It\r\ntakes tries in expectation to get to stage , and the player needs to add\r\none more try, trying times in total. But this also has a probability of\r\nto succeed, so the expected number of tries to actually get to stage is\r\nmultiplied by making it in total.This can be extended indefinitely.\r\nLetâs say is the expected number of tries to beat consecutive stages\r\nwith only one checkpoint at the beginning. If we extend it to\r\nconsecutive stages, it takes tries. If this is not intuitive, we can\r\nalways use Monte Carlo method to simulate how many tries each takes. The\r\ngeneral term for this sequence is , and it is introduced in OEIS A000918\r\nwith a similar example.As each checkpoint makes the stages after that\r\ncheckpoint independent of the previous stages, we can just add up\r\nappropriate âs to make it equal to . Using means we append the stages in\r\n... form where the number of âs is .As every term of the sequence is\r\neven, the answer is if is odd. Otherwise, we can show that there always\r\nexists an answer for all even . There are two simple strategies to make\r\nit with at most stages.The first strategy is to greedily take the\r\ngreatest where is the remaining number, then append and subtract it from\r\n. This works because either can be exactly , or we can use once and\r\nrepeat the process with . The worst case for this strategy is to use all\r\nof , , , ..., and another , which sums up to total of stages.Another\r\nstrategy is to use and if bit (-indexed) is . Since there can be at most\r\n-bits, the worst case for this strategy is still far less than .Time\r\ncomplexity:\r\n",
    "hint": []
}