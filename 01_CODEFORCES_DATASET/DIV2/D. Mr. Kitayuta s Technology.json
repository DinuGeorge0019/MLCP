{
    "link": "https://codeforces.com//contest/505/problem/D",
    "problemId": "20818",
    "problem_idx": "D",
    "shortId": "505D",
    "contest_number": "505",
    "problem_submissions": {
        "C": [
            9462976,
            9461898,
            9459707,
            9460323,
            9475230,
            9461474,
            9461128,
            9460598,
            9463476,
            9462889,
            9462051,
            9463671,
            9462825,
            9465572,
            9465481,
            9462466,
            9464504,
            9463286,
            9463626,
            9462651,
            9461631
        ],
        "D": [
            9460671,
            9463777,
            9464008,
            9474989,
            9464501,
            9744902
        ],
        "B": [
            9456425,
            9457631,
            9456673,
            22609961,
            9456565,
            9458361,
            9457629,
            9458613,
            9458858,
            9457628,
            9457194,
            9457755,
            9457863,
            9458685,
            9458451,
            9458743,
            9457349,
            9458774,
            9459522,
            9459663,
            9461689
        ],
        "A": [
            9456096,
            9456444,
            9456105,
            9456129,
            9456125,
            9456286,
            9457000,
            9456383,
            9456164,
            9456547,
            9456739,
            9457117,
            9457263,
            9456225,
            9456374,
            9456854,
            9456408,
            9460374,
            9456267
        ]
    },
    "name": "D. Mr. Kitayuta s Technology",
    "statement": "Shuseki Kingdom is the world\u2019s leading nation for innovation and\r\ntechnology. There are cities in the kingdom, numbered from to .Thanks to\r\nMr. Kitayuta\u2019s research, it has finally become possible to construct\r\nteleportation pipes between two cities. A teleportation pipe will\r\nconnect two cities unidirectionally, that is, a teleportation pipe from\r\ncity to city cannot be used to travel from city to city . The\r\ntransportation within each city is extremely developed, therefore if a\r\npipe from city to city and a pipe from city to city are both\r\nconstructed, people will be able to travel from city to city\r\ninstantly.Mr. Kitayuta is also involved in national politics. He\r\nconsiders that the transportation between the pairs of city () is\r\nimportant. He is planning to construct teleportation pipes so that for\r\neach important pair , it will be possible to travel from city to city by\r\nusing one or more teleportation pipes (but not necessarily from city to\r\ncity ). Find the minimum number of teleportation pipes that need to be\r\nconstructed. So far, no teleportation pipe has been constructed, and\r\nthere is no other effective transportation between cities.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<vector>\n#include<stack>\n#define MAXN 100100\nusing namespace std;\nvector<int> disj[MAXN];\nvector<int> invdisj[MAXN];\nint color[MAXN];\nvector<int> colors[MAXN];\nbool check[MAXN];\nbool revcheck[MAXN];\nint tp=1;\nint N,M;\nstack<int> st;\nvoid dfs(int a)\n{\n\tif(check[a]) return;\n\tcheck[a]=true;\n\tfor(int i=0;i<disj[a].size();i++)\n\t\tdfs(disj[a][i]);\n\tst.push(a);\n}\nvoid colordfs(int now,int colornow)\n{\n\tif(color[now]) return;\n\tcolor[now]=colornow;\n\tcolors[colornow].push_back(now);\n\tfor(int i=0;i<disj[now].size();i++)\n\t\tcolordfs(disj[now][i],colornow);\n\tfor(int i=0;i<invdisj[now].size();i++)\n\t\tcolordfs(invdisj[now][i],colornow);\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\t//puts(\"Wtf\");\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--;y--;\n\t\tdisj[x].push_back(y);\n\t\tinvdisj[y].push_back(x);\n\t}\n\tfor(int i=0;i<N;i++)\n\t\tif(!color[i]) colordfs(i,tp++);\n\tint cnt=0;\n\tfor(int i=1;i<tp;i++)\n\t{\n\t\tcnt+=colors[i].size()-1;\n\t\tfor(int j=0;j<colors[i].size();j++)\n\t\t\tdfs(colors[i][j]);\n\t\twhile(!st.empty())\n\t\t{\n\t\t\tint x=st.top();\n\t\t\tst.pop();\n\t\t\trevcheck[x]=true;\n\t\t\tfor(int i=0;i<invdisj[x].size();i++)\n\t\t\t{\n\t\t\t\tif(!revcheck[invdisj[x][i]])\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t\tgoto fuck;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfuck:\n\t\twhile(!st.empty()) st.pop();\n\t}\n\t//int cnt=0;\n\tprintf(\"%d\",cnt);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Mr. Kitayuta s Technology.json",
    "editorial_link": "https://codeforces.com/blog/entry/15889",
    "editorial": "[Problem] Given an integer and pairs of integers (), find the minimum\r\nnumber of edges in a directed graph that satisfies the following\r\ncondition: (Problem from evima) Let be the directed graph built from the\r\ninput, and be a directed graph that satisfies the given conditions. What\r\nwe seek is the minimum number of edges in . Also, we say that two\r\nvertices and in a directed graph are \"weakly connected\" if we can reach\r\nfrom by traversing edges, not considering their directions. If a pair is\r\npresent in the input, then vertices and must be weakly connected in .\r\nTherefore, for each weakly connected component (abbreviated to wcc) in ,\r\nthe vertices in that component must also be in the same wcc in . We can\r\n\"merge\" multiple wccs in and create a larger wcc in , but for now, let\r\nus find the minimum number of edges required in for each wcc in when we\r\ndo not \"merge\" them. There are two cases to consider: We have found the\r\nminimum required number of edges for each wcc in when we do not \"merge\"\r\nthem. Let us show that \"merging\" wccs in do not reduce the number of\r\nrequired edges. Suppose we combine wccs in into one wcc in . Again,\r\nthere are two cases to consider: Thus, we do not need to combine\r\nmultiple wccs into one wcc in in order to obtain the optimal solution.\r\nThat is, the final answer to the problem is the sum of the minimum\r\nrequired number of edges for each wcc in , when they are considered\r\nseparately. As for the implementation, detecting cycles in a directed\r\ngraph with vertices and edges might be a problem if this is your first\r\nencounter with it. One possible way is to paste a code that decomposes a\r\ngraph into strongly connected components. If the size of a strongly\r\nconnected component is more than one, then that means the component\r\ncontains cycles. The writer\u00e2\u0080\u0099s code (strongly connected component\r\ndecomposition, C++): 9501202\r\n"
}