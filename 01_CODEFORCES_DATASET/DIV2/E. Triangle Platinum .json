{"link": "https://codeforces.com//contest/1847/problem/E", "problemId": "1996642", "problem_idx": "E", "shortId": "1847E", "contest_number": "1847", "problem_submissions": {"F": [212433608, 212431110, 212414836, 212437044, 212436646, 212438573, 212439809, 212461142, 212444034, 212441048, 212442560, 212446414, 212448526, 212446363, 212477387, 212473113, 212447258, 212445412, 212440060, 212484613, 212430011, 212447626, 212448642, 212429172], "D": [212389437, 212405663, 212427981, 212401825, 212406614, 212408665, 212391793, 212412178, 212420289, 212416938, 212416798, 212415041, 212411965, 212408607, 212417943, 212402342, 212440813, 212424407, 212414209, 212448028], "C": [212379554, 212388481, 212381978, 212383167, 212391492, 212395637, 212408363, 212918680, 212459952, 212459679, 212387499, 212392748, 212401136, 212392067, 212389261, 212394523, 212454918, 212396638, 212395742, 212387056, 212410808, 212403757, 212388758, 212439567], "B": [212375586, 212386366, 212383195, 212377114, 212379209, 212382779, 212400416, 212381176, 212374781, 212381202, 212383485, 212376778, 212384302, 212388840, 212379283, 212442148, 212382593, 212383125, 212398777, 212403514], "A": [212372531, 212381099, 212372843, 212372985, 212372832, 212383462, 212396957, 212372898, 212372422, 212372468, 212373223, 212373301, 212373237, 212373415, 212375604, 212372629, 212374004, 212375662, 212372722, 212387500], "E": [212780531, 212480822]}, "name": "E. Triangle Platinum ", "statement": "is a rather curious Stand. Of course, it is (arguably) the strongest\r\nStand in existence, but it is also an ardent puzzle enjoyer. For\r\nexample, it gave Qtaro the following problem recently: has n hidden\r\nintegers a_1, a_2,\r\ndots, a_n (3\r\nle n\r\nle 5000, 1\r\nle a_i\r\nle 4). Qtaro must determine all the a_i by asking some queries of the\r\nfollowing form: In one query Qtaro is allowed to give three indexes i, j\r\nand k (1\r\nleq i, j, k\r\nleq n). If a_i, a_j, a_k form the sides of a non-degenerate triangle^\r\ndagger, will respond with the area of this triangle. Otherwise, will\r\nrespond with 0. By asking at most 5500 such questions, Qtaro must either\r\ntell all the values of the a_i, or report that it is possible to\r\ndetermine them.Unfortunately due to the universe reboot, Qtaro is not as\r\nsmart as Jotaro. Please help Qtaro solve \u2019s problem. ^\r\ndagger Three positive integers a, b, c are said to form the sides of a\r\nnon-degenerate triangle if and only if all of the following three\r\ninequalities hold: a+b > c, b+c > a, c+a > b.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nint get(int x, int y, int z)\n{\n    int res=0;\n    printf(\"? %d %d %d\\n\", x, y, z);\n    fflush(stdout);\n    scanf(\"%d\", &res);\n    return res;\n}\nint calcVal(int a, int b, int c)\n{\n    if(a+b<=c||b+c<=a||a+c<=b) return 0;\n    int p=a+b+c;\n    return p*(p-2*a)*(p-2*b)*(p-2*c);\n}\nnamespace Sub1 {\n    int f[10][10][10];\n    int a[10],b[10];\n    int cnt;\n    void check()\n    {\n        for(int i=1; i<=n; i++)\n        for(int j=i+1; j<=n; j++)\n        for(int k=j+1; k<=n; k++)\n        if(f[i][j][k]!=calcVal(a[i], a[j], a[k]))\n        return;\n\n        ++cnt;\n        for(int i=1; i<=n; i++) b[i]=a[i];\n    }\n    void dfs(int x)\n    {\n        if(x==n+1) check();\n        else\n        for(int i=1; i<=4; i++)\n        a[x]=i, dfs(x+1);\n    }\n    void work()\n    {\n        for(int i=1; i<=n; i++)\n        for(int j=i+1; j<=n; j++)\n        for(int k=j+1; k<=n; k++)\n        f[i][j][k]=get(i, j, k);\n        dfs(1);\n        if(cnt!=1) puts(\"! -1\");\n        else\n        {\n            printf(\"! \");\n            for(int i=1; i<=n; i++)\n            printf(\"%d \", b[i]);\n        }\n        fflush(stdout);\n    }\n}\nnamespace Sub2 {\n    int a[5100];\n    pair<int,int> getSame1()\n    {\n        for(int i=1; i<=9; i++)\n        for(int j=i+1; j<=9; j++)\n        for(int k=j+1; k<=9; k++)\n        {\n            int val=get(i, j, k);\n            for(int q=1; q<=4; q++)\n            if(val==calcVal(q, q, q))\n            {\n                a[i]=a[j]=a[k]=q;\n                return make_pair(i,j);\n            }\n        }\n        return make_pair(-1, -1);\n    }\n    pair<int,int> getSame2(int x, int y)\n    {\n        vector<int> v;\n        for(int i=1; i<=n&&v.size()<4; i++)\n        if(!a[i])\n        {\n            int val=get(x, y, i);\n            if(val) a[i]=1;\n            else v.push_back(i);\n        }\n\n        if(v.empty()) return make_pair(0,0);\n        for(int i=0; i<v.size(); i++)\n        for(int j=i+1; j<v.size(); j++)\n        {\n            int val=get(x, v[i], v[j]);\n            for(int q=2; q<=4; q++)\n            if(calcVal(a[x], q, q)==val)\n            {\n                a[v[i]]=a[v[j]]=q;\n                return make_pair(v[i], v[j]);\n            }\n        }\n        return make_pair(-1, -1);\n    }\n    void solve(int x, int y)\n    {\n        for(int i=1; i<=n; i++)\n        if(!a[i])\n        {\n            int val=get(x, y, i);\n            for(int q=1; q<=4; q++)\n            if(calcVal(a[x], a[y], q)==val)\n            a[i]=q;\n        }\n    }\n    void work()\n    {\n        int x,y;\n        tie(x,y)=getSame1();\n        if(x!=-1&&a[x]==1) tie(x, y)=getSame2(x, y);\n        if(x==-1) puts(\"! -1\");\n        else\n        {\n            solve(x, y);\n            printf(\"! \");\n            for(int i=1; i<=n; i++)\n            printf(\"%d \", a[i]);\n        }\n        fflush(stdout);\n    }\n}\nint main()\n{\n    cin>>n;\n    if(n<9) Sub1::work();\n    else Sub2::work();\n    return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "combinatorics", "implementation", "interactive", "math", "probabilities"], "dificulty": "2900", "interactive": false}