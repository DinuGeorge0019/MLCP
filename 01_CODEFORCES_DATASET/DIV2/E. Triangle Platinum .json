{
    "link": "https://codeforces.com//contest/1847/problem/E",
    "problemId": "1996642",
    "problem_idx": "E",
    "shortId": "1847E",
    "contest_number": "1847",
    "problem_submissions": {
        "F": [
            212433608,
            212431110,
            212414836,
            212437044,
            212436646,
            212438573,
            212439809,
            212461142,
            212444034,
            212441048,
            212442560,
            212446414,
            212448526,
            212446363,
            212477387,
            212473113,
            212447258,
            212445412,
            212440060,
            212484613,
            212430011,
            212447626,
            212448642,
            212429172
        ],
        "D": [
            212389437,
            212405663,
            212427981,
            212401825,
            212406614,
            212408665,
            212391793,
            212412178,
            212420289,
            212416938,
            212416798,
            212415041,
            212411965,
            212408607,
            212417943,
            212402342,
            212440813,
            212424407,
            212414209,
            212448028
        ],
        "C": [
            212379554,
            212388481,
            212381978,
            212383167,
            212391492,
            212395637,
            212408363,
            212918680,
            212459952,
            212459679,
            212387499,
            212392748,
            212401136,
            212392067,
            212389261,
            212394523,
            212454918,
            212396638,
            212395742,
            212387056,
            212410808,
            212403757,
            212388758,
            212439567
        ],
        "B": [
            212375586,
            212386366,
            212383195,
            212377114,
            212379209,
            212382779,
            212400416,
            212381176,
            212374781,
            212381202,
            212383485,
            212376778,
            212384302,
            212388840,
            212379283,
            212442148,
            212382593,
            212383125,
            212398777,
            212403514
        ],
        "A": [
            212372531,
            212381099,
            212372843,
            212372985,
            212372832,
            212383462,
            212396957,
            212372898,
            212372422,
            212372468,
            212373223,
            212373301,
            212373237,
            212373415,
            212375604,
            212372629,
            212374004,
            212375662,
            212372722,
            212387500
        ],
        "E": [
            212780531,
            212480822
        ]
    },
    "name": "E. Triangle Platinum ",
    "statement": "is a rather curious Stand. Of course, it is (arguably) the strongest\r\nStand in existence, but it is also an ardent puzzle enjoyer. For\r\nexample, it gave Qtaro the following problem recently: has n hidden\r\nintegers a_1, a_2,\r\ndots, a_n (3\r\nle n\r\nle 5000, 1\r\nle a_i\r\nle 4). Qtaro must determine all the a_i by asking some queries of the\r\nfollowing form: In one query Qtaro is allowed to give three indexes i, j\r\nand k (1\r\nleq i, j, k\r\nleq n). If a_i, a_j, a_k form the sides of a non-degenerate triangle^\r\ndagger, will respond with the area of this triangle. Otherwise, will\r\nrespond with 0. By asking at most 5500 such questions, Qtaro must either\r\ntell all the values of the a_i, or report that it is possible to\r\ndetermine them.Unfortunately due to the universe reboot, Qtaro is not as\r\nsmart as Jotaro. Please help Qtaro solve ’s problem. ^\r\ndagger Three positive integers a, b, c are said to form the sides of a\r\nnon-degenerate triangle if and only if all of the following three\r\ninequalities hold: a+b > c, b+c > a, c+a > b.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nint get(int x, int y, int z)\n{\n    int res=0;\n    printf(\"? %d %d %d\\n\", x, y, z);\n    fflush(stdout);\n    scanf(\"%d\", &res);\n    return res;\n}\nint calcVal(int a, int b, int c)\n{\n    if(a+b<=c||b+c<=a||a+c<=b) return 0;\n    int p=a+b+c;\n    return p*(p-2*a)*(p-2*b)*(p-2*c);\n}\nnamespace Sub1 {\n    int f[10][10][10];\n    int a[10],b[10];\n    int cnt;\n    void check()\n    {\n        for(int i=1; i<=n; i++)\n        for(int j=i+1; j<=n; j++)\n        for(int k=j+1; k<=n; k++)\n        if(f[i][j][k]!=calcVal(a[i], a[j], a[k]))\n        return;\n\n        ++cnt;\n        for(int i=1; i<=n; i++) b[i]=a[i];\n    }\n    void dfs(int x)\n    {\n        if(x==n+1) check();\n        else\n        for(int i=1; i<=4; i++)\n        a[x]=i, dfs(x+1);\n    }\n    void work()\n    {\n        for(int i=1; i<=n; i++)\n        for(int j=i+1; j<=n; j++)\n        for(int k=j+1; k<=n; k++)\n        f[i][j][k]=get(i, j, k);\n        dfs(1);\n        if(cnt!=1) puts(\"! -1\");\n        else\n        {\n            printf(\"! \");\n            for(int i=1; i<=n; i++)\n            printf(\"%d \", b[i]);\n        }\n        fflush(stdout);\n    }\n}\nnamespace Sub2 {\n    int a[5100];\n    pair<int,int> getSame1()\n    {\n        for(int i=1; i<=9; i++)\n        for(int j=i+1; j<=9; j++)\n        for(int k=j+1; k<=9; k++)\n        {\n            int val=get(i, j, k);\n            for(int q=1; q<=4; q++)\n            if(val==calcVal(q, q, q))\n            {\n                a[i]=a[j]=a[k]=q;\n                return make_pair(i,j);\n            }\n        }\n        return make_pair(-1, -1);\n    }\n    pair<int,int> getSame2(int x, int y)\n    {\n        vector<int> v;\n        for(int i=1; i<=n&&v.size()<4; i++)\n        if(!a[i])\n        {\n            int val=get(x, y, i);\n            if(val) a[i]=1;\n            else v.push_back(i);\n        }\n\n        if(v.empty()) return make_pair(0,0);\n        for(int i=0; i<v.size(); i++)\n        for(int j=i+1; j<v.size(); j++)\n        {\n            int val=get(x, v[i], v[j]);\n            for(int q=2; q<=4; q++)\n            if(calcVal(a[x], q, q)==val)\n            {\n                a[v[i]]=a[v[j]]=q;\n                return make_pair(v[i], v[j]);\n            }\n        }\n        return make_pair(-1, -1);\n    }\n    void solve(int x, int y)\n    {\n        for(int i=1; i<=n; i++)\n        if(!a[i])\n        {\n            int val=get(x, y, i);\n            for(int q=1; q<=4; q++)\n            if(calcVal(a[x], a[y], q)==val)\n            a[i]=q;\n        }\n    }\n    void work()\n    {\n        int x,y;\n        tie(x,y)=getSame1();\n        if(x!=-1&&a[x]==1) tie(x, y)=getSame2(x, y);\n        if(x==-1) puts(\"! -1\");\n        else\n        {\n            solve(x, y);\n            printf(\"! \");\n            for(int i=1; i<=n; i++)\n            printf(\"%d \", a[i]);\n        }\n        fflush(stdout);\n    }\n}\nint main()\n{\n    cin>>n;\n    if(n<9) Sub1::work();\n    else Sub2::work();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "implementation",
        "interactive",
        "math",
        "probabilities"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Triangle Platinum .json",
    "editorial_link": "https://codeforces.com//blog/entry/117928",
    "editorial": "First, notice that we can uniquely determine the multiset of numbers any\r\nthree except for the collision between triples and . The issue is that\r\neven if we know the multiset we cannot always uniquely determine . But\r\nwhat if all the elements of the multiset are equal? Then each element\r\nobviously has to be equal to the value of the multiset. So if for some\r\nthree distinct the area of is one of , then they are all equal to or\r\nrespectively, depending on the area. Let us say we knew that for some\r\nafter asking queries. By querying for every other than we can obtain the\r\narea of for each . This will allow us to uniquely determine each . But\r\nwait! There is an important edge case here. We also require to form a\r\nvalid triangle. If , this is not an issue because can be just assigned\r\nan area of \"\" and we can still uniquely retrieve the values. So using\r\nthis procedure, it takes us queries to determine all the values.The only\r\npossibility remaining is when . In this case, the issue is that only let\r\nus know the value of . When , itâs impossible to distinguish between .\r\nSo if we asked all questions, we would know which indices have value and\r\nwhich indices have a value of . Now if we could find two equal elements\r\namong these indices with value , we can repeat a similar linear scan as\r\nabove and find all values. But how do we find two equal values? Notice\r\nthat every value is among . So if we had such indices with value some\r\ntwo of them would be equal, and we could find them by bruting queries of\r\nthe form over all pairs of indices with value . After this we can then\r\nagain query all the other indices and find answer. This would take\r\naround queries, where is the number of ones. Unfortunately this would\r\nQLE if were around .How do we fix this? The answer is surprisingly\r\nsimple. When we were finding indices with value we simply stop the\r\nminute we have at least such indices (itâs ok even if we donât).Now we\r\nbrute over all pairs. If we find two equal, we are done within at most\r\nqueries. On the other hand if we cannot find two equal it means that we\r\ncan never distinguish between them. This is because any query of the\r\nform where are both is always a degenerate query hence will have answer\r\n. So if we do not find two equal, we will print .After all this work,\r\nthere are still a few details left. First, must be small. Otherwise all\r\nthe above work is useless. Second there should be three equal elements\r\nin the first place. The first observation is that if then by Piegonhole\r\nPrinciple, some must be equal. So if then by bruting over all triples we\r\ncan always find some three equal. Here we would have and we are asking\r\nat most queries, which fits comfortably.But what if ? In this case we\r\ncan simply brute all possible queries and then for each of the arrays\r\npossible check if the triples of that array match with the query answers\r\nobtained here. If there is exactly one such array, we have found it and\r\nwe can print it, otherwise we print because it is not possible to\r\nuniquely determine the values of the array. Notice that this takes at\r\nmost operations, which is around which fits in the TL.This solves the\r\nproblem. You might wonder why queries were allowed even though the above\r\nsolution does not use more than around queries. This is because we\r\nallowed randomisation as a valid way of finding three equal values .\r\nSuppose there are counts of respectively. If we randomly queried a\r\ntriple each time, the probability all would be equal is precisely: It is\r\neasy to see that the above is minimised when the are roughly equal. When\r\n, the above is at most , so we will find a equal triple very quickly.\r\nThe other case is when . In this case, since , we can simply query every\r\ntriple and solve directly by finding three equal instead of relying on\r\nrandomness. This sort of a method gives with very high probability, so\r\nit will still pass with at most queries.\r\n",
    "hint": []
}