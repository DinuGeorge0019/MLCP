{
    "link": "https://codeforces.com//contest/1777/problem/A",
    "problemId": "1746201",
    "problem_idx": "A",
    "shortId": "1777A",
    "contest_number": "1777",
    "problem_submissions": {
        "F": [
            189999253,
            189998361,
            189995169,
            190011490,
            190011116,
            190013769,
            190004003,
            190169577,
            190021489,
            190008226,
            190022277,
            190024196,
            190001976,
            190021500,
            190024711,
            190004961,
            190022857,
            190022045,
            190022993,
            190023276
        ],
        "E": [
            189990969,
            189994239,
            190006715,
            190001929,
            190054762,
            190054746,
            190004086,
            189987917,
            190017805,
            190001567,
            190021800,
            189999439,
            190005213,
            190019127,
            190007828,
            190009522,
            190469875,
            190020733,
            190022555,
            190013627,
            190011832,
            190008524,
            190011505
        ],
        "D": [
            189985748,
            189986829,
            189987429,
            189993541,
            189993926,
            189998094,
            189993119,
            189991582,
            189993898,
            189993229,
            189996303,
            190011551,
            189999620,
            189998025,
            189985279,
            189989471,
            190001136,
            190003775,
            189995371
        ],
        "C": [
            189982736,
            189982649,
            189981053,
            189986400,
            189987697,
            189986317,
            189985767,
            189986390,
            189987035,
            189982802,
            189983463,
            189984656,
            189988557,
            189987620,
            190014819,
            189984186,
            189995951,
            189999181,
            189985198
        ],
        "B": [
            189976042,
            189976916,
            189975827,
            189979459,
            189978444,
            189990271,
            189980176,
            189980492,
            189982493,
            189987295,
            189978177,
            189974359,
            189977682,
            189978251,
            190006967,
            189977343,
            189982864,
            189993219,
            189987444
        ],
        "A": [
            189973782,
            189974189,
            189973729,
            189974335,
            189974674,
            189974171,
            189975493,
            189974143,
            189973720,
            189987925,
            189975596,
            189973718,
            189975380,
            189974227,
            189988175,
            189973870,
            189975652,
            189992324,
            189990668
        ]
    },
    "name": "A. Everybody Likes Good Arrays ",
    "statement": "An array a is if for all pairs of adjacent elements, a_i and a_{i+1} (1\r\nle i\r\nlt n) are of parity. Note that an array of size 1 is trivially good.You\r\nare given an array of size n. In one operation you can select any pair\r\nof adjacent elements in which both elements are of the parity, delete\r\nthem, and insert their product in the same position.Find the minimum\r\nnumber of operations to form a good array.\r\n",
    "solutions": [
        "//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include \"my_header\\debug.h\"\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n;\n\t\tvector<int> a(n);\n\t\tcin>>a;\n\t\tint r=0;\n\t\tfor (i=0; i+1<n; i++) r+=(a[i]&1)==(a[i+1]&1);\n\t\tcout<<r<<'\\n';\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Everybody Likes Good Arrays .json",
    "editorial_link": "https://codeforces.com//blog/entry/111729",
    "editorial": "Replace even numbers with and odd numbers with in the array . Now we\r\nobserve that the given operation is equivalent to selecting two equal\r\nadjacent elements and deleting one of them. Now the array can be\r\nvisualized as strips of zeros (in green) and ones (in red) like this .\r\nNote that since the number of adjacent elements ( such that remains\r\nconstant (nice invariant!), every strip can be handled independently.\r\nThe size of every strip must be in the final array and performing an\r\noperation reduces the size of the corresponding strip by .So, for a\r\nstrip of length , it would require operations to reduce its size to .\r\nSo, every strip would contribute to the number of operations apart from\r\nits length. So, the answer is ( total no. of strips) which also equals\r\n() where x is number of adjacent elements () such that ().\r\n",
    "hint": [
        "Hint 1 Try to make the problem simpler.",
        "Hint 2 Parity?",
        "Hint 3 Try replacing even numbers with and odd numbers with in other words consider all numbers modulo .",
        "Hint 4 Think harder! It works!"
    ]
}