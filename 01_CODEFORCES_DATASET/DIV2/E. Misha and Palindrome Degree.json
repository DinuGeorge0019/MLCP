{
    "link": "https://codeforces.com//contest/501/problem/E",
    "problemId": "20656",
    "problem_idx": "E",
    "shortId": "501E",
    "contest_number": "501",
    "problem_submissions": {
        "D": [
            9410957,
            9411339,
            9411793,
            9412714,
            9412830,
            9413378,
            9413495,
            9413859,
            9416597,
            9414226,
            9414777,
            9414880,
            9414082,
            9414871,
            9413282,
            9414476,
            9414234,
            9413065,
            9413605,
            9413446,
            9414020
        ],
        "C": [
            9409710,
            9412812,
            9409915,
            9410635,
            9411145,
            9410890,
            9410381,
            9411803,
            9411723,
            9411491,
            9410908,
            9413785,
            9412825,
            9408972,
            9410063,
            9413464,
            9416221,
            9416007
        ],
        "B": [
            9408651,
            9408711,
            9412680,
            9409222,
            9408915,
            9408969,
            9409184,
            9409368,
            9409570,
            9409614,
            9412592,
            9408622,
            9409821,
            9442325,
            9413740,
            9410394,
            9410355,
            9410485
        ],
        "A": [
            9407105,
            9407522,
            9412385,
            9407579,
            9407165,
            9407296,
            9407604,
            9407397,
            9407151,
            9407485,
            9407144,
            9407155,
            9408421,
            9441866,
            9414917,
            9414709,
            9407354,
            9407430,
            9407583,
            9409049
        ],
        "E": [
            9423665,
            9415217
        ]
    },
    "name": "E. Misha and Palindrome Degree",
    "statement": "Misha has an array of integers indexed by integers from to . Let’s\r\ndefine of array as the number of such index pairs , that the elements\r\nfrom the -th to the -th one inclusive can be rearranged in such a way\r\nthat the array will be a palindrome. In other words, pair should meet\r\nthe condition that after some rearranging of numbers on positions from\r\nto , inclusive (it is allowed not to rearrange the numbers at all), for\r\nany following condition holds: . Your task is to find the of Misha’s\r\narray.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#define SIZE 110000\n#define clear(a,b) memset(a,b,sizeof(a))\ntypedef long long LL ;\nusing namespace std;\n\nint n , a[ SIZE ] , num[ SIZE ] ;\nint main()\n{\n\t// freopen( \"in.txt\",\"r\",stdin );\n\tscanf( \"%d\",&n );\n\tfor ( int i = 1 ; i <= n ; i++ ) scanf( \"%d\",&a[i] );\n\tclear(num,0);\n\tfor ( int i = 1 ; i <= n ; i++ ) num[a[i]]++ ;\n\tfor ( int i = 1 ; i <= n ; i++ ) if ( num[i]%2==1 ) num[0]++ ;\n\tif ( num[0] > 1 ) {\n\t\tprintf( \"0\\n\" );\n\t\treturn 0;\n\t}\n\t\n\t\n\tif ( n % 2 == 1 ) {\n\t\tint k , mid = n/2+1 , l = 1 , r = n ;\n\t\tfor ( ;a[l]==a[r]&&l<=r;l++,r-- );\n\t\tif ( l>r ){\n\t\t\tprintf( \"%I64d\\n\",(LL)n*(n+1)/2 );\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tLL ans0=0,ans1=0;\n\t\t\n\t\tclear(num,0);\n\t\tfor ( int i = l ; i <= r ; i++ ) num[a[i]]++ ;\n\t\tfor ( k = r ; k > mid ; k-- ) {\n\t\t\tif ( num[a[k]] < 2 ) break;\n\t\t\tnum[a[k]] -= 2 ;\n\t\t}\n\t\tif ( k>mid ) ans0=r-k+1; \n\t\t\telse\n\t\t\tif ( num[a[mid]] ) {\n\t\t\t\tfor ( k--;a[k]==a[2*mid-k];k-- );\n\t\t\t\tans0 = r-k+1;\n\t\t\t}\telse ans0 = r-k+1 ;\n\t\t\n\t\tclear(num,0);\n\t\tfor ( int i = l ; i <= r ; i++ ) num[a[i]]++ ;\n\t\tfor ( k = l ; k < mid ; k++ ) {\n\t\t\tif ( num[a[k]] < 2 ) break ;\n\t\t\tnum[ a[k] ] -= 2 ;\n\t\t}\n\t\tif ( k < mid ) ans1=k-l+1;\n\t\t\telse \n\t\t\tif ( num[a[mid]] ) {\n\t\t\t\tfor ( k++;a[k]==a[2*mid-k];k++ );\n\t\t\t\tans1 = k-l+1;\n\t\t\t}\telse ans1 = k-l+1 ;\n\t\t\n\t\tLL ans = 0 ;\n\t\tans += (ans0+n-r)*(l-1);\n\t\tans += (n-r)*(ans1);\n\t\tans += ans0+ans1-1;\n\t\tprintf( \"%I64d\\n\",ans );\n\t}\telse {\n\t\tint k , l = 1 , r = n ;\n\t\tfor ( ;a[l]==a[r]&&l<=r;l++,r-- );\n\t\tif ( l>r ) {\n\t\t\tprintf( \"%I64d\\n\",(LL)n*(n+1)/2 );\n\t\t\treturn 0;\n\t\t}\n\t\tLL ans0=0,ans1=0;\n\t\tclear(num,0);\n\t\tfor ( int i=l;i<=r;i++ ) num[a[i]]++ ;\n\t\tfor ( k=r;;k-- ){\n\t\t\tif ( num[a[k]]<2 ) break;\n\t\t\tnum[a[k]] -= 2 ;\n\t\t}\n\t\tif ( k==n/2 ) {\n\t\t\twhile ( a[k]==a[n-k+1] ) k-- ;\n\t\t\tans0 = r-k+1;\n\t\t}\telse ans0 = r-k+1;\n\t\t\n\t\t\n\t\tclear(num,0);\n\t\tfor ( int i=l;i<=r;i++ ) num[a[i]]++ ;\n\t\tfor ( k=l;;k++ ){\n\t\t\tif ( num[a[k]]<2 ) break;\n\t\t\tnum[a[k]] -= 2 ;\n\t\t}\n\t\tif ( k==n/2+1 ){\n\t\t\twhile ( a[k]==a[n-k+1] ) k++ ;\n\t\t\tans1 = k-l+1 ;\n\t\t}\telse ans1 = k-l+1;\n\t\t\n\t\tLL ans=0;\n\t\tans += (l-1)*(ans0+n-r);\n\t\tans += (n-r)*ans1;\n\t\tans += ans0+ans1-1;\n\t\tprintf( \"%I64d\\n\",ans );\n\t}\n\t\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Misha and Palindrome Degree.json",
    "editorial_link": "https://codeforces.com//blog/entry/15743",
    "editorial": "Note that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .\n\nLet's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l,?r] which cover some prefix or suffix of b.\n\nWe need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .\n\nTime complexity: O(n) or .",
    "hint": []
}