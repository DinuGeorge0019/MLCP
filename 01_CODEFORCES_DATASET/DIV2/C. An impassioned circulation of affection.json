{
    "link": "https://codeforces.com//contest/814/problem/C",
    "problemId": "108815",
    "problem_idx": "C",
    "shortId": "814C",
    "contest_number": "814",
    "problem_submissions": {
        "D": [
            27647493,
            27672108,
            27640106,
            27643923,
            27641961,
            27641720,
            27642103,
            27641350,
            27644262,
            27643542,
            27643790,
            27645753,
            27644413,
            27642630,
            27644185,
            27644064,
            27644363,
            27643194,
            27644293,
            27646026
        ],
        "C": [
            27645217,
            27635551,
            27636661,
            27634217,
            27636436,
            27636571,
            27637453,
            27638720,
            27637173,
            27637214,
            27639563,
            27637118,
            27638741,
            27639783,
            27640321,
            27639165,
            27639941,
            27659642,
            27639358,
            27640727,
            27637633
        ],
        "A": [
            27642326,
            27632216,
            27632277,
            27632196,
            27632419,
            27632275,
            27632342,
            27633234,
            27632333,
            27632408,
            27632471,
            27632235,
            27632967,
            27632675,
            27632317,
            27633643,
            27632625,
            27632707,
            27632622,
            27632717
        ],
        "E": [
            27641600,
            27647168,
            27666856,
            27661378,
            27652552,
            27730170,
            27729667,
            27669973,
            27692659
        ],
        "B": [
            27634262,
            27635046,
            27632554,
            27634627,
            27634088,
            27635201,
            27635429,
            27634469,
            27634865,
            27635554,
            27634700,
            27635414,
            27636492,
            27635586,
            27636132,
            27636741,
            27636455,
            27636685,
            27634894
        ]
    },
    "name": "C. An impassioned circulation of affection",
    "statement": "Nadeko’s birthday is approaching! As she decorated the room for the\r\nparty, a long garland of Dianthus-shaped paper pieces was placed on a\r\nprominent part of the wall. Brother Koyomi will like it!Still\r\nunsatisfied with the garland, Nadeko decided to polish it again. The\r\ngarland has pieces numbered from to from left to right, and the -th\r\npiece has a colour , denoted by a lowercase English letter. Nadeko will\r\nrepaint of the pieces to give each of them an arbitrary new colour\r\n(still denoted by a lowercase English letter). After this work, she\r\nfinds out all subsegments of the garland containing pieces of only\r\ncolour Brother Koyomi’s favourite one, and takes the length of the\r\nlongest among them to be the of the garland.For instance, let’s say the\r\ngarland is represented by \"\", and Brother Koyomi’s favourite colour is\r\n\"\". Among all subsegments containing pieces of \"\" only, \"\" is the\r\nlongest, with a length of . Thus the of this garland equals .But problem\r\narises as Nadeko is unsure about Brother Koyomi’s favourite colour, and\r\nhas swaying ideas on the amount of work to do. She has plans on this,\r\neach of which can be expressed as a pair of an integer and a lowercase\r\nletter , meanings of which are explained above. You are to find out the\r\nmaximum achievable after repainting the garland according to each plan.\r\n",
    "solutions": [
        "/*\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nint q[1600][26];\n\nstring s;\n\nint n;\n\nvoid precalc(){\n    for (int k = 1; k <= n; k++)\n        for (int col = 0; col < 26; col++){\n            vector<int> mas;\n            mas.push_back(-1);\n            for (int i = 0; i < n; i++)\n                if (s[i] != col + 'a')\n                    mas.push_back(i);\n            mas.push_back(n);\n            if (mas.size() < k + 2)\n                q[k][col] = n;\n            else\n            for (int i = k; i < mas.size() - 1; i++)\n                q[k][col] = max(q[k][col], mas[i + 1] - mas[i - k] - 1);\n        }\n}\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(\"a.in\");\n    ofstream cout(\"a.out\");\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n >> s;\n    precalc();\n    int zap;\n    cin >> zap;\n    for (int i = 0; i < zap; i++){\n        int k;\n        char col;\n        cin >> k >> col;\n        cout << q[k][col - 'a'] << '\\n';\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "strings",
        "two pointers"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. An impassioned circulation of affection.json",
    "editorial_link": "https://codeforces.com//blog/entry/52449",
    "editorial": "The first thing to notice is that we are only changing other colours to\r\nKoyomiâs favourite one. Furthermore, we wonât create disconnected\r\nsegments of that colour, for thatâs no better than painting just around\r\nthe longest among them.This leads us to a straightforward approach: when\r\nfaced with a query , we check each segment and determine whether itâs\r\npossible to fill this segment with letter , within at most replacements.\r\nThis can be done by finding the number of times occurs in that segment\r\n(denote it by ), and checking whether . But this solution would be too\r\nslow.Since the number of different queries is , we can calculate all\r\nanswers beforehand. For each letter and a segment , weâll be able to\r\nfill the whole segment with within moves. Use this information to update\r\nthe answers, and employing a \"prefix max\" method gives us a time\r\ncomplexity of , where equals . Refer to the code for a possible\r\nimplementation. Find out the solutions and the solutions (some of them\r\nmay get TLE remember to check against maximum data next time!).\r\n",
    "hint": []
}