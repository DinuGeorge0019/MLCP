{
    "link": "https://codeforces.com//contest/1591/problem/F",
    "problemId": "1225718",
    "problem_idx": "F",
    "shortId": "1591F",
    "contest_number": "1591",
    "problem_submissions": {
        "E": [
            138939759,
            138896286,
            138892087,
            138904906,
            138899099,
            138912542,
            138905319,
            138942968,
            138922159,
            138917295,
            138909678,
            138916267,
            138912773,
            142180374,
            138919614,
            138909983,
            141705495,
            138930168,
            138928555,
            138925316,
            138913022,
            138892012,
            138926540,
            138931077,
            138931064,
            138930963,
            138930485,
            138930038,
            138902474,
            138912155
        ],
        "F": [
            138896881,
            138908816,
            138884874,
            138909478,
            138884427,
            138908517,
            138891044,
            138904560,
            138893395,
            138899285,
            138915632,
            142180394,
            138899469,
            138921469,
            138919710,
            138905703,
            138891520,
            138877610,
            138877802,
            138894139
        ],
        "D": [
            138884909,
            138887502,
            138910689,
            138885286,
            138904549,
            138890635,
            138896357,
            138890254,
            138899856,
            138910347,
            138894967,
            142180350,
            138908889,
            138894185,
            138899015,
            138918606,
            138885986,
            138899645,
            138900772
        ],
        "C": [
            138879406,
            138882062,
            138878466,
            138879202,
            138893756,
            138887313,
            138887413,
            138881365,
            138897506,
            138896182,
            138887184,
            142180334,
            138892648,
            138885173,
            138883573,
            138910386,
            138882034,
            138887438,
            138893006,
            138887255
        ],
        "B": [
            138872954,
            138874823,
            138871917,
            138872565,
            138874131,
            138872675,
            138878614,
            138874098,
            138894802,
            138876267,
            138881546,
            142180302,
            138877235,
            138875059,
            138878573,
            138912046,
            138876941,
            138876177,
            138883593,
            138876483
        ],
        "A": [
            138869941,
            138869454,
            138869620,
            138869532,
            138871744,
            138869648,
            138874054,
            138870679,
            138872074,
            138872428,
            138873158,
            142180273,
            138870902,
            138870272,
            138873798,
            138910683,
            138871332,
            138872992,
            138880205,
            138869700
        ]
    },
    "name": "F. Non-equal Neighbours",
    "statement": "You are given an array of n positive integers a_1, a_2,\r\nldots, a_n. Your task is to calculate the number of arrays of n positive\r\nintegers b_1, b_2,\r\nldots, b_n such that: 1\r\nle b_i\r\nle a_i for every i (1\r\nle i\r\nle n), and b_i\r\nneq b_{i+1} for every i (1\r\nle i\r\nle n - 1). The number of such arrays can be very large, so print it\r\nmodulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "// Author: wlzhouzhuan\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\n#define SZ(a) ((int)(a.size()))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\n\nconst int N = 500005;\nconst int mod = 998244353;\n\nint stk[N], top, f[N];\nll sum[N], dp[N], ans;\nint a[N], n;\n\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) a[i] = read();\n  dp[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    ll t = 0;\n    while (top && a[stk[top]] > a[i]) {\n      t += sum[top], t %= mod; \n      ans -= 1ll * (sum[top] % mod) * (a[stk[top]] % mod) % mod;\n      ans %= mod;\n      if (ans < 0) ans += mod;\n      top--;\n    }\n    t += dp[i - 1], t %= mod;\n    stk[++top] = i, sum[top] = t;\n    ans += sum[top] * (a[i] % mod) % mod, ans %= mod;\n    dp[i] = mod - ans;\n//    printf(\"dp[%d] = %lld\\n\", i, dp[i]);\n  }\n  dp[n] = (dp[n] % mod + mod) % mod;\n  printf(\"%lld\\n\", (n & 1 ? (mod - dp[n]) % mod: dp[n]));\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dp",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Non-equal Neighbours.json",
    "editorial_link": "https://codeforces.com//blog/entry/97845",
    "editorial": "Let's solve the problem using the inclusion-exclusion formula. Let the i\n-th property mean that the elements bi\n and bi+1\n are the same. Then for each k=1,\u0085,n?1\n the array is divided into n?k\n consecutive segments, where all the numbers in each of the segments are equal.\n\nNext, we will use the dynamic programming method dp[i][j]\n ?\n we have already split the prefix of the array b\n of length i\n into a number of segments, where j\n denotes the parity of the number of segments.\n\nWe will iterate over the index i=1,\u0085,n\n. Now for each j\n (1?j<i\n) we have to make an update dp[i][0]+=dp[j?1][1]?f(j,i)\n, where f(j,i)\n is the minimum of the numbers in the array a\n on the segment [j,i]\n. Similar to dp[i][1]+=dp[j?1][0]??f(j,i)\n.\n\nWe get the solution with time complexity O(n2)\n. To speed it up to O(n)\n, it is enough to maintain a stack of minimums on the prefix and recalculate dp[i][0/1]\n with it."
}