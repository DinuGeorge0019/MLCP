{
    "link": "https://codeforces.com//contest/75/problem/D",
    "problemId": "400",
    "problem_idx": "D",
    "shortId": "75D",
    "contest_number": "75",
    "problem_submissions": {
        "D": [
            384982,
            385991,
            384525,
            384834,
            384839,
            385091,
            385312,
            385411,
            385305,
            385211,
            385417,
            386039,
            385176,
            384867,
            394964
        ],
        "C": [
            384042,
            383483,
            383576,
            384129,
            383851,
            384490,
            383698,
            383909,
            384477,
            383838,
            383994,
            384507,
            384866,
            384204,
            386282,
            384164
        ],
        "B": [
            383618,
            384106,
            385087,
            383734,
            383356,
            383597,
            384237,
            383641,
            383456,
            385358,
            383400,
            383978,
            384400,
            387215,
            383552,
            383723
        ],
        "A": [
            383049,
            382879,
            382894,
            382934,
            382877,
            382996,
            383262,
            382978,
            383667,
            382943,
            382941,
            383102,
            383157,
            382990,
            383202
        ],
        "E": [
            3910444
        ]
    },
    "name": "D. Big Maximum Sum",
    "statement": "Ahmed and Mostafa used to compete together in many programming contests\r\nfor several years. Their coach Fegla asked them to solve one challenging\r\nproblem, of course Ahmed was able to solve it but Mostafa couldn’t.This\r\nproblem is similar to a standard problem but it has a different format\r\nand constraints.In the standard problem you are given an array of\r\nintegers, and you have to find one or more consecutive elements in this\r\narray where their sum is the maximum possible sum.But in this problem\r\nyou are given small arrays, and you will create one big array from the\r\nconcatenation of one or more instances of the small arrays (each small\r\narray could occur more than once). The big array will be given as an\r\narray of indexes (1-based) of the small arrays, and the concatenation\r\nshould be done in the same order as in this array. Then you should apply\r\nthe standard problem mentioned above on the resulting big array.For\r\nexample let’s suppose that the small arrays are {1, 6, -2}, {3, 3} and\r\n{-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the\r\nactual values in the big array after formatting it as concatenation of\r\nthe small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example\r\nthe maximum sum is 9.Can you help Mostafa solve this problem?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <map>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nlong long n, m;\n\nvector <long long> a[100];\nlong long sum[100], maxp[100], maxs[100], aa[100];\nlong long b[300000];\nlong long k , x;\nint main() {\n  //freopen (\"input.txt\", \"r\", stdin);\n  //freopen (\"output.txt\", \"w\", stdout);\n  cin >> n >> m;\n  for (long long i = 0; i < n; ++i) {\n    cin >> k;\n    for (long long j = 0; j < k; ++j) {\n      cin >> x;\n      a[i].push_back(x);\n    }\n  }\n  for (long long i = 0; i < m; ++i) {\n    cin >> b[i];\n    b[i]--;\n  }\n  for (long long i = 0; i < n; ++i) {\n    sum[i] = 0;\n    maxp[i] = a[i][0];\n    maxs[i] = a[i][a[i].size() - 1];\n    aa[i] = a[i][0];\n    long long ct = aa[i];\n    for (long long j = 1; j < a[i].size(); ++j) {\n      if (a[i][j] > ct + a[i][j]) {\n        ct = a[i][j];\n      } else\n       ct += a[i][j];\n      if (ct > aa[i])\n        aa[i] = ct;\n    }\n    for (long long j = 0; j < a[i].size(); ++j) {\n      sum[i] += a[i][j];\n      if (sum[i] > maxp[i])\n      maxp[i] = sum[i];\n    }\n    long long uu = 0;\n    for (long long j = a[i].size() - 1; j >= 0; --j) {\n      uu += a[i][j];\n      if (uu >= maxs[i])\n        maxs[i] = uu;\n    }\n  }\n  long long ans = aa[b[0]];\n  long long ee = maxs[b[0]];\n  for (long long i = 1; i < m; ++i) {\n    if (ans < aa[b[i]])\n      ans = aa[b[i]];\n    if (ee + maxp[b[i]] > ans)\n      ans = ee + maxp[b[i]];\n    if (ee + sum[b[i]] > ans)\n      ans = ee + sum[b[i]];\n    if (ee + sum[b[i]] > maxs[b[i]])\n      ee = ee + sum[b[i]];\n    else\n      ee = maxs[b[i]];\n\n  }\n  if (ee > ans)\n    ans = ee;\n  cout << ans;\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Big Maximum Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/1715",
    "editorial": "This problem is my favorite one in this problem set. Maybe it will be easier to solve this problem if you know how to solve the standard one.\nBut because we can't construct the big array, so we can't apply the standard solution for this problem.\nLet's see first how to solve the standard problem, the following code solves it for a given array arr with length len:\n\nNow let's solve the big array problem, the first step is to calculate 4 values for each small array:\n1- The total sum of it, let's call it tot.\n2- The maximum sum of 0 or more consecutive elements starting from the first element in the array, let's call it lft.\n3- The maximum sum of 0 or more consecutive elements ending at the last element in the array, let's call it rght.\n4- The maximum sum of 1 or more consecutive elements, let's call it gen.\n\nThe final result will be 1 of 2 cases:\n1- The consecutive elements with the maximum sum will start and end inside the same small array.\n2- The consecutive elements with the maximum sum will start and end inside different small arrays.\n\nFor the first case, we can simply pick the maximum gen for all small arrays which exist in the big array.\nFor the second case, we can apply something similar to the standard solution, we will keep a variable called sum, and it's initialized to 0, this will be the maximum sum of 0 or more consecutive elements ending at the last element in the previous small array. Now for each small array, if the maximum possible sum will end in this small array, so it will be sum+lft and maximize over this value (make sure this will be for 1 or more elements). And we need to update sum to be the maximum of the following 3 values:\n1- sum+tot (we will include all elements of this small array to the old sum).\n2- rght (we will take the maximum sum ending at the last element in the current small array).\n3- 0 (we will not take any elements in sum).\n\nThe running time for this solution will be just for reading the input, in my solutions I have no iterations except for reading the input.",
    "hint": []
}