{"link": "https://codeforces.com//contest/75/problem/D", "problemId": "400", "problem_idx": "D", "shortId": "75D", "contest_number": "75", "problem_submissions": {"D": [384982, 385991, 384525, 384834, 384839, 385091, 385312, 385411, 385305, 385211, 385417, 386039, 385176, 384867, 394964], "C": [384042, 383483, 383576, 384129, 383851, 384490, 383698, 383909, 384477, 383838, 383994, 384507, 384866, 384204, 386282, 384164], "B": [383618, 384106, 385087, 383734, 383356, 383597, 384237, 383641, 383456, 385358, 383400, 383978, 384400, 387215, 383552, 383723], "A": [383049, 382879, 382894, 382934, 382877, 382996, 383262, 382978, 383667, 382943, 382941, 383102, 383157, 382990, 383202], "E": [3910444]}, "name": "D. Big Maximum Sum", "statement": "Ahmed and Mostafa used to compete together in many programming contests\r\nfor several years. Their coach Fegla asked them to solve one challenging\r\nproblem, of course Ahmed was able to solve it but Mostafa couldn\u2019t.This\r\nproblem is similar to a standard problem but it has a different format\r\nand constraints.In the standard problem you are given an array of\r\nintegers, and you have to find one or more consecutive elements in this\r\narray where their sum is the maximum possible sum.But in this problem\r\nyou are given small arrays, and you will create one big array from the\r\nconcatenation of one or more instances of the small arrays (each small\r\narray could occur more than once). The big array will be given as an\r\narray of indexes (1-based) of the small arrays, and the concatenation\r\nshould be done in the same order as in this array. Then you should apply\r\nthe standard problem mentioned above on the resulting big array.For\r\nexample let\u2019s suppose that the small arrays are {1, 6, -2}, {3, 3} and\r\n{-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the\r\nactual values in the big array after formatting it as concatenation of\r\nthe small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example\r\nthe maximum sum is 9.Can you help Mostafa solve this problem?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <map>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nlong long n, m;\n\nvector <long long> a[100];\nlong long sum[100], maxp[100], maxs[100], aa[100];\nlong long b[300000];\nlong long k , x;\nint main() {\n  //freopen (\"input.txt\", \"r\", stdin);\n  //freopen (\"output.txt\", \"w\", stdout);\n  cin >> n >> m;\n  for (long long i = 0; i < n; ++i) {\n    cin >> k;\n    for (long long j = 0; j < k; ++j) {\n      cin >> x;\n      a[i].push_back(x);\n    }\n  }\n  for (long long i = 0; i < m; ++i) {\n    cin >> b[i];\n    b[i]--;\n  }\n  for (long long i = 0; i < n; ++i) {\n    sum[i] = 0;\n    maxp[i] = a[i][0];\n    maxs[i] = a[i][a[i].size() - 1];\n    aa[i] = a[i][0];\n    long long ct = aa[i];\n    for (long long j = 1; j < a[i].size(); ++j) {\n      if (a[i][j] > ct + a[i][j]) {\n        ct = a[i][j];\n      } else\n       ct += a[i][j];\n      if (ct > aa[i])\n        aa[i] = ct;\n    }\n    for (long long j = 0; j < a[i].size(); ++j) {\n      sum[i] += a[i][j];\n      if (sum[i] > maxp[i])\n      maxp[i] = sum[i];\n    }\n    long long uu = 0;\n    for (long long j = a[i].size() - 1; j >= 0; --j) {\n      uu += a[i][j];\n      if (uu >= maxs[i])\n        maxs[i] = uu;\n    }\n  }\n  long long ans = aa[b[0]];\n  long long ee = maxs[b[0]];\n  for (long long i = 1; i < m; ++i) {\n    if (ans < aa[b[i]])\n      ans = aa[b[i]];\n    if (ee + maxp[b[i]] > ans)\n      ans = ee + maxp[b[i]];\n    if (ee + sum[b[i]] > ans)\n      ans = ee + sum[b[i]];\n    if (ee + sum[b[i]] > maxs[b[i]])\n      ee = ee + sum[b[i]];\n    else\n      ee = maxs[b[i]];\n\n  }\n  if (ee > ans)\n    ans = ee;\n  cout << ans;\n  return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dp", "greedy", "implementation", "math", "trees"], "dificulty": "2000", "interactive": false}