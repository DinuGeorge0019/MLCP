{
    "link": "https://codeforces.com//contest/110/problem/E",
    "problemId": "581",
    "problem_idx": "E",
    "shortId": "110E",
    "contest_number": "110",
    "problem_submissions": {
        "E": [
            647829,
            649167,
            646023,
            646546,
            645768,
            647440,
            646441,
            647692,
            647579,
            647730,
            647778,
            648074,
            648205,
            648643,
            672231,
            648607
        ],
        "D": [
            646207,
            648016,
            1801308,
            650206,
            650204,
            650149,
            645758,
            648839,
            651051,
            646617,
            672309,
            672304
        ],
        "C": [
            644127,
            643544,
            644243,
            643865,
            645241,
            644451,
            644887,
            644131,
            644140,
            645305,
            644925,
            643505,
            644385,
            643763,
            644812,
            644362,
            644073,
            643923
        ],
        "B": [
            643233,
            642711,
            643039,
            643416,
            643607,
            643662,
            644238,
            643262,
            643508,
            644064,
            644105,
            643023,
            643503,
            644212,
            644124,
            643915,
            643258,
            643069
        ],
        "A": [
            642482,
            642215,
            642278,
            642632,
            643064,
            642636,
            643448,
            642358,
            642849,
            643249,
            642539,
            642283,
            642426,
            642982,
            643205,
            642425,
            642448,
            642447
        ]
    },
    "name": "E. Lucky Tree",
    "statement": "One day Petya encountered a tree with vertexes. Besides, the tree was\r\nweighted, i. e. each edge of the tree has weight (a positive integer).\r\nAn edge is lucky if its weight is a lucky number. Note that a is an\r\nundirected connected graph that has exactly edges.Petya wondered how\r\nmany vertex triples exists that on the way from to , as well as on the\r\nway from to there must be at least one lucky edge (all three vertexes\r\nare pairwise distinct). The order of numbers in the triple matters, that\r\nis, the triple is not equal to the triple and is not equal to the triple\r\n. Find how many such triples of vertexes exist.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 100010;\nvector<pair<int,int> > E[MAXN];\nint vis[MAXN];\nint dp1[MAXN], dp2[MAXN], sz[MAXN];\nint N;\nint ROOT = 0;\n\ninline int lucky(int x)\n{\n    do{ \n        if(x%10 != 4 && x%10 != 7) return 0;\n        x /= 10;\n    } while(x);\n    return 1;\n}\n\nvoid dfs1(int u)\n{\n    vis[u] = 1;\n    sz[u] = 1;\n    for(int i = 0; i < E[u].size(); i++){\n        int v = E[u][i].first;\n        if(!vis[v]){\n            dfs1(v);\n            sz[u] += sz[v];\n            if(E[u][i].second) dp1[u] += sz[v];\n            else dp1[u] += dp1[v];\n        }\n    }\n}\n\nvoid dfs2(int u, int s)\n{\n    vis[u] = 1;\n    dp2[u] = dp1[u] + s;\n    for(int i = 0; i < E[u].size(); i++){\n        int v= E[u][i].first;\n        if(!vis[v]){\n            int ts;\n            if(E[u][i].second) ts = sz[ROOT]-sz[v];\n            else ts = dp2[u]-dp1[v];\n            dfs2(v, ts);\n        }\n    }\n}\n\nint main()\n{\n    int u, v, w;\n    while(~scanf(\"%d\", &N)) {\n        for(int i = 0; i < N; i++)\n            E[i].clear(), dp1[i] = dp2[i] = 0, sz[i] = 1;\n        for(int i = 0; i < N-1; i++){\n            scanf(\"%d%d%d\", &u, &v, &w), u--, v--;\n            w = lucky(w);\n            E[u].push_back(make_pair(v,w)), E[v].push_back(make_pair(u,w));\n        }\n        memset(vis, 0, sizeof(vis));\n        dfs1(ROOT);\n        memset(vis, 0, sizeof(vis));\n        dfs2(ROOT, 0);\n        long long ans = 0;\n        for(int i = 0; i < N; i++){\n//            cout << sz[i] << \" \" << dp1[i] << \" \" << dp2[i] << endl;\n            if(dp2[i] >= 2) ans += (long long)dp2[i]*(dp2[i]-1);\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Lucky Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/2547",
    "editorial": "Solve this problem using dynamic programming. Consider that root of a tree is vertex with number 1. Let F(x) - number of vertex in subtree of vertex x for which there is a path containing lucky edge. We will calculate F(x) using recursion. If x is a leaf, than F(x)?=?0. Else, if there is an edge from x that leads to y and this edge is lucky, then to F(x) we need to add C(y), otherwise we add F(y), here C(y) - number of vertex in subtree of y, including y. But, to solve this problem we need to know also F'(x) - number of vertex which are not in subtree of x and there exits a path from x to that vertex that contains lucky edge. For a root of tree, F'(x) equals to 0. We should go recursive from root, and if we are in vertex x now, we suppose that F'(x) is already calculated. If from x we can directly go to y and that edge is lucky, then F'(y)?=?C(0)?-?C(y), otherwise F'(y)?=?F'(x)?+?F(x)?-?F(y).\n\nAfter that, result equals to .",
    "hint": []
}