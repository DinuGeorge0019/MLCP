{
    "link": "https://codeforces.com//contest/898/problem/F",
    "problemId": "139119",
    "problem_idx": "F",
    "shortId": "898F",
    "contest_number": "898",
    "problem_submissions": {
        "F": [
            33307844,
            33307069,
            33308143,
            33307333,
            33304725,
            33309674,
            33307617,
            33324444,
            33463766,
            33463739
        ],
        "E": [
            33298700,
            33298827,
            33296850,
            33298062,
            33299543,
            33301231,
            33302052,
            33295023,
            33295557,
            33302644,
            33297022,
            33300051,
            33297188,
            33300909,
            33298325,
            33294157,
            33299352
        ],
        "D": [
            33295484,
            33296274,
            33295804,
            33295438,
            33296979,
            33297889,
            33299897,
            33296885,
            33293153,
            33301610,
            33299195,
            33297291,
            33294317,
            33297559,
            33296082,
            33292010,
            33295516
        ],
        "C": [
            33293049,
            33292838,
            33294192,
            33293208,
            33294387,
            33295591,
            36631893,
            33298752,
            33292900,
            33291380,
            33326974,
            33293057,
            33293412,
            33294345,
            33292038,
            33294840,
            33294194,
            33298225,
            33297034
        ],
        "B": [
            33288797,
            33294236,
            33289524,
            33296573,
            33305320,
            33291082,
            33290611,
            33289720,
            33288149,
            33288790,
            33289877,
            33289821,
            33288702,
            33290526,
            33291731,
            33294974,
            33291014
        ],
        "A": [
            33287337,
            33293381,
            33287422,
            33296068,
            33304988,
            33288124,
            33288589,
            33287509,
            33287292,
            33287275,
            33287989,
            33287858,
            33287278,
            33288680,
            33290739,
            33295465,
            33288106
        ]
    },
    "name": "F. Restoring the Expression",
    "statement": "A correct expression of the form was written; , and are non-negative\r\nintegers without leading zeros. In this expression, the plus and equally\r\nsigns were lost. The task is to restore the expression. In other words,\r\none character \u201d and one character \u201d should be inserted into given\r\nsequence of digits so that: character\u201d is placed on the left of\r\ncharacter \u201d, characters \u201d and \u201d split the sequence into three non-empty\r\nsubsequences consisting of digits (let\u2019s call the left part , the middle\r\npart and the right part ), all the three parts , and do not contain\r\nleading zeros, it is true that . It is guaranteed that in given tests\r\nanswer always exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define ll long long\n\nusing namespace std;\n\nconst int N = int(1e6) + 10;\nconst int mod1 = int(1e9) + 21, mod2 = int(1e9) + 5133, base1 = 10, base2 = 10;\n\nll h1[N],h2[N],p1[N],p2[N];\nint n;\nchar s[N];\n\nll hash1(int l,int r){\n\tll res = (h1[r] - h1[l-1] * p1[r-l+1]) % mod1;\n\tif(res < 0) res += mod1;\n\treturn res;\n}\n\nll hash2(int l,int r){\n\tll res = (h2[r] - h2[l-1] * p2[r-l+1]) % mod2;\n\tif(res < 0) res += mod2;\n\treturn res;\n}\n\nbool check(int j,int a,int b){\n\tif(a <= 0 || b <= 0) return 0;\n\tif(max(a,b) > (n - j + 1)) return 0;\n\tif(s[1] == '0' && a > 1) return 0;\n\tif(s[a + 1] == '0' && b > 1) return 0;\n\tif(s[a + b + 1] == '0' && (n - j + 1) > 1) return 0;\n\tif((hash1(1,a) + hash1(a + 1,a + b)) % mod1 != hash1(a + b + 1, n)) return 0;\n\tif((hash2(1,a) + hash2(a + 1,a + b)) % mod2 != hash2(a + b + 1, n)) return 0;\n\tfor(int i = 1; i <= a; i++){\n\t\tputchar(s[i]);\n\t}\n\tputchar('+');\n\tfor(int i = a + 1; i <= a + b; i++){\n\t\tputchar(s[i]);\n\t}\n\tputchar('=');\n\tfor(int i = a + b + 1; i <= n; i++){\n\t\tputchar(s[i]);\n\t}\n\texit(0);\n}\n\nint main () {\n\tscanf(\"%s\",s + 1);\n\tn = strlen(s + 1);\n\tp1[0] = p2[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\th1[i] = (h1[i - 1] * base1 + s[i] - '0') % mod1;\n\t\th2[i] = (h2[i - 1] * base2 + s[i] - '0') % mod2;\n\t\tp1[i] = p1[i - 1] * base1 % mod1;\n\t\tp2[i] = p2[i - 1] * base2 % mod2;\n\t\tif(h1[i] < 0) h1[i] += mod1;\n\t\tif(h2[i] < 0) h2[i] += mod2;\n\t}\n\tint len = 0;\n\tfor(int j = 3; j <= n; j++){\n\t\tlen = (n - j + 1);\n\t\tcheck(j, len, n - len - len);\n\t\tcheck(j, len - 1, n - len - len + 1);\n\t\tcheck(j, n - len - len, len);\n\t\tcheck(j, n - len - len + 1, len - 1);\n\t}\nreturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "hashing",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Restoring the Expression.json",
    "editorial_link": "https://codeforces.com//blog/entry/56381",
    "editorial": "At first we should calculate \"hash\" by big prime module from the given\r\nstring, and the base must be equal to because we work with numbers. We\r\ncan use prime module about , if we will use multiple of long longs by\r\nmodule with help of long doubles.After that we will brute the length of\r\nthe result of summation, let this value is . Because when two numbers\r\nare added the result may have the same length as the larger term, or may\r\nhave a length one greater than the length of the larger term it is\r\nenough to check the following cases ( the length of the first term, the\r\nlength of the second term): , , , , For each case the check algorithm is\r\nthe same. At first we should check that all parts have positive length,\r\nthat the length satisfies the conditions described at the beginning of\r\nthe tutorial and that it part has no trailing spaces.Now we should\r\ndivide each part on in the needed power, to bring the value of the\r\ncalculated \"hash\" to the desired degree. To make it we can multiply each\r\npart on element, which is reverse to by the used module, in the desired\r\npower. To find which is reverse to be the prime module we should raising\r\nto the power with help of binary power raising.If after the described\r\noperations the sum of first to parts by used module equals to the value\r\nof third part, we found the answer and we should print corresponding\r\nparts.You could also perform calculations on several smaller modules.\r\n"
}