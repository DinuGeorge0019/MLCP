{
    "link": "https://codeforces.com//contest/1937/problem/C",
    "problemId": "2503241",
    "problem_idx": "C",
    "shortId": "1937C",
    "contest_number": "1937",
    "problem_submissions": {
        "E": [
            250576191,
            250576177,
            248956893,
            248968788,
            248957297,
            248966672,
            249441680,
            249396118,
            248946403,
            248968676,
            250133778
        ],
        "D": [
            248945664,
            248934669,
            248940205,
            248942769,
            248942389,
            248945370,
            250100307,
            248949877,
            248955428,
            248958358,
            248955920,
            248959000,
            248953793,
            248954441,
            248955304,
            248954744,
            248950479,
            248956622
        ],
        "C": [
            248925723,
            248918003,
            248945269,
            248925093,
            248927475,
            248916202,
            248925097,
            248924482,
            248928585,
            248926397,
            248923906,
            248930862,
            248927119,
            248930899,
            248930534,
            249020336,
            248929752,
            248931403,
            248935918,
            248933256
        ],
        "B": [
            248910702,
            248909576,
            248913624,
            248915352,
            248915231,
            248904510,
            248914972,
            248915980,
            248915024,
            248914144,
            248910066,
            248915252,
            248914074,
            248914693,
            248914679,
            249015802,
            248915248,
            248914394,
            248908476,
            248910261
        ],
        "A": [
            248903051,
            248903069,
            248903106,
            248903549,
            248904708,
            248903046,
            248903582,
            248903569,
            248903261,
            248903372,
            248905387,
            248903521,
            248905435,
            248904180,
            248904557,
            248904753,
            248904311,
            248904712,
            248903327
        ],
        "F": [
            250203263
        ]
    },
    "name": "C. Bitwise Operation Wizard",
    "statement": "There is a secret sequence p_0, p_1,\r\nldots, p_{n-1}, which is a permutation of\r\n{0,1,\r\nldots,n-1\r\n}.You need to find any two indices i and j such that p_i\r\noplus p_j is maximized, where\r\noplus denotes the bitwise XOR operation.To do this, you can ask queries.\r\nEach query has the following form: you pick arbitrary indices a, b, c,\r\nand d (0\r\nle a,b,c,d < n). Next, the jury calculates x = (p_a\r\nmid p_b) and y = (p_c\r\nmid p_d), where | denotes the bitwise OR operation. Finally, you receive\r\nthe result of comparison between x and y. In other words, you are told\r\nif x < y, x > y, or x = y.Please find any two indices i and j (0\r\nle i,j < n) such that p_i\r\noplus p_j is maximum among all such pairs, using at most 3n queries. If\r\nthere are multiple pairs of indices satisfying the condition, you may\r\noutput any one of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x first\n#define y second\n// #define int long long\n#define mp(x, y) make_pair(x, y)\n#define eb(...) emplace_back(__VA_ARGS__)\n#define fro(i, x, y) for(int i = (x); i <= (y); i++)\n#define pre(i, x, y) for(int i = (x); i >= (y); i--)\ninline void JYFILE19();\n\ntypedef int64_t i64;\ntypedef pair<int, int> PII;\n\nbool ST;\nconst int N = 1e6 + 10;\n\nint n, m;\n\ninline int ask(int a, int b, int c, int d) {\n  cout << \"? \" << a << \" \" << b << \" \" << c << \" \" << d << endl;\n  char x; cin >> x;\n  if(x == '>') return 2;\n  if(x == '<') return 1;\n  if(x == '=') return 0;\n}\ninline void solve() {\n  cin >> n;\n  int mx = 0;\n  vector<int> res;\n  fro(i, 1, n - 1) {\n    int v = ask(mx, mx, i, i);\n    if(v == 1) mx = i;\n  }\n  int mi = 0; res.eb(mi);\n  fro(i, 1, n - 1) {\n    int v = ask(mx, mi, mx, i);\n    if(v == 1) {\n      res.clear();\n      res.eb(i), mi = i;\n    }\n    if(v == 0) {\n      res.eb(i);\n    }\n  }\n  int ot = res[0];\n  m = res.size();\n  fro(i, 1, m - 1) {\n    int v = ask(ot, ot, res[i], res[i]);\n    if(v == 2) ot = res[i];\n  }\n  cout << \"! \" << mx << \" \" << ot << endl;\n}\n\nsigned main() {\n  JYFILE19();\n  int t; cin >> t;\n  while(t--) {\n    solve();\n  }\n  return 0;\n}\nbool ED;\ninline void JYFILE19() {\n  // freopen(\"\", \"r\", stdin);\n  // freopen(\"\", \"w\", stdout);\n  ios::sync_with_stdio(0), cin.tie(0);\n  double MIB = fabs((&ED-&ST)/1048576.), LIM = 125;\n  cerr << \"MEMORY: \" << MIB << endl, assert(MIB<=LIM);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "interactive"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Bitwise Operation Wizard.json",
    "editorial_link": "https://codeforces.com//blog/entry/126513",
    "editorial": "Step1:do queries ? x x y y\n like classic searching for the maximum value among n\n numbers to get pi=n?1\n;\n\nStep2:do queries ? x i y i\n to find all index k\n such that pi|pk\n reaches the maximum value. We store all such indexes in a vector id\n .\n\nStep3:do queries ? id[x] id[x] id[y] id[y]\n to find j\n in id\n such that pj\n reaches the minimum value."
}