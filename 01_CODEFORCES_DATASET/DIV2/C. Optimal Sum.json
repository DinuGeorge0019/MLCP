{"link": "https://codeforces.com//contest/182/problem/C", "problemId": "1268", "problem_idx": "C", "shortId": "182C", "contest_number": "182", "problem_submissions": {"C": [1663733, 1663728, 1623940, 1623119, 1624114, 1624504, 1624399, 1622980, 1643406, 10562948], "E": [1624193, 1623067, 1622067, 1624242, 1623079, 1622816, 1625915, 1622385, 1624996, 1622444, 1622634], "D": [1623370, 1620768, 1625829, 1625101, 1620935, 1627627, 1625879, 1620500, 1624702, 1623228, 1623926, 1620648, 1625035, 1621025, 1621358], "B": [1622937, 1621227, 1620887, 1620496, 1621242, 1620438, 1620699, 1620796, 1623576, 1623718, 1620257, 1623264, 1620331, 1620463], "A": [1622661, 1624396, 1623052, 1628460, 1622766, 1623550, 1622930]}, "name": "C. Optimal Sum", "statement": "And here goes another problem on arrays. You are given positive integer\r\nand array which consists of integers , , ..., . Let\u2019s introduce two\r\ncharacteristics for the given array. Let\u2019s consider an arbitrary\r\ninterval of the array with length , starting in position . Value , is\r\nthe on the chosen interval. In other words, the modular sum is the sum\r\nof integers on the chosen interval with length , taken in its absolute\r\nvalue. Value is the of the array. In other words, the optimal sum of an\r\narray is the maximum of all modular sums on various intervals of array\r\nwith length . Your task is to calculate the optimal sum of the given\r\narray . However, before you do the calculations, you are allowed to\r\nproduce than consecutive operations of the following form with this\r\narray: one operation means taking an arbitrary number from array and\r\nmultiply it by -1. In other words, no more than times you are allowed to\r\ntake an arbitrary number from the array and replace it with . Each\r\nnumber of the array is allowed to choose an arbitrary number of\r\ntimes.Your task is to calculate the maximum possible optimal sum of the\r\narray after at most operations described above are completed.\r\n", "solutions": ["#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <string.h>\n#include <sstream>\n#define _USE_MATH_DEFINES\n#define fo(i,n) for(i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define sz(x) x.size()\nusing namespace std;\n\ntypedef long long ll;\n\nenum colour {BLACK, RED};\n\ntemplate <class data>\n\nclass redblack\n{\npublic:\n    redblack *left, *right, *par;\n    int subTreeSize;\n    colour color;\n    data compVal;\n\n    data subTreeSum;\n    data sumOfMax(int k)\n    {\n        if (subTreeSize <= k) return subTreeSum;\n        ll ret = 0;\n        if (right != NULL)\n            {\n                ret += right->sumOfMax(k);\n                k -= right->subTreeSize;\n            }\n        if (k <= 0) return ret;\n        ret += compVal * min(k, nodeSize());\n        k -= nodeSize();\n        if (k <= 0) return ret;\n        ret += left->sumOfMax(k);\n        return ret;\n    }\n\n    redblack* root()\n    {\n        if (par != NULL) return par->root();\n        return this;\n    }\n    \n    static redblack* create()\n    {\n        redblack *tree = new redblack();\n        return tree;\n    }\n    \n    int nodeSize()\n    {\n        return sz(values);\n    }\n\n    vector < data > getValues()\n    {\n        return values;\n    }\n\n    redblack find(data val)\n    {\n        if (isNil) return NULL;\n        if (compVal == val) return this;\n        redblack next = getNext(val);\n        if (next == NULL) return NULL;\n        return next.find(val);\n    }\n\n    redblack* treeMin()\n    {\n        if (left == NULL) return this;\n        return treeMin(left);\n    }\n\n    redblack* treeMax()\n    {\n        if (right == NULL) return this;\n        return treeMax(right);\n    }\n\n    redblack* succesor()\n    {\n        if (isNil) return NULL;\n        if (right != NULL) return treeMin(right);\n        redblack *pr = par, *ptr = this;        \n        while(pr != NULL && ptr == pr->right)\n            {\n                ptr = pr;\n                pr = ptr->par;\n            }\n        return pr;\n    }\n\n    redblack* predecessor()\n    {\n        if (isNil) return NULL;\n        if (left != NULL) return treeMax(left);\n        redblack *pr = par, *ptr = this;        \n        while(pr != NULL && ptr == pr->left)\n            {\n                ptr = pr;\n                pr = ptr->par;\n            }\n        return pr;\n    }\n\n    bool remove(data val)\n    {\n        if (isNil) return false;\n        if (compVal == val)\n            {\n                if (sz(values))\n                    {\n                        values.pop_back();\n                        subTreeSize--;\n                        subTreeSum -= val;\n                        return true;\n                    }\n                return false;\n            }\n        redblack *next = getNext(val);\n        if (next == NULL) return false;\n        bool deleted = next->remove(val);\n        if (deleted)\n            {\n                subTreeSize--;\n                subTreeSum -= val;\n            }\n        return deleted;\n    }\n\n    redblack* insert(data val)\n      {\n          if (isNil)\n              {\n                  isNil = false;\n                  par = left = right = NULL;\n                  compVal = val;\n                  values.pb(val);\n                  subTreeSize = 1;                  \n                  subTreeSum = val;\n                  color = BLACK;\n                  return this;\n              }\n          if (compVal == val)\n              {\n                  values.pb(val);\n                  subTreeSize++;\n                  subTreeSum += val;\n                  return this;\n              }\n          redblack *next = getNext(val);\n          if (next == NULL)\n              {\n                  redblack *node = new redblack(this, val);\n                  if (val > compVal) right = node; else left = node;\n                  subTreeSize++;\n                  subTreeSum += val;\n                  return node;\n              }\n          redblack *inserted = next->insert(val);\n          subTreeSize++;\n          subTreeSum += val;\n          if (par == NULL) inserted->insertBalance();\n          return inserted;              \n      }\n\n    redblack* getNext(data val)\n    {\n        if (compVal > val) return left;\n        return right;\n    }\n\n    void clear()\n    {\n        if (left != NULL) left->clear();\n        if (right != NULL) right->clear();\n        delete(this);\n    }\n\nprivate:\n    bool isNil;\n    vector < data > values;\n\n    redblack()\n    {\n        par = left = right = NULL;\n        isNil = true;\n        color = RED;\n        subTreeSize = 0;\n        subTreeSum = 0;\n    }\n\n    redblack(redblack *parent, data val)\n    {\n        left = right = NULL;        \n        par = parent;\n        isNil = false;\n        color = RED;\n        compVal = val;\n        values.pb(val);\n        subTreeSize = 1;\n        subTreeSum = val;\n    }\n\n    void rightRotate()\n    {\n        redblack *x = this, *y = x->left;\n        if (x -> isNil || y == NULL || y->isNil) return;\n        x->left = y->right;\n        if (y->right != NULL) y->right->par = x;\n        y->par = x->par;\n        if (x->par != NULL)\n            {\n                if (x->par->left == x) x->par->left = y;\n                else x->par->right = y;\n            }\n        y->right = x;\n        x->par = y;\n        y->subTreeSize = x->subTreeSize;\n        x->subTreeSize = x->nodeSize() + ((x->left != NULL)?x->left->subTreeSize:0) + ((x->right != NULL)?x->right->subTreeSize:0);\n        y->subTreeSum = x->subTreeSum;\n        x->subTreeSum = x->nodeSize()*x->compVal + ((x->left != NULL)?x->left->subTreeSum:0) + ((x->right != NULL)?x->right->subTreeSum:0);\n    }\n\n    void leftRotate()\n    {\n        redblack *x = this, *y = x->right;\n        if (x->isNil || y == NULL || y->isNil ) return;\n        x->right = y->left;\n        if (y->left != NULL) y->left->par = x;\n        y->par = x->par;\n        if (x->par != NULL)\n            {\n                if (x->par->left == x) x->par->left = y;\n                else x->par->right = y;\n            }\n        y->left = x;\n        x->par = y;\n        y->subTreeSize = x->subTreeSize;\n        x->subTreeSize = x->nodeSize() + ((x->left != NULL)?x->left->subTreeSize:0) + ((x->right != NULL)?x->right->subTreeSize:0);\n        y->subTreeSum = x->subTreeSum;\n        x->subTreeSum = x->nodeSize()*x->compVal + ((x->left != NULL)?x->left->subTreeSum:0) + ((x->right != NULL)?x->right->subTreeSum:0);\n    }\n\n    void insertBalance()\n    {\n        redblack *x = this, *y;\n        \n        while(x->par != NULL && x->par->color == RED)\n            {\n                if (x->par->par == NULL) return;\n                if (x->par == x->par->par->left)\n                    {\n                        y = x->par->par->right;\n                        if (y != NULL && y->color == RED)\n                            {\n                                x->par->color = y->color = BLACK;\n                                x->par->par->color = RED;\n                                x = x->par->par;\n                            }\n                        else\n                            {\n                                if (x == x->par->right)\n                                    {\n                                        x = x->par;\n                                        x->leftRotate();\n                                    }\n                                x->par->color = BLACK;\n                                x->par->par->color = RED;\n                                x->par->par->rightRotate();\n                            }\n                    }\n                else\n                    {\n                        y = x->par->par->left;    \n                        if (y != NULL && y->color == RED)\n                            {\n                                x->par->color = y->color = BLACK;\n                                x->par->par->color = RED;\n                                x = x->par->par;\n                            }\n                        else\n                            {\n                                if (x == x->par->left)\n                                    {\n                                        x = x->par;\n                                        x->rightRotate();\n                                    }\n                                x->par->color = BLACK;\n                                x->par->par->color = RED;\n                                x->par->par->leftRotate();\n                            }\n                    }\n            }\n        this->root()->color = BLACK;\n    }\n};\n\nint n, len, k;\nint a[200000];\n\nll solve()\n{\n    ll ret = 0, posSum = 0;\n    int i;\n    redblack<ll> *tree = redblack<ll>::create();\n    fo(i,(len-1))\n        {\n            if (a[i] < 0) tree->root()->insert(-a[i]); else posSum += a[i];\n        }\n    for(i = len-1; i < n; i++)\n        {\n            if (a[i] < 0) tree->root()->insert(-a[i]); else posSum += a[i];\n            ll maxTreeSum = tree->root()->sumOfMax(k);\n            ll noChange = tree->root()->subTreeSum - maxTreeSum;\n            ret = max(ret, maxTreeSum + posSum - noChange);\n            if (a[i + 1 - len] < 0) tree->root()->remove(-a[i + 1 - len]); else posSum -= a[i + 1 - len];\n        }\n    tree->root()->clear();\n    return ret;\n}\n\nint main(void)\n{\n    int i;\n    cin >> n >> len;\n    fo(i,n)\n        {\n            cin >> a[i];\n        }\n    cin >> k;\n\n    ll ans = 0;\n    ans = max(ans, solve());\n    fo(i,n)\n        {\n            a[i] = -a[i];\n        }\n    ans = max(ans, solve());\n    cout << ans << endl;\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "2000", "interactive": false}