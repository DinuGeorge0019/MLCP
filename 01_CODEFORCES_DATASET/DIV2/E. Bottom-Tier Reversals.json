{"link": "https://codeforces.com//contest/1561/problem/E", "problemId": "1088961", "problem_idx": "E", "shortId": "1561E", "contest_number": "1561", "problem_submissions": {"F": [126904536, 126901655, 126903407, 126897889, 126905462, 126895857, 126909746, 126868411], "E": [126872829, 126873450, 126873472, 126876837, 126887119, 126925237, 126873365, 126880329, 126880730, 126881569, 126878334, 126883106, 126884943, 126885452, 126887344, 126884906, 126885650, 126888199, 126863450], "C": [126869012, 126865542, 126864086, 126863127, 126863122, 126861060, 126868974, 126853568, 126857674, 126857569, 126854957, 126857844, 126858666, 126860889, 126860513, 126857734, 126864125, 126867660, 126866693], "D1": [126861759, 126863688, 126864717, 126869692, 126872900, 126868199, 126862491, 126866683, 126868762, 126864055, 126863339, 126863270, 126867571, 126865653, 126863522, 126870959, 126872615, 126860538, 126862556], "D2": [126861568, 126863750, 126868373, 126869562, 126876457, 126868351, 126862413, 126873746, 126868674, 126867473, 126864201, 126863508, 126868989, 126866379, 126880112, 126871782, 126872752, 126861102, 126877754], "B": [126856962, 126852931, 126853927, 126857335, 126862047, 126855473, 126854073, 126848963, 126854204, 126852816, 126866896, 126854673, 126855023, 126857298, 126855876, 126863677, 126859086, 126871391, 126876744], "A": [126847903, 126848403, 126847412, 126849843, 126849112, 126848036, 126848332, 126847281, 126847584, 126847566, 126847516, 126847717, 126847410, 126847430, 126850448, 126848322, 126849200, 126856163, 126853136]}, "name": "E. Bottom-Tier Reversals", "statement": "You have a permutation: an array a = [a_1, a_2,\r\nldots, a_n] of distinct integers from 1 to n. The length of the\r\npermutation n is odd.You need to sort the permutation in increasing\r\norder.In one step, you can choose any prefix of the permutation with an\r\nodd length and reverse it. Formally, if a = [a_1, a_2,\r\nldots, a_n], you can choose any odd integer p between 1 and n,\r\ninclusive, and set a to [a_p, a_{p-1},\r\nldots, a_1, a_{p+1}, a_{p+2},\r\nldots, a_n].Find a way to sort a using no more than\r\nfrac{5n}{2} reversals of the above kind, or determine that such a way\r\ndoesn\u2019t exist. The number of reversals doesn\u2019t have to be minimized.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nint n,a[2025];\nint find(int x,int up)\n{\n\tfor(int i=1;i<=up;++i)\tif(a[i]==x)\treturn i;\n\treturn -1;\n}\nvoid Solve()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;++i)\tif((i&1)^(a[i]&1))\t{puts(\"-1\");return ;}\n\tvector<int> Ans;\n\tfor(int i=n;i>=3;i-=2)\n\t{\n\t\tint pos=find(i,i);\n\t\tassert(pos!=-1);\n\t\tAns.push_back(pos);\n\t\treverse(a+1,a+1+pos);\n\t\tpos=find(i-1,i);\n\t\tAns.push_back(pos-1); //It's impossible to make pos-1=0\n\t\treverse(a+1,a+pos);\n\t\tAns.push_back(pos+1);\n\t\treverse(a+1,a+pos+2);\n\t\tAns.push_back(3);\n\t\tswap(a[1],a[3]);\n\t\tAns.push_back(i);\n\t\treverse(a+1,a+1+i);\n\t}\n\tprintf(\"%d\\n\",int(Ans.size()));\n\tfor(auto st:Ans)\tprintf(\"%d \",st);\n\tputs(\"\");\n}\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0)\tSolve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "2000", "interactive": false}