{
    "link": "https://codeforces.com//contest/1561/problem/E",
    "problemId": "1088961",
    "problem_idx": "E",
    "shortId": "1561E",
    "contest_number": "1561",
    "problem_submissions": {
        "F": [
            126904536,
            126901655,
            126903407,
            126897889,
            126905462,
            126895857,
            126909746,
            126868411
        ],
        "E": [
            126872829,
            126873450,
            126873472,
            126876837,
            126887119,
            126925237,
            126873365,
            126880329,
            126880730,
            126881569,
            126878334,
            126883106,
            126884943,
            126885452,
            126887344,
            126884906,
            126885650,
            126888199,
            126863450
        ],
        "C": [
            126869012,
            126865542,
            126864086,
            126863127,
            126863122,
            126861060,
            126868974,
            126853568,
            126857674,
            126857569,
            126854957,
            126857844,
            126858666,
            126860889,
            126860513,
            126857734,
            126864125,
            126867660,
            126866693
        ],
        "D1": [
            126861759,
            126863688,
            126864717,
            126869692,
            126872900,
            126868199,
            126862491,
            126866683,
            126868762,
            126864055,
            126863339,
            126863270,
            126867571,
            126865653,
            126863522,
            126870959,
            126872615,
            126860538,
            126862556
        ],
        "D2": [
            126861568,
            126863750,
            126868373,
            126869562,
            126876457,
            126868351,
            126862413,
            126873746,
            126868674,
            126867473,
            126864201,
            126863508,
            126868989,
            126866379,
            126880112,
            126871782,
            126872752,
            126861102,
            126877754
        ],
        "B": [
            126856962,
            126852931,
            126853927,
            126857335,
            126862047,
            126855473,
            126854073,
            126848963,
            126854204,
            126852816,
            126866896,
            126854673,
            126855023,
            126857298,
            126855876,
            126863677,
            126859086,
            126871391,
            126876744
        ],
        "A": [
            126847903,
            126848403,
            126847412,
            126849843,
            126849112,
            126848036,
            126848332,
            126847281,
            126847584,
            126847566,
            126847516,
            126847717,
            126847410,
            126847430,
            126850448,
            126848322,
            126849200,
            126856163,
            126853136
        ]
    },
    "name": "E. Bottom-Tier Reversals",
    "statement": "You have a permutation: an array a = [a_1, a_2,\r\nldots, a_n] of distinct integers from 1 to n. The length of the\r\npermutation n is odd.You need to sort the permutation in increasing\r\norder.In one step, you can choose any prefix of the permutation with an\r\nodd length and reverse it. Formally, if a = [a_1, a_2,\r\nldots, a_n], you can choose any odd integer p between 1 and n,\r\ninclusive, and set a to [a_p, a_{p-1},\r\nldots, a_1, a_{p+1}, a_{p+2},\r\nldots, a_n].Find a way to sort a using no more than\r\nfrac{5n}{2} reversals of the above kind, or determine that such a way\r\ndoesn’t exist. The number of reversals doesn’t have to be minimized.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[2025];\nint find(int x,int up)\n{\n\tfor(int i=1;i<=up;++i)\tif(a[i]==x)\treturn i;\n\treturn -1;\n}\nvoid Solve()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;++i)\tif((i&1)^(a[i]&1))\t{puts(\"-1\");return ;}\n\tvector<int> Ans;\n\tfor(int i=n;i>=3;i-=2)\n\t{\n\t\tint pos=find(i,i);\n\t\tassert(pos!=-1);\n\t\tAns.push_back(pos);\n\t\treverse(a+1,a+1+pos);\n\t\tpos=find(i-1,i);\n\t\tAns.push_back(pos-1); //It's impossible to make pos-1=0\n\t\treverse(a+1,a+pos);\n\t\tAns.push_back(pos+1);\n\t\treverse(a+1,a+pos+2);\n\t\tAns.push_back(3);\n\t\tswap(a[1],a[3]);\n\t\tAns.push_back(i);\n\t\treverse(a+1,a+1+i);\n\t}\n\tprintf(\"%d\\n\",int(Ans.size()));\n\tfor(auto st:Ans)\tprintf(\"%d \",st);\n\tputs(\"\");\n}\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0)\tSolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Bottom-Tier Reversals.json",
    "editorial_link": "https://codeforces.com//blog/entry/94216",
    "editorial": "First of all, consider what happens when we reverse a prefix of odd length p\n. Elements ap+1\n to an\n don't move at all, and for each i\n from 1\n to p\n, ai\n moves to ap?i+1\n. Note that i\n and p?i+1\n have the same parity: therefore, no element can ever change the parity of its position. In the final sorted permutation, we need to have ai=i\n for all i\n: that is, the parity of each element's position must match the parity of its value.\n\nThis leads to the following necessary condition: for each i?[1,n]\n, aimod2=imod2\n. If for any i\n this doesn't hold, the permutation can not be sorted.\n\nIt turns out this condition is also sufficient.\n\nLet's devise a procedure to sort a permutation of odd length n\n. If an=n\n and an?1=n?1\n, we don't have to touch an?1\n and an\n ever again, and we can proceed to sorting a permutation of length n?2\n. Can we actually move n\n and n?1\n to their final positions with a simple sequence of steps?\n\nIndeed we can. Here is one way to do this in exactly 5\n steps:\n\nLet ax=n\n (note that x\n is odd). Reverse a prefix of length x\n to move n\n to position 1\n.\nLet ay=n?1\n (note that y\n is even). Reverse a prefix of length y?1\n to move n\n to position y?1\n.\nReverse a prefix of length y+1\n to move n?1\n to position 2\n and n\n to position 3\n.\nReverse a prefix of length 3\n to move n\n to position 1\n (n?1\n stays at position 2\n).\nReverse a prefix of length n\n to move n\n to position n\n and n?1\n to position n?1\n, as desired.\nWe can use this procedure n?12\n times to first move n\n and n?1\n to their final positions, then n?2\n and n?3\n, and so on. This solution requires exactly 5(n?1)2\n steps.",
    "hint": []
}