{
    "link": "https://codeforces.com//contest/1659/problem/C",
    "problemId": "1371413",
    "problem_idx": "C",
    "shortId": "1659C",
    "contest_number": "1659",
    "problem_submissions": {
        "E": [
            153913573,
            153929614,
            153928927,
            153922832,
            153919141,
            153972138,
            153926923,
            153927092,
            153929319,
            153932903,
            153930192,
            153930364,
            153930632,
            153931626,
            153929090,
            153932497,
            153927674,
            153932539,
            153931108,
            153930225
        ],
        "D": [
            153912412,
            153905719,
            153910339,
            153913081,
            153925687,
            153914747,
            153914843,
            153917030,
            153914214,
            153914225,
            153916202,
            153914923,
            153911260,
            153911942,
            153919382,
            153913809,
            153916530,
            153910597,
            153914778,
            153923066
        ],
        "B": [
            153899189,
            153895163,
            153894044,
            153901045,
            153896660,
            153905534,
            153895509,
            153894100,
            153894393,
            153894053,
            153896780,
            153900091,
            153895296,
            153893292,
            153896323,
            153897272,
            153895755,
            153896012,
            153922971,
            153892638
        ],
        "C": [
            153893804,
            153899081,
            153898923,
            153904670,
            153899860,
            153895491,
            153906966,
            153902317,
            153904388,
            153898598,
            153905688,
            153905657,
            153901854,
            153898683,
            153904460,
            153903103,
            153900333,
            153901824,
            153895900,
            153899518
        ],
        "A": [
            153892134,
            153890875,
            153890881,
            153898852,
            153891639,
            153899777,
            153891702,
            153891302,
            153890852,
            153890890,
            153891590,
            153893681,
            153891282,
            153890712,
            153890944,
            153892901,
            153890725,
            153890838,
            153891604,
            153890839
        ],
        "F": [
            153937865
        ]
    },
    "name": "C. Line Empire",
    "statement": "Consider a number axis. The capital of your empire is initially at 0.\r\nThere are n unconquered kingdoms at positions 0<x_1<x_2<\r\nldots<x_n. You want to conquer all other kingdoms.There are two actions\r\navailable to you: You can change the location of your capital (let its\r\ncurrent position be c_1) to any other kingdom (let its position be c_2)\r\nat a cost of a\r\ncdot |c_1-c_2|. From the current capital (let its current position be\r\nc_1) you can conquer an unconquered kingdom (let its position be c_2) at\r\na cost of b\r\ncdot |c_1-c_2|. You conquer a kingdom if there is an unconquered kingdom\r\nbetween the target and your capital. Note that you place the capital at\r\na point without a kingdom. In other words, at any point, your capital\r\ncan only be at 0 or one of x_1,x_2,\r\nldots,x_n. Also note that conquering a kingdom does not change the\r\nposition of your capital.Find the minimum total cost to conquer all\r\nkingdoms. Your capital can be anywhere at the end.\r\n",
    "solutions": [
        "#include<iostream>\nusing namespace std;\nint a[200010];\nlong long sum[200010];\nint main() {\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>T;\n\twhile(T--) {\n\t\tint n,x,y;\n\t\tcin>>n>>x>>y;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tcin>>a[i];\n\t\t\tsum[i]=sum[i-1]+a[i];\n\t\t}\n\t\tlong long ans=1e18,s=0;\n\t\tfor(int i=0; i<=n; i++) {\n\t\t\tif(i) {\n\t\t\t\ts+=a[i]-a[i-1];\n\t\t\t}\n\t\t\tans=min(ans,(long long)x*a[i]+y*(sum[n]-sum[i]-(long long)a[i]*(n-i)+s));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Line Empire.json",
    "editorial_link": "https://codeforces.com//blog/entry/100938",
    "editorial": "Clearly, we should always move from left to right. Also, assume for\r\nsimplicity.Let us analyze what our cost would look like. It will be\r\ncomposed of a part due to moving capitals, and a part due to conquering\r\nkingdoms. If we shift our capital from to , the cost is . If we conquer\r\nkingdoms from with capital , the cost is , which can be written as ,\r\nwhere .Now, notice that and are linear. Also, if we isolate the parts\r\ninvolving , the sum will be like . This means we can simply write the\r\nfinal sum of this part as , where is the final position of the capital.\r\nWe can say the same thing about , except that the final kingdom\r\nconquered is always . So the final sum of this part is always (, so they\r\nwerenât written explicitly).Our final cost, then, looks like , where is\r\ncomposed of terms like . If we want to minimise , we want to maximise .\r\nThat is achieved if we always increase ! Then we can write We cannot\r\nincrease beyond since that is the final position of our capital.Hence,\r\nour final answer is given by Time complexity:\r\n",
    "hint": [
        "Hint 1 Try to analyze the cost of each operation separately. Is there some linearity you can exploit?",
        "Hint 2 Try to make greedy decisions. Can we say that it is always better to move right whenever possible?",
        "Hint 3 Let's say you fix the final position of your capital. Now think about Hint 2."
    ]
}