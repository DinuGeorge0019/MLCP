{"link": "https://codeforces.com//contest/1768/problem/D", "problemId": "1720621", "problem_idx": "D", "shortId": "1768D", "contest_number": "1768", "problem_submissions": {"D": [204982953, 188071247, 188067925, 188068130, 188070945, 188072940, 188074516, 188075810, 188085152, 188074579, 188073456, 188074101, 188082385, 188164225, 188089006, 188069736, 188081987, 188082522, 188078305, 188078232, 188080797], "F": [188116348, 188135822, 188160798, 188176131, 188168385], "E": [188083790, 188076616, 188084542, 188083977, 188085068, 188090588, 188090979, 188080120, 188090253, 188095827, 188095081, 188082638, 188089969, 188164249, 188075544, 188101242, 188092147, 188102271, 188100942, 188097984], "C": [188076017, 188062341, 188060907, 188066248, 188067691, 188065722, 188067475, 188070114, 188066780, 188064718, 188068797, 188076939, 188164202, 188081893, 188163969, 188059068, 188075112, 188075686, 188069461, 188068577, 188075836], "B": [188057634, 188051968, 188049872, 188053488, 188055902, 188055318, 188053420, 188056521, 188052830, 188053386, 188052891, 188065110, 188164191, 188059182, 188051170, 188056859, 188053279, 188061154, 188058286], "A": [188047123, 188046830, 188047332, 188048108, 188047085, 188046543, 188047234, 188050361, 188047575, 188046807, 188046596, 188059906, 188164162, 188047560, 188046948, 188050516, 188048920, 188047550, 188060898, 188051639]}, "name": "D. Lucky Permutation", "statement": "You are given a permutation^\r\ndagger p of length n.In one operation, you can choose two indices 1\r\nle i < j\r\nle n and swap p_i with p_j.Find the minimum number of operations needed\r\nto have inversion^\r\nddagger in the permutation.^\r\ndagger A permutation is an array consisting of n distinct integers from\r\n1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation,\r\nbut [1,2,2] is not a permutation (2 appears twice in the array), and\r\n[1,3,4] is also not a permutation (n=3 but there is 4 in the array).^\r\nddagger The number of inversions of a permutation p is the number of\r\npairs of indices (i, j) such that 1\r\nle i < j\r\nle n and p_i > p_j.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define ri int\n#define DEBUG(k...) fprintf(stderr,k)\ntypedef long long ll;\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,true:false;}\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,true:false;}\ntemplate<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}\nconst int maxn=2e5+10;\nint a[maxn],m,n,t_case;\nstruct dsu{\n\tint fa[maxn],siz[maxn];\n\tinline void init(int k){for(ri i=1;i<=k;++i)fa[i]=i,siz[i]=1;}\n\tint find(int k){return k==fa[k]?k:fa[k]=find(fa[k]);}\n\tinline bool merge(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y){\n\t\t\tif(siz[x]>siz[y])swap(x,y);\n\t\t\tfa[x]=y,siz[y]+=siz[x];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}d;\nint main(){\n\tscanf(\"%d\",&t_case);\n\twhile(t_case--){\n\t\tscanf(\"%d\",&n);\n\t\td.init(n);\n\t\tfor(ri i=1;i<=n;++i)scanf(\"%d\",a+i),d.merge(a[i],i);\n\t\tri sum=0;\n\t\tfor(ri i=1;i<=n;++i)\n\t\t\tif(d.find(i)==i)\n\t\t\t\tsum+=d.siz[i]-1;\n\t\tri ans=sum+1;\n\t\tfor(ri i=1;i<n;++i)\n\t\t\tif(d.find(i)==d.find(i+1))\n\t\t\t\tckmin(ans,sum-1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs", "greedy"], "dificulty": "1800", "interactive": false}