{
    "link": "https://codeforces.com//contest/2019/problem/D",
    "problemId": "2905356",
    "problem_idx": "D",
    "shortId": "2019D",
    "contest_number": "2019",
    "problem_submissions": {
        "F": [
            283223839,
            283223286,
            283233615,
            283232657,
            283229948,
            283240516,
            283246459,
            283246565,
            283251452,
            283250505,
            283246427,
            283244651,
            283250557,
            283250319,
            283249369,
            283252799,
            283231473,
            283385869
        ],
        "D": [
            283212674,
            283217889,
            283216603,
            283210525,
            283219753,
            283227849,
            283216187,
            283224832,
            283209439,
            283233196,
            283224958,
            283235552,
            283222166,
            283223408,
            283233229,
            283225040,
            283257759,
            283214659,
            283210870,
            283212555
        ],
        "C": [
            283205819,
            283208819,
            283200046,
            283197191,
            283204787,
            283192339,
            283195887,
            283200218,
            283196222,
            283200867,
            283211801,
            283203783,
            283208730,
            283210534,
            283225468,
            283214456,
            283200932,
            283202854,
            283202139,
            283199131
        ],
        "B": [
            283197247,
            283193710,
            283188887,
            283186540,
            283192007,
            283185443,
            283202984,
            283190900,
            283188420,
            283188733,
            283190635,
            283190801,
            283197405,
            283188473,
            283191300,
            283202121,
            283194633,
            283194452,
            283194664,
            283188555
        ],
        "A": [
            283194983,
            283181021,
            283181315,
            283181373,
            283182984,
            283180436,
            283198713,
            283181153,
            283180882,
            283182334,
            283181092,
            283183886,
            283188674,
            283181377,
            283181185,
            283196847,
            283190061,
            283183844,
            283182154,
            283180956
        ],
        "E": [
            283192360,
            283198927,
            283209740,
            283216991,
            283212803,
            283197800,
            283209059,
            283219624,
            283225534,
            283213304,
            283232353,
            283227746,
            283232779,
            283233925,
            283218649,
            283231587,
            283221137,
            283211364,
            283219849,
            283218893
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "At some time t\n, consider the minimal interval [l,r]\n that contains all the cities with ai?t\n (let's call it \"the minimal interval at time t\n\"). You have to visit all this interval within time t\n, otherwise there are some cities with ai?t\n which you do not visit in time. So if this interval has length >t\n, you cannot visit it all within time t\n, and the answer is 0\n.\n\nOtherwise, the answer is at least 1\n. A possible construction is visiting \"the minimal interval at time 1\n\", then \"the minimal interval at time 2\n\", ..., then \"the minimal interval at time n\n\". Note that, when you visit \"the minimal interval at time t\n\", the actual time is equal to the length of the interval, which is ?t\n. In this way, at time t\n you will have conquered all the cities in the minimal interval at time t\n, and possibly other cities.\n\nStarting from city x\n is equivalent to setting ax=1\n. After this operation, you have to guarantee that, for each i\n, the minimal interval at time t\n is short enough. If this interval is [l,r]\n before the operation, it can become either [x,r]\n (if x<l\n), or [l,x]\n (if x>r\n), or stay the same. In all this cases, the resulting length must be ?t\n. With some calculations (e.g., r?x+1?t\n), you can get than x\n must be contained in [r?t+1,l+t?1]\n. So it's enough to calculate and intersect the intervals obtained at t=1,,n\n, and print the length of the final interval.\n\nYou can calculate the minimal intervals by iterating on the cities in increasing order of ai\n. Again, if the old interval is [l,r]\n and the new city has index x\n, the new possible intervals are [x,r]\n, [l,r]\n, [l,x]\n.\n\nAnother correct solution is to intersect the intervals [i?ai+1,i+ai?1]\n.",
    "name": "D. Speedbreaker",
    "statement": "There are n cities in a row, numbered 1, 2,\r\nldots, n left to right. At time 1, you conquer exactly one city, called\r\nthe . At time 2, 3,\r\nldots, n, you can choose a city adjacent to the ones conquered so far\r\nand conquer it. You win if, for each i, you conquer city i at a time no\r\nlater than a_i. A winning strategy may or may not exist, also depending\r\non the starting city. How many starting cities allow you to win?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;#define int long longconst int N=2e5+7;int T,n,a[N],tg[N],ans;void modi(int x,int y){\tx=max(x,1ll);\ty=min(y,n);\tif(x<=y){\t\ttg[x]++;\t\ttg[y+1]--;\t}\treturn;}int id[N];bool cmp(int x,int y){\treturn x-a[x]+1<y-a[y]+1;}int minn[N];signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);\tcin>>T;\twhile(T--){\t\tcin>>n;\t\tfor(int i=1;i<=n;i++)\t\t\tcin>>a[i];\t\tfor(int i=1;i<=n;i++){\t\t\tmodi(1,i-a[i]),\t\t\tmodi(i+a[i],n);\t\t\tid[i]=i;\t\t}\t\tsort(id+1,id+n+1,cmp);\t\tint nw=1;\t\tfor(int i=1;i<=n;i++){\t\t\twhile(nw<=n&&nw<id[i]-a[id[i]]+1){\t\t\t\tint st=nw+a[nw];\t\t\t\tfor(;st<=n;st++){\t\t\t\t\tif(minn[st])\t\t\t\t\t\tbreak;\t\t\t\t\tminn[st]=nw;\t\t\t\t}\t\t\t\tnw++;\t\t\t}\t\t\tif(minn[id[i]]){\t\t\t\tmodi(minn[id[i]],id[i]);\t\t\t}\t\t}\t\tfor(int i=2;i<=n;i++)\t\t\ttg[i]+=tg[i-1];\t\tint ans=0;\t\tfor(int i=1;i<=n;i++){\t\t\tif(!tg[i])ans++;\t\t\tminn[i]=0;\t\t}\t\tcout<<ans<<\"\\n\";\t\tfor(int i=0;i<=n+1;i++)\t\t\ttg[i]=0;\t}\treturn 0;}/*max(a[i],a[j])<j-i+1 i<j-a[j]+1a[i]+i<=j*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Speedbreaker.json",
    "hint": []
}