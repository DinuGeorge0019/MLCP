{
    "link": "https://codeforces.com//contest/2024/problem/F",
    "problemId": "2964361",
    "problem_idx": "F",
    "shortId": "2024F",
    "contest_number": "2024",
    "problem_submissions": {
        "F": [
            287015023,
            287169223,
            287373673,
            287215917,
            287215736,
            287211292,
            287210539
        ],
        "D": [
            286987175,
            286931903,
            286960958,
            286961825,
            286971656,
            286929566,
            286931351,
            286932695,
            286932954,
            286934298,
            286931628,
            286927969,
            286932481,
            286936758,
            286930518,
            286960977,
            286959072,
            286943034,
            286936933
        ],
        "B": [
            286981623,
            286914966,
            286919282,
            286915114,
            286921371,
            286905134,
            286915552,
            286914323,
            286916482,
            286915957,
            286912577,
            286914600,
            286917409,
            286917069,
            286960523,
            286915841,
            286912540,
            286913505,
            286928405,
            286917057
        ],
        "E": [
            286971252,
            287005601,
            287014904,
            287015860,
            287015861,
            287172897,
            287179171,
            286984012
        ],
        "A": [
            286921784,
            286907603,
            286905627,
            286906243,
            286909098,
            286912198,
            286906985,
            286905683,
            286907292,
            286909521,
            286906250,
            286906979,
            286905397,
            286905452,
            286905213,
            286906731,
            286905626,
            286906240,
            286907336,
            286905986
        ],
        "C": [
            286916369,
            286924618,
            286933885,
            286931704,
            286933058,
            286906288,
            286921833,
            286923843,
            286925202,
            286923774,
            286923641,
            286921029,
            286922676,
            286924091,
            286919391,
            286920408,
            286922209,
            286923637,
            286916167,
            286927200
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "Claim 1: Suppose we took at least one item with pi<100\n. Then it is claimed that the sum wi\n over all taken elements is ?200000?10099=C\n. To prove this, let's assume the opposite and try to remove any element with pi<100\n from the taken set, denoting qi=pi100\n.\n\nThe answer was (W+wi)?Q?qi\n, but it became W?Q\n. The answer increased if wi?Q?qi<W?Q?(1?qi)\n, that is, wi?qi<W?(1?qi)\n, which is true if wi?pi<W?(100?pi)\n. This is true since wi?pi?200,000\n, while W?(100?pi)>200000\n.\n\nLet's isolate all items with pi==100\n. If their sum is >C\n, then we know the answer; otherwise, for each weight sum, we will find the maximum probability with which such weight can be obtained using a dynamic programming approach similar to the knapsack problem.\n\nTo do this quickly, we will reduce the number of considered items. For each p\n, answer will contain some prefix of elements with that p\n, sorted in descending order by wi\n. If in the optimal answer there are cp\n elements with pi==p\n, then cp?qcp>(cp?1)?qcp?1\n; otherwise, the smallest element can definitely be removed. Rewriting the inequality gives us cp?q>cp?1\n, which means cp<11?q\n. Thus, among the elements with a given p\n, it is sufficient to keep for consideration the top 100100?p\n best items, or about 450\n (i.e., 99?ln99\n) items across all p\n.\n\nIn the end, it is enough to go through the dynamic programming and find the cell with the highest answer.\n\nThe total running time is C?99?ln99\n.",
    "name": "F. Many Games",
    "statement": "Recently, you received a rare ticket to the only casino in the world\r\nwhere you can actually earn something, and you want to take full\r\nadvantage of this opportunity.The conditions in this casino are as\r\nfollows: There are a total of n games in the casino. You can play each\r\ngame . Each game is characterized by two parameters: p_i (1\r\nle p_i\r\nle 100) and w_i the probability of winning the game in percentage and\r\nthe winnings for a win. If you lose in any game you decide to play, you\r\nwill receive nothing at all (even for the games you won). You need to\r\nchoose a set of games in advance that you will play in such a way as to\r\nmaximize the expected value of your winnings.In this case, if you choose\r\nto play the games with indices i_1 < i_2 <\r\nldots < i_k, you will win in all of them with a probability of\r\nprod\r\nlimits_{j=1}^k\r\nfrac{p_{i_j}}{100}, and in that case, your winnings will be equal to\r\nsum\r\nlimits_{j=1}^k w_{i_j}.That is, the expected value of your winnings will\r\nbe\r\nleft(\r\nprod\r\nlimits_{j=1}^k\r\nfrac{p_{i_j}}{100}\r\nright)\r\ncdot\r\nleft(\r\nsum\r\nlimits_{j=1}^k w_{i_j}\r\nright).To avoid going bankrupt, the casino owners have limited the\r\nexpected value of winnings for each individual game. Thus, for all i (1\r\nle i\r\nle n), it holds that w_i\r\ncdot p_i\r\nle 2\r\ncdot 10^5.Your task is to find the maximum expected value of winnings\r\nthat can be obtained by choosing some set of games in the casino.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;#pragma GCC optimize(\"O3\")#pragma GCC optimize(\"unroll-loops\")typedef long long int ll;const ll FOD = 998244353;typedef pair<ll, ll> P;using ull = unsigned long long;template <class T> using V = vector<T>;template <class T> using VV = V<V<T>>;\u00a0\u00a0template <ll MD> struct ModInt {    using M = ModInt;    const static M G;    ll v;    ModInt(ll _v = 0) { set_v(_v % MD + MD); }    M& set_v(ll _v) {        v = (_v < MD) ? _v : _v - MD;        return *this;    }    explicit operator bool() const { return v != 0; }    M operator-() const { return M() - *this; }    M operator+(const M& r) const { return M().set_v(v + r.v); }    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }    M operator*(const M& r) const { return M().set_v(ll(v) * r.v % MD); }    M operator/(const M& r) const { return *this * r.inv(); }    M& operator+=(const M& r) { return *this = *this + r; }    M& operator-=(const M& r) { return *this = *this - r; }    M& operator*=(const M& r) { return *this = *this * r; }    M& operator/=(const M& r) { return *this = *this / r; }    bool operator==(const M& r) const { return v == r.v; }    M pow(ll n) const {        M x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    M inv() const { return pow(MD - 2); }    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }};using Mint = ModInt<998244353>;template<> const Mint Mint::G = Mint(3);\u00a0template <class Mint> void nft(bool type, V<Mint>& a) {    int n = int(a.size()), s = 0;    while ((1 << s) < n) s++;    assert(1 << s == n);\u00a0    static V<Mint> ep, iep;    while (int(ep.size()) <= s) {        ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));        iep.push_back(ep.back().inv());    }    V<Mint> b(n);    for (int i = 1; i <= s; i++) {        int w = 1 << (s - i);        Mint base = type ? iep[i] : ep[i], now = 1;        for (int y = 0; y < n / 2; y += w) {            for (int x = 0; x < w; x++) {                auto l = a[y << 1 | x];                auto r = now * a[y << 1 | x | w];                b[y | x] = l + r;                b[y | x | n >> 1] = l - r;            }            now *= base;        }        swap(a, b);    }}\u00a0template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {    int n = int(a.size()), m = int(b.size());    if (!n || !m) return {};    int lg = 0;    while ((1 << lg) < n + m - 1) lg++;    int z = 1 << lg;    auto a2 = a, b2 = b;    a2.resize(z);    b2.resize(z);    nft(false, a2);    nft(false, b2);    for (int i = 0; i < z; i++) a2[i] *= b2[i];    nft(true, a2);    a2.resize(n + m - 1);    Mint iz = Mint(z).inv();    for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;    return a2;}\u00a0// ll n, k, q, h, w;ll n;\u00a0ll m1, m2;vector<ll> g[400'009 * 2];\u00a0vector<ll> p, w;\u00a0vector<ll> a, b;\u00a0Mint mod_pow (Mint l, ll r) {\tif (r == 0) return 1;\u00a0\treturn mod_pow((l * l), r/2) * ((r%2) ? l : 1);}Mint mod_inv (Mint x) {\treturn mod_pow(x, FOD-2);}\u00a0template<class T>vector<ll> mp (const vector<T> &s) {\tvector<ll> ans(s.size() + 1);\tans[0] = -1;\tll j = -1;\tfor (ll i = 0; i < s.size(); i++) {\t\twhile (j >= 0 && s[i] != s[j]) j = ans[j];\t\tj++;\t\tans[i+1] = j;\t}\treturn ans;}typedef double ld;// typedef long double ld;\u00a0\u00a0ld dp[3000000];\u00a0void solve () {\t// ll sum = 0;\t// ll sc = 0;\t// for (ll i = 1; i <= 99; i++) {\t// \tll cnt = 100 / (100 - i) + 1;\u00a0\t// \tsum += (200000 / i) * cnt;\t// \tsc += cnt;\t// }\u00a0\t// cerr << sum << \" \" << sc << endl;\t// 100 / (100 - p[i]);\u00a0\t// 2920446 580\u00a0\tvector<ld> perc(101);\tfor (ll i = 0; i <= 100; i++) {\t\tperc[i] = (ld)i / (ld)100;\t}\u00a0\u00a0\tfor (ll i = 0; i < n; i++) {\t\tg[p[i]].push_back(-w[i]);\t}\tfor (ll i = 1; i <= 100; i++) {\t\tsort(g[i].begin(), g[i].end());\t\tfor (ll j = 0; j < g[i].size(); j++) {\t\t\tg[i][j] = -g[i][j];\t\t}\t}\u00a0\tvector<P> list;\tfor (ll i = 1; i <= 100 - 1; i++) {\t\tll cnt = 100 / (100 - i);\t\tcnt = min(cnt, (ll)g[i].size());\t\tfor (ll j = 0; j < cnt; j++) {\t\t\tlist.push_back({g[i][j], i});\t\t}\t\t// cerr << i << \" \" << cnt << endl;\t}\u00a0\tsort(list.begin(), list.end());\u00a0\tdp[0] = 1;\tint maxv = 0;\tfor (auto &[wi, pi] : list) {\t\tint gap = wi;\t\tld px = perc[pi];\t\tfor (int i = maxv; i >= 0; i--) {\t\t\tdp[i + gap] = max(dp[i + gap], dp[i] * px);\t\t}\u00a0\t\tmaxv += wi;\t}\u00a0\tll sum100 = 0;\tfor (ll v : g[100]) {\t\tsum100 += (ld)v;\t}\u00a0\tld ans = 0;\tfor (ll i = 0; i <= maxv; i++) {\t\tld maybe = (ld)(i + sum100) * dp[i];\t\tans = max(ans, maybe);\t}\u00a0\u00a0\tcout << fixed << setprecision(12) << ans << \"\\n\";}\u00a0int main (void) {\tstd::cin.tie(nullptr);\tstd::ios_base::sync_with_stdio(false);\tcin >> n;\tp.resize(n);\tw.resize(n);\tfor (ll i = 0; i < n; i++) {\t\tcin >> p[i] >> w[i];\t}\u00a0\t// n = 200000;\t// p.resize(n);\t// w.resize(n);\t// for (ll i = 1; i <= 100; i++) {\t// \tfor (ll j = 0; j < 200000 / 100; j++) {\t// \t\tll v = (i-1)*(200000 / 100) + j;\u00a0\t// \t\tp[v] = i;\t// \t\tw[v] = 200000 / i;\t// \t}\t// }\u00a0\tsolve();\u00a0}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Many Games.json"
}