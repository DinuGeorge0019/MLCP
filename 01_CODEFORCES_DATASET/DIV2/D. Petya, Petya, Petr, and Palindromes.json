{
    "link": "https://codeforces.com//contest/1808/problem/D",
    "problemId": "1854693",
    "problem_idx": "D",
    "shortId": "1808D",
    "contest_number": "1808",
    "problem_submissions": {
        "D": [
            199663586,
            199652295,
            199649543,
            199658153,
            199660313,
            199664555,
            199663522,
            199658681,
            199662131,
            199663211,
            199665809,
            199666904,
            199686788,
            200680943,
            199672659,
            199667818,
            199670491,
            199654888,
            199672673
        ],
        "E3": [
            199660988,
            199675708,
            199684437,
            199678631,
            199683096,
            201130452,
            199666847,
            199711014
        ],
        "E2": [
            199660914,
            199675587,
            199684591,
            199669150,
            199671171,
            199672422,
            199667417,
            199667886,
            199667544,
            199677124,
            199673172,
            199673912,
            199667116,
            200681161,
            200681118,
            199662837,
            199681512,
            199697948,
            199682318
        ],
        "E1": [
            199660827,
            199647476,
            199655105,
            199665173,
            199671231,
            199655192,
            199650032,
            199667518,
            199667485,
            199670735,
            199673329,
            199674123,
            199667097,
            200681014,
            199659398,
            199681451,
            199697918,
            199676180,
            199669612,
            199661602
        ],
        "C": [
            199660389,
            199669471,
            199646653,
            199653605,
            199654568,
            199648568,
            199646672,
            199649651,
            199653794,
            199654418,
            199657068,
            199657978,
            199676868,
            200680878,
            200680798,
            199678734,
            199656497,
            199658569,
            199658535,
            199649977
        ],
        "A": [
            199643949,
            199642214,
            199639989,
            199639150,
            199640540,
            199639256,
            199639177,
            199639048,
            199640380,
            199639173,
            199640678,
            199639746,
            199643343,
            200680660,
            199641247,
            199641300,
            199640545,
            199639604,
            199639018
        ],
        "B": [
            199639404,
            199640164,
            199644601,
            199640956,
            199642784,
            199641076,
            199640175,
            199641302,
            199643530,
            199641294,
            199644684,
            199643246,
            199643095,
            200680723,
            199647537,
            199644556,
            199644782,
            199642649,
            199640242
        ]
    },
    "name": "D. Petya, Petya, Petr, and Palindromes",
    "statement": "Petya and his friend, the robot Petya++, have a common friend the cyborg\r\nPetr. Sometimes Petr comes to the friends for a cup of tea and tells\r\nthem interesting problems.Today, Petr told them the following problem.A\r\npalindrome is a sequence that reads the same from left to right as from\r\nright to left. For example, [38, 12, 8, 12, 38], [1], and [3, 8, 8, 3]\r\nare palindromes.Let’s call the of a sequence a_1, a_2,\r\ndots, a_n the minimum count of elements that need to be replaced to make\r\nthis sequence a palindrome. For example, the palindromicity of the\r\nsequence [38, 12, 8, 38, 38] is 1 since it is sufficient to replace the\r\nnumber 38 at the fourth position with the number 12. And the\r\npalindromicity of the sequence [3, 3, 5, 5, 5] is two since you can\r\nreplace the first two threes with fives, and the resulting sequence [5,\r\n5, 5, 5, 5] is a palindrome.Given a sequence a of length n, and an\r\ninteger k, you need to find the sum of palindromicity of all subarrays\r\nof length k, i. e., the sum of the palindromicity values for the\r\nsequences a_i, a_{i+1},\r\ndots, a_{i+k-1} for all i from 1 to n-k+1.The students quickly solved\r\nthe problem. Can you do it too?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <forward_list>\n#include <fstream>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\ninline int rd() {\n  char ch = getchar();\n  int x = 0, f = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\n#define ll long long\n#define LD long double\n#define i7 __int128\n#define re return\n#define con continue\ntemplate <class T>\ninline bool ckmin(T &a, T b) {\n  re\n    b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline bool ckmax(T &a, T b) {\n  re\n    a < b ? a = b, 1 : 0;\n}\nconst int N = 2e5 + 5;\nint T, n, a[N], S[2], K, cnt;\nstruct xxs {\n  int x, k, p;\n  bool operator<(const xxs &a) const {\n    re\n      x < a.x;\n  }\n} q[N << 1];\nint b[2][N];\nll ans;\nsigned main() {\n  n = rd(), K = rd();\n  for (int i = 1; i <= n; i++) {\n    a[i] = rd();\n    //\t\tint l=max(i-K+1,1),r=min(i-2,i-(K/2-(n-i)));\n    //\t\tint l=max(i-K+1,1),r=min(i-2,n-K+1+(n-i));\n    int l = max(i - K + 1, K - i + 1), r = min(i - 2, n - K + 1 + (n - i));\n    if ((l & 1) ^ (i & 1)) ++l;\n    if ((r & 1) ^ (i & 1)) --r;\n    //\t\tprintf(\"i:%d %d\\n\",l,r);\n    if (l > r) con;\n    q[++cnt] = {r, 1, a[i]};\n    if (l - 2 > 0) q[++cnt] = {l - 2, -1, a[i]};\n  }\n  sort(q + 1, q + cnt + 1);\n  int nw = 1;\n  for (int i = 1; i <= n; i++) {\n    ++b[i & 1][a[i]], ++S[i & 1];\n    while (nw <= cnt && q[nw].x == i) {\n      ans += q[nw].k * (S[i & 1] - b[i & 1][q[nw].p]);\n      //\t\t\tprintf(\"(%d,%d):%d\\n\",q[nw].x,q[nw].p,q[nw].k*(S[i&1]-b[i&1][q[nw].p]));\n      ++nw;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  re\n    0;\n}\n/*\n8 5\n1 2 8 2 5 2 8 6\n\n\n\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Petya, Petya, Petr, and Palindromes.json",
    "editorial_link": "https://codeforces.com//blog/entry/114523",
    "editorial": "Let us see when is added to the palindrome. Let there be some string of\r\nodd length , consider the index to the left of the central one. If this\r\ncharacter and the corresponding one on the right side of the string are\r\ndifferent, we can replace one of the characters with the other and get\r\nto the answer. Now the problem is as follows: count the number of\r\nindices on all substring of length such that they differ from the\r\ncorresponding character in that substring. Letâs solve the inverse\r\nproblem: count the number of indices for all substring of length such\r\nthat the given symbol and its corresponding one are equal. Then simply\r\nsubtract from the maximum possible number of differences the required\r\nnumber of matches.Try some symbol and count for it the number of matches\r\nin all substring. Create a new array of length , that when , otherwise .\r\nNow we have to count the number of indices and such that , , and mod\r\n(i.e. the distance between indices is even). Letâs fix some where , then\r\nindexes , , etc. fit the parity condition. Then we can calculate prefix\r\nsums for each parity of indices. That is, means the sum on prefix length\r\nover all indices with parity equal to . Then , where is subtracted from\r\nthe answer for some fixed . Total we get the solution for , where is the\r\nnumber of different characters of the string.To solve the problem\r\nfaster, we will use the work from the previous solution. Write out\r\nseparately for each character all its occurrences in the string. Letâs\r\ngo through the symbol and write out all positions with even and odd\r\nindices. Solve the problem for even ones (odd ones are solved\r\nsimilarly). We will maintain a sliding window, where the difference\r\nbetween right and left elements is no more than . When we finish\r\niterating after removing the left element, we will subtract the window\r\nlength from the answer, because for the left element of the window\r\nexactly as many elements have the same parity on the right at a distance\r\nof no more than .P.S. The solution for can also be reworked into using\r\nthe trick with heavy and light numbers.\r\n",
    "hint": []
}