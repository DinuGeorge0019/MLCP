{
    "link": "https://codeforces.com//contest/1379/problem/C",
    "problemId": "676891",
    "problem_idx": "C",
    "shortId": "1379C",
    "contest_number": "1379",
    "problem_submissions": {
        "F2": [
            87337334
        ],
        "F1": [
            87335742,
            87339101,
            87337260,
            87346349,
            87331786
        ],
        "C": [
            87325904,
            87311494,
            87310672,
            87300625,
            87303708,
            87304495,
            87303918,
            144460845,
            87308563,
            87299896,
            87303811,
            87316171,
            87303179,
            87308051,
            87311612,
            87310601,
            87310579,
            87310057,
            87313129,
            87307968,
            87308536
        ],
        "D": [
            87320979,
            87326317,
            87326054,
            87310243,
            87318999,
            87323134,
            87327442,
            144461795,
            87328150,
            87328279,
            87321031,
            87333849,
            87337374,
            87336880,
            87336733,
            87324819,
            87323673,
            87326632,
            87332039,
            87324509
        ],
        "B": [
            87292569,
            87299875,
            87297218,
            87294683,
            87294536,
            87293871,
            87299681,
            144459626,
            87295308,
            87293115,
            87290952,
            87296663,
            87291474,
            87295427,
            87292476,
            87294398,
            87295480,
            87294133,
            87302755,
            87296827,
            87299220
        ],
        "A": [
            87289516,
            87291821,
            87290680,
            87291117,
            87290110,
            87290710,
            87290018,
            144458741,
            87289978,
            87290066,
            87289499,
            87289644,
            87295538,
            87290013,
            87289641,
            87289754,
            87291674,
            87304051,
            87290874,
            87292316,
            87291880
        ]
    },
    "name": "C. Choosing flowers",
    "statement": "Vladimir would like to prepare a present for his wife: they have an\r\nanniversary! He decided to buy her n flowers.Vladimir went to a flower\r\nshop, and he was amazed to see that there are m types of flowers being\r\nsold there, and there is unlimited supply of flowers of each type.\r\nVladimir wants to choose flowers to maximize the happiness of his wife.\r\nHe knows that after receiving the first flower of the i-th type\r\nhappiness of his wife increases by a_i and after receiving each\r\nconsecutive flower of this type her happiness increases by b_i. That is,\r\nif among the chosen flowers there are x_i > 0 flowers of type i, his\r\nwife gets a_i + (x_i - 1)\r\ncdot b_i additional happiness (and if there are no flowers of type i,\r\nshe gets nothing for this particular type).Please help Vladimir to\r\nchoose exactly n flowers to maximize the total happiness of his wife.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n\tint t;\n\tcin >> t;\n\n\tfor(int x = 0; x < t; x++) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tvector< pair<int, int> > arr;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tarr.emplace_back(a, b);\n\t\t}\n\t\tsort(arr.begin(), arr.end());\n\t\tvector<int> sufsum(m);\n\t\tsufsum[m - 1] = arr[m - 1].first;\n\t\tfor(int i = m - 2; i >= 0; i--) {\n\t\t\tsufsum[i] = sufsum[i + 1] + arr[i].first;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint j = lower_bound(arr.begin(), arr.end(), make_pair(arr[i].second + 1, 0LL)) - arr.begin();\n\n\t\t\tint cnt = m - j;\n\t\t\tif(cnt > n - 1) {\n\t\t\t\tcnt = n - 1;\n\t\t\t\tj = m - cnt;\n\t\t\t}\n\n\t\t\tif(cnt == n - 1 && i >= j && j >= 1 && arr[j - 1].first > arr[i].second) {\n\t\t\t\tj--;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tif(i < j) {\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tassert(cnt <= n);\n\t\t\tint c = (j == m ? 0 : sufsum[j]) + (i < j ? arr[i].first : 0) + (n - cnt) * arr[i].second;\n\t\t\tans = max(ans, c);\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dfs and similar",
        "dp",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Choosing flowers.json",
    "editorial_link": "https://codeforces.com//blog/entry/80216",
    "editorial": "Let\u00e2\u0080\u0099s look at sorts, for which there is more than one flower in the\r\nbouquet. We can prove, that there can be only one such sort. Let\u00e2\u0080\u0099s\r\nassume that there are sorts and with , such that for both sorts there\r\nare at least 2 flowers. Let\u00e2\u0080\u0099s exclude flower of sort from bouquet and\r\nadd flower of sort . The total happiness will change by , so it will not\r\ndecrease. Repeating this, we can leave bouquet with only one flower of\r\nsort without decreasing the total happiness. So, there always exists an\r\nanswer where there is only one sort with multiple flowers.Using this\r\nfact, we can solve the problem the following way. Let\u00e2\u0080\u0099s iterate over\r\neach sort of flowers and for every suppose that there are multiple\r\nflowers of sort . It is obvious, that if some sort has , then we should\r\ntake one flower of such sort, and if , then we would better take another\r\nflower of sort . So, we need to know sum of for all flowers that have .\r\nTo do it in , we can sort all flowers by in decreasing order, calculate\r\nprefix sums on that array, and using binary search find maximum , such\r\nthat and get prefix sum of for first sorts. All the rest flowers will be\r\nof the sort .Also we should take into account the case when for each\r\nsort only one flower of that sort is taken. In that case we should take\r\nsorts with largest .That way we can get the answer in time.\r\n"
}