{
    "link": "https://codeforces.com//contest/1173/problem/E1",
    "problemId": "355019",
    "problem_idx": "E1",
    "shortId": "1173E1",
    "contest_number": "1173",
    "problem_submissions": {
        "B": [
            55390180,
            55249364,
            55248813,
            55247081,
            55248572,
            55248319,
            55248049,
            55248085,
            55247784,
            55250606,
            55249875,
            55247888,
            55253438,
            55255965,
            55247147,
            55247479,
            55247401,
            55252892,
            55249644,
            55245503,
            55249304
        ],
        "A": [
            55390168,
            55244540,
            55242948,
            55243093,
            55244653,
            55243324,
            55244848,
            55243589,
            55244417,
            55250689,
            55243924,
            55243392,
            55251670,
            55243714,
            55243163,
            55243456,
            55243342,
            55251282,
            55247743,
            55247907,
            55243333
        ],
        "E2": [
            55264453,
            55265045,
            55329518,
            55304255
        ],
        "E1": [
            55264406,
            55262702,
            55259992,
            55263176,
            55264651,
            55262666,
            55266873,
            55264627,
            55264452,
            55266634,
            55266464,
            55265263,
            55264681,
            55280794
        ],
        "D": [
            55255531,
            55258124,
            55255281,
            55257012,
            55256681,
            55257269,
            55258420,
            55260440,
            55256109,
            55260509,
            55259549,
            55259968,
            55265550,
            55252742,
            55256814,
            55258411,
            55258273,
            55257931,
            55253830,
            55257656
        ],
        "C": [
            55252151,
            55255450,
            55254699,
            55254410,
            55253838,
            55254769,
            55255630,
            55254749,
            55258947,
            55256880,
            55254444,
            55257615,
            55254129,
            55257128,
            55254804,
            55253939,
            55250315,
            55254309,
            55260196,
            55254835
        ]
    },
    "name": "E1. Nauuo and Pictures  easy version ",
    "statement": "Nauuo is a girl who loves random picture websites.One day she made a\r\nrandom picture website by herself which includes n pictures.When Nauuo\r\nvisits the website, she sees exactly one picture. The website does not\r\ndisplay each picture with equal probability. The i-th picture has a\r\nnon-negative weight w_i, and the probability of the i-th picture being\r\ndisplayed is\r\nfrac{w_i}{\r\nsum_{j=1}^nw_j}. That is to say, the probability of a picture to be\r\ndisplayed is proportional to its weight.However, Nauuo discovered that\r\nsome pictures she does not like were displayed too often. To solve this\r\nproblem, she came up with a great idea: when she saw a picture she\r\nlikes, she would add 1 to its weight; otherwise, she would subtract 1\r\nfrom its weight.Nauuo will visit the website m times. She wants to know\r\nthe expected weight of each picture after all the m visits modulo\r\n998244353. Can you help her?The expected weight of the i-th picture can\r\nbe denoted by\r\nfrac {q_i} {p_i} where\r\ngcd(p_i,q_i)=1, you need to print an integer r_i satisfying 0\r\nle r_i<998244353 and r_i\r\ncdot p_i\r\nequiv q_i\r\npmod{998244353}. It can be proved that such r_i exists and is unique.\r\n",
    "solutions": [
        "//2019.6.7 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n//inline void add(res &x,const res &y,const res &kcz){\n//    x+=y,x>=kcz?x-=kcz:(x<0?x+=kcz:1);\n//}\n//inline int Add(const res &x,const res &y,const res &kcz){\n//    return x+y>=kcz?x+y-kcz:(x+y<0?x+y+kcz:x+y);\n//}\n//inline int mul(const res &x,const res &y,const res &kcz){\n//    return int(1LL*x*y%kcz);\n//}\n//inline int qpow(res x,res y,const res &kcz){\n//    res ret=1;\n//    while(y){\n//        if(y&1)ret=mul(ret,x,kcz);\n//        y>>=1,x=mul(x,x,kcz);\n//    }\n//    return ret;\n//}\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void swap(res &x,res &y) {\n//    x^=y^=x^=y;\n//}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int kcz=998244353;\nconst int N=2e5+10;\nnamespace MAIN {\n    int n,m;\n    int fac[N],inv[N],a[N],w[N],sum[2],Sum;\n    inline void add(res &x,const res &y,const res &kcz){\n        x+=y,x>=kcz?x-=kcz:(x<0?x+=kcz:1);\n    }\n    inline int Add(const res &x,const res &y,const res &kcz){\n        return x+y>=kcz?x+y-kcz:(x+y<0?x+y+kcz:x+y);\n    }\n    inline int mul(const res &x,const res &y,const res &kcz){\n        return int(1LL*x*y%kcz);\n    }\n    inline int qpow(res x,res y,const res &kcz){\n        res ret=1;\n        while(y){\n            if(y&1)ret=mul(ret,x,kcz);\n            y>>=1,x=mul(x,x,kcz);\n        }\n        return ret;\n    }\n    int gl[2][N],cur;\n    int INV[2][N];\n    map<int,int> M[2];\n    inline int DP(const res &fl,const res &val,const res &lim){\n        if(M[fl].count(val))return M[fl][val];\n        res ret=0,sum=0;\n        for(res i=0;i<m;i++)add(sum,mul(fl==0?Add(val,-sum,kcz):Add(val,sum,kcz),INV[fl][i],kcz),kcz),add(ret,mul(sum,fl==0?gl[cur][m-i-1]:gl[cur][i+1],kcz),kcz);\n        return M[fl][val]=ret;\n    }\n    inline void MAIN(){\n        n=read(),m=read();\n        res qaq=m+5;\n        for(res i=1;i<=n;i++)a[i]=read();\n        for(res i=1;i<=n;i++)w[i]=read(),sum[a[i]]+=w[i],Sum+=w[i];\n        for(res i=0;i<=2*qaq;i++)inv[i]=qpow(Sum+i-qaq,kcz-2,kcz);\n        gl[0][0]=1,INV[0][0]=qpow(sum[0],kcz-2,kcz),INV[1][0]=qpow(sum[1],kcz-2,kcz);\n        for(res i=1;i<=m;i++){\n            INV[0][i]=qpow(sum[0]-i,kcz-2,kcz),INV[1][i]=qpow(sum[1]+i,kcz-2,kcz);\n            for(res j=0;j<=i;j++)gl[cur^1][j]=0;\n            for(res j=0;j<i;j++){\n                res p=mul(sum[1]+j,inv[2*j-i+1+qaq],kcz);\n                add(gl[cur^1][j],mul(gl[cur][j],1-p,kcz),kcz),add(gl[cur^1][j+1],mul(gl[cur][j],p,kcz),kcz);\n            }\n            cur^=1;\n        }\n        for(res i=1;i<=n;i++)printf(\"%d\\n\",Add(w[i],a[i]==0?-DP(a[i],w[i],m):DP(a[i],w[i],m),kcz));\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n    // freopen(\"zao.in\",\"r\",stdin);\n    // freopen(\"std.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "probabilities"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Nauuo and Pictures  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/67511",
    "editorial": "First, let's focus on a single picture with weight w\n which Nauuo likes, so we only have to know the sum of the weights of the pictures Nauuo likes (SA=?i=1nwi[ai=1]\n) and the sum of the disliked ones (SB=?i=1nwi[ai=0]\n) instead of all the n\n weights.\n\nThen, we can use DP to solve this problem.\n\nLet fw[i][j][k]\n be the expected weight of a picture Nauuo likes with weight w\n after another i\n visits since SA=j\n and SB=k\n.\n\nObviously, fw[0][j][k]=w\n.\n\nThe state transition:\n\nThe next visit displays the picture we focus on. Probaility: wj+k\n. Lead to: fw+1[i?1][j+1][k]\n.\n\nThe next visit displays a picture Nauuo likes but is not the one we focus on. Probaility: j?wj+k\n. Lead to: fw[i?1][j+1][k]\n.\n\nThe next visit displays a picture Nauuo doesn't like. Probaility: kj+k\n. Lead to: fw[i?1][j][k?1]\n.\n\nSo, fw[i][j][k]=wj+kfw+1[i?1][j+1][k]+j?wj+kfw[i?1][j+1][k]+kj+kfw[i?1][j][k?1]\n.\n\nLet gw[i][j][k]\n be the expected weight of a picture Nauuo doesn't like with weight w\n after another i\n visits since SA=j\n and SB=k\n. The state transition is similar.\n\nNote that i,j,k,m\n have some relation. In fact we can let f?w[i][j]\n be fw[m?i?j][SA+i][SB?j]\n (SA\n and SB\n are the initial ones here).\n\nBut up to now, we can only solve the easy version.\n\nTo solve the hard version, let's introduce a lemma:\n\nfw[i][j][k]=wf1[i][j][k]\nProof:\n\nObviously, this is true when i=0\n.\n\nThen, suppose we have already proved fw[i?1][j][k]=wf1[i?1][j][k]\n.\n\nf1[i][j][k]=1j+kf2[i?1][j+1][k]+j?1j+kf1[i?1][j+1][k]+kj+kf1[i?1][j][k?1]=2j+kf1[i?1][j+1][k]+j?1j+kf1[i?1][j+1][k]+kj+kf1[i?1][j][k?1]=j+1j+kf1[i?1][j+1][k]+kj+kf1[i?1][j][k?1]\n\nfw[i][j][k]=wj+kfw+1[i?1][j+1][k]+j?wj+kfw[i?1][j+1][k]+kj+kfw[i?1][j][k?1]=w(w+1)j+kf1[i?1][j+1][k]+w(j?w)j+kf1[i?1][j+1][k]+wkj+kf1[i?1][j][k?1]=w(j+1)j+kf1[i?1][j+1][k]+wkj+kf1[i?1][j][k?1]=wf1[i][j][k]\n\nAlso, a brief but not so strict proof: the increment in each step is proportional to the expectation.\n\nSo, we only have to calculate f1[i][j][k]\n (f?1[i][j]\n).\n\nIn conclusion:\n\nf?1[i][j]=1 (i+j=m)\n\nf?1[i][j]=SA+i+1SA+SB+i?jf?1[i+1][j]+SB?jSA+SB+i?jf?1[i][j+1] (i+j<m)\n\ng?1[i][j]=1 (i+j=m)\n\ng?1[i][j]=SA+iSA+SB+i?jg?1[i+1][j]+SB?j?1SA+SB+i?jg?1[i][j+1] (i+j<m)\n\nIf ai=1\n, the expected weight of the i\n-th picture is wif?1[0][0]\n, otherwise, the expected weight is wig?1[0][0]\n.\n\nLast question: how to calculate the result modulo 998244353\n?\n\nIf you don't know how, please read the wiki to learn it.\n\nYou can calculate and store all the O(m)\n inverses at first, then you can get an O(n+m2+mlogp)\n solution instead of O(n+m2logp)\n (p=998244353\n here).",
    "hint": []
}