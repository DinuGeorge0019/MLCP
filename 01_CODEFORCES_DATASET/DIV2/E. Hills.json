{
    "link": "https://codeforces.com//contest/1013/problem/E",
    "problemId": "203189",
    "problem_idx": "E",
    "shortId": "1013E",
    "contest_number": "1013",
    "problem_submissions": {
        "E": [
            40956112,
            40954604,
            40952959,
            40954177,
            40956704,
            40954852,
            40958592,
            40955861,
            40956957,
            40959161,
            40962228,
            40958309,
            40954877,
            40961226,
            40962426,
            40963172,
            40959599,
            40960095,
            40962704,
            40960316
        ],
        "D": [
            40947895,
            40949235,
            40948190,
            40942963,
            40949230,
            40956987,
            40949637,
            40959376,
            40954303,
            40954900,
            40949703,
            40954385,
            40960744,
            40953417,
            40949714,
            40950014,
            40955109,
            40955161,
            40948236,
            40957040
        ],
        "C": [
            40945093,
            40946094,
            40946460,
            40948959,
            40947981,
            40948222,
            40950831,
            40945123,
            40948645,
            40944950,
            40947268,
            40951753,
            40947430,
            40945326,
            40946788,
            40945079,
            40948090,
            40945103,
            40952740,
            40948559
        ],
        "B": [
            40941603,
            40943452,
            40942391,
            40945819,
            40943517,
            40942695,
            40945308,
            40942798,
            40941517,
            40942505,
            40944306,
            40945361,
            40944304,
            40947125,
            40945606,
            40951205,
            40942971,
            40942106,
            40951005,
            40945032
        ],
        "A": [
            40939736,
            40940294,
            40939785,
            40944381,
            40940232,
            40940059,
            40941218,
            40939821,
            40939967,
            40940115,
            40940253,
            40940672,
            40939837,
            40940000,
            40940214,
            40942500,
            40940832,
            40939878,
            40942490,
            40940286
        ],
        "F": [
            82478981,
            40991650
        ]
    },
    "name": "E. Hills",
    "statement": "Welcome to Innopolis city. Throughout the whole year, Innopolis citizens\r\nsuffer from everlasting city construction. From the window in your room,\r\nyou see the sequence of hills, where -th of them has height . The\r\nInnopolis administration wants to build some houses on the hills.\r\nHowever, for the sake of city appearance, a house can be only built on\r\nthe hill, which is strictly higher than neighbouring hills (if they are\r\npresent). For example, if the sequence of heights is , then houses could\r\nbe built on hills with heights and only.The Innopolis administration has\r\nan excavator, that can decrease the height of an arbitrary hill by one\r\nin one hour. The excavator can only work on one hill at a time. It is\r\nallowed to decrease hills up to zero height, or even to negative values.\r\nIncreasing height of any hill is impossible. The city administration\r\nwants to build houses, so there must be at least hills that satisfy the\r\ncondition above. What is the minimum time required to adjust the hills\r\nto achieve the administration’s plan?However, the exact value of is not\r\nyet determined, so could you please calculate answers for all in range ?\r\nHere denotes divided by two, rounded up.\r\n",
    "solutions": [
        "/// In The Name Of God\n/// I wish, that I could leave it all behind me / Go to my own world where no one can find me\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define int long long\n#define ll long long\n#define pii pair <int , int>\n#define ld long double\n#define for2(a,b,c) for(int (a) = (b); (a) < (c); (a)++)\n#define for3(a,b,c) for(    (a) = (b); (a) < (c); (a)++)\n#define setp cout << fixed << setprecision(15)\n#define endl \"\\n\"\n#define minit(a,b) a = min(a,b)\n#define maxit(a,b) a = max(a,b)\n#define PII pair<int,int>\n#define Vec vector<int>\n#define error(x) cerr << #x << \" = \" << (x) << endl;\n#define all(x) (x).begin() , (x).end()\n\nconst int maxn = 5010;\nconst int inf = 1e9;\nint  a[maxn];\nint f[maxn][maxn];\nint g[maxn][maxn];\n\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n; cin >> n;\n    for2(i,0,n) cin >> a[i];\n    for2(i,0,n) fill(g[i],g[i]+maxn,inf),fill(f[i],f[i]+maxn,inf);\n    for2(i,0,n) g[i][0] = 0;\n    g[0][1] = inf;\n    f[0][1] = 0;\n    for2(i,0,n){\n        if(i) f[i][1] = max(0,a[i-1]-a[i]+1);\n        if(i) g[i][1] = min(g[i-1][1],f[i-1][1] + max(0,a[i]-a[i-1]+1) );\n    }\n    for2(k,2,n) for2(i,2,n){\n        f[i][k] = f[i-2][k-1];\n        f[i][k] += max(0, a[i-1]-min(a[i],a[i-2])+1  );\n\n        f[i][k] = min(f[i][k], g[i-1][k-1] + max(0,a[i-1]-a[i]+1) );\n\n        g[i][k] = min(g[i-1][k], f[i-1][k] + max(0,a[i]-a[i-1]+1)   );\n\n    }\n    for2(k,1,(n+1)/2+1 ) cout << min(f[n-1][k],g[n-1][k]) << ' ';\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Hills.json",
    "editorial_link": "https://codeforces.com//blog/entry/60920",
    "editorial": "The problem's short statement is: \"we allowed to decrease any element and should create at least k local maximums, count the minimum number of operations for all k\".\n\nNotice, that any set of positions, where no positions are adjacent could be made to be local maximums  we just need to decrease the neighbouring hills to some value.\n\nLet's introduce the following dynamic programming:\n\ndp[prefix][local_maxs]  the minimum cost if we analyze only given prefix, have the specified number of local maximums (\"good hills to build on\") and we make a local maximum in the last hill of this prefix.\n\nTh dumb implementation of this leads to O(n2) states and O(n4) time  in each state we can brute force the previous position of local maximum (n) and then calculate the cost of patching the segment from previous local maximum to current one.\n\nA more attentive look says that it is, in fact O(n3) solution  on the segment only first and last elements need to be decreased (possibly first and last elements are same).\n\nTo get the full solution full solution in O(n2) we need to optimize dp a little bit. As we noticed in the previous paragraph, there is one extreme situation, when the first and elements are same, let's handle this transition by hand in O(1) for each state.\n\nOtherwise, funny fact, the cost of the segment strictly between local maximums is the cost of it's left part plus it'cost of it's right part. Seems like something we can decompose, right?\n\nSince our goal is to update state (prefix,?local) now the right part is fixed constant for all such transitions. And we need to select minimum value of dp[i][local?-?1]?+?cost(i,?i?+?1) where i?<??=?prefix?-?3.\n\nThis can be done by calculating a supplementary dp during the primarily dp calculation  for example we can calculate f[pref][j] = min dp[i][j] + cost(i, i + 1) for i???pref.",
    "hint": []
}