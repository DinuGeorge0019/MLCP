{"link": "https://codeforces.com//contest/515/problem/E", "problemId": "22487", "problem_idx": "E", "shortId": "515E", "contest_number": "515", "problem_submissions": {"C": [9901093, 9891593, 9889966, 9894661, 9890694, 9891519, 9891807, 9891147, 9894312, 9892979, 9890976, 9896690, 9895106, 9891765, 9893860, 9889767, 9894769], "E": [9897953, 9901196, 9901641], "A": [9893658, 9884581, 9884436, 9884731, 9884617, 9893616, 9885742, 9884882, 9886057, 9890988, 9899002, 9884584, 9884720, 9884480, 9897882, 9895179, 9887232], "B": [9893222, 9886714, 9886489, 9887475, 9887922, 9887319, 9888734, 9887265, 9890144, 9891119, 9888369, 9892060, 9887541, 9886326, 9890729, 9894202, 9891245], "D": [9889440, 9896686, 9895645, 9901264, 9898104, 9900858, 9899954, 9900443, 9899935, 9899852, 9899500, 9928352, 9928159, 9899922, 9900339, 9901106]}, "name": "E. Drazil and Park", "statement": "Drazil is a monkey. He lives in a circular park. There are trees around\r\nthe park. The distance between the -th tree and ()-st trees is , the\r\ndistance between the -th tree and the first tree is . The height of the\r\n-th tree is .Drazil starts each day with the . The morning run consists\r\nof the following steps: Drazil chooses two different trees He starts\r\nwith climbing up the first tree Then he climbs down the first tree, runs\r\naround the park (in one of two possible directions) to the second tree,\r\nand climbs on it Then he finally climbs down the second tree. But there\r\nare always children playing around some consecutive trees. Drazil can\u2019t\r\nstand children, so he can\u2019t choose the trees close to children. He even\r\ncan\u2019t stay close to those trees.If the two trees Drazil chooses are -th\r\nand -th, we can estimate the energy the takes to him as . Since there\r\nare children on exactly one of two arcs connecting and , the distance\r\nbetween trees and is uniquely defined.Now, you know that on the -th day\r\nchildren play between -th tree and -th tree. More formally, if ,\r\nchildren play around the trees with indices from range , otherwise they\r\nplay around the trees with indices from .Please help Drazil to determine\r\nwhich two trees he should choose in order to consume the most energy\r\n(since he wants to become fit and cool-looking monkey) and report the\r\nresulting amount of energy for each day.\r\n", "solutions": ["#include <stdio.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define RMQN 200010\nstruct RMQ{\n    long long c[RMQN];\n    int a[RMQN][20][2];\n    int f(int x, int y){ return c[x]>c[y]?x:y; }\n    void build(int n){\n        for (int i = 0; i < n; i++){ a[i][0][0] = i; a[i][0][1] = n; }\n        for (int j = 1; (1<<j) <= n; j++)\n            for (int i = 0; i + (1<<j) - 1 < n; i++) {\n                int x = a[i][j - 1][0], y = a[i + (1<<(j - 1))][j - 1][0];\n                if (f(x, y) == x) {\n                    a[i][j][0] = x;\n                    x = a[i][j - 1][1];\n                } else {\n                    a[i][j][0] = y;\n                    y = a[i + (1<<(j - 1))][j - 1][1];\n                }\n                a[i][j][1] = f(x, y);\n            }\n    }\n    int query(int x, int y){\n        int k = log2(y - x + 1.0);\n        return f(a[x][k][0], a[y - (1<<k) + 1][k][0]);\n    }\n    int query2(int x, int y) {\n        int k = log2(y - x + 1.0);\n        int p = a[x][k][0], q = a[y - (1<<k) + 1][k][0];\n        if (p == q) {\n            return f(a[x][k][1], a[y - (1<<k) + 1][k][1]);\n        }\n        if (f(p, q) == p) {\n            p = a[x][k][1];\n        } else {\n            q = a[y - (1<<k) + 1][k][1];\n        }\n        return f(p, q);\n    }\n}p, q;\nlong long d[200010];\nint h[200010];\nint main(){\n    int n, m, i, x, y, l, r;\n    scanf(\"%d%d\", &n, &m);\n    for (i = 1; i <= n; i++) {\n        scanf(\"%d\", &x);\n        d[i] = d[n + i] = x;\n    }\n    for (i = 1; i < n + n; i++) d[i] += d[i - 1];\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &h[i]); h[n + i] += h[i];\n    }\n    for (i = 0; i < n + n; i++) {\n        p.c[i] = h[i] + h[i] + d[i];\n        q.c[i] = h[i] + h[i] - d[i];\n    }\n    p.c[n + n] = q.c[n + n] = -(1ll<<60);\n    p.build(n + n); q.build(n + n);\n    while (m--) {\n        scanf(\"%d%d\", &x, &y);\n        if (x <= y) {\n            l = y; r = x + n - 2;\n        } else {\n            l = y + n; r = x + n - 2;\n        }\n        x = p.query(l, r); y = q.query(l, r);\n        if (x != y) printf(\"%I64d\\n\", p.c[x] + q.c[y]);\n        else {\n            long long ans = p.c[x] + q.c[q.query2(l, r)];\n            ans = max(ans, p.c[p.query2(l, r)] + q.c[y]);\n            printf(\"%I64d\\n\", ans);\n        }\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2300", "interactive": false}