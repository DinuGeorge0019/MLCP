{
    "link": "https://codeforces.com//contest/816/problem/E",
    "problemId": "110368",
    "problem_idx": "E",
    "shortId": "816E",
    "contest_number": "816",
    "problem_submissions": {
        "E": [
            27863231,
            27863827,
            27863029,
            27860461,
            27863136,
            27865351,
            27864615,
            27864468,
            27888047,
            27887967,
            27937085
        ],
        "C": [
            27850215,
            27861317,
            27854036,
            27851177,
            27862299,
            27857090,
            27854650,
            27852662,
            27850415,
            27853530,
            27854524,
            27855938,
            27852726,
            27856877,
            27849179,
            27853471,
            27855491,
            27856929,
            27856486
        ],
        "B": [
            27848642,
            27849640,
            27850149,
            27848668,
            27849856,
            27851634,
            27849204,
            27854414,
            27848329,
            27850570,
            27851030,
            27849936,
            27849151,
            27848884,
            27852810,
            27850464,
            27851714,
            27851843,
            27851131
        ],
        "A": [
            27848027,
            27848026,
            27848067,
            27848089,
            27848256,
            27849615,
            27848022,
            27851364,
            27847966,
            27848494,
            27847999,
            27848587,
            27848127,
            27847967,
            27851375,
            27849723,
            27848224,
            27848952,
            27848135
        ],
        "D": [
            27863292,
            28057801,
            28341325,
            27862819,
            27861012,
            27860728,
            27886034,
            27863751,
            27864128
        ]
    },
    "name": "E. Karen and Supermarket",
    "statement": "On the way home, Karen decided to stop by the supermarket to buy some\r\ngroceries. She needs to buy a lot of goods, but since she is a student\r\nher budget is still quite limited. In fact, she can only spend up to\r\ndollars.The supermarket sells goods. The -th good can be bought for\r\ndollars. Of course, each good can only be bought once.Lately, the\r\nsupermarket has been trying to increase its business. Karen, being a\r\nloyal customer, was given coupons. If Karen purchases the -th good, she\r\ncan use the -th coupon to decrease its price by . Of course, a coupon\r\ncannot be used without buying the corresponding good.There is, however,\r\na constraint with the coupons. For all , in order to use the -th coupon,\r\nKaren must also use the -th coupon (which may mean using even more\r\ncoupons to satisfy the requirement for that coupon).Karen wants to know\r\nthe following. What is the maximum number of goods she can buy, without\r\nexceeding her budget ?\r\n",
    "solutions": [
        "//#pragma comment(linker,\"/STACK:16777216\") /*16Mb*/\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <list>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <time.h>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\n\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define RFOR(i,a,b) for(int (i)=(a)-1;(i)>=(b);--(i))\n#define MP make_pair\n#define I insert\n#define mod 1000000007\n#define INF 2000000007\n#define PB push_back\n#define x0 sdfhrthrth\n#define x1 fdhttrlhn\n#define y0 kihrbdb\n#define y1 ugvrrtgtrg\n#define eps 1e-5\n#define X first\n#define Y second\n\nconst int MAXN = 300000;\n\nLL sum[2][5005][5005];\nvector<int> g[5005];\nvector<LL> num;\nint n;\nLL a[5005],b[5005],to[5005];\nint sz[5005];\nLL Q;\nvector<LL> E[5005];\n\nvoid dfs(int v)\n{\n    FOR (i,1,n+1) sum[0][v][i] = sum[1][v][i] = Q+1;\n    sz[v] = 0;\n    E[v].PB(a[v]);\n    FOR (qwe,0,g[v].size())\n    {\n        int u = g[v][qwe];\n        dfs(u);\n        FOR (i,0,E[u].size()) E[v].PB(E[u][i]);\n        RFOR (j,sz[v]+1,0)\n        FOR (i,1,sz[u]+1)\n        {\n                sum[1][v][j+i] = min(sum[1][v][j+i],sum[1][v][j]+sum[1][u][i]);\n        }\n        sz[v] += sz[u];\n    }\n    sz[v]++;\n    RFOR (i,sz[v]+1,1)\n    {\n        sum[1][v][i] = sum[1][v][i-1]+b[v];\n    }\n\n    LL Y = 0;\n    sort(E[v].begin(),E[v].end());\n    FOR (i,0,E[v].size())\n    {\n        Y += E[v][i];\n        sum[0][v][i+1] = Y;\n    }\n    \n    FOR (i,0,sz[v]+1)\n        sum[1][v][i] = min(sum[1][v][i], sum[0][v][i]);\n}\n\nint main()\n{\n    cin >> n >> Q;\n    FOR (i,0,n)\n    {\n        cin >> a[i] >> b[i];\n        b[i] = a[i]-b[i];\n        if (i)\n        {\n            cin >> to[i];\n            g[to[i]-1].PB(i);\n        }\n    }\n    dfs(0);\n    int ans = 0;\n    FOR (j,0,n+1)\n    {\n        if (sum[1][0][j] <= Q)\n            ans = j;\n    }\n    cout << ans;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Karen and Supermarket.json",
    "editorial_link": "https://codeforces.com//blog/entry/52742",
    "editorial": "Instead of asking for the maximum number of items we can buy with b dollars, let's ask instead for the minimum cost to buy j items for all j. Afterwards, we can simply brute force all j to find the largest j that still fits within her budget b.\n\nNote this problem is actually on a rooted tree, with root at node 1; the constraint xi?<?i guarantees there are no cycles in this problem. The coupon requirement essentially means that if we buy good i at the discounted price, we also need to buy good xi at the discounted price, and so on. If we don't buy at discounted price there are no constraints (except that Karen can afford it. Unfortunately, she isn't a criminal.)\n\nThere is a rather straightforward O(n3) dynamic programming solution to this problem, as follows:\n\nLet fi,?j be the minimum cost to buy j items in the subtree of i if we can still use coupons, and gi,?j the minimum cost to buy j items in the subtree of i if we cannot use any more coupons.\n\nWe know that for all leaves, fi,?j?=?ci?-?di and gi,?j?=?ci.\n\nWe can compute gi,?j for all nodes as well; this is simply the sum of the j smallest c's in the subtree of i. This can be done straightforwardly in O(n2) or .\n\nTo compute this fi,?j for some non-leaf node i, we should initialize fi,?1?=?ci?-?di.\n\nNow, we can add each of the children of i one by one, and try each j. Suppose we take k elements from one of the children. Then we have fi,?j?=?min(fi,?j,?fi,?j?-?k?+?fi,?k). We just have to make sure to implement it in a way that we don't inadvertently take elements multiple times, usually by making an auxiliary array.\n\nFinally, we set fi,?j?=?min(fi,?j,?gi,?j) to consider not using the coupons. Note that we can't do this at the start, because otherwise it could cause conflicts.\n\nThis runs in O(n3), which is too slow. This is because there are n nodes, and to compute fi,?j for all j in that node, it takes  where pi is the set of all of the children of i, and s(h) is the subtree size of node h. This sum turns out to be O(n2), and so the final runtime is O(n3).\n\nHow could we make it faster? Take the largest (in terms of nodes) child of subtree i. Can we avoid iterating through this?\n\nYes, we can! Suppose our tree was binary. Now, we can compute fi,?j?=?min0???k?<?j(fa,?j?-?k?-?1?+?fb,?k?+?ci?-?di), where a and b are the subtrees of i, with s(a)???s(b). This skips iterating through the larger subtree a.\n\nWe can extend this to non-binary trees, too; just do this to skip the largest subtree, and then add the rest like before.\n\nThe runtime of the transition is now , which turns out to be just O(n). The final runtime is hence O(n2) (or , depending on the algorithm used for the greedy portion.) This is sufficient to solve this problem.",
    "hint": []
}