{"link": "https://codeforces.com//contest/16/problem/B", "problemId": "73", "problem_idx": "B", "shortId": "16B", "contest_number": "16", "problem_submissions": {"E": [70472, 70287, 71317, 71555, 71009, 2823445, 70557, 71514, 71526, 71256, 71545, 71259, 70518, 71999, 73011], "D": [70195, 70680, 70666, 70921, 71632, 2869290, 71074, 70915, 71037, 71486, 70532, 71544, 71595, 70760], "C": [69769, 69933, 69973, 70337, 70580, 70313, 70299, 72753, 70416, 70325, 69894, 70966, 71276, 70125], "B": [69600, 69688, 69697, 69888, 69866, 69936, 69851, 69883, 69690, 70057, 69594, 70701, 69726, 69706], "A": [69453, 69471, 69475, 69541, 69630, 69660, 69596, 69456, 69746, 69452, 71841, 69827, 69528, 69489]}, "name": "B. Burglar and Matches", "statement": "A burglar got into a matches warehouse and wants to steal as many\r\nmatches as possible. In the warehouse there are containers, in the -th\r\ncontainer there are matchboxes, and each matchbox contains matches. All\r\nthe matchboxes are of the same size. The burglar\u2019s rucksack can hold\r\nmatchboxes exactly. Your task is to find out the maximum amount of\r\nmatches that a burglar can carry away. He has no time to rearrange\r\nmatches in the matchboxes, that\u2019s why he just chooses not more than\r\nmatchboxes so that the total amount of matches in them is maximal.\r\n", "solutions": ["#include <algorithm> \n#include <iostream> \n#include <sstream> \n#include <string> \n#include <vector> \n#include <queue> \n#include <set> \n#include <map> \n#include <cstdio> \n#include <cstdlib> \n#include <cctype> \n#include <cmath> \n#include <list> \nusing namespace std; \n\n#define PB push_back \n#define MP make_pair \n#define SZ(v) ((int)(v).size()) \n#define FOR(i,a,b) for(int i=(a);i<(b);++i) \n#define REP(i,n) FOR(i,0,n) \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i) \n#define REPE(i,n) FORE(i,0,n) \n#define FORSZ(i,a,v) FOR(i,a,SZ(v)) \n#define REPSZ(i,v) REP(i,SZ(v)) \ntypedef long long ll; \n\nvoid run() {\n\tint can,n; scanf(\"%d%d\",&can,&n);\n\tvector<pair<int,int> > have;\n\tREP(i,n) { int nr,each; scanf(\"%d%d\",&nr,&each); have.PB(MP(each,nr)); }\n\tsort(have.rbegin(),have.rend());\n\tint left=can;\n\tint ret=0;\n\tfor(int i=0;i<SZ(have)&&left>0;++i) {\n\t\tint cur=min(left,have[i].second);\n\t\tret+=cur*have[i].first;\n\t\tleft-=cur;\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["greedy", "implementation", "sortings"], "dificulty": "900", "interactive": false}