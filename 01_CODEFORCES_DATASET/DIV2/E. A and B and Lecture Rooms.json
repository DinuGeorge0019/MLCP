{
    "link": "https://codeforces.com//contest/519/problem/E",
    "problemId": "23227",
    "problem_idx": "E",
    "shortId": "519E",
    "contest_number": "519",
    "problem_submissions": {
        "E": [
            10073402,
            10073826,
            10071435,
            10075682,
            10073508,
            10076499,
            10076691,
            10077686,
            10078395,
            10078558,
            10077889,
            10071597,
            10078230,
            10079725,
            10079205,
            10080058,
            10080571,
            10081897,
            10077792,
            10077601
        ],
        "B": [
            10068822,
            10066495,
            10066094,
            10071522,
            10065688,
            10067197,
            10068098,
            10065513,
            10067032,
            10066771,
            10065927,
            10073256,
            10064342,
            10066337,
            10068191,
            10068245,
            10065978,
            10064399,
            10070061,
            10067255
        ],
        "A": [
            10067760,
            10065092,
            10070229,
            10067607,
            10065441,
            10066194,
            10064523,
            10065142,
            10067859,
            10064294,
            10074313,
            10075152,
            10065080,
            10075511,
            10064659,
            10064877,
            10064769,
            10067836,
            10065055
        ],
        "D": [
            10065946,
            10069869,
            10068018,
            10068104,
            10075209,
            10071298,
            10070153,
            10071171,
            10068423,
            10070885,
            10071374,
            10076292,
            10070706,
            10072961,
            10071572,
            10075243,
            10072547,
            10071425,
            10078247,
            10079828
        ],
        "C": [
            10064224,
            10067438,
            10064240,
            10065614,
            10064567,
            10068407,
            10064386,
            10066890,
            10064235,
            10064221,
            10067480,
            10072542,
            10066908,
            10064218,
            10069397,
            10066796,
            10066694,
            10065658,
            10065115,
            10068337
        ]
    },
    "name": "E. A and B and Lecture Rooms",
    "statement": "The University where A and B study is a set of rooms connected by\r\ncorridors. Overall, the University has rooms connected by corridors so\r\nthat you can get from any room to any other one by moving along the\r\ncorridors. The rooms are numbered from to .Every day and B write\r\ncontests in some rooms of their university, and after each contest they\r\ngather together in the same room and discuss problems. A and B want the\r\ndistance from the rooms where problems are discussed to the rooms where\r\ncontests are written to be equal. The distance between two rooms is the\r\nnumber of edges on the shortest path between them.As they write contests\r\nin new rooms every day, they asked you to help them find the number of\r\npossible rooms to discuss problems for each of the following days.\r\n",
    "solutions": [
        "#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\n\nconst int N = 100100;\n\nint n, m, niv[N], p[19][N], nrnod[N];\nvector<int> v[N];\n\nvoid df(int nod, int pp) {\n\n    nrnod[nod] = 1;\n\n    for(vector<int>::iterator it = v[nod].begin(); it != v[nod].end(); ++it) if(*it != pp) {\n        niv[*it] = niv[nod] + 1;\n        p[0][*it] = nod;\n        df(*it, nod);\n\n        nrnod[nod] += nrnod[*it];\n    }\n}\n\nint lca(int a, int b) {\n    if(niv[a] > niv[b])\n        swap(a, b);\n\n    int k;\n    for(k = 18; k >= 0; --k)\n        if(niv[b] - (1<<k) >= niv[a])\n            b = p[k][b];\n\n    for(k = 18; k >= 0; --k)\n    if(p[k][a] != p[k][b]) {\n        a = p[k][a];\n        b = p[k][b];\n    }\n\n    if(a == b)\n        return a;\n    return p[0][a];\n}\n\nint par(int nr, int nod) {\n    int k;\n\n    for(k = 18; k >= 0; --k)\n    if((1<<k) <= nr) {\n        nr -= (1<<k);\n        nod = p[k][nod];\n    }\n\n    return nod;\n}\n\nint main() {\n    int i, j;\n    //freopen(\"ttt\", \"r\", stdin);\n\n    cin >> n;\n    for(i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    df(1, 0);\n    for(i = 1; i < 19; ++i)\n        for(j = 1; j <= n; ++j)\n            p[i][j] = p[i - 1][p[i - 1][j]];\n\n    cin >> m;\n\n    for(i = 1; i <= m; ++i) {\n        int lc, a, b;\n        cin >> a >> b;\n\n        if(a == b) {\n            cout << n << \"\\n\";\n            continue;\n        }\n\n        lc = lca(a, b);\n\n        int sum = niv[a] + niv[b] - 2 * niv[lc];\n\n        if(sum % 2 == 1) {\n            cout << \"0\\n\";\n            continue;\n        }\n        else {\n            sum /= 2;\n            if(niv[a] > niv[b])\n                swap(a, b);\n\n\n            int nod = par(sum, b);\n\n            int nrel = nrnod[nod];\n\n            if(nod == lc) {\n                nrel = n;\n                nrel -= nrnod[par(sum - 1, a)];\n            }\n            nrel -= nrnod[par(sum - 1, b)];\n\n            cout << nrel << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. A and B and Lecture Rooms.json",
    "editorial_link": "https://codeforces.com/blog/entry/16687",
    "editorial": "In this problem we have to answer to the following queries on tree: for given pairs of vertices your program should output number of eqidistand vertices from them.\n\nLet's denote:\n\ndist(a,?b) as distance between vertices a and b.\n\nLCA(a,?b) as lowest common ancestor of vertices a and b.\n\ndepth[a] as distance between root of the tree and vertex a.\n\nsize[a] as size of subtree of vertex a.\n\nOn each picture green nodes are equidistant nodes, blue nodes Â— nodes from query.\n\nPreprocessing: Read edges of tree and build data structure for LCA (it is more convenient to use binary raise, becase we will use it further for other purposes).\n\nComplexity: O(NlogN)\n\nQueries:\n\nWe have to consider several cases for each query:\n\n1) a?=?b. In that case answer is n.\n\n2) dist(a,?b) is odd. Then answer is 0.\n\n3) dist(a,?l)?=?dist(b,?l), where l?=?LCA(a,?b).\n\n \n\nFind children of l, which are ancestors of a and b (let's denote them as aa and bb). Answer will be n?-?size[aa]?-?size[bb].\n\n4) All other cases.\n\n   \n\nAssume that depth[a]?>?depth[b]. Then using binary raise find dist(a,?b)?/?2-th ancestor of a (let's denote it as p1), dist(a,?b)?/?2?-?1-th ancestor of vertex a (denote it as p2). Answer will be size[p1]?-?size[p2].\n\nComplexity: O(logN) for each query, O(MlogN) for all queries.",
    "hint": []
}