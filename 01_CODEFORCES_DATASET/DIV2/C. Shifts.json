{"link": "https://codeforces.com//contest/230/problem/C", "problemId": "1887", "problem_idx": "C", "shortId": "230C", "contest_number": "230", "problem_submissions": {"E": [2281369, 2283553, 2285030, 2285047, 2275013, 2277312, 2281959, 2280926, 2282812, 2282942, 2289756, 2303849, 2284350, 2284110], "D": [2279019, 2282259, 2281806, 2284336, 2468189, 2293544, 2293533, 2293531, 2292779, 2280034, 2280797, 2282637, 2281762, 2282078, 2282947], "C": [2276837, 2279164, 2278509, 2280041, 2280782, 2279772, 2278719, 2276895, 2277991, 2280210, 2277389, 2280622, 2278662, 2279358, 2278439, 2277863, 2279847, 2279222], "B": [2275270, 2276827, 2276000, 2275039, 2278453, 2275508, 2275984, 2274908, 2281260, 2276330, 2275784, 2276800, 2275571, 2275505, 2276144, 2275193, 2276949, 2275915], "A": [2273678, 2274800, 2273664, 2274083, 2276565, 2273916, 2274258, 2273731, 2273800, 2274208, 2273713, 2274806, 2273983, 2273830, 2274358, 2274055, 2274259, 2273895]}, "name": "C. Shifts", "statement": "You are given a table consisting of rows and columns. Each cell of the\r\ntable contains a number, 0 or 1. In one move we can choose some row of\r\nthe table and cyclically shift its values either one cell to the left,\r\nor one cell to the right.To a table row one cell to the right means to\r\nmove the value of each cell, except for the last one, to the right\r\nneighboring cell, and to move the value of the last cell to the first\r\ncell. A cyclical shift of a row to the left is performed similarly, but\r\nin the other direction. For example, if we cyclically shift a row \"\" one\r\ncell to the right, we get a row \"\", but if we shift a row \"\" one cell to\r\nthe left, we get a row \"\".Determine the minimum number of moves needed\r\nto make some table column consist only of numbers 1.\r\n", "solutions": ["#include <cstdio>\n#include <queue>\n\nint ans[10010], min[10010];\n\nint main(){\n\n    int n, m;\n    scanf(\"%d %d\\n\" ,&n ,&m);\n\n    char buf[10010];\n    for(int i = 1; i <= n; i++){\n\n        scanf(\"%s\" ,buf + 1);\n\n        std::queue<int> que;\n        for(int j = 1; j <= m; j++){\n            if(buf[j] == '1'){\n                min[j] = 0;\n                que.push(j);\n            }\n            else min[j] = m;\n        }\n\n        if(que.empty()){\n            puts(\"-1\");\n            return 0;\n        }\n\n        while(!que.empty()){\n\n            int now = que.front(); que.pop();\n\n            int lnex = (now == 1)? m: now - 1;\n            int rnex = (now == m)? 1: now + 1;\n\n            if(min[lnex] > min[now] + 1){\n                min[lnex] = min[now] + 1;\n                que.push(lnex);\n            }\n            if(min[rnex] > min[now] + 1){\n                min[rnex] = min[now] + 1;\n                que.push(rnex);\n            }\n\n        }\n        \n        for(int j = 1; j <= m; j++) ans[j] += min[j];\n\n    }\n\n    int res = m * n;\n    for(int i = 1; i <= m; i++){\n        if(res > ans[i]) res = ans[i];\n    }\n    printf(\"%d\\n\" ,res);\n\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "dp", "implementation"], "dificulty": "1500", "interactive": false}