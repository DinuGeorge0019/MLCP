{"link": "https://codeforces.com//contest/967/problem/F", "problemId": "179486", "problem_idx": "F", "shortId": "967F", "contest_number": "967", "problem_submissions": {"F": [37724740, 37785350], "D": [37715859, 37718485, 37714997, 37714910, 37721057, 37715196, 37718252, 37721060, 37725740, 37722409, 37721493, 37718542, 37720902, 37723570, 37717977, 37722095, 37718943, 37720444, 37720943, 37717804], "C": [37713201, 37714275, 37715739, 37715714, 37735586, 37715171, 37716355, 37717661, 37717233, 37716160, 37725218, 37716853, 37715198, 37728018, 37717261, 37727878, 37722084, 37716869, 37714314], "B": [37710580, 37710295, 37709555, 37710161, 37717401, 37713108, 37711288, 37712382, 37711143, 37713098, 37711452, 37711212, 37711591, 37710867, 37709639, 37712905, 37712898, 37710688, 37712013, 37710071], "A": [37709201, 37709088, 37708901, 37710764, 37709412, 37710987, 37735764, 37709724, 37709576, 37710227, 37709634, 37709699, 37709830, 37709320, 37917335, 37710605, 37727121, 37709146, 37708986], "E": [37722960, 37719908, 37746295, 37728001, 37723621, 37714048, 37723133, 37726145, 37721957, 37725590, 37727533, 37724467, 37727640, 37727967, 37722685, 37746402, 37724717, 37727899, 37780807]}, "name": "F. Aztec Catacombs", "statement": "Indiana Jones found ancient Aztec catacombs containing a golden idol.\r\nThe catacombs consists of n caves. Each pair of caves is connected with\r\na two-way corridor that can be opened or closed. The entrance to the\r\ncatacombs is in the cave 1, the idol and the exit are in the cave n.When\r\nIndiana goes from a cave x to a cave y using an open corridor, all\r\ncorridors connected to the cave x change their state: all open corridors\r\nbecome closed, all closed corridors become open. Indiana wants to go\r\nfrom cave 1 to cave n going through as small number of corridors as\r\npossible. Help him find the optimal path, or determine that it is\r\nimpossible to get out of catacombs.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define N 400000\nusing namespace std;\n\nset<int>s[N];\nint bl[N],S[N],sz,n,m;\n\nvoid dfs(int x,int y){\n\tbl[x]=y;++sz;\n\tfor(int z:s[x])if(z!=1&&!bl[z])dfs(z,y);\n}\n\nvoid dft(int x){\n\tS[x]=sz;\n\tfor(int y:s[x])if(y!=1&&!S[y])dft(y);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\ts[x].insert(y);s[y].insert(x);\n\t}\n\tif(s[1].count(n))return printf(\"1\\n1 %d\\n\",n),0;\n\tfor(int x:s[1])if(s[x].count(n))return printf(\"2\\n1 %d %d\\n\",x,n),0;\n\tfor(int x:s[1])for(int y:s[x])if(s[y].count(n))return printf(\"3\\n1 %d %d %d\\n\",x,y,n),0;\n\tfor(int x:s[1])for(int y:s[x])if(y!=1&&!s[1].count(y))return printf(\"4\\n1 %d %d 1 %d\\n\",x,y,n),0;\n\tif(!s[1].size())return puts(\"-1\"),0;\n\tfor(int x:s[1])\n\t\tif(!bl[x]){sz=0;dfs(x,x);dft(x);}\n\tint mn=n+10,mid=0;\n\tfor(int x:s[1])if(S[x]!=s[x].size()){\n\t\tif(s[x].size()<mn){\n\t\t\tmn=s[x].size();mid=x;\n\t\t}\n\t}\n\tif(mid){\n\t\tputs(\"5\");\n\t\tfor(int y:s[mid])\n\t\t\tif(y!=1)for(int z:s[y])if(z!=1&&z!=mid&&!s[mid].count(z))return printf(\"1 %d %d %d %d %d\\n\",mid,y,z,mid,n),0;\n\t}\n\tputs(\"-1\");\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["graphs"], "dificulty": "2600", "interactive": false}