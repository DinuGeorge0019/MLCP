{
    "link": "https://codeforces.com//contest/155/problem/B",
    "problemId": "950",
    "problem_idx": "B",
    "shortId": "155B",
    "contest_number": "155",
    "problem_submissions": {
        "C": [
            1225243,
            1226717,
            1224971,
            1224506,
            1224768,
            1224444,
            1224336,
            1226178,
            1224907,
            1224916,
            1224811,
            1224924,
            1224662,
            1223975,
            1226905,
            1227456,
            1225902,
            1228923,
            4141949,
            1225351
        ],
        "D": [
            1224117,
            1227696,
            1226383,
            1225863,
            1228335,
            1226351,
            1226456,
            1225394,
            1226266,
            1226950,
            1226772,
            1227105,
            1227425,
            1226475,
            1226136,
            1224942,
            1227473,
            1225325,
            1227301
        ],
        "B": [
            1221607,
            1221762,
            1222099,
            1223177,
            1225270,
            1222150,
            1223376,
            1222553,
            1222471,
            1222167,
            1223151,
            1222830,
            1222882,
            1224581,
            1222789,
            1222810,
            1222778,
            1222687,
            1222965
        ],
        "A": [
            1221146,
            1221148,
            1221169,
            1221961,
            1222044,
            1221349,
            1221696,
            1221640,
            1221515,
            1221343,
            1221470,
            1221634,
            1221617,
            17013899,
            1224871,
            1221409,
            1221848,
            1221716,
            1221534,
            1221252
        ],
        "E": [
            1239607,
            1239595,
            1239584,
            1231448,
            1239840,
            1243072
        ]
    },
    "name": "B. Combination",
    "statement": "Ilya plays a card game by the following rules.A player has several\r\ncards. Each card contains two non-negative integers inscribed, one at\r\nthe top of the card and one at the bottom. At the beginning of the round\r\nthe player chooses one of his cards to play it. If the top of the card\r\ncontains number , and the bottom contains number , then when the player\r\nis playing the card, he gets points and also gets the opportunity to\r\nplay additional cards. After the playing the card is discarded.More\r\nformally: let\u2019s say that there is a counter of the cards that can be\r\nplayed. At the beginning of the round the counter equals one. When a\r\ncard is played, the counter decreases by one for the played card and\r\nincreases by the number , which is written at the bottom of the card.\r\nThen the played card is discarded. If after that the counter is not\r\nequal to zero, the player gets the opportunity to play another card from\r\nthe remaining cards. The round ends when the counter reaches zero or the\r\nplayer runs out of cards.Of course, Ilya wants to get as many points as\r\npossible. Can you determine the maximum number of points he can score\r\nprovided that you know his cards?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n; cin >> n;\n    vector<pair<int, int> > v;\n    for (int i=0; i < n; i++) {\n        int a, b; cin >> a >> b;\n        v.push_back(make_pair(b, a));\n    }\n    sort(v.rbegin(), v.rend());\n    int pt = 0, count = 1;\n    for (int i=0; i < n; i++) {\n        int b = v[i].first, a = v[i].second;\n        pt += a;\n        count += b-1;\n        if (count == 0) break;\n    }\n    cout << pt << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Combination.json",
    "editorial_link": "https://codeforces.com//blog/entry/3969",
    "editorial": "Clearly, we can play the cards with > 0 first as each of them gives at\r\nleast one extra move. After that, the number of extra moves left doesn\u00e2\u0080\u0099t\r\ndepend on the order of playing. The left cards all have = 0, so we play\r\nthose of them which have larger . Simpler version of this solution: sort\r\nall the cards by decrease of , if equal by decrease of , and then go\r\nthrough the sorted array from beginning to end, simulate the counter and\r\nsum up the points. Remember not to fall over the edge of array if the\r\nsum of \u00e2\u0080\u0099s is larger than the number of cards. Complexity O(n log n) (or\r\nO(n^2), if using bubblesort, which is still accepted).\r\n"
}