{
    "link": "https://codeforces.com//contest/1236/problem/F",
    "problemId": "442398",
    "problem_idx": "F",
    "shortId": "1236F",
    "contest_number": "1236",
    "problem_submissions": {
        "F": [
            62811108
        ],
        "E": [
            62897948,
            62812842,
            62804306,
            62804069,
            62813891,
            62807146,
            62814095,
            62805221,
            62811322,
            62812238,
            62805891,
            62807935,
            62864987,
            62832474
        ],
        "D": [
            62802950,
            62812650,
            62812836,
            62802625,
            62815190,
            62803700,
            62813698,
            62812781,
            62814654,
            62821887,
            62803442,
            62805006,
            62803249,
            62804002,
            62802909,
            62805902,
            62806423
        ],
        "C": [
            62792622,
            62791071,
            62789610,
            62791879,
            62789897,
            62794126,
            62795764,
            62792967,
            62790282,
            62793895,
            62789462,
            62790719,
            62789824,
            62786960,
            62793187,
            62790332,
            62791408,
            62792941
        ],
        "B": [
            62786209,
            62787426,
            62787186,
            62788924,
            62792966,
            62790776,
            62793499,
            62788719,
            62790312,
            62785414,
            62786772,
            62787247,
            62786648,
            62784848,
            62788974,
            62787295,
            62787730,
            62787714
        ],
        "A": [
            62784582,
            62784627,
            62784321,
            62785968,
            62783805,
            62784292,
            62799939,
            62784596,
            62785095,
            62790291,
            62784662,
            62784215,
            62784012,
            62783846,
            62784720,
            62784658,
            62784976,
            62784753
        ]
    },
    "name": "F. Alice and the Cactus",
    "statement": "Alice recently found some cactuses growing near her house! After several\r\nmonths, more and more cactuses appeared and soon they blocked the road.\r\nSo Alice wants to clear them.A cactus is a connected undirected graph.\r\nNo edge of this graph lies on more than one simple cycle. Letâ€™s call a\r\nsequence of different nodes of the graph x_1, x_2,\r\nldots, x_k a simple cycle, if k\r\ngeq 3 and all pairs of nodes x_1 and x_2, x_2 and x_3,\r\nldots, x_{k-1} and x_k, x_k and x_1 are connected with edges. Edges\r\n(x_1, x_2), (x_2, x_3),\r\nldots, (x_{k-1}, x_k), (x_k, x_1) lies on this simple cycle.There are so\r\nmany cactuses, so it seems hard to destroy them. But Alice has magic.\r\nWhen she uses the magic, every node of the cactus will be removed\r\nindependently with the probability\r\nfrac{1}{2}. When a node is removed, the edges connected to it are also\r\nremoved.Now Alice wants to test her magic. She has picked a cactus with\r\nn nodes and m edges. Let X[S] (where S is a subset of the removed nodes)\r\nbe the number of connected components in the remaining graph after\r\nremoving nodes of set S. Before she uses magic, she wants to know the\r\nvariance of random variable X, if all nodes of the graph have\r\nprobability\r\nfrac{1}{2} to be removed and all n of these events are independent. By\r\nthe definition the variance is equal to E[(X - E[X])^2], where E[X] is\r\nthe expected value of X. Help her and calculate this value by modulo\r\n10^9+7.Formally, let M = 10^9 + 7 (a prime number). It can be shown that\r\nthe answer can be expressed as an irreducible fraction\r\nfrac{p}{q}, where p and q are integers and q\r\nnot\r\nequiv 0\r\npmod{M}. Output the integer equal to p\r\ncdot q^{-1}\r\nbmod M. In other words, find such an integer x that 0\r\nle x < M and x\r\ncdot q\r\nequiv p\r\npmod{M}.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 5 * (int)1e5 + 100;\nint n, m;\nconst int mod = (int)1e9 + 7;\nint mult(int a, int b) {\n  return (1LL * a * b) % mod;\n}\nint pw(int a, int b) {\n  if (b == 0) return 1;\n  if (b & 1) return mult(a, pw(a, b - 1));\n  int res = pw(a, b / 2);\n  return mult(res, res);\n}\nint sub(int a, int b) {\n  int s = a - b;\n  if (s < 0) s += mod;\n  return s;\n}\nint sum(int a, int b) {\n  int s = a + b;\n  if (s >= mod) s -= mod;\n  return s;\n}\nvector < int > cyc;\nint st_number[maxN];\nint used[maxN];\nvector < vector < int > > cycles;\nvector < int > g[maxN];\nint pw2[maxN]; int inv2[maxN];\nvoid dfs(int v, int p) {\n  used[v] = 1;\n  st_number[v] = cyc.size();\n  cyc.push_back(v);\n  for (int to : g[v]) {\n    if (used[to] == 2) continue;\n    if (used[to] == 0) {\n      dfs(to, v);\n    }\n    if (used[to] == 1 && to != p) {\n      vector < int > nall;\n      for (int i = st_number[to]; i < cyc.size(); i++) nall.push_back(cyc[i]);\n      cycles.push_back(nall);\n      continue;\n    }\n  }\n  used[v] = 2;\n  cyc.pop_back();\n}\nint vertex() {\n  return mult(n, inv2[1]);\n}\nint edges() {\n  return mult(m, inv2[2]);\n}\nint cyces() {\n  int tot = 0;\n  for (auto it : cycles) {\n    tot = sum(tot, inv2[it.size()]);\n  }\n  return tot;\n}\nint vert2() {\n  int ans = mult(mult(n, n - 1), inv2[2]);\n  ans = sum(ans, mult(n, inv2[1]));\n  return ans;\n}\nint edges2() {\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int to : g[i]) {\n      if (i > to) continue;\n      // i < to\n      int other_edges = m - g[i].size() - g[to].size() + 1;\n      int not_other = g[i].size() - 1 + g[to].size() - 1;\n      ans = sum(ans, mult(other_edges, inv2[4]));\n      ans = sum(ans, mult(not_other, inv2[3]));\n    }\n  }\n  ans = sum(ans, mult(m, inv2[2]));\n  return ans;\n}\nint veredges() {\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int other_edges = m - g[i].size();\n    ans = sum(ans, mult(other_edges, inv2[3]));\n    int my_edges = g[i].size();\n    ans = sum(ans, mult(my_edges, inv2[2]));\n  }\n  return ans;\n}\nvector < int > bySz[maxN];\nint vercycles() {\n  int ans = 0;\n  int tot = cyces();\n  for (int i = 1; i <= n; i++) {\n    int val = tot;\n    for (int sz : bySz[i]) {\n      val = sub(val, inv2[sz]);\n    }\n    ans = sum(ans, mult(inv2[1], val));\n    ans = sum(ans, sub(tot, val));\n  }\n  return ans;\n}\nint cyccyc() {\n  int total = cyces();\n  int ans = 0;\n  for (auto it : cycles) {\n    int my_sz = it.size();\n    int coef = inv2[my_sz];\n    ans = sum(ans, coef);\n    int val = total;\n    for (int v : it) {\n      for (int sz : bySz[v]) {\n        val = sub(val, inv2[sz]);\n      }\n      val = sum(val, inv2[my_sz]);\n    }\n    val = sub(val, inv2[my_sz]);\n    ans = sum(ans, mult(inv2[my_sz], val));\n    int rest = sub(total, sum(val, inv2[my_sz]));\n    // they have 2\n    ans = sum(ans, mult(mult(inv2[my_sz], 2), rest));\n  }\n  return ans;\n}\nint cycedges() {\n  int ans = 0;\n  for (auto it : cycles) {\n    int my_sz = it.size();\n    int edges_inside = my_sz;\n    ans = sum(ans, mult(edges_inside, inv2[my_sz]));\n    int edges_not_inside = 0;\n    for (int u : it) {\n      edges_not_inside = sum(edges_not_inside, g[u].size() - 2);\n    }\n    int left_edges = m - edges_inside - edges_not_inside;\n    ans = sum(ans, mult(edges_not_inside, inv2[my_sz + 1]));\n    ans = sum(ans, mult(left_edges, inv2[my_sz + 2]));\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  //freopen(\"input.txt\", \"r\", stdin);\n  cin >> n >> m;\n  pw2[0] = 1;\n  for (int i = 1; i < maxN; i++) {\n    pw2[i] = mult(pw2[i - 1], 2);\n  }\n  inv2[0] = 1;\n  for (int i = 1; i < maxN; i++) {\n    inv2[i] = mult(inv2[i - 1], (mod + 1) / 2);\n  }\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(1, -1);\n  for (auto it : cycles) {\n    for (int v : it) bySz[v].push_back(it.size());\n  }\n  int ex = sub(sum(vertex(), cyces()), edges());\n  ex = pw(ex, 2);\n  int v2 = vert2();\n  int c2 = cyccyc();\n  int ed2 = edges2();\n  int val = sum(sum(v2, c2), ed2);\n  int other_coef = vercycles();\n  other_coef = sub(other_coef, sum(cycedges(), veredges()));\n  other_coef = mult(other_coef, 2);\n  val = sum(other_coef, val);\n  val = sub(val, ex);\n  cout << val;\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "math",
        "probabilities"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Alice and the Cactus.json",
    "editorial_link": "https://codeforces.com/blog/entry/70654",
    "editorial": "First we consider how to calculate .The number of connected components\r\nequals to the number of nodes minus the number of edges and then add the\r\nnumber of rings in it. So we can calculate the possibility of removing\r\none node, one edge or one single ring.Then we can split the variance, it\r\nis equals to . Then we can again to split . Let the number nodes equal\r\nto , the number edges equal to , the number rings equal to . Then . We\r\ncan find there is contribution between a pair of nodes, edges, rings\r\n(the two may be the same) and between a node and an edge, a node and a\r\nring, an edge and a ring. Then we can calculate the possibility of such\r\npair that the elements in it remains at the same time. The answer is the\r\nsame when the pair is a ring and a node on it, or when it is a ring and\r\na node not on it, or an edge with one of its end point ... If we\r\nconsider all the situation of intersection and not intersection, we can\r\nget a liner algorithm. But the Time Complexity is since we need to\r\ncalculate the multiplicative inverse of modulo.\r\n",
    "hint": []
}