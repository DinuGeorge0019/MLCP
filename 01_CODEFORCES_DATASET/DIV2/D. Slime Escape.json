{
    "link": "https://codeforces.com//contest/1734/problem/D",
    "problemId": "1552471",
    "problem_idx": "D",
    "shortId": "1734D",
    "contest_number": "1734",
    "problem_submissions": {
        "F": [
            173185632,
            175218475,
            173190546,
            173191658,
            173196355,
            173188817,
            173202455,
            173187697,
            173194085,
            173183123,
            173202233,
            173182648,
            173206619,
            173206031,
            173205548,
            173214371,
            173208785,
            173211522,
            173212671,
            173216120,
            173216610
        ],
        "E": [
            173175699,
            173166069,
            173180507,
            173192080,
            173179852,
            173184971,
            173197330,
            173182409,
            173189641,
            173194573,
            173204944,
            173179755,
            173194867,
            173195446,
            173190898,
            173195535,
            173185614,
            173194125,
            173192157,
            173195124
        ],
        "D": [
            173172113,
            173184362,
            173173933,
            173177548,
            173199975,
            173194507,
            173189936,
            173202354,
            173195516,
            173191220,
            173189692,
            173195961,
            173190592,
            173192533,
            173179112,
            173186768,
            173197574,
            173186962,
            173186353,
            173189234
        ],
        "C": [
            173171420,
            173173245,
            173168676,
            173179830,
            173175634,
            173167876,
            173187173,
            173175996,
            173196980,
            173169255,
            173195772,
            173170163,
            173177695,
            173173390,
            173174005,
            173175329,
            173173990,
            173179546,
            173179107,
            173169662
        ],
        "B": [
            173169227,
            173171175,
            173193336,
            173168846,
            173171766,
            173171866,
            173178703,
            173171564,
            173199117,
            173175233,
            173193770,
            173167986,
            173174104,
            173170609,
            173170567,
            173169827,
            173173815,
            173175076,
            173172718,
            173176884
        ],
        "A": [
            173165060,
            173168188,
            173166559,
            173165334,
            173167696,
            173173794,
            173167259,
            173167875,
            173200226,
            173178050,
            173191224,
            173165056,
            173168611,
            173165867,
            173165345,
            173165147,
            173168349,
            173167419,
            173166169,
            173173512
        ]
    },
    "name": "D. Slime Escape",
    "statement": "You are playing a game called . The game takes place on a number line.\r\nInitially, there are n slimes. For all positive integers i where 1\r\nle i\r\nle n, the i-th slime is located at position i and has health a_i. You\r\nare controlling the slime at position k. There are two escapes located\r\nat positions 0 and n+1. Your goal is to reach of the two escapes by\r\nperforming any number of game moves.In one game move, you move your\r\nslime to the left or right by one position. However, if there is another\r\nslime in the new position, you must absorb it. When absorbing a slime,\r\nthe health of your slime would be increased by the health of the\r\nabsorbed slime, then the absorbed slime would be removed from the\r\ngame.Note that some slimes might have negative health, so your health\r\nwould decrease when absorbing such slimes. You lose the game immediately\r\nif your slime has negative health at any moment during the game.Can you\r\nreach one of two escapes by performing any number of game moves, without\r\never losing the game?\r\n",
    "solutions": [
        "// Problem: D. Slime Escape\n// Contest: Codeforces Round #822 (Div. 2)\n// URL: https://codeforces.com/contest/1734/problem/D\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//author: wuge with noi2022 cu\n//https://www.luogu.com.cn/team/48234\n#include<bits/stdc++.h>\nusing namespace std;\n#define M998 const int mod=998244353\n#define M197 const int mod=1e9+7\n#define int long long\n#define genshin getchar\n#define impact isdigit\ninline int read()\n{\n     int shaya=0,wugecu=1;//5 spaces\n  char cirno_9=genshin();//2 spaces\n        while(!impact(cirno_9))//8 spaces\n  {if(cirno_9=='-')wugecu=-1;cirno_9=genshin();}//2 spaces\n  while(impact(cirno_9)) shaya=shaya*10+cirno_9-'0',cirno_9=genshin();//2 spaces\n return shaya*wugecu;//1 space\n}\nint n,k;\nint a[1000003];\nbool chk()\n{\n\tvector<pair<int,int>> b;\n#define fi first\n#define se second\n\tint val=a[k];\n\tfor(int i=k+1; i<=n;)\n\t{\n\t\tint sum=0,mn=0;\n\t\twhile(i<=n&&sum<=0)\n\t\t{\n\t\t\tsum+=a[i++];\n\t\t\tmn=min(sum,mn);\n\t\t}\n\t\tif(sum>0)\n\t\t{\n\t\t\tb.push_back(make_pair(sum,mn));\n\t\t}\n\t}\n\tauto it=b.begin();\n\tfor(int i=k-1; i>=1; --i)\n\t{\n\t\twhile(it!=b.end()&&val+(it->se)>=0)\n\t\t{\n\t\t\tval+=it->fi,++it;\n\t\t}\n\t\tif(val+a[i]<0) return 0;\n\t\tval+=a[i];\n\t}\n\treturn 1;\n}\nvoid Meyi()\n{\n\tn=read(),k=read();\n\tfor(int i=1; i<=n; ++i) a[i]=read();\n\t//to left\n\tif(chk()) \n\t{\n\t\tputs(\"YES\");\n\t\treturn ;\n\t}\n\treverse(a+1,a+n+1);k=n+1-k;\n\tif(chk()) \n\t{\n\t\tputs(\"YES\");\n\t\treturn ;\n\t}\n\tputs(\"NO\");\n\treturn ;\t\n}\nsigned main()\n{\n\tint miHoYo=read();\n\twhile(miHoYo--) Meyi();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Slime Escape.json",
    "editorial_link": "https://codeforces.com//blog/entry/107231",
    "editorial": "Let\u00e2\u0080\u0099s call a group of slime good if their total health is at least , or\r\nif defeating this group allows you to reach the exits. We partition the\r\nslimes into good groups in a two-pointer like manner. To form the groups\r\nto the right, start from position , then find the smallest position such\r\nthat slimes from through form a good group. We do the same starting from\r\nagain. Repeat this process until slimes to the right are partitioned\r\ninto groups, which can be done by maintaining the sum of health. We\r\npartition the left slimes into groups in a similar way. We can observe\r\nthat in an optimal strategy, we may assume the player absorbs\r\ngroup-by-group. ProofAssuming there is a valid strategy to reach the\r\nexit. Let be the first group to the left, and be the first group to the\r\nright. Without loss of generality, assume all slimes of are absorbed\r\nbefore all slimes of are absorbed first. Suppose there are slimes in and\r\nslimes in .Suppose we did not absorb all of at a time. For example, if\r\nthere are slimes in and or more slimes in , the beginning of our\r\nstrategy may look like this: Consider instead the strategy where we move\r\nall \u00e2\u0080\u0098L\u00e2\u0080\u0099 to the front. We claim that the strategy stays valid. That is,\r\nthe following strategy is at least as good.We check that at every moment\r\nof strategy , there is some point in time which we would have less than\r\nor equal amount of health.For the state that we take moves to the left\r\nin , we compare it with any moment in that we have taken moves to the\r\nleft. To reach , we take moves to the right. We can check that under the\r\nassumption, . Since is the smallest good group to the right, taking\r\nthese extra right moves must have reduced our health. So, we have more\r\nhealth at than in . Now consider the state in where we take all left\r\nmoves and more right moves. We should compare it with any moment in that\r\nwe have taken right moves and some left moves. We can check that under\r\nthe assumption . Since is the smallest good group, taking only moves to\r\nthe left gives us less health compared to taking all moves to the left.\r\nTherefore, we have more health at than in .Therefore, if is valid, must\r\nbe valid. So, we only need to consider strategies of the second form. By\r\napplying this claim recursively, we notice that we only need to consider\r\nstrategies that absorb whole groups at a time.This works for all\r\nstrategies, we just referred to the starting strategy as , and the\r\nbetter strategy as to simplify notations.\r\n"
}