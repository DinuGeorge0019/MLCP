{
    "link": "https://codeforces.com//contest/1638/problem/F",
    "problemId": "1297620",
    "problem_idx": "F",
    "shortId": "1638F",
    "contest_number": "1638",
    "problem_submissions": {
        "E": [
            146394309,
            146388037,
            146392264,
            146392799,
            146383148,
            146391230,
            146412303,
            146401025,
            146403078,
            146402136,
            179550421,
            146406748,
            146402980,
            146407733,
            146480267,
            146392395,
            146416198,
            146408751,
            146407567,
            146399245,
            146416242,
            146413814
        ],
        "D": [
            146373961,
            146380846,
            146385038,
            146375477,
            146392500,
            146381733,
            146401310,
            146378870,
            146384454,
            146387386,
            146387880,
            146390053,
            146382176,
            146480222,
            146406431,
            146388651,
            146388267,
            146392625,
            146412206,
            146374640,
            146389515
        ],
        "C": [
            146366299,
            146372352,
            146371729,
            146367670,
            146366106,
            146373666,
            146370507,
            146365761,
            146370642,
            146376834,
            146376510,
            146371594,
            146370051,
            146480186,
            146375503,
            146369319,
            146374946,
            146378437,
            146373206,
            146367076,
            146373277
        ],
        "B": [
            146362311,
            146363442,
            146362707,
            146365725,
            146364605,
            146363885,
            146366228,
            146383066,
            146364746,
            146368584,
            146368423,
            146367380,
            146366091,
            146480117,
            146369102,
            146364936,
            146367883,
            146370547,
            146366764,
            146364119,
            146368017
        ],
        "A": [
            146361810,
            146361860,
            146361937,
            146362725,
            146362534,
            146362379,
            146363944,
            146381318,
            146362119,
            146362820,
            146362493,
            146479991,
            146363108,
            146363259,
            146480100,
            146363531,
            146362617,
            146363968,
            146362163,
            146363256,
            146362105,
            146365613
        ],
        "F": [
            154464206,
            146479912,
            146613983,
            146474726,
            146640126
        ]
    },
    "name": "F. Two Posters",
    "statement": "You want to advertise your new business, so you are going to place two\r\nposters on a billboard in the city center. The billboard consists of n\r\nvertical panels of width 1 and varying integer heights, held together by\r\na horizontal bar. The i-th of the n panels has height h_i. Initially,\r\nall panels hang down from the bar (their top edges lie on it), but\r\nbefore placing the two posters, you are allowed to move each panel up by\r\nany integer length, as long as it is still connected to the bar (its\r\nbottom edge lies below or on it).After the moves are done, you will\r\nplace two posters: one below the bar and one above it. They are not\r\nallowed to go over the bar and they must be positioned completely inside\r\nof the panels.What is the maximum total area the two posters can cover\r\ntogether if you make the optimal moves?\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i, s, e) for (int i = s; i <= e; ++i)\n#define drep(i, s, e) for (int i = s; i >= e; --i)\n#define file(a) freopen(#a\".in\", \"r\", stdin), freopen(#a\".out\", \"w\", stdout)\n#define pv(a) cout << #a << \" = \" << a << endl\n#define pa(a, l, r) cout << #a \" : \"; rep(_, l, r) cout << a[_] << ' '; cout << endl\n\nconst int N = 1e4 + 10;\n\nint read() {\n  int x = 0, f = 1; char c = getchar();\n  for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = -1;\n  for (; c >= '0' && c <= '9'; c = getchar()) x = x * 10 + c - 48;\n  return x * f;\n}\n\nint n, a[N], L[N], R[N], pre[N], suf[N], st[N], top, ans;\n\nsigned main() {\n  n = read();\n  rep(i, 1, n) a[i] = read();\n  rep(i, 1, n) {\n    while (top && a[st[top]] > a[i]) R[st[top]] = i - 1, -- top;\n    st[++ top] = i;\n  }\n  while (top) R[st[top]] = n, -- top;\n  drep(i, n, 1) {\n    while (top && a[st[top]] > a[i]) L[st[top]] = i + 1, -- top;\n    st[++ top] = i;\n  }\n  while (top) L[st[top]] = 1, -- top;\n  rep(i, 1, n) {\n    rep(j, 1, i) pre[i] = max(pre[i], a[j] * (min(i, R[j]) - L[j] + 1));\n    rep(j, i, n) suf[i] = max(suf[i], a[j] * (R[j] - max(i, L[j]) + 1));\n  }\n  rep(i, 0, n) ans = max(ans, pre[i] + suf[i + 1]);\n  // pa(L, 1, n);\n  // pa(R, 1, n);\n  rep(t, 1, n) {\n    int l = L[t], r = R[t];\n    // cout << \"------- t, l, r = \" << t << ' ' << l << ' ' << r << endl;\n    rep(i, 1, n) {\n      if (l < L[i] || R[i] < r) continue;\n      ans = max(ans, a[i] * (R[i] - L[i] - (r - l)) + a[t] * (r - l + 1));\n    }\n    for (int i = 1, p = r + 1; i <= r; ++ i) {\n      if (l < L[i] || R[i] < r) continue;\n      // cout << \"i, L[i], R[i] = \" << i << ' ' << L[i] << ' ' << R[i] << endl;\n      for (; p <= n && a[i] + a[p] >= a[t]; ++ p) ;\n      ans = max(ans, a[i] * (r - L[i] + 1) + (a[t] - a[i]) * (p - l));\n      // cout << \"2 p, ans = \" << p << ' ' << ans << endl;\n    }\n    for (int i = n, p = l - 1; i >= l; -- i) {\n      if (l < L[i] || R[i] < r) continue;\n      for (; p && a[i] + a[p] >= a[t]; -- p) ;\n      ans = max(ans, a[i] * (R[i] - l + 1) + (a[t] - a[i]) * (r - p));\n      // cout << \"2 p, ans = \" << p << ' ' << ans << endl;\n    }\n    for (int i = r, q = n, mx = 0; i; -- i) {\n      if (l < L[i] || R[i] < r) continue;\n      // cout << \"i, L[i], R[i] = \" << i << ' ' << L[i] << ' ' << R[i] << endl;\n      for (; q > r && (r < L[q] || R[q] < l || a[i] + a[q] <= a[t]); -- q) {\n        if (L[q] <= l && r <= R[q]) mx = max(mx, a[q] * (R[q] - l + 1));\n      }\n      ans = max(ans, a[i] * (r - L[i] + 1) + mx);\n      // cout << \"3 q, mx, ans = \" << q << ' ' << mx << ' ' << ans << endl;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Two Posters.json",
    "editorial_link": "https://codeforces.com//blog/entry/99942",
    "editorial": "There are many ways in which two posters can be positioned, therefore,\r\nwe split the problem into multiple sub-problems. Consider the following\r\ncases. The two posters share no common panel. The two posters share a\r\nrange of common panels. Here, there are two sub-cases. The second poster\r\ndoes not share all its panels with the first. The second poster shares\r\nall its panels with the first. Letâs find the maximum total area for\r\neach of these cases. The answer will be the maximum over them.The\r\nimportant element to analyze in an optimal positioning of the two\r\nposters is the . This is the panel (or one of them) which is completely\r\ncovered by the posters and doesnât allow the area to be any larger.\r\nSince the two posters cover disjoint ranges of panels, there is a left\r\nposter and a right poster. Thus, we can choose a position somewhere\r\nbetween the two posters and move up to the maximum all panels to the\r\nleft of this position.So, a correct solution is to consider all possible\r\nsplit positions. For each of them, solve the standard skyline problem\r\nfor both left and right sides or, for an easier implementation, use a\r\ntrivial precomputation. Time complexity: . In the following two subcases\r\nwe will deal with pairs of posters that share some panels. So, letâs\r\nmake some observations before going any further.Consider the height of\r\nthe first poster (red) to be and the height of the second poster (blue)\r\nto be . Now, letâs find all panels such that . We will color these\r\npanels yellow and the rest of them gray. Because of the condition we\r\nimposed on the heights of yellow panels, they canât be shared by the two\r\nposters. On the other hand, gray panels can. Now we can make one more\r\nobservation. The range of common panels lies between two yellow panels.\r\nMoreover, since we try to maximize the total area and the two heights\r\nare fixed, the range of common panels is one of the maximal gray ranges.\r\nNow comes the tricky part. We canât iterate over all the maximal gray\r\nranges. There are such ranges for any and . And even worse, the two\r\nheights are up to . The problem is that we are looking from the wrong\r\nperspective. Instead of iterating and and then finding the yellow\r\npanels, letâs consider some possible maximal intersection range and then\r\nfind all pairs of and influenced by this range.Ok, but there are ranges\r\nto consider, right? Well, there are actually only .Let the smallest\r\npanel inside a maximal intersection range be its (if there are multiple,\r\ntake the leftmost one). Now consider some panel . For which maximal\r\nintesrection ranges is it the representative? Start with the range and\r\nextend to the left and to the right, while at least one of the bounding\r\npanels is larger or equal to . We are doing this because we search for\r\nintersection ranges, and this means that they are contained between two\r\nyellow panels of smaller size. Now we stopped at some range , where and\r\nfor any . Can we extend even more? No, we considered panel to be the\r\nrepresentative and thus, the smallest in the range, extending it any\r\nfurther would contradict this. We now have possible maximal intersection\r\nranges, each having a unique representative. Let the prefix of panels\r\nbefore the range be colored red and the suffix of panels after the range\r\nbe colored blue. Now, letâs look at the two remaining cases and solve\r\nthem. This means that the first poster covers all gray panels and some\r\nof the red ones, and the second poster covers all gray panels and some\r\nof the blue ones. Consider the following example. These are all the ways\r\ntwo posters can be positioned in this case. Some of them are marked as\r\nuseless because they can be transformed into better configurations. How\r\ndo we tell if a configuration is useful? Well, in a useful\r\nconfiguration, the two posters should meet one of the following two\r\nconditions. They touch (the representative panel being a bottleneck) and\r\none of them also has its own bottleneck. If none of them had its own\r\nbottleneck, it would be possible to stretch the wider one, while\r\nshrinking the other, in order to increase the total area. This way, a\r\nbottleneck could be formed in a better configuration. Each of them has\r\nits own bottleneck. So, letâs sum up. First, we choose a representative\r\npanel. Then, we find the range it represents. Next, solve each of the\r\nabove cases separately. Some prefix/suffix precomputation and two\r\npointers algorithm should be enough.Time complexity: . This means that\r\nthe second poster covers all gray panels and the first poster covers all\r\ngray panels, some of the red ones and some of the blue ones (here, we\r\nwill replace blue and red with pink). Consider the following example.\r\nThis is obviously the simple subcase of the two. We only need to keep\r\ntrack on the left and right pink panels while we gradually decrease the\r\nheight of the second poster. We will use the two pointers algorithm\r\nagain.Note that the blue poster should touch the end of the\r\nrepresentative panel. You might argue that braking this restriction\r\ncould result in a larger total area, but donât forget that we will\r\nhandle those cases using other representative panels and their\r\nrespective gray ranges.Time complexity: .\r\n",
    "hint": [
        "Hint 1 Consider the ranges of panels covered by the two posters. Split the problem into multiple cases according to how these intervals are positioned relative to eachother. Throughout the solution, consider the concept of \"bottlenecks\". These are panels that stop the area to be any larger.",
        "Hint 2 First case: the ranges are disjoint. How do you solve this?",
        "Hint 3 Now, for the other cases, make some observations when the posters share some common range of pannels. Consider the heights to be fixed and group panels into two different types.",
        "Hint 4 There are panels that could fit both (let them be grey) and panels that could fit only one (let them be yellow). The shared range of pannels is between two consecutive yellow panels. Moreover, it is bounded by yellow panels in an optimal solution.",
        "Hint 5 Now, consider the heights of the two posters to not be fixed anymore. How many possible maximal ranges of shared panels can there be? They seem to be , but maybe there are less.",
        "Hint 6 Let the shortest panel inside a maximal shared range to be its \"representative panel\". Starting from such a panel, what ranges does it represent?",
        "Hint 7 It can be proven that the only possible range is the one between the closest shorter panels to the left and right. Now you are able to consider all possible shared ranges because there are . You can split further into two cases and solve them using two-pointers and possibly some precomputations."
    ]
}