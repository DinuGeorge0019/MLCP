{"link": "https://codeforces.com//contest/387/problem/E", "problemId": "6210", "problem_idx": "E", "shortId": "387E", "contest_number": "387", "problem_submissions": {"C": [27999099, 5844874, 5841061, 5847589, 5843566, 5843851, 5849910, 5846186, 5847507, 5847850, 5846546, 5848509, 5848776, 5843425, 5843791, 5843206, 5842568, 5843393], "B": [27998713, 5840894, 5845641, 5840512, 5841082, 5840804, 5840526, 5841204, 5841355, 5848318, 5840963, 5842246, 5843788, 5839620, 5840413, 5840368, 5840193, 5840883], "A": [27997874, 5839643, 5839445, 5839653, 5839813, 5839532, 5840047, 5839968, 5848701, 5839527, 5840349, 5840457, 5839510, 5839440, 5839451, 5839441, 5839465], "E": [5844573, 5844315, 5853477, 5849230, 5849007, 5850779, 5846373, 5849357, 5848789, 5849640, 5846140, 5851142, 5849993, 5849270, 5851283, 5851268, 5851181, 5850678], "D": [5843391, 5847525, 5847251, 5847489, 5848775, 5866620, 5866616]}, "name": "E. George and Cards", "statement": "George is a cat, so he loves playing very much.Vitaly put cards in a row\r\nin front of George. Each card has one integer written on it. All cards\r\nhad distinct numbers written on them. Let\u2019s number the cards from the\r\nleft to the right with integers from to . Then the -th card from the\r\nleft contains number (). Vitaly wants the row to have exactly cards\r\nleft. He also wants the -th card from left to have number written on it.\r\nVitaly gave a task to George, to get the required sequence of cards\r\nusing the remove operation times.In one George can choose (; is not\r\ngreater than the current number of cards in the row) contiguous cards\r\n(contiguous subsegment of cards). Let\u2019s denote the numbers written on\r\nthese card as (from the left to the right). After that, George can\r\nremove the card , such that for each . After the described operation\r\nGeorge gets pieces of sausage.George wondered: what maximum number of\r\npieces of sausage will he get in total if he reaches his goal and acts\r\noptimally well? Help George, find an answer to his question!\r\n", "solutions": ["#include <algorithm>\n#include <stdio.h>\n#include <memory.h>\n#include <ctype.h>\n\nusing namespace std;\n\ntypedef long long INT;\ntypedef pair<int, int> pii;\n\n#define NN 1100000\n\nint N;\nint t1[NN], t2[NN], t[NN];\nint p[NN], pos[NN], pre[NN], nxt[NN];\nint fix[NN];\n\nvoid update1(int u, int val) {\n\twhile (u<=N) {\n\t\tt1[u]=max(t1[u], val);\n\t\tu+=u&-u;\n\t}\n}\n\nint calc1(int u) {\n\tint res=0;\n\twhile (u) {\n\t\tres=max(res, t1[u]);\n\t\tu-=u&-u;\n\t}\n\treturn res;\n}\n\nvoid update2(int u, int val) {\n\twhile (u<=N) {\n\t\tt2[u]=min(t2[u], val);\n\t\tu+=u&-u;\n\t}\n}\n\nint calc2(int u) {\n\tint res=N+1;\n\twhile (u) {\n\t\tres=min(res, t2[u]);\n\t\tu-=u&-u;\n\t}\n\treturn res;\n}\n\nint calc(int u) {\n\tint res=0;\n\twhile (u) {\n\t\tres+=t[u];\n\t\tu-=u&-u;\n\t}\n\treturn res;\n}\n\nvoid update(int u, int val) {\n\twhile (u<=N) {\n\t\tt[u]+=val;\n\t\tu+=u&-u;\n\t}\n}\n\nint main() {\n\tint K, i, j, b;\n\tINT ans;\n\t\n\tscanf(\"%d%d\", &N, &K);\n\tfor (i=0; i<N; i++) scanf(\"%d\", &p[i]);\n\tfor (i=0; i<K; i++) {\n\t\tscanf(\"%d\", &b);\n\t\tfix[b]=1;\n\t}\n\t\n\tfor (i=0; i<N; i++) pos[p[i]]=i;\n\t\n\tfor (i=0; i<N; i++) {\n\t\tif (fix[p[i]]) {\n\t\t\tupdate1(p[i], i+1);\n\t\t} else {\n\t\t\tpre[i]=calc1(p[i]);\n\t\t}\n\t}\n\t\n\tfor (i=0; i<=N; i++) t2[i]=N+1;\n\t\n\tfor (i=N-1; i>=0; i--) {\n\t\tif (fix[p[i]]) {\n\t\t\tupdate2(p[i], i+1);\n\t\t} else {\n\t\t\tnxt[i]=calc2(p[i])-1;\n\t\t}\n\t}\n\t\n\tfor (i=1; i<=N; i++) {\n\t\tt[i]=(1<<__builtin_ctz(i));\n\t}\n\tans=0;\n\tfor (j=1; j<=N; j++) {\n\t\tif (fix[j]) continue;\n\t\ti=pos[j];\n\t\tans+=calc(nxt[i])-calc(pre[i]);\n\t\tupdate(i+1, -1);\n\t}\n\t\n\tprintf(\"%I64d\\n\", ans);\n\t\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["binary search", "data structures"], "dificulty": "2200", "interactive": false}