{"link": "https://codeforces.com//contest/959/problem/C", "problemId": "170880", "problem_idx": "C", "shortId": "959C", "contest_number": "959", "problem_submissions": {"F": [36922958, 36921545, 36916491, 36923329, 36927067, 36929072, 36922529, 36949027, 36923867], "D": [36916641, 36918902, 36913950, 36921936, 36920649, 36922086, 36938795, 36921202, 36919547, 36921230, 36920592, 36944605, 36921671, 36921791, 36916069, 36920555, 36925905, 36924207, 36923247], "E": [36914501, 36913015, 36925858, 36917118, 36923111, 36917652, 36920424, 36917502, 36915031, 36915660, 36915376, 36919671, 36917632, 36917697, 36920779, 36924711, 36918716, 36918302, 36918515], "C": [36911904, 36911030, 36920972, 36913089, 36913595, 36913140, 36914345, 36913057, 36911886, 36913682, 36913398, 36917432, 36913393, 36914727, 36913492, 36914481, 36914594, 36913357, 36914333], "B": [36910571, 36909536, 36910083, 36911621, 36910450, 36910777, 36911891, 36911461, 36909624, 36911118, 36910588, 36915553, 36910516, 36911975, 36910706, 36910209, 36911346, 36910873, 36911805], "A": [36909207, 36907273, 36907351, 36907609, 36907481, 36907506, 36907642, 36908528, 36907595, 36907279, 36907604, 36911260, 36907582, 36908413, 36907465, 36907398, 36907769, 36907688, 36907674]}, "name": "C. Mahmoud and Ehab and the wrong algorithm", "statement": "Mahmoud was trying to solve the vertex cover problem on trees. The\r\nproblem statement is:Given an undirected tree consisting of nodes, find\r\nthe minimum number of vertices that cover all the edges. Formally, we\r\nneed to find a set of vertices such that for each edge that belongs to\r\nthe tree, either is in the set, or is in the set, . Mahmoud has found\r\nthe following algorithm: Root the tree at node . Count the number of\r\nnodes at an even depth. Let it be . Count the number of nodes at an odd\r\ndepth. Let it be . The answer is the minimum between and . The depth of\r\na node in a tree is the number of edges in the shortest path between\r\nthis node and the root. The depth of the root is 0.Ehab told Mahmoud\r\nthat this algorithm is wrong, but he didn\u2019t believe because he had\r\ntested his algorithm against many trees and it worked, so Ehab asked you\r\nto find 2 trees consisting of nodes. The algorithm should find an\r\nincorrect answer for the first tree and a correct answer for the second\r\none.\r\n", "solutions": ["#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tif (n < 6)\n\t\tcout << \"-1\\n\";\n\telse{\n\t\tcout << \"1 2\\n\";\n\t\tint t = (n-2)/2;\n\t\tfor (int i = 3; i < 3+t; i++)\n\t\t\tcout << \"1 \" << i << \"\\n\";\n\t\tint temp = 3+t;\n\t\tt = (n-1)/2;\n\t\tfor (int i = temp; i < temp + t; i++)\n\t\t\tcout << \"2 \" << i << \"\\n\";\n\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tcout << i-1 << \" \" << i << \"\\n\";\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "trees"], "dificulty": "1500", "interactive": false}